<!DOCTYPE html><html lang="en"><head><title>Help for package nimble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nimble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nimble-package'><p>nimble: MCMC, Particle Filtering, and Programmable Hierarchical Modeling</p></a></li>
<li><a href='#ADbreak'><p>NIMBLE language function to break tracking of derivatives</p></a></li>
<li><a href='#ADNimbleList'><p>Data type for the return value of <code>nimDerivs</code></p></a></li>
<li><a href='#ADproxyModelClass-class'><p>create an ADproxyModelClass object</p></a></li>
<li><a href='#any_na'><p>Determine if any values in a vector are NA or NaN</p></a></li>
<li><a href='#as.carAdjacency'><p>Convert CAR structural parameters to adjacency, weights, num format</p></a></li>
<li><a href='#as.carCM'><p>Convert weights vector to parameters of <code>dcar_proper</code> distributio</p></a></li>
<li><a href='#asRow'><p>Turn a numeric vector into a single-row or single-column matrix</p></a></li>
<li><a href='#autoBlock'><p>Automated parameter blocking procedure for efficient MCMC sampling</p></a></li>
<li><a href='#BUGSdeclClass-class'><p>BUGSdeclClass contains the information extracted from one BUGS declaration</p></a></li>
<li><a href='#buildAGHQGrid'><p>Build Adaptive Gauss-Hermite Quadrature Grid</p></a></li>
<li><a href='#buildAuxiliaryFilter'><p>Placeholder for buildAuxiliaryFilter</p></a></li>
<li><a href='#buildBootstrapFilter'><p>Placeholder for buildBootstrapFilter</p></a></li>
<li><a href='#buildEnsembleKF'><p>Placeholder for buildEnsembleKF</p></a></li>
<li><a href='#buildIteratedFilter2'><p>Placeholder for buildIteratedFilter2</p></a></li>
<li><a href='#buildLaplace'><p>Laplace approximation and adaptive Gauss-Hermite quadrature</p></a></li>
<li><a href='#buildLiuWestFilter'><p>Placeholder for buildLiuWestFilter</p></a></li>
<li><a href='#buildMacro'><p>EXPERIMENTAL: Turn a function into a model macro</p></a></li>
<li><a href='#buildMCEM'><p>Builds an MCEM algorithm for a given NIMBLE model</p></a></li>
<li><a href='#buildMCMC'><p>Create an MCMC object from a NIMBLE model, or an MCMC configuration object</p></a></li>
<li><a href='#calculateWAIC'><p>Calculating WAIC using an offline algorithm</p></a></li>
<li><a href='#CAR_calcNumIslands'><p>Calculate number of islands based on a CAR adjacency matrix.</p></a></li>
<li><a href='#CAR-Normal'><p>The CAR-Normal Distribution</p></a></li>
<li><a href='#CAR-Proper'><p>The CAR-Proper Distribution</p></a></li>
<li><a href='#carBounds'><p>Calculate bounds for the autocorrelation parameter of the <code>dcar_proper</code> distribution</p></a></li>
<li><a href='#carMaxBound'><p>Calculate the upper bound for the autocorrelation parameter of the <code>dcar_proper</code> distribution</p></a></li>
<li><a href='#carMinBound'><p>Calculate the lower bound for the autocorrelation parameter of the <code>dcar_proper</code> distribution</p></a></li>
<li><a href='#Categorical'><p>The Categorical Distribution</p></a></li>
<li><a href='#checkInterrupt'><p>Check for interrupt (e.g. Ctrl-C) during nimbleFunction execution. Part of the NIMBLE language.</p></a></li>
<li><a href='#ChineseRestaurantProcess'><p>The Chinese Restaurant Process Distribution</p></a></li>
<li><a href='#clearCompiled'><p>Clear compiled objects from a project and unload shared library</p></a></li>
<li><a href='#CmodelBaseClass-class'><p>Class <code>CmodelBaseClass</code></p></a></li>
<li><a href='#CnimbleFunctionBase-class'><p>Class <code>CnimbleFunctionBase</code></p></a></li>
<li><a href='#codeBlockClass-class'><p>Class <code>codeBlockClass</code></p></a></li>
<li><a href='#compileNimble'><p>compile NIMBLE models and nimbleFunctions</p></a></li>
<li><a href='#configureMCMC'><p>Build the MCMCconf object for construction of an MCMC object</p></a></li>
<li><a href='#configureRJ'><p>Configure Reversible Jump for Variable Selection</p></a></li>
<li><a href='#Constraint'><p>Constraint calculations in NIMBLE</p></a></li>
<li><a href='#decide'><p>Makes the Metropolis-Hastings acceptance decision, based upon the input (log) Metropolis-Hastings ratio</p></a></li>
<li><a href='#decideAndJump'><p>Creates a nimbleFunction for executing the Metropolis-Hastings jumping decision,</p>
and updating values in the model, or in a carbon copy modelValues object, accordingly.</a></li>
<li><a href='#declare'><p>Explicitly declare a variable in run-time code of a nimbleFunction</p></a></li>
<li><a href='#deregisterDistributions'><p>Remove user-supplied distributions from use in NIMBLE BUGS models</p></a></li>
<li><a href='#Dirichlet'><p>The Dirichlet Distribution</p></a></li>
<li><a href='#distributionInfo'><p>Get information about a distribution</p></a></li>
<li><a href='#Double-Exponential'><p>The Double Exponential (Laplace) Distribution</p></a></li>
<li><a href='#eigenNimbleList'><p>eigenNimbleList definition</p></a></li>
<li><a href='#Exponential'><p>The Exponential Distribution</p></a></li>
<li><a href='#extractControlElement'><p>Extract named elements from MCMC sampler control list</p></a></li>
<li><a href='#flat'><p>The Improper Uniform Distribution</p></a></li>
<li><a href='#getBound'><p>Get value of bound of a stochastic node in a model</p></a></li>
<li><a href='#getBUGSexampleDir'><p>Get the directory path to one of the classic BUGS examples installed with NIMBLE package</p></a></li>
<li><a href='#getConditionallyIndependentSets'><p>Get a list of conditionally independent sets of nodes in a nimble model</p></a></li>
<li><a href='#getDefinition'><p>Get nimbleFunction definition</p></a></li>
<li><a href='#getMacroParameters'><p>EXPERIMENTAL: Get list of parameter names generated by model macros</p></a></li>
<li><a href='#getNimbleOption'><p>Get NIMBLE Option</p></a></li>
<li><a href='#getParam'><p>Get value of a parameter of a stochastic node in a model</p></a></li>
<li><a href='#getSamplesDPmeasure'><p>Get posterior samples for a Dirichlet process measure</p></a></li>
<li><a href='#getsize'><p>Returns number of rows of modelValues</p></a></li>
<li><a href='#identityMatrix'><p>Create an Identity matrix (Deprecated)</p></a></li>
<li><a href='#initializeModel'><p>Performs initialization of nimble model node values and log probabilities</p></a></li>
<li><a href='#Interval'><p>Interval calculations</p></a></li>
<li><a href='#Inverse-Gamma'><p>The Inverse Gamma Distribution</p></a></li>
<li><a href='#Inverse-Wishart'><p>The Inverse Wishart Distribution</p></a></li>
<li><a href='#is.nf'><p>check if a nimbleFunction</p></a></li>
<li><a href='#is.nl'><p>check if a nimbleList</p></a></li>
<li><a href='#LKJ'><p>The LKJ Distribution for the Cholesky Factor of a Correlation Matrix</p></a></li>
<li><a href='#makeBoundInfo'><p>Make an object of information about a model-bound pairing for getBound.  Used internally</p></a></li>
<li><a href='#makeModelDerivsInfo'><p>Information on model structure used for derivatives</p></a></li>
<li><a href='#makeParamInfo'><p>Make an object of information about a model-parameter pairing for getParam.  Used internally</p></a></li>
<li><a href='#MCMCconf-class'><p>Class <code>MCMCconf</code></p></a></li>
<li><a href='#modelBaseClass-class'><p>Class <code>modelBaseClass</code></p></a></li>
<li><a href='#modelDefClass-class'><p>Class for NIMBLE model definition</p></a></li>
<li><a href='#modelInitialization'><p>Information on initial values in a NIMBLE model</p></a></li>
<li><a href='#modelValues'><p>Create a NIMBLE modelValues Object</p></a></li>
<li><a href='#modelValuesBaseClass-class'><p>Class <code>modelValuesBaseClass</code></p></a></li>
<li><a href='#modelValuesConf'><p>Create the confs for a custom NIMBLE modelValues object</p></a></li>
<li><a href='#Multinomial'><p>The Multinomial Distribution</p></a></li>
<li><a href='#Multivariate-t'><p>The Multivariate t Distribution</p></a></li>
<li><a href='#MultivariateNormal'><p>The Multivariate Normal Distribution</p></a></li>
<li><a href='#nfMethod'><p>access (call) a member function of a nimbleFunction</p></a></li>
<li><a href='#nfVar'><p>Access or set a member variable of a nimbleFunction</p></a></li>
<li><a href='#nimble-internal'><p>Functions and Classes Internal to NIMBLE</p></a></li>
<li><a href='#nimble-math'><p>Mathematical functions for BUGS and nimbleFunction programming</p></a></li>
<li><a href='#nimble-R-functions'><p>NIMBLE language functions for R-like vector construction</p></a></li>
<li><a href='#nimbleCode'><p>Turn BUGS model code into an object for use in <code>nimbleModel</code> or <code>readBUGSmodel</code></p></a></li>
<li><a href='#nimbleExternalCall'><p>Create a nimbleFunction that wraps a call to external compiled code</p></a></li>
<li><a href='#nimbleFunction'><p>create a nimbleFunction</p></a></li>
<li><a href='#nimbleFunctionBase-class'><p>Class <code>nimbleFunctionBase</code></p></a></li>
<li><a href='#nimbleFunctionList-class'><p>Create a list of nimbleFunctions</p></a></li>
<li><a href='#nimbleFunctionVirtual'><p>create a virtual nimbleFunction, a base class for other nimbleFunctions</p></a></li>
<li><a href='#nimbleList'><p>create a nimbleList</p></a></li>
<li><a href='#nimbleMCMC'><p>Executes one or more chains of NIMBLE's default MCMC algorithm, for a model specified using BUGS code</p></a></li>
<li><a href='#nimbleModel'><p>Create a NIMBLE model from BUGS code</p></a></li>
<li><a href='#nimbleOptions'><p>NIMBLE Options Settings</p></a></li>
<li><a href='#nimbleRcall'><p>Make an R function callable from compiled nimbleFunctions (including nimbleModels).</p></a></li>
<li><a href='#nimbleType-class'><p>create a nimbleType object</p></a></li>
<li><a href='#nimCat'><p>cat function for use in nimbleFunctions</p></a></li>
<li><a href='#nimCopy'><p>Copying function for NIMBLE</p></a></li>
<li><a href='#nimDerivs'><p>Nimble Derivatives</p></a></li>
<li><a href='#nimDim'><p>return sizes of an object whether it is a vector, matrix or array</p></a></li>
<li><a href='#nimEigen'><p>Spectral Decomposition of a Matrix</p></a></li>
<li><a href='#nimIntegrate'><p>Integration of One-Dimensional Functions</p></a></li>
<li><a href='#nimMatrix'><p>Creates matrix or array objects for use in nimbleFunctions</p></a></li>
<li><a href='#nimNumeric'><p>Creates numeric, integer or logical vectors for use in nimbleFunctions</p></a></li>
<li><a href='#nimOptim'><p>General-purpose Optimization</p></a></li>
<li><a href='#nimOptimDefaultControl'><p>Creates a default <code>control</code> argument for <code>nimOptim</code>.</p></a></li>
<li><a href='#nimOptimMethod'><p>Set or get an optimization function to be used by <code>nimOptim</code></p></a></li>
<li><a href='#nimPrint'><p>print function for use in nimbleFunctions</p></a></li>
<li><a href='#nimStop'><p>Halt execution of a nimbleFunction function method.  Part of the NIMBLE language</p></a></li>
<li><a href='#nimSvd'><p>Singular Value Decomposition of a Matrix</p></a></li>
<li><a href='#nodeFunctions'><p>calculate, calculateDiff, simulate, or get the current log probabilities (densities) a set of nodes in a NIMBLE model</p></a></li>
<li><a href='#optimControlNimbleList'><p>Data type for the <code>control</code> parameter of <code>nimOptim</code></p></a></li>
<li><a href='#optimDefaultControl'><p>Creates a deafult <code>control</code> argument for <code>optim</code> (just an empty list).</p></a></li>
<li><a href='#optimResultNimbleList'><p>Data type for the return value of <code>nimOptim</code></p></a></li>
<li><a href='#parameterTransform'><p>Automated transformations of model nodes to unconstrained scales</p></a></li>
<li><a href='#pow_int'><p>Power function for integer-valued exponent</p></a></li>
<li><a href='#printErrors'><p>Print error messages after failed compilation</p></a></li>
<li><a href='#rankSample'><p>Generates a weighted sample (with replacement) of ranks</p></a></li>
<li><a href='#readBUGSmodel'><p>Create a NIMBLE BUGS model from a variety of input formats, including BUGS model files</p></a></li>
<li><a href='#registerDistributions'><p>Add user-supplied distributions for use in NIMBLE BUGS models</p></a></li>
<li><a href='#resize'><p>Resizes a modelValues object</p></a></li>
<li><a href='#Rmatrix2mvOneVar'><p>Set values of one variable of a modelValues object from an R matrix</p></a></li>
<li><a href='#RmodelBaseClass-class'><p>Class <code>RmodelBaseClass</code></p></a></li>
<li><a href='#run.time'><p>Time execution of NIMBLE code</p></a></li>
<li><a href='#runCrossValidate'><p>Perform k-fold cross-validation on a NIMBLE model fit by MCMC</p></a></li>
<li><a href='#runLaplace'><p>Combine steps of running Laplace or adaptive Gauss-Hermite quadrature approximation</p></a></li>
<li><a href='#runMCMC'><p>Run one or more chains of an MCMC algorithm and return samples, summary and/or WAIC</p></a></li>
<li><a href='#sampler_BASE'><p>MCMC Sampling Algorithms</p></a></li>
<li><a href='#setAndCalculate'><p>Creates a nimbleFunction for setting the values of one or more model nodes,</p>
calculating the associated deterministic dependents and logProb values,
and returning the total sum log-probability.</a></li>
<li><a href='#setAndCalculateOne'><p>Creates a nimbleFunction for setting the value of a scalar model node,</p>
calculating the associated deterministic dependents and logProb values,
and returning the total sum log-probability.</a></li>
<li><a href='#setSize'><p>set the size of a numeric variable in NIMBLE</p></a></li>
<li><a href='#setupMargNodes'><p>Organize model nodes for marginalization</p></a></li>
<li><a href='#setupOutputs'><p>Explicitly declare objects created in setup code to be preserved and compiled as member data</p></a></li>
<li><a href='#simNodes'><p>Basic nimbleFunctions for calculate, simulate, and getLogProb with a set of nodes</p></a></li>
<li><a href='#simNodesMV'><p>Basic nimbleFunctions for using a NIMBLE model with sets of stored values</p></a></li>
<li><a href='#singleVarAccessClass-class'><p>Class <code>singleVarAccessClass</code></p></a></li>
<li><a href='#StickBreakingFunction'><p>The Stick Breaking Function</p></a></li>
<li><a href='#summaryLaplace'><p>Summarize results from Laplace or adaptive Gauss-Hermite quadrature approximation</p></a></li>
<li><a href='#svdNimbleList'><p>svdNimbleList definition</p></a></li>
<li><a href='#t'><p>The t Distribution</p></a></li>
<li><a href='#testBUGSmodel'><p>Tests BUGS examples in the NIMBLE system</p></a></li>
<li><a href='#valueInCompiledNimbleFunction'><p>get or set value of member data from a compiled nimbleFunction using a multi-interface</p></a></li>
<li><a href='#values'><p>Access or set values for a set of nodes in a model</p></a></li>
<li><a href='#waic'><p>Using WAIC</p></a></li>
<li><a href='#waicDetailsNimbleList'><p>waicDetailsNimbleList definition</p></a></li>
<li><a href='#waicNimbleList'><p>waicNimbleList definition</p></a></li>
<li><a href='#Wishart'><p>The Wishart Distribution</p></a></li>
<li><a href='#withNimbleOptions'><p>Temporarily set some NIMBLE options.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>MCMC, Particle Filtering, and Programmable Hierarchical Modeling</td>
</tr>
<tr>
<td>Description:</td>
<td>A system for writing hierarchical statistical models largely
    compatible with 'BUGS' and 'JAGS', writing nimbleFunctions to operate models
    and do basic R-style math, and compiling both models and nimbleFunctions via
    custom-generated C++. 'NIMBLE' includes default methods for MCMC, Laplace
    Approximation, Monte Carlo Expectation Maximization, and some other tools.
    The nimbleFunction system makes it easy to do things like implement new MCMC
    samplers from R, customize the assignment of samplers to different parts of
    a model from R, and compile the new samplers automatically via C++ alongside
    the samplers 'NIMBLE' provides. 'NIMBLE' extends the 'BUGS'/'JAGS' language
    by making it extensible: New distributions and functions can be added,
    including as calls to external compiled code. Although most people think
    of MCMC as the main goal of the 'BUGS'/'JAGS' language for writing models,
    one can use 'NIMBLE' for writing arbitrary other kinds of model-generic
    algorithms as well. A full User Manual is available at <a href="https://r-nimble.org">https://r-nimble.org</a>.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Paciorek &lt;paciorek@stat.berkeley.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods,igraph,coda,R6,pracma,numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat,mcmcse,nloptr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-nimble.org">https://r-nimble.org</a>, <a href="https://github.com/nimble-dev/nimble">https://github.com/nimble-dev/nimble</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nimble-dev/nimble/issues">https://github.com/nimble-dev/nimble/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: BSD_3_clause + file LICENSE | GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See COPYRIGHTS file.</td>
</tr>
<tr>
<td>Note:</td>
<td>For convenience, the package includes the necessary header files
for the Eigen distribution. (This is all that is needed to use
that functionality.) You can use an alternative installation of
Eigen on your system or the one we provide. The license for the
Eigen code is very permissive and allows us to distribute it
with this package. See &lt;http://eigen.tuxfamily.org/index.php?
title=Main_Page&gt; and also the License section on that page.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>config.R all_utils.R options.R distributions_inputList.R
distributions_processInputList.R
distributions_implementations.R BUGS_BUGSdecl.R BUGS_contexts.R
BUGS_nimbleGraph.R BUGS_modelDef.R BUGS_model.R
BUGS_graphNodeMaps.R BUGS_readBUGS.R BUGS_macros.R
BUGS_testBUGS.R BUGS_getDependencies.R BUGS_utils.R
BUGS_mathCompatibility.R externalCalls.R genCpp_exprClass.R
genCpp_operatorLists.R genCpp_RparseTree2exprClasses.R
genCpp_initSizes.R genCpp_buildIntermediates.R
genCpp_processSpecificCalls.R genCpp_sizeProcessing.R
genCpp_toEigenize.R genCpp_insertAssertions.R genCpp_maps.R
genCpp_liftMaps.R genCpp_eigenization.R genCpp_addDebugMarks.R
genCpp_generateCpp.R RCfunction_core.R RCfunction_compile.R
nimbleFunction_util.R nimbleFunction_core.R
nimbleFunction_nodeFunction.R nimbleFunction_nodeFunctionNew.R
nimbleFunction_Rderivs.R nimbleFunction_Rexecution.R
nimbleFunction_compile.R nimbleFunction_keywordProcessing.R
nimbleList_core.R types_util.R types_symbolTable.R
types_modelValues.R types_modelValuesAccessor.R
types_modelVariableAccessor.R types_nimbleFunctionList.R
types_nodeFxnVector.R types_numericLists.R cppDefs_utils.R
cppDefs_variables.R cppDefs_core.R cppDefs_namedObjects.R
cppDefs_ADtools.R cppDefs_BUGSmodel.R cppDefs_RCfunction.R
cppDefs_nimbleFunction.R cppDefs_nimbleList.R
cppDefs_modelValues.R cppDefs_cppProject.R
cppDefs_outputCppFromRparseTree.R cppInterfaces_utils.R
cppInterfaces_models.R cppInterfaces_modelValues.R
cppInterfaces_nimbleFunctions.R cppInterfaces_otherTypes.R
nimbleProject.R initializeModel.R parameterTransform.R CAR.R
Laplace.R MCMC_utils.R MCMC_configuration.R MCMC_build.R
MCMC_run.R MCMC_samplers.R MCMC_conjugacy.R MCMC_autoBlock.R
MCMC_RJ.R MCMC_WAIC.R MCEM_build.R crossValidation.R
BNP_distributions.R BNP_samplers.R NF_utils.R miscFunctions.R
makevars.R setNimbleInternalFunctions.R registration.R
nimble-package.r QuadratureGrids.R zzz.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-17 17:45:07 UTC; paciorek</td>
</tr>
<tr>
<td>Author:</td>
<td>Perry de Valpine [aut],
  Christopher Paciorek [aut, cre],
  Daniel Turek [aut],
  Nick Michaud [aut],
  Cliff Anderson-Bergman [aut],
  Fritz Obermeyer [aut],
  Claudia Wehrhahn Cortes [aut] (Bayesian nonparametrics system),
  Abel Rodríguez [aut] (Bayesian nonparametrics system),
  Duncan Temple Lang [aut] (packaging configuration),
  Wei Zhang [aut] (Laplace approximation),
  Sally Paganin [aut] (reversible jump MCMC),
  Joshua Hug [aut] (WAIC),
  Paul van Dam-Bates [aut] (AGHQ approximation, Pólya-Gamma sampler,
    nimIntegrate),
  Jagadish Babu [ctb] (code for the compilation system for an early
    version of NIMBLE),
  Lauren Ponisio [ctb] (contributions to the cross-validation code),
  Peter Sujan [ctb] (multivariate t distribution code)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-17 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nimble-package'>nimble: MCMC, Particle Filtering, and Programmable Hierarchical Modeling</h2><span id='topic+nimble'></span><span id='topic+nimble-package'></span>

<h3>Description</h3>

<p>A system for writing hierarchical statistical models largely compatible with 'BUGS' and 'JAGS', writing nimbleFunctions to operate models and do basic R-style math, and compiling both models and nimbleFunctions via custom-generated C++. 'NIMBLE' includes default methods for MCMC, Laplace Approximation, Monte Carlo Expectation Maximization, and some other tools. The nimbleFunction system makes it easy to do things like implement new MCMC samplers from R, customize the assignment of samplers to different parts of a model from R, and compile the new samplers automatically via C++ alongside the samplers 'NIMBLE' provides. 'NIMBLE' extends the 'BUGS'/'JAGS' language by making it extensible: New distributions and functions can be added, including as calls to external compiled code. Although most people think of MCMC as the main goal of the 'BUGS'/'JAGS' language for writing models, one can use 'NIMBLE' for writing arbitrary other kinds of model-generic algorithms as well. A full User Manual is available at <a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Christopher Paciorek <a href="mailto:paciorek@stat.berkeley.edu">paciorek@stat.berkeley.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Perry de Valpine
</p>
</li>
<li><p> Daniel Turek
</p>
</li>
<li><p> Nick Michaud
</p>
</li>
<li><p> Cliff Anderson-Bergman
</p>
</li>
<li><p> Fritz Obermeyer
</p>
</li>
<li><p> Claudia Wehrhahn Cortes (Bayesian nonparametrics system)
</p>
</li>
<li><p> Abel Rodríguez (Bayesian nonparametrics system)
</p>
</li>
<li><p> Duncan Temple Lang (packaging configuration)
</p>
</li>
<li><p> Wei Zhang (Laplace approximation)
</p>
</li>
<li><p> Sally Paganin (reversible jump MCMC)
</p>
</li>
<li><p> Joshua Hug (WAIC)
</p>
</li>
<li><p> Paul van Dam-Bates (AGHQ approximation, Pólya-Gamma sampler, nimIntegrate)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Jagadish Babu (code for the compilation system for an early version of NIMBLE) [contributor]
</p>
</li>
<li><p> Lauren Ponisio (contributions to the cross-validation code) [contributor]
</p>
</li>
<li><p> Peter Sujan (multivariate t distribution code) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-nimble.org">https://r-nimble.org</a>
</p>
</li>
<li> <p><a href="https://github.com/nimble-dev/nimble">https://github.com/nimble-dev/nimble</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nimble-dev/nimble/issues">https://github.com/nimble-dev/nimble/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ADbreak'>NIMBLE language function to break tracking of derivatives</h2><span id='topic+ADbreak'></span>

<h3>Description</h3>

<p>This function is used in a method of a nimbleFunction that has derivatives enabled.  It returns its value but breaks tracking of derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADbreak(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ADbreak_+3A_x">x</code></td>
<td>
<p>scalar value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This funcion only works with scalars.
</p>

<hr>
<h2 id='ADNimbleList'>Data type for the return value of <code><a href="#topic+nimDerivs">nimDerivs</a></code></h2><span id='topic+ADNimbleList'></span>

<h3>Description</h3>

<p><code><a href="#topic+nimbleList">nimbleList</a></code> definition for the type of <code><a href="#topic+nimbleList">nimbleList</a></code> returned by <code><a href="#topic+nimDerivs">nimDerivs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADNimbleList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Fields</h3>


<dl>
<dt><code>value</code></dt><dd><p>The value of the function evaluated at the given input arguments.</p>
</dd>
<dt><code>jacobian</code></dt><dd><p>The Jacobian of the function evaluated at the given input arguments.</p>
</dd>
<dt><code>hessian</code></dt><dd><p>The Hessian of the function evaluated at the given input arguments.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+nimDerivs">nimDerivs</a></code>
</p>

<hr>
<h2 id='ADproxyModelClass-class'>create an ADproxyModelClass object</h2><span id='topic+ADproxyModelClass-class'></span><span id='topic+ADproxyModelClass'></span>

<h3>Description</h3>

<p>create an ADproxyModelClass object. For internal use.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ADproxyModelClass-class_+3A_rmodel">Rmodel</code></td>
<td>
<p>The name of an uncompiled model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a proxy model for model_AD. The class needs just enough pieces to be used like a model for purposes of nodeFunction compilation. The model will contain an ADproxyModel and then the nodeFunction setup code will extract it. The model interface will population the proxy model's CobjectInterface
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='any_na'>Determine if any values in a vector are NA or NaN</h2><span id='topic+any_na'></span><span id='topic+any_nan'></span>

<h3>Description</h3>

<p>NIMBLE language functions that can be used in either compiled or uncompiled
nimbleFunctions to detect if there are any NA or NaN values in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_na(x)

any_nan(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="any_na_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>NIMBLE Development Team
</p>

<hr>
<h2 id='as.carAdjacency'>Convert CAR structural parameters to adjacency, weights, num format</h2><span id='topic+as.carAdjacency'></span>

<h3>Description</h3>

<p>This will convert alternate representations of CAR process structure into
(adj, weights, num) form required by <code>dcar_normal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.carAdjacency(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.carAdjacency_+3A_...">...</code></td>
<td>
<p>Either: a symmetric matrix of unnormalized weights, or two lists specifying adjacency indices and the corresponding unnormalized weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two alternate representations are handled:
</p>
<p>A single matrix argument will be interpreted as a matrix of symmetric unnormalized weights.
</p>
<p>Two lists will be interpreted as (the first) a list of numeric vectors
specifying the adjacency (neighboring) indices of each CAR process component,
and (the second) a list of numeric vectors giving the unnormalized weights
for each of these neighboring relationships.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAR-Normal">CAR-Normal</a></code>
</p>

<hr>
<h2 id='as.carCM'>Convert weights vector to parameters of <code>dcar_proper</code> distributio</h2><span id='topic+as.carCM'></span>

<h3>Description</h3>

<p>Convert weights vector to <code>C</code> and <code>M</code> parameters of <code>dcar_proper</code> distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.carCM(adj, weights, num)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.carCM_+3A_adj">adj</code></td>
<td>
<p>vector of indices of the adjacent locations (neighbors) of each spatial location.  This is a sparse representation of the full adjacency matrix.</p>
</td></tr>
<tr><td><code id="as.carCM_+3A_weights">weights</code></td>
<td>
<p>vector of symmetric unnormalized weights associated with each pair of adjacent locations, of the same length as adj.  This is a sparse representation of the full (unnormalized) weight matrix.</p>
</td></tr>
<tr><td><code id="as.carCM_+3A_num">num</code></td>
<td>
<p>vector giving the number of neighbors of each spatial location, with length equal to the total number of locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a symmetric matrix of unnormalized weights, this function will calculate corresponding values for the <code>C</code> and <code>M</code> arguments suitable for use in the <code>dcar_proper</code> distribution.  This function can be used to transition between usage of <code>dcar_normal</code> and <code>dcar_proper</code>, since <code>dcar_normal</code> uses the <code>adj</code>, <code>weights</code>, and <code>num</code> arguments, while <code>dcar_proper</code> requires <code>adj</code>, <code>num</code>, and also the <code>C</code> and <code>M</code> as returned by this function.
</p>
<p>Here, <code>C</code> is a sparse vector representation of the row-normalized adjacency matrix, and <code>M</code> is a vector containing the conditional variance for each region.  The resulting values of <code>C</code> and <code>M</code> are guaranteed to satisfy the symmetry constraint imposed on <code class="reqn">C</code> and <code class="reqn">M</code>, that <code class="reqn">M^{-1} C</code> is symmetric, where <code class="reqn">M</code> is a diagonal matrix and <code class="reqn">C</code> is the row-normalized adjacency matrix.
</p>


<h3>Value</h3>

<p>A named list with elements <code>C</code> and <code>M</code>.  These may be used as the <code>C</code> and <code>M</code> arguments to the <code>dcar_proper</code> distribution.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAR-Normal">CAR-Normal</a></code>, <code><a href="#topic+CAR-Proper">CAR-Proper</a></code>
</p>

<hr>
<h2 id='asRow'>Turn a numeric vector into a single-row or single-column matrix</h2><span id='topic+asRow'></span><span id='topic+asCol'></span>

<h3>Description</h3>

<p>Turns a numeric vector into a matrix that has 1 row or 1 column.  Part of NIMBLE language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asRow(x)

asCol(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asRow_+3A_x">x</code></td>
<td>
<p>Numeric to be turned into a single row or column matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the NIMBLE language, some automatic determination of how to turn vectors into single-row or single-column matrices is done.
For example, in <code>A %*% x</code>, where A is a matrix and x a vector, x will be turned into a single-column matrix unless
it is known at compile time that A is a single column, in which case x will be turned into a single-row matrix.
However, if it is desired that x be turned into a single row but A cannot be determined at compile time to be a single column,
then one can use <code>A %*% asRow(x)</code> to force this conversion.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>

<hr>
<h2 id='autoBlock'>Automated parameter blocking procedure for efficient MCMC sampling</h2><span id='topic+autoBlock'></span>

<h3>Description</h3>

<p>The automated parameter blocking algorithm is no longer actively maintained.  In some cases, it may not operate correctly with more recent system features and/or distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoBlock(
  Rmodel,
  autoIt = 20000,
  run = list("all", "default"),
  setSeed = TRUE,
  verbose = FALSE,
  makePlots = FALSE,
  round = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoBlock_+3A_rmodel">Rmodel</code></td>
<td>
<p>A NIMBLE model object, created from <code><a href="#topic+nimbleModel">nimbleModel</a></code>.</p>
</td></tr>
<tr><td><code id="autoBlock_+3A_autoit">autoIt</code></td>
<td>
<p>The number of MCMC iterations to run intermediate MCMC algorithms, through the course of the procedure.  Default 20,000.</p>
</td></tr>
<tr><td><code id="autoBlock_+3A_run">run</code></td>
<td>
<p>List of additional MCMC algorithms to compare against the automated blocking MCMC.  These may be specified as: the character string 'all' to denote blocking all continuous-valued nodes; the character string 'default' to denote NIMBLE's default MCMC configuration; a named list element consisting of a quoted code block, which when executed returns an MCMC configuration object for comparison; a custom-specificed blocking scheme, specified as a named list element which itself is a list of character vectors, where each character vector specifies the nodes in a particular block.  Default is c('all', 'default').</p>
</td></tr>
<tr><td><code id="autoBlock_+3A_setseed">setSeed</code></td>
<td>
<p>Logical specificying whether to call set.seed(0) prior to beginning the blocking procedure.  Default TRUE.</p>
</td></tr>
<tr><td><code id="autoBlock_+3A_verbose">verbose</code></td>
<td>
<p>Logical specifying whether to output considerable details of the automated block procedure, through the course of execution.  Default FALSE.</p>
</td></tr>
<tr><td><code id="autoBlock_+3A_makeplots">makePlots</code></td>
<td>
<p>Logical specifying whether to plot the hierarchical clustering dendrograms, through the course of execution.  Default FALSE.</p>
</td></tr>
<tr><td><code id="autoBlock_+3A_round">round</code></td>
<td>
<p>Logical specifying whether to round the final output results to two decimal places.  Default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs NIMBLE's automated blocking procedure for a given model object, to dynamically determine a blocking scheme of the continuous-valued model nodes.  This blocking scheme is designed to produce efficient MCMC sampling (defined as number of effective samples generated per second of algorithm runtime).  See Turek, et al (2015) for details of this algorithm.  This also (optionally) compares this blocked MCMC against several static MCMC algorithms, including all univariate sampling, blocking of all continuous-valued nodes, NIMBLE's default MCMC configuration, and custom-specified blockings of parameters.
</p>
<p>This method allows for fine-tuned usage of the automated blocking procedure.  However, the main entry point to the automatic blocking procedure is intended to be through either buildMCMC(..., autoBlock = TRUE), or configureMCMC(..., autoBlock = TRUE).
</p>


<h3>Value</h3>

<p>Returns a named list containing elements:
</p>

<ul>
<li> <p><code>summary</code>: A data frame containing a numerical summary of the performance of all MCMC algorithms (including that from automated blocking)
</p>
</li>
<li> <p><code>autoGroups</code>: A list specifying the parameter blockings converged on by the automated blocking procedure
</p>
</li>
<li> <p><code>conf</code>: A NIMBLE MCMC configuration object corresponding to the results of the automated blocking procedure
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>References</h3>

<p>Turek, D., de Valpine, P., Paciorek, C., and Anderson-Bergman, C. (2015). Automated Parameter Blocking for Efficient Markov-Chain Monte Carlo Sampling. &lt;arXiv:1503.05621&gt;.
</p>


<h3>See Also</h3>

<p>configureMCMC buildMCMC
</p>

<hr>
<h2 id='BUGSdeclClass-class'>BUGSdeclClass contains the information extracted from one BUGS declaration</h2><span id='topic+BUGSdeclClass-class'></span><span id='topic+BUGSdeclClass'></span>

<h3>Description</h3>

<p>BUGSdeclClass contains the information extracted from one BUGS declaration
</p>

<hr>
<h2 id='buildAGHQGrid'>Build Adaptive Gauss-Hermite Quadrature Grid</h2><span id='topic+buildAGHQGrid'></span>

<h3>Description</h3>

<p>Create quadrature grid for use in AGHQuad methods in Nimble.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildAGHQGrid_+3A_d">d</code></td>
<td>
<p>Dimension of quadrature grid being requested.</p>
</td></tr>
<tr><td><code id="buildAGHQGrid_+3A_nquad">nQuad</code></td>
<td>
<p>Number of quadrature nodes requested on build.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by used by <code>buildOneAGHQuad1D</code>
and <code>buildOneAGHQuad</code> create the quadrature grid using
adaptive Gauss-Hermite quadrature. Handles single or multiple dimension 
grids and computes both grid locations and weights. Additionally, acts
as a cache system to do transformations, and return marginalized log density.
</p>
<p>Any of the input node vectors, when provided, will be processed using
<code>nodes &lt;- model$expandNodeNames(nodes)</code>, where <code>nodes</code> may be
<code>paramNodes</code>, <code>randomEffectsNodes</code>, and so on. This step allows
any of the inputs to include node-name-like syntax that might contain
multiple nodes. For example, <code>paramNodes = 'beta[1:10]'</code> can be
provided if there are actually 10 scalar parameters, 'beta[1]' through
'beta[10]'. The actual node names in the model will be determined by the
<code>exapndNodeNames</code> step.
</p>
<p>Available methods include
</p>

<ul>
<li> <p><code>buildAGHQ</code>. Builds a adaptive Gauss-Hermite quadrature grid in d dimensions.
Calls <code>buildAGHQOne</code> to build the one dimensional grid and then expands in each dimension.
Some numerical issues occur in Eigen decomposition making the grid weights only accurate up to 
35 quadrature nodes.
</p>
</li>
<li><p> Options to get internally cached values are <code>getGridSize</code>,
<code>getModeIndex</code> for when there are an odd number of quadrature nodes,
<code>getLogDensity</code> for the cached values, <code>getAllNodes</code> for the 
quadrature grids, <code>getNodes</code> for getting a single indexed nodes,
<code>getAllNodesTransformed</code> for nodes transformed to the parameter scale,
<code>getNodesTransformed</code> for a single transformed node, <code>getAllWeights</code> 
to get all quadrature weights, <code>getWeights</code> single indexed weight.
</p>
</li>
<li> <p><code>transformGrid(cholNegHess, inner_mode, method)</code> transforms 
the grid using either cholesky trasnformations,
as default, or spectral that makes use of the Eigen decomposition. For a single
dimension <code>transformGrid1D</code> is used.
</p>
</li>
<li><p> As the log density is evaluated externally, it is saved via <code>saveLogDens</code>,
which then is summed via <code>quadSum</code>.
</p>
</li>
<li> <p><code>buildGrid</code> builds the grid the initial time and is only run once in code. After,
the user must choose to <code>setGridSize</code> to update the grid size.
</p>
</li>
<li> <p><code>check</code>. If TRUE (default), a warning is issued if
<code>paramNodes</code>, <code>randomEffectsNodes</code> and/or <code>calcNodes</code>
are provided but seek to have missing elements or unnecessary
elements based on some default inspection of the model. If
unnecessary warnings are emitted, simply set <code>check=FALSE</code>.
</p>
</li>
<li> <p><code>innerOptimControl</code>. A list of control parameters for the inner 
optimization of Laplace approximation using <code>optim</code>. See 
'Details' of <code><a href="stats.html#topic+optim">optim</a></code> for further information.
</p>
</li>
<li> <p><code>innerOptimMethod</code>. Optimization method to be used in 
<code>optim</code> for the inner optimization. See 'Details' of 
<code><a href="stats.html#topic+optim">optim</a></code>. Currently <code>optim</code> in NIMBLE supports: 
&quot;<code>Nelder-Mead</code>&quot;, &quot;<code>BFGS</code>&quot;, &quot;<code>CG</code>&quot;, and 
&quot;<code>L-BFGS-B</code>&quot;. By default, method &quot;<code>CG</code>&quot; is used when 
marginalizing over a single (scalar) random effect, and &quot;<code>BFGS</code>&quot; 
is used for multiple random effects being jointly marginalized over.
</p>
</li>
<li> <p><code>innerOptimStart</code>. Choice of starting values for the inner 
optimization. This could be <code>"last"</code>, <code>"last.best"</code>, or a 
vector of user provided values. <code>"last"</code> means the most recent 
random effects values left in the model will be used. When finding 
the MLE, the most recent values will be the result of the most recent 
inner optimization for Laplace. <code>"last.best"</code> means the random 
effects values corresponding to the largest Laplace likelihood (from 
any call to the <code>calcLaplace</code> or <code>calcLogLik</code> method, 
including during an MLE search) will be used (even if it was not the 
most recent Laplace likelihood). By default, the initial random 
effects values will be used for inner optimization.
</p>
</li>
<li> <p><code>outOptimControl</code>. A list of control parameters for maximizing
the Laplace log-likelihood using <code>optim</code>. See 'Details' of
<code><a href="stats.html#topic+optim">optim</a></code> for further information.
</p>
</li></ul>



<h3>References</h3>

<p>Golub, G. H. and Welsch, J. H. (1969). Calculation of Gauss Quadrature Rules. 
Mathematics of Computation 23 (106): 221-230.
</p>
<p>Liu, Q. and Pierce, D. A. (1994). A Note on Gauss-Hermite Quadrature. Biometrika, 81(3) 624-629.
</p>
<p>Jackel, P. (2005). A note on multivariate Gauss-Hermite quadrature. London: ABN-Amro. Re.
</p>

<hr>
<h2 id='buildAuxiliaryFilter'>Placeholder for buildAuxiliaryFilter</h2><span id='topic+buildAuxiliaryFilter'></span>

<h3>Description</h3>

<p>This function has been moved to the 'nimbleSMC' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildAuxiliaryFilter(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildAuxiliaryFilter_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>

<hr>
<h2 id='buildBootstrapFilter'>Placeholder for buildBootstrapFilter</h2><span id='topic+buildBootstrapFilter'></span>

<h3>Description</h3>

<p>This function has been moved to the 'nimbleSMC' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildBootstrapFilter(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildBootstrapFilter_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>

<hr>
<h2 id='buildEnsembleKF'>Placeholder for buildEnsembleKF</h2><span id='topic+buildEnsembleKF'></span>

<h3>Description</h3>

<p>This function has been moved to the 'nimbleSMC' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildEnsembleKF(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildEnsembleKF_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>

<hr>
<h2 id='buildIteratedFilter2'>Placeholder for buildIteratedFilter2</h2><span id='topic+buildIteratedFilter2'></span>

<h3>Description</h3>

<p>This function has been moved to the 'nimbleSMC' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildIteratedFilter2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildIteratedFilter2_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>

<hr>
<h2 id='buildLaplace'>Laplace approximation and adaptive Gauss-Hermite quadrature</h2><span id='topic+buildLaplace'></span><span id='topic+buildAGHQ'></span><span id='topic+laplace'></span><span id='topic+Laplace'></span><span id='topic+AGHQuad'></span><span id='topic+AGHQ'></span>

<h3>Description</h3>

<p>Build a Laplace or AGHQ approximation algorithm for a given NIMBLE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildLaplace(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  calcNodesOther,
  control = list()
)

buildAGHQ(
  model,
  nQuad = 1,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  calcNodesOther,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildLaplace_+3A_model">model</code></td>
<td>
<p>a NIMBLE model object, such as returned by <code>nimbleModel</code>.
The model must have automatic derivatives (AD) turned on, e.g. by using
<code>buildDerivs=TRUE</code> in <code>nimbleModel</code>.</p>
</td></tr>
<tr><td><code id="buildLaplace_+3A_paramnodes">paramNodes</code></td>
<td>
<p>a character vector of names of parameter nodes in the
model; defaults are provided by <code><a href="#topic+setupMargNodes">setupMargNodes</a></code>.
Alternatively, <code>paramNodes</code> can be a list in the format returned by
<code>setupMargNodes</code>, in which case <code>randomEffectsNodes</code>,
<code>calcNodes</code>, and <code>calcNodesOther</code> are not needed (and will be
ignored).</p>
</td></tr>
<tr><td><code id="buildLaplace_+3A_randomeffectsnodes">randomEffectsNodes</code></td>
<td>
<p>a character vector of names of continuous
unobserved (latent) nodes to marginalize (integrate) over using Laplace/AGHQ
approximation; defaults are provided by <code><a href="#topic+setupMargNodes">setupMargNodes</a></code>.</p>
</td></tr>
<tr><td><code id="buildLaplace_+3A_calcnodes">calcNodes</code></td>
<td>
<p>a character vector of names of nodes for calculating the
integrand for Laplace/AGHQ approximation; defaults are provided by
<code><a href="#topic+setupMargNodes">setupMargNodes</a></code>. There may be deterministic nodes between
<code>paramNodes</code> and <code>calcNodes</code>. These will be included in
calculations automatically and thus do not need to be included in
<code>calcNodes</code> (but there is no problem if they are).</p>
</td></tr>
<tr><td><code id="buildLaplace_+3A_calcnodesother">calcNodesOther</code></td>
<td>
<p>a character vector of names of nodes for calculating
terms in the log-likelihood that do not depend on any
<code>randomEffectsNodes</code>, and thus are not part of the marginalization,
but should be included for purposes of finding the MLE. This defaults to
stochastic nodes that depend on <code>paramNodes</code> but are not part of and
do not depend on <code>randomEffectsNodes</code>. There may be deterministic
nodes between <code>paramNodes</code> and <code>calcNodesOther</code>. These will be
included in calculations automatically and thus do not need to be included
in <code>calcNodesOther</code> (but there is no problem if they are).</p>
</td></tr>
<tr><td><code id="buildLaplace_+3A_control">control</code></td>
<td>
<p>a named list for providing additional settings used in Laplace/AGHQ
approximation. See <code>control</code> section below. Most of these can be
updated later with the 'updateSettings' method.</p>
</td></tr>
<tr><td><code id="buildLaplace_+3A_nquad">nQuad</code></td>
<td>
<p>number of quadrature points for AGHQ (in one dimension). Laplace approximation is
AGHQ with 'nQuad=1'. Only odd numbers of nodes really
make sense. Often only one or a few nodes can achieve high accuracy. A maximum of
35 nodes is supported. Note that for multivariate quadratures, the number
of nodes will be (number of dimensions)^nQuad.</p>
</td></tr>
</table>


<h3><code>buildLaplace</code> and <code>buildAGHQ</code></h3>

<p><code>buildLaplace</code> creates an object that can run Laplace approximation
for a given model or part of a model. <code>buildAGHQ</code> creates an object
that can run adaptive Gauss-Hermite quadrature (AGHQ, sometimes called
&quot;adaptive Gaussian quadrature&quot;) for a given model or part of a model.
Laplace approximation is AGHQ with one quadrature point, hence
'buildLaplace' simply calls 'buildAGHQ' with 'nQuad=1'. These methods
approximate the integration over continuous random effects in a
hierarchical model to calculate the (marginal) likelihood.
</p>
<p><code>buildAGHQ</code> and <code>buildLaplace</code> will by default (unless changed
manually via 'control$split') determine from the model which random effects
can be integrated over (marginalized) independently. For example, in a GLMM
with a grouping factor and an independent random effect intercept for each
group, the random effects can be marginalized as a set of univariate
approximations rather than one multivariate approximation. On the other hand,
correlated or nested random effects would require multivariate marginalization.
</p>
<p>Maximum likelihood estimation is available for Laplace approximation
('nQuad=1') with univariate or multivariate integrations. With 'nQuad &gt; 1',
maximum likelihood estimation is available only if all integrations are
univariate (e.g., a set of univariate random effects). If there are
multivariate integrations, these can be calculated at chosen input parameters
but not maximized over parameters. For example, one can find the MLE based on
Laplace approximation and then increase 'nQuad' (using the 'updateSettings'
method below) to check on accuracy of the marginal log likelihood at the MLE.
</p>
<p>Beware that quadrature will use 'nQuad^k' quadrature points, where 'k' is the
dimension of each integration. Therefore quadrature for 'k' greater that 2 or
3 can be slow. As just noted, 'buildAGHQ' will determine independent
dimensions of quadrature, so it is fine to have a set of univariate random
effects, as these will each have k=1. Multivariate quadrature (k&gt;1) is only
necessary for nested, correlated, or otherwise dependent random effects.
</p>
<p>The recommended way to find the maximum likelihood estimate and associated
outputs is by calling <code><a href="#topic+runLaplace">runLaplace</a></code> or <code><a href="#topic+runAGHQ">runAGHQ</a></code>. The
input should be the compiled Laplace or AGHQ algorithm object. This would be
produced by running <code><a href="#topic+compileNimble">compileNimble</a></code> with input that is the result
of <code>buildLaplace</code> or <code>buildAGHQ</code>.
</p>
<p>For more granular control, see below for methods <code>findMLE</code> and
<code>summary</code>. See function <code><a href="#topic+summaryLaplace">summaryLaplace</a></code> for an easier way
to call the <code>summary</code> method and obtain results that include node
names. These steps are all done within <code>runLaplace</code> and
<code>runAGHQ</code>.
</p>
<p>The NIMBLE User Manual at r-nimble.org also contains an example of Laplace
approximation.
</p>


<h3>How input nodes are processed</h3>

<p><code>buildLaplace</code> and <code>buildAGHQ</code> make good tries at deciding what
to do with the input model and any (optional) of the node arguments. However,
random effects (over which approximate integration will be done) can be
written in models in multiple equivalent ways, and customized use cases may
call for integrating over chosen parts of a model. Hence, one can take full
charge of how different parts of the model will be used.
</p>
<p>Any of the input node vectors, when provided, will be processed using
<code>nodes &lt;- model$expandNodeNames(nodes)</code>, where <code>nodes</code> may be
<code>paramNodes</code>, <code>randomEffectsNodes</code>, and so on. This step allows
any of the inputs to include node-name-like syntax that might contain
multiple nodes. For example, <code>paramNodes = 'beta[1:10]'</code> can be
provided if there are actually 10 scalar parameters, 'beta[1]' through
'beta[10]'. The actual node names in the model will be determined by the
<code>exapndNodeNames</code> step.
</p>
<p>In many (but not all) cases, one only needs to provide a NIMBLE model object
and then the function will construct reasonable defaults necessary for
Laplace approximation to marginalize over all continuous latent states 
(aka random effects) in a model. The default values for the four groups of 
nodes are obtained by calling <code><a href="#topic+setupMargNodes">setupMargNodes</a></code>, whose arguments 
match those here (except for a few arguments which are taken from control 
list elements here).
</p>
<p><code>setupMargNodes</code> tries to give sensible defaults from
any combination of <code>paramNodes</code>, <code>randomEffectsNodes</code>,
<code>calcNodes</code>, and <code>calcNodesOther</code> that are provided. For example,
if you provide only <code>randomEffectsNodes</code> (perhaps you want to
marginalize over only some of the random effects in your model),
<code>setupMargNodes</code> will try to determine appropriate choices for the
others.
</p>
<p><code>setupMargNodes</code> also determines which integration dimensions are
conditionally independent, i.e., which can be done separately from each
other. For example, when possible, 10 univariate random effects will be split
into 10 univariate integration problems rather than one 10-dimensional
integration problem.
</p>
<p>The defaults make general assumptions such as that
<code>randomEffectsNodes</code> have <code>paramNodes</code> as parents. However, The
steps for determining defaults are not simple, and it is possible that they
will be refined in the future. It is also possible that they simply don't
give what you want for a particular model. One example where they will not
give desired results can occur when random effects have no prior
parameters, such as 'N(0,1)' nodes that will be multiplied by a scale
factor (e.g. sigma) and added to other explanatory terms in a model. Such
nodes look like top-level parameters in terms of model structure, so
you must provide a <code>randomEffectsNodes</code> argument to indicate which
they are.
</p>
<p>It can be helpful to call <code>setupMargNodes</code> directly to see exactly how
nodes will be arranged for Laplace approximation. For example, you may want
to verify the choice of <code>randomEffectsNodes</code> or get the order of
parameters it has established to use for making sense of the MLE and
results from the <code>summary</code> method. One can also call
<code>setupMargNodes</code>, customize the returned list, and then provide that
to <code>buildLaplace</code> as <code>paramNodes</code>. In that case,
<code>setupMargNodes</code> will not be called (again) by <code>buildLaplace</code>.
</p>
<p>If <code>setupMargNodes</code> is emitting an unnecessary warning, simply use
<code>control=list(check=FALSE)</code>.
</p>


<h3>Managing parameter transformations that may be used internally</h3>

<p>If any <code>paramNodes</code> (parameters) or <code>randomEffectsNodes</code> (random
effects / latent states) have constraints on the range of valid values
(because of the distribution they follow), they will be used on a
transformed scale determined by <code>parameterTransform</code>. This means the
Laplace approximation itself will be done on the transformed scale for
random effects and finding the MLE will be done on the transformed scale
for parameters. For parameters, prior distributions are not included in
calculations, but they are used to determine valid parameter ranges and
hence to set up any transformations. For example, if <code>sigma</code> is a
standard deviation, you can declare it with a prior such as <code>sigma ~
  dhalfflat()</code> to indicate that it must be greater than 0.
</p>
<p>For default determination of when transformations are needed, all parameters
must have a prior distribution simply to indicate the range of valid
values. For a param <code>p</code> that has no constraint, a simple choice is
<code>p ~ dflat()</code>.
</p>


<h3>Understanding inner and outer optimizations</h3>

<p>Note that there are two numerical optimizations when finding maximum
likelihood estimates with a Laplace or (1D) AGHQ algorithm: (1) maximizing
the joint log-likelihood of random effects and data given a parameter value
to construct the approximation to the marginal log-likelihood at the given
parameter value; (2) maximizing the approximation to the marginal
log-likelihood over the parameters. In what follows, the prefix 'inner'
refers to optimization (1) and 'outer' refers to optimization (2). Currently
both optimizations default to using method <code>"nlminb"</code>. However, one can
use other optimizers or simply run optimization (2) manually from R; see the
example below. In some problems, choice of inner and/or outer optimizer can
make a big difference for obtaining accurate results, especially for standard
errors. Hence it is worth experimenting if one is in doubt.
</p>


<h3><code>control</code> list arguments</h3>

<p>The <code>control</code> list allows additional settings to be made using named
elements of the list. Most (or all) of these can be updated later using the
'updateSettings' method. Supported elements include:
</p>

<ul>
<li> <p><code>split</code>. If TRUE (default), <code>randomEffectsNodes</code> will be
split into conditionally independent sets if possible. This
facilitates more efficient Laplace or AGHQ approximation because each
conditionally independent set can be marginalized independently. If
FALSE, <code>randomEffectsNodes</code> will be handled as one multivariate
block, with one multivariate approximation. If <code>split</code> is a
numeric vector, <code>randomEffectsNodes</code> will be split by calling
<code>split</code>(<code>randomEffectsNodes</code>, <code>control$split</code>). The
last option allows arbitrary control over how
<code>randomEffectsNodes</code> are blocked.
</p>
</li>
<li> <p><code>check</code>. If TRUE (default), a warning is issued if
<code>paramNodes</code>, <code>randomEffectsNodes</code> and/or <code>calcNodes</code>
are provided but seem to have missing or unnecessary
elements based on some default inspections of the model. If
unnecessary warnings are emitted, simply set <code>check=FALSE</code>.
</p>
</li>
<li> <p><code>innerOptimControl</code>. A list (either an R list or a
'optimControlNimbleList') of control parameters for the inner
optimization of Laplace approximation using <code>nimOptim</code>. See
'Details' of <code><a href="#topic+nimOptim">nimOptim</a></code> for further information. Default
is 'nimOptimDefaultControl()'.
</p>
</li>
<li> <p><code>innerOptimMethod</code>. Optimization method to be used in
<code>nimOptim</code> for the inner optimization. See 'Details' of
<code><a href="#topic+nimOptim">nimOptim</a></code>. Currently <code>nimOptim</code> in NIMBLE supports:
<code>"Nelder-Mead"</code>&quot;, <code>"BFGS"</code>, <code>"CG"</code>, <code>"L-BFGS-B"</code>,
<code>"nlminb"</code>, <code>"bobyqa"</code>, and user-provided optimizers. By default, method
<code>"nlminb"</code> is used for both univariate and multivariate cases. For
<code>"nlminb"</code>, <code>"bobyqa"</code>, or user-provided optimizers, only a subset of
elements of the <code>innerOptimControlList</code> are supported. (Note
that control over the outer optimization method is available as an
argument to 'findMLE'). Choice of optimizers can be important and so
can be worth exploring.
</p>
</li>
<li> <p><code>innerOptimStart</code>. Method for determining starting values for
the inner optimization. Options are:
</p>

<ul>
<li> <p><code>"last.best"</code> (default): use optimized random effects values corresponding to
the best outer optimization (i.e. the largest marginal log likelihood value) so far
for each conditionally independent part of the approximation;
</p>
</li>
<li> <p><code>"last"</code>: use the result of the last inner optimization;
</p>
</li>
<li> <p><code>"zero"</code>: use all zeros;
</p>
</li>
<li> <p><code>"constant"</code>: always use the same values, determined by
<code>innerOptimStartValues</code>;
</p>
</li>
<li> <p><code>"random"</code>: randomly draw new starting values from the
model (i.e., from the prior);
</p>
</li>
<li> <p><code>"model"</code>: use values for random effects stored in the
model, which are determined from the first call.
</p>
</li></ul>

<p>Note that <code>"model"</code> and <code>"zero"</code> are shorthand for
<code>"constant"</code> with particular choices of
<code>innerOptimStartValues</code>. Note that <code>"last"</code> and
<code>"last.best"</code> require a choice for the very first values, which will
come from <code>innerOptimStartValues</code>. The default is
<code>innerOptimStart="zero"</code> and may change in the future.
</p>
</li>
<li> <p><code>innerOptimStartValues</code>. Values for some of
<code>innerOptimStart</code> approaches. If a scalar is provided, that
value is used for all elements of random effects for each
conditionally independent set. If a vector is provided, it must be
the length of *all* random effects. If these are named (by node
names), the names will be used to split them correctly among each
conditionally independent set of random effects. If they are not
named, it is not always obvious what the order should be because it
may depend on the conditionally independent sets of random
effects. It should match the order of names returned as part of
'summaryLaplace'.
</p>
</li>
<li> <p><code>innerOptimWarning</code>. If FALSE (default), do not emit warnings
from the inner optimization. Optimization methods may sometimes emit a
warning such as for bad parameter values encountered during the
optimization search. Often, a method can recover and still find the
optimum. In the approximations here, sometimes the inner optimization
search can fail entirely, yet the outer optimization see this as one failed
parameter value and can recover. Hence, it is often desirable to silence
warnings from the inner optimizer, and this is done by default. Set
<code>innerOptimWarning=TRUE</code> to see all warnings.
</p>
</li>
<li> <p><code>useInnerCache</code>. If TRUE (default), use caching system for
efficiency of inner optimizations. The caching system records one set of
previous parameters and uses the corresponding results if those parameters
are used again (e.g., in a gradient call). This should generally not be
modified.
</p>
</li>
<li> <p><code>outerOptimMethod</code>. Optimization method to be used in
<code>nimOptim</code> for the outer optimization. See 'Details' of
<code><a href="#topic+nimOptim">nimOptim</a></code>. Currently <code>nimOptim</code> in NIMBLE supports:
<code>"Nelder-Mead"</code>&quot;, <code>"BFGS"</code>, <code>"CG"</code>, <code>"L-BFGS-B"</code>,
<code>"nlminb"</code>, <code>"bobyqa"</code>, and user-provided optimizers. By default, method
<code>"nlminb"</code> is used for both univariate and multivariate cases,
although some problems may benefit from other choices. For
<code>"nlminb"</code>, <code>"bobyqa"</code>, or user-provided optimizers, only a subset of
elements of the <code>innerOptimControlList</code> are supported. (Note
that control over the outer optimization method is available as an
argument to 'findMLE'). Choice of optimizers can be important and so
can be worth exploring.
</p>
</li>
<li> <p><code>outerOptimControl</code>. A list of control parameters for maximizing
the Laplace log-likelihood using <code>nimOptim</code>. See 'Details' of
<code><a href="#topic+nimOptim">nimOptim</a></code> for further information.
</p>
</li>
<li> <p><code>computeMethod</code>. There are three approaches available for
internal details of how the approximations, and specifically derivatives
involved in their calculation, are handled. These are labeled simply 1, 2,
and 3, and the default is 2. The relative performance of the methods will
depend on the specific model. Users wanting to explore efficiency can try
switching from method 2 (default) to methods 1 or 3 and comparing
performance. The first Laplace approximation with each method will be
(much) slower than subsequent Laplace approximations. Further details are
not provided at this time.
</p>
</li>
<li> <p><code>gridType</code> (relevant only <code>nQuad&gt;1</code>). For multivariate AGHQ,
a grid must be constructed based on the Hessian at the inner mode. Options
include &quot;cholesky&quot; (default) and &quot;spectral&quot; (i.e., eigenvectors and
eigenvalues) for the corresponding matrix decompositions on which the grid
can be based.
</p>
</li></ul>
<p> # end itemize
</p>


<h3>Available methods</h3>

<p>The object returned by <code>buildLaplace</code> or <code>buildAGHQ</code> is a nimbleFunction object with
numerous methods (functions). Here these are described in three tiers of user
relevance.
</p>


<h3>Most useful methods</h3>

<p>The most relevant methods to a user are:
</p>

<ul>
<li> <p><code>calcLogLik(p, trans=FALSE)</code>. Calculate the approximation to the
marginal log-likelihood function at parameter value <code>p</code>, which (if
<code>trans</code> is FALSE) should match the order of <code>paramNodes</code>. For
any non-scalar nodes in <code>paramNodes</code>, the order within the node is
column-major. The order of names can be obtained from method
<code>getNodeNamesVec(TRUE)</code>. Return value is the scalar (approximate,
marginal) log likelihood.
</p>
<p>If <code>trans</code> is TRUE, then <code>p</code> is the vector of parameters on
the transformed scale, if any, described above. In this case, the
parameters on the original scale (as the model was written) will be
determined by calling the method <code>pInverseTransform(p)</code>. Note that
the length of the parameter vector on the transformed scale might not
be the same as on the original scale (because some constraints of
non-scalar parameters result in fewer free transformed parameters than
original parameters).
</p>
</li>
<li> <p><code>calcLaplace(p, trans)</code>. This is the same as <code>calcLogLik</code> but
requires that the approximation be Laplace (i.e <code>nQuad</code> is 1),
and results in an error otherwise.
</p>
</li>
<li> <p><code>findMLE(pStart, hessian)</code>. Find the maximum likelihood
estimates of parameters using the approximated marginal likelihood.
This can be used if <code>nQuad</code> is 1 (Laplace case) or if
<code>nQuad&gt;1</code> and all marginalizations involve only univariate
random effects. Arguments are <code>pStart</code>: initial parameter
values (defaults to parameter values currently in the model);
and <code>hessian</code>: whether to calculate and return the
Hessian matrix (defaults to <code>TRUE</code>, which is required for
subsequent use of <code>summary</code> method). Second derivatives in the
Hessian are determined by finite differences of the gradients
obtained by automatic differentiation (AD). Return value is a
nimbleList of type <code>optimResultNimbleList</code>, similar to what is
returned by R's optim. See <code>help(nimOptim)</code>. Note that
parameters (<code>par</code>) are returned for the natural parameters, i.e. how
they are defined in the model. But the <code>hessian</code>, if requested, is
computed for the parameters as transformed for optimization if
necessary. Hence one must be careful interpreting 'hessian' if any
parameters have constraints, and the safest next step is to use the
<code>summary</code> method or <code>summaryLaplace</code> function.
</p>
</li>
<li> <p><code>summary(MLEoutput, originalScale, randomEffectsStdError,
       jointCovariance)</code>. Summarize the maximum likelihood estimation
results, given object <code>MLEoutput</code> that was returned by
<code>findMLE</code>. The summary can include a covariance matrix for the
parameters, the random effects, or both), and these can be returned on
the original parameter scale or on the (potentially) transformed
scale(s) used in estimation. It is often preferred instead to call
function (not method) 'summaryLaplace' because this will attach
parameter and random effects names (i.e., node names) to the results.
</p>
<p>In more detail, <code>summary</code> accepts the following optional arguments:
</p>

<ul>
<li> <p><code>originalScale</code>. Logical. If TRUE, the function returns
results on the original scale(s) of parameters and random effects;
otherwise, it returns results on the transformed scale(s). If there
are no constraints, the two scales are identical. Defaults to TRUE.
</p>
</li>
<li> <p><code>randomEffectsStdError</code>. Logical. If TRUE, standard
errors of random effects will be calculated.
Defaults to TRUE.
</p>
</li>
<li> <p><code>jointCovariance</code>. Logical. If TRUE, the joint
variance-covariance matrix of the parameters and the random effects
will be returned. If FALSE, the variance-covariance matrix of the 
parameters will be returned. Defaults to FALSE.
</p>
</li></ul>

<p>The object returned by <code>summary</code> is an <code>AGHQuad_summary</code>
nimbleList with elements:
</p>

<ul>
<li> <p><code>params</code>. A nimbleList that contains estimates and
standard errors of parameters (on the original or transformed
scale, as chosen by <code>originalScale</code>).
</p>
</li>
<li> <p><code>randomEffects</code>. A nimbleList that contains estimates of
random effects and, if requested
(<code>randomEffectsStdError=TRUE</code>) their standard errors, on
original or transformed scale. Standard errors are calculated
following the generalized delta method of Kass and Steffey (1989).
</p>
</li>
<li> <p><code>vcov</code>. If requested (i.e.
<code>jointCovariance=TRUE</code>), the joint variance-covariance
matrix of the parameters and random effects, on original or
transformed scale. If <code>jointCovariance=FALSE</code>, the
covariance matrix of the parameters, on original or transformed 
scale.
</p>
</li>
<li> <p><code>scale</code>. <code>"original"</code> or <code>"transformed"</code>, the
scale on which results were requested.
</p>
</li></ul>

</li></ul>



<h3>Methods for more advanced uses</h3>

<p>Additional methods to access or control more details of the Laplace/AGHQ
approximation include:
</p>

<ul>
<li> <p><code>updateSettings</code>. This provides a single function through which
many of the settings described above (mostly for the <code>control</code> list)
can be later changed. Options that can be changed include:
<code>innerOptimMethod</code>, <code>innerOptimStart</code>,
<code>innerOptimStartValues</code>, <code>useInnerCache</code>, <code>nQuad</code>,
<code>gridType</code>, <code>innerOptimControl</code>, <code>outerOptimMethod</code>,
<code>outerOptimControl</code>, and <code>computeMethod</code>.
For <code>innerOptimStart</code>, method &quot;zero&quot; cannot be
specified but can be achieved by choosing method &quot;constant&quot; with
<code>innerOptimStartValues=0</code>. Only provided options will be modified. The
exceptions are <code>innerOptimControl</code>, <code>outerOptimControl</code>, which
are replaced only when <code>replace_innerOptimControl=TRUE</code> or
<code>replace_outerOptimControl=TRUE</code>, respectively.
</p>
</li>
<li> <p><code>getNodeNamesVec(returnParams)</code>. Return a vector (&gt;1) of names
of parameters/random effects nodes, according to <code>returnParams =
  TRUE/FALSE</code>. Use this if there is more than one node.
</p>
</li>
<li> <p><code>getNodeNameSingle(returnParams)</code>. Return the name of a
single parameter/random effect node, according to <code>returnParams = 
  TRUE/FALSE</code>. Use this if there is only one node.
</p>
</li>
<li> <p><code>checkInnerConvergence(message)</code>. Checks whether all internal
optimizers converged. Returns a zero if everything converged and one
otherwise. If <code>message = TRUE</code>, it will print more details about
convergence for each conditionally independent set.
</p>
</li>
<li> <p><code>gr_logLik(p, trans)</code>. Gradient of the (approximated)
marginal log-likelihood at parameter value <code>p</code>. Argument <code>trans</code> 
is similar to that in <code>calcLaplace</code>. If there are multiple parameters,
the vector <code>p</code> is given in the order of parameter names returned by 
<code>getNodeNamesVec(returnParams=TRUE)</code>.
</p>
</li>
<li> <p><code>gr_Laplace(p, trans)</code>. This is the same as <code>gr_logLik</code>.
</p>
</li>
<li> <p><code>otherLogLik(p)</code>. Calculate the <code>calcNodesOther</code>
nodes, which returns the log-likelihood of the parts of the model that are
not included in the Laplace or AGHQ approximation.
</p>
</li>
<li> <p><code>gr_otherLogLik(p)</code>. Gradient (vector of derivatives with
respect to each parameter) of <code>otherLogLik(p)</code>. Results should
match <code>gr_otherLogLik_internal(p)</code> but may be more efficient after
the first call.
</p>
</li></ul>



<h3>Internal or development methods</h3>

<p>Some methods are included for calculating the (approximate) marginal log
posterior density by including the prior distribution of the parameters. This
is useful for finding the maximum a posteriori probability (MAP) estimate.
Currently these are provided for point calculations without estimation methods.
</p>

<ul>
<li> <p><code>calcPrior_p(p)</code>. Log density of prior distribution.
</p>
</li>
<li> <p><code>calcPrior_pTransformed(pTransform)</code>. Log density of prior distribution on transformed scale, includes the Jacobian.
</p>
</li>
<li> <p><code>calcPostLogDens(p)</code>. Marginal log posterior density in terms of the parameter p.
</p>
</li>
<li> <p><code>calcPostLogDens_pTransformed (pTransform)</code>. Marginal log posterior density in terms of the transformed
parameter, which includes the Jacobian transformation.
</p>
</li>
<li> <p><code>gr_postLogDens_pTransformed(pTransform)</code>. Graident of marginal log posterior density on the transformed scale. 
Other available options that are used in the derivative for more flexible include <code>logDetJacobian(pTransform)</code> and
<code>gr_logDeJacobian(pTransform)</code>, as well as <code>gr_prior(p)</code>.
</p>
</li></ul>

<p>Finally, methods that are primarily for internal use by other methods include:
</p>

<ul>
<li> <p><code>gr_logLik_pTransformed</code>. Gradient of the Laplace
approximation (<code>calcLogLik_pTransformed(pTransform)</code>) at transformed 
(unconstrained) parameter value <code>pTransform</code>.
</p>
</li>
<li> <p><code>pInverseTransform(pTransform)</code>. Back-transform the transformed
parameter value <code>pTransform</code> to original scale.
</p>
</li>
<li> <p><code>derivs_pInverseTransform(pTransform, order)</code>. Derivatives of
the back-transformation (i.e. inverse of parameter transformation) with
respect to transformed parameters at <code>pTransform</code>. Derivative order
is given by <code>order</code> (any of 0, 1, and/or 2).
</p>
</li>
<li> <p><code>reInverseTransform(reTrans)</code>. Back-transform the transformed
random effects value <code>reTrans</code> to original scale.
</p>
</li>
<li> <p><code>derivs_reInverseTransform(reTrans, order)</code>. Derivatives of the
back-transformation (i.e. inverse of random effects transformation) with
respect to transformed random effects at <code>reTrans</code>. Derivative order
is given by <code>order</code> (any of 0, 1, and/or 2).
</p>
</li>
<li> <p><code>optimRandomEffects(pTransform)</code>. Calculate the optimized
random effects given transformed parameter value <code>pTransform</code>. The
optimized random effects are the mode of the conditional distribution of
random effects given data at parameters <code>pTransform</code>, i.e. the
calculation of <code>calcNodes</code>.
</p>
</li>
<li> <p><code>inverse_negHess(p, reTransform)</code>. Calculate the inverse of the
negative Hessian matrix of the joint (parameters and random effects)
log-likelihood with respect to transformed random effects, evaluated at
parameter value <code>p</code> and transformed random effects
<code>reTransform</code>.
</p>
</li>
<li> <p><code>hess_logLik_wrt_p_wrt_re(p, reTransform)</code>. Calculate the
Hessian matrix of the joint log-likelihood with respect to parameters and
transformed random effects, evaluated at parameter value <code>p</code> and
transformed random effects <code>reTransform</code>.
</p>
</li>
<li> <p><code>one_time_fixes()</code>. Users never need to run this. Is is called
when necessary internally to fix dimensionality issues if there is only
one parameter in the model.
</p>
</li>
<li> <p><code>calcLogLik_pTransformed(pTransform)</code>. Laplace approximation at
transformed (unconstrained) parameter value <code>pTransform</code>. To
make maximizing the Laplace likelihood unconstrained, an automated
transformation via <code><a href="#topic+parameterTransform">parameterTransform</a></code> is performed on
any parameters with constraints indicated by their priors (even
though the prior probabilities are not used).
</p>
</li>
<li> <p><code>gr_otherLogLik_internal(p)</code>. Gradient (vector of
derivatives with respect to each parameter) of <code>otherLogLik(p)</code>.
This is obtained using automatic differentiation (AD) with single-taping.
First call will always be slower than later calls.
</p>
</li>
<li> <p><code>cache_outer_logLik(logLikVal)</code>. Save the marginal log likelihood value 
to the inner Laplace mariginlization functions to track the outer maximum internally.
</p>
</li>
<li> <p><code>reset_outer_inner_logLik()</code>. Reset the internal saved maximum marginal log likelihood.
</p>
</li>
<li> <p><code>get_inner_cholesky(atOuterMode = integer(0, default = 0))</code>. Returns the cholesky
of the negative Hessian with respect to the random effects. If <code>atOuterMode = 1</code> then returns
the value at the overall best marginal likelihood value, otherwise <code>atOuterMode = 0</code> returns the last.
</p>
</li>
<li> <p><code>get_inner_mode(atOuterMode = integer(0, default = 0))</code>. Returns the mode of the random effects
for either the last call to the innner quadrature functions (<code>atOuterMode = 0</code> ), or the last best
value for the marginal log likelihood, <code>atOuterMode = 1</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei Zhang, Perry de Valpine, Paul van Dam-Bates
</p>


<h3>References</h3>

<p>Kass, R. and Steffey, D. (1989). Approximate Bayesian inference in
conditionally independent hierarchical models (parametric empirical Bayes
models). <em>Journal of the American Statistical Association</em>, 84(407),
717-726.
</p>
<p>Liu, Q. and Pierce, D. A. (1994). A Note on Gauss-Hermite Quadrature. <em>Biometrika</em>, 81(3) 624-629.
</p>
<p>Jackel, P. (2005). A note on multivariate Gauss-Hermite quadrature. London: <em>ABN-Amro. Re.</em>
</p>
<p>Skaug, H. and Fournier, D. (2006). Automatic approximation of the marginal
likelihood in non-Gaussian hierarchical models. <em>Computational
Statistics &amp; Data Analysis</em>, 56, 699-709.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pumpCode &lt;- nimbleCode({ 
  for (i in 1:N){
    theta[i] ~ dgamma(alpha, beta)
    lambda[i] &lt;- theta[i] * t[i]
    x[i] ~ dpois(lambda[i])
  }
  alpha ~ dexp(1.0)
  beta ~ dgamma(0.1, 1.0)
})
pumpConsts &lt;- list(N = 10, t = c(94.3, 15.7, 62.9, 126, 5.24, 31.4, 1.05, 1.05, 2.1, 10.5))
pumpData &lt;- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))
pumpInits &lt;- list(alpha = 0.1, beta = 0.1, theta = rep(0.1, pumpConsts$N))
pump &lt;- nimbleModel(code = pumpCode, name = "pump", constants = pumpConsts, 
                    data = pumpData, inits = pumpInits, buildDerivs = TRUE)
                    
# Build Laplace approximation
pumpLaplace &lt;- buildLaplace(pump)

## Not run: 
# Compile the model
Cpump &lt;- compileNimble(pump)
CpumpLaplace &lt;- compileNimble(pumpLaplace, project = pump)
# Calculate MLEs of parameters
MLEres &lt;- CpumpLaplace$findMLE()
# Calculate estimates and standard errors for parameters and random effects on original scale
allres &lt;- CpumpLaplace$summary(MLEres, randomEffectsStdError = TRUE)

# Change the settings and also illustrate runLaplace
CpumpLaplace$updateSettings(innerOptimControl = list(maxit = 1000),
                            replace_innerOptimControl)
newres &lt;- runLaplace(CpumpLaplace)

# Illustrate use of the component log likelihood and gradient functions to
# run an optimizer manually from R.
# Use nlminb to find MLEs
MLEres.manual &lt;- nlminb(c(0.1, 0.1),
                        function(x) -CpumpLaplace$calcLogLik(x),
                        function(x) -CpumpLaplace$gr_Laplace(x))

## End(Not run)

</code></pre>

<hr>
<h2 id='buildLiuWestFilter'>Placeholder for buildLiuWestFilter</h2><span id='topic+buildLiuWestFilter'></span>

<h3>Description</h3>

<p>This function has been moved to the 'nimbleSMC' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildLiuWestFilter(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildLiuWestFilter_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>

<hr>
<h2 id='buildMacro'>EXPERIMENTAL: Turn a function into a model macro</h2><span id='topic+buildMacro'></span>

<h3>Description</h3>

<p>A model macro expands one line of code in a nimbleModel into one or
more new lines.  This supports compact programming by defining
re-usable modules.  <code>buildMacro</code> takes as input a
function that constructs new lines of model code from the original
line of code.  It returns a function suitable for internal use by
<code>nimbleModel</code> that arranges arguments for input function.  Macros
are an experimental feature and are available only after setting
<code>nimbleOptions(enableMacros = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMacro(fun, use3pieces = TRUE, unpackArgs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildMacro_+3A_fun">fun</code></td>
<td>
<p>A function written to construct new lines of model code (see below).</p>
</td></tr>
<tr><td><code id="buildMacro_+3A_use3pieces">use3pieces</code></td>
<td>
<p>logical indicating whether the arguments from the input
line be split into pieces for the LHS (left-hand side), RHS
(right-hand side, possibly further split depending on
<code>unpackArgs</code>), and <code>stoch</code> (<code>TRUE</code> if the line uses a
<code>~</code> and <code>FALSE</code> otherwise). (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="buildMacro_+3A_unpackargs">unpackArgs</code></td>
<td>
<p>logical indicating whether arguments be passed as a list
(<code>FALSE</code>) or as separate arguments (<code>TRUE</code>). (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>use3pieces</code> and <code>unpackArgs</code>
indicate how <code>fun</code> expects to have arguments arranged from an
input line of code (processed by <code>nimbleModel</code>).
</p>
<p>Consider the defaults <code>use3pieces = TRUE</code> and <code>unpackArgs =
TRUE</code>, for a macro called <code>macro1</code>.  In this case, the line of
model code <code>x ~ macro1(arg1 = z[1:10], arg2 = "hello")</code> will be
passed to <code>fun</code> as <code>fun(stoch = TRUE, LHS = x, arg1 =
z[1:10], arg2 = "hello")</code>.
</p>
<p>If <code>use3pieces = TRUE</code> but <code>unpackArgs = FALSE</code>, then the
RHS will be passed as is, without unpacking its arguments into
separate arguments to <code>fun</code>.  In this case, <code>x ~ macro1(arg1
= z[1:10], arg2 = "hello")</code> will be passed to <code>fun</code> as
<code>fun(stoch = TRUE, LHS = x, RHS = macro1(arg1 = z[1:10], arg2 =
"hello"))</code>.
</p>
<p>If <code>use3pieces = FALSE</code> and <code>unpackArgs = FALSE</code>, the entire
line of code is passed as a single object.  In this case, <code>x ~
macro1(arg1 = z[1:10], arg2 = "hello")</code> will be passed to <code>fun</code>
as <code>fun(x ~ macro1(arg1 = z[1:10], arg2 = "hello"))</code>.  It is also
possible in this case to pass a macro without using a <code>~</code> or
<code>&lt;-</code>.  For example, the line <code>macro1(arg1 = z[1:10], arg2 =
"hello")</code> will be passed to <code>fun</code> as <code>fun(macro1(arg1 =
z[1:10], arg2 = "hello"))</code>.
</p>
<p>If <code>use3pieces = FALSE</code> and <code>unpackArgs = TRUE</code>, it
won't make sense to anticipate a declaration using <code>~</code> or <code>&lt;-</code>.
Instead, arguments from an arbitrary call will be passed as separate arguments.
For example, the line <code>macro1(arg1 = z[1:10], arg2 = "hello")</code> will be
passed to <code>fun</code> as <code>fun(arg1 = z[1:10], arg2 = "hello")</code>.
</p>
<p>In addition, the final two arguments of <code>fun</code> must be called <code>modelInfo</code>
and <code>.env</code> respectively. 
</p>
<p>During macro processing, <code>nimbleModel</code> passes a named list to the <code>modelInfo</code> 
argument of <code>fun</code> containing, among other things, elements called
<code>constants</code> and <code>dimensions</code>. Macro developers can modify these
two elements (for example, to add a new constant needed for a macro) and
these changes will be reflected in the final model object. Note that currently
it is not possible for a macro to modify the data. Furthermore, if your macro add a new element to the
constants that <code>nimbleModel</code> then moves to the data, this new data will not be retained
in the final model object and thus will not be usable. 
</p>
<p><code>nimbleModel</code> passes the R environment from which <code>nimbleModel</code> was
called to the <code>.env</code> argument.
</p>
<p>The <code>fun</code> function must return a named list with two elements:
<code>code</code>, the replacement code, and <code>modelInfo</code>, the <code>modelInfo</code> 
list described above. <code>modelInfo</code> must be in the output even if the macro
does not modify it.
</p>
<p>It is extremely useful to be familiar with processing R code as an
object to write <code>fun</code> correctly.  Functions such as
<code><a href="base.html#topic+substitute">substitute</a></code> and <code><a href="base.html#topic+as.name">as.name</a></code>
(e.g. <code>as.name('~')</code>), <code><a href="base.html#topic+quote">quote</a></code>, <code><a href="base.html#topic+parse">parse</a></code>
and <code><a href="base.html#topic+deparse">deparse</a></code> are particularly handy.
</p>
<p>Multiple lines of new code should be contained in <code> {} </code>. Extra
curly braces are not a problem. See example 2.
</p>
<p>Macro expansion is done recursively: One macro can return code that
invokes another macro.
</p>


<h3>Value</h3>

<p>A list of class <code>model_macro</code> with one element called <code>process</code>,
which contains the macro function suitable for use by <code>nimbleModel</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nimbleOptions(enableMacros = TRUE)
nimbleOptions(enableMacroComments = FALSE)
nimbleOptions(verbose = FALSE)

## Example 1: Say one is tired of writing "for" loops.
## This macro will generate a "for" loop with dnorm declarations
all_dnorm &lt;- buildMacro(
    function(stoch, LHS, RHSvar, start, end, sd = 1, modelInfo, .env) {
        newCode &lt;- substitute(
            for(i in START:END) {
                LHS[i] ~ dnorm(RHSvar[i], SD)
            },
            list(START = start,
                 END = end,
                 LHS = LHS,
                 RHSvar = RHSvar,
                 SD = sd))
        list(code = newCode)
    },
    use3pieces = TRUE,
    unpackArgs = TRUE 
)

model1 &lt;- nimbleModel(
    nimbleCode(
    {
        ## Create a "for" loop of dnorm declarations by invoking the macro
        x ~ all_dnorm(mu, start = 1, end = 10)
    }
    ))

## show code from expansion of macro
model1$getCode()
## The result should be:
## {
##     for (i in 1:10) {
##         x[i] ~ dnorm(mu[i], 1)
##     }
## }

## Example 2: Say one is tired of writing priors.
## This macro will generate a set of priors in one statement
flat_normal_priors &lt;- buildMacro(
    function(..., modelInfo, .env) {
        allVars &lt;- list(...)
        priorDeclarations &lt;- lapply(allVars,
                                    function(x)
                                        substitute(VAR ~ dnorm(0, sd = 1000),
                                                   list(VAR = x)))
        newCode &lt;- quote({})
        newCode[2:(length(allVars)+1)] &lt;- priorDeclarations
        list(code = newCode)
    },
    use3pieces = FALSE,
    unpackArgs = TRUE
)

model2 &lt;- nimbleModel(
    nimbleCode(
    {
        flat_normal_priors(mu, beta, gamma)
    }
    ))

## show code from expansion of macro
model2$getCode()
## The result should be:
## {
##    mu ~ dnorm(0, sd = 1000)
##    beta ~ dnorm(0, sd = 1000)
##    gamma ~ dnorm(0, sd = 1000)
## }

## Example 3: Macro that modifies constants
new_constant &lt;- buildMacro(
   function(stoch, LHS, RHS, modelInfo, .env) {
     # number of elements
     n &lt;- as.numeric(length(modelInfo$constants[[deparse(LHS)]]))
     code &lt;- substitute({
       for (i in 1:N){
         L[i] ~ dnorm(mu[i], 1)
       }
     }, list(L = LHS, N = n))

     # Add a new constant mu
     modelInfo$constants$mu &lt;- rnorm(n, 0, 1)

     list(code = code, modelInfo = modelInfo)
   },
   use3pieces = TRUE,
   unpackArgs = TRUE
)

const &lt;- list(y = rnorm(10))
code &lt;- nimbleCode({
 y ~ new_constant()
})

mod &lt;- nimbleModel(code = code, constants=const)
mod$getCode()
mod$getConstants() # new constant is here
</code></pre>

<hr>
<h2 id='buildMCEM'>Builds an MCEM algorithm for a given NIMBLE model</h2><span id='topic+buildMCEM'></span>

<h3>Description</h3>

<p>Takes a NIMBLE model (with some missing data, aka random effects or latent
state nodes) and builds a Monte Carlo Expectation Maximization (MCEM)
algorithm for maximum likelihood estimation. The user can specify which
latent nodes are to be integrated out in the E-Step, or default choices will
be made based on model structure. All other stochastic non-data nodes will be
maximized over. The E-step is done with a sample from a nimble MCMC
algorithm. The M-step is done by a call to <code>optim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMCEM(
  model,
  paramNodes,
  latentNodes,
  calcNodes,
  calcNodesOther,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildMCEM_+3A_model">model</code></td>
<td>
<p>a NIMBLE model object, either compiled or uncompiled.</p>
</td></tr>
<tr><td><code id="buildMCEM_+3A_paramnodes">paramNodes</code></td>
<td>
<p>a character vector of names of parameter nodes in the
model; defaults are provided by <code><a href="#topic+setupMargNodes">setupMargNodes</a></code>.
Alternatively, <code>paramNodes</code> can be a list in the format returned by
<code>setupMargNodes</code>, in which case <code>latentNodes</code>, <code>calcNodes</code>,
and <code>calcNodesOther</code> are not needed (and will be ignored).</p>
</td></tr>
<tr><td><code id="buildMCEM_+3A_latentnodes">latentNodes</code></td>
<td>
<p>a character vector of names of unobserved (latent) nodes
to marginalize (sum or integrate) over; defaults are provided by
<code><a href="#topic+setupMargNodes">setupMargNodes</a></code> (as the <code>randomEffectsNodes</code> in its
return list).</p>
</td></tr>
<tr><td><code id="buildMCEM_+3A_calcnodes">calcNodes</code></td>
<td>
<p>a character vector of names of nodes for calculating
components of the full-data likelihood that involve <code>latentNodes</code>;
defaults are provided by <code><a href="#topic+setupMargNodes">setupMargNodes</a></code>. There may be
deterministic nodes between <code>paramNodes</code> and <code>calcNodes</code>. These
will be included in calculations automatically and thus do not need to be
included in <code>calcNodes</code> (but there is no problem if they are).</p>
</td></tr>
<tr><td><code id="buildMCEM_+3A_calcnodesother">calcNodesOther</code></td>
<td>
<p>a character vector of names of nodes for calculating
terms in the log-likelihood that do not depend on any <code>latentNodes</code>,
and thus are not part of the marginalization, but should be included for
purposes of finding the MLE. This defaults to stochastic nodes that depend
on <code>paramNodes</code> but are not part of and do not depend on
<code>latentNodes</code>. There may be deterministic nodes between
<code>paramNodes</code> and <code>calcNodesOther</code>. These will be included in
calculations automatically and thus do not need to be included in
<code>calcNodesOther</code> (but there is no problem if they are).</p>
</td></tr>
<tr><td><code id="buildMCEM_+3A_control">control</code></td>
<td>
<p>a named list for providing additional settings used in MCEM.
See <code>control</code> section below.</p>
</td></tr>
<tr><td><code id="buildMCEM_+3A_...">...</code></td>
<td>
<p>provided only as a means of checking if a user is using the
deprecated interface to 'buildMCEM' in nimble versions &lt; 1.2.0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>buildMCEM</code> is a nimbleFunction that creates an MCEM algorithm
for a model and choices (perhaps default) of nodes in different roles in
the model. The MCEM can then be compiled for fast execution with a compiled model.
</p>
<p>Note that <code>buildMCEM</code> was re-written for nimble version 1.2.0 and is not
backward-compatible with previous versions. The new version is considered to
be in beta testing.
</p>
<p>Denote data by Y, latent states (or missing data) by X, and parameters by T.
MCEM works by the following steps, starting from some T:
</p>

<ol>
<li><p> Draw a sample of size M from P(X | Y, T) using MCMC.
</p>
</li>
<li><p> Update T to be the maximizer of E[log P(X, Y | T)] where the
expectation is approximated as a Monte Carlo average over the sample from step(1)
</p>
</li>
<li><p> Repeat until converged.
</p>
</li></ol>

<p>The default version of MCEM is the ascent-based MCEM of Caffo et al. (2015).
This attempts to update M when necessary to ensure that step 2 really moves
uphill given that it is maximizing a Monte Carlo approximation and could
accidently move downhill on the real surface of interest due to Monte Carlo
error. The main tuning parameters include <code>alpha</code>, <code>beta</code>, <code>gamma</code>,
<code>Mfactor</code>, <code>C</code>, and <code>tol</code> (tolerance).
</p>
<p>If the model supports derivatives via nimble's automatic differentiation (AD)
(and <code>buildDerivs=TRUE</code> in <code>nimbleModel</code>), the maximization step
can use gradients from AD. You must manually set <code>useDerivs=FALSE</code> in
the control list if derivatives aren't supported or if you don't want to use
them.
</p>
<p>In the ascent-based method, after maximization in step 2, the Monte Carlo
standard error of the uphill movement is estimated. If the standardized
uphill step is bigger than 0 with Type I error rate <code>alpha</code>, the
iteration is accepted and the algorithm continues. Otherwise, it is not
certain that step 2 really moved uphill due to Monte Carlo error, so the MCMC
sample size <code>M</code> is incremented by a fixed factor (e.g. 0.33 or 0.5, called
<code>Mfactor</code> in the control list), the additional samples are added by
continuing step 1, and step 2 is tried again. If the Monte Carlo noise still
overwhelms the magnitude of uphill movement, the sample size is increased
again, and so on. <code>alpha</code> should be between 0 and 0.5. A larger value
than usually used for inference is recommended so that there is an easy
threshold to determine uphill movement, which avoids increasing <code>M</code>
prematurely. <code>M</code> will never be increased above <code>maxM</code>.
</p>
<p>Convergence is determined in a similar way. After a definite move uphill, we
determine if the uphill increment is less than <code>tol</code>, with Type I error
rate gamma. (But if <code>M</code> hits a maximum value, the convergence criterion
changes. See below.)
</p>
<p><code>beta</code> is used to help set <code>M</code> to a minimal level based on previous
iterations. This is a desired Type II error rate, assuming an uphill move
and standard error based on the previous iteration. Set <code>adjustM=FALSE</code>
in the control list if you don't want this behavior.
</p>
<p>There are some additional controls on convergence for practical purposes. Set
<code>C</code> in the control list to be the number of times the convergence
criterion mut be satisfied in order to actually stop. E.g setting <code>C=2</code>
means there will always be a restart after the first convergence.
</p>
<p>One problem that can occur with ascent-based MCEM is that the final iteration
can be very slow if M must become very large to satisfy the convergence
criterion. Indeed, if the algorithm starts near the MLE, this can occur. Set
<code>maxM</code> in the control list to set the MCMC sample size that should never
be exceeded.
</p>
<p>If <code>M==maxM</code>, a softer convergence criterion is used. This second
convergence criterion is to stop if we can't be sure we moved uphill using
Type I error rate delta. This is a soft criterion because for small delta,
Type II errors will be common (e.g. if we really did move uphill but can't be
sure from the Monte Carlo sample), allowing the algorithm to terminate. One
can continue the algorithm from where it stopped, so it is helpful to not
have it get stuck when having a very hard time with the first (stricter)
convergence criterion.
</p>
<p>All of <code>alpha</code>, <code>beta</code>, <code>delta</code>, and <code>gamma</code> are utilized
based on asymptotic arguments but in practice must be chosen heuristically.
In other words, their theoretical basis does not exactly yield practical
advice on good choices for efficiency and accuracy, so some trial and error
will be needed.
</p>
<p>It can also be helpful to set a minimum and maximum of allowed iterations (of
steps 1 and 2 above). Setting <code>minIter&gt;1</code> in the control list can
sometimes help avoid a false convergence on the first iteration by forcing at
least one more iteration. Setting <code>maxIter</code> provides a failsafe on a
stuck run.
</p>
<p>If you don't want the ascent-based method at all and simply want to run a set
of iterations, set <code>ascent=FALSE</code> in the control list. This will use the
second (softer) convergence criterion.
</p>
<p>Parameters to be maximized will by default be handled in an unconstrained
parameter space, transformed if necessary by a
<code><a href="#topic+parameterTransform">parameterTransform</a></code> object. In that case, the default
<code><a href="stats.html#topic+optim">optim</a></code> method will be &quot;BFGS&quot; and can can be changed by setting
<code>optimMehod</code> in the control list. Set <code>useTransform=FALSE</code> in the
control list if you don't want the parameters transformed. In that case the
default <code>optimMethod</code> will be &quot;L-BFGS-B&quot; if there are any actual
constraints, and you can provide a list of <code>boxConstraints</code> in the
control list. (Constraints may be determined by priors written in the model
for parameters, even though their priors play no other role in MLE. E.g.
<code>sigma ~ halfflat()</code> indicates <code>sigma &gt; 0</code>).
</p>
<p>Most of the control list elements can be overridden when calling the
<code>findMLE</code> method. The <code>findMLE</code> argument <code>continue=TRUE</code>
results in attempting to continue the algorithm where the previous call
finished, including whatever settings were in use.
</p>
<p>See <code><a href="#topic+setupMargNodes">setupMargNodes</a></code> (which is called with the given arguments
for <code>paramNodes</code>, <code>calcNodes</code>, and <code>calcNodesOther</code>; and with
<code>allowDiscreteLatent=TRUE</code>, <code>randomEffectsNodes=latentNodes</code>, and
<code>check=check</code>) for more about how the different groups of nodes are
determined. In general, you can provide none, one, or more of the different
kinds of nodes and <code>setupMargNodes</code> will try to determine the others in
a sensible way. However, note that this cannot work for all ways of writing a
model. One key example is that if random (latent) nodes are written as
top-level nodes (e.g. following <code>N(0,1)</code>), they appear structurally to
be parameters and you must tell <code>buildMCEM</code> that they are
<code>latentNodes</code>. The various &quot;Nodes&quot; arguments will all be passed through
<code>model$expandNodeNames</code>, allowing for example simply &quot;x&quot; to be provided
when there are many nodes within &quot;x&quot;.
</p>
<p>Estimating the Monte Carlo standard error of the uphill step is not trivial
because the sample was obtained by MCMC and so likely is autocorrelated. This
is done by calling whatever function in R's global environment is called
&quot;MCEM_mcse&quot;, which is required to take two arguments: <code>samples</code> (which
will be a vector of the differences in log(P(Y, X | T)) between the new and
old values of T, across the sample of X) and <code>m</code>, the sample size. It
must return an estimate of the standard error of the mean of the sample.
NIMBLE provides a default version (exported from the package namespace),
which calls <code>mcmcse::mcse</code> with method &quot;obm&quot;. Simply provide a different
function with this name in your R session to override NIMBLE's default.
</p>


<h3>Control list details</h3>

<p>The control list accepts the following named elements:
</p>

<ul>
<li> <p><code>initM</code> initial MCMC sample size, <code>M</code>. Default=1000.
</p>
</li>
<li> <p><code>Mfactor</code> Factor by which to increase MCMC sample size when step 2
results in noise overwhelming the uphill movement. The new <code>M</code> will be
<code>1+Mfactor)*M</code> (rounded up). <code>Mfactor</code> is <code>1/k</code> of Caffo et
al. (2015). Default=1/3.
</p>
</li>
<li> <p><code>maxM</code> Maximum allowed value of <code>M</code> (see above). Default=<code>initM*20</code>.
</p>
</li>
<li> <p><code>burnin</code> Number of burn-in iterations for the MCMC in step 1. Note
that the initial states of one MCMC will be the last states from the previous
MCMC, so they will often be good initial values after multiple iterations. Default=500.
</p>
</li>
<li> <p><code>thin</code> Thinning interval for the MCMC in step 1. Default=1.
</p>
</li>
<li> <p><code>alpha</code> Type I error rate for determining when step 2 has moved
uphill. See above. Default=0.25.
</p>
</li>
<li> <p><code>beta</code> Used for determining a minimal value of $M$ based on
previous iteration, if <code>adjustM</code> is <code>TRUE</code>. <code>beta</code> is a desired Type
II error rate for determining uphill moves. Default=0.25.
</p>
</li>
<li> <p><code>delta</code> Type I error rate for the soft convergence approach
(second approach above). Default=0.25.
</p>
</li>
<li> <p><code>gamma</code> Type I error rate for determining when step 2 has moved
less than <code>tol</code> uphill, in which case ascent-based convergence is
achieved (first approach above). Default=0.05.
</p>
</li>
<li> <p><code>buffer</code> A small amount added to lower box constraints and
substracted from upper box constraints for all parameters, relevant only if
<code>useTransform=FALSE</code> and some parameters do have <code>boxConstraints</code>
set or have bounds that can be determined from the model. Default=1e-6.
</p>
</li>
<li> <p><code>tol</code> Ascent-based convergence tolerance. Default=0.001.
</p>
</li>
<li> <p><code>ascent</code> Logical to determine whether to use the ascent-based
method of Caffo et al. Default=TRUE.
</p>
</li>
<li> <p><code>C</code> Number of convergences required to actually stop the
algorithm. Default = 1.
</p>
</li>
<li> <p><code>maxIter</code> Maximum number of MCEM iterations to run.
</p>
</li>
<li> <p><code>minIter</code> Minimum number of MCEM iterations to run.
</p>
</li>
<li> <p><code>adjustM</code> Logical indicating whether to see if M needs to be
increased based on statistical power argument in each iteration (using
<code>beta</code>). Default=TRUE.
</p>
</li>
<li> <p><code>verbose</code> Logical indicating whether verbose output is desired.
Default=TRUE.
</p>
</li>
<li> <p><code>MCMCprogressBar</code> Logical indicating whether MCMC progress bars
should be shown for every iteration of step 1. This argument is passed to
<code>configureMCMC</code>, or to <code>config</code> if provided. Default=TRUE.
</p>
</li>
<li> <p><code>derivsDelta</code> If AD derivatives are not used, then the method
<code>vcov</code> must use finite difference derivatives to implement the method of
Louis (1982). The finite differences will be <code>delta</code> or <code>delta/2</code>
for various steps. This is the same for all dimensions. Default=0.0001.
</p>
</li>
<li> <p><code>mcmcControl</code> This is passed to <code>configureMCMC</code>, or
<code>config</code> if provided, as the <code>control</code> argument. i.e.
<code>control=mcmcControl</code>.
</p>
</li>
<li> <p><code>boxContrainst</code> List of box constraints for the nodes that will be
maximized over, only relevant if <code>useTransform=FALSE</code> and
<code>forceNoConstraints=FALSE</code> (and ignored otherwise). Each constraint is a
list in which the first element is a character vector of node names to which
the constraint applies and the second element is a vector giving the lower
and upper limits. Limits of <code>-Inf</code> or <code>Inf</code> are allowed. Any nodes
that are not given constrains will have their constraints automatically
determined by NIMBLE. See above. Default=list().
</p>
</li>
<li> <p><code>forceNoConstraints</code> Logical indicating whether to force ignoring
constraints even if they might be necessary. Default=FALSE.
</p>
</li>
<li> <p><code>useTransform</code> Logical indicating whether to use a parameter
transformation (see <code><a href="#topic+parameterTransform">parameterTransform</a></code>) to create an unbounded
parameter space for the paramNodes. This allows unconstrained maximization
algorithms to be used. Default=TRUE.
</p>
</li>
<li> <p><code>check</code> Logical passed as the <code>check</code> argument to
<code><a href="#topic+setupMargNodes">setupMargNodes</a></code>. Default=TRUE.
</p>
</li>
<li> <p><code>useDerivs</code> Logical indicating whether to use AD. If TRUE, the
model must have been build with 'buildDerivs=TRUE'. It is not automatically
determined from the model whether derivatives are supported. Default=TRUE.
</p>
</li>
<li> <p><code>config</code> Function to create the MCMC configuration used for step
1. The MCMC configuration is created by calling
</p>
<pre>config(model, nodes = latentNodes, monitors = latentNodes,
thin = thinDefault, control = mcmcControl, print = FALSE) </pre>
<p>The default for <code>config</code> (if it is missing) is <code>configureMCMC</code>,
which is nimble's general default MCMC configuration function.
</p>
</li></ul>



<h3>Methods in the returned algorithm</h3>

<p>The object returned by <code>buildMCEM</code> is a nimbleFunction object with the following methods
</p>

<ul>
<li> <p><code>findMLE</code> is the main method of interest, launching the MCEM
algorithm. It takes the following arguments:
</p>

<ul>
<li> <p><code>pStart</code>. Vector of initial parameter values. If omitted, the
values currently in the model object are used.
</p>
</li>
<li> <p><code>returnTrans</code>. Logical indicating whether to return parameters
in the transformed space, if a parameter transformation is in use. Default=FALSE.
</p>
</li>
<li> <p><code>continue</code>. Logical indicating whether to continue the MCEM
from where the last call stopped. In addition, if TRUE, any other control
setting provided in the last call will be used again. If FALSE, all
control settings are reset to the values provided when <code>buildMCEM</code>
was called. Any control settings provided in the same call as
<code>continue=TRUE</code> will over-ride these behaviors and be used in the
continued run.
</p>
</li>
<li><p> All run-time control settings available in the <code>control</code> list
for <code>buildMCEM</code> (except for <code>buffer</code>, <code>boxConstraints</code>,
<code>forceNoConstraints</code>, <code>useTransform</code>, and <code>useDerivs</code>) are
accepted as individual arguments to over-ride the values provided in the
<code>control</code> list.
</p>
</li></ul>

<p><code>findMLE</code> returns on object of class <code>optimResultNimbleList</code> with
the results of the final optimization of step 2. The <code>par</code> element of
this list is the vector of maximum likelihood (MLE) parameters.
</p>
</li>
<li> <p><code>vcov</code> computes the approximate variance-covariance matrix of the MLE using
the method of Louis (1982). It takes the following arguments:
</p>

<ul>
<li> <p><code>params</code>. Vector of parameters at which to compute the
Hessian matrix used to obtain the <code>vcov</code> result. Typically this
will be <code>MLE$par</code>, if <code>MLE</code> is the output of <code>findMLE</code>.
</p>
</li>
<li> <p><code>trans</code>. Logical indicating whether <code>params</code> is on the
transformed prameter scale, if a parameter transformation is in use.
Typically this should be the same as the <code>returnTrans</code> argument to
<code>findMLE</code>. Default=FALSE.
</p>
</li>
<li> <p><code>returnTrans</code>. Logical indicting whether the <code>vcov</code>
result should be for the transformed parameter space. Default matches
<code>trans</code>.
</p>
</li>
<li> <p><code>M</code>. Number of MCMC samples to obtain if
<code>resetSamples=TRUE</code>. Default is the final value of <code>M</code> from
the last call to <code>findMLE</code>. It can be helpful to increase <code>M</code>
to obtain a more accurate <code>vcov</code> result (i.e. with less Monte Carlo
noise).
</p>
</li>
<li> <p><code>resetSamples</code>. Logical indicating whether to generate a new
MCMC sample from P(X | Y, T), where T is <code>params</code>. If FALSE, the
last sample from <code>findMLE</code> will be used. If MLE convergence was
reasonable, this sample can be used. However, if the last MCEM step made
a big move in parameter space (e.g. if convergence was not achieved),
the last MCMC sample may not be accurate for obtaining <code>vcov</code>. Default=FALSE.
</p>
</li>
<li> <p><code>atMLE</code>. Logical indicating whether you believe the
<code>params</code> represents the MLE. If TRUE, one part of the computation
will be skipped because it is expected to be 0 at the MLE. If there are
parts of the model that are not connected to the latent nodes, i.e. of
<code>calcNodesOther</code> is not empty, then <code>atMLE</code> will be ignored
and set to FALSE. Default=FALSE. It is not really worth using TRUE
unless you are confident and the time saving is meaningful, which is not
very likely. In other words, this argument is provided for technical
completeness.
</p>
</li></ul>

<p><code>vcov</code> returns a matrix that is the inverse of the negative Hessian of
the log likelihood surface, i.e. the usual asymptotic approximation of the
parameter variance-covariance matrix.
</p>
</li>
<li> <p><code>doMCMC</code>. This method runs the MCMC to sample from P(X | Y, T).
One does not need to call this, as it is called via the MCEM algorithm in
<code>findMLE</code>. This method is provided for users who want to use the MCMC
for latent states directly. Samples should be retrieved by
<code>as.matrix(MCEM$mvSamples)</code>, where <code>MCEM</code> is the (compiled or
uncompiled) MCEM algorithm object. This method takes the following arguments:
</p>

<ul>
<li> <p><code>M</code>. MCMC sample size.
</p>
</li>
<li> <p><code>thin</code>. MCMC thinning interval.
</p>
</li>
<li> <p><code>reset</code>. Logical indicating whether to reset the MCMC (passed
to the MCMC <code>run</code> method as <code>reset</code>).
</p>
</li></ul>

</li>
<li> <p><code>transform</code> and <code>inverseTransform</code>. Convert a parameter
vector to an unconstrained parameter space and vice-versa, if
<code>useTransform=TRUE</code> in the call to <code>buildDerivs</code>.
</p>
</li>
<li> <p><code>resetControls</code>. Reset all control arguments to the values
provided in the call to <code>buildMCEM</code>. The user does not normally need to
call this.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Perry de Valpine, Clifford Anderson-Bergman and Nicholas Michaud
</p>


<h3>References</h3>

<p>Caffo, Brian S., Wolfgang Jank, and Galin L. Jones (2005). Ascent-based Monte Carlo expectation-maximization.  <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 67(2), 235-251.
</p>
<p>Louis, Thomas A  (1982). Finding the Observed Information Matrix When Using the EM Algorithm. <em>Journal of the Royal Statistical Society. Series B (Statistical Methodology)</em>, 44(2), 226-233.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pumpCode &lt;- nimbleCode({
 for (i in 1:N){
     theta[i] ~ dgamma(alpha,beta);
     lambda[i] &lt;- theta[i]*t[i];
     x[i] ~ dpois(lambda[i])
 }
 alpha ~ dexp(1.0);
 beta ~ dgamma(0.1,1.0);
})

pumpConsts &lt;- list(N = 10,
              t = c(94.3, 15.7, 62.9, 126, 5.24,
                31.4, 1.05, 1.05, 2.1, 10.5))

pumpData &lt;- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))

pumpInits &lt;- list(alpha = 1, beta = 1,
             theta = rep(0.1, pumpConsts$N))
pumpModel &lt;- nimbleModel(code = pumpCode, name = 'pump', constants = pumpConsts,
                         data = pumpData, inits = pumpInits,
                         buildDerivs=TRUE)

pumpMCEM &lt;- buildMCEM(model = pumpModel)

CpumpModel &lt;- compileNimble(pumpModel)

CpumpMCEM &lt;- compileNimble(pumpMCEM, project=pumpModel)

MLE &lt;- CpumpMCEM$findMLE()
vcov &lt;- CpumpMCEM$vcov(MLE$par)


## End(Not run)
</code></pre>

<hr>
<h2 id='buildMCMC'>Create an MCMC object from a NIMBLE model, or an MCMC configuration object</h2><span id='topic+buildMCMC'></span>

<h3>Description</h3>

<p>First required argument, which may be of class <code>MCMCconf</code> (an MCMC configuration object), or inherit from class <code>modelBaseClass</code> (a NIMBLE model object).  Returns an uncompiled executable MCMC object.  See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMCMC(conf, print, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildMCMC_+3A_conf">conf</code></td>
<td>
<p>Either an MCMC configuration object of class <code>MCMCconf</code> or a NIMBLE model object. An MCMC configuration object would be returned from <code>configureMCMC</code> and contains information on the model, samplers, monitors, and thinning intervals to be used. Alternatively, <code>conf</code> may a NIMBLE model object, in which case default configuration from calling <code>configureMCMC(model, ...l)</code> will be used.</p>
</td></tr>
<tr><td><code id="buildMCMC_+3A_print">print</code></td>
<td>
<p>A logical argument, specifying whether to print details of the MCMC samplers and monitors.</p>
</td></tr>
<tr><td><code id="buildMCMC_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>configureMCMC</code> if <code>conf</code> is a NIMBLE model object (see <code>help(configureMCMC)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling buildMCMC(conf) will produce an uncompiled MCMC object. The object contains several methods, including the main <code>run</code> function for running the MCMC, a <code>getTimes</code> function for determining the computation time spent in each sampler (see 'getTimes' section below), and functions related to WAIC (<code>getWAIC</code>, <code>getWAICdetails</code>, <code>calculateWAIC</code> (see <code>help(waic)</code>).
</p>
<p>The uncompiled <code>run</code> function will have arguments:
</p>
<p><code>niter</code>: The number of iterations to run the MCMC.
</p>
<p><code>nburnin</code>: Number of initial, pre-thinning, MCMC iterations to discard (default = 0).
</p>
<p><code>thin</code>: The thinning interval for the <code>monitors</code> that were specified in the MCMC configuration.  If this argument is provided at MCMC runtime, it will take precedence over the <code>thin</code> interval that was specified in the MCMC configuration.  If omitted, the <code>thin</code> interval from the MCMC configuration will be used.
</p>
<p><code>thin2</code>: The thinning interval for the second set of monitors (<code>monitors2</code>) that were specified in the MCMC configuration.  If this argument is provided at MCMC runtime, it will take precedence over the <code>thin2</code> interval that was specified in the MCMC configuration.  If omitted, the <code>thin2</code> interval from the MCMC configuration will be used.
</p>
<p><code>reset</code>: Boolean specifying whether to reset the internal MCMC sampling algorithms to their initial state (in terms of self-adapting tuning parameters), and begin recording posterior sample chains anew. Specifying <code>reset = FALSE</code> allows the MCMC algorithm to continue running from where it left off, appending additional posterior samples to the already existing sample chains. Generally, <code>reset = FALSE</code> should only be used when the MCMC has already been run (default = TRUE).
</p>
<p><code>resetMV</code>: Boolean specifying whether to begin recording posterior sample chains anew. This argument is only considered when using <code>reset = FALSE</code>.  Specifying <code>reset = FALSE, resetMV = TRUE</code> allows the MCMC algorithm to continue running from where it left off, but without appending the new posterior samples to the already existing samples, i.e. all previously obtained samples will be erased. This option can help reduce memory usage during burn-in (default = FALSE).
</p>
<p><code>resetWAIC</code>: Boolean specifying whether to reset the WAIC summary statistics to their initial states and thereby begin the WAIC calculation anew (default = TRUE). Specifying <code>resetWAIC = FALSE</code> allows the WAIC calculation to continue running from where it left off. 
</p>
<p><code>initializeModel</code>: Boolean specifying whether to run the initializeModel routine on the underlying model object, prior to beginning MCMC sampling (default = TRUE).
</p>
<p><code>chain</code>: Integer specifying the MCMC chain number.  The chain number is passed to each MCMC sampler's before_chain and after_chain methods.  The value for this argument is specified automatically from invocation via runMCMC, and genernally need not be supplied when calling mcmc$run (default = 1).
<code>time</code>: Boolean specifying whether to record runtimes of the individual internal MCMC samplers.  When <code>time = TRUE</code>, a vector of runtimes (measured in seconds) can be extracted from the MCMC using the method <code>mcmc$getTimes()</code> (default = FALSE).
</p>
<p><code>progressBar</code>: Boolean specifying whether to display a progress bar during MCMC execution (default = TRUE).  The progress bar can be permanently disabled by setting the system option <code>nimbleOptions(MCMCprogressBar = FALSE)</code>.
</p>
<p>Samples corresponding to the <code>monitors</code> and <code>monitors2</code> from the MCMCconf are stored into the interval variables <code>mvSamples</code> and <code>mvSamples2</code>, respectively.
These may be accessed and converted into R matrix or list objects via:
<code>as.matrix(mcmc$mvSamples)</code>
<code>as.list(mcmc$mvSamples)</code>
<code>as.matrix(mcmc$mvSamples2)</code>
<code>as.list(mcmc$mvSamples2)</code>
</p>
<p>The uncompiled MCMC function may be compiled to a compiled MCMC object, taking care to compile in the same project as the R model object, using:
<code>Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)</code>
</p>
<p>The compiled object will function identically to the uncompiled object except acting on the compiled model object.
</p>


<h3>Timing the MCMC samplers</h3>

<p>If you want to obtain the computation time spent in each sampler, you can set <code>time=TRUE</code> as a run-time argument to <code>run()</code> and then use the method <code>getTimes()</code> to obtain the times.
</p>


<h3>Calculating WAIC</h3>

<p>Please see <code>help(waic)</code> for more information.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>References</h3>

<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and widely applicable information criterion in singular learning theory. <em>Journal of Machine Learning Research</em> 11: 3571-3594.
</p>
<p>Gelman, A., Hwang, J. and Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. <em>Statistics and Computing</em> 24(6): 997-1016.
</p>
<p>Ariyo, O., Quintero, A., Munoz, J., Verbeke, G. and Lesaffre, E. (2019). Bayesian model selection in linear mixed models for longitudinal data. <em>Journal of Applied Statistics</em> 47: 890-913.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configureMCMC">configureMCMC</a></code> <code><a href="#topic+runMCMC">runMCMC</a></code> <code><a href="#topic+nimbleMCMC">nimbleMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
code &lt;- nimbleCode({
    mu ~ dnorm(0, 1)
    x ~ dnorm(mu, 1)
    y ~ dnorm(x, 1)
})
Rmodel &lt;- nimbleModel(code, data = list(y = 0))
conf &lt;- configureMCMC(Rmodel, monitors = c('mu', 'x'), enableWAIC = TRUE)
Rmcmc &lt;- buildMCMC(conf)
Cmodel &lt;- compileNimble(Rmodel)
Cmcmc &lt;- compileNimble(Rmcmc, project=Rmodel)

## Running the MCMC with `run`
Cmcmc$run(10000)
samples &lt;- as.matrix(Cmcmc$mvSamples)
samplesAsList &lt;- as.list(Cmcmc$mvSamples)
head(samples)

## Getting WAIC
waicInfo &lt;- Cmcmc$getWAIC()
waicInfo$WAIC
waicInfo$pWAIC

## Timing the samplers (must set `time = TRUE` when running the MCMC)
Cmcmc$run(10000, time = TRUE)
Cmcmc$getTimes()

## End(Not run)

</code></pre>

<hr>
<h2 id='calculateWAIC'>Calculating WAIC using an offline algorithm</h2><span id='topic+calculateWAIC'></span>

<h3>Description</h3>

<p>In addition to the core online algorithm, NIMBLE implements an offline
WAIC algorithm that can be computed on the results of an MCMC. In contrast
to NIMBLE's built-in online WAIC, offline WAIC can compute only conditional
WAIC and does not allow for grouping data nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWAIC(mcmc, model, nburnin = 0, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateWAIC_+3A_mcmc">mcmc</code></td>
<td>
<p>An MCMC object (compiled or uncompiled) or matrix or dataframe
of MCMC samples as the first argument of <code>calculateWAIC</code>.</p>
</td></tr>
<tr><td><code id="calculateWAIC_+3A_model">model</code></td>
<td>
<p>A model (compiled or uncompiled) as the second argument of
<code>calculateWAIC</code>. Only required if <code>mcmc</code> is a matrix/dataframe
of samples.</p>
</td></tr>
<tr><td><code id="calculateWAIC_+3A_nburnin">nburnin</code></td>
<td>
<p>The number of pre-thinning MCMC samples to remove from the beginning
of the posterior samples for offline WAIC calculation via <code>calculateWAIC</code>
(default = 0). These samples are discarded in addition to any burn-in specified when
running the MCMC.</p>
</td></tr>
<tr><td><code id="calculateWAIC_+3A_thin">thin</code></td>
<td>
<p>Thinning factor interval to apply to the samples for offline
WAIC calculation using <code>calculateWAIC</code> (default = 1,
corresponding to no thinning).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ability to calculate WAIC post hoc after all MCMC sampling has been done
has certain advantages (e.g., allowing a user to calculate WAIC from MCMC 
chains run separately) in addition to providing compatibility with versions
of NIMBLE before 0.12.0. This functionality includes the ability to call
the <code>calculateWAIC</code> function on an MCMC object or matrix of samples
after running an MCMC and without setting up the MCMC initially to use WAIC.
</p>
<p>Important: The necessary variables to compute WAIC (all stochastic parent
nodes of the data nodes) must have been monitored when setting up the MCMC.
</p>
<p>Also note that while the <code>model</code> argument can be either a compiled or
uncompiled model, the model must have been compiled prior to calling
<code>calculateWAIC</code>.
</p>
<p>See <code>help(waic)</code> for details on using NIMBLE's recommended online
algorithm for WAIC.
</p>


<h3>Offline WAIC (WAIC computed after MCMC sampling)</h3>

<p>As an alternative to online WAIC, NIMBLE also provides a function,
<code>calculateWAIC</code>, that can be called on an MCMC object or a matrix of
samples, after running an MCMC. This function does not require that one
set <code>enableWAIC = TRUE</code> nor <code>WAIC = TRUE</code> when calling
<code>runMCMC</code>. The function checks that the necessary variables were
monitored in the MCMC and returns an error if they were not. This function
behaves identically to the <code>calculateWAIC</code> method of an MCMC object.
Note that to use this function when using <code>nimbleMCMC</code> one would
need to build the model outside of <code>nimbleMCMC</code>.
</p>
<p>The <code>calculateWAIC</code> function requires either an MCMC object or a matrix
(or dataframe) of posterior samples plus a model object. In addition, one
can provide optional <code>burnin</code> and <code>thin</code> arguments.
</p>
<p>In addition, for compatibility with older versions of NIMBLE (prior to
v0.12.0), one can also use the <code>calculateWAIC</code> method of the MCMC
object to calculate WAIC after all sampling has been completed.
</p>
<p>The <code>calculateWAIC()</code> method accepts a single argument, <code>nburnin</code>,
equivalent to the <code>nburnin</code> argument of the <code>calculateWAIC</code>
function described above.
</p>
<p>The <code>calculateWAIC</code> method can only be used if the <code>enableWAIC</code> 
argument to <code>configureMCMC</code> or to <code>buildMCMC</code> is set to <code>TRUE</code>,
or if the NIMBLE option <code>enableWAIC</code> is set to <code>TRUE</code>.  If a user
attempts to call <code>calculateWAIC</code> without having set
<code>enableWAIC = TRUE</code> (either in the call to <code>configureMCMC</code>, or
<code>buildMCMC</code>, or as a NIMBLE option), an error will occur.  
</p>
<p>The <code>calculateWAIC</code> function and method calculate the WAIC based on
Equations 5, 12, and 13 in Gelman et al. (2014) (i.e., using <em>p</em>WAIC2).
</p>
<p>Note that there is not a unique value of WAIC for a model. The 
<code>calculateWAIC</code> function and method only provide the conditional WAIC,
namely the version of WAIC where all parameters directly involved in the
likelihood are treated as <code class="reqn">theta</code> for the purposes of Equation 5 from
Gelman et al. (2014). As a result, the user must set the MCMC monitors
(via the <code>monitors</code> argument) to include all stochastic nodes that
are parents of any data nodes; by default the MCMC monitors are only the
top-level nodes of the model. For more detail on the use of different
predictive distributions, see Section 2.5 from Gelman et al. (2014) or
Ariyo et al. (2019).
Also note that WAIC relies on a partition of the observations, i.e.,
'pointwise' prediction. In <code>calculateWAIC</code> the sum over log pointwise
predictive density values treats each data node as contributing a single
value to the sum. When a data node is multivariate, that data node contributes
a single value to the sum based on the joint density of the elements in the
node. Note that if one wants the WAIC calculation via <code>calculateWAIC</code>
to be based on the joint predictive density for each group of observations
(e.g., grouping the observations from each person or unit in a longitudinal
data context), one would need to use a multivariate distribution for the
observations in each group (potentially by writing a user-defined
distribution).
</p>
<p>For more control over and flexibility in how WAIC is calculated, see
<code>help(waic)</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua Hug and Christopher Paciorek
</p>


<h3>References</h3>

<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and
widely applicable information criterion in singular learning theory.
<em>Journal of Machine Learning Research</em> 11: 3571-3594.
</p>
<p>Gelman, A., Hwang, J. and Vehtari, A. (2014). Understanding predictive
information criteria for Bayesian models.
<em>Statistics and Computing</em> 24(6): 997-1016.
</p>
<p>Ariyo, O., Quintero, A., Munoz, J., Verbeke, G. and Lesaffre, E. (2019).
Bayesian model selection in linear mixed models for longitudinal data.
<em>Journal of Applied Statistics</em> 47: 890-913.
</p>
<p>Vehtari, A., Gelman, A. and Gabry, J. (2017). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em> 27: 1413-1432.
</p>
<p>Hug, J.E.  and Paciorek, C.J. (2021). A numerically stable online
implementation and exploration of WAIC through variations of the
predictive density, using NIMBLE. <em>arXiv e-print</em> &lt;arXiv:2106.13359&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+waic">waic</a></code> <code><a href="#topic+configureMCMC">configureMCMC</a></code>
<code><a href="#topic+buildMCMC">buildMCMC</a></code> <code><a href="#topic+runMCMC">runMCMC</a></code> <code><a href="#topic+nimbleMCMC">nimbleMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
  for(j in 1:J) {
    for(i in 1:n) 
      y[j, i] ~ dnorm(mu[j], sd = sigma)
    mu[j] ~ dnorm(mu0, sd = tau)
  }
  tau ~ dunif(0, 10)
  sigma ~ dunif(0, 10)
})
J &lt;- 5
n &lt;- 10
y &lt;- matrix(rnorm(J*n), J, n)
Rmodel &lt;- nimbleModel(code, constants = list(J = J, n = n), data = list(y = y),
                      inits = list(tau = 1, sigma = 1))

## Make sure the needed variables are monitored.
## Only conditional WAIC without data grouping is available via this approach.
conf &lt;- configureMCMC(Rmodel, monitors = c('mu', 'sigma'))
## Not run: 
Cmodel &lt;- compileNimble(Rmodel)
Rmcmc &lt;- buildMCMC(conf)
Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)
output &lt;- runMCMC(Cmcmc, niter = 1000)
calculateWAIC(Cmcmc)           # Can run on the MCMC object
calculateWAIC(output, Rmodel)  # Can run on the samples directly

## Apply additional burnin (additional to any burnin already done in the MCMC.
calculateWAIC(Cmcmc, burnin = 500)

## End(Not run)
</code></pre>

<hr>
<h2 id='CAR_calcNumIslands'>Calculate number of islands based on a CAR adjacency matrix.</h2><span id='topic+CAR_calcNumIslands'></span>

<h3>Description</h3>

<p>Calculate number of islands (distinct connected groups) based on a CAR adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAR_calcNumIslands(adj, num)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAR_calcNumIslands_+3A_adj">adj</code></td>
<td>
<p>vector of indices of the adjacent locations (neighbors) of each spatial location.  This is a sparse representation of the full adjacency matrix.</p>
</td></tr>
<tr><td><code id="CAR_calcNumIslands_+3A_num">num</code></td>
<td>
<p>vector giving the number of neighbors of each spatial location, with length equal to the total number of locations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAR-Normal">CAR-Normal</a></code>
</p>

<hr>
<h2 id='CAR-Normal'>The CAR-Normal Distribution</h2><span id='topic+CAR-Normal'></span><span id='topic+dcar_normal'></span><span id='topic+rcar_normal'></span>

<h3>Description</h3>

<p>Density function and random generation for the improper (intrinsic)
Gaussian conditional autoregressive (CAR) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcar_normal(
  x,
  adj,
  weights = adj/adj,
  num,
  tau,
  c = CAR_calcNumIslands(adj, num),
  zero_mean = 0,
  log = FALSE
)

rcar_normal(
  n = 1,
  adj,
  weights = adj/adj,
  num,
  tau,
  c = CAR_calcNumIslands(adj, num),
  zero_mean = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAR-Normal_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_adj">adj</code></td>
<td>
<p>vector of indices of the adjacent locations (neighbors) of each spatial location.  This is a sparse representation of the full adjacency matrix.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_weights">weights</code></td>
<td>
<p>vector of symmetric unnormalized weights associated with each pair of adjacent locations, of the same length as adj.  If omitted, all weights are taken to be one.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_num">num</code></td>
<td>
<p>vector giving the number of neighboring locations of each spatial location, with length equal to the total number of locations.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_tau">tau</code></td>
<td>
<p>scalar precision of the Gaussian CAR prior.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_c">c</code></td>
<td>
<p>integer number of constraints to impose on the improper density function.  If omitted, <code>c</code> is calculated as the number of disjoint groups of spatial locations in the adjacency structure, which implicitly assumes a first-order CAR process for each group. Note that <code>c</code> should be equal to the number of eigenvalues of the precision matrix that are zero. For example, if the neighborhood structure is based on a second-order Markov random field in one dimension then the matrix has two zero eigenvalues and in two dimensions it has three zero eigenvalues. See Rue and Held (2005) and the NIMBLE <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for more information.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_zero_mean">zero_mean</code></td>
<td>
<p>integer specifying whether to set the mean of all locations to zero during MCMC sampling of a node specified with this distribution in BUGS code (default <code>0</code>). This argument is used only in BUGS model code when specifying models in NIMBLE. If <code>0</code>, the overall process mean is included implicitly in the value of each location in a BUGS model; if <code>1</code>, then during MCMC sampling, the mean of all locations is set to zero at each MCMC iteration, and a separate intercept term should be included in the BUGS model. Note that centering during MCMC as implemented in NIMBLE follows the ad hoc approach of <span class="pkg">WinBUGS</span> and does not sample under the constraint that the mean is zero as discussed on p. 36 of Rue and Held (2005).  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="CAR-Normal_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When specifying a CAR distribution in BUGS model code, the <code>zero_mean</code> parameter should be specified as either <code>0</code> or <code>1</code> (rather than <code>TRUE</code> or <code>FALSE</code>).
</p>
<p>Note that because the distribution is improper, <code>rcar_normal</code> does not generate a sample from the distribution. However, as discussed in Rue and Held (2005), it is possible to generate a sample from the distribution under constraints imposed based on the eigenvalues of the precision matrix that are zero.
</p>


<h3>Value</h3>

<p><code>dcar_normal</code> gives the density, while <code>rcar_normal</code> returns the current process values, since this distribution is improper.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2015). <em>Hierarchical Modeling and Analysis for Spatial Data</em>, 2nd ed. Chapman and Hall/CRC.
</p>
<p>Rue, H. and L. Held (2005). <em>Gaussian Markov Random Fields</em>, Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="#topic+CAR-Proper">CAR-Proper</a>, <a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 3, 3, 4)
num &lt;- c(1, 2, 2, 1)
adj &lt;- c(2, 1,3, 2,4, 3)
weights &lt;- c(1, 1, 1, 1, 1, 1)
lp &lt;- dcar_normal(x, adj, weights, num, tau = 1)
</code></pre>

<hr>
<h2 id='CAR-Proper'>The CAR-Proper Distribution</h2><span id='topic+CAR-Proper'></span><span id='topic+dcar_proper'></span><span id='topic+rcar_proper'></span>

<h3>Description</h3>

<p>Density function and random generation for the proper
Gaussian conditional autoregressive (CAR) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcar_proper(
  x,
  mu,
  C = CAR_calcC(adj, num),
  adj,
  num,
  M = CAR_calcM(num),
  tau,
  gamma,
  evs = CAR_calcEVs3(C, adj, num),
  log = FALSE
)

rcar_proper(
  n = 1,
  mu,
  C = CAR_calcC(adj, num),
  adj,
  num,
  M = CAR_calcM(num),
  tau,
  gamma,
  evs = CAR_calcEVs3(C, adj, num)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAR-Proper_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_mu">mu</code></td>
<td>
<p>vector of the same length as <code>x</code>, specifying the mean for each spatial location.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_c">C</code></td>
<td>
<p>vector of the same length as <code>adj</code>, giving the weights associated with each pair of neighboring locations.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_adj">adj</code></td>
<td>
<p>vector of indices of the adjacent locations (neighbors) of each spatial location.  This is a sparse representation of the full adjacency matrix.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_num">num</code></td>
<td>
<p>vector giving the number of neighboring locations of each spatial location, with length equal to the number of locations.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_m">M</code></td>
<td>
<p>vector giving the diagonal elements of the conditional variance matrix, with length equal to the number of locations.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_tau">tau</code></td>
<td>
<p>scalar precision of the Gaussian CAR prior.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_gamma">gamma</code></td>
<td>
<p>scalar representing the overall degree of spatial dependence.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_evs">evs</code></td>
<td>
<p>vector of eigenvalues of the adjacency matrix implied by <code>C</code>, <code>adj</code>, and <code>num</code>.  This parameter should not be provided; it will always be calculated using the adjacency information.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="CAR-Proper_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>C</code> and <code>M</code> are omitted, then all weights are taken as one, and corresponding values of <code>C</code> and <code>M</code> are generated.
</p>
<p>The <code>C</code> and <code>M</code> parameters must jointly satisfy a symmetry constraint: that <code>M^(-1) %*% C</code> is symmetric, where <code>M</code> is a diagonal matrix and <code>C</code> is the full weight matrix that is sparsely represented by the parameter vector <code>C</code>.
</p>
<p>For a proper CAR model, the value of <code>gamma</code> must lie within the inverse minimum and maximum eigenvalues of <code>M^(-0.5) %*% C %*% M^(0.5)</code>, where <code>M</code> is a diagonal matrix and <code>C</code> is the full weight matrix.  These bounds can be calculated using the deterministic functions <code>carMinBound(C, adj, num, M)</code> and <code>carMaxBound(C, adj, num, M)</code>, or simultaneously using <code>carBounds(C, adj, num, M)</code>.  In the case where <code>C</code> and <code>M</code> are omitted (all weights equal to one), the bounds on gamma are necessarily (-1, 1).
</p>


<h3>Value</h3>

<p><code>dcar_proper</code> gives the density, and <code>rcar_proper</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B.P., and Gelfand, A.E. (2015). <em>Hierarchical Modeling and Analysis for Spatial Data</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="#topic+CAR-Normal">CAR-Normal</a>, <a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 3, 3, 4)
mu &lt;- rep(3, 4)
adj &lt;- c(2, 1,3, 2,4, 3)
num &lt;- c(1, 2, 2, 1)
 
## omitting C and M uses all weights = 1
dcar_proper(x, mu, adj = adj, num = num, tau = 1, gamma = 0.95)
 
## equivalent to above: specifying all weights = 1,
## then using as.carCM to generate C and M arguments
weights &lt;- rep(1, 6)
CM &lt;- as.carCM(adj, weights, num)
C &lt;- CM$C
M &lt;- CM$M
dcar_proper(x, mu, C, adj, num, M, tau = 1, gamma = 0.95)
 
## now using non-unit weights
weights &lt;- c(2, 2, 3, 3, 4, 4)
CM2 &lt;- as.carCM(adj, weights, num)
C2 &lt;- CM2$C
M2 &lt;- CM2$M
dcar_proper(x, mu, C2, adj, num, M2, tau = 1, gamma = 0.95)
</code></pre>

<hr>
<h2 id='carBounds'>Calculate bounds for the autocorrelation parameter of the <code>dcar_proper</code> distribution</h2><span id='topic+carBounds'></span>

<h3>Description</h3>

<p>Calculate the lower and upper bounds for the <code>gamma</code> parameter of the <code>dcar_proper</code> distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carBounds(C, adj, num, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="carBounds_+3A_c">C</code></td>
<td>
<p>vector of the same length as <code>adj</code>, giving the normalized weights associated with each pair of neighboring locations.</p>
</td></tr>
<tr><td><code id="carBounds_+3A_adj">adj</code></td>
<td>
<p>vector of indices of the adjacent locations (neighbors) of each spatial location.  This is a sparse representation of the full adjacency matrix.</p>
</td></tr>
<tr><td><code id="carBounds_+3A_num">num</code></td>
<td>
<p>vector giving the number of neighboring locations of each spatial location, with length equal to the number of locations.</p>
</td></tr>
<tr><td><code id="carBounds_+3A_m">M</code></td>
<td>
<p>vector giving the diagonal elements of the conditional variance matrix, with length equal to the number of locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bounds for gamma are the inverse of the minimum and maximum eigenvalues of: <code class="reqn">M^(-0.5) C M^(0.5)</code>.  The lower and upper bounds are returned in a numeric vector.
</p>


<h3>Value</h3>

<p>A numeric vector containing the bounds (minimum and maximum allowable values) for the <code>gamma</code> parameter of the <code>dcar_proper</code> distribution.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAR-Proper">CAR-Proper</a></code>, <code><a href="#topic+carMinBound">carMinBound</a></code>, <code><a href="#topic+carMaxBound">carMaxBound</a></code>
</p>

<hr>
<h2 id='carMaxBound'>Calculate the upper bound for the autocorrelation parameter of the <code>dcar_proper</code> distribution</h2><span id='topic+carMaxBound'></span>

<h3>Description</h3>

<p>Calculate the upper bound for the <code>gamma</code> parameter of the <code>dcar_proper</code> distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carMaxBound(C, adj, num, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="carMaxBound_+3A_c">C</code></td>
<td>
<p>vector of the same length as <code>adj</code>, giving the normalized weights associated with each pair of neighboring locations.</p>
</td></tr>
<tr><td><code id="carMaxBound_+3A_adj">adj</code></td>
<td>
<p>vector of indices of the adjacent locations (neighbors) of each spatial location.  This is a sparse representation of the full adjacency matrix.</p>
</td></tr>
<tr><td><code id="carMaxBound_+3A_num">num</code></td>
<td>
<p>vector giving the number of neighboring locations of each spatial location, with length equal to the number of locations.</p>
</td></tr>
<tr><td><code id="carMaxBound_+3A_m">M</code></td>
<td>
<p>vector giving the diagonal elements of the conditional variance matrix, with length equal to the number of locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bounds for <code>gamma</code> are the inverse of the minimum and maximum eigenvalues of <code class="reqn">M^(-0.5) C M^(0.5)</code>.
</p>


<h3>Value</h3>

<p>The upper bound (maximum allowable value) for the <code>gamma</code> parameter of the <code>dcar_proper</code> distribution.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAR-Proper">CAR-Proper</a></code>, <code><a href="#topic+carMinBound">carMinBound</a></code>, <code><a href="#topic+carBounds">carBounds</a></code>
</p>

<hr>
<h2 id='carMinBound'>Calculate the lower bound for the autocorrelation parameter of the <code>dcar_proper</code> distribution</h2><span id='topic+carMinBound'></span>

<h3>Description</h3>

<p>Calculate the lower bound for the <code>gamma</code> parameter of the <code>dcar_proper</code> distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carMinBound(C, adj, num, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="carMinBound_+3A_c">C</code></td>
<td>
<p>vector of the same length as <code>adj</code>, giving the normalized weights associated with each pair of neighboring locations.</p>
</td></tr>
<tr><td><code id="carMinBound_+3A_adj">adj</code></td>
<td>
<p>vector of indices of the adjacent locations (neighbors) of each spatial location.  This is a sparse representation of the full adjacency matrix.</p>
</td></tr>
<tr><td><code id="carMinBound_+3A_num">num</code></td>
<td>
<p>vector giving the number of neighboring locations of each spatial location, with length equal to the number of locations.</p>
</td></tr>
<tr><td><code id="carMinBound_+3A_m">M</code></td>
<td>
<p>vector giving the diagonal elements of the conditional variance matrix, with length equal to the number of locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bounds for <code>gamma</code> are the inverse of the minimum and maximum eigenvalues of: <code class="reqn">M^(-0.5) C M^(0.5)</code>.
</p>


<h3>Value</h3>

<p>The lower bound (minimum allowable value) for the <code>gamma</code> parameter of the <code>dcar_proper</code> distribution.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAR-Proper">CAR-Proper</a></code>, <code><a href="#topic+carMaxBound">carMaxBound</a></code>, <code><a href="#topic+carBounds">carBounds</a></code>
</p>

<hr>
<h2 id='Categorical'>The Categorical Distribution</h2><span id='topic+Categorical'></span><span id='topic+dcat'></span><span id='topic+rcat'></span>

<h3>Description</h3>

<p>Density and random generation for the categorical distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcat(x, prob, log = FALSE)

rcat(n = 1, prob)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Categorical_+3A_x">x</code></td>
<td>
<p>non-negative integer-value numeric value.</p>
</td></tr>
<tr><td><code id="Categorical_+3A_prob">prob</code></td>
<td>
<p>vector of probabilities, internally normalized to sum to one.</p>
</td></tr>
<tr><td><code id="Categorical_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Categorical_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the BUGS manual for mathematical details.
</p>


<h3>Value</h3>

<p><code>dcat</code> gives the density and <code>rcat</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probs &lt;- c(1/4, 1/10, 1 - 1/4 - 1/10)
x &lt;- rcat(n = 30, probs)
dcat(x, probs)

</code></pre>

<hr>
<h2 id='checkInterrupt'>Check for interrupt (e.g. Ctrl-C) during nimbleFunction execution. Part of the NIMBLE language.</h2><span id='topic+checkInterrupt'></span>

<h3>Description</h3>

<p>Check for interrupt (e.g. Ctrl-C) during nimbleFunction execution. Part of the NIMBLE language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkInterrupt()
</code></pre>


<h3>Details</h3>

<p>During execution of nimbleFunctions that take a long time, it is nice to occassionally check if the user has entered an interrupt and bail out of execution if so.  This function does that.  During uncompiled nimbleFunction execution, it does nothing.  During compiled execution, it calls R_checkUserInterrupt() of the R headers.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>

<hr>
<h2 id='ChineseRestaurantProcess'>The Chinese Restaurant Process Distribution</h2><span id='topic+ChineseRestaurantProcess'></span><span id='topic+dCRP'></span><span id='topic+rCRP'></span>

<h3>Description</h3>

<p>Density and random generation for the Chinese
Restaurant Process distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCRP(x, conc = 1, size, log = 0)

rCRP(n, conc = 1, size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ChineseRestaurantProcess_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="ChineseRestaurantProcess_+3A_conc">conc</code></td>
<td>
<p>scalar concentration parameter.</p>
</td></tr>
<tr><td><code id="ChineseRestaurantProcess_+3A_size">size</code></td>
<td>
<p>integer-valued length of <code>x</code> (required).</p>
</td></tr>
<tr><td><code id="ChineseRestaurantProcess_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="ChineseRestaurantProcess_+3A_n">n</code></td>
<td>
<p>number of observations (only n = 1 is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Chinese restaurant process distribution is a distribution
on the space of partitions of the positive integers. 
The distribution with concentration parameter <code class="reqn">\alpha</code> equal to <code>conc</code> 
has probability function 
</p>
<p style="text-align: center;"><code class="reqn">
f(x_i \mid x_1, \ldots, x_{i-1})=\frac{1}{i-1+\alpha}\sum_{j=1}^{i-1}\delta_{x_j}+
\frac{\alpha}{i-1+\alpha}\delta_{x^{new}},</code>
</p>

<p>where <code class="reqn">x^{new}</code> is a new integer not in <code class="reqn">x_1, \ldots, x_{i-1}</code>.
</p>
<p>If <code>conc</code> is not specified, it assumes the default value of 1. The <code>conc</code> 
parameter has to be larger than zero. Otherwise, <code>NaN</code> are returned.
</p>


<h3>Value</h3>

<p><code>dCRP</code> gives the density, and <code>rCRP</code> gives random generation.
</p>


<h3>Author(s)</h3>

<p>Claudia Wehrhahn
</p>


<h3>References</h3>

<p>Blackwell, D., and MacQueen, J. B. (1973). Ferguson distributions via 
Pólya urn schemes. <em>The Annals of Statistics</em>, 1: 353-355.
</p>
<p>Aldous, D. J. (1985). Exchangeability and related topics. In <em>École d'Été 
de Probabilités de Saint-Flour XIII - 1983</em> (pp. 1-198). Springer, Berlin, 
Heidelberg.
</p>
<p>Pitman, J. (1996). Some developments of the Blackwell-MacQueen urn scheme. <em>IMS Lecture
Notes-Monograph Series</em>, 30: 245-267.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rCRP(n=1, conc = 1, size=10)
dCRP(x, conc = 1, size=10)
</code></pre>

<hr>
<h2 id='clearCompiled'>Clear compiled objects from a project and unload shared library</h2><span id='topic+clearCompiled'></span>

<h3>Description</h3>

<p>Clear all compiled objects from a project and unload the shared library produced by the C++ compiler. Has no effect on Windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearCompiled(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clearCompiled_+3A_obj">obj</code></td>
<td>
<p>A compiled nimbleFunction or nimble model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will clear all compiled objects associated with your NIMBLE project.  For example, if <code>cModel</code> is a compiled model, <code>clearCompiled(cModel)</code> will clear both the model and all associated nimbleFunctions such as compiled MCMCs that use that model.
</p>
<p>Use of this function can be dangerous.  There is some risk that if you have copies of the R objects that interfaced to compiled C++ objects that have been removed, and you attempt to use those R objects after clearing their compiled counterparts, you will crash R.  We have tried to minimize that risk, but we can't guarantee safe behavior.
</p>

<hr>
<h2 id='CmodelBaseClass-class'>Class <code>CmodelBaseClass</code></h2><span id='topic+CmodelBaseClass-class'></span><span id='topic+CmodelBaseClass'></span>

<h3>Description</h3>

<p>Classes used internally in NIMBLE and not expected to be called directly by users.
</p>

<hr>
<h2 id='CnimbleFunctionBase-class'>Class <code>CnimbleFunctionBase</code></h2><span id='topic+CnimbleFunctionBase-class'></span><span id='topic+CnimbleFunctionBase'></span>

<h3>Description</h3>

<p>Classes used internally in NIMBLE and not expected to be called directly by users.
</p>

<hr>
<h2 id='codeBlockClass-class'>Class <code>codeBlockClass</code></h2><span id='topic+codeBlockClass-class'></span><span id='topic+codeBlockClass'></span>

<h3>Description</h3>

<p>Classes used internally in NIMBLE and not expected to be called directly by users.
</p>

<hr>
<h2 id='compileNimble'>compile NIMBLE models and nimbleFunctions</h2><span id='topic+compileNimble'></span>

<h3>Description</h3>

<p>compile a collection of models and nimbleFunctions: generate C++, compile the C++, load the result, and return an interface object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileNimble(
  ...,
  project,
  dirName = NULL,
  projectName = "",
  control = list(),
  resetFunctions = FALSE,
  showCompilerOutput = getNimbleOption("showCompilerOutput")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compileNimble_+3A_...">...</code></td>
<td>
<p>An arbitrary set of NIMBLE models and nimbleFunctions, or lists of them.  If given as named parameters, those names may be used in the return list.</p>
</td></tr>
<tr><td><code id="compileNimble_+3A_project">project</code></td>
<td>
<p>Optional NIMBLE model or nimbleFunction already associated with a project, which the current units for compilation should join. If not provided, a new project will be created and the current compilation units will be associated with it.</p>
</td></tr>
<tr><td><code id="compileNimble_+3A_dirname">dirName</code></td>
<td>
<p>Optional directory name in which to generate the C++ code.  If not provided, a temporary directory will be generated using R's <code>tempdir</code> function.</p>
</td></tr>
<tr><td><code id="compileNimble_+3A_projectname">projectName</code></td>
<td>
<p>Optional character name for labeling the project if it is new</p>
</td></tr>
<tr><td><code id="compileNimble_+3A_control">control</code></td>
<td>
<p>A list mostly for internal use. See details.</p>
</td></tr>
<tr><td><code id="compileNimble_+3A_resetfunctions">resetFunctions</code></td>
<td>
<p>Logical value stating whether nimbleFunctions associated with an existing project should all be reset for compilation purposes.  See details.</p>
</td></tr>
<tr><td><code id="compileNimble_+3A_showcompileroutput">showCompilerOutput</code></td>
<td>
<p>Logical value indicating whether details of C++ compilation should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function for calling the NIMBLE compiler.  A set of compiler calls and output will be seen.  Compiling in NIMBLE does 4 things:
1. It generates C++ code files for all the model and nimbleFunction components.  2. It calls the system's C++ compiler.  3. It loads the compiled object(s) into R using <code>dyn.load</code>. And 4. it generates R objects for using the compiled model and nimbleFunctions.
</p>
<p>When the units for compilation provided in <code>...</code> include multiple models and/or nimbleFunctions, models are compiled first, in the order in which they are provided.  Groups of nimbleFunctions that were specialized from the same nimbleFunction generator (the result of a call to <code>nimbleFunction</code>, which then takes setup arguments and returns a specialized nimbleFunction) are then compiled as a group, in the order of first appearance.
</p>
<p>The behavior of adding new compilation units to an existing project is limited.  For example, one can compile a model in one call to <code>compileNimble</code> and then compile a nimbleFunction that uses the model (i.e. was given the model as a setup argument) in a second call to <code>compileNimble</code>, with the model provided as the <code>project</code> argument.  Either the uncompiled or compiled model can be provided.  However, compiling a second nimbleFunction and adding it to the same project will only work in limited circumstances.  Basically, the limitations occur because it attempts to re-use already compiled pieces, but if these do not have all the necessary information for the new compilation, it gives up.  An attempt has been made to give up in a controlled manner and provide somewhat informative messages.
</p>
<p>When compilation is not allowed or doesn't work, try using <code>resetFunctions = TRUE</code>, which will force recompilation of all nimbleFunctions in the new call.  Previously compiled nimbleFunctions will be unaffected, and their R interface objects should continue to work.  The only cost is additional compilation time for the current compilation call.  If that doesn't work, try re-creating the model and/or the nimbleFunctions from their generators.  An alternative possible fix is to compile multiple units in one call, rather than sequentially in multiple calls.
</p>
<p>The control list can contain the following named elements, each with <code>TRUE</code> or <code>FALSE</code>: debug, which sets a debug mode for the compiler for development purposes; debugCpp, which inserts an output message before every line of C++ code for debugging purposes; compileR, which determines whether the R-only steps of compilation should be executed; writeCpp, which determines whether the C++ files should be generated; compileCpp, which determines whether the C++ should be compiled;  loadSO, which determines whether the DLL or shared object should be loaded and interfaced; and returnAsList, which determines whether calls to the compiled nimbleFunction should return only the returned value of the call (<code>returnAsList = FALSE</code>) or whether a list including the input arguments, possibly modified, should be returned in a list with the returned value of the call at the end (<code>returnAsList = TRUE</code>).  The control list is mostly for developer use, although <code>returnAsArgs</code> may be useful to a user.  An example of developer use is that one can have the compiler write the C++ files but not compile them, then modify them by hand, then have the C++ compiler do the subsequent steps without over-writing the files.
</p>
<p>See the NIMBLE <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> Manual for examples
</p>


<h3>Value</h3>

<p>If there is only one compilation unit (one model or nimbleFunction), an R interface object is returned.  This object can be used like the uncompiled model or nimbleFunction, but execution will call the corresponding compiled objects or functions.  If there are multiple compilation units, they will be returned as a list of interface objects, in the order provided.  If names were included in the arguments, or in a list if any elements of <code>...</code> are lists, those names will be used for the corresponding element of the returned list.  Otherwise an attempt will be made to generate names from the argument code.  For example <code>compileNimble(A = fun1, B = fun2, project = myModel)</code> will return a list with named elements A and B, while <code>compileNimble(fun1, fun2, project = myModel)</code> will return a list with named elements fun1 and fun2.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>

<hr>
<h2 id='configureMCMC'>Build the MCMCconf object for construction of an MCMC object</h2><span id='topic+configureMCMC'></span>

<h3>Description</h3>

<p>Creates a default MCMC configuration for a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configureMCMC(
  model,
  nodes,
  control = list(),
  monitors,
  thin = 1,
  monitors2 = character(),
  thin2 = 1,
  useConjugacy = getNimbleOption("MCMCuseConjugacy"),
  onlyRW = FALSE,
  onlySlice = FALSE,
  multivariateNodesAsScalars = getNimbleOption("MCMCmultivariateNodesAsScalars"),
  enableWAIC = getNimbleOption("MCMCenableWAIC"),
  controlWAIC = list(),
  print = getNimbleOption("verbose"),
  autoBlock = FALSE,
  oldConf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configureMCMC_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object, created from <code><a href="#topic+nimbleModel">nimbleModel</a></code></p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_nodes">nodes</code></td>
<td>
<p>An optional character vector, specifying the nodes and/or variables for which samplers should be created.
Nodes may be specified in their indexed form, <code>y[1, 3]</code>.  Alternatively, nodes specified without indexing will be expanded fully, e.g., <code>x</code> will be expanded to <code>x[1]</code>, <code>x[2]</code>, etc.
If missing, the default value is all non-data stochastic nodes.
If NULL, then no samplers are added.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_control">control</code></td>
<td>
<p>An optional list of control arguments to sampler functions.  If a control list is provided, the elements will be provided to all sampler functions which utilize the named elements given.
For example, the standard Metropolis-Hastings random walk sampler (<a href="#topic+sampler_RW">sampler_RW</a>) utilizes control list elements <code>adaptive</code>, <code>adaptInterval</code>, and <code>scale</code>.
(Internally it also uses <code>targetNode</code>, but this should not generally be provided as a control list element).
The default values for control list arguments for samplers (if not otherwise provided as an argument to configureMCMC() ) are in the setup code of the sampling algorithms.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_monitors">monitors</code></td>
<td>
<p>A character vector of node names or variable names, to record during MCMC sampling.
This set of monitors will be recorded with thinning interval <code>thin</code>, and the samples will be stored into the <code>mvSamples</code> object.
The default value is all top-level stochastic nodes of the model &ndash; those having no stochastic parent nodes.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_thin">thin</code></td>
<td>
<p>The thinning interval for <code>monitors</code>.  Default value is one.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_monitors2">monitors2</code></td>
<td>
<p>A character vector of node names or variable names, to record during MCMC sampling.
This set of monitors will be recorded with thinning interval <code>thin2</code>, and the samples will be stored into the <code>mvSamples2</code> object.
The default value is an empty character vector, i.e. no values will be recorded.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_thin2">thin2</code></td>
<td>
<p>The thinning interval for <code>monitors2</code>.  Default value is one.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_useconjugacy">useConjugacy</code></td>
<td>
<p>A logical argument, with default value TRUE.  If specified as FALSE, then no conjugate samplers will be used, even when a node is determined to be in a conjugate relationship.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_onlyrw">onlyRW</code></td>
<td>
<p>A logical argument, with default value FALSE.  If specified as TRUE, then Metropolis-Hastings random walk samplers (<a href="#topic+sampler_RW">sampler_RW</a>) will be assigned for all non-terminal continuous-valued nodes nodes. Discrete-valued nodes are assigned a slice sampler (<a href="#topic+sampler_slice">sampler_slice</a>), and terminal nodes are assigned a posterior_predictive sampler (<a href="#topic+sampler_posterior_predictive">sampler_posterior_predictive</a>).</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_onlyslice">onlySlice</code></td>
<td>
<p>A logical argument, with default value FALSE.  If specified as TRUE, then a slice sampler is assigned for all non-terminal nodes. Terminal nodes are still assigned a posterior_predictive sampler.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_multivariatenodesasscalars">multivariateNodesAsScalars</code></td>
<td>
<p>A logical argument, with default value FALSE.  If specified as TRUE, then non-terminal multivariate stochastic nodes will have scalar samplers assigned to each of the scalar components of the multivariate node.  The default value of FALSE results in a single block sampler assigned to the entire multivariate node.  Note, multivariate nodes appearing in conjugate relationships will be assigned the corresponding conjugate sampler (provided <code>useConjugacy == TRUE</code>), regardless of the value of this argument.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_enablewaic">enableWAIC</code></td>
<td>
<p>A logical argument, specifying whether to enable WAIC calculations for the resulting MCMC algorithm.  Defaults to the value of <code>nimbleOptions('MCMCenableWAIC')</code>, which in turn defaults to FALSE.  Setting <code>nimbleOptions('enableWAIC' = TRUE)</code> will ensure that WAIC is enabled for all calls to <code><a href="#topic+configureMCMC">configureMCMC</a></code> and <code><a href="#topic+buildMCMC">buildMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_controlwaic">controlWAIC</code></td>
<td>
<p>A named list of inputs that control the behavior of the WAIC calculation. See <code>help(waic)</code>.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_print">print</code></td>
<td>
<p>A logical argument, specifying whether to print the ordered list of default samplers.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_autoblock">autoBlock</code></td>
<td>
<p>A logical argument specifying whether to use an automated blocking procedure to determine blocks of model nodes for joint sampling.  If TRUE, an MCMC configuration object will be created and returned corresponding to the results of the automated parameter blocking.  Default value is FALSE.</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_oldconf">oldConf</code></td>
<td>
<p>An optional MCMCconf object to modify rather than creating a new MCMCconf from scratch</p>
</td></tr>
<tr><td><code id="configureMCMC_+3A_...">...</code></td>
<td>
<p>Additional named control list elements for default samplers, or additional arguments to be passed to the <code><a href="#topic+autoBlock">autoBlock</a></code> function when <code>autoBlock = TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+MCMCconf">MCMCconf</a></code> for details on how to manipulate the <code>MCMCconf</code> object
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildMCMC">buildMCMC</a></code> <code><a href="#topic+runMCMC">runMCMC</a></code> <code><a href="#topic+nimbleMCMC">nimbleMCMC</a></code>
</p>

<hr>
<h2 id='configureRJ'>Configure Reversible Jump for Variable Selection</h2><span id='topic+configureRJ'></span>

<h3>Description</h3>

<p>Modifies an MCMC configuration object to perform a reversible jump MCMC sampling for variable selection, using a univariate normal proposal distribution.  Users can control the mean and scale of the proposal. This function supports two different types of model specification: with and without indicator variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configureRJ(
  conf,
  targetNodes,
  indicatorNodes = NULL,
  priorProb = NULL,
  control = list(mean = NULL, scale = NULL, fixedValue = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configureRJ_+3A_conf">conf</code></td>
<td>
<p>An <code>MCMCconf</code> object.</p>
</td></tr>
<tr><td><code id="configureRJ_+3A_targetnodes">targetNodes</code></td>
<td>
<p>A character vector, specifying the nodes and/or variables for which variable selection is to be performed. Nodes may be specified in their indexed form, <code>'y[1, 3]'</code>. Alternatively, nodes specified without indexing will be expanded, e.g., <code>'x'</code> will be expanded to <code>'x[1]'</code>, <code>'x[2]'</code>, etc.</p>
</td></tr>
<tr><td><code id="configureRJ_+3A_indicatornodes">indicatorNodes</code></td>
<td>
<p>An optional character vector, specifying the indicator nodes and/or variables paired with <code>targetNodes</code>. Nodes may be specified in their indexed form, <code>'y[1, 3]'</code>. Alternatively, nodes specified without indexing will be expanded, e.g., <code>'x'</code> will be expanded to <code>'x[1]'</code>, <code>'x[2]'</code>, etc. Nodes must be provided consistently with <code>targetNodes</code>. See details.</p>
</td></tr>
<tr><td><code id="configureRJ_+3A_priorprob">priorProb</code></td>
<td>
<p>An optional value or vector of prior probabilities for each node to be in the model. See details.</p>
</td></tr>
<tr><td><code id="configureRJ_+3A_control">control</code></td>
<td>
<p>An optional list of control arguments:
</p>

<ul>
<li><p> mean. The mean of the normal proposal distribution (default = 0).
</p>
</li>
<li><p> scale. The standard deviation of the normal proposal distribution (default = 1).
</p>
</li>
<li><p> fixedValue. Value for the variable when it is out of the model, which can be used only when <code>priorProb</code> is provided (default = 0). If specified when <code>indicatorNodes</code> is passed, a warning is given and <code>fixedValue</code> is ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function modifies the samplers in MCMC configuration object for each of the nodes provided in the <code>targetNodes</code> argument. To these elements two samplers are assigned: a reversible jump sampler to transition the variable in/out of the model, and a modified version of the original sampler, which performs updates only when the target node is already in the model.
</p>
<p><code>configureRJ</code> can handle two different ways of writing a NIMBLE model, either with or without indicator variables. When using indicator variables, the <code>indicatorNodes</code> argument must be provided. Without indicator variables, the <code>priorProb</code> argument must be provided. In the latter case, the user can provide a non-zero value for <code>fixedValue</code> if desired.
</p>
<p>Note that this functionality is intended for variable selection in regression-style models but may be useful for other situations as well. At the moment, setting a variance component to zero and thereby removing a set of random effects that are explicitly part of a model will not work because MCMC sampling in that case would need to propose values for multiple parameters (the random effects), whereas the current functionality only proposes adding/removing a single model node.
</p>


<h3>Value</h3>

<p><code>NULL</code> <code>configureRJ</code> modifies the input MCMC configuration object in place.
</p>


<h3>Author(s)</h3>

<p>Sally Paganin, Perry de Valpine, Daniel Turek
</p>


<h3>References</h3>

<p>Peter J. Green. (1995). Reversible jump Markov chain Monte Carlo computation and Bayesian model determination. <em>Biometrika</em>, 82(4), 711-732.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samplers">samplers</a></code> <code><a href="#topic+configureMCMC">configureMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Linear regression with intercept and two covariates, using indicator variables

code &lt;- nimbleCode({
  beta0 ~ dnorm(0, sd = 100)
  beta1 ~ dnorm(0, sd = 100)
  beta2 ~ dnorm(0, sd = 100)
  sigma ~ dunif(0, 100) 
  z1 ~ dbern(psi)   ## indicator variable associated with beta1
  z2 ~ dbern(psi)   ## indicator variable associated with beta2
  psi ~ dunif(0, 1) ## hyperprior on inclusion probability
  for(i in 1:N) {
    Ypred[i] &lt;- beta0 + beta1 * z1 * x1[i] + beta2 * z2 * x2[i]
    Y[i] ~ dnorm(Ypred[i], sd = sigma)
  }
})

## simulate some data
set.seed(1)
N &lt;- 100
x1 &lt;- runif(N, -1, 1)
x2 &lt;- runif(N, -1, 1) ## this covariate is not included
Y &lt;- rnorm(N, 1 + 2.5 * x1, sd = 1)

## build the model
rIndicatorModel &lt;- nimbleModel(code, constants = list(N = N),
                               data = list(Y = Y, x1 = x1, x2 = x2), 
                               inits = list(beta0 = 0, beta1 = 0, beta2 = 0, sigma = sd(Y),
                               z1 = 1, z2 = 1, psi = 0.5))

indicatorModelConf &lt;- configureMCMC(rIndicatorModel)

## Add reversible jump  
configureRJ(conf = indicatorModelConf,        ## model configuration
            targetNodes = c("beta1", "beta2"), ## coefficients for selection
            indicatorNodes = c("z1", "z2"),    ## indicators paired with coefficients
            control = list(mean = 0, scale = 2))

indicatorModelConf$addMonitors("beta1", "beta2", "z1", "z2")

rIndicatorMCMC &lt;- buildMCMC(indicatorModelConf)
cIndicatorModel &lt;- compileNimble(rIndicatorModel)
cIndicatorMCMC &lt;- compileNimble(rIndicatorMCMC, project = rIndicatorModel)

set.seed(1)
samples &lt;- runMCMC(cIndicatorMCMC, 10000, nburnin = 6000)

## posterior probability to be included in the mode
mean(samples[ , "z1"])
mean(samples[ , "z2"])

## posterior means when in the model
mean(samples[ , "beta1"][samples[ , "z1"] != 0])
mean(samples[ , "beta2"][samples[ , "z2"] != 0])


## Linear regression with intercept and two covariates, without indicator variables

code &lt;- nimbleCode({
  beta0 ~ dnorm(0, sd = 100)
  beta1 ~ dnorm(0, sd = 100)
  beta2 ~ dnorm(0, sd = 100)
  sigma ~ dunif(0, 100)
  for(i in 1:N) {
    Ypred[i] &lt;- beta0 + beta1 * x1[i] + beta2 * x2[i]
    Y[i] ~ dnorm(Ypred[i], sd = sigma)
  }
})

rNoIndicatorModel &lt;- nimbleModel(code, constants = list(N = N),
                                 data = list(Y = Y, x1 = x1, x2 = x2), 
                                 inits=  list(beta0 = 0, beta1 = 0, beta2 = 0, sigma = sd(Y)))

noIndicatorModelConf &lt;- configureMCMC(rNoIndicatorModel)

## Add reversible jump  
configureRJ(conf = noIndicatorModelConf,      ## model configuration
            targetNodes = c("beta1", "beta2"), ## coefficients for selection   
            priorProb = 0.5,                   ## prior probability of inclusion
            control = list(mean = 0, scale = 2))

## add monitors
noIndicatorModelConf$addMonitors("beta1", "beta2")
rNoIndicatorMCMC &lt;- buildMCMC(noIndicatorModelConf) 

cNoIndicatorModel &lt;- compileNimble(rNoIndicatorModel)
cNoIndicatorMCMC &lt;- compileNimble(rNoIndicatorMCMC, project = rNoIndicatorModel)

set.seed(1)
samples &lt;- runMCMC(cNoIndicatorMCMC, 10000, nburnin = 6000)

## posterior probability to be included in the mode
mean(samples[ , "beta1"] != 0)
mean(samples[ , "beta2"] != 0)

## posterior means when in the model
mean(samples[ , "beta1"][samples[ , "beta1"] != 0])
mean(samples[ , "beta2"][samples[ , "beta2"] != 0])

## End(Not run)

</code></pre>

<hr>
<h2 id='Constraint'>Constraint calculations in NIMBLE</h2><span id='topic+Constraint'></span><span id='topic+dconstraint'></span><span id='topic+rconstraint'></span>

<h3>Description</h3>

<p>Calculations to handle censoring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dconstraint(x, cond, log = FALSE)

rconstraint(n = 1, cond)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Constraint_+3A_x">x</code></td>
<td>
<p>value indicating whether <code>cond</code> is TRUE or FALSE</p>
</td></tr>
<tr><td><code id="Constraint_+3A_cond">cond</code></td>
<td>
<p>logical value</p>
</td></tr>
<tr><td><code id="Constraint_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Constraint_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for working with constraints in BUGS code.
See the NIMBLE manual for additional details.
</p>


<h3>Value</h3>

<p><code>dconstraint</code> gives the density and <code>rconstraint</code> generates random deviates,
but these are unusual as the density is 1 if <code>x</code> matches <code>cond</code> and
0 otherwise and the deviates are simply the value of <code>cond</code>
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>constr &lt;- 3 &gt; 2 &amp;&amp; 4 &gt; 0
x &lt;- rconstraint(1, constr)
dconstraint(x, constr)
dconstraint(0, 3 &gt; 4)
dconstraint(1, 3 &gt; 4)
rconstraint(1, 3 &gt; 4)
</code></pre>

<hr>
<h2 id='decide'>Makes the Metropolis-Hastings acceptance decision, based upon the input (log) Metropolis-Hastings ratio</h2><span id='topic+decide'></span>

<h3>Description</h3>

<p>This function returns a logical TRUE/FALSE value, indicating whether the proposed transition should be accepted (TRUE) or rejected (FALSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decide(logMetropolisRatio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decide_+3A_logmetropolisratio">logMetropolisRatio</code></td>
<td>
<p>The log of the Metropolis-Hastings ratio, which is calculated from model probabilities and forward/reverse transition probabilities. Calculated as the ratio of the model probability under the proposal to that under the current values multiplied by the ratio of the reverse transition probability to the forward transition probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Metropolis-Hastings accept/reject decisions is made as follows.  If <code>logMetropolisRatio</code> is greater than 0, accept (return <code>TRUE</code>).  Otherwise draw a uniform random number between 0 and 1 and accept if it is less that <code>exp(logMetropolisRatio</code>.  The proposed transition will be rejected (return <code>FALSE</code>). If <code>logMetropolisRatio</code> is NA, NaN, or -Inf, a reject (<code>FALSE</code>) decision will be returned.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>

<hr>
<h2 id='decideAndJump'>Creates a nimbleFunction for executing the Metropolis-Hastings jumping decision,
and updating values in the model, or in a carbon copy modelValues object, accordingly.</h2><span id='topic+decideAndJump'></span>

<h3>Description</h3>

<p>This nimbleFunction generator must be specialized to three required arguments: a model, a modelValues, and a character vector of node names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decideAndJump(model, mvSaved, target, UNUSED)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decideAndJump_+3A_model">model</code></td>
<td>
<p>An uncompiled or compiled NIMBLE model object.</p>
</td></tr>
<tr><td><code id="decideAndJump_+3A_mvsaved">mvSaved</code></td>
<td>
<p>A modelValues object containing identical variables and logProb variables as the model. Can be created by <code>modelValues(model)</code>.</p>
</td></tr>
<tr><td><code id="decideAndJump_+3A_target">target</code></td>
<td>
<p>A character vector providing the target node.</p>
</td></tr>
<tr><td><code id="decideAndJump_+3A_unused">UNUSED</code></td>
<td>
<p>Unused placeholder argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling decideAndJump(model, mvSaved, target) will generate a specialized nimbleFunction with four required numeric arguments:
</p>
<p>modelLP1: The model log-probability associated with the newly proposed value(s)
</p>
<p>modelLP0: The model log-probability associated with the original value(s)
</p>
<p>propLP1: The log-probability associated with the proposal forward-transition
</p>
<p>propLP0: The log-probability associated with the proposal reverse-tranisiton
</p>
<p>Executing this function has the following effects:
&ndash; Calculate the (log) Metropolis-Hastings ratio, as logMHR = modelLP1 - modelLP0 - propLP1 + propLP0
&ndash; Make the proposal acceptance decision based upon the (log) Metropolis-Hastings ratio
&ndash; If the proposal is accepted, the values and associated logProbs of all calcNodes are copied from the model object into the mvSaved object
&ndash; If the proposal is rejected, the values and associated logProbs of all calcNodes are copied from the mvSaved object into the model object
&ndash; Return a logical value, indicating whether the proposal was accepted
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>

<hr>
<h2 id='declare'>Explicitly declare a variable in run-time code of a nimbleFunction</h2><span id='topic+declare'></span>

<h3>Description</h3>

<p>Explicitly declare a variable in run-time code of a nimbleFunction, for cases when its dimensions cannot be inferred before it is used.  Works in R and NIMBLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>declare(name, def)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="declare_+3A_name">name</code></td>
<td>
<p>Name of a variable to declare, without quotes</p>
</td></tr>
<tr><td><code id="declare_+3A_def">def</code></td>
<td>
<p>NIMBLE type declaration, of the form <code>TYPE(nDim, sizes)</code>, where <code>TYPE</code> is <code>integer</code>, <code>double</code>, or <code>logical</code>, <code>nDim</code> is the number of dimensions, and <code>sizes</code> is an optional vector of sizes concatenated with <code>c</code>.  If <code>nDim</code> is omitted, it defaults to 0, indicating a scalar.  If sizes are provided, they should not be changed subsequently in the function, including by assignment.  Omitting <code>nDim</code> results in a scalar.  For <code>logical</code>, only scalar is currently supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a run-time function of a nimbleFunction (either the <code>run</code> function or a function provided in <code>methods</code> when calling <code>nimbleFunction</code>), the dimensionality and numeric type of a variable is inferred when possible from the statement first assigning into it.  E.g. <code>A &lt;- B + C</code> infers that <code>A</code> has numeric types, dimensions and sizes taken from <code>B + C</code>.  However, if the first appearance of <code>A</code> is e.g. <code>A[i] &lt;- 5</code>, <code>A</code> must have been explicitly declared.  In this case, <code>declare(A, double(1))</code> would make <code>A</code> a 1-dimensional (i.e. vector) double.
</p>
<p>When sizes are not set, they can be set by a call to <code>setSize</code> or by assignment to the whole object.  Sizes are not automatically extended if assignment is made to elements beyond the current sizes.  In compiled nimbleFunctions doing so can cause a segfault and crash the R session.
</p>
<p>This part of the NIMBLE language is needed for compilation, but it also runs in R.  When run in R, is works by the side effect of creating or modifying <code>name</code> in the calling environment.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>declare(A, logical())             ## scalar logical, the only kind allowed
declare(B, integer(2, c(10, 10))) ## 10 x 10 integer matrix
declare(C, double(3))             ## 3-dimensional double array with no sizes set.
</code></pre>

<hr>
<h2 id='deregisterDistributions'>Remove user-supplied distributions from use in NIMBLE BUGS models</h2><span id='topic+deregisterDistributions'></span>

<h3>Description</h3>

<p>Deregister distributional information originally supplied by the user
for use in BUGS model code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deregisterDistributions(
  distributionsNames,
  userEnv = parent.frame(),
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deregisterDistributions_+3A_distributionsnames">distributionsNames</code></td>
<td>
<p>a character vector giving the names of the distributions to be deregistered.</p>
</td></tr>
<tr><td><code id="deregisterDistributions_+3A_userenv">userEnv</code></td>
<td>
<p>environment in which to look for the nimbleFunctions that provide the distribution; this will generally not need to be set by the user as it will default to the environment from which this function was called.</p>
</td></tr>
<tr><td><code id="deregisterDistributions_+3A_warn">warn</code></td>
<td>
<p>logical indicating whether to warn if trying to deregister a distribution that is not registered (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>

<hr>
<h2 id='Dirichlet'>The Dirichlet Distribution</h2><span id='topic+Dirichlet'></span><span id='topic+dirichlet'></span><span id='topic+ddirch'></span><span id='topic+rdirch'></span>

<h3>Description</h3>

<p>Density and random generation for the Dirichlet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirch(x, alpha, log = FALSE)

rdirch(n = 1, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dirichlet_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>vector of parameters of same length as <code>x</code></p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A or the BUGS manual for mathematical details.
</p>


<h3>Value</h3>

<p><code>ddirch</code> gives the density and <code>rdirch</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- c(1, 10, 30)
x &lt;- rdirch(1, alpha)
ddirch(x, alpha)
</code></pre>

<hr>
<h2 id='distributionInfo'>Get information about a distribution</h2><span id='topic+distributionInfo'></span><span id='topic+isUserDefined'></span><span id='topic+pqDefined'></span><span id='topic+getType'></span><span id='topic+getParamNames'></span><span id='topic+getDistributionInfo'></span>

<h3>Description</h3>

<p>Give information about each BUGS distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistributionInfo(dist)

isUserDefined(dist)

pqDefined(dist)

getType(
  dist,
  params = NULL,
  valueOnly = is.null(params) &amp;&amp; !includeParams,
  includeParams = !is.null(params)
)

getParamNames(dist, includeValue = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distributionInfo_+3A_dist">dist</code></td>
<td>
<p>a character vector of length one, giving the name of the distribution (as used in BUGS code), e.g. <code>'dnorm'</code></p>
</td></tr>
<tr><td><code id="distributionInfo_+3A_params">params</code></td>
<td>
<p>an optional character vector of names of parameters for which dimensions are desired (possibly including \'value\' and alternate parameters)</p>
</td></tr>
<tr><td><code id="distributionInfo_+3A_valueonly">valueOnly</code></td>
<td>
<p>a logical indicating whether to only return the dimension of the value of the node</p>
</td></tr>
<tr><td><code id="distributionInfo_+3A_includeparams">includeParams</code></td>
<td>
<p>a logical indicating whether to return dimensions of parameters. If TRUE and \'params\' is NULL then dimensions of all parameters, including the dimension of the value of the node, are returned</p>
</td></tr>
<tr><td><code id="distributionInfo_+3A_includevalue">includeValue</code></td>
<td>
<p>a logical indicating whether to return the string 'value', which is the name of the node value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NIMBLE provides various functions to give information about a BUGS distribution. In some cases, functions of the same name and similar functionality operate on the node(s) of a model as well (see <code>help(modelBaseClass)</code>).
</p>
<p><code>getDistributionInfo</code> returns an internal data structure (a reference class object) providing various information about the distribution. The output is not very user-friendly, but does contain all of the information that NIMBLE has about the distribution.
</p>
<p><code>isDiscrete</code> tests if a BUGS distribution is a discrete distribution.
</p>
<p><code>isUserDefined</code> tests if a BUGS distribution is a user-defined distribution.
</p>
<p><code>pqAvail</code> tests if a BUGS distribution provides distribution ('p') and quantile ('q') functions.
</p>
<p><code>getDimension</code> provides the dimension of the value and/or parameters of a BUGS distribution. The return value is a numeric vector with an element for each parameter/value requested.
</p>
<p><code>getType</code> provides the type (numeric, logical, integer) of the value and/or parameters of a BUGS distribution. The return value is a character vector with an element for each parameter/value requested. At present, all quantities are stored as numeric (double) values, so this function is of little practical use but could be exploited in the future.
</p>
<p><code>getParamNames</code> provides the value and/or parameter names of a BUGS distribution.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distInfo &lt;- getDistributionInfo('dnorm')
distInfo
distInfo$range

isDiscrete('dbin')

isUserDefined('dbin')

pqDefined('dgamma')
pqDefined('dmnorm')

getDimension('dnorm')
getDimension('dnorm', includeParams = TRUE)
getDimension('dnorm', c('var', 'sd'))
getDimension('dcat', includeParams = TRUE)
getDimension('dwish', includeParams = TRUE)

getType('dnorm')
getType('dnorm', includeParams = TRUE)
getType('dnorm', c('var', 'sd'))
getType('dcat', includeParams = TRUE)
getType('dwish', includeParams = TRUE)

getParamNames('dnorm', includeValue = FALSE)
getParamNames('dmnorm')

</code></pre>

<hr>
<h2 id='Double-Exponential'>The Double Exponential (Laplace) Distribution</h2><span id='topic+Double-Exponential'></span><span id='topic+ddexp'></span><span id='topic+rdexp'></span><span id='topic+pdexp'></span><span id='topic+qdexp'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the double exponential distribution,
allowing non-zero location, <code>mu</code>,
and non-unit scale, <code>sigma</code>, or non-unit rate, <code>tau</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddexp(x, location = 0, scale = 1, rate = 1/scale, log = FALSE)

rdexp(n, location = 0, scale = 1, rate = 1/scale)

pdexp(
  q,
  location = 0,
  scale = 1,
  rate = 1/scale,
  lower.tail = TRUE,
  log.p = FALSE
)

qdexp(
  p,
  location = 0,
  scale = 1,
  rate = 1/scale,
  lower.tail = TRUE,
  log.p = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Double-Exponential_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_location">location</code></td>
<td>
<p>vector of location values.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_scale">scale</code></td>
<td>
<p>vector of scale values.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_rate">rate</code></td>
<td>
<p>vector of inverse scale values.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default) probabilities are <code class="reqn">P[X \le x]</code>; otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given by user as log(p).</p>
</td></tr>
<tr><td><code id="Double-Exponential_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A or the BUGS manual for mathematical details.
</p>


<h3>Value</h3>

<p><code>ddexp</code> gives the density, <code>pdexp</code> gives the distribution
function, <code>qdexp</code> gives the quantile function, and <code>rdexp</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rdexp(50, location = 2, scale = 1)
ddexp(x, 2, 1)
</code></pre>

<hr>
<h2 id='eigenNimbleList'>eigenNimbleList definition</h2><span id='topic+eigenNimbleList'></span>

<h3>Description</h3>

<p><code>nimbleList</code> definition for the type of <code>nimbleList</code> returned by <code><a href="#topic+nimEigen">nimEigen</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenNimbleList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimEigen">nimEigen</a></code>
</p>

<hr>
<h2 id='Exponential'>The Exponential Distribution</h2><span id='topic+Exponential'></span><span id='topic+dexp_nimble'></span><span id='topic+rexp_nimble'></span><span id='topic+pexp_nimble'></span><span id='topic+qexp_nimble'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the exponential distribution with rate
(i.e., mean of <code>1/rate</code>) or scale parameterizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexp_nimble(x, rate = 1/scale, scale = 1, log = FALSE)

rexp_nimble(n = 1, rate = 1/scale, scale = 1)

pexp_nimble(q, rate = 1/scale, scale = 1, lower.tail = TRUE, log.p = FALSE)

qexp_nimble(p, rate = 1/scale, scale = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Exponential_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Exponential_+3A_rate">rate</code></td>
<td>
<p>vector of rate values.</p>
</td></tr>
<tr><td><code id="Exponential_+3A_scale">scale</code></td>
<td>
<p>vector of scale values.</p>
</td></tr>
<tr><td><code id="Exponential_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Exponential_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Exponential_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Exponential_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default) probabilities are <code class="reqn">P[X \le x]</code>; otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Exponential_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given by user as log(p).</p>
</td></tr>
<tr><td><code id="Exponential_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NIMBLE's exponential distribution functions use Rmath's functions
under the hood, but are parameterized to take both rate and scale and to
use 'rate' as the core parameterization in C, unlike Rmath, which uses 'scale'.
See Gelman et al., Appendix A or
the BUGS manual for mathematical details.
</p>


<h3>Value</h3>

<p><code>dexp_nimble</code> gives the density, <code>pexp_nimble</code> gives the distribution
function, <code>qexp_nimble</code> gives the quantile function, and <code>rexp_nimble</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rexp_nimble(50, scale = 3)
dexp_nimble(x, scale = 3)
</code></pre>

<hr>
<h2 id='extractControlElement'>Extract named elements from MCMC sampler control list</h2><span id='topic+extractControlElement'></span>

<h3>Description</h3>

<p>Extract named elements from MCMC sampler control list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractControlElement(controlList, elementName, defaultValue, error)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractControlElement_+3A_controllist">controlList</code></td>
<td>
<p>control list object, which is passed as an argument to all MCMC sampler setup functions.</p>
</td></tr>
<tr><td><code id="extractControlElement_+3A_elementname">elementName</code></td>
<td>
<p>character string, giving the name of the element to be extracted from the control list.</p>
</td></tr>
<tr><td><code id="extractControlElement_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>default value of the control list element, giving the value to be used when the <code>elementName</code> does not exactly match the name of an element in the <code>controlList</code>.</p>
</td></tr>
<tr><td><code id="extractControlElement_+3A_error">error</code></td>
<td>
<p>character string, giving the error message to be printed if no <code>defaultValue</code> is provided and <code>elementName</code> does not match the name of an element in the <code>controlList</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The element of <code>controlList</code> whose name matches <code>elementName</code>. If no <code>controlList</code> name matches <code>elementName</code>, then <code>defaultValue</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>

<hr>
<h2 id='flat'>The Improper Uniform Distribution</h2><span id='topic+flat'></span><span id='topic+halfflat'></span><span id='topic+dflat'></span><span id='topic+rflat'></span><span id='topic+dhalfflat'></span><span id='topic+rhalfflat'></span>

<h3>Description</h3>

<p>Improper flat distribution for use as a prior distribution in BUGS models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dflat(x, log = FALSE)

rflat(n = 1)

dhalfflat(x, log = FALSE)

rhalfflat(n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flat_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="flat_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="flat_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dflat</code> gives the pseudo-density value of 1, while <code>rflat</code> and <code>rhalfflat</code> return <code>NaN</code>,
since one cannot simulate from an improper distribution. Similarly, <code>dhalfflat</code>
gives a pseudo-density value of 1 when <code>x</code> is non-negative.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dflat(1)
</code></pre>

<hr>
<h2 id='getBound'>Get value of bound of a stochastic node in a model</h2><span id='topic+getBound'></span>

<h3>Description</h3>

<p>Get the value of the lower or upper bound for a single stochastic node in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBound(model, node, bound, nodeFunctionIndex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBound_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object</p>
</td></tr>
<tr><td><code id="getBound_+3A_node">node</code></td>
<td>
<p>The name of a stochastic node in the model</p>
</td></tr>
<tr><td><code id="getBound_+3A_bound">bound</code></td>
<td>
<p>Either <code>'lower'</code> or <code>'upper'</code> indicating the desired bound for the node</p>
</td></tr>
<tr><td><code id="getBound_+3A_nodefunctionindex">nodeFunctionIndex</code></td>
<td>
<p>For internal NIMBLE use only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard usage is as a method of a model, in the form <code>model$getBound(node, bound)</code>, but the usage as a simple function with the model as the first argument as above is also allowed.
</p>
<p>For nodes that do not involve truncation of the distribution
this will return the lower or upper bound of the distribution, which
may be a constant or for a limited number of distributions a parameter
or functional of a parameter (at the moment in NIMBLE, the only case
where a bound is a parameter is for the uniform distribution. For nodes
that are truncated, this will return the desired bound, which may be
a functional of other quantities in the model or may be a constant.
</p>

<hr>
<h2 id='getBUGSexampleDir'>Get the directory path to one of the classic BUGS examples installed with NIMBLE package</h2><span id='topic+getBUGSexampleDir'></span>

<h3>Description</h3>

<p>NIMBLE comes with some of the classic BUGS examples.  <code>getBUGSexampleDir</code> looks up the location of an example from its name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBUGSexampleDir(example)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBUGSexampleDir_+3A_example">example</code></td>
<td>
<p>The name of the classic BUGS example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string of the fully pathed directory of the BUGS example.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readBUGSmodel">readBUGSmodel</a></code> for usage in creating a model from a classic BUGS example
</p>

<hr>
<h2 id='getConditionallyIndependentSets'>Get a list of conditionally independent sets of nodes in a nimble model</h2><span id='topic+getConditionallyIndependentSets'></span>

<h3>Description</h3>

<p>A conditionally independent set of nodes is such that the joint probability
(density) of nodes in the set will not change even if any non-given
node outside the set is changed. Default given nodes are data nodes and
parameter nodes (aka &quot;top-level&quot; nodes, i.e. nodes with no parent nodes), but
this can be controlled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConditionallyIndependentSets(
  model,
  nodes,
  givenNodes,
  omit = integer(),
  explore = c("both", "down", "up"),
  unknownAsGiven = TRUE,
  returnType = "names",
  returnScalarComponents = FALSE,
  endAsGiven = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getConditionallyIndependentSets_+3A_model">model</code></td>
<td>
<p>A nimble model object (uncompiled or compiled), such as returned
by <code>nimbleModel</code>.</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_nodes">nodes</code></td>
<td>
<p>A vector of stochastic node names (or their graph IDs) to split
into conditionally independent sets, conditioned on the <code>givenNodes</code>.
If <code>unknownAsGiven=FALSE</code>, the <code>nodes</code> are the starting nodes
from which conditionally independent sets of nodes should be found,
possibly including additional nodes not included in the <code>nodes</code>
argument. If <code>nodes</code> is omitted, the default will be all latent nodes
(defined as stochastic nodes that are not data and have at least one
stochastic parent node, possibly with determinstic nodes in-between) that
are a parent of a <code>givenNode</code> (either provided or default). Note that
this will omit latent states that have no hyperparameters. An example is
the first latent state in some state-space (time-series) models, which is
sometimes declared with known prior.</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_givennodes">givenNodes</code></td>
<td>
<p>A vector of node names or their graph IDs that should be
considered as fixed (given) and hence can be conditioned on. If omitted,
the default will be all data nodes and all parameter nodes, the latter
defined as nodes with no stochastic parent nodes (skipping over
deterministic parent nodes). See <code>endAsGiven</code> for a variant on
defaults.</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_omit">omit</code></td>
<td>
<p>A vector of node names or their graph IDs that should be omitted
and should block further graph exploration.</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_explore">explore</code></td>
<td>
<p>The method of graph exploration, which may corresond to what
the <code>nodes</code> argument represents. For &quot;down&quot;, graph exploration starts
only down (towards descendants) from <code>nodes</code>. For &quot;up&quot;, graph
exploration starts only up (towards ancestors) from <code>nodes</code>. For
&quot;both&quot; (the default and normal setting), both directions are explored.</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_unknownasgiven">unknownAsGiven</code></td>
<td>
<p>Logical for whether a model node not in <code>nodes</code> or
<code>givenNodes</code> should be treated as given (default = TRUE). Otherwise
(and by default) such a node may be grouped into a conditionally
independent set, resulting in more output nodes than input <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_returntype">returnType</code></td>
<td>
<p>Either &quot;names&quot; for returned nodes to be node names or
&quot;ids&quot; for returned nodes to be graph IDs.</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_returnscalarcomponents">returnScalarComponents</code></td>
<td>
<p>If FALSE (default), multivariate nodes are
returned as full names (e.g. <code>x[1:3]</code>). If TRUE, they are returned as
scalar elements (e.g. <code>x[1]</code>, <code>x[2]</code>, <code>x[3]</code>).</p>
</td></tr>
<tr><td><code id="getConditionallyIndependentSets_+3A_endasgiven">endAsGiven</code></td>
<td>
<p>If TRUE, end nodes (defined as nodes with stochastic
parents but no stochastic children, skipping through deterministic nodes)
are included in the default for <code>givenNodes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns sets of conditionally independent nodes.
Multiple input <code>nodes</code> might be in the same set or different sets.
</p>
<p>The <code>nodes</code> input and the returned sets include only stochastic nodes
because conditional independence is a property of random variables.
Deterministic nodes are considered in determining the sets. <code>givenNodes</code>
may contain stochastic or deterministic nodes.
</p>


<h3>Value</h3>

<p>List of nodes that are in conditionally independent sets. With each
set, nodes are returned in topologically sorted order. The sets themselves
are returned in topologically sorted order of their first nodes.
</p>
<p>Other nodes (not in <code>nodes</code>) may be included in the output if
<code>unknownAsGiven=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>

<hr>
<h2 id='getDefinition'>Get nimbleFunction definition</h2><span id='topic+getDefinition'></span>

<h3>Description</h3>

<p>Returns a list containing the nimbleFunction definition components (setup function, run function, and other member methods) for the supplied nimbleFunction generator or specialized instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDefinition(nf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDefinition_+3A_nf">nf</code></td>
<td>
<p>A nimbleFunction generator, or a compiled or un-compiled specialized nimbleFunction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>

<hr>
<h2 id='getMacroParameters'>EXPERIMENTAL: Get list of parameter names generated by model macros</h2><span id='topic+getMacroParameters'></span>

<h3>Description</h3>

<p>Get a list of all parameter names (or certain categories of parameters)
generated by model macros in the model code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMacroParameters(
  model,
  includeLHS = TRUE,
  includeRHS = TRUE,
  includeDeterm = TRUE,
  includeStoch = TRUE,
  includeIndexPars = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMacroParameters_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object</p>
</td></tr>
<tr><td><code id="getMacroParameters_+3A_includelhs">includeLHS</code></td>
<td>
<p>Include generated parameters on the left-hand side (LHS) of 
assignments (<code>&lt;-</code> or <code>~</code>) in the output</p>
</td></tr>
<tr><td><code id="getMacroParameters_+3A_includerhs">includeRHS</code></td>
<td>
<p>Include generated parameters on the left-hand side (RHS) of 
assignments (<code>&lt;-</code> or <code>~</code>) in the output</p>
</td></tr>
<tr><td><code id="getMacroParameters_+3A_includedeterm">includeDeterm</code></td>
<td>
<p>Include deterministic generated parameters in the output</p>
</td></tr>
<tr><td><code id="getMacroParameters_+3A_includestoch">includeStoch</code></td>
<td>
<p>Include stochastic generated parameters in the output</p>
</td></tr>
<tr><td><code id="getMacroParameters_+3A_includeindexpars">includeIndexPars</code></td>
<td>
<p>Include index parameters generated for use in for loops
in the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some model macros will generate new parameters to be included in the
output code. NIMBLE automatically detects these new parameters and 
records them in the model object. This function allows easy access
to this stored list, or subsets of it (see arguments).
</p>


<h3>Value</h3>

<p>A named list of generated parameters, with the element names 
corresponding to the original source macro.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nimbleOptions(enableMacros = TRUE)
nimbleOptions(enableMacroComments = FALSE)
nimbleOptions(verbose = FALSE)

testMacro &lt;- list(process = function(code, modelInfo, .env){
  code &lt;- quote({
    for (i_ in 1:n){
      mu[i_] &lt;- alpha + beta
      y[i_] ~ dnorm(0, sigma)
    }
    alpha ~ dnorm(0, 1)
  })
  list(code = code, modelInfo=modelInfo)
})
 class(testMacro) &lt;- "model_macro"

code &lt;- nimbleCode({
  y[1:n] ~ testMacro()
})

const &lt;- list(y = rnorm(10), n = 10)

mod &lt;- nimbleModel(code, constants=const)

mod$getMacroParameters()
# should be list(testMacro = list(c("mu", "alpha", "beta", "sigma")))

mod$getMacroParameters(includeRHS = FALSE)
# should be list(testMacro = list(c("mu", "alpha")))
</code></pre>

<hr>
<h2 id='getNimbleOption'>Get NIMBLE Option</h2><span id='topic+getNimbleOption'></span>

<h3>Description</h3>

<p>Allow the user to get the value of a global _option_
that affects the way in which NIMBLE operates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNimbleOption(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNimbleOption_+3A_x">x</code></td>
<td>
<p>a character string holding an option name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the option.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getNimbleOption('verifyConjugatePosteriors')
</code></pre>

<hr>
<h2 id='getParam'>Get value of a parameter of a stochastic node in a model</h2><span id='topic+getParam'></span>

<h3>Description</h3>

<p>Get the value of a parameter for any single stochastic node in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParam(model, node, param, nodeFunctionIndex, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getParam_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object</p>
</td></tr>
<tr><td><code id="getParam_+3A_node">node</code></td>
<td>
<p>The name of a stochastic node in the model</p>
</td></tr>
<tr><td><code id="getParam_+3A_param">param</code></td>
<td>
<p>The name of a parameter for the node</p>
</td></tr>
<tr><td><code id="getParam_+3A_nodefunctionindex">nodeFunctionIndex</code></td>
<td>
<p>For internal NIMBLE use only</p>
</td></tr>
<tr><td><code id="getParam_+3A_warn">warn</code></td>
<td>
<p>For internal NIMBLE use only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard usage is as a method of a model, in the form <code>model$getParam(node, param)</code>, but the usage as a simple function with the model as the first argument as above is also allowed.
</p>
<p>For example, suppose node 'x[1:5]' follows a multivariate
normal distribution (dmnorm) in a model declared by BUGS code.
model$getParam('x[1:5]', 'mean') would return the current value of
the mean parameter (which may be determined from other nodes).  The
parameter requested does not have to be part of the
parameterization used to declare the node.  Rather, it can be any
parameter known to the distribution.  For example, one can request
the scale or rate parameter of a gamma distribution, regardless of
which one was used to declare the node.
</p>

<hr>
<h2 id='getSamplesDPmeasure'>Get posterior samples for a Dirichlet process measure</h2><span id='topic+getSamplesDPmeasure'></span>

<h3>Description</h3>

<p>This function obtains posterior samples from a Dirichlet process distributed random measure of a model specified using the <code>dCRP</code> distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSamplesDPmeasure(
  MCMC,
  epsilon = 1e-04,
  setSeed = FALSE,
  progressBar = getNimbleOption("MCMCprogressBar")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSamplesDPmeasure_+3A_mcmc">MCMC</code></td>
<td>
<p>an MCMC class object, either compiled or uncompiled.</p>
</td></tr>
<tr><td><code id="getSamplesDPmeasure_+3A_epsilon">epsilon</code></td>
<td>
<p>used for determining the truncation level of the representation of the random measure.</p>
</td></tr>
<tr><td><code id="getSamplesDPmeasure_+3A_setseed">setSeed</code></td>
<td>
<p>Logical or numeric argument. If a single numeric value is provided, R's random number seed will be set to this value. In the case of a logical value, if <code>TRUE</code>, then R's random number seed will be set to <code>1</code>. Note that specifying the argument <code>setSeed = 0</code> does not prevent setting the RNG seed, but rather sets the random number generation seed to <code>0</code>.  Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getSamplesDPmeasure_+3A_progressbar">progressBar</code></td>
<td>
<p>Logical specifying whether to display a progress bar during execution (default = TRUE).  The progress bar can be permanently disabled by setting the system option <code>nimbleOptions(MCMCprogressBar = FALSE)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides samples from a random measure having a Dirichlet process prior. Realizations are almost surely discrete and represented by a (finite) stick-breaking representation (Sethuraman, 1994), whose atoms (or point masses) are independent and identically distributed. This sampler can only be used with models containing a <code>dCRP</code> distribution. 
</p>
<p>The <code>MCMC</code> argument is an object of class MCMC provided by <code>buildMCMC</code>, or its compiled version. The MCMC should already have been run, as <code>getSamplesDPmeasure</code> uses the posterior samples to generate samples of the random measure. Note that the monitors associated with that MCMC must include the cluster membership variable (which has the <code>dCRP</code> distribution), the cluster parameter variables, all variables directly determining the <code>dCRP</code> concentration parameter, and any stochastic parent variables of the cluster parameter variables. See <code>help(configureMCMC)</code> or <code>help(addMonitors)</code> for information on specifying monitors for an MCMC.
</p>
<p>The <code>epsilon</code> argument is optional and used to determine the truncation level of the random measure. <code>epsilon</code> is the tail probability of the random measure, which together with posterior samples of the concentration parameter, determines the truncation level. The default value is 1e-4.
</p>
<p>The output is a list of matrices. Each matrix represents a sample from the random measure. In order to reduce the output's dimensionality, the weights of identical atoms are added up. The stick-breaking weights are named <code>weights</code> and the atoms are named based on the cluster variables in the model.
</p>
<p>For more details about sampling the random measure and determining its truncation level, see Section 3 in Gelfand, A.E. and Kottas, A. 2002.
</p>


<h3>Author(s)</h3>

<p>Claudia Wehrhahn and Christopher Paciorek
</p>


<h3>References</h3>

<p>Sethuraman, J. (1994). A constructive definition of Dirichlet priors. <em>Statistica Sinica</em>, 639-650.
</p>
<p>Gelfand, A.E. and Kottas, A. (2002). A computational approach for full nonparametric Bayesian inference under Dirichlet process mixture models. <em>Journal of Computational and Graphical Statistics</em>, 11(2), 289-305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildMCMC">buildMCMC</a></code>, <code><a href="#topic+configureMCMC">configureMCMC</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  conf &lt;- configureMCMC(model)
  mcmc &lt;- buildMCMC(conf)
  cmodel &lt;- compileNimble(model)
  cmcmc &lt;- compileNimble(mcmc, project = model)
  runMCMC(cmcmc, niter = 1000)
  outputG &lt;- getSamplesDPmeasure(cmcmc)

## End(Not run)
</code></pre>

<hr>
<h2 id='getsize'>Returns number of rows of modelValues</h2><span id='topic+getsize'></span>

<h3>Description</h3>

<p>Returns the number of rows of NIMBLE modelValues object. Works in R and NIMBLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsize(container)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getsize_+3A_container">container</code></td>
<td>
<p>modelValues object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> or <code>help(modelValuesBaseClass)</code> for information about modelValues objects
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mvConf &lt;- modelValuesConf(vars = 'a', types = 'double', sizes = list(a = 1) )
mv &lt;- modelValues(mvConf)
 resize(mv, 10)
getsize(mv)
</code></pre>

<hr>
<h2 id='identityMatrix'>Create an Identity matrix (Deprecated)</h2><span id='topic+identityMatrix'></span>

<h3>Description</h3>

<p>Returns a d-by-d identity matrix (square matrix of 0's, with 1's on the main diagnol).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identityMatrix(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identityMatrix_+3A_d">d</code></td>
<td>
<p>The size of the identity matrix to return, will return a d-by-d matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in NIMBLE run code.  It is deprecated because now one can use diag(d) instead.
</p>


<h3>Value</h3>

<p>A d-by-d identity matrix
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Id &lt;- identityMatrix(d = 3)

</code></pre>

<hr>
<h2 id='initializeModel'>Performs initialization of nimble model node values and log probabilities</h2><span id='topic+initializeModel'></span>

<h3>Description</h3>

<p>Performs initialization of nimble model node values and log probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initializeModel(model, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initializeModel_+3A_model">model</code></td>
<td>
<p>A setup argument, which specializes an instance of this nimble function to a particular model.</p>
</td></tr>
<tr><td><code id="initializeModel_+3A_silent">silent</code></td>
<td>
<p>logical indicating whether to suppress logging information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This nimbleFunction may be used at the beginning of nimble algorithms to perform model initialization.
The intended usage is to specialize an instance of this nimbleFunction in the setup function of an algorithm,
then execute that specialied function at the beginning of the algorithm run function.
The specialized function takes no arguments.
</p>
<p>Executing this function ensures that all right-hand-side only nodes have been assigned real values,
that all stochastic nodes have a real value, or otherwise have their simulate() method called,
that all deterministic nodes have their simulate() method called,
and that all log-probabilities have been calculated with the current model values.
An error results if model initialization encounters a problem, for example a missing right-hand-side only
node value.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNewAlgorithm &lt;- nimbleFunction(
   setup = function(model, ...) {
      my_initializeModel &lt;- initializeModel(model)
      ....
   },
   run = function(...) {
      my_initializeModel()
      ....
   }
)
</code></pre>

<hr>
<h2 id='Interval'>Interval calculations</h2><span id='topic+Interval'></span><span id='topic+dinterval'></span><span id='topic+rinterval'></span>

<h3>Description</h3>

<p>Calculations to handle censoring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinterval(x, t, c, log = FALSE)

rinterval(n = 1, t, c)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Interval_+3A_x">x</code></td>
<td>
<p>vector of interval indices.</p>
</td></tr>
<tr><td><code id="Interval_+3A_t">t</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Interval_+3A_c">c</code></td>
<td>
<p>vector of one or more values delineating the intervals.</p>
</td></tr>
<tr><td><code id="Interval_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Interval_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for working with censoring in BUGS code.
Taking <code>c</code> to define the endpoints of two or more intervals (with implicit endpoints of plus/minus infinity), <code>x</code> (or the return value of <code>rinterval</code>) gives the non-negative integer valued index of the interval in which <code>t</code> falls. See the NIMBLE manual for additional details.
</p>


<h3>Value</h3>

<p><code>dinterval</code> gives the density and <code>rinterval</code> generates random deviates,
but these are unusual as the density is 1 if <code>x</code> indicates the interval in which <code>t</code>
falls and 0 otherwise and the deviates are simply the interval(s) in which <code>t</code> falls.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>endpoints &lt;- c(-3, 0, 3)
vals &lt;- c(-4, -1, 1, 5)
x &lt;- rinterval(4, vals, endpoints)
dinterval(x, vals, endpoints)
dinterval(c(1, 5, 2, 3), vals, endpoints)
</code></pre>

<hr>
<h2 id='Inverse-Gamma'>The Inverse Gamma Distribution</h2><span id='topic+Inverse-Gamma'></span><span id='topic+dinvgamma'></span><span id='topic+rinvgamma'></span><span id='topic+pinvgamma'></span><span id='topic+qinvgamma'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the inverse gamma distribution with rate
or scale (mean = scale / (shape - 1)) parameterizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma(x, shape, scale = 1, rate = 1/scale, log = FALSE)

rinvgamma(n = 1, shape, scale = 1, rate = 1/scale)

pinvgamma(
  q,
  shape,
  scale = 1,
  rate = 1/scale,
  lower.tail = TRUE,
  log.p = FALSE
)

qinvgamma(
  p,
  shape,
  scale = 1,
  rate = 1/scale,
  lower.tail = TRUE,
  log.p = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Inverse-Gamma_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_shape">shape</code></td>
<td>
<p>vector of shape values, must be positive.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_scale">scale</code></td>
<td>
<p>vector of scale values, must be positive.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_rate">rate</code></td>
<td>
<p>vector of rate values, must be positive.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default) probabilities are <code class="reqn">P[X \le x]</code>; otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given by user as log(p).</p>
</td></tr>
<tr><td><code id="Inverse-Gamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse gamma distribution with parameters <code>shape</code> <code class="reqn">=\alpha</code> and
<code>scale</code> <code class="reqn">=\sigma</code> has density
</p>
<p style="text-align: center;"><code class="reqn">
  f(x)= \frac{s^a}{\Gamma(\alpha)} {x}^{-(\alpha+1)} e^{-\sigma/x}%
 </code>
</p>

<p>for <code class="reqn">x \ge 0</code>, <code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\sigma &gt; 0</code>.
(Here <code class="reqn">\Gamma(\alpha)</code> is the function implemented by <span class="rlang"><b>R</b></span>'s
<code><a href="base.html#topic+gamma">gamma</a>()</code> and defined in its help.
</p>
<p>The mean and variance are
<code class="reqn">E(X) = \frac{\sigma}{\alpha}-1</code> and
<code class="reqn">Var(X) = \frac{\sigma^2}{(\alpha-1)^2 (\alpha-2)}</code>,
with the mean defined only
for <code class="reqn">\alpha &gt; 1</code> and the variance only for <code class="reqn">\alpha &gt; 2</code>.
</p>
<p>See Gelman et al., Appendix A or
the BUGS manual for mathematical details.
</p>


<h3>Value</h3>

<p><code>dinvgamma</code> gives the density, <code>pinvgamma</code> gives the distribution
function, <code>qinvgamma</code> gives the quantile function, and <code>rinvgamma</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rinvgamma(50, shape = 1, scale = 3)
dinvgamma(x, shape = 1, scale = 3)
</code></pre>

<hr>
<h2 id='Inverse-Wishart'>The Inverse Wishart Distribution</h2><span id='topic+Inverse-Wishart'></span><span id='topic+inverse-wishart'></span><span id='topic+dinvwish_chol'></span><span id='topic+rinvwish_chol'></span>

<h3>Description</h3>

<p>Density and random generation for the Inverse Wishart distribution, using the Cholesky factor of either the scale matrix or the rate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvwish_chol(x, cholesky, df, scale_param = TRUE, log = FALSE)

rinvwish_chol(n = 1, cholesky, df, scale_param = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Inverse-Wishart_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Inverse-Wishart_+3A_cholesky">cholesky</code></td>
<td>
<p>upper-triangular Cholesky factor of either the scale matrix (when <code>scale_param</code> is TRUE) or rate matrix (otherwise).</p>
</td></tr>
<tr><td><code id="Inverse-Wishart_+3A_df">df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code id="Inverse-Wishart_+3A_scale_param">scale_param</code></td>
<td>
<p>logical; if TRUE the Cholesky factor is that of the scale matrix; otherwise, of the rate matrix.</p>
</td></tr>
<tr><td><code id="Inverse-Wishart_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Inverse-Wishart_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A for mathematical details. The rate matrix as used here is defined as the inverse of the scale matrix, <code class="reqn">S^{-1}</code>, given in Gelman et al.
</p>


<h3>Value</h3>

<p><code>dinvwish_chol</code> gives the density and <code>rinvwish_chol</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- 40
ch &lt;- chol(matrix(c(1, .7, .7, 1), 2))
x &lt;- rwish_chol(1, ch, df = df)
dwish_chol(x, ch, df = df)

</code></pre>

<hr>
<h2 id='is.nf'>check if a nimbleFunction</h2><span id='topic+is.nf'></span>

<h3>Description</h3>

<p>Checks an object to determine if it is a nimbleFunction (i.e., a function created by <code>nimbleFunction</code> using setup code).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.nf(f, inputIsName = FALSE, where = -1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.nf_+3A_f">f</code></td>
<td>
<p>object to be tested</p>
</td></tr>
<tr><td><code id="is.nf_+3A_inputisname">inputIsName</code></td>
<td>
<p>logical indicating whether the function is provided as the character name of the function or the function object itself</p>
</td></tr>
<tr><td><code id="is.nf_+3A_where">where</code></td>
<td>
<p>Optional argument needed due to R package namespace issues but which should not need to be provided by a user.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nimbleFunction">nimbleFunction</a></code> for how to create a nimbleFunction
</p>

<hr>
<h2 id='is.nl'>check if a nimbleList</h2><span id='topic+is.nl'></span>

<h3>Description</h3>

<p>Checks an object to determine if it is a nimbleList (i.e., a list created by <code>nlDef$new()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.nl(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.nl_+3A_l">l</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nimbleList">nimbleList</a></code> for how to create a nimbleList
</p>

<hr>
<h2 id='LKJ'>The LKJ Distribution for the Cholesky Factor of a Correlation Matrix</h2><span id='topic+LKJ'></span><span id='topic+lkj'></span><span id='topic+dlkj'></span><span id='topic+rlkj'></span><span id='topic+lkj_corr'></span><span id='topic+lkj_corr_cholesky'></span><span id='topic+dlkj_corr_cholesky'></span><span id='topic+rlkj_corr_cholesky'></span>

<h3>Description</h3>

<p>Density and random generation for the LKJ distribution for the Cholesky factor of a correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlkj_corr_cholesky(x, eta, p, log = FALSE)

rlkj_corr_cholesky(n = 1, eta, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LKJ_+3A_x">x</code></td>
<td>
<p>upper-triangular Cholesky factor of a correlation matrix.</p>
</td></tr>
<tr><td><code id="LKJ_+3A_eta">eta</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="LKJ_+3A_p">p</code></td>
<td>
<p>size of the correlation matrix (number of rows and columns); required because random generation function has no information about dimension of matrix to generate without this argument.</p>
</td></tr>
<tr><td><code id="LKJ_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="LKJ_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Stan Development Team for mathematical details.
</p>


<h3>Value</h3>

<p><code>dlkj_corr_cholesky</code> gives the density and <code>rlkj_corr_cholesky</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Stan Development Team. Stan Reference Functions, version 2.27.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Distributions">Distributions</a></code> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eta &lt;- 3
x &lt;- rlkj_corr_cholesky(1, eta, 5)
dlkj_corr_cholesky(x, eta, 5)

</code></pre>

<hr>
<h2 id='makeBoundInfo'>Make an object of information about a model-bound pairing for getBound.  Used internally</h2><span id='topic+makeBoundInfo'></span>

<h3>Description</h3>

<p>Creates a simple getBound_info object, which has a list with a boundID and a type.
Unlike <code>makeParamInfo</code> this is more bare-bones, but keeping it for parallelism
with <code>getParam</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBoundInfo(model, nodes, bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeBoundInfo_+3A_model">model</code></td>
<td>
<p>A model such as returned by <code><a href="#topic+nimbleModel">nimbleModel</a></code>.</p>
</td></tr>
<tr><td><code id="makeBoundInfo_+3A_nodes">nodes</code></td>
<td>
<p>A character string naming a stochastic nodes, such as <code>'mu'</code>.</p>
</td></tr>
<tr><td><code id="makeBoundInfo_+3A_bound">bound</code></td>
<td>
<p>A character string naming a bound of the distribution, either <code>'lower'</code> or <code>'upper'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally by <code><a href="#topic+getBound">getBound</a></code>.  It is not intended for direct use by a user or even a nimbleFunction programmer.
</p>

<hr>
<h2 id='makeModelDerivsInfo'>Information on model structure used for derivatives</h2><span id='topic+makeModelDerivsInfo'></span>

<h3>Description</h3>

<p>Inspect structure of a nimble model to determine nodes needed as &quot;update&quot;
and/or &quot;constant&quot; entries in usage of nimDerivs. This will typically be used
in the setup code of a nimbleFunction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeModelDerivsInfo(model, wrtNodes, calcNodes, dataAsConstantNodes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeModelDerivsInfo_+3A_model">model</code></td>
<td>
<p>a nimble model object, such as returned from <code>nimbleModel</code>.</p>
</td></tr>
<tr><td><code id="makeModelDerivsInfo_+3A_wrtnodes">wrtNodes</code></td>
<td>
<p>a character vector of node names in the model with respect to
which derivatives will be taken through a call to <code>nimDerivs</code> (same as
<code>derivs</code>).</p>
</td></tr>
<tr><td><code id="makeModelDerivsInfo_+3A_calcnodes">calcNodes</code></td>
<td>
<p>a character vector of node names in the model that will be
used in <code>model$calculate(calcNodes)</code> while derivatives are being
recorded.</p>
</td></tr>
<tr><td><code id="makeModelDerivsInfo_+3A_dataasconstantnodes">dataAsConstantNodes</code></td>
<td>
<p>logical indicating whether data nodes in the model
should automatically be treated as &quot;constant&quot; entries (TRUE) or &quot;update&quot;
entries (FALSE). Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the compilable parts of a <code>nimbleFunction</code> (i.e. <code>run</code>
or other method code, not <code>setup</code> code), a call like
<code>nimDerivs(foo(x), ...)</code> records derivatives of <code>foo(x)</code>. If
<code>foo</code> contains any calls to <code>model$calculate(calcNodes)</code>, it may
be necessary to provide auxiliary information about the model in further
arguments to <code>nimDerivs</code>, specifically the <code>model</code>,
<code>updateNodes</code> and <code>constantNodes</code> arguments.
'makeModelDerivsInfo' is a utility to set up that information for typical
use cases. It returns a list with elements <code>updateNodes</code> and
<code>constantNodes</code> to be passed as arguments of the same name to
<code>nimDerivs</code> (along with passing the <code>model</code> as the <code>model</code>
argument).
</p>
<p>The reason auxiliary information is needed is that recording of derivatives
uses a different model than for regular calculations. Together,
<code>updateNodes</code> and <code>constantNodes</code> should contain all nodes whose
values are needed for the model calculations being recorded and that are not
part of <code>wrtNodes</code>. These may include parents of nodes that are in
<code>calcNodes</code> but are not themselves in <code>calcNodes</code>, as well as the
values of stochastic nodes in <code>calcNodes</code>, which are needed to calculate
the corresponding log probabilities. <code>updateNodes</code> will have their
values updated from the regular model every time that recorded derivative
calculations are used. <code>constantNodes</code> will not be updated every time,
which means their values will be permanently fixed either the first time the
call to 'nimDerivs' is invoked or on any subsequent call that has
<code>reset=TRUE</code>. Use of <code>constantNodes</code> can be slightly more
efficient, but one must be careful to be aware that values will not be
updated unless <code>reset=TRUE</code>. See the automatic differentiation section
of the User Manual for more information.
</p>
<p>In the above explanation, care must be taken to understand what should be
included in <code>wrtNodes</code>. In a typical use case, some arguments to
<code>foo</code> are put into the model using <code>values(model, nodes) &lt;-
some_foo_arguments</code>. Next there is typically a call to
<code>model$calculate(calcNodes)</code>. Here the <code>nodes</code> are considered
&quot;with-respect-to&quot; nodes because derivative tracking will follow the arguments
of <code>foo</code>, including when they are put into a model and hence used in
<code>model$calculate</code>. Therefore these <code>nodes</code> should be the
<code>wrtNodes</code> for <code>makeModelDerivsInfo</code>.
</p>


<h3>Value</h3>

<p>A list with elements <code>updateNodes</code> and <code>constantNodes</code>.
These shouls be provided as the same-named arguments to <code>nimDerivs</code>
(same as <code>derivs</code>).
</p>
<p>When using double-taping of derivatives (i.e. <code>foo</code> contains another
call to <code>nimDerivs</code>), both calls to <code>nimDerivs</code> should include the
<code>model</code>, <code>updateNodes</code>, and <code>constantNodes</code> arguments.
</p>

<hr>
<h2 id='makeParamInfo'>Make an object of information about a model-parameter pairing for getParam.  Used internally</h2><span id='topic+makeParamInfo'></span>

<h3>Description</h3>

<p>Creates a simple getParam_info object, which has a list with a paramID and a type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeParamInfo(model, nodes, param, vector = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeParamInfo_+3A_model">model</code></td>
<td>
<p>A model such as returned by <code><a href="#topic+nimbleModel">nimbleModel</a></code>.</p>
</td></tr>
<tr><td><code id="makeParamInfo_+3A_nodes">nodes</code></td>
<td>
<p>A character string naming one one or more stochastic nodes, such as &quot;mu&quot;, &quot;c('mu', 'beta[2]')&quot;, or &quot;eta[1:3, 2]&quot;.  getParam only works for one node at a time, but if it is indexed (nodes[i]), then makeParamInfo sets up the information for the entire vector nodes.  The processing pathway is used by the NIMBLE compiler.</p>
</td></tr>
<tr><td><code id="makeParamInfo_+3A_param">param</code></td>
<td>
<p>A character string naming a parameter of the distribution followed by node, such as &quot;mean&quot;, &quot;rate&quot;, &quot;lambda&quot;, or whatever parameter names are relevant for the distribution of the node.</p>
</td></tr>
<tr><td><code id="makeParamInfo_+3A_vector">vector</code></td>
<td>
<p>A logical indicating whether nodes should definitely be treated as a vector in compiled code, even if it has length = 1.  For type consistency, the compiler needs this option.  If nodes has length &gt; 1, this argument is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used internally by <code><a href="#topic+getParam">getParam</a></code>.  It is not intended for direct use by a user or even a nimbleFunction programmer.
</p>

<hr>
<h2 id='MCMCconf-class'>Class <code>MCMCconf</code></h2><span id='topic+MCMCconf-class'></span><span id='topic+MCMCconf'></span><span id='topic+addSampler'></span><span id='topic+removeSamplers'></span><span id='topic+setSamplers'></span><span id='topic+printSamplers'></span><span id='topic+getSamplers'></span><span id='topic+setSamplerExecutionOrder'></span><span id='topic+getSamplerExecutionOrder'></span><span id='topic+addMonitors'></span><span id='topic+addMonitors2'></span><span id='topic+setMonitors'></span><span id='topic+setMonitors2'></span><span id='topic+resetMonitors'></span><span id='topic+getMonitors'></span><span id='topic+getMonitors2'></span><span id='topic+printMonitors'></span><span id='topic+setThin'></span><span id='topic+setThin2'></span>

<h3>Description</h3>

<p>Objects of this class configure an MCMC algorithm, specific to a particular model.  Objects are normally created by calling <code><a href="#topic+configureMCMC">configureMCMC</a></code>.
Given an MCMCconf object, the actual MCMC function can be built by calling <code><a href="#topic+buildMCMC">buildMCMC</a>(conf)</code>.
See documentation below for method initialize() for details of creating an MCMCconf object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>addDefaultSampler(
  nodes = character(),
  control = list(),
  useConjugacy = getNimbleOption("MCMCuseConjugacy"),
  onlyRW = FALSE,
  onlySlice = FALSE,
  multivariateNodesAsScalars = getNimbleOption("MCMCmultivariateNodesAsScalars"),
  print = TRUE,
  ...
)</code></dt><dd><p>For internal use.  Adds default MCMC samplers to the specified nodes.</p>
</dd>
<dt><code>addMonitors(..., ind = 1, print = TRUE)</code></dt><dd><p>Adds variables to the list of monitors.
</p>
<p>Arguments:
</p>
<p>...: One or more character vectors of indexed nodes, or variables, which are to be monitored.  These are added onto the current monitors list.
</p>
<p>print: A logical argument specifying whether to print all current monitors (default TRUE).
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>addMonitors2(..., print = TRUE)</code></dt><dd><p>Adds variables to the list of monitors2.
</p>
<p>Arguments:
</p>
<p>...: One or more character vectors of indexed nodes, or variables, which are to be monitored.  These are added onto the current monitors2 list.
</p>
<p>print: A logical argument specifying whether to print all current monitors (default TRUE).
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>addOneSampler(
  thisSamplerName,
  samplerFunction,
  targetOne,
  thisControlList,
  allowData,
  print
)</code></dt><dd><p>For internal use only</p>
</dd>
<dt><code>addSampler(
  target = character(),
  type = "RW",
  control = list(),
  print = NULL,
  name,
  targetByNode = FALSE,
  multivariateNodesAsScalars = getNimbleOption("MCMCmultivariateNodesAsScalars"),
  expandTarget,
  scalarComponents,
  silent = FALSE,
  default = FALSE,
  useConjugacy = getNimbleOption("MCMCuseConjugacy"),
  onlyRW = FALSE,
  onlySlice = FALSE,
  allowData = FALSE,
  ...
)</code></dt><dd><p>Adds a sampler to the list of samplers contained in the MCMCconf object.
</p>
<p>Arguments:
</p>
<p>target: The target node or nodes to be sampled.  This may be specified as a character vector of model node and/or variable names.  For univariate samplers, only a single target node should be provided (unless 'targetByNode' is TRUE).  For multivariate samplers, one instance of the multivariate sampler will be assigned to all nodes specified.  Nodes are specified in combination with the 'targetByNode' and 'multivariateNodesAsScalars' arguments.
</p>
<p>type: When 'default' is FALSE, specifies the type of sampler to add, specified as either a character string or a nimbleFunction object.  If the character argument type='newSamplerType', then either newSamplerType or sampler_newSamplerType must correspond to a nimbleFunction (i.e. a function returned by nimbleFunction, not a specialized nimbleFunction).  Alternatively, the type argument may be provided as a nimbleFunction itself rather than its name.  In that case, the 'name' argument may also be supplied to provide a meaningful name for this sampler.  The default value is 'RW' which specifies scalar adaptive Metropolis-Hastings sampling with a normal proposal distribution. This default will result in an error if 'target' specifies more than one target node (unless 'targetByNode' is TRUE).  This argument is not used when the 'default' argument is TRUE.
</p>
<p>control: An optional list of control arguments to sampler functions.  These will override those specified in the control list argument to configureMCMC.  If a control list is provided, the elements will be provided to all sampler functions which utilize the named elements given. For example, the standard Metropolis-Hastings random walk sampler (sampler_RW) utilizes control list elements 'adaptive', 'adaptInterval', 'scale'. The default values for control list arguments for samplers (if not otherwise provided as an argument to configureMCMC or addSampler) are contained in the setup code of each sampling algorithm.
</p>
<p>print: Logical argument, specifying whether to print the details of newly added sampler(s).
</p>
<p>name: Optional character string name for the sampler, which is used by the printSamplers method.  If 'name' is not provided, the 'type' argument is used to generate the sampler name.
</p>
<p>targetByNode: Logical argument, with default FALSE.  This arguments controls whether separate instances of the specified sampler 'type' should be assigned to each node contained in 'target'.  When FALSE, a single instance of sampler 'type' is assigned to operate on 'target'.  When TRUE, potentially multiple instances of sampler 'type' will be added to the MCMC configuration, operating on the distinct nodes which compose 'target'.  For example, if 'target' is a vector of distinct node names, then a separate sampler will be assigned to each node in this vector.  If 'target' is a model variable which itself is comprised of multiple distinct nodes, then a separate sampler is assigned to each node composing the 'target' variable. Additional control of the handling of multivariate nodes is provided using the 'multivariateNodesAsScalars' argument.
</p>
<p>multivariateNodesAsScalars: Logical argument, with default value FALSE.  This argument is used in two ways.  Functionally, both uses result in separate instances of samplers being added to the scalar components which compose multivariate nodes. See details below.
</p>
<p>silent: Logical argument, specifying whether to print warning messages when assigning samplers.
</p>
<p>default: Logical argument, with default value FALSE.  When FALSE, the 'type' argument dictates what sampling algorithm is assigned to the specified nodes.  When TRUE, default samplers will be assigned to the specified nodes following the same logic as the configureMCMC method, and also using the 'useConjugacy', 'onlyRW', 'onlySlice' and 'multivariateNodesAsScalars' arguments.
</p>
<p>useConjugacy: Logical argument, with default value TRUE.  If specified as FALSE, then no conjugate samplers will be used, even when a node is determined to be in a conjugate relationship.  This argument is only used when the 'default' argument is TRUE.
</p>
<p>onlyRW: Logical argument, with default value FALSE.  If specified as TRUE, then Metropolis-Hastings random walk samplers will be assigned for all non-terminal continuous-valued nodes nodes. Discrete-valued nodes are assigned a slice sampler, and terminal nodes are assigned a posterior_predictive sampler.  This argument is only used when the 'default' argument is TRUE.
</p>
<p>onlySlice: Logical argument, with default value FALSE.  If specified as TRUE, then a slice sampler is assigned for all non-terminal nodes. Terminal nodes are still assigned a posterior_predictive sampler.  This argument is only used when the 'default' argument is TRUE.
</p>
<p>allowData: Logical argument, with default value FALSE.  When FALSE, samplers will not be assigned to operate on data nodes, even if data nodes are included in 'target'.  When TRUE, samplers will be assigned to 'target' without regard to whether nodes are designated as data.
</p>
<p>...: Additional named arguments passed through ... will be used as additional control list elements.
</p>
<p>Details:
</p>
<p>Samplers are added to the end of the list of samplers for this MCMCconf object, and do not replace any existing samplers.  Samplers are removed using the removeSamplers method.
</p>
<p>Invisibly returns a list of the current sampler configurations, which are samplerConf reference class objects.
</p>
<p>'multivariateNodesAsScalars' has two usages. The first usage occurs when 'targetByNode' is TRUE and therefore separate instances of sampler 'type' are assigned to each node which compose 'target'.  In this first usage, this argument controls how multivariate nodes (those included in the 'target') are handled.  If FALSE, any multivariate nodes in 'target' have a single instance of sampler 'type' assigned.  If TRUE, any multivariate nodes appearing in 'target' are themselves decomposed into their scalar elements, and a separate instance of sampler 'type' is assigned to operate on each scalar element.
</p>
<p>The second usage of 'multivariateNodesAsScalars' occurs when 'default' is TRUE, and therefore samplers are assigned according to the default logic of configureMCMC, which is further controlled by the arguments 'useConjugacy', 'onlyRW', 'onlySlice' and 'multivariateNodesAsScalars'.  In this second usage, if 'multivariateNodesAsScalars' is TRUE, then multivariate nodes will be decomposed into their scalar components, and separate samplers assigned to each scalar element.  Note, however, that multivariate nodes appearing in conjugate relationships will still be assigned the corresponding conjugate sampler (provided 'useConjugacy' is TRUE), regardless of the value of this argument.  If 'multivariateNodesAsScalars' is FALSE, then a single multivarate sampler will be assigned to update each multivariate node.  The default value of this argument can be controlled using the nimble option 'MCMCmultivariateNodesAsScalars'.</p>
</dd>
<dt><code>getMonitors()</code></dt><dd><p>Returns a character vector of the current monitors
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>getMonitors2()</code></dt><dd><p>Returns a character vector of the current monitors2
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>getSamplerDefinition(ind, print = FALSE)</code></dt><dd><p>Returns the nimbleFunction definition of an MCMC sampler.
</p>
<p>Arguments:
</p>
<p>ind: A numeric vector or character vector.  A numeric vector may be used to specify the index of the sampler definition to return, or a character vector may be used to indicate a target node for which the sampler acting on this nodes will be printed. For example, getSamplerDefinition('x[2]') will return the definition of the sampler whose target is model node 'x[2]'.  If more than one sampler function is specified, only the first is returned.
</p>
<p>Returns a list object, containing the setup function, run function, and additional member methods for the specified nimbleFunction sampler.</p>
</dd>
<dt><code>getSamplerExecutionOrder()</code></dt><dd><p>Returns a numeric vector, specifying the ordering of sampler function execution.
</p>
<p>The indices of execution specified in this numeric vector correspond to the enumeration of samplers printed by printSamplers(), or returned by getSamplers().</p>
</dd>
<dt><code>getSamplers(ind)</code></dt><dd><p>Returns a list of samplerConf objects.
</p>
<p>Arguments:
</p>
<p>ind: A numeric vector or character vector.  A numeric vector may be used to specify the indices of the samplerConf objects to return, or a character vector may be used to indicate a set of target nodes and/or variables, for which all samplers acting on these nodes will be returned. For example, getSamplers('x') will return all samplerConf objects whose target is model node 'x', or whose targets are contained (entirely or in part) in the model variable 'x'.  If omitted, then all samplerConf objects in this MCMC configuration object are returned.</p>
</dd>
<dt><code>initialize(
  model,
  nodes,
  control = list(),
  monitors,
  thin = 1,
  monitors2 = character(),
  thin2 = 1,
  useConjugacy = getNimbleOption("MCMCuseConjugacy"),
  onlyRW = FALSE,
  onlySlice = FALSE,
  multivariateNodesAsScalars = getNimbleOption("MCMCmultivariateNodesAsScalars"),
  enableWAIC = getNimbleOption("MCMCenableWAIC"),
  controlWAIC = list(),
  print = TRUE,
  ...
)</code></dt><dd><p>Creates a MCMC configuration for a given model.  The resulting object is suitable as an argument to buildMCMC.
</p>
<p>Arguments:
</p>
<p>model: A NIMBLE model object, created from nimbleModel(...)
</p>
<p>nodes: An optional character vector, specifying the nodes for which samplers should be created.
Nodes may be specified in their indexed form, 'y[1, 3]', or nodes specified without indexing will be expanded fully, e.g., 'x' will be expanded to 'x[1]', 'x[2]', etc.
If missing, the default value is all non-data stochastic nodes.
If NULL, then no samplers are added.
</p>
<p>control: An optional list of control arguments to sampler functions.  If a control list is provided, the elements will be provided to all sampler functions which utilize the named elements given.
For example, the standard Metropolis-Hastings random walk sampler (sampler_RW) utilizes control list elements 'adaptive', 'adaptInterval', 'scale'.
The default values for control list arguments for samplers (if not otherwise provided as an argument to configureMCMC() or addSampler()) are contained in the setup code of each sampling algorithm.
</p>
<p>monitors: A character vector of node names or variable names, to record during MCMC sampling.
This set of monitors will be recorded with thinning interval 'thin', and the samples will be stored into the 'mvSamples' object.
The default value is all top-level stochastic nodes of the model &ndash; those having no stochastic parent nodes.
</p>
<p>monitors2: A character vector of node names or variable names, to record during MCMC sampling.
This set of monitors will be recorded with thinning interval 'thin2', and the samples will be stored into the 'mvSamples2' object.
The default value is an empty character vector, i.e. no values will be recorded.
</p>
<p>thin: The thinning interval for 'monitors'.  Default value is one.
</p>
<p>thin2: The thinning interval for 'monitors2'.  Default value is one.
</p>
<p>useConjugacy: A logical argument, with default value TRUE.  If specified as FALSE, then no conjugate samplers will be used, even when a node is determined to be in a conjugate relationship.
</p>
<p>onlyRW: A logical argument, with default value FALSE.  If specified as TRUE, then Metropolis-Hastings random walk samplers will be assigned for all non-terminal continuous-valued nodes nodes. Discrete-valued nodes are assigned a slice sampler, and terminal nodes are assigned a posterior_predictive sampler.
</p>
<p>onlySlice: A logical argument, with default value FALSE.  If specified as TRUE, then a slice sampler is assigned for all non-terminal nodes. Terminal nodes are still assigned a posterior_predictive sampler.
</p>
<p>multivariateNodesAsScalars: A logical argument, with default value FALSE.  If specified as TRUE, then non-terminal multivariate stochastic nodes will have scalar samplers assigned to each of the scalar components of the multivariate node.  The default value of FALSE results in a single block sampler assigned to the entire multivariate node.  Note, multivariate nodes appearing in conjugate relationships will be assigned the corresponding conjugate sampler (provided useConjugacy == TRUE), regardless of the value of this argument.
</p>
<p>enableWAIC: A logical argument, specifying whether to enable WAIC calculations for the resulting MCMC algorithm.  Defaults to the value of nimbleOptions('MCMCenableWAIC'), which in turn defaults to FALSE.  Setting nimbleOptions('MCMCenableWAIC' = TRUE) will ensure that WAIC is enabled for all calls to 'configureMCMC' and 'buildMCMC'.
</p>
<p>controlWAIC A named list of inputs that control the behavior of the WAIC calculation, passed as the 'control' input to 'buildWAIC'. See 'help(waic)'.
</p>
<p>print: A logical argument specifying whether to print the montiors and samplers.  Default is TRUE.
</p>
<p>...: Additional named control list elements for default samplers, or additional arguments to be passed to the autoBlock function when autoBlock = TRUE.</p>
</dd>
<dt><code>printMonitors()</code></dt><dd><p>Prints all current monitors and monitors2
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>printSamplers(
  ...,
  ind,
  type,
  displayControlDefaults = FALSE,
  displayNonScalars = FALSE,
  displayConjugateDependencies = FALSE,
  executionOrder = FALSE,
  byType = FALSE
)</code></dt><dd><p>Prints details of the MCMC samplers.
</p>
<p>Arguments:
</p>
<p>...: Character node or variable names, or numeric indices.  Numeric indices may be used to specify the indices of the samplers to print, or character strings may be used to indicate a set of target nodes and/or variables, for which all samplers acting on these nodes will be printed. For example, printSamplers('x') will print all samplers whose target is model node 'x', or whose targets are contained (entirely or in part) in the model variable 'x'.  If omitted, then all samplers are printed.
</p>
<p>ind: A numeric vector or character vector.  A numeric vector may be used to specify the indices of the samplers to print, or a character vector may be used to indicate a set of target nodes and/or variables, for which all samplers acting on these nodes will be printed. For example, printSamplers('x') will print all samplers whose target is model node 'x', or whose targets are contained (entirely or in part) in the model variable 'x'.  If omitted, then all samplers are printed.
</p>
<p>type: a character vector containing sampler type names.  Only samplers with one of these specified types, as printed by this printSamplers method, will be displayed.  Standard regular expression mathing using is also applied.
</p>
<p>displayConjugateDependencies: A logical argument, specifying whether to display the dependency lists of conjugate samplers (default FALSE).
</p>
<p>displayNonScalars: A logical argument, specifying whether to display the values of non-scalar control list elements (default FALSE).
</p>
<p>executionOrder: A logical argument, specifying whether to print the sampler functions in the (possibly modified) order of execution (default FALSE).
</p>
<p>byType: A logical argument, specifying whether the nodes being sampled should be printed, sorted and organized according to the type of sampler (the sampling algorithm) which is acting on the nodes (default FALSE).</p>
</dd>
<dt><code>removeSampler(...)</code></dt><dd><p>Alias for removeSamplers method</p>
</dd>
<dt><code>removeSamplers(..., ind, print = FALSE)</code></dt><dd><p>Removes one or more samplers from an MCMCconf object.
</p>
<p>This function also has the side effect of resetting the sampler execution ordering so as to iterate over the remaining set of samplers, sequentially, executing each sampler once.
</p>
<p>Arguments:
</p>
<p>...: Character node names or numeric indices.  Character node names specify the node names for samplers to remove, or numeric indices can provide the indices of samplers to remove.
</p>
<p>ind: A numeric vector or character vector specifying the samplers to remove.  A numeric vector may specify the indices of the samplers to be removed.  Alternatively, a character vector may be used to specify a set of model nodes and/or variables, and all samplers whose 'target' is among these nodes will be removed.  If omitted, then all samplers are removed.
</p>
<p>print: A logical argument specifying whether to print the current list of samplers once the removal has been done (default FALSE).</p>
</dd>
<dt><code>replaceSampler(...)</code></dt><dd><p>Alias for replaceSamplers method</p>
</dd>
<dt><code>replaceSamplers(...)</code></dt><dd><p>Replaces one or more samplers from an MCMCconf object with newly specified sampler(s).  Operation and arguments are identical to the 'addSampler' method, with the additional side effect of first removing any existing samplers which operate on the specified node(s).
</p>
<p>This function also has the side effect of resetting the sampler execution ordering so as to iterate over the remaining set of samplers, sequentially, executing each sampler once.
</p>
<p>See 'addSamplers' for a description of the arguments.
</p>
<p>This function also has the side effect of resetting the sampler execution ordering so as to iterate over the newly specified set of samplers, sequentially, executing each sampler once.</p>
</dd>
<dt><code>resetMonitors()</code></dt><dd><p>Resets the current monitors and monitors2 lists to nothing.
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>setMonitors(..., ind = 1, print = TRUE)</code></dt><dd><p>Sets new variables to the list of monitors.
</p>
<p>Arguments:
</p>
<p>...: One or more character vectors of indexed nodes, or variables, which are to be monitored.  These replace the current monitors list.
</p>
<p>print: A logical argument specifying whether to print all current monitors (default TRUE).
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>setMonitors2(..., print = TRUE)</code></dt><dd><p>Sets new variables to the list of monitors2.
</p>
<p>Arguments:
</p>
<p>...: One or more character vectors of indexed nodes, or variables, which are to be monitored.  These replace the current monitors2 list.
</p>
<p>print: A logical argument specifying whether to print all current monitors (default TRUE).
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>setSampler(...)</code></dt><dd><p>Alias for setSamplers method</p>
</dd>
<dt><code>setSamplerExecutionOrder(order, print = FALSE)</code></dt><dd><p>Sets the ordering in which sampler functions will execute.
</p>
<p>This allows some samplers to be &quot;turned off&quot;, or others to execute multiple times in a single MCMC iteration.  The ordering in which samplers execute can also be interleaved.
</p>
<p>Arguments:
</p>
<p>order: A numeric vector, specifying the ordering in which the sampler functions will execute.  The indices of execution specified in this numeric vector correspond to the enumeration of samplers printed by printSamplers(), or returned by getSamplers().  If this argument is omitted, the sampler execution ordering is reset so as to sequentially execute each sampler once.
</p>
<p>print: A logical argument specifying whether to print the current list of samplers in the modified order of execution (default FALSE).</p>
</dd>
<dt><code>setSamplers(..., ind, print = FALSE)</code></dt><dd><p>Sets the ordering of the list of MCMC samplers.
</p>
<p>This function also has the side effect of resetting the sampler execution ordering so as to iterate over the specified set of samplers, sequentially, executing each sampler once.
</p>
<p>Arguments:
</p>
<p>...: Chracter strings or numeric indices.  Character names may be used to specify the node names for samplers to retain.  Numeric indices may be used to specify the indicies for the new list of MCMC samplers, in terms of the current ordered list of samplers.
</p>
<p>ind: A numeric vector or character vector.  A numeric vector may be used to specify the indicies for the new list of MCMC samplers, in terms of the current ordered list of samplers.
For example, if the MCMCconf object currently has 3 samplers, then the ordering may be reversed by calling MCMCconf$setSamplers(3:1), or all samplers may be removed by calling MCMCconf$setSamplers(numeric(0)).
</p>
<p>Alternatively, a character vector may be used to specify a set of model nodes and/or variables, and the sampler list will modified to only those samplers acting on these target nodes.
</p>
<p>As another alternative, a list of samplerConf objects may be used as the argument, in which case this ordered list of samplerConf objects will define the samplers in this MCMC configuration object, completely over-writing the current list of samplers.  No checking is done to ensure the validity of the contents of these samplerConf objects; only that all elements of the list argument are, in fact, samplerConf objects.
</p>
<p>print: A logical argument specifying whether to print the new list of samplers (default FALSE).</p>
</dd>
<dt><code>setThin(thin, print = TRUE, ind = 1)</code></dt><dd><p>Sets the value of thin.
</p>
<p>Arguments:
</p>
<p>thin: The new value for the thinning interval 'thin'.
</p>
<p>print: A logical argument specifying whether to print all current monitors (default TRUE).
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
<dt><code>setThin2(thin2, print = TRUE)</code></dt><dd><p>Sets the value of thin2.
</p>
<p>Arguments:
</p>
<p>thin2: The new value for the thinning interval 'thin2'.
</p>
<p>print: A logical argument specifying whether to print all current monitors (default TRUE).
</p>
<p>Details:
</p>
<p>See the initialize() function
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configureMCMC">configureMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
 mu ~ dnorm(0, 1)
 x ~ dnorm(mu, 1)
})
Rmodel &lt;- nimbleModel(code)
conf &lt;- configureMCMC(Rmodel)
conf$setSamplers(1)
conf$addSampler(target = 'x', type = 'slice', control = list(adaptInterval = 100))
conf$addMonitors('mu')
conf$addMonitors2('x')
conf$setThin(5)
conf$setThin2(10)
conf$printMonitors()
conf$printSamplers()
</code></pre>

<hr>
<h2 id='modelBaseClass-class'>Class <code>modelBaseClass</code></h2><span id='topic+modelBaseClass-class'></span><span id='topic+modelBaseClass'></span><span id='topic+getVarNames'></span><span id='topic+getNodeNames'></span><span id='topic+topologicallySortNodes'></span><span id='topic+resetData'></span><span id='topic+setData'></span><span id='topic+isData'></span><span id='topic+isEndNode'></span><span id='topic+getDistribution'></span><span id='topic+isDiscrete'></span><span id='topic+isBinary'></span><span id='topic+isStoch'></span><span id='topic+isDeterm'></span><span id='topic+isTruncated'></span><span id='topic+isUnivariate'></span><span id='topic+isMultivariate'></span><span id='topic+getDimension'></span><span id='topic+getDependencies'></span><span id='topic+getDependenciesList'></span><span id='topic+getDownstream'></span><span id='topic+expandNodeNames'></span><span id='topic+setInits'></span><span id='topic+checkConjugacy'></span><span id='topic+getCode'></span><span id='topic+getMacroInits'></span><span id='topic+getConstants'></span><span id='topic+newModel'></span><span id='topic+getParents'></span><span id='topic++5B+5B+2CmodelBaseClass-method'></span><span id='topic++5B+5B+3C-+2CmodelBaseClass-method'></span><span id='topic+initializeInfo'></span>

<h3>Description</h3>

<p>This class underlies all NIMBLE model objects: both R model objects created from the return value of nimbleModel(), and compiled model objects.
The model object contains a variety of member functions, for providing information about the model structure, setting or querying properties of the model, or accessing various internal components of the model.
These member functions of the modelBaseClass are commonly used in the body of the <code>setup</code> function argument to nimbleFunction(), to aid in preparation of node vectors, nimbleFunctionLists, and other runtime inputs.
See documentation for <code><a href="#topic+nimbleModel">nimbleModel</a></code> for details of creating an R model object.
</p>


<h3>Methods</h3>


<dl>
<dt><code>calculate(nodes)</code></dt><dd><p>See 'help(calculate)'</p>
</dd>
<dt><code>calculateDiff(nodes)</code></dt><dd><p>See 'help(calculateDiff)'</p>
</dd>
<dt><code>check()</code></dt><dd><p>Checks for errors in model specification and for missing values that prevent use of calculate/simulate on any nodes</p>
</dd>
<dt><code>checkBasics()</code></dt><dd><p>Checks for size/dimension mismatches and for presence of NAs in model variables (the latter is not an error but a note of this is given to the user)</p>
</dd>
<dt><code>checkConjugacy(nodeVector, restrictLink = NULL)</code></dt><dd><p>Determines whether or not the input nodes appear in conjugate relationships
</p>
<p>Arguments:
</p>
<p>nodeVector: A character vector specifying one or more node or variable names.  If omitted, all stochastic non-data nodes are checked for conjugacy.
</p>
<p>Details: The return value is a named list, with an element corresponding to each conjugate node.  The list names are the conjugate node names, and list elements are the control list arguments required by the corresponding MCMC conjugate sampler functions.  If no model nodes are conjugate, an empty list is returned.</p>
</dd>
<dt><code>expandNodeNames(
  nodes,
  env = parent.frame(),
  returnScalarComponents = FALSE,
  returnType = "names",
  sort = FALSE,
  unique = TRUE
)</code></dt><dd><p>Takes a vector of names of nodes or variables and returns the unique and expanded names in the model, i.e. 'x' expands to 'x[1]', 'x[2]', ...
</p>
<p>Arguments:
</p>
<p>nodes: a vector of names of nodes (or variables) to be expanded. Alternatively, can be a vector of integer graph IDs, but this use is intended only for advanced users
</p>
<p>returnScalarComponents: should multivariate nodes (i.e. dmnorm or dmulti) be broken up into scalar components?
</p>
<p>returnType: return type. Options are 'names' (character vector) or 'ids' (graph IDs)
</p>
<p>sort: should names be topologically sorted before being returned?
</p>
<p>unique: should names be the unique names or should original ordering of nodes (after expansion of any variable names into node names) be preserved</p>
</dd>
<dt><code>getBound(node, bound)</code></dt><dd><p>See 'help(getBound)'                                                                                                                                                                                                                               </p>
</dd>
<dt><code>getCode()</code></dt><dd><p>Return the code for a model after processing if-then-else statements, expanding macros, and replacing some keywords (e.g. nimStep for step) to avoid R ambiguity.</p>
</dd>
<dt><code>getConditionallyIndependentSets(
  nodes,
  givenNodes,
  omit = integer(),
  explore = c("both", "down", "up"),
  unknownAsGiven = TRUE,
  returnType = "names",
  returnScalarComponents = FALSE,
  endAsGiven = FALSE
)</code></dt><dd><p>see &quot;help(getConditionallyIndependentSets)&quot;, which this calls with the model as the first argument.</p>
</dd>
<dt><code>getConstants()</code></dt><dd><p>Return model constants, including any changes to the constants made by macros.</p>
</dd>
<dt><code>getDependencies(
  nodes,
  omit = character(),
  self = TRUE,
  determOnly = FALSE,
  stochOnly = FALSE,
  includeData = TRUE,
  dataOnly = FALSE,
  includePredictive = getNimbleOption("getDependenciesIncludesPredictiveNodes"),
  predictiveOnly = FALSE,
  includeRHSonly = FALSE,
  downstream = FALSE,
  returnType = "names",
  returnScalarComponents = FALSE
)</code></dt><dd><p>Returns a character vector of the nodes dependent upon the input argument nodes, sorted topologically according to the model graph. In the genealogical metaphor for a graphical model, this function returns the &quot;children&quot; of the input nodes.  In the river network metaphor, it returns downstream nodes. By default, the returned nodes include the input nodes, include both deterministic and stochastic nodes, and stop at stochastic nodes. Additional input arguments provide flexibility in the values returned.
</p>
<p>Arguments:
</p>
<p>nodes: Character vector of node names, with index blocks allowed, and/or variable names, the dependents of which will be returned.
</p>
<p>omit: Character vector of node names, which will be omitted from the nodes returned.  In addition, dependent nodes subsequent to these omitted nodes will not be returned.  The omitted nodes argument serves to stop the downward search within the hierarchical model structure, and excludes the specified node.
</p>
<p>self: Logical argument specifying whether to include the input argument nodes in the return vector of dependent nodes.  Default is TRUE.
</p>
<p>determOnly: Logical argument specifying whether to return only deterministic nodes.  Default is FALSE.
</p>
<p>stochOnly: Logical argument specifying whether to return only stochastic nodes.  Default is FALSE.  If both determOnly and stochOnly are TRUE, no nodes will be returned.
</p>
<p>includeData: Logical argument specifying whether to include 'data' nodes (set via nimbleModel or the setData method).  Default is TRUE.
</p>
<p>dataOnly: Logical argument specifying whether to return only 'data' nodes.  Default is FALSE.
</p>
<p>includePredictive: Logical argument specifying whether to include predictive nodes. Predictive nodes are stochastic nodes that are not data and have no downstream stochastic dependents that are data. In Bayesian settings, these are &quot;posterior predictive&quot; nodes. Used primarily to exclude predictive node calculations when setting up MCMC samplers on model parameters. Default value is controlled by 'nimbleOptions(&quot;getDependenciesIncludesPredictiveNodes&quot;)', which has a default value of 'TRUE'.
</p>
<p>predictiveOnly: Logical argument specifying whether to return only predictive nodes (see &quot;includePredictive&quot;). Default is FALSE.
</p>
<p>includeRHSonly: Logical argument specifying whether to include right-hand-side-only nodes (model nodes which never appear on the left-hand-side of ~ or &lt;- in the model code).  These nodes are neither stochastic nor deterministic, but instead function as variable inputs to the model.  Default is FALSE.
</p>
<p>downstream: Logical argument specifying whether the downward search through the hierarchical model structure should continue beyond the first and subsequent stochastic nodes encountered, hence returning all nodes downstream of the input nodes.  Default is FALSE.
</p>
<p>returnType: Character argument specifying type of object returned. Options are 'names' (returns character vector) and 'ids' (returns numeric graph IDs for model).
</p>
<p>returnScalarComponenets: Logical argument specifying whether multivariate nodes should be returned as full node names (i.e. 'x[1:2]') or as scalar componenets (i.e. 'x[1]' and 'x[2]').
</p>
<p>Details: The downward search for dependent nodes propagates through deterministic nodes, but by default will halt at the first level of stochastic nodes encountered.  Use getDependenciesList for a list of one-step dependent nodes of each node in the model.</p>
</dd>
<dt><code>getDependenciesList(returnNames = TRUE, sort = TRUE)</code></dt><dd><p>Returns a list of all dependent neighbor relationships.  Each list element gives the one-step dependencies of one vertex, and the element name is the vertex label (integer ID or character node name)
</p>
<p>Arguments:
</p>
<p>returnNames: If TRUE (default), list names and element contents are returns as character node names, e.g. 'x[1]'.  If FALSE, everything is returned using graph IDs, which are unique integer labels for each node.
</p>
<p>sort: If TRUE (default), each list element is returned in topologically sorted order.  If FALSE, they are returned in arbitrary order.
</p>
<p>Details: This provides a fairly raw representation of the graph (model) structure that may be useful for inspecting what NIMBLE has created from model code.</p>
</dd>
<dt><code>getDimension(
  node,
  params = NULL,
  valueOnly = is.null(params) &amp;&amp; !includeParams,
  includeParams = !is.null(params)
)</code></dt><dd><p>Determines the dimension of the value and/or parameters of the node
</p>
<p>Arguments:
</p>
<p>node: A character vector specifying a single node
</p>
<p>params: an optional character vector of names of parameters for which dimensions are desired (possibly including 'value' and alternate parameters)
</p>
<p>valueOnly: a logical indicating whether to only return the dimension of the value of the node
</p>
<p>includeParams: a logical indicating whether to return dimensions of parameters. If TRUE and 'params' is NULL then dimensions of all parameters, including the dimension of the value of the node, are returned
</p>
<p>Details: The return value is a numeric vector with an element for each parameter/value requested.</p>
</dd>
<dt><code>getDistribution(nodes)</code></dt><dd><p>Returns the names of the distributions for the requested node or nodes
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>Details: The return value is a character vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent node names, so the length of the output may be longer than that of the input.</p>
</dd>
<dt><code>getDownstream(...)</code></dt><dd><p>Identical to getDependencies(..., downstream = TRUE)
</p>
<p>Details: See documentation for member method getDependencies.</p>
</dd>
<dt><code>getLogProb(nodes)</code></dt><dd><p>See 'help(getLogProb)'</p>
</dd>
<dt><code>getMacroInits()</code></dt><dd><p>EXPERIMENTAL: Return initial values generated by macros.</p>
</dd>
<dt><code>getMacroParameters(
  includeLHS = TRUE,
  includeRHS = TRUE,
  includeDeterm = TRUE,
  includeStoch = TRUE,
  includeIndices = FALSE
)</code></dt><dd><p>See 'help(getMacroParameters)'</p>
</dd>
<dt><code>getNodeNames(
  determOnly = FALSE,
  stochOnly = FALSE,
  includeData = TRUE,
  dataOnly = FALSE,
  includeRHSonly = FALSE,
  topOnly = FALSE,
  latentOnly = FALSE,
  endOnly = FALSE,
  includePredictive = TRUE,
  predictiveOnly = FALSE,
  returnType = "names",
  returnScalarComponents = FALSE
)</code></dt><dd><p>Returns a character vector of all node names in the model, in topologically sorted order.  A variety of logical arguments allow for flexible subsetting of all model nodes.
</p>
<p>Arguments:
</p>
<p>determOnly: Logical argument specifying whether to return only deterministic nodes.  Default is FALSE.
</p>
<p>stochOnly: Logical argument specifying whether to return only stochastic nodes.  Default is FALSE.
</p>
<p>includeData: Logical argument specifying whether to include 'data' nodes (set via the member method setData).  Default is TRUE.
</p>
<p>dataOnly: Logical argument specifying whether to return only 'data' nodes.  Default is FALSE.
</p>
<p>includeRHSonly: Logical argument specifying whether to include right-hand-side-only nodes (model nodes which never appear on the left-hand-side of ~ or &lt;- in the model code).  Default is FALSE.
</p>
<p>topOnly: Logical argument specifying whether to return only top-level nodes from the hierarchical model structure.
</p>
<p>latentOnly: Logical argument specifying whether to return only latent (mid-level) nodes from the hierarchical model structure.
</p>
<p>endOnly: Logical argument specifying whether to return only end nodes from the hierarchical model structure.
</p>
<p>includePredictive: Logical argument specifying whether to include predictive nodes (stochastic nodes, which themselves are not data and have no downstream stochastic dependents which are data) from the hierarchical model structure.
</p>
<p>predictiveOnly: Logical argument specifying whether to return only predictive nodes (stochastic nodes, which themselves are not data and have no downstream stochastic dependents which are data) from the hierarchical model structure.
</p>
<p>returnType: Character argument specific type object returned. Options are 'names' (returns character vector) and 'ids' (returns numeric graph IDs for model)
</p>
<p>returnScalar Componenets: Logical argument specifying whether multivariate nodes should return full node name (i.e. 'x[1:2]') or should break down into scalar componenets (i.e. 'x[1]' and 'x[2]')
</p>
<p>Details: Multiple logical input arguments may be used simultaneously.  For example, &lsquo;model$getNodeNames(endOnly = TRUE, dataOnly = TRUE)' will return all end-level nodes from the model which are designated as &rsquo;data'.</p>
</dd>
<dt><code>getParam(node, param, warn = TRUE)</code></dt><dd><p>See 'help(getParam)'                                                                                                                                                                                                                               </p>
</dd>
<dt><code>getParents(
  nodes,
  omit = character(),
  self = FALSE,
  determOnly = FALSE,
  stochOnly = FALSE,
  includeData = TRUE,
  dataOnly = FALSE,
  includeRHSonly = FALSE,
  upstream = FALSE,
  immediateOnly = FALSE,
  returnType = "names",
  returnScalarComponents = FALSE
)</code></dt><dd><p> Returns a character vector of the nodes on which the input nodes depend, sorted topologically according to the model graph, by default recursing and stopping at stochastic parent nodes.  In the genealogical metaphor for a graphical model, this function returns the &quot;parents&quot; of the input nodes. In the river network metaphor, it returns upstream nodes.  By default, the returned nodes omit the input nodes. Additional input arguments provide flexibility in the values returned.
</p>
<p>Arguments:
</p>
<p>nodes: Character vector of node names, with index blocks allowed, and/or variable names, the parents of which will be returned.
</p>
<p>omit: Character vector of node names, which will be omitted from the nodes returned.  In addition, parent nodes beyond these omitted nodes will not be returned.  The omitted nodes argument serves to stop the upward search through the hierarchical model structure, and excludes the specified node.
</p>
<p>self: Logical argument specifying whether to include the input argument nodes in the return vector of dependent nodes.  Default is FALSE.
</p>
<p>determOnly: Logical argument specifying whether to return only deterministic nodes.  Default is FALSE.
</p>
<p>stochOnly: Logical argument specifying whether to return only stochastic nodes.  Default is FALSE.  If both determOnly and stochOnly are TRUE, no nodes will be returned.
</p>
<p>includeData: Logical argument specifying whether to include 'data' nodes (set via nimbleModel or the setData method).  Default is TRUE.
</p>
<p>dataOnly: Logical argument specifying whether to return only 'data' nodes.  Default is FALSE.
</p>
<p>includeRHSonly: Logical argument specifying whether to include right-hand-side-only nodes (model nodes which never appear on the left-hand-side of ~ or &lt;- in the model code).  These nodes are neither stochastic nor deterministic, but instead function as variable inputs to the model.  Default is FALSE.
</p>
<p>upstream: Logical argument specifying whether the upward search through the hierarchical model structure should continue beyond the first and subsequent stochastic nodes encountered, hence returning all nodes upstream of the input nodes.  Default is FALSE.
</p>
<p>immediateOnly: Logical argument specifying whether only the immediate parent nodes should be returned, even if they are deterministic.  If FALSE, getParents recurses and stops at stochastic nodes.  Default is FALSE.
</p>
<p>returnType: Character argument specifying type of object returned. Options are 'names' (returns character vector) and 'ids' (returns numeric graph IDs for model).
</p>
<p>returnScalarComponenets: Logical argument specifying whether multivariate nodes should be returned as full node names (i.e. 'x[1:2]') or as scalar componenets (i.e. 'x[1]' and 'x[2]').
</p>
<p>Details: The upward search for dependent nodes propagates through deterministic nodes, but by default will halt at the first level of stochastic nodes encountered.  Use getParentsList for a list of one-step parent nodes of each node in the model.</p>
</dd>
<dt><code>getParentsList(returnNames = TRUE, sort = TRUE)</code></dt><dd><p>Returns a list of all parent neighbor relationships.  Each list element gives the one-step parents of one vertex, and the element name is the vertex label (integer ID or character node name)
</p>
<p>Arguments:
</p>
<p>returnNames: If TRUE (default), list names and element contents are returns as character node names, e.g. 'x[1]'.  If FALSE, everything is returned using graph IDs, which are unique integer labels for each node.
</p>
<p>sort: If TRUE (default), each list element is returned in topologically sorted order.  If FALSE, they are returned in arbitrary order.
</p>
<p>Details: This provides a fairly raw representation of the graph (model) structure that may be useful for inspecting what NIMBLE has created from model code.</p>
</dd>
<dt><code>getVarNames(includeLogProb = FALSE, nodes)</code></dt><dd><p>Returns the names of all variables in a model, optionally including the logProb variables
</p>
<p>Arguments:
</p>
<p>logProb: Logical argument specifying whether or not to include the logProb variables.  Default is FALSE.
</p>
<p>nodes: An optional character vector supplying a subset of nodes for which to extract the variable names and return the unique set of variable names</p>
</dd>
<dt><code>initializeInfo(stochasticLogProbs = FALSE)</code></dt><dd><p>Provides more detailed information on which model nodes are not initialized.
</p>
<p>Arguments:
</p>
<p>stochasticLogProbs: Boolean argument. If TRUE, the log-density value associated with each stochastic model variable is calculated and printed.</p>
</dd>
<dt><code>isBinary(nodes)</code></dt><dd><p>Determines whether one or more nodes represent binary random variables
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>Details: The return value is a character vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent node names, so the length of the output may be longer than that of the input.</p>
</dd>
<dt><code>isData(nodes)</code></dt><dd><p>Returns a vector of logical TRUE / FALSE values, corresponding to the 'data' flags of the input node names.
</p>
<p>Arguments:
</p>
<p>nodes: A character vector of node or variable names.
</p>
<p>Details: The variable or node names specified is expanded into a vector of model node names. A logical vector is returned, indicating whether each model node has been flagged as containing 'data'. Multivariate nodes for which any elements are flagged as containing 'data' will be assigned a value of TRUE.</p>
</dd>
<dt><code>isDeterm(nodes, includeRHSonly = FALSE, nodesAlreadyExpanded = FALSE)</code></dt><dd><p>Determines whether one or more nodes are deterministic
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>nodesAlreadyExpanded: Boolean argument indicating whether 'nodes' should be expanded. Generally intended for internal use. Default is 'FALSE'.
</p>
<p>Details: The return value is a character vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent node names, so the length of the output may be longer than that of the input.</p>
</dd>
<dt><code>isDiscrete(nodes)</code></dt><dd><p>Determines whether one or more nodes represent discrete random variables
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>Details: The return value is a character vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent node names, so the length of the output may be longer than that of the input.</p>
</dd>
<dt><code>isEndNode(nodes)</code></dt><dd><p>Determines whether one or more nodes are end nodes (nodes with no stochastic dependences)
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>Details: The return value is logical vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent node names, so the length of the output may be longer than that of the input.</p>
</dd>
<dt><code>isMultivariate(nodes)</code></dt><dd><p>Determines whether one or more nodes represent multivariate nodes
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>Details: The return value is a logical vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent node names, so the length of the output may be longer than that of the input.</p>
</dd>
<dt><code>isStoch(nodes, nodesAlreadyExpanded = FALSE)</code></dt><dd><p>Determines whether one or more nodes are stochastic
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>nodesAlreadyExpanded: Boolean argument indicating whether 'nodes' should be expanded. Generally intended for internal use. Default is 'FALSE'.
</p>
<p>Details: The return value is a character vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent node names, so the length of the output may be longer than that of the input.</p>
</dd>
<dt><code>isTruncated(nodes)</code></dt><dd><p>Determines whether one or more nodes are truncated
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>Details: The return value is a character vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent nodes names, so the length of the output may be longer than that of the input</p>
</dd>
<dt><code>isUnivariate(nodes)</code></dt><dd><p>Determines whether one or more nodes represent univariate random variables
</p>
<p>Arguments:
</p>
<p>nodes: A character vector specifying one or more node or variable names.
</p>
<p>Details: The return value is a character vector with an element for each node indicated in the input. Note that variable names are expanded to their constituent nodes names, so the length of the output may be longer than that of the input</p>
</dd>
<dt><code>newModel(
  data = NULL,
  inits = NULL,
  modelName = character(),
  replicate = FALSE,
  check = getNimbleOption("checkModel"),
  calculate = TRUE
)</code></dt><dd><p>Returns a new R model object, with the same model definiton (as defined from the original model code) as the existing model object.
</p>
<p>Arguments:
</p>
<p>data: A named list specifying data nodes and values, for use in the newly returned model.  If not provided, the data argument from the creation of the original R model object will be used.
</p>
<p>inits: A named list specifying initial valuse, for use in the newly returned model.  If not provided, the inits argument from the creation of the original R model object will be used.
</p>
<p>modelName: An optional character string, used to set the internal name of the model object.  If provided, this name will propagate throughout the generated C++ code, serving to improve readability.
</p>
<p>replicate: Logical specifying whether to replicate all current values and data flags from the current model in the new model.  If TRUE, then the data and inits arguments are not used.  Default value is FALSE.
</p>
<p>check: A logical indicating whether to check the model object for missing or invalid values.  Default is given by the NIMBLE option 'checkModel', see help on 'nimbleOptions' for details. 
</p>
<p>calculate: A logical indicating whether to run 'calculate' on the model; this will calculate all deterministic nodes and logProbability values given the current state of all nodes. Default is TRUE. For large models, one might want to disable this, but note that deterministic nodes, including nodes introduced into the model by NIMBLE, may be NA. 
</p>
<p>Details: The newly created model object will be identical to the original model in terms of structure and functionality, but entirely distinct in terms of the internal values.</p>
</dd>
<dt><code>resetData()</code></dt><dd><p>Resets the 'data' property of ALL model nodes to FALSE.  Subsequent to this call, the model will have no nodes flagged as 'data'.</p>
</dd>
<dt><code>setData(..., warnAboutMissingNames = TRUE)</code></dt><dd><p>Sets the 'data' flag for specified stochastic nodes to TRUE, and also sets the value of these nodes to the value provided.  This is the exclusive method for specifying 'data' nodes in a model object.  When a 'data' argument is provided to 'nimbleModel()', it uses this method to set the data nodes. This also allows one to set the 'data' flag for nodes appearing only on the right-hand side of model declarations, thereby preventing their values from being overwritten via 'inits'.
</p>
<p>Arguments:
</p>
<p>...:  Arguments may be provided as named elements with numeric values or as character names of model variables.  These may be provided in a single list, a single character vector, or as multiple arguments.  When a named element with a numeric value is provided, the size and dimension must match the corresponding model variable.  This value will be copied to the model variable and any non-NA elements will be marked as data.  When a character name is provided, the value of that variable in the model is not changed but any currently non-NA values are marked as data.  Examples: setData('x', y = 1:10) will mark both x and y as data and will set the value of y to 1:10.  setData(list('x', y = 1:10)) is equivalent.  setData(c('x','y')) or setData('x','y') will mark both x and y as data.
</p>
<p>Details: If a provided value (or the current value in the model when only a name is specified) contains some NA values, then the model nodes corresponding to these NAs will not have their value set, and will not be designated as 'data'.  Only model nodes corresponding to numeric values in the argument list elements will be designated as data.  Designating a deterministic model node as 'data' will be ignored.  Designating part of a multivariate node as 'data' and part as non-data (NA) is allowed, but 'isData()' will report such a node as being 'data', calculations with the node will generally return NA, and MCMC samplers will not be assigned to such nodes.</p>
</dd>
<dt><code>setInits(inits)</code></dt><dd><p>Sets initial values (or more generally, any named list of value elements) into the model
</p>
<p>Arguments:
</p>
<p>inits: A named list.  The names of list elements must correspond to model variable names.  The elements of the list must be of class numeric, with size and dimension each matching the corresponding model variable.</p>
</dd>
<dt><code>simulate(nodes, includeData = FALSE)</code></dt><dd><p>See 'help(simulate)'                                                                                                                                                                                                                                </p>
</dd>
<dt><code>topologicallySortNodes(nodes, returnType = "names")</code></dt><dd><p>Sorts the input list of node names according to the topological dependence ordering of the model structure.
</p>
<p>Arguments:
</p>
<p>nodes: A character vector of node or variable names, which is to be topologically sorted. Alternatively can be a numeric vector of graphIDs
</p>
<p>returnType: character vector indicating return type. Choices are &quot;names&quot; or &quot;ids&quot;
</p>
<p>Details: This function merely reorders its input argument.  This may be important prior to calls such as model$simulate(nodes) or model$calculate(nodes), to enforce that the operation is performed in topological order.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initializeModel">initializeModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    mu ~ dnorm(0, 1)
    x[1] ~ dnorm(mu, 1)
    x[2] ~ dnorm(mu, 1)
})
Rmodel &lt;- nimbleModel(code)
modelVars &lt;- Rmodel$getVarNames()   ## returns 'mu' and 'x'
modelNodes &lt;- Rmodel$getNodeNames()   ## returns 'mu', 'x[1]' and 'x[2]'
Rmodel$resetData()
Rmodel$setData(list(x = c(1.2, NA)))   ## flags only 'x[1]' node as data
Rmodel$isData(c('mu', 'x[1]', 'x[2]'))   ## returns c(FALSE, TRUE, FALSE)
</code></pre>

<hr>
<h2 id='modelDefClass-class'>Class for NIMBLE model definition</h2><span id='topic+modelDefClass-class'></span><span id='topic+modelDefClass'></span>

<h3>Description</h3>

<p>Class for NIMBLE model definition that is not usually needed directly by a user.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+modelBaseClass">modelBaseClass</a></code> for information about creating NIMBLE BUGS models.
</p>

<hr>
<h2 id='modelInitialization'>Information on initial values in a NIMBLE model</h2><span id='topic+modelInitialization'></span>

<h3>Description</h3>

<p>Having uninitialized nodes in a NIMBLE model can potentially cause some algorithms to fail and can lead to poor performance in others.  Here are some
general guidelines on how non-initialized variables can affect performance:
</p>

<ul>
<li><p> MCMC will auto-initialize but will do so from the prior distribution.  This can cause slow convergence, especially in the case of diffuse priors.
</p>
</li>
<li><p> Likewise, particle filtering methods will initialize top-level parameters from their prior distributions, which can lead to errors or poor performance in these methods.
</p>
</li></ul>

<p>Please see this Section (<a href="https://r-nimble.org/html_manual/cha-mcmc.html#sec:initMCMC">https://r-nimble.org/html_manual/cha-mcmc.html#sec:initMCMC</a>) of the NIMBLE user manual for further suggestions.
</p>

<hr>
<h2 id='modelValues'>Create a NIMBLE modelValues Object</h2><span id='topic+modelValues'></span>

<h3>Description</h3>

<p>Builds modelValues object from a model values configuration object, which can include a NIMBLE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelValues(conf, m = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelValues_+3A_conf">conf</code></td>
<td>
<p>An object which includes information for building modelValues. Can either be a NIMBLE model (see <code>help(modelBaseClass)</code>) 
or the object returned from <code>modelValuesConf</code></p>
</td></tr>
<tr><td><code id="modelValues_+3A_m">m</code></td>
<td>
<p>The number of rows to create in the modelValues object.  Can later be changed with <code>resize</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> or <code>help(modelValuesBaseClass)</code> for information about manipulating NIMBLE modelValues object returned by this function
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#From model object:
code &lt;- nimbleCode({
 a ~ dnorm(0,1)
 for(i in 1:3){
	for(j in 1:3)
		b[i,j] ~ dnorm(0,1)
	}
})
Rmodel &lt;- nimbleModel(code)
Rmodel_mv &lt;- modelValues(Rmodel, m = 2)
#Custom modelValues object:
mvConf &lt;- modelValuesConf(vars = c('x', 'y'),
             types = c('double', 'int'),
             sizes = list(x = 3, y = c(2,2)))
custom_mv &lt;- modelValues(mvConf, m = 2)
custom_mv['y',]
</code></pre>

<hr>
<h2 id='modelValuesBaseClass-class'>Class <code>modelValuesBaseClass</code></h2><span id='topic+modelValuesBaseClass-class'></span><span id='topic+modelValuesBaseClass'></span><span id='topic++5B+2CCmodelValues-method'></span><span id='topic++5B+3C-+2CCmodelValues-method'></span><span id='topic++5B+5B+2CCmodelValues-method'></span><span id='topic++5B+5B+3C-+2CCmodelValues-method'></span><span id='topic++5B+2CCmodelValues-method+2Ccharacter+2Cmissing'></span><span id='topic++5B+2CmodelValuesBaseClass-method'></span><span id='topic++5B+3C-+2CmodelValuesBaseClass-method'></span><span id='topic++5B+2CCmodelValues-method+2Ccharacter+2Cmissing+2CANY-method'></span><span id='topic++5B+2CCmodelValues-method+2CANY+2CANY'></span>

<h3>Description</h3>

<p>modelValues are NIMBLE containers built to store values from models. They can either be built directly from 
a model or be custom built via the <code>modelValuesConf</code> function. They consist of rows, where each
row can be thought of as a set of values from a model. Like most nimble objects, and unlike most
R objects, they are passed by reference instead of by value. 
</p>
<p>See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mvConf &lt;- modelValuesConf(vars = c('a', 'b'), 
	types = c('double', 'double'), 
	sizes = list(a = 1, b = c(2,2) ) )
mv &lt;- modelValues(mvConf)
as.matrix(mv)
resize(mv, 2)
as.matrix(mv)
mv['a',1] &lt;- 1
mv['a',2] &lt;- 2
mv['b',1] &lt;- matrix(0, nrow = 2, ncol = 2)
mv['b',2] &lt;- matrix(1, nrow = 2, ncol = 2)
mv['a',]
as.matrix(mv)
basicModelCode &lt;- nimbleCode({
a ~ dnorm(0,1)
for(i in 1:4)
	b[i] ~ dnorm(0,1)
})
basicModel &lt;- nimbleModel(basicModelCode)
basicMV &lt;- modelValues(basicModel, m = 2)	# m sets the number of rows
basicMV['b',]
</code></pre>

<hr>
<h2 id='modelValuesConf'>Create the confs for a custom NIMBLE modelValues object</h2><span id='topic+modelValuesConf'></span>

<h3>Description</h3>

<p>Builds an R-based modelValues conf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelValuesConf(
  symTab,
  className,
  vars,
  types,
  sizes,
  modelDef = NA,
  where = globalenv()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelValuesConf_+3A_symtab">symTab</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="modelValuesConf_+3A_classname">className</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="modelValuesConf_+3A_vars">vars</code></td>
<td>
<p>A vector of character strings naming each variable in the modelValues object</p>
</td></tr>
<tr><td><code id="modelValuesConf_+3A_types">types</code></td>
<td>
<p>A vector of character strings describing the type of data for the modelValues object.
Options include &lsquo;double&rsquo; (for real-valued variables) and &lsquo;int&rsquo;.</p>
</td></tr>
<tr><td><code id="modelValuesConf_+3A_sizes">sizes</code></td>
<td>
<p>A list in which the named items of the list match the <code>var</code> arguments and each item is a numeric vector of the dimensions</p>
</td></tr>
<tr><td><code id="modelValuesConf_+3A_modeldef">modelDef</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="modelValuesConf_+3A_where">where</code></td>
<td>
<p>For internal use only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> or <code>help(modelValuesBaseClass)</code> and <code>help(modelValues)</code> for information
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Custom modelValues object:
mvConf &lt;- modelValuesConf(vars = c('x', 'y'), 
				types = c('double', 'int'), 
			sizes = list(x = 3, y = c(2,2)))
custom_mv &lt;- modelValues(mvConf, m = 2)
custom_mv['y',]
</code></pre>

<hr>
<h2 id='Multinomial'>The Multinomial Distribution</h2><span id='topic+Multinomial'></span><span id='topic+multinomial'></span><span id='topic+dmulti'></span><span id='topic+rmulti'></span>

<h3>Description</h3>

<p>Density and random generation for the multinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmulti(x, size = sum(x), prob, log = FALSE)

rmulti(n = 1, size, prob)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Multinomial_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_size">size</code></td>
<td>
<p>number of trials.</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_prob">prob</code></td>
<td>
<p>vector of probabilities, internally normalized to sum to one, of same length as <code>x</code></p>
</td></tr>
<tr><td><code id="Multinomial_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A or the BUGS manual for mathematical details.
</p>


<h3>Value</h3>

<p><code>dmulti</code> gives the density and <code>rmulti</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size &lt;- 30
probs &lt;- c(1/4, 1/10, 1 - 1/4 - 1/10)
x &lt;- rmulti(1, size, probs)
dmulti(x, size, probs)
</code></pre>

<hr>
<h2 id='Multivariate-t'>The Multivariate t Distribution</h2><span id='topic+Multivariate-t'></span><span id='topic+mvt'></span><span id='topic+multivariate-t'></span><span id='topic+dmvt_chol'></span><span id='topic+rmvt_chol'></span>

<h3>Description</h3>

<p>Density and random generation for the multivariate t distribution, using the Cholesky factor of either the precision matrix (i.e., inverse scale matrix) or the scale matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvt_chol(x, mu, cholesky, df, prec_param = TRUE, log = FALSE)

rmvt_chol(n = 1, mu, cholesky, df, prec_param = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Multivariate-t_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Multivariate-t_+3A_mu">mu</code></td>
<td>
<p>vector of values giving the location of the distribution.</p>
</td></tr>
<tr><td><code id="Multivariate-t_+3A_cholesky">cholesky</code></td>
<td>
<p>upper-triangular Cholesky factor of either the precision matrix (i.e., inverse scale matrix) (when <code>prec_param</code> is TRUE) or scale matrix (otherwise).</p>
</td></tr>
<tr><td><code id="Multivariate-t_+3A_df">df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code id="Multivariate-t_+3A_prec_param">prec_param</code></td>
<td>
<p>logical; if TRUE the Cholesky factor is that of the precision matrix; otherwise, of the scale matrix.</p>
</td></tr>
<tr><td><code id="Multivariate-t_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Multivariate-t_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A or the BUGS manual for mathematical details. The 'precision' matrix as used here is defined as the inverse of the scale matrix, <code class="reqn">\Sigma^{-1}</code>, given in Gelman et al.
</p>


<h3>Value</h3>

<p><code>dmvt_chol</code> gives the density and <code>rmvt_chol</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Peter Sujan
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(-10, 0, 10)
scalemat &lt;- matrix(c(1, .9, .3, .9, 1, -0.1, .3, -0.1, 1), 3)
ch &lt;- chol(scalemat)
x &lt;- rmvt_chol(1, mu, ch, df = 1, prec_param = FALSE)
dmvt_chol(x, mu, ch, df = 1, prec_param = FALSE)

</code></pre>

<hr>
<h2 id='MultivariateNormal'>The Multivariate Normal Distribution</h2><span id='topic+MultivariateNormal'></span><span id='topic+dmnorm_chol'></span><span id='topic+rmnorm_chol'></span>

<h3>Description</h3>

<p>Density and random generation for the multivariate normal distribution, using the Cholesky factor of either the precision matrix or the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnorm_chol(x, mean, cholesky, prec_param = TRUE, log = FALSE)

rmnorm_chol(n = 1, mean, cholesky, prec_param = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MultivariateNormal_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="MultivariateNormal_+3A_mean">mean</code></td>
<td>
<p>vector of values giving the mean of the distribution.</p>
</td></tr>
<tr><td><code id="MultivariateNormal_+3A_cholesky">cholesky</code></td>
<td>
<p>upper-triangular Cholesky factor of either the precision matrix (when <code>prec_param</code> is TRUE) or covariance matrix (otherwise).</p>
</td></tr>
<tr><td><code id="MultivariateNormal_+3A_prec_param">prec_param</code></td>
<td>
<p>logical; if TRUE the Cholesky factor is that of the precision matrix; otherwise, of the covariance matrix.</p>
</td></tr>
<tr><td><code id="MultivariateNormal_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="MultivariateNormal_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A or the BUGS manual for mathematical details. The rate matrix as used here is defined as the inverse of the scale matrix, <code class="reqn">S^{-1}</code>, given in Gelman et al.
</p>


<h3>Value</h3>

<p><code>dmnorm_chol</code> gives the density and <code>rmnorm_chol</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean &lt;- c(-10, 0, 10)
covmat &lt;- matrix(c(1, .9, .3, .9, 1, -0.1, .3, -0.1, 1), 3)
ch &lt;- chol(covmat)
x &lt;- rmnorm_chol(1, mean, ch, prec_param = FALSE)
dmnorm_chol(x, mean, ch, prec_param = FALSE)
</code></pre>

<hr>
<h2 id='nfMethod'>access (call) a member function of a nimbleFunction</h2><span id='topic+nfMethod'></span>

<h3>Description</h3>

<p>Internal function for accessing a member function (method) of a nimbleFunction.  Normally a user will write <code>nf$method(x)</code> instead of <code>nfMethod(nf, method)(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nfMethod(nf, methodName)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nfMethod_+3A_nf">nf</code></td>
<td>
<p>a specialized nimbleFunction, i.e. one that has already had setup parameters processed</p>
</td></tr>
<tr><td><code id="nfMethod_+3A_methodname">methodName</code></td>
<td>
<p>a character string giving the name of the member function to call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>nimbleFunctions have a default member function called <code>run</code>, and may have other member functions provided via the <code>methods</code> argument to <code>nimbleFunction</code>.
As an internal step, the NIMBLE compiler turns <code>nf$method(x)</code> into <code>nfMethod(nf, method)(x)</code>, but a NIMBLE user or programmer would not normally need to use <code>nfMethod</code> directly.
</p>


<h3>Value</h3>

<p>a function that can be called.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='nfVar'>Access or set a member variable of a nimbleFunction</h2><span id='topic+nfVar'></span><span id='topic+nfVar+3C-'></span>

<h3>Description</h3>

<p>Access or set a member variable of a specialized nimbleFunction, i.e. a variable passed to or created during the <code>setup</code> function that is used in run code or preserved by <code>setupOutputs</code>.  Works in R for any variable and in NIMBLE for numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nfVar(nf, varName)

nfVar(nf, varName) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nfVar_+3A_nf">nf</code></td>
<td>
<p>a specialized nimbleFunction, i.e. a function returned by executing a function returned from <code>nimbleFunction</code> with <code>setup</code> arguments</p>
</td></tr>
<tr><td><code id="nfVar_+3A_varname">varName</code></td>
<td>
<p>a character string naming a variable in the <code>setup</code> function.</p>
</td></tr>
<tr><td><code id="nfVar_+3A_value">value</code></td>
<td>
<p>value to set the variable to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal way to access or set a member variable of a nimbleFunction created during <code>setup</code>.  Normally in NIMBLE code you would use <code>nf$var</code> instead of <code>nfVar(nf, var)</code>.
</p>
<p>When <code>nimbleFunction</code> is called and a <code>setup</code> function is provided, then <code>nimbleFunction</code> returns a function.  That function is a generator that should be called with arguments to the <code>setup</code> function and returns another function with <code>run</code> and possibly other member functions.  The member functions can use objects created or passed to <code>setup</code>.  During internal processing, the NIMBLE compiler turns some cases of <code>nf$var</code> into <code>nfVar(nf, var)</code>. These provide direct access to setup variables (member data).  <code>nfVar</code> is not typically called by a NIMBLE user or programmer.
</p>
<p>For internal access to methods of <code>nf</code>, see <code><a href="#topic+nfMethod">nfMethod</a></code>.
</p>
<p>For more information, see <code>?nimbleFunction</code> and the NIMBLE <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a>.
</p>


<h3>Value</h3>

<p>whatever varName is in the nimbleFunction nf.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nfGen1 &lt;- nimbleFunction(
    setup = function(A) {
    B &lt;- matrix(rnorm(4), nrow = 2)
    setupOutputs(B) ## preserves B even though it is not used in run-code
   },
   run = function() {
      print('This is A', A, '\n')
})

nfGen2 &lt;- nimbleFunction(
  setup = function() {
    nf1 &lt;- nfGen1(1000)
  },
  run = function() {
      print('accessing A:', nfVar(nf1, 'A'))
      nfVar(nf1, 'B')[2,2] &lt;&lt;- -1000
      print('accessing B:', nfVar(nf1, 'B'))
   })
       
nf2 &lt;- nfGen2()
nf2$run()
</code></pre>

<hr>
<h2 id='nimble-internal'>Functions and Classes Internal to NIMBLE</h2><span id='topic+as.list.modelValuesBaseClass-Class'></span><span id='topic+as.matrix.modelValuesBaseClass-Class'></span><span id='topic+autoBlockClass-Class'></span><span id='topic+BUGScontextClass-Class'></span><span id='topic+BUGSsingleContextClass-Class'></span><span id='topic+CmultiNimbleFunctionClass-Class'></span><span id='topic+CmultiNimbleListClass-Class'></span><span id='topic+CmultiNimbleObjClass-Class'></span><span id='topic+conjugacyClass-Class'></span><span id='topic+conjugacyRelationshipsClass-Class'></span><span id='topic+copyExprClass-Class'></span><span id='topic+cppBUGSmodelClass-Class'></span><span id='topic+cppCodeFileClass-Class'></span><span id='topic+cppCPPfileClass-Class'></span><span id='topic+cppHfileClass-Class'></span><span id='topic+cppModelValuesClass-Class'></span><span id='topic+cppNamedObjectsClass-Class'></span><span id='topic+cppNimbleClassClass-Class'></span><span id='topic+cppNimbleFunctionClass-Class'></span><span id='topic+cppNimbleListClass-Class'></span><span id='topic+cppProjectClass-Class'></span><span id='topic+cppVirtualNimbleFunctionClass-Class'></span><span id='topic+dependentClass-Class'></span><span id='topic+distClass-Class'></span><span id='topic+distributionsClass-Class'></span><span id='topic+eigenize_nimbleNullaryClass-Class'></span><span id='topic+exprClass-Class'></span><span id='topic+exprTypeInfoClass-Class'></span><span id='topic+findMethodsInExprClass-Class'></span><span id='topic+indexedNodeInfoTableClass-Class'></span><span id='topic+keywordInfoClass-Class'></span><span id='topic+MakeCustomModelClass-Class'></span><span id='topic+makeCustomModelValuesClass-Class'></span><span id='topic+mapsClass-Class'></span><span id='topic+modelDefInfoClass-Class'></span><span id='topic+mvInfoClass-Class'></span><span id='topic+nfCompilationInfoClass-Class'></span><span id='topic+nimbleGraphClass-Class'></span><span id='topic+nimbleListDefClass-Class'></span><span id='topic+nimbleProjectClass-Class'></span><span id='topic+nimDerivsInfoClass-Class'></span><span id='topic+nlCompilationInfoClass-Class'></span><span id='topic+posteriorClass-Class'></span><span id='topic+RCfunctionCompileClass-Class'></span><span id='topic+RCfunInfoClass-Class'></span><span id='topic+RMakeCustomModelClass-Class'></span><span id='topic+setupCodeTemplateClass-Class'></span><span id='topic+singleModelValuesAccessClass-Class'></span><span id='topic+varInfoClass-Class'></span><span id='topic++5B+2CnumberedModelValuesAccessors-method'></span><span id='topic++5B+3C-+2CnumberedModelValuesAccessors-method'></span><span id='topic++5B+2CnumberedObjects-method'></span><span id='topic++5B+3C-+2CnumberedObjects-method'></span><span id='topic++5B+5B+2CCNumericList-method'></span><span id='topic++5B+5B+3C-+2CCNumericList-method'></span><span id='topic++5B+5B+2CRNumericList-method'></span><span id='topic++5B+5B+3C-+2CRNumericList-method'></span><span id='topic++5B+5B+2CnimPointerList-method'></span><span id='topic++5B+5B+3C-+2CnimPointerList-method'></span><span id='topic++5B+5B+3C-+2CnimbleFunctionList-method'></span><span id='topic++5B+2CdistributionsClass-method'></span><span id='topic++5B+5B+2CdistributionsClass-method'></span><span id='topic++5B+5B+2CconjugacyRelationshipsClass-method'></span><span id='topic+dsqrtinvgamma'></span><span id='topic+rsqrtinvgamma'></span><span id='topic+is.Cmodel'></span><span id='topic+is.Cnf'></span><span id='topic+is.Rmodel'></span><span id='topic+is.model'></span><span id='topic+nf_preProcessMemberDataObject'></span><span id='topic+samplesSummary'></span><span id='topic+AGHQuad_params'></span><span id='topic+AGHQuad_summary'></span><span id='topic+messageIfVerbose'></span><span id='topic+calc_dmnormConjugacyContributions'></span><span id='topic+calc_dmnormAltParams'></span><span id='topic+calc_dwishAltParams'></span><span id='topic+calc_dcatConjugacyContributions'></span><span id='topic+CAR_calcM'></span><span id='topic+CAR_calcC'></span><span id='topic+CAR_calcCmatrix'></span><span id='topic+CAR_calcEVs2'></span><span id='topic+CAR_calcEVs3'></span><span id='topic+getNodeFunctionIndexedInfo'></span><span id='topic+singleModelValuesAccess'></span><span id='topic+getNimbleProject'></span><span id='topic+cc_getNodesInExpr'></span><span id='topic+calcAdaptationFactor'></span><span id='topic+is.nfGenerator'></span><span id='topic+mcmc_createModelObject'></span><span id='topic+nimbleInternalFunctions'></span><span id='topic+nimbleUserNamespace'></span><span id='topic+MCEM_mcse'></span>

<h3>Description</h3>

<p>Functions and classes used internally in NIMBLE and not expected to be called directly by users. Some functions and classes not intended for direct use are documented and/or exported because they are used within Reference Class methods for classes programmatically generated by NIMBLE.
</p>


<h3>Author(s)</h3>

<p>NIMBLE Development Team</p>

<hr>
<h2 id='nimble-math'>Mathematical functions for BUGS and nimbleFunction programming</h2><span id='topic+besselK'></span><span id='topic+cloglog'></span><span id='topic+cube'></span><span id='topic+expit'></span><span id='topic+icloglog'></span><span id='topic+ilogit'></span><span id='topic+inprod'></span><span id='topic+inverse'></span><span id='topic+iprobit'></span><span id='topic+logdet'></span><span id='topic+logfact'></span><span id='topic+loggam'></span><span id='topic+logit'></span><span id='topic+nimEquals'></span><span id='topic+nimRound'></span><span id='topic+nimStep'></span><span id='topic+nimSwitch'></span><span id='topic+phi'></span><span id='topic+pow'></span><span id='topic+probit'></span>

<h3>Description</h3>

<p>Mathematical functions for use in BUGS code and in nimbleFunction programming (i.e., nimbleFunction run code). See Chapter 5 of the User Manual for more details.
</p>


<h3>Author(s)</h3>

<p>NIMBLE Development Team</p>

<hr>
<h2 id='nimble-R-functions'>NIMBLE language functions for R-like vector construction</h2><span id='topic+nimble-R-functions'></span><span id='topic+nimC'></span><span id='topic+nimRep'></span><span id='topic+nimSeq'></span><span id='topic+c'></span><span id='topic+rep'></span><span id='topic+seq'></span><span id='topic+which'></span><span id='topic+diag'></span><span id='topic+length'></span><span id='topic+seq_along'></span><span id='topic+is.na'></span><span id='topic+is.nan'></span><span id='topic+any'></span><span id='topic+all'></span>

<h3>Description</h3>

<p>The functions <code>c</code>, <code>rep</code>, <code>seq</code>, <code>which</code>, <code>diag</code>, <code>length</code>, <code>seq_along</code>, <code>is.na</code>, <code>is.nan</code>, <code>any</code>, and <code>all</code> can be used in nimbleFunctions and compiled using <code>compileNimble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimC(...)

nimRep(x, ...)

nimSeq(from, to, by, length.out)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimble-R-functions_+3A_...">...</code></td>
<td>
<p>values to be concatenated.</p>
</td></tr>
<tr><td><code id="nimble-R-functions_+3A_x">x</code></td>
<td>
<p>vector of values to be replicated (<code>rep</code>), or logical array or vector (<code>which</code>), or object whose length is wanted (<code>length</code>), or input value (<code>diag</code>), or vector of values to be tested/checked (<code>is.na</code>, <code>is.nan</code>, <code>any</code>, <code>all</code>).</p>
</td></tr>
<tr><td><code id="nimble-R-functions_+3A_from">from</code></td>
<td>
<p>starting value of sequence.</p>
</td></tr>
<tr><td><code id="nimble-R-functions_+3A_to">to</code></td>
<td>
<p>end value of sequence.</p>
</td></tr>
<tr><td><code id="nimble-R-functions_+3A_by">by</code></td>
<td>
<p>increment of the sequence.</p>
</td></tr>
<tr><td><code id="nimble-R-functions_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>c</code>, <code>rep</code>, <code>seq</code>, these functions are NIMBLE's version of similar R functions, e.g., <code>nimRep</code> for <code>rep</code>.   In a <code>nimbleFunction</code>, either the R name (e.g., <code>rep</code>) or the NIMBLE name (e.g., <code>nimRep</code>) can be used.  If the R name is used, it will be converted to the NIMBLE name. For <code>which</code>, <code>length</code>, <code>diag</code>, <code>seq_along</code>, <code>is.na</code>, <code>is.nan</code>, <code>any</code>, <code>all</code> simply use the standard name without <code>"nim"</code>. These functions largely mimic (see exceptions below) the behavior of their R counterparts, but they can be compiled in a <code>nimbleFunction</code> using <code>compileNimble</code>.
</p>
<p><code>nimC</code> is NIMBLE's version of <code>c</code> and behaves identically.
</p>
<p><code>nimRep</code> is NIMBLE's version of <code>rep</code>.  It should behave identically to <code>rep</code>.  There are no NIMBLE versions of <code>rep.int</code> or <code>rep_len</code>.
</p>
<p><code>nimSeq</code> is NIMBLE's version of <code>seq</code>.  It behaves like <code>seq</code> with support for <code>from</code>, <code>to</code>, <code>by</code> and <code>length.out</code> arguments.  The <code>along.with</code> argument is not supported.  There are no NIMBLE versions of <code>seq.int</code>, <code>seq_along</code> or <code>seq_len</code>, with the exception that <code>seq_along</code> can take a nimbleFunctionList as an argument to provide the index range of a for-loop (<a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> Ch. 13). 
</p>
<p><code>which</code> behaves like the R version but without support for <code>arr.ind</code> or <code>useNames</code> arguments.
</p>
<p><code>diag</code> behaves like the R version but without support for the <code>nrow</code> and <code>ncol</code> arguments.
</p>
<p><code>length</code> behaves like the R version.
</p>
<p><code>seq_along</code> behaves like the R version.
</p>
<p><code>is.na</code> behaves like the R version but does not correctly handle <code>NA</code> values from R that are type 'logical', so convert these using <code>as.numeric()</code> before passing from R to NIMBLE.
</p>
<p><code>is.nan</code> behaves like the R version, but treats <code>NA</code> of type 'double' as being <code>NaN</code> and <code>NA</code> of type 'logical' as not being <code>NaN</code>. 
</p>
<p><code>any</code> behaves like the R version but takes only one argument and treats NAs as <code>FALSE</code>.
</p>
<p><code>all</code> behaves like the R version but takes only one argument and treats NAs as <code>FALSE</code>.
</p>

<hr>
<h2 id='nimbleCode'>Turn BUGS model code into an object for use in <code>nimbleModel</code> or <code>readBUGSmodel</code></h2><span id='topic+nimbleCode'></span>

<h3>Description</h3>

<p>Simply keeps model code as an R call object, the form needed by <code><a href="#topic+nimbleModel">nimbleModel</a></code> and optionally usable by <code><a href="#topic+readBUGSmodel">readBUGSmodel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleCode(code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleCode_+3A_code">code</code></td>
<td>
<p>expression providing the code for the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is equivalent to use the R function <code><a href="base.html#topic+quote">quote</a></code>.  <code>nimbleCode</code> is simply provided as a more readable alternative for NIMBLE users not familiar with <code>quote</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    x ~ dnorm(mu, sd = 1)
    mu ~ dnorm(0, sd = prior_sd)
})
</code></pre>

<hr>
<h2 id='nimbleExternalCall'>Create a nimbleFunction that wraps a call to external compiled code</h2><span id='topic+nimbleExternalCall'></span>

<h3>Description</h3>

<p>Given C header information, a function that takes scalars or pointers can be called from a compiled nimbleFunction.  If non-scalar return values are needed, an argument can be selected to behave as the return value in nimble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleExternalCall(
  prototype,
  returnType,
  Cfun,
  headerFile,
  oFile,
  where = getNimbleFunctionEnvironment()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleExternalCall_+3A_prototype">prototype</code></td>
<td>
<p>Argument type information.  This can be provided as an R function using <code>nimbleFunction</code> type declarations or as a list of <code>nimbleType</code> objects.</p>
</td></tr>
<tr><td><code id="nimbleExternalCall_+3A_returntype">returnType</code></td>
<td>
<p>Return object type information.  This can be provided similarly to <code>prototype</code> as either a <code>nimbleFunction</code> type declaration or as a <code>nimbleType</code> object.  In the latter case, the name will be ignored. If there is no return value, this should be <code>void()</code>.</p>
</td></tr>
<tr><td><code id="nimbleExternalCall_+3A_cfun">Cfun</code></td>
<td>
<p>Name of the external function (character).</p>
</td></tr>
<tr><td><code id="nimbleExternalCall_+3A_headerfile">headerFile</code></td>
<td>
<p>Name (possibly including file path) of the header file where Cfun is declared.</p>
</td></tr>
<tr><td><code id="nimbleExternalCall_+3A_ofile">oFile</code></td>
<td>
<p>Name (possibly including path) of the .o file where Cfun has been compiled.  Spaces in the path may cause problems.</p>
</td></tr>
<tr><td><code id="nimbleExternalCall_+3A_where">where</code></td>
<td>
<p>An optional <code>where</code> argument passed to <code>setRefClass</code> for where the reference class definition generated for this nimbleFunction will be stored.  This is needed due to R package namespace issues but should never need to be provided by a user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only argument types allowed in Cfun are <code>double</code>, <code>int</code>, and <code>bool</code>, corresponding to <code>nimbleFunction</code> types <code>double</code>, <code>integer</code>, and <code>logical</code>, respectively.
</p>
<p>If the dimensionality is greater than zero, the arguments in <code>Cfun</code> should be pointers.  This means it will typically be necessary to pass additional integer arguments telling <code>Cfun</code> the size(s) of non-scalar arguments.
</p>
<p>The return argument can only be a scalar or void.  Since non-scalar arguments are passed by pointer, you can use an argument to return results from <code>Cfun</code>.  If you wish to have a <code>nimbleFunction</code> that uses one argument of <code>Cfun</code> as a return object, you can wrap the result of <code>nimbleExternalCall</code> in another <code>nimbleFunction</code> that allocates the return object.  This is useful for using <code>Cfun</code> in a <code>nimbleModel</code>.  See example below.
</p>
<p>Note that a <code>nimbleExternalCall</code> can only be executed in a compiled <code>nimbleFunction</code>, not an uncompiled one.
</p>
<p>If you have problems with spaces in file paths (e.g. for <code>oFile</code>), try compiling everything locally by including <code>dirName = "."</code> as an argument to <code>compileNimble</code>.
</p>
<p>Note that if you use <code>Rcpp</code> to generate object files, NIMBLE's use of the <code>--preclean</code> option to <code>R CMD SHLIB</code> can cause failures, so you may need to run <code>nimbleOptions(precleanCompilation=FALSE)</code> to prevent removal of needed object files.
</p>


<h3>Value</h3>

<p>A <code>nimbleFunction</code> that takes the indicated input arguments, calls <code>Cfun</code>, and returns the result.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimbleRcall">nimbleRcall</a></code> for calling arbitrary R code from compiled <code>nimbleFunction</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sink('add1.h')
cat('
 extern "C" {
 void my_internal_function(double *p, double*ans, int n);
 }
')
sink()
sink('add1.cpp') 
cat('
 #include &lt;cstdio&gt;
 #include "add1.h"
 void my_internal_function(double *p, double *ans, int n) {
   printf("In my_internal_function\\n");
     /* cat reduces the double slash to single slash */ 
   for(int i = 0; i &lt; n; i++) 
     ans[i] = p[i] + 1.0;
 }
')
sink()
system('g++ add1.cpp -c -o add1.o')
Radd1 &lt;- nimbleExternalCall(function(x = double(1), ans = double(1),
n = integer()){}, Cfun =  'my_internal_function',
headerFile = file.path(getwd(), 'add1.h'), returnType = void(),
oFile = file.path(getwd(), 'add1.o'))
## If you need to use a function with non-scalar return object in model code,
## you can wrap it  in another nimbleFunction like this:
model_add1 &lt;- nimbleFunction(
     run = function(x = double(1)) {
         ans &lt;- numeric(length(x))
         Radd1(x, ans, length(x))
         return(ans)
         returnType(double(1))
     })
demoCode &lt;- nimbleCode({
     for(i in 1:4) {x[i] ~ dnorm(0,1)} ## just to get a vector
     y[1:4] &lt;- model_add1(x[1:4])
})
demoModel &lt;- nimbleModel(demoCode, inits = list(x = rnorm(4)),
check = FALSE, calculate = FALSE)
CdemoModel &lt;- compileNimble(demoModel, showCompilerOutput = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='nimbleFunction'>create a nimbleFunction</h2><span id='topic+nimbleFunction'></span>

<h3>Description</h3>

<p>create a nimbleFunction from a setup function, run function, possibly other methods, and possibly inheritance via <code>contains</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleFunction(
  setup = NULL,
  run = function() {
 },
  methods = list(),
  globalSetup = NULL,
  contains = NULL,
  buildDerivs = list(),
  name = NA,
  check = getNimbleOption("checkNimbleFunction"),
  where = getNimbleFunctionEnvironment()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleFunction_+3A_setup">setup</code></td>
<td>
<p>An optional R function definition for setup processing.</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_run">run</code></td>
<td>
<p>An optional NIMBLE function definition that executes the primary job of the nimbleFunction</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_methods">methods</code></td>
<td>
<p>An optional named list of NIMBLE function definitions for other class methods.</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_globalsetup">globalSetup</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_contains">contains</code></td>
<td>
<p>An optional object returned from <code><a href="#topic+nimbleFunctionVirtual">nimbleFunctionVirtual</a></code> that defines arguments and returnTypes for <code>run</code> and/or methods, to which the current nimbleFunction must conform</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_buildderivs">buildDerivs</code></td>
<td>
<p>A list of names of function methods for which to build derivatives capabilities.</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_name">name</code></td>
<td>
<p>An optional name used internally, for example in generated C++ code.  Usually this is left blank and NIMBLE provides a name.</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_check">check</code></td>
<td>
<p>Boolean indicating whether to check the run code for function calls that NIMBLE cannot compile. Checking can be turned off for all calls to <code>nimbleFunction</code> using <code>nimbleOptions(checkNimbleFunction = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="nimbleFunction_+3A_where">where</code></td>
<td>
<p>An optional <code>where</code> argument passed to <code>setRefClass</code> for where the reference class definition generated for this nimbleFunction will be stored.  This is needed due to R package namespace issues but should never need to be provided by a user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function for defining nimbleFunctions.  A lot of information is provided in the NIMBLE <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a>, so only a brief summary will be given here.
</p>
<p>If a <code>setup</code> function is provided, then <code>nimbleFunction</code> returns a generator: a function that when called with arguments for the setup function will execute that function and return a specialized nimbleFunction.   The <code>run</code> and other methods can be called using <code>$</code> like in other R classes, e.g. <code>nf$run()</code>. The methods can use objects that were created in or passed to the <code>setup</code> function.
</p>
<p>If no <code>setup</code> function is provided, then <code>nimbleFunction</code> returns a function that executes the <code>run</code> function.  It is not a generator in this case, and no other <code>methods</code> can be provided.
</p>
<p>If one wants a generator but does not need any setup arguments or code, <code>setup = TRUE</code> can be used.
</p>
<p>See the NIMBLE <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for examples.
</p>
<p>For more information about the <code>contains</code> argument, see the section on nimbleFunctionLists.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='nimbleFunctionBase-class'>Class <code>nimbleFunctionBase</code></h2><span id='topic+nimbleFunctionBase-class'></span><span id='topic+nimbleFunctionBase'></span>

<h3>Description</h3>

<p>Classes used internally in NIMBLE and not expected to be called directly by users.
</p>

<hr>
<h2 id='nimbleFunctionList-class'>Create a list of nimbleFunctions</h2><span id='topic+nimbleFunctionList-class'></span><span id='topic+nimbleFunctionList'></span>

<h3>Description</h3>

<p>Create an empty list of nimbleFunctions that all will inherit from a base class.
</p>


<h3>Details</h3>

<p>See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for information about creating and populating a <code>nimbleFunctionList</code>.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='nimbleFunctionVirtual'>create a virtual nimbleFunction, a base class for other nimbleFunctions</h2><span id='topic+nimbleFunctionVirtual'></span>

<h3>Description</h3>

<p>define argument types and returnType for the <code>run</code> function and any <code>methods</code>, to be used in the <code>contains</code> argument of <code>nimbleFunction</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleFunctionVirtual(
  contains = NULL,
  run = function() {
 },
  methods = list(),
  name = NA,
  methodControl = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleFunctionVirtual_+3A_contains">contains</code></td>
<td>
<p>Not yet functional</p>
</td></tr>
<tr><td><code id="nimbleFunctionVirtual_+3A_run">run</code></td>
<td>
<p>A NIMBLE function that will only be used to inspect its argument types and returnType.</p>
</td></tr>
<tr><td><code id="nimbleFunctionVirtual_+3A_methods">methods</code></td>
<td>
<p>An optional named list of NIMBLE functions that will also only be used for inspecting argument types and returnTypes.</p>
</td></tr>
<tr><td><code id="nimbleFunctionVirtual_+3A_name">name</code></td>
<td>
<p>An optional name used internally by the NIMBLE compiler.  This is usually omitted and NIMBLE provides one.</p>
</td></tr>
<tr><td><code id="nimbleFunctionVirtual_+3A_methodcontrol">methodControl</code></td>
<td>
<p>An optional list that allows specification of methods with defaults.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the NIMBLE <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> section on nimbleFunctionLists for explanation of how to use a virtual nimbleFunction.
</p>


<h3>Value</h3>

<p>An object that can be passed as the <code>contains</code> argument to <code>nimbleFunction</code> or as the argument to <code>nimbleFunctionList</code>
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimbleFunction">nimbleFunction</a></code>
</p>

<hr>
<h2 id='nimbleList'>create a nimbleList</h2><span id='topic+nimbleList'></span>

<h3>Description</h3>

<p>create a nimbleList from a nimbleList definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleList(
  ...,
  name = as.character(NA),
  predefined = FALSE,
  where = getNimbleFunctionEnvironment()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleList_+3A_...">...</code></td>
<td>
<p>arbitrary set of names and types for the elements of the list or a single R list of type <code>nimbleType</code>.</p>
</td></tr>
<tr><td><code id="nimbleList_+3A_name">name</code></td>
<td>
<p>optional character providing a name used internally, for example in generated C++ code.  Usually this is left blank and NIMBLE provides a name.</p>
</td></tr>
<tr><td><code id="nimbleList_+3A_predefined">predefined</code></td>
<td>
<p>logical for internal use only.</p>
</td></tr>
<tr><td><code id="nimbleList_+3A_where">where</code></td>
<td>
<p>optional argument passed to <code>setRefClass</code> for where the reference class definition generated for this nimbleFunction will be stored.  This is needed due to R package namespace issues but should never need to be provided by a user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a definition for a nimbleList.  The <code>types</code> argument defines the names, types, and dimensions of the elements of the nimbleList.  Elements of nimbleLists can be either basic types (e.g., <code>integer</code>, <code>double</code>) or other nimbleList definitions.   
The <code>types</code> argument can be either a series of expressions of the form <code>name = type(dim)</code>, or a list of <code><a href="#topic+nimbleType">nimbleType</a></code> objects.
</p>
<p><code>nimbleList</code> returns a definition, which can be used to create instances of this type of nimbleList via the <code>new()</code> member function. 
</p>
<p>Definitions can be created in R's general environment or in nimbleFunction setup code.  Instances can be created using the <code>new()</code> function in R's global environment, in nimbleFunction setup code, or in nimbleFunction run code.  
</p>
<p>Instances of <code>nimbleList</code> definitions can be used as arguments to run code of nimbleFunctions, and as the return type of nimbleFunctions.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>Examples</h3>

<pre><code class='language-R'> exampleNimListDef &lt;- nimbleList(x = integer(0), Y = double(2))
 
 nimbleListTypes &lt;- list(nimbleType(name = 'x', type = 'integer', dim = 0),
                         nimbleType(name = 'Y', type = 'double', dim = 2))
 
 ## this nimbleList definition is identical to the one created above
 exampleNimListDef &lt;- nimbleList(nimbleListTypes)
</code></pre>

<hr>
<h2 id='nimbleMCMC'>Executes one or more chains of NIMBLE's default MCMC algorithm, for a model specified using BUGS code</h2><span id='topic+nimbleMCMC'></span>

<h3>Description</h3>

<p><code>nimbleMCMC</code> is designed as the most straight forward entry point to using NIMBLE's default MCMC algorithm.  It provides capability for running multiple MCMC chains, specifying the number of MCMC iterations, thinning, and burn-in, and which model variables should be monitored.  It also provides options to return the posterior samples, to return summary statistics calculated from the posterior samples, and to return a WAIC value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleMCMC(
  code,
  constants = list(),
  data = list(),
  inits,
  dimensions = list(),
  model,
  monitors,
  thin = 1,
  niter = 10000,
  nburnin = 0,
  nchains = 1,
  check = TRUE,
  setSeed = FALSE,
  progressBar = getNimbleOption("MCMCprogressBar"),
  samples = TRUE,
  samplesAsCodaMCMC = FALSE,
  summary = FALSE,
  WAIC = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleMCMC_+3A_code">code</code></td>
<td>
<p>The quoted code expression representing the model, such as the return value from a call to <code>nimbleCode</code>). Not required if <code>model</code> is provided.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_constants">constants</code></td>
<td>
<p>Named list of constants in the model.  Constants cannot be subsequently modified. For compatibility with JAGS and BUGS, one can include data values with constants and <code>nimbleModel</code> will automatically distinguish them based on what appears on the left-hand side of expressions in <code>code</code>.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_data">data</code></td>
<td>
<p>Named list of values for the data nodes.  Values that are NA will not be flagged as data.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_inits">inits</code></td>
<td>
<p>Argument to specify initial values for each MCMC chain.  See details.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_dimensions">dimensions</code></td>
<td>
<p>Named list of dimensions for variables.  Only needed for variables used with empty indices in model code that are not provided in constants or data.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_model">model</code></td>
<td>
<p>A compiled or uncompiled NIMBLE model object.  When provided, this model will be used to configure the MCMC algorithm to be executed, rather than using the <code>code</code>, <code>constants</code>, <code>data</code> and <code>inits</code> arguments to create a new model object.  However, if also provided, the <code>inits</code> argument will still be used to initialize this model prior to running each MCMC chain.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_monitors">monitors</code></td>
<td>
<p>A character vector giving the node names or variable names to monitor.  The samples corresponding to these nodes will returned, and/or will have summary statistics calculated. Default value is all top-level stochastic nodes of the model.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for collecting MCMC samples.  Thinning occurs after the initial nburnin samples are discarded. Default value is 1.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_niter">niter</code></td>
<td>
<p>Number of MCMC iterations to run.  Default value is 10000.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_nburnin">nburnin</code></td>
<td>
<p>Number of initial, pre-thinning, MCMC iterations to discard.  Default value is 0.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_nchains">nchains</code></td>
<td>
<p>Number of MCMC chains to run.  Default value is 1.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_check">check</code></td>
<td>
<p>Logical argument, specifying whether to check the model object for missing or invalid values.  Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_setseed">setSeed</code></td>
<td>
<p>Logical or numeric argument.  If a single numeric value is provided, R's random number seed will be set to this value at the onset of each MCMC chain.  If a numeric vector of length <code>nchains</code> is provided, then each element of this vector is provided as R's random number seed at the onset of the corresponding MCMC chain.  Otherwise, in the case of a logical value, if <code>TRUE</code>, then R's random number seed for the ith chain is set to be <code>i</code>, at the onset of each MCMC chain.  Note that specifying the argument <code>setSeed = 0</code> does not prevent setting the RNG seed, but rather sets the random number generation seed to <code>0</code> at the beginning of each MCMC chain.  Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_progressbar">progressBar</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, an MCMC progress bar is displayed during execution of each MCMC chain.  Default value is defined by the nimble package option MCMCprogressBar..</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_samples">samples</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, then posterior samples are returned from each MCMC chain.  These samples are optionally returned as <code>coda</code> <code>mcmc</code> objects, depending on the <code>samplesAsCodaMCMC</code> argument.  Default value is <code>TRUE</code>.  See details.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_samplesascodamcmc">samplesAsCodaMCMC</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, then a <code>coda</code> <code>mcmc</code> object is returned instead of an R matrix of samples, or when <code>nchains &gt; 1</code> a <code>coda</code> <code>mcmc.list</code> object is returned containing <code>nchains</code> <code>mcmc</code> objects.  This argument is only used when <code>samples</code> is <code>TRUE</code>.  Default value is <code>FALSE</code>.  See details.</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_summary">summary</code></td>
<td>
<p>Logical argument.  When <code>TRUE</code>, summary statistics for the posterior samples of each parameter are also returned, for each MCMC chain.  This may be returned in addition to the posterior samples themselves.  Default value is <code>FALSE</code>.  See details.
z</p>
</td></tr>
<tr><td><code id="nimbleMCMC_+3A_waic">WAIC</code></td>
<td>
<p>Logical argument.  When <code>TRUE</code>, the WAIC (Watanabe, 2010) of the model is calculated and returned.  If multiple chains are run, then a single WAIC value is calculated using the posterior samples from all chains.  Default value is <code>FALSE</code>. Note that the version of WAIC used is the default WAIC conditional on random effects/latent states and without any grouping of data nodes. See <code>help(waic)</code> for more details. If a different version of WAIC is desired, do not use <code>nimbleMCMC</code>. Instead, specify the <code>controlWAIC</code> argument to <code>configureMCMC</code> or <code>buildMCMC</code>, and then use <code>runMCMC</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entry point for this function is providing the <code>code</code>, <code>constants</code>, <code>data</code> and <code>inits</code> arguments, to create a new NIMBLE model object, or alternatively providing an exisiting NIMBLE model object as the <code>model</code> argument.
</p>
<p>At least one of <code>samples</code>, <code>summary</code> or <code>WAIC</code> must be <code>TRUE</code>, since otherwise, nothing will be returned.  Any combination of these may be <code>TRUE</code>, including possibly all three, in which case posterior samples, summary statistics, and WAIC values are returned for each MCMC chain.
</p>
<p>When <code>samples = TRUE</code>, the form of the posterior samples is determined by the <code>samplesAsCodaMCMC</code> argument, as either matrices of posterior samples, or <code>coda</code> <code>mcmc</code> and <code>mcmc.list</code> objects.
</p>
<p>Posterior summary statistics are returned individually for each chain, and also as calculated from all chains combined (when <code>nchains &gt; 1</code>).
</p>
<p>The <code>inits</code> argument can be one of three things:
</p>
<p>(1) a function to generate initial values, which will be executed once to initialize the model object, and once to generate initial values at the beginning of each MCMC chain, or
(2) a single named list of initial values which, will be used to initialize the model object and for each MCMC chain, or
(3) a list of length <code>nchains</code>, each element being a named list of initial values.  The first element will be used to initialize the model object, and once element of the list will be used for each MCMC chain.
</p>
<p>The <code>inits</code> argument may also be omitted, in which case the model will not be provided with initial values.  This is not recommended.
</p>
<p>The <code>niter</code> argument specifies the number of pre-thinning MCMC iterations, and the <code>nburnin</code> argument specifies the number of pre-thinning MCMC samples to discard.  After discarding these burn-in samples, thinning of the remaining samples will take place.  The total number of posterior samples returned will be floor((niter-nburnin)/thin).
</p>


<h3>Value</h3>

<p>A list is returned with named elements depending on the arguments passed to <code>nimbleMCMC</code>, unless only one among samples, summary, and WAIC are requested, in which case only that element is returned.  These elements may include <code>samples</code>, <code>summary</code>, and <code>WAIC</code>.  When <code>nchains = 1</code>, posterior samples are returned as a single matrix, and summary statistics as a single matrix.  When <code>nchains &gt; 1</code>, posterior samples are returned as a list of matrices, one matrix for each chain, and summary statistics are returned as a list containing <code>nchains+1</code> matrices: one matrix corresponding to each chain, and the final element providing a summary of all chains, combined.  If <code>samplesAsCodaMCMC</code> is <code>TRUE</code>, then posterior samples are provided as <code>coda</code> <code>mcmc</code> and <code>mcmc.list</code> objects.  When <code>WAIC</code> is <code>TRUE</code>, a WAIC summary object is returned.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configureMCMC">configureMCMC</a></code> <code><a href="#topic+buildMCMC">buildMCMC</a></code> <code><a href="#topic+runMCMC">runMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
code &lt;- nimbleCode({
    mu ~ dnorm(0, sd = 1000)
    sigma ~ dunif(0, 1000)
    for(i in 1:10) {
        x[i] ~ dnorm(mu, sd = sigma)
    }
})
data &lt;- list(x = c(2, 5, 3, 4, 1, 0, 1, 3, 5, 3))
inits &lt;- function() list(mu = rnorm(1,0,1), sigma = runif(1,0,10))
mcmc.output &lt;- nimbleMCMC(code, data = data, inits = inits,
                          monitors = c("mu", "sigma"), thin = 10,
                          niter = 20000, nburnin = 1000, nchains = 3,
                          summary = TRUE, WAIC = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='nimbleModel'>Create a NIMBLE model from BUGS code</h2><span id='topic+nimbleModel'></span>

<h3>Description</h3>

<p>Processes BUGS model code and optional constants, data, and initial values. Returns a NIMBLE model (see <code><a href="#topic+modelBaseClass">modelBaseClass</a></code>) or model definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleModel(
  code,
  constants = list(),
  data = list(),
  inits = list(),
  dimensions = list(),
  returnDef = FALSE,
  where = globalenv(),
  debug = FALSE,
  check = getNimbleOption("checkModel"),
  calculate = TRUE,
  name = NULL,
  buildDerivs = getNimbleOption("buildModelDerivs"),
  userEnv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleModel_+3A_code">code</code></td>
<td>
<p>code for the model in the form returned by <code><a href="#topic+nimbleCode">nimbleCode</a></code> or (equivalently) <code><a href="base.html#topic+quote">quote</a></code></p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_constants">constants</code></td>
<td>
<p>named list of constants in the model.  Constants cannot be subsequently modified. For compatibility with JAGS and BUGS, one can include data values with constants and <code><a href="#topic+nimbleModel">nimbleModel</a></code> will automatically distinguish them based on what appears on the left-hand side of expressions in <code>code</code>.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_data">data</code></td>
<td>
<p>named list of values for the data nodes.  Data values can be subsequently modified.  Providing this argument also flags nodes as having data for purposes of algorithms that inspect model structure. Values that are NA will not be flagged as data.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_inits">inits</code></td>
<td>
<p>named list of starting values for model variables. Unlike JAGS, should only be a single list, not a list of lists.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_dimensions">dimensions</code></td>
<td>
<p>named list of dimensions for variables.  Only needed for variables used with empty indices in model code that are not provided in constants or data.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_returndef">returnDef</code></td>
<td>
<p>logical indicating whether the model should be returned (FALSE) or just the model definition (TRUE).</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_where">where</code></td>
<td>
<p>argument passed to <code><a href="methods.html#topic+setRefClass">setRefClass</a></code>, indicating the environment in which the reference class definitions generated for the model and its modelValues should be created.  This is needed for managing package namespace issues during package loading and does not normally need to be provided by a user.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_debug">debug</code></td>
<td>
<p>logical indicating whether to put the user in a browser for debugging.  Intended for developer use.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_check">check</code></td>
<td>
<p>logical indicating whether to check the model object for missing or invalid values.  Default is given by the NIMBLE option 'checkModel'.  See <code><a href="#topic+nimbleOptions">nimbleOptions</a></code> for details.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_calculate">calculate</code></td>
<td>
<p>logical indicating whether to run <code><a href="#topic+calculate">calculate</a></code> on the model after building it; this will calculate all deterministic nodes and logProbability values given the current state of all nodes. Default is TRUE. For large models, one might want to disable this, but note that deterministic nodes, including nodes introduced into the model by NIMBLE, may be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_name">name</code></td>
<td>
<p>optional character vector giving a name of the model for internal use.  If omitted, a name will be provided.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_buildderivs">buildDerivs</code></td>
<td>
<p>logical indicating whether to build derivative capabilities for the model.</p>
</td></tr>
<tr><td><code id="nimbleModel_+3A_userenv">userEnv</code></td>
<td>
<p>environment in which if-then-else statements in BUGS code will be evaluated if needed information not found in <code>constants</code>; intended primarily for internal use only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> or <code>help(<a href="#topic+modelBaseClass">modelBaseClass</a>)</code> for information about manipulating NIMBLE models created by <code><a href="#topic+nimbleModel">nimbleModel</a></code>, including methods that operate on models, such as <code><a href="#topic+getDependencies">getDependencies</a></code>.
</p>
<p>The user may need to provide dimensions for certain variables as in some cases NIMBLE cannot automatically determine the dimensions and sizes of variables. See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for more information.
</p>
<p>As noted above, one may lump together constants and data (as part of the <code>constants</code> argument (unlike R interfaces to JAGS and BUGS where they are provided as the <code>data</code> argument). One may not provide lumped constants and data as the <code>data</code> argument.
</p>
<p>For variables that are a mixture of data nodes and non-data nodes, any values passed in via <code>inits</code> for components of the variable that are data will be ignored. All data values should be passed in through <code>data</code> (or <code>constants</code> as just discussed).
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readBUGSmodel">readBUGSmodel</a></code> for creating models from BUGS-format model files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
    x ~ dnorm(mu, sd = 1)
    mu ~ dnorm(0, sd = prior_sd)
})
constants = list(prior_sd = 1)
data = list(x = 4)
Rmodel &lt;- nimbleModel(code, constants = constants, data = data)
</code></pre>

<hr>
<h2 id='nimbleOptions'>NIMBLE Options Settings</h2><span id='topic+nimbleOptions'></span>

<h3>Description</h3>

<p>Allow the user to set and examine a variety of global _options_
that affect the way in which NIMBLE operates. Call <code>nimbleOptions()</code>
with no arguments to see a list of available opions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleOptions(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleOptions_+3A_...">...</code></td>
<td>
<p>any options to be defined as one or more <code>name = value</code> pairs
or as a single <code>list</code> of <code>name=value</code> pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nimbleOptions</code> mimics <code>options</code>. Invoking
<code>nimbleOptions()</code> with no arguments returns a list with the
current values of the options.  To access the value of a single option,
one should use <code>getNimbleOption()</code>.
</p>


<h3>Value</h3>

<p>When invoked with no arguments, returns a list with the current values of all options.
When invoked with one or more arguments, returns a list of the the updated options with their updated values.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set one option:
nimbleOptions(verifyConjugatePosteriors = FALSE)

# Compactly print all options:
str(nimbleOptions(), max.level = 1)

# Save-and-restore options:
old &lt;- nimbleOptions()                    # Saves old options.
nimbleOptions(showCompilerOutput = TRUE,
              verboseErrors = TRUE)       # Sets temporary options.
# ...do stuff...
nimbleOptions(old)                        # Restores old options.
</code></pre>

<hr>
<h2 id='nimbleRcall'>Make an R function callable from compiled nimbleFunctions (including nimbleModels).</h2><span id='topic+nimbleRcall'></span>

<h3>Description</h3>

<p>Normally compiled nimbleFunctions call other compiled nimbleFunctions.  nimbleRcall enables any R function (with viable argument types and return values) to be called (and evaluated in R) from compiled nimbleFunctions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimbleRcall(
  prototype,
  returnType,
  Rfun,
  where = getNimbleFunctionEnvironment()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleRcall_+3A_prototype">prototype</code></td>
<td>
<p>Argument type information for Rfun.  This can be provided as an R function using <code>nimbleFunction</code> type declarations or as a list of <code>nimbleType</code> objects.</p>
</td></tr>
<tr><td><code id="nimbleRcall_+3A_returntype">returnType</code></td>
<td>
<p>Return object type information.  This can be provided similarly to <code>prototype</code> as either a <code>nimbleFunction</code> type declaration or as a <code>nimbleType</code> object.  In the latter case, the name will be ignored. If there is no return value this should be <code>void()</code>.</p>
</td></tr>
<tr><td><code id="nimbleRcall_+3A_rfun">Rfun</code></td>
<td>
<p>The name of an R function to be called from compiled nimbleFunctions.</p>
</td></tr>
<tr><td><code id="nimbleRcall_+3A_where">where</code></td>
<td>
<p>An optional <code>where</code> argument passed to <code>setRefClass</code> for where the reference class definition generated for this nimbleFunction will be stored.  This is needed due to R package namespace issues but should never need to be provided by a user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nimbleFunction</code> returned by <code>nimbleRcall</code> can be used in other <code>nimbleFunction</code>s.  When called from a compiled <code>nimbleFunction</code> (including from a model), arguments will be copied according to the declared types, the function named by <code>Rfun</code> will be called, and the returned object will be copied if necessary.  The example below shows use of an R function in a compiled <code>nimbleModel</code>.
</p>
<p>A <code>nimbleFunction</code> returned by <code>nimbleRcall</code> can only be used in a compiled <code>nimbleFunction</code>.  <code>Rfun</code> itself should work in an uncompiled <code>nimbleFunction</code>.
</p>


<h3>Value</h3>

<p>A <code>nimbleFunction</code> that wraps a call to <code>Rfun</code> with type-declared arguments and return object.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimbleExternalCall">nimbleExternalCall</a></code> for calling externally provided C (or other) compiled code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Say we want an R function that adds 2 to every value in a vector
add2 &lt;- function(x) {
   x + 2 
}
Radd2 &lt;- nimbleRcall(function(x = double(1)){}, Rfun = 'add2',
returnType = double(1))
demoCode &lt;- nimbleCode({
    for(i in 1:4) {x[i] ~ dnorm(0,1)} 
    z[1:4] &lt;- Radd2(x[1:4])
})
demoModel &lt;- nimbleModel(demoCode, inits = list(x = rnorm(4)),
check = FALSE, calculate = FALSE)
CdemoModel &lt;- compileNimble(demoModel)

## End(Not run)
</code></pre>

<hr>
<h2 id='nimbleType-class'>create a nimbleType object</h2><span id='topic+nimbleType-class'></span><span id='topic+nimbleType'></span>

<h3>Description</h3>

<p>Create a nimbleType object, with information on the name, type, and dimension of an object to be placed in a <code><a href="#topic+nimbleList">nimbleList</a></code>.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimbleType-class_+3A_name">name</code></td>
<td>
<p>The name of the object, given as a character string.</p>
</td></tr>
<tr><td><code id="nimbleType-class_+3A_type">type</code></td>
<td>
<p>The type of the object, given as a character string.</p>
</td></tr>
<tr><td><code id="nimbleType-class_+3A_dim">dim</code></td>
<td>
<p>The dimension of the object, given as an integer.  This can be left blank if the object is a nimbleList.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates <code>nimbleType</code> objects, which can be used to define the elements of a <code><a href="#topic+nimbleList">nimbleList</a></code>.  
</p>
<p>The <code>type</code> argument can be chosen from among <code>character</code>, <code>double</code>, <code>integer</code>, and <code>logical</code>,
or can be the name of a previously created <code><a href="#topic+nimbleList">nimbleList</a> definition</code>.
</p>
<p>See the NIMBLE <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for additional examples.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nimbleTypeList &lt;- list()
nimbleTypeList[[1]] &lt;- nimbleType(name = 'x', type = 'integer', dim = 0)
nimbleTypeList[[2]] &lt;- nimbleType(name = 'Y', type = 'double', dim = 2)

</code></pre>

<hr>
<h2 id='nimCat'>cat function for use in nimbleFunctions</h2><span id='topic+nimCat'></span><span id='topic+cat'></span>

<h3>Description</h3>

<p>cat function for use in nimbleFunctions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimCat(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimCat_+3A_...">...</code></td>
<td>
<p>an arbitrary set of arguments that will be printed in sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cat</code> in nimbleFunction run-code imitates the R function <code><a href="#topic+cat">cat</a></code>.  It prints its arguments in order.  No newline is inserted, so include <code>"\n"</code> if one is desired.
</p>
<p>When an uncompiled nimbleFunction is executed, R's <code>cat</code> is used.  In a compiled nimbleFunction, a C++ output stream is used that will generally format output similarly to R's <code>cat</code>. Non-scalar numeric objects can be included, although their output will be formatted slightly different in uncompiled and compiled nimbleFunctions.
</p>
<p>In nimbleFunction run-time code, <code>cat</code> is identical to <code>print</code> except the latter appends a newline at the end.
</p>
<p><code>nimCat</code> is the same as <code>cat</code>, and the latter is converted to the former when a nimbleFunction is defined.
</p>
<p>For numeric values, the number of digits printed is controlled by the system option <code>nimbleOptions('digits')</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ans &lt;- matrix(1:4, nrow = 2) ## R code, not NIMBLE code
nimCat('Answer is ', ans) ## would work in R or NIMBLE

</code></pre>

<hr>
<h2 id='nimCopy'>Copying function for NIMBLE</h2><span id='topic+nimCopy'></span><span id='topic+copy'></span>

<h3>Description</h3>

<p>Copies values from a NIMBLE model or modelValues object to another NIMBLE model or modelValues. Work in R and NIMBLE.  The NIMBLE keyword <code>copy</code> is identical to <code>nimCopy</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimCopy(
  from,
  to,
  nodes = NULL,
  nodesTo = NULL,
  row = NA,
  rowTo = NA,
  logProb = FALSE,
  logProbOnly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimCopy_+3A_from">from</code></td>
<td>
<p>Either a NIMBLE model or modelValues object</p>
</td></tr>
<tr><td><code id="nimCopy_+3A_to">to</code></td>
<td>
<p>Either a NIMBLE model or modelValues object</p>
</td></tr>
<tr><td><code id="nimCopy_+3A_nodes">nodes</code></td>
<td>
<p>Vector of one or more node names of object <code>from</code> that will be copied from</p>
</td></tr>
<tr><td><code id="nimCopy_+3A_nodesto">nodesTo</code></td>
<td>
<p>Vector of one or more node names of object <code>to</code> that will be copied to. If <code>nodesTo</code> is <code>NULL</code>, will automatically be set to <code>nodes</code></p>
</td></tr>
<tr><td><code id="nimCopy_+3A_row">row</code></td>
<td>
<p>If <code>from</code> is a modelValues, the row that will be copied from</p>
</td></tr>
<tr><td><code id="nimCopy_+3A_rowto">rowTo</code></td>
<td>
<p>If <code>to</code> is a modelValues, the row which will be copied to. If <code>rowTo</code> is <code>NA</code>, will automatically be set to <code>row</code></p>
</td></tr>
<tr><td><code id="nimCopy_+3A_logprob">logProb</code></td>
<td>
<p>A logical value indicating whether the log probabilities of the given nodes should also be copied (i.e. if <code>nodes = 'x'</code>
and <code>logProb = TRUE</code>, then both <code>'x'</code> and <code>'logProb_x'</code> will be copied)</p>
</td></tr>
<tr><td><code id="nimCopy_+3A_logprobonly">logProbOnly</code></td>
<td>
<p>A logical value indicating whether only the log probabilities of the given nodes should be copied (i.e. if <code>nodes = 'x'</code>
and <code>logProbOnly = TRUE</code>, then only <code>'logProb_x'</code> will be copied)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function copies values from one or more nodes (possibly including log probabilities for nodes) between models and modelValues objects. For modelValues objects, the row must be specified. This function allows one to conveniently copy multiple nodes, avoiding having to write a loop.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Building model and modelValues object
simpleModelCode &lt;- nimbleCode({
for(i in 1:100)
	x[i] ~ dnorm(0,1)
})
rModel &lt;- nimbleModel(simpleModelCode)
rModelValues &lt;- modelValues(rModel)

#Setting model nodes
rModel$x &lt;- rnorm(100)
#Using nimCopy in R.
nimCopy(from = rModel, to = rModelValues, nodes = 'x', rowTo = 1)

#Use of nimCopy in a simple nimbleFunction
cCopyGen &lt;- nimbleFunction(
	setup = function(model, modelValues, nodeNames){},
	run = function(){
		nimCopy(from = model, to = modelValues, nodes = nodeNames, rowTo = 1)
	}
)

rCopy &lt;- cCopyGen(rModel, rModelValues, 'x')
## Not run: 
cModel &lt;- compileNimble(rModel)
cCopy &lt;- compileNimble(rCopy, project = rModel)
cModel[['x']] &lt;- rnorm(100)

cCopy$run() ## execute the copy with the compiled function

## End(Not run)
</code></pre>

<hr>
<h2 id='nimDerivs'>Nimble Derivatives</h2><span id='topic+nimDerivs'></span><span id='topic+derivs'></span><span id='topic+AD'></span>

<h3>Description</h3>

<p>Computes the value, 1st order (Jacobian), and 2nd order (Hessian) derivatives of a given
<code>nimbleFunction</code> method and/or model log probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimDerivs(call = NA, wrt = NULL, order = nimC(0, 1, 2), model = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimDerivs_+3A_call">call</code></td>
<td>
<p>a call to a <code>nimbleFunction</code> method with arguments
included.  Can also be a call to  <code>model$calculate(nodes)</code>, or to 
<code>calculate(model, nodes)</code>.</p>
</td></tr>
<tr><td><code id="nimDerivs_+3A_wrt">wrt</code></td>
<td>
<p>a character vector of either: names of function arguments 
(if taking derivatives of a <code>nimbleFunction</code> method), or node names 
(if taking derivatives of <code>model$calculate(nodes)</code>) to take derivatives 
with respect to.  If left empty, derivatives will be taken with respect to 
all arguments to <code>nimFxn</code>.</p>
</td></tr>
<tr><td><code id="nimDerivs_+3A_order">order</code></td>
<td>
<p>an integer vector with values within the set <code class="reqn">{0, 1, 2}</code>, 
corresponding to whether the function value, Jacobian, and Hessian should be
returned respectively.  Defaults to <code>c(0, 1, 2)</code>.</p>
</td></tr>
<tr><td><code id="nimDerivs_+3A_model">model</code></td>
<td>
<p>(optional) for derivatives of a nimbleFunction that involves model.
calculations, the uncompiled model that is used. This is needed in order
to be able to correctly restore values into the model when <code>order</code> does not
include 0 (or in all cases when double-taping).</p>
</td></tr>
<tr><td><code id="nimDerivs_+3A_...">...</code></td>
<td>
<p>additional arguments intended for internal use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Derivatives for uncompiled nimbleFunctions are calculated using the
<code>numDeriv</code> package.  If this package is not installed, an error will
be issued.  Derivatives for matrix valued arguments will be returned in 
column-major order.
</p>


<h3>Value</h3>

<p>an <code>ADNimbleList</code> with elements <code>value</code>, <code>jacobian</code>,
and <code>hessian</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
model &lt;- nimbleModel(code = ...)
calcDerivs &lt;- nimDerivs(model$calculate(model$getDependencies('x')),
 wrt = 'x')

## End(Not run)

</code></pre>

<hr>
<h2 id='nimDim'>return sizes of an object whether it is a vector, matrix or array</h2><span id='topic+nimDim'></span><span id='topic+dim'></span>

<h3>Description</h3>

<p>R's regular <code>dim</code> function returns NULL for a vector.  It is useful to have this function that treats a vector similarly to a matrix or array.  Works in R and NIMBLE.  In NIMBLE <code>dim</code> is identical to <code>nimDim</code>, not to R's <code>dim</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimDim(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimDim_+3A_obj">obj</code></td>
<td>
<p>objects for which the sizes are requested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of sizes in each dimension
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(4)
dim(x)
nimDim(x)
y &lt;- matrix(x, nrow = 2)
dim(y)
nimDim(y)

</code></pre>

<hr>
<h2 id='nimEigen'>Spectral Decomposition of a Matrix</h2><span id='topic+nimEigen'></span><span id='topic+eigen'></span>

<h3>Description</h3>

<p>Computes eigenvalues and eigenvectors of a numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimEigen(x, symmetric = FALSE, only.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimEigen_+3A_x">x</code></td>
<td>
<p>a  numeric matrix (double or integer) whose spectral decomposition is to be computed.</p>
</td></tr>
<tr><td><code id="nimEigen_+3A_symmetric">symmetric</code></td>
<td>
<p>if <code>TRUE</code>, the matrix is guarranteed to be symmetric, and only its lower triangle (diagonal included) is used.  Otherwise, the matrix
is checked for symmetry.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nimEigen_+3A_only.values">only.values</code></td>
<td>
<p>if <code>TRUE</code>, only the eigenvalues are computed, otherwise both eigenvalues and eigenvectors are computed. 
Setting <code>only.values = TRUE</code> can speed up eigendecompositions, especially for large matrices.  Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the spectral decomposition of a numeric matrix using the Eigen C++ template library. 
In a nimbleFunction, <code>eigen</code> is identical to <code>nimEigen</code>.  If the matrix is symmetric, a faster and more accurate algorithm will be used to compute the eigendecomposition. Note that non-symmetric matrices can have complex eigenvalues,
which are not supported by NIMBLE.  If a complex eigenvalue or a complex element of an eigenvector is detected, a warning will be issued and that element will be returned as <code>NaN</code>.
</p>
<p>Additionally, <code>returnType(eigenNimbleList())</code> can be used within a <code>link{nimbleFunction}</code> to specify that the function will return a <code><a href="#topic+nimbleList">nimbleList</a></code> generated by the <code>nimEigen</code> function.  <code>eigenNimbleList()</code> can also be used to define a nested <code><a href="#topic+nimbleList">nimbleList</a></code> element.  See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for usage examples.
</p>


<h3>Value</h3>

<p>The spectral decomposition of <code>x</code> is returned as a <code><a href="#topic+nimbleList">nimbleList</a></code> with elements:
</p>

<ul>
<li><p> values vector containing the eigenvalues of <code>x</code>, sorted in decreasing order.  Since <code>x</code> is required to be symmetric, all eigenvalues will be real numbers.
</p>
</li>
<li><p> vectors. matrix with columns containing the eigenvectors of <code>x</code>, or an empty matrix if <code>only.values</code> is <code>TRUE</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimSvd">nimSvd</a></code> for singular value decompositions in NIMBLE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eigenvaluesDemoFunction &lt;- nimbleFunction(
   setup = function(){
     demoMatrix &lt;- diag(4) + 2
   },
   run = function(){
     eigenvalues &lt;- eigen(demoMatrix, symmetric = TRUE)$values
     returnType(double(1))
     return(eigenvalues)
 })

</code></pre>

<hr>
<h2 id='nimIntegrate'>Integration of One-Dimensional Functions</h2><span id='topic+nimIntegrate'></span><span id='topic+integrate'></span>

<h3>Description</h3>

<p>NIMBLE wrapper around R's builtin <code><a href="#topic+integrate">integrate</a></code>. Adaptive quadrature
of functions of one variable over a finite or infinite interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimIntegrate(
  f,
  lower,
  upper,
  param,
  subdivisions = 100L,
  rel.tol = .Machine$double.eps^0.25,
  abs.tol = .Machine$double.eps^0.25,
  stop.on.error = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimIntegrate_+3A_f">f</code></td>
<td>
<p>nimbleFunction of one input for which the integral is desired.
See below for details on requirements for how <code>f</code> must be defined.</p>
</td></tr>
<tr><td><code id="nimIntegrate_+3A_lower">lower</code></td>
<td>
<p>an optional scalar lower bound for the input of the function.</p>
</td></tr>
<tr><td><code id="nimIntegrate_+3A_upper">upper</code></td>
<td>
<p>an optional scalar upper bound for the input of the function.</p>
</td></tr>
<tr><td><code id="nimIntegrate_+3A_param">param</code></td>
<td>
<p>additional parameter(s) to the function
that are fixed with respect to the integration. If <code>f</code>
takes no additional arguments (beyond the variable of
integration), this must be provided but need not be used in
<code>f</code>. Can be of length one or more.
parameters.</p>
</td></tr>
<tr><td><code id="nimIntegrate_+3A_subdivisions">subdivisions</code></td>
<td>
<p>the maximum number of subintervals.</p>
</td></tr>
<tr><td><code id="nimIntegrate_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative accuracy requested.</p>
</td></tr>
<tr><td><code id="nimIntegrate_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute accuracy requested.</p>
</td></tr>
<tr><td><code id="nimIntegrate_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) an error stops the
function. Otherwise some errors will give a result with the error
code given in the third element of the result vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>f</code> should take two arguments, the first of type
<code>double(1)</code>, i.e., vector. <code>f</code> should be vectorized
in that it should also return a <code>double(1)</code> object, containing
the result of applying the function to each element of the first
argument. (The result can be calculated using vectorized NIMBLE code or
using a loop.) The second argument is required to also be of type
<code>double(1)</code>, containing any additional parameter(s) to the function
that are not being integrated over. This argument can be unused in
the function if the function does not need additional parameters.
Note that this must be of type <code>double(1)</code> even if <code>param</code>
contains a single element (NIMBLE will manage the lengths behind the
scenes).
</p>
<p>Note that unlike with R's <code>integrate</code>, additional parameters
must be passed as part of a vector, specified via <code>param</code>,
and cannot be passed as individual named arguments.
</p>


<h3>Value</h3>

<p>A vector with three values, the first the estimate of the integral,
the second an estimate of the modulus of the absolute error, and the third
a result code corresponding to the <code>message</code> returned by <code>integrate</code>.
The numerical result code can be interpreted as follows:
</p>

<ul>
<li> <p><code>0</code>: &quot;OK&quot;
</p>
</li>
<li> <p><code>1</code>: &quot;maximum number of subdivisions reached&quot;
</p>
</li>
<li> <p><code>2</code>: &quot;roundoff error was detected&quot;
</p>
</li>
<li> <p><code>3</code>: &quot;extremely bad integrand behaviour&quot;
</p>
</li>
<li> <p><code>4</code>: &quot;roundoff error is detected in the extrapolation table&quot;
</p>
</li>
<li> <p><code>5</code>: &quot;the integral is probably divergent&quot;
</p>
</li>
<li> <p><code>6</code>: &quot;the input is invalid&quot;
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Christopher Paciorek, Paul van Dam-Bates, Perry de Valpine
</p>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>integrand &lt;- nimbleFunction(
   run = function(x = double(1), theta = double(1)) {
       return(x*theta[1])   
   returnType(double(1))
 }
)

fun &lt;- nimbleFunction(
   run = function(theta = double(0), lower = double(0), upper = double(0)) {
       param = c(theta, 0)  # cannot be scalar, so pad with zero.
       output = integrate(integrand, lower, upper, param)
       returnType(double(1))
       return(output)
 })

fun(3.1415927, 0, 1)
## Not run: 
cfun &lt;- compileNimble(fun)
cfun(3.1415927, 0, 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='nimMatrix'>Creates matrix or array objects for use in nimbleFunctions</h2><span id='topic+nimMatrix'></span><span id='topic+nimArray'></span><span id='topic+matrix'></span><span id='topic+array'></span>

<h3>Description</h3>

<p>In a <code>nimbleFunction</code>, <code>matrix</code> and <code>array</code> are identical to <code>nimMatrix</code> and <code>nimArray</code>, respectively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimMatrix(
  value = 0,
  nrow = NA,
  ncol = NA,
  init = TRUE,
  fillZeros = TRUE,
  recycle = TRUE,
  type = "double"
)

nimArray(
  value = 0,
  dim = c(1, 1),
  init = TRUE,
  fillZeros = TRUE,
  recycle = TRUE,
  nDim,
  type = "double"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimMatrix_+3A_value">value</code></td>
<td>
<p>value(s) for initialization (default = 0).  This can be a vector, matrix or array, but it will be used as a vector.</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_nrow">nrow</code></td>
<td>
<p>the number of rows in a matrix (default = 1)</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns in a matrix (default = 1)</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_init">init</code></td>
<td>
<p>logical, whether to initialize values (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_fillzeros">fillZeros</code></td>
<td>
<p>logical, whether to initialize any elements not filled by (possibly recycled) <code>value</code> with 0 (or <code>FALSE</code> for <code>nimLogical</code>) (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_recycle">recycle</code></td>
<td>
<p>logical, whether <code>value</code> should be recycled to fill the entire contents of the new object (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_type">type</code></td>
<td>
<p>character representing the data type, i.e. <code>'double'</code>, <code>'integer'</code>, or <code>'logical'</code> (default = <code>'double'</code>)</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_dim">dim</code></td>
<td>
<p>vector of dimension sizes in an array (default = <code>c(1, 1)</code>)</p>
</td></tr>
<tr><td><code id="nimMatrix_+3A_ndim">nDim</code></td>
<td>
<p>number of dimensions in an array.  This is only necessary for <code>compileNimble</code> if the length of <code>dim</code> cannot be determined during compilation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are similar to R's <code><a href="#topic+matrix">matrix</a></code> and <code><a href="#topic+array">array</a></code> functions, but they can be used in a nimbleFunction and compiled using <code>compileNimble</code>.  Largely for compilation purposes, finer control is provided over initialization behavior, similarly to <code><a href="#topic+nimNumeric">nimNumeric</a></code>, <code><a href="#topic+nimInteger">nimInteger</a></code>, and <code><a href="#topic+nimLogical">nimLogical</a></code>. If <code>init = FALSE</code>, no initialization will be done, and <code>value</code>, <code>fillZeros</code> and <code>recycle</code> will be ignored.  If <code>init=TRUE</code> and <code>recycle=TRUE</code>, then <code>fillZeros</code> will be ignored, and <code>value</code> will be repeated (according to R's recycling rule) as much as necessary to fill the object.  If <code>init=TRUE</code> and <code>recycle=FALSE</code>, then if <code>fillZeros=TRUE</code>, values of 0 (or FALSE for <code>nimLogical</code>) will be filled in after <code>value</code>.  Compiled code will be more efficient if unnecessary initialization is not done, but this may or may not be noticeable depending on the situation.
</p>
<p>When used in a <code>nimbleFunction</code> (in <code>run</code> or other member function), <code>matrix</code> and <code>array</code> are immediately converted to <code>nimMatrix</code> and <code>nimArray</code>, respectively.
</p>
<p>The <code>nDim</code> argument is only necessary for a use like <code>dim &lt;- c(2, 3, 4); A &lt;- nimArray(0, dim = dim, nDim = 3)</code>.  It is necessary because the NIMBLE compiler must determine during compilation that <code>A</code> will be a 3-dimensional numeric array.  However, the compiler doesn't know for sure what the length of <code>dim</code> will be at run time, only that it is a vector.  On the other hand,   <code>A &lt;- nimArray(0, dim = c(2, 3, 4))</code> is allowed because the compiler can directly determine that a vector of length three is constructed inline for the <code>dim</code> argument.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek and Perry de Valpine
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimNumeric">nimNumeric</a></code> <code><a href="#topic+nimInteger">nimInteger</a></code> <code><a href="#topic+nimLogical">nimLogical</a></code>
</p>

<hr>
<h2 id='nimNumeric'>Creates numeric, integer or logical vectors for use in nimbleFunctions</h2><span id='topic+nimNumeric'></span><span id='topic+nimInteger'></span><span id='topic+nimLogical'></span><span id='topic+numeric'></span><span id='topic+integer'></span><span id='topic+logical'></span>

<h3>Description</h3>

<p>In a <code>nimbleFunction</code>, <code>numeric</code>, <code>integer</code> and <code>logical</code> are identical to <code>nimNumeric</code>, <code>nimInteger</code> and <code>nimLogical</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimNumeric(
  length = 0,
  value = 0,
  init = TRUE,
  fillZeros = TRUE,
  recycle = TRUE
)

nimInteger(
  length = 0,
  value = 0,
  init = TRUE,
  fillZeros = TRUE,
  recycle = TRUE
)

nimLogical(
  length = 0,
  value = 0,
  init = TRUE,
  fillZeros = TRUE,
  recycle = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimNumeric_+3A_length">length</code></td>
<td>
<p>the length of the vector (default = 0)</p>
</td></tr>
<tr><td><code id="nimNumeric_+3A_value">value</code></td>
<td>
<p>value(s) for initializing the vector (default = 0).  This may be a vector, matrix or array but will be used as a vector.</p>
</td></tr>
<tr><td><code id="nimNumeric_+3A_init">init</code></td>
<td>
<p>logical, whether to initialize elements of the vector (default = TRUE)</p>
</td></tr>
<tr><td><code id="nimNumeric_+3A_fillzeros">fillZeros</code></td>
<td>
<p>logical, whether to initialize any elements not filled by (possibly recycled) <code>value</code> with 0 (or FALSE for <code>nimLogical</code>) (default = TRUE)</p>
</td></tr>
<tr><td><code id="nimNumeric_+3A_recycle">recycle</code></td>
<td>
<p>logical, whether <code>value</code> should be recycled to fill the entire <code>length</code> of the new vector (default = TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are similar to R's <code><a href="#topic+numeric">numeric</a></code>, <code><a href="#topic+integer">integer</a></code>, <code><a href="#topic+logical">logical</a></code> functions, but they can be used in a nimbleFunction and then compiled using <code>compileNimble</code>.  Largely for compilation purposes, finer control is provided over initialization behavior.  If <code>init = FALSE</code>, no initialization will be done, and <code>value</code>, <code>fillZeros</code> and <code>recycle</code> will be ignored.  If <code>init=TRUE</code> and <code>recycle=TRUE</code>, then <code>fillZeros</code> will be ignored, and <code>value</code> will be repeated (according to R's recycling rule) as much as necessary to fill a vector of length <code>length</code>.  If <code>init=TRUE</code> and <code>recycle=FALSE</code>, then if <code>fillZeros=TRUE</code>, values of 0 (or FALSE for <code>nimLogical</code>) will be filled in after <code>value</code> up to length <code>length</code>.  Compiled code will be more efficient if unnecessary initialization is not done, but this may or may not be noticeable depending on the situation.
</p>
<p>When used in a <code>nimbleFunction</code> (in <code>run</code> or other member function), <code>numeric</code>, <code>integer</code> and <code>logical</code> are immediately converted to <code>nimNumeric</code>, <code>nimInteger</code> and <code>nimLogical</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek, Christopher Paciorek, Perry de Valpine
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimMatrix">nimMatrix</a></code>, <code><a href="#topic+nimArray">nimArray</a></code>
</p>

<hr>
<h2 id='nimOptim'>General-purpose Optimization</h2><span id='topic+nimOptim'></span>

<h3>Description</h3>

<p>NIMBLE wrapper around R's builtin <code><a href="stats.html#topic+optim">optim</a></code>, with flexibility for
additional methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimOptim(
  par,
  fn,
  gr = "NULL",
  he = "NULL",
  ...,
  method = "Nelder-Mead",
  lower = -Inf,
  upper = Inf,
  control = nimOptimDefaultControl(),
  hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimOptim_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_fn">fn</code></td>
<td>
<p>A function to be minimized (or maximized), with first argument the
vector of parameters over which minimization is to take place. It should
return a scalar result.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_gr">gr</code></td>
<td>
<p>A function to return the gradient for the &quot;BFGS&quot;, &quot;CG&quot; and
&quot;L-BFGS-B&quot; methods. If not provided, a finite-difference approximation to
derivatives will be used.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_he">he</code></td>
<td>
<p>A function to return the Hessian matrix of second derivatives. Used
(but not required) in &quot;nlminb&quot; or (optionally) user-provided methods.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_...">...</code></td>
<td>
<p>IGNORED</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_method">method</code></td>
<td>
<p>The method to be used. See 'Details' section of
<code><a href="stats.html#topic+optim">optim</a></code>. One of: &quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;L-BFGS-B&quot;, &quot;nlminb&quot;, or &quot;bobyqa&quot;. Note that the R methods &quot;SANN&quot;, &quot;Brent&quot; are not supported. It is
also possible to provide a new method; see details.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_lower">lower</code></td>
<td>
<p>Vector or scalar of lower bounds for parameters.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_upper">upper</code></td>
<td>
<p>Vector or scalar of upper bounds for parameters.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_control">control</code></td>
<td>
<p>A list of control parameters. See <code>Details</code> section of
<code><a href="stats.html#topic+optim">optim</a></code>. For code in a nimbleFunction to be compiled, this must
be an <code>optimControlNimbleList</code>, which has fields for most elements in
the control list for R's <code>optim</code>.</p>
</td></tr>
<tr><td><code id="nimOptim_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a Hessian matrix be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function for use in nimbleFunctions for compilation by
<code>compileNimble</code> provides capabilities similar to R's <code>optim</code> and
<code>nlminb</code>. For the supported methods provided by <code>optim</code>, a
compiled nimbleFunction will directly call the C code used by R for these
methods.
</p>
<p>If <code>optim</code> appears in a nimbleFunction, it will be converted to
<code>nimOptim</code>.
</p>
<p>Note that if a gradient function (<code>gr</code>) is not provided, <code>optim</code>
provides a finite difference approximation for use by optimization methods
that need gradients. nimble's compiled version of <code>nimOptim</code> does the
same thing, although results might not be completely identical.
</p>
<p>For <code>method="nlminb"</code>, a compiled nimbleFunction will run R's
<code>nlminb</code> directly in R, with <code>fn</code>, <code>gr</code> (if provided) and
<code>he</code> (if provided) that call back into compiled code. For
<code>method="bobyqa"</code>, a compiled nimbleFunction will run R's
<code>nloptr::bobyqa</code> directly in R, with <code>fn</code> that calls back
into compiled code.
</p>
<p>An experimental feature is the capability to provide one's own optimization
method in R and register it for use by <code>nimOptim</code>. One must write a
function that takes arguments <code>par</code>, <code>fn</code>, <code>gr</code>, <code>he</code>,
<code>lower</code>, <code>upper</code>, <code>control</code>, and <code>hessian</code>. The function
must return a list with elements <code>par</code>, <code>value</code>,
<code>convergence</code>, <code>counts</code>, <code>evaluations</code>, <code>message</code>, and
<code>hessian</code> (which may be NULL). If <code>hessian=TRUE</code> but the function
does not return a matrix in the <code>hessian</code> element of its return list,
<code>nimOptim</code> will fill in that element using finite differences of the
gradient. In general the function will be a wrapper around the actual
R optimization function.
</p>
<p>The <code>control</code> list passed from a nimbleFunction to the
optimization function will include a minimum of options, including
<code>abstol</code>, <code>reltol</code>, <code>maxit</code>, and <code>trace</code>. This means
that the user's R (wrapper) function must map between those minimum options
and the equivalent inputs to the optimization function. Other options
for a specific method may be set within the R (wrapper) function but
cannot be passed from <code>nimOptim</code>.
</p>
<p>The elements <code>parscale</code> and <code>fnscale</code> in <code>control</code> are used in
a special way. They are implemented by <code>nimOptim</code> such that for *any*
the method is expected to do minimization and <code>nimOptim</code> will arrange
for it to minimize <code>fn(par)/fnscale</code> in the parameter space
<code>par/parscale</code>.
</p>
<p>To use the optimizer with <code>nimOptim</code>, an optimizer <code>fun</code> must be
registered by <code>nimOptimMethod("method_name", fun)</code>, and then
&quot;<code>method_name</code>&quot; can be used as the <code>method</code> argument to
<code>nimOptim</code> to use <code>fun</code>. An optimizer may be found by
<code>nimOptimMethod("method_name")</code> and may be removed by
<code>nimOptimMethod("method_name", NULL)</code>.
</p>
<p>Support for <code>method="nlminb"</code> is provided in this way, and can be
studied as an example via <code>nimOptimMethod("nlminb")</code>.
</p>
<p>The system for providing one's own optimizer is not considered stable and is
subject to change in future versions.
</p>


<h3>Value</h3>

<p><code><a href="#topic+optimResultNimbleList">optimResultNimbleList</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
objectiveFunction &lt;- nimbleFunction(
    run = function(par = double(1)) {
        return(sum(par) * exp(-sum(par ^ 2) / 2))
        returnType(double(0))
    }
)
optimizer &lt;- nimbleFunction(
    run = function(method = character(0), fnscale = double(0)) {
        control &lt;- optimDefaultControl()
        control$fnscale &lt;- fnscale
        par &lt;- c(0.1, -0.1)
        return(optim(par, objectiveFunction, method = method, control = control))
        returnType(optimResultNimbleList())
    }
)
cOptimizer &lt;- compileNimble(optimizer)
cOptimizer(method = 'BFGS', fnscale = -1)

## End(Not run)
</code></pre>

<hr>
<h2 id='nimOptimDefaultControl'>Creates a default <code>control</code> argument for <code><a href="#topic+nimOptim">nimOptim</a></code>.</h2><span id='topic+nimOptimDefaultControl'></span>

<h3>Description</h3>

<p>Creates a default <code>control</code> argument for <code><a href="#topic+nimOptim">nimOptim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimOptimDefaultControl()
</code></pre>


<h3>Value</h3>

<p><code><a href="#topic+optimControlNimbleList">optimControlNimbleList</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimOptim">nimOptim</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>

<hr>
<h2 id='nimOptimMethod'>Set or get an optimization function to be used by <code>nimOptim</code></h2><span id='topic+nimOptimMethod'></span>

<h3>Description</h3>

<p>Add, check, or remove an R optimization function to/from NIMBLE's set of
registered optimization functions that can be called from <code>nimOptim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimOptimMethod(name, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimOptimMethod_+3A_name">name</code></td>
<td>
<p>character string, giving the name of optimization method that
can be referred to by the <code>method</code> argument of <code>nimOptim</code>
(aka <code>optim</code> in a nimbleFunction).</p>
</td></tr>
<tr><td><code id="nimOptimMethod_+3A_value">value</code></td>
<td>
<p>An optimization function with specifications described below and
in <code><a href="#topic+nimOptim">nimOptim</a></code>. If <code>value</code> is <code>NULL</code>, then <code>name</code>
will be found in NIMBLE's set of registered optimizer names. If
<code>value</code> is missing, the registered optimizer for <code>name</code> will be
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When programming in nimbleFunctions, <code>optim</code>, which is converted
automatically to <code><a href="#topic+nimOptim">nimOptim</a></code>, provides a generalization of R's
<code>optim</code> methods for optimization. If one of the supported original
<code>optim</code> methods is not chosen with the <code>method</code> argument to
<code>nimOptim</code>, an arbitrary method name can be given. If that name has been
registered as a <code>name</code> by a call to <code>nimOptimMethod</code>, then the
corresponding function (<code>value</code>) will be called for optimization.
</p>
<p>The function <code>value</code> must perform minimization. If the call to
<code>nimOptim</code> includes a control list with either <code>fnscale</code> (which, if
negative, turns the problem into a maximization) or <code>parscale</code>, these
will be managed by <code>nimOptim</code> outside of the optimizer such that the
optimization should be minimization.
</p>
<p>The function <code>value</code> must take named arguments <code>par</code> (initial
parameter vector), <code>fn</code> (objective function), <code>gr</code> (optional
gradient function), <code>he</code> (optional Hessian function), <code>lower</code>
(vector of lower bounds), <code>upper</code> (vector of upper bounds),
<code>control</code> (arbitrary control list), and <code>hessian</code> (logical
indicating whether a Hessian at the optimum is requested). It must return a
list with elements elements <code>par</code> (parameter values of the optimium,
i.e., &quot;arg min&quot;), <code>value</code> (function value at the minimum),
<code>convergence</code> (should be 0 if convergence occurred), <code>counts</code>
(optional vector of counts of calls to <code>fn</code>, <code>gr</code>, and <code>he</code>),
<code>evaluations</code> (optional total function evaluations), <code>message</code>
(optional character message), and <code>hessian</code> (optional Hessian matrix,
which may be NULL).
</p>
<p>If the call to <code>nimOptim</code> has <code>hessian=TRUE</code>, that will be passed
as <code>hessian=TRUE</code> to the optimizer. However, if the optimizer returns a
<code>NULL</code> in the <code>hessian</code> element of the return list, then
<code>nimOptim</code> will calculate the Hessian by finite element differences.
Hence, an optimizer need not provide a Hessian capability.
</p>
<p>The <code>control</code> list passed from <code>nimOptim</code> to the optimizer will
have only a limited set of the <code>optim</code> control list options. These will
include <code>abstol</code>, <code>reltol</code>, <code>maxit</code>, and <code>trace</code>. The
optimizer may use these as it wishes. Other control options for a particular
optimizer must be managed in some other way.
</p>
<p>Note that it is possible to use <code>browser()</code> inside of <code>value</code>, or
to set <code>debug(value)</code>, to enter a browser when the optimizer
(<code>value</code>) is called and then inspect its arguments to make sense of the
situation.
</p>
<p>This whole feature is particularly helpful when the nimbleFunction using
<code>nimOptim</code> has been compiled by <code>compileNimble</code>. Many optimizers
are available through R, so <code>nimOptim</code> arranges to call a named
(registered) optimizer in R, while providing <code>fn</code> and optionally
<code>gr</code> or <code>he</code> as functions that will call the compiled (by nimble)
versions of the corresponding functions provided in the call to
<code>nimOptim</code>.
</p>
<p>R's optimizer <code>nlminb</code> is automatically registered under the name
<code>"nlminb"</code>.
</p>

<hr>
<h2 id='nimPrint'>print function for use in nimbleFunctions</h2><span id='topic+nimPrint'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>print function for use in nimbleFunctions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimPrint(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimPrint_+3A_...">...</code></td>
<td>
<p>an abitrary set of arguments that will be printed in sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The keyword <code>print</code> in nimbleFunction run-time code will be automatically turned into <code>nimPrint</code>.  This is a function that prints its arguments in order using <code>cat</code> in R, or using <code>std::cout</code> in C++ code generated by compiling nimbleFunctions.
Non-scalar numeric objects can be included, although their output will be formatted slightly different in uncompiled and compiled nimbleFunctions.
</p>
<p>For numeric values, the number of digits printed is controlled by the system option <code>nimbleOptions('digits')</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cat">cat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ans &lt;- matrix(1:4, nrow = 2) ## R code, not NIMBLE code
nimPrint('Answer is ', ans) ## would work in R or NIMBLE

</code></pre>

<hr>
<h2 id='nimStop'>Halt execution of a nimbleFunction function method.  Part of the NIMBLE language</h2><span id='topic+nimStop'></span><span id='topic+stop'></span>

<h3>Description</h3>

<p>Halt execution of a nimbleFunction function method.  Part of the NIMBLE language
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimStop(msg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimStop_+3A_msg">msg</code></td>
<td>
<p>Character object to be output as an error message</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NIMBLE <code>stop</code> is similar to the native R <code>stop</code>, but it takes only one argument, the error message to be output.  During uncompiled NIMBLE execution, <code>nimStop</code> simply calls R's stop funtion. During compiled execution it calls the error function from the R headers.  <code>stop</code> is an alias for <code>nimStop</code> in the NIMBLE language
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>

<hr>
<h2 id='nimSvd'>Singular Value Decomposition of a Matrix</h2><span id='topic+nimSvd'></span><span id='topic+svd'></span>

<h3>Description</h3>

<p>Computes singular values and, optionally, left and right singular vectors of a numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimSvd(x, vectors = "full")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nimSvd_+3A_x">x</code></td>
<td>
<p>a symmetric numeric matrix (double or integer) whose spectral decomposition is to be computed.</p>
</td></tr>
<tr><td><code id="nimSvd_+3A_vectors">vectors</code></td>
<td>
<p>character that determines whether to calculate left and right singular vectors.  Can take values <code>'none'</code>, <code>'thin'</code> or <code>'full'</code>.  Defaults to <code>'full'</code>.  See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the singular value decomposition of a numeric matrix using the Eigen C++ template library.  
</p>
<p>The <code>vectors</code> character argument determines whether to compute no left and right singular vectors (<code>'none'</code>), thinned left and right singular vectors (<code>'thin'</code>), or full left and right singular vectors (<code>'full'</code>).  For a
matrix <code>x</code> with dimensions <code>n</code> and <code>p</code>, setting <code>vectors = 'thin'</code> will does the following (quoted from eigen website): 
In case of a rectangular n-by-p matrix, letting m be the smaller value among n and p, there are only m singular vectors; 
the remaining columns of U and V do not correspond to actual singular vectors. 
Asking for thin U or V means asking for only their m first columns to be formed. 
So U is then a n-by-m matrix, and V is then a p-by-m matrix. 
Notice that thin U and V are all you need for (least squares) solving.
</p>
<p>Setting <code>vectors = 'full'</code> will compute full matrices for U and V, so that U will be of size n-by-n, and V will be of size p-by-p.
</p>
<p>In a <code>nimbleFunction</code>, <code>svd</code> is identical to <code>nimSvd</code>. 
</p>
<p><code>returnType(svdNimbleList())</code> can be used within a <code>link{nimbleFunction}</code> to specify that the function will return a <code><a href="#topic+nimbleList">nimbleList</a></code> generated by the <code>nimSvd</code> function.  <code>svdNimbleList()</code> can also be used to define a nested <code><a href="#topic+nimbleList">nimbleList</a></code> element.  See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> for usage examples.
</p>


<h3>Value</h3>

<p>The singular value decomposition of <code>x</code> is returned as a <code><a href="#topic+nimbleList">nimbleList</a></code> with elements:
</p>

<ul>
<li><p> d length m vector containing the singular values of <code>x</code>, sorted in decreasing order.
</p>
</li>
<li><p> v matrix with columns containing the left singular vectors of <code>x</code>, or an empty matrix if <code>vectors = 'none'</code>.
</p>
</li>
<li><p> u matrix with columns containing the right singular vectors of <code>x</code>, or an empty matrix if <code>vectors = 'none'</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimEigen">nimEigen</a></code> for spectral decompositions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> singularValuesDemoFunction &lt;- nimbleFunction(
   setup = function(){
     demoMatrix &lt;- diag(4) + 2
   },
   run = function(){
     singularValues &lt;- svd(demoMatrix)$d
     returnType(double(1))
     return(singularValues)
 })
</code></pre>

<hr>
<h2 id='nodeFunctions'>calculate, calculateDiff, simulate, or get the current log probabilities (densities) a set of nodes in a NIMBLE model</h2><span id='topic+nodeFunctions'></span><span id='topic+calculate'></span><span id='topic+calculateDiff'></span><span id='topic+getLogProb'></span><span id='topic+simulate'></span>

<h3>Description</h3>

<p>calculate, calculateDiff, simulate, or get the current log probabilities (densities) of one or more nodes of a NIMBLE model and (for calculate and getLogProb) return the sum of their log probabilities (or densities).  Part of R and NIMBLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate(model, nodes, nodeFxnVector, nodeFunctionIndex)

calculateDiff(model, nodes, nodeFxnVector, nodeFunctionIndex)

getLogProb(model, nodes, nodeFxnVector, nodeFunctionIndex)

simulate(model, nodes, includeData = FALSE, nodeFxnVector, nodeFunctionIndex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodeFunctions_+3A_model">model</code></td>
<td>
<p>A NIMBLE model, either the compiled or uncompiled version</p>
</td></tr>
<tr><td><code id="nodeFunctions_+3A_nodes">nodes</code></td>
<td>
<p>A character vector of node names, with index blocks allowed, such as 'x', 'y[2]', or 'z[1:3, 2:4]'</p>
</td></tr>
<tr><td><code id="nodeFunctions_+3A_nodefxnvector">nodeFxnVector</code></td>
<td>
<p>An optional vector of nodeFunctions on which to operate, in lieu of <code>model</code> and <code>nodes</code></p>
</td></tr>
<tr><td><code id="nodeFunctions_+3A_nodefunctionindex">nodeFunctionIndex</code></td>
<td>
<p>For internal NIMBLE use only</p>
</td></tr>
<tr><td><code id="nodeFunctions_+3A_includedata">includeData</code></td>
<td>
<p>A logical argument specifying whether <code>data</code> nodes should be simulated into (only relevant for <code><a href="#topic+simulate">simulate</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard usage is as a method of a model, in the form <code>model$calculate(nodes)</code>, but the usage as a simple function with the model as the first argument as above is also allowed.
</p>
<p>These functions expands the nodes and then process them in the model in the order provided.  Expanding nodes means turning 'y[1:2]' into c('y[1]','y[2]') if y is a vector of scalar nodes.
Calculation is defined for a stochastic node as executing the log probability (density) calculation and for a deterministic node as calculating whatever function was provided on the right-hand side of the model declaration.
</p>
<p>Difference calculation (calculateDiff) executes the operation(s) on the model as calculate, but it returns the sum of the difference between the new log probabilities and the previous ones.
</p>
<p>Simulation is defined for a stochastic node as drawing a random value from its distribution, and for deterministic node as equivalent to calculate.
</p>
<p>getLogProb collects and returns the sum of the log probabilities of nodes, using the log probability values currently stored in the model (as generated from the most recent call to calculate on each node)
</p>
<p>These functions can be used from R or in NIMBLE run-time functions that will be compiled.  When executed in R (including when an uncompiled nimbleFunction is executed), they can be slow because the nodes are expanded each time.  When compiled in NIMBLE, the nodes are expanded only once during compilation, so execution will be much faster.
</p>
<p>It is common to want the nodes to be provided in topologically sorted order, so that they will be calculated or simulated following the order of the model graph.  Functions such as model$getDependencies(nodes, ...) return nodes in topologically sorted order.  They can be directly sorted by model$topologicallySortNodes(nodes), but if so it is a good idea to expand names first by model$topologicallySortNodes(model$expandNodeNames(nodes))
</p>


<h3>Value</h3>

<p>calculate and getLogProb return the sum of the log probabilities (densities) of the calculated nodes, with a contribution of 0 from any deterministic nodes
</p>
<p>calculateDiff returns the sum of the difference between the new and old log probabilities (densities) of the calculated nodes, with a contribution of 0 from any deterministic nodes.
</p>
<p>simulate returns NULL.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='optimControlNimbleList'>Data type for the <code>control</code> parameter of <code><a href="#topic+nimOptim">nimOptim</a></code></h2><span id='topic+optimControlNimbleList'></span>

<h3>Description</h3>

<p><code><a href="#topic+nimbleList">nimbleList</a></code> definition for the type of <code><a href="#topic+nimbleList">nimbleList</a></code> input as the <code>control</code> parameter
to <code><a href="#topic+nimOptim">nimOptim</a></code>. See <code><a href="stats.html#topic+optim">optim</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimControlNimbleList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+nimOptim">nimOptim</a></code>
</p>

<hr>
<h2 id='optimDefaultControl'>Creates a deafult <code>control</code> argument for <code><a href="stats.html#topic+optim">optim</a></code> (just an empty list).</h2><span id='topic+optimDefaultControl'></span>

<h3>Description</h3>

<p>Creates a deafult <code>control</code> argument for <code><a href="stats.html#topic+optim">optim</a></code> (just an empty list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimDefaultControl()
</code></pre>


<h3>Value</h3>

<p>an empty <code>list</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimOptim">nimOptim</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>

<hr>
<h2 id='optimResultNimbleList'>Data type for the return value of <code><a href="#topic+nimOptim">nimOptim</a></code></h2><span id='topic+optimResultNimbleList'></span>

<h3>Description</h3>

<p><code><a href="#topic+nimbleList">nimbleList</a></code> definition for the type of <code><a href="#topic+nimbleList">nimbleList</a></code> returned by <code><a href="#topic+nimOptim">nimOptim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimResultNimbleList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Fields</h3>


<dl>
<dt><code>par</code></dt><dd><p>The best set of parameters found.</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of fn corresponding to par.</p>
</dd>
<dt><code>counts</code></dt><dd><p>A two-element integer vector giving the number of calls to fn and gr respectively.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>An integer code. 0 indicates successful completion. Possible error codes are
1 indicates that the iteration limit maxit had been reached.
10 indicates degeneracy of the Nelder-Mead simplex.
51 indicates a warning from the &quot;L-BFGS-B&quot; method; see component message for further details.
52 indicates an error from the &quot;L-BFGS-B&quot; method; see component message for further details.</p>
</dd>
<dt><code>message</code></dt><dd><p>A character string giving any additional information returned by the optimizer, or NULL.</p>
</dd>
<dt><code>hessian</code></dt><dd><p>Only if argument hessian is true. A symmetric matrix giving an estimate of the Hessian at the solution found.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+nimOptim">nimOptim</a></code>
</p>

<hr>
<h2 id='parameterTransform'>Automated transformations of model nodes to unconstrained scales</h2><span id='topic+parameterTransform'></span>

<h3>Description</h3>

<p>Provide general transformations of constrained continuous-valued model nodes (parameters) to unconstrained scales.  It handles the cases of interval-bounded parameters (e.g. uniform or beta distributions), semi-interval-bounded parameters (e.g. exponential or gamma distributions), and the multivariate Wishart, inverse Wishart, Dirichlet, and LKJ distributions.  Utilities are provided to transform parameters to an unconstrained scale, back-transform from the unconstrained scale to the original scale of the constrained parameterization, and to calculate the natural logarithm of the determinant of the Jacobian matrix of the inverse transformation, calculated at any location in the transformed (unconstrained) space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameterTransform(model, nodes = character(0), control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameterTransform_+3A_model">model</code></td>
<td>
<p>A nimble model object.  See details.</p>
</td></tr>
<tr><td><code id="parameterTransform_+3A_nodes">nodes</code></td>
<td>
<p>A character vector specifying model node names to undergo transformation.  See details.</p>
</td></tr>
<tr><td><code id="parameterTransform_+3A_control">control</code></td>
<td>
<p>An optional list allowing for additional control of the transformation. This currently supports a single element <code>allowDeterm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>parameterTransform</code> nimbleFunction is an unspecialized function.  Calling <code>parameterTransform(model, nodes)</code> will generate and return a specialized nimbleFunction, which provides transformation functionality for the specified hierarchical model and set of model nodes.  The <code>nodes</code> argument can represent mutliple model nodes arising from distinct prior distributions, which will be simultaneously transformed according to their respective distributions and constraints.
</p>
<p>If the <code>nodes</code> argument is missing or has length zero, then no nodes will be transformed.  A specialized nimbleFunction is created, but will not transform or operate on any model nodes.
</p>
<p>The <code>control</code> argument is a list that supports one additional setting. If <code>control$allowDeterm=FALSE</code> (the default), deterministic nodes are not allowed in the <code>nodes</code> argument.  If <code>control$allowDeterm=TRUE</code>, deterministic nodes are allowed and assumed to have no constraints on valid values.
</p>
<p>This specialized nimbleFunction has the following methods:
</p>
<p><code>transform</code>: Transforms a numeric vector of values from the original constrained model scale to a vector of values on the unconstrained scale.
</p>
<p><code>inverseTransform</code>: Transforms a numeric vector of values from the unconstrained scale to the original constrained parameterization scale.
</p>
<p>The unconstrained scale may have different dimensionality from the original constrained scale of the model parameters.  For example, a d-dimensional dirichlet distribution is constrained to reside on a simplex in d-dimensional space.  In contrast, the corresponding unconstrained parameterization is unrestrained in (d-1) dimensional space.  The specialized <code>parameterTransform</code> nimbleFunction also provides utilities to return the dimensionality of the original (constrained) parameterization, and the transformed (unconstrained) parameterization:
</p>
<p><code>getOriginalLength</code>: Returns the dimensionality (number of scalar elements) of the original constrained parameterization.
</p>
<p><code>getTransformedLength</code>: Returns the dimensionality (number of scalar elements) comprising the transformed unconstrained parameterization.
</p>
<p>The specialized <code>parameterTransform</code> nimbleFunction also provides a method for calculating the natural logarithm of the jacobian of the inverse transformation, calculated at any point in the transformed (unconstrained) space:
</p>
<p><code>logDetJacobian</code>
</p>
<p>The <code>parameterTransformation</code> function has no facility for handling discrete-valued parameters.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildLaplace">buildLaplace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
code &lt;- nimbleCode({
    a ~ dnorm(0, 1)
    b ~ dgamma(1, 1)
    c ~ dunif(2, 10)
    d[1:3] ~ dmnorm(mu[1:3], cov = C[1:3,1:3])
    e[1:3,1:3] ~ dwish(R = C[1:3,1:3], df = 5)
})
 
constants &lt;- list(mu=rep(0,3), C=diag(3))
 
Rmodel &lt;- nimbleModel(code, constants)
 
## create a specialized parameterTransform function:
nodes &lt;- c('a', 'b', 'c', 'd', 'e')
pt &lt;- parameterTransform(Rmodel, nodes)
 
vals &lt;- c(1, 10, 5,    1,2,3,   as.numeric(diag(3)))
 
## transform values to unconstrained scale:
transformedVals &lt;- pt$transform(vals)
 
## back-transform to original constrained scale of parameterization
pt$inverseTransform(transformedVals)  ## return is same as original vals
 
## dimensionality of original constrained scale = 1 + 1 + 1 + 3 + 9
pt$getOriginalLength()      ## 15
 
## dimensionality of transformed (unconstrained) scale = 1 + 1 + 1 + 3 + 6
pt$getTransformedLength()   ## 12
 
## log of the jacobian of the inverse transformation matrix:
pt$logDetJacobian(transformedVals)

## End(Not run)

</code></pre>

<hr>
<h2 id='pow_int'>Power function for integer-valued exponent</h2><span id='topic+pow_int'></span>

<h3>Description</h3>

<p>pow function with exponent required to be integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow_int(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pow_int_+3A_a">a</code></td>
<td>
<p>Base</p>
</td></tr>
<tr><td><code id="pow_int_+3A_b">b</code></td>
<td>
<p>Exponent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is required in nimble models and nimbleFunctions if derivatives will be tracked
but tracked only with respect to a, such that b might be any (positive, 0, or negative) integer.
This contrasts with pow(a, b) (equivalent to a^b), which requires b &gt; 0 if derivatives will be
tracked, even if they will only be requested with respect to a.
</p>


<h3>Value</h3>

<p>a^b
</p>

<hr>
<h2 id='printErrors'>Print error messages after failed compilation</h2><span id='topic+printErrors'></span>

<h3>Description</h3>

<p>Retrieves the error file from R's tempdir and prints to the screen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printErrors(excludeWarnings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printErrors_+3A_excludewarnings">excludeWarnings</code></td>
<td>
<p>logical indicating whether compiler warnings should be printed; generally such warnings can be ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>

<hr>
<h2 id='rankSample'>Generates a weighted sample (with replacement) of ranks</h2><span id='topic+rankSample'></span>

<h3>Description</h3>

<p>Takes a set of non-negative <code>weights</code> (do not need to sum to 1) and 
returns a sample with <code>size</code> elements of the integers <code>1:length(weights)</code>, where the probability of being sampled is proportional
to the value of <code>weights</code>. An important note is that the output vector
will be sorted in ascending order. Also, right now it works slightly odd syntax (see example below). Later releases of NIMBLE will contain more natural syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankSample(weights, size, output, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankSample_+3A_weights">weights</code></td>
<td>
<p>A vector of numeric weights. Does not need to sum to 1, but must be non-negative</p>
</td></tr>
<tr><td><code id="rankSample_+3A_size">size</code></td>
<td>
<p>Size of sample</p>
</td></tr>
<tr><td><code id="rankSample_+3A_output">output</code></td>
<td>
<p>An R object into which the values will be placed. See example below for proper use</p>
</td></tr>
<tr><td><code id="rankSample_+3A_silent">silent</code></td>
<td>
<p>Logical indicating whether to suppress logging information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If invalid weights provided (i.e. negative weights or weights sum to 1), sets output = rep(1, size) and prints warning. 
<code>rankSample</code> can be used inside nimble functions.
</p>
<p><code>rankSample</code> first samples from the joint distribution <code>size</code> uniform(0,1) distributions by conditionally sampling from the rank statistics. This leads to 
a sorted sample of uniform(0,1)'s. Then, a cdf vector is constructed from weights. Because the sample of uniforms is sorted, <code>rankSample</code> walks
down the cdf in linear time and fills out the sample.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
sampInts = NA	#sampled integers will be placed in sampInts
rankSample(weights = c(1, 1, 2), size = 10, sampInts)
sampInts
# [1] 1 1 2 2 2 2 2 3 3 3
rankSample(weights = c(1, 1, 2), size = 10000, sampInts)
table(sampInts)
#sampInts
#   1    2    3 
#2434 2492 5074 

#Used in a nimbleFunction
sampGen &lt;- nimbleFunction(setup = function(){
	x = 1:2
},
run = function(weights = double(1), k = integer() ){
	rankSample(weights, k, x)
	returnType(integer(1))
	return(x)
})
rSamp &lt;- sampGen()
rSamp$run(1:4, 5)
#[1] 3 3 4 4 4
</code></pre>

<hr>
<h2 id='readBUGSmodel'>Create a NIMBLE BUGS model from a variety of input formats, including BUGS model files</h2><span id='topic+readBUGSmodel'></span>

<h3>Description</h3>

<p><code>readBUGSmodel</code> processes inputs providing the model and values for constants, data, initial values of the model in a variety of forms, returning a NIMBLE BUGS R model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBUGSmodel(
  model,
  data = NULL,
  inits = NULL,
  dir = NULL,
  useInits = TRUE,
  debug = FALSE,
  returnComponents = FALSE,
  check = getNimbleOption("checkModel"),
  calculate = TRUE,
  buildDerivs = getNimbleOption("buildModelDerivs")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBUGSmodel_+3A_model">model</code></td>
<td>
<p>one of (1) a character string giving the file name containing the BUGS model code, with relative or absolute path, (2) an R function whose body is the BUGS model code, or (3) the output of <code><a href="#topic+nimbleCode">nimbleCode</a></code>. If a file name, the file can contain a 'var' block and 'data' block in the manner of the JAGS versions of the BUGS examples but should not contain references to other input data files nor a const block. The '.bug' or '.txt' extension can be excluded.</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_data">data</code></td>
<td>
<p>(optional) (1) character string giving the file name for an R file providing the input constants and data as R code [assigning individual objects or as a named list], with relative or absolute path, or (2) a named list providing the input constants and data. If neither is provided, the function will look for a file named 'name_of_model-data' including extensions .R, .r, or .txt.</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_inits">inits</code></td>
<td>
<p>(optional) (1) character string giving the file name for an R file providing starting values as R code [assigning individual objects or as a named list], with relative or absolute path, or (2) a named list providing the starting values. Unlike JAGS, this should provide a single set of starting values, and therefore if provided as a list should be a simple list and not a list of lists.</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_dir">dir</code></td>
<td>
<p>(optional) character string giving the directory where the (optional) files are located</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_useinits">useInits</code></td>
<td>
<p>boolean indicating whether to set the initial values, either based on <code>inits</code> or by finding the '-inits' file corresponding to the input model file</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_debug">debug</code></td>
<td>
<p>logical indicating whether to put the user in a browser for debugging when <code><a href="#topic+readBUGSmodel">readBUGSmodel</a></code> calls <code><a href="#topic+nimbleModel">nimbleModel</a></code>.  Intended for developer use.</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_returncomponents">returnComponents</code></td>
<td>
<p>logical indicating whether to return pieces of model  object without building the model. Default is FALSE.</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_check">check</code></td>
<td>
<p>logical indicating whether to check the model object for missing or invalid values.  Default is given by the NIMBLE option 'checkModel'. See <code><a href="#topic+nimbleOptions">nimbleOptions</a></code> for details.</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_calculate">calculate</code></td>
<td>
<p>logical indicating whether to run <code><a href="#topic+calculate">calculate</a></code> on the model after building it; this will calculate all deterministic nodes and logProbability values given the current state of all nodes. Default is TRUE. For large models, one might want to disable this, but note that deterministic nodes, including nodes introduced into the model by NIMBLE, may be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="readBUGSmodel_+3A_buildderivs">buildDerivs</code></td>
<td>
<p>logical indicating whether to build derivative capabilities for the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>readBUGSmodel</code> should handle most common ways of providing information on a model as used in BUGS and JAGS but does not handle input model files that refer to additional files containing data. Please see the BUGS examples provided with NIMBLE in the <code>classic-bugs</code> directory of the installed NIMBLE package or JAGS (<a href="https://sourceforge.net/projects/mcmc-jags/files/Examples/">https://sourceforge.net/projects/mcmc-jags/files/Examples/</a>) for examples of supported formats. Also, <code>readBUGSmodel</code> takes both constants and data via the 'data' argument, unlike <code><a href="#topic+nimbleModel">nimbleModel</a></code>, in which these are distinguished. The reason for allowing both to be given via 'data' is for backwards compatibility with the BUGS examples, in which constants and data are not distinguished.
</p>


<h3>Value</h3>

<p>returns a NIMBLE BUGS R model
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimbleModel">nimbleModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Reading a model defined in the R session

code &lt;- nimbleCode({
    x ~ dnorm(mu, sd = 1)
    mu ~ dnorm(0, sd = prior_sd)
})
data = list(prior_sd = 1, x = 4)
model &lt;- readBUGSmodel(code, data = data, inits = list(mu = 0))
model$x
model[['mu']]
model$calculate('x')

## Reading a classic BUGS model

pumpModel &lt;- readBUGSmodel('pump.bug', dir = getBUGSexampleDir('pump'))
pumpModel$getVarNames()
pumpModel$x

</code></pre>

<hr>
<h2 id='registerDistributions'>Add user-supplied distributions for use in NIMBLE BUGS models</h2><span id='topic+registerDistributions'></span>

<h3>Description</h3>

<p>Register distributional information so that NIMBLE can process
user-supplied distributions in BUGS model code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerDistributions(
  distributionsInput,
  userEnv = parent.frame(),
  verbose = nimbleOptions("verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="registerDistributions_+3A_distributionsinput">distributionsInput</code></td>
<td>
<p>either a list or character vector specifying the user-supplied distributions. If a list, it should be a named list of lists in the form of that shown in <code>nimble:::distributionsInputList</code> with each list having required field <code>BUGSdist</code> and optional fields <code>Rdist</code>, <code>altParams</code>, <code>discrete</code>, <code>pqAvail</code>, <code>types</code>, and with the name of the list the same as that of the density function. Alternatively, simply a character vector providing the names of the density functions for the user-supplied distributions.</p>
</td></tr>
<tr><td><code id="registerDistributions_+3A_userenv">userEnv</code></td>
<td>
<p>environment in which to look for the nimbleFunctions that provide the distribution; this will generally not need to be set by the user as it will default to the environment from which this function was called.</p>
</td></tr>
<tr><td><code id="registerDistributions_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print additional logging information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>distributionsInput</code> is a list of lists, see below for more information on the structure of the list. When <code>distributionsInput</code> is a character vector, the distribution is assumed to be of standard form, with parameters assumed to be the arguments provided in the density nimbleFunction, no alternative parameterizations, and the distribution assumed to be continuous with range from minus infinity to infinity. The availability of distribution and quantile functions is inferred from whether appropriately-named functions exist in the global environment.
</p>
<p>One usually does not need to explicitly call <code>registerDistributions</code> as it will be called automatically when the user-supplied distribution is used for the first time in BUGS code. However, if one wishes to provide alternative parameterizations, to provide a range, or to indicate a distribution is discrete, then one still must explicitly register the distribution using <code>registerDistributions</code> with the argument in the list format.
</p>
<p>Format of the component lists when <code>distributionsInput</code> is a list of lists:
</p>

<ul>
<li> <p><code>BUGSdist</code>. A character string in the form of the density name (starting with 'd') followed by the names of the parameters in parentheses. When alternative parameterizations are given in <code>Rdist</code>, this should be an exhaustive list of the unique parameter names from all possible parameterizations, with the default parameters specified first.
</p>
</li>
<li> <p><code>Rdist</code>. An optional character vector with one or more alternative specifications of the density; each alternative specification can be an alternative name for the density, a different ordering of the parameters, different parameter name(s), or an alternative parameterization. In the latter case, the character string in parentheses should provide a given reparameterization as comma-separated name = value pairs, one for each default parameter, where name is the name of the default parameter and value is a mathematical expression relating the default parameter to the alternative parameters or other default parameters. The default parameters should correspond to the input arguments of the nimbleFunctions provided as the density and random generation functions. The mathematical expression can use any of the math functions allowed in NIMBLE (see the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a>) as well as user-supplied nimbleFunctions (which must have no setup code). The names of your nimbleFunctions for the distribution functions must match the function name in the <code>Rdist</code> entry (or if missing, the function name in the <code>BUGSdist</code> entry.
</p>
</li>
<li> <p><code>discrete</code>. An optional logical indicating if the distribution is that of a discrete random variable. If not supplied, distribution is assumed to be for a continuous random variable.
</p>
</li>
<li> <p><code>pqAvail</code>. An optional logical indicating if distribution (CDF) and quantile (inverse CDF) functions are provided as nimbleFunctions. These are required for one to be able to use truncated versions of the distribution. Only applicable for univariate distributions. If not supplied, assumed to be FALSE.
</p>
</li>
<li> <p><code>altParams</code>. A character vector of comma-separated 'name = value' pairs that provide the mathematical expressions relating non-canonical parameters to canonical parameters (canonical parameters are those passed as arguments to your distribution functions). These inverse functions are used for MCMC conjugacy calculations when a conjugate relationship is expressed in terms of non-default parameters (such as the precision for normal-normal conjugacy). If not supplied, the system will still function but with a possible loss of efficiency in certain algorithms.
</p>
</li>
<li> <p><code>types</code>. A character vector of comma-separated 'name = input' pairs indicating the type and dimension of the random variable and parameters (including default and alternative parameters). 'input' should take the form 'double(d)' or 'integer(d)', where 'd' is 0 for scalars, 1 for vectors, 2 for matrices. Note that since NIMBLE uses doubles for numerical calculations and the default type  is <code>double(0)</code>, one should generally use 'double' and one need only specify the type for non-scalars. 'name' should be either 'value' to indicate the random variable itself or the parameter name to indicate a given parameter.  
</p>
</li>
<li> <p><code>range</code>. A vector of two values giving the range of the distribution for possible use in future algorithms (not used currently). When the lower or upper limit involves a strict inequality (e.g., $x&gt;0$), you should simply treat it as a non-strict inequality ($x&gt;=0$, and set the lower value to 0). Also we do not handle ranges that are functions of parameters, so simply use the smallest/largest possible values given the possible parameter values. If not supplied this is taken to be <code>(-Inf, Inf)</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmyexp &lt;- nimbleFunction(
   run = function(x = double(0), rate = double(0), log = integer(0)) {
       returnType(double(0))
       logProb &lt;- log(rate) - x*rate
       if(log) {
           return(logProb)
       } else {
           return(exp(logProb))
       }
   })
rmyexp &lt;- nimbleFunction(
   run = function(n = integer(0), rate = double(0)) {
       returnType(double(0))
       if(n != 1) nimPrint("rmyexp only allows n = 1; using n = 1.")
       dev &lt;- runif(1, 0, 1)
       return(-log(1-dev) / rate)
   }
   )
registerDistributions(list(
    dmyexp = list(
              BUGSdist = "dmyexp(rate, scale)",
              Rdist = "dmyexp(rate = 1/scale)",
              altParams = "scale = 1/rate",
              pqAvail = FALSE)))
code &lt;- nimbleCode({
    y ~ dmyexp(rate = r)
    r ~ dunif(0, 100)
})
m &lt;- nimbleModel(code, inits = list(r = 1), data = list(y = 2))
m$calculate('y')
m$r &lt;- 2
m$calculate('y')
m$resetData()
m$simulate('y')
m$y

# alternatively, simply specify a character vector with the
# name of one or more 'd' functions
deregisterDistributions('dmyexp')
registerDistributions('dmyexp')

# or simply use in BUGS code without registration
deregisterDistributions('dmyexp')
m &lt;- nimbleModel(code, inits = list(r = 1), data = list(y = 2))

# example of Dirichlet-multinomial registration to illustrate
# use of 'types' (note that registration is not actually needed
# in this case)
ddirchmulti &lt;- nimbleFunction(
    run = function(x = double(1), alpha = double(1), size = double(0), 
                   log = integer(0, default = 0)) {
        returnType(double(0))
        logProb &lt;- lgamma(size) - sum(lgamma(x)) + lgamma(sum(alpha)) - 
            sum(lgamma(alpha)) + sum(lgamma(alpha + x)) - lgamma(sum(alpha) + 
                                                                 size)
        if(log) return(logProb)
        else return(exp(logProb))
    })

rdirchmulti &lt;- nimbleFunction(
    run = function(n = integer(0), alpha = double(1), size = double(0)) {
        returnType(double(1))
        if(n != 1) print("rdirchmulti only allows n = 1; using n = 1.")
        p &lt;- rdirch(1, alpha)
        return(rmulti(1, size = size, prob = p))
    })

registerDistributions(list(
    ddirchmulti = list(
        BUGSdist = "ddirchmulti(alpha, size)",
        types = c('value = double(1)', 'alpha = double(1)')
        )
    ))
</code></pre>

<hr>
<h2 id='resize'>Resizes a modelValues object</h2><span id='topic+resize'></span>

<h3>Description</h3>

<p>Adds or removes rows to a modelValues object. If rows are added to a modelValues object, the default values are <code>NA</code>. Works in both R and NIMBLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resize(container, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resize_+3A_container">container</code></td>
<td>
<p>modelValues object</p>
</td></tr>
<tr><td><code id="resize_+3A_k">k</code></td>
<td>
<p>number of rows that modelValues is set to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a> or <code>help(modelValuesBaseClass)</code> for infomation about modelValues objects
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mvConf &lt;- modelValuesConf(vars = c('a', 'b'),
             types = c('double', 'double'),
             sizes = list(a = 1, b = c(2,2) ) ) 
mv &lt;- modelValues(mvConf)
as.matrix(mv)
resize(mv, 3)
as.matrix(mv)

</code></pre>

<hr>
<h2 id='Rmatrix2mvOneVar'>Set values of one variable of a modelValues object from an R matrix</h2><span id='topic+Rmatrix2mvOneVar'></span>

<h3>Description</h3>

<p>Normally a modelValues object is accessed one &quot;row&quot; at a time.  This function allows all rows for one variable to set from a matrix with one dimension more than the variable to be set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rmatrix2mvOneVar(mat, mv, varName, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rmatrix2mvOneVar_+3A_mat">mat</code></td>
<td>
<p>Input matrix</p>
</td></tr>
<tr><td><code id="Rmatrix2mvOneVar_+3A_mv">mv</code></td>
<td>
<p>modelValues object to be modified.</p>
</td></tr>
<tr><td><code id="Rmatrix2mvOneVar_+3A_varname">varName</code></td>
<td>
<p>Character string giving the name of the variable on <code>mv</code> to be set</p>
</td></tr>
<tr><td><code id="Rmatrix2mvOneVar_+3A_k">k</code></td>
<td>
<p>Number of rows to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be deprecated in the future when a more natural system for interacting with modelValues objects is developed.
</p>

<hr>
<h2 id='RmodelBaseClass-class'>Class <code>RmodelBaseClass</code></h2><span id='topic+RmodelBaseClass-class'></span><span id='topic+RmodelBaseClass'></span>

<h3>Description</h3>

<p>Classes used internally in NIMBLE and not expected to be called directly by users.
</p>

<hr>
<h2 id='run.time'>Time execution of NIMBLE code</h2><span id='topic+run.time'></span>

<h3>Description</h3>

<p>Time execution of NIMBLE code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.time(code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.time_+3A_code">code</code></td>
<td>
<p>code to be timed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for use in nimbleFunction run code; when nimbleFunctions are run in R, this simply wraps <code>system.time</code>.
</p>


<h3>Author(s)</h3>

<p>NIMBLE Development Team
</p>

<hr>
<h2 id='runCrossValidate'>Perform k-fold cross-validation on a NIMBLE model fit by MCMC</h2><span id='topic+runCrossValidate'></span>

<h3>Description</h3>

<p>Takes a NIMBLE model MCMC configuration and conducts k-fold cross-validation of
the MCMC fit, returning a measure of the model's predictive performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCrossValidate(
  MCMCconfiguration,
  k,
  foldFunction = "random",
  lossFunction = "MSE",
  MCMCcontrol = list(),
  returnSamples = FALSE,
  nCores = 1,
  nBootReps = 200,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runCrossValidate_+3A_mcmcconfiguration">MCMCconfiguration</code></td>
<td>
<p>a NIMBLE MCMC configuration object, returned by a 
call to <code>configureMCMC</code>.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_k">k</code></td>
<td>
<p>number of folds that should be used for cross-validation.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_foldfunction">foldFunction</code></td>
<td>
<p>one of (1) an R function taking a single integer argument
<code>i</code>, and returning a character vector with the names of the data nodes 
to leave out of the model for fold <code>i</code>, or (2) the character string 
<code>"random"</code>, indicating that data nodes will be randomly partitioned 
into <code>k</code> folds.  Note that choosing &quot;random&quot; and setting <code>k</code> equal to
the total number of data nodes in the model will perform leave-one-out cross-validation.
Defaults to <code>"random"</code>.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_lossfunction">lossFunction</code></td>
<td>
<p>one of (1) an R function taking a set of simulated data
and a set of observed data, and calculating the loss from those, or (2) a
character string naming one of NIMBLE's built-in loss functions.  If a 
character string, must be one of <code>"predictive"</code> to use the log 
predictive density as a loss function or <code>"MSE"</code> to use the mean squared
error as a loss function.  Defaults to <code>"MSE"</code>.  See &lsquo;Details&rsquo;
for information on creating a user-defined loss function.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_mcmccontrol">MCMCcontrol</code></td>
<td>
<p>(optional) an R list with parameters governing the 
MCMC algorithm,  See &lsquo;Details&rsquo; for specific parameters.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_returnsamples">returnSamples</code></td>
<td>
<p>logical indicating whether to return all 
posterior samples from all MCMC runs.  This can result in a very large returned
object  (there will be <code>k</code> sets of
posterior samples returned).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_ncores">nCores</code></td>
<td>
<p>number of cpu cores to use in
parallelizing the CV calculation. Only MacOS and Linux operating systems support multiple
cores at this time.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_nbootreps">nBootReps</code></td>
<td>
<p>number of bootstrap samples
to use when estimating the Monte Carlo error of the cross-validation metric. Defaults to 200.  If no Monte Carlo error estimate is desired,
<code>nBootReps</code> can be set to <code>NA</code>, which can potentially save significant computation time.</p>
</td></tr>
<tr><td><code id="runCrossValidate_+3A_silent">silent</code></td>
<td>
<p>Boolean specifying whether to show output from the algorithm as it's running (default = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>k-fold CV in NIMBLE proceeds by separating the data in a <code>nimbleModel</code>
into <code>k</code> folds, as determined by the
<code>foldFunction</code> argument.  For each fold, the corresponding data are held out of the model, 
and MCMC is run to estimate the posterior distribution and simultaneously impute
posterior predictive values for the held-out data. 
Then, the posterior predictive values are compared to the 
known, held-out data values via the specified <code>lossFunction</code>.  The loss values are
averaged over the posterior samples for each fold, and these averaged values for each
fold are then averaged over all folds to produce a single out-of-sample 
loss estimate.  Additionally, estimates of the Monte Carlo error for each fold are returned.
</p>


<h3>Value</h3>

<p>an R list with four elements:
</p>

<ul>
<li> <p><code>CVvalue</code>. The CV value, measuring the model's ability to predict new data.  Smaller relative values indicate better model performance.
</p>
</li>
<li> <p><code>CVstandardError</code>. The standard error of the CV value, giving an indication of the total Monte Carlo error in the CV estimate.
</p>
</li>
<li> <p><code>foldCVInfo</code>. An list of fold CV values and standard errors for each fold.
</p>
</li>
<li> <p><code>samples</code>. An R list, only returned when <code>returnSamples = TRUE</code>.  The i'th element of this list will be a matrix of posterior samples from the model with the i'th fold of data left out.  There will be <code>k</code> sets of samples.
</p>
</li></ul>



<h3>The <code>foldFunction</code> Argument</h3>

<p>If the default <code>'random'</code> method is not used, the <code>foldFunction</code> argument
must be an R function that takes a single integer-valued argument <code>i</code>.  <code>i</code>
is guaranteed to be within the range <code class="reqn">[1, k]</code>. For each integer value <code>i</code>,
the function should return a character vector of node names corresponding to the data
nodes that will be left out of the model for that fold. The returned node names can be expanded,
but don't need to be.   For example, if fold <code>i</code> is inteded to leave out the model nodes
<code>x[1]</code>, <code>x[2]</code> and <code>x[3]</code> then the function could return either
<code>c('x[1]', 'x[2]', 'x[3]')</code> or <code>'x[1:3]'</code>.
</p>


<h3>The <code>lossFunction</code> Argument</h3>

<p>If you don't wish to use NIMBLE's built-in <code>"MSE"</code> or <code>"predictive"</code> loss
functions, you may provide your own R function as the <code>lossFunction</code> argument to
<code>runCrossValidate</code>.  A user-supplied  <code>lossFunction</code> must be an R function
that takes two arguments: the first, named <code>simulatedDataValues</code>, will be a vector
of simulated data values.  The second, named <code>actualDataValues</code>, will be a vector of
observed data values corresponding to the simulated data values in <code>simulatedDataValues</code>.
The loss function should return a single scalar number.
See &lsquo;Examples&rsquo; for an example of a user-defined loss function.
</p>


<h3>The <code>MCMCcontrol</code> Argument</h3>

<p>The <code>MCMCcontrol</code> argument is a list with the following elements:
</p>

<ul>
<li> <p><code>niter</code>. An integer argument determining how many MCMC iterations should be run for each loss value calculation.  Defaults to 10000, but should probably be manually set.
</p>
</li>
<li> <p><code>nburnin</code>. The number of samples from the start of the MCMC chain to discard as burn-in for each loss value calculation.  Must be between 0 and <code>niter</code>.  Defaults to 10
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Michaud and Lauren Ponisio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## We conduct CV on the classic "dyes" BUGS model.

dyesCode &lt;- nimbleCode({
  for (i in 1:BATCHES) {
    for (j in 1:SAMPLES) {
      y[i,j] ~ dnorm(mu[i], tau.within);
    }
    mu[i] ~ dnorm(theta, tau.between);
  }

  theta ~ dnorm(0.0, 1.0E-10);
  tau.within ~ dgamma(0.001, 0.001);  sigma2.within &lt;- 1/tau.within;
  tau.between ~ dgamma(0.001, 0.001);  sigma2.between &lt;- 1/tau.between;
})

dyesData &lt;- list(y = matrix(c(1545, 1540, 1595, 1445, 1595,
                              1520, 1440, 1555, 1550, 1440,
                              1630, 1455, 1440, 1490, 1605,
                              1595, 1515, 1450, 1520, 1560, 
                              1510, 1465, 1635, 1480, 1580,
                              1495, 1560, 1545, 1625, 1445), 
                              nrow = 6, ncol = 5))
                              
dyesConsts &lt;- list(BATCHES = 6,
                   SAMPLES = 5)
                   
dyesInits &lt;- list(theta = 1500, tau.within = 1, tau.between =  1)

dyesModel &lt;- nimbleModel(code = dyesCode,
                         constants = dyesConsts,
                         data = dyesData,
                         inits = dyesInits)

# Define the fold function.
# This function defines the data to leave out for the i'th fold
# as the i'th row of the data matrix y.  This implies we will have
# 6 folds.

dyesFoldFunction &lt;- function(i){
  foldNodes_i &lt;- paste0('y[', i, ', ]')  # will return 'y[1,]' for i = 1 e.g.
  return(foldNodes_i)
}

# We define our own loss function as well.
# The function below will compute the root mean squared error.

RMSElossFunction &lt;- function(simulatedDataValues, actualDataValues){
  dataLength &lt;- length(simulatedDataValues) # simulatedDataValues is a vector
  SSE &lt;- 0
  for(i in 1:dataLength){
    SSE &lt;- SSE + (simulatedDataValues[i] - actualDataValues[i])^2
  }
  MSE &lt;- SSE / dataLength
  RMSE &lt;- sqrt(MSE)
  return(RMSE)
}

dyesMCMCconfiguration &lt;- configureMCMC(dyesModel)
  
crossValOutput &lt;- runCrossValidate(MCMCconfiguration = dyesMCMCconfiguration,
                                   k = 6,
                                   foldFunction = dyesFoldFunction,
                                   lossFunction = RMSElossFunction,
                                   MCMCcontrol = list(niter = 5000,
                                                      nburnin = 500))

## End(Not run)  

</code></pre>

<hr>
<h2 id='runLaplace'>Combine steps of running Laplace or adaptive Gauss-Hermite quadrature approximation</h2><span id='topic+runLaplace'></span><span id='topic+runAGHQ'></span>

<h3>Description</h3>

<p>Use an approximation (compiled or uncompiled) returned from
'buildLaplace' or 'buildAGHQ' to find the maximum likelihood estimate and return it
with random effects estimates and/or standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runLaplace(
  laplace,
  pStart,
  originalScale = TRUE,
  randomEffectsStdError = TRUE,
  jointCovariance = FALSE
)

runAGHQ(
  AGHQ,
  pStart,
  originalScale = TRUE,
  randomEffectsStdError = TRUE,
  jointCovariance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runLaplace_+3A_laplace">laplace</code></td>
<td>
<p>A (compiled or uncompiled) nimble laplace approximation object
returned from 'buildLaplace' or 'buildAGHQ'. These return the same type of
approximation algorithm object. 'buildLaplace' is simply 'buildAGHQ'
with 'nQuad=1'.</p>
</td></tr>
<tr><td><code id="runLaplace_+3A_pstart">pStart</code></td>
<td>
<p>Initial values for parameters to begin optimization search for
the maximum likelihood estimates. If omitted, the values currently in the
(compiled or uncompiled) model object will be used.</p>
</td></tr>
<tr><td><code id="runLaplace_+3A_originalscale">originalScale</code></td>
<td>
<p>If <code>TRUE</code>, return all results on the original scale
of the parameters and/or random effects as written in the model. Otherwise,
return all results on potentially unconstrained transformed scales that are
used in the actual computations. Transformed scales (parameterizations) are
used if any parameter or random effect has contraint(s) on its support
(range of allowed values). Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="runLaplace_+3A_randomeffectsstderror">randomEffectsStdError</code></td>
<td>
<p>If <code>TRUE</code>, include standard errors for the
random effects estimates. Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="runLaplace_+3A_jointcovariance">jointCovariance</code></td>
<td>
<p>If <code>TRUE</code>, return the full joint covariance
matrix (inverse of the Hessian) of parameters and random effects. Default =
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="runLaplace_+3A_aghq">AGHQ</code></td>
<td>
<p>Same as <code>laplace</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adaptive Gauss-Hermite quadrature is a generalization of Laplace
approximation. <code>runLaplace</code> simply calles <code>runAGHQ</code> and provides a
convenient name.
</p>
<p>These functions manage the steps of calling the 'findMLE' method to obtain
the maximum likelihood estimate of the parameters and then the
'summaryLaplace' function to obtain standard errors, (optionally) random
effects estimates (conditional modes), their standard errors, and the full
parameter-random effects covariance matrix.
</p>
<p>Note that for 'nQuad &gt; 1' (see <code><a href="#topic+buildAGHQ">buildAGHQ</a></code>), i.e., AGHQ with
higher order than Laplace approximation, maximum likelihood estimation is
available only if all random effects integrations are univariate. With
multivariate random effects integrations, one can use 'nQuad &gt; 1' only to
calculate marginal log likelihoods at given parameter values. This is useful
for checking the accuracy of the log likelihood at the MLE obtained for
Laplace approximation ('nQuad == 1'). 'nQuad' can be changed using the
'updateSettings' method of the approximation object.
</p>
<p>See <code><a href="#topic+summaryLaplace">summaryLaplace</a></code>, which is called for the summary components.
</p>


<h3>Value</h3>

<p>A list with elements <code>MLE</code> and <code>summary</code>.
</p>
<p><code>MLE</code> is the result of the <code>findMLE</code> method, which contains the
parameter estimates and Hessian matrix. This is considered raw output, and
one should normally use instead the contents of <code>summary</code>. (For example
not that the Hessian matrix in <code>MLE</code> may not correspond to the same
scale as the parameter estimates if a transformation was used to operate in
an unconstrained parameter space.)
</p>
<p><code>summary</code> is the result of <code>summaryLaplace</code> (or equivalently
<code>summaryAGHQ</code>), which contains parameter estimates and standard errors,
and optionally other requested components. All results in this object will be
on the same scale (parameterization), either original or transformed, as
requested.
</p>

<hr>
<h2 id='runMCMC'>Run one or more chains of an MCMC algorithm and return samples, summary and/or WAIC</h2><span id='topic+runMCMC'></span>

<h3>Description</h3>

<p>Takes as input an MCMC algorithm (ideally a compiled one for speed)
and runs the MCMC with one or more chains, any returns any combination
of posterior samples, posterior summary statistics, and a WAIC value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runMCMC(
  mcmc,
  niter = 10000,
  nburnin = 0,
  thin,
  thin2,
  nchains = 1,
  inits,
  setSeed = FALSE,
  progressBar = getNimbleOption("MCMCprogressBar"),
  samples = TRUE,
  samplesAsCodaMCMC = FALSE,
  summary = FALSE,
  WAIC = FALSE,
  perChainWAIC = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runMCMC_+3A_mcmc">mcmc</code></td>
<td>
<p>A NIMBLE MCMC algorithm.  See details.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_niter">niter</code></td>
<td>
<p>Number of iterations to run each MCMC chain.  Default value is 10000.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_nburnin">nburnin</code></td>
<td>
<p>Number of initial, pre-thinning, MCMC iterations to discard.  Default value is 0.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for collecting MCMC samples, corresponding to <code>monitors</code>.  Thinning occurs after the initial nburnin samples are discarded. Default value is 1.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_thin2">thin2</code></td>
<td>
<p>Thinning interval for collecting MCMC samples, corresponding to the second, optional set of <code>monitors2</code>.  Thinning occurs after the initial nburnin samples are discarded. Default value is 1.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_nchains">nchains</code></td>
<td>
<p>Number of MCMC chains to run.  Default value is 1.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_inits">inits</code></td>
<td>
<p>Optional argument to specify initial values for each chain.  See details.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_setseed">setSeed</code></td>
<td>
<p>Logical or numeric argument.  If a numeric vector of length <code>nchains</code> is provided, then each element of this vector is provided as R's random number seed at the onset of the corresponding MCMC chain.  Otherwise, in the case of a logical value, if <code>TRUE</code>, then R's random number seed for the ith chain is set to be <code>i</code>, at the onset of each MCMC chain, and if <code>FALSE</code>, the random number seed is never set or modified.  The case of providing a single numeric value for this argument is not supported, except in the case when <code>nchains = 1</code>.  If the same starting seed is desired for each chain, use <code>setSeed = rep(seed, nchains)</code>.  Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_progressbar">progressBar</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, an MCMC progress bar is displayed during execution of each MCMC chain.  Default value is defined by the nimble package option MCMCprogressBar.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_samples">samples</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, then posterior samples are returned from each MCMC chain.  These samples are optionally returned as <code>coda</code> <code>mcmc</code> objects, depending on the <code>samplesAsCodaMCMC</code> argument.  Default value is <code>TRUE</code>.  See details.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_samplesascodamcmc">samplesAsCodaMCMC</code></td>
<td>
<p>Logical argument.  If <code>TRUE</code>, then a <code>coda</code> <code>mcmc</code> object is returned instead of an R matrix of samples, or when <code>nchains &gt; 1</code> a <code>coda</code> <code>mcmc.list</code> object is returned containing <code>nchains</code> <code>mcmc</code> objects.  This argument is only used when <code>samples</code> is <code>TRUE</code>.  Default value is <code>FALSE</code>.  See details.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_summary">summary</code></td>
<td>
<p>Logical argument.  When <code>TRUE</code>, summary statistics for the posterior samples of each parameter are also returned, for each MCMC chain.  This may be returned in addition to the posterior samples themselves.  Default value is <code>FALSE</code>.  See details.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_waic">WAIC</code></td>
<td>
<p>Logical argument.  When <code>TRUE</code>, the WAIC (Watanabe, 2010) of the model is calculated and returned.  Note that in order for the WAIC to be calculated, the <code>mcmc</code> object must have also been created with the argument 'enableWAIC = TRUE'.  If multiple chains are run, then a single WAIC value is calculated using the posterior samples from all chains.  Default value is <code>FALSE</code>.  See <code>help(waic)</code>.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_perchainwaic">perChainWAIC</code></td>
<td>
<p>Logical argument. When <code>TRUE</code> and multiple chains are run, the WAIC for each chain is returned as a means of helping assess the stability of the WAIC estimate. Default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of <code>samples</code>, <code>summary</code> or <code>WAIC</code> must be <code>TRUE</code>, since otherwise, nothing will be returned.  Any combination of these may be <code>TRUE</code>, including possibly all three, in which case posterior samples and summary statistics are returned for each MCMC chain, and an overall WAIC value is calculated and returned.
</p>
<p>When <code>samples = TRUE</code>, the form of the posterior samples is determined by the <code>samplesAsCodaMCMC</code> argument, as either matrices of posterior samples, or <code>coda</code> <code>mcmc</code> and <code>mcmc.list</code> objects.
</p>
<p>Posterior summary statistics are returned individually for each chain, and also as calculated from all chains combined (when <code>nchains &gt; 1</code>).
</p>
<p>If provided, the <code>inits</code> argument can be one of three things:
</p>
<p>(1) a function to generate initial values, which will be executed to generate initial values at the beginning of each MCMC chain, or
(2) a single named list of initial values which, will be used for each chain, or
(3) a list of length <code>nchains</code>, each element being a named list of initial values which be used for one MCMC chain.
</p>
<p>The <code>inits</code> argument may also be omitted, in which case the current values in the <code>model</code> object will be used as the initial values of the first chain, and subsequent chains will begin using starting values where the previous chain ended.
</p>
<p>Other aspects of the MCMC algorithm, such as the specific sampler assignments, must be specified in advance using the MCMC configuration object (created using <code>configureMCMC</code>), which is then used to build an MCMC algorithm (using <code>buildMCMC</code>) argument.
</p>
<p>The <code>niter</code> argument specifies the number of pre-thinning MCMC iterations, and the <code>nburnin</code> argument specifies the number of pre-thinning MCMC samples to discard.  After discarding these burn-in samples, thinning of the remaining samples will take place.  The total number of posterior samples returned will be floor((niter-nburnin)/thin).
</p>
<p>The MCMC option <code>mcmc$run(..., reset = FALSE)</code>, used to continue execution of an MCMC chain, is not available through <code>runMCMC()</code>.
</p>


<h3>Value</h3>

<p>A list is returned with named elements depending on the arguments passed to <code>nimbleMCMC</code>, unless this list contains only a single element, in which case only that element is returned.  These elements may include <code>samples</code>, <code>summary</code>, and <code>WAIC</code>, and when the MCMC is monitoring a second set of nodes using <code>monitors2</code>, also <code>samples2</code>.  When <code>nchains = 1</code>, posterior samples are returned as a single matrix, and summary statistics as a single matrix.  When <code>nchains &gt; 1</code>, posterior samples are returned as a list of matrices, one matrix for each chain, and summary statistics are returned as a list containing <code>nchains+1</code> matrices: one matrix corresponding to each chain, and the final element providing a summary of all chains, combined.  If <code>samplesAsCodaMCMC</code> is <code>TRUE</code>, then posterior samples are provided as <code>coda</code> <code>mcmc</code> and <code>mcmc.list</code> objects.  When <code>WAIC</code> is <code>TRUE</code>, a WAIC summary object is returned.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configureMCMC">configureMCMC</a></code> <code><a href="#topic+buildMCMC">buildMCMC</a></code> <code><a href="#topic+nimbleMCMC">nimbleMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
code &lt;- nimbleCode({
    mu ~ dnorm(0, sd = 1000)
    sigma ~ dunif(0, 1000)
    for(i in 1:10) {
        x[i] ~ dnorm(mu, sd = sigma)
    }
})
Rmodel &lt;- nimbleModel(code)
Rmodel$setData(list(x = c(2, 5, 3, 4, 1, 0, 1, 3, 5, 3)))
Rmcmc &lt;- buildMCMC(Rmodel)
Cmodel &lt;- compileNimble(Rmodel)
Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)
inits &lt;- function() list(mu = rnorm(1,0,1), sigma = runif(1,0,10))
samplesList &lt;- runMCMC(Cmcmc, niter = 10000, nchains = 3, inits = inits)

## End(Not run)

</code></pre>

<hr>
<h2 id='sampler_BASE'>MCMC Sampling Algorithms</h2><span id='topic+sampler_BASE'></span><span id='topic+sampler_prior_samples'></span><span id='topic+sampler_posterior_predictive'></span><span id='topic+sampler_binary'></span><span id='topic+sampler_categorical'></span><span id='topic+sampler_noncentered'></span><span id='topic+sampler_RW'></span><span id='topic+sampler_RW_block'></span><span id='topic+sampler_RW_llFunction'></span><span id='topic+sampler_slice'></span><span id='topic+sampler_ess'></span><span id='topic+sampler_AF_slice'></span><span id='topic+sampler_crossLevel'></span><span id='topic+sampler_RW_llFunction_block'></span><span id='topic+sampler_RW_multinomial'></span><span id='topic+sampler_RW_dirichlet'></span><span id='topic+sampler_RW_wishart'></span><span id='topic+sampler_RW_lkj_corr_cholesky'></span><span id='topic+sampler_RW_block_lkj_corr_cholesky'></span><span id='topic+sampler_CAR_normal'></span><span id='topic+sampler_CAR_proper'></span><span id='topic+sampler_polyagamma'></span><span id='topic+samplers'></span><span id='topic+sampler'></span><span id='topic+binary'></span><span id='topic+categorical'></span><span id='topic+prior_samples'></span><span id='topic+posterior_predictive'></span><span id='topic+RW'></span><span id='topic+RW_block'></span><span id='topic+RW_multinomial'></span><span id='topic+RW_dirichlet'></span><span id='topic+RW_wishart'></span><span id='topic+RW_llFunction'></span><span id='topic+slice'></span><span id='topic+AF_slice'></span><span id='topic+crossLevel'></span><span id='topic+RW_llFunction_block'></span><span id='topic+CRP'></span><span id='topic+CRP_concentration'></span><span id='topic+DPmeasure'></span><span id='topic+RJ_fixed_prior'></span><span id='topic+RJ_indicator'></span><span id='topic+RJ_toggled'></span><span id='topic+RW_PF'></span><span id='topic+RW_PF_block'></span><span id='topic+RW_lkj_corr_cholesky'></span><span id='topic+RW_block_lkj_corr_cholesky'></span><span id='topic+sampler_barker'></span><span id='topic+barker'></span><span id='topic+sampler_RJ_fixed_prior'></span><span id='topic+sampler_RJ_indicator'></span><span id='topic+sampler_RJ_toggled'></span><span id='topic+sampler_CRP_concentration'></span><span id='topic+sampler_CRP'></span><span id='topic+sampler_slice_CRP_base_param'></span>

<h3>Description</h3>

<p>Details of the MCMC sampling algorithms provided with the NIMBLE MCMC engine; HMC samplers are in the <code>nimbleHMC</code> package and particle filter samplers are in the <code>nimbleSMC</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_BASE()

sampler_prior_samples(model, mvSaved, target, control)

sampler_posterior_predictive(model, mvSaved, target, control)

sampler_binary(model, mvSaved, target, control)

sampler_categorical(model, mvSaved, target, control)

sampler_noncentered(model, mvSaved, target, control)

sampler_RW(model, mvSaved, target, control)

sampler_RW_block(model, mvSaved, target, control)

sampler_RW_llFunction(model, mvSaved, target, control)

sampler_slice(model, mvSaved, target, control)

sampler_ess(model, mvSaved, target, control)

sampler_AF_slice(model, mvSaved, target, control)

sampler_crossLevel(model, mvSaved, target, control)

sampler_RW_llFunction_block(model, mvSaved, target, control)

sampler_RW_multinomial(model, mvSaved, target, control)

sampler_RW_dirichlet(model, mvSaved, target, control)

sampler_RW_wishart(model, mvSaved, target, control)

sampler_RW_lkj_corr_cholesky(model, mvSaved, target, control)

sampler_RW_block_lkj_corr_cholesky(model, mvSaved, target, control)

sampler_CAR_normal(model, mvSaved, target, control)

sampler_CAR_proper(model, mvSaved, target, control)

sampler_polyagamma(model, mvSaved, target, control)

sampler_RJ_fixed_prior(model, mvSaved, target, control)

sampler_RJ_indicator(model, mvSaved, target, control)

sampler_RJ_toggled(model, mvSaved, target, control)

sampler_CRP_concentration(model, mvSaved, target, control)

sampler_CRP(model, mvSaved, target, control)

sampler_slice_CRP_base_param(model, mvSaved, target, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampler_BASE_+3A_model">model</code></td>
<td>
<p>(uncompiled) model on which the MCMC is to be run</p>
</td></tr>
<tr><td><code id="sampler_BASE_+3A_mvsaved">mvSaved</code></td>
<td>
<p><code>modelValues</code> object to be used to store MCMC samples</p>
</td></tr>
<tr><td><code id="sampler_BASE_+3A_target">target</code></td>
<td>
<p>node(s) on which the sampler will be used</p>
</td></tr>
<tr><td><code id="sampler_BASE_+3A_control">control</code></td>
<td>
<p>named list that controls the precise behavior of the sampler, with elements specific to <code>samplertype</code>.  The default values for control list are specified in the setup code of each sampling algorithm.  Descriptions of each sampling algorithm, and the possible customizations for each sampler (using the <code>control</code> argument) appear below.</p>
</td></tr>
</table>


<h3>Hamiltonian Monte Carlo samplers</h3>

<p>Hamiltonian Monte Carlo (HMC) samplers are provided separately in the <code>nimbleHMC</code> R package.  After loading <code>nimbleHMC</code>, see <code>help(HMC)</code> for details.
</p>


<h3>Particle filter samplers</h3>

<p>As of Version 0.10.0 of NIMBLE, the <code>RW_PF</code> and <code>RW_PF_block</code> samplers are provided separately in the 'nimbleSMC' package. After loading <code>nimbleSMC</code>, see <code>help(samplers)</code> for details.
</p>


<h3><code>sampler_base</code></h3>

<p>base class for new samplers
</p>
<p>When you write a new sampler for use in a NIMBLE MCMC (see <a href="https://r-nimble.org/html_manual/cha-welcome-nimble.html">User Manual</a>), you must include <code>contains = sampler_BASE</code>.
</p>


<h3>binary sampler</h3>

<p>The binary sampler performs Gibbs sampling for binary-valued (discrete 0/1) nodes.  This can only be used for nodes following either a <code>dbern(p)</code> or <code>dbinom(p, size=1)</code> distribution.
</p>
<p>The binary sampler accepts no control list arguments.
</p>


<h3>categorical sampler</h3>

<p>The categorical sampler performs Gibbs sampling for a single node, which generally would follow a categorical (<code>dcat</code>) distribution.  The categorical sampler can be assigned to other distributions as well, in which case the number of possible outcomes (1, 2, 3, ..., k) of the distribution must be specified using the 'length' control argument.
</p>
<p>The categorical sampler accepts the following control list elements:
</p>

<ul>
<li><p> length. A character string or a numeric argument.  When a character string, this should be the name of a parameter of the distribution of the target node being sampled.  The length of this distribution parameter (considered as a 1-dimensional vector) will be used to determine the number of possible outcomes of the target node's distribution.  When a numeric value, this value will be used as the number of possible outcomes of the target node's distribution.  (default = &quot;prob&quot;)
</p>
</li>
<li><p> check. A logical argument.  When FALSE, no check for a 'dcat' prior distribution for the target node takes place. (default = TRUE)
</p>
</li></ul>



<h3>RW sampler</h3>

<p>The RW sampler executes adaptive Metropolis-Hastings sampling with a normal proposal distribution (Metropolis, 1953), implementing the adaptation routine given in Shaby and Wells, 2011.  This sampler can be applied to any scalar continuous-valued stochastic node, and can optionally sample on a log scale.
</p>
<p>The RW sampler accepts the following control list elements:
</p>

<ul>
<li><p> log. A logical argument, specifying whether the sampler should operate on the log scale. (default = FALSE)
</p>
</li>
<li><p> reflective. A logical argument, specifying whether the normal proposal distribution should reflect to stay within the range of the target distribution. (default = FALSE)
</p>
</li>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the scale (proposal standard deviation) throughout the course of MCMC execution to achieve a theoretically desirable acceptance rate. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation.  Every adaptInterval MCMC iterations (prior to thinning), the RW sampler will perform its adaptation procedure.  This updates the scale variable, based upon the sampler's achieved acceptance rate over the past adaptInterval iterations. (default = 200)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> scale. The initial value of the normal proposal standard deviation.  If adaptive = FALSE, scale will never change. (default = 1)
</p>
</li></ul>

<p>The RW sampler cannot be used with options log=TRUE and reflective=TRUE, i.e. it cannot do reflective sampling on a log scale.
</p>
<p>After an MCMC algorithm has been configured and built, the value of the proposal standard deviation of a RW sampler can be modified using the setScale method of the sampler object.  This use the scalar argument to modify the current value of the proposal standard deviation, as well as modifying the initial (pre-adaptation) value to which the proposal standard deviation is reset, at the onset of a new MCMC chain.
</p>


<h3>RW_block sampler</h3>

<p>The RW_block sampler performs a simultaneous update of one or more model nodes, using an adaptive Metropolis-Hastings algorithm with a multivariate normal proposal distribution (Roberts and Sahu, 1997), implementing the adaptation routine given in Shaby and Wells, 2011.  This sampler may be applied to any set of continuous-valued model nodes, to any single continuous-valued multivariate model node, or to any combination thereof. <br />
</p>
<p>The RW_block sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the scale (a coefficient for the entire proposal covariance matrix) and propCov (the multivariate normal proposal covariance matrix) throughout the course of MCMC execution.  If only the scale should undergo adaptation, this argument should be specified as TRUE. (default = TRUE)
</p>
</li>
<li><p> adaptScaleOnly. A logical argument, specifying whether adaption should be done only for scale (TRUE) or also for provCov (FALSE).  This argument is only relevant when adaptive = TRUE.  When adaptScaleOnly = FALSE, both scale and propCov undergo adaptation; the sampler tunes the scaling to achieve a theoretically good acceptance rate, and the proposal covariance to mimic that of the empirical samples.  When adaptScaleOnly = TRUE, only the proposal scale is adapted. (default = FALSE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation.  Every adaptInterval MCMC iterations (prior to thinning), the RW_block sampler will perform its adaptation procedure, based on the past adaptInterval iterations. (default = 200)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> scale. The initial value of the scalar multiplier for propCov.  If adaptive = FALSE, scale will never change. (default = 1)
</p>
</li>
<li><p> propCov. The initial covariance matrix for the multivariate normal proposal distribution.  This element may be equal to the character string 'identity', in which case the identity matrix of the appropriate dimension will be used for the initial proposal covariance matrix. (default = 'identity')
</p>
</li>
<li><p> tries. The number of times this sampler will repeatedly operate on each MCMC iteration.  Each try consists of a new proposed transition and an accept/reject decision of this proposal.  Specifying tries &gt; 1 can help increase the overall sampler acceptance rate and therefore chain mixing. (default = 1)
</p>
</li></ul>

<p>After an MCMC algorithm has been configured and built, the value of the proposal standard deviation of a RW_block sampler can be modified using the setScale method of the sampler object.  This use the scalar argument to will modify the current value of the proposal standard deviation, as well as modifying the initial (pre-adaptation) value which the proposal standard deviation is reset to, at the onset of a new MCMC chain.
</p>
<p>Operating analogous to the setScale method, the RW_block sampler also has a setPropCov method.  This method accepts a single matrix-valued argument, which will modify both the current and initial (used at the onset of a new MCMC chain) values of the multivariate normal proposal covariance.
</p>
<p>Note that modifying elements of the control list may greatly affect the performance of this sampler. In particular, the sampler can take a long time to find a good proposal covariance when the elements being sampled are not on the same scale. We recommend providing an informed value for <code>propCov</code> in this case (possibly simply a diagonal matrix that approximates the relative scales), as well as possibly providing a value of <code>scale</code> that errs on the side of being too small. You may also consider decreasing <code>adaptFactorExponent</code> and/or <code>adaptInterval</code>, as doing so has greatly improved performance in some cases.
</p>


<h3>Barker proposal sampler</h3>

<p>The Barker proposal sampler implements a (multivariate) gradient-based sampling scheme, following the work of Livingstone and Zanella (2022) and Vogrinc et al. (2023). This sampler may be applied to any set of continuous-valued model nodes, to any single continuous-valued multivariate model node, or to any combination thereof. The sampler uses an gradient-based adaptive Metropolis-Hastings algorithm with a multivariate normal proposal distribution, which can use a full proposal covariance matrix (recommended for most problems) or a diagonal matrix. To use the Barker sampler, you must set <code>buildDerivs = TRUE</code> when creating your model via <code>nimbleModel</code>.
</p>
<p>The Barker sampler accepts the following control list elements:
</p>

<ul>
<li> <p><code>adaptive</code>. A logical argument, specifying whether the sampler should adapt the scalar global scale (a coefficient scaling the entire proposal covariance matrix) and (possibly) the multivariate normal proposal covariance matrix throughout the course of MCMC execution.  If only the scale should undergo adaptation, this argument should be specified as <code>TRUE</code>. (default = TRUE)
</p>
</li>
<li> <p><code>adaptScaleOnly</code>. A logical argument, specifying whether adaption should be done only for the global scale and not for the covariance matrix.  This argument is only relevant when <code>adaptive = TRUE</code>. When <code>adaptScaleOnly = TRUE</code>, only the scale is adapted, tuned to achieve a theoretically good acceptance rate (specified by <code>targetAcceptanceRate</code>). (default = FALSE)
</p>
</li>
<li> <p><code>adaptCov</code>. A logical argument, specifying whether adaption should be done for the full proposal covariance matrix (<code>TRUE</code>) or only for the diagonal of the matrix (the proposal variances) (<code>FALSE</code>). This argument is only relevant when <code>adaptive = TRUE</code> and <code>adaptScaleOnly = FALSE</code>. The full covariance matrix or diagonal values are tuned to mimic the full covariance or the variances, respectively, of the empirical samples from the posterior.
</p>
</li>
<li> <p><code>scale</code>. Initial multiplier that scales the step-size of the proposal steps. If adaptation is turned off, this determines the step-size. (default = 1)
</p>
</li>
<li> <p><code>propCov</code>. Initial value for proposal covariance. This can be the string &quot;identity&quot; (indicating the identity matrix), a single number that scales the identity matrix, a vector of values that provides the diagonal values (variances) of the matrix (of length equal to the number of parameters in the transformed space), or a full proposal covariance matrix (with number of rows and columns equal to the number of parameters in the transformed space). (default = 1)
</p>
</li>
<li> <p><code>adaptInterval</code>. The interval on which to perform adaptation of the scale (and diagonal variance values when <code>adaptCov = FALSE</code>). At the moment only the value 1 is allowed.
</p>
</li>
<li> <p><code>adaptIntervalCov</code>. The interval on which to perform adaptation of the full proposal covariance. This only has effect when <code>adaptCov = TRUE</code>. The default of 10 was chosen based on performance on various examples but other values may improve mixing in specific cases. Note that if <code>invariantWeight = FALSE</code>, changing this value also has the effect of modifying the influence of the most recent set of empirical samples relative to the current proposal covariance. (default = 10)
</p>
</li>
<li> <p><code>adaptDelayCov</code>. The number of initial iterations in which the off-diagonal elements of the proposal covariance are not adapted. In experiments, adapting the full covariance from the first iteration can produce an algorithm that performs poorly as the covariances may be adapted while the chain is still burning in, during whih the samples are not reflective of the posterior. Only relevant if <code>adaptCov = TRUE</code>. The default of 100 was chosen based on performance on various examples but other values may improve mixing in specific cases. (default = 100)
</p>
</li>
<li> <p><code>adaptFactorExponent</code>. Exponent controlling the rate of decay of the scale adaptation factor. As suggested in Livingstone and Zanella (2022), the default is 0.6.
</p>
</li>
<li> <p><code>targetAcceptanceRate</code>. Acceptance rate targeted when adapting the global scale. As suggested in Vogrinc et al. (2023) the default is 0.574, as in the MALA algorithm.
</p>
</li>
<li> <p><code>bimodal</code>. A logical argument indicating whether to use the bimodal proposal of Vogrinc et al. (2023) (<code>TRUE</code>) or simply a normal distribution (<code>FALSE</code>). (default = TRUE)
</p>
</li>
<li> <p><code>sigma</code>. The value of <code>sigma</code> in the bimodal Barker proposal suggested in Vogrinc et al. (2023). Only used if <code>bimodal = TRUE</code>. (default = 0.1)
</p>
</li>
<li> <p><code>invariantWeight</code>. A logical argument indicating whether to modify the relative weight of the most recent set of empirical samples relative to the current proposal covariance such that changing <code>adaptIntervalCov</code> has little effect on the weighting. While in principle setting this to <code>TRUE</code> makes sense, in experiments this tended to make MCMC performance worse, so the default is <code>FALSE</code>.
</p>
</li></ul>

<p>The Barker proposal provides a gradient-based Metropolis-Hastings algorithm demonstrated to be more robust to tuning parameters than other gradient-based methods, in particular the Metropolis-adjusted Langevin algorithm (MALA). The approach tends to do a better job of adjusting to heterogeneity in the scaling of the target elements and to bad (particularly overly large) initial proposal variance(s) than random walk Metropolis-Hastings (i.e., the <code>RW_block</code> sampler).
</p>
<p>For some problems without strong dependence, adapting only the diagonal of the proposal covariance (<code>adaptCov = FALSE</code>) may perform well, but for most problems, use of the full proposal covariance matrix is expected to perform better. The implementation of the proposal covariance for the Barker proposal is derived based on the use of preconditioning to transform the parameters to be approximately linearly independent. This is equivalent to and implemented as a dense proposal covariance matrix.
</p>
<p>Adaptation of the full proposal covariance matrix (i.e., of the off-diagonal elements) starting from the first iteration of the MCMC can cause poor MCMC performance by adapting the covariances based on samples in which the MCMC is burning in, which can prevent the sampler from burning in and from finding a good proposal covariance in a reasonable number of iterations. For this reason, by default the sampler only adapts the global scale and proposal variances for the first <code>adaptDelayCov</code> iterations, defaulting to 100 iterations.
</p>
<p>The Barker proposal uses the gradient of the log posterior density with respect to the parameters, using nimble's automatic differentiation (AD) system. Given this, elements of the target vector that are constrained in some fashion (either by their prior or relative to other elements, such as sampling the elements of a Dirichlet-distributed vector or the elements of a positive definite matrix) are transformed to an unconstrained space using nimble's automatic parameter transformation system. Thus the proposal covariance is with respect to this transformed space.  
</p>
<p>To use this sampler instead of 'RW_block' as the default multivariate sampler for continuous distributions, set <code>nimbleOptions(MCMCuseBarkerAsDefaultMV = TRUE)</code>
</p>
<p>After an MCMC algorithm has been configured and built, the value of the global scale of a Barker sampler can be modified using the <code>setScale method</code> of the sampler object.  This use the scalar argument to will modify the current value of the scale, as well as modifying the initial (pre-adaptation) value which the scale is reset to, at the onset of a new MCMC chain.
</p>
<p>Operating analogous to the <code>setScale</code> method, the Barker sampler also has a <code>setPropVar</code> (for when <code>adaptCov = FALSE</code>) and <code>setPropCov</code> (for when <code>adaptCov = TRUE</code>). These method accept a single vector- and matrix-valued argument, respectively, which will modify both the current and initial (used at the onset of a new MCMC chain) values of the multivariate normal proposal variances or covariance, respectively.
</p>


<h3>RW_llFunction sampler</h3>

<p>Sometimes it is useful to control the log likelihood calculations used for an MCMC updater instead of simply using the model.  For example, one could use a sampler with a log likelihood that analytically (or numerically) integrates over latent model nodes.  Or one could use a sampler with a log likelihood that comes from a stochastic approximation such as a particle filter, allowing composition of a particle MCMC (PMCMC) algorithm (Andrieu et al., 2010).  The RW_llFunction sampler handles this by using a Metropolis-Hastings algorithm with a normal proposal distribution and a user-provided log-likelihood function.  To allow compiled execution, the log-likelihood function must be provided as a specialized instance of a nimbleFunction.  The log-likelihood function may use the same model as the MCMC as a setup argument, but if so the state of the model should be unchanged during execution of the function (or you must understand the implications otherwise).
</p>
<p>The RW_llFunction sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the scale (proposal standard deviation) throughout the course of MCMC execution. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation. (default = 200)
</p>
</li>
<li><p> scale. The initial value of the normal proposal standard deviation. (default = 1)
</p>
</li>
<li><p> llFunction. A specialized nimbleFunction that accepts no arguments and returns a scalar double number.  The return value must be the total log-likelihood of all stochastic dependents of the target nodes &ndash; and, if includesTarget = TRUE, of the target node(s) themselves &ndash;  or whatever surrogate is being used for the total log-likelihood.  This is a required element with no default.
</p>
</li>
<li><p> includesTarget. Logical variable indicating whether the return value of llFunction includes the log-likelihood associated with target.  This is a required element with no default.
</p>
</li></ul>



<h3>slice sampler</h3>

<p>The slice sampler performs slice sampling of the scalar node to which it is applied (Neal, 2003).  This sampler can operate on either continuous-valued or discrete-valued scalar nodes.  The slice sampler performs a 'stepping out' procedure, in which the slice is iteratively expanded to the left or right by an amount sliceWidth.  This sampler is optionally adaptive, governed by a control list element, whereby the value of sliceWidth is adapted towards the observed absolute difference between successive samples.
</p>
<p>The slice sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler will adapt the value of sliceWidth throughout the course of MCMC execution. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation. (default = 200)
</p>
</li>
<li><p> sliceWidth. The initial value of the width of each slice, and also the width of the expansion during the iterative 'stepping out' procedure. (default = 1)
</p>
</li>
<li><p> sliceMaxSteps. The maximum number of expansions which may occur during the 'stepping out' procedure. (default = 100)
</p>
</li>
<li><p> maxContractions. The maximum number of contractions of the interval that may occur during sampling (this prevents infinite looping in unusual situations). (default = 100)
</p>
</li>
<li><p> maxContractionsWarning. A logical argument specifying whether to warn when the maximum number of contractions is reached. (default = TRUE)
</p>
</li></ul>



<h3>ess sampler</h3>

<p>The ess sampler performs elliptical slice sampling of a single node, which must follow either a univariate or multivariate normal distribution (Murray, 2010).  The algorithm is an extension of slice sampling (Neal, 2003), generalized to context of the Gaussian distribution.  An auxiliary variable is used to identify points on an ellipse (which passes through the current node value) as candidate samples, which are accepted contingent upon a likelihood evaluation at that point.  This algorithm requires no tuning parameters and therefore no period of adaptation, and may result in very efficient sampling from Gaussian distributions.
</p>
<p>The ess sampler accepts the following control list arguments.
</p>

<ul>
<li><p> maxContractions. The maximum number of contractions of the interval that may occur during sampling (this prevents infinite looping in unusual situations). (default = 100)
</p>
</li>
<li><p> maxContractionsWarning. A logical argument specifying whether to warn when the maximum number of contractions is reached. (default = TRUE)
</p>
</li></ul>



<h3>AF_slice sampler</h3>

<p>The automated factor slice sampler conducts a slice sampling algorithm on one or more model nodes.  The sampler uses the eigenvectors of the posterior covariance between these nodes as an orthogonal basis on which to perform its 'stepping Out' procedure.  The sampler is adaptive in updating both the width of the slices and the values of the eigenvectors.  The sampler can be applied to any set of continuous or discrete-valued model nodes, to any single continuous or discrete-valued multivariate model node, or to any combination thereof. 
The automated factor slice sampler accepts the following control list elements:
</p>

<ul>
<li><p> sliceWidths.  A numeric vector of initial slice widths.  The length of the vector must be equal to the sum of the lengths of all nodes being used by the automated factor slice sampler.  Defaults to a vector of 1's.
</p>
</li>
<li><p> sliceAdaptFactorMaxIter.  The number of iterations for which the factors (eigenvectors) will continue to adapt to the posterior correlation. (default = 15000)
</p>
</li>
<li><p> sliceAdaptFactorInterval.  The interval on which to perform factor adaptation. (default = 200)
</p>
</li>
<li><p> sliceAdaptWidthMaxIter.  The maximum number of iterations for which to adapt the widths for a given set of factors. (default = 512)
</p>
</li>
<li><p> sliceAdaptWidthTolerance. The tolerance for when widths no longer need to adapt, between 0 and 0.5. (default = 0.1)
</p>
</li>
<li><p> sliceMaxSteps.  The maximum number of expansions which may occur during the 'stepping out' procedure. (default = 100)
</p>
</li>
<li><p> maxContractions. The maximum number of contractions of the interval that may occur during sampling (this prevents infinite looping in unusual situations). (default = 100)
</p>
</li>
<li><p> maxContractionsWarning. A logical argument specifying whether to warn when the maximum number of contractions is reached. (default = TRUE)
</p>
</li></ul>



<h3>crossLevel sampler</h3>

<p>This sampler is constructed to perform simultaneous updates across two levels of stochastic dependence in the model structure.  This is possible when all stochastic descendents of node(s) at one level have conjugate relationships with their own stochastic descendents.  In this situation, a Metropolis-Hastings algorithm may be used, in which a multivariate normal proposal distribution is used for the higher-level nodes, and the corresponding proposals for the lower-level nodes undergo Gibbs (conjugate) sampling.  The joint proposal is either accepted or rejected for all nodes involved based upon the Metropolis-Hastings ratio. This sampler is a conjugate version of Scheme 3 in Knorr-Held and Rue (2002). It can also be seen as a Metropolis-based version of collapsed Gibbs sampling (in particular Sampler 3 of van Dyk and Park (2008)). 
</p>
<p>The requirement that all stochastic descendents of the target nodes must themselves have only conjugate descendents will be checked when the MCMC algorithm is built.  This sampler is useful when there is strong dependence across the levels of a model that causes problems with convergence or mixing.
</p>
<p>The crossLevel sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. Logical argument, specifying whether the multivariate normal proposal distribution for the target nodes should be adaptived. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation. (default = 200)
</p>
</li>
<li><p> scale. The initial value of the scalar multiplier for propCov. (default = 1)
</p>
</li>
<li><p> propCov. The initial covariance matrix for the multivariate normal proposal distribution.  This element may be equal to the character string 'identity' or any positive definite matrix of the appropriate dimensions. (default = 'identity')
</p>
</li></ul>



<h3>RW_llFunction_block sampler</h3>

<p>Sometimes it is useful to control the log likelihood calculations used for an MCMC updater instead of simply using the model.  For example, one could use a sampler with a log likelihood that analytically (or numerically) integrates over latent model nodes.  Or one could use a sampler with a log likelihood that comes from a stochastic approximation such as a particle filter, allowing composition of a particle MCMC (PMCMC) algorithm (Andrieu et al., 2010) (but see samplers listed below for NIMBLE's direct implementation of PMCMC).  The <code>RW_llFunction_block</code> sampler handles this by using a Metropolis-Hastings algorithm with a multivariate normal proposal distribution and a user-provided log-likelihood function.  To allow compiled execution, the log-likelihood function must be provided as a specialized instance of a nimbleFunction.  The log-likelihood function may use the same model as the MCMC as a setup argument, but if so the state of the model should be unchanged during execution of the function (or you must understand the implications otherwise).
</p>
<p>The RW_llFunction_block sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the proposal covariance throughout the course of MCMC execution. (default is TRUE)
</p>
</li>
<li><p> adaptScaleOnly. A logical argument, specifying whether adaption should be done only for scale (TRUE) or also for provCov (FALSE).  This argument is only relevant when adaptive = TRUE.  When adaptScaleOnly = FALSE, both scale and propCov undergo adaptation; the sampler tunes the scaling to achieve a theoretically good acceptance rate, and the proposal covariance to mimic that of the empirical samples.  When adaptScaleOnly = TRUE, only the proposal scale is adapted. (default = FALSE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation. (default = 200)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> scale. The initial value of the scalar multiplier for propCov.  If adaptive = FALSE, scale will never change. (default = 1)
</p>
</li>
<li><p> propCov. The initial covariance matrix for the multivariate normal proposal distribution.  This element may be equal to the character string 'identity', in which case the identity matrix of the appropriate dimension will be used for the initial proposal covariance matrix. (default = 'identity')
</p>
</li>
<li><p> llFunction. A specialized nimbleFunction that accepts no arguments and returns a scalar double number.  The return value must be the total log-likelihood of all stochastic dependents of the target nodes &ndash; and, if includesTarget = TRUE, of the target node(s) themselves &ndash;  or whatever surrogate is being used for the total log-likelihood.  This is a required element with no default.
</p>
</li>
<li><p> includesTarget. Logical variable indicating whether the return value of llFunction includes the log-likelihood associated with target.  This is a required element with no default.
</p>
</li></ul>



<h3>RW_multinomial sampler</h3>

<p>This sampler updates latent multinomial distributions, using Metropolis-Hastings proposals to move observations between pairs of categories.  Each proposal moves one or more observations from one category to another category, and acceptance or rejection follows standard Metropolis-Hastings theory.  The number of observations in the proposed move is randomly drawn from a discrete uniform distribution, which is bounded above by the 'maxMove' control argument.  The RW_multinomial sampler can make multiple independent attempts at transitions on each sampling iteration, which is govered by the 'tries' control argument.
</p>
<p>The <code>RW_multinomial</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> maxMove.  An integer argument, specifying the upper bound for the number of observations to propose moving, on each independent propose/accept/reject step.  The number to move is drawn from a discrete uniform distribution, with lower limit one, and upper limit given by the minimum of 'maxMove' and the number of observations in the category. The default value for 'maxMove' is 1/20 of the total number of observations comprising the target multinomial distribution (given by the 'size' parameter of the distribution).
</p>
</li>
<li><p> tries.  An integer argument, specifying the number of independent Metropolis-Hastings proposals (and subsequent acceptance or rejection) that are attempted each time the sampler operates.  For example, if 'tries' is one, then a single proposal (of moving one or more observations to a different category) will be made, and either accepted or rejected.  If tries is two, this process is repeated twice.  The default value for 'tries' scales as the cube root of the total number of observations comprising the target multinomial distribution (given by the 'size' parameter of the distribution).
</p>
</li></ul>



<h3>RW_dirichlet sampler</h3>

<p>This sampler is designed for sampling non-conjugate Dirichlet distributions.  The sampler performs a series of Metropolis-Hastings updates (on the log scale) to each component of a gamma-reparameterization of the target Dirichlet distribution.  The acceptance or rejection of these proposals follows a standard Metropolis-Hastings procedure.
</p>
<p>The <code>RW_dirichlet</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should independently adapt the scale (proposal standard deviation, on the log scale) for each componentwise Metropolis-Hasting update, to achieve a theoretically desirable acceptance rate for each. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation.  Every adaptInterval MCMC iterations (prior to thinning), the sampler will perform its adaptation procedure.  (default = 200)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> scale. The initial value of the proposal standard deviation (on the log scale) for each component of the reparameterized Dirichlet distribution.  If adaptive = FALSE, the proposal standard deviations will never change. (default = 1)
</p>
</li></ul>



<h3>RW_wishart sampler</h3>

<p>This sampler is designed for sampling non-conjugate Wishart and inverse-Wishart distributions.  More generally, it can update any symmetric positive-definite matrix (for example, scaled covariance or precision matrices).  The sampler performs block Metropolis-Hastings updates following a transformation to an unconstrained scale (Cholesky factorization of the original matrix, then taking the log of the main diagonal elements.
</p>
<p>The <code>RW_wishart</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the scale and proposal covariance for the multivariate normal Metropolis-Hasting proposals, to achieve a theoretically desirable acceptance rate for each. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation.  Every adaptInterval MCMC iterations (prior to thinning), the sampler will perform its adaptation procedure.  (default = 200)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> scale. The initial value of the scalar multiplier for the multivariate normal Metropolis-Hastings proposal covariance.  If adaptive = FALSE, scale will never change. (default = 1)
</p>
</li></ul>



<h3>RW_block_lkj_corr_cholesky sampler</h3>

<p>This sampler is designed for sampling non-conjugate LKJ correlation Cholesky factor distributions. The sampler performs a blocked Metropolis-Hastings update following a transformation to an unconstrained scale (using the signed stickbreaking approach documented in Section 10.12 of the Stan Language Reference Manual, version 2.27). 
</p>
<p>The <code>RW_block_lkj_corr_cholesky</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the scale (a coefficient for the entire proposal covariance matrix) and propCov (the multivariate normal proposal covariance matrix) throughout the course of MCMC execution.  If only the scale should undergo adaptation, this argument should be specified as TRUE. (default = TRUE)
</p>
</li>
<li><p> adaptScaleOnly. A logical argument, specifying whether adaption should be done only for scale (TRUE) or also for provCov (FALSE).  This argument is only relevant when adaptive = TRUE.  When adaptScaleOnly = FALSE, both scale and propCov undergo adaptation; the sampler tunes the scaling to achieve a theoretically good acceptance rate, and the proposal covariance to mimic that of the empirical samples.  When adaptScaleOnly = TRUE, only the proposal scale is adapted. (default = FALSE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation.  Every adaptInterval MCMC iterations (prior to thinning), the RW_block sampler will perform its adaptation procedure, based on the past adaptInterval iterations. (default = 200)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> scale. The initial value of the scalar multiplier for propCov.  If adaptive = FALSE, scale will never change. (default = 1)
</p>
</li>
<li><p> propCov. The initial covariance matrix for the multivariate normal proposal distribution.  This element may be equal to the character string 'identity', in which case the identity matrix of the appropriate dimension will be used for the initial proposal covariance matrix. (default = 'identity')
</p>
</li></ul>

<p>This is the default sampler for the LKJ distribution. However, blocked samplers may perform poorly if the adaptation configuration is poorly chosen. See the comments in the RW_block section of this documentation.
</p>


<h3>RW_lkj_corr_cholesky sampler</h3>

<p>This sampler is designed for sampling non-conjugate LKJ correlation Cholesky factor distributions. The sampler performs individual Metropolis-Hastings updates following a transformation to an unconstrained scale (using the signed stickbreaking approach documented in Section 10.12 of the Stan Language Reference Manual, version 2.27). 
</p>
<p>The <code>RW_lkj_corr_cholesky</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the scales of the univariate normal Metropolis-Hasting proposals, to achieve a theoretically desirable acceptance rate for each. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation.  Every adaptInterval MCMC iterations (prior to thinning), the sampler will perform its adaptation procedure.  (default = 200)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> scale. The initial value of the scalar multiplier for the multivariate normal Metropolis-Hastings proposal covariance.  If adaptive = FALSE, scale will never change. (default = 1)
</p>
</li></ul>

<p>Note that this sampler is likely run much more slowly than the blocked sampler for the LKJ distribution, as updating each single element will generally incur the full cost of updating all dependencies of the entire matrix.
</p>


<h3>polyagamma sampler</h3>

<p>The polyagamma sampler uses Pólya-gamma data augmentation to do conjugate sampling for the parameters in the linear predictor of a logistic regression model (Polson et al., 2013), analogous to the Albert-Chib data augmentation scheme for probit regression. This sampler is not assigned as a default sampler by <code>configureMCMC</code> and so can only be used if manually added to an MCMC configuration.
</p>
<p>As an example, consider model code containing:
</p>
<pre>for(i in 1:n) {
  logit(prob[i]) &lt;- beta0 + beta1*x1[i] + beta2*x2[i] + u[group[i]] 
  y[i] ~ dbinom(prob = prob[i], size = size[i])
}
for(j in 1:num_groups)
  u[j] ~ dnorm(0, sd = sigma_group)
</pre>
<p>where <code>beta0</code>, <code>beta1</code>, and <code>beta2</code> are fixed effects with normal priors, <code>u</code> is a random effect associated with groups of data, and <code>group[i]</code> gives the group index of the i-th observation, <code>y[i]</code>. In this model, the parameters <code>beta0</code>, <code>beta1</code>, <code>beta2</code>, and all the <code>u[j]</code> can be jointly sampled by the polyagamma sampler, i.e., they will be its target nodes.
</p>
<p>After building a model (calling <code>nimbleModel</code>) containing the above code, one would configure the sampler as follows:
</p>
<pre>MCMCconf &lt;- configureMCMC(model)
logistic_nodes &lt;- c("beta0", "beta1", "beta2", "u")
# Optionally, remove default samplers.
MCMCconf$removeSamplers(logistic_nodes) 
MCMCconf$addSampler(target = logistic_nodes, type = "polyagamma",
  control = list(fixedDesignColumns=TRUE))
</pre>
<p>As shown here, the stochastic dependencies (<code>y[i]</code> here) of the target nodes must follow <code>dbin</code> or <code>dbern</code> distributions. The logit transformation of their probability parameter must be a linear function (technically an affine function) of the target nodes, which themselves must have <code>dnorm</code> or <code>dmnorm</code> priors. Zero inflation to account for structural zeroes is also supported, allowed as discussed below. The stochastic dependencies will often but not always be the observations in the logistic regression and will be referred to as 'responses' henceforth. Internally, the sampler draws latent values from the Pólya-gamma distribution, one per response. These latent values are then used to draw from the multivariate normal conditional distribution of the target nodes.
</p>
<p>Importantly, note that because the Pólya-gamma draws are not retained when an iteration of the sampler finishes, one generally wants to apply the sampler to all parameter nodes involved in the linear predictor of the logistic regression, to avoid duplicative Pólya-gamma draws of the latent values. If there are stochastic indices (e.g., if <code>group[i]</code> above is stochastic), the Pólya-gamma sampler can still be used, but the stochastic nodes cannot be sampled by it and must have separate sampler(s). It is also possible in some models that regression parameters can be split into (conditionally independent) groups that can be sampled independently, e.g., if one has distinct logistic regression specifications for different sets of responses in the model.
</p>
<p>Sampling involves use of the design matrix. The design matrix includes one column corresponding to each regression covariate as well as one columnar block corresponding to each random effect. In the example above, the columns would include a vector of ones (to multiply <code>beta0</code>), the vectors <code>x1</code> and <code>x2</code>, and a vector of indicators for each <code>u[j]</code> (with a 1 in row <code>i</code> if <code>group[i]</code> is <code>j</code>), resulting in <code>3+num_groups</code> columns. Note that the polyagamma sampler can determine the design matrix from the model, even when written as above such that the design matrix is not explicitly in the model code. It is also possible to write model code for the linear prediction using matrix multiplication and an explicit design matrix, but that is not necessary.
</p>
<p>Often the design matrix is fixed in advance, but in some cases elements of the matrix may be stochastic and sampled during the MCMC. That would be the case if there are missing values (e.g., missing covariate values (declared as stochastic nodes)) or stochastic indexing (e.g., unknown assignment of responses to clusters, as mentioned above). Note that changes in the values of any of the <code>beta</code> or <code>u[j]</code> target nodes in the example above do not change the design matrix.
</p>
<p>Recalculating the elements of the design matrix at every iteration is costly and will likely greatly slow the sampler. To alleviate this, users can specify which columns of the design matrix are fixed (non-stochastic) using the <code>fixedDesignColumns</code> control argument. If all columns are fixed, which will often be the case, this argument can be specified simply as <code>TRUE</code>. Note that the sampler does not determine if any or all columns are fixed, so users wishing to take advantage of the large speed gains from having fixed columns should provide this control argument. Columns indicated as fixed will be determined (if necessary) when the sampler is first run and retained for subsequent iterations.
</p>
<p>By default, NIMBLE will determine the design matrix (and as discussed above will do so repeatedly at each iteration for any columns not indicated as being fixed). If the matrix has no stochastic elements, users may choose to provide the matrix directly to the sampler via the <code>designMatrix</code> control argument. This will save time in computing the matrix initially but likely will have limited benefit relative to the cost of running many iterations of MCMC and therefore can be omitted in most cases.
</p>
<p>The sampler allows for binomial responses with stochastic sizes. This would be the case in the above example if the <code>size[i]</code> values are themselves declared as unobserved stochastic nodes and thus are sampled by MCMC.
</p>
<p>The sampler allows for zero inflation of the response probability in that the probability determined by the inverse logit transformation of the linear predictor can be multipled by one or more binary scalar nodes to produce the response probability. These binary nodes must be specified via the <code>dbern</code> distribution or the <code>dbin</code> distribution with size equal to one. This functionality is intended for use in cases where another part of the model introduces structural zeroes, such as in determining occupancy in ecological occupancy models. An example would be if the above were modified by <code>y[i] ~ dbinom(prob = z[i] * p[i], size = size[i])</code>, where each <code>z[i]</code> is either 0 or 1.
</p>
<p>The polyagamma sampler accepts the following control list elements:
</p>

<ul>
<li><p> fixedDesignColumns. Either a single logical value indicating if the design matrix is fixed (non-stochastic) or a logical vector indicating which columns are fixed. In the latter case, the columns must be ordered exactly as the ordering of target node elements given by <code>model$expandNodeNames(target, returnScalarComponents = TRUE)</code>, where <code>target</code> is the same as the <code>target</code> argument to <code>configureMCMC$addSampler</code> above. (default = FALSE)
</p>
</li>
<li><p> designMatrix. The full design matrix with rows corresponding to the ordering of the responses and columns ordered exactly as the ordering of target node elements given by <code>model$expandNodeNames(target, returnScalarComponents = TRUE)</code>, where <code>target</code> is the same as the <code>target</code> argument to <code>configureMCMC$addSampler</code> above. If provided, all columns are assumed to be fixed, ignoring the <code>fixedDesignColumns</code> control element.
</p>
</li>
<li><p> nonTargetNodes. Additional stochastic nodes involved in the linear predictor that are not to be sampled as part of the sampler. This must include any nodes specifying stochastic indexes (e.g., <code>"group"</code> if the <code>group[i]</code> values are stochastic) and any parameters considered known or that for any reason one does not want to sample. Providing <code>nonTargetNodes</code> is required in order to allow NIMBLE to check for the presence of zero inflation.  
</p>
</li>
<li><p> check. A logical value indicating whether NIMBLE should check various conditions required for validity of the sampler. This is provided for rare cases where the checking may be overly conservative and a user is sure that the sampler is valid and wants to override the checking. (default = TRUE)
</p>
</li></ul>



<h3>noncentered sampler</h3>

<p>The noncentered sampler is designed to sample the mean or standard deviation of a set of centered random effects while also moving the random effects values to possibly allow better mixing. The noncentered sampler deterministically shifts or scales the dependent node values to be consistent with the proposed value of the target (the mean or the standard deviation) such that the effect is to sample in a noncentered parameterization (Yu and Meng 2011), via an on-the-fly reparameterization. This can improve mixing by updating the target node based on information in the model nodes whose parent nodes are the dependent nodes of the target (i.e,. the &quot;grandchild&quot; nodes of the target; these will often be data nodes). This comes at the extra computational cost of calculating the logProbability of the &quot;grandchild&quot; nodes.
</p>
<p>It is still necessary to have other samplers on the random effects values.
</p>
<p>Mathematically, the noncentered sampler operates in one dimension of a transformed parameter space. When sampling a mean, all random effects will be shifted by the same amount as the mean. When sampling a standard deviation, all random effects (relative to their means) will be scaled by the same factor as the standard deviation.
Consider a model that includes the following code:
</p>
<pre>for(i in 1:n)
   y[i] ~ dnorm(beta1*x[i] + u[group[i]], sd = sigma_obs)
for(j in 1:num_groups)
   u[j] ~ dnorm(beta0, sd = sigma_group)
</pre>
<p>where <code>u</code> is a random effect associated with groups of data, and <code>group[i]</code> gives the group index of the i-th observation. This model has a centered random effect, because the <code>u[j]</code> have the intercept <code>beta0</code> as their mean. In basic univariate sampling, updates to <code>beta0</code> or to <code>sigma_group</code> do not change <code>u[j]</code>, making only small moves possible if <code>num_groups</code> is large. When the noncentered sampler considers a new value for <code>beta0</code>, it will shift all the <code>u[j]</code> so that (in this case) their prior probabilities do not change. If the noncentered sampler considers a new value for <code>sigma_group</code>, it will rescale all the <code>u[j]</code> accordingly.
</p>
<p>The effect of such a sampling strategy is to update <code>beta0</code> and <code>sigma_group</code> as if the model had been written in a different (noncentered) way. For updating <code>beta0</code>, it would be:
</p>
<pre>for(i in 1:n)
   y[i] ~ dnorm(beta0 + beta1*x[i] + u[group[i]], sd = sigma_obs)
for(j in 1:num_groups)
   u[j] ~ dnorm(0, sd = sigma_group)
</pre>
<p>For updating <code>sigma_group</code>, it would be:
</p>
<pre>for(i in 1:n)
   y[i] ~ dnorm(beta1*x[i] + u[group[i]] * sigma_group, sd = sigma_obs)
for(j in 1:num_groups)
   u[j] ~ dnorm(beta0, sd = 1)
</pre>
<p>Whether centered or noncentered parameterizations result in better sampling can depend on the model and the data. Therefore Yu and Meng (2011) recommended an &quot;interweaving&quot; strategy of using both kinds of samplers. Adding the noncentered sampler (on either the mean or standard deviation or both) to an existing MCMC configuration for a model specified using the centered parameterization (and with a sampler already assigned to the target node) produces an overall sampling approach that is a variation on the interweaving strategy of Yu and Meng (2011). This provides the benefits of sampling in both the centered and noncentered parameterizations in a single MCMC. 
</p>
<p>There is a higher computational cost to the noncentered sampler (or to writing the model directly in one of the equivalent ways shown). The cost is that when updating <code>beta0</code> or <code>sigma_group</code>, the relevant log probabilities calculations will include (in this case) all the of <code>y[i]</code>, i.e. the &quot;grandchild&quot; nodes of <code>beta0</code> or <code>sigma_group</code>.
</p>
<p>The noncentered sampler is not assigned by default by <code>configureMCMC</code> but must be manually added. For example:
</p>
<pre>MCMCconf &lt;- configureMCMC(model)
MCMCconf$addSampler(target = "beta0", type = "noncentered",
  control = list(param = "location", sampler = "RW"))
MCMCconf$addSampler(target = "sigma_group", type = "noncentered",
  control = list(param = "scale", sampler = "RW"))
</pre>
<p>While the target node will generally be either the mean (location) or standard deviation (scale) of a set of other nodes (e.g., random effects), it could in theory be used in other contexts and one can choose whether the transformation is a shift or a scale operation. In a shift operation (e.g., when the sampling target is a mean), the dependent nodes are set to their previous values plus the difference between the proposed value and previous value for the target. In a scale operation (e.g., when the sampling target is the standard deviation), the dependent nodes minus their means are multiplied by the ratio of the proposed value to the previous value for the target and the previous value for the target. Whether to shift or scale is determined from the <code>param</code> element of the control list.
</p>
<p>The sampling algorithm for the target node can either be adaptive Metropolis random walk (which uses NIMBLE's <code>RW</code> sampler) or slice sampling (which uses NIMBLE's <code>slice</code> sampler), determined from the <code>sampler</code> element of the control list. In either case, the underlying sampling accounts for the Jacobian of the deterministic shifting or scaling of the dependent nodes (in the case of shifting, the Jacobian is equal to 1 and has no impact). When the target is the standard deviation of normally-distributed dependent nodes, the Jacobian cancels with the prior distribution for the dependent nodes, and the update is in effect based only on the prior for the target and the distribution of the &quot;grandchild&quot; nodes. 
</p>
<p>The <code>noncentered</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> sampler. A character string, either <code>"RW"</code> or <code>"slice"</code> specifying the type of sampler to be used for the target node. (default = <code>"RW"</code>)
</p>
</li>
<li><p> param. A character string, either <code>"location"</code> or <code>"scale"</code> specifying whether sampling is done as shifting or scaling the dependent nodes. (default = <code>"location"</code>)
</p>
</li></ul>



<h3>CAR_normal sampler</h3>

<p>The CAR_normal sampler operates uniquely on improper (intrinsic) Gaussian conditional autoregressive (CAR) nodes, those with a <code>dcar_normal</code> prior distribution.  It internally assigns one of three univariate samplers to each dimension of the target node: a posterior predictive, conjugate, or RW sampler; however these component samplers are specialized to operate on dimensions of a <code>dcar_normal</code> distribution.
</p>
<p>The CAR_normal sampler accepts the following control list elements:
</p>

<ul>
<li> <p><code>carUseConjugacy</code>. A logical argument, specifying whether to assign conjugate samplers for conjugate components of the target node. If <code>FALSE</code>, a RW sampler would be assigned instead. (default = TRUE)
</p>
</li>
<li> <p><code>adaptive</code>. A logical argument, specifying whether any component RW samplers should adapt the scale (proposal standard deviation), to achieve a theoretically desirable acceptance rate. (default = <code>TRUE</code>)
</p>
</li>
<li> <p><code>adaptInterval</code>. The interval on which to perform adaptation for any component RW samplers.  Every <code>adaptInterval</code> MCMC iterations (prior to thinning), component RW samplers will perform an adaptation procedure.  This updates the <code>scale</code> variable, based upon the sampler's achieved acceptance rate over the past <code>adaptInterval</code> iterations. (default = 200)
</p>
</li>
<li> <p><code>scale</code>. The initial value of the normal proposal standard deviation for any component RW samplers.  If <code>adaptive = FALSE</code>, <code>scale</code> will never change. (default = 1)
</p>
</li></ul>



<h3>CAR_proper sampler</h3>

<p>The CAR_proper sampler operates uniquely on proper Gaussian conditional autoregressive (CAR) nodes, those with a <code>dcar_proper</code> prior distribution.  It internally assigns one of three univariate samplers to each dimension of the target node: a posterior predictive, conjugate, or RW sampler, however these component samplers are specialized to operate on dimensions of a <code>dcar_proper</code> distribution.
</p>
<p>The CAR_proper sampler accepts the following control list elements:
</p>

<ul>
<li> <p><code>carUseConjugacy</code>. A logical argument, specifying whether to assign conjugate samplers for conjugate components of the target node. If <code>FALSE</code>, a RW sampler would be assigned instead. (default = <code>TRUE</code>)
</p>
</li>
<li> <p><code>adaptive</code>. A logical argument, specifying whether any component RW samplers should adapt the scale (proposal standard deviation), to achieve a theoretically desirable acceptance rate. (default = <code>TRUE</code>)
</p>
</li>
<li> <p><code>adaptInterval</code>. The interval on which to perform adaptation for any component RW samplers.  Every adaptInterval MCMC iterations (prior to thinning), component RW samplers will perform an adaptation procedure.  This updates the scale variable, based upon the sampler's achieved acceptance rate over the past adaptInterval iterations. (default = 200)
</p>
</li>
<li> <p><code>scale</code>. The initial value of the normal proposal standard deviation for any component RW samplers.  If <code>adaptive = FALSE</code>, <code>scale</code> will never change. (default = 1)
</p>
</li></ul>



<h3>CRP sampler</h3>

<p>The CRP sampler is designed for fitting models involving Dirichlet process mixtures. It is exclusively assigned by NIMBLE's default MCMC configuration to nodes having the Chinese Restaurant Process distribution, <code>dCRP</code>. It executes sequential sampling of each component of the node (i.e., the cluster membership of each element being clustered). Internally, either of two samplers can be assigned, depending on conjugate or non-conjugate structures within the model. For conjugate and non-conjugate model structures, updates are based on Algorithm 2 and Algorithm 8 in Neal (2000), respectively.
</p>

<ul>
<li> <p><code>checkConjugacy</code>. A logical argument, specifying whether to assign conjugate samplers if valid. (default = <code>TRUE</code>)
</p>
</li>
<li> <p><code>printTruncation</code>. A logical argument, specifying whether to print a warning when the MCMC attempts to use more clusters than the maximum number specified in the model. Only relevant where the user has specified the maximum number of clusters to be less than the number of observations. (default = <code>TRUE</code>)
</p>
</li></ul>



<h3>CRP_concentration sampler</h3>

<p>The CRP_concentration sampler is designed for Bayesian nonparametric mixture modeling. It is exclusively assigned to the concentration parameter of the Dirichlet process when the model is specified using the Chinese Restaurant Process distribution, <code>dCRP</code>. This sampler is assigned by default by NIMBLE's default MCMC configuration and can only be used when the prior for the concentration parameter is a gamma distribution. The assigned sampler is an augmented beta-gamma sampler as discussed in Section 6 in Escobar and West (1995).
</p>


<h3>prior_samples sampler</h3>

<p>The prior_samples sampler uses a provided set of numeric values (<code>samples</code>) to define the prior distribution of one or more model nodes.  One every MCMC iteration, the prior_samples sampler takes value(s) from the numeric values provided, and stores these value(s) into the target model node(s).  This allows one to define the prior distribution of model parameters empirically, using a set of numeric <code>samples</code>, presumably obtained previously using MCMC.  The <code>target</code> node may be either a single scalar node (scalar case), or a collection of model nodes.
</p>
<p>The prior_samples sampler provides two options for selection of the value to use on each MCMC iteration.  The default behaviour is to take sequential values from the <code>samples</code> vector (scalar case), or in the case of multiple dimensions, sequential rows of the <code>samples</code> matrix are used.  The alternative behaviour, by setting the control argument <code>randomDraws = TRUE</code>, will instead use random draws from the <code>samples</code> vector (scalar case), or randomly selected rows of the <code>samples</code> matrix in the multidimensional case.
</p>
<p>If the default of sequential selection of values is used, and the number of MCMC iterations exceeds the length of the <code>samples</code> vector (scalar case) or the number of rows of the <code>samples</code> matrix, then <code>samples</code> will be recycled as necessary for the number of MCMC iterations.  A message to this effect is also printed at the beginning of the MCMC chain.
</p>
<p>Logically, prior_samples samplers might want to operate first, in advance of other samplers, on every MCMC iteration.  By default, at the time of MCMC building, all prior_samples samplers are re-ordered to appear first in the list of MCMC samplers.  This behaviour can be subverted, however, by setting nimbleOptions(MCMCorderPriorSamplesSamplersFirst = FALSE).
</p>
<p>The prior_samples sampler can be assigned to non-stochastic model nodes (nodes which are not assigned a prior distribution in the model). In fact, it is recommended that nodes being assigned a prior_samples are not provided with a prior distribution in the model, and rather, that these nodes only appear on the right-hand-side of model declaration lines.  In such case that a prior_samples sampler is assigned to a nodes with a prior distribution, the prior distribution will be overridden by the sample values provided to the sampler; however, the node will still be a stochastic node for other purposes, and will contribute to the model joint-density (using the sample values provided relative to the prior distribution), will have an MCMC sampler assigned to it by default, and also may introduce potential for confusion.  In this case, a message is issued at the time of MCMC building.
</p>
<p>The prior_samples sampler accepts the following control list elements:
</p>

<ul>
<li> <p><code>samples</code>. A numeric vector or matrix.  When the <code>target</code> node is a single scalar-valued node, <code>samples</code> should be a numeric vector.  When the <code>target</code> node specifies d &gt; 2 model dimensions, <code>samples</code> should be a matrix containing d columns.  The <code>samples</code> control argument is required.
</p>
</li>
<li> <p><code>randomDraws</code>. A logical argument, specifying whether to use a random draw from <code>samples</code> on each iteration.  If <code>samples</code> is a matrix, then a randomly-selected row of the <code>samples</code> matrix is used.  When <code>FALSE</code>, sequential values (or sequential matrix rows) are used (default = <code>FALSE</code>).
</p>
</li></ul>



<h3>posterior_predictive sampler</h3>

<p>The posterior_predictive sampler operates only on posterior predictive stochastic nodes. A posterior predictive node is a node that is not itself data and has no data nodes in its entire downstream (descendant) dependency network. Note that such nodes play no role in inference for model parameters but have often been included in BUGS models to make predictions, including for posterior predictive checks. As of version 0.13.0, NIMBLE samples model parameters without conditioning on the posterior predictive nodes and samples conditionally from the posterior predictive nodes as the last step of each MCMC iteration.
</p>
<p>(Also note that NIMBLE allows posterior predictive values to be simulated independently of running MCMC, for example by writing a nimbleFunction to do so.  This means that in many cases where terminal stochastic (posterior predictive) nodes have been included in BUGS models, they are not needed when using NIMBLE.)
</p>
<p>The posterior_predictive sampler functions by simulating new values for all downstream (dependent) nodes using their conditional distributions, as well as updating the associated model probabilities.  A posterior_predictive sampler will automatically be assigned to all trailing non-data stochastic nodes in a model, or when possible, to any node at a point in the model after which all downstream (dependent) stochastic nodes are non-data.
</p>
<p>The posterior_predictive sampler accepts no control list arguments.
</p>


<h3>RJ_fixed_prior sampler</h3>

<p>This sampler proposes addition/removal for variable of interest in the framework of variable selection using reversible jump MCMC, with a specified prior probability of inclusion.  A normal proposal distribution is used to generate proposals for the addition of the variable. This is a specialized sampler used by <code>configureRJ</code> function, when the model code is written without using indicator variables. See <code>help{configureRJ}</code> for details. It is not intended for direct assignment.
</p>


<h3>RJ_indicator sampler</h3>

<p>This sampler proposes transitions of a binary indicator variable, corresponding to a variable of interest, in the framework of variable selection using reversible jump MCMC.  This is a specialized sampler used by <code>configureRJ</code> function, when the model code is written using indicator variables. See <code>help{configureRJ}</code> for details. It is not intended for direct assignment.
</p>


<h3>RJ_toggled sampler</h3>

<p>This sampler operates in the framework of variable selection using reversible jump MCMC.  Specifically, it conditionally performs updates of the target variable of interest using the originally-specified sampling configuration, when variable is &quot;in the model&quot;.  This is a specialized sampler used by <code>configureRJ</code> when adding a reversible jump MCMC . See <code>help{configureRJ}</code> for details. It is not intended for direct assignment.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>References</h3>

<p>Andrieu, C., Doucet, A., and Holenstein, R. (2010). Particle Markov Chain Monte Carlo Methods. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 72(3), 269-342.
</p>
<p>Hoffman, Matthew D., and Gelman, Andrew (2014). The No-U-Turn Sampler: Adaptively setting path lengths in Hamiltonian Monte Carlo. <em>Journal of Machine Learning Research</em>, 15(1): 1593-1623.
</p>
<p>Escobar, M. D., and West, M. (1995). Bayesian density estimation and inference using mixtures. <em>Journal of the American Statistical Association</em>, 90(430), 577-588.
</p>
<p>Knorr-Held, L. and Rue, H. (2003). On block updating in Markov random field models for disease mapping. <em>Scandinavian Journal of Statistics</em>, 29, 597-614.
</p>
<p>Livingstone, S. and Zanella G. (2022). The Barker proposal: combining robustness and efficiency in gradient-based MCMC. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 84(2): 496-523.
</p>
<p>Metropolis, N., Rosenbluth, A. W., Rosenbluth, M. N., Teller, A. H., and Teller, E. (1953). Equation of State Calculations by Fast Computing Machines. <em>The Journal of Chemical Physics</em>, 21(6), 1087-1092.
</p>
<p>Murray, I., Prescott Adams, R., and MacKay, D. J. C. (2010). Elliptical Slice Sampling. <em>arXiv e-prints</em>, arXiv:1001.0175.
</p>
<p>Neal, R. M. (2000). Markov chain sampling methods for Dirichlet process mixture models. <em>Journal of Computational and Graphical Statistics</em>, 9(2), 249-265.
</p>
<p>Neal, R. M. (2003). Slice Sampling. <em>The Annals of Statistics</em>, 31(3), 705-741.
</p>
<p>Neal, R. M. (2011). MCMC Using Hamiltonian Dynamics. <em>Handbook of Markov Chain Monte Carlo</em>, CRC Press, 2011.
</p>
<p>Pitt, M. K. and Shephard, N. (1999). Filtering via simulation: Auxiliary particle filters. <em>Journal of the American Statistical Association</em> 94(446), 590-599.
</p>
<p>Polson, N.G., Scott, J.G., and J. Windle. (2013). Bayesian inference for logistic models using Pólya-gamma latent variables. Journal of the American Statistical Association, 108(504), 1339–1349. https://doi.org/10.1080/01621459.2013.829001
</p>
<p>Roberts, G. O. and S. K. Sahu (1997). Updating Schemes, Correlation Structure, Blocking and Parameterization for the Gibbs Sampler. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 59(2), 291-317.
</p>
<p>Shaby, B. and M. Wells (2011). <em>Exploring an Adaptive Metropolis Algorithm</em>. 2011-14. Department of Statistics, Duke University.
</p>
<p>Stan Development Team (2020). <em>Stan Language Reference Manual, Version 2.22, Section 10.12</em>.
</p>
<p>Tibbits, M. M.,  Groendyke, C.,  Haran, M., and Liechty, J. C. (2014).  Automated Factor Slice Sampling.  <em>Journal of Computational and Graphical Statistics</em>, 23(2), 543-563.
</p>
<p>van Dyk, D.A. and T. Park. (2008). Partially collapsed Gibbs Samplers. <em>Journal of the American Statistical Association</em>, 103(482), 790-796.
</p>
<p>Vogrinc, J., Livingstone, S., and Zanella, G. (2023). Optimal design of the Barker proposal and other locally balanced Metropolis–Hastings algorithms. <em>Biometrika</em>,  110(3): 579-595.
</p>
<p>Yu, Y. and Meng, X. L. (2011). To center or not to center: That is not the question - An ancillarity-sufficiency interweaving strategy (ASIS) for boosting MCMC efficiency. Journal of Computational and Graphical Statistics, 20(3), 531–570. https://doi.org/10.1198/jcgs.2011.203main
</p>


<h3>See Also</h3>

<p><code><a href="#topic+configureMCMC">configureMCMC</a></code> <code><a href="#topic+addSampler">addSampler</a></code> <code><a href="#topic+buildMCMC">buildMCMC</a></code> <code><a href="#topic+runMCMC">runMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## y[1] ~ dbern() or dbinom():
# mcmcConf$addSampler(target = 'y[1]', type = 'binary')   

# mcmcConf$addSampler(target = 'a', type = 'RW',
#    control = list(log = TRUE, adaptive = FALSE, scale = 3))
# mcmcConf$addSampler(target = 'b', type = 'RW',
#    control = list(adaptive = TRUE, adaptInterval = 200))
# mcmcConf$addSampler(target = 'p', type = 'RW',
#    control = list(reflective = TRUE))

## a, b, and c all continuous-valued:
# mcmcConf$addSampler(target = c('a', 'b', 'c'), type = 'RW_block')   

# mcmcConf$addSampler(target = 'p', type = 'RW_llFunction',
#    control = list(llFunction = RllFun, includesTarget = FALSE))

# mcmcConf$addSampler(target = 'y[1]', type = 'slice',
#    control = list(adaptive = FALSE, sliceWidth = 3))
# mcmcConf$addSampler(target = 'y[2]', type = 'slice',
#    control = list(adaptive = TRUE, sliceMaxSteps = 1))

# mcmcConf$addSampler(target = 'x[1:10]', type = 'ess')   ## x[1:10] ~ dmnorm()

# mcmcConf$addSampler(target = 'p[1:5]', type = 'RW_dirichlet')   ## p[1:5] ~ ddirch()

## y[1] is a posterior predictive node:
# mcmcConf$addSampler(target = 'y[1]', type = 'posterior_predictive')   

</code></pre>

<hr>
<h2 id='setAndCalculate'>Creates a nimbleFunction for setting the values of one or more model nodes,
calculating the associated deterministic dependents and logProb values,
and returning the total sum log-probability.</h2><span id='topic+setAndCalculate'></span><span id='topic+setAndCalculateDiff'></span>

<h3>Description</h3>

<p>This nimbleFunction generator must be specialized to any model object and one or more model nodes.
A specialized instance of this nimbleFunction will set the values of the target nodes in the specified model,
calculate the associated logProbs, calculate the values of any deterministic dependents,
calculate the logProbs of any stochastic dependents,
and return the sum log-probability associated with the target nodes and all stochastic dependent nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAndCalculate(model, targetNodes)

setAndCalculateDiff(model, targetNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setAndCalculate_+3A_model">model</code></td>
<td>
<p>An uncompiled or compiled NIMBLE model.  This argument is required.</p>
</td></tr>
<tr><td><code id="setAndCalculate_+3A_targetnodes">targetNodes</code></td>
<td>
<p>A character vector containing the names of one or more nodes or variables in the model.  This argument is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling <code>setAndCalculate(model, targetNodes)</code> or <code>setAndCalculate(model, targetNodes)</code> will return a nimbleFunction object whose <code>run</code> function takes a single, required argument:
</p>
<p>targetValues: A vector of numeric values which will be put into the target nodes in the specified model object.  The length of this numeric vector much exactly match the number of target nodes.
</p>
<p>The difference between <code>setAndCalculate</code> and <code>setAndCalculateDiff</code> is the return value of their <code>run</code> functions.  In the former, <code>run</code> returns the sum of the log probabilities of the <code>targetNodes</code> with the provided <code>targetValues</code>, while the latter returns the difference between that sum with the new <code>targetValues</code> and the previous values in the <code>model</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({ for(i in 1:3) { x[i] ~ dnorm(0,1); y[i] ~ dnorm(0, 1)}})
Rmodel &lt;- nimbleModel(code)
my_setAndCalc &lt;- setAndCalculate(Rmodel, c('x[1]', 'x[2]', 'y[1]', 'y[2]'))
lp &lt;- my_setAndCalc$run(c(1.2, 1.4, 7.6, 8.9))
</code></pre>

<hr>
<h2 id='setAndCalculateOne'>Creates a nimbleFunction for setting the value of a scalar model node,
calculating the associated deterministic dependents and logProb values,
and returning the total sum log-probability.</h2><span id='topic+setAndCalculateOne'></span>

<h3>Description</h3>

<p>This nimbleFunction generator must be specialized to any model object and any scalar model node.
A specialized instance of this nimbleFunction will set the value of the target node in the specified model,
calculate the associated logProb, calculate the values of any deterministic dependents,
calculate the logProbs of any stochastic dependents,
and return the sum log-probability associated with the target node and all stochastic dependent nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAndCalculateOne(model, targetNode)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setAndCalculateOne_+3A_model">model</code></td>
<td>
<p>An uncompiled or compiled NIMBLE model.  This argument is required.</p>
</td></tr>
<tr><td><code id="setAndCalculateOne_+3A_targetnode">targetNode</code></td>
<td>
<p>The character name of any scalar node in the model object.  This argument is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling setAndCalculateOne(model, targetNode) will return a function with a single, required argument:
</p>
<p>targetValue: The numeric value which will be put into the target node, in the specified model object.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({ for(i in 1:3) x[i] ~ dnorm(0, 1) })
Rmodel &lt;- nimbleModel(code)
my_setAndCalc &lt;- setAndCalculateOne(Rmodel, 'x[1]')
lp &lt;- my_setAndCalc$run(2)
</code></pre>

<hr>
<h2 id='setSize'>set the size of a numeric variable in NIMBLE</h2><span id='topic+setSize'></span>

<h3>Description</h3>

<p>set the size of a numeric variable in NIMBLE.  This works in R and NIMBLE, but in R it usually has no effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSize(numObj, ..., copy = TRUE, fillZeros = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setSize_+3A_numobj">numObj</code></td>
<td>
<p>This is the object to be resized</p>
</td></tr>
<tr><td><code id="setSize_+3A_...">...</code></td>
<td>
<p>sizes, provided as scalars, in order, or as a single vector</p>
</td></tr>
<tr><td><code id="setSize_+3A_copy">copy</code></td>
<td>
<p>logical indicating whether values should be preserved (in column-major order)</p>
</td></tr>
<tr><td><code id="setSize_+3A_fillzeros">fillZeros</code></td>
<td>
<p>logical indicating whether newly allocated space should be initialized with zeros (in compiled code)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that assigning the result of <code>numeric</code>, <code>integer</code>, <code>logical</code>, <code>matrix</code>, or <code>array</code> is often as good or better than using <code>setSize</code>.  For example, 'x &lt;- matrix(nrow = 5, ncol = 5)' is equivalent to 'setSize(x, 5, 5)' but the former allows more control over initialization.
</p>
<p>This function is part of the NIMBLE language.  Its purpose is to explicitly resize a multivariate object (vector, matrix or array), currently up to 4 dimensions.  Explicit resizing is not needed when an entire object is assigned to.  For example, in <code>Y &lt;- A %*% B</code>, where A and B are matrices, <code>Y</code> will be resized automatically.  Explicit resizing is necessary when assignment will be by indexed elements or blocks, if the object is not already an appropriate size for the assignment.  E.g. prior to <code>Y[5:10] &lt;- A %*% B</code>, one can use setSize to ensure that <code>Y</code> has a size (length) of at least 10.
</p>
<p>This does work in uncompiled (R) and well as compiled execution, but in some cases it is only necessary for compiled execution. During uncompiled execution, it may not catch bugs due to resizing because some R objects will be dynamically resized during assignments anyway.
</p>
<p>If preserving values in the resized object and/or initializing new values with 0 is not necessary, then setting these arguments to FALSE will yield slightly more efficient compiled code.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='setupMargNodes'>Organize model nodes for marginalization</h2><span id='topic+setupMargNodes'></span>

<h3>Description</h3>

<p>Process model to organize nodes for marginalization (integration over latent 
nodes or random effects) as by Laplace approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupMargNodes(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  calcNodesOther,
  split = TRUE,
  check = TRUE,
  allowDiscreteLatent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupMargNodes_+3A_model">model</code></td>
<td>
<p>A nimble model such as returned by <code>nimbleModel</code>.</p>
</td></tr>
<tr><td><code id="setupMargNodes_+3A_paramnodes">paramNodes</code></td>
<td>
<p>A character vector of names of stochastic nodes that are
parameters of nodes to be marginalized over (<code>randomEffectsNodes</code>).
See details for default.</p>
</td></tr>
<tr><td><code id="setupMargNodes_+3A_randomeffectsnodes">randomEffectsNodes</code></td>
<td>
<p>A character vector of nodes to be marginalized over
(or &quot;integrated out&quot;). In the case of calculating the likelihood of a model
with continuous random effects, the nodes to be marginalized over are the
random effects, hence the name of this argument. However, one can
marginalize over any nodes desired as long as they are continuous. 
See details for default.</p>
</td></tr>
<tr><td><code id="setupMargNodes_+3A_calcnodes">calcNodes</code></td>
<td>
<p>A character vector of nodes to be calculated as the
integrand for marginalization. Typically this will include
<code>randomEffectsNodes</code> and some data nodes. Se details for default.</p>
</td></tr>
<tr><td><code id="setupMargNodes_+3A_calcnodesother">calcNodesOther</code></td>
<td>
<p>A character vector of nodes to be calculated as part of
the log likelihood that are not connected to the <code>randomEffectNodes</code>
and so are not actually part of the marginalization. These are somewhat
extraneous to the purpose of this function, but it is convenient to handle
them here because often the purpose of marginalization is to calculate log
likelihoods, including from &quot;other&quot; parts of the model.</p>
</td></tr>
<tr><td><code id="setupMargNodes_+3A_split">split</code></td>
<td>
<p>A logical indicating whether to split <code>randomEffectsNodes</code>
into conditionally independent sets that can be marginalized separately
(<code>TRUE</code>) or to keep them all in one set for a single marginalization
calculation.</p>
</td></tr>
<tr><td><code id="setupMargNodes_+3A_check">check</code></td>
<td>
<p>A logical indicating whether to try to give reasonable warnings
of badly formed inputs that might be missing important nodes or include
unnecessary nodes.</p>
</td></tr>
<tr><td><code id="setupMargNodes_+3A_allowdiscretelatent">allowDiscreteLatent</code></td>
<td>
<p>A logical indicating whether to
allow discrete latent states. (default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code>buildLaplace</code> to organize model nodes into
roles needed for setting up the (approximate) marginalization done by Laplace
approximation. It is also possible to call this function directly and pass
the resulting list (possibly modified for your needs) to <code>buildLaplace</code>.
</p>
<p>Any of the input node vectors, when provided, will be processed using
<code>nodes &lt;- model$expandNodeNames(nodes)</code>, where <code>nodes</code> may be
<code>paramNodes</code>, <code>randomEffectsNodes</code>, and so on. This step allows
any of the inputs to include node-name-like syntax that might contain
multiple nodes. For example, <code>paramNodes = 'beta[1:10]'</code> can be
provided if there are actually 10 scalar parameters, 'beta[1]' through
'beta[10]'. The actual node names in the model will be determined by the
<code>exapndNodeNames</code> step.
</p>
<p>This function does not do any of the marginalization calculations. It only
organizes nodes into roles of parameters, random effects, integrand
calculations, and other log likelihood calculations.
</p>
<p>The checking done if &lsquo;check=TRUE' tries to be reasonable, but it can&rsquo;t cover
all cases perfectly. If it gives an unnecessary warning, simply set 'check=FALSE'.
</p>
<p>If <code>paramNodes</code> is not provided, its default depends on what other
arguments were provided. If neither <code>randomEffectsNodes</code> nor
<code>calcNodes</code> were provided, <code>paramNodes</code> defaults to all
top-level, stochastic nodes, excluding any posterior predictive nodes
(those with no data anywhere downstream). These are determined by
<code>model$getNodeNames(topOnly = TRUE, stochOnly = TRUE,
  includePredictive = FALSE)</code>. If <code>randomEffectsNodes</code> was provided,
<code>paramNodes</code> defaults to stochastic parents of
<code>randomEffectsNodes</code>. In these cases, any provided <code>calcNodes</code> or
<code>calcNodesOther</code> are excluded from default <code>paramNodes</code>. If
<code>calcNodes</code> but not <code>randomEffectsNodes</code> was provided, then the
default for <code>randomEffectsNodes</code> is determined first, and then
<code>paramNodes</code> defaults to stochastic parents of
<code>randomEffectsNodes</code>. Finally, any stochastic parents of
<code>calcNodes</code> (whether provided or default) that are not in
<code>calcNodes</code> are added to the default for <code>paramNodes</code>, but only
after <code>paramNodes</code> has been used to determine the defaults for
<code>randomEffectsNodes</code>, if necessary.
</p>
<p>Note that to obtain sensible defaults, some nodes must have been marked as
data, either by the <code>data</code> argument in <code>nimbleModel</code> or by
<code>model$setData</code>. Otherwise, all nodes will appear to be posterior
predictive nodes, and the default <code>paramNodes</code> may be empty.
</p>
<p>For purposes of <code>buildLaplace</code>, <code>paramNodes</code> does not need to (but
may) include deterministic nodes between the parameters and any
<code>calcNodes</code>. Such deterministic nodes will be included in
calculations automatically when needed.
</p>
<p>If <code>randomEffectsNodes</code> is missing, the default is a bit complicated: it
includes all latent nodes that are descendants (or &quot;downstream&quot;) of
<code>paramNodes</code> (if provided) and are either (i) ancestors (or
&quot;upstream&quot;) of data nodes (if <code>calcNodes</code> is missing), or (ii)
ancestors or elements of <code>calcNodes</code> (if <code>calcNodes</code> and
<code>paramNodes</code> are provided), or (iii) elements of <code>calcNodes</code> (if
<code>calcNodes</code> is provided but <code>paramNodes</code> is missing). In all
cases, discrete nodes (with warning if <code>check=TRUE</code>), posterior
predictive nodes and <code>paramNodes</code> are excluded.
</p>
<p><code>randomEffectsNodes</code> should only include stochastic nodes.
</p>
<p>If <code>calcNodes</code> is missing, the default is <code>randomEffectsNodes</code> and
their descendants to the next stochastic nodes, excluding posterior
predictive nodes. These are determined by
<code>model$getDependencies(randomEffectsNodes, includePredictive=FALSE)</code>.
</p>
<p>If <code>calcNodesOther</code> is missing, the default is all stochastic
descendants of <code>paramNodes</code>, excluding posterior predictive nodes
(from <code>model$getDependencies(paramNodes, stochOnly=TRUE, self=FALSE,
  includePosterior=FALSE)</code>) that are not part of <code>calcNodes</code>.
</p>
<p>For purposes of <code>buildLaplace</code>, neither <code>calcNodes</code> nor
<code>calcNodesOther</code> needs to (but may) contain deterministic nodes
between <code>paramNodes</code> and <code>calcNodes</code> or <code>calcNodesOther</code>,
respectively. These will be included in calculations automatically when
needed.
</p>
<p>If <code>split</code> is <code>TRUE</code>, <code>model$getConditionallyIndependentSets</code>
is used to determine sets of the <code>randomEffectsNodes</code> that can be
independently marginalized. The <code>givenNodes</code> are the
<code>paramNodes</code> and <code>calcNodes</code> excluding any
<code>randomEffectsNodes</code> and their deterministic descendants. The
<code>nodes</code> (to be split into sets) are the <code>randomEffectsNodes</code>.
</p>
<p>If <code>split</code> is a numeric vector, <code>randomEffectsNodes</code> will be split
by <code>split</code>(<code>randomEffectsNodes</code>, <code>control$split</code>). The last
option allows arbitrary control over how <code>randomEffectsNodes</code> are
blocked.
</p>
<p>If <code>check=TRUE</code>, then defaults for each of the four categories of nodes
are created even if the corresponding argument was provided. Then warnings
are emitted if there are any extra (potentially unnecessary) nodes provided
compared to the default or if there are any nodes in the default that were
not provided (potentially necessary). These checks are not perfect and may
be simply turned off if you are confident in your inputs.
</p>
<p>(If <code>randomEffectsNodes</code> was provided but <code>calcNodes</code> was not
provided, the default (for purposes of <code>check=TRUE</code> only) for
<code>randomEffectsNodes</code> differs from the above description. It uses
stochastic descendants of <code>randomEffectsNodes</code> in place of the
&quot;data nodes&quot; when determining ancestors of data nodes. And it uses item
(ii) instead of (iii) in the list above.)
</p>


<h3>Value</h3>

<p>A list is returned with elements:
</p>

<ul>
<li> <p><code>paramNodes</code>: final processed version of <code>paramNodes</code>
</p>
</li>
<li> <p><code>randomEffectsNodes</code>: final processed version of <code>randomEffectsNodes</code>
</p>
</li>
<li> <p><code>calcNodes</code>: final processed version of <code>calcNodes</code>
</p>
</li>
<li> <p><code>calcNodesOther</code>: final processed version of <code>calcNodesOther</code>
</p>
</li>
<li> <p><code>givenNodes</code>: Input to <code>model$getConditionallyIndependentSets</code>, if <code>split=TRUE</code>.
</p>
</li>
<li> <p><code>randomEffectsSets</code>: Output from
<code>model$getConditionallyIndependentSets</code>, if <code>split=TRUE</code>. This
will be a list of vectors of node names. The node names in one list element
can be marginalized independently from those in other list elements. The
union of the list elements should be all of <code>randomEffectsNodes</code>. If
<code>split=FALSE</code>, <code>randomEffectsSets</code> will be a list with one
element, simply containing <code>randomEffectsNodes</code>. If <code>split</code> is a
numeric vector,  <code>randomEffectsSets</code> will be the result of
<code>split</code>(<code>randomEffectsNodes</code>, <code>control$split</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Wei Zhang, Perry de Valpine, Paul van Dam-Bates
</p>

<hr>
<h2 id='setupOutputs'>Explicitly declare objects created in setup code to be preserved and compiled as member data</h2><span id='topic+setupOutputs'></span>

<h3>Description</h3>

<p>Normally a nimbleFunction determines what objects from setup code need to be preserved for run code or other member functions.  <code>setupOutputs</code> allows explicit declaration for cases when an object created in setup code is not used in member functions.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupOutputs_+3A_...">...</code></td>
<td>
<p>An arbitrary set of names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normally any object created in <code>setup</code> whose name appears in <code>run</code> or another member function is included in the saved results of setup code.  When the nimbleFunction is compiled, such objects will become member data of the resulting C++ class.  If it is desired to force an object to become member data even if it does not appear in a member function, declare it using <code>setupOutputs</code>.  E.g., <code>setupOutputs(a, b)</code> declares that <code>a</code> and <code>b</code> should be preserved.
</p>
<p>The <code>setupOutputs</code> line will be removed from the setup code.  It is really a marker during nimbleFunction creation of what should be preserved.
</p>

<hr>
<h2 id='simNodes'>Basic nimbleFunctions for calculate, simulate, and getLogProb with a set of nodes</h2><span id='topic+simNodes'></span><span id='topic+calcNodes'></span><span id='topic+getLogProbNodes'></span>

<h3>Description</h3>

<p>simulate, calculate, or get existing log probabilities for the current values in a NIMBLE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNodes(model, nodes)

calcNodes(model, nodes)

getLogProbNodes(model, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simNodes_+3A_model">model</code></td>
<td>
<p>A NIMBLE model</p>
</td></tr>
<tr><td><code id="simNodes_+3A_nodes">nodes</code></td>
<td>
<p>A set of nodes. If none are provided, default is all <code>model$getNodeNames()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are basic nimbleFunctions that take a model and set of nodes and return a function that will call <code>calculate</code>, <code>simulate</code>, or <code>getLogProb</code> on those nodes.  Each is equivalent to a direct call from R, but in nimbleFunction form they can be be compiled.  For example, <code>myCalc &lt;- calcNodes(model, nodes); ans &lt;- myCalc()</code> is equivalent to <code>ans &lt;- model$calculate(nodes)</code>, but one can also do <code>CmyCalc &lt;- compileNimble(myCalc)</code> to get a faster version. Note that this will often be much faster than using 'calculate' from R with a compiled model, such as <code>compiled_model$calculate(nodes)</code> because of overhead in running 'calculate' from R.
</p>
<p>In nimbleFunctions, one would generally use <code>model$calculate(nodes)</code> in the run-time code (and similarly for 'simulate' and 'getLogProb').
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>

<hr>
<h2 id='simNodesMV'>Basic nimbleFunctions for using a NIMBLE model with sets of stored values</h2><span id='topic+simNodesMV'></span><span id='topic+calcNodesMV'></span><span id='topic+getLogProbNodesMV'></span>

<h3>Description</h3>

<p>simulate, calculate, or get the existing log probabilities for values in a modelValues object using a NIMBLE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNodesMV(model, mv, nodes)

calcNodesMV(model, mv, nodes)

getLogProbNodesMV(model, mv, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simNodesMV_+3A_model">model</code></td>
<td>
<p>A nimble model.</p>
</td></tr>
<tr><td><code id="simNodesMV_+3A_mv">mv</code></td>
<td>
<p>A modelValues object in which multiple sets of model variables and their corresponding logProb values are or will be saved. <code>mv</code> must include the nodes provided</p>
</td></tr>
<tr><td><code id="simNodesMV_+3A_nodes">nodes</code></td>
<td>
<p>A set of nodes. If none are provided, default is all <code>model$getNodeNames()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simNodesMV</code> simulates values in the given nodes and saves them in <code>mv</code>. <code>calcNodesMV</code> calculates these nodes for each row of <code>mv</code> and returns a vector of the total log probabilities (densities) for each row. <code>getLogProbNodesMV</code> is like <code>calcNodesMV</code> without actually doing the calculations.
</p>
<p>Each of these will expand variables or index blocks and topologically sort them so that each node's parent nodes are processed before itself.
</p>
<p><code>getLogProbMV</code> should be used carefully.  It is generally for situations where the logProb values are guaranteed to have already been calculated, and all that is needed is to query them.  The risk is that a program may have changed the values in the nodes, in which case <code>getLogProbMV</code> would collect logProb values that are out of date with the node values.
</p>


<h3>Value</h3>

<p>from <code>simNodesMV</code>: NULL.  from <code>calcNodesMV</code> and <code>getLogProbMV</code>: a vector of the sum of log probabilities (densities) from any stochastic nodes in <code>nodes</code>.
</p>


<h3>Run time arguments</h3>


<ul>
<li> <p><code>m</code>. (<code>simNodesMV</code> only). Number of simulations requested.
</p>
</li>
<li> <p><code>saveLP</code>. (<code>calcNodesMV</code>only). Whether to save the logProb values in <code>mv</code>.  Should be given as <code>TRUE</code> unless there is a good reason not to.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
for(i in 1:5)
x[i] ~ dnorm(0,1)
})

myModel &lt;- nimbleModel(code)
myMV &lt;- modelValues(myModel)

Rsim &lt;- simNodesMV(myModel, myMV)
Rcalc &lt;- calcNodesMV(myModel, myMV)
Rglp &lt;- getLogProbNodesMV(myModel, myMV)
## Not run: 
  cModel &lt;- compileNimble(myModel)
  Csim &lt;- compileNimble(Rsim, project = myModel)
  Ccalc &lt;- compileNimble(Rcalc, project = myModel)
  Cglp &lt;- compileNimble(Rglp, project = myModel)
  Csim$run(10)
  Ccalc$run(saveLP = TRUE)
  Cglp$run()	#Gives identical answers to Ccalc because logProbs were saved
  Csim$run(10)
  Ccalc$run(saveLP = FALSE)
  Cglp$run()	  #Gives wrong answers because logProbs were not saved
  result &lt;- as.matrix(Csim$mv)

## End(Not run)
</code></pre>

<hr>
<h2 id='singleVarAccessClass-class'>Class <code>singleVarAccessClass</code></h2><span id='topic+singleVarAccessClass-class'></span><span id='topic+singleVarAccessClass'></span>

<h3>Description</h3>

<p>Classes used internally in NIMBLE and not expected to be called directly by users.
</p>

<hr>
<h2 id='StickBreakingFunction'>The Stick Breaking Function</h2><span id='topic+StickBreakingFunction'></span><span id='topic+stickbreaking'></span><span id='topic+stick_breaking'></span>

<h3>Description</h3>

<p>Computes probabilities based on stick breaking construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stick_breaking(z, log = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StickBreakingFunction_+3A_z">z</code></td>
<td>
<p>vector argument.</p>
</td></tr>
<tr><td><code id="StickBreakingFunction_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, weights are returned on the log scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stick breaking function produces a vector of probabilities that add up to one,
based on a series of individual probabilities in <code>z</code>, which define the breaking
points relative to the remaining stick length. The first element of <code>z</code> determines
the first probability based on breaking a proportion <code>z[1]</code> from a stick of length one.
The second element of <code>z</code> determines the second probability based on breaking a
proportion <code>z[2]</code> from the remaining stick (of length <code>1-z[1]</code>), and so forth.
Each element of <code>z</code> should be in 
<code class="reqn">(0,1)</code>.
The returned vector has length equal to the length of <code>z</code> plus 1. 
If <code>z[k]</code> is equal to 1 for any <code>k</code>, then the returned vector has length smaller than <code>z</code>. 
If one of the components is smaller than 0 or greater than 1, <code>NaN</code>s are returned.
</p>


<h3>Author(s)</h3>

<p>Claudia Wehrhahn
</p>


<h3>References</h3>

<p>Sethuraman, J. (1994). A constructive definition of Dirichlet priors.
<em>Statistica Sinica</em>, 639-650.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- rbeta(5, 1, 1)
stick_breaking(z)

## Not run: 
cstick_breaking &lt;- compileNimble(stick_breaking)
cstick_breaking(z)

## End(Not run)
</code></pre>

<hr>
<h2 id='summaryLaplace'>Summarize results from Laplace or adaptive Gauss-Hermite quadrature approximation</h2><span id='topic+summaryLaplace'></span><span id='topic+summaryAGHQ'></span>

<h3>Description</h3>

<p>Process the results of the 'findMLE' method of a nimble Laplace or AGHQ approximation
into a more useful format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryLaplace(
  laplace,
  MLEoutput,
  originalScale = TRUE,
  randomEffectsStdError = TRUE,
  jointCovariance = FALSE
)

summaryAGHQ(
  AGHQ,
  MLEoutput,
  originalScale = TRUE,
  randomEffectsStdError = TRUE,
  jointCovariance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryLaplace_+3A_laplace">laplace</code></td>
<td>
<p>The Laplace approximation object, typically the compiled one.
This would be the result of compiling an object returned from
'buildLaplace'.</p>
</td></tr>
<tr><td><code id="summaryLaplace_+3A_mleoutput">MLEoutput</code></td>
<td>
<p>The maximum likelihood estimate using Laplace or AGHQ,
returned from e.g. 'approx$findMLE(...)', where <code>approx</code> is the
algorithm object returned by 'buildLaplace' or 'buildAGHQ', or (more
typically) the result of compiling that object with 'compileNimble'. See
'help(buildLaplace)' for more information.</p>
</td></tr>
<tr><td><code id="summaryLaplace_+3A_originalscale">originalScale</code></td>
<td>
<p>Should results be returned using the original
parameterization in the model code (TRUE) or the potentially transformed
parameterization used internally by the Laplace approximation (FALSE).
Transformations are used for any parameters and/or random effects that have
constrained ranges of valid values, so that in the transformed parameter
space there are no constraints. (default = TRUE)</p>
</td></tr>
<tr><td><code id="summaryLaplace_+3A_randomeffectsstderror">randomEffectsStdError</code></td>
<td>
<p>If TRUE, calculate the standard error of the
estimates of random effects values. (default = TRUE)</p>
</td></tr>
<tr><td><code id="summaryLaplace_+3A_jointcovariance">jointCovariance</code></td>
<td>
<p>If TRUE, calculate the joint covariance matrix of
the parameters and random effects together. If FALSE, calculate the 
covariance matrix of the parameters. (default = FALSE)</p>
</td></tr>
<tr><td><code id="summaryLaplace_+3A_aghq">AGHQ</code></td>
<td>
<p>Same as <code>laplace</code>. Note that 'buildLaplace' and
'buildAGHQ' create the same kind of algorithm object that can be used
interchangeably. 'buildLaplace' simply sets the number of quadrature points
('nQuad') to 1 to achieve Laplace approximation as a special case of AGHQ.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numbers obtained by this function can be obtained more directly by
'approx$summary(...)'. The added benefit of 'summaryLaplace' is to arrange
the results into data frames (for parameters and random effects), with row
names for the model nodes, and also adding row and column names to the
covariance matrix.
</p>


<h3>Value</h3>

<p>A list with data frames 'params' and 'randomEffects', each with columns for
'estimate' and (possibly) 'se' (standard error) and row names for model
nodes, a matrix 'vcov' with the covariance matrix with row and column names,
and 'originalScale' with the input value of 'originalScale' so it is recorded
for later use if wanted.
</p>

<hr>
<h2 id='svdNimbleList'>svdNimbleList definition</h2><span id='topic+svdNimbleList'></span>

<h3>Description</h3>

<p><code>nimbleList</code> definition for the type of <code>nimbleList</code> returned by <code><a href="#topic+nimSvd">nimSvd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdNimbleList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nimSvd">nimSvd</a></code>
</p>

<hr>
<h2 id='t'>The t Distribution</h2><span id='topic+t'></span><span id='topic+dt_nonstandard'></span><span id='topic+rt_nonstandard'></span><span id='topic+pt_nonstandard'></span><span id='topic+qt_nonstandard'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the t distribution with <code>df</code> degrees of freedom,
allowing non-zero location, <code>mu</code>,
and non-unit scale, <code>sigma</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_nonstandard(x, df = 1, mu = 0, sigma = 1, log = FALSE)

rt_nonstandard(n, df = 1, mu = 0, sigma = 1)

pt_nonstandard(q, df = 1, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qt_nonstandard(p, df = 1, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="t_+3A_df">df</code></td>
<td>
<p>vector of degrees of freedom values.</p>
</td></tr>
<tr><td><code id="t_+3A_mu">mu</code></td>
<td>
<p>vector of location values.</p>
</td></tr>
<tr><td><code id="t_+3A_sigma">sigma</code></td>
<td>
<p>vector of scale values.</p>
</td></tr>
<tr><td><code id="t_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="t_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="t_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="t_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default) probabilities are <code class="reqn">P[X \le x]</code>; otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="t_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given by user as log(p).</p>
</td></tr>
<tr><td><code id="t_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A or the BUGS manual for mathematical details.
</p>


<h3>Value</h3>

<p><code>dt_nonstandard</code> gives the density, <code>pt_nonstandard</code> gives the distribution
function, <code>qt_nonstandard</code> gives the quantile function, and <code>rt_nonstandard</code>
generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rt_nonstandard(50, df = 1, mu = 5, sigma = 1)
dt_nonstandard(x, 3, 5, 1)
</code></pre>

<hr>
<h2 id='testBUGSmodel'>Tests BUGS examples in the NIMBLE system</h2><span id='topic+testBUGSmodel'></span>

<h3>Description</h3>

<p><code>testBUGSmodel</code> builds a BUGS model in the NIMBLE system and simulates from the model, comparing the values of the nodes and their log probabilities in the uncompiled and compiled versions of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testBUGSmodel(
  example = NULL,
  dir = NULL,
  model = NULL,
  data = NULL,
  inits = NULL,
  useInits = TRUE,
  expectModelWarning = FALSE,
  debug = FALSE,
  verbose = nimbleOptions("verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testBUGSmodel_+3A_example">example</code></td>
<td>
<p>(optional) example character vector indicating name of BUGS example to test; can be null if <code>model</code> is provided</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_dir">dir</code></td>
<td>
<p>(optional) character vector indicating directory in which files are contained, by default the classic-bugs directory if the installed package is used; to use the current working directory, set this to &quot;&quot;</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_model">model</code></td>
<td>
<p>(optional) one of (1) a character string giving the file name containing the BUGS model code, (2) an R function whose body is the BUGS model code, or (3) the output of <code>nimbleCode</code>. If a file name, the file can contain a 'var' block and 'data' block in the manner of the JAGS versions of the BUGS examples but should not contain references to other input data files nor a const block. The '.bug' or '.txt' extension can be excluded.</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_data">data</code></td>
<td>
<p>(optional) one of (1) character string giving the file name for an R file providing the input constants and data as R code [assigning individual objects or as a named list] or (2) a named list providing the input constants and data. If neither is provided, the function will look for a file named <code>example</code>-data including extensions .R, .r, or .txt.</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_inits">inits</code></td>
<td>
<p>(optional) (1) character string giving the file name for an R file providing the initial values for parameters as R code [assigning individual objects or as a named list] or (2) a named list providing the values. If neither is provided, the function will look for a file named <code>example</code>-init or <code>example</code>-inits including extensions .R, .r, or .txt.</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_useinits">useInits</code></td>
<td>
<p>boolean indicating whether to test model with initial values provided via <code>inits</code>.</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_expectmodelwarning">expectModelWarning</code></td>
<td>
<p>boolean indicating whether <code>nimbleModel</code> is expected to produce a warning or character string giving part of expected warning.</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_debug">debug</code></td>
<td>
<p>logical indicating whether to put the user in a browser for debugging when <code>testBUGSmodel</code> calls <code>readBUGSmodel</code>.  Intended for developer use.</p>
</td></tr>
<tr><td><code id="testBUGSmodel_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether to print additional logging information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that testing without initial values may cause warnings when parameters are sampled from improper or fat-tailed distributions
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
testBUGSmodel('pump')

## End(Not run)
</code></pre>

<hr>
<h2 id='valueInCompiledNimbleFunction'>get or set value of member data from a compiled nimbleFunction using a multi-interface</h2><span id='topic+valueInCompiledNimbleFunction'></span>

<h3>Description</h3>

<p>Most nimbleFunctions written for direct user interaction allow standard R-object-like access to member data using <code>$</code> or <code>`[[`</code>.  However, sometimes compiled nimbleFunctions contained within other compiled nimbleFunctions are interfaced with a light-weight system called a multi-interface.  <code>valueInCompiledNimbleFunction</code> provides a way to get or set values in such cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valueInCompiledNimbleFunction(cnf, name, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valueInCompiledNimbleFunction_+3A_cnf">cnf</code></td>
<td>
<p>Compiled nimbleFunction object</p>
</td></tr>
<tr><td><code id="valueInCompiledNimbleFunction_+3A_name">name</code></td>
<td>
<p>Name of the member data</p>
</td></tr>
<tr><td><code id="valueInCompiledNimbleFunction_+3A_value">value</code></td>
<td>
<p>If provided, the value to assign to the member data.  If omitted, the value of the member data is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The member data of a nimbleFunction are the objects created in <code>setup</code> code that are used in <code>run</code> code or other member functions.
</p>
<p>Whether multi-interfaces are used for nested nimbleFunctions is controlled by the <code>buildInterfacesForCompiledNestedNimbleFunctions</code> option in <code><a href="#topic+nimbleOptions">nimbleOptions</a></code>.
</p>
<p>To see an example of a multi-interface, see <code>samplerFunctions</code> in a compiled MCMC interface object.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine
</p>

<hr>
<h2 id='values'>Access or set values for a set of nodes in a model</h2><span id='topic+values'></span><span id='topic+values+3C-'></span>

<h3>Description</h3>

<p>Get or set values for a set of nodes in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values(model, nodes, accessorIndex)

values(model, nodes, accessorIndex) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="values_+3A_model">model</code></td>
<td>
<p>a NIMBLE model object, either compiled or uncompiled</p>
</td></tr>
<tr><td><code id="values_+3A_nodes">nodes</code></td>
<td>
<p>a vector of node names, allowing index blocks that will be expanded</p>
</td></tr>
<tr><td><code id="values_+3A_accessorindex">accessorIndex</code></td>
<td>
<p>For internal NIMBLE use only</p>
</td></tr>
<tr><td><code id="values_+3A_value">value</code></td>
<td>
<p>value to set the node(s) to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Access or set values for a set of nodes in a NIMBLE model.
</p>
<p>Calling <code>values(model, nodes)</code> returns a vector of the concatenation of values from the nodes requested
<code>P &lt;- values(model, nodes)</code> is a newer syntax for <code>getValues(P, model, values)</code>, which still works and modifies P in the calling environment.
</p>
<p>Calling <code>values(model, nodes) &lt;- P</code> sets the value of the nodes in the model, in sequential order from the vector P.
</p>
<p>In both uses, when requested nodes are from matrices or arrays, the values will be handled following column-wise order.
</p>
<p>The older function <code>getValues(P, model, nodes)</code> is equivalent to <code>P &lt;- values(model, nodes)</code>, and the older function <code>setValues(P, model, nodes)</code> is equivalent to <code>values(model, nodes) &lt;- P</code>
</p>
<p>These functions work in R and in NIMBLE run-time code that can be compiled.
</p>


<h3>Value</h3>

<p>A vector of values concatenated from the provided nodes in the model
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='waic'>Using WAIC</h2><span id='topic+waic'></span><span id='topic+getWAIC'></span><span id='topic+getWAICdetails'></span><span id='topic+buildWAIC'></span><span id='topic+WAIC'></span><span id='topic+enableWAIC'></span>

<h3>Description</h3>

<p>Details of the WAIC measure for comparing models. NIMBLE implements an online
WAIC algorithm, computed during the course of the MCMC iterations.
</p>


<h3>Details</h3>

<p>To obtain WAIC, set <code>WAIC = TRUE</code> in nimbleMCMC. If using a more
customized workflow, set <code>enableWAIC = TRUE</code> in <code>configureMCMC</code>
or (if skipping <code>configureMCMC</code>) in <code>buildMCMC</code>, followed by
setting <code>WAIC = TRUE</code> in <code>runMCMC</code>, if using runMCMC to manage
sample generation.
</p>
<p>By default, NIMBLE calculates WAIC using an online algorithm that updates
required summary statistics at each post-burnin iteration of the MCMC.
</p>
<p>One can also use <code>calculateWAIC</code> to run an offline version of the
WAIC algorithm after all MCMC sampling has been done. This allows calculation
of WAIC from a matrix (or dataframe) of posterior samples and also retains
compatibility with WAIC in versions of NIMBLE before 0.12.0. However, the
offline algorithm is less flexible than the online algorithm and only
provides conditional WAIC without the ability to group data points. See
<code>help(calculateWAIC)</code> for details.
</p>


<h3><code>controlWAIC</code> list</h3>

<p>The <code>controlWAIC</code> argument is a list that controls the behavior of the
WAIC algorithm and is passed to either <code>configureMCMC</code> or (if not using
<code>configureMCMC</code>) <code>buildMCMC</code>. One can supply any of the following
optional components:
</p>
<p><code>online</code>: Logical value indicating whether to calculate WAIC during the
course of the MCMC. Default is <code>TRUE</code> and setting to <code>FALSE</code> is
primarily for backwards compatibility to allow use of the old
<code>calculateWAIC</code> method that calculates WAIC from monitored values after
the MCMC finishes.
</p>
<p><code>dataGroups</code>: Optional list specifying grouping of data nodes,
one element per group, with each list element containing the node names
for the data nodes in that group. If provided, the predictive density values
computed will be the joint density values, one joint density per group.
Defaults to one data node per 'group'. See details.
</p>
<p><code>marginalizeNodes</code>: Optional set of nodes (presumably latent nodes)
over which to marginalize to compute marginal WAIC (i.e., WAIC based on a
marginal likelihood), rather than the default conditional WAIC (i.e., WAIC
conditioning on all parent nodes of the data nodes). See details.
</p>
<p><code>niterMarginal</code>: Number of Monte Carlo iterations to use when
marginalizing (default is 1000).
</p>
<p><code>convergenceSet</code>: Optional vector of numbers between 0 and 1 that
specify a set of shorter Monte Carlo simulations for marginal WAIC
calculation as fractions of the full (<code>niterMarginal</code>) Monte Carlo
simulation. If not provided, NIMBLE will use 0.25, 0.50, and 0.75.
NIMBLE will report the WAIC, lppd, and pWAIC that would have been obtained
for these smaller Monte Carlo simulations, allowing assessment of the number
of Monte Carlo samples needed for stable calculation of WAIC.
</p>
<p><code>thin</code>: Logical value for specifying whether to do WAIC calculations
only on thinned samples (default is <code>FALSE</code>). Likely only useful for
reducing computation when using marginal WAIC.
</p>
<p><code>nburnin_extra</code>: Additional number of pre-thinning MCMC iterations
to discard before calculating online WAIC. This number is discarded in
addition to the usual MCMC burnin, <code>nburnin</code>. The purpose of this
option is to allow a user to retain some samples for inspection without
having those samples used for online WAIC calculation (default = 0).
</p>


<h3>Extracting WAIC</h3>

<p>The calculated WAIC and related quantities can be obtained in various ways
depending on how the MCMC is run. If using <code>nimbleMCMC</code> and setting
<code>WAIC = TRUE</code>, see the <code>WAIC</code> component of the output list. If using
<code>runMCMC</code> and setting <code>WAIC = TRUE</code>, either see the <code>WAIC</code>
component of the output list or use the <code>getWAIC</code> method of the MCMC
object (in the latter case <code>WAIC = TRUE</code> is not required). If using
the <code>run</code> method of the MCMC object, use the <code>getWAIC</code> method of
the MCMC object.
</p>
<p>The output of running WAIC (unless one sets <code>online = FALSE</code>) is a list
containing the following components:
</p>
<p><code>WAIC</code>: The computed WAIC, on the deviance scale. Smaller values are
better when comparing WAIC for two models.
</p>
<p><code>lppd</code>: The log predictive density component of WAIC.
</p>
<p><code>pWAIC</code>: The pWAIC estimate of the effective number of parameters,
computed using the <em>p</em>WAIC2 method of Gelman et al. (2014).
</p>
<p>To get further information, one can use the <code>getWAICdetails</code> method
of the MCMC object.  The result of running <code>getWAICdetails</code> is a list
containing the following components:
</p>
<p><code>marginal</code>: Logical value indicating whether marginal (<code>TRUE</code>) or
conditional (<code>FALSE</code>) WAIC was calculated.
</p>
<p><code>niterMarginal</code>: Number of Monte Carlo iterations used in computing
marginal likelihoods if using marginal WAIC.
</p>
<p><code>thin</code>: Whether WAIC was calculated based only on thinned samples.
</p>
<p><code>online</code>: Whether WAIC was calculated during MCMC sampling.
</p>
<p><code>nburnin_extra</code>: Number of additional iterations discarded as burnin,
in addition to original MCMC burnin.
</p>
<p><code>WAIC_partialMC</code>, <code>lppd_partialMC</code>, <code>pWAIC_partialMC</code>: The
computed marginal WAIC, lppd, and pWAIC based on fewer Monte Carlo
simulations, for use in assessing the sensitivity of the WAIC calculation
to the number of Monte Carlo iterations.
</p>
<p><code>niterMarginal_partialMC</code>: Number of Monte Carlo iterations used for the
values in <code>WAIC_partialMC</code>, <code>lppd_partialMC</code>, <code>pWAIC_partialMC</code>.
</p>
<p><code>WAIC_elements</code>, <code>lppd_elements</code>, <code>pWAIC_elements</code>: Vectors of
individual WAIC, lppd, and pWAIC values, one element per data node (or group
of nodes in the case of specifying <code>dataGroups</code>). Of use in computing
the standard error of the difference in WAIC between two models, following
Vehtari et al. (2017).
</p>


<h3>Online WAIC</h3>

<p>As of version 0.12.0, NIMBLE provides enhanced WAIC functionality, with user
control over whether to use conditional or marginal versions of WAIC and
whether to group data nodes. In addition, users are no longer required to
carefully choose MCMC monitors. WAIC by default is now calculated in an online
manner (updating the required summary statistics at each MCMC iteration),
using all post-burnin samples. The WAIC (Watanabe, 2010) is calculated from
Equations 5, 12, and 13 in Gelman et al. (2014) (i.e., using 'pWAIC2').
</p>
<p>Note that there is not a unique value of WAIC for a model. By default, WAIC
is calculated conditional on the parent nodes of the data nodes, and the
density values used are the individual density values of the data nodes.
However, by modifying the <code>marginalizeNodes</code> and <code>dataGroups</code>
elements of the control list, users can request a marginal WAIC (using a
marginal likelihood that integrates over user-specified latent nodes) and/or
a WAIC based on grouping observations (e.g., all observations in a cluster)
to use joint density values. See the MCMC Chapter of the NIMBLE
<a href="https://r-nimble.org/html_manual/cha-mcmc.html">User Manual</a>
for more details.
</p>
<p>For more detail on the use of different predictive distributions, see Section
2.5 from Gelman et al. (2014) or Ariyo et al. (2019).
</p>
<p>Note that based on a limited set of simulation experiments in Hug and Paciorek
(2021) our tentative recommendation is that users only use marginal WAIC if
also using grouping.
</p>


<h3>Author(s)</h3>

<p>Joshua Hug and Christopher Paciorek
</p>


<h3>References</h3>

<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and
widely applicable information criterion in singular learning theory.
<em>Journal of Machine Learning Research</em> 11: 3571-3594.
</p>
<p>Gelman, A., Hwang, J. and Vehtari, A. (2014). Understanding predictive
information criteria for Bayesian models.
<em>Statistics and Computing</em> 24(6): 997-1016.
</p>
<p>Ariyo, O., Quintero, A., Munoz, J., Verbeke, G. and Lesaffre, E. (2019).
Bayesian model selection in linear mixed models for longitudinal data.
<em>Journal of Applied Statistics</em> 47: 890-913.
</p>
<p>Vehtari, A., Gelman, A. and Gabry, J. (2017). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em> 27: 1413-1432.
</p>
<p>Hug, J.E.  and Paciorek, C.J. (2021). A numerically stable online
implementation and exploration of WAIC through variations of the
predictive density, using NIMBLE. <em>arXiv e-print</em> &lt;arXiv:2106.13359&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateWAIC">calculateWAIC</a></code> <code><a href="#topic+configureMCMC">configureMCMC</a></code>
<code><a href="#topic+buildMCMC">buildMCMC</a></code> <code><a href="#topic+runMCMC">runMCMC</a></code> <code><a href="#topic+nimbleMCMC">nimbleMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- nimbleCode({
  for(j in 1:J) {
    for(i in 1:n) 
      y[j, i] ~ dnorm(mu[j], sd = sigma)
    mu[j] ~ dnorm(mu0, sd = tau)
  }
  sigma ~ dunif(0, 10)
  tau ~ dunif(0, 10)
})
J &lt;- 5
n &lt;- 10
groups &lt;- paste0('y[', 1:J, ', 1:', n, ']') 
y &lt;- matrix(rnorm(J*n), J, n)
Rmodel &lt;- nimbleModel(code, constants = list(J = J, n = n), data = list(y = y),
                      inits = list(tau = 1, sigma = 1))

## Various versions of WAIC available via online calculation.
## Conditional WAIC without data grouping:
conf &lt;- configureMCMC(Rmodel, enableWAIC = TRUE)
## Conditional WAIC with data grouping
conf &lt;- configureMCMC(Rmodel, enableWAIC = TRUE, controlWAIC = list(dataGroups = groups))
## Marginal WAIC with data grouping:
conf &lt;- configureMCMC(Rmodel, enableWAIC = TRUE, controlWAIC =
            list(dataGroups = groups, marginalizeNodes = 'mu'))
## Not run: 
Rmcmc &lt;- buildMCMC(conf)
Cmodel &lt;- compileNimble(Rmodel)
Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)
output &lt;- runMCMC(Cmcmc, niter = 1000, WAIC = TRUE)
output$WAIC              # direct access
## Alternatively call via the `getWAIC` method; this doesn't require setting
## `waic=TRUE` in `runMCMC`
Cmcmc$getWAIC()          
Cmcmc$getWAICdetails()

## End(Not run)
</code></pre>

<hr>
<h2 id='waicDetailsNimbleList'>waicDetailsNimbleList definition</h2><span id='topic+waicDetailsNimbleList'></span>

<h3>Description</h3>

<p><code>waicDetailsNimbleList</code> definition for the <code>nimbleList</code> type returned by WAIC
computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waicDetailsNimbleList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Details</h3>

<p>See <code>help(waic)</code> for details on the elements of the list.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='waicNimbleList'>waicNimbleList definition</h2><span id='topic+waicNimbleList'></span>

<h3>Description</h3>

<p><code>waicNimbleList</code> definition for the <code>nimbleList</code> type returned by WAIC
computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waicNimbleList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>


<h3>Details</h3>

<p>See <code>help(waic)</code> for details on the elements of the list.
</p>


<h3>Author(s)</h3>

<p>NIMBLE development team
</p>

<hr>
<h2 id='Wishart'>The Wishart Distribution</h2><span id='topic+Wishart'></span><span id='topic+wishart'></span><span id='topic+dwish_chol'></span><span id='topic+rwish_chol'></span>

<h3>Description</h3>

<p>Density and random generation for the Wishart distribution, using the Cholesky factor of either the scale matrix or the rate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwish_chol(x, cholesky, df, scale_param = TRUE, log = FALSE)

rwish_chol(n = 1, cholesky, df, scale_param = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Wishart_+3A_x">x</code></td>
<td>
<p>vector of values.</p>
</td></tr>
<tr><td><code id="Wishart_+3A_cholesky">cholesky</code></td>
<td>
<p>upper-triangular Cholesky factor of either the scale matrix (when <code>scale_param</code> is TRUE) or rate matrix (otherwise).</p>
</td></tr>
<tr><td><code id="Wishart_+3A_df">df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code id="Wishart_+3A_scale_param">scale_param</code></td>
<td>
<p>logical; if TRUE the Cholesky factor is that of the scale matrix; otherwise, of the rate matrix.</p>
</td></tr>
<tr><td><code id="Wishart_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probability density is returned on the log scale.</p>
</td></tr>
<tr><td><code id="Wishart_+3A_n">n</code></td>
<td>
<p>number of observations (only <code>n=1</code> is handled currently).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gelman et al., Appendix A or the BUGS manual for mathematical details. The rate matrix as used here is defined as the inverse of the scale matrix, <code class="reqn">S^{-1}</code>, given in Gelman et al.
</p>


<h3>Value</h3>

<p><code>dwish_chol</code> gives the density and <code>rwish_chol</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin, D.B. (2004) <em>Bayesian Data Analysis</em>, 2nd ed. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- 40
ch &lt;- chol(matrix(c(1, .7, .7, 1), 2))
x &lt;- rwish_chol(1, ch, df = df)
dwish_chol(x, ch, df = df)

</code></pre>

<hr>
<h2 id='withNimbleOptions'>Temporarily set some NIMBLE options.</h2><span id='topic+withNimbleOptions'></span>

<h3>Description</h3>

<p>Temporarily set some NIMBLE options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withNimbleOptions(options, expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="withNimbleOptions_+3A_options">options</code></td>
<td>
<p>a list of options suitable for <code>nimbleOptions</code>.</p>
</td></tr>
<tr><td><code id="withNimbleOptions_+3A_expr">expr</code></td>
<td>
<p>an expression or statement to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expr as evaluated with given options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (!(getNimbleOption('showCompilerOutput') == FALSE)) stop()
nf &lt;- nimbleFunction(run = function(){ return(0); returnType(double()) })
cnf &lt;- withNimbleOptions(list(showCompilerOutput = TRUE), {
    if (!(getNimbleOption('showCompilerOutput') == TRUE)) stop()
    compileNimble(nf)
})
if (!(getNimbleOption('showCompilerOutput') == FALSE)) stop()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
