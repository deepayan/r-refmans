<!DOCTYPE html><html><head><title>Help for package meta4diag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {meta4diag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#meta4diag-package'>
<p>Meta-Analysis for Diagnostic Test Studies</p></a></li>
<li><a href='#AUC'>
<p>A function that calculate the area under summary receiver operating chracteristic line.</p></a></li>
<li><a href='#Catheter'><p>The Catheter Segment Culture data.</p></a></li>
<li><a href='#crosshair'>
<p>Crosshair Plot.</p></a></li>
<li><a href='#fitted'><p>Get the estimated values of accuracies for each study.</p></a></li>
<li><a href='#forest'>
<p>Forest plot.</p></a></li>
<li><a href='#funnel'><p>Funnel plot.</p></a></li>
<li><a href='#makeData'><p>Make internally used data structure.</p></a></li>
<li><a href='#makeObject'>
<p>A function used to make a <code>meta4diag</code> object.</p></a></li>
<li><a href='#makePriors'><p>Priors for internal use.</p></a></li>
<li><a href='#meta4diag'>
<p>Function to analyse diagnostic meta-analysis with Bayesian methods using INLA.</p></a></li>
<li><a href='#meta4diagGUI'>
<p>A graphic user interface for meta4diag.</p></a></li>
<li><a href='#plot'><p>Default meta4diag plotting.</p></a></li>
<li><a href='#print'><p>print meta4diag object.</p></a></li>
<li><a href='#runModel'><p>Run the bivariate model.</p></a></li>
<li><a href='#Scheidler'><p>Scheidler dataset.</p></a></li>
<li><a href='#SROC'>
<p>A standard summary receiver operating chracteristic plot.</p></a></li>
<li><a href='#summary'><p>Provide summary information.</p></a></li>
<li><a href='#table_cor'><p>The example table prior for correlation.</p></a></li>
<li><a href='#table_var'><p>The example table prior for variance.</p></a></li>
<li><a href='#Telomerase'><p>Telomerase dataset.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Meta-Analysis for Diagnostic Test Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Jingyi Guo &lt;jingyi.guo@ntnu.no&gt; and Andrea Riebler &lt;andrea.riebler@ntnu.no&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jingyi Guo &lt;jingyi.guo@ntnu.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian inference analysis for bivariate meta-analysis of diagnostic test studies using integrated nested Laplace approximation with INLA. A purpose built graphic user interface is available. The installation of R package INLA is compulsory for successful usage. The INLA package can be obtained from <a href="https://www.r-inla.org">https://www.r-inla.org</a>. We recommend the testing version, which can be downloaded by running: install.packages("INLA", repos=c(getOption("repos"), INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), sp, methods, grid, shiny, shinyBS, caTools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>INLA</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>meta4diag</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>29</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2021-11-30 09:10:28</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-30 10:10:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-30 09:28:09 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='meta4diag-package'>
Meta-Analysis for Diagnostic Test Studies
</h2><span id='topic+meta4diag-package'></span>

<h3>Description</h3>

<p>Bayesian inference analysis for bivariate meta-analysis of diagnostic test studies using integrated nested Laplace approximation with INLA.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> meta4diag</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.0.7</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2018-02-14</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The meta4diag package provides tools to implement Bayesian bivariate
meta-analyses of diagnostic test studies. meta4diag is a purpose-built front
end of the R package INLA (Rue H., Martino S, and Chopin N. 2009). It allows the user a straightforward model specification and offers user-specific
prior distributions. Further, the newly proposed penalized complexity prior framework (Simpson et al. 2014) is supported, which builds on prior intuitions about the behaviors of the variance and correlation parameters (Guo, J., Riebler, A. and Rue H. 2017). Accurate posterior marginal distributions for sensitivity and specificity as well as all hyperparameters, and covariates are directly obtained without Markov chain Monte Carlo sampling. Further, univariate estimates of interest, such as odds ratios, as well as the summary receiver operating characteristic (SROC) curve and other common graphics are directly available for interpretation. An interactive graphical user interface provides the user with the full functionality of the package without requiring any R programming.
</p>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler
</p>


<h3>References</h3>

<p><cite>Rue H., Martino S, and Chopin N. (2009). Approximate
Bayesian Inference for Latent Gaussian Models Using Integrated Nested
Laplace Approximations. <em>Journal of the Royal Statistical Society B</em>
<b>71</b>: 319&ndash;392. (www.r-inla.org)</cite>
</p>
<p><cite>Simpson DP, Martins TG, Riebler A, Fuglstad GA, Rue H, Sorbye SH (2014) Penalised Model Component Complexity: A principled, Practical Approach to Constructing Priors. <em>Arxiv e-prints. 1403.4630</em></cite>
</p>
<p><cite>Guo, J., Riebler, A. and Rue H. (2017) Bayesian bivariate meta-analysis of diagnostic test studies with interpretable priors. <em>Statistics in Medicine</em>
<b>36(19)</b>: 3039&ndash;3058.</cite>
</p>
<p><cite>Guo, J. and Riebler, A. (2018) meta4diag: Bayesian Bivariate Meta-Analysis of Diagnostic Test Studies for Routine Practice. <em>Journal of Statistical Software</em>
<b>83(1)</b>: 1&ndash;31.</cite>
</p>

<hr>
<h2 id='AUC'>
A function that calculate the area under summary receiver operating chracteristic line.
</h2><span id='topic+AUC'></span><span id='topic+AUC.meta4diag'></span>

<h3>Description</h3>

<p>Takes a <code>meta4diag</code> object produced by <code>meta4diag()</code> and calculate the area under summary receiver operating chracteristic line. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'meta4diag'
AUC(x, sroc.type=1, est.type="median", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUC_+3A_x">x</code></td>
<td>
<p>A <code>meta4diag</code> object.</p>
</td></tr>
<tr><td><code id="AUC_+3A_est.type">est.type</code></td>
<td>
<p>The estimates type used to make SROC plot. Options are &quot;mean&quot; and &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="AUC_+3A_sroc.type">sroc.type</code></td>
<td>

<p>A numerical value specifying the function used to make SROC line. Options are 1, 2, 3, 4, 5. When <code>sroc.type=1</code>, the SROC line is plotted as &quot; The regression line 1&quot; according to Arends et al.(2008),
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \rho\sqrt{\frac{\sigma_{\mu}^2}{\sigma_{\nu}^2}}(x-\nu)</code>
</p>

<p>When <code>sroc.type=2</code>, the SROC line is plotted as &quot;The major axis method&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \frac{\sigma_{\mu}^2-\sigma_{\nu}^2\pm\sqrt{(\sigma_{\mu}^2-\sigma_{\nu}^2)^2+4\rho^2\sigma_{\mu}^2\sigma_{\nu}^2}}{2\rho\sqrt{\sigma_{\mu}^2\sigma_{\nu}^2}}(x-\nu)+\mu</code>
</p>

<p>When <code>sroc.type=3</code>, the SROC line is plotted as &quot;The Moses and Littenberg's regression line&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \frac{\sigma_{\mu}^2 + \rho\sqrt{\sigma_{\mu}^2\sigma_{\nu}^2}}{\sigma_{\nu}^2+\rho\sqrt{\sigma_{\mu}^2\sigma_{\nu}^2}}(x-\nu)+\mu</code>
</p>

<p>When <code>sroc.type=4</code>, the SROC line is plotted as &quot;The regression line 2&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \frac{1}{\rho}\sqrt(\frac{\sigma_{\mu}^2}{\sigma_{\nu}^2})(x-\nu)</code>
</p>

<p>When <code>sroc.type=5</code>, the SROC line is plotted as &quot;The Rutter and Gatsonis's SROC curve&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \sqrt{\frac{\sigma_{\mu}^2}{\sigma_{\nu}^2}}(x-\nu)</code>
</p>

</td></tr>
<tr><td><code id="AUC_+3A_...">...</code></td>
<td>

<p>Arguments to be passes to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>AUC()</code> returns an estimate of the area under the SROC curve. When the number of samples is given in the <code>makeObject()</code> or <code>meta4diag()</code>, the uncertainty of AUC is estimated. Otherwise only the estimates of the AUC respect to the estimated SROC curve is returned.
</p>


<h3>Value</h3>

<p>A vector containing the &quot;est&quot;, which indicate the estimates of AUC of the estimated SROC vurve and &quot;mean&quot; and &quot;sd&quot; (plus, possibly quantiles) of AUC if <code>nsample</code> is given.
</p>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>References</h3>

<p>Chappell F, Raab G, Wardlaw J (2009). &quot;When are Summary ROC Curves Appropriate for Diagnostic Meta-analyses?&quot; Statistics in Medicine, 28(21), 2653-2668. 
</p>
<p>Arends et al.(2008) &quot;Bivariate random effects meta-analysis of ROC curves.&quot; Medical Decision Making, 28(5), 621-638.
</p>


<h3>See Also</h3>

<p><code>SROC, meta4diag</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter, nsample=1000)
  AUC(res, est.type="mean")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='Catheter'>The Catheter Segment Culture data.</h2><span id='topic+Catheter'></span>

<h3>Description</h3>

<p>The Cathether dataset is a collection of studies which studied semi-quantitative (19 studies) and quantitative (14 studies) catheter segment culture for the diagnosis of intravascular device-related blood stream infection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Catheter)</code></pre>


<h3>Format</h3>

<p>A data frame with 33 rows and 8 columns. Each row provides data for one study. The columns are &quot;studynames&quot;, which indicates the name of studies; &quot;type&quot;, which indicates the study quality; &quot;prevalence&quot;, which denotes the study disease prevalence and is considered as a continuous covariate here; &quot;TP&quot;, &quot;FP&quot;, &quot;TN&quot; and &quot;FN&quot;, which are the observations of this dataset and must be given. 
</p>


<h3>References</h3>

<p>Chu, Haitao, Hongfei Guo, and Yijie Zhou. &quot;Bivariate Random Effects Meta-Analysis of Diagnostic Studies Using Generalized Linear Mixed Models.&quot; Medical Decision Making 30.4 (2010): 499-508.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Catheter)
</code></pre>

<hr>
<h2 id='crosshair'>
Crosshair Plot.
</h2><span id='topic+crosshair'></span><span id='topic+crosshair.meta4diag'></span>

<h3>Description</h3>

<p>Takes a <code>meta4diag</code> object produced by the function <code>meta4diag()</code> and produces a crosshair plot or adds such a plot to an existing plot. Crosshair plots go back to Phillips et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'meta4diag'
crosshair(x, est.type = "mean", add = FALSE, main="Crosshair Plot", xlim, ylim, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosshair_+3A_x">x</code></td>
<td>

<p>A <code>meta4diag</code> object.
</p>
</td></tr>
<tr><td><code id="crosshair_+3A_est.type">est.type</code></td>
<td>

<p>The estimates type used to make crosshair plot. Options are &quot;mean&quot; and &quot;median&quot;.
</p>
</td></tr>
<tr><td><code id="crosshair_+3A_add">add</code></td>
<td>

<p>If add is TRUE, the plots are added to an existing plot, otherwise a new plot is created.
</p>
</td></tr>
<tr><td><code id="crosshair_+3A_main">main</code></td>
<td>

<p>A overall title for the plot.
</p>
</td></tr>
<tr><td><code id="crosshair_+3A_xlim">xlim</code></td>
<td>

<p>A numeric value, giving the x coordinates ranges.
</p>
</td></tr>
<tr><td><code id="crosshair_+3A_ylim">ylim</code></td>
<td>

<p>A numeric value, giving the y coordinates ranges.
</p>
</td></tr>
<tr><td><code id="crosshair_+3A_col">col</code></td>
<td>

<p>Color of cross.
</p>
</td></tr>
<tr><td><code id="crosshair_+3A_...">...</code></td>
<td>

<p>graphics parameters can also be passed to this function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Besides plotting, the function returns an invisible NULL.
</p>


<h3>Author(s)</h3>

<p>Jingyi Guo
</p>


<h3>References</h3>

<p>Phillips, B., Stewart, L.A., &amp; Sutton, A.J. (2010). &quot;'Cross hairs' plots for diagnostic meta-analysis.&quot; Research Synthesis Methods, 1, 308-315. 
</p>


<h3>See Also</h3>

<p><code>meta4diag</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter)
  crosshair(res, est.type="mean")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted'>Get the estimated values of accuracies for each study.</h2><span id='topic+fitted'></span><span id='topic+fitted.meta4diag'></span>

<h3>Description</h3>

<p>Takes a <code>meta4diag</code> object produced by <code>meta4diag()</code> and returns the estimated study specified accuracies, such as sensitivity, specificity, odds ratios and likelihood ratios for each study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'meta4diag'
fitted(object, accuracy.type = "sens",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_+3A_object">object</code></td>
<td>
<p>A <code>meta4diag</code> object.</p>
</td></tr>
<tr><td><code id="fitted_+3A_accuracy.type">accuracy.type</code></td>
<td>

<p>A string specifying the accuracy type. Options are &quot;sens&quot;, &quot;TPR&quot;, &quot;spec&quot;, &quot;TNR&quot;, &quot;FPR&quot;, &quot;FNR&quot;, &quot;LRpos&quot;, &quot;LRneg&quot;, &quot;RD&quot;, &quot;LLRpos&quot;, &quot;LLRneg&quot;, &quot;LDOR&quot;, and &quot;DOR&quot;.
</p>

<ul>
<li> <p><code>"sens" and "TPR"</code>: The true positive rate, known as sensitivity, <code class="reqn">sens = \frac{TP}{TP+FN}</code>.
</p>
</li>
<li> <p><code>"spec" and "TNR"</code>: The true negative rate, known as specificity, <code class="reqn">spec = \frac{TN}{TN+FP}</code>.
</p>
</li>
<li> <p><code>"FPR"</code>: The false positive rate, <code class="reqn">FPR = \frac{FP}{FP+TN}</code>.
</p>
</li>
<li> <p><code>"FNR"</code>: The false negative rate, <code class="reqn">FNR = \frac{FN}{FN+TP}</code>.
</p>
</li>
<li> <p><code>"LRpos"</code>: The positive likelihood ratio, <code class="reqn">LRpos = \frac{sens}{1-spec}</code>.
</p>
</li>
<li> <p><code>"LRneg"</code>: The negative likelihood ratio, <code class="reqn">LRneg = \frac{1-sens}{spec}</code>.
</p>
</li>
<li> <p><code>"RD"</code>: The risk difference, <code class="reqn">RD = sens-(1-spec)</code>.
</p>
</li>
<li> <p><code>"DOR"</code>: The diagnostic odds ratio, <code class="reqn">DOR = \frac{LRpos}{LRneg}</code>.
</p>
</li>
<li> <p><code>"LLRpos"</code>: The log positive likelihood ratio, <code class="reqn">LLRpos = log(\frac{sens}{1-spec})</code>.
</p>
</li>
<li> <p><code>"LLRneg"</code>: The log negative likelihood ratio, <code class="reqn">LLRneg = log(\frac{1-sens}{spec})</code>.
</p>
</li>
<li> <p><code>"LDOR"</code>: The log diagnostic odds ratio, <code class="reqn">LDOR = log(\frac{LRpos}{LRneg})</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="fitted_+3A_...">...</code></td>
<td>

<p>Arguments to be passes to methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the estimated mean, standard deviation and the corresponding quantiles, which are specified by user when the user runs the main function <code>meta4diag()</code>, of the accuracies of each sudy.
</p>


<h3>Author(s)</h3>

<p>Jingyi Guo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter, nsample=2000)
  fitted(res, accuracy.type="sens")
  fitted(res, accuracy.type="DOR")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='forest'>
Forest plot.
</h2><span id='topic+forest'></span><span id='topic+forest.grid'></span><span id='topic+forest.grid.meta4diag'></span><span id='topic+forest.meta4diag'></span>

<h3>Description</h3>

<p>Takes a <code>meta4diag</code> object produced by the function <code>meta4diag()</code> and draws a forest plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'meta4diag'
forest(x, accuracy.type="sens", est.type="mean", p.cex="scaled", p.pch=15, p.col="black",
    nameShow="right", dataShow="center", estShow="left", text.cex=1,
    shade.col="gray", arrow.col="black", arrow.lty=1, arrow.lwd=1,
    cut=TRUE, intervals=c(0.025,0.975),
    main="Forest plot", main.cex=1.5, axis.cex=1,...)
## S3 method for class 'meta4diag'
forest.grid(x, accuracy.type = "sens", est.type = "mean", 
nameShow = T, dataShow = F, estShow = T, graphwidth = 1, main, xlab = "",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forest_+3A_x">x</code></td>
<td>

<p>A <code>meta4diag</code> object obtained by running the main function <code>meta4diag()</code>.
</p>
</td></tr>
<tr><td><code id="forest_+3A_accuracy.type">accuracy.type</code></td>
<td>

<p>A string specifying the accuracy type. Options are &quot;sens&quot;, &quot;TPR&quot;, &quot;spec&quot;, &quot;TNR&quot;, &quot;FPR&quot;, &quot;FNR&quot;, &quot;LRpos&quot;, &quot;LRneg&quot;, &quot;RD&quot;, &quot;LLRpos&quot;, &quot;LLRneg&quot;, &quot;LDOR&quot;, and &quot;DOR&quot;.
</p>
</td></tr>
<tr><td><code id="forest_+3A_est.type">est.type</code></td>
<td>

<p>The type of estimation of study specified summary points. Options are &quot;mean&quot; and &quot;median&quot;.
</p>
</td></tr>
<tr><td><code id="forest_+3A_p.cex">p.cex</code></td>
<td>

<p>Points size of study specific estimate.
</p>
</td></tr>
<tr><td><code id="forest_+3A_p.pch">p.pch</code></td>
<td>

<p>Points symbol of study specific estimate.
</p>
</td></tr>
<tr><td><code id="forest_+3A_p.col">p.col</code></td>
<td>

<p>Points color of study specific estimate.
</p>
</td></tr>
<tr><td><code id="forest_+3A_nameshow">nameShow</code></td>
<td>

<p>Boolean indicating whether the study names are shown or not. Can also be a string indicating the alignment of the study names. Options are &quot;left&quot;, &quot;center&quot; and &quot;right&quot;.
</p>
</td></tr>
<tr><td><code id="forest_+3A_datashow">dataShow</code></td>
<td>

<p>Boolean indicating whether the original data is shown or not. Can also be a string indicating the position to show the original data. Options are &quot;left&quot;, &quot;center&quot; and &quot;right&quot;.
</p>
</td></tr>
<tr><td><code id="forest_+3A_estshow">estShow</code></td>
<td>

<p>Boolean indicating whether the credible intervals are shown or not. Can also be a string indicating the position to show the values of credible intervals. Options are &quot;left&quot;, &quot;center&quot; and &quot;right&quot;.
</p>
</td></tr>
<tr><td><code id="forest_+3A_text.cex">text.cex</code></td>
<td>

<p>The size to be used for the table text.
</p>
</td></tr>
<tr><td><code id="forest_+3A_shade.col">shade.col</code></td>
<td>

<p>Color of shaded area. 
</p>
</td></tr>
<tr><td><code id="forest_+3A_arrow.col">arrow.col</code></td>
<td>

<p>Arrow color.
</p>
</td></tr>
<tr><td><code id="forest_+3A_arrow.lty">arrow.lty</code></td>
<td>

<p>Arrow line style.
</p>
</td></tr>
<tr><td><code id="forest_+3A_arrow.lwd">arrow.lwd</code></td>
<td>

<p>Arrow line width.
</p>
</td></tr>
<tr><td><code id="forest_+3A_cut">cut</code></td>
<td>

<p>Boolean indicating the arrows should be cut or not. Or a length 2 numerical vector indicating the cut position.
</p>
</td></tr>
<tr><td><code id="forest_+3A_main">main</code></td>
<td>

<p>An overall title for the plot.
</p>
</td></tr>
<tr><td><code id="forest_+3A_main.cex">main.cex</code></td>
<td>

<p>The size to be used for main titles.
</p>
</td></tr>
<tr><td><code id="forest_+3A_axis.cex">axis.cex</code></td>
<td>

<p>The size to be used for axis annotation.
</p>
</td></tr>
<tr><td><code id="forest_+3A_intervals">intervals</code></td>
<td>

<p>A numerical vector with length 2 specifying the credible intervals that is of interst. The values should be taken from the argument quantiles (see meta4diag). The first value should be smaller than 0.5 and the second value should be larger than 0.5. 
</p>
</td></tr>
<tr><td><code id="forest_+3A_graphwidth">graphwidth</code></td>
<td>

<p>A numerical value indicating the main plot device size.
</p>
</td></tr>
<tr><td><code id="forest_+3A_xlab">xlab</code></td>
<td>

<p>A title for the x axis.
</p>
</td></tr>
<tr><td><code id="forest_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A forest plot is a graphical representation of a meta-analysis. It is usually accompanied by a table listing references (author and date) of the studies included in the meta-analysis. In the main device each line represents one study in the meta-analysis, plotted according to the estimated result. The estimated accuracy for each study is plotted as point and credible intervals as arrows. The size of the estimated accuracy for each study can be chosen to be propotional to the number of individuals in each study. A diamond indicates the overall summary point. Estimated accuracies and the correspoing credible intervals for each study are plotted. Together shown in the plot with the study names, the original dataset and the values of accuracies and the credible intervals.
</p>
<p>The function <code>forest()</code> gives the user flexibility to control the plots.
</p>


<h3>Value</h3>

<p>Besides plotting, the function returns an invisible NULL.</p>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter)
  forest(res, accuracy.type = "sens")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='funnel'>Funnel plot.</h2><span id='topic+funnel'></span><span id='topic+funnel.meta4diag'></span>

<h3>Description</h3>

<p>Takes a <code>meta4diag</code> object produced by the function <code>meta4diag()</code> and draws a funnel plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'meta4diag'
funnel(x, est.type="median",intervals=c(0.025,0.975), 
  lwd=1, arrow.lty=1,col="black",
  main="Funnel Plot", xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funnel_+3A_x">x</code></td>
<td>
<p>A <code>meta4diag</code> object obtained by running the main function <code>meta4diag()</code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_est.type">est.type</code></td>
<td>
<p>The type of estimation of study specified summary points. Options are &quot;mean&quot; and &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="funnel_+3A_intervals">intervals</code></td>
<td>
<p>A numerical vector with length 2 specifying the credible intervals that is of interst. The values should be taken from the argument quantiles (see meta4diag). The first value should be smaller than 0.5 and the second value should be larger than 0.5.</p>
</td></tr>
<tr><td><code id="funnel_+3A_arrow.lty">arrow.lty</code></td>
<td>
<p>Arrow line style.</p>
</td></tr>
<tr><td><code id="funnel_+3A_lwd">lwd</code></td>
<td>
<p>Line width.</p>
</td></tr>
<tr><td><code id="funnel_+3A_col">col</code></td>
<td>
<p>Color of cross.</p>
</td></tr>
<tr><td><code id="funnel_+3A_main">main</code></td>
<td>
<p>An overall title for the plot.</p>
</td></tr>
<tr><td><code id="funnel_+3A_xlim">xlim</code></td>
<td>
<p>A numeric value, giving the x coordinates ranges.</p>
</td></tr>
<tr><td><code id="funnel_+3A_ylim">ylim</code></td>
<td>
<p>A numeric value, giving the y coordinates ranges.</p>
</td></tr>
<tr><td><code id="funnel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A funnel plot is a graphical representation of a meta-analysis. Funnel plots are used primarily as a visual aid for detecting bias or heterogeneity, and often it is not possible to distinguish between the two. A complete collection of unbiased studies, all estimating the same underlying effect with different levels of precision, would produce a symmetric funnel shape, with increasing scatter with decreasing precision. An asymmetric funnel indicates a relationship between effect size and precision in the studies at hand. This is most likely to be due to reporting bias, to a systematic difference between smaller and larger studies, or to the presence of subsets of studies with different mean effect sizes.
</p>
<p>The function <code>funnel()</code> gives the user flexibility to control the plots.
</p>


<h3>Value</h3>

<p>Besides plotting, the function returns an invisible NULL.</p>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>References</h3>

<p>Anzures-Cabrera J and Higgins J (2010). Graphical displays for meta-analysis: An
overview with suggestions for practice. Research Synthesis Methods,
1, 66-80. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    if(requireNamespace("INLA", quietly = TRUE)){
      require("INLA", quietly = TRUE)
      data(Catheter)
      res &lt;- meta4diag(data = Catheter)
      funnel(res, est.type = "median")
    }
  
## End(Not run)
</code></pre>

<hr>
<h2 id='makeData'>Make internally used data structure.</h2><span id='topic+makeData'></span>

<h3>Description</h3>

<p>Transform the format of the input dataset into internal use format. This function is used within the main function <code>meta4diag()</code> and can also be used as a separate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeData(data = NULL, model.type = 1, modality = NULL, covariates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeData_+3A_data">data</code></td>
<td>

<p>A data frame contains at least 4 columns specifying the number of True Positive(<code>TP</code>), False Negative(<code>FN</code>), True Negative(<code>TN</code>) and False Positive(<code>FP</code>). The additional columns other than <code>studynames</code> will be considered as potential covariates and the name or the column number of the potential covariates can be set in the arguments <code>modality</code> and <code>covariates</code> to use them in the model.
</p>
</td></tr>
<tr><td><code id="makeData_+3A_model.type">model.type</code></td>
<td>

<p>A numerical value specifying the model type, options are 1(default), 2, 3 and 4. <code>model.type=1</code> indicates that the Sensitivity(se) and Specificity(sp) will be modelled in the bivariate model, i.e. <code class="reqn">g(se)</code> and <code class="reqn">g(sp)</code> are bivariate normal distributed. <code>model.type=2,3,4</code> indicate that the Sensitivity(se) and False Negative Rate(1-sp), False Positive Rate(1-se) and Specificity(sp), False Positive Rate(1-se) and False Negative Rate(1-sp) are modelled in the bivariate model, respectively.
</p>
</td></tr>
<tr><td><code id="makeData_+3A_modality">modality</code></td>
<td>

<p>A string specifying the modality variable, which is a categorical variable, such as test threshold. Default value is NULL. See also <code>examples</code>.
</p>
</td></tr>
<tr><td><code id="makeData_+3A_covariates">covariates</code></td>
<td>

<p>A vector specifying the continuous covariates variables, such as disease prevalence or average individual patients status of each study. Default value is NULL. See also <code>examples</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A constructed list with components:
</p>
<table>
<tr><td><code>internaldata</code></td>
<td>
<p>a data frame used as internal data in <span class="pkg">INLA</span>.</p>
</td></tr>
<tr><td><code>originaldata</code></td>
<td>
<p>a data frame which is equal to the provided input data.</p>
</td></tr>
<tr><td><code>covariates.setting</code></td>
<td>
<p>a vector specified the setting of covariates, if <code>covariates</code> is given.</p>
</td></tr>
<tr><td><code>modality.setting</code></td>
<td>
<p>a vector specified the setting of modality, if <code>modality</code> is given.</p>
</td></tr>
<tr><td><code>model.type</code></td>
<td>
<p>a value specified the model type.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Catheter)

a = makeData(data=Catheter,model.type=1,modality="type")
b = makeData(data=Catheter,model.type=1,modality=2)
c = makeData(data=Catheter,model.type=1,covariates="prevalence")
d = makeData(data=Catheter,model.type=1,covariates=3)
e = makeData(data=Catheter,model.type=1,modality="type",covariates="prevalence")

## End(Not run)
</code></pre>

<hr>
<h2 id='makeObject'>
A function used to make a <code>meta4diag</code> object.
</h2><span id='topic+makeObject'></span>

<h3>Description</h3>

<p>Takes an internal data list, an internal prior setting list and an <code>INLA</code> object produced by <code>makeData()</code>, <code>makePriors()</code> and <code>runModel()</code>, respectively and makes a <code>meta4diag</code> object which contains various informations for later use. This function is used in the main function <code>meta4diag()</code> and can also be used as a separate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  makeObject(model, nsample=FALSE, seed=0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeObject_+3A_model">model</code></td>
<td>

<p>An <code>INLA</code> object. Get from function <code>runModel()</code>.
</p>
</td></tr>
<tr><td><code id="makeObject_+3A_nsample">nsample</code></td>
<td>

<p>A numerical value specifying the number of posterior samples, default is FALSE. The posterior samples are used to compute the marginals and estimates values of non-linear functions, such as log ratios and diagnostic odds ratios. If <code>nsample</code> is given, <code>summary.summarized.statistics</code>, <code>summary.fitted.LRpos</code>, <code>summary.fitted.LRneg</code>, <code>summary.fitted.DOR</code> and samples of <code class="reqn">E(se)</code>, <code class="reqn">E(sp)</code>, <code class="reqn">E(1-se)</code> and <code class="reqn">E(1-sp)</code> will be returned.
</p>
</td></tr>
<tr><td><code id="makeObject_+3A_seed">seed</code></td>
<td>

<p>A numerical value specifying the random seed to control the RNG for generating posterior samples if nsample &gt; 0. If you want reproducible results, you ALSO need to control the seed for the RNG in R by controlling the variable .Random.seed or using the function set.seed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>makeObject</code> returns a <code>meta4diag</code> object with components: 
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The provided input data.</p>
</td></tr>
<tr><td><code>outdata</code></td>
<td>
<p>The internal data that could be used in <span class="pkg">INLA</span> from function <code>makeData()</code>.</p>
</td></tr>
<tr><td><code>priors.density</code></td>
<td>
<p>Prior distributions for the variance components and correlation from function <code>makePriors()</code>.</p>
</td></tr>
<tr><td><code>names.fitted</code></td>
<td>
<p>Names of the jointly modelled accuracies in the model. For example, se and sp or (1-se) and sp.</p>
</td></tr> 
<tr><td><code>cpu.used</code></td>
<td>
<p>The cpu time used for running the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>summary.fixed</code></td>
<td>
<p>Matrix containing the mean and standard deviation (plus, possibly quantiles) of the fixed effects of the model.</p>
</td></tr>
<tr><td><code>marginals.fixed</code></td>
<td>
<p>A list containing the posterior marginal densities of the fixed effects of the model.</p>
</td></tr>
<tr><td><code>summary.expected.(...).accuracy</code></td>
<td>
<p>Matrix containing the mean and standard deviation (plus, possibly quantiles) of the mean of accuracies transformed with the link function, i.e. E(g(Se)), E(g(Sp)), E(g(1-Se)) and E(g(1-Sp)). Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>, i.e. if link function is &quot;logit&quot;, the full name of this output is &quot;summary.expected.logit.accuracy&quot;.</p>
</td></tr>
<tr><td><code>marginals.expected.(...).accuracy</code></td>
<td>
<p>A list containing the posterior marginal densities of the mean of accuracies transformed with the link function, i.e. E(g(Se)), E(g(Sp)), E(g(1-Se)) and E(g(1-Sp)). Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>, i.e. if link function is &quot;logit&quot;, the full name of this output is &quot;marginals.expected.logit.accuracy&quot;.</p>
</td></tr>
<tr><td><code>summary.expected.accuracy</code></td>
<td>
<p>Matrix containing the mean and standard deviation (plus, possibly quantiles) of the mean of the accuracies, i.e.  E(Se), E(Sp), E(1-Se) and E(1-Sp).</p>
</td></tr>
<tr><td><code>marginals.expected.accuracy</code></td>
<td>
<p>A list containing the posterior marginal densities of of the mean of the accuracies, i.e.  E(Se), E(Sp), E(1-Se) and E(1-Sp).</p>
</td></tr>
<tr><td><code>summary.hyperpar</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of the hyperparameters of the model.</p>
</td></tr>
<tr><td><code>marginals.hyperpar</code></td>
<td>
<p>A list containing the posterior marginal densities of the hyperparameters of the model.</p>
</td></tr> 
<tr><td><code>correlation.expected.(...).accuracy</code></td>
<td>
<p>A correlation matrix between the mean of the accuracies transformed with the link function. Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>.</p>
</td></tr> 
<tr><td><code>covariance.expected.(...).accuracy</code></td>
<td>
<p>A covariance matrix between the mean of the accuracies transformed with the link function. Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>.</p>
</td></tr>
<tr><td><code>summary.predictor.(...)</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of the linear predictors one transformed accuracy in the model. The accuracy type depends on the model type. See argument <code>model.type</code>. For example, the possible accuracy type could be <code class="reqn">g(se)</code>, <code class="reqn">g(sp)</code>, <code class="reqn">(se)</code> or <code class="reqn">(sp)</code>, where <code class="reqn">g()</code> is the link function.</p>
</td></tr>
<tr><td><code>marginals.predictor.(...)</code></td>
<td>
<p>A list containing the posterior marginals of the linear predictors of one transformed accuracy in the model. The accuracy type depends on the model type. See argument <code>model.type</code>. For example, the possible accuracy type could be <code class="reqn">g(se)</code>, <code class="reqn">g(sp)</code>, <code class="reqn">(se)</code> or <code class="reqn">(sp)</code>, where <code class="reqn">g()</code> is the link function.</p>
</td></tr>
<tr><td><code>misc</code></td>
<td>
<p>Some other settings that maybe useful retruned by <span class="pkg">meta4diag</span>.</p>
</td></tr>
<tr><td><code>dic</code></td>
<td>
<p>The deviance information criteria and effective number of parameters.</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>
<p>A list of three elements: <code>cpo$cpo</code> are the values of the conditional predictive ordinate (CPO), <code>cpo$pit</code> are the values of the 
probability integral transform (PIT) and <code>cpo$failure</code> 
indicates whether some assumptions are violated. In short, if 
cpo$failure[i] &gt; 0 then some assumption is violated, the higher the 
value (maximum 1) the more seriously.</p>
</td></tr>
<tr><td><code>waic</code></td>
<td>
<p>A list of two elements: <code>waic$waic</code> is the Watanabe-Akaike information criteria,  and <code>waic$p.eff</code> is the estimated effective number of parameters.</p>
</td></tr>
<tr><td><code>mlik</code></td>
<td>
<p>The log marginal likelihood of the model</p>
</td></tr>
<tr><td><code>inla.result</code></td>
<td>
<p>A <code>INLA</code> object that from function <code>runModel()</code> which implements INLA.</p>
</td></tr>
<tr><td><code>samples.fixed</code></td>
<td>
<p>A matrix of the fixed effects samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.hyperpar</code></td>
<td>
<p>A matrix of the hyperparameter samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.overall.Se</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of overall sensitivity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.overall.Sp</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of overall specificity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.overall.statistics</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of mean positive and negative likelihood ratios and mean diagnostic odds ratios if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.study.specific.Se</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of study specific sensitivity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.study.specific.Sp</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of study specific specificity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LRpos</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of positive likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LRneg</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of negative likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.DOR</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of diagnostic odds ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.RD</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of risk difference for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LDOR</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of log diagnostic odds ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LLRpos</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of log positive likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LLRneg</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of log negative likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jingyi Guo
</p>


<h3>See Also</h3>

<p><code>makeData, makePriors, runModel, meta4diag</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  outdata = makeData(Catheter)
  outpriors = makePriors()
  model = runModel(outdata=outdata, outpriors=outpriors, link="logit")
  res = makeObject(outdata, outpriors, model, nsample=2000)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='makePriors'>Priors for internal use.</h2><span id='topic+makePriors'></span>

<h3>Description</h3>

<p>Prepare the given prior settings for internal use in <span class="pkg">INLA</span>. The input of the function <code>makePriors</code> are prior settings for variances and correlation or the full covariance matrix, these are then transformed to the internal parameterisation that <span class="pkg">INLA</span> requires. This function is used internally in the main function <code>meta4diag()</code> but can also be used as a separate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePriors(var.prior = "PC", var2.prior="PC", cor.prior = "PC",
  var.par = c(3, 0.05), var2.par, cor.par = c(1,-0.1,0.5,-0.95,0.05,0.95,0.05),
  wishart.par = c(4,1,1,0), init = c(0.01, 0.01, -0.1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePriors_+3A_var.prior">var.prior</code></td>
<td>

<p>A string specifying the prior density for the first variance component, options are &quot;PC&quot; for penalised complexity prior, &quot;Invgamma&quot; for inverse gamma prior, &quot;Tnormal&quot; for truncated normal prior, &quot;Unif&quot; for uniform prior which allow the standard deviation uniformaly distributed on [0,1000], &quot;Hcauchy&quot; for half-cauchy prior and  &quot;table&quot; for user specific prior. <code>var.prior</code> can also be set to &quot;Invwishart&quot; for inverse wishart prior for covariance matrix. When <code>var.prior="Invwishart"</code>, no matter what <code>var2.prior</code> and <code>cor.prior</code> are given, the inverse Wishart prior covariance matrix is used for covariance matrix and the <code>wishart.par</code> must be given. Of note, the values of this argument is not case sensitive. The definition of the priors is as following,
</p>

<ul>
<li> <p><code>var.prior="Invgamma"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code>. The inverse gamma prior has density, 
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma^2)=\frac{1}{\Gamma(a)b^a}(\sigma^2)^{-a-1}exp(-\frac{1}{b\sigma^2}),</code>
</p>

<p>for <code class="reqn">\sigma^2&gt;0</code> where: <code class="reqn">a&gt;0</code> is the shape parameter, <code class="reqn">b&gt;0</code> is the rate (1/scale) parameter.
The parameters are here <code>c(a, b)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Tnormal"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows. 
The standard deviation <code class="reqn">\sigma=\sqrt{\sigma^2}</code> is Gaussian distributed with mean <code class="reqn">m</code> and variance <code class="reqn">v</code> but truncated to be positive.
The parameters are here <code>c(m, v)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="PC"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows. 
The left tail of the distribution of standard deviation <code class="reqn">\sigma</code> has behavior
</p>
<p style="text-align: center;"><code class="reqn">P(\sigma&gt;u)=\alpha,</code>
</p>

<p>which means it is unlikely that the standard deviation <code class="reqn">\sigma</code> to be larger than a value <code class="reqn">u</code> with probability <code class="reqn">\alpha</code>.
The parameters are here <code>c(u, alpha)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Hcauchy"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows.  
The standard deviation <code class="reqn">\sigma=\sqrt{\sigma^2}</code> is half-Cauchy distributed with density,
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma)=\frac{2\gamma}{\pi(\sigma^2+\gamma^2)},</code>
</p>

<p>where <code class="reqn">\gamma&gt;0</code> is the rate parameter.
The parameters are here <code>c(gamma)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Unif"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows.  
The standard deviation <code class="reqn">\sigma=\sqrt{\sigma^2}</code> is uniform distributed on <code class="reqn">(0,\infty)</code>.
No parameters need to be given for this prior, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Table"</code>:  This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows.  
Users have to specify a data.frame with 2 columns, 
one indicates the values of <code class="reqn">\sigma^2</code> and the other one indicates the values of <code class="reqn">\pi(\sigma^2)</code>.
The parameters are this data frame, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Invwishart"</code>: Instead of specifying separate prior distributions for the variance and correlation parameters we could also assume that the covariance matrix <code class="reqn">\Sigma</code> 
</p>
<p style="text-align: center;"><code class="reqn">\Sigma \sim Wishart^{-1}_{p}(\nu,R),p=2,</code>
</p>

<p>where the Wishart distribution has density
</p>
<p style="text-align: center;"><code class="reqn">\pi(\Sigma)=\frac{|R|^{\frac{\nu}{2}}}{2^{\frac{p\nu}{2}}\Gamma_{p}(\frac{\nu}{2})}|\Sigma|^{-\frac{\nu+p+1}{2}}exp(-\frac{1}{2}Trace(\frac{R}{\Sigma})), \nu&gt;p+1,</code>
</p>

<p>Then,
</p>
<p style="text-align: center;"><code class="reqn">E(\Sigma)=\frac{R}{\nu-p-1}.</code>
</p>

<p>The parameters are <code class="reqn">\nu, R_{11},R_{22} and R_{12}</code>, where
</p>
<p style="text-align: center;"><code class="reqn">R=\left(\begin{array}{cc}R_{11} &amp; R_{12} \\ R_{21} &amp; R_{22}\end{array}\right)</code>
</p>

<p>The parameters are here <code>c(nu, R11, R22, R12)</code>, see arguments <code>var.par</code>.
</p>
</li></ul>
  
</td></tr>
<tr><td><code id="makePriors_+3A_var2.prior">var2.prior</code></td>
<td>

<p>See <code>var.prior</code>.

</p>
</td></tr>
<tr><td><code id="makePriors_+3A_cor.prior">cor.prior</code></td>
<td>

<p>A string specifying the prior density for the correlation, options are &quot;PC&quot; for penalised complexity prior, &quot;Invgamma&quot; for inverse gamma prior, &quot;Beta&quot; for beta prior and &quot;table&quot; for user specific prior. <code>cor.prior</code> can also be set to &quot;Invwishart&quot; for inverse wishart prior for covariance matrix. When <code>cor.prior="Invwishart"</code>, no matter what <code>var.prior</code> and <code>var2.prior</code> are given, the inverse Wishart prior for covariance matrix is used and the <code>wishart.par</code> must be given. Of note, the values of this argument is not case sensitive. The definition of the priors is as following,
</p>

<ul>
<li> <p><code>cor.prior="Normal"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows. 
The correlation parameter is constrained to <code class="reqn">[-1, 1]</code>. We reparameterise the correlation parameter <code class="reqn">\rho</code> using Fisher's z-transformation as 
</p>
<p style="text-align: center;"><code class="reqn">\rho^{\star}=logit(\frac{\rho+1}{2}),</code>
</p>

<p>which assumes values over the whole real line and assign the following prior distribution to <code class="reqn">\rho</code>,
</p>
<p style="text-align: center;"><code class="reqn">\rho \sim Gaussian(\mu,\sigma^2).</code>
</p>

<p>The prior variance of <code class="reqn">2.5</code> and prior mean of <code class="reqn">0</code> corresponds, roughly, to a uniform prior on <code class="reqn">[-1,1]</code> for <code class="reqn">\rho</code> .
The parameters are here <code>c(mean, variance)</code>, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="PC"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows. 
The prior is defined around at a reference point with value <code class="reqn">\rho_{0}</code>. 
To define the density behavior, three <code>strategy</code> can be applied. 
The first strategy is to define the left tail behavior and the density weight on the left-hand side of the reference point <code class="reqn">\rho_{0}</code>,
</p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;u_{1})=a_{1},</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;\rho_{0})=\omega,</code>
</p>

<p>which means it is unlikely that the value of <code class="reqn">\rho</code> is smaller than a small value <code class="reqn">u_{1}</code> with probability <code class="reqn">a_{1}</code> and 
the probability that <code class="reqn">\rho</code> is smaller than <code class="reqn">\rho_0</code> is <code class="reqn">\omega</code>.
The parameters for the first strategy are here <code>c(1, rho0, omega, u1, a1, NA, NA)</code>, see arguments <code>cor.par</code>.
The second strategy is to define the right tail behavior and the density weight on the left-hand side of the reference point <code class="reqn">\rho_{0}</code>,
</p>
<p style="text-align: center;"><code class="reqn">P(\rho&gt;u_{2})=a_{2},</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;\rho_{0})=\omega,</code>
</p>

<p>which means it is unlikely that the value of <code class="reqn">\rho</code> is larger than a big value <code class="reqn">u_{2}</code> with probability <code class="reqn">a_{2}</code> and 
the probability that <code class="reqn">\rho</code> is smaller than <code class="reqn">\rho_0</code> is <code class="reqn">\omega</code>. 
The parameters for the second strategy are here <code>c(2, rho0, omega, NA, NA, u2, a2)</code>, see arguments <code>cor.par</code>.
The third strategy is to define both tail behaviors,
</p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;u_{1})=a_{1},</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(\rho&gt;u_{2})=a_{2}.</code>
</p>

<p>The parameters for the third strategy are here <code>c(3, rho0, NA, u1, a1, u2, a2)</code>, see arguments <code>cor.par</code>.
The parameters of the PC prior for the correlation here is <code>c(strategy, rho0, omega, u1, a1, u2, a2)</code>, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="Beta"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows. 
The correlation parameter <code class="reqn">\rho</code> has a <code class="reqn">Beta(a,b)</code> distribution scaled to have domain in <code class="reqn">(-1, 1)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\rho)=0.5\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\rho^{a-1}(1-\rho)^{b-1}</code>
</p>
<p>,
where <code class="reqn">a,b&gt;0</code> are the shape parameter.
The parameters are here <code>c(a, b)</code>, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="Table"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows.  
Users have to specify the data.frame with 2 columns, one indicates the values of <code class="reqn">\rho</code> and the other one indicates the values of <code class="reqn">\pi(\rho)</code>.
The parameters are this data frame, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="Invwishart"</code>: Instead of specifying separate prior distributions for the hyperparameters we could also assume that the covariance matrix <code class="reqn">\Sigma</code> 
</p>
<p style="text-align: center;"><code class="reqn">\Sigma \sim Wishart^{-1}_{p}(\nu,R),p=2,</code>
</p>

<p>where the inverse Wishart distribution has density
</p>
<p style="text-align: center;"><code class="reqn">\pi(\Sigma)=\frac{|R|^{\frac{\nu}{2}}}{2^{\frac{p\nu}{2}}\Gamma_{p}(\frac{\nu}{2})}|\Sigma|^{-\frac{\nu+p+1}{2}}exp(-\frac{1}{2}Trace(\frac{R}{\Sigma})), \nu&gt;p+1,</code>
</p>

<p>Then,
</p>
<p style="text-align: center;"><code class="reqn">E(\Sigma)=\frac{R}{\nu-p-1}.</code>
</p>

<p>The parameters are <code class="reqn">\nu, R_{11},R_{22} and R_{12}</code>, where
</p>
<p style="text-align: center;"><code class="reqn">R=\left(\begin{array}{cc}R_{11} &amp; R_{12} \\ R_{21} &amp; R_{22}\end{array}\right)</code>
</p>

<p>The parameters are here <code>c(nu, R11, R22, R12)</code>, see arguments <code>cor.par</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="makePriors_+3A_var.par">var.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the first variance component. 
</p>

<ul>
<li> <p><code>var.par=c(rate, shape)</code> when <code>var.prior="Invgamma"</code>.
</p>
</li>
<li> <p><code>var.par=c(u, alpha)</code> when <code>var.prior="PC"</code>.
</p>
</li>
<li> <p><code>var.par=c(m, v)</code> when <code>var.prior="Tnormal"</code>.
</p>
</li>
<li> <p><code>var.par=c(gamma)</code> when <code>var.prior="Hcauchy"</code>.
</p>
</li>
<li> <p><code>var.par=c()</code> when <code>var.prior="Unif"</code>.
</p>
</li>
<li> <p><code>var.par</code> is a data frame with 2 columns, one indicates the values of <code class="reqn">\sigma^2</code> and the other one indicates the values of <code class="reqn">\pi(\sigma^2)</code> when <code>var.prior="Table"</code>.
</p>
</li>
<li> <p><code>var.par</code> doesn't need to be given when <code>var.prior="Invwishart"</code>.
</p>
</li></ul>

<p>See also argument <code>var.prior</code>.
</p>
</td></tr>
<tr><td><code id="makePriors_+3A_var2.par">var2.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the second variance component. If not given, function will copy the setting for the first variance component. The definition of the priors is the same as for <code>var.par</code>. 
</p>
</td></tr>
<tr><td><code id="makePriors_+3A_cor.par">cor.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the correlation. See also <code>examples</code>.
</p>

<ul>
<li> <p><code>cor.par=c(mean, variance)</code> when <code>cor.prior="normal"</code>.
</p>
</li>
<li> <p><code>cor.par=c(strategy, rho0, omega, u1, a1, u2, a2)</code> when <code>cor.prior="PC"</code>.
</p>
</li>
<li> <p><code>cor.par=c(a, b)</code> when <code>var.prior="beta"</code>.
</p>
</li>
<li> <p><code>cor.par</code> is a data frame with 2 columns, one indicates the values of <code class="reqn">\rho</code> and the other one indicates the values of <code class="reqn">\pi(\rho)</code> when <code>cor.prior="Table"</code>.
</p>
</li>
<li> <p><code>cor.par</code> doesn't need to be given when <code>cor.prior="Invwishart"</code>.
</p>
</li></ul>

<p>See also argument <code>cor.prior</code>.
</p>
</td></tr>
<tr><td><code id="makePriors_+3A_wishart.par">wishart.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the covariance matrix. <code>wishart.par</code> must be given and <code>wishart.par=c(nu, R11, R22, R12)</code> when any of <code>var.prior</code>, <code>var2.prior</code> or <code>cor.prior</code> is <code>"Invwishart"</code>. See also <code>examples</code>.
</p>
</td></tr>
<tr><td><code id="makePriors_+3A_init">init</code></td>
<td>

<p>A numerical vector specifying the initial value of the first variance, the second variance and correlation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of prior settings with the components:
</p>
<table>
<tr><td><code>prec1</code></td>
<td>
<p>a list of prior settings for the first log precision (the log inverse of the first variance in the model).</p>
</td></tr>
<tr><td><code>prec2</code></td>
<td>
<p>a list of prior settings for the second log precision (the log inverse of the second variance in the model).</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>a list of prior settings for the transformed correlation (some functions of correlation in the model).</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>a vector of rate parameters for the PC correlation if <code>cor.prior="PC"</code>.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>a list of prior densities for precisions and correlations.</p>
</td></tr>
<tr><td><code>original.setting</code></td>
<td>
<p>a list of input prior settings.</p>
</td></tr>
<tr><td><code>wishart.flag</code></td>
<td>
<p>Boolean indicating whether a inverse Wishart prior is setting or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>References</h3>

<p>Simpson DP, Martins TG, Riebler A, Fuglstad GA, Rue H, Sorbye SH (2014) Penalised Model Component Complexity: A principled, Practical Approach to Constructing Priors. Arxiv e-prints. 1403.4630  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
require("INLA", quietly = TRUE)
makePriors(var.prior = "PC", cor.prior = "PC", var.par = c(3, 0.05), 
  cor.par = c(1, -0.1, 0.5, -0.95, 0.05, NA, NA))
makePriors(var.prior = "PC", cor.prior = "PC", var.par = c(3, 0.05), 
  cor.par = c(2, -0.1, 0.5, NA, NA, 0.95, 0.05))
makePriors(var.prior = "PC", cor.prior = "PC", var.par = c(3, 0.05), 
  cor.par = c(3, -0.1, NA, -0.95, 0.05, 0.95, 0.05))
makePriors(var.prior = "invgamma", cor.prior = "normal", 
  var.par = c(0.25, 0.025), cor.par = c(0, 5))
makePriors(var.prior = "invwishart", wishart.par=c(4,1,2,0.1))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='meta4diag'>
Function to analyse diagnostic meta-analysis with Bayesian methods using INLA.
</h2><span id='topic+meta4diag'></span>

<h3>Description</h3>

<p>Estimate a Bayesian bivariate hierarchical model fitted within INLA. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta4diag(data=NULL, model.type = 1, 
          var.prior = "Invgamma", var2.prior = "Invgamma", cor.prior = "Normal",
          var.par = c(0.25, 0.025), var2.par, cor.par = c(0,5),
          wishart.par = c(4, 1, 1, 0),
          init = c(0.01,0.01,0), link="logit", quantiles=c(0.025,0.5,0.975),
          modality = NULL, covariates = NULL,
          verbose = FALSE, nsample=FALSE,num.threads = 1, seed=0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta4diag_+3A_data">data</code></td>
<td>

<p>A data frame contains at least 4 columns specifying the number of True Positive(<code>TP</code>), False Negative(<code>FN</code>), True Negative(<code>TN</code>) and False Positive(<code>FP</code>). The additional columns other than <code>studynames</code> will be considered as potential covariates and the name or the column number of the potential covariates can be set in the arguments <code>modality</code> and <code>covariates</code> to use them in the model.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_model.type">model.type</code></td>
<td>

<p>A numerical value specifying the model type, options are 1(default), 2, 3 and 4. <code>model.type=1</code> indicates that the Sensitivity(se) and Specificity(sp) will be modelled in the bivariate model, i.e. <code class="reqn">g(se)</code> and <code class="reqn">g(sp)</code> are bivariate normal distributed. <code>model.type=2,3,4</code> indicate that the Sensitivity(se) and False Negative Rate(1-sp), False Positive Rate(1-se) and Specificity(sp), False Positive Rate(1-se) and False Negative Rate(1-sp) are modelled in the bivariate model, respectively.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_var.prior">var.prior</code></td>
<td>

<p>A string specifying the prior density for the first variance component, options are &quot;PC&quot; for penalised complexity prior, &quot;Invgamma&quot; for inverse gamma prior, &quot;Tnormal&quot; for truncated normal prior, &quot;Unif&quot; for uniform prior which allow the standard deviation uniformaly distributed on [0,1000], &quot;Hcauchy&quot; for half-cauchy prior and  &quot;table&quot; for user specific prior. <code>var.prior</code> can also be set to &quot;Invwishart&quot; for inverse wishart prior for covariance matrix. When <code>var.prior="Invwishart"</code>, no matter what <code>var2.prior</code> and <code>cor.prior</code> are given, the inverse Wishart prior covariance matrix is used for covariance matrix and the <code>wishart.par</code> must be given. The definition of the priors is as following,
</p>

<ul>
<li> <p><code>var.prior="Invgamma"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code>. The inverse gamma prior has density, 
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma^2)=\frac{1}{\Gamma(a)b^a}(\sigma^2)^{-a-1}exp(-\frac{1}{b\sigma^2}),</code>
</p>

<p>for <code class="reqn">\sigma^2&gt;0</code> where: <code class="reqn">a&gt;0</code> is the shape parameter, <code class="reqn">b&gt;0</code> is the rate (1/scale) parameter.
The parameters are here <code>c(a, b)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Tnormal"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows. 
The standard deviation <code class="reqn">\sigma=\sqrt{\sigma^2}</code> is Gaussian distributed with mean <code class="reqn">m</code> and variance <code class="reqn">v</code> but truncated to be positive.
The parameters are here <code>c(m, v)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="PC"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows. 
The left tail of the distribution of standard deviation <code class="reqn">\sigma</code> has behavior
</p>
<p style="text-align: center;"><code class="reqn">P(\sigma&gt;u)=\alpha,</code>
</p>

<p>which means it is unlikely that the standard deviation <code class="reqn">\sigma</code> to be larger than a value <code class="reqn">u</code> with probability <code class="reqn">\alpha</code>.
The parameters are here <code>c(u, alpha)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="HCauchy"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows.  
The standard deviation <code class="reqn">\sigma=\sqrt{\sigma^2}</code> is half-Cauchy distributed with density,
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma)=\frac{2\gamma}{\pi(\sigma^2+\gamma^2)},</code>
</p>

<p>where <code class="reqn">\gamma&gt;0</code> is the rate parameter.
The parameters are here <code>c(gamma)</code>, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Unif"</code>: This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows.  
The standard deviation <code class="reqn">\sigma=\sqrt{\sigma^2}</code> is uniform distributed on <code class="reqn">(0,\infty)</code>.
No parameters need to be given for this prior, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Table"</code>:  This is a prior for a variance <code class="reqn">\sigma^2</code> and defined as follows.  
Users have to specify a data.frame with 2 columns, 
one indicates the values of <code class="reqn">\sigma^2</code> and the other one indicates the values of <code class="reqn">\pi(\sigma^2)</code>.
The parameters are this data frame, see arguments <code>var.par</code>.
</p>
</li>
<li> <p><code>var.prior="Invwishart"</code>: Instead of specifying separate prior distributions for the variance and correlation parameters we could also assume that the covariance matrix <code class="reqn">\Sigma</code> 
</p>
<p style="text-align: center;"><code class="reqn">\Sigma \sim Wishart^{-1}_{p}(\nu,R),p=2,</code>
</p>

<p>where the Wishart distribution has density
</p>
<p style="text-align: center;"><code class="reqn">\pi(\Sigma)=\frac{|R|^{\frac{\nu}{2}}}{2^{\frac{p\nu}{2}}\Gamma_{p}(\frac{\nu}{2})}|\Sigma|^{-\frac{\nu+p+1}{2}}exp(-\frac{1}{2}Trace(\frac{R}{\Sigma})), \nu&gt;p+1,</code>
</p>

<p>Then,
</p>
<p style="text-align: center;"><code class="reqn">E(\Sigma)=\frac{R}{\nu-p-1}.</code>
</p>

<p>The parameters are <code class="reqn">\nu, R_{11},R_{22} and R_{12}</code>, where
</p>
<p style="text-align: center;"><code class="reqn">R=\left(\begin{array}{cc}R_{11} &amp; R_{12} \\ R_{21} &amp; R_{22}\end{array}\right)</code>
</p>

<p>The parameters are here <code>c(nu, R11, R22, R12)</code>, see arguments <code>var.par</code>.
</p>
</li></ul>
  
</td></tr>
<tr><td><code id="meta4diag_+3A_var2.prior">var2.prior</code></td>
<td>
<p>See <code>var.prior</code>.</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_cor.prior">cor.prior</code></td>
<td>

<p>A string specifying the prior density for the correlation, options are &quot;PC&quot; for penalised complexity prior, &quot;Invgamma&quot; for inverse gamma prior, &quot;beta&quot; for beta prior and &quot;table&quot; for user specific prior. <code>cor.prior</code> can also be set to &quot;Invwishart&quot; for inverse wishart prior for covariance matrix. When <code>cor.prior="Invwishart"</code>, no matter what <code>var.prior</code> and <code>var2.prior</code> are given, the inverse Wishart prior for covariance matrix is used and the <code>wishart.par</code> must be given. The definition of the priors is as following,
</p>

<ul>
<li> <p><code>cor.prior="Normal"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows. 
The correlation parameter is constrained to <code class="reqn">[-1, 1]</code>. We reparameterise the correlation parameter <code class="reqn">\rho</code> using Fisher's z-transformation as 
</p>
<p style="text-align: center;"><code class="reqn">\rho^{\star}=logit(\frac{\rho+1}{2}),</code>
</p>

<p>which assumes values over the whole real line and assign the following prior distribution to <code class="reqn">\rho</code>,
</p>
<p style="text-align: center;"><code class="reqn">\rho \sim Gaussian(\mu,\sigma^2).</code>
</p>

<p>The prior variance of <code class="reqn">2.5</code> and prior mean of <code class="reqn">0</code> corresponds, roughly, to a uniform prior on <code class="reqn">[-1,1]</code> for <code class="reqn">\rho</code> .
The parameters are here <code>c(mean, variance)</code>, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="PC"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows. 
The prior is defined around at a reference point with value <code class="reqn">\rho_{0}</code>. 
To define the density behavior, three <code>strategy</code> can be applied. 
The first strategy is to define the left tail behavior and the density weight on the left-hand side of the reference point <code class="reqn">\rho_{0}</code>,
</p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;u_{1})=a_{1},</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;\rho_{0})=\omega,</code>
</p>

<p>which means it is unlikely that the value of <code class="reqn">\rho</code> is smaller than a small value <code class="reqn">u_{1}</code> with probability <code class="reqn">a_{1}</code> and 
the probability that <code class="reqn">\rho</code> is smaller than <code class="reqn">\rho_0</code> is <code class="reqn">\omega</code>.
The parameters for the first strategy are here <code>c(1, rho0, omega, u1, a1, NA, NA)</code>, see arguments <code>cor.par</code>.
The second strategy is to define the right tail behavior and the density weight on the left-hand side of the reference point <code class="reqn">\rho_{0}</code>,
</p>
<p style="text-align: center;"><code class="reqn">P(\rho&gt;u_{2})=a_{2},</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;\rho_{0})=\omega,</code>
</p>

<p>which means it is unlikely that the value of <code class="reqn">\rho</code> is larger than a big value <code class="reqn">u_{2}</code> with probability <code class="reqn">a_{2}</code> and 
the probability that <code class="reqn">\rho</code> is smaller than <code class="reqn">\rho_0</code> is <code class="reqn">\omega</code>. 
The parameters for the second strategy are here <code>c(2, rho0, omega, NA, NA, u2, a2)</code>, see arguments <code>cor.par</code>.
The third strategy is to define both tail behaviors,
</p>
<p style="text-align: center;"><code class="reqn">P(\rho&lt;u_{1})=a_{1},</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(\rho&gt;u_{2})=a_{2}.</code>
</p>

<p>The parameters for the third strategy are here <code>c(3, rho0, NA, u1, a1, u2, a2)</code>, see arguments <code>cor.par</code>.
The parameters of the PC prior for the correlation here is <code>c(strategy, rho0, omega, u1, a1, u2, a2)</code>, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="beta"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows. 
The correlation parameter <code class="reqn">\rho</code> has a <code class="reqn">Beta(a,b)</code> distribution scaled to have domain in <code class="reqn">(-1, 1)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\rho)=0.5\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\rho^{a-1}(1-\rho)^{b-1}</code>
</p>
<p>,
where <code class="reqn">a,b&gt;0</code> are the shape parameter.
The parameters are here <code>c(a, b)</code>, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="Table"</code>: This is a prior for a correlation <code class="reqn">\rho</code> and defined as follows.  
Users have to specify the data.frame with 2 columns, one indicates the values of <code class="reqn">\rho</code> and the other one indicates the values of <code class="reqn">\pi(\rho)</code>.
The parameters are this data frame, see arguments <code>cor.par</code>.
</p>
</li>
<li> <p><code>cor.prior="Invwishart"</code>: Instead of specifying separate prior distributions for the hyperparameters we could also assume that the covariance matrix <code class="reqn">\Sigma</code> 
</p>
<p style="text-align: center;"><code class="reqn">\Sigma \sim Wishart^{-1}_{p}(\nu,R),p=2,</code>
</p>

<p>where the inverse Wishart distribution has density
</p>
<p style="text-align: center;"><code class="reqn">\pi(\Sigma)=\frac{|R|^{\frac{\nu}{2}}}{2^{\frac{p\nu}{2}}\Gamma_{p}(\frac{\nu}{2})}|\Sigma|^{-\frac{\nu+p+1}{2}}exp(-\frac{1}{2}Trace(\frac{R}{\Sigma})), \nu&gt;p+1,</code>
</p>

<p>Then,
</p>
<p style="text-align: center;"><code class="reqn">E(\Sigma)=\frac{R}{\nu-p-1}.</code>
</p>

<p>The parameters are <code class="reqn">\nu, R_{11},R_{22} and R_{12}</code>, where
</p>
<p style="text-align: center;"><code class="reqn">R=\left(\begin{array}{cc}R_{11} &amp; R_{12} \\ R_{21} &amp; R_{22}\end{array}\right)</code>
</p>

<p>The parameters are here <code>c(nu, R11, R22, R12)</code>, see arguments <code>cor.par</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="meta4diag_+3A_var.par">var.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the first variance component. 
</p>

<ul>
<li> <p><code>var.par=c(rate, shape)</code> when <code>var.prior="Invgamma"</code>.
</p>
</li>
<li> <p><code>var.par=c(u, alpha)</code> when <code>var.prior="PC"</code>.
</p>
</li>
<li> <p><code>var.par=c(m, v)</code> when <code>var.prior="Tnormal"</code>.
</p>
</li>
<li> <p><code>var.par=c(gamma)</code> when <code>var.prior="Hcauchy"</code>.
</p>
</li>
<li> <p><code>var.par=c()</code> when <code>var.prior="Unif"</code>.
</p>
</li>
<li> <p><code>var.par</code> is a data frame with 2 columns, one indicates the values of <code class="reqn">\sigma^2</code> and the other one indicates the values of <code class="reqn">\pi(\sigma^2)</code> when <code>var.prior="Table"</code>.
</p>
</li>
<li> <p><code>var.par</code> doesn't need to be given when <code>var.prior="Invwishart"</code>.
</p>
</li></ul>

<p>See also argument <code>var.prior</code>.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_var2.par">var2.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the second variance component. If not given, function will copy the setting for the first variance component. The definition of the priors is the same as for <code>var.par</code>. 
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_cor.par">cor.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the correlation. See also <code>examples</code>.
</p>

<ul>
<li> <p><code>cor.par=c(mean, variance)</code> when <code>cor.prior="normal"</code>.
</p>
</li>
<li> <p><code>cor.par=c(strategy, rho0, omega, u1, a1, u2, a2)</code> when <code>cor.prior="PC"</code>.
</p>
</li>
<li> <p><code>cor.par=c(a, b)</code> when <code>var.prior="beta"</code>.
</p>
</li>
<li> <p><code>cor.par</code> is a data frame with 2 columns, one indicates the values of <code class="reqn">\rho</code> and the other one indicates the values of <code class="reqn">\pi(\rho)</code> when <code>cor.prior="Table"</code>.
</p>
</li>
<li> <p><code>cor.par</code> doesn't need to be given when <code>cor.prior="Invwishart"</code>.
</p>
</li></ul>

<p>See also argument <code>cor.prior</code>.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_wishart.par">wishart.par</code></td>
<td>

<p>A numerical vector specifying the parameter of the prior density for the covariance matrix. <code>wishart.par</code> must be given and <code>wishart.par=c(nu, R11, R22, R12)</code> when any of <code>var.prior</code>, <code>var2.prior</code> or <code>cor.prior</code> is <code>"Invwishart"</code>. See also <code>examples</code>.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_init">init</code></td>
<td>

<p>A numerical vector specifying the initial value of the first variance, the second variance and correlation.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_link">link</code></td>
<td>

<p>A string specifying the link function used in the model. Options are &quot;logit&quot;, &quot;probit&quot; and &quot;cloglog&quot;.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_quantiles">quantiles</code></td>
<td>

<p>A vector of quantiles, p(0), p(1),... to compute for each posterior marginal. The function returns, for each posterior marginal, the values x(0), x(1),... such that </p>
<p style="text-align: center;"><code class="reqn">Prob(X&lt;x)=p.</code>
</p>

<p>The default value are c(0.025, 0.5, 0.975). Not matter what other values are going to be given, the estimates for these 3 quantiles are always returned.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_verbose">verbose</code></td>
<td>

<p>Boolean (default:FALSE) indicating whether the program should run in a verbose model.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_modality">modality</code></td>
<td>

<p>A string specifying the modality variable, which is a categorical variable, such as test threshold. Default value is NULL. See also <code>examples</code>. At the moment, only one categorical covariate variable can be used in the model.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_covariates">covariates</code></td>
<td>

<p>A vector, which could be either the name of columns or the number of columns, specifying the continuous covariates variables, such as disease prevalence or average individual patients status of each study. Default value is NULL. See also <code>examples</code>.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_nsample">nsample</code></td>
<td>

<p>A numerical value specifying the number of posterior samples, default is 5000. The posterior samples are used to compute the marginals and estimates values of non-linear functions, such as log radios and diagnostic odds radios. If <code>nsample</code> is given, <code>summary.summarized.statistics</code>, <code>summary.fitted.LRpos</code>, <code>summary.fitted.LRneg</code>, <code>summary.fitted.DOR</code> and samples of <code class="reqn">E(se)</code>, <code class="reqn">E(sp)</code>, <code class="reqn">E(1-se)</code> and <code class="reqn">E(1-sp)</code> will be returned.
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_num.threads">num.threads</code></td>
<td>

<p>Maximum number of threads the inla-program will use. xFor Windows this defaults to 1, otherwise its defaults to NULL (for which the system takes over control).
</p>
</td></tr>
<tr><td><code id="meta4diag_+3A_seed">seed</code></td>
<td>

<p>A numerical value specifying the random seed to control the RNG for generating posterior samples if nsample &gt; 0. If you want reproducible results, you ALSO need to control the seed for the RNG in R by controlling the variable .Random.seed or using the function set.seed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate model has two levels, in the first level, the observed number of individuals in a specific group in a 2 by 2 table is binomial distributed, for example, the numbers of individuals in the group of true positive and true negative of a study <code class="reqn">i</code> are modelled jointly,
</p>
<p style="text-align: center;"><code class="reqn">TP_{i} | Se_{i} \sim Binomial(TP_{i}+ FN_{i},Se_{i})</code>
</p>

<p style="text-align: center;"><code class="reqn">TN_{i} | Sp_{i} \sim Binomial(TN_{i}+ FP_{i},Sp_{i})</code>
</p>

<p>In the second level, two transformed accuracies with some link function (see argument <code>link</code>) are bivariate Gaussian distributed, continuous with the previous example,
</p>
<p style="text-align: center;"><code class="reqn">g(Se_{i}) = \mu + V_{i}\alpha + \phi_{i}</code>
</p>

<p style="text-align: center;"><code class="reqn">g(Sp_{i}) = \nu + U_{i}\beta + \psi_{i}</code>
</p>

<p>where <code class="reqn">\phi_{i}</code> and <code class="reqn">\psi_{i}</code> are bivariate Gaussian distributed with mean 0 and covariance matrix <code class="reqn">\Sigma</code>. The <code class="reqn">se</code> and <code class="reqn">sp</code> in the example could be changed to <code class="reqn">se</code> and <code class="reqn">(1-sp)</code>, <code class="reqn">(1-se)</code> and <code class="reqn">sp</code> or <code class="reqn">(1-se)</code> and <code class="reqn">(1-sp)</code>, see argument <code>model.type</code>.
</p>
<p>The function <code>meta4diag()</code> depends on four internal functions which are also given in the <span class="pkg">meta4diag</span> package in order to flexibly implement a list of dataset with the same prior setting. The four internal functions are <code>makeData()</code>, <code>makePriors()</code>, <code>runModel()</code> and <code>makeObject()</code>. Details can be seen the corresponding documentations and examples.
</p>
<p>After running the function <code>meta4diag()</code>, a <code>meta4diag</code> object will be returned which contains various estimated results for later analysis, such as the posterior marginals, estimated value, standard deviations and the coresponding quaniles of the accuracies. See <code>Values</code>.
</p>


<h3>Value</h3>

<p><code>meta4diag</code> returns a <code>meta4diag</code> object with components: 
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The provided input data.</p>
</td></tr>
<tr><td><code>outdata</code></td>
<td>
<p>The internal data that could be used in <span class="pkg">INLA</span> from function <code>makeData()</code>.</p>
</td></tr>
<tr><td><code>priors.density</code></td>
<td>
<p>Prior distributions for the variance components and correlation from function <code>makePriors()</code>.</p>
</td></tr>
<tr><td><code>names.fitted</code></td>
<td>
<p>Names of the jointly modelled accuracies in the model. For example, se and sp or (1-se) and sp.</p>
</td></tr> 
<tr><td><code>cpu.used</code></td>
<td>
<p>The cpu time used for running the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>summary.fixed</code></td>
<td>
<p>Matrix containing the mean and standard deviation (plus, possibly quantiles) of the fixed effects of the model.</p>
</td></tr>
<tr><td><code>marginals.fixed</code></td>
<td>
<p>A list containing the posterior marginal densities of the fixed effects of the model.</p>
</td></tr>
<tr><td><code>summary.expected.(...).accuracy</code></td>
<td>
<p>Matrix containing the mean and standard deviation (plus, possibly quantiles) of the mean of accuracies transformed with the link function, i.e. E(g(Se)), E(g(Sp)), E(g(1-Se)) and E(g(1-Sp)). Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>, i.e. if link function is &quot;logit&quot;, the full name of this output is &quot;summary.expected.logit.accuracy&quot;.</p>
</td></tr>
<tr><td><code>marginals.expected.(...).accuracy</code></td>
<td>
<p>A list containing the posterior marginal densities of the mean of accuracies transformed with the link function, i.e. E(g(Se)), E(g(Sp)), E(g(1-Se)) and E(g(1-Sp)). Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>, i.e. if link function is &quot;logit&quot;, the full name of this output is &quot;marginals.expected.logit.accuracy&quot;.</p>
</td></tr>
<tr><td><code>summary.expected.accuracy</code></td>
<td>
<p>Matrix containing the mean and standard deviation (plus, possibly quantiles) of the mean of the accuracies, i.e.  E(Se), E(Sp), E(1-Se) and E(1-Sp).</p>
</td></tr>
<tr><td><code>marginals.expected.accuracy</code></td>
<td>
<p>A list containing the posterior marginal densities of of the mean of the accuracies, i.e.  E(Se), E(Sp), E(1-Se) and E(1-Sp).</p>
</td></tr>
<tr><td><code>summary.hyperpar</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of the hyperparameters of the model.</p>
</td></tr>
<tr><td><code>marginals.hyperpar</code></td>
<td>
<p>A list containing the posterior marginal densities of the hyperparameters of the model.</p>
</td></tr> 
<tr><td><code>correlation.expected.(...).accuracy</code></td>
<td>
<p>A correlation matrix between the mean of the accuracies transformed with the link function. Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>.</p>
</td></tr> 
<tr><td><code>covariance.expected.(...).accuracy</code></td>
<td>
<p>A covariance matrix between the mean of the accuracies transformed with the link function. Dynamic name for this output. (...) indicates the name of link function used in <code>runModel()</code>.</p>
</td></tr>
<tr><td><code>summary.predictor.(...)</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of the linear predictors one transformed accuracy in the model. The accuracy type depends on the model type. See argument <code>model.type</code>. For example, the possible accuracy type could be <code class="reqn">g(se)</code>, <code class="reqn">g(sp)</code>, <code class="reqn">(se)</code> or <code class="reqn">(sp)</code>, where <code class="reqn">g()</code> is the link function.</p>
</td></tr>
<tr><td><code>marginals.predictor.(...)</code></td>
<td>
<p>A list containing the posterior marginals of the linear predictors of one transformed accuracy in the model. The accuracy type depends on the model type. See argument <code>model.type</code>. For example, the possible accuracy type could be <code class="reqn">g(se)</code>, <code class="reqn">g(sp)</code>, <code class="reqn">(se)</code> or <code class="reqn">(sp)</code>, where <code class="reqn">g()</code> is the link function.</p>
</td></tr>
<tr><td><code>misc</code></td>
<td>
<p>Some other settings that maybe useful retruned by <span class="pkg">meta4diag</span>.</p>
</td></tr>
<tr><td><code>dic</code></td>
<td>
<p>The deviance information criteria and effective number of parameters.</p>
</td></tr>
<tr><td><code>cpo</code></td>
<td>
<p>A list of three elements: <code>cpo$cpo</code> are the values of the conditional predictive ordinate (CPO), <code>cpo$pit</code> are the values of the 
probability integral transform (PIT) and <code>cpo$failure</code> 
indicates whether some assumptions are violated. In short, if 
cpo$failure[i] &gt; 0 then some assumption is violated, the higher the 
value (maximum 1) the more seriously.</p>
</td></tr>
<tr><td><code>waic</code></td>
<td>
<p>A list of two elements: <code>waic$waic</code> is the Watanabe-Akaike information criteria,  and <code>waic$p.eff</code> is the estimated effective number of parameters.</p>
</td></tr>
<tr><td><code>mlik</code></td>
<td>
<p>The log marginal likelihood of the model</p>
</td></tr>
<tr><td><code>inla.result</code></td>
<td>
<p>A <code>INLA</code> object that from function <code>runModel()</code> which implements INLA.</p>
</td></tr>
<tr><td><code>samples.fixed</code></td>
<td>
<p>A matrix of the fixed effects samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.hyperpar</code></td>
<td>
<p>A matrix of the hyperparameter samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.overall.Se</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of overall sensitivity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.overall.Sp</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of overall specificity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.overall.statistics</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of mean positive and negative likelihood ratios and mean diagnostic odds ratios if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.study.specific.Se</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of study specific sensitivity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>samples.study.specific.Sp</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of study specific specificity samples if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LRpos</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of positive likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LRneg</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of negative likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.DOR</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of diagnostic odds ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.RD</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of risk difference for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LDOR</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of log diagnostic odds ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LLRpos</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of log positive likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
<tr><td><code>summary.study.specific.LLRneg</code></td>
<td>
<p>A matrix containing the mean and sd (plus, possibly quantiles) of log negative likelihood ratios for each study if <code>nsample</code> is given.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>References</h3>

<p><cite>Rue H., Martino S, and Chopin N. (2009). Approximate
Bayesian Inference for Latent Gaussian Models Using Integrated Nested
Laplace Approximations. <em>Journal of the Royal Statistical Society B</em>
<b>71</b>: 319&ndash;392. (www.r-inla.org)</cite>
</p>
<p><cite>Simpson DP, Martins TG, Riebler A, Fuglstad GA, Rue H, Sorbye SH (2014) Penalised Model Component Complexity: A principled, Practical Approach to Constructing Priors. <em>Arxiv e-prints. 1403.4630</em></cite>
</p>
<p><cite>Guo, J., Riebler, A. and Rue H. (2017) Bayesian bivariate meta-analysis of diagnostic test studies with interpretable priors. <em>Statistics in Medicine</em>
<b>36(19)</b>: 3039&ndash;3058.</cite>
</p>


<h3>See Also</h3>

<p><code>makeData, makePrior, runModel, forest, SROC, crosshair.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  meta4diag(data = Catheter, model.type = 1, var.prior = "invgamma", cor.prior = "normal", 
    var.par = c(0.25, 0.025), cor.par = c(0, 5), init = c(0.01, 0.01, 0), 
    link = "logit", quantiles = c(0.025, 0.5, 0.975), verbose = FALSE, covariates = NULL, 
    nsample = FALSE)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='meta4diagGUI'>
A graphic user interface for meta4diag.
</h2><span id='topic+meta4diagGUI'></span>

<h3>Description</h3>

<p>A graphic user interface for meta4diag which is fully interactive but still provides full functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	meta4diagGUI()
</code></pre>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>References</h3>

<p>Havard Rue, Sara Martino, and Nicholas Chopin (2009). Approximate
Bayesian Inference for Latent Gaussian Models Using Integrated Nested
Laplace Approximations. Journal of the Royal Statistical Society B,
71, 319-392. (www.r-inla.org)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meta4diag">meta4diag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: meta4diagGUI()
</code></pre>

<hr>
<h2 id='plot'>Default meta4diag plotting.</h2><span id='topic+plot.meta4diag'></span>

<h3>Description</h3>

<p>Takes a <code>meta4diag</code> object produced by <code>meta4diag()</code> and plot the posterior marginals (possibly with underlying priors) for hyperparameters and fixed effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'meta4diag'
plot(x, var.type="var1", add=FALSE, overlay.prior = TRUE, 
      save = FALSE, width=5, height=5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>

<p>A <code>meta4diag</code> object.
</p>
</td></tr>
<tr><td><code id="plot_+3A_var.type">var.type</code></td>
<td>

<p>Variable type that is of interest. Options are &quot;var1&quot;, &quot;var2&quot;, &quot;rho&quot; and names for fixed effects, which can be found after calling <code>summary()</code> function.
</p>
</td></tr>
<tr><td><code id="plot_+3A_add">add</code></td>
<td>

<p>If add is TRUE, the plots are added to an existing plot, otherwise a new plot is created.
</p>
</td></tr>
<tr><td><code id="plot_+3A_overlay.prior">overlay.prior</code></td>
<td>

<p>Boolean to indicate whether the prior will be plotted overlay or not only for hyperparameters.
</p>
</td></tr>
<tr><td><code id="plot_+3A_save">save</code></td>
<td>

<p>If save is TRUE, the plots are saved (pdf format) automatically in the working directory. save could also be a file name, i.e. <code>save="plot1.eps"</code>, a file with name plot1 and eps format will be saved in the working directory.
</p>
</td></tr>
<tr><td><code id="plot_+3A_width">width</code></td>
<td>

<p>The width when used for saving the plot, unit of inches is used.
</p>
</td></tr>
<tr><td><code id="plot_+3A_height">height</code></td>
<td>

<p>The height when used for saving the plot, unit of inches is used.
</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods, such as graphical parameters (see <a href="graphics.html#topic+par">par</a>) such as &quot;main&quot;, &quot;sub&quot;, &quot;xlab&quot;, &quot;ylab&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior marginal distribution possibly with underlying prior distribution is plotted.
</p>


<h3>Value</h3>

<p>Besides plotting, the function returns an invisible NULL.
</p>


<h3>Author(s)</h3>

<p>Jingyi Guo <a href="mailto:jingyi.guo@math.ntnu.no">jingyi.guo@math.ntnu.no</a> and Andrea Riebler <a href="mailto:andrea.riebler@math.ntnu.no">andrea.riebler@math.ntnu.no</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meta4diag">meta4diag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter)
  plot(res, var.type="var1")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='print'>print meta4diag object.</h2><span id='topic+print'></span><span id='topic+print.meta4diag'></span><span id='topic+print.summary.meta4diag'></span><span id='topic+print.fitted.meta4diag'></span>

<h3>Description</h3>

<p>Takes an <code>meta4diag</code> object which is obtained by function <code>meta4diag()</code> and print the model and data information such as model type used in the model, number of studies in the dataset and the name of covariates which are contained in the model. The variable type used in <code>plot.meta4diag</code> can be found here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'meta4diag'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>

<p>A <code>meta4diag</code> object.
</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic model setting and dataset information are printed.
</p>


<h3>Value</h3>

<p>The return value is invisible NULL.</p>


<h3>Author(s)</h3>

<p>Jingyi Guo <a href="mailto:jingyi.guo@math.ntnu.no">jingyi.guo@math.ntnu.no</a> and Andrea Riebler <a href="mailto:andrea.riebler@math.ntnu.no">andrea.riebler@math.ntnu.no</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter)
  print(res)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='runModel'>Run the bivariate model.</h2><span id='topic+runModel'></span>

<h3>Description</h3>

<p>Run the bivariate model with INLA. This function is used within the main function <code>meta4diag()</code> and can also be used as a separate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runModel(outdata, outpriors, link = "logit", 
  quantiles = c(0.025, 0.5, 0.975), verbose = FALSE, num.threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runModel_+3A_outdata">outdata</code></td>
<td>

<p>A data file for internal use.
</p>
</td></tr>
<tr><td><code id="runModel_+3A_outpriors">outpriors</code></td>
<td>

<p>A list of prior settings prepared for internal use, see <code>makePriors</code>.
</p>
</td></tr>
<tr><td><code id="runModel_+3A_link">link</code></td>
<td>

<p>A string specifying the link function used in the model. Options are &quot;logit&quot;, &quot;probit&quot; and &quot;cloglog&quot;.
</p>
</td></tr>
<tr><td><code id="runModel_+3A_quantiles">quantiles</code></td>
<td>

<p>A vector of quantiles, p(0), p(1),... to compute for each posterior marginal. The function returns, for each posterior marginal, the values x(0), x(1),... such that </p>
<p style="text-align: center;"><code class="reqn">Prob(X&lt;x)=p.</code>
</p>

<p>The default value are c(0.025, 0.5, 0.975). Not matter what other values are going to be given, the estimates for these 3 quantiles are always returned.
</p>
</td></tr>
<tr><td><code id="runModel_+3A_verbose">verbose</code></td>
<td>

<p>Boolean (default:FALSE) indicating whether the program should run in a verbose mode.
</p>
</td></tr>
<tr><td><code id="runModel_+3A_num.threads">num.threads</code></td>
<td>

<p>Maximum number of threads the inla-program will use. xFor Windows this defaults to 1, otherwise its defaults to NULL (for which the system takes over control).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>INLA</code> object which will be used into function <code>makeObject()</code>.
</p>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>References</h3>

<p>Havard Rue, Sara Martino, and Nicholas Chopin (2009). Approximate
Bayesian Inference for Latent Gaussian Models Using Integrated Nested
Laplace Approximations. Journal of the Royal Statistical Society B,
71, 319-392. (www.r-inla.org)  
</p>


<h3>See Also</h3>

<p><code>makeData, makePriors, makeObject, meta4diag, inla</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)) {
   require("INLA", quietly = TRUE)
   data(Catheter)

   outdata = makeData(data=Catheter,model.type=1,covariates="type")
   outpriors = makePriors(var.prior = "invgamma", cor.prior = "normal", 
                          var.par = c(0.25, 0.025), cor.par = c(0, 5))
   runModel(outdata, outpriors, link = "logit", 
            quantiles = c(0.025, 0.5, 0.975), verbose = FALSE)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='Scheidler'>Scheidler dataset.</h2><span id='topic+Scheidler'></span>

<h3>Description</h3>

<p>The dataset is used to compare the utility of three types of diagnostic imaging to detect lymph node metastases in patients with cervical cancer: lymphangiography (LAG), computed tomography (CT) and magnetic resonance (MR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Scheidler)</code></pre>


<h3>Format</h3>

<p>A data frame with 44 rows and 6 columns. Each row provides data for one study. The columns are &quot;studynames&quot; indicates the name of studies, &quot;modality&quot; indicates which diagnostic study that the observation is conducted from and is considered as a covariate, &quot;TP&quot;, &quot;FP&quot;, &quot;FN&quot; and &quot;TN&quot; are the number of true positive, false positive, false negative and true negative, respectively.
</p>


<h3>References</h3>

<p>Scheidler J, Hricak H, Kyle K Y, et al. Radiological evaluation of lymph node metastases in patients with cervical cancer: a meta-analysis. Jama, 1997, 278(13): 1096-1101.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Scheidler)
</code></pre>

<hr>
<h2 id='SROC'>
A standard summary receiver operating chracteristic plot.
</h2><span id='topic+SROC'></span><span id='topic+SROC.meta4diag'></span>

<h3>Description</h3>

<p>Takes a <code>meta4diag</code> object produced by <code>meta4diag()</code> and makes the standard summary receiver operating chracteristic plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SROC(x,...)
## S3 method for class 'meta4diag'
SROC(x, sroc.type=1, est.type="mean", sp.cex=1.5,sp.pch=8,sp.col="red",
              dataShow="o", data.col="#FF0000", data.cex="scaled", data.pch=1, 
              lineShow=T, line.lty=1, line.lwd=2, line.col="black",
              crShow=T, cr.lty=2, cr.lwd=1.5, cr.col="blue",
              prShow=T, pr.lty=3, pr.lwd=1,  pr.col="darkgray",
              dataFit = T, add=FALSE, main="", xlim, ylim,
              legend=F,legend.cex = 0.7,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SROC_+3A_x">x</code></td>
<td>

<p>A <code>meta4diag</code> object.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_sroc.type">sroc.type</code></td>
<td>

<p>A numerical value specifying the function used to make SROC line. Options are 1, 2, 3, 4, 5. When <code>sroc.type=1</code>, the SROC line is plotted as &quot; The regression line 1&quot; according to Arends et al.(2008),
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \rho\sqrt{\frac{\sigma_{\mu}^2}{\sigma_{\nu}^2}}(x-\nu)</code>
</p>

<p>When <code>sroc.type=2</code>, the SROC line is plotted as &quot;The major axis method&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \frac{\sigma_{\mu}^2-\sigma_{\nu}^2\pm\sqrt{(\sigma_{\mu}^2-\sigma_{\nu}^2)^2+4\rho^2\sigma_{\mu}^2\sigma_{\nu}^2}}{2\rho\sqrt{\sigma_{\mu}^2\sigma_{\nu}^2}}(x-\nu)+\mu</code>
</p>

<p>When <code>sroc.type=3</code>, the SROC line is plotted as &quot;The Moses and Littenberg's regression line&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \frac{\sigma_{\mu}^2 + \rho\sqrt{\sigma_{\mu}^2\sigma_{\nu}^2}}{\sigma_{\nu}^2+\rho\sqrt{\sigma_{\mu}^2\sigma_{\nu}^2}}(x-\nu)+\mu</code>
</p>

<p>When <code>sroc.type=4</code>, the SROC line is plotted as &quot;The regression line 2&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \frac{1}{\rho}\sqrt(\frac{\sigma_{\mu}^2}{\sigma_{\nu}^2})(x-\nu)</code>
</p>

<p>When <code>sroc.type=5</code>, the SROC line is plotted as &quot;The Rutter and Gatsonis's SROC curve&quot;,
</p>
<p style="text-align: center;"><code class="reqn">y = \mu + \sqrt{\frac{\sigma_{\mu}^2}{\sigma_{\nu}^2}}(x-\nu)</code>
</p>

</td></tr>
<tr><td><code id="SROC_+3A_est.type">est.type</code></td>
<td>

<p>The estimates type used to make SROC plot. Options are &quot;mean&quot; and &quot;median&quot;.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_sp.cex">sp.cex</code></td>
<td>

<p>Summary points size. The summary points are mean or median of sensitivities and specificities of all sudies.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_sp.pch">sp.pch</code></td>
<td>

<p>Point symbols of summary points.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_sp.col">sp.col</code></td>
<td>

<p>Color of summary points.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_datashow">dataShow</code></td>
<td>

<p>A character indicating whether the original dataset or the fitted dataset is shown or not. If is &quot;o&quot;, the original data will be plotted. If is &quot;f&quot;, the fitted data will be plotted. No dataset will be plotted if <code>dataShow</code> is not &quot;o&quot; or &quot;f&quot;. 
</p>
</td></tr>
<tr><td><code id="SROC_+3A_data.col">data.col</code></td>
<td>

<p>Color of orignal data bubbles.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_data.cex">data.cex</code></td>
<td>

<p>A string or a numerical value indicating the size of the plotted dataset points. If is &quot;bubble&quot; or &quot;scaled&quot;, the size of the data points are proportional to the total number of individuals in each study. 
</p>
</td></tr>
<tr><td><code id="SROC_+3A_data.pch">data.pch</code></td>
<td>

<p>A string or a numerical value indicating the symbol of the plotted dataset points.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_lineshow">lineShow</code></td>
<td>

<p>Boolean indicating whether the SROC line is shown or not.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_line.lty">line.lty</code></td>
<td>

<p>SROC line type.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_line.lwd">line.lwd</code></td>
<td>

<p>SROC line width.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_line.col">line.col</code></td>
<td>

<p>Color for the SROC line.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_crshow">crShow</code></td>
<td>

<p>Boolean indicating whether the confidence region is shown or not.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_cr.lty">cr.lty</code></td>
<td>

<p>Confidence region line width.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_cr.lwd">cr.lwd</code></td>
<td>

<p>Confidence region line width.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_cr.col">cr.col</code></td>
<td>

<p>Color for the confidence region line.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_prshow">prShow</code></td>
<td>

<p>Boolean indicating whether the prediction region is shown or not.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_pr.lty">pr.lty</code></td>
<td>

<p>Prediction region line type.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_pr.lwd">pr.lwd</code></td>
<td>

<p>Prediciton region line width.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_pr.col">pr.col</code></td>
<td>

<p>Color for the prediction region line.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_datafit">dataFit</code></td>
<td>

<p>Boolean indicating the length SROC line. Either plotted from -1 to 1, or fit the data.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_add">add</code></td>
<td>

<p>If add is TRUE, the plots are added to an existing plot, otherwise a new plot is created.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_main">main</code></td>
<td>

<p>A overall title for the plot.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_xlim">xlim</code></td>
<td>

<p>A numeric value, giving the x coordinates ranges.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_ylim">ylim</code></td>
<td>

<p>A numeric value, giving the y coordinates ranges.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_legend">legend</code></td>
<td>

<p>Boolean indicating whether the legend is shown or not. Can also be a string indicating the position to show the legend. Options are &quot;left&quot;, &quot;bottom&quot; and &quot;right&quot;.
</p>
</td></tr>
<tr><td><code id="SROC_+3A_legend.cex">legend.cex</code></td>
<td>

<p>Lengend size. 
</p>
</td></tr>
<tr><td><code id="SROC_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SROC()</code> returns a plot of the true positive rate against the false positive rate (1-specificity) (ROC space) for the different possible cutpoints of a diagnostic test. It shows the tradeoff between sensitivity and specificity (any increase in sensitivity will be accompanied by a decrease in specificity). The closer the curve follows the left-hand border and then the top border of the ROC space, the more accurate the test. The closer the curve comes to the 45-degree diagonal of the ROC space, the less accurate the test. The area under the curve is a measure of text accuracy. Summary points, summary receiver operating characteristic line, confidence region and prediction region of the summary points are plotted.
</p>
<p>The function <code>SROC()</code> gives the user flexibility to control the plots.
</p>


<h3>Value</h3>

<p>The return value is a list of the files created (if any).</p>


<h3>Author(s)</h3>

<p>Jingyi Guo and Andrea Riebler 
</p>


<h3>References</h3>

<p>Chappell F, Raab G, Wardlaw J (2009). &quot;When are Summary ROC Curves Appropriate for Diagnostic Meta-analyses?&quot; Statistics in Medicine, 28(21), 2653-2668. 
</p>
<p>Arends et al.(2008) &quot;Bivariate random effects meta-analysis of ROC curves.&quot; Medical Decision Making, 28(5), 621-638.
</p>


<h3>See Also</h3>

<p><code>meta4diag</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter)
  SROC(res, est.type="mean")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='summary'>Provide summary information.</h2><span id='topic+summary'></span><span id='topic+summary.meta4diag'></span>

<h3>Description</h3>

<p>Takes a fitted <code>meta4diag</code> object produced by <code>meta4diag()</code> and produces a summary from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'meta4diag'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>a fitted <code>meta4diag</code> object as produced by <code>meta4diag()</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p> other arguments may be useful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior mean and standard deviation (together with quantiles) are printed for the fixed effects in the model.
</p>
<p>For the random effects the function <code>summary()</code> prints the
posterior mean and standard deviations of the hyperparameters.
</p>


<h3>Value</h3>

<p><code>summary.meta4diag</code> returns a list with components: 
</p>
<table>
<tr><td><code>cpu.used</code></td>
<td>
<p>The cpu time used to fit the corresponding model and data.</p>
</td></tr>
<tr><td><code>summary.fixed</code></td>
<td>
<p>The posterior mean and standard deviation (together with quantiles) for the fixed effects.</p>
</td></tr>
<tr><td><code>summary.expected.g</code></td>
<td>
<p>The posterior mean and standard deviation (together with quantiles) for the summarized fixed effects.</p>
</td></tr>
<tr><td><code>summary.hyperpar</code></td>
<td>
<p>The posterior mean and standard deviation (together with quantiles) for model hyperparameters.</p>
</td></tr>
<tr><td><code>mlik</code></td>
<td>
<p>The marginal log-likelihood of the model.</p>
</td></tr> 
<tr><td><code>var.type</code></td>
<td>
<p>The variables type used in the <code>plot()</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jingyi Guo <a href="mailto:jingyi.guo@math.ntnu.no">jingyi.guo@math.ntnu.no</a> and Andrea Riebler <a href="mailto:andrea.riebler@math.ntnu.no">andrea.riebler@math.ntnu.no</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code>,<code><a href="#topic+meta4diag">meta4diag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(requireNamespace("INLA", quietly = TRUE)){
  require("INLA", quietly = TRUE)
  data(Catheter)
  res &lt;- meta4diag(data = Catheter)
  summary(res)
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='table_cor'>The example table prior for correlation.</h2><span id='topic+table_cor'></span>

<h3>Description</h3>

<p>An example of a table prior density for the correlation parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(table_cor)</code></pre>


<h3>Format</h3>

<p>A data frame with 2 columns named &quot;x&quot; and &quot;y&quot;. The first column indicates the value of correlation points, usually in [-1,1]. The second column indicates the density of the corresponding points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(table_cor)
  plot(table_cor)
</code></pre>

<hr>
<h2 id='table_var'>The example table prior for variance.</h2><span id='topic+table_var'></span>

<h3>Description</h3>

<p>An example of a table prior density for the variance parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(table_var)</code></pre>


<h3>Format</h3>

<p>A data frame with 2 columns named &quot;x&quot; and &quot;y&quot;. The first column indicates the value of variance points, usually in [0, some positive value]. The second column indicates the density of the corresponding points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(table_var)
  plot(table_var)
</code></pre>

<hr>
<h2 id='Telomerase'>Telomerase dataset.</h2><span id='topic+Telomerase'></span>

<h3>Description</h3>

<p>The dataset contains 10 studies from a meta-analysis that uses the telomerase marker for the diagnosis of bladder cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Telomerase)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 rows and 5 columns. Each row provides data for one study. The columns are &quot;studynames&quot; indicates the name of studies, &quot;TP&quot;, &quot;FP&quot;, &quot;FN&quot; and &quot;TN&quot; which are the number of true positive, false positive, false negative and true negative, respectively.
</p>


<h3>References</h3>

<p>Glas AS, Roos D, Deutekom M, Zwinderman AH, Bossuyt PM, Kurth KH (2003). &quot;Tumor Markers in the Diagnosis of Primary Bladder Cancer. A Systematic Review.&quot; The Journal of Urology, 169(6), 1975-1982.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Telomerase)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
