<!DOCTYPE html><html><head><title>Help for package dplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#across'><p>Apply a function (or functions) across multiple columns</p></a></li>
<li><a href='#add_rownames'><p>Convert row names to an explicit variable.</p></a></li>
<li><a href='#all_equal'><p>Flexible equality comparison for data frames</p></a></li>
<li><a href='#all_vars'><p>Apply predicate to all variables</p></a></li>
<li><a href='#args_by'><p>Helper for consistent documentation of <code>.by</code></p></a></li>
<li><a href='#arrange'><p>Order rows using column values</p></a></li>
<li><a href='#arrange_all'><p>Arrange rows by a selection of variables</p></a></li>
<li><a href='#auto_copy'><p>Copy tables to same source, if necessary</p></a></li>
<li><a href='#backend_dbplyr'><p>Database and SQL generics.</p></a></li>
<li><a href='#band_members'><p>Band membership</p></a></li>
<li><a href='#between'><p>Detect where values fall in a specified range</p></a></li>
<li><a href='#bind_cols'><p>Bind multiple data frames by column</p></a></li>
<li><a href='#bind_rows'><p>Bind multiple data frames by row</p></a></li>
<li><a href='#c_across'><p>Combine values from multiple columns</p></a></li>
<li><a href='#case_match'><p>A general vectorised <code>switch()</code></p></a></li>
<li><a href='#case_when'><p>A general vectorised if-else</p></a></li>
<li><a href='#check_dbplyr'><p>dbplyr compatibility functions</p></a></li>
<li><a href='#coalesce'><p>Find the first non-missing element</p></a></li>
<li><a href='#combine'><p>Combine vectors</p></a></li>
<li><a href='#common_by'><p>Extract out common by variables</p></a></li>
<li><a href='#compute'><p>Force computation of a database query</p></a></li>
<li><a href='#consecutive_id'><p>Generate a unique identifier for consecutive combinations</p></a></li>
<li><a href='#context'><p>Information about the &quot;current&quot; group or variable</p></a></li>
<li><a href='#copy_to'><p>Copy a local data frame to a remote src</p></a></li>
<li><a href='#count'><p>Count the observations in each group</p></a></li>
<li><a href='#cross_join'><p>Cross join</p></a></li>
<li><a href='#cumall'><p>Cumulativate versions of any, all, and mean</p></a></li>
<li><a href='#defunct'><p>Defunct functions</p></a></li>
<li><a href='#deprec-context'><p>Information about the &quot;current&quot; group or variable</p></a></li>
<li><a href='#desc'><p>Descending order</p></a></li>
<li><a href='#dim_desc'><p>Describing dimensions</p></a></li>
<li><a href='#distinct'><p>Keep distinct/unique rows</p></a></li>
<li><a href='#distinct_all'><p>Select distinct rows by a selection of variables</p></a></li>
<li><a href='#distinct_prepare'><p>Same basic philosophy as group_by_prepare(): lazy_dots comes in, list of data and</p>
vars (character vector) comes out.</a></li>
<li><a href='#do'><p>Do anything</p></a></li>
<li><a href='#dplyr_by'><p>Per-operation grouping with <code>.by</code>/<code>by</code></p></a></li>
<li><a href='#dplyr_data_masking'><p>Data-masking</p></a></li>
<li><a href='#dplyr_extending'><p>Extending dplyr with new data frame subclasses</p></a></li>
<li><a href='#dplyr_tidy_select'><p>Argument type: tidy-select</p></a></li>
<li><a href='#dplyr-locale'><p>Locale used by <code>arrange()</code></p></a></li>
<li><a href='#dplyr-package'><p>dplyr: A Grammar of Data Manipulation</p></a></li>
<li><a href='#explain'><p>Explain details of a tbl</p></a></li>
<li><a href='#filter'><p>Keep rows that match a condition</p></a></li>
<li><a href='#filter_all'><p>Filter within a selection of variables</p></a></li>
<li><a href='#filter-joins'><p>Filtering joins</p></a></li>
<li><a href='#funs'><p>Create a list of function calls</p></a></li>
<li><a href='#glimpse'><p>Get a glimpse of your data</p></a></li>
<li><a href='#group_by'><p>Group by one or more variables</p></a></li>
<li><a href='#group_by_all'><p>Group by a selection of variables</p></a></li>
<li><a href='#group_by_drop_default'><p>Default value for .drop argument of group_by</p></a></li>
<li><a href='#group_cols'><p>Select grouping variables</p></a></li>
<li><a href='#group_data'><p>Grouping metadata</p></a></li>
<li><a href='#group_map'><p>Apply a function to each group</p></a></li>
<li><a href='#group_nest'><p>Nest a tibble using a grouping specification</p></a></li>
<li><a href='#group_split'><p>Split data frame by groups</p></a></li>
<li><a href='#group_trim'><p>Trim grouping structure</p></a></li>
<li><a href='#grouped_df'><p>A grouped data frame.</p></a></li>
<li><a href='#ident'><p>Flag a character vector as SQL identifiers</p></a></li>
<li><a href='#if_else'><p>Vectorised if-else</p></a></li>
<li><a href='#join_by'><p>Join specifications</p></a></li>
<li><a href='#last_dplyr_warnings'><p>Show warnings from the last command</p></a></li>
<li><a href='#lead-lag'><p>Compute lagged or leading values</p></a></li>
<li><a href='#make_tbl'><p>Create a &quot;tbl&quot; object</p></a></li>
<li><a href='#mutate'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#mutate_all'><p>Mutate multiple columns</p></a></li>
<li><a href='#mutate-joins'><p>Mutating joins</p></a></li>
<li><a href='#n_distinct'><p>Count unique combinations</p></a></li>
<li><a href='#na_if'><p>Convert values to <code>NA</code></p></a></li>
<li><a href='#near'><p>Compare two numeric vectors</p></a></li>
<li><a href='#nest_by'><p>Nest by one or more variables</p></a></li>
<li><a href='#nest_join'><p>Nest join</p></a></li>
<li><a href='#new_grouped_df'><p>Low-level construction and validation for the grouped_df and rowwise_df classes</p></a></li>
<li><a href='#nth'><p>Extract the first, last, or nth value from a vector</p></a></li>
<li><a href='#ntile'><p>Bucket a numeric vector into <code>n</code> groups</p></a></li>
<li><a href='#order_by'><p>A helper function for ordering window function output</p></a></li>
<li><a href='#percent_rank'><p>Proportional ranking functions</p></a></li>
<li><a href='#pick'><p>Select a subset of columns</p></a></li>
<li><a href='#progress_estimated'><p>Progress bar with estimated time.</p></a></li>
<li><a href='#pull'><p>Extract a single column</p></a></li>
<li><a href='#recode'><p>Recode values</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reframe'><p>Transform each group to an arbitrary number of rows</p></a></li>
<li><a href='#relocate'><p>Change column order</p></a></li>
<li><a href='#rename'><p>Rename columns</p></a></li>
<li><a href='#row_number'><p>Integer ranking functions</p></a></li>
<li><a href='#rows'><p>Manipulate individual rows</p></a></li>
<li><a href='#rowwise'><p>Group input by rows</p></a></li>
<li><a href='#same_src'><p>Figure out if two sources are the same (or two tbl have the same source)</p></a></li>
<li><a href='#sample_n'><p>Sample n rows from a table</p></a></li>
<li><a href='#scoped'><p>Operate on a selection of variables</p></a></li>
<li><a href='#se-deprecated'><p>Deprecated SE versions of main verbs.</p></a></li>
<li><a href='#select'><p>Keep or drop columns using their names and types</p></a></li>
<li><a href='#select_all'><p>Select and rename a selection of variables</p></a></li>
<li><a href='#setops'><p>Set operations</p></a></li>
<li><a href='#slice'><p>Subset rows using their positions</p></a></li>
<li><a href='#sql'><p>SQL escaping.</p></a></li>
<li><a href='#src'><p>Create a &quot;src&quot; object</p></a></li>
<li><a href='#src_dbi'><p>Source for database backends</p></a></li>
<li><a href='#src_local'><p>A local source</p></a></li>
<li><a href='#src_tbls'><p>List all tbls provided by a source.</p></a></li>
<li><a href='#starwars'><p>Starwars characters</p></a></li>
<li><a href='#storms'><p>Storm tracks data</p></a></li>
<li><a href='#summarise'><p>Summarise each group down to one row</p></a></li>
<li><a href='#summarise_all'><p>Summarise multiple columns</p></a></li>
<li><a href='#summarise_each'><p>Summarise and mutate multiple columns.</p></a></li>
<li><a href='#tbl'><p>Create a table from a data source</p></a></li>
<li><a href='#tbl_df'><p>Coerce to a tibble</p></a></li>
<li><a href='#tbl_ptype'><p>Return a prototype of a tbl</p></a></li>
<li><a href='#tbl_vars'><p>List variables provided by a tbl.</p></a></li>
<li><a href='#tidyeval-compat'><p>Other tidy eval tools</p></a></li>
<li><a href='#top_n'><p>Select top (or bottom) n rows (by value)</p></a></li>
<li><a href='#transmute'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#vars'><p>Select variables</p></a></li>
<li><a href='#with_groups'><p>Perform an operation with temporary groups</p></a></li>
<li><a href='#with_order'><p>Run a function with one order, translating result back to original order</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Grammar of Data Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast, consistent tool for working with data frame like
    objects, both in memory and out of memory.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dplyr.tidyverse.org">https://dplyr.tidyverse.org</a>, <a href="https://github.com/tidyverse/dplyr">https://github.com/tidyverse/dplyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/dplyr/issues">https://github.com/tidyverse/dplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.0), generics, glue (&ge; 1.3.2), lifecycle (&ge;
1.0.3), magrittr (&ge; 1.5), methods, pillar (&ge; 1.9.0), R6,
rlang (&ge; 1.1.0), tibble (&ge; 3.2.0), tidyselect (&ge; 1.2.0),
utils, vctrs (&ge; 0.6.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, broom, callr, covr, DBI, dbplyr (&ge; 2.2.1), ggplot2,
knitr, Lahman, lobstr, microbenchmark, nycflights13, purrr,
rmarkdown, RMySQL, RPostgreSQL, RSQLite, stringi (&ge; 1.7.6),
testthat (&ge; 3.1.5), tidyr (&ge; 1.3.0), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse, shiny, pkgdown, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-16 21:48:56 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Romain François <a href="https://orcid.org/0000-0002-2444-4226"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Lionel Henry [aut],
  Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Davis Vaughan <a href="https://orcid.org/0000-0003-4777-038X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 16:50:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:56:06 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='across'>Apply a function (or functions) across multiple columns</h2><span id='topic+across'></span><span id='topic+if_any'></span><span id='topic+if_all'></span>

<h3>Description</h3>

<p><code>across()</code> makes it easy to apply the same transformation to multiple
columns, allowing you to use <code><a href="MASS.html#topic+select">select()</a></code> semantics inside in &quot;data-masking&quot;
functions like <code><a href="dplyr.html#topic+summarise">summarise()</a></code> and <code><a href="dplyr.html#topic+mutate">mutate()</a></code>. See <code>vignette("colwise")</code> for
more details.
</p>
<p><code>if_any()</code> and <code>if_all()</code> apply the same
predicate function to a selection of columns and combine the
results into a single logical vector: <code>if_any()</code> is <code>TRUE</code> when
the predicate is <code>TRUE</code> for <em>any</em> of the selected columns, <code>if_all()</code>
is <code>TRUE</code> when the predicate is <code>TRUE</code> for <em>all</em> selected columns.
</p>
<p>If you just need to select columns without applying a transformation to each
of them, then you probably want to use <code><a href="dplyr.html#topic+pick">pick()</a></code> instead.
</p>
<p><code>across()</code> supersedes the family of &quot;scoped variants&quot; like
<code>summarise_at()</code>, <code>summarise_if()</code>, and <code>summarise_all()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>across(.cols, .fns, ..., .names = NULL, .unpack = FALSE)

if_any(.cols, .fns, ..., .names = NULL)

if_all(.cols, .fns, ..., .names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="across_+3A_.cols">.cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to transform.
You can't select grouping columns because they are already automatically
handled by the verb (i.e. <code><a href="dplyr.html#topic+summarise">summarise()</a></code> or <code><a href="dplyr.html#topic+mutate">mutate()</a></code>).</p>
</td></tr>
<tr><td><code id="across_+3A_.fns">.fns</code></td>
<td>
<p>Functions to apply to each of the selected columns.
Possible values are:
</p>

<ul>
<li><p> A function, e.g. <code>mean</code>.
</p>
</li>
<li><p> A purrr-style lambda, e.g. <code>~ mean(.x, na.rm = TRUE)</code>
</p>
</li>
<li><p> A named list of functions or lambdas, e.g.
<code style="white-space: pre;">&#8288;list(mean = mean, n_miss = ~ sum(is.na(.x))&#8288;</code>. Each function is applied
to each column, and the output is named by combining the function name
and the column name using the glue specification in <code>.names</code>.
</p>
</li></ul>

<p>Within these functions you can use <code><a href="dplyr.html#topic+cur_column">cur_column()</a></code> and <code><a href="dplyr.html#topic+cur_group">cur_group()</a></code>
to access the current column and grouping keys respectively.</p>
</td></tr>
<tr><td><code id="across_+3A_...">...</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Additional arguments for the function calls in <code>.fns</code> are no longer
accepted in <code>...</code> because it's not clear when they should be evaluated:
once per <code>across()</code> or once per group? Instead supply additional arguments
directly in <code>.fns</code> by using a lambda. For example, instead of
<code>across(a:b, mean, na.rm = TRUE)</code> write
<code>across(a:b, ~ mean(.x, na.rm = TRUE))</code>.</p>
</td></tr>
<tr><td><code id="across_+3A_.names">.names</code></td>
<td>
<p>A glue specification that describes how to name the output
columns. This can use <code>{.col}</code> to stand for the selected column name, and
<code>{.fn}</code> to stand for the name of the function being applied. The default
(<code>NULL</code>) is equivalent to <code>"{.col}"</code> for the single function case and
<code>"{.col}_{.fn}"</code> for the case where a list is used for <code>.fns</code>.</p>
</td></tr>
<tr><td><code id="across_+3A_.unpack">.unpack</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Optionally <a href="tidyr.html#topic+pack">unpack</a> data frames returned by functions in
<code>.fns</code>, which expands the df-columns out into individual columns, retaining
the number of rows in the data frame.
</p>

<ul>
<li><p> If <code>FALSE</code>, the default, no unpacking is done.
</p>
</li>
<li><p> If <code>TRUE</code>, unpacking is done with a default glue specification of
<code>"{outer}_{inner}"</code>.
</p>
</li>
<li><p> Otherwise, a single glue specification can be supplied to describe how to
name the unpacked columns. This can use <code>{outer}</code> to refer to the name
originally generated by <code>.names</code>, and <code>{inner}</code> to refer to the names of
the data frame you are unpacking.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>across()</code> typically returns a tibble with one column for each column in
<code>.cols</code> and each function in <code>.fns</code>. If <code>.unpack</code> is used, more columns may
be returned depending on how the results of <code>.fns</code> are unpacked.
</p>
<p><code>if_any()</code> and <code>if_all()</code> return a logical vector.
</p>


<h3>Timing of evaluation</h3>

<p>R code in dplyr verbs is generally evaluated once per group.
Inside <code>across()</code> however, code is evaluated once for each
combination of columns and groups. If the evaluation timing is
important, for example if you're generating random variables, think
about when it should happen and place your code in consequence.
</p>
<div class="sourceCode r"><pre>gdf &lt;-
  tibble(g = c(1, 1, 2, 3), v1 = 10:13, v2 = 20:23) %&gt;%
  group_by(g)

set.seed(1)

# Outside: 1 normal variate
n &lt;- rnorm(1)
gdf %&gt;% mutate(across(v1:v2, ~ .x + n))
#&gt; # A tibble: 4 x 3
#&gt; # Groups:   g [3]
#&gt;       g    v1    v2
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1  9.37  19.4
#&gt; 2     1 10.4   20.4
#&gt; 3     2 11.4   21.4
#&gt; 4     3 12.4   22.4

# Inside a verb: 3 normal variates (ngroup)
gdf %&gt;% mutate(n = rnorm(1), across(v1:v2, ~ .x + n))
#&gt; # A tibble: 4 x 4
#&gt; # Groups:   g [3]
#&gt;       g    v1    v2      n
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
#&gt; 1     1  10.2  20.2  0.184
#&gt; 2     1  11.2  21.2  0.184
#&gt; 3     2  11.2  21.2 -0.836
#&gt; 4     3  14.6  24.6  1.60

# Inside `across()`: 6 normal variates (ncol * ngroup)
gdf %&gt;% mutate(across(v1:v2, ~ .x + rnorm(1)))
#&gt; # A tibble: 4 x 3
#&gt; # Groups:   g [3]
#&gt;       g    v1    v2
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1  10.3  20.7
#&gt; 2     1  11.3  21.7
#&gt; 3     2  11.2  22.6
#&gt; 4     3  13.5  22.7
</pre></div>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+c_across">c_across()</a></code> for a function that returns a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For better printing
iris &lt;- as_tibble(iris)

# across() -----------------------------------------------------------------
# Different ways to select the same set of columns
# See &lt;https://tidyselect.r-lib.org/articles/syntax.html&gt; for details
iris %&gt;%
  mutate(across(c(Sepal.Length, Sepal.Width), round))
iris %&gt;%
  mutate(across(c(1, 2), round))
iris %&gt;%
  mutate(across(1:Sepal.Width, round))
iris %&gt;%
  mutate(across(where(is.double) &amp; !c(Petal.Length, Petal.Width), round))

# Using an external vector of names
cols &lt;- c("Sepal.Length", "Petal.Width")
iris %&gt;%
  mutate(across(all_of(cols), round))

# If the external vector is named, the output columns will be named according
# to those names
names(cols) &lt;- tolower(cols)
iris %&gt;%
  mutate(across(all_of(cols), round))

# A purrr-style formula
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), ~ mean(.x, na.rm = TRUE)))

# A named list of functions
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd)))

# Use the .names argument to control the output names
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), mean, .names = "mean_{.col}"))
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd), .names = "{.col}.{.fn}"))

# If a named external vector is used for column selection, .names will use
# those names when constructing the output names
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(all_of(cols), mean, .names = "mean_{.col}"))

# When the list is not named, .fn is replaced by the function's position
iris %&gt;%
  group_by(Species) %&gt;%
  summarise(across(starts_with("Sepal"), list(mean, sd), .names = "{.col}.fn{.fn}"))

# When the functions in .fns return a data frame, you typically get a
# "packed" data frame back
quantile_df &lt;- function(x, probs = c(0.25, 0.5, 0.75)) {
  tibble(quantile = probs, value = quantile(x, probs))
}

iris %&gt;%
  reframe(across(starts_with("Sepal"), quantile_df))

# Use .unpack to automatically expand these packed data frames into their
# individual columns
iris %&gt;%
  reframe(across(starts_with("Sepal"), quantile_df, .unpack = TRUE))

# .unpack can utilize a glue specification if you don't like the defaults
iris %&gt;%
  reframe(across(starts_with("Sepal"), quantile_df, .unpack = "{outer}.{inner}"))

# This is also useful inside mutate(), for example, with a multi-lag helper
multilag &lt;- function(x, lags = 1:3) {
  names(lags) &lt;- as.character(lags)
  purrr::map_dfr(lags, lag, x = x)
}

iris %&gt;%
  group_by(Species) %&gt;%
  mutate(across(starts_with("Sepal"), multilag, .unpack = TRUE)) %&gt;%
  select(Species, starts_with("Sepal"))

# if_any() and if_all() ----------------------------------------------------
iris %&gt;%
  filter(if_any(ends_with("Width"), ~ . &gt; 4))
iris %&gt;%
  filter(if_all(ends_with("Width"), ~ . &gt; 2))

</code></pre>

<hr>
<h2 id='add_rownames'>Convert row names to an explicit variable.</h2><span id='topic+add_rownames'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Please use <code><a href="tibble.html#topic+rownames">tibble::rownames_to_column()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_rownames(df, var = "rowname")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_rownames_+3A_df">df</code></td>
<td>
<p>Input data frame with rownames.</p>
</td></tr>
<tr><td><code id="add_rownames_+3A_var">var</code></td>
<td>
<p>Name of variable to use</p>
</td></tr>
</table>

<hr>
<h2 id='all_equal'>Flexible equality comparison for data frames</h2><span id='topic+all_equal'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>all_equal()</code> allows you to compare data frames, optionally ignoring
row and column names. It is deprecated as of dplyr 1.1.0, because it
makes it too easy to ignore important differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_equal(
  target,
  current,
  ignore_col_order = TRUE,
  ignore_row_order = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_equal_+3A_target">target</code>, <code id="all_equal_+3A_current">current</code></td>
<td>
<p>Two data frames to compare.</p>
</td></tr>
<tr><td><code id="all_equal_+3A_ignore_col_order">ignore_col_order</code></td>
<td>
<p>Should order of columns be ignored?</p>
</td></tr>
<tr><td><code id="all_equal_+3A_ignore_row_order">ignore_row_order</code></td>
<td>
<p>Should order of rows be ignored?</p>
</td></tr>
<tr><td><code id="all_equal_+3A_convert">convert</code></td>
<td>
<p>Should similar classes be converted? Currently this will
convert factor to character and integer to double.</p>
</td></tr>
<tr><td><code id="all_equal_+3A_...">...</code></td>
<td>
<p>Ignored. Needed for compatibility with <code>all.equal()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if equal, otherwise a character vector describing
the reasons why they're not equal. Use <code><a href="base.html#topic+isTRUE">isTRUE()</a></code> if using the
result in an <code>if</code> expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scramble &lt;- function(x) x[sample(nrow(x)), sample(ncol(x))]

# `all_equal()` ignored row and column ordering by default,
# but we now feel that that makes it too easy to make mistakes
mtcars2 &lt;- scramble(mtcars)
all_equal(mtcars, mtcars2)

# Instead, be explicit about the row and column ordering
all.equal(
  mtcars,
  mtcars2[rownames(mtcars), names(mtcars)]
)
</code></pre>

<hr>
<h2 id='all_vars'>Apply predicate to all variables</h2><span id='topic+all_vars'></span><span id='topic+any_vars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>all_vars()</code> and <code>any_vars()</code> were only needed for the scoped verbs, which
have been superseded by the use of <code><a href="dplyr.html#topic+across">across()</a></code> in an existing verb. See
<code>vignette("colwise")</code> for details.
</p>
<p>These quoting functions signal to scoped filtering verbs
(e.g. <code><a href="dplyr.html#topic+filter_if">filter_if()</a></code> or <code><a href="dplyr.html#topic+filter_all">filter_all()</a></code>) that a predicate expression
should be applied to all relevant variables. The <code>all_vars()</code>
variant takes the intersection of the predicate expressions with
<code>&amp;</code> while the <code>any_vars()</code> variant takes the union with <code>|</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_vars(expr)

any_vars(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_vars_+3A_expr">expr</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; An expression that
returns a logical vector, using <code>.</code> to refer to the &quot;current&quot; variable.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+vars">vars()</a></code> for other quoting functions that you
can use with scoped verbs.
</p>

<hr>
<h2 id='args_by'>Helper for consistent documentation of <code>.by</code></h2><span id='topic+args_by'></span>

<h3>Description</h3>

<p>Use <code style="white-space: pre;">&#8288;@inheritParams args_by&#8288;</code> to consistently document <code>.by</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="args_by_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='arrange'>Order rows using column values</h2><span id='topic+arrange'></span><span id='topic+arrange.data.frame'></span>

<h3>Description</h3>

<p><code>arrange()</code> orders the rows of a data frame by the values of selected
columns.
</p>
<p>Unlike other dplyr verbs, <code>arrange()</code> largely ignores grouping; you
need to explicitly mention grouping variables (or use  <code>.by_group = TRUE</code>)
in order to group by them, and functions of variables are evaluated
once per data frame, not once per group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange(.data, ..., .by_group = FALSE)

## S3 method for class 'data.frame'
arrange(.data, ..., .by_group = FALSE, .locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="desc.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="arrange_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
<tr><td><code id="arrange_+3A_.locale">.locale</code></td>
<td>
<p>The locale to sort character vectors in.
</p>

<ul>
<li><p> If <code>NULL</code>, the default, uses the <code>"C"</code> locale unless the
<code>dplyr.legacy_locale</code> global option escape hatch is active. See the
<a href="dplyr.html#topic+dplyr-locale">dplyr-locale</a> help page for more details.
</p>
</li>
<li><p> If a single string from <code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> is supplied, then
this will be used as the locale to sort with. For example, <code>"en"</code> will
sort with the American English locale. This requires the stringi package.
</p>
</li>
<li><p> If <code>"C"</code> is supplied, then character vectors will always be sorted in the
C locale. This does not require stringi and is often much faster than
supplying a locale identifier.
</p>
</li></ul>

<p>The C locale is not the same as English locales, such as <code>"en"</code>,
particularly when it comes to data containing a mix of upper and lower case
letters. This is explained in more detail on the <a href="dplyr.html#topic+dplyr-locale">locale</a>
help page under the <code style="white-space: pre;">&#8288;Default locale&#8288;</code> section.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Missing values</h4>

<p>Unlike base sorting with <code>sort()</code>, <code>NA</code> are:
</p>

<ul>
<li><p> always sorted to the end for local data, even when wrapped with <code>desc()</code>.
</p>
</li>
<li><p> treated differently for remote data, depending on the backend.
</p>
</li></ul>




<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> All rows appear in the output, but (usually) in a different place.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="stats.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="MASS.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arrange(mtcars, cyl, disp)
arrange(mtcars, desc(disp))

# grouped arrange ignores groups
by_cyl &lt;- mtcars %&gt;% group_by(cyl)
by_cyl %&gt;% arrange(desc(wt))
# Unless you specifically ask:
by_cyl %&gt;% arrange(desc(wt), .by_group = TRUE)

# use embracing when wrapping in a function;
# see ?rlang::args_data_masking for more details
tidy_eval_arrange &lt;- function(.data, var) {
  .data %&gt;%
    arrange({{ var }})
}
tidy_eval_arrange(mtcars, mpg)

# Use `across()` or `pick()` to select columns with tidy-select
iris %&gt;% arrange(pick(starts_with("Sepal")))
iris %&gt;% arrange(across(starts_with("Sepal"), desc))
</code></pre>

<hr>
<h2 id='arrange_all'>Arrange rows by a selection of variables</h2><span id='topic+arrange_all'></span><span id='topic+arrange_at'></span><span id='topic+arrange_if'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code>, <code style="white-space: pre;">&#8288;_all&#8288;</code>) have been superseded by the use of
<code><a href="dplyr.html#topic+pick">pick()</a></code> or <code><a href="dplyr.html#topic+across">across()</a></code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>These <a href="dplyr.html#topic+scoped">scoped</a> variants of <code><a href="dplyr.html#topic+arrange">arrange()</a></code> sort a data frame by a
selection of variables. Like <code><a href="dplyr.html#topic+arrange">arrange()</a></code>, you can modify the
variables before ordering with the <code>.funs</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_all(.tbl, .funs = list(), ..., .by_group = FALSE, .locale = NULL)

arrange_at(.tbl, .vars, .funs = list(), ..., .by_group = FALSE, .locale = NULL)

arrange_if(
  .tbl,
  .predicate,
  .funs = list(),
  ...,
  .by_group = FALSE,
  .locale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_all_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="arrange_all_+3A_.funs">.funs</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td></tr>
<tr><td><code id="arrange_all_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with <a href="rlang.html#topic+dyn-dots">tidy dots</a> support.</p>
</td></tr>
<tr><td><code id="arrange_all_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
<tr><td><code id="arrange_all_+3A_.locale">.locale</code></td>
<td>
<p>The locale to sort character vectors in.
</p>

<ul>
<li><p> If <code>NULL</code>, the default, uses the <code>"C"</code> locale unless the
<code>dplyr.legacy_locale</code> global option escape hatch is active. See the
<a href="dplyr.html#topic+dplyr-locale">dplyr-locale</a> help page for more details.
</p>
</li>
<li><p> If a single string from <code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> is supplied, then
this will be used as the locale to sort with. For example, <code>"en"</code> will
sort with the American English locale. This requires the stringi package.
</p>
</li>
<li><p> If <code>"C"</code> is supplied, then character vectors will always be sorted in the
C locale. This does not require stringi and is often much faster than
supplying a locale identifier.
</p>
</li></ul>

<p>The C locale is not the same as English locales, such as <code>"en"</code>,
particularly when it comes to data containing a mix of upper and lower case
letters. This is explained in more detail on the <a href="dplyr.html#topic+dplyr-locale">locale</a>
help page under the <code style="white-space: pre;">&#8288;Default locale&#8288;</code> section.</p>
</td></tr>
<tr><td><code id="arrange_all_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="arrange_all_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
</table>


<h3>Grouping variables</h3>

<p>The grouping variables that are part of the selection participate
in the sorting of the data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- as_tibble(mtcars)
arrange_all(df)
# -&gt;
arrange(df, pick(everything()))

arrange_all(df, desc)
# -&gt;
arrange(df, across(everything(), desc))
</code></pre>

<hr>
<h2 id='auto_copy'>Copy tables to same source, if necessary</h2><span id='topic+auto_copy'></span>

<h3>Description</h3>

<p>Copy tables to same source, if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_copy(x, y, copy = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_copy_+3A_x">x</code>, <code id="auto_copy_+3A_y">y</code></td>
<td>
<p><code>y</code> will be copied to <code>x</code>, if necessary.</p>
</td></tr>
<tr><td><code id="auto_copy_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="auto_copy_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='backend_dbplyr'>Database and SQL generics.</h2><span id='topic+backend_dbplyr'></span><span id='topic+db_desc'></span><span id='topic+sql_translate_env'></span><span id='topic+db_list_tables'></span><span id='topic+db_has_table'></span><span id='topic+db_data_type'></span><span id='topic+db_save_query'></span><span id='topic+db_begin'></span><span id='topic+db_commit'></span><span id='topic+db_rollback'></span><span id='topic+db_write_table'></span><span id='topic+db_create_table'></span><span id='topic+db_insert_into'></span><span id='topic+db_create_indexes'></span><span id='topic+db_create_index'></span><span id='topic+db_drop_table'></span><span id='topic+db_analyze'></span><span id='topic+db_explain'></span><span id='topic+db_query_fields'></span><span id='topic+db_query_rows'></span><span id='topic+sql_select'></span><span id='topic+sql_subquery'></span><span id='topic+sql_join'></span><span id='topic+sql_semi_join'></span><span id='topic+sql_set_op'></span><span id='topic+sql_escape_string'></span><span id='topic+sql_escape_ident'></span>

<h3>Description</h3>

<p>The <code>sql_</code> generics are used to build the different types of SQL queries.
The default implementations in dbplyr generates ANSI 92 compliant SQL.
The <code>db_</code> generics execute actions on the database. The default
implementations in dbplyr typically just call the standard DBI S4
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_desc(x)

sql_translate_env(con)

db_list_tables(con)

db_has_table(con, table)

db_data_type(con, fields)

db_save_query(con, sql, name, temporary = TRUE, ...)

db_begin(con, ...)

db_commit(con, ...)

db_rollback(con, ...)

db_write_table(con, table, types, values, temporary = FALSE, ...)

db_create_table(con, table, types, temporary = FALSE, ...)

db_insert_into(con, table, values, ...)

db_create_indexes(con, table, indexes = NULL, unique = FALSE, ...)

db_create_index(con, table, columns, name = NULL, unique = FALSE, ...)

db_drop_table(con, table, force = FALSE, ...)

db_analyze(con, table, ...)

db_explain(con, sql, ...)

db_query_fields(con, sql, ...)

db_query_rows(con, sql, ...)

sql_select(
  con,
  select,
  from,
  where = NULL,
  group_by = NULL,
  having = NULL,
  order_by = NULL,
  limit = NULL,
  distinct = FALSE,
  ...
)

sql_subquery(con, from, name = random_table_name(), ...)

sql_join(con, x, y, vars, type = "inner", by = NULL, ...)

sql_semi_join(con, x, y, anti = FALSE, by = NULL, ...)

sql_set_op(con, x, y, method)

sql_escape_string(con, x)

sql_escape_ident(con, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backend_dbplyr_+3A_con">con</code></td>
<td>
<p>A database connection.</p>
</td></tr>
<tr><td><code id="backend_dbplyr_+3A_table">table</code></td>
<td>
<p>A string, the table name.</p>
</td></tr>
<tr><td><code id="backend_dbplyr_+3A_fields">fields</code></td>
<td>
<p>A list of fields, as in a data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A few backend methods do not call the standard DBI S4 methods including
</p>

<ul>
<li> <p><code>db_data_type()</code>: Calls <code><a href="DBI.html#topic+dbDataType">DBI::dbDataType()</a></code> for every field
(e.g. data frame column) and returns a vector of corresponding SQL data
types
</p>
</li>
<li> <p><code>db_save_query()</code>: Builds and executes a
<code style="white-space: pre;">&#8288;CREATE [TEMPORARY] TABLE &lt;table&gt; ...&#8288;</code> SQL command.
</p>
</li>
<li> <p><code>db_create_index()</code>: Builds and executes a
<code style="white-space: pre;">&#8288;CREATE INDEX &lt;name&gt; ON &lt;table&gt;&#8288;</code> SQL command.
</p>
</li>
<li> <p><code>db_drop_table()</code>: Builds and executes a
<code style="white-space: pre;">&#8288;DROP TABLE [IF EXISTS]  &lt;table&gt;&#8288;</code> SQL command.
</p>
</li>
<li> <p><code>db_analyze()</code>: Builds and executes an
<code style="white-space: pre;">&#8288;ANALYZE &lt;table&gt;&#8288;</code> SQL command.
</p>
</li></ul>

<p>Currently, <code><a href="dplyr.html#topic+copy_to">copy_to()</a></code> is the only user of <code>db_begin()</code>, <code>db_commit()</code>,
<code>db_rollback()</code>, <code>db_write_table()</code>, <code>db_create_indexes()</code>, <code>db_drop_table()</code> and
<code>db_analyze()</code>. If you find yourself overriding many of these
functions it may suggest that you should just override <code>copy_to()</code>
instead.
</p>
<p><code>db_create_table()</code> and <code>db_insert_into()</code> have been deprecated
in favour of <code>db_write_table()</code>.
</p>


<h3>Value</h3>

<p>Usually a logical value indicating success. Most failures should generate
an error. However, <code>db_has_table()</code> should return <code>NA</code> if
temporary tables cannot be listed with <code><a href="DBI.html#topic+dbListTables">DBI::dbListTables()</a></code> (due to backend
API limitations for example). As a result, you methods will rely on the
backend to throw an error if a table exists when it shouldn't.
</p>

<hr>
<h2 id='band_members'>Band membership</h2><span id='topic+band_members'></span><span id='topic+band_instruments'></span><span id='topic+band_instruments2'></span>

<h3>Description</h3>

<p>These data sets describe band members of the Beatles and Rolling Stones. They
are toy data sets that can be displayed in their entirety on a slide (e.g. to
demonstrate a join).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>band_members

band_instruments

band_instruments2
</code></pre>


<h3>Format</h3>

<p>Each is a tibble with two variables and three observations
</p>


<h3>Details</h3>

<p><code>band_instruments</code> and <code>band_instruments2</code> contain the same data but use
different column names for the first column of the data set.
<code>band_instruments</code> uses <code>name</code>, which matches the name of the key column of
<code>band_members</code>; <code>band_instruments2</code> uses <code>artist</code>, which does not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>band_members
band_instruments
band_instruments2
</code></pre>

<hr>
<h2 id='between'>Detect where values fall in a specified range</h2><span id='topic+between'></span>

<h3>Description</h3>

<p>This is a shortcut for <code>x &gt;= left &amp; x &lt;= right</code>, implemented for local
vectors and translated to the appropriate SQL for remote tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>between(x, left, right)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="between_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="between_+3A_left">left</code>, <code id="between_+3A_right">right</code></td>
<td>
<p>Boundary values. Both <code>left</code> and <code>right</code> are recycled to
the size of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code>, <code>left</code>, and <code>right</code> are all cast to their common type before the
comparison is made.
</p>


<h3>Value</h3>

<p>A logical vector the same size as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> if you are looking for documentation for the <code>between()</code> overlap
join helper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>between(1:12, 7, 9)

x &lt;- rnorm(1e2)
x[between(x, -1, 1)]

# On a tibble using `filter()`
filter(starwars, between(height, 100, 150))
</code></pre>

<hr>
<h2 id='bind_cols'>Bind multiple data frames by column</h2><span id='topic+bind_cols'></span>

<h3>Description</h3>

<p>Bind any number of data frames by column, making a wider result.
This is similar to <code>do.call(cbind, dfs)</code>.
</p>
<p>Where possible prefer using a <a href="dplyr.html#topic+left_join">join</a> to combine multiple
data frames. <code>bind_cols()</code> binds the rows in order in which they appear
so it is easy to create meaningless results without realising it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_cols(
  ...,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_cols_+3A_...">...</code></td>
<td>
<p>Data frames to combine. Each argument can either be a data frame,
a list that could be a data frame, or a list of data frames.
Inputs are <a href="vctrs.html#topic+theory-faq-recycling">recycled</a> to the same length,
then matched by position.</p>
</td></tr>
<tr><td><code id="bind_cols_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, or
<code>"check_unique"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for the meaning of these
options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame the same type as the first element of <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tibble(x = 1:3)
df2 &lt;- tibble(y = 3:1)
bind_cols(df1, df2)

# Row sizes must be compatible when column-binding
try(bind_cols(tibble(x = 1:3), tibble(y = 1:2)))
</code></pre>

<hr>
<h2 id='bind_rows'>Bind multiple data frames by row</h2><span id='topic+bind_rows'></span><span id='topic+bind'></span>

<h3>Description</h3>

<p>Bind any number of data frames by row, making a longer result. This is
similar to <code>do.call(rbind, dfs)</code>, but the output will contain all columns
that appear in any of the inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_rows(..., .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_rows_+3A_...">...</code></td>
<td>
<p>Data frames to combine. Each argument can either be a data frame,
a list that could be a data frame, or a list of data frames. Columns are
matched by name, and any missing columns will be filled with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="bind_rows_+3A_.id">.id</code></td>
<td>
<p>The name of an optional identifier column. Provide a string to
create an output column that identifies each input. The column will use
names if available, otherwise it will use positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame the same type as the first element of <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tibble(x = 1:2, y = letters[1:2])
df2 &lt;- tibble(x = 4:5, z = 1:2)

# You can supply individual data frames as arguments:
bind_rows(df1, df2)

# Or a list of data frames:
bind_rows(list(df1, df2))

# When you supply a column name with the `.id` argument, a new
# column is created to link each row to its original data frame
bind_rows(list(df1, df2), .id = "id")
bind_rows(list(a = df1, b = df2), .id = "id")
</code></pre>

<hr>
<h2 id='c_across'>Combine values from multiple columns</h2><span id='topic+c_across'></span>

<h3>Description</h3>

<p><code>c_across()</code> is designed to work with <code><a href="dplyr.html#topic+rowwise">rowwise()</a></code> to make it easy to
perform row-wise aggregations. It has two differences from <code>c()</code>:
</p>

<ul>
<li><p> It uses tidy select semantics so you can easily select multiple variables.
See <code>vignette("rowwise")</code> for more details.
</p>
</li>
<li><p> It uses <code><a href="vctrs.html#topic+vec_c">vctrs::vec_c()</a></code> in order to give safer outputs.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>c_across(cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_across_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to transform.
You can't select grouping columns because they are already automatically
handled by the verb (i.e. <code><a href="dplyr.html#topic+summarise">summarise()</a></code> or <code><a href="dplyr.html#topic+mutate">mutate()</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+across">across()</a></code> for a function that returns a tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(id = 1:4, w = runif(4), x = runif(4), y = runif(4), z = runif(4))
df %&gt;%
  rowwise() %&gt;%
  mutate(
    sum = sum(c_across(w:z)),
    sd = sd(c_across(w:z))
  )
</code></pre>

<hr>
<h2 id='case_match'>A general vectorised <code>switch()</code></h2><span id='topic+case_match'></span>

<h3>Description</h3>

<p>This function allows you to vectorise multiple <code><a href="base.html#topic+switch">switch()</a></code> statements. Each
case is evaluated sequentially and the first match for each element
determines the corresponding value in the output vector. If no cases match,
the <code>.default</code> is used.
</p>
<p><code>case_match()</code> is an R equivalent of the SQL &quot;simple&quot; <code style="white-space: pre;">&#8288;CASE WHEN&#8288;</code> statement.
</p>


<h4>Connection to <code>case_when()</code></h4>

<p>While <code><a href="dplyr.html#topic+case_when">case_when()</a></code> uses logical expressions on the left-hand side of the
formula, <code>case_match()</code> uses values to match against <code>.x</code> with. The following
two statements are roughly equivalent:
</p>
<div class="sourceCode"><pre>case_when(
  x %in% c("a", "b") ~ 1,
  x %in% "c" ~ 2,
  x %in% c("d", "e") ~ 3
)

case_match(
  x,
  c("a", "b") ~ 1,
  "c" ~ 2,
  c("d", "e") ~ 3
)
</pre></div>



<h3>Usage</h3>

<pre><code class='language-R'>case_match(.x, ..., .default = NULL, .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_match_+3A_.x">.x</code></td>
<td>
<p>A vector to match against.</p>
</td></tr>
<tr><td><code id="case_match_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; A sequence of two-sided
formulas: <code>old_values ~ new_value</code>. The right hand side (RHS) determines
the output value for all values of <code>.x</code> that match the left hand side
(LHS).
</p>
<p>The LHS must evaluate to the same type of vector as <code>.x</code>. It can be any
length, allowing you to map multiple <code>.x</code> values to the same RHS value.
If a value is repeated in the LHS, i.e. a value in <code>.x</code> matches to
multiple cases, the first match is used.
</p>
<p>The RHS inputs will be coerced to their common type. Each RHS input will be
<a href="vctrs.html#topic+theory-faq-recycling">recycled</a> to the size of <code>.x</code>.</p>
</td></tr>
<tr><td><code id="case_match_+3A_.default">.default</code></td>
<td>
<p>The value used when values in <code>.x</code> aren't matched by any of
the LHS inputs. If <code>NULL</code>, the default, a missing value will be used.
</p>
<p><code>.default</code> is <a href="vctrs.html#topic+theory-faq-recycling">recycled</a> to the size of
<code>.x</code>.</p>
</td></tr>
<tr><td><code id="case_match_+3A_.ptype">.ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If
not supplied, the output type will be taken from the common type of
all RHS inputs and <code>.default</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same size as <code>.x</code> and the same type as the common type of
the RHS inputs and <code>.default</code> (if not overridden by <code>.ptype</code>).
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+case_when">case_when()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "b", "a", "d", "b", NA, "c", "e")

# `case_match()` acts like a vectorized `switch()`.
# Unmatched values "fall through" as a missing value.
case_match(
  x,
  "a" ~ 1,
  "b" ~ 2,
  "c" ~ 3,
  "d" ~ 4
)

# Missing values can be matched exactly, and `.default` can be used to
# control the value used for unmatched values of `.x`
case_match(
  x,
  "a" ~ 1,
  "b" ~ 2,
  "c" ~ 3,
  "d" ~ 4,
  NA ~ 0,
  .default = 100
)

# Input values can be grouped into the same expression to map them to the
# same output value
case_match(
  x,
  c("a", "b") ~ "low",
  c("c", "d", "e") ~ "high"
)

# `case_match()` isn't limited to character input:
y &lt;- c(1, 2, 1, 3, 1, NA, 2, 4)

case_match(
  y,
  c(1, 3) ~ "odd",
  c(2, 4) ~ "even",
  .default = "missing"
)

# Setting `.default` to the original vector is a useful way to replace
# selected values, leaving everything else as is
case_match(y, NA ~ 0, .default = y)

starwars %&gt;%
  mutate(
    # Replace missings, but leave everything else alone
    hair_color = case_match(hair_color, NA ~ "unknown", .default = hair_color),
    # Replace some, but not all, of the species
    species = case_match(
      species,
      "Human" ~ "Humanoid",
      "Droid" ~ "Robot",
      c("Wookiee", "Ewok") ~ "Hairy",
      .default = species
    ),
    .keep = "used"
  )
</code></pre>

<hr>
<h2 id='case_when'>A general vectorised if-else</h2><span id='topic+case_when'></span>

<h3>Description</h3>

<p>This function allows you to vectorise multiple <code><a href="dplyr.html#topic+if_else">if_else()</a></code> statements. Each
case is evaluated sequentially and the first match for each element
determines the corresponding value in the output vector. If no cases match,
the <code>.default</code> is used as a final &quot;else&quot; statment.
</p>
<p><code>case_when()</code> is an R equivalent of the SQL &quot;searched&quot; <code style="white-space: pre;">&#8288;CASE WHEN&#8288;</code> statement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_when(..., .default = NULL, .ptype = NULL, .size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_when_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; A sequence of two-sided
formulas. The left hand side (LHS) determines which values match this case.
The right hand side (RHS) provides the replacement value.
</p>
<p>The LHS inputs must evaluate to logical vectors.
</p>
<p>The RHS inputs will be coerced to their common type.
</p>
<p>All inputs will be recycled to their common size. That said, we encourage
all LHS inputs to be the same size. Recycling is mainly useful for RHS
inputs, where you might supply a size 1 input that will be recycled to the
size of the LHS inputs.
</p>
<p><code>NULL</code> inputs are ignored.</p>
</td></tr>
<tr><td><code id="case_when_+3A_.default">.default</code></td>
<td>
<p>The value used when all of the LHS inputs return either
<code>FALSE</code> or <code>NA</code>.
</p>
<p><code>.default</code> must be size 1 or the same size as the common size computed
from <code>...</code>.
</p>
<p><code>.default</code> participates in the computation of the common type with the RHS
inputs.
</p>
<p><code>NA</code> values in the LHS conditions are treated like <code>FALSE</code>, meaning that
the result at those locations will be assigned the <code>.default</code> value. To
handle missing values in the conditions differently, you must explicitly
catch them with another condition before they fall through to the
<code>.default</code>. This typically involves some variation of <code>is.na(x) ~ value</code>
tailored to your usage of <code>case_when()</code>.
</p>
<p>If <code>NULL</code>, the default, a missing value will be used.</p>
</td></tr>
<tr><td><code id="case_when_+3A_.ptype">.ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If
supplied, this overrides the common type of the RHS inputs.</p>
</td></tr>
<tr><td><code id="case_when_+3A_.size">.size</code></td>
<td>
<p>An optional size declaring the desired output size. If supplied,
this overrides the common size computed from <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same size as the common size computed from the
inputs in <code>...</code> and the same type as the common type of the RHS inputs
in <code>...</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+case_match">case_match()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:70
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  .default = as.character(x)
)

# Like an if statement, the arguments are evaluated in order, so you must
# proceed from the most specific to the most general. This won't work:
case_when(
  x %%  5 == 0 ~ "fizz",
  x %%  7 == 0 ~ "buzz",
  x %% 35 == 0 ~ "fizz buzz",
  .default = as.character(x)
)

# If none of the cases match and no `.default` is supplied, NA is used:
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
)

# Note that `NA` values on the LHS are treated like `FALSE` and will be
# assigned the `.default` value. You must handle them explicitly if you
# want to use a different value. The exact way to handle missing values is
# dependent on the set of LHS conditions you use.
x[2:4] &lt;- NA_real_
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  is.na(x) ~ "nope",
  .default = as.character(x)
)

# `case_when()` evaluates all RHS expressions, and then constructs its
# result by extracting the selected (via the LHS expressions) parts.
# In particular `NaN`s are produced in this case:
y &lt;- seq(-2, 2, by = .5)
case_when(
  y &gt;= 0 ~ sqrt(y),
  .default = y
)

# `case_when()` is particularly useful inside `mutate()` when you want to
# create a new variable that relies on a complex combination of existing
# variables
starwars %&gt;%
  select(name:mass, gender, species) %&gt;%
  mutate(
    type = case_when(
      height &gt; 200 | mass &gt; 200 ~ "large",
      species == "Droid" ~ "robot",
      .default = "other"
    )
  )


# `case_when()` is not a tidy eval function. If you'd like to reuse
# the same patterns, extract the `case_when()` call in a normal
# function:
case_character_type &lt;- function(height, mass, species) {
  case_when(
    height &gt; 200 | mass &gt; 200 ~ "large",
    species == "Droid" ~ "robot",
    .default = "other"
  )
}

case_character_type(150, 250, "Droid")
case_character_type(150, 150, "Droid")

# Such functions can be used inside `mutate()` as well:
starwars %&gt;%
  mutate(type = case_character_type(height, mass, species)) %&gt;%
  pull(type)

# `case_when()` ignores `NULL` inputs. This is useful when you'd
# like to use a pattern only under certain conditions. Here we'll
# take advantage of the fact that `if` returns `NULL` when there is
# no `else` clause:
case_character_type &lt;- function(height, mass, species, robots = TRUE) {
  case_when(
    height &gt; 200 | mass &gt; 200 ~ "large",
    if (robots) species == "Droid" ~ "robot",
    .default = "other"
  )
}

starwars %&gt;%
  mutate(type = case_character_type(height, mass, species, robots = FALSE)) %&gt;%
  pull(type)
</code></pre>

<hr>
<h2 id='check_dbplyr'>dbplyr compatibility functions</h2><span id='topic+check_dbplyr'></span><span id='topic+wrap_dbplyr_obj'></span>

<h3>Description</h3>

<p>In dplyr 0.7.0, a number of database and SQL functions moved from dplyr to
dbplyr. The generic functions stayed in dplyr (since there is no easy way
to conditionally import a generic from different packages), but many other
SQL and database helper functions moved. If you have written a backend,
these functions generate the code you need to work with both dplyr 0.5.0
dplyr 0.7.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dbplyr()

wrap_dbplyr_obj(obj_name)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
wrap_dbplyr_obj("build_sql")
wrap_dbplyr_obj("base_agg")

</code></pre>

<hr>
<h2 id='coalesce'>Find the first non-missing element</h2><span id='topic+coalesce'></span>

<h3>Description</h3>

<p>Given a set of vectors, <code>coalesce()</code> finds the first non-missing value at
each position. It's inspired by the SQL <code>COALESCE</code> function which does the
same thing for SQL <code>NULL</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce(..., .ptype = NULL, .size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesce_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt;
</p>
<p>One or more vectors. These will be
<a href="vctrs.html#topic+theory-faq-recycling">recycled</a> against each other, and will be
cast to their common type.</p>
</td></tr>
<tr><td><code id="coalesce_+3A_.ptype">.ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If
supplied, this overrides the common type of the vectors in <code>...</code>.</p>
</td></tr>
<tr><td><code id="coalesce_+3A_.size">.size</code></td>
<td>
<p>An optional size declaring the desired output size. If supplied,
this overrides the common size of the vectors in <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same type and size as the common type and common
size of the vectors in <code>...</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+na_if">na_if()</a></code> to replace specified values with an <code>NA</code>.
<code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code> to replace <code>NA</code> with a value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use a single value to replace all missing values
x &lt;- sample(c(1:5, NA, NA, NA))
coalesce(x, 0L)

# The equivalent to a missing value in a list is `NULL`
coalesce(list(1, 2, NULL), list(NA))

# Or generate a complete vector from partially missing pieces
y &lt;- c(1, 2, NA, NA, 5)
z &lt;- c(NA, NA, 3, 4, 5)
coalesce(y, z)

# Supply lists by splicing them into dots:
vecs &lt;- list(
  c(1, 2, NA, NA, 5),
  c(NA, NA, 3, 4, 5)
)
coalesce(!!!vecs)
</code></pre>

<hr>
<h2 id='combine'>Combine vectors</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>combine()</code> is deprecated in favour of <code><a href="vctrs.html#topic+vec_c">vctrs::vec_c()</a></code>. <code>combine()</code>
attempted to automatically guess whether you wanted <code><a href="base.html#topic+c">c()</a></code> or <code><a href="base.html#topic+unlist">unlist()</a></code>,
but could fail in surprising ways. We now believe it's better to be explicit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>Vectors to combine.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- factor("a")
f2 &lt;- factor("b")

combine(f1, f2)
# -&gt;
vctrs::vec_c(f1, f1)

combine(list(f1, f2))
# -&gt;
vctrs::vec_c(!!!list(f1, f2))
</code></pre>

<hr>
<h2 id='common_by'>Extract out common by variables</h2><span id='topic+common_by'></span>

<h3>Description</h3>

<p>Extract out common by variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_by(by = NULL, x, y)
</code></pre>

<hr>
<h2 id='compute'>Force computation of a database query</h2><span id='topic+compute'></span><span id='topic+collect'></span><span id='topic+collapse'></span>

<h3>Description</h3>

<p><code>compute()</code> stores results in a remote temporary table.
<code>collect()</code> retrieves data into a local tibble.
<code>collapse()</code> is slightly different: it doesn't force computation, but
instead forces generation of the SQL query. This is sometimes needed to work
around bugs in dplyr's SQL generation.
</p>
<p>All functions preserve grouping and ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute(x, ...)

collect(x, ...)

collapse(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy
data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for more
details.</p>
</td></tr>
<tr><td><code id="compute_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>These functions are <strong>generics</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>compute()</code>: no methods found
</p>
</li>
<li> <p><code>collect()</code>: no methods found
</p>
</li>
<li> <p><code>collapse()</code>: no methods found
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+copy_to">copy_to()</a></code>, the opposite of <code>collect()</code>: it takes a local data
frame and uploads it to the remote source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars2 &lt;- dbplyr::src_memdb() %&gt;%
  copy_to(mtcars, name = "mtcars2-cc", overwrite = TRUE)

remote &lt;- mtcars2 %&gt;%
  filter(cyl == 8) %&gt;%
  select(mpg:drat)

# Compute query and save in remote table
compute(remote)

# Compute query bring back to this session
collect(remote)

# Creates a fresh query based on the generated SQL
collapse(remote)

</code></pre>

<hr>
<h2 id='consecutive_id'>Generate a unique identifier for consecutive combinations</h2><span id='topic+consecutive_id'></span>

<h3>Description</h3>

<p><code>consecutive_id()</code> generates a unique identifier that increments every time
a variable (or combination of variables) changes. Inspired by
<code>data.table::rleid()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consecutive_id(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consecutive_id_+3A_...">...</code></td>
<td>
<p>Unnamed vectors. If multiple vectors are supplied, then they should
have the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length as the longest
element of <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>consecutive_id(c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, NA, NA))
consecutive_id(c(1, 1, 1, 2, 1, 1, 2, 2))

df &lt;- data.frame(x = c(0, 0, 1, 0), y = c(2, 2, 2, 2))
df %&gt;% group_by(x, y) %&gt;% summarise(n = n())
df %&gt;% group_by(id = consecutive_id(x, y), x, y) %&gt;% summarise(n = n())
</code></pre>

<hr>
<h2 id='context'>Information about the &quot;current&quot; group or variable</h2><span id='topic+context'></span><span id='topic+n'></span><span id='topic+cur_group'></span><span id='topic+cur_group_id'></span><span id='topic+cur_group_rows'></span><span id='topic+cur_column'></span>

<h3>Description</h3>

<p>These functions return information about the &quot;current&quot; group or &quot;current&quot;
variable, so only work inside specific contexts like <code><a href="dplyr.html#topic+summarise">summarise()</a></code> and
<code><a href="dplyr.html#topic+mutate">mutate()</a></code>.
</p>

<ul>
<li> <p><code>n()</code> gives the current group size.
</p>
</li>
<li> <p><code>cur_group()</code> gives the group keys, a tibble with one row and one column
for each grouping variable.
</p>
</li>
<li> <p><code>cur_group_id()</code> gives a unique numeric identifier for the current group.
</p>
</li>
<li> <p><code>cur_group_rows()</code> gives the row indices for the current group.
</p>
</li>
<li> <p><code>cur_column()</code> gives the name of the current column (in <code><a href="dplyr.html#topic+across">across()</a></code> only).
</p>
</li></ul>

<p>See <code><a href="dplyr.html#topic+group_data">group_data()</a></code> for equivalent functions that return values for all
groups.
</p>
<p>See <code><a href="dplyr.html#topic+pick">pick()</a></code> for a way to select a subset of columns using tidyselect syntax
while inside <code>summarise()</code> or <code>mutate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n()

cur_group()

cur_group_id()

cur_group_rows()

cur_column()
</code></pre>


<h3>data.table</h3>

<p>If you're familiar with data.table:
</p>

<ul>
<li> <p><code>cur_group_id()</code> &lt;-&gt; <code>.GRP</code>
</p>
</li>
<li> <p><code>cur_group()</code> &lt;-&gt; <code>.BY</code>
</p>
</li>
<li> <p><code>cur_group_rows()</code> &lt;-&gt; <code>.I</code>
</p>
</li></ul>

<p>See <code><a href="dplyr.html#topic+pick">pick()</a></code> for an equivalent to <code>.SD</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  g = sample(rep(letters[1:3], 1:3)),
  x = runif(6),
  y = runif(6)
)
gf &lt;- df %&gt;% group_by(g)

gf %&gt;% summarise(n = n())

gf %&gt;% mutate(id = cur_group_id())
gf %&gt;% reframe(row = cur_group_rows())
gf %&gt;% summarise(data = list(cur_group()))

gf %&gt;% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))
</code></pre>

<hr>
<h2 id='copy_to'>Copy a local data frame to a remote src</h2><span id='topic+copy_to'></span>

<h3>Description</h3>

<p>This function uploads a local data frame into a remote data source, creating
the table definition as needed. Wherever possible, the new object will be
temporary, limited to the current connection to the source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_to(dest, df, name = deparse(substitute(df)), overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_to_+3A_dest">dest</code></td>
<td>
<p>remote data source</p>
</td></tr>
<tr><td><code id="copy_to_+3A_df">df</code></td>
<td>
<p>local data frame</p>
</td></tr>
<tr><td><code id="copy_to_+3A_name">name</code></td>
<td>
<p>name for new remote table.</p>
</td></tr>
<tr><td><code id="copy_to_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, will overwrite an existing table with
name <code>name</code>. If <code>FALSE</code>, will throw an error if <code>name</code> already
exists.</p>
</td></tr>
<tr><td><code id="copy_to_+3A_...">...</code></td>
<td>
<p>other parameters passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tbl</code> object in the remote source
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+collect">collect()</a></code> for the opposite action; downloading remote data into
a local dbl.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
iris2 &lt;- dbplyr::src_memdb() %&gt;% copy_to(iris, overwrite = TRUE)
iris2

## End(Not run)
</code></pre>

<hr>
<h2 id='count'>Count the observations in each group</h2><span id='topic+count'></span><span id='topic+count.data.frame'></span><span id='topic+tally'></span><span id='topic+add_count'></span><span id='topic+add_tally'></span>

<h3>Description</h3>

<p><code>count()</code> lets you quickly count the unique values of one or more variables:
<code>df %&gt;% count(a, b)</code> is roughly equivalent to
<code>df %&gt;% group_by(a, b) %&gt;% summarise(n = n())</code>.
<code>count()</code> is paired with <code>tally()</code>, a lower-level helper that is equivalent
to <code>df %&gt;% summarise(n = n())</code>. Supply <code>wt</code> to perform weighted counts,
switching the summary from <code>n = n()</code> to <code>n = sum(wt)</code>.
</p>
<p><code>add_count()</code> and <code>add_tally()</code> are equivalents to <code>count()</code> and <code>tally()</code>
but use <code>mutate()</code> instead of <code>summarise()</code> so that they add a new column
with group-wise counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(x, ..., wt = NULL, sort = FALSE, name = NULL)

## S3 method for class 'data.frame'
count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = group_by_drop_default(x)
)

tally(x, wt = NULL, sort = FALSE, name = NULL)

add_count(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = deprecated())

add_tally(x, wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.</p>
</td></tr>
<tr><td><code id="count_+3A_wt">wt</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="count_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="count_+3A_.drop">.drop</code></td>
<td>
<p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. <code>count()</code> and <code>add_count()</code>
group transiently, so the output has the same groups as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># count() is a convenient way to get a sense of the distribution of
# values in a dataset
starwars %&gt;% count(species)
starwars %&gt;% count(species, sort = TRUE)
starwars %&gt;% count(sex, gender, sort = TRUE)
starwars %&gt;% count(birth_decade = round(birth_year, -1))

# use the `wt` argument to perform a weighted count. This is useful
# when the data has already been aggregated once
df &lt;- tribble(
  ~name,    ~gender,   ~runs,
  "Max",    "male",       10,
  "Sandra", "female",      1,
  "Susan",  "female",      4
)
# counts rows:
df %&gt;% count(gender)
# counts runs:
df %&gt;% count(gender, wt = runs)

# When factors are involved, `.drop = FALSE` can be used to retain factor
# levels that don't appear in the data
df2 &lt;- tibble(
  id = 1:5,
  type = factor(c("a", "c", "a", NA, "a"), levels = c("a", "b", "c"))
)
df2 %&gt;% count(type)
df2 %&gt;% count(type, .drop = FALSE)

# Or, using `group_by()`:
df2 %&gt;% group_by(type, .drop = FALSE) %&gt;% count()

# tally() is a lower-level function that assumes you've done the grouping
starwars %&gt;% tally()
starwars %&gt;% group_by(species) %&gt;% tally()

# both count() and tally() have add_ variants that work like
# mutate() instead of summarise
df %&gt;% add_count(gender, wt = runs)
df %&gt;% add_tally(wt = runs)
</code></pre>

<hr>
<h2 id='cross_join'>Cross join</h2><span id='topic+cross_join'></span>

<h3>Description</h3>

<p>Cross joins match each row in <code>x</code> to every row in <code>y</code>, resulting in a data
frame with <code>nrow(x) * nrow(y)</code> rows.
</p>
<p>Since cross joins result in all possible matches between <code>x</code> and <code>y</code>, they
technically serve as the basis for all <a href="dplyr.html#topic+mutate-joins">mutating joins</a>, which
can generally be thought of as cross joins followed by a filter. In practice,
a more specialized procedure is used for better performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_join(x, y, ..., copy = FALSE, suffix = c(".x", ".y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_join_+3A_x">x</code>, <code id="cross_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="cross_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="cross_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="cross_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> (including the same groups). The output has
the following properties:
</p>

<ul>
<li><p> There are <code>nrow(x) * nrow(y)</code> rows returned.
</p>
</li>
<li><p> Output columns include all columns from both <code>x</code> and <code>y</code>. Column name
collisions are resolved using <code>suffix</code>.
</p>
</li>
<li><p> The order of the rows and columns of <code>x</code> is preserved as much as possible.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>,
<code><a href="dplyr.html#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="dplyr.html#topic+nest_join">nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cross joins match each row in `x` to every row in `y`.
# Data within the columns is not used in the matching process.
cross_join(band_instruments, band_members)

# Control the suffix added to variables duplicated in
# `x` and `y` with `suffix`.
cross_join(band_instruments, band_members, suffix = c("", "_y"))
</code></pre>

<hr>
<h2 id='cumall'>Cumulativate versions of any, all, and mean</h2><span id='topic+cumall'></span><span id='topic+cumany'></span><span id='topic+cummean'></span>

<h3>Description</h3>

<p>dplyr provides <code>cumall()</code>, <code>cumany()</code>, and <code>cummean()</code> to complete R's set
of cumulative functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumall(x)

cumany(x)

cummean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumall_+3A_x">x</code></td>
<td>
<p>For <code>cumall()</code> and <code>cumany()</code>, a logical vector; for
<code>cummean()</code> an integer or numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>x</code>.
</p>


<h3>Cumulative logical functions</h3>

<p>These are particularly useful in conjunction with <code>filter()</code>:
</p>

<ul>
<li> <p><code>cumall(x)</code>: all cases until the first <code>FALSE</code>.
</p>
</li>
<li> <p><code>cumall(!x)</code>: all cases until the first <code>TRUE</code>.
</p>
</li>
<li> <p><code>cumany(x)</code>: all cases after the first <code>TRUE</code>.
</p>
</li>
<li> <p><code>cumany(!x)</code>: all cases after the first <code>FALSE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `cummean()` returns a numeric/integer vector of the same length
# as the input vector.
x &lt;- c(1, 3, 5, 2, 2)
cummean(x)
cumsum(x) / seq_along(x)

# `cumall()` and `cumany()` return logicals
cumall(x &lt; 5)
cumany(x == 3)

# `cumall()` vs. `cumany()`
df &lt;- data.frame(
  date = as.Date("2020-01-01") + 0:6,
  balance = c(100, 50, 25, -25, -50, 30, 120)
)
# all rows after first overdraft
df %&gt;% filter(cumany(balance &lt; 0))
# all rows until first overdraft
df %&gt;% filter(cumall(!(balance &lt; 0)))

</code></pre>

<hr>
<h2 id='defunct'>Defunct functions</h2><span id='topic+defunct'></span><span id='topic+id'></span><span id='topic+failwith'></span><span id='topic+select_vars'></span><span id='topic+rename_vars'></span><span id='topic+select_var'></span><span id='topic+current_vars'></span><span id='topic+bench_tbls'></span><span id='topic+compare_tbls'></span><span id='topic+compare_tbls2'></span><span id='topic+eval_tbls'></span><span id='topic+eval_tbls2'></span><span id='topic+location'></span><span id='topic+changes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a>
</p>
<p>These functions were deprecated for at least two years before being
made defunct. If there's a known replacement, calling the function
will tell you about it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Deprecated in 0.5.0 -------------------------------------

id(.variables, drop = FALSE)

# Deprecated in 0.7.0 -------------------------------------

failwith(default = NULL, f, quiet = FALSE)

# Deprecated in 0.8.* -------------------------------------

select_vars(vars = chr(), ..., include = chr(), exclude = chr())

rename_vars(vars = chr(), ..., strict = TRUE)

select_var(vars, var = -1)

current_vars(...)

# Deprecated in 1.0.0 -------------------------------------

bench_tbls(tbls, op, ..., times = 10)

compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...)

compare_tbls2(tbls_x, tbls_y, op, ref = NULL, compare = equal_data_frame, ...)

eval_tbls(tbls, op)

eval_tbls2(tbls_x, tbls_y, op)

location(df)

changes(x, y)
</code></pre>

<hr>
<h2 id='deprec-context'>Information about the &quot;current&quot; group or variable</h2><span id='topic+deprec-context'></span><span id='topic+cur_data'></span><span id='topic+cur_data_all'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions were deprecated in dplyr 1.1.0.
</p>

<ul>
<li> <p><code>cur_data()</code> is deprecated in favor of <code><a href="dplyr.html#topic+pick">pick()</a></code>.
</p>
</li>
<li> <p><code>cur_data_all()</code> is deprecated but does not have a direct replacement as
selecting the grouping variables is not well-defined and is unlikely to
ever be useful.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cur_data()

cur_data_all()
</code></pre>

<hr>
<h2 id='desc'>Descending order</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>Transform a vector into a format that will be sorted in descending order.
This is useful within <code><a href="dplyr.html#topic+arrange">arrange()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc_+3A_x">x</code></td>
<td>
<p>vector to transform</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>desc(1:10)
desc(factor(letters))

first_day &lt;- seq(as.Date("1910/1/1"), as.Date("1920/1/1"), "years")
desc(first_day)

starwars %&gt;% arrange(desc(mass))
</code></pre>

<hr>
<h2 id='dim_desc'>Describing dimensions</h2><span id='topic+dim_desc'></span>

<h3>Description</h3>

<p>Prints the dimensions of an array-like object in a user-friendly manner,
substituting <code>NA</code> with ?? (for SQL queries).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_desc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_desc_+3A_x">x</code></td>
<td>
<p>Object to show dimensions for.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dim_desc(mtcars)
</code></pre>

<hr>
<h2 id='distinct'>Keep distinct/unique rows</h2><span id='topic+distinct'></span>

<h3>Description</h3>

<p>Keep only unique/distinct rows from a data frame. This is similar
to <code><a href="base.html#topic+unique.data.frame">unique.data.frame()</a></code> but considerably faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="distinct_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Optional variables to
use when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame.</p>
</td></tr>
<tr><td><code id="distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Rows are a subset of the input but appear in the same order.
</p>
</li>
<li><p> Columns are not modified if <code>...</code> is empty or <code>.keep_all</code> is <code>TRUE</code>.
Otherwise, <code>distinct()</code> first calls <code>mutate()</code> to create new columns.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)
nrow(df)
nrow(distinct(df))
nrow(distinct(df, x, y))

distinct(df, x)
distinct(df, y)

# You can choose to keep all other variables as well
distinct(df, x, .keep_all = TRUE)
distinct(df, y, .keep_all = TRUE)

# You can also use distinct on computed variables
distinct(df, diff = abs(x - y))

# Use `pick()` to select columns with tidy-select
distinct(starwars, pick(contains("color")))

# Grouping -------------------------------------------------

df &lt;- tibble(
  g = c(1, 1, 2, 2, 2),
  x = c(1, 1, 2, 1, 2),
  y = c(3, 2, 1, 3, 1)
)
df &lt;- df %&gt;% group_by(g)

# With grouped data frames, distinctness is computed within each group
df %&gt;% distinct(x)

# When `...` are omitted, `distinct()` still computes distinctness using
# all variables in the data frame
df %&gt;% distinct()
</code></pre>

<hr>
<h2 id='distinct_all'>Select distinct rows by a selection of variables</h2><span id='topic+distinct_all'></span><span id='topic+distinct_at'></span><span id='topic+distinct_if'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code>, <code style="white-space: pre;">&#8288;_all&#8288;</code>) have been superseded by the use of
<code><a href="dplyr.html#topic+pick">pick()</a></code> or <code><a href="dplyr.html#topic+across">across()</a></code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>These <a href="dplyr.html#topic+scoped">scoped</a> variants of <code><a href="dplyr.html#topic+distinct">distinct()</a></code> extract distinct rows by a
selection of variables. Like <code>distinct()</code>, you can modify the
variables before ordering with the <code>.funs</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct_all(.tbl, .funs = list(), ..., .keep_all = FALSE)

distinct_at(.tbl, .vars, .funs = list(), ..., .keep_all = FALSE)

distinct_if(.tbl, .predicate, .funs = list(), ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct_all_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="distinct_all_+3A_.funs">.funs</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td></tr>
<tr><td><code id="distinct_all_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with <a href="rlang.html#topic+dyn-dots">tidy dots</a> support.</p>
</td></tr>
<tr><td><code id="distinct_all_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
<tr><td><code id="distinct_all_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="distinct_all_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
</table>


<h3>Grouping variables</h3>

<p>The grouping variables that are part of the selection are taken
into account to determine distinct rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2)

distinct_all(df)
# -&gt;
distinct(df, pick(everything()))

distinct_at(df, vars(x,y))
# -&gt;
distinct(df, pick(x, y))

distinct_if(df, is.numeric)
# -&gt;
distinct(df, pick(where(is.numeric)))

# You can supply a function that will be applied before extracting the distinct values
# The variables of the sorted tibble keep their original values.
distinct_all(df, round)
# -&gt;
distinct(df, across(everything(), round))
</code></pre>

<hr>
<h2 id='distinct_prepare'>Same basic philosophy as group_by_prepare(): lazy_dots comes in, list of data and
vars (character vector) comes out.</h2><span id='topic+distinct_prepare'></span><span id='topic+group_by_prepare'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;*_prepare()&#8288;</code> performs standard manipulation that is needed prior
to actual data processing. They are only be needed by packages
that implement dplyr backends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct_prepare(
  .data,
  vars,
  group_vars = character(),
  .keep_all = FALSE,
  caller_env = caller_env(2),
  error_call = caller_env()
)

group_by_prepare(
  .data,
  ...,
  .add = FALSE,
  .dots = deprecated(),
  add = deprecated(),
  error_call = caller_env()
)
</code></pre>


<h3>Value</h3>

<p>A list
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>Modified tbl</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>Modified groups</p>
</td></tr>
</table>

<hr>
<h2 id='do'>Do anything</h2><span id='topic+do'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>do()</code> is superseded as of dplyr 1.0.0, because its syntax never really
felt like it belonged with the rest of dplyr. It's replaced by a combination
of <code><a href="dplyr.html#topic+reframe">reframe()</a></code> (which can produce multiple rows and multiple columns),
<code><a href="dplyr.html#topic+nest_by">nest_by()</a></code> (which creates a <a href="dplyr.html#topic+rowwise">rowwise</a> tibble of nested data),
and <code><a href="dplyr.html#topic+pick">pick()</a></code> (which allows you to access the data for the &quot;current&quot; group).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_+3A_.data">.data</code></td>
<td>
<p>a tbl</p>
</td></tr>
<tr><td><code id="do_+3A_...">...</code></td>
<td>
<p>Expressions to apply to each group. If named, results will be
stored in a new column. If unnamed, must return a data frame. You can
use <code>.</code> to refer to the current group. You can not mix named and
unnamed arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># do() with unnamed arguments becomes reframe() or summarise()
# . becomes pick()
by_cyl &lt;- mtcars %&gt;% group_by(cyl)
by_cyl %&gt;% do(head(., 2))
# -&gt;
by_cyl %&gt;% reframe(head(pick(everything()), 2))
by_cyl %&gt;% slice_head(n = 2)

# Can refer to variables directly
by_cyl %&gt;% do(mean = mean(.$vs))
# -&gt;
by_cyl %&gt;% summarise(mean = mean(vs))

# do() with named arguments becomes nest_by() + mutate() &amp; list()
models &lt;- by_cyl %&gt;% do(mod = lm(mpg ~ disp, data = .))
# -&gt;
models &lt;- mtcars %&gt;%
  nest_by(cyl) %&gt;%
  mutate(mod = list(lm(mpg ~ disp, data = data)))
models %&gt;% summarise(rsq = summary(mod)$r.squared)

# use broom to turn models into data
models %&gt;% do(data.frame(
  var = names(coef(.$mod)),
  coef(summary(.$mod)))
)

# -&gt;
models %&gt;% reframe(broom::tidy(mod))

</code></pre>

<hr>
<h2 id='dplyr_by'>Per-operation grouping with <code>.by</code>/<code>by</code></h2><span id='topic+dplyr_by'></span>

<h3>Description</h3>

<p>There are two ways to group in dplyr:
</p>

<ul>
<li><p> Persistent grouping with <code><a href="dplyr.html#topic+group_by">group_by()</a></code>
</p>
</li>
<li><p> Per-operation grouping with <code>.by</code>/<code>by</code>
</p>
</li></ul>

<p>This help page is dedicated to explaining where and why you might want to use the latter.
</p>
<p>Depending on the dplyr verb, the per-operation grouping argument may be named <code>.by</code> or <code>by</code>.
The <em>Supported verbs</em> section below outlines this on a case-by-case basis.
The remainder of this page will refer to <code>.by</code> for simplicity.
</p>
<p>Grouping radically affects the computation of the dplyr verb you use it with, and one of the goals of <code>.by</code> is to allow you to place that grouping specification alongside the code that actually uses it.
As an added benefit, with <code>.by</code> you no longer need to remember to <code><a href="dplyr.html#topic+ungroup">ungroup()</a></code> after <code><a href="dplyr.html#topic+summarise">summarise()</a></code>, and <code>summarise()</code> won't ever message you about how it's handling the groups!
</p>
<p>This idea comes from <a href="https://CRAN.R-project.org/package=data.table">data.table</a>, which allows you to specify <code>by</code> alongside modifications in <code>j</code>, like: <code>dt[, .(x = mean(x)), by = g]</code>.
</p>


<h4>Supported verbs</h4>


<ul>
<li> <p><code><a href="dplyr.html#topic+mutate">mutate(.by = )</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+summarise">summarise(.by = )</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+reframe">reframe(.by = )</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+filter">filter(.by = )</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice">slice(.by = )</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice_head">slice_head(by = )</a></code> and <code><a href="dplyr.html#topic+slice_tail">slice_tail(by = )</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice_min">slice_min(by = )</a></code> and <code><a href="dplyr.html#topic+slice_max">slice_max(by = )</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice_sample">slice_sample(by = )</a></code>
</p>
</li></ul>

<p>Note that some dplyr verbs use <code>by</code> while others use <code>.by</code>.
This is a purely technical difference.
</p>



<h4>Differences between <code>.by</code> and <code>group_by()</code></h4>


<table>
<tr>
 <td style="text-align: left;">
   <code>.by</code> </td><td style="text-align: left;"> <code>group_by()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Grouping only affects a single verb </td><td style="text-align: left;"> Grouping is persistent across multiple verbs </td>
</tr>
<tr>
 <td style="text-align: left;">
   Selects variables with <a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a> </td><td style="text-align: left;"> Computes expressions with <a href="rlang.html#topic+args_data_masking">data-masking</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Summaries use existing order of group keys </td><td style="text-align: left;"> Summaries sort group keys in ascending order </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>Using <code>.by</code></h4>

<p>Let's take a look at the two grouping approaches using this <code>expenses</code> data set, which tracks costs accumulated across various <code>id</code>s and <code>region</code>s:
</p>
<div class="sourceCode r"><pre>expenses &lt;- tibble(
  id = c(1, 2, 1, 3, 1, 2, 3),
  region = c("A", "A", "A", "B", "B", "A", "A"),
  cost = c(25, 20, 19, 12, 9, 6, 6)
)
expenses
#&gt; # A tibble: 7 x 3
#&gt;      id region  cost
#&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1     1 A         25
#&gt; 2     2 A         20
#&gt; 3     1 A         19
#&gt; 4     3 B         12
#&gt; 5     1 B          9
#&gt; 6     2 A          6
#&gt; 7     3 A          6
</pre></div>
<p>Imagine that you wanted to compute the average cost per region.
You'd probably write something like this:
</p>
<div class="sourceCode r"><pre>expenses %&gt;%
  group_by(region) %&gt;%
  summarise(cost = mean(cost))
#&gt; # A tibble: 2 x 2
#&gt;   region  cost
#&gt;   &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1 A       15.2
#&gt; 2 B       10.5
</pre></div>
<p>Instead, you can now specify the grouping <em>inline</em> within the verb:
</p>
<div class="sourceCode r"><pre>expenses %&gt;%
  summarise(cost = mean(cost), .by = region)
#&gt; # A tibble: 2 x 2
#&gt;   region  cost
#&gt;   &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1 A       15.2
#&gt; 2 B       10.5
</pre></div>
<p><code>.by</code> applies to a single operation, meaning that since <code>expenses</code> was an ungrouped data frame, the result after applying <code>.by</code> will also always be an ungrouped data frame, regardless of the number of grouping columns.
</p>
<div class="sourceCode r"><pre>expenses %&gt;%
  summarise(cost = mean(cost), .by = c(id, region))
#&gt; # A tibble: 5 x 3
#&gt;      id region  cost
#&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1     1 A         22
#&gt; 2     2 A         13
#&gt; 3     3 B         12
#&gt; 4     1 B          9
#&gt; 5     3 A          6
</pre></div>
<p>Compare that with <code>group_by() %&gt;% summarise()</code>, where <code>summarise()</code> generally peels off 1 layer of grouping by default, typically with a message that it is doing so:
</p>
<div class="sourceCode r"><pre>expenses %&gt;%
  group_by(id, region) %&gt;%
  summarise(cost = mean(cost))
#&gt; `summarise()` has grouped output by 'id'. You can override using the `.groups`
#&gt; argument.
#&gt; # A tibble: 5 x 3
#&gt; # Groups:   id [3]
#&gt;      id region  cost
#&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1     1 A         22
#&gt; 2     1 B          9
#&gt; 3     2 A         13
#&gt; 4     3 A          6
#&gt; 5     3 B         12
</pre></div>
<p>Because <code>.by</code> grouping applies to a single operation, you don't need to worry about ungrouping, and it never needs to emit a message to remind you what it is doing with the groups.
</p>
<p>Note that with <code>.by</code> we specified multiple columns to group by using the <a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a> syntax <code>c(id, region)</code>.
If you have a character vector of column names you'd like to group by, you can do so with <code>.by = all_of(my_cols)</code>.
It will group by the columns in the order they were provided.
</p>
<p>To prevent surprising results, you can't use <code>.by</code> on an existing grouped data frame:
</p>
<div class="sourceCode r"><pre>expenses %&gt;% 
  group_by(id) %&gt;%
  summarise(cost = mean(cost), .by = c(id, region))
#&gt; Error in `summarise()`:
#&gt; ! Can't supply `.by` when `.data` is a grouped data frame.
</pre></div>
<p>So far we've focused on the usage of <code>.by</code> with <code>summarise()</code>, but <code>.by</code> works with a number of other dplyr verbs.
For example, you could append the mean cost per region onto the original data frame as a new column rather than computing a summary:
</p>
<div class="sourceCode r"><pre>expenses %&gt;%
  mutate(cost_by_region = mean(cost), .by = region)
#&gt; # A tibble: 7 x 4
#&gt;      id region  cost cost_by_region
#&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;          &lt;dbl&gt;
#&gt; 1     1 A         25           15.2
#&gt; 2     2 A         20           15.2
#&gt; 3     1 A         19           15.2
#&gt; 4     3 B         12           10.5
#&gt; 5     1 B          9           10.5
#&gt; 6     2 A          6           15.2
#&gt; 7     3 A          6           15.2
</pre></div>
<p>Or you could slice out the maximum cost per combination of id and region:
</p>
<div class="sourceCode r"><pre># Note that the argument is named `by` in `slice_max()`
expenses %&gt;%
  slice_max(cost, n = 1, by = c(id, region))
#&gt; # A tibble: 5 x 3
#&gt;      id region  cost
#&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
#&gt; 1     1 A         25
#&gt; 2     2 A         20
#&gt; 3     3 B         12
#&gt; 4     1 B          9
#&gt; 5     3 A          6
</pre></div>



<h4>Result ordering</h4>

<p>When used with <code>.by</code>, <code>summarise()</code>, <code>reframe()</code>, and <code>slice()</code> all maintain the ordering of the existing data.
This is different from <code>group_by()</code>, which has always sorted the group keys in ascending order.
</p>
<div class="sourceCode r"><pre>df &lt;- tibble(
  month = c("jan", "jan", "feb", "feb", "mar"),
  temp = c(20, 25, 18, 20, 40)
)

# Uses ordering by "first appearance" in the original data
df %&gt;%
  summarise(average_temp = mean(temp), .by = month)
#&gt; # A tibble: 3 x 2
#&gt;   month average_temp
#&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1 jan           22.5
#&gt; 2 feb           19  
#&gt; 3 mar           40

# Sorts in ascending order
df %&gt;%
  group_by(month) %&gt;%
  summarise(average_temp = mean(temp))
#&gt; # A tibble: 3 x 2
#&gt;   month average_temp
#&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1 feb           19  
#&gt; 2 jan           22.5
#&gt; 3 mar           40
</pre></div>
<p>If you need sorted group keys, we recommend that you explicitly use <code><a href="dplyr.html#topic+arrange">arrange()</a></code> either before or after the call to <code>summarise()</code>, <code>reframe()</code>, or <code>slice()</code>.
This also gives you full access to all of <code>arrange()</code>'s features, such as <code>desc()</code> and the <code>.locale</code> argument.
</p>



<h4>Verbs without <code>.by</code> support</h4>

<p>If a dplyr verb doesn't support <code>.by</code>, then that typically means that the verb isn't inherently affected by grouping.
For example, <code><a href="dplyr.html#topic+pull">pull()</a></code> and <code><a href="dplyr.html#topic+rename">rename()</a></code> don't support <code>.by</code>, because specifying columns to group by would not affect their implementations.
</p>
<p>That said, there are a few exceptions to this where sometimes a dplyr verb doesn't support <code>.by</code>, but <em>does</em> have special support for grouped data frames created by <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
This is typically because the verbs are required to retain the grouping columns, for example:
</p>

<ul>
<li> <p><code><a href="MASS.html#topic+select">select()</a></code> always retains grouping columns, with a message if any aren't specified in the <code>select()</code> call.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+distinct">distinct()</a></code> and <code><a href="dplyr.html#topic+count">count()</a></code> place unspecified grouping columns at the front of the data frame before computing their results.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+arrange">arrange()</a></code> has a <code>.by_group</code> argument to optionally order by grouping columns first.
</p>
</li></ul>

<p>If <code>group_by()</code> didn't exist, then these verbs would not have special support for grouped data frames.
</p>


<hr>
<h2 id='dplyr_data_masking'>Data-masking</h2><span id='topic+dplyr_data_masking'></span>

<h3>Description</h3>

<p>This page is now located at
<code><a href="rlang.html#topic+args_data_masking">?rlang::args_data_masking</a></code>.
</p>

<hr>
<h2 id='dplyr_extending'>Extending dplyr with new data frame subclasses</h2><span id='topic+dplyr_extending'></span><span id='topic+dplyr_row_slice'></span><span id='topic+dplyr_col_modify'></span><span id='topic+dplyr_reconstruct'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>These three functions, along with <code style="white-space: pre;">&#8288;names&lt;-&#8288;</code> and 1d numeric <code>[</code>
(i.e. <code>x[loc]</code>) methods, provide a minimal interface for extending dplyr
to work with new data frame subclasses. This means that for simple cases
you should only need to provide a couple of methods, rather than a method
for every dplyr verb.
</p>
<p>These functions are a stop-gap measure until we figure out how to solve
the problem more generally, but it's likely that any code you write to
implement them will find a home in what comes next.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dplyr_row_slice(data, i, ...)

dplyr_col_modify(data, cols)

dplyr_reconstruct(data, template)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_extending_+3A_data">data</code></td>
<td>
<p>A tibble. We use tibbles because they avoid some inconsistent
subset-assignment use cases.</p>
</td></tr>
<tr><td><code id="dplyr_extending_+3A_i">i</code></td>
<td>
<p>A numeric or logical vector that indexes the rows of <code>data</code>.</p>
</td></tr>
<tr><td><code id="dplyr_extending_+3A_cols">cols</code></td>
<td>
<p>A named list used to modify columns. A <code>NULL</code> value should remove
an existing column.</p>
</td></tr>
<tr><td><code id="dplyr_extending_+3A_template">template</code></td>
<td>
<p>Template data frame to use for restoring attributes.</p>
</td></tr>
</table>


<h3>Basic advice</h3>

<p>This section gives you basic advice if you want to extend dplyr to work with
your custom data frame subclass, and you want the dplyr methods to behave
in basically the same way.
</p>

<ul>
<li><p> If you have data frame attributes that don't depend on the rows or columns
(and should unconditionally be preserved), you don't need to do anything.
The one exception to this is if your subclass extends a data.frame
directly rather than extending a tibble. The <code style="white-space: pre;">&#8288;[.data.frame&#8288;</code> method does not
preserve attributes, so you'll need to write a <code>[</code> method for your subclass
that preserves attributes important for your class.
</p>
</li>
<li><p> If you have <strong>scalar</strong> attributes that depend on <strong>rows</strong>, implement a
<code>dplyr_reconstruct()</code> method. Your method should recompute the attribute
depending on rows now present.
</p>
</li>
<li><p> If you have <strong>scalar</strong> attributes that depend on <strong>columns</strong>, implement a
<code>dplyr_reconstruct()</code> method and a 1d <code>[</code> method. For example, if your
class requires that certain columns be present, your method should return
a data.frame or tibble when those columns are removed.
</p>
</li>
<li><p> If your attributes are <strong>vectorised</strong> over <strong>rows</strong>, implement a
<code>dplyr_row_slice()</code> method. This gives you access to <code>i</code> so you can
modify the row attribute accordingly. You'll also need to think carefully
about how to recompute the attribute in <code>dplyr_reconstruct()</code>, and
you will need to carefully verify the behaviour of each verb, and provide
additional methods as needed.
</p>
</li>
<li><p> If your attributes that are <strong>vectorised</strong> over <strong>columns</strong>, implement
<code>dplyr_col_modify()</code>, 1d <code>[</code>, and <code style="white-space: pre;">&#8288;names&lt;-&#8288;</code> methods. All of these methods
know which columns are being modified, so you can update the column
attribute according. You'll also need to think carefully about how to
recompute the attribute in <code>dplyr_reconstruct()</code>, and you will need to
carefully verify the behaviour of each verb, and provide additional
methods as needed.
</p>
</li></ul>



<h3>Current usage</h3>


<ul>
<li> <p><code>arrange()</code>, <code>filter()</code>, <code>slice()</code> (and the rest of the <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>
family), <code>semi_join()</code>, and <code>anti_join()</code> work by generating a vector of
row indices, and then subsetting with <code>dplyr_row_slice()</code>.
</p>
</li>
<li> <p><code>mutate()</code> generates a list of new column value (using <code>NULL</code> to indicate
when columns should be deleted), then passes that to <code>dplyr_col_modify()</code>.
It also uses 1d <code>[</code> to implement <code>.keep</code>, and will call <code>relocate()</code> if
either <code>.before</code> or <code>.after</code> are supplied.
</p>
</li>
<li> <p><code>summarise()</code> and <code>reframe()</code> work similarly to <code>mutate()</code> but the data
modified by <code>dplyr_col_modify()</code> comes from <code>group_data()</code> or is built
from <code>.by</code>.
</p>
</li>
<li> <p><code>select()</code> uses 1d <code>[</code> to select columns, then <code style="white-space: pre;">&#8288;names&lt;-&#8288;</code> to rename them.
<code>rename()</code> just uses <code style="white-space: pre;">&#8288;names&lt;-&#8288;</code>. <code>relocate()</code> just uses 1d <code>[</code>.
</p>
</li>
<li> <p><code>inner_join()</code>, <code>left_join()</code>, <code>right_join()</code>, and <code>full_join()</code>
coerce <code>x</code> to a tibble, modify the rows, then use <code>dplyr_reconstruct()</code>
to convert back to the same type as <code>x</code>.
</p>
</li>
<li> <p><code>nest_join()</code> converts both <code>x</code> and <code>y</code> to tibbles, modifies the rows,
and uses <code>dplyr_col_modify()</code> to handle modified key variables and the
list-column that <code>y</code> becomes. It also uses <code>dplyr_reconstruct()</code> to convert
the outer result back to the type of <code>x</code>, and to convert the nested tibbles
back to the type of <code>y</code>.
</p>
</li>
<li> <p><code>distinct()</code> does a <code>mutate()</code> if any expressions are present, then
uses 1d <code>[</code> to select variables to keep, then <code>dplyr_row_slice()</code> to
select distinct rows.
</p>
</li></ul>

<p>Note that <code>group_by()</code> and <code>ungroup()</code> don't use any of these generics and
you'll need to provide methods for them directly, or rely on <code>.by</code> for
per-operation grouping.
</p>

<hr>
<h2 id='dplyr_tidy_select'>Argument type: tidy-select</h2><span id='topic+dplyr_tidy_select'></span>

<h3>Description</h3>

<p>This page describes the <code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> argument modifier which indicates
the argument supports <strong>tidy selections</strong>. Tidy selection provides a concise
dialect of R for selecting variables based on their names or properties.
</p>
<p>Tidy selection is a variant of tidy evaluation. This means that inside
functions, tidy-select arguments require special attention, as described in
the <em>Indirection</em> section below. If you've never heard of tidy evaluation
before, start with <code>vignette("programming")</code>.
</p>


<h3>Overview of selection features</h3>

<p>Tidyverse selections implement a dialect of R where operators make
it easy to select variables:
</p>

<ul>
<li> <p><code>:</code> for selecting a range of consecutive variables.
</p>
</li>
<li> <p><code>!</code> for taking the complement of a set of variables.
</p>
</li>
<li> <p><code>&amp;</code> and <code>|</code> for selecting the intersection or the union of two
sets of variables.
</p>
</li>
<li> <p><code>c()</code> for combining selections.
</p>
</li></ul>

<p>In addition, you can use <strong>selection helpers</strong>. Some helpers select specific
columns:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+everything">everything()</a></code>: Matches all variables.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+everything">last_col()</a></code>: Select last variable, possibly with an offset.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_cols">group_cols()</a></code>: Select all grouping columns.
</p>
</li></ul>

<p>Other helpers select variables by matching patterns in their names:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+starts_with">starts_with()</a></code>: Starts with a prefix.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">ends_with()</a></code>: Ends with a suffix.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">contains()</a></code>: Contains a literal string.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">matches()</a></code>: Matches a regular expression.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">num_range()</a></code>: Matches a numerical range like x01, x02, x03.
</p>
</li></ul>

<p>Or from variables stored in a character vector:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+all_of">all_of()</a></code>: Matches variable names in a character vector. All
names must be present, otherwise an out-of-bounds error is
thrown.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+all_of">any_of()</a></code>: Same as <code>all_of()</code>, except that no error is thrown
for names that don't exist.
</p>
</li></ul>

<p>Or using a predicate function:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+where">where()</a></code>: Applies a function to all variables and selects those
for which the function returns <code>TRUE</code>.
</p>
</li></ul>



<h3>Indirection</h3>

<p>There are two main cases:
</p>

<ul>
<li><p> If you have a character vector of column names, use <code>all_of()</code>
or <code>any_of()</code>, depending on whether or not you want unknown variable
names to cause an error, e.g. <code>select(df, all_of(vars))</code>,
<code>select(df, !any_of(vars))</code>.
</p>
</li>
<li><p> If you want the user to be able to supply a tidyselect specification in
a function argument, embrace the function argument, e.g.
<code>select(df, {{ vars }})</code>.
</p>
</li></ul>


<hr>
<h2 id='dplyr-locale'>Locale used by <code>arrange()</code></h2><span id='topic+dplyr-locale'></span>

<h3>Description</h3>

<p>This page documents details about the locale used by <code><a href="dplyr.html#topic+arrange">arrange()</a></code> when
ordering character vectors.
</p>


<h4>Default locale</h4>

<p>The default locale used by <code>arrange()</code> is the C locale. This is used when
<code>.locale = NULL</code> unless the <code>dplyr.legacy_locale</code> global option is set to
<code>TRUE</code>. You can also force the C locale to be used unconditionally with
<code>.locale = "C"</code>.
</p>
<p>The C locale is not exactly the same as English locales, such as <code>"en"</code>. The
main difference is that the C locale groups the English alphabet by <em>case</em>,
while most English locales group the alphabet by <em>letter</em>. For example,
<code>c("a", "b", "C", "B", "c")</code> will sort as <code>c("B", "C", "a", "b", "c")</code> in the
C locale, with all uppercase letters coming before lowercase letters, but
will sort as <code>c("a", "b", "B", "c", "C")</code> in an English locale. This often
makes little practical difference during data analysis, because both return
identical results when case is consistent between observations.
</p>



<h4>Reproducibility</h4>

<p>The C locale has the benefit of being completely reproducible across all
supported R versions and operating systems with no extra effort.
</p>
<p>If you set <code>.locale</code> to an option from <code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code>, then
stringi must be installed by anyone who wants to run your code. If you
utilize this in a package, then stringi should be placed in <code>Imports</code>.
</p>



<h4>Legacy behavior</h4>

<p>Prior to dplyr 1.1.0, character columns were ordered in the system locale. If
you need to temporarily revert to this behavior, you can set the global
option <code>dplyr.legacy_locale</code> to <code>TRUE</code>, but this should be used sparingly and
you should expect this option to be removed in a future version of dplyr. It
is better to update existing code to explicitly use <code>.locale</code> instead. Note
that setting <code>dplyr.legacy_locale</code> will also force calls to <code><a href="dplyr.html#topic+group_by">group_by()</a></code> to
use the system locale when internally ordering the groups.
</p>
<p>Setting <code>.locale</code> will override any usage of <code>dplyr.legacy_locale</code>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- tibble(x = c("a", "b", "C", "B", "c"))
df

# Default locale is C, which groups the English alphabet by case, placing
# uppercase letters before lowercase letters.
arrange(df, x)

# The American English locale groups the alphabet by letter.
# Explicitly override `.locale` with `"en"` for this ordering.
arrange(df, x, .locale = "en")

# This Danish letter is expected to sort after `z`
df &lt;- tibble(x = c("o", "p", "\u00F8", "z"))
df

# The American English locale sorts it right after `o`
arrange(df, x, .locale = "en")

# Using `"da"` for Danish ordering gives the expected result
arrange(df, x, .locale = "da")

# If you need the legacy behavior of `arrange()`, which respected the
# system locale, then you can set the global option `dplyr.legacy_locale`,
# but expect this to be removed in the future. We recommend that you use
# the `.locale` argument instead.
rlang::with_options(dplyr.legacy_locale = TRUE, {
  arrange(df, x)
})

</code></pre>

<hr>
<h2 id='dplyr-package'>dplyr: A Grammar of Data Manipulation</h2><span id='topic+dplyr'></span><span id='topic+dplyr-package'></span>

<h3>Description</h3>

<p>To learn more about dplyr, start with the vignettes:
<code>browseVignettes(package = "dplyr")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Romain François (<a href="https://orcid.org/0000-0002-2444-4226">ORCID</a>)
</p>
</li>
<li><p> Lionel Henry
</p>
</li>
<li><p> Kirill Müller (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
</li>
<li><p> Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a> (<a href="https://orcid.org/0000-0003-4777-038X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dplyr.tidyverse.org">https://dplyr.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/dplyr">https://github.com/tidyverse/dplyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/dplyr/issues">https://github.com/tidyverse/dplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='explain'>Explain details of a tbl</h2><span id='topic+explain'></span><span id='topic+show_query'></span>

<h3>Description</h3>

<p>This is a generic function which gives more details about an object than
<code><a href="base.html#topic+print">print()</a></code>, and is more focused on human readable output than
<code><a href="utils.html#topic+str">str()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explain(x, ...)

show_query(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explain_+3A_x">x</code></td>
<td>
<p>An object to explain</p>
</td></tr>
<tr><td><code id="explain_+3A_...">...</code></td>
<td>
<p>Other parameters possibly used by generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly.
</p>


<h3>Databases</h3>

<p>Explaining a <code>tbl_sql</code> will run the SQL <code>EXPLAIN</code> command which
will describe the query plan. This requires a little bit of knowledge about
how <code>EXPLAIN</code> works for your database, but is very useful for
diagnosing performance problems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

lahman_s &lt;- dbplyr::lahman_sqlite()
batting &lt;- tbl(lahman_s, "Batting")
batting %&gt;% show_query()
batting %&gt;% explain()

# The batting database has indices on all ID variables:
# SQLite automatically picks the most restrictive index
batting %&gt;% filter(lgID == "NL" &amp; yearID == 2000L) %&gt;% explain()

# OR's will use multiple indexes
batting %&gt;% filter(lgID == "NL" | yearID == 2000) %&gt;% explain()

# Joins will use indexes in both tables
teams &lt;- tbl(lahman_s, "Teams")
batting %&gt;% left_join(teams, c("yearID", "teamID")) %&gt;% explain()


</code></pre>

<hr>
<h2 id='filter'>Keep rows that match a condition</h2><span id='topic+filter'></span>

<h3>Description</h3>

<p>The <code>filter()</code> function is used to subset a data frame,
retaining all rows that satisfy your conditions.
To be retained, the row must produce a value of <code>TRUE</code> for all conditions.
Note that when a condition evaluates to <code>NA</code>
the row will be dropped, unlike base subsetting with <code>[</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter(.data, ..., .by = NULL, .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.</p>
</td></tr>
<tr><td><code id="filter_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="filter_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>filter()</code> function is used to subset the rows of
<code>.data</code>, applying the expressions in <code>...</code> to the column values to determine which
rows should be retained. It can be applied to both grouped and ungrouped data (see <code><a href="dplyr.html#topic+group_by">group_by()</a></code> and
<code><a href="dplyr.html#topic+ungroup">ungroup()</a></code>). However, dplyr is not yet smart enough to optimise the filtering
operation on grouped datasets that do not need grouped calculations. For this
reason, filtering is often considerably faster on ungrouped data.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following properties:
</p>

<ul>
<li><p> Rows are a subset of the input, but appear in the same order.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> The number of groups may be reduced (if <code>.preserve</code> is not <code>TRUE</code>).
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Useful filter functions</h3>

<p>There are many functions and operators that are useful when constructing the
expressions used to filter the data:
</p>

<ul>
<li> <p><code><a href="base.html#topic++3D+3D">==</a></code>, <code><a href="base.html#topic++3E">&gt;</a></code>, <code><a href="base.html#topic++3E+3D">&gt;=</a></code> etc
</p>
</li>
<li> <p><code><a href="base.html#topic++26">&amp;</a></code>, <code><a href="base.html#topic++7C">|</a></code>, <code><a href="base.html#topic++21">!</a></code>, <code><a href="base.html#topic+xor">xor()</a></code>
</p>
</li>
<li> <p><code><a href="Matrix.html#topic+is.na">is.na()</a></code>
</p>
</li>
<li> <p><code><a href="data.table.html#topic+between">between()</a></code>, <code><a href="dplyr.html#topic+near">near()</a></code>
</p>
</li></ul>



<h3>Grouped tibbles</h3>

<p>Because filtering expressions are computed within groups, they may
yield different results on grouped tibbles. This will be the case
as soon as an aggregating, lagging, or ranking function is
involved. Compare this ungrouped filtering:
</p>
<div class="sourceCode"><pre>starwars %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))
</pre></div>
<p>With the grouped equivalent:
</p>
<div class="sourceCode"><pre>starwars %&gt;% group_by(gender) %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))
</pre></div>
<p>In the ungrouped version, <code>filter()</code> compares the value of <code>mass</code> in each row to
the global average (taken over the whole data set), keeping only the rows with
<code>mass</code> greater than this global average. In contrast, the grouped version calculates
the average mass separately for each <code>gender</code> group, and keeps rows with <code>mass</code> greater
than the relevant within-gender average.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="MASS.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filtering by one criterion
filter(starwars, species == "Human")
filter(starwars, mass &gt; 1000)

# Filtering by multiple criteria within a single logical expression
filter(starwars, hair_color == "none" &amp; eye_color == "black")
filter(starwars, hair_color == "none" | eye_color == "black")

# When multiple expressions are used, they are combined using &amp;
filter(starwars, hair_color == "none", eye_color == "black")


# The filtering operation may yield different results on grouped
# tibbles because the expressions are computed within groups.
#
# The following filters rows where `mass` is greater than the
# global average:
starwars %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))

# Whereas this keeps rows with `mass` greater than the gender
# average:
starwars %&gt;% group_by(gender) %&gt;% filter(mass &gt; mean(mass, na.rm = TRUE))


# To refer to column names that are stored as strings, use the `.data` pronoun:
vars &lt;- c("mass", "height")
cond &lt;- c(80, 150)
starwars %&gt;%
  filter(
    .data[[vars[[1]]]] &gt; cond[[1]],
    .data[[vars[[2]]]] &gt; cond[[2]]
  )
# Learn more in ?rlang::args_data_masking
</code></pre>

<hr>
<h2 id='filter_all'>Filter within a selection of variables</h2><span id='topic+filter_all'></span><span id='topic+filter_if'></span><span id='topic+filter_at'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code>, <code style="white-space: pre;">&#8288;_all&#8288;</code>) have been superseded by the use of
<code><a href="dplyr.html#topic+if_all">if_all()</a></code> or <code><a href="dplyr.html#topic+if_any">if_any()</a></code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>These <a href="dplyr.html#topic+scoped">scoped</a> filtering verbs apply a predicate expression to a
selection of variables. The predicate expression should be quoted
with <code><a href="dplyr.html#topic+all_vars">all_vars()</a></code> or <code><a href="dplyr.html#topic+any_vars">any_vars()</a></code> and should mention the pronoun
<code>.</code> to refer to variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_all(.tbl, .vars_predicate, .preserve = FALSE)

filter_if(.tbl, .predicate, .vars_predicate, .preserve = FALSE)

filter_at(.tbl, .vars, .vars_predicate, .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_all_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="filter_all_+3A_.vars_predicate">.vars_predicate</code></td>
<td>
<p>A quoted predicate expression as returned by
<code><a href="dplyr.html#topic+all_vars">all_vars()</a></code> or <code><a href="dplyr.html#topic+any_vars">any_vars()</a></code>.
</p>
<p>Can also be a function or purrr-like formula. In this case, the
intersection of the results is taken by default and there's
currently no way to request the union.</p>
</td></tr>
<tr><td><code id="filter_all_+3A_.preserve">.preserve</code></td>
<td>
<p>when <code>FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise it is kept as is.</p>
</td></tr>
<tr><td><code id="filter_all_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
<tr><td><code id="filter_all_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Grouping variables</h3>

<p>The grouping variables that are part of the selection are taken
into account to determine filtered rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># While filter() accepts expressions with specific variables, the
# scoped filter verbs take an expression with the pronoun `.` and
# replicate it over all variables. This expression should be quoted
# with all_vars() or any_vars():
all_vars(is.na(.))
any_vars(is.na(.))


# You can take the intersection of the replicated expressions:
filter_all(mtcars, all_vars(. &gt; 150))
# -&gt;
filter(mtcars, if_all(everything(), ~ .x &gt; 150))

# Or the union:
filter_all(mtcars, any_vars(. &gt; 150))
# -&gt;
filter(mtcars, if_any(everything(), ~ . &gt; 150))


# You can vary the selection of columns on which to apply the
# predicate. filter_at() takes a vars() specification:
filter_at(mtcars, vars(starts_with("d")), any_vars((. %% 2) == 0))
# -&gt;
filter(mtcars, if_any(starts_with("d"), ~ (.x %% 2) == 0))

# And filter_if() selects variables with a predicate function:
filter_if(mtcars, ~ all(floor(.) == .), all_vars(. != 0))
# -&gt;
is_int &lt;- function(x) all(floor(x) == x)
filter(mtcars, if_all(where(is_int), ~ .x != 0))
</code></pre>

<hr>
<h2 id='filter-joins'>Filtering joins</h2><span id='topic+filter-joins'></span><span id='topic+semi_join'></span><span id='topic+semi_join.data.frame'></span><span id='topic+anti_join'></span><span id='topic+anti_join.data.frame'></span>

<h3>Description</h3>

<p>Filtering joins filter rows from <code>x</code> based on the presence or absence
of matches in <code>y</code>:
</p>

<ul>
<li> <p><code>semi_join()</code> return all rows from <code>x</code> with a match in <code>y</code>.
</p>
</li>
<li> <p><code>anti_join()</code> return all rows from <code>x</code> with<strong>out</strong> a match in <code>y</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>semi_join(x, y, by = NULL, copy = FALSE, ...)

## S3 method for class 'data.frame'
semi_join(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never"))

anti_join(x, y, by = NULL, copy = FALSE, ...)

## S3 method for class 'data.frame'
anti_join(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter-joins_+3A_x">x</code>, <code id="filter-joins_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code>. The output has the following properties:
</p>

<ul>
<li><p> Rows are a subset of the input, but appear in the same order.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are taken from <code>x</code>. The number of groups may be reduced.
</p>
</li></ul>



<h3>Methods</h3>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>semi_join()</code>: no methods found.
</p>
</li>
<li> <p><code>anti_join()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+cross_join">cross_join</a>()</code>,
<code><a href="dplyr.html#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="dplyr.html#topic+nest_join">nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "Filtering" joins keep cases from the LHS
band_members %&gt;% semi_join(band_instruments)
band_members %&gt;% anti_join(band_instruments)

# To suppress the message about joining variables, supply `by`
band_members %&gt;% semi_join(band_instruments, by = join_by(name))
# This is good practice in production code
</code></pre>

<hr>
<h2 id='funs'>Create a list of function calls</h2><span id='topic+funs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>funs()</code> is deprecated; please use <code>list()</code> instead. We deprecated this
function because it provided a unique way of specifying anonymous functions,
rather than adopting the conventions used by purrr and other packages
in the tidyverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funs(..., .args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; A list of functions
specified by:
</p>

<ul>
<li><p> Their name, <code>"mean"</code>
</p>
</li>
<li><p> The function itself, <code>mean</code>
</p>
</li>
<li><p> A call to the function with <code>.</code> as a dummy argument,
<code>mean(., na.rm = TRUE)</code>
</p>
</li></ul>

<p>The following notations are <strong>not</strong> supported, see examples:
</p>

<ul>
<li><p> An anonymous function, <code>function(x) mean(x, na.rm = TRUE)</code>
</p>
</li>
<li><p> An anonymous function in <span class="pkg">purrr</span> notation, <code>~mean(., na.rm = TRUE)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="funs_+3A_.args">.args</code>, <code id="funs_+3A_args">args</code></td>
<td>
<p>A named list of additional arguments to be added to all
function calls. As <code>funs()</code> is being deprecated, use other methods to
supply arguments: <code>...</code> argument in <a href="dplyr.html#topic+summarise_at">scoped verbs</a> or make
own functions with <code><a href="purrr.html#topic+partial">purrr::partial()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>funs("mean", mean(., na.rm = TRUE))
# -&gt;
list(mean = mean, mean = ~ mean(.x, na.rm = TRUE))

funs(m1 = mean, m2 = "mean", m3 = mean(., na.rm = TRUE))
# -&gt;
list(m1 = mean, m2 = "mean", m3 = ~ mean(.x, na.rm = TRUE))
</code></pre>

<hr>
<h2 id='glimpse'>Get a glimpse of your data</h2><span id='topic+glimpse'></span>

<h3>Description</h3>

<p><code>glimpse()</code> is like a transposed version of <code>print()</code>:
columns run down the page, and data runs across.
This makes it possible to see every column in a data frame.
It's a little like <code><a href="utils.html#topic+str">str()</a></code> applied to a data frame
but it tries to show you as much data as possible.
(And it always shows the underlying data, even when applied
to a remote data source.)
</p>
<p><code>glimpse()</code> is provided by the pillar package, and re-exported
by dplyr. See <code><a href="pillar.html#topic+glimpse">pillar::glimpse()</a></code> for more details.
</p>


<h3>Value</h3>

<p>x original x is (invisibly) returned, allowing <code>glimpse()</code> to be
used within a data pipeline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>glimpse(mtcars)

# Note that original x is (invisibly) returned, allowing `glimpse()` to be
# used within a pipeline.
mtcars %&gt;%
  glimpse() %&gt;%
  select(1:3)

glimpse(starwars)
</code></pre>

<hr>
<h2 id='group_by'>Group by one or more variables</h2><span id='topic+group_by'></span><span id='topic+ungroup'></span>

<h3>Description</h3>

<p>Most data operations are done on groups defined by variables.
<code>group_by()</code> takes an existing tbl and converts it into a grouped tbl
where operations are performed &quot;by group&quot;. <code>ungroup()</code> removes grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))

ungroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
<tr><td><code id="group_by_+3A_x">x</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grouped data frame with class <code><a href="dplyr.html#topic+grouped_df">grouped_df</a></code>,
unless the combination of <code>...</code> and <code>add</code> yields a empty set of
grouping columns, in which case a tibble will be returned.
</p>


<h3>Methods</h3>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>group_by()</code>: no methods found.
</p>
</li>
<li> <p><code>ungroup()</code>: no methods found.
</p>
</li></ul>



<h3>Ordering</h3>

<p>Currently, <code>group_by()</code> internally orders the groups in ascending order. This
results in ordered output from functions that aggregate groups, such as
<code><a href="dplyr.html#topic+summarise">summarise()</a></code>.
</p>
<p>When used as grouping columns, character vectors are ordered in the C locale
for performance and reproducibility across R sessions. If the resulting
ordering of your grouped operation matters and is dependent on the locale,
you should follow up the grouped operation with an explicit call to
<code><a href="dplyr.html#topic+arrange">arrange()</a></code> and set the <code>.locale</code> argument. For example:
</p>
<div class="sourceCode"><pre>data %&gt;%
  group_by(chr) %&gt;%
  summarise(avg = mean(x)) %&gt;%
  arrange(chr, .locale = "en")
</pre></div>
<p>This is often useful as a preliminary step before generating content intended
for humans, such as an HTML table.
</p>


<h4>Legacy behavior</h4>

<p>Prior to dplyr 1.1.0, character vector grouping columns were ordered in the
system locale. If you need to temporarily revert to this behavior, you can
set the global option <code>dplyr.legacy_locale</code> to <code>TRUE</code>, but this should be
used sparingly and you should expect this option to be removed in a future
version of dplyr. It is better to update existing code to explicitly call
<code>arrange(.locale = )</code> instead. Note that setting <code>dplyr.legacy_locale</code> will
also force calls to <code><a href="dplyr.html#topic+arrange">arrange()</a></code> to use the system locale.
</p>



<h3>See Also</h3>

<p>Other grouping functions: 
<code><a href="dplyr.html#topic+group_map">group_map</a>()</code>,
<code><a href="dplyr.html#topic+group_nest">group_nest</a>()</code>,
<code><a href="dplyr.html#topic+group_split">group_split</a>()</code>,
<code><a href="dplyr.html#topic+group_trim">group_trim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>by_cyl &lt;- mtcars %&gt;% group_by(cyl)

# grouping doesn't change how the data looks (apart from listing
# how it's grouped):
by_cyl

# It changes how it acts with the other dplyr verbs:
by_cyl %&gt;% summarise(
  disp = mean(disp),
  hp = mean(hp)
)
by_cyl %&gt;% filter(disp == max(disp))

# Each call to summarise() removes a layer of grouping
by_vs_am &lt;- mtcars %&gt;% group_by(vs, am)
by_vs &lt;- by_vs_am %&gt;% summarise(n = n())
by_vs
by_vs %&gt;% summarise(n = sum(n))

# To removing grouping, use ungroup
by_vs %&gt;%
  ungroup() %&gt;%
  summarise(n = sum(n))

# By default, group_by() overrides existing grouping
by_cyl %&gt;%
  group_by(vs, am) %&gt;%
  group_vars()

# Use add = TRUE to instead append
by_cyl %&gt;%
  group_by(vs, am, .add = TRUE) %&gt;%
  group_vars()

# You can group by expressions: this is a short-hand
# for a mutate() followed by a group_by()
mtcars %&gt;%
  group_by(vsam = vs + am)

# The implicit mutate() step is always performed on the
# ungrouped data. Here we get 3 groups:
mtcars %&gt;%
  group_by(vs) %&gt;%
  group_by(hp_cut = cut(hp, 3))

# If you want it to be performed by groups,
# you have to use an explicit mutate() call.
# Here we get 3 groups per value of vs
mtcars %&gt;%
  group_by(vs) %&gt;%
  mutate(hp_cut = cut(hp, 3)) %&gt;%
  group_by(hp_cut)

# when factors are involved and .drop = FALSE, groups can be empty
tbl &lt;- tibble(
  x = 1:10,
  y = factor(rep(c("a", "c"), each  = 5), levels = c("a", "b", "c"))
)
tbl %&gt;%
  group_by(y, .drop = FALSE) %&gt;%
  group_rows()

</code></pre>

<hr>
<h2 id='group_by_all'>Group by a selection of variables</h2><span id='topic+group_by_all'></span><span id='topic+group_by_at'></span><span id='topic+group_by_if'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code>, <code style="white-space: pre;">&#8288;_all&#8288;</code>) have been superseded by the use of
<code><a href="dplyr.html#topic+pick">pick()</a></code> or <code><a href="dplyr.html#topic+across">across()</a></code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>These <a href="dplyr.html#topic+scoped">scoped</a> variants of <code><a href="dplyr.html#topic+group_by">group_by()</a></code> group a data frame by a
selection of variables. Like <code><a href="dplyr.html#topic+group_by">group_by()</a></code>, they have optional
<a href="dplyr.html#topic+mutate">mutate</a> semantics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by_all(
  .tbl,
  .funs = list(),
  ...,
  .add = FALSE,
  .drop = group_by_drop_default(.tbl)
)

group_by_at(
  .tbl,
  .vars,
  .funs = list(),
  ...,
  .add = FALSE,
  .drop = group_by_drop_default(.tbl)
)

group_by_if(
  .tbl,
  .predicate,
  .funs = list(),
  ...,
  .add = FALSE,
  .drop = group_by_drop_default(.tbl)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_all_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="group_by_all_+3A_.funs">.funs</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td></tr>
<tr><td><code id="group_by_all_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with <a href="rlang.html#topic+dyn-dots">tidy dots</a> support.</p>
</td></tr>
<tr><td><code id="group_by_all_+3A_.add">.add</code></td>
<td>
<p>See <code><a href="dplyr.html#topic+group_by">group_by()</a></code></p>
</td></tr>
<tr><td><code id="group_by_all_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
<tr><td><code id="group_by_all_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="group_by_all_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
</table>


<h3>Grouping variables</h3>

<p>Existing grouping variables are maintained, even if not included in
the selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Group a data frame by all variables:
group_by_all(mtcars)
# -&gt;
mtcars %&gt;% group_by(pick(everything()))

# Group by variables selected with a predicate:
group_by_if(iris, is.factor)
# -&gt;
iris %&gt;% group_by(pick(where(is.factor)))

# Group by variables selected by name:
group_by_at(mtcars, vars(vs, am))
# -&gt;
mtcars %&gt;% group_by(pick(vs, am))

# Like group_by(), the scoped variants have optional mutate
# semantics. This provide a shortcut for group_by() + mutate():
d &lt;- tibble(x=c(1,1,2,2), y=c(1,2,1,2))
group_by_all(d, as.factor)
# -&gt;
d %&gt;% group_by(across(everything(), as.factor))

group_by_if(iris, is.factor, as.character)
# -&gt;
iris %&gt;% group_by(across(where(is.factor), as.character))
</code></pre>

<hr>
<h2 id='group_by_drop_default'>Default value for .drop argument of group_by</h2><span id='topic+group_by_drop_default'></span>

<h3>Description</h3>

<p>Default value for .drop argument of group_by
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by_drop_default(.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_drop_default_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> unless <code>.tbl</code> is a grouped data frame that was previously
obtained by <code>group_by(.drop = FALSE)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>group_by_drop_default(iris)

iris %&gt;%
  group_by(Species) %&gt;%
  group_by_drop_default()

iris %&gt;%
  group_by(Species, .drop = FALSE) %&gt;%
  group_by_drop_default()

</code></pre>

<hr>
<h2 id='group_cols'>Select grouping variables</h2><span id='topic+group_cols'></span>

<h3>Description</h3>

<p>This selection helpers matches grouping variables. It can be used
in <code><a href="MASS.html#topic+select">select()</a></code> or <code><a href="dplyr.html#topic+vars">vars()</a></code> selections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_cols(vars = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_cols_+3A_vars">vars</code></td>
<td>
<p>Deprecated; please use data instead.</p>
</td></tr>
<tr><td><code id="group_cols_+3A_data">data</code></td>
<td>
<p>For advanced use only. The default <code>NULL</code> automatically
finds the &quot;current&quot; data frames.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+groups">groups()</a></code> and <code><a href="dplyr.html#topic+group_vars">group_vars()</a></code> for retrieving the grouping
variables outside selection contexts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gdf &lt;- iris %&gt;% group_by(Species)
gdf %&gt;% select(group_cols())

# Remove the grouping variables from mutate selections:
gdf %&gt;% mutate_at(vars(-group_cols()), `/`, 100)
# -&gt; No longer necessary with across()
gdf %&gt;% mutate(across(everything(), ~ . / 100))
</code></pre>

<hr>
<h2 id='group_data'>Grouping metadata</h2><span id='topic+group_data'></span><span id='topic+group_keys'></span><span id='topic+group_rows'></span><span id='topic+group_indices'></span><span id='topic+group_vars'></span><span id='topic+groups'></span><span id='topic+group_size'></span><span id='topic+n_groups'></span>

<h3>Description</h3>

<p>This collection of functions accesses data about grouped data frames in
various ways:
</p>

<ul>
<li> <p><code>group_data()</code> returns a data frame that defines the grouping structure.
The columns give the values of the grouping variables. The last column,
always called <code>.rows</code>, is a list of integer vectors that gives the
location of the rows in each group.
</p>
</li>
<li> <p><code>group_keys()</code> returns a data frame describing the groups.
</p>
</li>
<li> <p><code>group_rows()</code> returns a list of integer vectors giving the rows that
each group contains.
</p>
</li>
<li> <p><code>group_indices()</code> returns an integer vector the same length as <code>.data</code>
that gives the group that each row belongs to.
</p>
</li>
<li> <p><code>group_vars()</code> gives names of grouping variables as character vector.
</p>
</li>
<li> <p><code>groups()</code> gives the names of the grouping variables as a list of symbols.
</p>
</li>
<li> <p><code>group_size()</code> gives the size of each group.
</p>
</li>
<li> <p><code>n_groups()</code> gives the total number of groups.
</p>
</li></ul>

<p>See <a href="dplyr.html#topic+context">context</a> for equivalent functions that return values for the <em>current</em>
group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_data(.data)

group_keys(.tbl, ...)

group_rows(.data)

group_indices(.data, ...)

group_vars(x)

groups(x)

group_size(x)

n_groups(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_data_+3A_.data">.data</code>, <code id="group_data_+3A_.tbl">.tbl</code>, <code id="group_data_+3A_x">x</code></td>
<td>
<p>A data frame or extension (like a tibble or grouped
tibble).</p>
</td></tr>
<tr><td><code id="group_data_+3A_...">...</code></td>
<td>
<p>Use of <code>...</code> is now deprecated; please use <code>group_by()</code> first
instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = c(1,1,2,2))
group_vars(df)
group_rows(df)
group_data(df)
group_indices(df)

gf &lt;- group_by(df, x)
group_vars(gf)
group_rows(gf)
group_data(gf)
group_indices(gf)
</code></pre>

<hr>
<h2 id='group_map'>Apply a function to each group</h2><span id='topic+group_map'></span><span id='topic+group_modify'></span><span id='topic+group_walk'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>group_map()</code>, <code>group_modify()</code> and <code>group_walk()</code> are purrr-style functions that can
be used to iterate on grouped tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_map(.data, .f, ..., .keep = FALSE)

group_modify(.data, .f, ..., .keep = FALSE)

group_walk(.data, .f, ..., .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_map_+3A_.data">.data</code></td>
<td>
<p>A grouped tibble</p>
</td></tr>
<tr><td><code id="group_map_+3A_.f">.f</code></td>
<td>
<p>A function or formula to apply to each group.
</p>
<p>If a <strong>function</strong>, it is used as is. It should have at least 2 formal arguments.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ head(.x)</code>, it is converted to a function.
</p>
<p>In the formula, you can use
</p>

<ul>
<li> <p><code>.</code> or <code>.x</code> to refer to the subset of rows of <code>.tbl</code>
for the given group
</p>
</li>
<li> <p><code>.y</code> to refer to the key, a one row tibble with one column per grouping variable
that identifies the group
</p>
</li></ul>
</td></tr>
<tr><td><code id="group_map_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="group_map_+3A_.keep">.keep</code></td>
<td>
<p>are the grouping variables kept in <code>.x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>group_modify()</code> when <code>summarize()</code> is too limited, in terms of what you need
to do and return for each group. <code>group_modify()</code> is good for &quot;data frame in, data frame out&quot;.
If that is too limited, you need to use a <a href="dplyr.html#topic+group_nest">nested</a> or <a href="dplyr.html#topic+group_split">split</a> workflow.
<code>group_modify()</code> is an evolution of <code><a href="dplyr.html#topic+do">do()</a></code>, if you have used that before.
</p>
<p>Each conceptual group of the data frame is exposed to the function <code>.f</code> with two pieces of information:
</p>

<ul>
<li><p> The subset of the data for the group, exposed as <code>.x</code>.
</p>
</li>
<li><p> The key, a tibble with exactly one row and columns for each grouping variable, exposed as <code>.y</code>.
</p>
</li></ul>

<p>For completeness, <code>group_modify()</code>, <code>group_map</code> and <code>group_walk()</code> also work on
ungrouped data frames, in that case the function is applied to the
entire data frame (exposed as <code>.x</code>), and <code>.y</code> is a one row tibble with no
column, consistently with <code><a href="dplyr.html#topic+group_keys">group_keys()</a></code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>group_modify()</code> returns a grouped tibble. In that case <code>.f</code> must return a data frame.
</p>
</li>
<li> <p><code>group_map()</code> returns a list of results from calling <code>.f</code> on each group.
</p>
</li>
<li> <p><code>group_walk()</code> calls <code>.f</code> for side effects and returns the input <code>.tbl</code>, invisibly.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other grouping functions: 
<code><a href="dplyr.html#topic+group_by">group_by</a>()</code>,
<code><a href="dplyr.html#topic+group_nest">group_nest</a>()</code>,
<code><a href="dplyr.html#topic+group_split">group_split</a>()</code>,
<code><a href="dplyr.html#topic+group_trim">group_trim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# return a list
mtcars %&gt;%
  group_by(cyl) %&gt;%
  group_map(~ head(.x, 2L))

# return a tibble grouped by `cyl` with 2 rows per group
# the grouping data is recalculated
mtcars %&gt;%
  group_by(cyl) %&gt;%
  group_modify(~ head(.x, 2L))


# a list of tibbles
iris %&gt;%
  group_by(Species) %&gt;%
  group_map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))

# a restructured grouped tibble
iris %&gt;%
  group_by(Species) %&gt;%
  group_modify(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))


# a list of vectors
iris %&gt;%
  group_by(Species) %&gt;%
  group_map(~ quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)))

# to use group_modify() the lambda must return a data frame
iris %&gt;%
  group_by(Species) %&gt;%
  group_modify(~ {
     quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)) %&gt;%
     tibble::enframe(name = "prob", value = "quantile")
  })

iris %&gt;%
  group_by(Species) %&gt;%
  group_modify(~ {
    .x %&gt;%
      purrr::map_dfc(fivenum) %&gt;%
      mutate(nms = c("min", "Q1", "median", "Q3", "max"))
  })

# group_walk() is for side effects
dir.create(temp &lt;- tempfile())
iris %&gt;%
  group_by(Species) %&gt;%
  group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, ".csv"))))
list.files(temp, pattern = "csv$")
unlink(temp, recursive = TRUE)

# group_modify() and ungrouped data frames
mtcars %&gt;%
  group_modify(~ head(.x, 2L))

</code></pre>

<hr>
<h2 id='group_nest'>Nest a tibble using a grouping specification</h2><span id='topic+group_nest'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Nest a tibble using a grouping specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_nest(.tbl, ..., .key = "data", keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_nest_+3A_.tbl">.tbl</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="group_nest_+3A_...">...</code></td>
<td>
<p>Grouping specification, forwarded to <code><a href="dplyr.html#topic+group_by">group_by()</a></code></p>
</td></tr>
<tr><td><code id="group_nest_+3A_.key">.key</code></td>
<td>
<p>the name of the list column</p>
</td></tr>
<tr><td><code id="group_nest_+3A_keep">keep</code></td>
<td>
<p>Should the grouping columns be kept in the list column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl with one row per unique combination of the grouping variables.
The first columns are the grouping variables, followed by a list column of tibbles
with matching rows of the remaining columns.
</p>


<h3>Lifecycle</h3>

<p><code>group_nest()</code> is not stable because <code><a href="tidyr.html#topic+nest">tidyr::nest(.by =)</a></code>
provides very similar behavior. It may be deprecated in the future.
</p>


<h3>Grouped data frames</h3>

<p>The primary use case for <code><a href="dplyr.html#topic+group_nest">group_nest()</a></code> is with already grouped data frames,
typically a result of <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. In this case <code><a href="dplyr.html#topic+group_nest">group_nest()</a></code> only uses
the first argument, the grouped tibble, and warns when <code>...</code> is used.
</p>


<h3>Ungrouped data frames</h3>

<p>When used on ungrouped data frames, <code><a href="dplyr.html#topic+group_nest">group_nest()</a></code> forwards the <code>...</code> to
<code><a href="dplyr.html#topic+group_by">group_by()</a></code> before nesting, therefore the <code>...</code> are subject to the data mask.
</p>


<h3>See Also</h3>

<p>Other grouping functions: 
<code><a href="dplyr.html#topic+group_by">group_by</a>()</code>,
<code><a href="dplyr.html#topic+group_map">group_map</a>()</code>,
<code><a href="dplyr.html#topic+group_split">group_split</a>()</code>,
<code><a href="dplyr.html#topic+group_trim">group_trim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----- use case 1: a grouped data frame
iris %&gt;%
  group_by(Species) %&gt;%
  group_nest()

# this can be useful if the grouped data has been altered before nesting
iris %&gt;%
  group_by(Species) %&gt;%
  filter(Sepal.Length &gt; mean(Sepal.Length)) %&gt;%
  group_nest()

#----- use case 2: using group_nest() on a ungrouped data frame with
#                  a grouping specification that uses the data mask
starwars %&gt;%
  group_nest(species, homeworld)
</code></pre>

<hr>
<h2 id='group_split'>Split data frame by groups</h2><span id='topic+group_split'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code><a href="dplyr.html#topic+group_split">group_split()</a></code> works like <code><a href="base.html#topic+split">base::split()</a></code> but:
</p>

<ul>
<li><p> It uses the grouping structure from <code><a href="dplyr.html#topic+group_by">group_by()</a></code> and therefore is subject
to the data mask
</p>
</li>
<li><p> It does not name the elements of the list based on the grouping as this
only works well for a single character grouping variable. Instead,
use <code><a href="dplyr.html#topic+group_keys">group_keys()</a></code> to access a data frame that defines the groups.
</p>
</li></ul>

<p><code>group_split()</code> is primarily designed to work with grouped data frames.
You can pass <code>...</code> to group and split an ungrouped data frame, but this
is generally not very useful as you want have easy access to the group
metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_split(.tbl, ..., .keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_split_+3A_.tbl">.tbl</code></td>
<td>
<p>A tbl.</p>
</td></tr>
<tr><td><code id="group_split_+3A_...">...</code></td>
<td>
<p>If <code>.tbl</code> is an ungrouped data frame, a grouping specification,
forwarded to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.</p>
</td></tr>
<tr><td><code id="group_split_+3A_.keep">.keep</code></td>
<td>
<p>Should the grouping columns be kept?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tibbles. Each tibble contains the rows of <code>.tbl</code> for the
associated group and all the columns, including the grouping variables.
Note that this returns a <a href="vctrs.html#topic+list_of">list_of</a> which is slightly
stricter than a simple list but is useful for representing lists where
every element has the same type.
</p>


<h3>Lifecycle</h3>

<p><code>group_split()</code> is not stable because you can achieve very similar results by
manipulating the nested column returned from
<code><a href="tidyr.html#topic+nest">tidyr::nest(.by =)</a></code>. That also retains the group keys all
within a single data structure. <code>group_split()</code> may be deprecated in the
future.
</p>


<h3>See Also</h3>

<p>Other grouping functions: 
<code><a href="dplyr.html#topic+group_by">group_by</a>()</code>,
<code><a href="dplyr.html#topic+group_map">group_map</a>()</code>,
<code><a href="dplyr.html#topic+group_nest">group_nest</a>()</code>,
<code><a href="dplyr.html#topic+group_trim">group_trim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ir &lt;- iris %&gt;% group_by(Species)

group_split(ir)
group_keys(ir)
</code></pre>

<hr>
<h2 id='group_trim'>Trim grouping structure</h2><span id='topic+group_trim'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Drop unused levels of all factors that are used as grouping variables,
then recalculates the grouping structure.
</p>
<p><code>group_trim()</code> is particularly useful after a <code><a href="stats.html#topic+filter">filter()</a></code> that is intended
to select a subset of groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_trim(.tbl, .drop = group_by_drop_default(.tbl))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_trim_+3A_.tbl">.tbl</code></td>
<td>
<p>A <a href="dplyr.html#topic+grouped_df">grouped data frame</a></p>
</td></tr>
<tr><td><code id="group_trim_+3A_.drop">.drop</code></td>
<td>
<p>See <code><a href="dplyr.html#topic+group_by">group_by()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="dplyr.html#topic+grouped_df">grouped data frame</a>
</p>


<h3>See Also</h3>

<p>Other grouping functions: 
<code><a href="dplyr.html#topic+group_by">group_by</a>()</code>,
<code><a href="dplyr.html#topic+group_map">group_map</a>()</code>,
<code><a href="dplyr.html#topic+group_nest">group_nest</a>()</code>,
<code><a href="dplyr.html#topic+group_split">group_split</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;%
  group_by(Species) %&gt;%
  filter(Species == "setosa", .preserve = TRUE) %&gt;%
  group_trim()
</code></pre>

<hr>
<h2 id='grouped_df'>A grouped data frame.</h2><span id='topic+grouped_df'></span><span id='topic+is.grouped_df'></span><span id='topic+is_grouped_df'></span>

<h3>Description</h3>

<p>The easiest way to create a grouped data frame is to call the <code>group_by()</code>
method on a data frame or tbl: this will take care of capturing
the unevaluated expressions for you.
</p>
<p>These functions are designed for programmatic use. For data analysis
purposes see <code><a href="dplyr.html#topic+group_data">group_data()</a></code> for the accessor functions that retrieve
various metadata from a grouped data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_df(data, vars, drop = group_by_drop_default(data))

is.grouped_df(x)

is_grouped_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped_df_+3A_data">data</code></td>
<td>
<p>a tbl or data frame.</p>
</td></tr>
<tr><td><code id="grouped_df_+3A_vars">vars</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="grouped_df_+3A_drop">drop</code></td>
<td>
<p>When <code>.drop = TRUE</code>, empty groups are dropped.</p>
</td></tr>
</table>

<hr>
<h2 id='ident'>Flag a character vector as SQL identifiers</h2><span id='topic+ident'></span>

<h3>Description</h3>

<p><code>ident()</code> takes unquoted strings and flags them as identifiers.
<code>ident_q()</code> assumes its input has already been quoted, and ensures
it does not get quoted again. This is currently used only for
<code>schema.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ident(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ident_+3A_...">...</code></td>
<td>
<p>A character vector, or name-value pairs</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Identifiers are escaped with "

ident("x")

</code></pre>

<hr>
<h2 id='if_else'>Vectorised if-else</h2><span id='topic+if_else'></span>

<h3>Description</h3>

<p><code>if_else()</code> is a vectorized <a href="base.html#topic+if">if-else</a>. Compared to the base R equivalent,
<code><a href="base.html#topic+ifelse">ifelse()</a></code>, this function allows you to handle missing values in the
<code>condition</code> with <code>missing</code> and always takes <code>true</code>, <code>false</code>, and <code>missing</code>
into account when determining what the output type should be.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else(condition, true, false, missing = NULL, ..., ptype = NULL, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_else_+3A_condition">condition</code></td>
<td>
<p>A logical vector</p>
</td></tr>
<tr><td><code id="if_else_+3A_true">true</code>, <code id="if_else_+3A_false">false</code></td>
<td>
<p>Vectors to use for <code>TRUE</code> and <code>FALSE</code> values of
<code>condition</code>.
</p>
<p>Both <code>true</code> and <code>false</code> will be <a href="vctrs.html#topic+theory-faq-recycling">recycled</a>
to the size of <code>condition</code>.
</p>
<p><code>true</code>, <code>false</code>, and <code>missing</code> (if used) will be cast to their common type.</p>
</td></tr>
<tr><td><code id="if_else_+3A_missing">missing</code></td>
<td>
<p>If not <code>NULL</code>, will be used as the value for <code>NA</code> values of
<code>condition</code>. Follows the same size and type rules as <code>true</code> and <code>false</code>.</p>
</td></tr>
<tr><td><code id="if_else_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="if_else_+3A_ptype">ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If
supplied, this overrides the common type of <code>true</code>, <code>false</code>, and <code>missing</code>.</p>
</td></tr>
<tr><td><code id="if_else_+3A_size">size</code></td>
<td>
<p>An optional size declaring the desired output size. If supplied,
this overrides the size of <code>condition</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same size as <code>condition</code> and the same type as the common
type of <code>true</code>, <code>false</code>, and <code>missing</code>.
</p>
<p>Where <code>condition</code> is <code>TRUE</code>, the matching values from <code>true</code>, where it is
<code>FALSE</code>, the matching values from <code>false</code>, and where it is <code>NA</code>, the matching
values from <code>missing</code>, if provided, otherwise a missing value will be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(-5:5, NA)
if_else(x &lt; 0, NA, x)

# Explicitly handle `NA` values in the `condition` with `missing`
if_else(x &lt; 0, "negative", "positive", missing = "missing")

# Unlike `ifelse()`, `if_else()` preserves types
x &lt;- factor(sample(letters[1:5], 10, replace = TRUE))
ifelse(x %in% c("a", "b", "c"), x, NA)
if_else(x %in% c("a", "b", "c"), x, NA)

# `if_else()` is often useful for creating new columns inside of `mutate()`
starwars %&gt;%
  mutate(category = if_else(height &lt; 100, "short", "tall"), .keep = "used")
</code></pre>

<hr>
<h2 id='join_by'>Join specifications</h2><span id='topic+join_by'></span><span id='topic+closest'></span><span id='topic+overlaps'></span><span id='topic+within'></span>

<h3>Description</h3>

<p><code>join_by()</code> constructs a specification that describes how to join two tables
using a small domain specific language. The result can be supplied as the
<code>by</code> argument to any of the join functions (such as <code><a href="dplyr.html#topic+left_join">left_join()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_by(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_by_+3A_...">...</code></td>
<td>
<p>Expressions specifying the join.
</p>
<p>Each expression should consist of one of the following:
</p>

<ul>
<li><p> Equality condition: <code>==</code>
</p>
</li>
<li><p> Inequality conditions: <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, or <code>&lt;</code>
</p>
</li>
<li><p> Rolling helper: <code>closest()</code>
</p>
</li>
<li><p> Overlap helpers: <code>between()</code>, <code>within()</code>, or <code>overlaps()</code>
</p>
</li></ul>

<p>Other expressions are not supported. If you need to perform a join on
a computed variable, e.g. <code>join_by(sales_date - 40 &gt;= promo_date)</code>,
you'll need to precompute and store it in a separate column.
</p>
<p>Column names should be specified as quoted or unquoted names. By default,
the name on the left-hand side of a join condition refers to the left-hand
table, unless overridden by explicitly prefixing the column name with
either <code style="white-space: pre;">&#8288;x$&#8288;</code> or <code style="white-space: pre;">&#8288;y$&#8288;</code>.
</p>
<p>If a single column name is provided without any join conditions, it is
interpreted as if that column name was duplicated on each side of <code>==</code>,
i.e. <code>x</code> is interpreted as <code>x == x</code>.</p>
</td></tr>
</table>


<h3>Join types</h3>

<p>The following types of joins are supported by dplyr:
</p>

<ul>
<li><p> Equality joins
</p>
</li>
<li><p> Inequality joins
</p>
</li>
<li><p> Rolling joins
</p>
</li>
<li><p> Overlap joins
</p>
</li>
<li><p> Cross joins
</p>
</li></ul>

<p>Equality, inequality, rolling, and overlap joins are discussed in more detail
below. Cross joins are implemented through <code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.
</p>


<h4>Equality joins</h4>

<p>Equality joins require keys to be equal between one or more pairs of columns,
and are the most common type of join. To construct an equality join using
<code>join_by()</code>, supply two column names to join with separated by <code>==</code>.
Alternatively, supplying a single name will be interpreted as an equality
join between two columns of the same name. For example, <code>join_by(x)</code> is
equivalent to <code>join_by(x == x)</code>.
</p>



<h4>Inequality joins</h4>

<p>Inequality joins match on an inequality, such as <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, or <code>&lt;=</code>, and
are common in time series analysis and genomics. To construct an inequality
join using <code>join_by()</code>, supply two column names separated by one of the above
mentioned inequalities.
</p>
<p>Note that inequality joins will match a single row in <code>x</code> to a potentially
large number of rows in <code>y</code>. Be extra careful when constructing inequality
join specifications!
</p>



<h4>Rolling joins</h4>

<p>Rolling joins are a variant of inequality joins that limit the results
returned from an inequality join condition. They are useful for &quot;rolling&quot; the
closest match forward/backwards when there isn't an exact match. To construct
a rolling join, wrap an inequality with <code>closest()</code>.
</p>

<ul>
<li> <p><code>closest(expr)</code>
</p>
<p><code>expr</code> must be an inequality involving one of: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, or <code>&lt;=</code>.
</p>
<p>For example, <code>closest(x &gt;= y)</code> is interpreted as: For each value in <code>x</code>,
find the closest value in <code>y</code> that is less than or equal to that <code>x</code> value.
</p>
</li></ul>

<p><code>closest()</code> will always use the left-hand table (<code>x</code>) as the primary table,
and the right-hand table (<code>y</code>) as the one to find the closest match in,
regardless of how the inequality is specified. For example,
<code>closest(y$a &gt;= x$b)</code> will always be interpreted as <code>closest(x$b &lt;= y$a)</code>.
</p>



<h4>Overlap joins</h4>

<p>Overlap joins are a special case of inequality joins involving one or two
columns from the left-hand table <em>overlapping</em> a range defined by two columns
from the right-hand table. There are three helpers that <code>join_by()</code>
recognizes to assist with constructing overlap joins, all of which can be
constructed from simpler inequalities.
</p>

<ul>
<li> <p><code>between(x, y_lower, y_upper, ..., bounds = "[]")</code>
</p>
<p>For each value in <code>x</code>, this finds everywhere that value falls between
<code style="white-space: pre;">&#8288;[y_lower, y_upper]&#8288;</code>. Equivalent to <code style="white-space: pre;">&#8288;x &gt;= y_lower, x &lt;= y_upper&#8288;</code> by
default.
</p>
<p><code>bounds</code> can be one of <code>"[]"</code>, <code>"[)"</code>, <code>"(]"</code>, or
<code>"()"</code> to alter the inclusiveness of the lower and upper bounds. This
changes whether <code>&gt;=</code> or <code>&gt;</code> and <code>&lt;=</code> or <code>&lt;</code> are used to build the
inequalities shown above.
</p>
<p>Dots are for future extensions and must be empty.
</p>
</li>
<li> <p><code>within(x_lower, x_upper, y_lower, y_upper)</code>
</p>
<p>For each range in <code style="white-space: pre;">&#8288;[x_lower, x_upper]&#8288;</code>, this finds everywhere that range
falls completely within <code style="white-space: pre;">&#8288;[y_lower, y_upper]&#8288;</code>. Equivalent to <code style="white-space: pre;">&#8288;x_lower &gt;= y_lower, x_upper &lt;= y_upper&#8288;</code>.
</p>
<p>The inequalities used to build <code>within()</code> are the same regardless of the
inclusiveness of the supplied ranges.
</p>
</li>
<li> <p><code>overlaps(x_lower, x_upper, y_lower, y_upper, ..., bounds = "[]")</code>
</p>
<p>For each range in <code style="white-space: pre;">&#8288;[x_lower, x_upper]&#8288;</code>, this finds everywhere that range
overlaps <code style="white-space: pre;">&#8288;[y_lower, y_upper]&#8288;</code> in any capacity. Equivalent to <code style="white-space: pre;">&#8288;x_lower &lt;= y_upper, x_upper &gt;= y_lower&#8288;</code> by default.
</p>
<p><code>bounds</code> can be one of <code>"[]"</code>, <code>"[)"</code>, <code>"(]"</code>, or
<code>"()"</code> to alter the inclusiveness of the lower and upper bounds.
<code>"[]"</code> uses <code>&lt;=</code> and <code>&gt;=</code>, but the 3 other options use <code>&lt;</code> and <code>&gt;</code>
and generate the exact same inequalities.
</p>
<p>Dots are for future extensions and must be empty.
</p>
</li></ul>

<p>These conditions assume that the ranges are well-formed and non-empty, i.e.
<code>x_lower &lt;= x_upper</code> when bounds are treated as <code>"[]"</code>, and
<code>x_lower &lt; x_upper</code> otherwise.
</p>



<h3>Column referencing</h3>

<p>When specifying join conditions, <code>join_by()</code> assumes that column names on the
left-hand side of the condition refer to the left-hand table (<code>x</code>), and names
on the right-hand side of the condition refer to the right-hand table (<code>y</code>).
Occasionally, it is clearer to be able to specify a right-hand table name on
the left-hand side of the condition, and vice versa. To support this, column
names can be prefixed by <code style="white-space: pre;">&#8288;x$&#8288;</code> or <code style="white-space: pre;">&#8288;y$&#8288;</code> to explicitly specify which table they
come from.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sales &lt;- tibble(
  id = c(1L, 1L, 1L, 2L, 2L),
  sale_date = as.Date(c("2018-12-31", "2019-01-02", "2019-01-05", "2019-01-04", "2019-01-01"))
)
sales

promos &lt;- tibble(
  id = c(1L, 1L, 2L),
  promo_date = as.Date(c("2019-01-01", "2019-01-05", "2019-01-02"))
)
promos

# Match `id` to `id`, and `sale_date` to `promo_date`
by &lt;- join_by(id, sale_date == promo_date)
left_join(sales, promos, by)

# For each `sale_date` within a particular `id`,
# find all `promo_date`s that occurred before that particular sale
by &lt;- join_by(id, sale_date &gt;= promo_date)
left_join(sales, promos, by)

# For each `sale_date` within a particular `id`,
# find only the closest `promo_date` that occurred before that sale
by &lt;- join_by(id, closest(sale_date &gt;= promo_date))
left_join(sales, promos, by)

# If you want to disallow exact matching in rolling joins, use `&gt;` rather
# than `&gt;=`. Note that the promo on `2019-01-05` is no longer considered the
# closest match for the sale on the same date.
by &lt;- join_by(id, closest(sale_date &gt; promo_date))
left_join(sales, promos, by)

# Same as before, but also require that the promo had to occur at most 1
# day before the sale was made. We'll use a full join to see that id 2's
# promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`.
sales &lt;- mutate(sales, sale_date_lower = sale_date - 1)
by &lt;- join_by(id, closest(sale_date &gt;= promo_date), sale_date_lower &lt;= promo_date)
full_join(sales, promos, by)

# ---------------------------------------------------------------------------

segments &lt;- tibble(
  segment_id = 1:4,
  chromosome = c("chr1", "chr2", "chr2", "chr1"),
  start = c(140, 210, 380, 230),
  end = c(150, 240, 415, 280)
)
segments

reference &lt;- tibble(
  reference_id = 1:4,
  chromosome = c("chr1", "chr1", "chr2", "chr2"),
  start = c(100, 200, 300, 415),
  end = c(150, 250, 399, 450)
)
reference

# Find every time a segment `start` falls between the reference
# `[start, end]` range.
by &lt;- join_by(chromosome, between(start, start, end))
full_join(segments, reference, by)

# If you wanted the reference columns first, supply `reference` as `x`
# and `segments` as `y`, then explicitly refer to their columns using `x$`
# and `y$`.
by &lt;- join_by(chromosome, between(y$start, x$start, x$end))
full_join(reference, segments, by)

# Find every time a segment falls completely within a reference.
# Sometimes using `x$` and `y$` makes your intentions clearer, even if they
# match the default behavior.
by &lt;- join_by(chromosome, within(x$start, x$end, y$start, y$end))
inner_join(segments, reference, by)

# Find every time a segment overlaps a reference in any way.
by &lt;- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end))
full_join(segments, reference, by)

# It is common to have right-open ranges with bounds like `[)`, which would
# mean an end value of `415` would no longer overlap a start value of `415`.
# Setting `bounds` allows you to compute overlaps with those kinds of ranges.
by &lt;- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end, bounds = "[)"))
full_join(segments, reference, by)
</code></pre>

<hr>
<h2 id='last_dplyr_warnings'>Show warnings from the last command</h2><span id='topic+last_dplyr_warnings'></span>

<h3>Description</h3>

<p>Warnings that occur inside a dplyr verb like <code>mutate()</code> are caught
and stashed away instead of being emitted to the console. This
prevents rowwise and grouped data frames from flooding the console
with warnings. To see the original warnings, use
<code>last_dplyr_warnings()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_dplyr_warnings(n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_dplyr_warnings_+3A_n">n</code></td>
<td>
<p>Passed to <code><a href="utils.html#topic+head">head()</a></code> so that only the first <code>n</code> warnings are
displayed.</p>
</td></tr>
</table>

<hr>
<h2 id='lead-lag'>Compute lagged or leading values</h2><span id='topic+lead-lag'></span><span id='topic+lag'></span><span id='topic+lead'></span>

<h3>Description</h3>

<p>Find the &quot;previous&quot; (<code>lag()</code>) or &quot;next&quot; (<code>lead()</code>) values in a vector. Useful
for comparing values behind of or ahead of the current values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag(x, n = 1L, default = NULL, order_by = NULL, ...)

lead(x, n = 1L, default = NULL, order_by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lead-lag_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="lead-lag_+3A_n">n</code></td>
<td>
<p>Positive integer of length 1, giving the number of positions to
lag or lead by</p>
</td></tr>
<tr><td><code id="lead-lag_+3A_default">default</code></td>
<td>
<p>The value used to pad <code>x</code> back to its original size after the
lag or lead has been applied. The default, <code>NULL</code>, pads with a missing
value. If supplied, this must be a vector with size 1, which will be cast
to the type of <code>x</code>.</p>
</td></tr>
<tr><td><code id="lead-lag_+3A_order_by">order_by</code></td>
<td>
<p>An optional secondary vector that defines the ordering to use
when applying the lag or lead to <code>x</code>. If supplied, this must be the same
size as <code>x</code>.</p>
</td></tr>
<tr><td><code id="lead-lag_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same type and size as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lag(1:5)
lead(1:5)

x &lt;- 1:5
tibble(behind = lag(x), x, ahead = lead(x))

# If you want to look more rows behind or ahead, use `n`
lag(1:5, n = 1)
lag(1:5, n = 2)

lead(1:5, n = 1)
lead(1:5, n = 2)

# If you want to define a value to pad with, use `default`
lag(1:5)
lag(1:5, default = 0)

lead(1:5)
lead(1:5, default = 6)

# If the data are not already ordered, use `order_by`
scrambled &lt;- slice_sample(
  tibble(year = 2000:2005, value = (0:5) ^ 2),
  prop = 1
)

wrong &lt;- mutate(scrambled, previous_year_value = lag(value))
arrange(wrong, year)

right &lt;- mutate(scrambled, previous_year_value = lag(value, order_by = year))
arrange(right, year)
</code></pre>

<hr>
<h2 id='make_tbl'>Create a &quot;tbl&quot; object</h2><span id='topic+make_tbl'></span>

<h3>Description</h3>

<p><code>tbl()</code> is the standard constructor for tbls. <code>as.tbl()</code> coerces,
and <code>is.tbl()</code> tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tbl(subclass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tbl_+3A_subclass">subclass</code></td>
<td>
<p>name of subclass. &quot;tbl&quot; is an abstract base class, so you
must supply this value. <code>tbl_</code> is automatically prepended to the
class name</p>
</td></tr>
<tr><td><code id="make_tbl_+3A_...">...</code></td>
<td>
<p>For <code>tbl()</code>, other fields used by class. For <code>as.tbl()</code>,
other arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='mutate'>Create, modify, and delete columns</h2><span id='topic+mutate'></span><span id='topic+mutate.data.frame'></span>

<h3>Description</h3>

<p><code>mutate()</code> creates new columns that are functions of existing variables.
It can also modify (if the name is the same as an existing
column) and delete columns (by setting their value to <code>NULL</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate(.data, ...)

## S3 method for class 'data.frame'
mutate(
  .data,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="mutate_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_+3A_.before">.before</code>, <code id="mutate_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Columns from <code>.data</code> will be preserved according to the <code>.keep</code> argument.
</p>
</li>
<li><p> Existing columns that are modified by <code>...</code> will always be returned in
their original location.
</p>
</li>
<li><p> New columns created through <code>...</code> will be placed according to the
<code>.before</code> and <code>.after</code> arguments.
</p>
</li>
<li><p> The number of rows is not affected.
</p>
</li>
<li><p> Columns given the value <code>NULL</code> will be removed.
</p>
</li>
<li><p> Groups will be recomputed if a grouping variable is mutated.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Useful mutate functions</h3>


<ul>
<li> <p><code><a href="base.html#topic++2B">+</a></code>, <code><a href="base.html#topic+-">-</a></code>, <code><a href="base.html#topic+log">log()</a></code>, etc., for their usual mathematical meanings
</p>
</li>
<li> <p><code><a href="data.table.html#topic+lead">lead()</a></code>, <code><a href="stats.html#topic+lag">lag()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+dense_rank">dense_rank()</a></code>, <code><a href="dplyr.html#topic+min_rank">min_rank()</a></code>, <code><a href="dplyr.html#topic+percent_rank">percent_rank()</a></code>, <code><a href="dplyr.html#topic+row_number">row_number()</a></code>,
<code><a href="dplyr.html#topic+cume_dist">cume_dist()</a></code>, <code><a href="dplyr.html#topic+ntile">ntile()</a></code>
</p>
</li>
<li> <p><code><a href="base.html#topic+cumsum">cumsum()</a></code>, <code><a href="dplyr.html#topic+cummean">cummean()</a></code>, <code><a href="base.html#topic+cummin">cummin()</a></code>, <code><a href="base.html#topic+cummax">cummax()</a></code>, <code><a href="dplyr.html#topic+cumany">cumany()</a></code>, <code><a href="dplyr.html#topic+cumall">cumall()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+na_if">na_if()</a></code>, <code><a href="dplyr.html#topic+coalesce">coalesce()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+if_else">if_else()</a></code>, <code><a href="car.html#topic+recode">recode()</a></code>, <code><a href="dplyr.html#topic+case_when">case_when()</a></code>
</p>
</li></ul>



<h3>Grouped tibbles</h3>

<p>Because mutating expressions are computed within groups, they may
yield different results on grouped tibbles. This will be the case
as soon as an aggregating, lagging, or ranking function is
involved. Compare this ungrouped mutate:
</p>
<div class="sourceCode"><pre>starwars %&gt;%
  select(name, mass, species) %&gt;%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
</pre></div>
<p>With the grouped equivalent:
</p>
<div class="sourceCode"><pre>starwars %&gt;%
  select(name, mass, species) %&gt;%
  group_by(species) %&gt;%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
</pre></div>
<p>The former normalises <code>mass</code> by the global average whereas the
latter normalises by the averages within species levels.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="stats.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="MASS.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Newly created variables are available immediately
starwars %&gt;%
  select(name, mass) %&gt;%
  mutate(
    mass2 = mass * 2,
    mass2_squared = mass2 * mass2
  )

# As well as adding new variables, you can use mutate() to
# remove variables and modify existing variables.
starwars %&gt;%
  select(name, height, mass, homeworld) %&gt;%
  mutate(
    mass = NULL,
    height = height * 0.0328084 # convert to feet
  )

# Use across() with mutate() to apply a transformation
# to multiple columns in a tibble.
starwars %&gt;%
  select(name, homeworld, species) %&gt;%
  mutate(across(!name, as.factor))
# see more in ?across

# Window functions are useful for grouped mutates:
starwars %&gt;%
  select(name, mass, homeworld) %&gt;%
  group_by(homeworld) %&gt;%
  mutate(rank = min_rank(desc(mass)))
# see `vignette("window-functions")` for more details

# By default, new columns are placed on the far right.
df &lt;- tibble(x = 1, y = 2)
df %&gt;% mutate(z = x + y)
df %&gt;% mutate(z = x + y, .before = 1)
df %&gt;% mutate(z = x + y, .after = x)

# By default, mutate() keeps all columns from the input data.
df &lt;- tibble(x = 1, y = 2, a = "a", b = "b")
df %&gt;% mutate(z = x + y, .keep = "all") # the default
df %&gt;% mutate(z = x + y, .keep = "used")
df %&gt;% mutate(z = x + y, .keep = "unused")
df %&gt;% mutate(z = x + y, .keep = "none")

# Grouping ----------------------------------------
# The mutate operation may yield different results on grouped
# tibbles because the expressions are computed within groups.
# The following normalises `mass` by the global average:
starwars %&gt;%
  select(name, mass, species) %&gt;%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))

# Whereas this normalises `mass` by the averages within species
# levels:
starwars %&gt;%
  select(name, mass, species) %&gt;%
  group_by(species) %&gt;%
  mutate(mass_norm = mass / mean(mass, na.rm = TRUE))

# Indirection ----------------------------------------
# Refer to column names stored as strings with the `.data` pronoun:
vars &lt;- c("mass", "height")
mutate(starwars, prod = .data[[vars[[1]]]] * .data[[vars[[2]]]])
# Learn more in ?rlang::args_data_masking
</code></pre>

<hr>
<h2 id='mutate_all'>Mutate multiple columns</h2><span id='topic+mutate_all'></span><span id='topic+mutate_if'></span><span id='topic+mutate_at'></span><span id='topic+transmute_all'></span><span id='topic+transmute_if'></span><span id='topic+transmute_at'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code>, <code style="white-space: pre;">&#8288;_all&#8288;</code>) have been superseded by the use of
<code><a href="dplyr.html#topic+pick">pick()</a></code> or <code><a href="dplyr.html#topic+across">across()</a></code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>The <a href="dplyr.html#topic+scoped">scoped</a> variants of <code><a href="dplyr.html#topic+mutate">mutate()</a></code> and <code><a href="dplyr.html#topic+transmute">transmute()</a></code> make it easy to apply
the same transformation to multiple variables. There are three variants:
</p>

<ul>
<li><p> _all affects every variable
</p>
</li>
<li><p> _at affects variables selected with a character vector or vars()
</p>
</li>
<li><p> _if affects variables selected with a predicate function:
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mutate_all(.tbl, .funs, ...)

mutate_if(.tbl, .predicate, .funs, ...)

mutate_at(.tbl, .vars, .funs, ..., .cols = NULL)

transmute_all(.tbl, .funs, ...)

transmute_if(.tbl, .predicate, .funs, ...)

transmute_at(.tbl, .vars, .funs, ..., .cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_all_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="mutate_all_+3A_.funs">.funs</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td></tr>
<tr><td><code id="mutate_all_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with <a href="rlang.html#topic+dyn-dots">tidy dots</a> support.</p>
</td></tr>
<tr><td><code id="mutate_all_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
<tr><td><code id="mutate_all_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mutate_all_+3A_.cols">.cols</code></td>
<td>
<p>This argument has been renamed to <code>.vars</code> to fit
dplyr's terminology and is deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. By default, the newly created columns have the shortest
names needed to uniquely identify the output. To force inclusion of a name,
even when not needed, name the input (see examples for details).
</p>


<h3>Grouping variables</h3>

<p>If applied on a grouped tibble, these operations are <em>not</em> applied
to the grouping variables. The behaviour depends on whether the
selection is <strong>implicit</strong> (<code>all</code> and <code>if</code> selections) or
<strong>explicit</strong> (<code>at</code> selections).
</p>

<ul>
<li><p> Grouping variables covered by explicit selections in
<code>mutate_at()</code> and <code>transmute_at()</code> are always an error. Add
<code>-group_cols()</code> to the <code><a href="dplyr.html#topic+vars">vars()</a></code> selection to avoid this:
</p>
<div class="sourceCode"><pre>data %&gt;% mutate_at(vars(-group_cols(), ...), myoperation)
</pre></div>
<p>Or remove <code>group_vars()</code> from the character vector of column names:
</p>
<div class="sourceCode"><pre>nms &lt;- setdiff(nms, group_vars(data))
data %&gt;% mutate_at(vars, myoperation)
</pre></div>
</li>
<li><p> Grouping variables covered by implicit selections are ignored by
<code>mutate_all()</code>, <code>transmute_all()</code>, <code>mutate_if()</code>, and
<code>transmute_if()</code>.
</p>
</li></ul>



<h3>Naming</h3>

<p>The names of the new columns are derived from the names of the
input variables and the names of the functions.
</p>

<ul>
<li><p> if there is only one unnamed function (i.e. if <code>.funs</code> is an unnamed list
of length one),
the names of the input variables are used to name the new columns;
</p>
</li>
<li><p> for <code style="white-space: pre;">&#8288;_at&#8288;</code> functions, if there is only one unnamed variable (i.e.,
if <code>.vars</code> is of the form <code>vars(a_single_column)</code>) and <code>.funs</code> has length
greater than one,
the names of the functions are used to name the new columns;
</p>
</li>
<li><p> otherwise, the new names are created by
concatenating the names of the input variables and the names of the
functions, separated with an underscore <code>"_"</code>.
</p>
</li></ul>

<p>The <code>.funs</code> argument can be a named or unnamed list.
If a function is unnamed and the name cannot be derived automatically,
a name of the form &quot;fn#&quot; is used.
Similarly, <code><a href="dplyr.html#topic+vars">vars()</a></code> accepts named and unnamed arguments.
If a variable in <code>.vars</code> is named, a new column by that name will be created.
</p>
<p>Name collisions in the new columns are disambiguated using a unique suffix.
</p>


<h3>See Also</h3>

<p><a href="dplyr.html#topic+scoped">The other scoped verbs</a>, <code><a href="dplyr.html#topic+vars">vars()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris &lt;- as_tibble(iris)

# All variants can be passed functions and additional arguments,
# purrr-style. The _at() variants directly support strings. Here
# we'll scale the variables `height` and `mass`:
scale2 &lt;- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)
starwars %&gt;% mutate_at(c("height", "mass"), scale2)
# -&gt;
starwars %&gt;% mutate(across(c("height", "mass"), scale2))

# You can pass additional arguments to the function:
starwars %&gt;% mutate_at(c("height", "mass"), scale2, na.rm = TRUE)
starwars %&gt;% mutate_at(c("height", "mass"), ~scale2(., na.rm = TRUE))
# -&gt;
starwars %&gt;% mutate(across(c("height", "mass"), ~ scale2(.x, na.rm = TRUE)))

# You can also supply selection helpers to _at() functions but you have
# to quote them with vars():
iris %&gt;% mutate_at(vars(matches("Sepal")), log)
iris %&gt;% mutate(across(matches("Sepal"), log))

# The _if() variants apply a predicate function (a function that
# returns TRUE or FALSE) to determine the relevant subset of
# columns. Here we divide all the numeric columns by 100:
starwars %&gt;% mutate_if(is.numeric, scale2, na.rm = TRUE)
starwars %&gt;% mutate(across(where(is.numeric), ~ scale2(.x, na.rm = TRUE)))

# mutate_if() is particularly useful for transforming variables from
# one type to another
iris %&gt;% mutate_if(is.factor, as.character)
iris %&gt;% mutate_if(is.double, as.integer)
# -&gt;
iris %&gt;% mutate(across(where(is.factor), as.character))
iris %&gt;% mutate(across(where(is.double), as.integer))

# Multiple transformations ----------------------------------------

# If you want to apply multiple transformations, pass a list of
# functions. When there are multiple functions, they create new
# variables instead of modifying the variables in place:
iris %&gt;% mutate_if(is.numeric, list(scale2, log))
iris %&gt;% mutate_if(is.numeric, list(~scale2(.), ~log(.)))
iris %&gt;% mutate_if(is.numeric, list(scale = scale2, log = log))
# -&gt;
iris %&gt;%
  as_tibble() %&gt;%
  mutate(across(where(is.numeric), list(scale = scale2, log = log)))

# When there's only one function in the list, it modifies existing
# variables in place. Give it a name to instead create new variables:
iris %&gt;% mutate_if(is.numeric, list(scale2))
iris %&gt;% mutate_if(is.numeric, list(scale = scale2))
</code></pre>

<hr>
<h2 id='mutate-joins'>Mutating joins</h2><span id='topic+mutate-joins'></span><span id='topic+join'></span><span id='topic+join.data.frame'></span><span id='topic+inner_join'></span><span id='topic+inner_join.data.frame'></span><span id='topic+left_join'></span><span id='topic+left_join.data.frame'></span><span id='topic+right_join'></span><span id='topic+right_join.data.frame'></span><span id='topic+full_join'></span><span id='topic+full_join.data.frame'></span>

<h3>Description</h3>

<p>Mutating joins add columns from <code>y</code> to <code>x</code>, matching observations based on
the keys. There are four mutating joins: the inner join, and the three outer
joins.
</p>


<h4>Inner join</h4>

<p>An <code>inner_join()</code> only keeps observations from <code>x</code> that have a matching key
in <code>y</code>.
</p>
<p>The most important property of an inner join is that unmatched rows in either
input are not included in the result. This means that generally inner joins
are not appropriate in most analyses, because it is too easy to lose
observations.
</p>



<h4>Outer joins</h4>

<p>The three outer joins keep observations that appear in at least one of the
data frames:
</p>

<ul>
<li><p> A <code>left_join()</code> keeps all observations in <code>x</code>.
</p>
</li>
<li><p> A <code>right_join()</code> keeps all observations in <code>y</code>.
</p>
</li>
<li><p> A <code>full_join()</code> keeps all observations in <code>x</code> and <code>y</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'data.frame'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL
)

left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'data.frame'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL
)

right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'data.frame'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL
)

full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'data.frame'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  relationship = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate-joins_+3A_x">x</code>, <code id="mutate-joins_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate-joins_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate-joins_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate-joins_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate-joins_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> (including the same groups). The order of
the rows and columns of <code>x</code> is preserved as much as possible. The output has
the following properties:
</p>

<ul>
<li><p> The rows are affect by the join type.
</p>

<ul>
<li> <p><code>inner_join()</code> returns matched <code>x</code> rows.
</p>
</li>
<li> <p><code>left_join()</code> returns all <code>x</code> rows.
</p>
</li>
<li> <p><code>right_join()</code>  returns matched of <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li>
<li> <p><code>full_join()</code>  returns all <code>x</code> rows, followed by unmatched <code>y</code> rows.
</p>
</li></ul>

</li>
<li><p> Output columns include all columns from <code>x</code> and all non-key columns from
<code>y</code>. If <code>keep = TRUE</code>, the key columns from <code>y</code> are included as well.
</p>
</li>
<li><p> If non-key columns in <code>x</code> and <code>y</code> have the same name, <code>suffix</code>es are added
to disambiguate. If <code>keep = TRUE</code> and key columns in <code>x</code> and <code>y</code> have
the same name, <code>suffix</code>es are added to disambiguate these as well.
</p>
</li>
<li><p> If <code>keep = FALSE</code>, output columns included in <code>by</code> are coerced to their
common type between <code>x</code> and <code>y</code>.
</p>
</li></ul>



<h3>Many-to-many relationships</h3>

<p>By default, dplyr guards against many-to-many relationships in equality joins
by throwing a warning. These occur when both of the following are true:
</p>

<ul>
<li><p> A row in <code>x</code> matches multiple rows in <code>y</code>.
</p>
</li>
<li><p> A row in <code>y</code> matches multiple rows in <code>x</code>.
</p>
</li></ul>

<p>This is typically surprising, as most joins involve a relationship of
one-to-one, one-to-many, or many-to-one, and is often the result of an
improperly specified join. Many-to-many relationships are particularly
problematic because they can result in a Cartesian explosion of the number of
rows returned from the join.
</p>
<p>If a many-to-many relationship is expected, silence this warning by
explicitly setting <code>relationship = "many-to-many"</code>.
</p>
<p>In production code, it is best to preemptively set <code>relationship</code> to whatever
relationship you expect to exist between the keys of <code>x</code> and <code>y</code>, as this
forces an error to occur immediately if the data doesn't align with your
expectations.
</p>
<p>Inequality joins typically result in many-to-many relationships by nature, so
they don't warn on them by default, but you should still take extra care when
specifying an inequality join, because they also have the capability to
return a large number of rows.
</p>
<p>Rolling joins don't warn on many-to-many relationships either, but many
rolling joins follow a many-to-one relationship, so it is often useful to
set <code>relationship = "many-to-one"</code> to enforce this.
</p>
<p>Note that in SQL, most database providers won't let you specify a
many-to-many relationship between two tables, instead requiring that you
create a third <em>junction table</em> that results in two one-to-many relationships
instead.
</p>


<h3>Methods</h3>

<p>These functions are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>inner_join()</code>: no methods found.
</p>
</li>
<li> <p><code>left_join()</code>: no methods found.
</p>
</li>
<li> <p><code>right_join()</code>: no methods found.
</p>
</li>
<li> <p><code>full_join()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+cross_join">cross_join</a>()</code>,
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>,
<code><a href="dplyr.html#topic+nest_join">nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>band_members %&gt;% inner_join(band_instruments)
band_members %&gt;% left_join(band_instruments)
band_members %&gt;% right_join(band_instruments)
band_members %&gt;% full_join(band_instruments)

# To suppress the message about joining variables, supply `by`
band_members %&gt;% inner_join(band_instruments, by = join_by(name))
# This is good practice in production code

# Use an equality expression if the join variables have different names
band_members %&gt;% full_join(band_instruments2, by = join_by(name == artist))
# By default, the join keys from `x` and `y` are coalesced in the output; use
# `keep = TRUE` to keep the join keys from both `x` and `y`
band_members %&gt;%
  full_join(band_instruments2, by = join_by(name == artist), keep = TRUE)

# If a row in `x` matches multiple rows in `y`, all the rows in `y` will be
# returned once for each matching row in `x`.
df1 &lt;- tibble(x = 1:3)
df2 &lt;- tibble(x = c(1, 1, 2), y = c("first", "second", "third"))
df1 %&gt;% left_join(df2)

# If a row in `y` also matches multiple rows in `x`, this is known as a
# many-to-many relationship, which is typically a result of an improperly
# specified join or some kind of messy data. In this case, a warning is
# thrown by default:
df3 &lt;- tibble(x = c(1, 1, 1, 3))
df3 %&gt;% left_join(df2)

# In the rare case where a many-to-many relationship is expected, set
# `relationship = "many-to-many"` to silence this warning
df3 %&gt;% left_join(df2, relationship = "many-to-many")

# Use `join_by()` with a condition other than `==` to perform an inequality
# join. Here we match on every instance where `df1$x &gt; df2$x`.
df1 %&gt;% left_join(df2, join_by(x &gt; x))

# By default, NAs match other NAs so that there are two
# rows in the output of this join:
df1 &lt;- data.frame(x = c(1, NA), y = 2)
df2 &lt;- data.frame(x = c(1, NA), z = 3)
left_join(df1, df2)

# You can optionally request that NAs don't match, giving a
# a result that more closely resembles SQL joins
left_join(df1, df2, na_matches = "never")
</code></pre>

<hr>
<h2 id='n_distinct'>Count unique combinations</h2><span id='topic+n_distinct'></span>

<h3>Description</h3>

<p><code>n_distinct()</code> counts the number of unique/distinct combinations in a set
of one or more vectors. It's a faster and more concise equivalent to
<code>nrow(unique(data.frame(...)))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_distinct(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_distinct_+3A_...">...</code></td>
<td>
<p>Unnamed vectors. If multiple vectors are supplied, then they should
have the same length.</p>
</td></tr>
<tr><td><code id="n_distinct_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, exclude missing observations from the count.
If there are multiple vectors in <code>...</code>, an observation will
be excluded if <em>any</em> of the values are missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 1, 2, 2, 2)
n_distinct(x)

y &lt;- c(3, 3, NA, 3, 3)
n_distinct(y)
n_distinct(y, na.rm = TRUE)

# Pairs (1, 3), (2, 3), and (2, NA) are distinct
n_distinct(x, y)

# (2, NA) is dropped, leaving 2 distinct combinations
n_distinct(x, y, na.rm = TRUE)

# Also works with data frames
n_distinct(data.frame(x, y))
</code></pre>

<hr>
<h2 id='na_if'>Convert values to <code>NA</code></h2><span id='topic+na_if'></span>

<h3>Description</h3>

<p>This is a translation of the SQL command <code>NULLIF</code>. It is useful if you want
to convert an annoying value to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_if(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_if_+3A_x">x</code></td>
<td>
<p>Vector to modify</p>
</td></tr>
<tr><td><code id="na_if_+3A_y">y</code></td>
<td>
<p>Value or vector to compare against. When <code>x</code> and <code>y</code> are equal, the
value in <code>x</code> will be replaced with <code>NA</code>.
</p>
<p><code>y</code> is <a href="vctrs.html#topic+theory-faq-coercion">cast</a> to the type of <code>x</code> before
comparison.
</p>
<p><code>y</code> is <a href="vctrs.html#topic+theory-faq-recycling">recycled</a> to the size of <code>x</code> before
comparison. This means that <code>y</code> can be a vector with the same size as <code>x</code>,
but most of the time this will be a single value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of <code>x</code> that replaces any values that
are equal to <code>y</code> with <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+coalesce">coalesce()</a></code> to replace missing values with a specified
value.
</p>
<p><code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code> to replace <code>NA</code> with a value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_if(1:5, 5:1)

x &lt;- c(1, -1, 0, 10)
100 / x
100 / na_if(x, 0)

y &lt;- c("abc", "def", "", "ghi")
na_if(y, "")

# `na_if()` allows you to replace `NaN` with `NA`,
# even though `NaN == NaN` returns `NA`
z &lt;- c(1, NaN, NA, 2, NaN)
na_if(z, NaN)

# `na_if()` is particularly useful inside `mutate()`,
# and is meant for use with vectors rather than entire data frames
starwars %&gt;%
  select(name, eye_color) %&gt;%
  mutate(eye_color = na_if(eye_color, "unknown"))

# `na_if()` can also be used with `mutate()` and `across()`
# to alter multiple columns
starwars %&gt;%
   mutate(across(where(is.character), ~na_if(., "unknown")))
</code></pre>

<hr>
<h2 id='near'>Compare two numeric vectors</h2><span id='topic+near'></span>

<h3>Description</h3>

<p>This is a safe way of comparing if two vectors of floating point numbers
are (pairwise) equal.  This is safer than using <code>==</code>, because it has
a built in tolerance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>near(x, y, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="near_+3A_x">x</code>, <code id="near_+3A_y">y</code></td>
<td>
<p>Numeric vectors to compare</p>
</td></tr>
<tr><td><code id="near_+3A_tol">tol</code></td>
<td>
<p>Tolerance of comparison.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2, 2)
</code></pre>

<hr>
<h2 id='nest_by'>Nest by one or more variables</h2><span id='topic+nest_by'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>nest_by()</code> is closely related to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. However, instead of storing
the group structure in the metadata, it is made explicit in the data,
giving each group key a single row along with a list-column of data frames
that contain all the other data.
</p>
<p><code>nest_by()</code> returns a <a href="dplyr.html#topic+rowwise">rowwise</a> data frame, which makes operations on the
grouped data particularly elegant. See <code>vignette("rowwise")</code> for more
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_by(.data, ..., .key = "data", .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_by_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="nest_by_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="nest_by_+3A_.key">.key</code></td>
<td>
<p>Name of the list column</p>
</td></tr>
<tr><td><code id="nest_by_+3A_.keep">.keep</code></td>
<td>
<p>Should the grouping columns be kept in the list column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>df %&gt;% nest_by(x, y)</code> is roughly equivalent to
</p>
<div class="sourceCode"><pre>df %&gt;%
  group_by(x, y) %&gt;%
  summarise(data = list(pick(everything()))) %&gt;%
  rowwise()
</pre></div>
<p>If you want to unnest a nested data frame, you can either use
<code>tidyr::unnest()</code> or take advantage of <code>reframe()</code>s multi-row behaviour:
</p>
<div class="sourceCode"><pre>nested %&gt;%
  reframe(data)
</pre></div>


<h3>Value</h3>

<p>A <a href="dplyr.html#topic+rowwise">rowwise</a> data frame. The output has the following properties:
</p>

<ul>
<li><p> The rows come from the underlying <code><a href="dplyr.html#topic+group_keys">group_keys()</a></code>.
</p>
</li>
<li><p> The columns are the grouping keys plus one list-column of data frames.
</p>
</li>
<li><p> Data frame attributes are <strong>not</strong> preserved, because <code>nest_by()</code>
fundamentally creates a new data frame.
</p>
</li></ul>

<p>A tbl with one row per unique combination of the grouping variables.
The first columns are the grouping variables, followed by a list column of tibbles
with matching rows of the remaining columns.
</p>


<h3>Lifecycle</h3>

<p><code>nest_by()</code> is not stable because <code><a href="tidyr.html#topic+nest">tidyr::nest(.by =)</a></code>
provides very similar behavior. It may be deprecated in the future.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># After nesting, you get one row per group
iris %&gt;% nest_by(Species)
starwars %&gt;% nest_by(species)

# The output is grouped by row, which makes modelling particularly easy
models &lt;- mtcars %&gt;%
  nest_by(cyl) %&gt;%
  mutate(model = list(lm(mpg ~ wt, data = data)))
models

models %&gt;% summarise(rsq = summary(model)$r.squared)


# This is particularly elegant with the broom functions
models %&gt;% summarise(broom::glance(model))
models %&gt;% reframe(broom::tidy(model))


# Note that you can also `reframe()` to unnest the data
models %&gt;% reframe(data)
</code></pre>

<hr>
<h2 id='nest_join'>Nest join</h2><span id='topic+nest_join'></span><span id='topic+nest_join.data.frame'></span>

<h3>Description</h3>

<p>A nest join leaves <code>x</code> almost unchanged, except that it adds a new
list-column, where each element contains the rows from <code>y</code> that match the
corresponding row in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_join(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ...)

## S3 method for class 'data.frame'
nest_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  keep = NULL,
  name = NULL,
  ...,
  na_matches = c("na", "never"),
  unmatched = "drop"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_join_+3A_x">x</code>, <code id="nest_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_keep">keep</code></td>
<td>
<p>Should the new list-column contain join keys? The default
will preserve the join keys for inequality joins.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_name">name</code></td>
<td>
<p>The name of the list-column created by the join. If <code>NULL</code>,
the default, the name of <code>y</code> is used.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nest_join_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The output:
</p>

<ul>
<li><p> Is same type as <code>x</code> (including having the same groups).
</p>
</li>
<li><p> Has exactly the same number of rows as <code>x</code>.
</p>
</li>
<li><p> Contains all the columns of <code>x</code> in the same order with the same values.
They are only modified (slightly) if <code>keep = FALSE</code>, when columns listed
in <code>by</code> will be coerced to their common type across <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> Gains one new column called <code>{name}</code> on the far right, a list column
containing data frames the same type as <code>y</code>.
</p>
</li></ul>



<h3>Relationship to other joins</h3>

<p>You can recreate many other joins from the result of a nest join:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+inner_join">inner_join()</a></code> is a <code>nest_join()</code> plus <code><a href="tidyr.html#topic+unnest">tidyr::unnest()</a></code>.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+left_join">left_join()</a></code> is a <code>nest_join()</code> plus <code>tidyr::unnest(keep_empty = TRUE)</code>.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+semi_join">semi_join()</a></code> is a <code>nest_join()</code> plus a <code>filter()</code> where you check
that every element of data has at least one row.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+anti_join">anti_join()</a></code> is a <code>nest_join()</code> plus a <code>filter()</code> where you check that every
element has zero rows.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other joins: 
<code><a href="dplyr.html#topic+cross_join">cross_join</a>()</code>,
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>,
<code><a href="dplyr.html#topic+mutate-joins">mutate-joins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tibble(x = 1:3)
df2 &lt;- tibble(x = c(2, 3, 3), y = c("a", "b", "c"))

out &lt;- nest_join(df1, df2)
out
out$df2
</code></pre>

<hr>
<h2 id='new_grouped_df'>Low-level construction and validation for the grouped_df and rowwise_df classes</h2><span id='topic+new_grouped_df'></span><span id='topic+validate_grouped_df'></span><span id='topic+new_rowwise_df'></span><span id='topic+validate_rowwise_df'></span>

<h3>Description</h3>

<p><code>new_grouped_df()</code> and <code>new_rowwise_df()</code> are constructors designed to be high-performance so only
check types, not values. This means it is the caller's responsibility
to create valid values, and hence this is for expert use only.
</p>
<p><code>validate_grouped_df()</code> and <code>validate_rowwise_df()</code> validate the attributes
of a <code>grouped_df</code> or a <code>rowwise_df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_grouped_df(x, groups, ..., class = character())

validate_grouped_df(x, check_bounds = FALSE)

new_rowwise_df(data, group_data = NULL, ..., class = character())

validate_rowwise_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_grouped_df_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="new_grouped_df_+3A_groups">groups</code></td>
<td>
<p>The grouped structure, <code>groups</code> should be a data frame.
Its last column should be called <code>.rows</code> and be
a list of 1 based integer vectors that all are between 1 and the number of rows of <code>.data</code>.</p>
</td></tr>
<tr><td><code id="new_grouped_df_+3A_...">...</code></td>
<td>
<p>additional attributes</p>
</td></tr>
<tr><td><code id="new_grouped_df_+3A_class">class</code></td>
<td>
<p>additional class, will be prepended to canonical classes.</p>
</td></tr>
<tr><td><code id="new_grouped_df_+3A_check_bounds">check_bounds</code></td>
<td>
<p>whether to check all indices for out of bounds problems in <code>grouped_df</code> objects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># 5 bootstrap samples
tbl &lt;- new_grouped_df(
  tibble(x = rnorm(10)),
  groups = tibble(".rows" := replicate(5, sample(1:10, replace = TRUE), simplify = FALSE))
)
# mean of each bootstrap sample
summarise(tbl, x = mean(x))

</code></pre>

<hr>
<h2 id='nth'>Extract the first, last, or nth value from a vector</h2><span id='topic+nth'></span><span id='topic+first'></span><span id='topic+last'></span>

<h3>Description</h3>

<p>These are useful helpers for extracting a single value from a vector. They
are guaranteed to return a meaningful value, even when the input is shorter
than expected. You can also provide an optional secondary vector that defines
the ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nth(x, n, order_by = NULL, default = NULL, na_rm = FALSE)

first(x, order_by = NULL, default = NULL, na_rm = FALSE)

last(x, order_by = NULL, default = NULL, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nth_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="nth_+3A_n">n</code></td>
<td>
<p>For <code>nth()</code>, a single integer specifying the position.
Negative integers index from the end (i.e. <code>-1L</code> will return the
last value in the vector).</p>
</td></tr>
<tr><td><code id="nth_+3A_order_by">order_by</code></td>
<td>
<p>An optional vector the same size as <code>x</code> used to determine the
order.</p>
</td></tr>
<tr><td><code id="nth_+3A_default">default</code></td>
<td>
<p>A default value to use if the position does not exist in <code>x</code>.
</p>
<p>If <code>NULL</code>, the default, a missing value is used.
</p>
<p>If supplied, this must be a single value, which will be cast to the type of
<code>x</code>.
</p>
<p>When <code>x</code> is a list , <code>default</code> is allowed to be any value. There are no
type or size restrictions in this case.</p>
</td></tr>
<tr><td><code id="nth_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>x</code> be removed before extracting the
value?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most vector types, <code>first(x)</code>, <code>last(x)</code>, and <code>nth(x, n)</code> work like
<code>x[[1]]</code>, <code style="white-space: pre;">&#8288;x[[length(x)]&#8288;</code>, and <code>x[[n]]</code>, respectively. The primary exception
is data frames, where they instead retrieve rows, i.e. <code>x[1, ]</code>, <code>x[nrow(x), ]</code>, and <code>x[n, ]</code>. This is consistent with the tidyverse/vctrs principle which
treats data frames as a vector of rows, rather than a vector of columns.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a list, a single element from that list. Otherwise, a vector the
same type as <code>x</code> with size 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
y &lt;- 10:1

first(x)
last(y)

nth(x, 1)
nth(x, 5)
nth(x, -2)

# `first()` and `last()` are often useful in `summarise()`
df &lt;- tibble(x = x, y = y)
df %&gt;%
  summarise(
    across(x:y, first, .names = "{col}_first"),
    y_last = last(y)
  )

# Selecting a position that is out of bounds returns a default value
nth(x, 11)
nth(x, 0)

# This out of bounds behavior also applies to empty vectors
first(integer())

# You can customize the default value with `default`
nth(x, 11, default = -1L)
first(integer(), default = 0L)

# `order_by` provides optional ordering
last(x)
last(x, order_by = y)

# `na_rm` removes missing values before extracting the value
z &lt;- c(NA, NA, 1, 3, NA, 5, NA)
first(z)
first(z, na_rm = TRUE)
last(z, na_rm = TRUE)
nth(z, 3, na_rm = TRUE)

# For data frames, these select entire rows
df &lt;- tibble(a = 1:5, b = 6:10)
first(df)
nth(df, 4)
</code></pre>

<hr>
<h2 id='ntile'>Bucket a numeric vector into <code>n</code> groups</h2><span id='topic+ntile'></span>

<h3>Description</h3>

<p><code>ntile()</code> is a sort of very rough rank, which breaks the input vector into
<code>n</code> buckets. If <code>length(x)</code> is not an integer multiple of <code>n</code>, the size of
the buckets will differ by up to one, with larger buckets coming first.
</p>
<p>Unlike other ranking functions, <code>ntile()</code> ignores ties: it will create
evenly sized buckets even if the same value of <code>x</code> ends up in different
buckets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntile(x = row_number(), n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ntile_+3A_x">x</code></td>
<td>
<p>A vector to rank
</p>
<p>By default, the smallest values will get the smallest ranks. Use <code><a href="desc.html#topic+desc">desc()</a></code>
to reverse the direction so the largest values get the smallest ranks.
</p>
<p>Missing values will be given rank <code>NA</code>. Use <code>coalesce(x, Inf)</code> or
<code>coalesce(x, -Inf)</code> if you want to treat them as the largest or smallest
values respectively.
</p>
<p>To rank by multiple columns at once, supply a data frame.</p>
</td></tr>
<tr><td><code id="ntile_+3A_n">n</code></td>
<td>
<p>Number of groups to bucket into</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ranking functions: 
<code><a href="dplyr.html#topic+percent_rank">percent_rank</a>()</code>,
<code><a href="dplyr.html#topic+row_number">row_number</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(5, 1, 3, 2, 2, NA)
ntile(x, 2)
ntile(x, 4)

# If the bucket sizes are uneven, the larger buckets come first
ntile(1:8, 3)

# Ties are ignored
ntile(rep(1, 8), 3)
</code></pre>

<hr>
<h2 id='order_by'>A helper function for ordering window function output</h2><span id='topic+order_by'></span>

<h3>Description</h3>

<p>This function makes it possible to control the ordering of window functions
in R that don't have a specific ordering parameter. When translated to SQL
it will modify the order clause of the OVER function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_by(order_by, call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_by_+3A_order_by">order_by</code></td>
<td>
<p>a vector to order_by</p>
</td></tr>
<tr><td><code id="order_by_+3A_call">call</code></td>
<td>
<p>a function call to a window function, where the first argument
is the vector being operated on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works by changing the <code>call</code> to instead call
<code><a href="dplyr.html#topic+with_order">with_order()</a></code> with the appropriate arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>order_by(10:1, cumsum(1:10))
x &lt;- 10:1
y &lt;- 1:10
order_by(x, cumsum(y))

df &lt;- data.frame(year = 2000:2005, value = (0:5) ^ 2)
scrambled &lt;- df[sample(nrow(df)), ]

wrong &lt;- mutate(scrambled, running = cumsum(value))
arrange(wrong, year)

right &lt;- mutate(scrambled, running = order_by(year, cumsum(value)))
arrange(right, year)
</code></pre>

<hr>
<h2 id='percent_rank'>Proportional ranking functions</h2><span id='topic+percent_rank'></span><span id='topic+cume_dist'></span>

<h3>Description</h3>

<p>These two ranking functions implement two slightly different ways to
compute a percentile. For each <code>x_i</code> in <code>x</code>:
</p>

<ul>
<li> <p><code>cume_dist(x)</code> counts the total number of values less than
or equal to <code>x_i</code>, and divides it by the number of observations.
</p>
</li>
<li> <p><code>percent_rank(x)</code> counts the total number of values less than
<code>x_i</code>, and divides it by the number of observations minus 1.
</p>
</li></ul>

<p>In both cases, missing values are ignored when counting the number
of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percent_rank(x)

cume_dist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percent_rank_+3A_x">x</code></td>
<td>
<p>A vector to rank
</p>
<p>By default, the smallest values will get the smallest ranks. Use <code><a href="desc.html#topic+desc">desc()</a></code>
to reverse the direction so the largest values get the smallest ranks.
</p>
<p>Missing values will be given rank <code>NA</code>. Use <code>coalesce(x, Inf)</code> or
<code>coalesce(x, -Inf)</code> if you want to treat them as the largest or smallest
values respectively.
</p>
<p>To rank by multiple columns at once, supply a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing a proportion.
</p>


<h3>See Also</h3>

<p>Other ranking functions: 
<code><a href="dplyr.html#topic+ntile">ntile</a>()</code>,
<code><a href="dplyr.html#topic+row_number">row_number</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(5, 1, 3, 2, 2)

cume_dist(x)
percent_rank(x)

# You can understand what's going on by computing it by hand
sapply(x, function(xi) sum(x &lt;= xi) / length(x))
sapply(x, function(xi) sum(x &lt; xi)  / (length(x) - 1))
# The real computations are a little more complex in order to
# correctly deal with missing values
</code></pre>

<hr>
<h2 id='pick'>Select a subset of columns</h2><span id='topic+pick'></span>

<h3>Description</h3>

<p><code>pick()</code> provides a way to easily select a subset of columns from your data
using <code><a href="MASS.html#topic+select">select()</a></code> semantics while inside a
<a href="rlang.html#topic+args_data_masking">&quot;data-masking&quot;</a> function like <code><a href="dplyr.html#topic+mutate">mutate()</a></code> or
<code><a href="dplyr.html#topic+summarise">summarise()</a></code>. <code>pick()</code> returns a data frame containing the selected columns
for the current group.
</p>
<p><code>pick()</code> is complementary to <code><a href="dplyr.html#topic+across">across()</a></code>:
</p>

<ul>
<li><p> With <code>pick()</code>, you typically apply a function to the full data frame.
</p>
</li>
<li><p> With <code>across()</code>, you typically apply a function to each column.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pick(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;
</p>
<p>Columns to pick.
</p>
<p>You can't pick grouping columns because they are already automatically
handled by the verb (i.e. <code><a href="dplyr.html#topic+summarise">summarise()</a></code> or <code><a href="dplyr.html#topic+mutate">mutate()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Theoretically, <code>pick()</code> is intended to be replaceable with an equivalent call
to <code>tibble()</code>. For example, <code>pick(a, c)</code> could be replaced with
<code>tibble(a = a, c = c)</code>, and <code>pick(everything())</code> on a data frame with cols
<code>a</code>, <code>b</code>, and <code>c</code> could be replaced with <code>tibble(a = a, b = b, c = c)</code>.
<code>pick()</code> specially handles the case of an empty selection by returning a 1
row, 0 column tibble, so an exact replacement is more like:
</p>
<div class="sourceCode"><pre>size &lt;- vctrs::vec_size_common(..., .absent = 1L)
out &lt;- vctrs::vec_recycle_common(..., .size = size)
tibble::new_tibble(out, nrow = size)
</pre></div>


<h3>Value</h3>

<p>A tibble containing the selected columns for the current group.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+across">across()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  x = c(3, 2, 2, 2, 1),
  y = c(0, 2, 1, 1, 4),
  z1 = c("a", "a", "a", "b", "a"),
  z2 = c("c", "d", "d", "a", "c")
)
df

# `pick()` provides a way to select a subset of your columns using
# tidyselect. It returns a data frame.
df %&gt;% mutate(cols = pick(x, y))

# This is useful for functions that take data frames as inputs.
# For example, you can compute a joint rank between `x` and `y`.
df %&gt;% mutate(rank = dense_rank(pick(x, y)))

# `pick()` is also useful as a bridge between data-masking functions (like
# `mutate()` or `group_by()`) and functions with tidy-select behavior (like
# `select()`). For example, you can use `pick()` to create a wrapper around
# `group_by()` that takes a tidy-selection of columns to group on. For more
# bridge patterns, see
# https://rlang.r-lib.org/reference/topic-data-mask-programming.html#bridge-patterns.
my_group_by &lt;- function(data, cols) {
  group_by(data, pick({{ cols }}))
}

df %&gt;% my_group_by(c(x, starts_with("z")))

# Or you can use it to dynamically select columns to `count()` by
df %&gt;% count(pick(starts_with("z")))
</code></pre>

<hr>
<h2 id='progress_estimated'>Progress bar with estimated time.</h2><span id='topic+progress_estimated'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This progress bar has been deprecated since providing progress bars is not
the responsibility of dplyr. Instead, you might try the more powerful
<a href="https://github.com/r-lib/progress">progress</a> package.
</p>
<p>This reference class represents a text progress bar displayed estimated
time remaining. When finished, it displays the total duration.  The
automatic progress bar can be disabled by setting option
<code>dplyr.show_progress</code> to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_estimated(n, min_time = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progress_estimated_+3A_n">n</code></td>
<td>
<p>Total number of items</p>
</td></tr>
<tr><td><code id="progress_estimated_+3A_min_time">min_time</code></td>
<td>
<p>Progress bar will wait until at least <code>min_time</code>
seconds have elapsed before displaying any results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ref class with methods <code>tick()</code>, <code>print()</code>,
<code>pause()</code>, and <code>stop()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- progress_estimated(3)
p$tick()
p$tick()
p$tick()

p &lt;- progress_estimated(3)
for (i in 1:3) p$pause(0.1)$tick()$print()

p &lt;- progress_estimated(3)
p$tick()$print()$
 pause(1)$stop()

# If min_time is set, progress bar not shown until that many
# seconds have elapsed
p &lt;- progress_estimated(3, min_time = 3)
for (i in 1:3) p$pause(0.1)$tick()$print()

## Not run: 
p &lt;- progress_estimated(10, min_time = 3)
for (i in 1:10) p$pause(0.5)$tick()$print()

## End(Not run)
</code></pre>

<hr>
<h2 id='pull'>Extract a single column</h2><span id='topic+pull'></span>

<h3>Description</h3>

<p><code>pull()</code> is similar to <code>$</code>. It's mostly useful because it looks a little
nicer in pipes, it also works with remote data frames, and it can optionally
name the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull(.data, var = -1, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="pull_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last column (on the assumption that's the
column you've created most recently).
</p>
<p>This argument is taken by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names and column locations).</p>
</td></tr>
<tr><td><code id="pull_+3A_name">name</code></td>
<td>
<p>An optional parameter that specifies the column to be used
as names for a named vector. Specified in a similar manner as <code>var</code>.</p>
</td></tr>
<tr><td><code id="pull_+3A_...">...</code></td>
<td>
<p>For use by methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same size as <code>.data</code>.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% pull(-1)
mtcars %&gt;% pull(1)
mtcars %&gt;% pull(cyl)


# Also works for remote sources
df &lt;- dbplyr::memdb_frame(x = 1:10, y = 10:1, .name = "pull-ex")
df %&gt;%
  mutate(z = x * y) %&gt;%
  pull()


# Pull a named vector
starwars %&gt;% pull(height, name)
</code></pre>

<hr>
<h2 id='recode'>Recode values</h2><span id='topic+recode'></span><span id='topic+recode_factor'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>recode()</code> is superseded in favor of <code><a href="dplyr.html#topic+case_match">case_match()</a></code>, which handles the most
important cases of <code>recode()</code> with a more elegant interface.
<code>recode_factor()</code> is also superseded, however, its direct replacement is not
currently available but will eventually live in
<a href="https://forcats.tidyverse.org/">forcats</a>. For creating new variables based
on logical vectors, use <code><a href="dplyr.html#topic+if_else">if_else()</a></code>. For even more complicated criteria, use
<code><a href="dplyr.html#topic+case_when">case_when()</a></code>.
</p>
<p><code>recode()</code> is a vectorised version of <code><a href="base.html#topic+switch">switch()</a></code>: you can replace numeric
values based on their position or their name, and character or factor values
only by their name. This is an S3 generic: dplyr provides methods for
numeric, character, and factors. You can use <code>recode()</code> directly with
factors; it will preserve the existing order of levels while changing the
values. Alternatively, you can use <code>recode_factor()</code>, which will change the
order of levels to match the order of replacements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(.x, ..., .default = NULL, .missing = NULL)

recode_factor(.x, ..., .default = NULL, .missing = NULL, .ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_+3A_.x">.x</code></td>
<td>
<p>A vector to modify</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Replacements. For character and factor <code>.x</code>, these should be named
and replacement is based only on their name. For numeric <code>.x</code>, these can be
named or not. If not named, the replacement is done based on position i.e.
<code>.x</code> represents positions to look for in replacements. See examples.
</p>
<p>When named, the argument names should be the current values to be replaced, and the
argument values should be the new (replacement) values.
</p>
<p>All replacements must be the same type, and must have either
length one or the same length as <code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_.default">.default</code></td>
<td>
<p>If supplied, all values not otherwise matched will
be given this value. If not supplied and if the replacements are
the same type as the original values in <code>.x</code>, unmatched
values are not changed. If not supplied and if the replacements
are not compatible, unmatched values are replaced with <code>NA</code>.
</p>
<p><code>.default</code> must be either length 1 or the same length as
<code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_.missing">.missing</code></td>
<td>
<p>If supplied, any missing values in <code>.x</code> will be
replaced by this value. Must be either length 1 or the same length as
<code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_.ordered">.ordered</code></td>
<td>
<p>If <code>TRUE</code>, <code>recode_factor()</code> creates an
ordered factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>.x</code>, and the same type as
the first of <code>...</code>, <code>.default</code>, or <code>.missing</code>.
<code>recode_factor()</code> returns a factor whose levels are in the same order as
in <code>...</code>. The levels in <code>.default</code> and <code>.missing</code> come last.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+na_if">na_if()</a></code> to replace specified values with a <code>NA</code>.
</p>
<p><code><a href="dplyr.html#topic+coalesce">coalesce()</a></code> to replace missing values with a specified value.
</p>
<p><code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code> to replace <code>NA</code> with a value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char_vec &lt;- sample(c("a", "b", "c"), 10, replace = TRUE)

# `recode()` is superseded by `case_match()`
recode(char_vec, a = "Apple", b = "Banana")
case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = char_vec)

# With `case_match()`, you don't need typed missings like `NA_character_`
recode(char_vec, a = "Apple", b = "Banana", .default = NA_character_)
case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = NA)

# Throws an error as `NA` is logical, not character.
try(recode(char_vec, a = "Apple", b = "Banana", .default = NA))

# `case_match()` is easier to use with numeric vectors, because you don't
# need to turn the numeric values into names
num_vec &lt;- c(1:4, NA)
recode(num_vec, `2` = 20L, `4` = 40L)
case_match(num_vec, 2 ~ 20, 4 ~ 40, .default = num_vec)

# `case_match()` doesn't have the ability to match by position like
# `recode()` does with numeric vectors
recode(num_vec, "a", "b", "c", "d")
recode(c(1,5,3), "a", "b", "c", "d", .default = "nothing")

# For `case_match()`, incompatible types are an error rather than a warning
recode(num_vec, `2` = "b", `4` = "d")
try(case_match(num_vec, 2 ~ "b", 4 ~ "d", .default = num_vec))

# The factor method of `recode()` can generally be replaced with
# `forcats::fct_recode()`
factor_vec &lt;- factor(c("a", "b", "c"))
recode(factor_vec, a = "Apple")

# `recode_factor()` does not currently have a direct replacement, but we
# plan to add one to forcats. In the meantime, you can use the `.ptype`
# argument to `case_match()`.
recode_factor(
  num_vec,
  `1` = "z",
  `2` = "y",
  `3` = "x",
  .default = "D",
  .missing = "M"
)
case_match(
  num_vec,
  1 ~ "z",
  2 ~ "y",
  3 ~ "x",
  NA ~ "M",
  .default = "D",
  .ptype = factor(levels = c("z", "y", "x", "D", "M"))
)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+type_sum'></span><span id='topic+data_frame'></span><span id='topic+as_data_frame'></span><span id='topic+lst'></span><span id='topic+add_row'></span><span id='topic+tribble'></span><span id='topic+tibble'></span><span id='topic+as_tibble'></span><span id='topic+view'></span><span id='topic+contains'></span><span id='topic+select_helpers'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span><span id='topic+last_col'></span><span id='topic+any_of'></span><span id='topic+all_of'></span><span id='topic+where'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>pillar</dt><dd><p><code><a href="pillar.html#topic+type_sum">type_sum</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+add_row">add_row</a></code>, <code><a href="tibble.html#topic+deprecated">as_data_frame</a></code>, <code><a href="tibble.html#topic+as_tibble">as_tibble</a></code>, <code><a href="tibble.html#topic+deprecated">data_frame</a></code>, <code><a href="tibble.html#topic+lst">lst</a></code>, <code><a href="tibble.html#topic+tibble">tibble</a></code>, <code><a href="tibble.html#topic+tribble">tribble</a></code>, <code><a href="tibble.html#topic+view">view</a></code></p>
</dd>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+all_of">all_of</a></code>, <code><a href="tidyselect.html#topic+all_of">any_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code>, <code><a href="tidyselect.html#topic+where">where</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reframe'>Transform each group to an arbitrary number of rows</h2><span id='topic+reframe'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>While <code><a href="dplyr.html#topic+summarise">summarise()</a></code> requires that each argument returns a single value, and
<code><a href="dplyr.html#topic+mutate">mutate()</a></code> requires that each argument returns the same number of rows as the
input, <code>reframe()</code> is a more general workhorse with no requirements on the
number of rows returned per group.
</p>
<p><code>reframe()</code> creates a new data frame by applying functions to columns of an
existing data frame. It is most similar to <code>summarise()</code>, with two big
differences:
</p>

<ul>
<li> <p><code>reframe()</code> can return an arbitrary number of rows per group, while
<code>summarise()</code> reduces each group down to a single row.
</p>
</li>
<li> <p><code>reframe()</code> always returns an ungrouped data frame, while <code>summarise()</code>
might return a grouped or rowwise data frame, depending on the scenario.
</p>
</li></ul>

<p>We expect that you'll use <code>summarise()</code> much more often than <code>reframe()</code>, but
<code>reframe()</code> can be particularly helpful when you need to apply a complex
function that doesn't return a single summary value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reframe(.data, ..., .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reframe_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="reframe_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
</p>
<p>Name-value pairs of functions. The name will be the name of the variable in
the result. The value can be a vector of any length.
</p>
<p>Unnamed data frame values add multiple columns from a single expression.</p>
</td></tr>
<tr><td><code id="reframe_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>.data</code> is a tibble, a tibble. Otherwise, a data.frame.
</p>

<ul>
<li><p> The rows originate from the underlying grouping keys.
</p>
</li>
<li><p> The columns are a combination of the grouping keys and the
expressions that you provide.
</p>
</li>
<li><p> The output is always ungrouped.
</p>
</li>
<li><p> Data frame attributes are <strong>not</strong> preserved, because <code>reframe()</code>
fundamentally creates a new data frame.
</p>
</li></ul>



<h3>Connection to tibble</h3>

<p><code>reframe()</code> is theoretically connected to two functions in tibble,
<code><a href="tibble.html#topic+enframe">tibble::enframe()</a></code> and <code><a href="tibble.html#topic+enframe">tibble::deframe()</a></code>:
</p>

<ul>
<li> <p><code>enframe()</code>: vector -&gt; data frame
</p>
</li>
<li> <p><code>deframe()</code>: data frame -&gt; vector
</p>
</li>
<li> <p><code>reframe()</code>: data frame -&gt; data frame
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="stats.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="MASS.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>table &lt;- c("a", "b", "d", "f")

df &lt;- tibble(
  g = c(1, 1, 1, 2, 2, 2, 2),
  x = c("e", "a", "b", "c", "f", "d", "a")
)

# `reframe()` allows you to apply functions that return
# an arbitrary number of rows
df %&gt;%
  reframe(x = intersect(x, table))

# Functions are applied per group, and each group can return a
# different number of rows.
df %&gt;%
  reframe(x = intersect(x, table), .by = g)

# The output is always ungrouped, even when using `group_by()`
df %&gt;%
  group_by(g) %&gt;%
  reframe(x = intersect(x, table))

# You can add multiple columns at once using a single expression by returning
# a data frame.
quantile_df &lt;- function(x, probs = c(0.25, 0.5, 0.75)) {
  tibble(
    val = quantile(x, probs, na.rm = TRUE),
    quant = probs
  )
}

x &lt;- c(10, 15, 18, 12)
quantile_df(x)

starwars %&gt;%
  reframe(quantile_df(height))

starwars %&gt;%
  reframe(quantile_df(height), .by = homeworld)

starwars %&gt;%
  reframe(
    across(c(height, mass), quantile_df, .unpack = TRUE),
    .by = homeworld
  )
</code></pre>

<hr>
<h2 id='relocate'>Change column order</h2><span id='topic+relocate'></span>

<h3>Description</h3>

<p>Use <code>relocate()</code> to change column positions, using the same syntax as
<code>select()</code> to make it easy to move blocks of columns at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relocate(.data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relocate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="relocate_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to move.</p>
</td></tr>
<tr><td><code id="relocate_+3A_.before">.before</code>, <code id="relocate_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination of
columns selected by <code>...</code>. Supplying neither will move columns to the
left-hand side; specifying both is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> The same columns appear in the output, but (usually) in a different place
and possibly renamed.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are not affected.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")
df %&gt;% relocate(f)
df %&gt;% relocate(a, .after = c)
df %&gt;% relocate(f, .before = b)
df %&gt;% relocate(a, .after = last_col())

# relocated columns can change name
df %&gt;% relocate(ff = f)

# Can also select variables based on their type
df %&gt;% relocate(where(is.character))
df %&gt;% relocate(where(is.numeric), .after = last_col())
# Or with any other select helper
df %&gt;% relocate(any_of(c("a", "e", "i", "o", "u")))

# When .before or .after refers to multiple variables they will be
# moved to be immediately before/after the selected variables.
df2 &lt;- tibble(a = 1, b = "a", c = 1, d = "a")
df2 %&gt;% relocate(where(is.numeric), .after = where(is.character))
df2 %&gt;% relocate(where(is.numeric), .before = where(is.character))
</code></pre>

<hr>
<h2 id='rename'>Rename columns</h2><span id='topic+rename'></span><span id='topic+rename_with'></span>

<h3>Description</h3>

<p><code>rename()</code> changes the names of individual variables using
<code>new_name = old_name</code> syntax; <code>rename_with()</code> renames columns using a
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename(.data, ...)

rename_with(.data, .fn, .cols = everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="rename_+3A_...">...</code></td>
<td>
<p>For <code>rename()</code>: &lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Use
<code>new_name = old_name</code> to rename selected variables.
</p>
<p>For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="rename_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</td></tr>
<tr><td><code id="rename_+3A_.cols">.cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> Column names are changed; column order is preserved.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are updated to reflect new names.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="stats.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="MASS.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris &lt;- as_tibble(iris) # so it prints a little nicer
rename(iris, petal_length = Petal.Length)

# Rename using a named vector and `all_of()`
lookup &lt;- c(pl = "Petal.Length", sl = "Sepal.Length")
rename(iris, all_of(lookup))

# If your named vector might contain names that don't exist in the data,
# use `any_of()` instead
lookup &lt;- c(lookup, new = "unknown")
try(rename(iris, all_of(lookup)))
rename(iris, any_of(lookup))

rename_with(iris, toupper)
rename_with(iris, toupper, starts_with("Petal"))
rename_with(iris, ~ tolower(gsub(".", "_", .x, fixed = TRUE)))


# If your renaming function uses `paste0()`, make sure to set
# `recycle0 = TRUE` to ensure that empty selections are recycled correctly
try(rename_with(
  iris,
  ~ paste0("prefix_", .x),
  starts_with("nonexistent")
))

rename_with(
  iris,
  ~ paste0("prefix_", .x, recycle0 = TRUE),
  starts_with("nonexistent")
)

</code></pre>

<hr>
<h2 id='row_number'>Integer ranking functions</h2><span id='topic+row_number'></span><span id='topic+min_rank'></span><span id='topic+dense_rank'></span>

<h3>Description</h3>

<p>Three ranking functions inspired by SQL2003. They differ primarily in how
they handle ties:
</p>

<ul>
<li> <p><code>row_number()</code> gives every input a unique rank, so that <code>c(10, 20, 20, 30)</code>
would get ranks <code>c(1, 2, 3, 4)</code>. It's equivalent to
<code>rank(ties.method = "first")</code>.
</p>
</li>
<li> <p><code>min_rank()</code> gives every tie the same (smallest) value so that
<code>c(10, 20, 20, 30)</code> gets ranks <code>c(1, 2, 2, 4)</code>. It's the way that ranks
are usually computed in sports and is equivalent to
<code>rank(ties.method = "min")</code>.
</p>
</li>
<li> <p><code>dense_rank()</code> works like <code>min_rank()</code>, but doesn't leave any gaps,
so that <code>c(10, 20, 20, 30)</code> gets ranks <code>c(1, 2, 2, 3)</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>row_number(x)

min_rank(x)

dense_rank(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_number_+3A_x">x</code></td>
<td>
<p>A vector to rank
</p>
<p>By default, the smallest values will get the smallest ranks. Use <code><a href="desc.html#topic+desc">desc()</a></code>
to reverse the direction so the largest values get the smallest ranks.
</p>
<p>Missing values will be given rank <code>NA</code>. Use <code>coalesce(x, Inf)</code> or
<code>coalesce(x, -Inf)</code> if you want to treat them as the largest or smallest
values respectively.
</p>
<p>To rank by multiple columns at once, supply a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>See Also</h3>

<p>Other ranking functions: 
<code><a href="dplyr.html#topic+ntile">ntile</a>()</code>,
<code><a href="dplyr.html#topic+percent_rank">percent_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(5, 1, 3, 2, 2, NA)
row_number(x)
min_rank(x)
dense_rank(x)

# Ranking functions can be used in `filter()` to select top/bottom rows
df &lt;- data.frame(
  grp = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  x = c(3, 2, 1, 1, 2, 2, 1, 1, 1),
  y = c(1, 3, 2, 3, 2, 2, 4, 1, 2),
  id = 1:9
)
# Always gives exactly 1 row per group
df %&gt;% group_by(grp) %&gt;% filter(row_number(x) == 1)
# May give more than 1 row if ties
df %&gt;% group_by(grp) %&gt;% filter(min_rank(x) == 1)
# Rank by multiple columns (to break ties) by selecting them with `pick()`
df %&gt;% group_by(grp) %&gt;% filter(min_rank(pick(x, y)) == 1)
# See slice_min() and slice_max() for another way to tackle the same problem

# You can use row_number() without an argument to refer to the "current"
# row number.
df %&gt;% group_by(grp) %&gt;% filter(row_number() == 1)

# It's easiest to see what this does with mutate():
df %&gt;% group_by(grp) %&gt;% mutate(grp_id = row_number())
</code></pre>

<hr>
<h2 id='rows'>Manipulate individual rows</h2><span id='topic+rows'></span><span id='topic+rows_insert'></span><span id='topic+rows_append'></span><span id='topic+rows_update'></span><span id='topic+rows_patch'></span><span id='topic+rows_upsert'></span><span id='topic+rows_delete'></span>

<h3>Description</h3>

<p>These functions provide a framework for modifying rows in a table using a
second table of data. The two tables are matched <code>by</code> a set of key variables
whose values typically uniquely identify each row. The functions are inspired
by SQL's <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>, and can optionally modify
<code>in_place</code> for selected backends.
</p>

<ul>
<li> <p><code>rows_insert()</code> adds new rows (like <code>INSERT</code>). By default, key values in
<code>y</code> must not exist in <code>x</code>.
</p>
</li>
<li> <p><code>rows_append()</code> works like <code>rows_insert()</code> but ignores keys.
</p>
</li>
<li> <p><code>rows_update()</code> modifies existing rows (like <code>UPDATE</code>). Key values in <code>y</code>
must be unique, and, by default, key values in <code>y</code> must exist in <code>x</code>.
</p>
</li>
<li> <p><code>rows_patch()</code> works like <code>rows_update()</code> but only overwrites <code>NA</code> values.
</p>
</li>
<li> <p><code>rows_upsert()</code> inserts or updates depending on whether or not the
key value in <code>y</code> already exists in <code>x</code>. Key values in <code>y</code> must be unique.
</p>
</li>
<li> <p><code>rows_delete()</code> deletes rows (like <code>DELETE</code>). By default, key values in <code>y</code>
must exist in <code>x</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>rows_insert(
  x,
  y,
  by = NULL,
  ...,
  conflict = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE
)

rows_append(x, y, ..., copy = FALSE, in_place = FALSE)

rows_update(
  x,
  y,
  by = NULL,
  ...,
  unmatched = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE
)

rows_patch(
  x,
  y,
  by = NULL,
  ...,
  unmatched = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE
)

rows_upsert(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE)

rows_delete(
  x,
  y,
  by = NULL,
  ...,
  unmatched = c("error", "ignore"),
  copy = FALSE,
  in_place = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rows_+3A_x">x</code>, <code id="rows_+3A_y">y</code></td>
<td>
<p>A pair of data frames or data frame extensions (e.g. a tibble).
<code>y</code> must have the same columns of <code>x</code> or a subset.</p>
</td></tr>
<tr><td><code id="rows_+3A_by">by</code></td>
<td>
<p>An unnamed character vector giving the key columns. The key columns
must exist in both <code>x</code> and <code>y</code>. Keys typically uniquely identify each row,
but this is only enforced for the key values of <code>y</code> when <code>rows_update()</code>,
<code>rows_patch()</code>, or <code>rows_upsert()</code> are used.
</p>
<p>By default, we use the first column in <code>y</code>, since the first column is
a reasonable place to put an identifier variable.</p>
</td></tr>
<tr><td><code id="rows_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="rows_+3A_conflict">conflict</code></td>
<td>
<p>For <code>rows_insert()</code>, how should keys in <code>y</code> that conflict
with keys in <code>x</code> be handled? A conflict arises if there is a key in <code>y</code>
that already exists in <code>x</code>.
</p>
<p>One of:
</p>

<ul>
<li> <p><code>"error"</code>, the default, will error if there are any keys in <code>y</code> that
conflict with keys in <code>x</code>.
</p>
</li>
<li> <p><code>"ignore"</code> will ignore rows in <code>y</code> with keys that conflict with keys in
<code>x</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rows_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="rows_+3A_in_place">in_place</code></td>
<td>
<p>Should <code>x</code> be modified in place? This argument is only
relevant for mutable backends (e.g. databases, data.tables).
</p>
<p>When <code>TRUE</code>, a modified version of <code>x</code> is returned invisibly;
when <code>FALSE</code>, a new object representing the resulting changes is returned.</p>
</td></tr>
<tr><td><code id="rows_+3A_unmatched">unmatched</code></td>
<td>
<p>For <code>rows_update()</code>, <code>rows_patch()</code>, and <code>rows_delete()</code>,
how should keys in <code>y</code> that are unmatched by the keys in <code>x</code> be handled?
</p>
<p>One of:
</p>

<ul>
<li> <p><code>"error"</code>, the default, will error if there are any keys in <code>y</code> that
are unmatched by the keys in <code>x</code>.
</p>
</li>
<li> <p><code>"ignore"</code> will ignore rows in <code>y</code> with keys that are unmatched by the
keys in <code>x</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>x</code>. The order of the rows and columns of <code>x</code>
is preserved as much as possible. The output has the following properties:
</p>

<ul>
<li> <p><code>rows_update()</code> and <code>rows_patch()</code> preserve the number of rows;
<code>rows_insert()</code>, <code>rows_append()</code>, and <code>rows_upsert()</code> return all existing
rows and potentially new rows; <code>rows_delete()</code> returns a subset of the
rows.
</p>
</li>
<li><p> Columns are not added, removed, or relocated, though the data may be
updated.
</p>
</li>
<li><p> Groups are taken from <code>x</code>.
</p>
</li>
<li><p> Data frame attributes are taken from <code>x</code>.
</p>
</li></ul>

<p>If <code>in_place = TRUE</code>, the result will be returned invisibly.
</p>


<h3>Methods</h3>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>rows_insert()</code>: no methods found.
</p>
</li>
<li> <p><code>rows_append()</code>: no methods found.
</p>
</li>
<li> <p><code>rows_update()</code>: no methods found.
</p>
</li>
<li> <p><code>rows_patch()</code>: no methods found.
</p>
</li>
<li> <p><code>rows_upsert()</code>: no methods found.
</p>
</li>
<li> <p><code>rows_delete()</code>: no methods found.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)
data

# Insert
rows_insert(data, tibble(a = 4, b = "z"))

# By default, if a key in `y` matches a key in `x`, then it can't be inserted
# and will throw an error. Alternatively, you can ignore rows in `y`
# containing keys that conflict with keys in `x` with `conflict = "ignore"`,
# or you can use `rows_append()` to ignore keys entirely.
try(rows_insert(data, tibble(a = 3, b = "z")))
rows_insert(data, tibble(a = 3, b = "z"), conflict = "ignore")
rows_append(data, tibble(a = 3, b = "z"))

# Update
rows_update(data, tibble(a = 2:3, b = "z"))
rows_update(data, tibble(b = "z", a = 2:3), by = "a")

# Variants: patch and upsert
rows_patch(data, tibble(a = 2:3, b = "z"))
rows_upsert(data, tibble(a = 2:4, b = "z"))

# Delete and truncate
rows_delete(data, tibble(a = 2:3))
rows_delete(data, tibble(a = 2:3, b = "b"))

# By default, for update, patch, and delete it is an error if a key in `y`
# doesn't exist in `x`. You can ignore rows in `y` that have unmatched keys
# with `unmatched = "ignore"`.
y &lt;- tibble(a = 3:4, b = "z")
try(rows_update(data, y, by = "a"))
rows_update(data, y, by = "a", unmatched = "ignore")
rows_patch(data, y, by = "a", unmatched = "ignore")
rows_delete(data, y, by = "a", unmatched = "ignore")
</code></pre>

<hr>
<h2 id='rowwise'>Group input by rows</h2><span id='topic+rowwise'></span>

<h3>Description</h3>

<p><code>rowwise()</code> allows you to compute on a data frame a row-at-a-time.
This is most useful when a vectorised function doesn't exist.
</p>
<p>Most dplyr verbs preserve row-wise grouping. The exception is <code><a href="dplyr.html#topic+summarise">summarise()</a></code>,
which return a <a href="dplyr.html#topic+grouped_df">grouped_df</a>. You can explicitly ungroup with <code><a href="dplyr.html#topic+ungroup">ungroup()</a></code>
or <code><a href="dplyr.html#topic+as_tibble">as_tibble()</a></code>, or convert to a <a href="dplyr.html#topic+grouped_df">grouped_df</a> with <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowwise(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowwise_+3A_data">data</code></td>
<td>
<p>Input data frame.</p>
</td></tr>
<tr><td><code id="rowwise_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Variables to be preserved
when calling <code><a href="dplyr.html#topic+summarise">summarise()</a></code>. This is typically a set of variables whose
combination uniquely identify each row.
</p>
<p><strong>NB</strong>: unlike <code>group_by()</code> you can not create new variables here but
instead you can select multiple variables with (e.g.) <code>everything()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row-wise data frame with class <code>rowwise_df</code>. Note that a
<code>rowwise_df</code> is implicitly grouped by row, but is not a <code>grouped_df</code>.
</p>


<h3>List-columns</h3>

<p>Because a rowwise has exactly one row per group it offers a small
convenience for working with list-columns. Normally, <code>summarise()</code> and
<code>mutate()</code> extract a groups worth of data with <code>[</code>. But when you index
a list in this way, you get back another list. When you're working with
a <code>rowwise</code> tibble, then dplyr will use <code>[[</code> instead of <code>[</code> to make your
life a little easier.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+nest_by">nest_by()</a></code> for a convenient way of creating rowwise data frames
with nested data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = runif(6), y = runif(6), z = runif(6))
# Compute the mean of x, y, z in each row
df %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z)))
# use c_across() to more easily select many variables
df %&gt;% rowwise() %&gt;% mutate(m = mean(c_across(x:z)))

# Compute the minimum of x and y in each row
df %&gt;% rowwise() %&gt;% mutate(m = min(c(x, y, z)))
# In this case you can use an existing vectorised function:
df %&gt;% mutate(m = pmin(x, y, z))
# Where these functions exist they'll be much faster than rowwise
# so be on the lookout for them.

# rowwise() is also useful when doing simulations
params &lt;- tribble(
 ~sim, ~n, ~mean, ~sd,
    1,  1,     1,   1,
    2,  2,     2,   4,
    3,  3,    -1,   2
)
# Here I supply variables to preserve after the computation
params %&gt;%
  rowwise(sim) %&gt;%
  reframe(z = rnorm(n, mean, sd))

# If you want one row per simulation, put the results in a list()
params %&gt;%
  rowwise(sim) %&gt;%
  summarise(z = list(rnorm(n, mean, sd)), .groups = "keep")
</code></pre>

<hr>
<h2 id='same_src'>Figure out if two sources are the same (or two tbl have the same source)</h2><span id='topic+same_src'></span>

<h3>Description</h3>

<p>Figure out if two sources are the same (or two tbl have the same source)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same_src(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same_src_+3A_x">x</code>, <code id="same_src_+3A_y">y</code></td>
<td>
<p>src or tbls to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical flag
</p>

<hr>
<h2 id='sample_n'>Sample n rows from a table</h2><span id='topic+sample_n'></span><span id='topic+sample_frac'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
<code>sample_n()</code> and <code>sample_frac()</code> have been superseded in favour of
<code><a href="dplyr.html#topic+slice_sample">slice_sample()</a></code>. While they will not be deprecated in the near future,
retirement means that we will only perform critical bug fixes, so we recommend
moving to the newer alternative.
</p>
<p>These functions were superseded because we realised it was more convenient to
have two mutually exclusive arguments to one function, rather than two
separate functions. This also made it to clean up a few other smaller
design issues with <code>sample_n()</code>/<code>sample_frac</code>:
</p>

<ul>
<li><p> The connection to <code>slice()</code> was not obvious.
</p>
</li>
<li><p> The name of the first argument, <code>tbl</code>, is inconsistent with other
single table verbs which use <code>.data</code>.
</p>
</li>
<li><p> The <code>size</code> argument uses tidy evaluation, which is surprising and
undocumented.
</p>
</li>
<li><p> It was easier to remove the deprecated <code>.env</code> argument.
</p>
</li>
<li> <p><code>...</code> was in a suboptimal position.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...)

sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_n_+3A_tbl">tbl</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_size">size</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;
For <code>sample_n()</code>, the number of rows to select.
For <code>sample_frac()</code>, the fraction of rows to select.
If <code>tbl</code> is grouped, <code>size</code> applies to each group.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_replace">replace</code></td>
<td>
<p>Sample with or without replacement?</p>
</td></tr>
<tr><td><code id="sample_n_+3A_weight">weight</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Sampling weights.
This must evaluate to a vector of non-negative numbers the same length as
the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_.env">.env</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="sample_n_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(x = 1:5, w = c(0.1, 0.1, 0.1, 2, 2))

# sample_n() -&gt; slice_sample() ----------------------------------------------
# Was:
sample_n(df, 3)
sample_n(df, 10, replace = TRUE)
sample_n(df, 3, weight = w)

# Now:
slice_sample(df, n = 3)
slice_sample(df, n = 10, replace = TRUE)
slice_sample(df, n = 3, weight_by = w)

# Note that sample_n() would error if n was bigger than the group size
# slice_sample() will just use the available rows for consistency with
# the other slice helpers like slice_head()
try(sample_n(df, 10))
slice_sample(df, n = 10)

# sample_frac() -&gt; slice_sample() -------------------------------------------
# Was:
sample_frac(df, 0.25)
sample_frac(df, 2, replace = TRUE)

# Now:
slice_sample(df, prop = 0.25)
slice_sample(df, prop = 2, replace = TRUE)
</code></pre>

<hr>
<h2 id='scoped'>Operate on a selection of variables</h2><span id='topic+scoped'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code>, <code style="white-space: pre;">&#8288;_all&#8288;</code>) have been superseded by the use of
<code><a href="dplyr.html#topic+pick">pick()</a></code> or <code><a href="dplyr.html#topic+across">across()</a></code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>The variants suffixed with <code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code> or <code style="white-space: pre;">&#8288;_all&#8288;</code> apply an
expression (sometimes several) to all variables within a specified
subset. This subset can contain all variables (<code style="white-space: pre;">&#8288;_all&#8288;</code> variants), a
<code><a href="dplyr.html#topic+vars">vars()</a></code> selection (<code style="white-space: pre;">&#8288;_at&#8288;</code> variants), or variables selected with a
predicate (<code style="white-space: pre;">&#8288;_if&#8288;</code> variants).
</p>
<p>The verbs with scoped variants are:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+mutate">mutate()</a></code>, <code><a href="dplyr.html#topic+transmute">transmute()</a></code> and <code><a href="dplyr.html#topic+summarise">summarise()</a></code>. See <code><a href="dplyr.html#topic+summarise_all">summarise_all()</a></code>.
</p>
</li>
<li> <p><code><a href="stats.html#topic+filter">filter()</a></code>. See <code><a href="dplyr.html#topic+filter_all">filter_all()</a></code>.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_by">group_by()</a></code>. See <code><a href="dplyr.html#topic+group_by_all">group_by_all()</a></code>.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rename">rename()</a></code> and <code><a href="MASS.html#topic+select">select()</a></code>. See <code><a href="dplyr.html#topic+select_all">select_all()</a></code>.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+arrange">arrange()</a></code>. See <code><a href="dplyr.html#topic+arrange_all">arrange_all()</a></code>
</p>
</li></ul>

<p>There are three kinds of scoped variants. They differ in the scope
of the variable selection on which operations are applied:
</p>

<ul>
<li><p> Verbs suffixed with <code style="white-space: pre;">&#8288;_all()&#8288;</code> apply an operation on all variables.
</p>
</li>
<li><p> Verbs suffixed with <code style="white-space: pre;">&#8288;_at()&#8288;</code> apply an operation on a subset of
variables specified with the quoting function <code><a href="dplyr.html#topic+vars">vars()</a></code>. This
quoting function accepts <code><a href="tidyselect.html#topic+vars_select">tidyselect::vars_select()</a></code> helpers like
<code><a href="dplyr.html#topic+starts_with">starts_with()</a></code>. Instead of a <code><a href="dplyr.html#topic+vars">vars()</a></code> selection, you can also
supply an <a href="rlang.html#topic+is_integerish">integerish</a> vector of column
positions or a character vector of column names.
</p>
</li>
<li><p> Verbs suffixed with <code style="white-space: pre;">&#8288;_if()&#8288;</code> apply an operation on the subset of
variables for which a predicate function returns <code>TRUE</code>. Instead
of a predicate function, you can also supply a logical vector.
</p>
</li></ul>



<h3>Arguments</h3>

<table>
<tr><td><code id="scoped_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="scoped_+3A_.funs">.funs</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td></tr>
<tr><td><code id="scoped_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="scoped_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
<tr><td><code id="scoped_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with <a href="rlang.html#topic+dyn-dots">tidy dots</a> support.</p>
</td></tr>
</table>


<h3>Grouping variables</h3>

<p>Most of these operations also apply on the grouping variables when
they are part of the selection. This includes:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+arrange_all">arrange_all()</a></code>, <code><a href="dplyr.html#topic+arrange_at">arrange_at()</a></code>, and <code><a href="dplyr.html#topic+arrange_if">arrange_if()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+distinct_all">distinct_all()</a></code>, <code><a href="dplyr.html#topic+distinct_at">distinct_at()</a></code>, and <code><a href="dplyr.html#topic+distinct_if">distinct_if()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+filter_all">filter_all()</a></code>, <code><a href="dplyr.html#topic+filter_at">filter_at()</a></code>, and <code><a href="dplyr.html#topic+filter_if">filter_if()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_by_all">group_by_all()</a></code>, <code><a href="dplyr.html#topic+group_by_at">group_by_at()</a></code>, and <code><a href="dplyr.html#topic+group_by_if">group_by_if()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+select_all">select_all()</a></code>, <code><a href="dplyr.html#topic+select_at">select_at()</a></code>, and <code><a href="dplyr.html#topic+select_if">select_if()</a></code>
</p>
</li></ul>

<p>This is not the case for summarising and mutating variants where
operations are <em>not</em> applied on grouping variables. The behaviour
depends on whether the selection is <strong>implicit</strong> (<code>all</code> and <code>if</code>
selections) or <strong>explicit</strong> (<code>at</code> selections). Grouping variables
covered by explicit selections (with <code><a href="dplyr.html#topic+summarise_at">summarise_at()</a></code>,
<code><a href="dplyr.html#topic+mutate_at">mutate_at()</a></code>, and <code><a href="dplyr.html#topic+transmute_at">transmute_at()</a></code>) are always an error. For
implicit selections, the grouping variables are always ignored. In
this case, the level of verbosity depends on the kind of operation:
</p>

<ul>
<li><p> Summarising operations (<code><a href="dplyr.html#topic+summarise_all">summarise_all()</a></code> and <code><a href="dplyr.html#topic+summarise_if">summarise_if()</a></code>)
ignore grouping variables silently because it is obvious that
operations are not applied on grouping variables.
</p>
</li>
<li><p> On the other hand it isn't as obvious in the case of mutating
operations (<code><a href="dplyr.html#topic+mutate_all">mutate_all()</a></code>, <code><a href="dplyr.html#topic+mutate_if">mutate_if()</a></code>, <code><a href="dplyr.html#topic+transmute_all">transmute_all()</a></code>, and
<code><a href="dplyr.html#topic+transmute_if">transmute_if()</a></code>). For this reason, they issue a message
indicating which grouping variables are ignored.
</p>
</li></ul>


<hr>
<h2 id='se-deprecated'>Deprecated SE versions of main verbs.</h2><span id='topic+se-deprecated'></span><span id='topic+add_count_'></span><span id='topic+add_tally_'></span><span id='topic+arrange_'></span><span id='topic+count_'></span><span id='topic+distinct_'></span><span id='topic+do_'></span><span id='topic+filter_'></span><span id='topic+funs_'></span><span id='topic+group_by_'></span><span id='topic+group_indices_'></span><span id='topic+mutate_'></span><span id='topic+tally_'></span><span id='topic+transmute_'></span><span id='topic+rename_'></span><span id='topic+rename_vars_'></span><span id='topic+select_'></span><span id='topic+select_vars_'></span><span id='topic+slice_'></span><span id='topic+summarise_'></span><span id='topic+summarize_'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>dplyr used to offer twin versions of each verb suffixed with an
underscore. These versions had standard evaluation (SE) semantics:
rather than taking arguments by code, like NSE verbs, they took
arguments by value. Their purpose was to make it possible to
program with dplyr. However, dplyr now uses tidy evaluation
semantics. NSE verbs still capture their arguments, but you can now
unquote parts of these arguments. This offers full programmability
with NSE verbs. Thus, the underscored versions are now superfluous.
</p>
<p>Unquoting triggers immediate evaluation of its operand and inlines
the result within the captured expression. This result can be a
value or an expression to be evaluated later with the rest of the
argument. See <code>vignette("programming")</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_count_(x, vars, wt = NULL, sort = FALSE)

add_tally_(x, wt, sort = FALSE)

arrange_(.data, ..., .dots = list())

count_(x, vars, wt = NULL, sort = FALSE, .drop = group_by_drop_default(x))

distinct_(.data, ..., .dots, .keep_all = FALSE)

do_(.data, ..., .dots = list())

filter_(.data, ..., .dots = list())

funs_(dots, args = list(), env = base_env())

group_by_(.data, ..., .dots = list(), add = FALSE)

group_indices_(.data, ..., .dots = list())

mutate_(.data, ..., .dots = list())

tally_(x, wt, sort = FALSE)

transmute_(.data, ..., .dots = list())

rename_(.data, ..., .dots = list())

rename_vars_(vars, args)

select_(.data, ..., .dots = list())

select_vars_(vars, args, include = chr(), exclude = chr())

slice_(.data, ..., .dots = list())

summarise_(.data, ..., .dots = list())

summarize_(.data, ..., .dots = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se-deprecated_+3A_x">x</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_vars">vars</code></td>
<td>
<p>Various meanings depending on the verb.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_wt">wt</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="se-deprecated_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_dots">dots</code>, <code id="se-deprecated_+3A_.dots">.dots</code>, <code id="se-deprecated_+3A_...">...</code></td>
<td>
<p>Pair/values of expressions coercible to lazy objects.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_args">args</code></td>
<td>
<p>Various meanings depending on the verb.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_env">env</code></td>
<td>
<p>The environment in which functions should be evaluated.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_add">add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="se-deprecated_+3A_include">include</code>, <code id="se-deprecated_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of column names to always
include/exclude.</p>
</td></tr>
</table>

<hr>
<h2 id='select'>Keep or drop columns using their names and types</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Select (and optionally rename) variables in a data frame, using a concise
mini-language that makes it easy to refer to variables based on their name
(e.g. <code>a:f</code> selects all columns from <code>a</code> on the left to <code>f</code> on the
right) or type (e.g. <code>where(is.numeric)</code> selects all numeric columns).
</p>


<h4>Overview of selection features</h4>

<p>Tidyverse selections implement a dialect of R where operators make
it easy to select variables:
</p>

<ul>
<li> <p><code>:</code> for selecting a range of consecutive variables.
</p>
</li>
<li> <p><code>!</code> for taking the complement of a set of variables.
</p>
</li>
<li> <p><code>&amp;</code> and <code>|</code> for selecting the intersection or the union of two
sets of variables.
</p>
</li>
<li> <p><code>c()</code> for combining selections.
</p>
</li></ul>

<p>In addition, you can use <strong>selection helpers</strong>. Some helpers select specific
columns:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+everything">everything()</a></code>: Matches all variables.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+everything">last_col()</a></code>: Select last variable, possibly with an offset.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_cols">group_cols()</a></code>: Select all grouping columns.
</p>
</li></ul>

<p>Other helpers select variables by matching patterns in their names:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+starts_with">starts_with()</a></code>: Starts with a prefix.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">ends_with()</a></code>: Ends with a suffix.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">contains()</a></code>: Contains a literal string.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">matches()</a></code>: Matches a regular expression.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+starts_with">num_range()</a></code>: Matches a numerical range like x01, x02, x03.
</p>
</li></ul>

<p>Or from variables stored in a character vector:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+all_of">all_of()</a></code>: Matches variable names in a character vector. All
names must be present, otherwise an out-of-bounds error is
thrown.
</p>
</li>
<li> <p><code><a href="tidyselect.html#topic+all_of">any_of()</a></code>: Same as <code>all_of()</code>, except that no error is thrown
for names that don't exist.
</p>
</li></ul>

<p>Or using a predicate function:
</p>

<ul>
<li> <p><code><a href="tidyselect.html#topic+where">where()</a></code>: Applies a function to all variables and selects those
for which the function returns <code>TRUE</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; One or more unquoted
expressions separated by commas. Variable names can be used as if they
were positions in the data frame, so expressions like <code>x:y</code> can
be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> Output columns are a subset of input columns, potentially with a different
order. Columns will be renamed if <code>new_name = old_name</code> form is used.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are maintained; you can't select off grouping variables.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>Examples</h3>

<p>Here we show the usage for the basic selection operators. See the
specific help pages to learn about helpers like <code><a href="dplyr.html#topic+starts_with">starts_with()</a></code>.
</p>
<p>The selection language can be used in functions like
<code>dplyr::select()</code> or <code>tidyr::pivot_longer()</code>. Let's first attach
the tidyverse:
</p>
<div class="sourceCode r"><pre>library(tidyverse)

# For better printing
iris &lt;- as_tibble(iris)
</pre></div>
<p>Select variables by name:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(height)
#&gt; # A tibble: 87 x 1
#&gt;   height
#&gt;    &lt;int&gt;
#&gt; 1    172
#&gt; 2    167
#&gt; 3     96
#&gt; 4    202
#&gt; # i 83 more rows

iris %&gt;% pivot_longer(Sepal.Length)
#&gt; # A tibble: 150 x 6
#&gt;   Sepal.Width Petal.Length Petal.Width Species name         value
#&gt;         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1         3.5          1.4         0.2 setosa  Sepal.Length   5.1
#&gt; 2         3            1.4         0.2 setosa  Sepal.Length   4.9
#&gt; 3         3.2          1.3         0.2 setosa  Sepal.Length   4.7
#&gt; 4         3.1          1.5         0.2 setosa  Sepal.Length   4.6
#&gt; # i 146 more rows
</pre></div>
<p>Select multiple variables by separating them with commas. Note how
the order of columns is determined by the order of inputs:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(homeworld, height, mass)
#&gt; # A tibble: 87 x 3
#&gt;   homeworld height  mass
#&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt;
#&gt; 1 Tatooine     172    77
#&gt; 2 Tatooine     167    75
#&gt; 3 Naboo         96    32
#&gt; 4 Tatooine     202   136
#&gt; # i 83 more rows
</pre></div>
<p>Functions like <code>tidyr::pivot_longer()</code> don't take variables with
dots. In this case use <code>c()</code> to select multiple variables:
</p>
<div class="sourceCode r"><pre>iris %&gt;% pivot_longer(c(Sepal.Length, Petal.Length))
#&gt; # A tibble: 300 x 5
#&gt;   Sepal.Width Petal.Width Species name         value
#&gt;         &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1         3.5         0.2 setosa  Sepal.Length   5.1
#&gt; 2         3.5         0.2 setosa  Petal.Length   1.4
#&gt; 3         3           0.2 setosa  Sepal.Length   4.9
#&gt; 4         3           0.2 setosa  Petal.Length   1.4
#&gt; # i 296 more rows
</pre></div>


<h4>Operators:</h4>

<p>The <code>:</code> operator selects a range of consecutive variables:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(name:mass)
#&gt; # A tibble: 87 x 3
#&gt;   name           height  mass
#&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt;
#&gt; 1 Luke Skywalker    172    77
#&gt; 2 C-3PO             167    75
#&gt; 3 R2-D2              96    32
#&gt; 4 Darth Vader       202   136
#&gt; # i 83 more rows
</pre></div>
<p>The <code>!</code> operator negates a selection:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(!(name:mass))
#&gt; # A tibble: 87 x 11
#&gt;   hair_color skin_color  eye_color birth_year sex   gender    homeworld species
#&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;  
#&gt; 1 blond      fair        blue            19   male  masculine Tatooine  Human  
#&gt; 2 &lt;NA&gt;       gold        yellow         112   none  masculine Tatooine  Droid  
#&gt; 3 &lt;NA&gt;       white, blue red             33   none  masculine Naboo     Droid  
#&gt; 4 none       white       yellow          41.9 male  masculine Tatooine  Human  
#&gt; # i 83 more rows
#&gt; # i 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;

iris %&gt;% select(!c(Sepal.Length, Petal.Length))
#&gt; # A tibble: 150 x 3
#&gt;   Sepal.Width Petal.Width Species
#&gt;         &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1         3.5         0.2 setosa 
#&gt; 2         3           0.2 setosa 
#&gt; 3         3.2         0.2 setosa 
#&gt; 4         3.1         0.2 setosa 
#&gt; # i 146 more rows

iris %&gt;% select(!ends_with("Width"))
#&gt; # A tibble: 150 x 3
#&gt;   Sepal.Length Petal.Length Species
#&gt;          &lt;dbl&gt;        &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1          5.1          1.4 setosa 
#&gt; 2          4.9          1.4 setosa 
#&gt; 3          4.7          1.3 setosa 
#&gt; 4          4.6          1.5 setosa 
#&gt; # i 146 more rows
</pre></div>
<p><code>&amp;</code> and <code>|</code> take the intersection or the union of two selections:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with("Petal") &amp; ends_with("Width"))
#&gt; # A tibble: 150 x 1
#&gt;   Petal.Width
#&gt;         &lt;dbl&gt;
#&gt; 1         0.2
#&gt; 2         0.2
#&gt; 3         0.2
#&gt; 4         0.2
#&gt; # i 146 more rows

iris %&gt;% select(starts_with("Petal") | ends_with("Width"))
#&gt; # A tibble: 150 x 3
#&gt;   Petal.Length Petal.Width Sepal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          1.4         0.2         3.5
#&gt; 2          1.4         0.2         3  
#&gt; 3          1.3         0.2         3.2
#&gt; 4          1.5         0.2         3.1
#&gt; # i 146 more rows
</pre></div>
<p>To take the difference between two selections, combine the <code>&amp;</code> and
<code>!</code> operators:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with("Petal") &amp; !ends_with("Width"))
#&gt; # A tibble: 150 x 1
#&gt;   Petal.Length
#&gt;          &lt;dbl&gt;
#&gt; 1          1.4
#&gt; 2          1.4
#&gt; 3          1.3
#&gt; 4          1.5
#&gt; # i 146 more rows
</pre></div>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="stats.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>

<hr>
<h2 id='select_all'>Select and rename a selection of variables</h2><span id='topic+select_all'></span><span id='topic+rename_all'></span><span id='topic+select_if'></span><span id='topic+rename_if'></span><span id='topic+select_at'></span><span id='topic+rename_at'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>rename_if()</code>, <code>rename_at()</code>, and <code>rename_all()</code> have been superseded by
<code>rename_with()</code>. The matching select statements have been superseded by the
combination of a <code>select()</code> + <code>rename_with()</code>. Any predicate functions passed
as arguments to <code>select()</code> or <code>rename_with()</code> must be wrapped in <code><a href="ape.html#topic+where">where()</a></code>.
</p>
<p>These functions were superseded because <code>mutate_if()</code> and friends were
superseded by <code>across()</code>. <code>select_if()</code> and <code>rename_if()</code> already use tidy
selection so they can't be replaced by <code>across()</code> and instead we need a new
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_all(.tbl, .funs = list(), ...)

rename_all(.tbl, .funs = list(), ...)

select_if(.tbl, .predicate, .funs = list(), ...)

rename_if(.tbl, .predicate, .funs = list(), ...)

select_at(.tbl, .vars, .funs = list(), ...)

rename_at(.tbl, .vars, .funs = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_all_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="select_all_+3A_.funs">.funs</code></td>
<td>
<p>A function <code>fun</code>, a purrr style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td></tr>
<tr><td><code id="select_all_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with <a href="rlang.html#topic+dyn-dots">tidy dots</a> support.</p>
</td></tr>
<tr><td><code id="select_all_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
<tr><td><code id="select_all_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars &lt;- as_tibble(mtcars) # for nicer printing

mtcars %&gt;% rename_all(toupper)
# -&gt;
mtcars %&gt;% rename_with(toupper)

# NB: the transformation comes first in rename_with
is_whole &lt;- function(x) all(floor(x) == x)
mtcars %&gt;% rename_if(is_whole, toupper)
# -&gt;
mtcars %&gt;% rename_with(toupper, where(is_whole))

mtcars %&gt;% rename_at(vars(mpg:hp), toupper)
# -&gt;
mtcars %&gt;% rename_with(toupper, mpg:hp)

# You now must select() and then rename

mtcars %&gt;% select_all(toupper)
# -&gt;
mtcars %&gt;% rename_with(toupper)

# Selection drops unselected variables:
mtcars %&gt;% select_if(is_whole, toupper)
# -&gt;
mtcars %&gt;% select(where(is_whole)) %&gt;% rename_with(toupper)

mtcars %&gt;% select_at(vars(-contains("ar"), starts_with("c")), toupper)
# -&gt;
mtcars %&gt;%
  select(!contains("ar") | starts_with("c")) %&gt;%
  rename_with(toupper)
</code></pre>

<hr>
<h2 id='setops'>Set operations</h2><span id='topic+setops'></span><span id='topic+intersect'></span><span id='topic+union'></span><span id='topic+union_all'></span><span id='topic+setdiff'></span><span id='topic+setequal'></span><span id='topic+symdiff'></span>

<h3>Description</h3>

<p>Perform set operations using the rows of a data frame.
</p>

<ul>
<li> <p><code>intersect(x, y)</code> finds all rows in both <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>union(x, y)</code> finds all rows in either <code>x</code> or <code>y</code>, excluding duplicates.
</p>
</li>
<li> <p><code>union_all(x, y)</code> finds all rows in either <code>x</code> or <code>y</code>, including duplicates.
</p>
</li>
<li> <p><code>setdiff(x, y)</code> finds all rows in <code>x</code> that aren't in <code>y</code>.
</p>
</li>
<li> <p><code>symdiff(x, y)</code> computes the symmetric difference, i.e. all rows in
<code>x</code> that aren't in <code>y</code> and all rows in <code>y</code> that aren't in <code>x</code>.
</p>
</li>
<li> <p><code>setequal(x, y)</code> returns <code>TRUE</code> if <code>x</code> and <code>y</code> contain the same rows
(ignoring order).
</p>
</li></ul>

<p>Note that <code>intersect()</code>, <code>union()</code>, <code>setdiff()</code>, and <code>symdiff()</code> remove
duplicates in <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect(x, y, ...)

union(x, y, ...)

union_all(x, y, ...)

setdiff(x, y, ...)

setequal(x, y, ...)

symdiff(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setops_+3A_x">x</code>, <code id="setops_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="setops_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Base functions</h3>

<p><code>intersect()</code>, <code>union()</code>, <code>setdiff()</code>, and <code>setequal()</code> override the base
functions of the same name in order to make them generic. The existing
behaviour for vectors is preserved by providing default methods that call
the base functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tibble(x = 1:3)
df2 &lt;- tibble(x = 3:5)

intersect(df1, df2)
union(df1, df2)
union_all(df1, df2)
setdiff(df1, df2)
setdiff(df2, df1)
symdiff(df1, df2)

setequal(df1, df2)
setequal(df1, df1[3:1, ])

# Note that the following functions remove pre-existing duplicates:
df1 &lt;- tibble(x = c(1:3, 3, 3))
df2 &lt;- tibble(x = c(3:5, 5))

intersect(df1, df2)
union(df1, df2)
setdiff(df1, df2)
symdiff(df1, df2)
</code></pre>

<hr>
<h2 id='slice'>Subset rows using their positions</h2><span id='topic+slice'></span><span id='topic+slice_head'></span><span id='topic+slice_tail'></span><span id='topic+slice_min'></span><span id='topic+slice_max'></span><span id='topic+slice_sample'></span>

<h3>Description</h3>

<p><code>slice()</code> lets you index rows by their (integer) locations. It allows you
to select, remove, and duplicate rows. It is accompanied by a number of
helpers for common use cases:
</p>

<ul>
<li> <p><code>slice_head()</code> and <code>slice_tail()</code> select the first or last rows.
</p>
</li>
<li> <p><code>slice_sample()</code> randomly selects rows.
</p>
</li>
<li> <p><code>slice_min()</code> and <code>slice_max()</code> select rows with the smallest or largest
values of a variable.
</p>
</li></ul>

<p>If <code>.data</code> is a <a href="dplyr.html#topic+grouped_df">grouped_df</a>, the operation will be performed on each group,
so that (e.g.) <code>slice_head(df, n = 5)</code> will select the first five rows in
each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(.data, ..., .by = NULL, .preserve = FALSE)

slice_head(.data, ..., n, prop, by = NULL)

slice_tail(.data, ..., n, prop, by = NULL)

slice_min(
  .data,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = FALSE
)

slice_max(
  .data,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = FALSE
)

slice_sample(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.</p>
</td></tr>
<tr><td><code id="slice_+3A_.by">.by</code>, <code id="slice_+3A_by">by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="slice_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
<tr><td><code id="slice_+3A_n">n</code>, <code id="slice_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</td></tr>
<tr><td><code id="slice_+3A_order_by">order_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</td></tr>
<tr><td><code id="slice_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="slice_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</td></tr>
<tr><td><code id="slice_+3A_weight_by">weight_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="slice_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slice does not work with relational databases because they have no
intrinsic notion of row order. If you want to perform the equivalent
operation, use <code><a href="stats.html#topic+filter">filter()</a></code> and <code><a href="dplyr.html#topic+row_number">row_number()</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Each row may appear 0, 1, or many times in the output.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Methods</h3>

<p>These function are <strong>generic</strong>s, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
</p>

<ul>
<li> <p><code>slice()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_head()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_tail()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_min()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_max()</code>: no methods found.
</p>
</li>
<li> <p><code>slice_sample()</code>: no methods found.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="stats.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="MASS.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+summarise">summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Similar to head(mtcars, 1):
mtcars %&gt;% slice(1L)
# Similar to tail(mtcars, 1):
mtcars %&gt;% slice(n())
mtcars %&gt;% slice(5:n())
# Rows can be dropped with negative indices:
slice(mtcars, -(1:4))

# First and last rows based on existing order
mtcars %&gt;% slice_head(n = 5)
mtcars %&gt;% slice_tail(n = 5)

# Rows with minimum and maximum values of a variable
mtcars %&gt;% slice_min(mpg, n = 5)
mtcars %&gt;% slice_max(mpg, n = 5)

# slice_min() and slice_max() may return more rows than requested
# in the presence of ties.
mtcars %&gt;% slice_min(cyl, n = 1)
# Use with_ties = FALSE to return exactly n matches
mtcars %&gt;% slice_min(cyl, n = 1, with_ties = FALSE)
# Or use additional variables to break the tie:
mtcars %&gt;% slice_min(tibble(cyl, mpg), n = 1)

# slice_sample() allows you to random select with or without replacement
mtcars %&gt;% slice_sample(n = 5)
mtcars %&gt;% slice_sample(n = 5, replace = TRUE)

# you can optionally weight by a variable - this code weights by the
# physical weight of the cars, so heavy cars are more likely to get
# selected
mtcars %&gt;% slice_sample(weight_by = wt, n = 5)

# Group wise operation ----------------------------------------
df &lt;- tibble(
  group = rep(c("a", "b", "c"), c(1, 2, 4)),
  x = runif(7)
)

# All slice helpers operate per group, silently truncating to the group
# size, so the following code works without error
df %&gt;% group_by(group) %&gt;% slice_head(n = 2)

# When specifying the proportion of rows to include non-integer sizes
# are rounded down, so group a gets 0 rows
df %&gt;% group_by(group) %&gt;% slice_head(prop = 0.5)

# Filter equivalents --------------------------------------------
# slice() expressions can often be written to use `filter()` and
# `row_number()`, which can also be translated to SQL. For many databases,
# you'll need to supply an explicit variable to use to compute the row number.
filter(mtcars, row_number() == 1L)
filter(mtcars, row_number() == n())
filter(mtcars, between(row_number(), 5, n()))
</code></pre>

<hr>
<h2 id='sql'>SQL escaping.</h2><span id='topic+sql'></span>

<h3>Description</h3>

<p>These functions are critical when writing functions that translate R
functions to sql functions. Typically a conversion function should escape
all its inputs and return an sql object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sql_+3A_...">...</code></td>
<td>
<p>Character vectors that will be combined into a single SQL
expression.</p>
</td></tr>
</table>

<hr>
<h2 id='src'>Create a &quot;src&quot; object</h2><span id='topic+src'></span><span id='topic+is.src'></span>

<h3>Description</h3>

<p><code>src()</code> is the standard constructor for srcs and <code>is.src()</code> tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src(subclass, ...)

is.src(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="src_+3A_subclass">subclass</code></td>
<td>
<p>name of subclass. &quot;src&quot; is an abstract base class, so you
must supply this value. <code>src_</code> is automatically prepended to the
class name</p>
</td></tr>
<tr><td><code id="src_+3A_...">...</code></td>
<td>
<p>fields used by object.
</p>
<p>These dots are evaluated with <a href="rlang.html#topic+list2">explicit splicing</a>.</p>
</td></tr>
<tr><td><code id="src_+3A_x">x</code></td>
<td>
<p>object to test for &quot;src&quot;-ness.</p>
</td></tr>
</table>

<hr>
<h2 id='src_dbi'>Source for database backends</h2><span id='topic+src_dbi'></span><span id='topic+src_mysql'></span><span id='topic+src_postgres'></span><span id='topic+src_sqlite'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions have been deprecated; instead please use <code><a href="dplyr.html#topic+tbl">tbl()</a></code>
directly on an <code>DBIConnection</code>. See <a href="https://dbplyr.tidyverse.org/">https://dbplyr.tidyverse.org/</a> for
more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_mysql(
  dbname,
  host = NULL,
  port = 0L,
  username = "root",
  password = "",
  ...
)

src_postgres(
  dbname = NULL,
  host = NULL,
  port = NULL,
  user = NULL,
  password = NULL,
  ...
)

src_sqlite(path, create = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="src_dbi_+3A_dbname">dbname</code></td>
<td>
<p>Database name</p>
</td></tr>
<tr><td><code id="src_dbi_+3A_host">host</code>, <code id="src_dbi_+3A_port">port</code></td>
<td>
<p>Host name and port number of database</p>
</td></tr>
<tr><td><code id="src_dbi_+3A_...">...</code></td>
<td>
<p>for the src, other arguments passed on to the underlying
database connector, <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect()</a></code>. For the tbl, included for
compatibility with the generic, but otherwise ignored.</p>
</td></tr>
<tr><td><code id="src_dbi_+3A_user">user</code>, <code id="src_dbi_+3A_username">username</code>, <code id="src_dbi_+3A_password">password</code></td>
<td>
<p>User name and password.
</p>
<p>Generally, you should avoid saving username and password in your
scripts as it is easy to accidentally expose valuable credentials.
Instead, retrieve them from environment variables, or use database
specific credential scores. For example, with MySQL you can set up <code>my.cnf</code>
as described in <code><a href="RMySQL.html#topic+MySQLDriver-class">RMySQL::MySQL()</a></code>.</p>
</td></tr>
<tr><td><code id="src_dbi_+3A_path">path</code></td>
<td>
<p>Path to SQLite database. You can use the special path
&quot;:memory:&quot; to create a temporary in memory database.</p>
</td></tr>
<tr><td><code id="src_dbi_+3A_create">create</code></td>
<td>
<p>if <code>FALSE</code>, <code>path</code> must already exist. If
<code>TRUE</code>, will create a new SQLite3 database at <code>path</code> if
<code>path</code> does not exist and connect to the existing database if
<code>path</code> does exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with class <code>src_dbi</code>, <code>src_sql</code>, <code>src</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
copy_to(con, mtcars)

# To retrieve a single table from a source, use `tbl()`
mtcars &lt;- con %&gt;% tbl("mtcars")
mtcars

# You can also use pass raw SQL if you want a more sophisticated query
con %&gt;% tbl(sql("SELECT * FROM mtcars WHERE cyl == 8"))

</code></pre>

<hr>
<h2 id='src_local'>A local source</h2><span id='topic+src_local'></span><span id='topic+src_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated since it existed to support a style of testing
dplyr backends that turned out not to be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_local(tbl, pkg = NULL, env = NULL)

src_df(pkg = NULL, env = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="src_local_+3A_tbl">tbl</code></td>
<td>
<p>name of the function used to generate <code>tbl</code> objects</p>
</td></tr>
<tr><td><code id="src_local_+3A_pkg">pkg</code>, <code id="src_local_+3A_env">env</code></td>
<td>
<p>Either the name of a package or an environment object in
which to look for objects.</p>
</td></tr>
</table>

<hr>
<h2 id='src_tbls'>List all tbls provided by a source.</h2><span id='topic+src_tbls'></span>

<h3>Description</h3>

<p>This is a generic method which individual src's will provide methods for.
Most methods will not be documented because it's usually pretty obvious what
possible results will be.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src_tbls(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="src_tbls_+3A_x">x</code></td>
<td>
<p>a data src.</p>
</td></tr>
<tr><td><code id="src_tbls_+3A_...">...</code></td>
<td>
<p>other arguments passed on to the individual methods.</p>
</td></tr>
</table>

<hr>
<h2 id='starwars'>Starwars characters</h2><span id='topic+starwars'></span>

<h3>Description</h3>

<p>The original data, from SWAPI, the Star Wars API, <a href="https://swapi.py4e.com/">https://swapi.py4e.com/</a>, has been revised
to reflect additional research into gender and sex determinations of characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starwars
</code></pre>


<h3>Format</h3>

<p>A tibble with 87 rows and 14 variables:
</p>

<dl>
<dt>name</dt><dd><p>Name of the character</p>
</dd>
<dt>height</dt><dd><p>Height (cm)</p>
</dd>
<dt>mass</dt><dd><p>Weight (kg)</p>
</dd>
<dt>hair_color,skin_color,eye_color</dt><dd><p>Hair, skin, and eye colors</p>
</dd>
<dt>birth_year</dt><dd><p>Year born (BBY = Before Battle of Yavin)</p>
</dd>
<dt>sex</dt><dd><p>The biological sex of the character, namely male, female, hermaphroditic, or none (as in the case for Droids).</p>
</dd>
<dt>gender</dt><dd><p>The gender role or gender identity of the character as determined by their personality or the way they were programmed (as in the case for Droids).</p>
</dd>
<dt>homeworld</dt><dd><p>Name of homeworld</p>
</dd>
<dt>species</dt><dd><p>Name of species</p>
</dd>
<dt>films</dt><dd><p>List of films the character appeared in</p>
</dd>
<dt>vehicles</dt><dd><p>List of vehicles the character has piloted</p>
</dd>
<dt>starships</dt><dd><p>List of starships the character has piloted</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>starwars
</code></pre>

<hr>
<h2 id='storms'>Storm tracks data</h2><span id='topic+storms'></span>

<h3>Description</h3>

<p>This dataset is the NOAA Atlantic hurricane database best track data,
<a href="https://www.nhc.noaa.gov/data/#hurdat">https://www.nhc.noaa.gov/data/#hurdat</a>. The data includes the positions and
attributes of storms from 1975-2022. Storms
from 1979 onward are measured every six hours during the lifetime of the
storm. Storms in earlier years have some missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storms
</code></pre>


<h3>Format</h3>

<p>A tibble with 19,537 observations
and 13 variables:
</p>

<dl>
<dt>name</dt><dd><p>Storm Name</p>
</dd>
<dt>year,month,day</dt><dd><p>Date of report</p>
</dd>
<dt>hour</dt><dd><p>Hour of report (in UTC)</p>
</dd>
<dt>lat,long</dt><dd><p>Location of storm center</p>
</dd>
<dt>status</dt><dd><p>Storm classification (Tropical Depression, Tropical Storm,
or Hurricane)</p>
</dd>
<dt>category</dt><dd><p>Saffir-Simpson hurricane category calculated from wind speed.
</p>

<ul>
<li> <p><code>NA</code>: Not a hurricane
</p>
</li>
<li><p> 1: 64+ knots
</p>
</li>
<li><p> 2: 83+ knots
</p>
</li>
<li><p> 3: 96+ knots
</p>
</li>
<li><p> 4: 113+ knots
</p>
</li>
<li><p> 5: 137+ knots
</p>
</li></ul>

</dd>
<dt>wind</dt><dd><p>storm's maximum sustained wind speed (in knots)</p>
</dd>
<dt>pressure</dt><dd><p>Air pressure at the storm's center (in millibars)</p>
</dd>
<dt>tropicalstorm_force_diameter</dt><dd><p>Diameter (in nautical miles) of the
area experiencing tropical storm strength winds (34 knots or above).
Only available starting in 2004.</p>
</dd>
<dt>hurricane_force_diameter</dt><dd><p>Diameter (in nautical miles) of the area
experiencing hurricane strength winds (64 knots or above). Only available
starting in 2004.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The script to create the storms data set:
<a href="https://github.com/tidyverse/dplyr/blob/main/data-raw/storms.R">https://github.com/tidyverse/dplyr/blob/main/data-raw/storms.R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>storms

# Show a few recent storm paths
if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2)
  storms %&gt;%
    filter(year &gt;= 2000) %&gt;%
    ggplot(aes(long, lat, color = paste(year, name))) +
    geom_path(show.legend = FALSE) +
    facet_wrap(~year)
}

storms
</code></pre>

<hr>
<h2 id='summarise'>Summarise each group down to one row</h2><span id='topic+summarise'></span><span id='topic+summarize'></span>

<h3>Description</h3>

<p><code>summarise()</code> creates a new data frame. It returns one row for each
combination of grouping variables; if there are no grouping variables, the
output will have a single row summarising all observations in the input. It
will contain one column for each grouping variable and one column for each of
the summary statistics that you have specified.
</p>
<p><code>summarise()</code> and <code>summarize()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise(.data, ..., .by = NULL, .groups = NULL)

summarize(.data, ..., .by = NULL, .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="summarise_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="summarise_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="summarise_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the
result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li>
<li><p> &quot;rowwise&quot;: Each row is its own group.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get &quot;drop_last&quot;.
</p>
</li>
<li><p> If the number of rows varies, you get &quot;keep&quot; (note that returning a
variable number of rows was deprecated in favor of <code><a href="dplyr.html#topic+reframe">reframe()</a></code>, which
also unconditionally drops all levels of grouping).
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <em>usually</em> of the same type as <code>.data</code>.
</p>

<ul>
<li><p> The rows come from the underlying <code><a href="dplyr.html#topic+group_keys">group_keys()</a></code>.
</p>
</li>
<li><p> The columns are a combination of the grouping keys and the summary
expressions that you provide.
</p>
</li>
<li><p> The grouping structure is controlled by the <code style="white-space: pre;">&#8288;.groups=&#8288;</code> argument, the
output may be another <a href="dplyr.html#topic+grouped_df">grouped_df</a>, a <a href="dplyr.html#topic+tibble">tibble</a> or a <a href="dplyr.html#topic+rowwise">rowwise</a> data frame.
</p>
</li>
<li><p> Data frame attributes are <strong>not</strong> preserved, because <code>summarise()</code>
fundamentally creates a new data frame.
</p>
</li></ul>



<h3>Useful functions</h3>


<ul>
<li><p> Center: <code><a href="base.html#topic+mean">mean()</a></code>, <code><a href="stats.html#topic+median">median()</a></code>
</p>
</li>
<li><p> Spread: <code><a href="stats.html#topic+sd">sd()</a></code>, <code><a href="stats.html#topic+IQR">IQR()</a></code>, <code><a href="stats.html#topic+mad">mad()</a></code>
</p>
</li>
<li><p> Range: <code><a href="base.html#topic+min">min()</a></code>, <code><a href="base.html#topic+max">max()</a></code>,
</p>
</li>
<li><p> Position: <code><a href="data.table.html#topic+first">first()</a></code>, <code><a href="data.table.html#topic+last">last()</a></code>, <code><a href="dplyr.html#topic+nth">nth()</a></code>,
</p>
</li>
<li><p> Count: <code><a href="dplyr.html#topic+n">n()</a></code>, <code><a href="dplyr.html#topic+n_distinct">n_distinct()</a></code>
</p>
</li>
<li><p> Logical: <code><a href="base.html#topic+any">any()</a></code>, <code><a href="base.html#topic+all">all()</a></code>
</p>
</li></ul>



<h3>Backend variations</h3>

<p>The data frame backend supports creating a variable and using it in the
same summary. This means that previously created summary variables can be
further transformed or combined within the summary, as in <code><a href="dplyr.html#topic+mutate">mutate()</a></code>.
However, it also means that summary variables with the same names as previous
variables overwrite them, making those variables unavailable to later summary
variables.
</p>
<p>This behaviour may not be supported in other backends. To avoid unexpected
results, consider using new names for your summary variables, especially when
creating multiple summaries.
</p>


<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>The following methods are currently available in loaded packages:
no methods found.
</p>


<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="dplyr.html#topic+arrange">arrange</a>()</code>,
<code><a href="stats.html#topic+filter">filter</a>()</code>,
<code><a href="dplyr.html#topic+mutate">mutate</a>()</code>,
<code><a href="dplyr.html#topic+reframe">reframe</a>()</code>,
<code><a href="dplyr.html#topic+rename">rename</a>()</code>,
<code><a href="MASS.html#topic+select">select</a>()</code>,
<code><a href="dplyr.html#topic+slice">slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A summary applied to ungrouped tbl returns a single row
mtcars %&gt;%
  summarise(mean = mean(disp), n = n())

# Usually, you'll want to group first
mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarise(mean = mean(disp), n = n())

# Each summary call removes one grouping level (since that group
# is now just a single row)
mtcars %&gt;%
  group_by(cyl, vs) %&gt;%
  summarise(cyl_n = n()) %&gt;%
  group_vars()

# BEWARE: reusing variables may lead to unexpected results
mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarise(disp = mean(disp), sd = sd(disp))

# Refer to column names stored as strings with the `.data` pronoun:
var &lt;- "mass"
summarise(starwars, avg = mean(.data[[var]], na.rm = TRUE))
# Learn more in ?rlang::args_data_masking

# In dplyr 1.1.0, returning multiple rows per group was deprecated in favor
# of `reframe()`, which never messages and always returns an ungrouped
# result:
mtcars %&gt;%
   group_by(cyl) %&gt;%
   summarise(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))
# -&gt;
mtcars %&gt;%
   group_by(cyl) %&gt;%
   reframe(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))
</code></pre>

<hr>
<h2 id='summarise_all'>Summarise multiple columns</h2><span id='topic+summarise_all'></span><span id='topic+summarise_if'></span><span id='topic+summarise_at'></span><span id='topic+summarize_all'></span><span id='topic+summarize_if'></span><span id='topic+summarize_at'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">&#8288;_if&#8288;</code>, <code style="white-space: pre;">&#8288;_at&#8288;</code>, <code style="white-space: pre;">&#8288;_all&#8288;</code>) have been superseded by the use of
<code><a href="dplyr.html#topic+pick">pick()</a></code> or <code><a href="dplyr.html#topic+across">across()</a></code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>The <a href="dplyr.html#topic+scoped">scoped</a> variants of <code><a href="dplyr.html#topic+summarise">summarise()</a></code> make it easy to apply the same
transformation to multiple variables.
There are three variants.
</p>

<ul>
<li> <p><code>summarise_all()</code> affects every variable
</p>
</li>
<li> <p><code>summarise_at()</code> affects variables selected with a character vector or
vars()
</p>
</li>
<li> <p><code>summarise_if()</code> affects variables selected with a predicate function
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>summarise_all(.tbl, .funs, ...)

summarise_if(.tbl, .predicate, .funs, ...)

summarise_at(.tbl, .vars, .funs, ..., .cols = NULL)

summarize_all(.tbl, .funs, ...)

summarize_if(.tbl, .predicate, .funs, ...)

summarize_at(.tbl, .vars, .funs, ..., .cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_all_+3A_.tbl">.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td></tr>
<tr><td><code id="summarise_all_+3A_.funs">.funs</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td></tr>
<tr><td><code id="summarise_all_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with <a href="rlang.html#topic+dyn-dots">tidy dots</a> support.</p>
</td></tr>
<tr><td><code id="summarise_all_+3A_.predicate">.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td></tr>
<tr><td><code id="summarise_all_+3A_.vars">.vars</code></td>
<td>
<p>A list of columns generated by <code><a href="dplyr.html#topic+vars">vars()</a></code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="summarise_all_+3A_.cols">.cols</code></td>
<td>
<p>This argument has been renamed to <code>.vars</code> to fit
dplyr's terminology and is deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. By default, the newly created columns have the shortest
names needed to uniquely identify the output. To force inclusion of a name,
even when not needed, name the input (see examples for details).
</p>


<h3>Grouping variables</h3>

<p>If applied on a grouped tibble, these operations are <em>not</em> applied
to the grouping variables. The behaviour depends on whether the
selection is <strong>implicit</strong> (<code>all</code> and <code>if</code> selections) or
<strong>explicit</strong> (<code>at</code> selections).
</p>

<ul>
<li><p> Grouping variables covered by explicit selections in
<code>summarise_at()</code> are always an error. Add <code>-group_cols()</code> to the
<code><a href="dplyr.html#topic+vars">vars()</a></code> selection to avoid this:
</p>
<div class="sourceCode"><pre>data %&gt;%
  summarise_at(vars(-group_cols(), ...), myoperation)
</pre></div>
<p>Or remove <code>group_vars()</code> from the character vector of column names:
</p>
<div class="sourceCode"><pre>nms &lt;- setdiff(nms, group_vars(data))
data %&gt;% summarise_at(nms, myoperation)
</pre></div>
</li>
<li><p> Grouping variables covered by implicit selections are silently
ignored by <code>summarise_all()</code> and <code>summarise_if()</code>.
</p>
</li></ul>



<h3>Naming</h3>

<p>The names of the new columns are derived from the names of the
input variables and the names of the functions.
</p>

<ul>
<li><p> if there is only one unnamed function (i.e. if <code>.funs</code> is an unnamed list
of length one),
the names of the input variables are used to name the new columns;
</p>
</li>
<li><p> for <code style="white-space: pre;">&#8288;_at&#8288;</code> functions, if there is only one unnamed variable (i.e.,
if <code>.vars</code> is of the form <code>vars(a_single_column)</code>) and <code>.funs</code> has length
greater than one,
the names of the functions are used to name the new columns;
</p>
</li>
<li><p> otherwise, the new names are created by
concatenating the names of the input variables and the names of the
functions, separated with an underscore <code>"_"</code>.
</p>
</li></ul>

<p>The <code>.funs</code> argument can be a named or unnamed list.
If a function is unnamed and the name cannot be derived automatically,
a name of the form &quot;fn#&quot; is used.
Similarly, <code><a href="dplyr.html#topic+vars">vars()</a></code> accepts named and unnamed arguments.
If a variable in <code>.vars</code> is named, a new column by that name will be created.
</p>
<p>Name collisions in the new columns are disambiguated using a unique suffix.
</p>


<h3>See Also</h3>

<p><a href="dplyr.html#topic+scoped">The other scoped verbs</a>, <code><a href="dplyr.html#topic+vars">vars()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The _at() variants directly support strings:
starwars %&gt;%
  summarise_at(c("height", "mass"), mean, na.rm = TRUE)
# -&gt;
starwars %&gt;% summarise(across(c("height", "mass"), ~ mean(.x, na.rm = TRUE)))

# You can also supply selection helpers to _at() functions but you have
# to quote them with vars():
starwars %&gt;%
  summarise_at(vars(height:mass), mean, na.rm = TRUE)
# -&gt;
starwars %&gt;%
  summarise(across(height:mass, ~ mean(.x, na.rm = TRUE)))

# The _if() variants apply a predicate function (a function that
# returns TRUE or FALSE) to determine the relevant subset of
# columns. Here we apply mean() to the numeric columns:
starwars %&gt;%
  summarise_if(is.numeric, mean, na.rm = TRUE)
starwars %&gt;%
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))

by_species &lt;- iris %&gt;%
  group_by(Species)

# If you want to apply multiple transformations, pass a list of
# functions. When there are multiple functions, they create new
# variables instead of modifying the variables in place:
by_species %&gt;%
  summarise_all(list(min, max))
# -&gt;
by_species %&gt;%
  summarise(across(everything(), list(min = min, max = max)))
</code></pre>

<hr>
<h2 id='summarise_each'>Summarise and mutate multiple columns.</h2><span id='topic+summarise_each'></span><span id='topic+summarise_each_'></span><span id='topic+mutate_each'></span><span id='topic+mutate_each_'></span><span id='topic+summarize_each'></span><span id='topic+summarize_each_'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>mutate_each()</code> and <code>summarise_each()</code> are deprecated in favour of
the new <code><a href="dplyr.html#topic+across">across()</a></code> function that works within <code>summarise()</code> and <code>mutate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_each(tbl, funs, ...)

summarise_each_(tbl, funs, vars)

mutate_each(tbl, funs, ...)

mutate_each_(tbl, funs, vars)

summarize_each(tbl, funs, ...)

summarize_each_(tbl, funs, vars)
</code></pre>

<hr>
<h2 id='tbl'>Create a table from a data source</h2><span id='topic+tbl'></span><span id='topic+is.tbl'></span>

<h3>Description</h3>

<p>This is a generic method that dispatches based on the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl(src, ...)

is.tbl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_+3A_src">src</code></td>
<td>
<p>A data source</p>
</td></tr>
<tr><td><code id="tbl_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to the individual methods</p>
</td></tr>
<tr><td><code id="tbl_+3A_x">x</code></td>
<td>
<p>Any object</p>
</td></tr>
</table>

<hr>
<h2 id='tbl_df'>Coerce to a tibble</h2><span id='topic+tbl_df'></span><span id='topic+as.tbl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Please use <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_df(data)

as.tbl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_df_+3A_data">data</code>, <code id="tbl_df_+3A_x">x</code></td>
<td>
<p>Object to coerce</p>
</td></tr>
</table>

<hr>
<h2 id='tbl_ptype'>Return a prototype of a tbl</h2><span id='topic+tbl_ptype'></span>

<h3>Description</h3>

<p>Used in <code style="white-space: pre;">&#8288;_if&#8288;</code> functions to enable type-based selection even when the data
is lazily generated. Should either return the complete tibble, or if that
can not be computed quickly, a 0-row tibble where the columns are of
the correct type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_ptype(.data)
</code></pre>

<hr>
<h2 id='tbl_vars'>List variables provided by a tbl.</h2><span id='topic+tbl_vars'></span><span id='topic+tbl_nongroup_vars'></span>

<h3>Description</h3>

<p><code>tbl_vars()</code> returns all variables while <code>tbl_nongroup_vars()</code>
returns only non-grouping variables. The <code>groups</code> attribute
of the object returned by <code>tbl_vars()</code> is a character vector of the
grouping columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_vars(x)

tbl_nongroup_vars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_vars_+3A_x">x</code></td>
<td>
<p>A tbl object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+group_vars">group_vars()</a></code> for a function that returns grouping
variables.
</p>

<hr>
<h2 id='tidyeval-compat'>Other tidy eval tools</h2><span id='topic+tidyeval-compat'></span><span id='topic+.data'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+as_label'></span><span id='topic+quo'></span><span id='topic+quos'></span><span id='topic+quo_name'></span><span id='topic+ensym'></span><span id='topic+ensyms'></span><span id='topic+enexpr'></span><span id='topic+enexprs'></span>

<h3>Description</h3>

<p>These tidy eval functions are no longer for normal usage, but are still
exported from dplyr for backward compatibility.
See <code><a href="rlang.html#topic+args_data_masking">?rlang::args_data_masking</a></code> and
<code>vignette("programming")</code> for the latest recommendations.
</p>

<ul>
<li> <p><a href="rlang.html#topic+expr">expr()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+enquo">enquo()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+enquo">enquos()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+sym">sym()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+sym">syms()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+as_label">as_label()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">quo()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">quos()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+quo_label">quo_name()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">ensym()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">ensyms()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">enexpr()</a>
</p>
</li>
<li> <p><a href="rlang.html#topic+defusing-advanced">enexprs()</a>
</p>
</li></ul>


<hr>
<h2 id='top_n'>Select top (or bottom) n rows (by value)</h2><span id='topic+top_n'></span><span id='topic+top_frac'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
<code>top_n()</code> has been superseded in favour of <code><a href="dplyr.html#topic+slice_min">slice_min()</a></code>/<code><a href="dplyr.html#topic+slice_max">slice_max()</a></code>.
While it will not be deprecated in the near future, retirement means
that we will only perform critical bug fixes, so we recommend moving to the
newer alternatives.
</p>
<p><code>top_n()</code> was superseded because the name was fundamentally confusing as
it returned what you might reasonably consider to be the <em>bottom</em>
rows. Additionally, the <code>wt</code> variable had a confusing name, and strange
default (the last column in the data frame). Unfortunately we could not
see an easy way to fix the existing <code>top_n()</code> function without breaking
existing code, so we created a new alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_n(x, n, wt)

top_frac(x, n, wt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_n_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="top_n_+3A_n">n</code></td>
<td>
<p>Number of rows to return for <code>top_n()</code>, fraction of rows to
return for <code>top_frac()</code>. If <code>n</code> is positive, selects the top rows.
If negative, selects the bottom rows.
If <code>x</code> is grouped, this is the number (or fraction) of rows per group.
Will include more rows if there are ties.</p>
</td></tr>
<tr><td><code id="top_n_+3A_wt">wt</code></td>
<td>
<p>(Optional). The variable to use for ordering. If not
specified, defaults to the last variable in the tbl.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c(6, 4, 1, 10, 3, 1, 1))

df %&gt;% top_n(2)  # highest values
df %&gt;% top_n(-2) # lowest values
# now use
df %&gt;% slice_max(x, n = 2)
df %&gt;% slice_min(x, n = 2)

# top_frac() -&gt; prop argument of slice_min()/slice_max()
df %&gt;% top_frac(.5)
# -&gt;
df %&gt;% slice_max(x, prop = 0.5)
</code></pre>

<hr>
<h2 id='transmute'>Create, modify, and delete columns</h2><span id='topic+transmute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>transmute()</code> creates a new data frame containing only the specified
computations. It's superseded because you can perform the same job
with <code>mutate(.keep = "none")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmute(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmute_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="transmute_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Columns created or modified through <code>...</code> will be returned in the order
specified by <code>...</code>.
</p>
</li>
<li><p> Unmodified grouping columns will be placed at the front.
</p>
</li>
<li><p> The number of rows is not affected.
</p>
</li>
<li><p> Columns given the value <code>NULL</code> will be removed.
</p>
</li>
<li><p> Groups will be recomputed if a grouping variable is mutated.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Methods</h3>

<p>This function is a <strong>generic</strong>, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.
</p>
<p>Methods available in currently loaded packages:
no methods found.
</p>

<hr>
<h2 id='vars'>Select variables</h2><span id='topic+vars'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p><code>vars()</code> is superseded because it is only needed for the scoped verbs (i.e.
<code><a href="dplyr.html#topic+mutate_at">mutate_at()</a></code>, <code><a href="dplyr.html#topic+summarise_at">summarise_at()</a></code>, and friends), which have been been
superseded in favour of <code><a href="dplyr.html#topic+across">across()</a></code>. See <code>vignette("colwise")</code> for details.
</p>
<p>This helper is intended to provide tidy-select semantics for scoped verbs
like <code>mutate_at()</code> and <code>summarise_at()</code>. Note that anywhere you can supply
<code>vars()</code> specification, you can also supply a numeric vector of column
positions or a character vector of column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Variables to operate on.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+all_vars">all_vars()</a></code> and <code><a href="dplyr.html#topic+any_vars">any_vars()</a></code> for other quoting
functions that you can use with scoped verbs.
</p>

<hr>
<h2 id='with_groups'>Perform an operation with temporary groups</h2><span id='topic+with_groups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>This was an experimental function that allows you to modify the grouping
variables for a single operation; it is superseded in favour of using the
<code>.by</code> argument to individual verbs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_groups(.data, .groups, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_groups_+3A_.data">.data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="with_groups_+3A_.groups">.groups</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; One or more variables
to group by. Unlike <code><a href="dplyr.html#topic+group_by">group_by()</a></code>, you can only group by existing variables,
and you can use tidy-select syntax like <code>c(x, y, z)</code> to select multiple
variables.
</p>
<p>Use <code>NULL</code> to temporarily <strong>un</strong>group.</p>
</td></tr>
<tr><td><code id="with_groups_+3A_.f">.f</code></td>
<td>
<p>Function to apply to regrouped data.
Supports purrr-style <code>~</code> syntax</p>
</td></tr>
<tr><td><code id="with_groups_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>...</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(g = c(1, 1, 2, 2, 3), x = runif(5))

# Old
df %&gt;%
  with_groups(g, mutate, x_mean = mean(x))
# New
df %&gt;% mutate(x_mean = mean(x), .by = g)
</code></pre>

<hr>
<h2 id='with_order'>Run a function with one order, translating result back to original order</h2><span id='topic+with_order'></span>

<h3>Description</h3>

<p>This is used to power the ordering parameters of dplyr's window functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_order(order_by, fun, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_order_+3A_order_by">order_by</code></td>
<td>
<p>vector to order by</p>
</td></tr>
<tr><td><code id="with_order_+3A_fun">fun</code></td>
<td>
<p>window function</p>
</td></tr>
<tr><td><code id="with_order_+3A_x">x</code>, <code id="with_order_+3A_...">...</code></td>
<td>
<p>arguments to <code>f</code></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
