<!DOCTYPE html><html><head><title>Help for package elliptic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {elliptic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#elliptic-package'>
<p>Weierstrass and Jacobi Elliptic Functions</p></a></li>
<li><a href='#amn'><p>matrix a on page 637</p></a></li>
<li><a href='#as.primitive'><p>Converts basic periods to a primitive pair</p></a></li>
<li><a href='#ck'><p>Coefficients of Laurent expansion of Weierstrass P function</p></a></li>
<li><a href='#congruence'><p>Solves mx+by=1 for x and y</p></a></li>
<li><a href='#coqueraux'><p>Fast, conceptually simple, iterative scheme for Weierstrass P</p>
functions</a></li>
<li><a href='#divisor'><p>Number theoretic functions</p></a></li>
<li><a href='#e16.28.1'><p>Numerical verification of equations 16.28.1 to 16.28.5</p></a></li>
<li><a href='#e18.10.9'><p>Numerical checks of equations 18.10.9-11, page 650</p></a></li>
<li><a href='#e1e2e3'><p>Calculate e1, e2, e3 from the invariants</p></a></li>
<li><a href='#equianharmonic'><p>Special cases of the Weierstrass elliptic function</p></a></li>
<li><a href='#eta'><p>Dedekind's eta function</p></a></li>
<li><a href='#farey'><p>Farey sequences</p></a></li>
<li><a href='#fpp'><p>Fundamental period parallelogram</p></a></li>
<li><a href='#g.fun'><p>Calculates the invariants g2 and g3</p></a></li>
<li><a href='#half.periods'><p>Calculates half periods in terms of e</p></a></li>
<li><a href='#J'><p>Various modular functions</p></a></li>
<li><a href='#K.fun'><p>quarter period K</p></a></li>
<li><a href='#latplot'><p>Plots a lattice of periods on the complex plane</p></a></li>
<li><a href='#lattice'><p>Lattice of complex numbers</p></a></li>
<li><a href='#limit'><p>Limit the magnitude of elements of a vector</p></a></li>
<li><a href='#massage'><p>Massages numbers near the real line to be real</p></a></li>
<li><a href='#misc'><p>Manipulate real or imaginary components of an object</p></a></li>
<li><a href='#mob'><p>Moebius transformations</p></a></li>
<li><a href='#myintegrate'><p>Complex integration</p></a></li>
<li><a href='#near.match'><p>Are two vectors close to one another?</p></a></li>
<li><a href='#newton_raphson'><p>Newton Raphson iteration to find roots of equations</p></a></li>
<li><a href='#nome'><p>Nome in terms of m or k</p></a></li>
<li><a href='#P.laurent'><p>Laurent series for elliptic and related functions</p></a></li>
<li><a href='#p1.tau'><p>Does the right thing when calling g2.fun() and g3.fun()</p></a></li>
<li><a href='#parameters'><p>Parameters for Weierstrass's P function</p></a></li>
<li><a href='#pari'><p>Wrappers for PARI functions</p></a></li>
<li><a href='#sn'><p>Jacobi form of the elliptic functions</p></a></li>
<li><a href='#sqrti'><p>Generalized square root</p></a></li>
<li><a href='#theta'><p>Jacobi theta functions 1-4</p></a></li>
<li><a href='#theta.neville'><p>Neville's form for the theta functions</p></a></li>
<li><a href='#theta1.dash.zero'><p>Derivative of theta1</p></a></li>
<li><a href='#theta1dash'><p>Derivatives of theta functions</p></a></li>
<li><a href='#unimodular'><p>Unimodular matrices</p></a></li>
<li><a href='#view'><p>Visualization of complex functions</p></a></li>
<li><a href='#WeierstrassP'><p>Weierstrass P and related functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4-0</td>
</tr>
<tr>
<td>Title:</td>
<td>Weierstrass and Jacobi Elliptic Functions</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>emulator, calibrator (&ge; 1.2-8)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pari/gp</td>
</tr>
<tr>
<td>Description:</td>
<td>
 A suite of elliptic and related functions including Weierstrass and
 Jacobi forms.  Also includes various tools for manipulating and
 visualizing complex functions.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/elliptic.git">https://github.com/RobinHankin/elliptic.git</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/elliptic/issues">https://github.com/RobinHankin/elliptic/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-14 00:30:29 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-14 06:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='elliptic-package'>
Weierstrass and Jacobi Elliptic Functions
</h2><span id='topic+elliptic-package'></span><span id='topic+elliptic'></span>

<h3>Description</h3>

<p>A suite of elliptic and related functions including Weierstrass and
Jacobi forms.  Also includes various tools for manipulating and
visualizing complex functions.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> elliptic</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Weierstrass and Jacobi Elliptic Functions</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> MASS</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> emulator, calibrator (&gt;= 1.2-8)</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> pari/gp</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> 
 A suite of elliptic and related functions including Weierstrass and
 Jacobi forms.  Also includes various tools for manipulating and
 visualizing complex functions.</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/elliptic.git</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/elliptic/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
Im&lt;-                    Manipulate real or imaginary components of an
                        object
J                       Various modular functions
K.fun                   quarter period K
P.laurent               Laurent series for elliptic and related
                        functions
WeierstrassP            Weierstrass P and related functions
amn                     matrix a on page 637
as.primitive            Converts basic periods to a primitive pair
ck                      Coefficients of Laurent expansion of
                        Weierstrass P function
congruence              Solves mx+by=1 for x and y
coqueraux               Fast, conceptually simple, iterative scheme for
                        Weierstrass P functions
divisor                 Number theoretic functions
e16.28.1                Numerical verification of equations 16.28.1 to
                        16.28.5
e18.10.9                Numerical checks of equations 18.10.9-11, page
                        650
e1e2e3                  Calculate e1, e2, e3 from the invariants
elliptic-package        Weierstrass and Jacobi Elliptic Functions
equianharmonic          Special cases of the Weierstrass elliptic
                        function
eta                     Dedekind's eta function
farey                   Farey sequences
fpp                     Fundamental period parallelogram
g.fun                   Calculates the invariants g2 and g3
half.periods            Calculates half periods in terms of e
latplot                 Plots a lattice of periods on the complex plane
lattice                 Lattice of complex numbers
limit                   Limit the magnitude of elements of a vector
massage                 Massages numbers near the real line to be real
mob                     Moebius transformations
myintegrate             Complex integration
near.match              Are two vectors close to one another?
newton_raphson          Newton Raphson iteration to find roots of
                        equations
nome                    Nome in terms of m or k
p1.tau                  Does the right thing when calling g2.fun() and
                        g3.fun()
parameters              Parameters for Weierstrass's P function
pari                    Wrappers for PARI functions
sn                      Jacobi form of the elliptic functions
sqrti                   Generalized square root
theta                   Jacobi theta functions 1-4
theta.neville           Neville's form for the theta functions
theta1.dash.zero        Derivative of theta1
theta1dash              Derivatives of theta functions
unimodular              Unimodular matrices
view                    Visualization of complex functions
</pre>
<p>The primary function in package <span class="pkg">elliptic</span> is <code>P()</code>: this
calculates the Weierstrass <code class="reqn">\wp</code> function, and may take named
arguments that specify either the invariants <code>g</code> or half
periods <code>Omega</code>.  The derivative is given by function <code>Pdash</code>
and the Weierstrass sigma and zeta functions are given by functions
<code>sigma()</code> and <code>zeta()</code> respectively; these are documented in
<code>?P</code>.  Jacobi forms are documented under <code>?sn</code> and modular
forms under <code>?J</code>.
</p>
<p>Notation follows Abramowitz and Stegun (1965) where possible, although
there only real invariants are considered; <code>?e1e2e3</code> and
<code>?parameters</code> give a more detailed discussion.  Various equations
from AMS-55 are implemented (for fun); the functions are named after
their equation numbers in AMS-55; all references are to this work unless
otherwise indicated.
</p>
<p>The package uses Jacobi's theta functions (<code>?theta</code> and
<code>?theta.neville</code>) where possible: they converge very quickly.
</p>
<p>Various number-theoretic functions that are required for (eg) converting
a period pair to primitive form (<code>?as.primitive</code>) are implemented;
see <code>?divisor</code> for a list.
</p>
<p>The package also provides some tools for numerical verification of
complex analysis such as contour integration (<code>?myintegrate</code>) and
Newton-Raphson iteration for complex functions
(<code>?newton_raphson</code>).
</p>
<p>Complex functions may be visualized using <code>view()</code>; this is
customizable but has an extensive set of built-in colourmaps.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li>
<p>R. K. S. Hankin.  <em>Introducing Elliptic, an R package for
Elliptic and Modular Functions</em>.  Journal of Statistical Software,
Volume 15, Issue 7.  February 2006.
</p>
</li>
<li>
<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of Mathematical
Functions.</em>  New York, Dover.
</p>
</li>
<li>
<p>K. Chandrasekharan 1985. <em>Elliptic functions</em>,  Springer-Verlag.
</p>
</li>
<li>
<p>E. T. Whittaker and G. N. Watson 1952.  <em>A Course of Modern
Analysis</em>, Cambridge University Press (fourth edition)
</p>
</li>
<li>
<p>G. H. Hardy and  E. M. Wright 1985.  <em>An introduction to the
theory of numbers</em>, Oxford University Press (fifth edition)
</p>
</li>
<li>
<p>S. D. Panteliou and A. D. Dimarogonas and I. N .Katz 1996.
<em>Direct and inverse interpolation for Jacobian elliptic
functions, zeta function of Jacobi and complete elliptic integrals
of the second kind</em>.  Computers and Mathematics with Applications,
volume 32, number 8, pp51-57
</p>
</li>
<li>
<p>E. L. Wachspress 2000.  <em>Evaluating Elliptic functions and their
inverses</em>.  Computers and Mathematics with Applications, volume 29,
pp131-136
</p>
</li>
<li>
<p>D. G. Vyridis and S. D. Panteliou and I. N. Katz 1999.  <em>An inverse
convergence approach for arguments of Jacobian elliptic functions</em>.
Computers and Mathematics with Applications, volume 37, pp21-26
</p>
</li>
<li>
<p>S. Paszkowski 1997.  <em>Fast convergent quasipower series for some
elementary and special functions</em>.   Computers and Mathematics with
Applications, volume 33, number 1/2, pp181-191
</p>
</li>
<li>
<p>B. Thaller 1998. <em>Visualization of complex functions</em>, The
Mathematica Journal, 7(2):163&ndash;180
</p>
</li>
<li>
<p>J. Kotus and M. Urb\'anski 2003.  <em>Hausdorff dimension and Hausdorff
measures of Julia sets of elliptic functions</em>.  Bulletin of the London
Mathematical Society, volume 35, pp269-275
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>     ## Example 8, p666, RHS:
 P(z=0.07 + 0.1i, g=c(10,2)) 

     ## Now a nice little plot of the zeta function:
 x &lt;- seq(from=-4,to=4,len=100)
 z &lt;- outer(x,1i*x,"+")
 par(pty="s")
 view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=3,scheme=1)
 view(x,x,P(z*3,params=equianharmonic()),real=FALSE)

     ## Some number theory:
 mobius(1:10)
 plot(divisor(1:300,k=1),type="s",xlab="n",ylab="divisor(n,1)")

    ## Primitive periods:
 as.primitive(c(3+4.01i , 7+10i))
 as.primitive(c(3+4.01i , 7+10i),n=10)   # Note difference

    ## Now some contour integration:
 f &lt;- function(z){1/z}
 u &lt;- function(x){exp(2i*pi*x)}
 udash &lt;- function(x){2i*pi*exp(2i*pi*x)}
 integrate.contour(f,u,udash) - 2*pi*1i


 x &lt;- seq(from=-10,to=10,len=200)
 z &lt;- outer(x,1i*x,"+")
 view(x,x,P(z,params=lemniscatic()),real=FALSE)
 view(x,x,P(z,params=pseudolemniscatic()),real=FALSE)
 view(x,x,P(z,params=equianharmonic()),real=FALSE)
</code></pre>

<hr>
<h2 id='amn'>matrix a on page 637</h2><span id='topic+amn'></span><span id='topic+18.5.7'></span><span id='topic+18.5.8'></span>

<h3>Description</h3>

<p>Matrix of coefficients of the Taylor series for
<code class="reqn">\sigma(z)</code> as described on page 636 and tabulated on page
637. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amn(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amn_+3A_u">u</code></td>
<td>
<p>Integer specifying size of output matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reproduces the coefficients <code class="reqn">a_{mn}</code> on page 637 according to
recurrence formulae 18.5.7 and 18.5.8, p636.  Used in equation
18.5.6. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>amn(12)   #page 637
</code></pre>

<hr>
<h2 id='as.primitive'>Converts basic periods to a primitive pair</h2><span id='topic+as.primitive'></span><span id='topic+is.primitive'></span>

<h3>Description</h3>

<p>Given a pair of basic periods, returns a primitive pair and (optionally)
the unimodular transformation used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.primitive(p, n = 3, tol = 1e-05, give.answers = FALSE)
is.primitive(p, n = 3, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.primitive_+3A_p">p</code></td>
<td>
<p>Two element vector containing the two basic periods</p>
</td></tr>
<tr><td><code id="as.primitive_+3A_n">n</code></td>
<td>
<p>Maximum magnitude of matrix entries considered</p>
</td></tr>
<tr><td><code id="as.primitive_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance used to determine reality of period ratios</p>
</td></tr>
<tr><td><code id="as.primitive_+3A_give.answers">give.answers</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return extra
information (unimodular matrix and the magnitudes of the primitive
periods) and default <code>FALSE</code> meaning to return just the
primitive periods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Primitive periods are not unique.  This function follows
Chandrasekharan and others (but not, of course, Abramowitz and Stegun)
in demanding that the real part of <code>p1</code>, and the
imaginary part of <code>p2</code>, are nonnegative.
</p>


<h3>Value</h3>

<p>If <code>give.answers</code> is <code>TRUE</code>, return a list with components
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>The unimodular matrix used</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The pair of primitive periods</p>
</td></tr>
<tr><td><code>mags</code></td>
<td>
<p>The magnitudes of the primitive periods</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Here, &ldquo;unimodular&rdquo; includes the case of determinant minus
one.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>K. Chandrasekharan 1985. <em>Elliptic functions</em>,  Springer-Verlag
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.primitive(c(3+5i,2+3i))
as.primitive(c(3+5i,2+3i),n=5)

##Rounding error:
is.primitive(c(1,1i))

## Try
 is.primitive(c(1,1.001i))

</code></pre>

<hr>
<h2 id='ck'>Coefficients of Laurent expansion of Weierstrass P function</h2><span id='topic+ck'></span><span id='topic+e18.5.2'></span><span id='topic+e18.5.3'></span><span id='topic+e18.5.16'></span>

<h3>Description</h3>

<p>Calculates the coefficients of the Laurent expansion of the
Weierstrass <code class="reqn">\wp</code> function in terms of the invariants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck(g, n=20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ck_+3A_g">g</code></td>
<td>
<p>The invariants: a vector of length two with <code>g=c(g2,g3)</code></p>
</td></tr>
<tr><td><code id="ck_+3A_n">n</code></td>
<td>
<p>length of series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the series <code class="reqn">c_k</code> as per equation 18.5.3, p635.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+P.laurent">P.laurent</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> #Verify 18.5.16, p636:
 x &lt;- ck(g=c(0.1+1.1i,4-0.63i))
14*x[2]*x[3]*(389*x[2]^3+369*x[3]^2)/3187041-x[11] #should be zero


# Now try a random example by comparing the default (theta function) method
# for P(z) with the Laurent expansion:

z &lt;- 0.5-0.3i
g &lt;- c(1.1-0.2i, 1+0.4i)
series &lt;- ck(15,g=g)
1/z^2+sum(series*(z^2)^(0:14)) - P(z,g=g) #should be zero
</code></pre>

<hr>
<h2 id='congruence'>Solves mx+by=1 for x and y</h2><span id='topic+congruence'></span>

<h3>Description</h3>

<p>Solves the Diophantine equation <code class="reqn">mx+by=1</code> for <code class="reqn">x</code>
and <code class="reqn">y</code>.  The function is named for equation 57 in Hardy and Wright.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruence(a, l = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruence_+3A_a">a</code></td>
<td>
<p>Two element vector with <code>a=c(m,n)</code></p>
</td></tr>
<tr><td><code id="congruence_+3A_l">l</code></td>
<td>
<p>Right hand side with default 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the usual case of <code class="reqn">(m,n)=1</code>, returns a square matrix
whose rows are <code>a</code> and <code>c(x,y)</code>.  This matrix is a unimodular
transformation that takes a pair of basic periods to another pair of
basic periods.
</p>
<p>If <code class="reqn">(m,n)\neq 1</code> then more than one solution is
available (for example <code>congruence(c(4,6),2)</code>).  In this case, extra rows
are added and the matrix is no longer square.
</p>


<h3>Note</h3>

<p>This function does not generate <em>all</em> unimodular matrices with a
given first row (here, it will be assumed that the function returns a
square matrix).
</p>
<p>For a start, this function only returns matrices all of whose
elements are positive, and if <code>a</code> is unimodular, then after
<code>diag(a) &lt;- -diag(a)</code>, both <code>a</code> and <code>-a</code> are
unimodular (so if <code>a</code> was originally generated by
<code>congruence()</code>, neither of the derived matrices could be).
</p>
<p>Now if the first row is <code>c(1,23)</code>, for example, then the second
row need only be of the form <code>c(n,1)</code> where <code>n</code> is any
integer.  There are thus an infinite number of unimodular matrices
whose first row is <code>c(1,23)</code>.  While this is (somewhat)
pathological, consider matrices with a first row of, say,
<code>c(2,5)</code>.  Then the second row could be <code>c(1,3)</code>, or
<code>c(3,8)</code> or <code>c(5,13)</code>.  Function <code>congruence()</code> will
return only the first of these.
</p>
<p>To systematically generate all unimodular matrices, use
<code>unimodular()</code>, which uses Farey sequences.    
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>G. H. Hardy and  E. M. Wright 1985.  <em>An introduction to the
theory of numbers</em>, Oxford University Press (fifth edition)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unimodular">unimodular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- congruence(c(4,9))
det(M)

o &lt;- c(1,1i)
g2.fun(o) - g2.fun(o,maxiter=840)  #should be zero

</code></pre>

<hr>
<h2 id='coqueraux'>Fast, conceptually simple, iterative scheme for Weierstrass P
functions</h2><span id='topic+coqueraux'></span>

<h3>Description</h3>

<p>Fast, conceptually simple, iterative scheme for Weierstrass
<code class="reqn">\wp</code> functions, following the ideas of Robert Coqueraux
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coqueraux(z, g, N = 5, use.fpp = FALSE, give = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coqueraux_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="coqueraux_+3A_g">g</code></td>
<td>
<p>Invariants; if an object of type <code>parameters</code> is supplied,
the invariants will be extracted appropriately</p>
</td></tr>
<tr><td><code id="coqueraux_+3A_n">N</code></td>
<td>
<p>Number of iterations to use</p>
</td></tr>
<tr><td><code id="coqueraux_+3A_use.fpp">use.fpp</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to <em>not</em>
reduce <code>z</code> to the fpp.  Setting to <code>TRUE</code> reduces
<code>z</code> to the fpp via <code>parameters()</code>: this is more
accurate (see example) but slower</p>
</td></tr>
<tr><td><code id="coqueraux_+3A_give">give</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return an estimate of
the error, and <code>FALSE</code> meaning to return just the value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>R. Coqueraux, 1990.  <em>Iterative method for calculation of the
Weierstrass elliptic function</em>, IMA Journal of Numerical Analysis,
volume 10, pp119-128
</p>


<h3>Examples</h3>

<pre><code class='language-R'> z &lt;- seq(from=1+1i,to=30-10i,len=55)
 p &lt;- P(z,c(0,1))
 c.true &lt;- coqueraux(z,c(0,1),use.fpp=TRUE)
 c.false &lt;- coqueraux(z,c(0,1),use.fpp=FALSE)
 plot(1:55,abs(p-c.false))
 points(1:55,abs(p-c.true),pch=16)
 
</code></pre>

<hr>
<h2 id='divisor'>Number theoretic functions</h2><span id='topic+divisor'></span><span id='topic+primes'></span><span id='topic+factorize'></span><span id='topic+mobius'></span><span id='topic+totient'></span><span id='topic+liouville'></span>

<h3>Description</h3>

<p>Various useful number theoretic functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisor(n,k=1)
primes(n)
factorize(n)
mobius(n)
totient(n)
liouville(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisor_+3A_n">n</code>, <code id="divisor_+3A_k">k</code></td>
<td>
<p>Integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>primes()</code> and <code>factorize()</code> cut-and-pasted from
Bill Venables's conf.design package, version 0.0-3.  Function
<code>primes(n)</code> returns a vector of all primes not exceeding
<code>n</code>; function <code>factorize(n)</code> returns an integer vector of
nondecreasing primes whose product is <code>n</code>.
</p>
<p>The others are multiplicative functions, defined in Hardy and
Wright:
</p>
<p>Function <code>divisor()</code>, also written
<code class="reqn">\sigma_k(n)</code>, is the divisor function defined on
p239.  This gives the sum of the <code class="reqn">k^{\rm th}</code> powers of all
the divisors of <code>n</code>.  Setting <code class="reqn">k=0</code> corresponds to
<code class="reqn">d(n)</code>, which gives the number of divisors of <code>n</code>. 
</p>
<p>Function <code>mobius()</code> is the Moebius function (p234), giving zero
if <code>n</code> has a repeated prime factor, and <code class="reqn">(-1)^q</code> where
<code class="reqn">n=p_1p_2\ldots p_q</code> otherwise.
</p>
<p>Function <code>totient()</code> is Euler's totient function (p52), giving
the number of integers smaller than <code>n</code> and relatively prime to
it.
</p>
<p>Function <code>liouville()</code> gives the Liouville function.
</p>


<h3>Note</h3>

<p>The divisor function crops up in <code>g2.fun()</code> and <code>g3.fun()</code>.
Note that this function is not called <code>sigma()</code> to
avoid conflicts with Weierstrass's <code class="reqn">\sigma</code> function (which
ought to take priority in this context).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin and Bill Venables (<code>primes()</code> and
<code>factorize()</code>)</p>


<h3>References</h3>

<p>G. H. Hardy and E. M. Wright, 1985.  <em>An
introduction to the theory of numbers</em> (fifth edition).
Oxford University Press.</p>


<h3>Examples</h3>

<pre><code class='language-R'>mobius(1)
mobius(2)
divisor(140)
divisor(140,3)


plot(divisor(1:100,k=1),type="s",xlab="n",ylab="divisor(n,1)")

plot(cumsum(liouville(1:1000)),type="l",main="does the function ever exceed zero?")
</code></pre>

<hr>
<h2 id='e16.28.1'>Numerical verification of equations 16.28.1 to 16.28.5</h2><span id='topic+e16.28.1'></span><span id='topic+e16.28.2'></span><span id='topic+e16.28.3'></span><span id='topic+e16.28.4'></span><span id='topic+e16.28.5'></span>

<h3>Description</h3>

<p>Numerical verification of formulae 16.28.1 to 16.28.5 on p576
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e16.28.1(z, m, ...)
e16.28.2(z, m, ...)
e16.28.3(z, m, ...)
e16.28.4(z, m, ...)
e16.28.5(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e16.28.1_+3A_z">z</code></td>
<td>
<p>Complex number</p>
</td></tr>
<tr><td><code id="e16.28.1_+3A_m">m</code></td>
<td>
<p>Parameter <code class="reqn">m</code></p>
</td></tr>
<tr><td><code id="e16.28.1_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>theta[1-4]()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the left hand side minus the right hand side of each formula.
Each formula documented here is identically zero; nonzero values
are returned due to numerical errors and should be small.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of Mathematical
Functions.</em>  New York, Dover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(e16.28.4(z=1:6000,m=0.234))
 plot(abs(e16.28.4(z=1:6000,m=0.234+0.1i)))
</code></pre>

<hr>
<h2 id='e18.10.9'>Numerical checks of equations 18.10.9-11, page 650</h2><span id='topic+e18.10.9'></span><span id='topic+e18.10.9a'></span><span id='topic+e18.10.9b'></span><span id='topic+e18.10.10'></span><span id='topic+e18.10.10a'></span><span id='topic+e18.10.10b'></span><span id='topic+e18.10.11'></span><span id='topic+e18.10.11a'></span><span id='topic+e18.10.11b'></span><span id='topic+e18.10.12'></span><span id='topic+e18.10.12a'></span><span id='topic+e18.10.12b'></span>

<h3>Description</h3>

<p>Numerical checks of equations 18.10.9-11, page 650.  Function returns
LHS minus RHS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e18.10.9(parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e18.10.9_+3A_parameters">parameters</code></td>
<td>
<p>An object of class &ldquo;parameters&rdquo;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a complex vector of length three: <code class="reqn">e_1</code>,
<code class="reqn">e_2</code>, <code class="reqn">e_3</code>
</p>


<h3>Note</h3>

<p>A good check for the three <code class="reqn">e</code>'s being in the right order.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of Mathematical
Functions.</em>  New York, Dover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e18.10.9(parameters(g=c(0,1)))
e18.10.9(parameters(g=c(1,0)))
</code></pre>

<hr>
<h2 id='e1e2e3'>Calculate e1, e2, e3 from the invariants</h2><span id='topic+e1e2e3'></span><span id='topic+eee.cardano'></span><span id='topic+e18.3.1'></span><span id='topic+e18.3.7'></span><span id='topic+e18.3.8'></span>

<h3>Description</h3>

<p>Calculates <code class="reqn">e_1,e_2,e_3</code> from the invariants using
either <code>polyroot</code> or Cardano's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1e2e3(g, use.laurent=TRUE, AnS=is.double(g), Omega=NULL, tol=1e-6)
eee.cardano(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e1e2e3_+3A_g">g</code></td>
<td>
<p>Two-element vector with <code>g=c(g2,g3)</code></p>
</td></tr>
<tr><td><code id="e1e2e3_+3A_use.laurent">use.laurent</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning
to use <code>P.laurent()</code> to determine the correct ordering for the
<code class="reqn">e</code>: <code class="reqn">\wp(\omega_1)</code>, <code class="reqn">\wp(\omega_2)</code>,
<code class="reqn">\wp(\omega_3)</code>.  Setting to  <code>FALSE</code> means to
return the solutions of the cubic equation directly: this is much
faster, but is not guaranteed to find the <code class="reqn">e_i</code> in the
right order (the roots are found according to the vagaries of
<code>polyroot()</code>)</p>
</td></tr>
<tr><td><code id="e1e2e3_+3A_ans">AnS</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to define
<code class="reqn">\omega_3</code> as per ams-55, and <code>FALSE</code> meaning to
follow Whittaker and Watson, and define
<code class="reqn">\omega_1</code> and <code class="reqn">\omega_2</code> as the
primitive half periods, and
<code class="reqn">\omega_3=-\omega_1-\omega_2</code>.  This is
also consistent with Chandrasekharan except the factor of 2.
</p>
<p>Also note that setting <code>AnS</code> to <code>TRUE</code> forces the
<code class="reqn">e</code> to be real</p>
</td></tr>
<tr><td><code id="e1e2e3_+3A_omega">Omega</code></td>
<td>
<p>A pair of primitive half periods, if known.  If supplied, the
function uses them to calculate approximate values for the three
<code class="reqn">e</code>s (but supplies values calculated by <code>polyroot()</code>,
which are much more accurate).  The function needs the approximate
values to determine in which order the <code class="reqn">e</code>s should be, as
<code>polyroot()</code> returns roots in whichever order the polynomial
solver gives them in</p>
</td></tr>
<tr><td><code id="e1e2e3_+3A_tol">tol</code></td>
<td>
<p>Real, relative tolerance criterion for terminating Laurent
summation</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a three-element vector.
</p>


<h3>Note</h3>

<p>Function <code>parameters()</code> calls <code>e1e2e3()</code>, so <strong>do not
use <code>parameters()</code> to determine argument <code>g</code>, because
doing so will result in a recursive loop.</strong>
</p>
<p>Just to be specific: <code>e1e2e3(g=parameters(...))</code> will fail.  It
would be pointless anyway, because <code>parameters()</code> returns
(inter alia) <code class="reqn">e_1, e_2, e_3</code>.
</p>
<p>There is considerable confusion about the order of <code class="reqn">e_1</code>,
<code class="reqn">e_2</code> and <code class="reqn">e_3</code>, essentially due to Abramowitz and
Stegun's definition of the half periods being inconsistent with that
of Chandrasekharan's, and Mathematica's.  It is not possible to
reconcile A and S's notation for theta functions with
Chandrasekharan's definition of a primitive pair.  Thus,
the convention adopted here is the rather strange-seeming choice of
<code class="reqn">e_1=\wp(\omega_1/2)</code>,
<code class="reqn">e_2=\wp(\omega_3/2)</code>,
<code class="reqn">e_3=\wp(\omega_2/2)</code>.  This has the advantage
of making equation 18.10.5 (p650, ams55), and equation
09.13.27.0011.01, return three identical values.
</p>
<p>The other scheme to rescue 18.10.5 would be to define
<code class="reqn">(\omega_1,\omega_3)</code> as a primitive pair, and
to require
<code class="reqn">\omega_2=-\omega_1-\omega_3</code>.  This is
the method adopted by Mathematica; it is no more inconsistent with
ams55 than the solution used in package <span class="pkg">elliptic</span>.  However,
this scheme suffers from the
disadvantage that the independent elements of <code>Omega</code> would
have to be supplied as <code>c(omega1,NA,omega3)</code>, and this is
inimical to the precepts of R.
</p>
<p>One can realize the above in practice by
considering what this package calls
&ldquo;<code class="reqn">\omega_2</code>&rdquo; to be <em>really</em>
<code class="reqn">\omega_3</code>, and what this package calls
&ldquo;<code class="reqn">\omega_1+\omega_2</code>&rdquo; to be
<em>really</em> <code class="reqn">\omega_2</code>.  Making function
<code>half.periods()</code> return a three element vector with names
<code>omega1</code>, <code>omega3</code>, <code>omega2</code> might work on some
levels, and indeed might be the correct solution for a user
somewhere; but it would be confusing.  This confusion would
dog my weary steps for ever more.    
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Mathematica</p>


<h3>Examples</h3>

<pre><code class='language-R'> sum(e1e2e3(g=c(1,2)))
</code></pre>

<hr>
<h2 id='equianharmonic'>Special cases of the Weierstrass elliptic function</h2><span id='topic+equianharmonic'></span><span id='topic+lemniscatic'></span><span id='topic+pseudolemniscatic'></span>

<h3>Description</h3>

<p>Gives parameters for the equianharmonic case, the lemniscatic case, and
the pseudolemniscatic case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equianharmonic(...)
lemniscatic(...)
pseudolemniscatic(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equianharmonic_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return values from section 18.13, p652; 18.14, p658;
and 18.15, p662.  They use elementary functions (and the gamma
function) only, so ought to be more accurate and faster than calling
<code>parameters(g=c(1,0))</code> directly.
</p>
<p>Note that the values for the half periods correspond to the general
case for complex <code>g2</code> and <code>g3</code> so are simple linear
combinations of those given in AnS.
</p>
<p>One can use <code>parameters("equianharmonic")</code> <em>et seq</em> instead.
</p>


<h3>Value</h3>

<p>Returns a list with the same elements as <code>parameters()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of Mathematical
Functions.</em>  New York, Dover.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parameters">parameters</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>P(z=0.1+0.1212i,params=equianharmonic())


x &lt;- seq(from=-10,to=10,len=200)
z &lt;- outer(x,1i*x,"+")
view(x,x,P(z,params=lemniscatic()),real=FALSE)
view(x,x,P(z,params=pseudolemniscatic()),real=FALSE)
view(x,x,P(z,params=equianharmonic()),real=FALSE)

</code></pre>

<hr>
<h2 id='eta'>Dedekind's eta function</h2><span id='topic+eta'></span><span id='topic+eta.series'></span>

<h3>Description</h3>

<p>  Dedekind's <code class="reqn">\eta</code> function  </p>


<h3>Usage</h3>

<pre><code class='language-R'>eta(z, ...)
eta.series(z, maxiter=300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eta_+3A_z">z</code></td>
<td>
<p>Complex argument</p>
</td></tr>
<tr><td><code id="eta_+3A_...">...</code></td>
<td>
<p>In function <code>eta()</code>, extra arguments sent to
<code>theta3()</code></p>
</td></tr>
<tr><td><code id="eta_+3A_maxiter">maxiter</code></td>
<td>
<p>In function <code>eta.series()</code>, maximum value of
iteration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>eta()</code> uses Euler's formula, viz
</p>
<p style="text-align: center;"><code class="reqn">\eta(z)=e^{\pi
      iz/12}\theta_3\left(\frac{1}{2}+\frac{z}{2},3z\right)</code>
</p>

<p>Function <code>eta.series()</code> is present for validation (and interest)
only; it uses the infinite product formula:
</p>
<p style="text-align: center;"><code class="reqn">\eta(z)=
    e^{\pi iz/12}\prod_{n=1}^\infty\left(1-e^{2\pi inz}\right)</code>
</p>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>K. Chandrasekharan 1985. <em>Elliptic functions</em>,  Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+farey">farey</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> z &lt;- seq(from=1+1i,to=10+0.06i,len=999)
 plot(eta(z))

max(abs(eta(z)-eta.series(z)))
</code></pre>

<hr>
<h2 id='farey'>Farey sequences</h2><span id='topic+farey'></span>

<h3>Description</h3>

<p>Returns the Farey sequence of order <code class="reqn">n</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>farey(n, print=FALSE, give.series = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="farey_+3A_n">n</code></td>
<td>
<p>Order of Farey sequence</p>
</td></tr>
<tr><td><code id="farey_+3A_print">print</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to print out the text
version of the Farey sequence in human-readable form.  Default value
of <code>FALSE</code> means not to print anything</p>
</td></tr>
<tr><td><code id="farey_+3A_give.series">give.series</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return the
series explicitly, and default <code>FALSE</code> meaning to return a 3
dimensional array as detailed below</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>If <code>give.series</code> takes its default value of <code>FALSE</code>, return
a matrix <code>a</code> of dimension <code>c(2,u)</code> where <code>u</code> is a
(complicated) function of <code>n</code>.  If <code>v &lt;- a[i,]</code>, then
<code>v[1]/v[2]</code> is the <code class="reqn">i^{\mathrm{th}}</code> term of the Farey
sequence.  Note that <code>det(a[(n):(n+1),])== -1</code> 
</p>
<p>If <code>give.series</code> is <code>TRUE</code>, then return a matrix <code>a</code> of
size <code>c(4,u-1)</code>.  If <code>v &lt;- a[i,]</code>, then <code>v[1]/v[2]</code> and
<code>v[3]/v[4]</code> are successive pairs of the Farey sequence.  Note
that <code>det(matrix(a[,i],2,2))== -1</code>  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>G. H. Hardy and  E. M. Wright 1985.  <em>An introduction to the
theory of numbers</em>, Oxford University Press (fifth edition)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unimodular">unimodular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>farey(3)
</code></pre>

<hr>
<h2 id='fpp'>Fundamental period parallelogram</h2><span id='topic+fpp'></span><span id='topic+mn'></span>

<h3>Description</h3>

<p>Reduce <code class="reqn">z=x+iy</code> to a congruent value within the
fundamental period parallelogram (FPP).  Function <code>mn()</code> gives
(real, possibly noninteger) <code class="reqn">m</code> and <code class="reqn">n</code> such that
<code class="reqn">z=m\cdot p_1+n\cdot p_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpp(z, p, give=FALSE)
mn(z, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpp_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="fpp_+3A_p">p</code></td>
<td>
<p>Vector of length two with first element the first period and
second element the second period.  Note that <code class="reqn">p</code> is the
period, so <code class="reqn">p_1=2\omega_1</code>, where <code class="reqn">\omega_1</code> is the
half period</p>
</td></tr>
<tr><td><code id="fpp_+3A_give">give</code></td>
<td>
<p>Boolean, with  <code>TRUE</code> meaning to return M and N, and
default <code>FALSE</code> meaning to return just the congruent values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>fpp()</code> is fully vectorized.
</p>
<p>Use function <code>mn()</code> to determine the &ldquo;coordinates&rdquo; of a
point.
</p>
<p>Use <code>floor(mn(z,p)) %*% p </code> to give the  complex value of
the (unique) point in the same period parallelogram as <code>z</code> that
is congruent to the origin.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(1.01+1.123i, 1.1+1.43i)
mn(z=1:10,p) %*% p  ## should be close to 1:10

 #Now specify some periods:
 p2 &lt;- c(1+1i,1-1i)

 #Define a sequence of complex numbers that zooms off to infinity:
 u &lt;- seq(from=0,by=pi+1i*exp(1),len=2007)

 #and plot the sequence, modulo the periods:
 plot(fpp(z=u,p=p2))

 #and check that the resulting points are within the qpp:
polygon(c(-1,0,1,0),c(0,1,0,-1))
 

</code></pre>

<hr>
<h2 id='g.fun'>Calculates the invariants g2 and g3</h2><span id='topic+g.fun'></span><span id='topic+g2.fun'></span><span id='topic+g3.fun'></span><span id='topic+g2.fun.lambert'></span><span id='topic+g3.fun.lambert'></span><span id='topic+g2.fun.direct'></span><span id='topic+g3.fun.direct'></span><span id='topic+g2.fun.fixed'></span><span id='topic+g3.fun.fixed'></span><span id='topic+g2.fun.divisor'></span><span id='topic+g3.fun.divisor'></span><span id='topic+g2.fun.vectorized'></span><span id='topic+g3.fun.vectorized'></span><span id='topic+e18.1.1'></span>

<h3>Description</h3>

<p>Calculates the invariants g2 and g3 using any of a number of methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.fun(b, ...)
g2.fun(b, use.first=TRUE, ...)
g3.fun(b, use.first=TRUE, ...)
g2.fun.lambert(b, nmax=50, tol=1e-10, strict=TRUE)
g3.fun.lambert(b, nmax=50, tol=1e-10, strict=TRUE)
g2.fun.direct(b, nmax=50, tol=1e-10)
g3.fun.direct(b, nmax=50, tol=1e-10)
g2.fun.fixed(b, nmax=50, tol=1e-10, give=FALSE)
g3.fun.fixed(b, nmax=50, tol=1e-10, give=FALSE)
g2.fun.vectorized(b, nmax=50, tol=1e-10, give=FALSE)
g3.fun.vectorized(b, nmax=50, tol=1e-10, give=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.fun_+3A_b">b</code></td>
<td>
<p>Half periods.  NB: the arguments
are the <strong>half periods</strong> as per AMS55!
In these functions, argument <code>b</code> is interpreted as per
<code>p1.tau()</code></p>
</td></tr>
<tr><td><code id="g.fun_+3A_nmax">nmax</code></td>
<td>
<p>Maximum number of terms to sum.  See details section for
more discussion</p>
</td></tr>
<tr><td><code id="g.fun_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance for stopping: summation stops when adding
an additional term makes less</p>
</td></tr>
<tr><td><code id="g.fun_+3A_strict">strict</code></td>
<td>
<p>Boolean, with default (where taken) <code>TRUE</code> meaning to
<code>stop()</code> if convergence is not achieved in <code>nmax</code> terms.
Setting to <code>FALSE</code> returns the partial sum and a warning.</p>
</td></tr>
<tr><td><code id="g.fun_+3A_give">give</code></td>
<td>
<p>Boolean, with default (where taken) <code>TRUE</code> meaning to
return the partial sums.  See examples section for an example of this
argument in use</p>
</td></tr>
<tr><td><code id="g.fun_+3A_...">...</code></td>
<td>
<p>In functions <code>g.fun()</code>, <code>g2.fun()</code> and
<code>g3.fun()</code>, extra arguments passed to <code>theta1()</code> and friends</p>
</td></tr>
<tr><td><code id="g.fun_+3A_use.first">use.first</code></td>
<td>
<p>In function <code>g2.fun()</code> and <code>g3.fun()</code>,
Boolean with default <code>TRUE</code> meaning to use Wolfram's first formula
(<strong>remember to cite this</strong>) and <code>FALSE</code> meaning to use the second</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>g2.fun()</code> and <code>g3.fun()</code> use theta functions
which converge very quickly.  These functions are the best in most
circumstances.  The theta functions include a loop that continues to add
terms until the partial sum is unaltered by addition
of the next term.  Note that summation continues until <em>all</em>
elements of the argument are properly summed, so performance is
limited by the single worst-case element.
</p>
<p>The following functions are provided for interest only, although there
is a remote possibility that some weird circumstances may exist in which
they are faster than the theta function approach.  
</p>
<p>Functions <code>g2.fun.divisor()</code> and <code>g3.fun.divisor()</code> use
Chandrasekharan's formula on page 83.  This is generally slower than
the theta function approach
</p>
<p>Functions <code>g2.fun.lambert()</code> and <code>g3.fun.lambert()</code> use a 
Lambert series to accelerate Chandrasekharan's formula.  In general,
it is a little better than the divisor form.
</p>
<p>Functions <code>g2.fun.fixed()</code> and <code>g2.fun.fixed()</code> also use
Lambert series.  These functions are vectorized in the sense that
the function body uses only vector operations.  These functions do
not take a vector argument.  They are called &ldquo;fixed&rdquo; because
the number of terms used is fixed in advance (unlike <code>g2.fun()</code>
and <code>g3.fun()</code>).
</p>
<p>Functions <code>g2.fun.vectorized()</code> and <code>g3.fun.vectorized()</code>
also use Lambert series.  They are fully vectorized in that they take
a vector of periods or period ratios, unlike the previous two
functions.  However, this can lead to loss of precision in some
cases (specifically when the periods give rise to widely varying
values of g2 and g3).
</p>
<p>Functions <code>g2.fun.direct()</code> and <code>g3.fun.direct()</code> use a
direct summation.  These functions are absurdly slow.  In general,
the Lambert series functions converge much faster; and the
&ldquo;default&rdquo; functions <code>g2.fun()</code> and <code>g3.fun()</code>,
which use theta functions, converge faster still.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Mathematica website
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g.fun(half.periods(g=c(8,4+1i)))  ## should be c(8,4+1i)


## Example 4, p664, LHS:
omega &lt;- c(10,11i)
(g2 &lt;- g2.fun(omega))
(g3 &lt;- g3.fun(omega))
e1e2e3(Re(c(g2,g3)))

## Example 4, p664, RHS:
omega2 &lt;- 10
omega2dash &lt;- 11i
omega1 &lt;- (omega2-omega2dash)/2   ## From figure 18.1, p630
(g2 &lt;- g2.fun(c(omega1,omega2)))
(g3 &lt;- g3.fun(c(omega1,omega2)))
e1e2e3(Re(c(g2,g3)))
</code></pre>

<hr>
<h2 id='half.periods'>Calculates half periods in terms of e</h2><span id='topic+half.periods'></span>

<h3>Description</h3>

<p>Calculates half periods in terms of <code class="reqn">e</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>half.periods(ignore=NULL, e=NULL, g=NULL, primitive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="half.periods_+3A_e">e</code></td>
<td>
<p>e</p>
</td></tr>
<tr><td><code id="half.periods_+3A_g">g</code></td>
<td>
<p>g</p>
</td></tr>
<tr><td><code id="half.periods_+3A_ignore">ignore</code></td>
<td>
<p>Formal argument present to ensure that <code>e</code> or
<code>g</code> is named (ignored)</p>
</td></tr>
<tr><td><code id="half.periods_+3A_primitive">primitive</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return
primitive periods and <code>FALSE</code> to return the direct result of
Legendre's iterative scheme</p>
</td></tr>
</table>


<h3>Details</h3>

    
<p>Parameter <code>e=c(e1,e2,e3)</code> are the values of the Weierstrass
<code class="reqn">\wp</code> function at the half periods:
</p>
<p style="text-align: center;"><code class="reqn">e_1=\wp(\omega_1)\qquad e_2=\wp(\omega_2)\qquad e_3=
  \wp(\omega_3)</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">\omega_1+\omega_2+\omega_3=0.</code>
</p>

<p>Also, <code class="reqn">e</code> is given by the roots of the cubic
equation <code class="reqn">x^3-g_2x-g_3=0</code>, but the problem is
finding which root corresponds to which of the three elements of
<code class="reqn">e</code>.
</p>


<h3>Value</h3>

<p>Returns a pair of primitive half periods
</p>


<h3>Note</h3>

<p>Function <code>parameters()</code> uses function <code>half.periods()</code>
internally, so do not use <code>parameters()</code> 
to determine <code>e</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of Mathematical
Functions.</em>  New York, Dover.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
half.periods(g=c(8,4))                ## Example 6, p665, LHS

u &lt;- half.periods(g=c(-10,2))
massage(c(u[1]-u[2] , u[1]+u[2]))     ## Example 6, p665, RHS

half.periods(g=c(10,2))               ## Example 7, p665, LHS

u &lt;- half.periods(g=c(7,6))
massage(c(u[1],2*u[2]+u[1]))          ## Example 7, p665, RHS


half.periods(g=c(1,1i, 1.1+1.4i))
half.periods(e=c(1,1i, 2, 1.1+1.4i))


g.fun(half.periods(g=c(8,4)))         ##  should be c(8,4)


</code></pre>

<hr>
<h2 id='J'>Various modular functions</h2><span id='topic+J'></span><span id='topic+lambda'></span>

<h3>Description</h3>

<p>Modular functions including Klein's modular function J (aka Dedekind's
Valenz function J, aka the Klein invariant function, aka Klein's
absolute invariant), the lambda function, and Delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J(tau, use.theta = TRUE, ...)
lambda(tau, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code>; it is assumed that <code>Im(tau)&gt;0</code></p>
</td></tr>
<tr><td><code id="J_+3A_use.theta">use.theta</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to use the
theta function expansion, and <code>FALSE</code> meaning to evaluate
<code>g2</code> and <code>g3</code> directly</p>
</td></tr>
<tr><td><code id="J_+3A_...">...</code></td>
<td>
<p>Extra arguments sent to either <code>theta1()</code> et seq, or
<code>g2.fun()</code> and <code>g3.fun()</code> as appropriate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>K. Chandrasekharan 1985. <em>Elliptic functions</em>,  Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> J(2.3+0.23i,use.theta=TRUE)
 J(2.3+0.23i,use.theta=FALSE)

 #Verify that J(z)=J(-1/z):
 z &lt;- seq(from=1+0.7i,to=-2+1i,len=20)
 plot(abs((J(z)-J(-1/z))/J(z)))

 # Verify that lamba(z) = lambda(Mz) where M is a modular matrix with b,c
 # even and a,d odd:

 M &lt;- matrix(c(5,4,16,13),2,2)
 z &lt;- seq(from=1+1i,to=3+3i,len=100)
 plot(lambda(z)-lambda(M %mob% z,maxiter=100))


#Now a nice little plot; vary n to change the resolution:
 n &lt;- 50
 x &lt;- seq(from=-0.1, to=2,len=n)
 y &lt;- seq(from=0.02,to=2,len=n)

 z &lt;- outer(x,1i*y,"+")
 f &lt;- lambda(z,maxiter=40)
 g &lt;- J(z)
 view(x,y,f,scheme=04,real.contour=FALSE,main="try higher resolution")
 view(x,y,g,scheme=10,real.contour=FALSE,main="try higher resolution")

</code></pre>

<hr>
<h2 id='K.fun'>quarter period K</h2><span id='topic+K.fun'></span><span id='topic+e16.1.1'></span>

<h3>Description</h3>

<p>Calculates the K.fun in terms of either <code class="reqn">m</code> (<code>K.fun()</code>)
or <code class="reqn">k</code> (<code>K.fun.k()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K.fun(m, strict=TRUE, maxiter=7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K.fun_+3A_m">m</code></td>
<td>
<p>Real or complex parameter</p>
</td></tr>
<tr><td><code id="K.fun_+3A_strict">strict</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return an
error if the sequence has not converged exactly, and <code>FALSE</code>
meaning to return the partial sum, and a warning</p>
</td></tr>
<tr><td><code id="K.fun_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>R. Coquereaux, A. Grossman, and B. E. Lautrup. <em>Iterative
method for calculation of the Weierstrass elliptic function</em>. IMA
Journal of Numerical Analysis, vol 10, pp119-128, 1990
</p>


<h3>Examples</h3>

<pre><code class='language-R'>K.fun(0.09)  # AMS-55 give 1.60804862 in example 7 on page 581

# next example not run because: (i), it needs gsl; (ii) it gives a warning.
## Not run: 
K.fun(0.4,strict=F, maxiter=4) - ellint_Kcomp(sqrt(0.4))

## End(Not run)
</code></pre>

<hr>
<h2 id='latplot'>Plots a lattice of periods on the complex plane</h2><span id='topic+latplot'></span>

<h3>Description</h3>

<p>Given a pair of basic periods, plots a lattice of periods on the complex plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latplot(p, n=10, do.lines=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latplot_+3A_p">p</code></td>
<td>
<p>Vector of length two with first element the first period and
second element the second period.  Note that
<code class="reqn">p_1=2\omega_1</code></p>
</td></tr>
<tr><td><code id="latplot_+3A_n">n</code></td>
<td>
<p>Size of lattice</p>
</td></tr>
<tr><td><code id="latplot_+3A_do.lines">do.lines</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to show
boundaries between adjacent period parallelograms</p>
</td></tr>
<tr><td><code id="latplot_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to
<code>plot()</code>.  See examples section for working use</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>K. Chandrasekharan 1985. <em>Elliptic functions</em>,
Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- c(1,1i)
p2 &lt;- c(2+3i,5+7i)
latplot(p1)
latplot(p2,xlim=c(-4,4),ylim=c(-4,4),n=40)

</code></pre>

<hr>
<h2 id='lattice'>Lattice of complex numbers</h2><span id='topic+lattice'></span>

<h3>Description</h3>

<p>Returns a lattice of numbers generated by a  given complex basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lattice(p,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lattice_+3A_p">p</code></td>
<td>
<p>Complex vector of length two giving a basis for the lattice</p>
</td></tr>
<tr><td><code id="lattice_+3A_n">n</code></td>
<td>
<p>size of lattice</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'> lattice(c(1+10i,100+1000i),n=2)
plot(lattice(c(1+1i,1.1+1.4i),5))
</code></pre>

<hr>
<h2 id='limit'>Limit the magnitude of elements of a vector</h2><span id='topic+limit'></span>

<h3>Description</h3>

<p>Deals appropriately with objects with a few very large elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limit(x, upper=quantile(Re(x),0.99,na.rm=TRUE),
         lower=quantile(Re(x),0.01,na.rm=TRUE),
         na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limit_+3A_x">x</code></td>
<td>
<p>Vector of real or complex values</p>
</td></tr>
<tr><td><code id="limit_+3A_upper">upper</code></td>
<td>
<p>Upper limit</p>
</td></tr>
<tr><td><code id="limit_+3A_lower">lower</code></td>
<td>
<p>Lower limit</p>
</td></tr>
<tr><td><code id="limit_+3A_na">na</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to &ldquo;clip&rdquo;
<code>x</code> (if real) by setting elements of <code>x</code> with <code>x&gt;high</code> to
<code>high</code>; if <code>TRUE</code>, set such elements to <code>NA</code>.
If <code>x</code> is complex, this argument is ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is complex, <code>low</code> is ignored and the function returns
<code>x</code>, after executing <code>x[abs(x)&gt;high] &lt;- NA</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(rep(1,5),300, -200)
limit(x,100)
limit(x,upper=200,lower= -400)
limit(x,upper=200,lower= -400,na=TRUE)
</code></pre>

<hr>
<h2 id='massage'>Massages numbers near the real line to be real</h2><span id='topic+massage'></span>

<h3>Description</h3>

<p>Returns the Real part of numbers near the real line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>massage(z, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="massage_+3A_z">z</code></td>
<td>
<p>vector of complex numbers to be massaged</p>
</td></tr>
<tr><td><code id="massage_+3A_tol">tol</code></td>
<td>
<p>Tolerance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>massage(1+1i)
massage(1+1e-11i)

massage(c(1,1+1e-11i,1+10i))
</code></pre>

<hr>
<h2 id='misc'>Manipulate real or imaginary components of an object</h2><span id='topic+Im+3C-'></span><span id='topic+Re+3C-'></span>

<h3>Description</h3>

<p>Manipulate real or imaginary components of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Im(x) &lt;- value
Re(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misc_+3A_x">x</code></td>
<td>
<p>Complex-valued object</p>
</td></tr>
<tr><td><code id="misc_+3A_value">value</code></td>
<td>
<p>Real-valued object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
Im(x) &lt;- 1

x &lt;- 1:5
Im(x) &lt;- 1/x


</code></pre>

<hr>
<h2 id='mob'>Moebius transformations</h2><span id='topic+mob'></span><span id='topic++25mob+25'></span>

<h3>Description</h3>

<p>Moebius transformations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mob(M, x)
M %mob% x
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mob_+3A_m">M</code></td>
<td>
<p>2-by-2 matrix of integers</p>
</td></tr>
<tr><td><code id="mob_+3A_x">x</code></td>
<td>
<p>vector of values to be transformed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a value with the same attributes as <code>x</code>.  Elementwise, if
</p>
<p style="text-align: center;"><code class="reqn">M=\left(\begin{array}{cc}a&amp;b\\c&amp;d\end{array}\right)</code>
</p>

<p>then <code>mob(M,x)</code> is <code class="reqn">\frac{ax+b}{cx+d}</code>.
</p>


<h3>Note</h3>

<p>This function does not check for <code>M</code> being having integer
elements, nor for the determinant being unity.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Wikipedia contributors, &quot;Mobius transformation,&quot; Wikipedia, The Free
Encyclopedia (accessed February 13, 2011). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unimodular">unimodular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(11,6,9,5),2,2)
x &lt;- seq(from=1+1i,to=10-2i,len=6)

M %mob% x
plot(mob(M,x))
</code></pre>

<hr>
<h2 id='myintegrate'>Complex integration</h2><span id='topic+myintegrate'></span><span id='topic+integrate.contour'></span><span id='topic+integrate.segments'></span><span id='topic+residue'></span>

<h3>Description</h3>

<p>Integration of complex valued functions along the real axis
(<code>myintegrate()</code>), along arbitrary paths
(<code>integrate.contour()</code>), and following arbitrary straight line
segments (<code>integrate.segments()</code>).  Also, evaluation of a function at a
point using the residue theorem (<code>residue()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myintegrate(f, lower,upper, ...)
integrate.contour(f,u,udash, ...)
integrate.segments(f,points, close=TRUE, ...)
residue(f, z0, r, O=z0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myintegrate_+3A_f">f</code></td>
<td>
<p>function, possibly complex valued</p>
</td></tr>
<tr><td><code id="myintegrate_+3A_lower">lower</code>, <code id="myintegrate_+3A_upper">upper</code></td>
<td>
<p>Lower and upper limits of integration in <code>myintegrate()</code>; 
real numbers (for complex values, use <code>integrate.contour()</code> or
<code>integrate.segments()</code>)</p>
</td></tr>
<tr><td><code id="myintegrate_+3A_u">u</code></td>
<td>
<p>Function mapping <code class="reqn">[0,1]</code> to the contour.  For a
closed contour, require that <code class="reqn">u(0)=u(1)</code></p>
</td></tr>
<tr><td><code id="myintegrate_+3A_udash">udash</code></td>
<td>
<p>Derivative of <code>u</code></p>
</td></tr>
<tr><td><code id="myintegrate_+3A_points">points</code></td>
<td>
<p>In function <code>integrate.segments()</code>, a vector of complex
numbers.  Integration will be taken over straight segments joining
consecutive elements of <code>points</code></p>
</td></tr>
<tr><td><code id="myintegrate_+3A_close">close</code></td>
<td>
<p>In function <code>integrate.segments()</code>, a Boolean
variable with default <code>TRUE</code> meaning to integrate along the segment
from <code>points[n]</code> to <code>points[1]</code> in addition to the internal
segments</p>
</td></tr>
<tr><td><code id="myintegrate_+3A_r">r</code>, <code id="myintegrate_+3A_o">O</code>, <code id="myintegrate_+3A_z0">z0</code></td>
<td>
<p>In function <code>residue()</code> returns <code>f(z0)</code> by
integrating <code class="reqn">f(z)/(z-z0)</code> around a circle of radius <code>r</code> and
center <code>O</code></p>
</td></tr>
<tr><td><code id="myintegrate_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f1 &lt;- function(z){sin(exp(z))}
f2 &lt;- function(z,p){p/z}

myintegrate(f1,2,3)  # that is, along the real axis


integrate.segments(f1,c(1,1i,-1,-1i),close=TRUE)   # should be zero

# (following should be pi*2i; note secondary argument):
integrate.segments(f2,points=c(1,1i,-1,-1i),close=TRUE,p=1)



# To integrate round the unit circle, we need the contour and its
# derivative:

 u &lt;- function(x){exp(pi*2i*x)}
 udash &lt;- function(x){pi*2i*exp(pi*2i*x)}

# Some elementary functions, for practice:

# (following should be 2i*pi; note secondary argument 'p'):
integrate.contour(function(z,p){p/z},u,udash,p=1)      
integrate.contour(function(z){log(z)},u,udash)         # should be -2i*pi
integrate.contour(function(z){sin(z)+1/z^2},u,udash)   # should be zero



# residue() is a convenience wrapper integrating f(z)/(z-z0) along a
# circular contour:

residue(function(z){1/z},2,r=0.1)  # should be 1/2=0.5



# Now, some elliptic functions:
g &lt;- c(3,2+4i)
Zeta &lt;- function(z){zeta(z,g)}
Sigma &lt;- function(z){sigma(z,g)}
WeierstrassP &lt;- function(z){P(z,g)}

jj &lt;- integrate.contour(Zeta,u,udash) 
abs(jj-2*pi*1i)                              # should be zero
abs(integrate.contour(Sigma,u,udash))        # should be zero
abs(integrate.contour(WeierstrassP,u,udash)) # should be zero




# Now integrate f(x) = exp(1i*x)/(1+x^2) from -Inf to +Inf along the
# real axis, using the Residue Theorem.  This tells us that integral of
# f(z) along any closed path is equal to pi*2i times the sum of the
# residues inside it.  Take a semicircular path P from -R to +R along
# the real axis, then following a semicircle in the upper half plane, of
# radius R to close the loop.  Now consider large R.  Then P encloses a
# pole at +1i [there is one at -1i also, but this is outside P, so
# irrelevent here] at which the residue is -1i/2e.  Thus the integral of
# f(z) = 2i*pi*(-1i/2e) = pi/e along P; the contribution from the
# semicircle tends to zero as R tends to infinity; thus the integral
# along the real axis is the whole path integral, or pi/e.

# We can now reproduce this result analytically.  First, choose an R:
R &lt;- 400

# now define P.  First, the semicircle, u1:
u1     &lt;- function(x){R*exp(pi*1i*x)}
u1dash &lt;- function(x){R*pi*1i*exp(pi*1i*x)}

# and now the straight part along the real axis, u2:
u2     &lt;- function(x){R*(2*x-1)}
u2dash &lt;- function(x){R*2}

# Better define the function:
f &lt;- function(z){exp(1i*z)/(1+z^2)}

# OK, now carry out the path integral.  I'll do it explicitly, but note
# that the contribution from the first integral should be small:

answer.approximate &lt;-
    integrate.contour(f,u1,u1dash) +
    integrate.contour(f,u2,u2dash) 

# And compare with the analytical value:
answer.exact &lt;- pi/exp(1)
abs(answer.approximate - answer.exact)


# Now try the same thing but integrating over a triangle, using
# integrate.segments().  Use a path P' with base from -R to +R along the
# real axis, closed by two straight segments, one from +R to 1i*R, the
# other from 1i*R to -R:

abs(integrate.segments(f,c(-R,R,1i*R))- answer.exact)


# Observe how much better one can do by integrating over a big square
# instead:

abs(integrate.segments(f,c(-R,R,R+1i*R, -R+1i*R))- answer.exact)


# Now in the interests of search engine findability, here is an
# application of Cauchy's integral formula, or Cauchy's formula.  I will
# use it to find sin(0.8):

u     &lt;- function(x){exp(pi*2i*x)}
udash &lt;- function(x){pi*2i*exp(pi*2i*x)}

g &lt;- function(z){sin(z)/(z-0.8)}

a &lt;- 1/(2i*pi)*integrate.contour(g,u,udash)


abs(a-sin(0.8))


</code></pre>

<hr>
<h2 id='near.match'>Are two vectors close to one another?</h2><span id='topic+near.match'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if each element of <code>x</code> and <code>y</code> are
&ldquo;near&rdquo; one another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>near.match(x, y, tol=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="near.match_+3A_x">x</code></td>
<td>
<p>First object</p>
</td></tr>
<tr><td><code id="near.match_+3A_y">y</code></td>
<td>
<p>Second object</p>
</td></tr>
<tr><td><code id="near.match_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance with default NULL meaning to use machine
precision</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(1,6)
near.match(x, x+rnorm(6)/1e10)
</code></pre>

<hr>
<h2 id='newton_raphson'>Newton Raphson iteration to find roots of equations</h2><span id='topic+newton_raphson'></span><span id='topic+Newton_raphson'></span><span id='topic+Newton_Raphson'></span><span id='topic+newton_Raphson'></span>

<h3>Description</h3>

<p>Newton-Raphson iteration to find roots of equations with the emphasis
on complex functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'> newton_raphson(initial, f, fdash, maxiter, give=TRUE, tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newton_raphson_+3A_initial">initial</code></td>
<td>
<p>Starting guess</p>
</td></tr>
<tr><td><code id="newton_raphson_+3A_f">f</code></td>
<td>
<p>Function for which <code class="reqn">f(z)=0</code> is to be solved for
<code class="reqn">z</code></p>
</td></tr>
<tr><td><code id="newton_raphson_+3A_fdash">fdash</code></td>
<td>
<p>Derivative of function (note: Cauchy-Riemann conditions
assumed)</p>
</td></tr> 
<tr><td><code id="newton_raphson_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations attempted</p>
</td></tr>
<tr><td><code id="newton_raphson_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to give
output based on that of <code>uniroot()</code> and <code>FALSE</code> meaning to
return only the estimated root</p>
</td></tr>
<tr><td><code id="newton_raphson_+3A_tol">tol</code></td>
<td>
<p>Tolerance: iteration stops if <code class="reqn">|f(z)|&lt;tol</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bog-standard implementation of the Newton-Raphson algorithm
</p>


<h3>Value</h3>

<p>If <code>give</code> is <code>FALSE</code>,
returns <code class="reqn">z</code> with <code class="reqn">|f(z)|&lt;tol</code>; if <code>TRUE</code>, returns a list
with elements <code>root</code> (the estimated root), <code>f.root</code> (the
function evaluated at the estimated root; should have small modulus),
and <code>iter</code>, the number of iterations required.
</p>


<h3>Note</h3>

<p>Previous versions of this function used the misspelling
&ldquo;Rapheson&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Find the two square roots of 2+i:
f &lt;- function(z){z^2-(2+1i)}
fdash &lt;- function(z){2*z}
newton_raphson( 1.4+0.3i,f,fdash,maxiter=10)
newton_raphson(-1.4-0.3i,f,fdash,maxiter=10)

# Now find the three cube roots of unity:
g &lt;- function(z){z^3-1}
gdash &lt;- function(z){3*z^2}
newton_raphson(-0.5+1i,g,gdash,maxiter=10)
newton_raphson(-0.5-1i,g,gdash,maxiter=10)
newton_raphson(+0.5+0i,g,gdash,maxiter=10)
</code></pre>

<hr>
<h2 id='nome'>Nome in terms of m or k</h2><span id='topic+nome'></span><span id='topic+nome.k'></span>

<h3>Description</h3>

<p>Calculates the nome in terms of either <code class="reqn">m</code> (<code>nome()</code>)
or <code class="reqn">k</code> (<code>nome.k()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nome(m)
nome.k(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nome_+3A_m">m</code></td>
<td>
<p>Real parameter</p>
</td></tr>
<tr><td><code id="nome_+3A_k">k</code></td>
<td>
<p>Real parameter with <code class="reqn">k=m^2</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The nome is defined as <code class="reqn">e^{-i\pi K'/K}</code>, where
<code class="reqn">K</code> and <code class="reqn">iK'</code> are the quarter periods (see page 576 of
AMS-55).  These are calculated using function <code>K.fun()</code>. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+K.fun">K.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nome(0.09)  # AMS-55 give 0.00589414 in example 7 on page 581
</code></pre>

<hr>
<h2 id='P.laurent'>Laurent series for elliptic and related functions</h2><span id='topic+P.laurent'></span><span id='topic+Pdash.laurent'></span><span id='topic+sigma.laurent'></span><span id='topic+sigmadash.laurent'></span><span id='topic+zeta.laurent'></span><span id='topic+e18.5.1'></span><span id='topic+e18f.5.3'></span><span id='topic+e18.5.4'></span><span id='topic+e18.5.5'></span><span id='topic+e18.5.6'></span>

<h3>Description</h3>

<p>Laurent series for various functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>        P.laurent(z, g=NULL, tol=0, nmax=80)
    Pdash.laurent(z, g=NULL, nmax=80)
    sigma.laurent(z, g=NULL, nmax=8, give.error=FALSE)
sigmadash.laurent(z, g=NULL, nmax=8, give.error=FALSE)
     zeta.laurent(z, g=NULL, nmax=80)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="P.laurent_+3A_z">z</code></td>
<td>
<p>Primary argument (complex)</p>
</td></tr>
<tr><td><code id="P.laurent_+3A_g">g</code></td>
<td>
<p>Vector of length two with <code>g=c(g2,g3)</code></p>
</td></tr>
<tr><td><code id="P.laurent_+3A_tol">tol</code></td>
<td>
<p>Tolerance</p>
</td></tr>
<tr><td><code id="P.laurent_+3A_give.error">give.error</code></td>
<td>
<p>In <code>sigma.laurent()</code>, Boolean with default
<code>FALSE</code> meaning to return the computed value and <code>TRUE</code>
to return the error (as estimated by the sum of the absolute values
of the terms along the minor long diagonal of the matrix)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="P.laurent_+3A_nmax">nmax</code></td>
<td>
<p>Number of terms used (or, for <code>sigma()</code>, the size of
matrix used)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigma.laurent(z=1+1i,g=c(0,4))
  </code></pre>

<hr>
<h2 id='p1.tau'>Does the right thing when calling g2.fun() and g3.fun()</h2><span id='topic+p1.tau'></span>

<h3>Description</h3>

<p>Takes vectors and
interprets them appropriately for input to <code>g2.fun()</code> and
<code>g3.fun()</code>.  Not really intended for the end user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1.tau(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p1.tau_+3A_b">b</code></td>
<td>
<p>Vector of periods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>b</code> is of length two, interpret the elements as
<code class="reqn">\omega_1</code> and <code class="reqn">\omega_2</code> respectively.
</p>
<p>If a two-column matrix, interpret the columns as
<code class="reqn">\omega_1</code> and <code class="reqn">\omega_2</code> respectively.
</p>
<p>Otherwise, interpret as a vector of
<code class="reqn">\tau=\omega_1/\omega_2</code>.
</p>


<h3>Value</h3>

<p>Returns a two-component list:
</p>
<table>
<tr><td><code>p1</code></td>
<td>
<p>First period</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Period ratio</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'> p1.tau(c(1+1i,1.1+23.123i))
</code></pre>

<hr>
<h2 id='parameters'>Parameters for Weierstrass's P function</h2><span id='topic+parameters'></span><span id='topic+e18.7.4'></span><span id='topic+e18.7.5'></span><span id='topic+e18.7.7'></span><span id='topic+e18.3.5'></span><span id='topic+e18.3.3'></span><span id='topic+e18.3.37'></span><span id='topic+e18.3.38'></span><span id='topic+e18.3.39'></span>

<h3>Description</h3>

<p>Calculates the invariants <code class="reqn">g_2</code> and <code class="reqn">g_3</code>,
the e-values <code class="reqn">e_1,e_2,e_3</code>, and the half periods
<code class="reqn">\omega_1,\omega_2</code>, from any one of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(Omega=NULL, g=NULL, description=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_omega">Omega</code></td>
<td>
<p>Vector of length two, containing the <strong>half
periods</strong> <code class="reqn">(\omega_1,\omega_2)</code></p>
</td></tr>
<tr><td><code id="parameters_+3A_g">g</code></td>
<td>
<p>Vector of length two:
<code class="reqn">(g_2,g_3)</code></p>
</td></tr>
<tr><td><code id="parameters_+3A_description">description</code></td>
<td>
<p>string containing &ldquo;equianharmonic&rdquo;,
&ldquo;lemniscatic&rdquo;, or &ldquo;pseudolemniscatic&rdquo;, to specify one
of A and S's special cases</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>Returns a list with the following items:
</p>
<table>
<tr><td><code>Omega</code></td>
<td>
<p>A complex vector of length 2 giving the fundamental half
periods <code class="reqn">\omega_1</code> and <code class="reqn">\omega_2</code>.  Notation
follows Chandrasekharan: half period
<code class="reqn">\omega_1</code> is 0.5 times a (nontrivial) period of minimal
modulus, and <code class="reqn">\omega_2</code> is 0.5 times a period of smallest
modulus having the property <code class="reqn">\omega_2/\omega_1</code>
not real.
</p>
<p>The relevant periods are made unique by the further requirement that
<code class="reqn">\mathrm{Re}(\omega_1)&gt;0</code>, and 
<code class="reqn">\mathrm{Im}(\omega_2)&gt;0</code>; but note that this
often results in sign changes when considering cases on boundaries
(such as real <code class="reqn">g_2</code> and <code class="reqn">g_3</code>). 
</p>
<p><strong>Note</strong> Different definitions exist for <code class="reqn">\omega_3</code>!
A and S use <code class="reqn">\omega_3=\omega_2-\omega_1</code>,
while Whittaker and Watson (eg, page 443), and Mathematica, have
<code class="reqn">\omega_1+\omega_2+\omega_3=0</code>
</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The nome.  Here,
<code class="reqn">q=e^{\pi i\omega_2/\omega_1}</code>.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>Complex vector of length 2 holding the invariants</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>Complex vector of length 3.  Here <code class="reqn">e_1</code>, <code class="reqn">e_2</code>,
and <code class="reqn">e_3</code> are defined by
</p>
<p style="text-align: center;"><code class="reqn">e_1=\wp(\omega1/2)m\qquad e_2=\wp(\omega2/2),\qquad
	e_3=\wp(\omega3/2)</code>
</p>

<p>where <code class="reqn">\omega_3</code> is defined by
<code class="reqn">\omega_1+\omega_2+\omega_3=0</code>.
</p>
<p>Note that the <code class="reqn">e</code>s are also defined as the three roots of
<code class="reqn">x^3-g_2x-g_3=0</code>; but this method cannot be used in
isolation because the roots may be returned in the wrong order.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>The quantity <code class="reqn">g_2^3-27g_3^2</code>, often
denoted <code class="reqn">\Delta</code></p>
</td></tr>
<tr><td><code>Eta</code></td>
<td>
<p>Complex vector of length 3 often denoted
<code class="reqn">\eta</code>.  Here
<code class="reqn">\eta=(\eta_1,\eta_2,\eta_3)</code> are defined
in terms of the Weierstrass zeta function with
<code class="reqn">\eta_i=\zeta(\omega_i)</code> for <code class="reqn">i=1,2,3</code>.
</p>
<p>Note that the name of this element is capitalized to avoid confusion 
with function <code>eta()</code></p>
</td></tr>
<tr><td><code>is.AnS</code></td>
<td>
<p>Boolean, with <code>TRUE</code> corresponding to real
invariants, as per Abramowitz and Stegun</p>
</td></tr>
<tr><td><code>given</code></td>
<td>
<p>character string indicating which parameter was supplied.
Currently, one of &ldquo;<code>o</code>&rdquo; (omega), or  &ldquo;<code>g</code>&rdquo;
(invariants)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Example 6, p665, LHS
 parameters(g=c(10,2+0i))


 ## Example 7, p665, RHS
 a &lt;- parameters(g=c(7,6)) ;  attach(a)
 c(omega2=Omega[1],omega2dash=Omega[1]+Omega[2]*2)


  ## verify 18.3.37:
  Eta[2]*Omega[1]-Eta[1]*Omega[2]   #should be close to pi*1i/2


## from Omega to g and and back;
## following should be equivalentto c(1,1i):
 parameters(g=parameters(Omega=c(1,1i))$g)$Omega 


</code></pre>

<hr>
<h2 id='pari'>Wrappers for PARI functions</h2><span id='topic+pari'></span><span id='topic+PARI'></span><span id='topic+P.pari'></span><span id='topic+gp'></span><span id='topic+GP'></span><span id='topic+Gp'></span>

<h3>Description</h3>

<p>Wrappers for the three elliptic functions of PARI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P.pari(z,Omega,pari.fun="ellwp",numerical=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pari_+3A_z">z</code></td>
<td>
<p>Complex argument</p>
</td></tr>
<tr><td><code id="pari_+3A_omega">Omega</code></td>
<td>
<p>Half periods</p>
</td></tr>
<tr><td><code id="pari_+3A_pari.fun">pari.fun</code></td>
<td>
<p>String giving the name of the function passed to
PARI.  Values of <code>ellwp</code>, <code>ellsigma</code>, and <code>ellzeta</code>,
are acceptable here for the Weierstrass <code class="reqn">\wp</code> function, the
<code class="reqn">\sigma</code> function, and the <code class="reqn">\zeta</code> function
respectively</p>
</td></tr>   
<tr><td><code id="pari_+3A_numerical">numerical</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to return
the complex value returned by PARI, and <code>FALSE</code> meaning to
return the ascii string returned by PARI</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls PARI via an R <code>system()</code> call.
</p>


<h3>Value</h3>

<p>Returns an object with the same attributes as <code>z</code>.
</p>


<h3>Note</h3>

<p>Function translates input into, for example,
&ldquo;<code>ellwp([1+1*I,2+3*I],1.111+5.1132*I)</code>&rdquo; and pipes this string
directly into <code>gp</code>.
</p>
<p>The PARI system clearly has more powerful syntax than the basic version
that I'm using here, but I can't (for example) figure out how to
vectorize any of the calls.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="http://www.parigp-home.de/">http://www.parigp-home.de/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  #this in a dontrun environment because it requires pari/gp 
z  &lt;- seq(from=1,to=3+2i,len=34)
p &lt;- c(1,1i)
plot(abs(P.pari(z=z,Omega=p) - P(z=z,Omega=p)))
plot(zeta(z=z,params=parameters(Omega=p))- P.pari(z=z,Omega=c(p),pari.fun="ellzeta"))


## End(Not run)
</code></pre>

<hr>
<h2 id='sn'>Jacobi form of the elliptic functions</h2><span id='topic+ss'></span><span id='topic+sc'></span><span id='topic+sn'></span><span id='topic+sd'></span><span id='topic+cs'></span><span id='topic+cc'></span><span id='topic+cn'></span><span id='topic+cd'></span><span id='topic+ns'></span><span id='topic+nc'></span><span id='topic+nn'></span><span id='topic+nd'></span><span id='topic+ds'></span><span id='topic+dc'></span><span id='topic+dn'></span><span id='topic+dd'></span><span id='topic+e16.36.3'></span>

<h3>Description</h3>

<p>Jacobian elliptic functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss(u,m, ...)
sc(u,m, ...)
sn(u,m, ...)
sd(u,m, ...)
cs(u,m, ...)
cc(u,m, ...)
cn(u,m, ...)
cd(u,m, ...)
ns(u,m, ...)
nc(u,m, ...)
nn(u,m, ...)
nd(u,m, ...)
ds(u,m, ...)
dc(u,m, ...)
dn(u,m, ...)
dd(u,m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sn_+3A_u">u</code></td>
<td>
<p>Complex argument</p>
</td></tr>
<tr><td><code id="sn_+3A_m">m</code></td>
<td>
<p>Parameter</p>
</td></tr>
<tr><td><code id="sn_+3A_...">...</code></td>
<td>
<p>Extra arguments, such as <code>maxiter</code>, passed to
<code>theta.?()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All sixteen Jacobi elliptic functions. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965.  <em>Handbook of mathematical
functions</em>. New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta">theta</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example 1, p579:
nc(1.9965,m=0.64)
# (some problem here)

# Example 2, p579:
dn(0.20,0.19)

# Example 3, p579:
dn(0.2,0.81)

# Example 4, p580:
cn(0.2,0.81)

# Example 5, p580:
dc(0.672,0.36)

# Example 6, p580:
Theta(0.6,m=0.36)

# Example 7, p581:
cs(0.53601,0.09)

# Example 8, p581:
sn(0.61802,0.5)

#Example 9, p581:
sn(0.61802,m=0.5)

#Example 11, p581:
cs(0.99391,m=0.5)
# (should be 0.75 exactly)

#and now a pretty picture:

n &lt;- 300
K &lt;- K.fun(1/2)
f &lt;- function(z){1i*log((z-1.7+3i)*(z-1.7-3i)/(z+1-0.3i)/(z+1+0.3i))}
# f &lt;- function(z){log((z-1.7+3i)/(z+1.7+3i)*(z+1-0.3i)/(z-1-0.3i))}
x &lt;- seq(from=-K,to=K,len=n)
y &lt;- seq(from=0,to=K,len=n)
z &lt;- outer(x,1i*y,"+")

view(x, y, f(sn(z,m=1/2)), nlevels=44, imag.contour=TRUE,
     real.cont=TRUE, code=1, drawlabels=FALSE,
     main="Potential flow in a rectangle",axes=FALSE,xlab="",ylab="")
rect(-K,0,K,K,lwd=3)




</code></pre>

<hr>
<h2 id='sqrti'>Generalized square root</h2><span id='topic+sqrti'></span>

<h3>Description</h3>

<p>Square root wrapper that keeps answer real if possible, coerces to
complex if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrti(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrti_+3A_x">x</code></td>
<td>
<p>Vector to return square root of</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqrti(1:10)  #real
sqrti(-10:10) #coerced to complex (compare sqrt(-10:10))
sqrti(1i+1:10) #complex anyway
</code></pre>

<hr>
<h2 id='theta'>Jacobi theta functions 1-4</h2><span id='topic+theta'></span><span id='topic+theta1'></span><span id='topic+theta2'></span><span id='topic+theta3'></span><span id='topic+theta4'></span><span id='topic+e16.27.1'></span><span id='topic+e16.27.2'></span><span id='topic+e16.27.3'></span><span id='topic+e16.27.4'></span><span id='topic+theta.00'></span><span id='topic+theta.01'></span><span id='topic+theta.10'></span><span id='topic+theta.11'></span><span id='topic+Theta'></span><span id='topic+Theta1'></span><span id='topic+H'></span><span id='topic+H1'></span><span id='topic+e16.31.1'></span><span id='topic+e16.31.2'></span><span id='topic+e16.31.3'></span><span id='topic+e16.31.4'></span>

<h3>Description</h3>

<p>Computes Jacobi's four theta functions for complex <code class="reqn">z</code> in terms
of the parameter <code class="reqn">m</code> or <code class="reqn">q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta1  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
theta2  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
theta3  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
theta4  (z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
theta.00(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
theta.01(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
theta.10(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
theta.11(z, ignore=NULL, m=NULL, q=NULL, give.n=FALSE, maxiter=30)
Theta (u, m, ...)
Theta1(u, m, ...)
H (u, m, ...)
H1(u, m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_+3A_z">z</code>, <code id="theta_+3A_u">u</code></td>
<td>
<p>Complex argument of function</p>
</td></tr>
<tr><td><code id="theta_+3A_ignore">ignore</code></td>
<td>
<p>Dummy variable whose intention is to force the user to
name the second argument either <code>m</code> or <code>q</code>.</p>
</td></tr>
<tr><td><code id="theta_+3A_m">m</code></td>
<td>
<p>Does not seem to have a name.   The variable is introduced in
section 16.1, p569</p>
</td></tr>
<tr><td><code id="theta_+3A_q">q</code></td>
<td>
<p>The nome <code class="reqn">q</code>, defined in section 16.27, p576</p>
</td></tr>
<tr><td><code id="theta_+3A_give.n">give.n</code></td>
<td>
<p>Boolean with default <code>FALSE</code> meaning to return the
function evaluation, and <code>TRUE</code> meaning to return a two element
list, with first element the function evaluation, and second element
the number of iterations used</p>
</td></tr>
<tr><td><code id="theta_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations used.  Note that the
series generally converge very quickly</p>
</td></tr>
<tr><td><code id="theta_+3A_...">...</code></td>
<td>
<p>In functions that take it, extra arguments passed to
<code>theta1()</code> et seq; notably, <code>maxiter</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Should have a <code>tol</code> argument.
</p>
<p>Functions <code>theta.00()</code> eq seq are just wrappers for 
<code>theta1()</code> et seq, following Whittaker and Watson's terminology
on p487; the notation does not appear in Abramowitz and Stegun.
</p>

<ul>
<li> <p><code>theta.11() = theta1()</code>
</p>
</li>
<li> <p><code>theta.10() = theta2()</code>
</p>
</li>
<li> <p><code>theta.00() = theta3()</code>
</p>
</li>
<li> <p><code>theta.01() = theta4()</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a complex-valued object with the same attributes as either
<code>z</code>, or (<code>m</code> or <code>q</code>), whichever wasn't recycled.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965.  <em>Handbook of mathematical
functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta.neville">theta.neville</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- 0.5
derivative &lt;- function(small){(theta1(small,m=m)-theta1(0,m=m))/small}
right.hand.side1 &lt;-  theta2(0,m=m)*theta3(0,m=m)*theta4(0,m=m)
right.hand.side2 &lt;-  theta1.dash.zero(m)

derivative(1e-5)-right.hand.side1   #should be zero
derivative(1e-5)-right.hand.side2   #should be zero
</code></pre>

<hr>
<h2 id='theta.neville'>Neville's form for the theta functions</h2><span id='topic+theta.neville'></span><span id='topic+theta.s'></span><span id='topic+theta.c'></span><span id='topic+theta.d'></span><span id='topic+theta.n'></span><span id='topic+e16.36.6'></span><span id='topic+e16.36.6a'></span><span id='topic+e16.36.6b'></span><span id='topic+e16.36.7'></span><span id='topic+e16.36.7a'></span><span id='topic+e16.36.7b'></span><span id='topic+e16.37.1'></span><span id='topic+e16.37.2'></span><span id='topic+e16.37.3'></span><span id='topic+e16.37.4'></span><span id='topic+e16.38.1'></span><span id='topic+e16.38.2'></span><span id='topic+e16.38.3'></span><span id='topic+e16.38.4'></span>

<h3>Description</h3>

<p>Neville's notation for theta functions as per section 16.36 of
Abramowitz and Stegun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.s(u, m, method = "16.36.6", ...)
theta.c(u, m, method = "16.36.6", ...)
theta.d(u, m, method = "16.36.7", ...)
theta.n(u, m, method = "16.36.7", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta.neville_+3A_u">u</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="theta.neville_+3A_m">m</code></td>
<td>
<p>Real parameter</p>
</td></tr>
<tr><td><code id="theta.neville_+3A_method">method</code></td>
<td>
<p>Character string corresponding to A and S's equation
numbering scheme</p>
</td></tr>
<tr><td><code id="theta.neville_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the method function, such as
<code>maxiter</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965.  <em>Handbook of mathematical
functions</em>. New York: Dover
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Figure 16.4.
m &lt;- 0.5
K &lt;- K.fun(m)
Kdash &lt;- K.fun(1-m)
x &lt;- seq(from=0,to=4*K,len=100)
plot  (x/K,theta.s(x,m=m),type="l",lty=1,main="Figure 16.4, p578")
points(x/K,theta.n(x,m=m),type="l",lty=2)
points(x/K,theta.c(x,m=m),type="l",lty=3)
points(x/K,theta.d(x,m=m),type="l",lty=4)
abline(0,0)



#plot a graph of something that should be zero:
 x &lt;- seq(from=-4,to=4,len=55)
 plot(x,(e16.37.1(x,0.5)-theta.s(x,0.5)),pch="+",main="error: note vertical scale")

#now table 16.1 on page 582 et seq:
 alpha &lt;- 85
 m &lt;- sin(alpha*pi/180)^2
## K &lt;- ellint_Kcomp(sqrt(m))
 K &lt;- K.fun(m)
 u &lt;- K/90*5*(0:18)
 u.deg &lt;- round(u/K*90)
 cbind(u.deg,"85"=theta.s(u,m))      # p582, last col. 
 cbind(u.deg,"85"=theta.n(u,m))      # p583, last col. 


</code></pre>

<hr>
<h2 id='theta1.dash.zero'>Derivative of theta1</h2><span id='topic+theta1.dash.zero'></span><span id='topic+theta1.dash.zero.q'></span><span id='topic+e16.28.6'></span>

<h3>Description</h3>

<p>Calculates <code class="reqn">\theta_1'</code> as a function of either <code class="reqn">m</code>
or <code class="reqn">k</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta1.dash.zero(m, ...)
theta1.dash.zero.q(q, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta1.dash.zero_+3A_m">m</code></td>
<td>
<p>real parameter</p>
</td></tr>
<tr><td><code id="theta1.dash.zero_+3A_q">q</code></td>
<td>
<p>Real parameter</p>
</td></tr>
<tr><td><code id="theta1.dash.zero_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>theta1()</code> et seq, notably
<code>maxiter</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Now, try and get 16.28.6, p576: theta1dash=theta2*theta3*theta4:

m &lt;- 0.5
derivative &lt;- function(small){(theta1(small,m=m)-theta1(0,m=m))/small}
right.hand.side &lt;-  theta2(0,m=m)*theta3(0,m=m)*theta4(0,m=m)
derivative(1e-7)-right.hand.side

</code></pre>

<hr>
<h2 id='theta1dash'>Derivatives of theta functions</h2><span id='topic+theta1dash'></span><span id='topic+theta1dashdash'></span><span id='topic+theta1dashdashdash'></span>

<h3>Description</h3>

<p>First, second, and third derivatives of the theta functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta1dash(z, ignore = NULL, m = NULL, q = NULL, give.n = FALSE, maxiter = 30)
theta1dashdash(z, ignore = NULL, m = NULL, q = NULL, give.n = FALSE, maxiter = 30)
theta1dashdashdash(z, ignore = NULL, m = NULL, q = NULL, give.n = FALSE, maxiter = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta1dash_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="theta1dash_+3A_ignore">ignore</code></td>
<td>
<p>Dummy argument to force the user to name the next
argument either <code>m</code> or <code>q</code></p>
</td></tr>
<tr><td><code id="theta1dash_+3A_m">m</code></td>
<td>
<p>m as documented in <code>theta1()</code></p>
</td></tr>
<tr><td><code id="theta1dash_+3A_q">q</code></td>
<td>
<p>q as documented in <code>theta1()</code></p>
</td></tr>
<tr><td><code id="theta1dash_+3A_give.n">give.n</code></td>
<td>
<p>Boolean with default <code>FALSE</code> meaning to return the
function evaluation, and <code>TRUE</code> meaning to return a two element
list, with first element the function evaluation, and second element
the number of iterations used</p>
</td></tr>
<tr><td><code id="theta1dash_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses direct expansion as for <code>theta1()</code> et seq
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of Mathematical
Functions.</em>  New York, Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta">theta</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 0.3+0.31i
z &lt;- seq(from=1,to=2+1i,len=7)
delta &lt;- 0.001
deriv.numer &lt;- (theta1dashdash(z=z+delta,m=m) - theta1dashdash(z=z,m=m))/delta
deriv.exact &lt;- theta1dashdashdash(z=z+delta/2,m=m)
abs(deriv.numer-deriv.exact)

</code></pre>

<hr>
<h2 id='unimodular'>Unimodular matrices</h2><span id='topic+unimodular'></span><span id='topic+unimodularity'></span>

<h3>Description</h3>

<p>Systematically generates unimodular matrices; numerical verfication of a
function's unimodularness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unimodular(n)
unimodularity(n,o, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unimodular_+3A_n">n</code></td>
<td>
<p>Maximum size of entries of matrices</p>
</td></tr>
<tr><td><code id="unimodular_+3A_o">o</code></td>
<td>
<p>Two element vector</p>
</td></tr>
<tr><td><code id="unimodular_+3A_fun">FUN</code></td>
<td>
<p>Function whose unimodularity is to be checked</p>
</td></tr>
<tr><td><code id="unimodular_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here, a &lsquo;unimodular&rsquo; matrix is of size <code class="reqn">2\times 2</code>,
with integer entries and a determinant of unity.
</p>


<h3>Value</h3>

<p>Function <code>unimodular()</code> returns an array <code>a</code> of dimension
<code>c(2,2,u)</code> (where <code>u</code> is a complicated function of <code>n</code>).
Thus 3-slices of <code>a</code> (that is, <code>a[,,i]</code>) are unimodular.
</p>
<p>Function <code>unimodularity()</code> returns the result of applying
<code>FUN()</code> to the unimodular transformations of <code>o</code>.  The
function returns a vector of length <code>dim(unimodular(n))[3]</code>; if
<code>FUN()</code> is unimodular and roundoff is neglected, all elements of
the vector should be identical.
</p>


<h3>Note</h3>

<p>In function <code>as.primitive()</code>, a &lsquo;unimodular&rsquo; may have
determinant minus one.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.primitive">as.primitive</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>unimodular(3)

o &lt;- c(1,1i)
plot(abs(unimodularity(3,o,FUN=g2.fun,maxiter=100)-g2.fun(o)))


</code></pre>

<hr>
<h2 id='view'>Visualization of complex functions</h2><span id='topic+view'></span>

<h3>Description</h3>

<p>Visualization of complex functions using colourmaps and contours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view(x, y, z, scheme = 0, real.contour = TRUE, imag.contour = real.contour,
default = 0, col="black", r0=1, power=1, show.scheme=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_+3A_x">x</code>, <code id="view_+3A_y">y</code></td>
<td>
<p>Vectors showing real and imaginary components of complex
plane; same functionality as  arguments to <code>image()</code></p>
</td></tr>
<tr><td><code id="view_+3A_z">z</code></td>
<td>
<p>Matrix of complex values to be visualized</p>
</td></tr>
<tr><td><code id="view_+3A_scheme">scheme</code></td>
<td>
<p>Visualization scheme to be used.  A numeric value is
interpreted as one of the (numbered) provided schemes; see source
code for details, as I add new schemes from time to time and the
code would in any case dominate anything written here.
</p>
<p>A default of zero corresponds to Thaller (1998): see references.  
For no colour (ie a white background), set <code>scheme</code> to a
negative number.
</p>
<p>If <code>scheme</code> does not correspond to a built-in function, the
<code>switch()</code> statement &ldquo;drops through&rdquo; and provides a
white background (use this to show just real or imaginary contours;
a value of <code class="reqn">-1</code> will always give this behaviour)
</p>
<p>If not numeric, <code>scheme</code> is interpreted as a function that
produces a colour; see examples section below.  See details section
for some tools that make writing such functions easier</p>
</td></tr>
<tr><td><code id="view_+3A_real.contour">real.contour</code>, <code id="view_+3A_imag.contour">imag.contour</code></td>
<td>
<p>Boolean with default <code>TRUE</code>
meaning to draw contours of constant <code class="reqn">Re(z)</code> (resp: <code class="reqn">Im(z)</code>)
and <code>FALSE</code> meaning not to draw them</p>
</td></tr>
<tr><td><code id="view_+3A_default">default</code></td>
<td>
<p>Complex value to be assumed for colouration, if
<code>z</code> takes <code>NA</code> or infinite values; defaults to zero.
Set to <code>NA</code> for no substitution (ie plot <code>z</code> &ldquo;as is&rdquo;);
usually a bad idea</p>
</td></tr>
<tr><td><code id="view_+3A_col">col</code></td>
<td>
<p>Colour (sent to <code>contour()</code>)</p>
</td></tr>
<tr><td><code id="view_+3A_r0">r0</code></td>
<td>
<p>If <code>scheme=0</code>, radius of Riemann sphere as used by
Thaller</p>
</td></tr>
<tr><td><code id="view_+3A_power">power</code></td>
<td>
<p>Defines a slight generalization of Thaller's scheme.
Use high values to emphasize areas of high modulus (white) and low
modulus (black); use low values to emphasize the argument over the
whole of the function's domain.
</p>
<p>This argument is also applied to some of the other schemes where it
makes sense</p>
</td></tr>
<tr><td><code id="view_+3A_show.scheme">show.scheme</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
perform as advertized and visualize a complex function; and
<code>TRUE</code> meaning to return the function corresponding to the
value of argument <code>scheme</code></p>
</td></tr>
<tr><td><code id="view_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>image()</code> and <code>contour()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The examples given for different values of <code>scheme</code> are intended
as examples only: the user is encouraged to experiment by passing
homemade colour schemes (and indeed to pass such schemes to the
author).
</p>
<p>Scheme 0 implements the ideas of Thaller: the complex plane is mapped
to the Riemann sphere, which is coded with the North pole white
(indicating a pole) and the South Pole black (indicating a zero).  The
equator (that is, complex numbers of modulus <code>r0</code>) maps to
colours of maximal saturation.
</p>
<p>Function <code>view()</code> includes several tools that simplify the
creation of suitable functions for passing to <code>scheme</code>.
</p>
<p>These include:
</p>

<dl>
<dt><code>breakup()</code>:</dt><dd><p>Breaks up a continuous map:
<code>function(x){ifelse(x&gt;1/2,3/2-x,1/2-x)}</code></p>
</dd>
<dt><code>g()</code>:</dt><dd><p>maps positive real to <code class="reqn">[0,1]</code>:
<code>function(x){0.5+atan(x)/pi}</code></p>
</dd>
<dt><code>scale()</code>:</dt><dd><p>scales range to <code class="reqn">[0,1]</code>:
<code>function(x){(x-min(x))/(max(x)-min(x))}</code></p>
</dd>
<dt><code>wrap()</code>:</dt><dd><p>wraps phase to <code class="reqn">[0,1]</code>:
<code>function(x){1/2+x/(2*pi)}</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>Additional ellipsis arguments are given to both <code>image()</code> and
<code>contour()</code> (typically, <code>nlevels</code>).  The resulting
<code>warning()</code> from one or other function is suppressed by
<code>suppressWarnings()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>B. Thaller 1998. <em>Visualization of complex functions</em>, The
Mathematica Journal, 7(2):163&ndash;180
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x &lt;- seq(from=-4,to=4,len=n)
y &lt;- x
z &lt;- outer(x,1i*y,"+")
view(x,y,limit(1/z),scheme=2)
view(x,y,limit(1/z),scheme=18)


view(x,y,limit(1/z+1/(z-1-1i)^2),scheme=5)
view(x,y,limit(1/z+1/(z-1-1i)^2),scheme=17)

view(x,y,log(0.4+0.7i+log(z/2)^2),main="Some interesting cut lines")


view(x,y,z^2,scheme=15,main="try finer resolution")
view(x,y,sn(z,m=1/2+0.3i),scheme=6,nlevels=33,drawlabels=FALSE)

view(x,y,limit(P(z,c(1+2.1i,1.3-3.2i))),scheme=2,nlevels=6,drawlabels=FALSE)
view(x,y,limit(Pdash(z,c(0,1))),scheme=6,nlevels=7,drawlabels=FALSE)
view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=6,scheme=4,col="white")

# Now an example with a bespoke colour function:

 fun &lt;- function(z){hcl(h=360*wrap(Arg(z)),c= 100 * (Mod(z) &lt; 1))}
 view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=6,scheme=fun)

view(scheme=10, show.scheme=TRUE)
</code></pre>

<hr>
<h2 id='WeierstrassP'>Weierstrass P and related functions</h2><span id='topic+WeierstrassP'></span><span id='topic+P'></span><span id='topic+Pdash'></span><span id='topic+sigma'></span><span id='topic+zeta'></span><span id='topic+e18.10.1'></span><span id='topic+e18.10.2'></span><span id='topic+e18.10.3'></span><span id='topic+e18.10.4'></span><span id='topic+e18.10.5'></span><span id='topic+e18.10.6'></span><span id='topic+e18.10.7'></span>

<h3>Description</h3>

<p>Weierstrass elliptic function and its derivative, Weierstrass sigma
function, and the Weierstrass zeta function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P(z, g=NULL, Omega=NULL, params=NULL, use.fpp=TRUE, give.all.3=FALSE, ...)
Pdash(z, g=NULL, Omega=NULL, params=NULL, use.fpp=TRUE, ...)
sigma(z, g=NULL, Omega=NULL, params=NULL, use.theta=TRUE, ...)
zeta(z, g=NULL, Omega=NULL, params=NULL, use.fpp=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WeierstrassP_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="WeierstrassP_+3A_g">g</code></td>
<td>
<p>Invariants <code>g=c(g2,g3)</code>.  Supply exactly one of
(<code>g</code>, <code>Omega</code>, <code>params</code>)</p>
</td></tr>
<tr><td><code id="WeierstrassP_+3A_omega">Omega</code></td>
<td>
<p>Half periods</p>
</td></tr>
<tr><td><code id="WeierstrassP_+3A_params">params</code></td>
<td>
<p>Object with class &ldquo;<code>parameters</code>&rdquo; (typically
provided by  <code>parameters()</code>)</p>
</td></tr>
<tr><td><code id="WeierstrassP_+3A_use.fpp">use.fpp</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to calculate
<code class="reqn">\wp(z^C)</code> where <code class="reqn">z^C</code> is congruent to <code class="reqn">z</code>
in the period lattice.  The default means that accuracy is greater
for large <code class="reqn">z</code> but has the deficiency that slight
discontinuities may appear near parallelogram boundaries</p>
</td></tr>
<tr><td><code id="WeierstrassP_+3A_give.all.3">give.all.3</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return
<code class="reqn">\wp(z)</code> and <code>TRUE</code> meaning to return the other forms given
in equation 18.10.5, p650.  Use <code>TRUE</code> to check for accuracy</p>
</td></tr>
<tr><td><code id="WeierstrassP_+3A_use.theta">use.theta</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to use
theta function forms, and <code>FALSE</code> meaning to use a Laurent
expansion.  Usually, the theta function form is faster, but not
always</p>
</td></tr>
<tr><td><code id="WeierstrassP_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>theta1()</code> and <code>theta1dash()</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>In this package, function <code>sigma()</code> is the Weierstrass sigma
function.  For the number theoretic divisor function also known as
&ldquo;sigma&rdquo;, see <code>divisor()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>R. K. S. Hankin.  <em>Introducing Elliptic, an R package for
Elliptic and Modular Functions</em>.  Journal of Statistical Software,
Volume 15, Issue 7.  February 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 8, p666, RHS:
P(z=0.07 + 0.1i,g=c(10,2))

## Example 8, p666, RHS:
P(z=0.1 + 0.03i,g=c(-10,2))
## Right answer!

## Compare the Laurent series, which also gives the Right Answer (tm):
 P.laurent(z=0.1 + 0.03i,g=c(-10,2))


## Now a nice little plot of the zeta function:
x &lt;- seq(from=-4,to=4,len=100)
z &lt;- outer(x,1i*x,"+")
view(x,x,limit(zeta(z,c(1+1i,2-3i))),nlevels=6,scheme=1)


#now figure 18.5, top of p643:
p &lt;- parameters(Omega=c(1+0.1i,1+1i))
n &lt;- 40

f &lt;- function(r,i1,i2=1)seq(from=r+1i*i1, to=r+1i*i2,len=n)
g &lt;- function(i,r1,r2=1)seq(from=1i*i+r1,to=1i*i+2,len=n)

solid.lines &lt;-
  c(
    f(0.1,0.5),NA,
    f(0.2,0.4),NA,
    f(0.3,0.3),NA,
    f(0.4,0.2),NA,
    f(0.5,0.0),NA,
    f(0.6,0.0),NA,
    f(0.7,0.0),NA,
    f(0.8,0.0),NA,
    f(0.9,0.0),NA,
    f(1.0,0.0)
    )
dotted.lines &lt;-
  c(
    g(0.1,0.5),NA,
    g(0.2,0.4),NA,
    g(0.3,0.3),NA,
    g(0.4,0.2),NA,
    g(0.5,0.0),NA,
    g(0.6,0.0),NA,
    g(0.7,0.0),NA,
    g(0.8,0.0),NA,
    g(0.9,0.0),NA,
    g(1.0,0.0),NA
    )

plot(P(z=solid.lines,params=p),xlim=c(-4,4),ylim=c(-6,0),type="l",asp=1)
lines(P(z=dotted.lines,params=p),xlim=c(-4,4),ylim=c(-6,0),type="l",lty=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
