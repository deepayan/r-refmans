<!DOCTYPE html><html><head><title>Help for package gosset</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gosset}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#akaike_weights'><p>Akaike weights</p></a></li>
<li><a href='#breadwheat'><p>Preferred bread wheat varieties</p></a></li>
<li><a href='#btpermute'><p>Variable selection with Permuted Inclusion Criterion</p></a></li>
<li><a href='#compare'><p>Compare agreement between two methods</p></a></li>
<li><a href='#crossvalidation'><p>Cross-validation</p></a></li>
<li><a href='#gosset'><p>Tools for Data Analysis in Experimental Agriculture</p></a></li>
<li><a href='#kendallTau'><p>Kendall rank correlation coefficient</p></a></li>
<li><a href='#kendallW'><p>Kendall's W (coefficient of concordance)</p></a></li>
<li><a href='#kenyachoice'><p>Kenyan farmers’ preferences for agricultural and livelihood practices</p></a></li>
<li><a href='#nicabean'><p>Common bean on-farm trial in Nicaragua</p></a></li>
<li><a href='#node_labels'><p>Get node labels and rules used in a party tree</p></a></li>
<li><a href='#pseudo_rank'><p>Add pseudo-rank to missing values</p></a></li>
<li><a href='#pseudoR2'><p>Pseudo R-squared</p></a></li>
<li><a href='#rank_numeric'><p>Plackett-Luce rankings from numeric values</p></a></li>
<li><a href='#rank_tricot'><p>Build Plackett-Luce rankings from tricot dataset</p></a></li>
<li><a href='#regret'><p>Regret-based values for risk assessment</p></a></li>
<li><a href='#reliability'><p>Probability of outperforming a check</p></a></li>
<li><a href='#rowbind'><p>Combine R objects by rows</p></a></li>
<li><a href='#set_binomialfreq'><p>Binomial frequency rankings from pairwise contests</p></a></li>
<li><a href='#set_paircomp'><p>Pairwise comparison rankings</p></a></li>
<li><a href='#worth_map'><p>Plot worth parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Data Analysis in Experimental Agriculture</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://agrdatasci.github.io/gosset/">https://agrdatasci.github.io/gosset/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/agrdatasci/gosset/issues">https://github.com/agrdatasci/gosset/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Toolkit to analyse experimental agriculture data, 
    from data synthesis to model selection and visualisation. 
    The package is named after W.S. Gosset aka ‘Student’, a pioneer 
    of modern statistics in small sample experimental design and analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>BradleyTerry2, DescTools, ggplot2, ggparty, ggrepel, partykit,
PlackettLuce, psychotools, qvcalc, stats, tidyr, utils,
patchwork</td>
</tr>
<tr>
<td>Suggests:</td>
<td>climatrends, ClimMobTools, chirps, gnm, knitr, psychotree,
rmarkdown</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-21 13:47:15 UTC; kauefeitosadiasdesousa</td>
</tr>
<tr>
<td>Author:</td>
<td>Kauê de Sousa <a href="https://orcid.org/0000-0002-7571-7845"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jacob van Etten <a href="https://orcid.org/0000-0001-7554-2558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David Brown <a href="https://orcid.org/0000-0003-2859-1618"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jonathan Steinke <a href="https://orcid.org/0000-0001-5742-702X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kauê de Sousa &lt;desousa.kaue@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-21 17:02:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='akaike_weights'>Akaike weights</h2><span id='topic+akaike_weights'></span>

<h3>Description</h3>

<p>Akaike weights represent the relative likelihood of a model.  
It can be used in model averaging and selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>akaike_weights(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="akaike_weights_+3A_object">object</code></td>
<td>
<p>a numerical vector with models goodness of fit coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the coefficients:
</p>
<table>
<tr><td><code>delta</code></td>
<td>
<p>the delta overall change in the coefficients</p>
</td></tr>
<tr><td><code>relative_logLik</code></td>
<td>
<p>the relative log-likelihood</p>
</td></tr>
<tr><td><code>akaike_weights</code></td>
<td>
<p>the Akaike weights</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kauê de Sousa and Jacob van Etten
</p>


<h3>References</h3>

<p>Wagenmakers E. J. &amp; Farrell S. (2004). 
Psychonomic Bulletin and Review, 11(1), 192–196. 
<a href="https://doi.org/10.3758/BF03206482">doi:10.3758/BF03206482</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data("airquality")

# try three model approaches
mod1 = glm(Temp ~ 1,
            data = airquality,
            family = poisson())

mod2 = glm(Temp ~ Ozone,
            data = airquality,
            family = poisson())

mod3 = glm(Temp ~ Ozone + Solar.R,
            data = airquality,
            family = poisson())

# models AICs together in a single vector
models = c(mod1 = AIC(mod1),
            mod2 = AIC(mod2),
            mod3 = AIC(mod3))

# calculate akaike weights
aw = akaike_weights(models)

# the higher the better
names(models[which.max(aw$akaike_weights)])

</code></pre>

<hr>
<h2 id='breadwheat'>Preferred bread wheat varieties</h2><span id='topic+breadwheat'></span>

<h3>Description</h3>

<p>Data from decentralized on-farm trials of bread wheat 
(<em>Triticum aestivum</em> L.) varieties in Vaishali, India over the 
2014's Rabi season. Farmers were asked to test three varieties 
of bread wheat randomly assigned as incomplete blocks of 
three varieties (out of 16 varieties) and assess which one had
the best and worst performance considering 
four traits, germination, grain quality, yield and overall performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breadwheat
</code></pre>


<h3>Format</h3>

<p>A data frame with 493 records and 19 variables:
</p>

<dl>
<dt><code>variety_a</code></dt><dd><p>The name of variety A in the comparison.</p>
</dd>
<dt><code>variety_b</code></dt><dd><p>The name of variety B in the comparison.</p>
</dd>
<dt><code>variety_c</code></dt><dd><p>The name of variety C in the comparison.</p>
</dd>
<dt><code>district</code></dt><dd><p>The administrative region where the experiment was stablished.</p>
</dd>
<dt><code>village</code></dt><dd><p>The village within the administrative region where the 
experiment was stablished.</p>
</dd>
<dt><code>participant_name</code></dt><dd><p>The participant name (ommited for protection and privacy).</p>
</dd>
<dt><code>age</code></dt><dd><p>The participant age.</p>
</dd>
<dt><code>gender</code></dt><dd><p>The participant gender M = Male; F = Female.</p>
</dd>
<dt><code>planting_date</code></dt><dd><p>The date which the experiment started.</p>
</dd>
<dt><code>lon</code></dt><dd><p>The longitude in which the experiment was stablished.</p>
</dd>
<dt><code>lat</code></dt><dd><p>The latitude in which the experiment was stablished.</p>
</dd>
<dt><code>germination_best</code></dt><dd><p>The variety ranked as best for germination (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>germination_worst</code></dt><dd><p>The variety ranked as worst for germination (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>grainquality_best</code></dt><dd><p>The variety ranked as best for grain quality (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>grainquality_worst</code></dt><dd><p>The variety ranked as worst for grain quality (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>yield_best</code></dt><dd><p>The variety ranked as best for yield (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>yield_worst</code></dt><dd><p>The variety ranked as worst for yield (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>overall_best</code></dt><dd><p>The variety ranked as best for overall perfomance (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>overall_worst</code></dt><dd><p>The variety ranked as worst for overall perfomance (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were provided by Bioversity International <a href="https://www.bioversityinternational.org/">https://www.bioversityinternational.org/</a>, 
a CGIAR Research Centre, through the ClimMob platform <a href="https://climmob.net">https://climmob.net</a>.
</p>

<hr>
<h2 id='btpermute'>Variable selection with Permuted Inclusion Criterion</h2><span id='topic+btpermute'></span>

<h3>Description</h3>

<p>Method of forward variable selection based on deviance for Bradley-Terry
models using pairwise ranking data. The selection procedure consists of two steps, 
first, permuting the variables from the original <code>predictors</code> with 
<code>n.iteractions</code>, then performing a forward selection to retain the
<code>predictors</code> with highest contribution to the model, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btpermute(
  contests = NULL,
  predictors = NULL,
  n.iterations = 15,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btpermute_+3A_contests">contests</code></td>
<td>
<p>a data frame with pairwise binary contests with these variables
'id','player1','player2','win1','win2'; in that order. The id should be equivalent 
to the index of each row in <code>predictors</code></p>
</td></tr>
<tr><td><code id="btpermute_+3A_predictors">predictors</code></td>
<td>
<p>a data frame with player-specific variables with row indices that 
should match with the ids in <code>contests</code>. An id is not required, only the 
predictor variables, the ids are the index for each row</p>
</td></tr>
<tr><td><code id="btpermute_+3A_n.iterations">n.iterations</code></td>
<td>
<p>integer, number of iterations to compute</p>
</td></tr>
<tr><td><code id="btpermute_+3A_seed">seed</code></td>
<td>
<p>integer, the seed for random number generation. If NULL (the default), 
<span class="pkg">gosset</span> will set the seed randomly</p>
</td></tr>
<tr><td><code id="btpermute_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <span class="pkg">BradleyTerry2</span> methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection procedure consists of two steps. In the first step, <code>btpermute</code> 
adds to the set of original (candidate) <code>predictors</code> variables
an additional set of 'fake', permuted variables. This set of permuted 
<code>predictors</code> is created 
by assigning to each ranking the variables from another, randomly selected 
ranking. The permuted variables are not expected to have any predictive 
power for pairwise rankings. In the second step, <code>btpermute</code> adds 
predictors to the Bradley-Terry model in a forward selection procedure. 
Each <code>predictors</code> (real and permuted) is added to the null model 
individually, and <code>btpermute</code> retains which variable reduces model 
deviance most strongly. The two-step process is replicated <code>n</code> times 
with argument <code>n.iterations</code>. At each iteration, a new random permutation 
is generated and all variables are tested. Replicability can be controlled 
using argument <code>seed</code>. Across the n <code>n.iterations</code>, the function 
identifies the predictor that appeared most often as the most deviance-reducing 
one. When this is a real variable, it is constantly added to the model and 
the forward selection procedure moves on – again creating new permutations, 
adding real and fake variables individually, and examining model deviance. 
Variable selection stops when a permuted variable is found to be most 
frequently the most deviance-reducing <code>predictors</code> across <code>n.iterations</code>. 
In turn, variable selection continuous as long as any real variable has stronger 
explanatory power for pairwise rankings than the random variables.
</p>


<h3>Value</h3>

<p>an object of class <code>gosset_btpermute</code> with the final <code>BTm()</code> model,
selected variables, seeds (random numbers) used for permutations and deviances
</p>


<h3>Author(s)</h3>

<p>Jonathan Steinke and Kauê de Sousa
</p>


<h3>References</h3>

<p>Lysen, S. (2009) Permuted inclusion criterion: A variable selection technique. 
University of Pennsylvania
<a href="https://repository.upenn.edu/edissertations/28/">https://repository.upenn.edu/edissertations/28/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_binomialfreq">set_binomialfreq</a></code>, <code><a href="BradleyTerry2.html#topic+BTm">BTm</a></code>
</p>
<p>Other model selection functions: 
<code><a href="#topic+crossvalidation">crossvalidation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require("BradleyTerry2")

data("kenyachoice", package = "gosset")

mod &lt;- btpermute(contests = kenyachoice$contests,
                 predictors = kenyachoice$predictors,
                 n.iterations = 10,
                 seed = 1)

mod

</code></pre>

<hr>
<h2 id='compare'>Compare agreement between two methods</h2><span id='topic+compare'></span><span id='topic+compare.default'></span><span id='topic+compare.PlackettLuce'></span>

<h3>Description</h3>

<p>Measures the agreement between two methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(x, y, ...)

## Default S3 method:
compare(x, y, labels = NULL, ...)

## S3 method for class 'PlackettLuce'
compare(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_x">x</code></td>
<td>
<p>a numeric vector, or an object
of class <code>PlackettLuce</code></p>
</td></tr>
<tr><td><code id="compare_+3A_y">y</code></td>
<td>
<p>a numeric vector, or an object
of class <code>PlackettLuce</code></p>
</td></tr>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="compare_+3A_labels">labels</code></td>
<td>
<p>optional, a vector with the same length <var>x</var>
to plot values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot with the agreement
</p>


<h3>References</h3>

<p>Bland, M. J., and Altman, D. G. (1986).
Lancet (8476):307-10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = runif(10, -1, 2)

set.seed(2)
y = runif(10, -1, 2)

compare(x, y)

</code></pre>

<hr>
<h2 id='crossvalidation'>Cross-validation</h2><span id='topic+crossvalidation'></span><span id='topic+AIC.bttree'></span><span id='topic+deviance.bttree'></span><span id='topic+deviance.pltree'></span><span id='topic+AIC.gnm'></span><span id='topic+deviance.gnm'></span>

<h3>Description</h3>

<p>Methods for measuring the performance of a predictive model on sets of 
test data in Bradley-Terry model from <span class="pkg">psychotree</span>, Generalized Linear and 
Generalized Nonlinear models from <span class="pkg">gnm</span>, and Plackett-Luce model from 
<span class="pkg">PlackettLuce</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossvalidation(formula, data, k = 10, folds = NULL, seed = NULL, ...)

## S3 method for class 'bttree'
AIC(object, newdata = NULL, ...)

## S3 method for class 'bttree'
deviance(object, newdata = NULL, ...)

## S3 method for class 'pltree'
deviance(object, newdata = NULL, ...)

## S3 method for class 'gnm'
AIC(object, newdata = NULL, ...)

## S3 method for class 'gnm'
deviance(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossvalidation_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be 
coerced to that class): a symbolic description of the model to be fitted,
of the form <code class="reqn">y ~ x1 + ... + xn</code></p>
</td></tr>
<tr><td><code id="crossvalidation_+3A_data">data</code></td>
<td>
<p>a data frame (or object coercible by as.data.frame to a data frame)
containing the variables in the model</p>
</td></tr>
<tr><td><code id="crossvalidation_+3A_k">k</code></td>
<td>
<p>an integer for the number of bins in the cross-validation</p>
</td></tr>
<tr><td><code id="crossvalidation_+3A_folds">folds</code></td>
<td>
<p>an optional vector or list of vectors specifying the <var>k</var>-folds 
in the cross-validation</p>
</td></tr>
<tr><td><code id="crossvalidation_+3A_seed">seed</code></td>
<td>
<p>integer, the seed for random number generation. If <code>NULL</code> (the default), 
<span class="pkg">gosset</span> will set the seed randomly</p>
</td></tr>
<tr><td><code id="crossvalidation_+3A_...">...</code></td>
<td>
<p>additional arguments passed the methods of the chosen model</p>
</td></tr>
<tr><td><code id="crossvalidation_+3A_object">object</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="crossvalidation_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame with test data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>gosset_cv</code> with the cross-validation 
goodness-of-fit estimates, which are:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike Information Criterion</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Model deviance</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Log-Likelihood</p>
</td></tr>
<tr><td><code>MaxLik</code></td>
<td>
<p>Maximum likelihood pseudo R-squared</p>
</td></tr>
<tr><td><code>CraggUhler</code></td>
<td>
<p>Cragg and Uhler's pseudo R-squared</p>
</td></tr>
<tr><td><code>McFadden</code></td>
<td>
<p>McFadden pseudo R-squared</p>
</td></tr>
<tr><td><code>kendallTau</code></td>
<td>
<p>the Kendall correlation coefficient</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kauê de Sousa, Jacob van Etten and David Brown
</p>


<h3>References</h3>

<p>Elder J. F. (2003). Journal of Computational and Graphical Statistics, 
12(4), 853–864. <a href="https://doi.org/10.1198/1061860032733">doi:10.1198/1061860032733</a>
</p>
<p>James G., et al. (2013). <a href="https://doi.org/10.1007/978-1-4614-7138-7">doi:10.1007/978-1-4614-7138-7</a>
</p>
<p>Whitlock M. C. (2005). Journal of Evolutionary Biology, 18(5), 1368–1373. 
<a href="https://doi.org/10.1111/j.1420-9101.2005.00917.x">doi:10.1111/j.1420-9101.2005.00917.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="psychotree.html#topic+bttree">bttree</a></code>, 
<code><a href="gnm.html#topic+gnm">gnm</a></code>,
<code><a href="PlackettLuce.html#topic+pltree">pltree</a></code>
</p>
<p>Other model selection functions: 
<code><a href="#topic+btpermute">btpermute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generalized Linear Models
if (require("gnm")) {
data("airquality")

cv = crossvalidation(Temp ~ Wind + Solar.R,
                      data = airquality,
                      k = 3,
                      seed = 999,
                      family = poisson())
}                    
# Plackett-Luce Model
if(require("PlackettLuce")) {
# beans data from PlackettLuce
data("beans", package = "PlackettLuce")

G = rank_tricot(data = beans,
                 items = c(1:3),
                 input = c(4:5),
                 additional.rank = beans[c(6:8)],
                 group = TRUE)

beans = cbind(G, beans)

# take seasons as bins
k = length(unique(beans$season))
folds = as.integer(as.factor(beans$season))

cv = crossvalidation(G ~ maxTN,
                      data = beans,
                      k = k,
                      folds = folds,
                      minsize = 100)
}

                
</code></pre>

<hr>
<h2 id='gosset'>Tools for Data Analysis in Experimental Agriculture</h2><span id='topic+gosset'></span><span id='topic+gosset-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Toolkit to analyse experimental agriculture data, from data synthesis to model selection and visualisation. The package is named after W.S. Gosset aka ‘Student’, a pioneer of modern statistics in small sample experimental design and analysis.
</p>


<h3>Author(s)</h3>

<p>Kauê de Sousa and Jacob van Etten 
and David Brown and Jonathan Steinke
</p>


<h3>See Also</h3>

<p><strong>Useful links:</strong>
</p>

<ul>
<li><p>gosset paper: 
<a href="https://doi.org/10.2139/ssrn.4236267">doi:10.2139/ssrn.4236267</a>
</p>
</li>
<li><p>Development repository: 
<a href="https://github.com/AgrDataSci/gosset">https://github.com/AgrDataSci/gosset</a>
</p>
</li>
<li><p>Static documentation: 
<a href="https://AgrDataSci.github.io/gosset/">https://AgrDataSci.github.io/gosset/</a>
</p>
</li>
<li><p>Report bugs: 
<a href="https://github.com/AgrDataSci/gosset/issues">https://github.com/AgrDataSci/gosset/issues</a>
</p>
</li></ul>


<hr>
<h2 id='kendallTau'>Kendall rank correlation coefficient</h2><span id='topic+kendallTau'></span><span id='topic+kendallTau.default'></span><span id='topic+kendallTau.matrix'></span><span id='topic+kendallTau.rankings'></span><span id='topic+kendallTau.grouped_rankings'></span><span id='topic+kendallTau.paircomp'></span>

<h3>Description</h3>

<p>Compute Kendall rank correlation coefficient between two objects. 
Kendall is a coefficient used in statistics to measure the ordinal 
association between two measured quantities. A tau test is a non-parametric 
hypothesis test for statistical dependence based on the tau coefficient.
The 'kendallTau' function applies the &quot;kendall&quot; method from 'stats::cor' 
with some previous treatment in the data, such as converting floating numbers
into ranks (from the higher being the first and negative being the last) 
and the possibility to remove zeros from incomplete ranks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kendallTau(x, y, null.rm = TRUE, average = TRUE, na.omit = FALSE, ...)

## Default S3 method:
kendallTau(x, y, null.rm = TRUE, ...)

## S3 method for class 'matrix'
kendallTau(x, y, null.rm = TRUE, average = TRUE, na.omit = FALSE, ...)

## S3 method for class 'rankings'
kendallTau(x, y, ...)

## S3 method for class 'grouped_rankings'
kendallTau(x, y, ...)

## S3 method for class 'paircomp'
kendallTau(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kendallTau_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame</p>
</td></tr>
<tr><td><code id="kendallTau_+3A_y">y</code></td>
<td>
<p>a vector, matrix or data frame with compatible dimensions to <code>x</code></p>
</td></tr>
<tr><td><code id="kendallTau_+3A_null.rm">null.rm</code></td>
<td>
<p>logical, to remove zeros from <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="kendallTau_+3A_average">average</code></td>
<td>
<p>logical, if <code>FALSE</code> returns the kendall and N-effective for each entry</p>
</td></tr>
<tr><td><code id="kendallTau_+3A_na.omit">na.omit</code></td>
<td>
<p>logical, if <code>TRUE</code> ignores entries with kendall = NA when computing the average</p>
</td></tr>
<tr><td><code id="kendallTau_+3A_...">...</code></td>
<td>
<p>further arguments affecting the Kendall tau produced. See details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Kendall correlation coefficient and the Effective N, which 
is the equivalent N needed if all items were compared to all items. 
Can be used for significance testing.
</p>


<h3>Author(s)</h3>

<p>Kauê de Sousa and Jacob van Etten
</p>


<h3>References</h3>

<p>Kendall M. G. (1938). Biometrika, 30(1–2), 81–93. 
<a href="https://doi.org/10.1093/biomet/30.1-2.81">doi:10.1093/biomet/30.1-2.81</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>
</p>
<p>Other goodness-of-fit functions: 
<code><a href="#topic+kendallW">kendallW</a>()</code>,
<code><a href="#topic+pseudoR2">pseudoR2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Vector based example same as stats::cor(x, y, method = "kendall")
# but showing N-effective
x = c(1, 2, 3, 4, 5)

y = c(1, 1, 3, 2, NA)

w = c(1, 1, 3, 2, 5)

kendallTau(x, y)

kendallTau(x, w)

# Matrix and PlacketLuce ranking example 

library("PlackettLuce")
 
R = matrix(c(1, 2, 4, 3,
             1, 4, 2, 3,
             1, 2, NA, 3,
             1, 2, 4, 3,
             1, 3, 4, 2,
             1, 4, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) = LETTERS[1:4]

G = group(as.rankings(R), 1:6)

mod = pltree(G ~ 1, data = G)

preds = predict(mod)

kendallTau(R, preds)

# Also returns raw values (no average) 

kendallTau(R, preds, average = FALSE)

# Choose to ignore entries with NA
R2 = matrix(c(1, 2, 4, 3,
              1, 4, 2, 3,
              NA, NA, NA, NA,
              1, 2, 4, 3,
              1, 3, 4, 2,
              1, 4, 3, 2), nrow = 6, byrow = TRUE)

kendallTau(R, R2, average = FALSE)

kendallTau(R, R2, average = TRUE)

kendallTau(R, R2, average = TRUE, na.omit = TRUE)

</code></pre>

<hr>
<h2 id='kendallW'>Kendall's W (coefficient of concordance)</h2><span id='topic+kendallW'></span><span id='topic+kendallW.default'></span><span id='topic+kendallW.pltree'></span>

<h3>Description</h3>

<p>Compute Kendall's W, also known as coefficient of concordance among observed rankings
and those predicted by the Plackett-Luce model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kendallW(x, ...)

## Default S3 method:
kendallW(x, y, ...)

## S3 method for class 'pltree'
kendallW(x, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kendallW_+3A_x">x</code></td>
<td>
<p>an object of class <code>pltree</code></p>
</td></tr>
<tr><td><code id="kendallW_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="kendallW_+3A_y">y</code></td>
<td>
<p>an object of class <code>pltree</code></p>
</td></tr>
<tr><td><code id="kendallW_+3A_newdata">newdata</code></td>
<td>
<p>data for predictions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is as wrapper of the function DescTools::KendallW, adapted to compute the Kendall's W
on the observed and predicted rankings.
</p>
<p>Kendall's W values range between 0 (no agreement) to 1 (full agreement)
</p>


<h3>Value</h3>

<p>Kendall's W (coefficient of concordance)
</p>


<h3>Author(s)</h3>

<p>David Brown and Jacob van Etten
</p>


<h3>See Also</h3>

<p>Other goodness-of-fit functions: 
<code><a href="#topic+kendallTau">kendallTau</a>()</code>,
<code><a href="#topic+pseudoR2">pseudoR2</a>()</code>
</p>

<hr>
<h2 id='kenyachoice'>Kenyan farmers’ preferences for agricultural and livelihood practices</h2><span id='topic+kenyachoice'></span>

<h3>Description</h3>

<p>Data from a preference experiment in Makueni County, Kenya. Twenty-six 
smallholder farmers ordered 9 different livelihood improvement practices
by their personal preference. Full rankings were broken down into 
multiple pairwise rankings (<code>kenyachoice[["contests"]]</code>). To each 
respondent, a set of nine socio-economic variables is available 
(<code>kenyachoice[["predictors"]]</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kenyachoice
</code></pre>


<h3>Format</h3>

<p>A list with two dataframes. <code>kenyachoice[["contests"]]</code> contains 
the pairwise rankings from farmers choices. <code>kenyachoice[["predictors"]]</code>
contains the socioeconomic data for each farmer.
Codes for contests are described:
</p>

<dl>
<dt><code>B</code></dt><dd><p>Opening a business</p>
</dd>
<dt><code>D</code></dt><dd><p>Dry planting</p>
</dd>
<dt><code>G</code></dt><dd><p>Collective crop marketing</p>
</dd>
<dt><code>J</code></dt><dd><p>Finding off-farm job</p>
</dd>
<dt><code>M</code></dt><dd><p>Machine tillage</p>
</dd>
<dt><code>O</code></dt><dd><p>Renting out traction animals</p>
</dd>
<dt><code>R</code></dt><dd><p>Mulching</p>
</dd>
<dt><code>T</code></dt><dd><p>Terracing</p>
</dd>
<dt><code>Z</code></dt><dd><p>Zai pits</p>
</dd>  
</dl>



<h3>Source</h3>

<p>Steinke, J., et. al. (2019). 
Computers and Electronics in Agriculture, 162, 991–1000.
<a href="https://doi.org/10.1016/j.compag.2019.05.026">doi:10.1016/j.compag.2019.05.026</a>
</p>

<hr>
<h2 id='nicabean'>Common bean on-farm trial in Nicaragua</h2><span id='topic+nicabean'></span>

<h3>Description</h3>

<p>Data from decentralized on-farm trials of common bean 
(<em>Phaseolus vulgaris</em> L.) varieties in Nicaragua over
five seasons between 2015 and 2016. Following the tricot approach, 
farmers were asked to test three varieties of common bean randomly 
assigned as incomplete blocks of three varieties (out of 10 varieties) 
and assess which of those three had the best and worst performance in 
nine traits (Vigor, Architecture, Resistance to Pests, Resistance to 
Diseases, Tolerance to Drought, Yield, Marketability, Taste, and Overall 
Appreciation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nicabean
</code></pre>


<h3>Format</h3>

<p>A list with two data frames, 
<code>nicabean[["trial"]]</code> contains the trial data:
</p>

<dl>
<dt><code>id</code></dt><dd><p>the plot id</p>
</dd>
<dt><code>item</code></dt><dd><p>the variety name</p>
</dd>
<dt><code>trait</code></dt><dd><p>the trait for the given variety and plot id</p>
</dd>
<dt><code>rank</code></dt><dd><p>the rank for the given variety and trait, with 1 being higher and 3 the lowest</p>
</dd>
</dl>

<p><code>nicabean[["bean_covar"]]</code> contains the covariates associated with the data:
</p>

<dl>
<dt><code>id</code></dt><dd><p>the plot id</p>
</dd>
<dt><code>adm0</code></dt><dd><p>the country name where trials were set</p>
</dd>
<dt><code>longitude</code></dt><dd><p>the longitude of the trial plot</p>
</dd>
<dt><code>latitude</code></dt><dd><p>the latitude of the trial plot</p>
</dd>
<dt><code>trial</code></dt><dd><p>the trial name as registered on ClimMob</p>
</dd>
<dt><code>variety_a</code></dt><dd><p>the variety assigned as label A in the incomplete block</p>
</dd>
<dt><code>variety_b</code></dt><dd><p>the variety assigned as label B in the incomplete block</p>
</dd>
<dt><code>variety_c</code></dt><dd><p>the variety assigned as label C in the incomplete block</p>
</dd>
<dt><code>planting_date</code></dt><dd><p>the planting date</p>
</dd>
<dt><code>gender</code></dt><dd><p>the farmer gender</p>
</dd>
<dt><code>age</code></dt><dd><p>the farmer age</p>
</dd>
</dl>



<h3>Source</h3>

<p>van Etten, J., et. al. (2016). 
Experimental Agriculture, 55, 275-296.
<a href="https://doi.org/10.1017/S0014479716000739">doi:10.1017/S0014479716000739</a>
</p>
<p>van Etten, J., et. al. (2019). 
PNAS 116(10) 4194-4199
<a href="https://doi.org/10.1073/pnas.1813720116">doi:10.1073/pnas.1813720116</a>
</p>

<hr>
<h2 id='node_labels'>Get node labels and rules used in a party tree</h2><span id='topic+node_labels'></span><span id='topic+node_rules'></span><span id='topic+top_items'></span><span id='topic+plot.pltree'></span>

<h3>Description</h3>

<p>Returns the covariates used to split a recursive
partitioning tree and the rules that were applied 
to build the tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_labels(x)

node_rules(x)

top_items(x, top = 5)

## S3 method for class 'pltree'
plot(x, log = TRUE, ref = NULL, ci.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_labels_+3A_x">x</code></td>
<td>
<p>an object of class <code>party</code></p>
</td></tr>
<tr><td><code id="node_labels_+3A_top">top</code></td>
<td>
<p>an integer for the number of items to return</p>
</td></tr>
<tr><td><code id="node_labels_+3A_log">log</code></td>
<td>
<p>logical, if <code>TRUE</code> log-worth coefficients are 
displayed instead of worth</p>
</td></tr>
<tr><td><code id="node_labels_+3A_ref">ref</code></td>
<td>
<p>optional, character for the reference item when
<var>log</var> = <code>TRUE</code></p>
</td></tr>
<tr><td><code id="node_labels_+3A_ci.level">ci.level</code></td>
<td>
<p>an integer for the confidence interval levels</p>
</td></tr>
<tr><td><code id="node_labels_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument multcomp = TRUE adds multi-comparison letters from multcompView
</p>


<h3>Value</h3>

<p>a vector with the node labels, 
a data.frame with node rules, a ggplot
</p>


<h3>Author(s)</h3>

<p>Kauê de Sousa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("PlackettLuce")
data("beans", package = "PlackettLuce")
G = rank_tricot(data = beans,
                 items = c(1:3),
                 input = c(4:5),
                 group = TRUE,
                 additional.rank = beans[c(6:8)])
 
pld = cbind(G, beans[,c("maxTN", "season", "lon")])

tree = pltree(G ~ maxTN + season + lon, data = pld)

node_labels(tree)

node_rules(tree)

top_items(tree)

plot(tree)

plot(tree, log = TRUE)

</code></pre>

<hr>
<h2 id='pseudo_rank'>Add pseudo-rank to missing values</h2><span id='topic+pseudo_rank'></span>

<h3>Description</h3>

<p>Add pseudo-rank to missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_rank(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_rank_+3A_object">object</code></td>
<td>
<p>a matrix or PlackettLuce rank</p>
</td></tr>
<tr><td><code id="pseudo_rank_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix or PlackettLuce rank
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PlackettLuce")
R = matrix(c(1, 2, 0, 0,
              4, 1, 0, 3,
              2, 1, 0, 3,
              1, 2, 0, 0,
              2, 1, 0, 0,
              1, 0, 0, 2), nrow = 6, byrow = TRUE)
colnames(R) = c("apple", "banana", "orange", "pear")

# summary(PlackettLuce(R))

R = pseudo_rank(R)

summary(PlackettLuce(R))
</code></pre>

<hr>
<h2 id='pseudoR2'>Pseudo R-squared</h2><span id='topic+pseudoR2'></span><span id='topic+pseudoR2.default'></span><span id='topic+pseudoR2.pltree'></span><span id='topic+pseudoR2.bttree'></span>

<h3>Description</h3>

<p>Regression coefficient to evaluate goodness-of-fit in a given model when 
ordinary least squares (OLS) are not available. The algorithm computes estimates 
from the maximum likelihood through an iterative process. These estimates are called 
'pseudo R-squared' because they look like 'R-squared' in the sense that they are on 
a similar scale (from 0 to 1), with higher values indicating better model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoR2(object, ...)

## Default S3 method:
pseudoR2(object, ...)

## S3 method for class 'pltree'
pseudoR2(object, newdata = NULL, ...)

## S3 method for class 'bttree'
pseudoR2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoR2_+3A_object">object</code></td>
<td>
<p>a model object of class glm, gnm, lm, pltree or bttree</p>
</td></tr>
<tr><td><code id="pseudoR2_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the R-squared produced</p>
</td></tr>
<tr><td><code id="pseudoR2_+3A_newdata">newdata</code></td>
<td>
<p>a data.set with testing data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the pseudo R-squared coefficients:
</p>
<table>
<tr><td><code>logLik</code></td>
<td>
<p>log-likelihood</p>
</td></tr>
<tr><td><code>logLikNull</code></td>
<td>
<p>Null log-likelihood</p>
</td></tr>
<tr><td><code>MaxLik</code></td>
<td>
<p>maximum likelihood pseudo R-squared</p>
</td></tr>
<tr><td><code>CraggUhler</code></td>
<td>
<p>Cragg and Uhler's pseudo R-squared</p>
</td></tr>
<tr><td><code>McFadden</code></td>
<td>
<p>McFadden pseudo R-squared</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kauê de Sousa and Jacob van Etten
</p>


<h3>References</h3>

<p>Agresti A. (2002). Categorical Data Analysis. John Wiley &amp; Sons, Inc., 
Hoboken, NJ, USA. doi:10.1002/0471249688
</p>
<p>Hunter D. R. (2004). The Annals of Statistics, 32(1), 384–406. 
http://www.jstor.org/stable/3448514
</p>
<p>Cragg, J. G., &amp; Uhler, R. S. (1970). The Canadian Journal of 
Economics 3(3), 386-406. doi:10.2307/133656
</p>
<p>McFadden, D. (1973). Conditional logit analysis of qualitative choice behavior.
</p>


<h3>See Also</h3>

<p>Other goodness-of-fit functions: 
<code><a href="#topic+kendallTau">kendallTau</a>()</code>,
<code><a href="#topic+kendallW">kendallW</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("airquality")

mod = glm(Temp ~ Wind + Solar.R,
           data = airquality,
           family = poisson())

pseudoR2(mod)

</code></pre>

<hr>
<h2 id='rank_numeric'>Plackett-Luce rankings from numeric values</h2><span id='topic+rank_numeric'></span>

<h3>Description</h3>

<p>Group and coerce numeric values into Plackett-Luce rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_numeric(
  data,
  items,
  input,
  id = NULL,
  group = FALSE,
  ascending = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_numeric_+3A_data">data</code></td>
<td>
<p>a data.frame with columns specified by items and input values</p>
</td></tr>
<tr><td><code id="rank_numeric_+3A_items">items</code></td>
<td>
<p>a character or numerical vector for indexing the column(s) 
containing the item names in <code>data</code></p>
</td></tr>
<tr><td><code id="rank_numeric_+3A_input">input</code></td>
<td>
<p>a character or numerical vector for indexing the column(s) 
containing the values in <code>data</code> to be ranked</p>
</td></tr>
<tr><td><code id="rank_numeric_+3A_id">id</code></td>
<td>
<p>an index of <code>data</code> indicating the 
ids for &quot;long&quot; <code>data</code></p>
</td></tr>
<tr><td><code id="rank_numeric_+3A_group">group</code></td>
<td>
<p>logical, if <code>TRUE</code> return an object of class &quot;grouped_rankings&quot;</p>
</td></tr>
<tr><td><code id="rank_numeric_+3A_ascending">ascending</code></td>
<td>
<p>logical, only for floating point numbers, to 
compute rankings from lower to higher values</p>
</td></tr>
<tr><td><code id="rank_numeric_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a PlackettLuce &quot;rankings&quot; object, which is a matrix 
of dense rankings
</p>


<h3>Author(s)</h3>

<p>Kauê de Sousa
</p>


<h3>See Also</h3>

<p><code><a href="PlackettLuce.html#topic+rankings">rankings</a></code>
</p>
<p>Other rank functions: 
<code><a href="#topic+rank_tricot">rank_tricot</a>()</code>,
<code><a href="#topic+set_binomialfreq">set_binomialfreq</a>()</code>,
<code><a href="#topic+set_paircomp">set_paircomp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A matrix with 10 rankings of 5 items (A, B, C, D, E)
# with numeric values as "rank"
set.seed(123)
df = cbind(id = rep(1:10, each = 5),
            items = rep(LETTERS[1:5], times = 10),
            input = runif(50, 1, 3))

# return an object of class 'rankings'
R = rank_numeric(df,
                  items = 2,
                  input = 3,
                  id = 1)

# rankings can be computed in ascending order
R = rank_numeric(df,
                  items = 2,
                  input = 3,
                  id = 1,
                  ascending = TRUE)


# return an object of class 'grouped_rankings'
R = rank_numeric(df,
                  items = 2,
                  input = 3,
                  id = 1,
                  group = TRUE)

</code></pre>

<hr>
<h2 id='rank_tricot'>Build Plackett-Luce rankings from tricot dataset</h2><span id='topic+rank_tricot'></span>

<h3>Description</h3>

<p>Create an object of class &quot;rankings&quot; from tricot data. Tricot stands 
for &quot;triadic comparison of technology options&quot;. Is an approach to carry out 
large decentralized agronomic field experiments as incomplete blocks. 
Each incomplete block contains a set of three randomised technologies 
out of a larger set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_tricot(
  data,
  items,
  input,
  group = FALSE,
  validate.rankings = FALSE,
  additional.rank = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_tricot_+3A_data">data</code></td>
<td>
<p>a data.frame with columns specified by items and input values</p>
</td></tr>
<tr><td><code id="rank_tricot_+3A_items">items</code></td>
<td>
<p>a character or numerical vector for indexing the column(s) 
containing the item names in <code>data</code></p>
</td></tr>
<tr><td><code id="rank_tricot_+3A_input">input</code></td>
<td>
<p>a character or numerical vector for indexing the column(s) 
containing the values in <code>data</code> to be ranked</p>
</td></tr>
<tr><td><code id="rank_tricot_+3A_group">group</code></td>
<td>
<p>logical, if <code>TRUE</code> return an object of class &quot;grouped_rankings&quot;</p>
</td></tr>
<tr><td><code id="rank_tricot_+3A_validate.rankings">validate.rankings</code></td>
<td>
<p>logical, if <code>TRUE</code> implements a check on ranking consistency 
looking for possible ties, NA or letters other than A, B, C. These entries are set to 0</p>
</td></tr>
<tr><td><code id="rank_tricot_+3A_additional.rank">additional.rank</code></td>
<td>
<p>optional, a data frame for the comparisons between 
tricot items and the local item</p>
</td></tr>
<tr><td><code id="rank_tricot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>full.output: logical, to return a list with a &quot;rankings&quot;, 
a &quot;grouped_rankings&quot; and the ordered items
</p>


<h3>Value</h3>

<p>a PlackettLuce &quot;rankings&quot; object, which is a matrix of dense rankings
</p>


<h3>Author(s)</h3>

<p>Kauê de Sousa and Jacob van Etten, with ideas from Heather Turner
</p>


<h3>References</h3>

<p>van Etten J., et al. (2016). Experimental Agriculture, 55(S1), 275–296.
<a href="https://doi.org/10.1017/S0014479716000739">doi:10.1017/S0014479716000739</a>
</p>


<h3>See Also</h3>

<p><code><a href="PlackettLuce.html#topic+rankings">rankings</a></code>, <code><a href="#topic+breadwheat">breadwheat</a></code>
</p>
<p>Other rank functions: 
<code><a href="#topic+rank_numeric">rank_numeric</a>()</code>,
<code><a href="#topic+set_binomialfreq">set_binomialfreq</a>()</code>,
<code><a href="#topic+set_paircomp">set_paircomp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("PlackettLuce")
data("beans", package = "PlackettLuce")

# Using a subset of the bean data
beans = beans[1:5, 1:5]
beans[1, 1] = NA
beans[3, 4:5] = NA
beans[5, 5] = "Tie"

# The default approach do not validate rankings
# accepting any entry used in the argument input
R1 = rank_tricot(beans,
                 items = c(1:3),
                 input = c(4:5), 
                 group = FALSE)

# Using validate.rankings = TRUE, the rankings
# are only considered for those entries without 
# NAs, Ties and with any of the letters A, B, C
# this do not affect the lenght of the final ranking 
R2 = rank_tricot(beans,
                 items = c(1:3),
                 input = c(4:5),
                 validate.rankings = TRUE,
                 group = FALSE)

coef(PlackettLuce(R1))

coef(PlackettLuce(R2))

############################################################

# pass the comparison with local item as an additional rankings, then
# each of the 3 varieties are compared separately with the local item
# and return an object of class grouped_rankings

data("beans", package = "PlackettLuce")

G = rank_tricot(data = beans,
                 items = c(1:3),
                 input = c(4:5),
                 group = TRUE,
                 additional.rank = beans[c(6:8)])

head(G)

</code></pre>

<hr>
<h2 id='regret'>Regret-based values for risk assessment</h2><span id='topic+regret'></span><span id='topic+regret.default'></span><span id='topic+regret.pltree'></span><span id='topic+regret.list'></span>

<h3>Description</h3>

<p>Regret is an important heuristic in the behavioural sciences. 
Minimizing worst regret (the loss under the worst possible 
outcome) is a criterion that takes a conservative approach 
to risk analysis in diversification strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regret(object, ..., bootstrap = TRUE, normalize = TRUE)

## Default S3 method:
regret(object, ..., values, items, group, bootstrap = TRUE, normalize = TRUE)

## S3 method for class 'pltree'
regret(object, bootstrap = TRUE, normalize = TRUE, ...)

## S3 method for class 'list'
regret(object, bootstrap = TRUE, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regret_+3A_object">object</code></td>
<td>
<p>a data.frame, an object of class <code>pltree</code>, or a 
list with <code>PlackettLuce</code> models</p>
</td></tr>
<tr><td><code id="regret_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods</p>
</td></tr>
<tr><td><code id="regret_+3A_bootstrap">bootstrap</code></td>
<td>
<p>logical, to run a bayes bootstrap on <var>object</var></p>
</td></tr>
<tr><td><code id="regret_+3A_normalize">normalize</code></td>
<td>
<p>logical, to normalize values to sum to 1</p>
</td></tr>
<tr><td><code id="regret_+3A_values">values</code></td>
<td>
<p>an index in <var>object</var> with the values to compute regret</p>
</td></tr>
<tr><td><code id="regret_+3A_items">items</code></td>
<td>
<p>an index in  <var>object</var> for the different items</p>
</td></tr>
<tr><td><code id="regret_+3A_group">group</code></td>
<td>
<p>an index in <var>object</var> for the different scenarios</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with regret estimates
</p>
<table>
<tr><td><code>items</code></td>
<td>
<p>the item names</p>
</td></tr>
<tr><td><code>worth</code></td>
<td>
<p>the worth parameters</p>
</td></tr>
<tr><td><code>regret</code></td>
<td>
<p>the squared regret</p>
</td></tr>
<tr><td><code>worst_regret</code></td>
<td>
<p>the worst regret</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob van Etten and Kauê de Sousa
</p>


<h3>References</h3>

<p>Loomes G. &amp; Sugden R. (1982). 
The Economic Journal, 92(368), 805. 
<a href="https://doi.org/10.2307/2232669">doi:10.2307/2232669</a>
</p>
<p>Bleichrodt H. &amp; Wakker P. P. (2015). 
The Economic Journal, 125(583), 493–532. 
<a href="https://doi.org/10.1111/ecoj.12200">doi:10.1111/ecoj.12200</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Case 1 ####
library("PlackettLuce")
data("breadwheat", package = "gosset")

# convert the tricot rankings from breadwheat data
# into a object of class 'grouped_rankings'

G = rank_tricot(breadwheat,
                 items = c("variety_a","variety_b","variety_c"),
                 input = c("overall_best","overall_worst"),
                 group = TRUE)


# combine grouped rankings with temperature indices
mydata = cbind(G, breadwheat[c("lon","lat")])

# fit a pltree model using geographic data
mod = pltree(G ~ ., data = mydata)

regret(mod)

# Case 2 ####
# list of PlackettLuce models
R = matrix(c(1, 2, 3, 0,
              4, 1, 2, 3,
              2, 1, 3, 4,
              1, 2, 3, 0,
              2, 1, 3, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) = c("apple", "banana", "orange", "pear")

mod1 = PlackettLuce(R)

R2 = matrix(c(1, 2, 0, 3,
               2, 1, 0, 3,
               2, 1, 0, 3,
               1, 2, 0, 3,
               2, 1, 0, 3,
               1, 3, 4, 2), nrow = 6, byrow = TRUE)
colnames(R2) = c("apple", "banana", "orange", "pear")

mod2 = PlackettLuce(R2)

mod = list(mod1, mod2)

regret(mod, n1 = 500)
</code></pre>

<hr>
<h2 id='reliability'>Probability of outperforming a check</h2><span id='topic+reliability'></span><span id='topic+reliability.default'></span><span id='topic+reliability.PlackettLuce'></span><span id='topic+reliability.pltree'></span>

<h3>Description</h3>

<p>Measures the precision of estimated values, and
the potential response to selection on those 
estimated values compared to a check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reliability(x, ...)

## Default S3 method:
reliability(x, y = NULL, ...)

## S3 method for class 'PlackettLuce'
reliability(x, ref, ...)

## S3 method for class 'pltree'
reliability(x, ref, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reliability_+3A_x">x</code></td>
<td>
<p>a numeric vector, or an object
of class <code>PlackettLuce</code> or <code>pltree</code></p>
</td></tr>
<tr><td><code id="reliability_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="reliability_+3A_y">y</code></td>
<td>
<p>numeric, the reference value</p>
</td></tr>
<tr><td><code id="reliability_+3A_ref">ref</code></td>
<td>
<p>a character or integer for indexing the
element containing reference values in <var>x</var></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the reliability based on the worth parameters
</p>


<h3>Author(s)</h3>

<p>Kauê de Sousa, David Brown, Jacob van Etten
</p>


<h3>References</h3>

<p>Eskridge and Mumm (1992). Theoret. Appl. Genetics 84, 494–500 <a href="https://doi.org/10.1007/BF00229512">doi:10.1007/BF00229512</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Case 1. vector example

x = c(9.5, 12, 12.3, 17)

y = 11.2

reliability(x, y)

# Case 2. PlackettLuce model

library("PlackettLuce") 

R = matrix(c(1, 2, 4, 3,
              4, 1, 2, 3,
              2, 3, 1, 4,
              4, 2, 3, 1,
              2, 1, 4, 3,
              1, 4, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) = c("apple", "banana", "orange", "pear")

mod = PlackettLuce(R)

reliability(mod, ref = "orange")


# Case 3. PlackettLuce tree

data("beans", package = "PlackettLuce")

G = rank_tricot(data = beans,
                 items = c(1:3),
                 input = c(4:5),
                 group = TRUE,
                 additional.rank = beans[c(6:8)])

pld = cbind(G, beans[,c("maxTN", "season", "lon")])

tree = pltree(G ~ maxTN + season + lon, data = pld)

reliability(tree, ref = "Local")


</code></pre>

<hr>
<h2 id='rowbind'>Combine R objects by rows</h2><span id='topic+rowbind'></span><span id='topic+rowbind.default'></span><span id='topic+rowbind.list'></span>

<h3>Description</h3>

<p>Combine R objects when number and names of columns do not match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowbind(x, ...)

## Default S3 method:
rowbind(x, y, ...)

## S3 method for class 'list'
rowbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowbind_+3A_x">x</code></td>
<td>
<p>a R object, typically a data.frame, matrix or list</p>
</td></tr>
<tr><td><code id="rowbind_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="rowbind_+3A_y">y</code></td>
<td>
<p>a matrix, a data.frame (or any other object that can
be coerced to data.frame)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the combined data
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# two data frames
rowbind(airquality, mtcars)

# a list of data frames
l = list(airquality, mtcars)
rowbind(l)

</code></pre>

<hr>
<h2 id='set_binomialfreq'>Binomial frequency rankings from pairwise contests</h2><span id='topic+set_binomialfreq'></span>

<h3>Description</h3>

<p>Binary comparisons from a ranking object. Ties are not 
taken into account, then they are added as NA's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_binomialfreq(object, drop.null = FALSE, disaggregate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_binomialfreq_+3A_object">object</code></td>
<td>
<p>an object of class <code>rankings</code>, <code>grouped_rankings</code>
or <code>paircomp</code></p>
</td></tr>
<tr><td><code id="set_binomialfreq_+3A_drop.null">drop.null</code></td>
<td>
<p>logical, an optional argument to remove null contests</p>
</td></tr>
<tr><td><code id="set_binomialfreq_+3A_disaggregate">disaggregate</code></td>
<td>
<p>logical, if <code>TRUE</code> binaries are disaggregated 
by individual contests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with binary rank of pairwise contests:
</p>
<table>
<tr><td><code>player1</code></td>
<td>
<p>a factor with n levels for the first player 
in the contests</p>
</td></tr>
<tr><td><code>player2</code></td>
<td>
<p>a factor with n levels (same as player1) for 
the second player in the contests</p>
</td></tr>
<tr><td><code>win1</code></td>
<td>
<p>number of times player1 wins against player2</p>
</td></tr>
<tr><td><code>win2</code></td>
<td>
<p>number of times player2 wins against player1</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kauê de Sousa
</p>


<h3>References</h3>

<p>Turner H. &amp; Firth D. (2012). 
Journal of Statistical Software, 48(9), 1–21. 
<a href="https://doi.org/10.18637/jss.v048.i09">doi:10.18637/jss.v048.i09</a>
</p>


<h3>See Also</h3>

<p>Other rank functions: 
<code><a href="#topic+rank_numeric">rank_numeric</a>()</code>,
<code><a href="#topic+rank_tricot">rank_tricot</a>()</code>,
<code><a href="#topic+set_paircomp">set_paircomp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("PlackettLuce")

R = matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 4, 3, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) = c("apple", "banana", "orange", "pear")

R = as.rankings(R)

set_binomialfreq(R)

set_binomialfreq(R, disaggregate = TRUE)

</code></pre>

<hr>
<h2 id='set_paircomp'>Pairwise comparison rankings</h2><span id='topic+set_paircomp'></span>

<h3>Description</h3>

<p>Pairwise comparisons from a PlackettLuce ranking object. 
Ties are not taken into account, then coerced to NA's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_paircomp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_paircomp_+3A_object">object</code></td>
<td>
<p>an object of class &quot;rankings&quot; or &quot;grouped_rankings&quot; 
which is a matrix of dense rankings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;paircomp&quot; which is a matrix 
of pairwise comparisons
</p>


<h3>Author(s)</h3>

<p>Kauê de Sousa and Jacob van Etten
</p>


<h3>References</h3>

<p>Strobl C., Wickelmaier F. &amp; Zeileis A. (2011). 
Journal of Educational and Behavioral Statistics, 36(2), 135–153.
doi:10.3102/1076998609359791
</p>


<h3>See Also</h3>

<p><code><a href="PlackettLuce.html#topic+rankings">rankings</a></code>, 
<code><a href="psychotools.html#topic+paircomp">paircomp</a></code>
</p>
<p>Other rank functions: 
<code><a href="#topic+rank_numeric">rank_numeric</a>()</code>,
<code><a href="#topic+rank_tricot">rank_tricot</a>()</code>,
<code><a href="#topic+set_binomialfreq">set_binomialfreq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library("PlackettLuce")

R = matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 4, 3, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) = c("apple", "banana", "orange", "pear")
R = as.rankings(R)

PC = set_paircomp(R)

#############################################

# using breadwheat data
data("breadwheat", package = "gosset")

# convert the tricot rankings from breadwheat data
# into a object of class 'rankings' from PlackettLuce
R = rank_tricot(breadwheat,
                 items = c("variety_a","variety_b","variety_c"),
                 input = c("overall_best","overall_worst"))


PC = set_paircomp(R)

</code></pre>

<hr>
<h2 id='worth_map'>Plot worth parameters</h2><span id='topic+worth_map'></span><span id='topic+worth_map.default'></span><span id='topic+worth_map.list'></span><span id='topic+worth_bar'></span>

<h3>Description</h3>

<p>Produces plots to highlight worth
coefficients of items in a party tree of 
a list of PlackettLuce models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worth_map(object, ...)

## Default S3 method:
worth_map(object, ...)

## S3 method for class 'list'
worth_map(object, labels, ...)

worth_bar(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="worth_map_+3A_object">object</code></td>
<td>
<p>an object of class <code>party</code> or 
an object of class <code>PlackettLuce</code> or
a list objects of class <code>PlackettLuce</code></p>
</td></tr>
<tr><td><code id="worth_map_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="worth_map_+3A_labels">labels</code></td>
<td>
<p>a vector with the name of models in <var>object</var></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library("psychotree")
library("PlackettLuce")
data("Topmodel2007", package = "psychotree")
R = as.grouped_rankings(Topmodel2007$preference)

tm_tree = pltree(R ~ ., data = Topmodel2007[, -1], 
                  minsize = 5,
                  npseudo = 0)

worth_map(tm_tree)

##########################################

# Ranking of preference on four fruits 
# based on traits taste, texture, 
# price and storability

# taste
R1 = matrix(c(1, 2, 3, 4,
               4, 1, 3, 2,
               4, 1, 2, 3,
               1, 2, 0, 3), nrow = 4, byrow = TRUE)
colnames(R1) = c("apple", "banana", "orange", "pear")
mod1 = PlackettLuce(R1)

# texture
R2 = matrix(c(1, 4, 2, 3,
               1, 4, 3, 2,
               1, 4, 2, 3,
               1, 4, 2, 3), nrow = 4, byrow = TRUE)
colnames(R2) = c("apple", "banana", "orange", "pear")
mod2 = PlackettLuce(R2)

# price
R3 = matrix(c(2, 4, 3, 1,
               4, 1, 2, 3,
               3, 4, 2, 1,
               4, 3, 1, 2), nrow = 4, byrow = TRUE)
colnames(R3) = c("apple", "banana", "orange", "pear")
mod3 = PlackettLuce(R3)

# storability
R4 = matrix(c(1, 4, 3, 2,
               3, 4, 1, 2,
               1, 3, 2, 4,
               2, 3, 4, 1), nrow = 4, byrow = TRUE)
colnames(R4) = c("apple", "banana", "orange", "pear")
mod4 = PlackettLuce(R4)

# models in a list
mods = list(mod1, mod2, mod3, mod4)

# name for each model
labels = c("Taste", "Texture", "Price", "Storability")

worth_map(mods, labels)

# plot only one model as bar 
worth_bar(mod1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
