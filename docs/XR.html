<!DOCTYPE html><html lang="en"><head><title>Help for package XR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {XR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#XR'><p>A Structure for Interfaces from R</p></a></li>
<li><a href='#asJSONS4'><p>Convert an Object to a Dictionary or Array in JSON Notation</p></a></li>
<li><a href='#asRObject'><p>Specialize the R Object Returned from an Interface Evaluator</p></a></li>
<li><a href='#asServerObject'><p>Generate a Server Language Expression corresponding to an R Object</p></a></li>
<li><a href='#AssignedProxy-class'><p>Class for Assigned Proxy Objects and Related Mechanisms</p></a></li>
<li><a href='#dumpProxyFunction'><p>Write A Proxy Function to a File or Connection</p></a></li>
<li><a href='#evaluatorAction'><p>Carry Out an Evaluator Initialization Action</p></a></li>
<li><a href='#evaluatorActions'><p>Add to Table of Search Paths and Import Commands</p></a></li>
<li><a href='#fillNames'><p>Utilities for Server-Language Specific Use</p></a></li>
<li><a href='#fixHelpTopic'><p>Make a Help Topic an Explicit Character String</p></a></li>
<li><a href='#from_Server-class'><p>A Class to Describe General Server Objects</p></a></li>
<li><a href='#getInterface'><p>Get or start an evaluator for an interface</p></a></li>
<li><a href='#Interface-class'><p>Reference class for all interface evaluators</p></a></li>
<li><a href='#InterfaceCondition-class'><p>Classes of objects representing errors or other conditions in a server language</p></a></li>
<li><a href='#isProxy'><p>Test if an Object is a Proxy</p></a></li>
<li><a href='#MiscMethods'><p>Miscellaneous methods</p></a></li>
<li><a href='#nameQuote'><p>Plain Double Quote for Names</p></a></li>
<li><a href='#noScalar'><p>Send a Non-scalar Version of an Object</p></a></li>
<li><a href='#objectAsJSON'><p>Construct a String in JSON Notation to Represent an R Object</p></a></li>
<li><a href='#objectDictionary'><p>Generate the Explicit Dictionary form for an R Object</p></a></li>
<li><a href='#packageSetup'><p>Execute a Setup Step for a Package</p></a></li>
<li><a href='#ProxyClass-class'><p>A Class to Describe Classes in the Server Language</p></a></li>
<li><a href='#ProxyClassObject-class'><p>A Class for Objects that are Proxies for Specific Server Class Objects</p></a></li>
<li><a href='#proxyEvaluator'><p>The Evaluator Function Object Referred to from a Proxy Objec</p></a></li>
<li><a href='#ProxyFunction-class'><p>A Class for Proxy Functions</p></a></li>
<li><a href='#proxyName'><p>Return the Server Language Name Corresponding to a Proxy Object</p></a></li>
<li><a href='#ProxyObject-class'><p>Class Union to Represent Proxy Objects</p></a></li>
<li><a href='#ServerClassDef-class'><p>The Definition of a Server Language Class</p></a></li>
<li><a href='#serverFields-class'><p>Class Union for Describing Server Language Fields</p></a></li>
<li><a href='#setProxyClass'><p>Create a Proxy Class</p></a></li>
<li><a href='#typeToJSON'><p>Convert a Simple Object to JSON String</p></a></li>
<li><a href='#Unconvertible-class'><p>Unconverted Server Language Objects</p></a></li>
<li><a href='#valueFromServer'><p>Convert the String Returned by a Server Language Interface to an R Object.</p></a></li>
<li><a href='#vector_R-class'><p>A class that facilitates returning R vectors via a list in JSON</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Structure for Interfaces from R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-03-01</td>
</tr>
<tr>
<td>Author:</td>
<td>John M. Chambers</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Chambers &lt;jmc@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Support for interfaces from R to other languages,
    built around a class for evaluators and a combination of functions, classes and
    methods for communication. Will be used through a specific language interface
    package. Described in the book "Extending R".</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, jsonlite</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-18 21:26:17 UTC; jmc</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-18 22:31:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='XR'>A Structure for Interfaces from R</h2><span id='topic+XR'></span><span id='topic+XR-package'></span>

<h3>Description</h3>

<p>The XR package defines classes and functions that will be extended and used by interfaces from R to
other languages.
The goals are: a uniform approach; simplicity in programming; users of application packages should be
essentially unaware that particular functions and objects are in fact proxies for computations in
other languages.
</p>


<h3>Details</h3>

<p>The functions in this package will nearly always be used by other packages, providing an interface to a
particular language (see packages XRPython and XRJulia for examples).  Users will rarely need to call
functions in XR and application packages will rarely need to import it directly.
</p>
<p>For further details, see the reference [1] (Chapter 13 is included in the documentation for this package).
</p>


<h3>References</h3>

<p>[1] Chambers, John M.
<em>Extending R.</em> Chapman &amp; Hall, 2016
</p>

<hr>
<h2 id='asJSONS4'>Convert an Object to a Dictionary or Array in JSON Notation</h2><span id='topic+asJSONS4'></span>

<h3>Description</h3>

<p>The general converter for an object with a formal class
or an object to be described via its S3 class, data and attributes.
Not usually called directly, but from <code><a href="#topic+objectAsJSON">objectAsJSON</a></code> or method in an interface package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asJSONS4(object, prototype, exclude = character(), level = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asJSONS4_+3A_object">object</code></td>
<td>
<p>The object to convert.</p>
</td></tr>
<tr><td><code id="asJSONS4_+3A_prototype">prototype</code></td>
<td>
<p>The prototype object (supplied from the evaluator).</p>
</td></tr>
<tr><td><code id="asJSONS4_+3A_exclude">exclude</code></td>
<td>
<p>Slots to exclude from the dictionary.</p>
</td></tr>
<tr><td><code id="asJSONS4_+3A_level">level</code></td>
<td>
<p>The level of expansion of objects within the original object.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='asRObject'>Specialize the R Object Returned from an Interface Evaluator</h2><span id='topic+asRObject'></span><span id='topic+asRObject+2CProxyObject-method'></span><span id='topic+asRObject+2Cvector_R-method'></span><span id='topic+asRObject+2Clist-method'></span><span id='topic+asRObject+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The result of a server language expression is returned as a string, using the JSON
standard notation to represent a scalar, list or dictionary.  Methods for this function
get the simple R object obtained from deparsing and interpret it generally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asRObject(object, evaluator)

## S4 method for signature 'ProxyObject'
asRObject(object, evaluator)

## S4 method for signature 'vector_R'
asRObject(object, evaluator)

## S4 method for signature 'list'
asRObject(object, evaluator)

## S4 method for signature 'data.frame'
asRObject(object, evaluator)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asRObject_+3A_object">object</code></td>
<td>
<p>An object constructed from the explicit representation as a dictionary.
The elements of the dictionary will be converted into objects for the slots of the same
name.  Application-written methods will re-interpret the object into the intended <span class="rlang"><b>R</b></span> form,
not necessarily from the same class.</p>
</td></tr>
<tr><td><code id="asRObject_+3A_evaluator">evaluator</code></td>
<td>
<p>This argument will be supplied as the evaluator object doing the conversion.
Therefore, methods may have one of the specific evaluator classes (e.g., <code>"PythonInterface"</code>,
in their signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods supplied with the 'XR' pacakage handle the standard mechanisms for interpretation.
Additional methods are likely to interpret proxy class objects for which the standard
XR representation in terms of class and slots is not what's actually wanted.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ProxyObject</code>: When a proxy object appears, usually as an element of a list, it
is expanded, by using the 'Get()' method of the evaluator and calling 'asRObject()' on the
result.
</p>
</li>
<li> <p><code>vector_R</code>: To distinguish typed R vectors from a general JSON list, encode the
desired data as an object from the &quot;vector_R&quot; class.
Vector types whose elements cannot be represented in JSON (e..g, &quot;complex&quot;) should
be returned as a list of character strings in a format that R will parse as
elements of the suitable vector object. (e.g, &quot;.5+3i&quot;)
</p>
</li>
<li> <p><code>list</code>: Both lists and dictionaries will come here from the basic conversion.
'names(object)' will either be NULL or all non-empty, from a dictionary.
</p>
</li>
<li> <p><code>data.frame</code>: Assume this has been done via .RClass; avoid inheriting the list method
</p>
</li></ul>


<h3>Writing Application Methods</h3>

<p>Application packages will typically write methods for special classes, and often for classes
themselves defined in the package.  One good reason is that the server language does not
naturally return the eventually intended object in a convenient form; for example, because
it does not have typed arrays.  Then a special class will be defined in <span class="rlang"><b>R</b></span>.  The server code
will generate a dictionary with the <code>".RClass"</code> element having the class name, plus
whatever slots make sense.  The application method for <code>asRObject()</code> will take these
slots and construct whatever object is really intended.  For an example, see the method
for class <code>vector_R</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='asServerObject'>Generate a Server Language Expression corresponding to an R Object</h2><span id='topic+asServerObject'></span><span id='topic+asServerObject+2Cname-method'></span><span id='topic+asServerObject+2CAssignedProxy-method'></span><span id='topic+asServerObject+2CProxyFunction-method'></span><span id='topic+asServerObject+2CProxyClassObject-method'></span>

<h3>Description</h3>

<p>Returns a string that can be inserted into a server language expression.
When parsed and evaluated by the server evaluator, the result
will be the appropriate object or data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asServerObject(object, prototype)

## S4 method for signature 'name'
asServerObject(object, prototype)

## S4 method for signature 'AssignedProxy'
asServerObject(object, prototype)

## S4 method for signature 'ProxyFunction'
asServerObject(object, prototype)

## S4 method for signature 'ProxyClassObject'
asServerObject(object, prototype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asServerObject_+3A_object">object</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="asServerObject_+3A_prototype">prototype</code></td>
<td>
<p>The proxy for a prototype of the server language object wanted.
When called from the 'AsServerObject()' method of an evaluator, this argument is supplied
automatically from a class of objects for that evaluator, allowing methods to be defined
specialized to the various interface evalutor classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for proxy objects and proxy class objects
will produce the name under which they were assigned.
The default method uses JSON to encode the object as a string and expects the server side
interface to have a function objectFromJSON() to decode the string.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>name</code>: class &quot;name&quot; is used to pass unquoted strings, in case your
interface code did an explicit assign (but that's discouraged).
</p>
</li>
<li> <p><code>AssignedProxy</code>: Proxy objects are just passed as their character string, although
a particular interface class could do something different, like refer to a table.
</p>
</li>
<li> <p><code>ProxyFunction</code>: a proxy function just turns into its server language name.
</p>
</li>
<li> <p><code>ProxyClassObject</code>: an object from a proxy class will be replaced by the name of the referenced object
</p>
</li></ul>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='AssignedProxy-class'>Class for Assigned Proxy Objects and Related Mechanisms</h2><span id='topic+AssignedProxy-class'></span><span id='topic+AssignedProxy'></span>

<h3>Description</h3>

<p>The 'AssignedProxy' class is used by interface packages to return a reference
to an assigned server object.  The <span class="rlang"><b>R</b></span> user can then supply this object anywhere
in later interface computations, just as one would use the name of an <span class="rlang"><b>R</b></span> object
in a function call or other expression.
</p>


<h3>Details</h3>

<p>The virtual class 'ProxyObject' is a superclass, designed to allow
other mechanisms for proxy objects (none exists at this time).
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>The 'AssignedProxy' class is a subclass of 'character'; the actual character string
will be generated by the interface and is unique over the session, so long as the 'XR'
package stays loaded.</p>
</dd>
<dt><code>serverClass,module</code></dt><dd><p>The server language class and module for the corresponding object.</p>
</dd>
<dt><code>size</code></dt><dd><p>The size (usually, length) of the server object, if that makes sense.
Can be used to make decisions about handling large objects.</p>
</dd>
<dt><code>evaluator</code></dt><dd><p>The evaluator object that returned the proxy.  Having this as a slot allows
interface computations to operate directly on the proxy, without a user-supplied evaluator.</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='dumpProxyFunction'>Write A Proxy Function to a File or Connection</h2><span id='topic+dumpProxyFunction'></span>

<h3>Description</h3>

<p>This function is called by the <code>$SaveProxyFunction()</code> method of an evaluator object.  It is exported
for the convenience of packages inheriting from XR and would not normally be called by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dumpProxyFunction(file, object, objName = object@name, docText)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dumpProxyFunction_+3A_file">file</code></td>
<td>
<p>the file or connection for writing the function text.</p>
</td></tr>
<tr><td><code id="dumpProxyFunction_+3A_object">object</code>, <code id="dumpProxyFunction_+3A_objname">objName</code>, <code id="dumpProxyFunction_+3A_doctext">docText</code></td>
<td>
<p>arguments supplied by the evaluator method.</p>
</td></tr>
</table>

<hr>
<h2 id='evaluatorAction'>Carry Out an Evaluator Initialization Action</h2><span id='topic+evaluatorAction'></span><span id='topic+evaluatorAction+2Clanguage-method'></span><span id='topic+evaluatorAction+2CpathEl-method'></span>

<h3>Description</h3>

<p>This function is called from the Startup() method of an evalautor and is not
useful to be called directly.  It is exported to make it visible from within
a subclass of &quot;Interface&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluatorAction(action, ev)

## S4 method for signature 'language'
evaluatorAction(action, ev)

## S4 method for signature 'pathEl'
evaluatorAction(action, ev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluatorAction_+3A_action">action</code></td>
<td>
<p>the action from the table.  Must be an expression or some special
class, typically a path element to add to the server path.</p>
</td></tr>
<tr><td><code id="evaluatorAction_+3A_ev">ev</code></td>
<td>
<p>the evaluator.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>language</code>: a language object, just evaluate it.
</p>
</li>
<li> <p><code>pathEl</code>: a &quot;pathEl&quot; object to add to the server search path.
</p>
</li></ul>

<hr>
<h2 id='evaluatorActions'>Add to Table of Search Paths and Import Commands</h2><span id='topic+evaluatorActions'></span><span id='topic+serverAddToPath'></span><span id='topic+serverImport'></span><span id='topic+serverTask'></span>

<h3>Description</h3>

<p>Utilities to add to the table of search paths, import commands and tasks for all evalutors of the
specified class.  Called only from analogous functions in packages for specific languages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serverAddToPath(Class, directory,
  package = utils::packageName(topenv(parent.frame())), pos = NA,
  onLoad = NA, where = topenv(parent.frame()))

serverImport(Class, ..., onLoad = nzchar(packageName(where))  &amp;&amp;
                 !environmentIsLocked(where),  where = topenv(parent.frame()))

serverTask(Class, command, onLoad = nzchar(packageName(where)),
  where = topenv(parent.frame()))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluatorActions_+3A_class">Class</code></td>
<td>
<p>the class of the server-specific evalutor.</p>
</td></tr>
<tr><td><code id="evaluatorActions_+3A_directory">directory</code></td>
<td>
<p>the directory to add to the search path table.</p>
</td></tr>
<tr><td><code id="evaluatorActions_+3A_package">package</code></td>
<td>
<p>the name of the server-specific interface package.</p>
</td></tr>
<tr><td><code id="evaluatorActions_+3A_pos">pos</code></td>
<td>
<p>where in the list of directories to insert this one.  Defaults to the end.</p>
</td></tr>
<tr><td><code id="evaluatorActions_+3A_onload">onLoad</code>, <code id="evaluatorActions_+3A_where">where</code></td>
<td>
<p>used to set up a load action; should be omitted if called from a package source</p>
</td></tr>
<tr><td><code id="evaluatorActions_+3A_...">...</code></td>
<td>
<p>arguments to pass to the evaluator's <code>$Import()</code> method</p>
</td></tr>
<tr><td><code id="evaluatorActions_+3A_command">command</code></td>
<td>
<p>an <em>unevaluated</em> command or expression for the evaluator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The server-specific information is added to the table stored by the XR package.  All future
evaluators for the specified interface class will have these directories in their search
path, will import the module information specified and carry out any other tasks supplied.
</p>
<p>If a current evaluator for this
class exists, it applies all the commands, but <em>previous</em> evalutors
for this class are not modified.
</p>
<p>Commands are evaluated in the order of the calls to these functions.  For example, the application
package should execute a call to add to the search path before any calls to import modules form
the corresponding directory.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>serverAddToPath</code>: Add the directory to the search path of all evaluators of this class.
</p>
</li>
<li> <p><code>serverImport</code>: An import command with these arguments will be executed for each new evaluator of this
interface class, and for the current evaluator if one exists.
</p>
</li>
<li> <p><code>serverTask</code>: An unevalated command or expression for the interface is supplied, typically using
<code>quote()</code> or <code>substitute</code>.  When an evaluator from the class is created, this
command will be evaluated.
</p>
</li></ul>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='fillNames'>Utilities for Server-Language Specific Use</h2><span id='topic+fillNames'></span>

<h3>Description</h3>

<p>A utility to fill in blank names in list elements to make it valid for a dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillNames(object, noNamesOK = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fillNames_+3A_object">object</code></td>
<td>
<p>a list object, possibly with empty or duplicate names.</p>
</td></tr>
<tr><td><code id="fillNames_+3A_nonamesok">noNamesOK</code></td>
<td>
<p>what to do with a list having no names&mdash;leave it alone or fill them all in?</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='fixHelpTopic'>Make a Help Topic an Explicit Character String</h2><span id='topic+fixHelpTopic'></span>

<h3>Description</h3>

<p>A helper function to pass on a help topic (specifically for a reference-class method) to
another help-style function; i.e., so the user could have supplied either a name or a
general expression that evaluates to a character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixHelpTopic(topic)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixHelpTopic_+3A_topic">topic</code></td>
<td>
<p>The <em>expression</em> supplied by your user.  If this was a name, it will be
taken literally, otherwise evaluated two levels up the call stack, which should return a character string.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='from_Server-class'>A Class to Describe General Server Objects</h2><span id='topic+from_Server-class'></span><span id='topic+from_Server'></span><span id='topic+initialize+2Cfrom_Server-method'></span><span id='topic++24+2Cfrom_Server-method'></span><span id='topic+show+2Cfrom_Server-method'></span>

<h3>Description</h3>

<p>Classes that inherit from this class are used to convert to R a server language
object that is composed of named fields.  The corresponding R object will have
conversions for the fields that can be accessed with the &quot;$&quot; operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'from_Server'
initialize(.Object, ..., referenceClass = TRUE)

## S4 method for signature 'from_Server'
x$name

## S4 method for signature 'from_Server'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="from_Server-class_+3A_.object">.Object</code>, <code id="from_Server-class_+3A_referenceclass">referenceClass</code></td>
<td>
<p>arguments supplied automatically.</p>
</td></tr>
<tr><td><code id="from_Server-class_+3A_...">...</code></td>
<td>
<p>possible slots for subclasses</p>
</td></tr>
<tr><td><code id="from_Server-class_+3A_x">x</code>, <code id="from_Server-class_+3A_name">name</code></td>
<td>
<p>the object and the field name</p>
</td></tr>
<tr><td><code id="from_Server-class_+3A_object">object</code></td>
<td>
<p>an object from some server class, converted by the <code>$Get()</code> method
or an equivalent computation, such as supplying <code>.get = TRUE</code> to a proxy function
call.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>initialize</code>: performs some checks on the fields
</p>
</li>
<li> <p><code>$</code>: extract a field.  The name must match a field in the
data part.
</p>
</li>
<li> <p><code>show</code>: automatic printing, currently just a list of field names.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>serverClass</code></dt><dd><p>the name of the server language class</p>
</dd>
<dt><code>module</code></dt><dd><p>the name of the server language module</p>
</dd>
<dt><code>language</code></dt><dd><p>the name of the server language</p>
</dd>
<dt><code>fields</code></dt><dd><p>the names of the server language fields</p>
</dd>
<dt><code>data</code></dt><dd><p>the converted data for the server fields</p>
</dd>
</dl>

<hr>
<h2 id='getInterface'>Get or start an evaluator for an interface</h2><span id='topic+getInterface'></span><span id='topic+evaluatorTable'></span><span id='topic+rmInterface'></span><span id='topic+evaluatorNumber'></span>

<h3>Description</h3>

<p>Utility functions to manage a table of evaluators, indexed by the evaluator class, typically
one class per server language. All are typically hidden by functions or methods for the particular
class. <code>rmInterface</code> and <code>evaluatorNumber</code> are used by methods and exported so that
subclasses of interface evaluators will have access to them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInterface(Class, ..., .makeNew = NA, .select = NULL)

rmInterface(evaluator)

evaluatorNumber(evaluator, add = length(id) &gt; 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getInterface_+3A_class">Class</code></td>
<td>
<p>the name of the interface class for this evaluator; by default, the class of the
current evaluator. Can also be the class definition object.</p>
</td></tr>
<tr><td><code id="getInterface_+3A_...">...</code></td>
<td>
<p>arguments, if any, are passed to the generator for the evaluator</p>
</td></tr>
<tr><td><code id="getInterface_+3A_.makenew">.makeNew</code></td>
<td>
<p>can be used to force or prevent starting a new evaluator, if passed as
a logical value.  Can also be passed as a function that tests the suitability of a
current evaluator, returning TRUE if this one won't do, and a new one should be
generated instead (consistent with the ... arguments, presumably).
</p>
<p>The default is NA, meaning that an existing evaluator is OK, but one should be generated
if none exists.  In contrast, FALSE means to return NULL if no matching evaluator exists.</p>
</td></tr>
<tr><td><code id="getInterface_+3A_.select">.select</code></td>
<td>
<p>Can be supplied as a function of one argument, which will be called for
each evaluator of this class and which should return <code>TRUE</code>/<code>FALSE</code> according to
whether the evaluator should be accepted.  Allows applications to select, for example, a
particular evaluator corresponding to a known connection.</p>
</td></tr>
<tr><td><code id="getInterface_+3A_evaluator">evaluator</code></td>
<td>
<p>any evaluator object.</p>
</td></tr>
<tr><td><code id="getInterface_+3A_add">add</code></td>
<td>
<p>if this evaluator is not in the table, add it.  Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specific language interface packages usually supply a convenience function equivalent
to calling <code>getInterface()</code> for their class; e.g., <code>RPython()</code> in <code>'XRPython'</code>
</p>
<p>If no <code>Class</code> is given, the current (i.e., last active) evaluator is returned
</p>


<h3>Value</h3>

<p><code>getInterface()</code> returns an  interface evaluator for this class, starting one if none exists.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rmInterface</code>: Remove the specified  evaluator from the table of available interfaces.
</p>
</li>
<li> <p><code>evaluatorNumber</code>: Return the sequential number for this evalutor; used in <code>ProxyName()</code> method.
If not there: if <code>add</code>, add the evaluator to the table; else return <code>NA</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## the current evaluator, or NULL if none exists
getInterface()
## this will always be NULL, because no evaluator has this class
getInterface("Interface", .makeNew = FALSE)
</code></pre>

<hr>
<h2 id='Interface-class'>Reference class for all interface evaluators</h2><span id='topic+Interface-class'></span><span id='topic+Interface'></span>

<h3>Description</h3>

<p>This class has the fields required for any specific interface and the methods that
are defined centrally in the XR structure.  As noted in the documentation for inidividual
methods, some methods must be redefined in the specific interface.
</p>


<h3>Fields</h3>


<dl>
<dt><code>evaluatorId</code></dt><dd><p>A character string (usually unique) giving the language and date when started</p>
</dd>
<dt><code>languageName</code></dt><dd><p>The server language.  Does not have to be unique if multiple classes implement interfaces to the same language.</p>
</dd>
<dt><code>proxyCount</code></dt><dd><p>Counter used to generate unique names for proxy objects.</p>
</dd>
<dt><code>propertyFormat</code></dt><dd><p>C-style format string for access to properties and methods in this
evaluator.  Nearly always just the two names, separated by &quot;.&quot;</p>
</dd>
<dt><code>proxyClassTable</code></dt><dd><p>An environment for all proxy classes known currently for this
evaluator class.</p>
</dd>
<dt><code>prototypeObject</code></dt><dd><p>The object representing any proxy class for this inteface.  Usually from
a class defined by the specific interface package, to distinguish its proxy classes. This
field is passed as the <code>prototype</code> argument in calls to <code><a href="#topic+asServerObject">asServerObject</a></code>.</p>
</dd>
<dt><code>simplify</code></dt><dd><p>Should lists whose elements are each basic scalars be unlisted?
Default FALSE.  May also be a function that takes a possibly simplifiable
list as argument and returns the vector/list result.
Use this to apply a customized test; e.g., all scalars must have same type.</p>
</dd>
<dt><code>propertyFormat</code></dt><dd><p>The C-style format for a property (i.e., field) in the server language.
The default assumes <code>"."</code> is the field operator, as in all likely server languages so far.</p>
</dd>
<dt><code>proxyClassTable</code></dt><dd><p>Used to keep track of proxy classes encountered</p>
</dd>
<dt><code>modules</code></dt><dd><p>The evaluator's table of currently imported modules.</p>
</dd>
<dt><code>serverPath</code></dt><dd><p>The evaluator's current server language path for importing.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>AddToPath(directory = base::tolower(languageName),
  package = utils::packageName(topenv(parent.frame())), pos = NA)</code></dt><dd><p>Add the directory to the systemPath
By default, appends to the path; if 'pos' is given, inserts at that position.
If both directory and package are omitted, the method looks for the package name in the
calling function (suitable if the method call is from a package source file).</p>
</dd>
<dt><code>AsRObject(object)</code></dt><dd><p>Given an R object made up of vectors, lists and named tables, interpret that as a general R object,
using a convention that may be specialized to the server language by overriding
$AsRObject() or by methods for asRObject().  The argument will may be from a proxy class.</p>
</dd>
<dt><code>AsServerObject(object, prototype = prototypeObject)</code></dt><dd><p>Given an R object return a string that, when evaluated in the server language gives
a corresponding object in that language.  The default implementation uses the function
XR::objectAsJSON, which returns a JSON string and assumes a function 'objectFromJSON(string)'
in the server. The conversion may be specialized to server language classes by methods for
asServerObject() or objectAsJSON().</p>
</dd>
<dt><code>Call(fun, ..., .get = NA)</code></dt><dd><p>Call the server language function 'fun'.  Each of the '...' arguments will be
translated into a server language expression by the AsServerObject() method.</p>
</dd>
<dt><code>Command(expr, ...)</code></dt><dd><p>Like Eval(), but the value of the expression is ignored.  In particular, may be a command
in the server language that is not an expression.</p>
</dd>
<dt><code>Eval(expr, ..., .get = NA)</code></dt><dd><p>Evaluate 'expr' and return the value, possibly as a proxy.
Expressions are supplied as character strings to be parsed and
evaluated by the server language. If 'expr' has &quot;
with the appropriate server language code equivalent to the '...' arguments.  If 'expr' has
more than one element, all but the last are evaluated by $Command(), with '...' ignored.</p>
</dd>
<dt><code>finalize(...)</code></dt><dd><p>method called when the object is garbage collected.  A call to the $Quit() method
also calls this method (recalling it later then does nothing).  In case some server action
(like closing down a subprocess) is required, the $ServerQuit() method is called, and
the evaluator is then removed from the table of interface evaluators.</p>
</dd>
<dt><code>Function(serverFun)</code></dt><dd><p>Returns an R function object that calls the specified sever language function,
specified by its name in the server language or by the proxy object returned by the
$Define() method of the evaluator</p>
</dd>
<dt><code>Get(what, ...)</code></dt><dd><p>Return the value, always converted to an R object.  Usually gets a proxy object as the argument, but can be called like $Eval(), if ... is non-empty.</p>
</dd>
<dt><code>Import(module, ...)</code></dt><dd><p>Import the module.  The &quot;Interface&quot; method assumes a command &quot;import&quot; in the server
language and does not handle any extra arguments (e.g., for importing specific members).</p>
</dd>
<dt><code>initialize(...)</code></dt><dd><p>initializes the evaluator in a language-independent sense.</p>
</dd>
<dt><code>MethodCall(object, name, ..., .get = NA)</code></dt><dd><p>Call the server language method 'name' on 'object', with arguments '...',
by default assuming a language in which the syntax is 'object.name(...)'.
To override with a different syntax, define field propertyFormat in the evaluator.
Note that 'name' must be a character string, not an evaluation in the server.</p>
</dd>
<dt><code>MethodEval(string, catch = FALSE, print = FALSE)</code></dt><dd><p>The string is a method call for the evaluator, or the name of a field.
Evaluated as the expression ev$string.</p>
</dd>
<dt><code>New(serverClass, serverModule = "", ...)</code></dt><dd><p>Generate a new object from the specified server class.  The corresponding generator function
in the server is given by ServerGenerator(serverClass), by default just the class name.
Typically called from the $Initialize() method of the proxy class.</p>
</dd>
<dt><code>ProxyClassName(serverClass)</code></dt><dd><p>If there is a proxy class defined corresponding to this serverClass, return the name
of that class (typically pasted with the server langauge, separated by underscore).  If no
such class is defined, return NA.</p>
</dd>
<dt><code>ProxyClassObject(object)</code></dt><dd><p>If 'object' is an assigned proxy, check whether the serverClass is a known proxy class
and if so, return an object from that class; otherwise return 'object'.</p>
</dd>
<dt><code>ProxyName(x, new = TRUE)</code></dt><dd><p>Called without arguments, returns a key for the next proxy object.  In the default strategy, this is a string
&quot;R_i_j&quot; where i is the sequence code for the evaluator and j is the proxy count,
incremented if 'new' is TRUE.  If 'x' is supplied as an existing proxy object,
returns the key for that object.</p>
</dd>
<dt><code>SaveProxyFunction(save, object, objName = obj@name, docText = NULL)</code></dt><dd><p>The object is an expanded function definition, provided by the initialize method for this class.
'save' should be either an environment in which to assign it or a place to dump the R source, either an
open connection or a file name.</p>
</dd>
<dt><code>Send(object, serverClass = "", .key = NULL)</code></dt><dd><p>Send the converted version of 'object' to the server language.
If '.key' is specified, assign it under that name.  By default (and recommended)
a proxy object in R provides the name for the converted object.
If 'serverClass' is supplied, there should be a corresponding asServerObject() method.</p>
</dd>
<dt><code>Serialize(object, file, append = FALSE)</code></dt><dd><p>Use the server language serialization to serialize 'object' to the specified 'file'.
According to 'append' either append to the file (default) or overwrite.
The supplied object should be a proxy for a server language object.</p>
</dd>
<dt><code>ServerClass(Class, module)</code></dt><dd><p>If possible, return the class structure of Class, a class in the server language.
module= is the server module/package/library in which Class is defined, or &quot;&quot;.
If no reflection information is available, return NULL (which this definition does).
Should return a list or reference object: &quot;$fields&quot; and &quot;$methods&quot; should be character
vectors or named lists of the server fields and metohds.</p>
</dd>
<dt><code>ServerClassDef(Class, module, ...)</code></dt><dd><p>Individual interface packages will define this to return a named list or other object such that value$fields and value$methods are the server fields and methods, character vectors
of names or named objects whose elements give further information.  This default version
returns NULL, indicating that no metadata is available.</p>
</dd>
<dt><code>ServerEval(expr, key, get)</code></dt><dd><p>Must be defined by the server language interface: evaluates 'expr'(a text string).
If 'key' is an empty string, 'expr' is treated as a directive, with no defined value.
Otherwise, 'key' is a non-empty string, and the server
object should be assigned with this name. The value returned is the R result, which may
be an AssignedProxy() object. If 'get' is TRUE or the value judged simple enough,
it will be converted to an ordinary R object instead.</p>
</dd>
<dt><code>ServerExpression(...)</code></dt><dd><p>The arguments define an expression in the server language.
The first argument is a string; any others are objects to be substituted for 
in the string.  These can include proxy objects or R data.</p>
</dd>
<dt><code>ServerFunctionDef(name, module = "", ...)</code></dt><dd><p>The XR method defines the proxy function with no special metadata information.
Server langugae metadata may be used by a method that overrides this one, and calls it.</p>
</dd>
<dt><code>ServerRemove(key)</code></dt><dd><p>Should be defined by the server language interface:
The reference previously created for 'key' should be removed.
What happens has no effect on the client side; the intent is to potentially recover memory.</p>
</dd>
<dt><code>ServerSerialize(key, file)</code></dt><dd><p>Serialize the proxy function corresponding to 'key' to the specified 'file'.
Will normally be defined using the serialization supported by the particular server
language. The default gets the object and serializes in R, so only works if conversion does</p>
</dd>
<dt><code>ServerUnserialize(file, all)</code></dt><dd><p>Unserialize the file, returning a proxy object for a list, or equivalent in the server
language, of all the objects serialized to this file.  Because open connections can not
generally be shared among languages, must unserialize the entire file.</p>
</dd>
<dt><code>Shell(endCode = "quit", prompt = "&gt;&gt;&gt;: ", cont = "+++: ")</code></dt><dd><p>Starts an interactive shell.  Each line of input must be a complete expression
or statement in the server language. To continue over multiple lines, append an unescaped
backslash to all but the last line.
</p>
<p>A line typed to the shell starting with &quot;$&quot; is an escape back to the evaluator, and
can be used to call evaluator methods, e.g., &quot;ProxyName(x)&quot;.  See the example in
the documentation for class &quot;Interface&quot; in XR</p>
</dd>
<dt><code>Source(filename)</code></dt><dd><p>Parse and evaluate the contents of the file.  This method is likely to be overriden for particular langauges
with a directive to include the contents of the file.  The 'XR' version reads the file and processes the entire contents
as a single string, newlines inserted between lines of the file.</p>
</dd>
<dt><code>startupActions()</code></dt><dd><p>Perform the evaluator actions specified for this object, typically additions to search path and imports</p>
</dd>
<dt><code>Unserialize(file, all = FALSE)</code></dt><dd><p>Unserialize a list of objects previously written to 'file' by $Serialize().
Returns a list of proxy objects. If all=FALSE, returns a single object if exactly one object found.</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='InterfaceCondition-class'>Classes of objects representing errors or other conditions in a server language</h2><span id='topic+InterfaceCondition-class'></span><span id='topic+InterfaceError-class'></span><span id='topic+InterfaceWarning-class'></span>

<h3>Description</h3>

<p>Errors and warnings generated in evaluating an expression in the server language will
be returned to R as objects from one of these classes.
The interface evaluator will normally throw an error for <code>"InterfaceError"</code> and
issue a warning for <code>"InterfaceWarning"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>message</code></dt><dd><p>The character string message from the server language evaluator.</p>
</dd>
<dt><code>value</code></dt><dd><p>In the case of a warning, the object to return after issuing the condition.</p>
</dd>
<dt><code>expr</code></dt><dd><p>The expression sent to the server language that produced the condition.</p>
</dd>
<dt><code>evaluator</code></dt><dd><p>The interface evaluator object receiving the condition.</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='isProxy'>Test if an Object is a Proxy</h2><span id='topic+isProxy'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if <code>object</code> is either a simple proxy or an object from a proxy class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isProxy(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isProxy_+3A_object">object</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>

<hr>
<h2 id='MiscMethods'>Miscellaneous methods</h2><span id='topic+MiscMethods'></span><span id='topic++24+2CAssignedProxy-method'></span><span id='topic++24+3C-+2CAssignedProxy-method'></span>

<h3>Description</h3>

<p>Convenience methods are provided for operator <code>$</code> to give more informative error messages
if <code>AssignedProxy</code> objects are assumed
incorrectly to have a proxy class definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AssignedProxy'
x$name

## S4 replacement method for signature 'AssignedProxy'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MiscMethods_+3A_x">x</code>, <code id="MiscMethods_+3A_name">name</code>, <code id="MiscMethods_+3A_value">value</code></td>
<td>
<p>Arguments to the operator.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='nameQuote'>Plain Double Quote for Names</h2><span id='topic+nameQuote'></span>

<h3>Description</h3>

<p>Utility to surround names of classes, etc with double quotes (not the single quotes of
shQuote or the fancy quotes of dQuote)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nameQuote(what)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nameQuote_+3A_what">what</code></td>
<td>
<p>the input string.  Should be a name or something without quotes at least.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the string with quotes.  But empty strings stay empty.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='noScalar'>Send a Non-scalar Version of an Object</h2><span id='topic+noScalar'></span>

<h3>Description</h3>

<p>Ensures that an object is interpreted as a vector (array) when sent to the server language.
The default strategy is to send length-1 vectors as scalars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noScalar(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noScalar_+3A_object">object</code></td>
<td>
<p>A vector object.  Calling with a non-vector is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object, but with the S4 bit turned on.
Relies on the convention that XR interfaces leave S4 objects
as vectors, not scalars, even when they are of length 1
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='objectAsJSON'>Construct a String in JSON Notation to Represent an R Object</h2><span id='topic+objectAsJSON'></span><span id='topic+objectAsJSON+2Carray-method'></span><span id='topic+objectAsJSON+2Cenvironment-method'></span><span id='topic+objectAsJSON+2Clist-method'></span><span id='topic+objectAsJSON+2CenvRefClass-method'></span><span id='topic+objectAsJSON+2CInterface-method'></span><span id='topic+objectAsJSON+2CAssignedProxy-method'></span><span id='topic+objectAsJSON+2CProxyClassObject-method'></span>

<h3>Description</h3>

<p>The XR structure requires a server-language function <code>objectFromJSON()</code> which
parses an object description in JSON.  Methods for generic function <code>objectAsJSON()</code>
should produce the appropriate string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectAsJSON(object, prototype = prototypeObject(), level = 1)

## S4 method for signature 'array'
objectAsJSON(object, prototype = prototypeObject(),
  level = 1)

## S4 method for signature 'environment'
objectAsJSON(object, prototype = prototypeObject(),
  level = 1)

## S4 method for signature 'list'
objectAsJSON(object, prototype = prototypeObject(),
  level = 1)

## S4 method for signature 'envRefClass'
objectAsJSON(object, prototype = prototypeObject(),
  level = 1)

## S4 method for signature 'Interface'
objectAsJSON(object, prototype = prototypeObject(),
  level = 1)

## S4 method for signature 'AssignedProxy'
objectAsJSON(object, prototype = prototypeObject(),
  level = 1)

## S4 method for signature 'ProxyClassObject'
objectAsJSON(object,
  prototype = prototypeObject(), level = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objectAsJSON_+3A_object">object</code></td>
<td>
<p>The object to be converted.</p>
</td></tr>
<tr><td><code id="objectAsJSON_+3A_prototype">prototype</code></td>
<td>
<p>The prototype server class; see <code><a href="#topic+asServerObject">asServerObject</a></code>.</p>
</td></tr>
<tr><td><code id="objectAsJSON_+3A_level">level</code></td>
<td>
<p>Will be 1 for top-level call, incremented when recalled for an element.
Used to make choices about scalars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically called from a method for <code><a href="#topic+asServerObject">asServerObject</a></code>.
Methods for <code>objectAsJSON()</code> in turn often call one or both of two helper functions:
<code><a href="#topic+asJSONS4">asJSONS4</a>()</code>, which produces the full description of the <span class="rlang"><b>R</b></span> object; and
<code><a href="#topic+typeToJSON">typeToJSON</a>()</code>, which produces the code for the basic <span class="rlang"><b>R</b></span> types, ignoring all
class or attribute information.
</p>


<h3>Value</h3>

<p>A string that will be parsed according to JSON grammar.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>array</code>: treat matrix and array objects as legitimate S3 objects
</p>
</li>
<li> <p><code>environment</code>: An environment is encoded with its class, in contrast to a named list
which may be a simple dictionary.
</p>
</li>
<li> <p><code>list</code>: A list will be encoded as a JSON list if it has no names, as a JSON
dictionary if it has all distinct, non-empty names, or with an explicit representation in
all other cases.
</p>
</li>
<li> <p><code>envRefClass</code>: An explicit representation that includes the fields.
</p>
</li>
<li> <p><code>Interface</code>: An interface object is transmitted via its character string Id,
enough to identify the object; the rest is too R-dependent to be useful.
</p>
</li>
<li> <p><code>AssignedProxy</code>: Gets the object back from the server, then recalls the generic.
It's usually not a good idea to get here, because bringing the proxy back and then converting
it again is not foolproof; better to make direct use of the proxy.  But if a proxy object
is part of an ordinary list, environment or other R object, this method will be used.
</p>
</li>
<li> <p><code>ProxyClassObject</code>: Gets the object back from the server, then recalls the generic.
See the comments under the <code>"AssignedProxy"</code> method.
</p>
</li></ul>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='objectDictionary'>Generate the Explicit Dictionary form for an R Object</h2><span id='topic+objectDictionary'></span>

<h3>Description</h3>

<p>The XR interface strategy uses an explicit named list (i.e., dictionary) to describe an R object
from a particular class.  This function creates the suitable form for such a dictionary, based on
the formal class or the contents of an object.  Used by some interface packages (e.g., XRJulia) but
likely only of information value otherwise, to tell you how to code an object in the server language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectDictionary(object, exclude = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objectDictionary_+3A_object">object</code></td>
<td>
<p>the object to use to infer the representation</p>
</td></tr>
<tr><td><code id="objectDictionary_+3A_exclude">exclude</code></td>
<td>
<p>slots or the like that should <em>not</em> be in the dictionary form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with the required entries, e.g., <code>".RClass"</code>.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='packageSetup'>Execute a Setup Step for a Package</h2><span id='topic+packageSetup'></span>

<h3>Description</h3>

<p>The R code in one or more files is evaluated to carry out setup computations that will
write some code, documentation or anything else into the source directory of an R package.
Designed for package authors who want to use techniques such as the proxy classes in the
XR set of interfaces, <code>compileAttributes()</code> in Rcpp or inline documentation in roxygen2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packageSetup(file = "setup.R", dir = ".", needPackage = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="packageSetup_+3A_file">file</code></td>
<td>
<p>The name of the files to be parsed and evaluated for the setup step,  by default,
<code>"setup.R"</code>.  Will look in the the current directory or the inst/tools directory
for a file of this name.</p>
</td></tr>
<tr><td><code id="packageSetup_+3A_dir">dir</code></td>
<td>
<p>Optional directory to use as the working directory for the evaluation. By default
the current working directory should be the source directory for the package.</p>
</td></tr>
<tr><td><code id="packageSetup_+3A_needpackage">needPackage</code></td>
<td>
<p>The package for which the setup is intended.  Not needed if the working
directory (either currently or given by <code>dir</code> is the source directory for that package.
If supplied can be either the package name or <code>FALSE</code> if the setup is not intended for
a package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computations will be carried out in an environment constructed by<code>packageSetup()</code>
with the namespace of the package as its parent, and a <code>.packageName</code> object to
associate it with the package.  By default, the setup step looks for the <code>DESCRIPTION</code> file in the
working directory to find the package name.  The package must have been installed in the
library path of this R session.
</p>

<hr>
<h2 id='ProxyClass-class'>A Class to Describe Classes in the Server Language</h2><span id='topic+ProxyClass-class'></span><span id='topic+ProxyClass'></span>

<h3>Description</h3>

<p>Used by initialize() methods for proxy class objects and therefore exported for the sake of
packages using the XR model.  Not typically needed by end users.
</p>


<h3>Fields</h3>


<dl>
<dt><code>ServerClass</code></dt><dd><p>the name of the corresponding server language class.</p>
</dd>
<dt><code>language</code></dt><dd><p>the name of the server language (locked)</p>
</dd>
<dt><code>evaluatorClass</code></dt><dd><p>the class for an interface evaluator for this proxy class.</p>
</dd>
</dl>

<hr>
<h2 id='ProxyClassObject-class'>A Class for Objects that are Proxies for Specific Server Class Objects</h2><span id='topic+ProxyClassObject-class'></span><span id='topic+ProxyClassObject'></span>

<h3>Description</h3>

<p>This class is extended by all specific proxy classes for a particular language.
If a proxy object is returned from the server language whose server class matches a
defined proxy class, then an object from that class is generated.
</p>


<h3>Fields</h3>


<dl>
<dt><code>.proxyObject</code></dt><dd><p>the actual proxy reference</p>
</dd>
<dt><code>.proxyClass</code></dt><dd><p>the description of the server language class (name, module, langauge)</p>
</dd>
<dt><code>.ev</code></dt><dd><p>the evaluator that produced this proxy object.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>proxyName()</code></dt><dd><p>the character string under which the server language object is assigned.
Useful to examine the object in a shell for the server language.</p>
</dd>
<dt><code>size()</code></dt><dd><p>returns the server-language size of the object, possibly NA</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='proxyEvaluator'>The Evaluator Function Object Referred to from a Proxy Objec</h2><span id='topic+proxyEvaluator'></span>

<h3>Description</h3>

<p>Any proxy for a server language object contains a reference to the interface evaluator object
used to create the proxy object.  This function retrieves the evaluator (whether or not there is
a proxy class for this object).  The function is called from specialized methods for particular
server langauge classes, as part of a package using the XR package.  End users will not typically
need to call it directly; it is exported to simplify life for the extending package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proxyEvaluator(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proxyEvaluator_+3A_object">object</code></td>
<td>
<p>any proxy object</p>
</td></tr>
</table>

<hr>
<h2 id='ProxyFunction-class'>A Class for Proxy Functions</h2><span id='topic+ProxyFunction-class'></span><span id='topic+ProxyFunction'></span>

<h3>Description</h3>

<p>A class for functions in R that call functions in a server language.  The arguments in a call are converted to
equivalent server language objects, via <code><a href="#topic+asServerObject">asServerObject</a>()</code>.  These usually include proxy
objects in R for results previously computed through the same interface evaluator.
</p>


<h3>Details</h3>

<p>This class is always subclassed for a particular server language.  Proxy functions for that
language will use a corresponding evaluator to find metadata about the server function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>the function</p>
</dd>
<dt><code>name</code></dt><dd><p>the name of the server language function</p>
</dd>
<dt><code>module</code></dt><dd><p>the name of the module, if that needs to be imported</p>
</dd>
<dt><code>evaluatorClass</code></dt><dd><p>the class for the evaluator, identifying which server lanaguage is involved.</p>
</dd>
<dt><code>serverDoc</code></dt><dd><p>documentation for the server language function</p>
</dd>
<dt><code>serverArgs</code></dt><dd><p>the formal arguments of the server language function, if known</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='proxyName'>Return the Server Language Name Corresponding to a Proxy Object</h2><span id='topic+proxyName'></span><span id='topic+proxyName+2CAssignedProxy-method'></span><span id='topic+proxyName+2CProxyClassObject-method'></span>

<h3>Description</h3>

<p>Interface evaluators pass constructed names to the server language evaluator, arranged
to be unique within and between evaluators.  This function returns the name when given a
proxy object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proxyName(x)

## S4 method for signature 'AssignedProxy'
proxyName(x)

## S4 method for signature 'ProxyClassObject'
proxyName(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proxyName_+3A_x">x</code></td>
<td>
<p>an object returned from some computation in the server  as a proxy
for that server object.  May be from a proxy class, but doesn't need to be.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>AssignedProxy</code>: for this class, the name is the object (which extends class
&quot;character&quot;)
</p>
</li>
<li> <p><code>ProxyClassObject</code>: this class has a proxy object as a field.
</p>
</li></ul>

<hr>
<h2 id='ProxyObject-class'>Class Union to Represent Proxy Objects</h2><span id='topic+ProxyObject-class'></span>

<h3>Description</h3>

<p>A virtual class to include all classes that can represent proxy objects
in the server language.  May be extended by the interface for a particular language.
</p>

<hr>
<h2 id='ServerClassDef-class'>The Definition of a Server Language Class</h2><span id='topic+ServerClassDef-class'></span><span id='topic+ServerClassDef'></span>

<h3>Description</h3>

<p>The Definition of a Server Language Class
</p>


<h3>Fields</h3>


<dl>
<dt><code>fields,methods</code></dt><dd><p>named lists of the server language fields and methods to be exported</p>
</dd>
<dt><code>operators</code></dt><dd><p>named list of the server class methods that are &quot;operator overloading&quot; of functions.</p>
</dd>
<dt><code>readOnly</code></dt><dd><p>the names of any fields that should be made read-only in the R class</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='serverFields-class'>Class Union for Describing Server Language Fields</h2><span id='topic+serverFields-class'></span>

<h3>Description</h3>

<p>May be extended by the interface for a particular language.
</p>

<hr>
<h2 id='setProxyClass'>Create a Proxy Class</h2><span id='topic+setProxyClass'></span>

<h3>Description</h3>

<p>Creates a proxy class of a given name and other requirements.
Usually infers fields and methods from server language metadata, but can also
use explicitly supplied values.  Particular interface packages will typically have
a specialized version that calls this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setProxyClass(Class, module = "", fields = character(), methods = NULL,
  ServerClass = Class, where = topenv(parent.frame()),
  contains = character(), evaluatorClass,
  proxyObjectClass = "ProxyClassObject", language = if (is.null(evaluator))
  "" else evaluator$languageName, readOnly = NULL, ..., save = FALSE,
  objName = Class, docText = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setProxyClass_+3A_class">Class</code></td>
<td>
<p>the name of the class to be used in the proxy, usually just the server language class.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_module">module</code></td>
<td>
<p>the name of the server langauge module if it needs to be imported.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_fields">fields</code>, <code id="setProxyClass_+3A_methods">methods</code></td>
<td>
<p>explicit field and method information if this cannot be found by inspection. Normally omitted.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_serverclass">ServerClass</code></td>
<td>
<p>the name of the server language class, normall defaults to <code>Class</code>.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_where">where</code></td>
<td>
<p>the environment for the class definition.  By default, and nearly always, the namespace of the
package in which the call to <code>setProxyClass()</code> occurs.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_contains">contains</code></td>
<td>
<p>explicitly needed superclasses if any.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_evaluatorclass">evaluatorClass</code></td>
<td>
<p>the evaluator class to identify the evaluator, e.g.  <code>"PythonInterface"</code> for Python.
By default, the current evaluator class.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_proxyobjectclass">proxyObjectClass</code></td>
<td>
<p>The general class for proxy objects in this interface.  Typically
obtained automatically from the <code>prototypObject</code> field of the evaluator.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_language">language</code></td>
<td>
<p>the server language, taken from the evaluator if one is found.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_readonly">readOnly</code></td>
<td>
<p>character vector of any field names that should be marked read-only.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_...">...</code></td>
<td>
<p>extra arguments to pass on to <code>setRefClass()</code>.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_save">save</code></td>
<td>
<p>If the proxy class is being defined in an application package,
use this to write to a source file (see Ch. 12 of Extending R)
Default <code>FALSE</code>, if the proxy class is being assigned in the installation or load of a package.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_objname">objName</code></td>
<td>
<p>When using the <code>save=</code> argument to write R code, use this name in the
assignment expression for the generator object.  By default, the name of the class.</p>
</td></tr>
<tr><td><code id="setProxyClass_+3A_doctext">docText</code></td>
<td>
<p>metadata information supplied by the interface for a particular
server language.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A proxy class has fields and methods that are created to use the corresponding fields
and methods of the server language, through an interface evaluator.  This function
normally expects information about the class to be returned by the <code>$ServerClassDef()</code>
method of the evaluator, specialized to the language. It can also be called with explicit
lists for the fields and methods.  The actual fields and methods will use the interface to
access or call the corresponding code in the server language.
</p>


<h3>Value</h3>

<p>a generator object for the R class, along with the side effect of setting the class definition.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='typeToJSON'>Convert a Simple Object to JSON String</h2><span id='topic+typeToJSON'></span>

<h3>Description</h3>

<p>Convert a simple object (should have no attributes or formal class) to JSON string.
Called from some specific interface packages, usually to put quotes and escapes into a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typeToJSON(object, prototype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="typeToJSON_+3A_object">object</code></td>
<td>
<p>the object to convert; only its type will be used to select format</p>
</td></tr>
<tr><td><code id="typeToJSON_+3A_prototype">prototype</code></td>
<td>
<p>the prototype object, supplied from the evaluator calling this function</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='Unconvertible-class'>Unconverted Server Language Objects</h2><span id='topic+Unconvertible-class'></span>

<h3>Description</h3>

<p>Objects from this class represent server language objects whose conversion was requested
but which are judged (by the server side of the interface) to have no equivalent R form.
Rather than generating an error, the interface returns an object of this class, which can
have convertible attributes.  Fields of a convertible object may be unconvertible without
preventing conversion of the rest of the parent object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>serverClass,serverModule</code></dt><dd><p>The names of the class and module in the server language.</p>
</dd>
<dt><code>language</code></dt><dd><p>The language name (for communicating with users), not the interface class name.</p>
</dd>
<dt><code>attributes</code></dt><dd><p>A list with names that should be interpreted as properties of the object.</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='valueFromServer'>Convert the String Returned by a Server Language Interface to an R Object.</h2><span id='topic+valueFromServer'></span>

<h3>Description</h3>

<p>This is the conversion mechanism for results returned from a server language interface.
By default, JSON is used to decode the string.  Otherwise the result of the basic
decoding should be provided as argument <code>object</code>.
Should be called by the implementation of ServerEval for individual interface classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valueFromServer(string, key, get, evaluator, object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valueFromServer_+3A_string">string</code></td>
<td>
<p>the string to be passed to JSON.</p>
</td></tr>
<tr><td><code id="valueFromServer_+3A_key">key</code></td>
<td>
<p>the key if a proxy was allowed, otherwise the empty string.</p>
</td></tr>
<tr><td><code id="valueFromServer_+3A_get">get</code></td>
<td>
<p>the logical controling whether a proxy or a converted value was wanted.</p>
</td></tr>
<tr><td><code id="valueFromServer_+3A_evaluator">evaluator</code></td>
<td>
<p>the evaluator object that issued the server language expression.</p>
</td></tr>
<tr><td><code id="valueFromServer_+3A_object">object</code></td>
<td>
<p>If JSON is not used, the call from the server language method should provide the
elementary conversion of the result (without using <code>asRObject()</code> and the string argument
should be omitted.  If JSON is used, <code>object</code> should be computed by default from JSON.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the R object implied by the server result.
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='vector_R-class'>A class that facilitates returning R vectors via a list in JSON</h2><span id='topic+vector_R-class'></span><span id='topic+vector_R'></span>

<h3>Description</h3>

<p>Server language code will return a dictionary in which data= is a JSON-style list
and type= is the R vector type desired.  See the asRObject() method documentation.
Objects from this class can also be generated in R, usually supplying just <code>data</code>
and generating the other slots from that object's properties.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>The actual vector data.</p>
</dd>
<dt><code>type</code></dt><dd><p>The string for the <span class="rlang"><b>R</b></span> type intended. In spite of the slot name, this really the class;
for example, &quot;numeric&quot; rather than &quot;double&quot;.</p>
</dd>
<dt><code>missing</code></dt><dd><p>The index of NA's in this vector.  Needed because most server languages only
treat 'NaN' for doubles and have no mechanism for 'NA' in other types.</p>
</dd>
</dl>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 13, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:2,NA,4:5)
vector_R(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
