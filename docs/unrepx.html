<!DOCTYPE html><html lang="en"><head><title>Help for package unrepx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unrepx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unrepx-package'>
<p>Analysis and graphics for unreplicated experiments</p></a></li>
<li><a href='#daniel.paper'><p>Half-normal graph paper</p></a></li>
<li><a href='#dot.plot'><p>Resizeable dot plots</p></a></li>
<li><a href='#hnplot'><p>Half-normal plots (Daniel plots) of effects</p></a></li>
<li><a href='#parplot'><p>Pareto plot of effects</p></a></li>
<li><a href='#pdEff'>
<p>Effect examples</p></a></li>
<li><a href='#PSE'><p>Pseudo standard error of effects</p></a></li>
<li><a href='#ref.dist'><p>Analysis of effects from screening experiments</p></a></li>
<li><a href='#refplot'><p>Dot plot of effects with a reference distribution</p></a></li>
<li><a href='#yates'><p>Yates's algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis and Graphics for Unreplicated Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-11</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rvlenth/unrepx/issues">https://github.com/rvlenth/unrepx/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides half-normal plots, reference plots, and Pareto plots
    of effects from an unreplicated experiment, along with various 
    pseudo-standard-error measures, simulated reference distributions, 
    and other tools. Many of these methods are described in 
    Daniel C. (1959) &lt;<a href="https://doi.org/10.1080%2F00401706.1959.10489866">doi:10.1080/00401706.1959.10489866</a>&gt; and/or
    Lenth R.V. (1989) &lt;<a href="https://doi.org/10.1080%2F00401706.1989.10488595">doi:10.1080/00401706.1989.10488595</a>&gt;, but some new
    approaches are added and integrated in one package.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-11 21:21:56 UTC; rlenth</td>
</tr>
<tr>
<td>Author:</td>
<td>Russell Lenth [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Russell Lenth &lt;russell-lenth@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-11 21:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='unrepx-package'>
Analysis and graphics for unreplicated experiments
</h2><span id='topic+unrepx-package'></span><span id='topic+unrepx'></span>

<h3>Description</h3>

<p>Provides half-normal plots, reference plots, and Pareto plots
of effects from an unreplicated experiment, along with various PSE
measures, simulated reference distributions, and other tools
</p>


<h3>Details</h3>

<p>See the package vignette: <code>vignette("overview", package="unrepx")</code>
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>
<p>Maintainer: Russell V. Lenth &lt;russell-lenth@uiowa.edu&gt;
</p>

<hr>
<h2 id='daniel.paper'>Half-normal graph paper</h2><span id='topic+daniel.paper'></span>

<h3>Description</h3>

<p>The <code>daniel.paper</code> function draws a graph-paper grid suitable for manually constructing a half-normal plot of effects. The paper is customized to the number of effects to be plotted, thus making the task as simple as possible.</p>


<h3>Usage</h3>

<pre><code class='language-R'>daniel.paper(n.effects = 15, linear = 0:40, a = 0.375, 
    rank.axis = c("y", "x"), type = c("half.normal", "normal"), 
    theme = "blue", lin.lab, rank.lab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daniel.paper_+3A_n.effects">n.effects</code></td>
<td>
<p>Numeric vector of effects or contrasts to be explored.</p>
</td></tr>
<tr><td><code id="daniel.paper_+3A_linear">linear</code></td>
<td>
<p>sequence of numbers to use for the linear scale.</p>
</td></tr>
<tr><td><code id="daniel.paper_+3A_a">a</code></td>
<td>
<p>The adjustment used in scaling and centering ranks in the interval (0, 1). The <code class="reqn">i</code>th ordered (half-) normal score is computed as the <code class="reqn">(i - a) / (n + 1 - 2*a)</code> quantile of the reference distribution. The value should always be less than 1, and is recommended to be in [0,.5]. The scale becomes somewhat more nonlinear as <code class="reqn">a</code> increases. </p>
</td></tr>
<tr><td><code id="daniel.paper_+3A_rank.axis">rank.axis</code></td>
<td>
<p>Character value of <code>"y"</code> or <code>"x"</code> selecting whether the ranks of effects should be plotted as the vertical or the horizontal coordinate.</p>
</td></tr>
<tr><td><code id="daniel.paper_+3A_type">type</code></td>
<td>
<p>Character value matching <code>"half.normal"</code> or <code>"normal"</code> specifying whether the scaling is for a half-normal or a normal plot. The latter is not recommended.</p>
</td></tr>
<tr><td><code id="daniel.paper_+3A_theme">theme</code></td>
<td>
<p>Character giving the name of the theme to use for the grid lines. The default of <code>"blue"</code> plots the major grid lines in blue and the minor ones in cyan. Other built-in themes are <code>"bw"</code> (black majors, and dotted black minors), <code>"gray"</code> (black majors and gray minors), and <code>"bold"</code> (all lines black, but major lines are heavier). See details below for information on how to create one's own theme.</p>
</td></tr>
<tr><td><code id="daniel.paper_+3A_lin.lab">lin.lab</code>, <code id="daniel.paper_+3A_rank.lab">rank.lab</code></td>
<td>
<p>Labels for the linear and rank scales.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use of <code>type = "normal"</code> is discouraged, as is discussed in the Details section in <code><a href="#topic+hnplot">hnplot</a></code>.
</p>
<p>A custom theme, say <code>"foo"</code>, may be created by creating a <code>list</code> named <code>foo_thm</code>, which should contain two elements named <code>major</code> and <code>minor</code>, and (optionally) <code>axis</code>. <code>major</code> must be a named <code>list</code> with graphical parameters <code>col</code>, <code>lty</code>, and <code>lwd</code> as described in <code><a href="graphics.html#topic+par">par</a></code>. <code>minor</code> only requires <code>col</code> and <code>lty</code>, as minor lines are always drawn using <code>lwd = 1</code>. <code>axis</code> must contain <code>col</code> and <code>lwd</code>, which are used for the tick marks and labels on the rank scale. If <code>axis</code> is not included, <code>major</code> is used.
</p>


<h3>Value</h3>

<p>Nothing is returned.</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>References</h3>

<p>Daniel, C (1959)
Use of Half-Normal Plots in Interpreting Factorial Two-Level Experiments.
<em>Technometrics</em>, 1(4), 311-341
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hnplot">hnplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

old.par &lt;- par(mar = c(5, 5, 1, 1) + .1)
daniel.paper(15)

neon_thm &lt;- list(
    major = list(col = "green", lty = 1, lwd = 2),
    minor = list(col = "orange", lty = 1),
    axis = list(col = "magenta", lwd = 2)
)
daniel.paper(31, rank.axis = "x", theme = "neon")

par(old.par)
</code></pre>

<hr>
<h2 id='dot.plot'>Resizeable dot plots</h2><span id='topic+dot.plot'></span><span id='topic+dot.id'></span><span id='topic+dot.mod'></span>

<h3>Description</h3>

<p>Flexible stacked-dot plots of relatively small samples, and provisions for identifying points. The dot plot is responsive to resizing of the plot window: a vertical resizing does not affect the vertical spacing of the dots, and a horizontal resizing may lead to re-binning to fit well within the range.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot.plot(x, pch = 16, cex.dot = 1, spacing = 1, xlab, xlim = range(x), ...)

dot.id(env, height.id = 2, cex.id = 1, col.id = "black")
dot.mod(env, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dot.plot_+3A_x">x</code></td>
<td>
<p>Numeric vector of values to be plotted.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_pch">pch</code></td>
<td>
<p>Plotting character for the dots. Default is a filled circle.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_cex.dot">cex.dot</code></td>
<td>
<p>Size of dots relative to <code>par("cex")</code>.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_spacing">spacing</code></td>
<td>
<p>Factor for adjusting the vertical spacing of stacked dots.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_xlab">xlab</code>, <code id="dot.plot_+3A_xlim">xlim</code></td>
<td>
<p>The usual graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>), but used by <code>dot.plot</code> or <code>dot.id</code>.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_env">env</code></td>
<td>
<p>Environment returned by <code>dot.plot</code>.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_height.id">height.id</code></td>
<td>
<p>Height (in character heights) above the horizontal axis for displaying identification labels.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_cex.id">cex.id</code>, <code id="dot.plot_+3A_col.id">col.id</code></td>
<td>
<p><code>cex</code> and <code>col</code> settings for labeling identified points.</p>
</td></tr>
<tr><td><code id="dot.plot_+3A_...">...</code></td>
<td>
<p>In <code>dot.plot</code>, additional graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) used in constructing the plot. In <code>dot.mod</code>, parameters to modify, from among <code>cex.dot</code>, <code>cex.id</code>, <code>col.id</code>, and <code>height.id</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dot.id</code> and <code>dot.mod</code> work only with interactive graphics devices.
</p>
<p>The <code>dot.id</code> works similarly to <code><a href="graphics.html#topic+identify">identify</a></code>, but all dots in a particular stack are identified at once. The user should click along the bottom row of dots. No labels are displayed until the user exits identify mode (and then it may be necessary to refresh the plot by resizing it slightly). Also, the points that are labeled may change if the plot is resized horizontally, because only the x values are actually identified.
</p>
<p>The user may call <code>dot.id(..., modify = FALSE)</code> more than once, if it is desired to change which values are identified.
</p>
<p>After a call to <code>dot.id</code> or (especially) to <code>dot.mod</code>, the graph may need to be refreshed. There appears to be no standard way to do this, so the user may need to resize its window slightly.
</p>


<h3>Value</h3>

<p><code>dot.plot</code> returns an environment that is used to hold information on points that are identified. <code>dot.id</code> modifies this environment; it (invisibly) returns the currently identified x values. (These are values from the original call to <code>dot.plot</code>, not their rounded values used in the plot.)</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

educ = swiss$Education
names(educ) = abbreviate(row.names(swiss))
dp &lt;- dot.plot(educ, xlab = "Percent Post-Primary Education (Switzerland, 1888)")

## Not run: 
    dot.id(dp)
    
    dot.mod(dp, height.id = 3, cex.id = .5)

## End(Not run)
</code></pre>

<hr>
<h2 id='hnplot'>Half-normal plots (Daniel plots) of effects</h2><span id='topic+hnplot'></span>

<h3>Description</h3>

<p>The <code>hnplot</code> function constructs a (half-) normal plot of effects (see Daniel 1959) that is traditionally used to identify active effects in a screening experiment. Reference lines and various other options and extensions are supported.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hnplot(effects, ref = TRUE, half = TRUE, horiz = TRUE, method = "Zahn", 
       a = 0.375, col = half, pch = 16, ID = FALSE, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hnplot_+3A_effects">effects</code></td>
<td>
<p>Numeric vector of effects or contrasts to be explored.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_ref">ref</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, a reference line is added to the plot determined by <code>method</code>. If <code>FALSE</code>, no reference is shown.
</p>
</td></tr>
<tr><td><code id="hnplot_+3A_half">half</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, a plot based on the absolute effects is constructed. If <code>FALSE</code> (not recommended: see Details), the original signed effects are used.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_horiz">horiz</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the (absolute) effects are plotted on the horizontal scale and the (half-) normal scores or labels are plotted on the vertical scale. If <code>FALSE</code>, these axes are reversed.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_method">method</code></td>
<td>
<p>Character value. When <code>ref</code> is <code>TRUE</code>, the method to use in determining the reference line, curve, and/or critical values. This must be the name of a provided pseudo-standard-error method (see <code><a href="#topic+PSE">PSE</a></code>), or a compatible user-supplied one.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_a">a</code></td>
<td>
<p>The adjustment used in scaling and centering ranks in the interval (0, 1). The <code class="reqn">i</code>th ordered (half-) normal score is computed as the <code class="reqn">(i - a) / (n + 1 - 2*a)</code> quantile of the reference distribution.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_col">col</code></td>
<td>
<p>Scalar or vector of colors; or a logical value. If logical, a value of <code>TRUE</code> colors the positive effects blue, the negative effects red, and any zeros as black. A logical value of <code>FALSE</code> colors them all black.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_pch">pch</code></td>
<td>
<p>Plotting character(s) to use.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value. If specified, a null reference distribution for <code>method</code> is used (see <code><a href="#topic+ref.dist">ref.dist</a></code>) to determine a margin of error (labeled &lsquo;ME&rsquo;) and simultaneous margin of error (labeled &lsquo;SME&rsquo;) corresponding to a significance level of <code>alpha</code>, and reference lines are added to the plot at those positions as an aid to assessing the statistical significance of the effects. This is based on a suggestion in Mee (2015). These reference lines are omitted when <code>alpha</code> is left unspecified.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_id">ID</code></td>
<td>
<p>Logical or numeric value. If logical and <code>TRUE</code>, then after the plot is contructed, the plot is put in <code><a href="graphics.html#topic+identify">identify</a></code> mode, where the user may click on points to be labeled on the plot. If a numeric value is supplied, it is used as a threshold by which all effects greater than <code>ID[1]</code> in absolute value are labeled.</p>
</td></tr>
<tr><td><code id="hnplot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) used in constructing the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use of <code>half = FALSE</code> is not recommended because it can be misleading to the user. Inactive effects are those that are close to zero, and a regular normal plot displays deviations from normality rather than deviations from zero.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>References</h3>

<p>Daniel, C (1959)
Use of Half-Normal Plots in Interpreting Factorial Two-Level Experiments.
<em>Technometrics</em>, 1(4), 311-341
</p>
<p>Mee, R (2015) 
Discussion: Better, not Fewer, Plots. 
<em>Journal of Quality Technology</em>, 47(2), 107-109
</p>


<h3>See Also</h3>

<p>Other ways of assessing active effects include a dot plot with a reference curve (<code><a href="#topic+refplot">refplot</a></code>), a pareto plot of effects (see <code><a href="#topic+parplot">parplot</a></code>), and a tabular style of presenting effects and <code class="reqn">P</code> values (see <code>eff.test</code>). For more information on methods, see <code><a href="#topic+PSE">PSE</a></code> and <code><a href="#topic+ref.dist">ref.dist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

hnplot(pdEff, ID = ME(pdEff))
</code></pre>

<hr>
<h2 id='parplot'>Pareto plot of effects</h2><span id='topic+parplot'></span>

<h3>Description</h3>

<p>Constructs a bar plot of ordered effects, along with cutoff values for the margin of error (ME) and simultaneous margin of error (SME). Such a plot is suggested in Lenth (1989), but other methods may be used for obtaining the ME and SME.</p>


<h3>Usage</h3>

<pre><code class='language-R'>parplot(effects, pareto = TRUE, absolute = TRUE, horiz = FALSE, col = absolute,
    critvals, method = "Zahn", alpha = .05, refdist, sim.opts, 
    ylab = "Estimated effects", top = n.effects, cex.annot = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parplot_+3A_effects">effects</code></td>
<td>
<p>Numeric vector of effects or contrasts to be explored.</p>
</td></tr>
<tr><td><code id="parplot_+3A_pareto">pareto</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the effects are plotted in decreasing order of their absolute values.</p>
</td></tr>
<tr><td><code id="parplot_+3A_absolute">absolute</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the absolute effects are plotted. If <code>FALSE</code>, the original signed effects are used, so that there are potentially positive- and negative-going bars in the plot.</p>
</td></tr>
<tr><td><code id="parplot_+3A_horiz">horiz</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the bars are horizontal, and if <code>FALSE</code>, they are vertical.</p>
</td></tr>
<tr><td><code id="parplot_+3A_col">col</code></td>
<td>
<p>A logical value, or valid color code(s) or names(s). If logical, a value of <code>TRUE</code> shades the positive effects in light blue, and the negative effects in pink. A logical value of <code>FALSE</code> colors them all light gray.</p>
</td></tr>
<tr><td><code id="parplot_+3A_critvals">critvals</code></td>
<td>
<p>Numeric value(s). If these are provided, the first two elements of <code>critvals</code> are used as the ME and SME respectively (on the absolute scale of the effects). When <code>critvals</code> is specified, <code>method</code>, <code>alpha</code>, and <code>refdist</code> are ignored.</p>
</td></tr>
<tr><td><code id="parplot_+3A_method">method</code></td>
<td>
<p>Character value designating the method to use in determining the margins of error displayed in the plot when <code>critvals</code> is not given. This must be the name of a provided pseudo-standard-error method (see <code><a href="#topic+PSE">PSE</a></code>), or a compatible user-supplied one.</p>
</td></tr>
<tr><td><code id="parplot_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value. A null reference distribution for <code>method</code> is used (see <code><a href="#topic+ref.dist">ref.dist</a></code>) to determine a margin of error (labeled &lsquo;ME&rsquo;) and simultaneous margin of error (labeled &lsquo;SME&rsquo;) corresponding to a significance level of <code>alpha</code>, and reference lines are added to the plot at those positions as an aid to assessing the statistical significance of the effects.</p>
</td></tr>
<tr><td><code id="parplot_+3A_refdist">refdist</code></td>
<td>
<p>A result of <code><a href="#topic+ref.dist">ref.dist</a></code>. If given, it is used to obtain critical values, rather than running a new simulation of the null distribution. The user should be careful that <code>refdist</code> indeed matches <code>method</code> and the number of effects.</p>
</td></tr>
<tr><td><code id="parplot_+3A_sim.opts">sim.opts</code></td>
<td>
<p>A <code>list</code> containing arguments <code>nsets</code> and/or <code>save</code> to pass to <code><a href="#topic+ref.dist">ref.dist</a></code> in case a new reference distribution needs to be simulated. See also details below.</p>
</td></tr>
<tr><td><code id="parplot_+3A_ylab">ylab</code></td>
<td>
<p>Character axis label (overrides the default).</p>
</td></tr>
<tr><td><code id="parplot_+3A_top">top</code></td>
<td>
<p>Numeric value giving the number of effects to display (this may help make all the important effect names visible). When <code>top</code> is less than the number of effects (<code>n.effects</code>), this forces <code>pareto = TRUE</code> and only the largest <code>top</code> effects are displayed. When this happens, an annotation is added to the plot to help clarify that not all effects are displayed.</p>
</td></tr>
<tr><td><code id="parplot_+3A_cex.annot">cex.annot</code></td>
<td>
<p>Character magnification for annotations</p>
</td></tr>
<tr><td><code id="parplot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) used in constructing the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cutoff values displayed in the plot are labeled &ldquo;ME&rdquo;, the margin of error, and &ldquo;SME&rdquo;, the simultaneous margin of error. If not specified using <code>crtivals</code>, they are obtained using the 1-<code>alpha</code> quantiles of the reference distribution of absolute pseudo-<code class="reqn">t</code> ratios. ME is based on the distribution of <code class="reqn">|t|</code>. SME is based on the distribution of the maximum <code class="reqn">|t|</code> for a whole set of null effects.
</p>
<p>In determining cutoff values, <code>parplot</code> tries to avoid re-simulating the reference distribution. Specifically, if the global variable <code>.Last.ref.dist</code> exists, and its contents match the given <code>method</code> and number of effects, it is used as the reference distribution. Similarly, if <code>refdist</code> is supplied, it is used (without checking). If a suitable reference distribution is not found, then it is simulated via <code><a href="#topic+ref.dist">ref.dist</a></code>, with any arguments from <code>sim.opts</code> added.
</p>
<p>If <code>critvals</code> is supplied, the specified values are used as the ME and SME: no reference distribution is needed, and hence <code>method</code>, <code>alpha</code>, and <code>refdist</code> are ignored. 
</p>
<p>The plot is scaled so that the ME cutoff always shows. The SME cutoff will only be visible if an observed effect is near or exceeds that boundary. The numeric values of the ME and SME are also shown in an annotation in the plot.
</p>


<h3>Value</h3>

<p>Invisibly, the vector of the ME and SME values.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>References</h3>

<p>Lenth, R (1989)
Quick and Easy Analysis of Unrelicated Factorials.
<em>Technometrics</em> 31(4), 469-473
</p>


<h3>See Also</h3>

<p>For more details on PSEs and reference distributions, see <code><a href="#topic+PSE">PSE</a></code> and <code><a href="#topic+ref.dist">ref.dist</a></code>. Note that <code>parplot</code> produces in essence a graphical version of the information from <code><a href="#topic+eff.test">eff.test</a></code>, but the latter provides more resolution in terms of <code class="reqn">P</code> values.
</p>
<p>Other graphical ways of assessing active effects include a dot plot with a reference curve (<code><a href="#topic+refplot">refplot</a></code>) and a half-normal plot (see <code><a href="#topic+hnplot">hnplot</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

parplot(pdEff, top = 10)
</code></pre>

<hr>
<h2 id='pdEff'>
Effect examples
</h2><span id='topic+pdEff'></span><span id='topic+bikeEff'></span><span id='topic+viseEff'></span><span id='topic+shnkEff'></span><span id='topic+shnkDisp'></span>

<h3>Description</h3>

<p>Published or simulated examples of effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdEff
bikeEff
viseEff
shnkEff
shnkDisp
</code></pre>


<h3>Format</h3>

<p>Each is a named numeric vector of effect estimates from unreplicated experiments. 
Also, each has an additional <code>mean</code> attribute containing the response mean.
</p>


<h3>Details</h3>


<dl>
<dt>pdEff</dt><dd><p>A vector of 15 effects from a four-factor experiment on process development. The experiment is described in Box, Hunter, and Hunter (2005), Section 5.13, and the effects are tabulated in Table 5.11, page 200. The response variable is conversion percent, and the experiment involves one replication each of each combination of four two-level factors: catalyst charge (C), temperature (T), pressure (P), and concentration (c). (The text labels these factors as 1, 2, 3, and 4 but we elected to use more suggestive alphabetic labels.) The effects are in standard (Yates) order.</p>
</dd>
<dt>bikeEff</dt><dd><p>A vector of 7 effects from a saturated experiment in 8 runs with 7 two-level factors. The experiment is described in Box, Hunter, and Hunter (2005), Section 6.5 and the effects are reported in Table 6.5, page 245. The response variable is time required to climb a particular hill, and the factors are seat height, dynamo, gear, handlebars, raincoat, breakfast, and tires. (Effect labels are abbreviations of these.) The effects are in standard order of the first, second, and fourth factors.</p>
</dd>
<dt>viseEff</dt><dd><p>A vector of 15 effect estimates from a fictitious experiment, simulated by the package developer. The effects are labeled alphabetically, A-O, in stanradr order of A, B, D, and H.</p>
</dd>
<dt>shnkEff, shnkDisp</dt><dd><p>Vectors of location and dispersion effects, respectively, from the speedometer-cable shrinkage example discussed in Box, Hunter, and Hunter (2005), Section 6.14. Each vector is of length 15. The effect names are 4-letter abbreviations of the factor names. Effects are computed anew from the data in Table 6.18: <code>shnkEff</code> from the &ldquo;Average&rdquo; response and <code>shnkDisp</code> from the &ldquo;Log Variance&rdquo; response. The table in the book actually gives variances, not log variances, and logs were taken before dispersion effects were calculated. A few effect values differ somewhat from those in the book.
</p>
</dd>
</dl>


<h3>References</h3>

<p>Box, GEP, Hunter, JS, and Hunter, WG (2005)
<em>Statistics for Experimenters</em> (2nd ed)
New York: John Wiley &amp; Sons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

parplot(bikeEff, method = "Zahn")

opar &lt;- par(mfcol = c(1,2))
  hnplot(shnkEff, half = FALSE, main = "Normal plot")
  hnplot(shnkEff, half = TRUE, main = "Half-Normal plot")
#   Why ordinary normal plots are a bad idea
#   Both plots have the same reference line
par(opar)

# Note - Examples in help pages for hnplot, parplot, refplot, and eff.test
#        use pdEff for illustration

## Not run: 
    # Do try this at home:
    hnplot(viseEff, ID = TRUE)
    refplot(viseEff, ID = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='PSE'>Pseudo standard error of effects</h2><span id='topic+PSE'></span><span id='topic+ME'></span>

<h3>Description</h3>

<p>Computes a pseudo standard error using any of a variety of built-in methods, or a user-supplied one.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSE(effects, method = "Zahn", verbose = FALSE)

ME(effects, method = "Zahn", alpha = .05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PSE_+3A_effects">effects</code></td>
<td>
<p>Numeric vector of effects or contrasts to be explored.</p>
</td></tr>
<tr><td><code id="PSE_+3A_method">method</code></td>
<td>
<p>Character value. The name of the method to be used. See Details.</p>
</td></tr>
<tr><td><code id="PSE_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the parameters (if any) generated by the method's setup code are printed.</p>
</td></tr>
<tr><td><code id="PSE_+3A_alpha">alpha</code></td>
<td>
<p>Numeric significance level, between 0 and 1.</p>
</td></tr>
<tr><td><code id="PSE_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+ref.dist">ref.dist</a></code>. If a matching reference distribution is already available in <code>.Last.ref.dist</code>, these arguments have no effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>PSE</code> function implements methods of estimating the standard error of effects estimates from unreplicated designs. The underlying assumption is that the effects all have the same variance, and that &ldquo;effect sparsity&rdquo; assumption applies, whereby the majority of the effects are inactive and only a handful are active. The method may be any &ldquo;directed&rdquo; method (as described in Hamada and Balakrishnan (1998).
A number of built-in methods are available; see the list below.
</p>
<p>Users may easily write their own method. The method <code>"foo"</code> would be implemented by writing a function <code>foo_pse &lt;- function(effects) { ... }</code> and saving it where it can be found in the search path. An example can be found by listing <code>unrepx:::Lenth_pse</code>.
</p>
<p>If the user-supplied function needs to use weights, coefficients, or other parameters that depend on <code>length(effects)</code> that would be cumbersome in simulations (e.g., in <code><a href="#topic+ref.dist">ref.dist</a></code>), the user may instead provide a function <code>foo_pse &lt;- function(effects, parm) { ... }</code>, along with <code>attr(foo_pse, "setup") &lt;- function(n.effects) { ... }</code> which returns the <code>parm</code> argument (say, a <code>list</code>) to be used when <code>length(effects) = n.effects</code>. The setup function is called automatically if the <code>"setup"</code> attribute exists, and if so, the function is expected to have the second argument. See a listing of <code>unrepx:::Zahn_pse</code> for an example. 
</p>


<h3>Value</h3>

<p><code>PSE</code> returns a single numeric value, named in the style <code>method_PSE</code>.
<code>ME</code> returns a named numeric vector of length 2, containing the margin of error <code>ME</code> and the simultaneous margin of error <code>SME</code>.
</p>


<h3>Built-in methods</h3>


<dl>
<dt>Daniel</dt><dd><p>The 68.3rd quantile of the absolute effects. See Daniel (1959).</p>
</dd>
<dt>Dong</dt><dd><p>The RMS method, applied after excluding all effects that exceed <code>2.5 * PSE(effects, "SMedian")</code> in absolute value. See Dong (19??).</p>
</dd>
<dt>JuanPena</dt><dd><p>An iterated median method whereby we repeatedly calculate the median of the absolute effects that don't exceed 3.5 times the previous median, until it stabilizes. The estimate is the final median, divided by .6578. See Juan and Pena (1992).</p>
</dd>
<dt>Lenth</dt><dd><p>The SMedian method, applied after excluding all effects that exceed <code>2.5 * PSE(effects, "SMedian")</code> in absolute value. See Lenth (1989).</p>
</dd>
<dt>RMS</dt><dd><p>Square root of the mean of the squared effects. This is not a good PSE in the presence of active effects, but it is provided for sake of comparisons.</p>
</dd>
<dt>SMedian</dt><dd><p>1.5 times the median of the absolute effects.</p>
</dd>
<dt>Zahn, WZahn</dt><dd><p>The Zahn method is the slope of the least-squares line fitted to the first <code class="reqn">m</code> points of <code>hnplot(effects, horiz = FALSE)</code>, where <code>m = floor(.683 * length(effects))</code>. (This line is fitted through the origin.) The WZahn method is an experimental version of Zahn's method, based on weighted least-squares with weights decreasing linearly from <code class="reqn">m - .5</code> to <code class="reqn">.5</code>, but bounded above by <code class="reqn">.65m</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>References</h3>

<p>Daniel, C (1959)
Use of Half-Normal Plots in Interpreting Factorial Two-Level Experiments.
<em>Technometrics</em>, 1(4), 311-341
</p>
<p>Dong, F (1993)
On the Identification of Active Contrasts in Unreplicated Fractional Factorials.
<em>Statistica Sinica</em> 3, 209-217
</p>
<p>Hamada and Balakrishnan (1998)
Analyzing Unreplicated Factorial Experiments:
A Review With Some New Proposals.
<em>Statistica Sinica</em> 8, 1-41
</p>
<p>Juan, J and Pena, D (1992)
A Simple Method to Identify Significant Effects in Unreplicated
Two-Level Factorial Designs. 
<em>Communications in Statistics: Theory and Methods</em> 21, 1383-1403  
</p>
<p>Lenth, R (1989)
Quick and Easy Analysis of Unrelicated Factorials
<em>Technometrics</em> 31(4), 469-473
</p>
<p>Zahn, D (1975)
Modifications of and Revised Critical Values for the Half-Normal Plot.
<em>Technometrics</em> 17(2), 189-200
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

PSE(shnkEff, method = "Lenth")
</code></pre>

<hr>
<h2 id='ref.dist'>Analysis of effects from screening experiments</h2><span id='topic+ref.dist'></span><span id='topic+eff.test'></span>

<h3>Description</h3>

<p>These functions facilitate making inferences based on effect estimates in an unreplicated experiment, withn an underlying effect-sparsity model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref.dist(method, n.effects, nsets, save = TRUE)

eff.test(effects, method = "Zahn", pareto = TRUE, refdist, save = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ref.dist_+3A_method">method</code></td>
<td>
<p>The method to use in determining the reference line, curve, and/or critical values. This must be the name of a provided pseudo-standard-error method (see <code><a href="#topic+PSE">PSE</a></code>), or a compatible user-supplied one.</p>
</td></tr>
<tr><td><code id="ref.dist_+3A_n.effects">n.effects</code></td>
<td>
<p>Integer number of effects estimated.</p>
</td></tr>
<tr><td><code id="ref.dist_+3A_nsets">nsets</code></td>
<td>
<p>The number of complete-null samples of size <code>n.effects</code> to be simulated. If omitted, <code>nsets</code> is determined so that the total number of simulated effects is about 40,000.</p>
</td></tr>
<tr><td><code id="ref.dist_+3A_save">save</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the simulated reference distribution is saved in the workspace under <code>.Last.ref.dist</code>. Other routines in this package try to avoid re-simulating a reference distribution if <code>.Last.refdist</code> exists and matches the current <code>method</code> and <code>n.effects</code>.</p>
</td></tr>
<tr><td><code id="ref.dist_+3A_effects">effects</code></td>
<td>
<p>Vector of observed effects to be tested against the reference distribution.</p>
</td></tr>
<tr><td><code id="ref.dist_+3A_pareto">pareto</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the effects are presented in decreasing order of their absolute size.</p>
</td></tr>
<tr><td><code id="ref.dist_+3A_refdist">refdist</code></td>
<td>
<p>A result of a previous call to <code>ref.dist</code>, in case the user wishes to manually supply a previously simulated reference distribution. Note however that <code>eff.test</code> will automatically reuse <code>.Last.ref.dist</code> if it is available and matches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ref.dist</code> simulates samples of effects from the standard normal dstribution. For each sample, the pseudo standaerd error (PSE) of the effects (typically some kind of outlier-resistant estimate of the SD) is obtained via a call to <code><a href="#topic+PSE">PSE</a></code> with specified method. The absolute <code class="reqn">t</code> values are obtained as ratios of the simulated effects and the PSE, as well as and the maxima of these absolute <code class="reqn">t</code> values. Quantiles and tail areas of these simulated distributions then form a reference for obtaining critical values and P values in testing an observed sample of effects.
</p>
<p><code>eff.test</code> performs a traditional-style analysis for an observed sample of effects. It outputs the effects, PSE, <code class="reqn">t</code> ratios; and uses tail areas of the associated reference distribution to compute individual and simultaneous <code class="reqn">P</code> values. The simultaneous <code class="reqn">P</code> values implement a multiplicity correction for <em>any</em> type-I errors occurring among the tests. 
</p>


<h3>Value</h3>

<p><code>ref.dist</code> returns an object of class <code>"eff_refdist"</code> &ndash; structurally, a <code>list</code> with elements <code>abst</code> (the absolute values of the simulated <code class="reqn">t</code> statistics), <code>max.abst</code> (the sample maxima of <code>abst</code>), and <code>sig</code> (a signature of the form <code>method_n.effects</code>). There is a <code>print</code> method for this class that displays a summary.
</p>
<p><code>eff.test</code> returns a <code>data.frame</code> containing the estimates, <code class="reqn">t ratios</code>, and estimated P values as tail areas of <code>abst</code> and <code>max.abst</code> from the reference distribution.</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

zahn15 &lt;- ref.dist("Zahn", 15)
eff.test(pdEff, refdist = zahn15)
</code></pre>

<hr>
<h2 id='refplot'>Dot plot of effects with a reference distribution</h2><span id='topic+refplot'></span>

<h3>Description</h3>

<p>The <code>refplot</code> function constructs a dot plot of effects along with a rweference distribution (either normal or simulated) to help in visually identifying active effects in a screening experiment.</p>


<h3>Usage</h3>

<pre><code class='language-R'>refplot(effects, ref = TRUE, half = TRUE, method = "Zahn", 
    col = half, guides = FALSE, ID = FALSE, pch = 16, xlab, xlim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refplot_+3A_effects">effects</code></td>
<td>
<p>Numeric vector of effects or contrasts to be explored.</p>
</td></tr>
<tr><td><code id="refplot_+3A_ref">ref</code></td>
<td>
<p>Logical or character value. If <code>TRUE</code>, a reference line or curve is added to the plot determined by <code>method</code>. If <code>FALSE</code>, no reference is added to the plot.
</p>
<p>A character value matching <code>"normal"</code> or <code>"simulated"</code> is also permitted.
<code>"normal"</code> is equivalent to <code>ref = TRUE</code>. With <code>"simulated"</code>, 
, a kernel density estimate is displayed; it is obtained by scaling the simulated reference distribution for <code>"method"</code> by its observed PSE. </p>
</td></tr>
<tr><td><code id="refplot_+3A_half">half</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, a dot plot of the absolute effects is constructed. If <code>FALSE</code>, the original signed effects are plotted.</p>
</td></tr>
<tr><td><code id="refplot_+3A_method">method</code></td>
<td>
<p>Character value. When <code>ref</code> is not false, the method to use in determining the PSE for scaling the reference curve (and also the method used for simulating the referemnce distribution when <code>ref = "simulated"</code>). This must be the name of a provided pseudo-standard-error method (see <code><a href="#topic+PSE">PSE</a></code>), or a compatible user-supplied one.</p>
</td></tr>
<tr><td><code id="refplot_+3A_col">col</code></td>
<td>
<p>Scalar or vector of colors; or a logical value. If logical, a value of <code>TRUE</code> colors the positive effects blue, the negative effects red, and any zeros as black. A logical value of <code>FALSE</code> colors them all black.</p>
</td></tr>
<tr><td><code id="refplot_+3A_guides">guides</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, dotted lines are added that illustrate guide lines that could be used to draw the normal curve by hand.</p>
</td></tr>
<tr><td><code id="refplot_+3A_id">ID</code></td>
<td>
<p>Logical value. If logical and <code>TRUE</code>, then after the plot is contructed, the <code><a href="#topic+dot.id">dot.id</a></code> invoked so that the user may click on points to be labeled on the plot. If a numeric value is given, it is used as a threshold by which all effects greater than <code>ID[1]</code> in absolute value are labeled.</p>
</td></tr>
<tr><td><code id="refplot_+3A_pch">pch</code>, <code id="refplot_+3A_xlab">xlab</code>, <code id="refplot_+3A_xlim">xlim</code>, <code id="refplot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>) passed to <code><a href="#topic+dot.plot">dot.plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the returned environment is saved, then <code><a href="#topic+dot.id">dot.id</a></code> or <code><a href="#topic+dot.mod">dot.mod</a></code> may be used later as for <code><a href="#topic+dot.plot">dot.plot</a></code> results.</p>


<h3>Value</h3>

<p>An environment that can be modified using <code><a href="#topic+dot.id">dot.id</a></code> or <code><a href="#topic+dot.mod">dot.mod</a></code>.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>See Also</h3>

<p>Other ways of assessing active effects include a half-normal plot (<code><a href="#topic+hnplot">hnplot</a></code>), a Pareto plot of effects (see <code><a href="#topic+parplot">parplot</a></code>), and a tabular style of presenting effects and <code class="reqn">P</code> values (see <code>eff.test</code>). For more information on PSEs and methods, see <code><a href="#topic+PSE">PSE</a></code> and <code><a href="#topic+ref.dist">ref.dist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(unrepx)

refplot(pdEff, ID = ME(pdEff))

## Not run: 
    # Batman lives!
    refplot(pdEff, ref = "sim", method = "Lenth", half = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='yates'>Yates's algorithm</h2><span id='topic+yates'></span><span id='topic+gyates'></span>

<h3>Description</h3>

<p>Implementations of Yates's method for obtaining factor effects; and reverse Yates's method for recovering response values; and a generalization for balanced unreplicated experiments having other than two-level factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yates(y, labels = LETTERS, sep = "")
gyates(y, nlevels, basis = "poly")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yates_+3A_y">y</code></td>
<td>

<p>Numeric vector of response values or effects, in standard order. See Details.
</p>
</td></tr>
<tr><td><code id="yates_+3A_labels">labels</code></td>
<td>

<p>Character labels for 2-level factors to use when <code>y</code> contains resoponse values. The first <code class="reqn">log_2(n)</code> are used, where <code class="reqn">n</code> is <code>length(y).</code>
</p>
</td></tr>
<tr><td><code id="yates_+3A_sep">sep</code></td>
<td>

<p>Character to use between labels for interaction effects.
</p>
</td></tr>
<tr><td><code id="yates_+3A_nlevels">nlevels</code></td>
<td>

<p>Numeric vector of numbers of levels. The number of observations is assumed to be <code>prod(nlevels).</code>  
</p>
</td></tr>
<tr><td><code id="yates_+3A_basis">basis</code></td>
<td>

<p>Character value or vector specifying what method to use to generate orthonormal contrasts. Built-in ones include <code>"poly"</code> and <code>"helmert"</code>, but the user may create others. The elements of <code>basis</code> are recycled cyclically as needed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement a method for computing factor effects for balanced, unreplicated designs without need for a matrix of predictor levels. Instead, the responses must be arranged in standard order. The method is described in Yates (1937) for the case where all factors have two levels (as implemented in <code>yates</code>), and its generalization (<code>gyates</code>) can be found in Good (1958). Both are described in Drum (2005). In this implementation, <code>gyates()</code> uses orthonormal (unitary) matrices, rather than keeping track of needed divisors. 
</p>
<p>Standard order (also called Yates order) is that in which the first factor varies the fastest and the last varies the slowest. The <code><a href="base.html#topic+expand.grid">expand.grid</a></code> function creates factor combinations in standard order. The <code>yates</code> function is for experiments with all factors having two levels. The returned effects are also in standard order: with the default labels in <code>yates</code>, the order of the returned effects is (intercept), A, B, AB, C, AC, BC, ABC, D, etc.: note that absence or presence of each factor proceeds in standard order.
</p>
<p>In both <code>yates</code> and <code>gyates</code>, if the length of <code>y</code> is one less than expected, <code>y</code> is assumed to be a set of effects, without the intercept. In that instance, the algorithm is reversed and the response values are recovered from the effects. Since the intercept is absent, the mean is arbitrary. If <code>y</code> has a <code>"mean"</code> attribute, the mean is adjusted to that value; otherwise, the recovered responses have a mean of zero. 
</p>
<p>In <code>gyates</code>, the values of <code>nlevels</code> and <code>basis</code> are saved as attributes. In a subsequent call on the returned effects, these values are used and will override the <code>nlevels</code> and <code>basis</code> arguments supplied by the user.
</p>
<p>Effects are scaled to all have the same variance. In <code>yates</code>, we apply the same convention as in most design texts, e.g., Box et al. (2005): effect = (mean at &quot;+&quot; level) - (mean at &quot;-&quot; level), which is twice the regression coefficient one obtains by regressing <code>y</code> on predictors of -1s and +1s. In <code>gyates</code>, effects are computed using orthonormal contrasts, making the squared effects equal to their ANOVA sums of squares. When effects are reversed, the same scaling is assumed. Also, if the elements of <code>y</code> are independent, so are the effects.
</p>
<p>The two basis functions supplied are <code>"poly"</code> and <code>"helmert"</code>, which are based on <code><a href="stats.html#topic+contr.poly">contr.poly</a></code> and <code><a href="stats.html#topic+contr.helmert">contr.helmert</a></code> respectively. Users may create a custom basis, say <code>"foo"</code>, by writing a function <code>foo_gyb = function(k) {...}</code>, and supplying <code>basis = "foo"</code> in the call. The function should return a <code>k</code> by <code>k</code> matrix having its first column equal to <code>1/sqrt(k)</code> and orthonormal contrasts in the remaining columns. 
</p>


<h3>Value</h3>

<p>If <code>length(y)</code> is a power of two (in <code>yates</code>) or the product of <code>nlevels</code> (in <code>gyates</code>), a vector of <code>length(y) - 1</code> effects is returned (the intercept is omitted). In addition, the returned value has a <code>"mean"</code> attribute set equal to <code>mean(y)</code>. The effects from <code>yates</code> are named in standard order using the labels provided. The effects from <code>gyates</code> are labeled using patterns of the characters <code>.123456789</code>. Any <code>.</code> in a label indicates a factor whose effect is out of play. For illustration, with 3 factors, the effect named <code>.1.</code> is the first-order effect of the second factor, and the one named <code>23.</code> is the interaction of the second-order effect of the first factor and the third-order effect of the second factor.
</p>
<p>If <code>length(y)</code> is one less than a power of two or the product of levels, then a vector one longer of response values is returned. The names of the returned responses are symbol combinations from <code>-+</code> for <code>yates</code>, and <code>123456789</code> from <code>gyates</code>. For example, in <code>yates</code> with <code>length(y) = 7</code>, the returned values are labeled <code>---, +--, -+-, ++-, --+, +-+, -++, +++</code>; and <code>gyates</code> with 5 effects and <code>nlevels = c(3, 2)</code>, the returned effects are labeled <code>11, 21, 31, 12, 22, 32</code>.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth
</p>


<h3>References</h3>

<p>Box, GEP, Hunter, JS, and Hunter, WG (2005)
<em>Statistics for Experimenters</em> (2nd ed)
New York: John Wiley &amp; Sons
</p>
<p>Drum, M (2005)
Yates's Algorithm. <em>Encyclopedia of Biostatistics</em>, 8. Wiley.
</p>
<p>Good, IJ (1958)
The interaction algorithm and practical Fourier analysis.
<em>Journal of the Royal Statistical Society, Series B</em> 20, 361-372.
</p>
<p>Yates, F (1937) The design and analysis of factorial experiments. Technical Communication of the Commonwealth Bureau of Soils, 35, Commonwealth Agricultural Bureau, Farnham Royal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("unrepx")

# pilot-plant example, BH^2 p. 177
yates(c(60, 72, 54, 68,  52, 83, 45, 80), labels = c("T", "C", "K"))

# recover shrinkage data
yates(shnkEff)

# A 3 x 2 x 4 example
y &lt;- c( 214, 193, 207,   193, 178, 188, 
        225, 206, 213,   221, 214, 216, 
        227, 213, 221,   231, 215, 225, 
        228, 203, 206,   190, 178, 195 )
yeff &lt;- gyates(y, c(3,2,4), basis = "helmert")
head(eff.test(yeff))  ## Show the largest few effects
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
