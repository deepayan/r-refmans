<!DOCTYPE html><html><head><title>Help for package dsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dsm-package'><p>Density surface modelling</p></a></li>
<li><a href='#block.info.per.su'><p>Find the block information</p></a></li>
<li><a href='#check.cols'><p>Check column names exist</p></a></li>
<li><a href='#dsm'><p>Fit a density surface model to segment-specific estimates of abundance</p>
or density.</a></li>
<li><a href='#dsm_cor'><p>Check for autocorrelation in residuals</p></a></li>
<li><a href='#dsm_var_gam'><p>Prediction variance estimation assuming independence</p></a></li>
<li><a href='#dsm_var_movblk'><p>Variance estimation via parametric moving block bootstrap</p></a></li>
<li><a href='#dsm_var_prop'><p>Prediction variance propagation for DSMs</p></a></li>
<li><a href='#dsm_varprop'><p>Variance propagation for density surface models</p></a></li>
<li><a href='#dsm-data'><p>Data format for DSM</p></a></li>
<li><a href='#dsm.cor'><p>Check for autocorrelation in residuals</p></a></li>
<li><a href='#dsm.var.gam'><p>Prediction variance estimation assuming independence</p></a></li>
<li><a href='#dsm.var.movblk'><p>Variance estimation via parametric moving block bootstrap</p></a></li>
<li><a href='#dsm.var.prop'><p>Prediction variance propagation for DSMs</p></a></li>
<li><a href='#dummy_ddf'><p>Detection function objects when detection is certain</p></a></li>
<li><a href='#generate.ds.uncertainty'><p>Generate data from a fitted detection function</p></a></li>
<li><a href='#generate.mb.sample'><p>Moving block bootstrap sampler</p></a></li>
<li><a href='#latlong2km'><p>Convert latitude and longitude to Northings and Eastings</p></a></li>
<li><a href='#make.soapgrid'><p>Create a knot grid for the internal part of a soap film smoother.</p></a></li>
<li><a href='#mexdolphins'><p>Pan-tropical spotted dolphins in the Gulf of Mexico</p></a></li>
<li><a href='#obs_exp'><p>Observed versus expected diagnostics for fitted DSMs</p></a></li>
<li><a href='#plot_pred_by_term'><p>Spatially plot predictions per model term</p></a></li>
<li><a href='#plot.dsm'><p>Plot a density surface model.</p></a></li>
<li><a href='#plot.dsm.var'><p>Create plots of abundance uncertainty</p></a></li>
<li><a href='#predict.dsm'><p>Predict from a fitted density surface model</p></a></li>
<li><a href='#predict.fake_ddf'><p>Prediction for fake detection functions</p></a></li>
<li><a href='#print.dsm'><p>Print a description of a density surface model object</p></a></li>
<li><a href='#print.dsm_varprop'><p>Print a description of a density surface model variance object</p></a></li>
<li><a href='#print.dsm.var'><p>Print a description of a density surface model variance object</p></a></li>
<li><a href='#print.summary.dsm_varprop'><p>Print summary of density surface model variance object</p></a></li>
<li><a href='#print.summary.dsm.var'><p>Print summary of density surface model variance object</p></a></li>
<li><a href='#rqgam_check'><p>Randomised quantile residuals check plot for GAMs/DSMs</p></a></li>
<li><a href='#rqgam.check'><p>Randomised quantile residuals check plot for GAMs/DSMs</p></a></li>
<li><a href='#summary.dsm'><p>Summarize a fitted density surface model</p></a></li>
<li><a href='#summary.dsm_varprop'><p>Summarize the variance of a density surface model</p></a></li>
<li><a href='#summary.dsm.var'><p>Summarize the variance of a density surface model</p></a></li>
<li><a href='#trim.var'><p>Trimmed variance</p></a></li>
<li><a href='#vis_concurvity'><p>Visualise concurvity between terms in a GAM</p></a></li>
<li><a href='#vis.concurvity'><p>Visualise concurvity between terms in a GAM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Laura Marshall &lt;lhm@st-andrews.ac.uk&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Title:</td>
<td>Density Surface Modelling of Distance Sampling Data</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>David L. Miller, Eric Rexstad, Louise Burt, Mark V. Bravington,
    Sharon Hedley, Megan Ferguson, Natalie Kelly.</td>
</tr>
<tr>
<td>Description:</td>
<td>Density surface modelling of line transect data. A Generalized
    Additive Model-based approach is used to calculate spatially-explicit estimates
    of animal abundance from distance sampling (also presence/absence and strip
    transect) data. Several utility functions are provided for model checking,
    plotting and variance estimation.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DistanceDevelopment/dsm">https://github.com/DistanceDevelopment/dsm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DistanceDevelopment/dsm/issues">https://github.com/DistanceDevelopment/dsm/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), mgcv (&ge; 1.8-23), mrds (&ge; 2.1.16), numDeriv</td>
</tr>
<tr>
<td>Imports:</td>
<td>nlme, ggplot2, plyr, statmod</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Distance, sp, tweedie, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-20 21:42:22 UTC; laura</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-20 22:10:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='dsm-package'>Density surface modelling</h2><span id='topic+dsm-package'></span>

<h3>Description</h3>

<p><code>dsm</code> implements spatial models for distance sampling data. Models for
detectability can be fitted using packages <code>mrds</code> or <code>Distance</code>. <code>dsm</code> fits
generalized additive models to spatially-referenced data. See Miller et al
(2013) for an introduction.
</p>


<h3>Details</h3>

<p>Further information on distance sampling methods and example code is
available at <a href="http://distancesampling.org/R/">http://distancesampling.org/R/</a>.
</p>
<p>For help with distance sampling and this package, there is a Google Group
<a href="https://groups.google.com/forum/#!forum/distance-sampling">https://groups.google.com/forum/#!forum/distance-sampling</a>.
</p>
<p>A example analyses are available at <a href="http://examples.distancesampling.org">http://examples.distancesampling.org</a>.
</p>


<h3>References</h3>

<p>Hedley, S. and S. T. Buckland. 2004. Spatial models for line
transect sampling. JABES 9:181-199.
</p>
<p>Miller, D. L., Burt, M. L., Rexstad, E. A., Thomas, L. (2013), Spatial
models for distance sampling data: recent developments and future
directions. Methods in Ecology and Evolution, 4: 1001-1010. doi:
10.1111/2041-210X.12105 (Open Access)
</p>
<p>Wood, S.N. 2006. Generalized Additive Models: An Introduction with R.
CRC/Chapman &amp; Hall.
</p>

<hr>
<h2 id='block.info.per.su'>Find the block information</h2><span id='topic+block.info.per.su'></span>

<h3>Description</h3>

<p>Takes the transect data and works out how many blocks of a given
size (in segment terms) fit into each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block.info.per.su(block.size, data, name.su)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block.info.per.su_+3A_block.size">block.size</code></td>
<td>
<p>number of segments per block</p>
</td></tr>
<tr><td><code id="block.info.per.su_+3A_data">data</code></td>
<td>
<p>data used to build the model</p>
</td></tr>
<tr><td><code id="block.info.per.su_+3A_name.su">name.su</code></td>
<td>
<p>names of the sampling units (i.e., transects)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with the following columns
</p>

<ul>
<li> <p><code>name</code>        the sample unit name (e.g. transect label)
</p>
</li>
<li> <p><code>num.seg</code>     number of segments in that transect
</p>
</li>
<li> <p><code>num.block</code>   number of blocks available
</p>
</li>
<li> <p><code>start.block</code> block number for first block
</p>
</li>
<li> <p><code>end.block</code>   block number for last block
</p>
</li>
<li> <p><code>num.req</code>     number of blocks needed for the unit
</p>
</li></ul>


<hr>
<h2 id='check.cols'>Check column names exist</h2><span id='topic+check.cols'></span>

<h3>Description</h3>

<p>Internal function to check that supplied <code>data.frames</code> have the correct
columns and checks that sample labels are all unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.cols(ddf.obj, segment.data, observation.data, segment.area)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.cols_+3A_ddf.obj">ddf.obj</code></td>
<td>
<p>a <code>ddf</code> object from <code><a href="mrds.html#topic+mrds">mrds</a></code></p>
</td></tr>
<tr><td><code id="check.cols_+3A_segment.data">segment.data</code></td>
<td>
<p>segment data as defined in <code><a href="#topic+dsm">dsm</a></code></p>
</td></tr>
<tr><td><code id="check.cols_+3A_observation.data">observation.data</code></td>
<td>
<p>observation data as defined in <code><a href="#topic+dsm">dsm</a></code></p>
</td></tr>
<tr><td><code id="check.cols_+3A_segment.area">segment.area</code></td>
<td>
<p>area of segments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, but throws an error if something went wrong
</p>


<h3>Author(s)</h3>

<p>David Lawrence Miller
</p>

<hr>
<h2 id='dsm'>Fit a density surface model to segment-specific estimates of abundance
or density.</h2><span id='topic+dsm'></span>

<h3>Description</h3>

<p>Fits a density surface model (DSM) to detection adjusted counts from a
spatially-referenced distance sampling analysis. <code>dsm</code> takes observations of
animals, allocates them to segments of line (or strip transects) and
optionally adjusts the counts based on detectability using a supplied
detection function model. A generalized additive model, generalized mixed
model or generalized linear model is then used to model these adjusted
counts based on a formula involving environmental covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm(
  formula,
  ddf.obj,
  segment.data,
  observation.data,
  engine = "gam",
  convert.units = 1,
  family = quasipoisson(link = "log"),
  group = FALSE,
  control = list(keepData = TRUE),
  availability = 1,
  segment.area = NULL,
  weights = NULL,
  method = "REML",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm_+3A_formula">formula</code></td>
<td>
<p>formula for the surface. This should be a valid formula. See
&quot;Details&quot;, below, for how to define the response.</p>
</td></tr>
<tr><td><code id="dsm_+3A_ddf.obj">ddf.obj</code></td>
<td>
<p>result from call to <code><a href="mrds.html#topic+ddf">ddf</a></code> or
<code><a href="Distance.html#topic+ds">ds</a></code>. If multiple detection functions are required a <code>list</code>
can be provided. For strip/circle transects where it is assumed all objects
are observed, see <code><a href="#topic+dummy_ddf">dummy_ddf</a></code>. Mark-recapture distance sampling
(<code>mrds</code>) models of type <code>io</code> (independent observers) and <code>trial</code> are
allowed.</p>
</td></tr>
<tr><td><code id="dsm_+3A_segment.data">segment.data</code></td>
<td>
<p>segment data, see <code><a href="#topic+dsm-data">dsm-data</a></code>.</p>
</td></tr>
<tr><td><code id="dsm_+3A_observation.data">observation.data</code></td>
<td>
<p>observation data, see <code><a href="#topic+dsm-data">dsm-data</a></code>.</p>
</td></tr>
<tr><td><code id="dsm_+3A_engine">engine</code></td>
<td>
<p>which fitting engine should be used for the DSM
(<code>"glm"</code>/<code>"gam"</code>/<code>"gamm"</code>/<code>"bam"</code>).</p>
</td></tr>
<tr><td><code id="dsm_+3A_convert.units">convert.units</code></td>
<td>
<p>conversion factor to multiply the area of the segments
by. See 'Units' below.</p>
</td></tr>
<tr><td><code id="dsm_+3A_family">family</code></td>
<td>
<p>response distribution (popular choices include
<code><a href="stats.html#topic+family">quasipoisson</a></code>, <code><a href="mgcv.html#topic+Tweedie">Tweedie</a></code>/<code><a href="mgcv.html#topic+Tweedie">tw</a></code>
and <code><a href="mgcv.html#topic+negbin">negbin</a></code>/<code><a href="mgcv.html#topic+negbin">nb</a></code>). Defaults
<code><a href="stats.html#topic+family">quasipoisson</a></code>.</p>
</td></tr>
<tr><td><code id="dsm_+3A_group">group</code></td>
<td>
<p>if <code>TRUE</code> the abundance of <em>groups</em> will be calculated rather
than the abundance of <em>individuals</em>. Setting this option to <code>TRUE</code> is
equivalent to setting the size of each group to be 1.</p>
</td></tr>
<tr><td><code id="dsm_+3A_control">control</code></td>
<td>
<p>the usual <code>control</code> argument for a <code><a href="mgcv.html#topic+gam">gam</a></code>;
<code>keepData</code> must be <code>TRUE</code> for variance estimation to work (though this
option cannot be set for GLMs or GAMMs).</p>
</td></tr>
<tr><td><code id="dsm_+3A_availability">availability</code></td>
<td>
<p>an estimate of availability bias. For count models used
to multiply the effective strip width (must be a vector of length 1 or
length the number of rows in <code>segment.data</code>); for estimated
abundance/estimated density models used to scale the response (must be a
vector of length 1 or length the number of rows in <code>observation.data</code>).
Uncertainty in the availability is not handled at present.</p>
</td></tr>
<tr><td><code id="dsm_+3A_segment.area">segment.area</code></td>
<td>
<p>if <code>NULL</code> (default) segment areas will be calculated by
multiplying the <code>Effort</code> column in <code>segment.data</code> by the (right minus left)
truncation distance for the <code>ddf.obj</code> or by <code>strip.width</code>. Alternatively a
vector of segment areas can be provided (which must be the same length as
the number of rows in <code>segment.data</code>) or a character string giving the name
of a column in <code>segment.data</code> which contains the areas. If <code>segment.area</code> is
specified it takes precedent.</p>
</td></tr>
<tr><td><code id="dsm_+3A_weights">weights</code></td>
<td>
<p>weights for each observation used in model fitting. The
default, <code>weights=NULL</code>, weights each observation by its area (see Details).
Setting a scalar value (e.g., <code>weights=1</code>) all observations are equally
weighted.</p>
</td></tr>
<tr><td><code id="dsm_+3A_method">method</code></td>
<td>
<p>The smoothing parameter estimation method. Default is
<code>"REML"</code>, using Restricted Maximum Likelihood. See <code><a href="mgcv.html#topic+gam">gam</a></code> for
other options. Ignored for <code>engine="glm"</code>.</p>
</td></tr>
<tr><td><code id="dsm_+3A_...">...</code></td>
<td>
<p>anything else to be passed straight to <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+gamm">gamm</a></code> or <code><a href="mgcv.html#topic+bam">bam</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The response (LHS of <code>formula</code>) can be one of the following (with
restrictions outlined below):
</p>

<ul>
<li> <p><code>count</code> count in each segment
</p>
</li>
<li> <p><code>abundance.est</code> estimated abundance per segment, estimation is via a
Horvitz-Thompson estimator
</p>
</li>
<li> <p><code>density.est</code> density per segment
</p>
</li></ul>

<p>The offset used in the model is dependent on the response:
</p>

<ul>
<li> <p><code>count</code> area of segment multiplied by average probability of detection
in the segment
</p>
</li>
<li> <p><code>abundance.est</code> area of the segment
</p>
</li>
<li> <p><code>density</code> zero
</p>
</li></ul>

<p>The <code>count</code> response can only be used when detection function covariates
only vary between segments/points (not within). For example, weather
conditions (like visibility or sea state) or foliage cover are usually
acceptable as they do not change within the segment, but animal sex or
behaviour will not work. The <code>abundance.est</code> response can be used with any
covariates in the detection function.
</p>
<p>In the density case, observations can be weighted by segment areas via the
<code style="white-space: pre;">&#8288;weights=&#8288;</code> argument. By default (<code>weights=NULL</code>), when density is estimated
the weights are set to the segment areas (using <code>segment.area</code> or by
calculated from detection function object metadata and <code>Effort</code> data).
Alternatively <code>weights=1</code> will set the weights to all be equal. A third
alternative is to pass in a vector of length equal to the number of
segments, containing appropriate weights.
</p>
<p>A example analyses are available at <a href="http://examples.distancesampling.org">http://examples.distancesampling.org</a>.
</p>


<h3>Value</h3>

<p>a <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+gamm">gamm</a></code> or
<code><a href="mgcv.html#topic+bam">bam</a></code> object, with an additional element, <code style="white-space: pre;">&#8288;$ddf&#8288;</code> which holds the
detection function object.
</p>


<h3>Units</h3>

<p>It is often the case that distances are collected in metres and segment
lengths are recorded in kilometres. <code>dsm</code> allows you to provide a conversion
factor (<code>convert.units</code>) to multiply the areas by. For example: if distances
are in metres and segment lengths are in kilometres setting
<code>convert.units=1000</code> will lead to the analysis being in metres. Setting
<code>convert.units=1/1000</code> will lead to the analysis being in kilometres. The
conversion factor will be applied to <code>segment.area</code> if that is specified.
</p>


<h3>Large models</h3>

<p>For large models, <code>engine="bam"</code> with <code>method="fREML"</code> may be useful. Models
specified for <code>bam</code> should be as <code>gam</code>. Read <code><a href="mgcv.html#topic+bam">bam</a></code> before using
this option; this option is considered EXPERIMENTAL at the moment. In
particular note that the default basis choice (thin plate regression
splines) will be slow and that in general fitting is less stable than when
using <code><a href="mgcv.html#topic+gam">gam</a></code>. For negative binomial response, theta must be
specified when using <code><a href="mgcv.html#topic+bam">bam</a></code>.
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>References</h3>

<p>Hedley, S. and S. T. Buckland. 2004. Spatial models for line
transect sampling. JABES 9:181-199.
</p>
<p>Miller, D. L., Burt, M. L., Rexstad, E. A., Thomas, L. (2013), Spatial
models for distance sampling data: recent developments and future
directions. Methods in Ecology and Evolution, 4: 1001-1010. doi:
10.1111/2041-210X.12105 (Open Access)
</p>
<p>Wood, S.N. 2006. Generalized Additive Models: An Introduction with R.
CRC/Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Distance)
library(dsm)

# load the Gulf of Mexico dolphin data (see ?mexdolphins)
data(mexdolphins)

# fit a detection function and look at the summary
hr.model &lt;- ds(distdata, truncation=6000,
               key = "hr", adjustment = NULL)
summary(hr.model)

# fit a simple smooth of x and y to counts
mod1 &lt;- dsm(count~s(x,y), hr.model, segdata, obsdata)
summary(mod1)

# predict over a grid
mod1.pred &lt;- predict(mod1, preddata, preddata$area)

# calculate the predicted abundance over the grid
sum(mod1.pred)

# plot the smooth
plot(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='dsm_cor'>Check for autocorrelation in residuals</h2><span id='topic+dsm_cor'></span>

<h3>Description</h3>

<p>Once a DSM has been fitted to data, this function can be used to check for
autocorrelation in the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm_cor(
  dsm.obj,
  Transect.Label = "Transect.Label",
  Segment.Label = "Segment.Label",
  max.lag = 10,
  resid.type = "scaled.pearson",
  fun = cor,
  ylim = c(0, 1),
  subset = "all",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm_cor_+3A_dsm.obj">dsm.obj</code></td>
<td>
<p>a fitted dsm object.</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_transect.label">Transect.Label</code></td>
<td>
<p>label for the transect (default: <code>Transect.Label</code>).
Using different labels can be useful when transects are split over
geographical features or when transects are surveyed multiple times.</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_segment.label">Segment.Label</code></td>
<td>
<p>label for the segments (default: <code>Segment.Label</code>).The
result of calling <code><a href="base.html#topic+order">order</a></code> must make sense.</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_max.lag">max.lag</code></td>
<td>
<p>maximum lag to calculate at.</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_resid.type">resid.type</code></td>
<td>
<p>the type of residuals used, see
<code><a href="mgcv.html#topic+residuals.gam">residuals.gam</a></code>. Defaults to <code>"scaled.pearson"</code> in the GAM
case and <code>"normalized"</code> in the GAMM case (which are equivalent).</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_fun">fun</code></td>
<td>
<p>the function to use, by default <code><a href="stats.html#topic+cor">cor</a></code>, must take two
column vectors as arguments.</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_ylim">ylim</code></td>
<td>
<p>user defined limits in y direction.</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_subset">subset</code></td>
<td>
<p>which subset of the data should the correlation function be
calculated on?</p>
</td></tr>
<tr><td><code id="dsm_cor_+3A_...">...</code></td>
<td>
<p>other options to pass to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot or a vector of <code>fun</code> applied at the lags.
</p>


<h3>Details</h3>

<p>Within each <code>Transect.Label</code>, segments will be sorted
according to their <code>Segment.Label</code>s. This may require some time to get right
for your particular data. If one has multiple surveys where transects are
revisited, for example, one may want to make <code>Transect.Label</code> a unique
transect-survey identifier. Neither label need to be included in the model,
they must just be present in the <code style="white-space: pre;">&#8288;$data&#8288;</code> field in the model. This usually
means that they have to be in the segment data passed to <code><a href="#topic+dsm">dsm</a></code>.
</p>
<p>The current iteration of this function will only plot correlations nicely,
other things are up to you but you can get the function to return the data
(by assigning the result to an object).
</p>
<p>If there are NA values in the residuals then the correlogram will not be
calculated. This usually occurs due to <code>NA</code> values in the covariates (so the
smoother will not have fitted values there). Code like
<code>any(is.na(dsm.obj$data))</code> might be helpful.
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(Distance)
 library(dsm)

 # load the data, see ?mexdolphins
 data(mexdolphins)

 # fit a model
 hr.model &lt;- ds(distdata, truncation=6000,
                key = "hr", adjustment = NULL)
 mod1 &lt;- dsm(count~s(x,y), hr.model, segdata, obsdata)

 # look at lag 1 differences up to a maximum of lag 9, using deviance
 # residuals
 dsm_cor(mod1, resid.type="deviance", max.lag=9,
         Segment.Label="Sample.Label")

</code></pre>

<hr>
<h2 id='dsm_var_gam'>Prediction variance estimation assuming independence</h2><span id='topic+dsm_var_gam'></span>

<h3>Description</h3>

<p>If one is willing to assume the the detection function and spatial model are
independent, this function will produce estimates of variance of predictions
of abundance, using the result that squared coefficients of variation will
add.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm_var_gam(
  dsm.obj,
  pred.data,
  off.set,
  seglen.varname = "Effort",
  type.pred = "response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm_var_gam_+3A_dsm.obj">dsm.obj</code></td>
<td>
<p>a model object fitted by <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="dsm_var_gam_+3A_pred.data">pred.data</code></td>
<td>
<p>either: a single prediction grid or list of prediction
grids. Each grid should be a <code>data.frame</code> with the same columns as the
original data.</p>
</td></tr>
<tr><td><code id="dsm_var_gam_+3A_off.set">off.set</code></td>
<td>
<p>a a vector or list of vectors with as many elements as there
are in <code>pred.data</code>. Each vector is as long as the number of rows in the
corresponding element of <code>pred.data</code>. These give the area associated with
each prediction cell. If a single number is supplied it will be replicated
for the length of <code>pred.data</code>.</p>
</td></tr>
<tr><td><code id="dsm_var_gam_+3A_seglen.varname">seglen.varname</code></td>
<td>
<p>name for the column which holds the segment length
(default value <code>"Effort"</code>).</p>
</td></tr>
<tr><td><code id="dsm_var_gam_+3A_type.pred">type.pred</code></td>
<td>
<p>should the predictions be on the &quot;response&quot; or &quot;link&quot;
scale? (default <code>"response"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with elements
</p>

<ul>
<li> <p><code>model</code> the fitted model object
</p>
</li>
<li> <p><code>pred.var</code> variance of the regions given in <code>pred.data</code>.
</p>
</li>
<li> <p><code>bootstrap</code> logical, always <code>FALSE</code>
</p>
</li>
<li> <p><code>model</code> the fitted model with the extra term
</p>
</li>
<li> <p><code>dsm.object</code> the original model (<code>dsm.obj</code> above)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 library(Distance)
 library(dsm)

 # load the Gulf of Mexico dolphin data (see ?mexdolphins)
 data(mexdolphins)

 # fit a detection function and look at the summary
 hr.model &lt;- ds(distdata, truncation=6000,
                key = "hr", adjustment = NULL)
 summary(hr.model)

 # fit a simple smooth of x and y
 mod1 &lt;- dsm(count~s(x, y), hr.model, segdata, obsdata)

 # Calculate the variance
 # this will give a summary over the whole area in mexdolphins$preddata
 mod1.var &lt;- dsm_var_gam(mod1, preddata, off.set=preddata$area)

## End(Not run)
</code></pre>

<hr>
<h2 id='dsm_var_movblk'>Variance estimation via parametric moving block bootstrap</h2><span id='topic+dsm_var_movblk'></span>

<h3>Description</h3>

<p>Estimate the variance in abundance over an area using a moving block
bootstrap. Two procedures are implemented, one incorporating detection
function uncertainty, one not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm_var_movblk(
  dsm.object,
  pred.data,
  n.boot,
  block.size,
  off.set,
  ds.uncertainty = FALSE,
  samp.unit.name = "Transect.Label",
  progress.file = NULL,
  bs.file = NULL,
  bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm_var_movblk_+3A_dsm.object">dsm.object</code></td>
<td>
<p>object returned from <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_pred.data">pred.data</code></td>
<td>
<p>either: a single prediction grid or list of prediction
grids. Each grid should be a <code>data.frame</code> with the same columns as the
original data.</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_n.boot">n.boot</code></td>
<td>
<p>number of bootstrap resamples.</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_block.size">block.size</code></td>
<td>
<p>number of segments in each block.</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_off.set">off.set</code></td>
<td>
<p>a a vector or list of vectors with as many elements as there
are in <code>pred.data</code>. Each vector is as long as the number of rows in the
corresponding element of <code>pred.data</code>. These give the area associated with
each prediction cell. If a single number is supplied it will be replicated
for the length of <code>pred.data</code>.</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_ds.uncertainty">ds.uncertainty</code></td>
<td>
<p>incorporate uncertainty in the detection function? See
Details, below. Note that this feature is EXPERIMENTAL at the moment.</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_samp.unit.name">samp.unit.name</code></td>
<td>
<p>name sampling unit to resample (default
'Transect.Label').</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_progress.file">progress.file</code></td>
<td>
<p>path to a file to be used (usually by Distance) to
generate a progress bar (default <code>NULL</code> &ndash; no file written).</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_bs.file">bs.file</code></td>
<td>
<p>path to a file to store each bootstrap round. This stores all
of the bootstrap results rather than just the summaries, enabling
outliers to be detected and removed. (Default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="dsm_var_movblk_+3A_bar">bar</code></td>
<td>
<p>should a progress bar be printed to screen? (Default <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting <code>ds.uncertainty=TRUE</code> will incorporate detection function
uncertainty directly into the bootstrap. This is done by generating
observations from the fitted detection function and then re-fitting a new
detection function (of the same form), then calculating a new effective
strip width. Rejection sampling is used to generate the observations
(except in the half-normal case) so the procedure can be rather slow. Note
that this is currently not supported with covariates in the detection
function.
</p>
<p>Setting <code>ds.uncertainty=FALSE</code> will incorporate detection function
uncertainty using the delta method. This assumes that the detection
function and the spatial model are INDEPENDENT. This is probably not
reasonable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Distance)
library(dsm)

# load the Gulf of Mexico dolphin data (see ?mexdolphins)
data(mexdolphins)

# fit a detection function and look at the summary
hr.model &lt;- ds(distdata, truncation=6000,
               key = "hr", adjustment = NULL)
summary(hr.model)

# fit a simple smooth of x and y
mod1 &lt;- dsm(count~s(x, y), hr.model, segdata, obsdata)
summary(mod1)

# calculate the variance by 500 moving block bootstraps
mod1.movblk &lt;- dsm_var_movblk(mod1, preddata, n.boot = 500,
   block.size = 3, samp.unit.name = "Transect.Label",
   off.set = preddata$area,
   bar = TRUE, bs.file = "mexico-bs.csv", ds.uncertainty = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dsm_var_prop'>Prediction variance propagation for DSMs</h2><span id='topic+dsm_var_prop'></span>

<h3>Description</h3>

<p>To ensure that uncertainty from the detection function is correctly
propagated to the final variance estimate of abundance, this function uses a
method first detailed in Williams et al (2011), further explanation is given
in Bravington et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm_var_prop(
  dsm.obj,
  pred.data,
  off.set,
  seglen.varname = "Effort",
  type.pred = "response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm_var_prop_+3A_dsm.obj">dsm.obj</code></td>
<td>
<p>a model object fitted by <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="dsm_var_prop_+3A_pred.data">pred.data</code></td>
<td>
<p>either: a single prediction grid or list of prediction
grids. Each grid should be a <code>data.frame</code> with the same columns as the
original data.</p>
</td></tr>
<tr><td><code id="dsm_var_prop_+3A_off.set">off.set</code></td>
<td>
<p>a a vector or list of vectors with as many elements as there
are in <code>pred.data</code>. Each vector is as long as the number of rows in the
corresponding element of <code>pred.data</code>. These give the area associated with
each prediction cell. If a single number is supplied it will be replicated
for the length of <code>pred.data</code>.</p>
</td></tr>
<tr><td><code id="dsm_var_prop_+3A_seglen.varname">seglen.varname</code></td>
<td>
<p>name for the column which holds the segment length
(default value <code>"Effort"</code>).</p>
</td></tr>
<tr><td><code id="dsm_var_prop_+3A_type.pred">type.pred</code></td>
<td>
<p>should the predictions be on the &quot;response&quot; or &quot;link&quot;
scale? (default <code>"response"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea is to refit the spatial model but including an extra random effect.
This random effect has zero mean and hence to effect on point estimates. Its
variance is the Hessian of the detection function. Variance estimates then
incorporate detection function uncertainty. Further mathematical details are
given in the paper in the references below.
</p>
<p>Many prediction grids can be supplied by supplying a list of <code>data.frame</code>s
to the function.
</p>
<p>Note that this routine simply calls <code><a href="#topic+dsm_varprop">dsm_varprop</a></code>. If you
don't require multiple prediction grids, the other routine will probably be
faster.
</p>
<p>This routine is only useful if a detection function with covariates has been
used in the DSM.
</p>


<h3>Value</h3>

<p>a <code>list</code> with elements
</p>

<ul>
<li> <p><code>model</code> the fitted model object
</p>
</li>
<li> <p><code>pred.var</code> variance of each region given in <code>pred.data</code>
</p>
</li>
<li> <p><code>bootstrap</code> logical, always <code>FALSE</code>
</p>
</li>
<li> <p><code>pred.data</code> as above
</p>
</li>
<li> <p><code>off.set</code> as above
</p>
</li>
<li> <p><code>model</code> the fitted model with the extra term
</p>
</li>
<li> <p><code>dsm.object</code> the original model, as above
</p>
</li>
<li> <p><code>model.check</code> simple check of subtracting the coefficients of the two
models to see if there is a large difference
</p>
</li>
<li> <p><code>deriv</code> numerically calculated Hessian of the offset
</p>
</li></ul>



<h3>Diagnostics</h3>

<p>The summary output from the function includes a simply diagnostic that shows
the average probability of detection from the &quot;original&quot; fitted model (the
model supplied to this function; column <code>Fitted.model</code>) and the probability
of detection from the refitted model (used for variance propagation; column
<code>Refitted.model</code>) along with the standard error of the probability of
detection from the fitted model (<code>Fitted.model.se</code>), at the unique values of
any factor covariates used in the detection function (for continuous
covariates the 5%, 50% and 95% quantiles are shown). If there are large
differences between the probabilities of detection then there are
potentially problems with the fitted model, the variance propagation or
both. This can be because the fitted model does not account for enough of
the variability in the data and in refitting the variance model accounts for
this in the random effect.
</p>


<h3>Limitations</h3>

<p>Note that this routine is only useful if a detection function has been used
in the DSM. It cannot be used when the <code>abundance.est</code> or <code>density.est</code>
responses are used. Importantly this requires that if the detection function
has covariates, then these do not vary within a segment (so, for example
covariates like sex cannot be used).
</p>


<h3>Author(s)</h3>

<p>Mark V. Bravington, Sharon L. Hedley. Bugs added by David L. Miller.
</p>


<h3>References</h3>

<p>Bravington, M. V., Miller, D. L., &amp; Hedley, S. L. (2021). Variance
Propagation for Density Surface Models. Journal of Agricultural, Biological
and Environmental Statistics. https://doi.org/10.1007/s13253-021-00438-2
</p>
<p>Williams, R., Hedley, S.L., Branch, T.A., Bravington, M.V., Zerbini, A.N.
and Findlay, K.P. (2011). Chilean Blue Whales as a Case Study to Illustrate
Methods to Estimate Abundance and Evaluate Conservation Status of Rare
Species. Conservation Biology 25(3), 526-535.
</p>

<hr>
<h2 id='dsm_varprop'>Variance propagation for density surface models</h2><span id='topic+dsm_varprop'></span>

<h3>Description</h3>

<p>Calculate the uncertainty in predictions from a fitted DSM, including
uncertainty from the detection function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm_varprop(
  model,
  newdata = NULL,
  trace = FALSE,
  var.type = "Vp",
  var_type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm_varprop_+3A_model">model</code></td>
<td>
<p>a fitted <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="dsm_varprop_+3A_newdata">newdata</code></td>
<td>
<p>the prediction grid. Set to <code>NULL</code> to avoid making
predictions and just return model objects.</p>
</td></tr>
<tr><td><code id="dsm_varprop_+3A_trace">trace</code></td>
<td>
<p>for debugging, see how the scale parameter estimation is going.</p>
</td></tr>
<tr><td><code id="dsm_varprop_+3A_var.type">var.type</code></td>
<td>
<p>which variance-covariance matrix should be used (<code>"Vp"</code> for
variance-covariance conditional on smoothing parameter(s), <code>"Vc"</code> for
unconditional). See <code><a href="mgcv.html#topic+gamObject">gamObject</a></code> for an details/explanation. If
in doubt, stick with the default, <code>"Vp"</code>.</p>
</td></tr>
<tr><td><code id="dsm_varprop_+3A_var_type">var_type</code></td>
<td>
<p>deprecated, use <code>var.type</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When we make predictions from a spatial model, we also want to know the
uncertainty about that abundance estimate. Since density surface models are
2 (or more) stage models, we need to incorporate the uncertainty from the
earlier stages (i.e. the detection function) into our &quot;final&quot; uncertainty
estimate.
</p>
<p>This function will refit the spatial model but include the Hessian of the
offset as an extra term. Variance estimates using this new model can then be
used to calculate the variance of predicted abundance estimates which
incorporate detection function uncertainty. Importantly this requires that
if the detection function has covariates, then these do not vary within a
segment (so, for example covariates like sex cannot be used).
</p>
<p>For more information on how to construct the prediction grid <code>data.frame</code>,
<code>newdata</code>, see <code><a href="#topic+predict.dsm">predict.dsm</a></code>.
</p>
<p>This routine is only useful if a detection function with covariates has been
used in the DSM.
</p>
<p>Note that we can use <code>var.type="Vc"</code> here (see <code>gamObject</code>), which is the
variance-covariance matrix for the spatial model, corrected for smoothing
parameter uncertainty. See Wood, Pya &amp; S\&quot;afken (2016) for more
information.
</p>
<p>Models with fixed scale parameters (e.g., negative binomial) do not require
an extra round of optimisation.
</p>


<h3>Value</h3>

<p>a <code>list</code> with elements:
</p>

<ul>
<li> <p><code>old_model</code> fitted model supplied to the function as <code>model</code>
</p>
</li>
<li> <p><code>refit</code> refitted model object, with extra term
</p>
</li>
<li> <p><code>pred</code> point estimates of predictions at <code>newdata</code>
</p>
</li>
<li> <p><code>var</code> total variance calculated over all of <code>newdata</code>
</p>
</li>
<li> <p><code>ses</code> standard error for each prediction cell in <code>newdata</code>
if <code>newdata=NULL</code> then the last three entries are <code>NA</code>.
</p>
</li></ul>



<h3>Diagnostics</h3>

<p>The summary output from the function includes a simply diagnostic that shows
the average probability of detection from the &quot;original&quot; fitted model (the
model supplied to this function; column <code>Fitted.model</code>) and the probability
of detection from the refitted model (used for variance propagation; column
<code>Refitted.model</code>) along with the standard error of the probability of
detection from the fitted model (<code>Fitted.model.se</code>), at the unique values of
any factor covariates used in the detection function (for continuous
covariates the 5%, 50% and 95% quantiles are shown). If there are large
differences between the probabilities of detection then there are
potentially problems with the fitted model, the variance propagation or
both. This can be because the fitted model does not account for enough of
the variability in the data and in refitting the variance model accounts for
this in the random effect.
</p>


<h3>Author(s)</h3>

<p>David L. Miller, based on code from Mark V. Bravington and Sharon L.
Hedley.
</p>


<h3>References</h3>

<p>Bravington, M. V., Miller, D. L., &amp; Hedley, S. L. (2021). Variance
Propagation for Density Surface Models. Journal of Agricultural, Biological
and Environmental Statistics. https://doi.org/10.1007/s13253-021-00438-2
</p>
<p>Williams, R., Hedley, S.L., Branch, T.A., Bravington, M.V., Zerbini, A.N.
and Findlay, K.P. (2011). Chilean Blue Whales as a Case Study to Illustrate
Methods to Estimate Abundance and Evaluate Conservation Status of Rare
Species. Conservation Biology 25(3), 526-535.
</p>
<p>Wood, S.N., Pya, N. and S\&quot;afken, B. (2016) Smoothing parameter and model
selection for general smooth models. Journal of the American Statistical
Association, 1-45.
</p>

<hr>
<h2 id='dsm-data'>Data format for DSM</h2><span id='topic+dsm-data'></span>

<h3>Description</h3>

<p>Two <code>data.frame</code>s must be provided to <code><a href="#topic+dsm">dsm</a></code>. They are referred to as
<code>observation.data</code> and <code>segment.data</code>.
</p>


<h3>Details</h3>

<p>The <code>segment.data</code> table has the sample identifiers which define the
segments, the corresponding effort (line length) expended and the
environmental covariates that will be used to model abundance/density.
<code>observation.data</code> provides a link table between the observations used in
the detection function and the samples (segments), so that we can aggregate
the observations to the segments (i.e., <code>observation.data</code> is a &quot;look-up
table&quot; between the observations and the segments).
</p>
<p><code>observation.data</code> - the observation <code>data.frame</code> must have (at least) the
following columns:
</p>

<ul>
<li> <p><code>object</code> unique object identifier
</p>
</li>
<li> <p><code>Sample.Label</code> the identifier for the segment where observation occurred
</p>
</li>
<li> <p><code>size</code> the size of each observed group (e.g., 1 if all animals occurred
individually)
</p>
</li>
<li> <p><code>distance</code> distance to observation
</p>
</li></ul>

<p>One can often also use <code>observation.data</code> to fit a detection function (so
additional columns for detection function covariates are allowed in this
table).
</p>
<p><code>segment.data</code>: the segment <code>data.frame</code> must have (at least) the following
columns:
</p>

<ul>
<li> <p><code>Effort</code> the effort (in terms of length of the segment)
</p>
</li>
<li> <p><code>Sample.Label</code> identifier for the segment (unique!)
</p>
</li>
<li><p> ??? environmental covariates, for example location (projected latitude
and longitude), and other relevant covariates (sea surface temperature,
foliage type, altitude, bathymetry etc).
</p>
</li></ul>



<h3>Multiple detection functions</h3>

<p>If multiple detection functions are to be used, then a column named <code>ddfobj</code>
must be included in <code>observation.data</code> and <code>segment.data</code>. This lets the
model know which detection function each observation is from. These are
numeric and ordered as the <code>ddf.obj</code> argument to <code><a href="#topic+dsm">dsm</a></code>, e.g.,
<code>ddf.obj=list(ship_ddf, aerial_ddf)</code> means ship detections have <code>ddfobj=1</code>
and aerial detections have <code>ddfobj=2</code> in the observation data.
</p>


<h3>Mark-recapture distance sampling models</h3>

<p>When using <code>mrds</code> models that include mark-recapture components (currently
independent observer and trial modes are supported) then the format of the
observation data needs to be checked to ensure that observations are not
duplicated. The <code>observer</code> column is also required in the
<code>observation.data</code>.
</p>

<ul>
<li> <p><em>Independent observer mode</em> only unique observations (unique object IDs)
are required.
</p>
</li>
<li> <p><em>Trial mode</em> only observations made by observer 1 are required.
</p>
</li></ul>


<hr>
<h2 id='dsm.cor'>Check for autocorrelation in residuals</h2><span id='topic+dsm.cor'></span>

<h3>Description</h3>

<p>This function is deprecated, use <a href="#topic+dsm_cor">dsm_cor</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm.cor(
  dsm.obj,
  Transect.Label = "Transect.Label",
  Segment.Label = "Segment.Label",
  max.lag = 10,
  resid.type = "scaled.pearson",
  fun = cor,
  ylim = c(0, 1),
  subset = "all",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm.cor_+3A_dsm.obj">dsm.obj</code></td>
<td>
<p>a fitted dsm object.</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_transect.label">Transect.Label</code></td>
<td>
<p>label for the transect (default: <code>Transect.Label</code>).
Using different labels can be useful when transects are split over
geographical features or when transects are surveyed multiple times.</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_segment.label">Segment.Label</code></td>
<td>
<p>label for the segments (default: <code>Segment.Label</code>).The
result of calling <code><a href="base.html#topic+order">order</a></code> must make sense.</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_max.lag">max.lag</code></td>
<td>
<p>maximum lag to calculate at.</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_resid.type">resid.type</code></td>
<td>
<p>the type of residuals used, see
<code><a href="mgcv.html#topic+residuals.gam">residuals.gam</a></code>. Defaults to <code>"scaled.pearson"</code> in the GAM
case and <code>"normalized"</code> in the GAMM case (which are equivalent).</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_fun">fun</code></td>
<td>
<p>the function to use, by default <code><a href="stats.html#topic+cor">cor</a></code>, must take two
column vectors as arguments.</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_ylim">ylim</code></td>
<td>
<p>user defined limits in y direction.</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_subset">subset</code></td>
<td>
<p>which subset of the data should the correlation function be
calculated on?</p>
</td></tr>
<tr><td><code id="dsm.cor_+3A_...">...</code></td>
<td>
<p>other options to pass to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='dsm.var.gam'>Prediction variance estimation assuming independence</h2><span id='topic+dsm.var.gam'></span>

<h3>Description</h3>

<p>This function is deprecated, use <a href="#topic+dsm_var_gam">dsm_var_gam</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm.var.gam(
  dsm.obj,
  pred.data,
  off.set,
  seglen.varname = "Effort",
  type.pred = "response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm.var.gam_+3A_dsm.obj">dsm.obj</code></td>
<td>
<p>a model object fitted by <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="dsm.var.gam_+3A_pred.data">pred.data</code></td>
<td>
<p>either: a single prediction grid or list of prediction
grids. Each grid should be a <code>data.frame</code> with the same columns as the
original data.</p>
</td></tr>
<tr><td><code id="dsm.var.gam_+3A_off.set">off.set</code></td>
<td>
<p>a a vector or list of vectors with as many elements as there
are in <code>pred.data</code>. Each vector is as long as the number of rows in the
corresponding element of <code>pred.data</code>. These give the area associated with
each prediction cell. If a single number is supplied it will be replicated
for the length of <code>pred.data</code>.</p>
</td></tr>
<tr><td><code id="dsm.var.gam_+3A_seglen.varname">seglen.varname</code></td>
<td>
<p>name for the column which holds the segment length
(default value <code>"Effort"</code>).</p>
</td></tr>
<tr><td><code id="dsm.var.gam_+3A_type.pred">type.pred</code></td>
<td>
<p>should the predictions be on the &quot;response&quot; or &quot;link&quot;
scale? (default <code>"response"</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='dsm.var.movblk'>Variance estimation via parametric moving block bootstrap</h2><span id='topic+dsm.var.movblk'></span>

<h3>Description</h3>

<p>This function is deprecated, use <a href="#topic+dsm_var_movblk">dsm_var_movblk</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm.var.movblk(
  dsm.object,
  pred.data,
  n.boot,
  block.size,
  off.set,
  ds.uncertainty = FALSE,
  samp.unit.name = "Transect.Label",
  progress.file = NULL,
  bs.file = NULL,
  bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm.var.movblk_+3A_dsm.object">dsm.object</code></td>
<td>
<p>object returned from <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_pred.data">pred.data</code></td>
<td>
<p>either: a single prediction grid or list of prediction
grids. Each grid should be a <code>data.frame</code> with the same columns as the
original data.</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_n.boot">n.boot</code></td>
<td>
<p>number of bootstrap resamples.</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_block.size">block.size</code></td>
<td>
<p>number of segments in each block.</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_off.set">off.set</code></td>
<td>
<p>a a vector or list of vectors with as many elements as there
are in <code>pred.data</code>. Each vector is as long as the number of rows in the
corresponding element of <code>pred.data</code>. These give the area associated with
each prediction cell. If a single number is supplied it will be replicated
for the length of <code>pred.data</code>.</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_ds.uncertainty">ds.uncertainty</code></td>
<td>
<p>incorporate uncertainty in the detection function? See
Details, below. Note that this feature is EXPERIMENTAL at the moment.</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_samp.unit.name">samp.unit.name</code></td>
<td>
<p>name sampling unit to resample (default
'Transect.Label').</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_progress.file">progress.file</code></td>
<td>
<p>path to a file to be used (usually by Distance) to
generate a progress bar (default <code>NULL</code> &ndash; no file written).</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_bs.file">bs.file</code></td>
<td>
<p>path to a file to store each bootstrap round. This stores all
of the bootstrap results rather than just the summaries, enabling
outliers to be detected and removed. (Default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="dsm.var.movblk_+3A_bar">bar</code></td>
<td>
<p>should a progress bar be printed to screen? (Default <code>TRUE</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='dsm.var.prop'>Prediction variance propagation for DSMs</h2><span id='topic+dsm.var.prop'></span>

<h3>Description</h3>

<p>This function is deprecated, use <a href="#topic+dsm_var_prop">dsm_var_prop</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsm.var.prop(
  dsm.obj,
  pred.data,
  off.set,
  seglen.varname = "Effort",
  type.pred = "response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsm.var.prop_+3A_dsm.obj">dsm.obj</code></td>
<td>
<p>a model object fitted by <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="dsm.var.prop_+3A_pred.data">pred.data</code></td>
<td>
<p>either: a single prediction grid or list of prediction
grids. Each grid should be a <code>data.frame</code> with the same columns as the
original data.</p>
</td></tr>
<tr><td><code id="dsm.var.prop_+3A_off.set">off.set</code></td>
<td>
<p>a a vector or list of vectors with as many elements as there
are in <code>pred.data</code>. Each vector is as long as the number of rows in the
corresponding element of <code>pred.data</code>. These give the area associated with
each prediction cell. If a single number is supplied it will be replicated
for the length of <code>pred.data</code>.</p>
</td></tr>
<tr><td><code id="dsm.var.prop_+3A_seglen.varname">seglen.varname</code></td>
<td>
<p>name for the column which holds the segment length
(default value <code>"Effort"</code>).</p>
</td></tr>
<tr><td><code id="dsm.var.prop_+3A_type.pred">type.pred</code></td>
<td>
<p>should the predictions be on the &quot;response&quot; or &quot;link&quot;
scale? (default <code>"response"</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='dummy_ddf'>Detection function objects when detection is certain</h2><span id='topic+dummy_ddf'></span>

<h3>Description</h3>

<p>Create a detection function object for strip/plot surveys for use in density
surface models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_ddf(object, size = 1, width, left = 0, transect = "line")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_ddf_+3A_object">object</code></td>
<td>
<p>numeric vector of object identifiers, relating to the <code>object</code>
field in the observation data of the DSM.</p>
</td></tr>
<tr><td><code id="dummy_ddf_+3A_size">size</code></td>
<td>
<p>group size for each observation (default all groups size 1)</p>
</td></tr>
<tr><td><code id="dummy_ddf_+3A_width">width</code></td>
<td>
<p>right truncation</p>
</td></tr>
<tr><td><code id="dummy_ddf_+3A_left">left</code></td>
<td>
<p>left truncation (default 0, no left truncation)</p>
</td></tr>
<tr><td><code id="dummy_ddf_+3A_transect">transect</code></td>
<td>
<p><code>"line"</code> or <code>"point"</code> transect</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David L Miller
</p>

<hr>
<h2 id='generate.ds.uncertainty'>Generate data from a fitted detection function</h2><span id='topic+generate.ds.uncertainty'></span>

<h3>Description</h3>

<p>When using <code><a href="#topic+dsm.var.movblk">dsm.var.movblk</a></code> if <code>ds.uncertainty=TRUE</code>, this
procedure generates data from the fitted detection function (assuming that
it is correct).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.ds.uncertainty(ds.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.ds.uncertainty_+3A_ds.object">ds.object</code></td>
<td>
<p>a fitted detection function object (as returned by a call
to <code><a href="mrds.html#topic+ddf.ds">ddf.ds</a></code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function changes the random number generator seed. To avoid any
potential side-effects, use something like: <code>seed &lt;- get(".Random.seed",envir=.GlobalEnv)</code> before running code and
<code>assign(".Random.seed",seed,envir=.GlobalEnv)</code> after.
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>

<hr>
<h2 id='generate.mb.sample'>Moving block bootstrap sampler</h2><span id='topic+generate.mb.sample'></span>

<h3>Description</h3>

<p>Not usually used on its own, called from within
<code><a href="#topic+dsm.var.movblk">dsm.var.movblk</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.mb.sample(
  num.blocks.required,
  block.size,
  which.blocks,
  dsm.data,
  unit.info,
  n.units
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.mb.sample_+3A_num.blocks.required">num.blocks.required</code></td>
<td>
<p>number of blocks that we need.</p>
</td></tr>
<tr><td><code id="generate.mb.sample_+3A_block.size">block.size</code></td>
<td>
<p>number of segments per block.</p>
</td></tr>
<tr><td><code id="generate.mb.sample_+3A_which.blocks">which.blocks</code></td>
<td>
<p>which blocks should be sampled.</p>
</td></tr>
<tr><td><code id="generate.mb.sample_+3A_dsm.data">dsm.data</code></td>
<td>
<p>the <code style="white-space: pre;">&#8288;$data&#8288;</code> element of the result of a call to <code><a href="#topic+dsm">dsm</a></code>.</p>
</td></tr>
<tr><td><code id="generate.mb.sample_+3A_unit.info">unit.info</code></td>
<td>
<p>result of calling <code><a href="#topic+block.info.per.su">block.info.per.su</a></code>.</p>
</td></tr>
<tr><td><code id="generate.mb.sample_+3A_n.units">n.units</code></td>
<td>
<p>number of sampling units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of log-residuals
</p>

<hr>
<h2 id='latlong2km'>Convert latitude and longitude to Northings and Eastings</h2><span id='topic+latlong2km'></span>

<h3>Description</h3>

<p>Convert longitude and latitude co-ordinates to kilometres west-east and
south-north from axes through (<code>lon0</code>,<code>lat0</code>) using the
&quot;spherical law of cosines&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong2km(lon, lat, lon0 = sum(range(lon))/2, lat0 = sum(range(lat))/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlong2km_+3A_lon">lon</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code id="latlong2km_+3A_lat">lat</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code id="latlong2km_+3A_lon0">lon0</code></td>
<td>
<p>longitude reference point (defaults to mean longitude)</p>
</td></tr>
<tr><td><code id="latlong2km_+3A_lat0">lat0</code></td>
<td>
<p>latitude reference point (defaults to mean latitude)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: This is an approximate procedure for converting between latitude/
longitude and Northing/Easting. Consider using projection conversions
available in packages <code>sp</code>, <code>sf</code> and <code>rgdal</code> for better results.
</p>


<h3>Value</h3>

<p>list with elements <code>km.e</code> and <code>km.n</code>.
</p>


<h3>Author(s)</h3>

<p>Simon N. Wood
</p>

<hr>
<h2 id='make.soapgrid'>Create a knot grid for the internal part of a soap film smoother.</h2><span id='topic+make.soapgrid'></span>

<h3>Description</h3>

<p>This routine simply creates a grid of knots (in the correct format) to be
used as in the &quot;internal&quot; part of the soap film smoother
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.soapgrid(bnd, n.grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.soapgrid_+3A_bnd">bnd</code></td>
<td>
<p><code>list</code> with elements <code>x</code> and <code>y</code> which give the locations of the
boundary vertices. The first and last elements should be the same.</p>
</td></tr>
<tr><td><code id="make.soapgrid_+3A_n.grid">n.grid</code></td>
<td>
<p>either one number giving the number of points along the <code>x</code>
and <code>y</code> axes that should be used to create the grid, or a vector giving the
number in the <code>x</code> direction, then <code>y</code> direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>x</code> and <code>y</code>, containing the knot locations.
</p>


<h3>Author(s)</h3>

<p>David L Miller
</p>

<hr>
<h2 id='mexdolphins'>Pan-tropical spotted dolphins in the Gulf of Mexico</h2><span id='topic+mexdolphins'></span><span id='topic+obsdata'></span><span id='topic+segdata'></span><span id='topic+preddata'></span><span id='topic+pred.polys'></span><span id='topic+distdata'></span><span id='topic+survey.area'></span>

<h3>Description</h3>

<p>Data from a combination of several NOAA shipboard surveys conducted on
pan-tropical spotted dolphins in the Gulf of Mexico. The data consist of 47
observations of groups of dolphins. The group size was recorded, as well as
the Beaufort sea state at the time of the observation. Coordinates for each
observation and bathymetry data were also available as covariates for the
analysis. A complete example analysis (and description of the data) is
provided at <a href="http://distancesampling.org/R/vignettes/mexico-analysis.html">http://distancesampling.org/R/vignettes/mexico-analysis.html</a>.
</p>


<h3>References</h3>

<p>Halpin, P.N., A.J. Read, E. Fujioka, B.D. Best, B. Donnelly,
L.J. Hazen, C. Kot, K. Urian, E. LaBrecque, A. Dimatteo, J. Cleary, C. Good,
L.B. Crowder, and K.D. Hyrenbach. 2009. OBIS-SEAMAP: The world data center
for marine mammal, sea bird, and sea turtle distributions. Oceanography
22(2):104-115
</p>
<p>NOAA Southeast Fisheries Science Center. 1996. Report of a Cetacean Survey
of Oceanic and Selected Continental Shelf Waters of the Northern Gulf of
Mexico aboard NOAA Ship Oregon II (Cruise 220)
</p>

<hr>
<h2 id='obs_exp'>Observed versus expected diagnostics for fitted DSMs</h2><span id='topic+obs_exp'></span>

<h3>Description</h3>

<p>Given a covariate, calculate the observed and expected counts for each
unique value of the covariate. This can be a useful goodness of fit check
for DSMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs_exp(model, covar, cut = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obs_exp_+3A_model">model</code></td>
<td>
<p>a fitted <code><a href="#topic+dsm">dsm</a></code> model object</p>
</td></tr>
<tr><td><code id="obs_exp_+3A_covar">covar</code></td>
<td>
<p>covariate to aggregate by (<code>character</code>)</p>
</td></tr>
<tr><td><code id="obs_exp_+3A_cut">cut</code></td>
<td>
<p>vector of cut points to aggregate at. If not supplied, the unique
values of <code>covar</code> are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One strategy for model checking is to calculate observed and expected counts
at different aggregations of the variable. If these match well then the
model fit is good.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with values of observed and expected counts.
</p>


<h3>Author(s)</h3>

<p>David L Miller, on the suggestion of Mark Bravington.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Distance)
library(dsm)

# example with the Gulf of Mexico dolphin data
data(mexdolphins)
hr.model &lt;- ds(distdata, truncation=6000,
               key = "hr", adjustment = NULL)
mod1 &lt;- dsm(count~s(x,y), hr.model, segdata, obsdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_pred_by_term'>Spatially plot predictions per model term</h2><span id='topic+plot_pred_by_term'></span>

<h3>Description</h3>

<p>Plot the effect of each smooth in the model spatially. For each term in the
model, plot its effect in space. Plots are made on the same scale, so that
the relative influence of each smooth can be seen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pred_by_term(dsm.obj, data, location.cov = c("x", "y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pred_by_term_+3A_dsm.obj">dsm.obj</code></td>
<td>
<p>fitted <code><a href="#topic+dsm">dsm</a></code> object</p>
</td></tr>
<tr><td><code id="plot_pred_by_term_+3A_data">data</code></td>
<td>
<p>data to use to plot (often the same as the prediction grid), data
should also include <code>width</code> and <code>height</code> columns for plotting</p>
</td></tr>
<tr><td><code id="plot_pred_by_term_+3A_location.cov">location.cov</code></td>
<td>
<p>deprecated, use <code>location.cov</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot2</code> plot
</p>


<h3>Author(s)</h3>

<p>David L Miller (idea taken from <code>inlabru</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Distance)
library(dsm)

# load the Gulf of Mexico dolphin data and fit a model
data(mexdolphins)
hr.model &lt;- ds(distdata, truncation=6000,
               key = "hr", adjustment = NULL)
mod1 &lt;- dsm(count~s(x,y) + s(depth), hr.model, segdata, obsdata)

preddata$width &lt;- preddata$height &lt;- sqrt(preddata$area)

# make the plot
plot_pred_by_term(mod1, preddata, c("x","y"))

# better plot would be
# library(viridis)
# plot_pred_by_term(mod1, preddata, c("x","y")) + scale_fill_viridis()

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.dsm'>Plot a density surface model.</h2><span id='topic+plot.dsm'></span>

<h3>Description</h3>

<p>See <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dsm_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+dsm">dsm</a></code></p>
</td></tr>
<tr><td><code id="plot.dsm_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot!
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsm">dsm</a></code> <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>
</p>

<hr>
<h2 id='plot.dsm.var'>Create plots of abundance uncertainty</h2><span id='topic+plot.dsm.var'></span>

<h3>Description</h3>

<p>Note that the prediction data set must have <code>x</code> and <code>y</code> columns even if
these were not used in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm.var'
plot(
  x,
  poly = NULL,
  limits = NULL,
  breaks = NULL,
  legend.breaks = NULL,
  xlab = "x",
  ylab = "y",
  observations = TRUE,
  plot = TRUE,
  boxplot.coef = 1.5,
  x.name = "x",
  y.name = "y",
  gg.grad = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dsm.var_+3A_x">x</code></td>
<td>
<p>a <code>dsm.var</code> object</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_poly">poly</code></td>
<td>
<p>a <code>list</code> or <code>data.frame</code> with columns <code>x</code> and <code>y</code>, which gives
the coordinates of a polygon to draw. It may also optionally have a column
<code>group</code>, if there are many polygons.</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_limits">limits</code></td>
<td>
<p>limits for the fill colours</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_breaks">breaks</code></td>
<td>
<p>breaks for the colour fill</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_legend.breaks">legend.breaks</code></td>
<td>
<p>breaks as they should be displayed</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_xlab">xlab</code></td>
<td>
<p>label for the <code>x</code> axis</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_ylab">ylab</code></td>
<td>
<p>label for the <code>y</code> axis</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_observations">observations</code></td>
<td>
<p>should observations be plotted?</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_plot">plot</code></td>
<td>
<p>actually plot the map, or just return a <code>ggplot2</code> object?</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_boxplot.coef">boxplot.coef</code></td>
<td>
<p>control trimming (as in
<code><a href="#topic+summary.dsm.var">summary.dsm.var</a></code>), only has an effect if the bootstrap
file was saved.</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_x.name">x.name</code></td>
<td>
<p>name of the variable to plot as the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_y.name">y.name</code></td>
<td>
<p>name of the variable to plot as the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_gg.grad">gg.grad</code></td>
<td>
<p>optional <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> gradient object.</p>
</td></tr>
<tr><td><code id="plot.dsm.var_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Details</h3>

<p>In order to get plotting to work with <code><a href="#topic+dsm_var_prop">dsm_var_prop</a></code> and
<code><a href="#topic+dsm_var_gam">dsm_var_gam</a></code>, one must first format the data correctly
since these functions are designed to compute very general summaries. One
summary is calculated for each element of the list <code>pred</code> supplied to
<code><a href="#topic+dsm_var_prop">dsm_var_prop</a></code> and <code><a href="#topic+dsm_var_gam">dsm_var_gam</a></code>.
</p>
<p>For a plot of uncertainty over a prediction grid, <code>pred</code> (a <code>data.frame</code>),
say, we can create the correct format by simply using <code>pred.new &lt;- split(pred,1:nrow(pred))</code>.
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsm_var_prop">dsm_var_prop</a></code>, <code><a href="#topic+dsm_var_gam">dsm_var_gam</a></code>,
<code><a href="#topic+dsm_var_movblk">dsm_var_movblk</a></code>
</p>

<hr>
<h2 id='predict.dsm'>Predict from a fitted density surface model</h2><span id='topic+predict.dsm'></span>

<h3>Description</h3>

<p>Make predictions of density or abundance outside (or inside) the covered
area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm'
predict(object, newdata = NULL, off.set = NULL, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dsm_+3A_object">object</code></td>
<td>
<p>a fitted <code><a href="#topic+dsm">dsm</a></code> object</p>
</td></tr>
<tr><td><code id="predict.dsm_+3A_newdata">newdata</code></td>
<td>
<p>spatially referenced covariates e.g. altitude, depth,
distance to shore, etc. Covariates in the <code>data.frame</code> must have names
<em>identical</em> to variable names used in fitting the model</p>
</td></tr>
<tr><td><code id="predict.dsm_+3A_off.set">off.set</code></td>
<td>
<p>area of each of the cells in the prediction grid. Should be
in the same units as the segments/distances given to <code>dsm</code>. Replaces the
column in <code>newdata</code> called <code>off.set</code> if it is supplied. Ignored if <code>newdata</code>
is not supplied</p>
</td></tr>
<tr><td><code id="predict.dsm_+3A_type">type</code></td>
<td>
<p>what scale should the results be on. The default is
<code>"response"</code>, see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> for an explanation of
other options (usually not necessary)</p>
</td></tr>
<tr><td><code id="predict.dsm_+3A_...">...</code></td>
<td>
<p>any other arguments passed to <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is not supplied, predictions are made for the data that built
the model. Note that the order of the results will not necessarily be the
same as the <code>segdata</code> (segment data) <code>data.frame</code> that was supplied to
<code><a href="#topic+dsm">dsm</a></code>.
</p>
<p>The area <code>off.set</code> is used if that argument is supplied, otherwise it will
look for the areas in the column named <code>off.set</code> in the <code>newdata</code>. Either
way the link function (usually <code>log</code>) will be applied to the offsets, so
there is no need to log them before passing them to this function.
</p>


<h3>Value</h3>

<p>predicted values on the response scale by default (unless <code>type</code> is
specified, in which case see <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>).
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code>, <code><a href="#topic+dsm_var_gam">dsm_var_gam</a></code>,
<code><a href="#topic+dsm_var_prop">dsm_var_prop</a></code>
</p>

<hr>
<h2 id='predict.fake_ddf'>Prediction for fake detection functions</h2><span id='topic+predict.fake_ddf'></span>

<h3>Description</h3>

<p>Prediction function for dummy detection functions. The function returns as
many 1s as there are rows in <code>newdata</code>. If <code>esw=TRUE</code> then the
strip width is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fake_ddf'
predict(
  object,
  newdata = NULL,
  compute = FALSE,
  int.range = NULL,
  esw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fake_ddf_+3A_object">object</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="predict.fake_ddf_+3A_newdata">newdata</code></td>
<td>
<p>how many 1s should we return?</p>
</td></tr>
<tr><td><code id="predict.fake_ddf_+3A_compute">compute</code></td>
<td>
<p>unused, compatibility with <code><a href="mrds.html#topic+predict.ds">mrds::predict</a></code></p>
</td></tr>
<tr><td><code id="predict.fake_ddf_+3A_int.range">int.range</code></td>
<td>
<p>unused, compatibility with <code><a href="mrds.html#topic+predict.ds">mrds::predict</a></code></p>
</td></tr>
<tr><td><code id="predict.fake_ddf_+3A_esw">esw</code></td>
<td>
<p>should the strip width be returned?</p>
</td></tr>
<tr><td><code id="predict.fake_ddf_+3A_...">...</code></td>
<td>
<p>for S3 consistency</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David L Miller
</p>

<hr>
<h2 id='print.dsm'>Print a description of a density surface model object</h2><span id='topic+print.dsm'></span>

<h3>Description</h3>

<p>This method just gives a short description of the fitted model. Use the
<code><a href="#topic+summary.dsm">summary.dsm</a></code> method for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dsm_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+dsm">dsm</a></code></p>
</td></tr>
<tr><td><code id="print.dsm_+3A_...">...</code></td>
<td>
<p>unspecified and unused arguments for S3 consistency</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>

<hr>
<h2 id='print.dsm_varprop'>Print a description of a density surface model variance object</h2><span id='topic+print.dsm_varprop'></span>

<h3>Description</h3>

<p>This method only provides a short summary, see
<code><a href="#topic+summary.dsm_varprop">summary.dsm_varprop</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm_varprop'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dsm_varprop_+3A_x">x</code></td>
<td>
<p>a <code>dsm</code> variance object</p>
</td></tr>
<tr><td><code id="print.dsm_varprop_+3A_...">...</code></td>
<td>
<p>unspecified and unused arguments for S3 consistency</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dsm_varprop">summary.dsm_varprop</a></code>
</p>

<hr>
<h2 id='print.dsm.var'>Print a description of a density surface model variance object</h2><span id='topic+print.dsm.var'></span>

<h3>Description</h3>

<p>This method only provides a short summary, use the
<code><a href="#topic+summary.dsm.var">summary.dsm.var</a></code> method for information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm.var'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dsm.var_+3A_x">x</code></td>
<td>
<p>a <code>dsm</code> variance object</p>
</td></tr>
<tr><td><code id="print.dsm.var_+3A_...">...</code></td>
<td>
<p>unspecified and unused arguments for S3 consistency</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dsm.var">summary.dsm.var</a></code>
</p>

<hr>
<h2 id='print.summary.dsm_varprop'>Print summary of density surface model variance object</h2><span id='topic+print.summary.dsm_varprop'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+summary.dsm_varprop">summary.dsm_varprop</a></code> for information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.dsm_varprop'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.dsm_varprop_+3A_x">x</code></td>
<td>
<p>a summary of <code>dsm</code> variance object</p>
</td></tr>
<tr><td><code id="print.summary.dsm_varprop_+3A_...">...</code></td>
<td>
<p>unspecified and unused arguments for S3 consistency</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dsm.var">summary.dsm.var</a></code>
</p>

<hr>
<h2 id='print.summary.dsm.var'>Print summary of density surface model variance object</h2><span id='topic+print.summary.dsm.var'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+summary.dsm.var">summary.dsm.var</a></code> for information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.dsm.var'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.dsm.var_+3A_x">x</code></td>
<td>
<p>a summary of <code>dsm</code> variance object</p>
</td></tr>
<tr><td><code id="print.summary.dsm.var_+3A_...">...</code></td>
<td>
<p>unspecified and unused arguments for S3 consistency</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dsm.var">summary.dsm.var</a></code>
</p>

<hr>
<h2 id='rqgam_check'>Randomised quantile residuals check plot for GAMs/DSMs</h2><span id='topic+rqgam_check'></span>

<h3>Description</h3>

<p>Reproduces the &quot;Resids vs. linear pred&quot; plot from
<code><a href="mgcv.html#topic+gam.check">gam.check</a></code> but using randomised quantile residuals, a la
Dunn and Smyth (1996). Checks for heteroskedasticity as as usual, looking
for &quot;funnel&quot;-type structures in the points, which is much easier with
randomised quantile residuals than with deviance residuals, when your model
uses a count distribution as the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqgam_check(gam.obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rqgam_check_+3A_gam.obj">gam.obj</code></td>
<td>
<p>a <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="#topic+dsm">dsm</a></code>
object.</p>
</td></tr>
<tr><td><code id="rqgam_check_+3A_...">...</code></td>
<td>
<p>arguments passed on to all plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function only works with negative binomial and Tweedie
response distributions.
</p>
<p>Earlier versions of this function produced the full
<code><a href="mgcv.html#topic+gam.check">gam.check</a></code> output, but this was confusing as only one of
the plots was really useful.  Checks of <code>k</code> are not computed, these need to
be done using <code><a href="mgcv.html#topic+gam.check">gam.check</a></code>.
</p>


<h3>Value</h3>

<p>just plots!
</p>


<h3>Author(s)</h3>

<p>Based on code by Natalie Kelly, bugs added by Dave Miller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Distance)
library(dsm)
library(tweedie)

# load the Gulf of Mexico dolphin data (see ?mexdolphins)
data(mexdolphins)

# fit a detection function and look at the summary
hr.model &lt;- ds(distdata, truncation=6000,
               key = "hr", adjustment = NULL)

# fit a simple smooth of x and y with a Tweedie response with estimated
#  p parameter
mod1 &lt;- dsm(count~s(x, y), hr.model, segdata, obsdata, family=tw())
rqgam_check(mod1)

</code></pre>

<hr>
<h2 id='rqgam.check'>Randomised quantile residuals check plot for GAMs/DSMs</h2><span id='topic+rqgam.check'></span>

<h3>Description</h3>

<p>This function is deprecated, use <a href="#topic+rqgam_check">rqgam_check</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqgam.check(gam.obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rqgam.check_+3A_gam.obj">gam.obj</code></td>
<td>
<p>a <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="#topic+dsm">dsm</a></code>
object.</p>
</td></tr>
<tr><td><code id="rqgam.check_+3A_...">...</code></td>
<td>
<p>arguments passed on to all plotting functions</p>
</td></tr>
</table>

<hr>
<h2 id='summary.dsm'>Summarize a fitted density surface model</h2><span id='topic+summary.dsm'></span>

<h3>Description</h3>

<p>Gives a brief summary of a fitted <code><a href="#topic+dsm">dsm</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dsm_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+dsm">dsm</a></code></p>
</td></tr>
<tr><td><code id="summary.dsm_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary object
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsm">dsm</a></code>
</p>

<hr>
<h2 id='summary.dsm_varprop'>Summarize the variance of a density surface model</h2><span id='topic+summary.dsm_varprop'></span>

<h3>Description</h3>

<p>Gives a brief summary of a fitted <code><a href="#topic+dsm_varprop">dsm_varprop</a></code> variance
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm_varprop'
summary(object, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dsm_varprop_+3A_object">object</code></td>
<td>
<p>a <code>dsm.var</code> object</p>
</td></tr>
<tr><td><code id="summary.dsm_varprop_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence intervals (default 0.05 to give a
95% confidence internal)</p>
</td></tr>
<tr><td><code id="summary.dsm_varprop_+3A_...">...</code></td>
<td>
<p>unused arguments for S3 compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary object
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsm_varprop">dsm_varprop</a></code>, <code><a href="#topic+summary.dsm.var">summary.dsm.var</a></code>
</p>

<hr>
<h2 id='summary.dsm.var'>Summarize the variance of a density surface model</h2><span id='topic+summary.dsm.var'></span>

<h3>Description</h3>

<p>Gives a brief summary of a fitted <code>dsm</code> variance object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsm.var'
summary(
  object,
  alpha = 0.05,
  boxplot.coef = 1.5,
  bootstrap.subregions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dsm.var_+3A_object">object</code></td>
<td>
<p>a <code>dsm.var</code> object</p>
</td></tr>
<tr><td><code id="summary.dsm.var_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence intervals (default 0.05 to give a
95\
confidence intervals)</p>
</td></tr>
<tr><td><code id="summary.dsm.var_+3A_boxplot.coef">boxplot.coef</code></td>
<td>
<p>the value of <code>coef</code> used to calculate the outliers see
<code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
<tr><td><code id="summary.dsm.var_+3A_bootstrap.subregions">bootstrap.subregions</code></td>
<td>
<p>list of vectors of logicals or indices for
subregions for which variances need to be calculated (only for bootstraps
(see <code><a href="#topic+dsm.var.prop">dsm.var.prop</a></code> for how to use subregions with variance
propagation).</p>
</td></tr>
<tr><td><code id="summary.dsm.var_+3A_...">...</code></td>
<td>
<p>unused arguments for S3 compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary object
</p>


<h3>Author(s)</h3>

<p>David L. Miller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsm.var.movblk">dsm.var.movblk</a></code>, <code><a href="#topic+dsm.var.prop">dsm.var.prop</a></code>
</p>

<hr>
<h2 id='trim.var'>Trimmed variance</h2><span id='topic+trim.var'></span>

<h3>Description</h3>

<p>Trim the variance estimates from the bootstrap. This is defined as the
percentage defined as amount necessary to bring median and trimmed mean
within 8% of each other these are defined as 'outliers'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim.var(untrimmed.bootstraps, boxplot.coef = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.var_+3A_untrimmed.bootstraps">untrimmed.bootstraps</code></td>
<td>
<p>(usually the <code style="white-space: pre;">&#8288;$study.area.total&#8288;</code> element of a
returned <code><a href="#topic+dsm.var.movblk">dsm.var.movblk</a></code> bootstrap object.</p>
</td></tr>
<tr><td><code id="trim.var_+3A_boxplot.coef">boxplot.coef</code></td>
<td>
<p>the value of <code>coef</code> used to calculate the outliers see
<code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>trimmed variance
</p>


<h3>Author(s)</h3>

<p>Louise Burt
</p>

<hr>
<h2 id='vis_concurvity'>Visualise concurvity between terms in a GAM</h2><span id='topic+vis_concurvity'></span>

<h3>Description</h3>

<p>Plot measures of how much one term in the model could be explained by
another. When values are high, one should consider re-running variable
selection with one of the offending variables removed to check for stability
in term selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_concurvity(model, type = "estimate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vis_concurvity_+3A_model">model</code></td>
<td>
<p>fitted model</p>
</td></tr>
<tr><td><code id="vis_concurvity_+3A_type">type</code></td>
<td>
<p>concurvity measure to plot, see <code><a href="mgcv.html#topic+concurvity">concurvity</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods are considered somewhat experimental at this time. Consult
<code><a href="mgcv.html#topic+concurvity">concurvity</a></code> for more information on how concurvity
measures are calculated.
</p>


<h3>Author(s)</h3>

<p>David L Miller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Distance)
library(dsm)

# load the Gulf of Mexico dolphin data (see ?mexdolphins)
data(mexdolphins)

# fit a detection function and look at the summary
hr.model &lt;- ds(distdata, truncation=6000,
               key = "hr", adjustment = NULL)

# fit a simple smooth of x and y to counts
mod1 &lt;- dsm(count~s(x,y)+s(depth), hr.model, segdata, obsdata)

# visualise concurvity using the "estimate" metric
vis_concurvity(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='vis.concurvity'>Visualise concurvity between terms in a GAM</h2><span id='topic+vis.concurvity'></span>

<h3>Description</h3>

<p>This function is deprecated, use <a href="#topic+vis_concurvity">vis_concurvity</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.concurvity(model, type = "estimate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vis.concurvity_+3A_model">model</code></td>
<td>
<p>fitted model</p>
</td></tr>
<tr><td><code id="vis.concurvity_+3A_type">type</code></td>
<td>
<p>concurvity measure to plot, see <code><a href="mgcv.html#topic+concurvity">concurvity</a></code></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
