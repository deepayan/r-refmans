<!DOCTYPE html><html><head><title>Help for package ThreeWay</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ThreeWay}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrapCP'><p>Bootstrap percentile intervals for CANDECOMP/PARAFAC</p></a></li>
<li><a href='#bootstrapT3'><p>Bootstrap percentile intervals for Tucker3</p></a></li>
<li><a href='#Bus'><p>Bus data</p></a></li>
<li><a href='#Cc'><p>Columnwise centering of a matrix</p></a></li>
<li><a href='#ccmat'><p>Columns concatenation</p></a></li>
<li><a href='#cent3'><p>Centering of a matricized array</p></a></li>
<li><a href='#CP'><p>Interactive Candecomp/Parafac analysis</p></a></li>
<li><a href='#CPdimensionalityplot'><p>Plot fit of Candecomp/Parafac</p></a></li>
<li><a href='#CPfitpartitioning'><p>Fit of each entity per mode</p></a></li>
<li><a href='#CPfunc'><p>Algorithm for the Candecomp/Parafac (CP) model</p></a></li>
<li><a href='#CPfuncrep'><p>Algorithm for the Candecomp/Parafac (CP) model</p></a></li>
<li><a href='#CPrunsFit'><p>Candecomp/Parafac solutions</p></a></li>
<li><a href='#DimSelector'><p>Convex Hull procedure</p></a></li>
<li><a href='#jointplotgen'><p>Jointplots</p></a></li>
<li><a href='#Kinship'><p>Kinship terms data</p></a></li>
<li><a href='#LineCon'><p>Middle point location</p></a></li>
<li><a href='#meaudret'><p> Meaudret data</p></a></li>
<li><a href='#norm3'><p>Normalization of a matricized array</p></a></li>
<li><a href='#normvari'><p>Normalized varimax rotation</p></a></li>
<li><a href='#nrm2'><p> Columnwise normalization of a matrix</p></a></li>
<li><a href='#ord'><p>Order</p></a></li>
<li><a href='#orth'><p>Orthonormalization of a matrix</p></a></li>
<li><a href='#orthmax2'><p>Orthomax Rotation</p></a></li>
<li><a href='#pcamean'><p>PCA of the mean matrix</p></a></li>
<li><a href='#pcasup1'><p>PCASup Analysis</p></a></li>
<li><a href='#pcasup2'><p>PCASup Analysis</p></a></li>
<li><a href='#pcasup3'><p>PCASup Analysis</p></a></li>
<li><a href='#percentile95'><p>95% percentile intervals</p></a></li>
<li><a href='#permnew'><p>Permutation of a matricized array</p></a></li>
<li><a href='#perms'><p>Permutation</p></a></li>
<li><a href='#phi'><p>Phi coefficient</p></a></li>
<li><a href='#rarray'><p>Array reconstruction</p></a></li>
<li><a href='#renormsolCP'><p>Scaling of the Candecomp/Parafac solution</p></a></li>
<li><a href='#renormsolT3'><p>Renormalization of the Tucker3 (and Tucker2) solution</p></a></li>
<li><a href='#splithalfCP'><p>Split-Half Analysis</p></a></li>
<li><a href='#splithalfT3'><p>Split-Half Analysis</p></a></li>
<li><a href='#SUM'><p>Summary</p></a></li>
<li><a href='#supermat'><p>Matrix unfolding</p></a></li>
<li><a href='#T1'><p>Interactive Tucker1 analysis</p></a></li>
<li><a href='#T1runsFit'><p>Tucker1 solutions</p></a></li>
<li><a href='#T2'><p>Interactive Tucker2 analysis</p></a></li>
<li><a href='#T2func'><p>Algorithm for the Tucker2 model</p></a></li>
<li><a href='#T2funcrep'><p>Algorithm for the Tucker2 model</p></a></li>
<li><a href='#T2runsApproxFit'><p>Approximated Tucker2 solutions</p></a></li>
<li><a href='#T3'><p>Interactive Tucker3 analysis</p></a></li>
<li><a href='#T3dimensionalityplot'><p>Plot fit of Tucker3</p></a></li>
<li><a href='#T3fitpartitioning'><p>Fit of each entity per mode</p></a></li>
<li><a href='#T3func'><p>Algorithm for the Tucker3 model</p></a></li>
<li><a href='#T3funcrep'><p>Algorithm for the Tucker3 model</p></a></li>
<li><a href='#T3runsApproxFit'><p>Approximated Tucker3 solutions</p></a></li>
<li><a href='#threewayanova'><p>Three-way ANOVA</p></a></li>
<li><a href='#tr'><p>Trace</p></a></li>
<li><a href='#TV'><p>TV data</p></a></li>
<li><a href='#varim'><p>Varimax roation</p></a></li>
<li><a href='#varimcoco'><p>Varimax Rotation for Tucker3 and Tucker2</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Three-Way Component Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-09-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria Antonietta Del Ferraro, Henk A.L. Kiers, Paolo Giordani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paolo Giordani &lt;paolo.giordani@uniroma1.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Component analysis for three-way data arrays by means of Candecomp/Parafac, Tucker3, Tucker2 and Tucker1 models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.8.1), base, stats, graphics, grDevices</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-07 06:41:51 UTC; Win8</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-07 10:22:29</td>
</tr>
</table>
<hr>
<h2 id='bootstrapCP'>Bootstrap percentile intervals for CANDECOMP/PARAFAC</h2><span id='topic+bootstrapCP'></span>

<h3>Description</h3>

<p>Produces percentile intervals for all output parameters. The percentile intervals indicate the instability of the sample solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 bootstrapCP(X, A, B, C, n, m, p, r, ort1, ort2, ort3, conv, centopt, normopt, 
  scaleopt, maxit, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapCP_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_a">A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_b">B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_c">C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities of <code>X</code></p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities of <code>X</code></p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities of <code>X</code></p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_r">r</code></td>
<td>
<p>Number of extracted components</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_ort1">ort1</code></td>
<td>
<p>Type of constraints on <code>A</code> (see <code><a href="#topic+CP">CP</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_ort2">ort2</code></td>
<td>
<p>Type of constraints on <code>B</code> (see <code><a href="#topic+CP">CP</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_ort3">ort3</code></td>
<td>
<p>Type of constraints on <code>C</code> (see <code><a href="#topic+CP">CP</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_centopt">centopt</code></td>
<td>
<p>Centering option (see <code><a href="#topic+cent3">cent3</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_normopt">normopt</code></td>
<td>
<p>Normalization option (see <code><a href="#topic+norm3">norm3</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_scaleopt">scaleopt</code></td>
<td>
<p>Scaling option (see <code><a href="#topic+renormsolCP">renormsolCP</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_maxit">maxit</code></td>
<td>
<p>Maximal number of iterations</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="bootstrapCP_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>Bint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>B</code></p>
</td></tr>
<tr><td><code>Cint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>C</code></p>
</td></tr>
<tr><td><code>fpint</code></td>
<td>
<p>Bootstrap percentile interval for the goodness of fit index expressed as a percentage</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The preprocessing must be done in same way as for sample analysis. 
<br /> The resampling mode must be the <code>A</code>-mode. 
<br /> The starting points for every bootstrap solution are two: rational (using SVD) and solution from the observed sample.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2004). Bootstrap confidence intervals for three-way methods. <em>Journal of Chemometrics 18:22&ndash;36</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrapT3">bootstrapT3</a></code>, <code><a href="#topic+CP">CP</a></code>, <code><a href="#topic+percentile95">percentile95</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
labSCALE=TV[[2]]
labPROGRAM=TV[[3]]
labSTUDENT=TV[[4]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
# CP solution
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 1, 1, 1, 0, 1e-6, 10000)
## Not run: 
# Bootstrap analysis on CP solution
boot &lt;- bootstrapCP(TVdata, TVcp$A, TVcp$B, TVcp$C, 30, 16, 15, 2, 1, 1, 1, 
 1e-6, 0, 0, 0, 10000, labSTUDENT, labSCALE, labPROGRAM)
# Bootstrap analysis on CP solution (when labels are not available)
boot &lt;- bootstrapCP(TVdata, TVcp$A, TVcp$B, TVcp$C, 30, 16, 15, 2, 1, 1, 1, 
 1e-6, 0, 0, 0, 10000)

## End(Not run)
</code></pre>

<hr>
<h2 id='bootstrapT3'>Bootstrap percentile intervals for Tucker3</h2><span id='topic+bootstrapT3'></span>

<h3>Description</h3>

<p>Produces percentile intervals for all output parameters. The percentile intervals indicate the instability of the sample solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> bootstrapT3(X, A, B, C, G, n, m, p, r1, r2, r3, conv, centopt, normopt, 
  optimalmatch, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapT3_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_a">A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_b">B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_c">C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_g">G</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities of <code>X</code></p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities of <code>X</code></p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities of <code>X</code></p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_r1">r1</code></td>
<td>
<p>Number of extracted components for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_r2">r2</code></td>
<td>
<p>Number of extracted components for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_r3">r3</code></td>
<td>
<p>Number of extracted components for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_centopt">centopt</code></td>
<td>
<p>Centering option (see <code><a href="#topic+cent3">cent3</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_normopt">normopt</code></td>
<td>
<p>Normalization option (see <code><a href="#topic+norm3">norm3</a></code>)</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_optimalmatch">optimalmatch</code></td>
<td>
<p>Binary indicator (0 if the procedure uses matching via orthogonal rotation towards full solutions, 1 if the procedure uses matching via optimal transformation towards full solutions)</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="bootstrapT3_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>Bint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>B</code></p>
</td></tr>
<tr><td><code>Cint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>C</code></p>
</td></tr>
<tr><td><code>Gint</code></td>
<td>
<p>Bootstrap percentile interval of matricized core array (frontal slices) <code>G</code></p>
</td></tr>
<tr><td><code>fpint</code></td>
<td>
<p>Bootstrap percentile interval for the goodness of fit index expressed as a percentage</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The preprocessing must be done in same way as for sample analysis. 
<br /> The resampling mode must be the <code>A</code>-mode. 
<br /> The starting points for every bootstrap solution are two: rational (using SVD) and solution from the observed sample.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2004). Bootstrap confidence intervals for three-way methods. <em>Journal of Chemometrics 18:22&ndash;36</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrapCP">bootstrapCP</a></code>, <code><a href="#topic+percentile95">percentile95</a></code>, <code><a href="#topic+T3">T3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5],1,1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)],3,8)
# T3 solution
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 0, 1e-6)
## Not run: 
# Bootstrap analysis on T3 solution using matching via optimal transformation
boot &lt;- bootstrapT3(Bus, BusT3$A, BusT3$B, BusT3$C, BusT3$H, 7, 5, 37, 2, 2, 2, 
 1e-6, 0, 0, 1, laba, labb, labc)
# Bootstrap analysis on T3 solution using matching via orthogonal rotation 
# (when labels are not available)
boot &lt;- bootstrapT3(Bus, BusT3$A, BusT3$B, BusT3$C, BusT3$H, 7, 5, 37, 2, 2, 2, 
 1e-6, 0, 0, 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='Bus'>Bus data</h2><span id='topic+Bus'></span>

<h3>Description</h3>

<p>Three-way data about the process of learning to read of seven first-grade children tested weekly (from week 3 to 47, but weeks 10, 19, 20, 29, 35, 36, 39, 43 were holidays and, thus, data on 37 weeks) with five different tests. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Bus)</code></pre>


<h3>Format</h3>

<p>A matrix with 7 rows and 185 (5x37) columns.
<br /> The rows refer to the pupils.
<br /> The columns refer to the combinations of tests and weeks with the tests nested within the weeks.
<br /> The matrix contains the frontal slices next to each other of the original array. 
<br /> The meanings and the ranges of the tests are as follows:
<br /> <code>L</code>: letter knowledge test (scores in 0-47);
<br /> <code>P</code>: regular orthographic short words (scores in 0-10); 
<br /> <code>Q</code>: regular orthographic long words (scores in 0-10);
<br /> <code>S</code>: regular orthographic long and short words within context (scores in 0-15);
<br /> <code>R</code>: irregular orthographic long and short words (scores in 0-15).
</p>


<h3>Details</h3>

<p>In the literature the Bus data have been analyzed by Tucker3 (see Kroonenberg, 1983; Timmerman, 2001).
There is consensus on normalizing the data so to eliminate artificial differences among ranges of tests.
Different centering options and numbers of extracted components have been chosen. 
Specifically, Kroonenberg (1983) suggests averaging over pupils and tests for each time occasions and extracting two components for every mode.
Timmerman (2001) suggests to apply Tucker3 to the normalized data with two components for pupils and time occasions and one component for tests.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>P.M. Kroonenberg (1983). <em>Three-mode Principal Component Analysis. Theory and Applications</em>. DSWO Press, Leiden.
<br /> M.E. Timmerman (2001). <em>Component Analysis of Multisubject Multivariate Longitudinal Data</em>. Ph.D. Thesis, University of Groningen.</p>

<hr>
<h2 id='Cc'>Columnwise centering of a matrix</h2><span id='topic+Cc'></span>

<h3>Description</h3>

<p>Computation of a columnwise centered version of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Cc(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cc_+3A_a">A</code></td>
<td>
<p>Matrix of any order</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Ac</code></td>
<td>
<p>Matrix columnwise centered</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nrm2">nrm2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- Cc(X)
apply(Y,2,mean)
</code></pre>

<hr>
<h2 id='ccmat'>Columns concatenation</h2><span id='topic+ccmat'></span>

<h3>Description</h3>

<p>Concatenates the columns of two matrices next to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ccmat(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccmat_+3A_a">A</code></td>
<td>
<p>Matrix of the same order of <code>B</code></p>
</td></tr>
<tr><td><code id="ccmat_+3A_b">B</code></td>
<td>
<p>Matrix of the same order of <code>A</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mat</code></td>
<td>
<p>Matrix in which the columns of <code>A</code> and <code>B</code> are concatenated next to each other</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- matrix(rnorm(6*3),ncol=3)
Z &lt;- ccmat(X,Y)
</code></pre>

<hr>
<h2 id='cent3'>Centering of a matricized array</h2><span id='topic+cent3'></span>

<h3>Description</h3>

<p>Centering of a matricized array across one mode (modes indicated by 1,2, or 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cent3(X, n, m, p, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cent3_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="cent3_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="cent3_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="cent3_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="cent3_+3A_mode">mode</code></td>
<td>
<p>Centering option (1 if <code>X</code> is centered across <code>A</code>-mode, 2 if <code>X</code> is centered across <code>B</code>-mode, 3 if <code>X</code> is centered across <code>C</code>-mode)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>
<p>Matrix of order (<code>n</code> <code>x</code> <code>mp</code>) containing the centered matricized array (frontal slices)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cc">Cc</a></code>, <code><a href="#topic+norm3">norm3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- array(c(rnorm(120)),c(6,5,4))
# matricized array
Y &lt;- supermat(X)
# data centered across A-mode
Z &lt;- cent3(Y$Xa, 6, 5, 4, 1)
apply(Z,2,mean)
# data centered also across B-modes (double centering)
Z &lt;- cent3(Z, 6, 5, 4, 2)
apply(Z,1,mean)
apply(Z,2,mean)
</code></pre>

<hr>
<h2 id='CP'>Interactive Candecomp/Parafac analysis</h2><span id='topic+CP'></span>

<h3>Description</h3>

<p>Detects the underlying structure of a three-way array according to the Candecomp/Parafac (CP) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> CP(data,laba,labb,labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CP_+3A_data">data</code></td>
<td>
<p>Array of order <code>n</code> by <code>m</code> by <code>p</code> or matrix or data.frame of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="CP_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="CP_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="CP_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Fit value expressed as a percentage</p>
</td></tr> 
<tr><td><code>tripcos</code></td>
<td>
<p>Matrix of the triple cosines among pairs of components (to inspect degeneracy)</p>
</td></tr>
<tr><td><code>fitValues</code></td>
<td>
<p>Fit values expressed as a percentage upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+CPfunc">CPfunc</a></code>)</p>
</td></tr>
<tr><td><code>funcValues</code></td>
<td>
<p>Function values upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+CPfunc">CPfunc</a></code>)</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation times for all the runs of the CP algorithm (see <code><a href="#topic+CPfunc">CPfunc</a></code>)</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Numbers of iterations upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+CPfunc">CPfunc</a></code>)</p>
</td></tr>
<tr><td><code>fitA</code></td>
<td>
<p>Fit contributions for the <code>A</code>-mode entities (see <code><a href="#topic+CPfitpartitioning">CPfitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitB</code></td>
<td>
<p>Fit contributions for the <code>B</code>-mode entities (see <code><a href="#topic+CPfitpartitioning">CPfitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitC</code></td>
<td>
<p>Fit contributions for the <code>C</code>-mode entities (see <code><a href="#topic+CPfitpartitioning">CPfitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>Bint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>B</code> (see <code><a href="#topic+bootstrapCP">bootstrapCP</a></code>)</p>
</td></tr>
<tr><td><code>Cint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>C</code> (see <code><a href="#topic+bootstrapCP">bootstrapCP</a></code>)</p>
</td></tr>
<tr><td><code>fpint</code></td>
<td>
<p>Bootstrap percentile interval for the goodness of fit index expressed as a percentage (see <code><a href="#topic+bootstrapCP">bootstrapCP</a></code>)</p>
</td></tr>
<tr><td><code>Afull</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (full data) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>As1</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.1) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>As2</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.2) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>Bfull</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (full data) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>Bs1</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.1) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>Bs2</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.2) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>Cfull</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (full data) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>Cs1</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.1) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>Cs2</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.2) from split-half analysis (see <code><a href="#topic+splithalfCP">splithalfCP</a></code>)</p>
</td></tr>
<tr><td><code>A1</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>B1</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>C1</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>A2</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>B2</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>C2</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>laba</code></td>
<td>
<p>Vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code>labb</code></td>
<td>
<p>Vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code>labc</code></td>
<td>
<p>Vector of length <code>P</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code>Xprep</code></td>
<td>
<p>Matrix of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices) after preprocessing used for the analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>J.D. Carroll and J.J. Chang (1970). Analysis of individual differences in multidimensional scaling via an <em>N</em>-way generalization of 'Eckart-Young' decomposition. <em>Psychometrika 35:283&ndash;319</em>. 
<br /> P. Giordani, H.A.L. Kiers, M.A. Del Ferraro (2014). Three-way component analysis using the R package ThreeWay. <em>Journal of Statistical Software 57(7):1&ndash;23</em>. <a href="http://www.jstatsoft.org/v57/i07/">http://www.jstatsoft.org/v57/i07/</a>.
<br /> R.A. Harshman (1970). Foundations of the Parafac procedure: models and conditions for an 'explanatory' multi-mode factor analysis. <em>UCLA Working Papers in Phonetics 16:1&ndash;84</em>.
<br /> P.M. Kroonenberg (2008). <em>Applied Multiway Data Analysis</em>. Wiley, New Jersey.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3">T3</a></code>, <code><a href="#topic+T2">T2</a></code>, <code><a href="#topic+T1">T1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
labSCALE=TV[[2]]
labPROGRAM=TV[[3]]
labSTUDENT=TV[[4]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
## Not run: 
# interactive CP analysis
TVcp &lt;- CP(TVdata, labSTUDENT, labSCALE, labPROGRAM)
# interactive CP analysis (when labels are not available)
TVcp &lt;- CP(TVdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='CPdimensionalityplot'>Plot fit of Candecomp/Parafac</h2><span id='topic+CPdimensionalityplot'></span>

<h3>Description</h3>

<p>Plots fits against numbers of dimensions, with <code>S</code> as labels and fits against number of effective paramaters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPdimensionalityplot(A, n, m, p)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPdimensionalityplot_+3A_a">A</code></td>
<td>
<p>A matrix with columns: number of components, goodness of fit (%)</p>
</td></tr>
<tr><td><code id="CPdimensionalityplot_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPdimensionalityplot_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPdimensionalityplot_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>A</code> is usually the first and fourth columns of the output of <code><a href="#topic+DimSelector">DimSelector</a></code>.
<br /> The number of effective parameters  in a Candecomp/Parafac analysis is discussed in Weesie and Van Houwelingen (1983).
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>E. Ceulemans \&amp; H.A.L. Kiers (2006). Selecting among three-mode principal component models of different types and complexities: A numerical convex hull based method. <em>British Journal of Mathematical and Statistical Psychology 59:133&ndash;150</em>. 
<br /> J. Weesie \&amp; H. Van Houwelingen (1983). <em>GEPCAM users' manual (first draft)</em>. Utrecht, The Netherlands: Institute of Mathematical Statistics, State University of Utrecht.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code>, <code><a href="#topic+DimSelector">DimSelector</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
# Fit values of CP with different numbers of components (from 1 to 5)
FitCP &lt;- CPrunsFit(TVdata, 30, 16, 15, 5)
OutCP &lt;- FitCP[,c(1,4)]
CPdimensionalityplot(OutCP, 30, 16, 15)
</code></pre>

<hr>
<h2 id='CPfitpartitioning'>Fit of each entity per mode</h2><span id='topic+CPfitpartitioning'></span>

<h3>Description</h3>

<p>Computation of fit contributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> CPfitpartitioning(Xprep, n, m, p, A, B, C, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPfitpartitioning_+3A_xprep">Xprep</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_a">A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_b">B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_c">C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfitpartitioning_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>fitA</code></td>
<td>
<p>Fit contribution for the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code>fitB</code></td>
<td>
<p>Fit contribution for the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code>fitC</code></td>
<td>
<p>Fit contribution for the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
labSCALE=TV[[2]]
labPROGRAM=TV[[3]]
labSTUDENT=TV[[4]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
# CP solution
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 1, 1, 1, 0, 1e-6, 10000)
# Fitpartitioning of the CP solution
FitCP &lt;-  CPfitpartitioning(TVdata, 30, 16, 15, TVcp$A, TVcp$B, TVcp$C, 
 labSTUDENT, labSCALE, labPROGRAM)
# Fitpartitioning of the CP solution (when labels are not available)
FitCP &lt;-  CPfitpartitioning(TVdata, 30, 16, 15, TVcp$A, TVcp$B, TVcp$C)
</code></pre>

<hr>
<h2 id='CPfunc'>Algorithm for the Candecomp/Parafac (CP) model</h2><span id='topic+CPfunc'></span>

<h3>Description</h3>

<p>Alternating Least Squares algorithm for the minimization of the Candecomp/Parafac loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> CPfunc(X, n, m, p, r, ort1, ort2, ort3, start, conv, maxit, A, B, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPfunc_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <em>x</em> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_r">r</code></td>
<td>
<p>Number of extracted components</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_ort1">ort1</code></td>
<td>
<p>Type of constraints on <code>A</code> (1 for no constraints, 2 for orthogonality constraints, 3 for zero correlations constraints)</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_ort2">ort2</code></td>
<td>
<p>Type of constraints on <code>B</code> (1 for no constraints, 2 for orthogonality constraints, 3 for zero correlations constraints)</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_ort3">ort3</code></td>
<td>
<p>Type of constraints on <code>C</code> (1 for no constraints, 2 for orthogonality constraints, 3 for zero correlations constraints)</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_start">start</code></td>
<td>
<p>Starting point (0 for starting point of the algorithm from SVD's, 1 for random starting point (orthonormalized component matrices), 2 for user specified components</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_maxit">maxit</code></td>
<td>
<p>Maximal number of iterations</p>
</td></tr>
<tr><td><code id="CPfunc_+3A_a">A</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>A</code></p>
</td></tr>
<tr><td><code id="CPfunc_+3A_b">B</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>B</code></p>
</td></tr>
<tr><td><code id="CPfunc_+3A_c">C</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>C</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Loss function value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit value expressed as a percentage</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>tripcos</code></td>
<td>
<p>Minimal triple cosine between two components across three component matrices (to inspect degeneracy)</p>
</td></tr>
<tr><td><code>mintripcos</code></td>
<td>
<p>Minimal triple cosine during the iterative algorithm observed at every 10 iterations (to inspect degeneracy)</p>
</td></tr>
<tr><td><code>ftiter</code></td>
<td>
<p>Matrix containing in each row the function value and the minimal triple cosine at every 10 iterations</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation time</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The loss function to be minimized is <code class="reqn">sum(k)|| X(k) - A D(k) B' ||^2</code>, where <code class="reqn">D(k)</code> is a diagonal matrix holding the <code>k</code>-th row of <code>C</code>.
<br /> <code>CPfunc</code> is the same as <code>CPfuncrep</code> except that all printings are available.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>R.A. Harshman (1970). Foundations of the Parafac procedure: models and conditions for an &lsquo;explanatory&rsquo; multi-mode factor analysis. <em>UCLA Working Papers in Phonetics 16:1&ndash;84</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code>, <code><a href="#topic+CPfuncrep">CPfuncrep</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
# unconstrained CP solution using two components 
# (rational starting point by SVD [start=0])
TVcp &lt;- CPfunc(TVdata, 30, 16, 15, 2, 1, 1, 1, 0, 1e-6, 10000)
# constrained CP solution using two components with orthogonal A-mode 
# component matrix (rational starting point by SVD [start=0])
TVcp &lt;- CPfunc(TVdata, 30, 16, 15, 2, 2, 1, 1, 0, 1e-6, 10000)
# constrained CP solution using two components with orthogonal A-mode 
# component matrix and zero correlated C-mode component matrix 
# (rational starting point by SVD [start=0])
TVcp &lt;- CPfunc(TVdata, 30, 16, 15, 2, 2, 1, 3, 0, 1e-6, 10000)
# unconstrained CP solution using two components 
# (random orthonormalized starting point [start=1])
TVcp &lt;- CPfunc(TVdata, 30, 16, 15, 2, 1, 1, 1, 1, 1e-6, 10000)
# unconstrained CP solution using two components (user starting point [start=2])
TVcp &lt;- CPfunc(TVdata, 30, 16, 15, 2, 1, 1, 1, 2, 1e-6, 10000, 
 matrix(rnorm(30*2),nrow=30), matrix(rnorm(16*2),nrow=16), 
 matrix(rnorm(15*2),nrow=15))
</code></pre>

<hr>
<h2 id='CPfuncrep'>Algorithm for the Candecomp/Parafac (CP) model</h2><span id='topic+CPfuncrep'></span>

<h3>Description</h3>

<p>Alternating Least Squares algorithm for the minimization of the Candecomp/Parafac loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> CPfuncrep(X, n, m, p, r, ort1, ort2, ort3, start, conv, maxit, A, B, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPfuncrep_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_r">r</code></td>
<td>
<p>Number of extracted components</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_ort1">ort1</code></td>
<td>
<p>Type of constraints on <code>A</code> (1 for no constraints, 2 for orthogonality constraints, 3 for zero correlations constraints)</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_ort2">ort2</code></td>
<td>
<p>Type of constraints on <code>B</code> (1 for no constraints, 2 for orthogonality constraints, 3 for zero correlations constraints)</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_ort3">ort3</code></td>
<td>
<p>Type of constraints on <code>C</code> (1 for no constraints, 2 for orthogonality constraints, 3 for zero correlations constraints)</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_start">start</code></td>
<td>
<p>Starting point (0 for starting point of the algorithm from SVD's, 1 for random starting point (orthonormalized component matrices), 2 for user specified components</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_maxit">maxit</code></td>
<td>
<p>Maximal number of iterations</p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_a">A</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>A</code></p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_b">B</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>B</code></p>
</td></tr>
<tr><td><code id="CPfuncrep_+3A_c">C</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>C</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Loss function value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit value expressed as a percentage</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>tripcos</code></td>
<td>
<p>Minimal triple cosine between two components across three component matrices (to inspect degeneracy)</p>
</td></tr>
<tr><td><code>mintripcos</code></td>
<td>
<p>Minimal triple cosine during the iterative algorithm observed at every 10 iterations (to inspect degeneracy)</p>
</td></tr>
<tr><td><code>ftiter</code></td>
<td>
<p>Matrix containing in each row the function value and the minimal triple cosine at every 10 iterations</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation time</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The loss function to be minimized is <code class="reqn">sum(k)|| X(k) - A D(k) B' ||^2</code>, where <code class="reqn">D(k)</code> is a diagonal matrix holding the <code>k</code>-th row of <code>C</code>.
<br /> <code>CPfuncrep</code> is the same as <code>CPfunc</code> except that all printings are suppressed. Thus, <code>CPfuncrep</code> can be helpful for simulation experiments.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>R.A. Harshman (1970). Foundations of the Parafac procedure: models and conditions for an &lsquo;explanatory&rsquo; multi-mode factor analysis. <em>UCLA Working Papers in Phonetics 16:1&ndash;84</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code>, <code><a href="#topic+CPfunc">CPfunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
# unconstrained CP solution using two components 
# (rational starting point by SVD [start=0])
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 1, 1, 1, 0, 1e-6, 10000)
# constrained CP solution using two components with orthogonal A-mode  
# component matrix (rational starting point by SVD [start=0])
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 2, 1, 1, 0, 1e-6, 10000)
# constrained CP solution using two components with orthogonal A-mode 
# component matrix and zero correlated C-mode component matrix 
# (rational starting point by SVD [start=0])
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 2, 1, 3, 0, 1e-6, 10000)
# unconstrained CP solution using two components 
# (random orthonormalized starting point [start=1])
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 1, 1, 1, 1, 1e-6, 10000)
# unconstrained CP solution using two components (user starting point [start=2])
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 1, 1, 1, 2, 1e-6, 10000, 
 matrix(rnorm(30*2),nrow=30), matrix(rnorm(16*2),nrow=16), 
 matrix(rnorm(15*2),nrow=15))
</code></pre>

<hr>
<h2 id='CPrunsFit'>Candecomp/Parafac solutions</h2><span id='topic+CPrunsFit'></span>

<h3>Description</h3>

<p>Computes all the Candecomp/Parafac solutions (CP) with <code>r</code> (from 1 to <code>maxC</code>) components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	CPrunsFit(X, n, m, p, maxC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CPrunsFit_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="CPrunsFit_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPrunsFit_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPrunsFit_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="CPrunsFit_+3A_maxc">maxC</code></td>
<td>
<p>Maximum dimensionality for the <code>A</code>-mode</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>Matrix with columns: number of components for the <code>A</code>-mode, number of components for the <code>B</code>-mode, number of components for the <code>C</code>-mode, goodness of fit (%), total number of components
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The structure of <code>out</code> is consistent with Tucker models. In CP, the first and forth columns are sufficient for choosing the optimal number of components.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56:449&ndash;470</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimSelector">DimSelector</a></code>, <code><a href="#topic+LineCon">LineCon</a></code>, <code><a href="#topic+CP">CP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
# Fit values of CP with different numbers of components (from 1 to 5)
FitCP &lt;- CPrunsFit(TVdata, 30, 16, 15, 5)
</code></pre>

<hr>
<h2 id='DimSelector'>Convex Hull procedure</h2><span id='topic+DimSelector'></span>

<h3>Description</h3>

<p>Selects among three-mode principal component models of different complexities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> DimSelector(out, n, m, p, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DimSelector_+3A_out">out</code></td>
<td>
<p>Matrix with columns: number of components for the <code>A</code>-mode, number of components for the <code>B</code>-mode, number of components for the <code>C</code>-mode, goodness of fit (%), total number of components</p>
</td></tr>
<tr><td><code id="DimSelector_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="DimSelector_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="DimSelector_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="DimSelector_+3A_model">model</code></td>
<td>
<p>Kind of model (1 for Candecomp/Parafac, 2 for Tucke3, 3 for Tucker2, 4 for Tucker1</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p> E. Ceulemans and H.A.L. Kiers (2006). Selecting among three-mode principal component models of different types and complexities: A numerical convex hull based method. <em>British Journal of Mathematical and Statistical Psychology 59:133&ndash;150</em>. 
<br /> J. Weesie and H. Van Houwelingen (1983). <em>GEPCAM users' manual (first draft)</em>. Utrecht, The Netherlands: Institute of Mathematical Statistics, State University of Utrecht.</p>


<h3>See Also</h3>

<p><code><a href="#topic+LineCon">LineCon</a></code>, <code><a href="#topic+T3runsApproxFit">T3runsApproxFit</a></code> <code><a href="#topic+T2runsApproxFit">T2runsApproxFit</a></code> <code><a href="#topic+T1runsFit">T1runsFit</a></code> <code><a href="#topic+CPrunsFit">CPrunsFit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# Analysis on T3 with different numbers of components (from 1 to 4 for the A-mode,
# from 1 to 3 for the B-mode, from 1 to 5 for the C-mode)
FitT3 &lt;- T3runsApproxFit(Bus,7,5,37,4,4,4)
T3opt &lt;- DimSelector(FitT3,7,5,37,2)
</code></pre>

<hr>
<h2 id='jointplotgen'>Jointplots</h2><span id='topic+jointplotgen'></span>

<h3>Description</h3>

<p>Program for producing jointplots in general.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> jointplotgen(K, A, B, C, fixmode, fixunit, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointplotgen_+3A_k">K</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_a">A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_b">B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_c">C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_fixmode">fixmode</code></td>
<td>
<p>Mode for which one unit is to be chosen (1 for A-mode, 2 for B-mode, 3 for C-mode)</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_fixunit">fixunit</code></td>
<td>
<p>Number of component for which joint plot is desired</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_laba">laba</code></td>
<td>
<p>Vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_labb">labb</code></td>
<td>
<p>Vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="jointplotgen_+3A_labc">labc</code></td>
<td>
<p>Vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>fit</code></td>
<td>
<p>Percentage of info for component at hand, explained by two-dimensional plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>P.M. Kroonenberg (2008). <em>Applied Multiway Data Analysis</em>. Wiley, New Jersey.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
# &lt;- T3 solution
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 0, 1e-6)
# Joint plot for mode C and component 2
jointplotgen(BusT3$H, BusT3$A, BusT3$B, BusT3$C, 3, 2, laba, labb, labc)
</code></pre>

<hr>
<h2 id='Kinship'>Kinship terms data</h2><span id='topic+Kinship'></span>

<h3>Description</h3>

<p>Three-way proximity data about 15 kinship terms produced by 6 groups of subjects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Kinship)</code></pre>


<h3>Format</h3>

<p>An array of order 15 x 15 x 6.
<br /> The A-mode and B-mode entities are the kinship terms (Aunt, Brother, Cousin, Daughter, Father, Granddaughter, Grandfather, Grandmother, Grandson, Mother, Nephew, Niece, Sister, Son, Uncle).
<br /> The C-mode entities are groups of subjects (First female, Second female, First male, Second male, Single female, Single male).
</p>


<h3>Details</h3>

<p>The original data have been introduced by Rosenborg \&amp; Kim (1975).
The data were collected by asking to 6 groups of subjects to produce a partition of 15 kinship terms.
Two groups (Single female and Single male) were composed by 85 male and 85 female college students, respectively, and provided a single partition. 
Two additional groups of, respectively, 80 male and 80 female students produced two partitions each (First female, Second female, First male, Second male). 
In fact, they were informed in advance that, after making the first partition, they should give a new partition of the kinship terms using a different basis of meaning. 
The array contains similarities. For every group of subjects, the numbers of times in which the kinship terms were grouped together are given.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>S. Rosenborg \&amp; M.P. Kim (1975). The method of sorting as a data-gathering procedure in multivariate research. <em>Multivariate Behavioral Research 10:489&ndash;502</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Kinship)
## The labels are in the data array
laba &lt;- dimnames(Kinship)[[1]]
labb &lt;- dimnames(Kinship)[[2]]
labc &lt;- dimnames(Kinship)[[3]]
## Candecomp/Parafac analysis
## Not run: 
CP(Kinship,laba,labb,labc)

## End(Not run)
</code></pre>

<hr>
<h2 id='LineCon'>Middle point location</h2><span id='topic+LineCon'></span>

<h3>Description</h3>

<p>Checks whether the middle point is located below or on the line connecting its neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> LineCon(f1, f2, f3, fp1, fp2, fp3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LineCon_+3A_f1">f1</code></td>
<td>
<p>Goodness-of-fit value for the first point</p>
</td></tr>
<tr><td><code id="LineCon_+3A_f2">f2</code></td>
<td>
<p>Goodness-of-fit value for the second point</p>
</td></tr>
<tr><td><code id="LineCon_+3A_f3">f3</code></td>
<td>
<p>Goodness-of-fit value for the third point</p>
</td></tr>
<tr><td><code id="LineCon_+3A_fp1">fp1</code></td>
<td>
<p>Number of effective parameters for the first point</p>
</td></tr>
<tr><td><code id="LineCon_+3A_fp2">fp2</code></td>
<td>
<p>Number of effective parameters for the second point</p>
</td></tr>
<tr><td><code id="LineCon_+3A_fp3">fp3</code></td>
<td>
<p>Number of effective parameters for the third point</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>ret</code></td>
<td>
<p>Value that indicates if the middle point is located below or on the line connecting its neighbors (0 if the middle point is not located below the line connecting its neighbors, 1  if the middle point is not located on the line connecting its neighbors)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>E. Ceulemans and H.A.L. Kiers (2006). Selecting among three-mode principal component models of different types and complexities: A numerical convex hull based method. <em>British Journal of Mathematical and Statistical Psychology 59:133&ndash;150</em>. 
<br /> J. Weesie and H. Van Houwelingen (1983). <em>GEPCAM users' manual (first draft)</em>. Utrecht, The Netherlands: Institute of Mathematical Statistics, State University of Utrecht.</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimSelector">DimSelector</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# T2-AB with 1 component for the A- and B-mode
FitBusT2AB11 &lt;- T2funcrep(Bus, 7, 5, 37, 1, 1, 37, 0, 1e-6,1)$fp
# T2-AB with 2 components for the A-mode and 1 component for the B-mode
FitBusT2AB21 &lt;- T2funcrep(Bus, 7, 5, 37, 2, 1, 37, 0, 1e-6, 1)$fp
# T2-AB with 1 component for the A-mode and 2 components for the B-mode
# T2-AB with 1 component for the A-mode and 2 components for the B-mode
# FitBusT2AB21&gt;FitBusT2AB12
# T2-AB with 2 components for the A- and B-mode
FitBusT2AB22 &lt;- T2funcrep(Bus, 7, 5, 37, 2, 2, 37, 0, 1e-6,1)$fp
# number of effective parameters n x r1 + m x r2 + r1 x r2 x p - r1^2 - r2^2
nepT2AB11 &lt;- 47
nepT2AB21 &lt;- 88
nepT2AB22 &lt;- 164
ret &lt;- LineCon(FitBusT2AB11, FitBusT2AB21, FitBusT2AB22, nepT2AB11, nepT2AB21, nepT2AB22)
</code></pre>

<hr>
<h2 id='meaudret'> Meaudret data</h2><span id='topic+meaudret'></span>

<h3>Description</h3>

<p>Three-way data about six sampling sites along a small French stream (the Meaudret) on which ten biological and chemical variables are collected four times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meaudret)</code></pre>


<h3>Format</h3>

<p>An array of order 6 x 10 x 4.
<br /> The A-mode entities are sampling sites (Site1, ..., Site6).
<br /> The B-mode entities are biological and chemical variables (Temp, Debi, PH, Cond, Oxyg, Biod, Chem, NH4, NO3, PO4).
<br /> The C-mode entities are months (June, August, November, February).
</p>


<h3>Details</h3>

<p>The ranges of the variables are very different and, therefore, normalization of the raw data is recommended.
The data have been used by Kiers (1991) in order to show the existing relations among three-way methods.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56:449&ndash;470</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meaudret)
## The labels are in the data array
laba &lt;- dimnames(meaudret)[[1]]
labb &lt;- dimnames(meaudret)[[2]]
labc &lt;- dimnames(meaudret)[[3]]
## Candecomp/Parafac analysis
## Not run: 
CP(meaudret,laba,labb,labc)
## Tucker3 analysis
T3(meaudret,laba,labb,labc)
## Tucker2 analysis
T2(meaudret,laba,labb,labc)
## Tucker1 analysis
T1(meaudret,laba,labb,labc)

## End(Not run)
</code></pre>

<hr>
<h2 id='norm3'>Normalization of a matricized array</h2><span id='topic+norm3'></span>

<h3>Description</h3>

<p>Normalization of a matricized array within one mode (modes indicated by 1,2, or 3) to sum of squares equal to product of size of other modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> norm3(X, n, m, p, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm3_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="norm3_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="norm3_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="norm3_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="norm3_+3A_mode">mode</code></td>
<td>
<p>Normalization option (1 if <code>X</code> is normalized within <code>A</code>-mode, 2 if <code>X</code> is normalized within <code>B</code>-mode, 3 if <code>X</code> is normalized within <code>C</code>-mode)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>
<p>Matrix of order (<code>n</code> <code>x</code> <code>mp</code>) containing the normalized matricized array (frontal slices)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+cent3">cent3</a></code>, <code><a href="#topic+nrm2">nrm2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- array(c(rnorm(120)), c(6,5,4))
# matricized array
Y &lt;- supermat(X)
# data normalized within A-mode
Z &lt;- norm3(Y$Xa, 6, 5, 4, 1)
apply(Z^2,1,sum)
# data normalized within C-mode
Z &lt;- norm3(Y$Xa, 6, 5, 4, 3)
Z &lt;- permnew(Z, 6, 5, 4)
Z &lt;- permnew(Z, 5, 4, 6)
apply(Z^2, 1, sum)
</code></pre>

<hr>
<h2 id='normvari'>Normalized varimax rotation</h2><span id='topic+normvari'></span>

<h3>Description</h3>

<p>Produces normalized varimax rotated version of <code>A</code> and rotation matrix <code>T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> normvari(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normvari_+3A_a">A</code></td>
<td>
<p>Matrix to be to be rotated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>Rotated version of <code>A</code> (<code>B=AT</code>)</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Rotation matrix</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Varimax function value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H. Kaiser (1958). The varimax criterion for analytic rotation in factor analysis. <em>Psychometrika 23:187&ndash;200</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+varim">varim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- normvari(X)
# normalized varimax rotated version of X
Y$B
# rotation matrix
Y$T
</code></pre>

<hr>
<h2 id='nrm2'> Columnwise normalization of a matrix</h2><span id='topic+nrm2'></span>

<h3>Description</h3>

<p>Computation of a columnwise normalized version of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nrm2(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrm2_+3A_a">A</code></td>
<td>
<p>Matrix of any order</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>N</code></td>
<td>
<p>Matrix columnwise normalized</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Cc">Cc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- nrm2(X)
apply(Y^2, 2, sum)
</code></pre>

<hr>
<h2 id='ord'>Order</h2><span id='topic+ord'></span>

<h3>Description</h3>

<p>In case of vectors, an ordering of its elements in ascending order is produced; in case of matrices, the ordering in ascending order refers to every column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ord(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ord_+3A_x">X</code></td>
<td>
<p>Vector or matrix to be ordered</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>Vector or matrix with the elements sorted in ascending order</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>Vector or matrix with the ordering indices</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># vector
x &lt;- rnorm(6)
y &lt;- ord(x)
# matrix
X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- ord(X)
</code></pre>

<hr>
<h2 id='orth'>Orthonormalization of a matrix</h2><span id='topic+orth'></span>

<h3>Description</h3>

<p>Returns an orthonormal basis for the range of <code>A</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> orth(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orth_+3A_a">A</code></td>
<td>
<p>Matrix to be orthogonalized</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Q</code></td>
<td>
<p>Orthonormal basis for the range of <code>A</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The columns of <code>Q</code> span the same space as the columns of <code>A</code> with <code>t(Q)Q=I</code>. 
<br /> The number of columns of <code>Q</code> is the rank of <code>A</code>.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- orth(X)
</code></pre>

<hr>
<h2 id='orthmax2'>Orthomax Rotation</h2><span id='topic+orthmax2'></span>

<h3>Description</h3>

<p>Produces a simultaneous orthomax rotation of two matrices (using one rotation matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> orthmax2(A1, A2, gam1, gam2, conv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthmax2_+3A_a1">A1</code></td>
<td>
<p>First matrix to be rotated with the same number of columns of A2</p>
</td></tr>
<tr><td><code id="orthmax2_+3A_a2">A2</code></td>
<td>
<p>Second matrix to be rotated with the same number of columns of A1</p>
</td></tr>
<tr><td><code id="orthmax2_+3A_gam1">gam1</code></td>
<td>
<p>orthmax parameter for <code>A1</code></p>
</td></tr> 
<tr><td><code id="orthmax2_+3A_gam2">gam2</code></td>
<td>
<p>orthmax parameter for <code>A2</code></p>
</td></tr>
<tr><td><code id="orthmax2_+3A_conv">conv</code></td>
<td>
<p>Optional convergence value (default 1e-6)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components: 
</p>
<table>
<tr><td><code>B1</code></td>
<td>
<p>Rotated version of <code>A1</code></p>
</td></tr> 
<tr><td><code>B2</code></td>
<td>
<p>Rotated version of <code>A2</code></p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Rotation matrix</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Orthomax function value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function to be maximized is <code class="reqn">f=sum((A1^2)-1/m1*gam1*sum((sum(A1^2))^2))^2+sum((A2^2)-1/m2*gam2*sum((sum(A2^2))^2))^2</code>.</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>R. Jennrich (1970). Orthogonal rotation algorithms. <em>Psychometrika 35:229&ndash;235</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+varim">varim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(8*3),ncol=3)
Y &lt;- matrix(rnorm(6*3),ncol=3)
orthXY &lt;- orthmax2(X,Y,1,2)
# rotated version of X
orthXY$B1
# rotated version of Y
orthXY$B2
# rotation matrix
orthXY$T
</code></pre>

<hr>
<h2 id='pcamean'>PCA of the mean matrix</h2><span id='topic+pcamean'></span>

<h3>Description</h3>

<p>Performs Principal Component Analysis (PCA) of the mean matrix aggregated over mode number indicated by <code>aggregmode</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcamean(X, n, m, p, laba, labb, labc)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcamean_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="pcamean_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcamean_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcamean_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcamean_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcamean_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcamean_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>An object of class <code>matrix</code> containing the mean matrix</p>
</td></tr>
<tr><td><code>ev</code></td>
<td>
<p>A vector containing the eigenvalues of <code>Y</code></p>
</td></tr>
<tr><td><code>A1</code></td>
<td>
<p>Component matrix for the <code>A</code> mode based on varimax rotation of loadings</p>
</td></tr>
<tr><td><code>B1</code></td>
<td>
<p>Component matrix for the <code>B</code> mode based on varimax rotation of loadings</p>
</td></tr>
<tr><td><code>C1</code></td>
<td>
<p>Component matrix for the <code>C</code> mode based on varimax rotation of loadings</p>
</td></tr>
<tr><td><code>A2</code></td>
<td>
<p>Component matrix for the <code>A</code> mode based on oblique &lsquo;HKIC&rsquo; (Harris-Kaiser Independent Cluster) orthomax rotation of loadings</p>
</td></tr>
<tr><td><code>B2</code></td>
<td>
<p>Component matrix for the <code>B</code> mode based on oblique &lsquo;HKIC&rsquo; (Harris-Kaiser Independent Cluster) orthomax rotation of loadings</p>
</td></tr>
<tr><td><code>C2</code></td>
<td>
<p>Component matrix for the <code>C</code> mode based on oblique &lsquo;HKIC&rsquo; (Harris-Kaiser Independent Cluster) orthomax rotation of loadings</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>aggregmode</code> denotes the mode over which means are computed (1 for <code>A</code>-mode, 2 for <code>B</code>-mode, 3 for <code>C</code>-mode).
<br /> <code>aggregmode</code> is provided interactively. 
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H. Kaiser (1958). The varimax criterion for analytic rotation in factor analysis. <em>Psychometrika 23:187&ndash;200</em>. 
<br /> C. Harris \&amp; H. Kaiser (1964). Some mathematical notes on three-mode factor analysis. <em>Psychometrika 29:347&ndash;362</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
labSCALE=TV[[2]]
labPROGRAM=TV[[3]]
labSTUDENT=TV[[4]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
## Not run: 
# PCA on the mean matrix
TVpcamean &lt;- pcamean(TVdata, 30, 16, 15, labSTUDENT, labSCALE, labPROGRAM)
# PCA on the mean matrix (when labels are not available)
TVpcamean &lt;- pcamean(TVdata, 30, 16, 15)

## End(Not run)
</code></pre>

<hr>
<h2 id='pcasup1'>PCASup Analysis</h2><span id='topic+pcasup1'></span>

<h3>Description</h3>

<p>Computes PCASup analysis for the direction concerning the reduced mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pcasup1(X, n, m, p, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcasup1_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="pcasup1_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup1_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup1_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup1_+3A_model">model</code></td>
<td>
<p>Tucker1 model choice (1 for T1-A, 2 for T1-B, 3 for T2-C)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the frontal slices of the array (<code>A</code>-mode)</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the horizontal slices of the array (<code>B</code>-mode)</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the lateral slices of the array (<code>C</code>-mode)</p>
</td></tr>
<tr><td><code>la</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the frontal slices of the array (<code>A</code>-mode)</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the horizontal slices of the array (<code>B</code>-mode)</p>
</td></tr>
<tr><td><code>lc</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the lateral slices of the array (<code>C</code>-mode)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>pcasup1</code> computes the Tucker1 solution.
<br /> Cumulative sum of eigenvalues and fits from PCAsup applied to the reduced mode are automatically printed.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56: 449&ndash;470</em>.
<br /> H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.
<br /> L.R Tucker (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika 31: 279&ndash;311</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T1">T1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# PCA-sup for T1-B
pcasupBus &lt;- pcasup1(Bus, 7, 5, 37, 2)
</code></pre>

<hr>
<h2 id='pcasup2'>PCASup Analysis</h2><span id='topic+pcasup2'></span>

<h3>Description</h3>

<p>Computes PCASup analysis for the directions concerning the reduced modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pcasup2(X, n, m, p, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcasup2_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="pcasup2_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup2_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup2_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup2_+3A_model">model</code></td>
<td>
<p>Tucker2 model choice (1 for T2-AB, 2 for T2-AC, 3 for T2-BC)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the frontal slices of the array (<code>A</code>-mode)</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the horizontal slices of the array (<code>B</code>-mode)</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the lateral slices of the array (<code>C</code>-mode)</p>
</td></tr>
<tr><td><code>la</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the frontal slices of the array (<code>A</code>-mode)</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the horizontal slices of the array (<code>B</code>-mode)</p>
</td></tr>
<tr><td><code>lc</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the lateral slices of the array (<code>C</code>-mode)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Cumulative sum of eigenvalues and fits from PCAsup applied to the reduced modes are automatically printed.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56: 449&ndash;470</em>.
<br /> H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.
<br /> L.R Tucker (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika 31: 279&ndash;311</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T2">T2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# PCA-sup for T2-AB
pcasupBus &lt;- pcasup2(Bus, 7, 5, 37, 1)
</code></pre>

<hr>
<h2 id='pcasup3'>PCASup Analysis</h2><span id='topic+pcasup3'></span>

<h3>Description</h3>

<p>Computes PCASup analysis in all the three directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pcasup3(X, n, m, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcasup3_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="pcasup3_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup3_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="pcasup3_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the frontal slices of the array (<code>A</code>-mode)</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the horizontal slices of the array (<code>B</code>-mode)</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Matrix of the eingenvectors of the supermatrix containing the lateral slices of the array (<code>C</code>-mode)</p>
</td></tr>
<tr><td><code>la</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the frontal slices of the array (<code>A</code>-mode)</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the horizontal slices of the array (<code>B</code>-mode)</p>
</td></tr>
<tr><td><code>lc</code></td>
<td>
<p>Vector of the eigenvalues of the supermatrix containing the lateral slices of the array (<code>C</code>-mode)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>pcasup3</code> computes the Tucker3 solution according to Tucker (1966).
<br /> Cumulative sum of eigenvalues and fits from PCAsup applied to the <code>A</code>-, <code>B</code>- and <code>C</code>-modes are automatically printed.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56: 449&ndash;470</em>.
<br /> H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.
<br /> L.R Tucker (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika 31: 279&ndash;311</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3">T3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
## Not run: 
# PCA-sup
pcasupBus &lt;- pcasup3(Bus, 7, 5, 37)

## End(Not run)
</code></pre>

<hr>
<h2 id='percentile95'>95% percentile intervals</h2><span id='topic+percentile95'></span>

<h3>Description</h3>

<p>Computes 2.5% and 97.5% percentiles for all columns of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentile95(X)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentile95_+3A_x">X</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>lo</code></td>
<td>
<p>Vector of the 2.5% percentiles of the values in the columns of <code>X</code></p>
</td></tr>
<tr><td><code>up</code></td>
<td>
<p>Vector of the 97.5% percentiles of the values in the columns of <code>X</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrapCP">bootstrapCP</a></code>,<code><a href="#topic+bootstrapT3">bootstrapT3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(50*3),ncol=3)
perc95X &lt;- percentile95(X)
</code></pre>

<hr>
<h2 id='permnew'>Permutation of a matricized array</h2><span id='topic+permnew'></span>

<h3>Description</h3>

<p>Permutes the matricized (<code>n</code> <code>x</code> <code>m</code> <code>x</code> <code>p</code>) array <code>X</code> to the matricized array <code>Y</code> of order (<code>m</code> <code>x</code> <code>p</code> <code>x</code> <code>n</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> permnew(X,n,m,p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permnew_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) containing the matricized array</p>
</td></tr>
<tr><td><code id="permnew_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities of the array <code>X</code></p>
</td></tr>
<tr><td><code id="permnew_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities of the array <code>X</code></p>
</td></tr>
<tr><td><code id="permnew_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities of the array <code>X</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>
<p>Matrix containing the permuted matricized array</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- array(c(rnorm(120)),c(6,5,4))
dim(X)
# matricized array
Xa &lt;- supermat(X)$Xa
# matricized X with the A-mode entities in its rows
dim(Xa)
# matricized X with the B-mode entities in its rows
Xb &lt;- permnew(Xa, 6, 5, 4)
dim(Xb)
# matricized X with the C-mode entities in its rows
Xc &lt;- permnew(Xb, 5, 4, 6)
dim(Xc)
</code></pre>

<hr>
<h2 id='perms'>Permutation</h2><span id='topic+perms'></span>

<h3>Description</h3>

<p>Gives all the permutations of the first integer numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> perms(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perms_+3A_n">n</code></td>
<td>
<p>Integer</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>z</code></td>
<td>
<p>Matrix containing in its rows all the permutation of the first <code>n</code> integer numbers</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2004). Bootstrap confidence intervals for three-way methods. <em>Journal of Chemometrics 18:22&ndash;36</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- perms(4)
</code></pre>

<hr>
<h2 id='phi'>Phi coefficient</h2><span id='topic+phi'></span>

<h3>Description</h3>

<p>Computes the phi coefficients among columns of two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> phi(a,b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_+3A_a">a</code></td>
<td>
<p>Vector or matrix of the same order of <code>b</code></p>
</td></tr>
<tr><td><code id="phi_+3A_b">b</code></td>
<td>
<p>Vector or matrix of the same order of <code>a</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>
<p>Matrix containing the phi coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>L.R Tucker (1951). A method for synthesis of factor analysis studies. <em>Personnel Research Section Report No. 984</em>. Department of the Army, Washington, DC.</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- matrix(rnorm(6*3),ncol=3)
P &lt;- phi(X,Y)
</code></pre>

<hr>
<h2 id='rarray'>Array reconstruction</h2><span id='topic+rarray'></span>

<h3>Description</h3>

<p>Produces an array starting from its matricization with all the frontal slices of the array next to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rarray(Xa, n, m, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rarray_+3A_xa">Xa</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) containing the elements of the frontal slices of an array</p>
</td></tr>
<tr><td><code id="rarray_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="rarray_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="rarray_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>Array leading to <code>Xa</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># matricized array (frontal slice)
Xa &lt;- matrix(1:8,nrow=2)
X &lt;- rarray(Xa, 2, 2, 2)
# original array
X
</code></pre>

<hr>
<h2 id='renormsolCP'>Scaling of the Candecomp/Parafac solution</h2><span id='topic+renormsolCP'></span>

<h3>Description</h3>

<p>Scales the Candecomp/Parafac solution producing two component matrices normalized to unit sum of squares (and compensating this scaling in the remaining component matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> renormsolCP(A, B, C, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renormsolCP_+3A_a">A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="renormsolCP_+3A_b">B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="renormsolCP_+3A_c">C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="renormsolCP_+3A_mode">mode</code></td>
<td>
<p>Scaling option (1 if scaling for B- and C-modes, 2 if scaling for A- and C-modes, 3 if scaling for A- and B-modes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode after normalization</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode after normalization</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode after normalization</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
# CP solution
TVcp &lt;- CPfuncrep(TVdata, 30, 16, 15, 2, 1, 1, 1, 0, 1e-6, 10000)
# sums of squares of A, B and C
sum(TVcp$A^2)
sum(TVcp$B^2)
sum(TVcp$C^2)
# Renormalization by scaling B- and C-modes
TVcpScalBC &lt;- renormsolCP(TVcp$A, TVcp$B, TVcp$C, 1)
# sums of squares of A, B and C after renormalization
sum(TVcpScalBC$A^2)
sum(TVcpScalBC$B^2)
sum(TVcpScalBC$C^2)
</code></pre>

<hr>
<h2 id='renormsolT3'>Renormalization of the Tucker3 (and Tucker2) solution</h2><span id='topic+renormsolT3'></span>

<h3>Description</h3>

<p>Renormalizes the Tucker3 solution producing a core normalized to unit sum of squares (and compensating the core normalization in the component matrices).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> renormsolT3(A, B, C, G, mode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renormsolT3_+3A_a">A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="renormsolT3_+3A_b">B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="renormsolT3_+3A_c">C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="renormsolT3_+3A_g">G</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code id="renormsolT3_+3A_mode">mode</code></td>
<td>
<p>Renormalization option (1 if renormalization with respect to <code>A</code>-mode, 2 if renormalization with respect to <code>B</code>-mode, 3 if renormalization with respect to <code>C</code>-mode)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode after normalization of the core</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode after normalization of the core</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode after normalization of the core</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Normalized matricized core array (frontal slices)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
# T3 solution
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 0, 1e-6)
# sums of squares of A and core
sum(BusT3$A^2)
sum(BusT3$H^2)
# Renormalization with respect to the A-mode
BusT3rA &lt;- renormsolT3(BusT3$A, BusT3$B, BusT3$C, BusT3$H,1)
# sums of squares of A and core after renormalization
sum(BusT3rA$A^2)
sum(BusT3rA$H^2)
</code></pre>

<hr>
<h2 id='splithalfCP'>Split-Half Analysis</h2><span id='topic+splithalfCP'></span>

<h3>Description</h3>

<p>Performs split-half analysis for Candecomp/Parafac.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> splithalfCP(X, n, m, p, r, centopt, normopt, scaleopt, addanal, conv, 
  maxit, ort1, ort2, ort3, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splithalfCP_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_r">r</code></td>
<td>
<p>Number of extracted components</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_centopt">centopt</code></td>
<td>
<p>Centering option (see <code><a href="#topic+cent3">cent3</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_normopt">normopt</code></td>
<td>
<p>Normalization option (see <code><a href="#topic+norm3">norm3</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_scaleopt">scaleopt</code></td>
<td>
<p>Scaling option (see <code><a href="#topic+renormsolCP">renormsolCP</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_addanal">addanal</code></td>
<td>
<p>Number of additional runs</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_maxit">maxit</code></td>
<td>
<p>Maximal number of iterations</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_ort1">ort1</code></td>
<td>
<p>Type of constraints on <code>A</code> (see <code><a href="#topic+CP">CP</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_ort2">ort2</code></td>
<td>
<p>Type of constraints on <code>B</code> (see <code><a href="#topic+CP">CP</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_ort3">ort3</code></td>
<td>
<p>Type of constraints on <code>C</code> (see <code><a href="#topic+CP">CP</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfCP_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Afull</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (full data)</p>
</td></tr>
<tr><td><code>As1</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.1)</p>
</td></tr>
<tr><td><code>As2</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.2)</p>
</td></tr>
<tr><td><code>Bfull</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (full data)</p>
</td></tr>
<tr><td><code>Bs1</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.1)</p>
</td></tr>
<tr><td><code>Bs2</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.2)</p>
</td></tr>
<tr><td><code>Cfull</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (full data)</p>
</td></tr>
<tr><td><code>Cs1</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.1)</p>
</td></tr>
<tr><td><code>Cs2</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>P.M. Kroonenberg (2008). <em>Applied Multiway Data Analysis</em>. Wiley, New Jersey.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
labSCALE=TV[[2]]
labPROGRAM=TV[[3]]
labSTUDENT=TV[[4]]
# permutation of the modes so that the A-mode refers to students
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
## Not run: 
# Split-half analysis on CP solution
splitCP &lt;- splithalfCP(TVdata, 30, 16, 15, 2, 0, 0, 0, 5, 1e-6, 10000, 1, 1, 1, 
 labSTUDENT, labSCALE, labPROGRAM)
# Split-half analysis on CP solution (when labels are not available)
splitCP &lt;- splithalfCP(TVdata, 30, 16, 15, 2, 0, 0, 0, 5, 1e-6, 10000, 1, 1, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='splithalfT3'>Split-Half Analysis</h2><span id='topic+splithalfT3'></span>

<h3>Description</h3>

<p>Performs split-half analysis for Tucker3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> splithalfT3(X, n, m, p, r1, r2, r3, centopt, normopt, renormmode, 
  wa_rel, wb_rel, wc_rel, addanal, conv, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splithalfT3_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_r1">r1</code></td>
<td>
<p>Number of extracted components for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_r2">r2</code></td>
<td>
<p>Number of extracted components for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_r3">r3</code></td>
<td>
<p>Number of extracted components for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_centopt">centopt</code></td>
<td>
<p>Centering option (see <code><a href="#topic+cent3">cent3</a></code>) </p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_normopt">normopt</code></td>
<td>
<p>Normalization option (see <code><a href="#topic+norm3">norm3</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_renormmode">renormmode</code></td>
<td>
<p>Renormalization option (see <code><a href="#topic+renormsolT3">renormsolT3</a></code>)</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_wa_rel">wa_rel</code></td>
<td>
<p>Relative weight for simplicity of <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_wb_rel">wb_rel</code></td>
<td>
<p>Relative weight for simplicity of <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_wc_rel">wc_rel</code></td>
<td>
<p>Relative weight for simplicity of <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_addanal">addanal</code></td>
<td>
<p>Number of additional runs</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="splithalfT3_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Afull</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (full data)</p>
</td></tr>
<tr><td><code>As1</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.1)</p>
</td></tr>
<tr><td><code>As2</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.2)</p>
</td></tr>
<tr><td><code>Bfull</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (full data)</p>
</td></tr>
<tr><td><code>Bs1</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.1)</p>
</td></tr>
<tr><td><code>Bs2</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.2)</p>
</td></tr>
<tr><td><code>Cfull</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (full data)</p>
</td></tr>
<tr><td><code>Cs1</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.1)</p>
</td></tr>
<tr><td><code>Cs2</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.2)</p>
</td></tr>
<tr><td><code>Kfull</code></td>
<td>
<p>Matricized core array (frontal slices) (full data)</p>
</td></tr>
<tr><td><code>Ks1</code></td>
<td>
<p>Matricized core array (frontal slices) (split n.1)</p>
</td></tr>
<tr><td><code>Ks2</code></td>
<td>
<p>Matricized core array (frontal slices) (split n.2)</p>
</td></tr>
<tr><td><code>Kss1</code></td>
<td>
<p>Matricized core array (frontal slices) (using full data solutions for A,B and C for split n.1)</p>
</td></tr>
<tr><td><code>Kss2</code></td>
<td>
<p>Matricized core array (frontal slices) (using full data solutions for A,B and C for split n.2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>P.M. Kroonenberg (2008). <em>Applied Multiway Data Analysis</em>. Wiley, New Jersey.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3">T3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5],1,1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)],3,8)
## Not run: 
# Split-half analysis on T3 solution
splitT3 &lt;- splithalfT3(Bus, 7, 5, 37, 2, 2, 2, 0, 0, 0, 3, 3, 0, 5, 1e-6, 
 laba, labb, labc)
# Split-half analysis on T3 solution (when labels are not available)
splitT3 &lt;- splithalfT3(Bus, 7, 5, 37, 2, 2, 2, 0, 0, 0, 3, 3, 0, 5, 1e-6)

## End(Not run)
</code></pre>

<hr>
<h2 id='SUM'>Summary</h2><span id='topic+SUM'></span>

<h3>Description</h3>

<p>Summary of the elements of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> SUM(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SUM_+3A_a">A</code></td>
<td>
<p>Matrix or data.frame (coerced to a matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>Vector containing the sum of squares of every row</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>Vector containing the sum of squares of every column</p>
</td></tr>
<tr><td><code>mr</code></td>
<td>
<p>Vector containing the mean of every row</p>
</td></tr>
<tr><td><code>mc</code></td>
<td>
<p>Vector containing the mean of every column</p>
</td></tr>
<tr><td><code>minc</code></td>
<td>
<p>Vector containing the minimum of every column</p>
</td></tr>
<tr><td><code>maxc</code></td>
<td>
<p>Vector containing the maximum of every for column</p>
</td></tr>
<tr><td><code>valueMinr</code></td>
<td>
<p>Vector containing the columns corresponding to the minimum values of every row</p>
</td></tr>
<tr><td><code>valueMinc</code></td>
<td>
<p>Vector containing the rows corresponding to the minimum values of every column</p>
</td></tr>
<tr><td><code>valueMaxr</code></td>
<td>
<p>Vector containing the columns corresponding to the maximum values of every row</p>
</td></tr>
<tr><td><code>valueMaxc</code></td>
<td>
<p>Vector containing the rows corresponding to the maximum values of every column</p>
</td></tr>
<tr><td><code>ssq</code></td>
<td>
<p>Sum of squares of the matrix</p>
</td></tr>
<tr><td><code>cumsumr</code></td>
<td>
<p>Matrix containing the cumulative sums of every row</p>
</td></tr>
<tr><td><code>cumsumc</code></td>
<td>
<p>Matrix containing the cumulative sums of every column</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
summary &lt;- SUM(X)
</code></pre>

<hr>
<h2 id='supermat'>Matrix unfolding</h2><span id='topic+supermat'></span>

<h3>Description</h3>

<p>Produces matricizations of a three-way array into matrices denoted as super-matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> supermat(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supermat_+3A_x">X</code></td>
<td>
<p>Array to be unfolded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>Xa</code></td>
<td>
<p>Super-matrix with <code>B</code>-mode entities nested within <code>C</code>-mode entities (all the frontal slices of the array next to each other)</p>
</td></tr>
<tr><td><code>Xb</code></td>
<td>
<p>Super-matrix with <code>C</code>-mode entities nested within <code>A</code>-mode entities (all the horizontal slices of the array next to each other)</p>
</td></tr>
<tr><td><code>Xc</code></td>
<td>
<p>Super-matrix with <code>A</code>-mode entities nested within <code>B</code>-mode entities (all the lateral slices of the array next to each other)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># array (2x2x2) with integers from 1 to 8
X &lt;- array(1:8,c(2,2,2))
Y &lt;- supermat(X)
# matricized arrays
Y$Xa
Y$Xb
Y$Xc 
</code></pre>

<hr>
<h2 id='T1'>Interactive Tucker1 analysis</h2><span id='topic+T1'></span>

<h3>Description</h3>

<p>Detects the underlying structure of a three-way array according to the Tucker1 (T1) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 T1(dati, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T1_+3A_dati">dati</code></td>
<td>
<p>Array of order <code>n</code> by <code>m</code> by <code>p</code> or matrix or data.frame of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T1_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T1_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T1_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>core</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Fit value expressed as a percentage</p>
</td></tr> 
<tr><td><code>fitA</code></td>
<td>
<p>Fit contributions for the <code>A</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitB</code></td>
<td>
<p>Fit contributions for the <code>B</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitC</code></td>
<td>
<p>Fit contributions for the <code>C</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>laba</code></td>
<td>
<p>Vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code>labb</code></td>
<td>
<p>Vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code>labc</code></td>
<td>
<p>Vector of length <code>P</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code>Xprep</code></td>
<td>
<p>Matrix of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices) after preprocessing used for the analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>P. Giordani, H.A.L. Kiers, M.A. Del Ferraro (2014). Three-way component analysis using the R package ThreeWay. <em>Journal of Statistical Software 57(7):1&ndash;23</em>. <a href="http://www.jstatsoft.org/v57/i07/">http://www.jstatsoft.org/v57/i07/</a>.
<br /> P.M. Kroonenberg (2008). <em>Applied Multiway Data Analysis</em>. Wiley, New Jersey.
<br /> L.R Tucker (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika 31:279&ndash;311</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code>,<code><a href="#topic+T3">T3</a></code>,<code><a href="#topic+T2">T2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5],1,1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)],3,8)
## Not run: 
# interactive T1 analysis
BusT1 &lt;- T1(Bus, laba, labb, labc)
# interactive T1 analysis (when labels are not available)
BusT1 &lt;- T1(Bus)

## End(Not run)
</code></pre>

<hr>
<h2 id='T1runsFit'>Tucker1 solutions</h2><span id='topic+T1runsFit'></span>

<h3>Description</h3>

<p>Computes all the Tucker1 solutions using PCASup results with <code>r1</code> (from 1 to <code>maxa</code>, if <code>A</code>-mode reduced), <code>r2</code> (from 1 to <code>maxb</code>, if <code>B</code>-mode reduced) and <code>r3</code> (from 1 to <code>maxc</code>, if <code>C</code>-mode reduced) components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T1runsFit(X, n, m, p, maxa, maxb, maxc, model)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T1runsFit_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T1runsFit_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T1runsFit_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T1runsFit_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T1runsFit_+3A_maxa">maxa</code></td>
<td>
<p>Maximum dimensionality for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T1runsFit_+3A_maxb">maxb</code></td>
<td>
<p>Maximum dimensionality for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T1runsFit_+3A_maxc">maxc</code></td>
<td>
<p>Maximum dimensionality for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="T1runsFit_+3A_model">model</code></td>
<td>
<p>Tucker1 model choice (1 for T1-A, 2 for T1-B, 3 for T2-C)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>Matrix with columns: number of components for the <code>A</code>-mode, number of components for the <code>B</code>-mode, number of components for the <code>C</code>-mode, goodness of fit (%), total number of components</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Cumulative sum of eigenvalues and fits from PCAsup applied to the reduced mode are automatically printed.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56:449&ndash;470</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimSelector">DimSelector</a></code>, <code><a href="#topic+LineCon">LineCon</a></code>, <code><a href="#topic+pcasup1">pcasup1</a></code>, <code><a href="#topic+T1">T1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# Fit values of T1-A with different numbers of components (from 1 to 5)
FitT1 &lt;- T1runsFit(Bus, 7, 5, 37, 5, 5, 37, 1)
</code></pre>

<hr>
<h2 id='T2'>Interactive Tucker2 analysis</h2><span id='topic+T2'></span>

<h3>Description</h3>

<p>Detects the underlying structure of a three-way array according to the Tucker2 (T2) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 T2(dati, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T2_+3A_dati">dati</code></td>
<td>
<p>Array of order <code>n x m x p</code> or matrix or data.frame of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T2_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>core</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Fit value expressed as a percentage</p>
</td></tr> 
<tr><td><code>fitValues</code></td>
<td>
<p>Fit values expressed as a percentage upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+T2func">T2func</a></code>)</p>
</td></tr>
<tr><td><code>funcValues</code></td>
<td>
<p>Function values upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+T2func">T2func</a></code>)</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation times for all the runs of the CP algorithm (see <code><a href="#topic+T2func">T2func</a></code>)</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Numbers of iterations upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+T2func">T2func</a></code>)</p>
</td></tr>
<tr><td><code>fitA</code></td>
<td>
<p>Fit contributions for the <code>A</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitB</code></td>
<td>
<p>Fit contributions for the <code>B</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitC</code></td>
<td>
<p>Fit contributions for the <code>C</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitAB</code></td>
<td>
<p>Fit contributions for the <code>A</code>-and mode <code>B</code> component combinations (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitAC</code></td>
<td>
<p>Fit contributions for the <code>A</code>-and mode <code>C</code> component combinations (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitBC</code></td>
<td>
<p>Fit contributions for the <code>B</code>-and mode <code>C</code> component combinations (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>laba</code></td>
<td>
<p>Vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code>labb</code></td>
<td>
<p>Vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code>labc</code></td>
<td>
<p>Vector of length <code>P</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code>Xprep</code></td>
<td>
<p>Matrix of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices) after preprocessing used for the analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>P. Giordani, H.A.L. Kiers, M.A. Del Ferraro (2014). Three-way component analysis using the R package ThreeWay. <em>Journal of Statistical Software 57(7):1&ndash;23</em>. <a href="http://www.jstatsoft.org/v57/i07/">http://www.jstatsoft.org/v57/i07/</a>.
<br /> P.M. Kroonenberg (2008). <em>Applied Multiway Data Analysis</em>. Wiley, New Jersey.
<br /> L.R Tucker (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika 31:279&ndash;311</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code>,<code><a href="#topic+T3">T3</a></code>,<code><a href="#topic+T1">T1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
## Not run: 
# interactive T2 analysis
BusT2 &lt;- T2(Bus, laba, labb, labc)
# interactive T2 analysis (when labels are not available)
BusT2 &lt;- T2(Bus)

## End(Not run)
</code></pre>

<hr>
<h2 id='T2func'>Algorithm for the Tucker2 model</h2><span id='topic+T2func'></span>

<h3>Description</h3>

<p>Alternating Least Squares algorithm for the minimization of the Tucker2 loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> T2func(X, n, m, p, r1, r2, r3, start, conv, model, A, B, C, H) 
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T2func_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T2func_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2func_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2func_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2func_+3A_r1">r1</code></td>
<td>
<p>Number of extracted components for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T2func_+3A_r2">r2</code></td>
<td>
<p>Number of extracted components for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T2func_+3A_r3">r3</code></td>
<td>
<p>Number of extracted components for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="T2func_+3A_start">start</code></td>
<td>
<p>Starting point: 0 starting point of the algorithm from generalized eigenvalue decomposition, 1 random starting point (orthonormalized component matrices), 2 if users specified component matrices</p>
</td></tr>
<tr><td><code id="T2func_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="T2func_+3A_model">model</code></td>
<td>
<p>Tucker2 model choice (1 for T2-AB, 2 for T2-AC, 3 for T2-BC)</p>
</td></tr>
<tr><td><code id="T2func_+3A_a">A</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>A</code></p>
</td></tr>
<tr><td><code id="T2func_+3A_b">B</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>B</code></p>
</td></tr>
<tr><td><code id="T2func_+3A_c">C</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>C</code></p>
</td></tr>
<tr><td><code id="T2func_+3A_h">H</code></td>
<td>
<p>Optional (necessary if start=2) starting value for the matricized core array (frontal slices)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Orthonormal component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Orthonormal component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Orthonormal component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Loss function value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit percentage</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation time</p>
</td></tr>
<tr><td><code>La</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>A</code>-mode</p>
</td></tr>
<tr><td><code>Lb</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>B</code>-mode</p>
</td></tr>
<tr><td><code>Lc</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>C</code>-mode</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The loss function to be minimized is <code class="reqn">||X_A - A G_A kron(C',B')||^2</code> where <code class="reqn">X_A</code> and <code class="reqn">G_A</code> denote the matricized (frontal slices) data array and core array, respectively, and kron stands for the Kronecker product.
<br /> <code>T2func</code> is the same as <code>T2funcrep</code> except that all printings are available.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers, P.M. Kroonenberg \&amp; J.M.F. ten Berge (1992). An efficient algorithm for TUCKALS3 on data with large numbers of observation units. <em>Psychometrika 57:415&ndash;422</em>. 
<br /> P.M. Kroonenberg and J. de Leeuw (1980). Principal component analysis of three-mode data by means of alternating least squares algorithms. <em>Psychometrika 45:69&ndash;97</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T2">T2</a></code>, <code><a href="#topic+T2funcrep">T2funcrep</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
# T2-AB solution using two components for the A- and B-modes 
# (rational starting point by SVD [start=0])
BusT2 &lt;- T2func(Bus, 7, 5, 37, 2, 2, 37, 0, 1e-6, 1)
# T2-AC solution using two components for for the A- and C-modes 
# (random orthonormalized starting point [start=1])
BusT2 &lt;- T2func(Bus, 7, 5, 37, 2, 5, 2, 1, 1e-6, 2)
# T2-BC solution using two components for the B- and C- modes 
# (user starting point [start=2])
BusT2 &lt;- T2func(Bus, 7, 5, 37, 7, 2, 2, 1, 1e-6, 3, diag(7), 
 matrix(rnorm(5*2),nrow=5), matrix(rnorm(37*2),nrow=37), 
 matrix(rnorm(7*4),nrow=7))
</code></pre>

<hr>
<h2 id='T2funcrep'>Algorithm for the Tucker2 model</h2><span id='topic+T2funcrep'></span>

<h3>Description</h3>

<p>Alternating Least Squares algorithm for the minimization of the Tucker2 loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> T2funcrep(X, n, m, p, r1, r2, r3, start, conv, model, A, B, C, H) 
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T2funcrep_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_r1">r1</code></td>
<td>
<p>Number of extracted components for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_r2">r2</code></td>
<td>
<p>Number of extracted components for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_r3">r3</code></td>
<td>
<p>Number of extracted components for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_start">start</code></td>
<td>
<p>Starting point: 0 starting point of the algorithm from generalized eigenvalue decomposition, 1 random starting point (orthonormalized component matrices), 2 if users specified component matrices</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_model">model</code></td>
<td>
<p>Tucker2 model choice (1 for T2-AB, 2 for T2-AC, 3 for T2-BC)</p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_a">A</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>A</code></p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_b">B</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>B</code></p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_c">C</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>C</code></p>
</td></tr>
<tr><td><code id="T2funcrep_+3A_h">H</code></td>
<td>
<p>Optional (necessary if start=2) starting value for the matricized core array (frontal slices)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Orthonormal component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Orthonormal component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Orthonormal component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Loss function value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit percentage</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation time</p>
</td></tr>
<tr><td><code>La</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>A</code>-mode</p>
</td></tr>
<tr><td><code>Lb</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>B</code>-mode</p>
</td></tr>
<tr><td><code>Lc</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>C</code>-mode</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The loss function to be minimized is <code class="reqn">||X_A - A G_A kron(C',B')||^2</code> where <code class="reqn">X_A</code> and <code class="reqn">G_A</code> denote the matricized (frontal slices) data array and core array, respectively, and kron stands for the Kronecker product.
<br /> <code>T2funcrep</code> is the same as <code>T2func</code> except that all printings are suppressed. Thus, <code>T2funcrep</code> can be helpful for simulation experiments.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers, P.M. Kroonenberg \&amp; J.M.F. ten Berge (1992). An efficient algorithm for TUCKALS3 on data with large numbers of observation units. <em>Psychometrika 57:415&ndash;422</em>. 
<br /> P.M. Kroonenberg and J. de Leeuw (1980). Principal component analysis of three-mode data by means of alternating least squares algorithms. <em>Psychometrika 45:69&ndash;97</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T2">T2</a></code>, <code><a href="#topic+T2func">T2func</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
# T2-AB solution using two components for the A- and B-modes 
# (rational starting point by SVD [start=0])
BusT2 &lt;- T2funcrep(Bus, 7, 5, 37, 2, 2, 37, 0, 1e-6,1)
# T2-AC solution using two components for for the A- and C-modes 
# (random orthonormalized starting point [start=1])
BusT2 &lt;- T2funcrep(Bus, 7, 5, 37, 2, 5, 2, 1, 1e-6, 2)
# T2-BC solution using two components for the B- and C- modes 
# (user starting point [start=2])
BusT2 &lt;- T2funcrep(Bus, 7, 5, 37, 7, 2, 2, 1, 1e-6, 3, diag(7), 
 matrix(rnorm(5*2),nrow=5), matrix(rnorm(37*2),nrow=37), 
 matrix(rnorm(7*4),nrow=7))
</code></pre>

<hr>
<h2 id='T2runsApproxFit'>Approximated Tucker2 solutions</h2><span id='topic+T2runsApproxFit'></span>

<h3>Description</h3>

<p>Computes all the approximated Tucker2 solutions using PCASup results with <code>r1</code> (from 1 to <code>maxa</code>, if <code>A</code>-mode reduced), <code>r2</code> (from 1 to <code>maxb</code>, if <code>B</code>-mode reduced) and <code>r3</code> (from 1 to <code>maxc</code>, if <code>C</code>-mode reduced) components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T2runsApproxFit(X, n, m, p, maxa, maxb, maxc, model)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T2runsApproxFit_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T2runsApproxFit_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2runsApproxFit_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2runsApproxFit_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T2runsApproxFit_+3A_maxa">maxa</code></td>
<td>
<p>Maximum dimensionality for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T2runsApproxFit_+3A_maxb">maxb</code></td>
<td>
<p>Maximum dimensionality for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T2runsApproxFit_+3A_maxc">maxc</code></td>
<td>
<p>Maximum dimensionality for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="T2runsApproxFit_+3A_model">model</code></td>
<td>
<p>Tucker2 model choice (1 for T2-AB, 2 for T2-AC, 3 for T2-BC)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>Matrix with columns: number of components for the <code>A</code>-mode, number of components for the <code>B</code>-mode, number of components for the <code>C</code>-mode, goodness of fit (%), total number of components
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Cumulative sum of eigenvalues and fits from PCAsup applied to the reduced modes are automatically printed.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56:449&ndash;470</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimSelector">DimSelector</a></code>, <code><a href="#topic+LineCon">LineCon</a></code>, <code><a href="#topic+pcasup2">pcasup2</a></code>, <code><a href="#topic+T2">T2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# Fit values of T2-AB with different numbers of components 
# (from 1 to 3 for the B-mode, from 1 to 5 for the C-mode)
FitT2 &lt;- T2runsApproxFit(Bus, 7, 5, 37, 7, 3, 5, 3)
</code></pre>

<hr>
<h2 id='T3'>Interactive Tucker3 analysis</h2><span id='topic+T3'></span>

<h3>Description</h3>

<p>Detects the underlying structure of a three-way array according to the Tucker3 (T3) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 T3(data, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3_+3A_data">data</code></td>
<td>
<p>Array of order <code>n</code> <code>x</code> <code>m</code> <code>x</code> <code>p</code> or matrix or data.frame of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T3_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>core</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Fit value expressed as a percentage</p>
</td></tr> 
<tr><td><code>fitValues</code></td>
<td>
<p>Fit values expressed as a percentage upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+T3func">T3func</a></code>)</p>
</td></tr>
<tr><td><code>funcValues</code></td>
<td>
<p>Function values upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+T3func">T3func</a></code>)</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation times for all the runs of the CP algorithm (see <code><a href="#topic+T3func">T3func</a></code>)</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Numbers of iterations upon convergence for all the runs of the CP algorithm (see <code><a href="#topic+T3func">T3func</a></code>)</p>
</td></tr>
<tr><td><code>fitA</code></td>
<td>
<p>Fit contributions for the <code>A</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitB</code></td>
<td>
<p>Fit contributions for the <code>B</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitC</code></td>
<td>
<p>Fit contributions for the <code>C</code>-mode entities (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitAB</code></td>
<td>
<p>Fit contributions for the <code>A</code>-and mode <code>B</code> component combinations (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitAC</code></td>
<td>
<p>Fit contributions for the <code>A</code>-and mode <code>C</code> component combinations (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>fitBC</code></td>
<td>
<p>Fit contributions for the <code>B</code>-and mode <code>C</code> component combinations (see <code><a href="#topic+T3fitpartitioning">T3fitpartitioning</a></code>)</p>
</td></tr>
<tr><td><code>Bint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>B</code> (see <code><a href="#topic+bootstrapT3">bootstrapT3</a></code>)</p>
</td></tr>
<tr><td><code>Cint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>C</code> (see <code><a href="#topic+bootstrapT3">bootstrapT3</a></code>)</p>
</td></tr>
<tr><td><code>Kint</code></td>
<td>
<p>Bootstrap percentile interval of every element of <code>core</code> (see <code><a href="#topic+bootstrapT3">bootstrapT3</a></code>)</p>
</td></tr>
<tr><td><code>fpint</code></td>
<td>
<p>Bootstrap percentile interval for the goodness of fit index expressed as a percentage (see <code><a href="#topic+bootstrapT3">bootstrapT3</a></code>)</p>
</td></tr>
<tr><td><code>Afull</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (full data) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>As1</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.1) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>As2</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode (split n.2) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Bfull</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (full data) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Bs1</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.1) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Bs2</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode (split n.2) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Cfull</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (full data) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Cs1</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.1) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Cs2</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode (split n.2) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Kfull</code></td>
<td>
<p>Matricized core array (frontal slices) (full data) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Ks1</code></td>
<td>
<p>Matricized core array (frontal slices) (split n.1) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Ks2</code></td>
<td>
<p>Matricized core array (frontal slices) (split n.2) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Kss1</code></td>
<td>
<p>Matricized core array (frontal slices) (using full data solutions for A,B and C for split n.1) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Kss2</code></td>
<td>
<p>Matricized core array (frontal slices) (using full data solutions for A,B and C for split n.2) from split-half analysis (see <code><a href="#topic+splithalfT3">splithalfT3</a></code>)</p>
</td></tr>
<tr><td><code>Aplot</code></td>
<td>
<p>Coordinates for plots of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code>Bplot</code></td>
<td>
<p>Coordinates for plots of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code>Cplot</code></td>
<td>
<p>Coordinates for plots of the <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code>CBplot</code></td>
<td>
<p>Coordinates for plots of the <code>C</code> and <code>B</code>-mode entities using the <code>A</code>-mode projected in it as axes (to be added in <code>plot</code>, i.e. coordinates in (<code>$CBplot</code>,<code>$A</code>))</p>
</td></tr>
<tr><td><code>ACplot</code></td>
<td>
<p>Coordinates for plots of the <code>A</code> and <code>C</code>-mode entities using the <code>B</code>-mode projected in it as axes (to be added in <code>plot</code>, i.e. coordinates in (<code>$ACplot</code>,<code>$B</code>))</p>
</td></tr>
<tr><td><code>BAplot</code></td>
<td>
<p>Coordinates for plots of the <code>B</code> and <code>A</code>-mode entities using the <code>C</code>-mode projected in it as axes (to be added in <code>plot</code>, i.e. coordinates in (<code>$BAplot</code>,<code>$C</code>))</p>
</td></tr>
<tr><td><code>A1</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>B1</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>C1</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>A2</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>B2</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>C2</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode from Principal Component Analysis of mean values (see <code><a href="#topic+pcamean">pcamean</a></code>)</p>
</td></tr>
<tr><td><code>laba</code></td>
<td>
<p>Vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code>labb</code></td>
<td>
<p>Vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code>labc</code></td>
<td>
<p>Vector of length <code>P</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code>Xprep</code></td>
<td>
<p>Matrix of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices) after preprocessing used for the analysis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>P. Giordani, H.A.L. Kiers, M.A. Del Ferraro (2014). Three-way component analysis using the R package ThreeWay. <em>Journal of Statistical Software 57(7):1&ndash;23</em>. <a href="http://www.jstatsoft.org/v57/i07/">http://www.jstatsoft.org/v57/i07/</a>.
<br /> P.M. Kroonenberg (2008). <em>Applied Multiway Data Analysis</em>. Wiley, New Jersey.
<br /> L.R Tucker (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika 31:279&ndash;311</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP">CP</a></code>,<code><a href="#topic+T2">T2</a></code>,<code><a href="#topic+T1">T1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5],1,1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)],3,8)
## Not run: 
# interactive T3 analysis
BusT3 &lt;- T3(Bus, laba, labb, labc)
# interactive T3 analysis (when labels are not available)
BusT3 &lt;- T3(Bus)

## End(Not run)
</code></pre>

<hr>
<h2 id='T3dimensionalityplot'>Plot fit of Tucker3</h2><span id='topic+T3dimensionalityplot'></span>

<h3>Description</h3>

<p>Plots fits against numbers of dimensions, with <code>PQR</code> as labels and fits against number of effective paramaters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T3dimensionalityplot(A, n, m, p)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3dimensionalityplot_+3A_a">A</code></td>
<td>
<p>Matrix with columns: number of components for the <code>A</code>-mode, number of components for the <code>B</code>-mode, number of components for the <code>C</code>-mode, goodness of fit (%), total number of components</p>
</td></tr>
<tr><td><code id="T3dimensionalityplot_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3dimensionalityplot_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3dimensionalityplot_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>A</code> is usually the output of <code><a href="#topic+DimSelector">DimSelector</a></code>.
<br /> The number of effective parameters  in a Candecomp/Parafac analysis is discussed in Weesie and Van Houwelingen (1983).
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>E. Ceulemans \&amp; H.A.L. Kiers (2006). Selecting among three-mode principal component models of different types and complexities: A numerical convex hull based method. <em>British Journal of Mathematical and Statistical Psychology 59:133&ndash;150</em>. 
<br /> J. Weesie and H. Van Houwelingen (1983). <em>GEPCAM users' manual (first draft)</em>. Utrecht, The Netherlands: Institute of Mathematical Statistics, State University of Utrecht.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3">T3</a></code>, <code><a href="#topic+DimSelector">DimSelector</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# Fit values of T3 with different numbers of components (from 1 to 4 for the A-mode, 
# from 1 to 3 for the B-mode, from 1 to 5 for the C-mode)
FitT3 &lt;- T3runsApproxFit(Bus,7,5,37,4,3,5)
T3dimensionalityplot(FitT3,7,5,37)
</code></pre>

<hr>
<h2 id='T3fitpartitioning'>Fit of each entity per mode</h2><span id='topic+T3fitpartitioning'></span>

<h3>Description</h3>

<p>Computation of fit contributions by combinations of modes in case of &lsquo;renormalization&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T3fitpartitioning(Xprep, n, m, p, AS, BT, CU, K, renormmode, laba, labb, labc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3fitpartitioning_+3A_xprep">Xprep</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_as">AS</code></td>
<td>
<p>Component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_bt">BT</code></td>
<td>
<p>Component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_cu">CU</code></td>
<td>
<p>Component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_k">K</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_renormmode">renormmode</code></td>
<td>
<p>Renormalization option (0 for no renormalization, 1 for fit contribution to total fit of each <code>B</code>- and <code>C</code>-mode component combination, 2 for fit contribution to total fit of each <code>A</code>- and <code>C</code>-mode component combination, 3 for fit contribution to total fit of each <code>A</code>- and <code>B</code>-mode component combination)</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_laba">laba</code></td>
<td>
<p>Optional vector of length <code>n</code> containing the labels of the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_labb">labb</code></td>
<td>
<p>Optional vector of length <code>m</code> containing the labels of the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3fitpartitioning_+3A_labc">labc</code></td>
<td>
<p>Optional vector of length <code>p</code> containing the labels of the <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>fitA</code></td>
<td>
<p>Fit contribution for the <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code>fitB</code></td>
<td>
<p>Fit contribution for the <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code>fitC</code></td>
<td>
<p>Fit contribution for the <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code>ABcontr</code></td>
<td>
<p>Contribution to the goodness of fit contributions by combinations of <code>A</code>- and <code>B</code>-modes in case of &lsquo;renormalization&rsquo;</p>
</td></tr>
<tr><td><code>BCcontr</code></td>
<td>
<p>Contribution to the goodness of fit contributions by combinations of <code>B</code>- and <code>C</code>-modes in case of &lsquo;renormalization&rsquo;</p>
</td></tr>
<tr><td><code>ACcontr</code></td>
<td>
<p>Contribution to the goodness of fit contributions by combinations of <code>A</code>- and <code>C</code>-modes in case of &lsquo;renormalization&rsquo;</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The computation of the fit contributions by combinations of modes is done in case of &lsquo;renormalization&rsquo;.
<br /> In Tucker1, <code>renormmode</code> must be equal to 0.</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+T3">T3</a></code>, <code><a href="#topic+T2">T2</a></code>, <code><a href="#topic+T1">T1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
# T3 solution
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 0, 1e-6)
# Fitpartitioning of the T3 solution
FitT3 &lt;- T3fitpartitioning(Bus, 7, 5, 37, BusT3$A, BusT3$B, BusT3$C, BusT3$H, 0, 
 laba, labb, labc)
# Fitpartitioning of the T3 solution (when labels are not available)
FitT3 &lt;- T3fitpartitioning(Bus, 7, 5, 37, BusT3$A, BusT3$B, BusT3$C, BusT3$H, 0)
</code></pre>

<hr>
<h2 id='T3func'>Algorithm for the Tucker3 model</h2><span id='topic+T3func'></span>

<h3>Description</h3>

<p>Alternating Least Squares algorithm for the minimization of the Tucker3 loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> T3func(X, n, m, p, r1, r2, r3, start, conv, A, B, C, H) 
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3func_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T3func_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3func_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3func_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3func_+3A_r1">r1</code></td>
<td>
<p>Number of extracted components for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T3func_+3A_r2">r2</code></td>
<td>
<p>Number of extracted components for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T3func_+3A_r3">r3</code></td>
<td>
<p>Number of extracted components for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="T3func_+3A_start">start</code></td>
<td>
<p>Starting point (0 starting point of the algorithm from generalized eigenvalue decomposition, 1 random starting point (orthonormalized component matrices), 2 if users specified component matrices</p>
</td></tr>
<tr><td><code id="T3func_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="T3func_+3A_a">A</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>A</code></p>
</td></tr>
<tr><td><code id="T3func_+3A_b">B</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>B</code></p>
</td></tr>
<tr><td><code id="T3func_+3A_c">C</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>C</code></p>
</td></tr>
<tr><td><code id="T3func_+3A_h">H</code></td>
<td>
<p>Optional (necessary if start=2) starting value for the matricized core array (frontal slices)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Orthonormal component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Orthonormal component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Orthonormal component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Loss function value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit percentage</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation time</p>
</td></tr>
<tr><td><code>La</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>A</code>-mode</p>
</td></tr>
<tr><td><code>Lb</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>B</code>-mode</p>
</td></tr>
<tr><td><code>Lc</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>C</code>-mode</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The loss function to be minimized is <code class="reqn">||X_A - A G_A kron(C',B')||^2</code> where <code class="reqn">X_A</code> and <code class="reqn">G_A</code> denote the matricized (frontal slices) data array and core array, respectively, and kron stands for the Kronecker product.
<br /> <code>T3func</code> is the same as <code>T3funcrep</code> except that all printings are available.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers, P.M. Kroonenberg \&amp; J.M.F. ten Berge (1992). An efficient algorithm for TUCKALS3 on data with large numbers of observation units. <em>Psychometrika 57:415&ndash;422</em>. 
<br /> P.M. Kroonenberg \&amp; J. de Leeuw (1980). Principal component analysis of three-mode data by means of alternating least squares algorithms. <em>Psychometrika 45:69&ndash;97</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3">T3</a></code>, <code><a href="#topic+T3funcrep">T3funcrep</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
# T3 solution using two components for all the modes 
# (rational starting point by SVD [start=0])
BusT3 &lt;- T3func(Bus, 7, 5, 37, 2, 2, 2, 0, 1e-6)
# T3 solution using two components for all the modes 
# (random orthonormalized starting point [start=1])
BusT3 &lt;- T3func(Bus, 7, 5, 37, 2, 2, 2, 1, 1e-6)
# T3 solution using two components for all the modes 
# (user starting point [start=2])
BusT3 &lt;- T3func(Bus, 7, 5, 37, 2, 2, 2, 1, 1e-6, matrix(rnorm(7*2),nrow=7), 
 matrix(rnorm(5*2),nrow=5), matrix(rnorm(37*2),nrow=37), 
 matrix(rnorm(2*4),nrow=2))
</code></pre>

<hr>
<h2 id='T3funcrep'>Algorithm for the Tucker3 model</h2><span id='topic+T3funcrep'></span>

<h3>Description</h3>

<p>Alternating Least Squares algorithm for the minimization of the Tucker3 loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> T3funcrep(X, n, m, p, r1, r2, r3, start, conv, A, B, C, H) 
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3funcrep_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_r1">r1</code></td>
<td>
<p>Number of extracted components for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_r2">r2</code></td>
<td>
<p>Number of extracted components for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_r3">r3</code></td>
<td>
<p>Number of extracted components for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_start">start</code></td>
<td>
<p>Starting point (0 starting point of the algorithm from generalized eigenvalue decomposition, 1 random starting point (orthonormalized component matrices), 2 if users specified component matrices</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_a">A</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>A</code></p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_b">B</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>B</code></p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_c">C</code></td>
<td>
<p>Optional (necessary if start=2) starting value for <code>C</code></p>
</td></tr>
<tr><td><code id="T3funcrep_+3A_h">H</code></td>
<td>
<p>Optional (necessary if start=2) starting value for the matricized core array (frontal slices)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Orthonormal component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Orthonormal component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Orthonormal component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Loss function value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit percentage</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>cputime</code></td>
<td>
<p>Computation time</p>
</td></tr>
<tr><td><code>La</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>A</code>-mode</p>
</td></tr>
<tr><td><code>Lb</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>B</code>-mode</p>
</td></tr>
<tr><td><code>Lc</code></td>
<td>
<p>Matrix which should be diagonal, and if so, contain &lsquo;intrinsic eigenvalues&rsquo; for <code>C</code>-mode</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The loss function to be minimized is <code class="reqn">||X_A - A G_A kron(C',B')||^2</code> where <code class="reqn">X_A</code> and <code class="reqn">G_A</code> denote the matricized (frontal slices) data array and core array, respectively, and kron stands for the Kronecker product.
<br /> <code>T3funcrep</code> is the same as <code>T3func</code> except that all printings are suppressed. Thus, <code>T3funcrep</code> can be helpful for simulation experiments.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers, P.M. Kroonenberg \&amp; J.M.F. ten Berge (1992). An efficient algorithm for TUCKALS3 on data with large numbers of observation units. <em>Psychometrika 57:415&ndash;422</em>. 
<br /> P.M. Kroonenberg \&amp; J. de Leeuw (1980). Principal component analysis of three-mode data by means of alternating least squares algorithms. <em>Psychometrika 45:69&ndash;97</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3">T3</a></code>, <code><a href="#topic+T3func">T3func</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# labels for Bus data
laba &lt;- rownames(Bus)
labb &lt;- substr(colnames(Bus)[1:5], 1, 1)
labc &lt;- substr(colnames(Bus)[seq(1,ncol(Bus),5)], 3, 8)
# T3 solution using two components for all the modes 
# (rational starting point by SVD [start=0])
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 0, 1e-6)
# T3 solution using two components for all the modes 
# (random orthonormalized starting point [start=1])
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 1, 1e-6)
# T3 solution using two components for all the modes 
# (user starting point [start=2])
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 1, 1e-6, matrix(rnorm(7*2),nrow=7), 
 matrix(rnorm(5*2),nrow=5), matrix(rnorm(37*2),nrow=37), 
 matrix(rnorm(2*4),nrow=2))
</code></pre>

<hr>
<h2 id='T3runsApproxFit'>Approximated Tucker3 solutions</h2><span id='topic+T3runsApproxFit'></span>

<h3>Description</h3>

<p>Computes all the approximated Tcker3 solutions using PCASup results with <code>r1</code> (from 1 to <code>maxa</code>), <code>r2</code> (from 1 to <code>maxb</code>) and <code>r3</code> (from 1 to <code>maxc</code>) components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T3runsApproxFit(X, n, m, p, maxa, maxb, maxc)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3runsApproxFit_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="T3runsApproxFit_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3runsApproxFit_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3runsApproxFit_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
<tr><td><code id="T3runsApproxFit_+3A_maxa">maxa</code></td>
<td>
<p>Maximum dimensionality for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="T3runsApproxFit_+3A_maxb">maxb</code></td>
<td>
<p>Maximum dimensionality for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="T3runsApproxFit_+3A_maxc">maxc</code></td>
<td>
<p>Maximum dimensionality for the <code>C</code>-mode</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>Matrix with columns: number of components for the <code>A</code>-mode, number of components for the <code>B</code>-mode, number of components for the <code>C</code>-mode, goodness of fit (%), total number of components</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Cumulative sum of eigenvalues and fits from PCAsup applied to the <code>A</code>-, <code>B</code>- and <code>C</code>-modes are automatically printed.
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1991). Hierarchical relations among three-way methods. <em>Psychometrika 56:449&ndash;470</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+DimSelector">DimSelector</a></code>, <code><a href="#topic+LineCon">LineCon</a></code>, <code><a href="#topic+pcasup3">pcasup3</a></code>, <code><a href="#topic+T3">T3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# Fit values of T3 with different numbers of components (from 1 to 4 for the A-mode, 
# from 1 to 3 for the B-mode, from 1 to 5 for the C-mode)
FitT3 &lt;- T3runsApproxFit(Bus, 7, 5, 37, 4, 3, 5)
</code></pre>

<hr>
<h2 id='threewayanova'>Three-way ANOVA</h2><span id='topic+threewayanova'></span>

<h3>Description</h3>

<p>Computation of three-way Analysis of Variance (ANOVA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threewayanova(Y, n, m, p)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threewayanova_+3A_y">Y</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) of order (<code>n</code> <code>x</code> <code>mp</code>) containing the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="threewayanova_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities</p>
</td></tr>
<tr><td><code id="threewayanova_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities</p>
</td></tr>
<tr><td><code id="threewayanova_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>SS.a</code></td>
<td>
<p>Main effect for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>SS.b</code></td>
<td>
<p>Main effect for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>SS.c</code></td>
<td>
<p>Main effect for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>SS.ab</code></td>
<td>
<p>Second order interaction (<code>A</code>- and <code>B</code>-mode)</p>
</td></tr>
<tr><td><code>SS.bc</code></td>
<td>
<p>Second order interaction (<code>B</code>- and <code>C</code>-mode)</p>
</td></tr>
<tr><td><code>SS.ac</code></td>
<td>
<p>Second order interaction (<code>A</code>- and <code>C</code>-mode)</p>
</td></tr>
<tr><td><code>SS.abc</code></td>
<td>
<p>Residual sum of squares after subtraction of second order interactions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers \&amp; I. Van Mechelen (2001). Three-way component analysis: principles and illustrative applications. <em>Psychological Methods 6:84&ndash;110</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TV)
TVdata=TV[[1]]
anova3 &lt;- threewayanova(TVdata, 16, 15, 30)
</code></pre>

<hr>
<h2 id='tr'>Trace</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Computes the trace of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> tr(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_a">a</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>t</code></td>
<td>
<p>Trace of <code>A</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*6),ncol=6)
trace &lt;- tr(X)
</code></pre>

<hr>
<h2 id='TV'>TV data</h2><span id='topic+TV'></span>

<h3>Description</h3>

<p>Three-way data about ratings of 15 American television shows on 16 bipolar scales made by 30 students. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TV)</code></pre>


<h3>Format</h3>

<p>A list containing one data.frame and three character vectors.
<br /> <code>TV[[1]]</code> is a data.frame with 16 rows and 450 (15 <code>x</code> 30) columns.
<br /> The rows refer to the American television shows.
<br /> The columns refer to the combinations of scales and students with the sclaes nested within the students.
<br /> The data.frame contains the frontal slices next to each other of the original array. 
<br /> The labels for the bipolar scales are in the character vector <code>TV[[2]]</code>.
<br /> The labels for the TV programs are in the character vector <code>TV[[3]]</code>.
<br /> The labels for the students are in the character vector <code>TV[[4]]</code>.
</p>


<h3>Details</h3>

<p>The original data set consists of ratings made by 40 subjects (psychology students at the University of Western Ontario in 1981).
To avoid missing data, only 30 students are considered.
The ratings are made on 13-point bipolar scales.
Lundy et al. (1989) perform Candecomp/Parafac on the preprocessed data. 
Details on preprocessing are not reported, but should be centered within TV programs and scales.
Three real components are extracted. However, the unconstrained Candecomp/Parafac solution with three components suffers from the so-called degeneracy (obtained solution with highly correlated and uninterpretable dimensions). 
Degeneracy (see, for instance,  Harshman \&amp; Lundy, 1984; Stegeman, 2006, 2007; De Silva \&amp; Lim, 2008; Rocci \&amp; Giordani, 2010) can be overcome by imposing orthogonal constraints in one of the component matrices. 
The so-obtained solution with three components is meaningful and interpretable as described in Lundy et al. (1989).
</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>V. De Silva \&amp; L.-H. Lim (2008). Tensor rank and the ill-posedness of the best low-rank approximation problem. <em>SIAM Journal on Matrix Analysis and Applications 30:1084&ndash;1127</em>.
<br /> R.A. Harshman \&amp; M.E. Lundy (1984). Data preprocessing and the extended PARAFAC model. In <em>H.G. Law, C.W. Snyder Jr, J.A. Hattie, \&amp; R.P. McDonald (Eds.): Research methods for multimode data analysis</em>. Praeger, New York (pp. 216&ndash;284).
<br /> M.E. Lundy, R.A. Harshman \&amp; J.B. Kruskal (1989). A two-stage procedure incorporating good features of both trilinear and quadrilinear models. In <em>R. Coppi, S. Bolasco (Eds.): Multiway Data Analysis</em>. Elsevier, North Holland (pp. 123&ndash;130).
<br /> R. Rocci R \&amp; P. Giordani (2010). A weak degeneracy decomposition for the CANDECOMP/PARAFAC  model. <em>Journal of Chemometrics 24:57&ndash;66</em>.
<br /> A. Stegeman (2006). Degeneracy in Candecomp/Parafac explained for <code>pxpx2</code> arrays of rank p+1 or higher. <em>Psychometrika 71:483&ndash;501</em>.
<br /> A. Stegeman (2007). Degeneracy in Candecomp/Parafac and Indscal explained for several three-sliced arrays with a two-valued typical rank. <em>Psychometrika 72:601&ndash;619</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to perform stability check and produce bootstrap confidence intervals 
# it is useful to permute the modes so that the A-mode refers to students
data(TV)
TVdata=TV[[1]]
labSCALE=TV[[2]]
labPROGRAM=TV[[3]]
labSTUDENT=TV[[4]]
TVdata &lt;- permnew(TVdata, 16, 15, 30)
TVdata &lt;- permnew(TVdata, 15, 30, 16)
</code></pre>

<hr>
<h2 id='varim'>Varimax roation</h2><span id='topic+varim'></span>

<h3>Description</h3>

<p>Produces varimax rotated version of <code>A</code> and rotation matrix <code>T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> varim(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varim_+3A_a">A</code></td>
<td>
<p>Matrix to be to be rotated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>Rotated version of <code>A</code> (<code>B=AT</code>)</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Rotation matrix</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Varimax function value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H. Kaiser (1958). The varimax criterion for analytic rotation in factor analysis. <em>Psychometrika 23:187&ndash;200</em>.
<br /> K. Nevels (1986). A direct solution for pairwise rotations in Kaiser's varimax method. <em>Psychometrika 51:327&ndash;329</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+normvari">normvari</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(6*3),ncol=3)
Y &lt;- varim(X)
# varimax rotated version of X
Y$B
# rotation matrix
Y$T
</code></pre>

<hr>
<h2 id='varimcoco'>Varimax Rotation for Tucker3 and Tucker2</h2><span id='topic+varimcoco'></span>

<h3>Description</h3>

<p>Performs varimax rotation of the core and component matrix rotations to simple structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varimcoco(A, B, C, H, wa_rel, wb_rel, wc_rel, rot1, rot2, rot3, nanal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varimcoco_+3A_a">A</code></td>
<td>
<p>Columnwise orthomornal component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code id="varimcoco_+3A_b">B</code></td>
<td>
<p>Columnwise orthomornal component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code id="varimcoco_+3A_c">C</code></td>
<td>
<p>Columnwise orthomornal component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code id="varimcoco_+3A_h">H</code></td>
<td>
<p>Matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code id="varimcoco_+3A_wa_rel">wa_rel</code></td>
<td>
<p>relative weight (&gt;=0) for the simplicity of <code>A</code></p>
</td></tr>
<tr><td><code id="varimcoco_+3A_wb_rel">wb_rel</code></td>
<td>
<p>relative weight (&gt;=0) for the simplicity of <code>B</code></p>
</td></tr>
<tr><td><code id="varimcoco_+3A_wc_rel">wc_rel</code></td>
<td>
<p>relative weight (&gt;=0) for the simplicity of <code>C</code></p>
</td></tr>
<tr><td><code id="varimcoco_+3A_rot1">rot1</code></td>
<td>
<p>binary indicator (1 if the <code>A</code>-mode is rotated, 0 otherwise, default 1)</p>
</td></tr>
<tr><td><code id="varimcoco_+3A_rot2">rot2</code></td>
<td>
<p>binary indicator (1 if the <code>B</code>-mode is rotated, 0 otherwise, default 1)</p>
</td></tr>
<tr><td><code id="varimcoco_+3A_rot3">rot3</code></td>
<td>
<p>binary indicator (1 if the <code>C</code>-mode is rotated, 0 otherwise, default 1)</p>
</td></tr>
<tr><td><code id="varimcoco_+3A_nanal">nanal</code></td>
<td>
<p>Number of random starts, default 5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>
<table>
<tr><td><code>AS</code></td>
<td>
<p>Rotated component matrix for the <code>A</code>-mode</p>
</td></tr>
<tr><td><code>BT</code></td>
<td>
<p>Rotated component matrix for the <code>B</code>-mode</p>
</td></tr>
<tr><td><code>CU</code></td>
<td>
<p>Rotated component matrix for the <code>C</code>-mode</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Rotated matricized core array (frontal slices)</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Rotation matrix for the <code>A</code>-mode</p>
</td></tr> 
<tr><td><code>T</code></td>
<td>
<p>Rotation matrix for the <code>B</code>-mode</p>
</td></tr> 
<tr><td><code>U</code></td>
<td>
<p>Rotation matrix for the <code>C</code>-mode</p>
</td></tr> 
<tr><td><code>f</code></td>
<td>
<p>Best solution for three-way orthomax function value</p>
</td></tr> 
<tr><td><code>f1</code></td>
<td>
<p>Varimax value of <code>H</code></p>
</td></tr>
<tr><td><code>f2a</code></td>
<td>
<p>Varimax value of <code>AS</code></p>
</td></tr> 
<tr><td><code>f2b</code></td>
<td>
<p>Varimax value of <code>BT</code></p>
</td></tr>
<tr><td><code>f2c</code></td>
<td>
<p>Varimax value of <code>CU</code></p>
</td></tr>
<tr><td><code>func</code></td>
<td>
<p>Function values upon convergence for all the runs of the orthomax algorithm</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The simplicity values <code>f1</code>, <code>f2a</code>, <code>f2b</code>, <code>f2c</code> are based on &lsquo;natural&rsquo; 
weigths and therefore comparable across matrices. When multiplied by the relative weights, 
they give the contribution to the overall simplicity value (they are <code>I^2/p</code>, <code>J^2/q</code> or <code>K^2/r</code>, 
respectively, times the sum of the variances of squared values).</p>


<h3>Author(s)</h3>

<p>Maria Antonietta Del Ferraro <a href="mailto:mariaantonietta.delferraro@yahoo.it">mariaantonietta.delferraro@yahoo.it</a> <br /> Henk A.L. Kiers <a href="mailto:h.a.l.kiers@rug.nl">h.a.l.kiers@rug.nl</a> <br /> Paolo Giordani <a href="mailto:paolo.giordani@uniroma1.it">paolo.giordani@uniroma1.it</a></p>


<h3>References</h3>

<p>H.A.L. Kiers (1998). Joint orthomax rotation of the core and component matrices resulting from three-mode principal components analysis. <em>Journal of Classification  15:245&ndash;263</em>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+orthmax2">orthmax2</a></code>, <code><a href="#topic+varim">varim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bus)
# T3 solution
BusT3 &lt;- T3funcrep(Bus, 7, 5, 37, 2, 2, 2, 0, 1e-6)
# Simplicity of A (with weight = 2.5), B (with weight = 2) and C (with weight = 1.5)
T3vmABC &lt;- varimcoco(BusT3$A, BusT3$B, BusT3$C, BusT3$H, 2.5, 2, 1.5)
# Simplicity of only A (with weight = 2.5) and B (with weight = 2)
# rot3=0; the value of wc_rel (= 0) does not play an active role
T3vmAB &lt;- varimcoco(BusT3$A, BusT3$B, BusT3$C, BusT3$H, 2.5, 2, 0, 1, 1, 0)
# simplicity repeatedly with different relative weights for A, B and C
T3vm &lt;- list()
weight.a &lt;- c(1, 3, 6)
weight.b &lt;- c(0, 2, 5)
weight.c &lt;- c(1, 4)
i &lt;- 1
for (wa_rel in weight.a){
 for (wb_rel in weight.b){
  for (wc_rel in weight.c){
   T3vm[[i]] &lt;- varimcoco(BusT3$A, BusT3$B, BusT3$C, 
    BusT3$H, wa_rel, wb_rel, wc_rel)
   i &lt;- i+1
  }
 }
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
