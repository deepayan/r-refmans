<!DOCTYPE html><html><head><title>Help for package cheapr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cheapr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cheapr-package'><p>cheapr: Simple Functions to Save Time and Memory</p></a></li>
<li><a href='#count_val'><p>Count the number of occurrences of a value.</p></a></li>
<li><a href='#factor_'><p>A faster version of <code>factor()</code></p></a></li>
<li><a href='#gcd'><p>Greatest common divisor and smallest common multiple</p></a></li>
<li><a href='#is_na'><p>Efficient functions for dealing with missing values.</p></a></li>
<li><a href='#lag_'><p>Lagged operations.</p></a></li>
<li><a href='#lengths_'><p>List utilities</p></a></li>
<li><a href='#overview'><p>An alternative to <code>summary()</code> inspired by the skimr package</p></a></li>
<li><a href='#recycle'><p>Recycle objects to a common size</p></a></li>
<li><a href='#sequence_'><p>Utilities for creating many sequences</p></a></li>
<li><a href='#set_abs'><p>Math operations by reference - <b>Experimental</b></p></a></li>
<li><a href='#setdiff_'><p>Extra utilities</p></a></li>
<li><a href='#sset'><p>Cheaper subset</p></a></li>
<li><a href='#which_'><p>Memory-efficient alternative to <code>which()</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simple Functions to Save Time and Memory</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nick Christofides &lt;nick.christofides.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and memory-efficient (or 'cheap') tools to facilitate
    efficient programming, saving time and memory. It aims to provide
    'cheaper' alternatives to common base R functions, as well as some
    additional functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NicChr/cheapr/issues">https://github.com/NicChr/cheapr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>collapse (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, data.table, testthat (&ge; 3.0.0), vctrs</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-10 10:10:58 UTC; Nmc5</td>
</tr>
<tr>
<td>Author:</td>
<td>Nick Christofides <a href="https://orcid.org/0000-0002-9743-7342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-11 02:03:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='cheapr-package'>cheapr: Simple Functions to Save Time and Memory</h2><span id='topic+cheapr'></span><span id='topic+cheapr-package'></span>

<h3>Description</h3>

<p>In this package, 'cheap' means fast and efficient.
</p>
<p>cheapr aims to provide a set of functions for programmers to write
cheaper code, saving time and memory.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nick Christofides <a href="mailto:nick.christofides.r@gmail.com">nick.christofides.r@gmail.com</a> (<a href="https://orcid.org/0000-0002-9743-7342">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/NicChr/cheapr/issues">https://github.com/NicChr/cheapr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='count_val'>Count the number of occurrences of a value.</h2><span id='topic+count_val'></span>

<h3>Description</h3>

<p>This is a programmer's version of <code>sum(x == value)</code> to count the number of
occurrences of a value without creating a potentially large logical vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_val(x, value, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_val_+3A_x">x</code></td>
<td>
<p>A vector, list, data frame or matrix.</p>
</td></tr>
<tr><td><code id="count_val_+3A_value">value</code></td>
<td>
<p>A value with which to count the frequency of.</p>
</td></tr>
<tr><td><code id="count_val_+3A_recursive">recursive</code></td>
<td>
<p>Should the function be applied recursively to lists?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of <code>num_na()</code> and as such the identity
<code>count_val(x, NA) == num_na(x)</code> will always hold.
</p>


<h3>Value</h3>

<p>A count of the number of times <code>value</code> appears in <code>x</code>.
</p>

<hr>
<h2 id='factor_'>A faster version of <code>factor()</code></h2><span id='topic+factor_'></span><span id='topic+levels_factor'></span><span id='topic+used_levels'></span><span id='topic+unused_levels'></span>

<h3>Description</h3>

<p>A fast version of <code>factor()</code> using the collapse package.
There are some additional utilities such as
<code>levels_factor()</code> which returns the levels of a factor, as a factor,
<code>used_levels()</code> which returns the used levels of a factor,
and <code>unused_levels()</code> which returns the unused levels of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_(
  x = integer(),
  levels = NULL,
  order = TRUE,
  na_exclude = TRUE,
  ordered = is.ordered(x)
)

levels_factor(x)

used_levels(x)

unused_levels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor__+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="factor__+3A_levels">levels</code></td>
<td>
<p>Optional factor levels.</p>
</td></tr>
<tr><td><code id="factor__+3A_order">order</code></td>
<td>
<p>Should factor levels be sorted? Default is <code>TRUE</code>.
It typically is faster to set this to <code>FALSE</code>, in which case the levels
are sorted by order of first appearance.</p>
</td></tr>
<tr><td><code id="factor__+3A_na_exclude">na_exclude</code></td>
<td>
<p>Should <code>NA</code> values be excluded from the factor levels?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="factor__+3A_ordered">ordered</code></td>
<td>
<p>Should the result be an ordered factor?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operates similarly to <code>collapse::qF()</code>. <br />
The main difference internally is that <code>collapse::funique()</code> is used
and therefore s3 methods can be written for it. <br />
Furthermore, for date-times <code>factor_</code> differs in that it differentiates
all instances in time whereas <code>factor</code> differentiates calendar times.
Using a daylight savings example where the clocks go back: <br />
<code>factor(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 4 levels whereas <br />
<code>factor_(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 5 levels.
</p>


<h3>Value</h3>

<p>A <code>factor</code> or <code>character</code> in the case of <code>used_levels</code> and <code>unused_levels</code>.
</p>

<hr>
<h2 id='gcd'>Greatest common divisor and smallest common multiple</h2><span id='topic+gcd'></span><span id='topic+scm'></span><span id='topic+gcd2'></span><span id='topic+scm2'></span>

<h3>Description</h3>

<p>Fast greatest common divisor and smallest common multiple
using the Euclidean algorithm.
</p>
<p><code>gcd()</code> returns the greatest common divisor. <br />
<code>scm()</code> returns the smallest common multiple. <br />
<code>gcd2()</code> is a vectorised binary version of <code>gcd</code>. <br />
<code>scm2()</code> is a vectorised binary version of <code>scm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd(
  x,
  tol = sqrt(.Machine$double.eps),
  na_rm = TRUE,
  round = TRUE,
  break_early = TRUE
)

scm(x, tol = sqrt(.Machine$double.eps), na_rm = TRUE)

gcd2(x, y, tol = sqrt(.Machine$double.eps), na_rm = TRUE)

scm2(x, y, tol = sqrt(.Machine$double.eps), na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcd_+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+numeric">numeric</a> vector.</p>
</td></tr>
<tr><td><code id="gcd_+3A_tol">tol</code></td>
<td>
<p>Tolerance. This must
be a single positive number strictly less than 1.</p>
</td></tr>
<tr><td><code id="gcd_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code> the default, <code>NA</code> values are ignored.</p>
</td></tr>
<tr><td><code id="gcd_+3A_round">round</code></td>
<td>
<p>If <code>TRUE</code> the output is rounded as
<code>round(gcd, digits)</code> where digits is
<code>ceiling(abs(log10(tol))) + 1</code>. <br />
This can potentially reduce floating point errors on
further calculations. <br />
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_break_early">break_early</code></td>
<td>
<p>This is experimental and
applies only to floating-point numbers.
When <code>TRUE</code> the algorithm will end once <code>gcd &gt; 0 &amp;&amp; gcd &lt; 2 * tol</code>.
This can offer a tremendous speed improvement.
If <code>FALSE</code> the algorithm finishes once it has gone through all elements of <code>x</code>.
The default is <code>TRUE</code>. <br />
For integers, the algorithm always breaks early once <code>gcd &gt; 0 &amp;&amp; gcd &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_y">y</code></td>
<td>
<p>A <a href="base.html#topic+numeric">numeric</a> vector.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>



<h5>GCD</h5>

<p>The GCD is calculated using a binary function that takes input
<code>GCD(gcd, x[i + 1])</code> where the output of this function is passed as input
back into the same function iteratively along the length of <code>x</code>.
The first gcd value is <code>x[1]</code>.
</p>
<p>Zeroes are handled in the following way: <br />
<code>GCD(0, 0) = 0</code> <br />
<code>GCD(a, 0) = a</code> <br />
</p>
<p>This has the nice property that zeroes are essentially ignored.
</p>



<h5>SCM</h5>

<p>This is calculated using the GCD and the formula is: <br />
<code>SCM(x, y) = (abs(x) / GCD(x, y) ) * abs(y)</code>
</p>
<p>If you want to calculate the gcd &amp; lcm for 2 values
or across 2 vectors of values, use <code>gcd2</code> and <code>scm2</code>.
</p>




<h3>Value</h3>

<p>A number representing the GCD or SCM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# Binary versions
gcd2(15, 25)
gcd2(15, seq(5, 25, 5))
scm2(15, seq(5, 25, 5))
scm2(15, 25)

# GCD across a vector
gcd(c(0, 5, 25))
mark(gcd(c(0, 5, 25)))

x &lt;- rnorm(10^5)
gcd(x)
gcd(x, round = FALSE)
mark(gcd(x))
</code></pre>

<hr>
<h2 id='is_na'>Efficient functions for dealing with missing values.</h2><span id='topic+is_na'></span><span id='topic+is_na.default'></span><span id='topic+is_na.POSIXlt'></span><span id='topic+is_na.vctrs_rcrd'></span><span id='topic+is_na.data.frame'></span><span id='topic+num_na'></span><span id='topic+which_na'></span><span id='topic+which_not_na'></span><span id='topic+any_na'></span><span id='topic+all_na'></span><span id='topic+row_na_counts'></span><span id='topic+col_na_counts'></span><span id='topic+row_all_na'></span><span id='topic+col_all_na'></span><span id='topic+row_any_na'></span><span id='topic+col_any_na'></span>

<h3>Description</h3>

<p><code>is_na()</code> is a parallelised alternative to <code>is.na()</code>. <br />
<code>num_na(x)</code> is a faster and more efficient <code>sum(is.na(x))</code>. <br />
<code>which_na(x)</code> is a more efficient <code>which(is.na(x))</code> <br />
<code>which_not_na(x)</code> is a more efficient <code>which(!is.na(x))</code> <br />
<code>row_na_counts(x)</code> is a more efficient <code>rowSums(is.na(x))</code> <br />
<code>row_all_na()</code> returns a logical vector indicating which rows are empty
and have only <code>NA</code> values. <br />
<code>row_any_na()</code> returns a logical vector indicating which rows have at least
1 <code>NA</code> value. <br />
The <code>col_</code> variants are the same, but operate by-column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_na(x)

## Default S3 method:
is_na(x)

## S3 method for class 'POSIXlt'
is_na(x)

## S3 method for class 'vctrs_rcrd'
is_na(x)

## S3 method for class 'data.frame'
is_na(x)

num_na(x, recursive = TRUE)

which_na(x)

which_not_na(x)

any_na(x, recursive = TRUE)

all_na(x, recursive = TRUE)

row_na_counts(x)

col_na_counts(x)

row_all_na(x)

col_all_na(x)

row_any_na(x)

col_any_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_na_+3A_x">x</code></td>
<td>
<p>A vector, list, data frame or matrix.</p>
</td></tr>
<tr><td><code id="is_na_+3A_recursive">recursive</code></td>
<td>
<p>Should the function be applied recursively to lists?
The default is <code>TRUE</code>. Setting this to <code>TRUE</code> is actually much cheaper because
when <code>FALSE</code>, the other <code>NA</code> functions rely on calling <code>is_na()</code>,
therefore allocating a vector. This is so that alternative objects with
<code>is.na</code> methods can be supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed primarily for programmers, to increase the speed
and memory-efficiency of <code>NA</code> handling. <br />
Most of these functions can be parallelised through <code>options(cheapr.cores)</code>. <br />
</p>


<h4>Common use-cases</h4>

<p>To replicate <code>complete.cases(x)</code>, use <code>!row_any_na(x)</code>. <br />
To find rows with any empty values,
use <code>which_(row_any_na(df))</code>. <br />
To find empty rows use <code>which_(row_all_na(df))</code> or <code>which_na(df)</code>.
To drop empty rows use <code>na_rm(df)</code> or <code>sset(df, which_(row_all_na(df), TRUE))</code>.
</p>



<h4><code>is_na</code></h4>

<p><code>is_na</code> Is an S3 generic function. It will internally fall back on
using <code>is.na</code> if it can't find a suitable method.
Alternatively you can write your own <code>is_na</code> method.
For example there is a method for <code>vctrs_rcrd</code>
objects that simply converts it to a data frame and then calls <code>row_all_na()</code>.
There is also a <code>POSIXlt</code> method for <code>is_na</code> that is much faster than <code>is.na</code>.
</p>



<h4>Lists</h4>

<p>When <code>x</code> is a list, <code>num_na</code>, <code>any_na</code> and <code>all_na</code> will recursively search
the list for <code>NA</code> values. If <code>recursive = F</code> then <code>is_na()</code> is used to
find <code>NA</code> values. <br />
<code>is_na</code> differs to <code>is.na</code> in 2 ways:
</p>

<ul>
<li><p> List elements are counted as <code>NA</code> if either that value is <code>NA</code>, or
if it's a list, then all values of that list are <code>NA</code>.
</p>
</li>
<li><p> When called on a data frame, it returns <code>TRUE</code> for empty rows that contain
only <code>NA</code> values.
</p>
</li></ul>




<h3>Value</h3>

<p>Number or location of <code>NA</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

x &lt;- 1:10
x[c(1, 5, 10)] &lt;- NA
num_na(x)
which_na(x)
which_not_na(x)

row_nas &lt;- row_na_counts(airquality)
col_nas &lt;- col_na_counts(airquality)
names(row_nas) &lt;- rownames(airquality)
names(col_nas) &lt;- colnames(airquality)
row_nas
col_nas

df &lt;- airquality[, 1:2]

# Number of NAs in data
num_na(df)
# Which rows are empty?
row_na &lt;- row_all_na(df)
df[which_(row_na), ]

# Removing the empty rows
df[which_(row_na, invert = TRUE), ]

</code></pre>

<hr>
<h2 id='lag_'>Lagged operations.</h2><span id='topic+lag_'></span><span id='topic+lag2_'></span>

<h3>Description</h3>

<p>Fast lags and leads optionally using dynamic vectorised lags, ordering and
run lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_(x, n = 1L, fill = NULL, set = FALSE, recursive = TRUE)

lag2_(
  x,
  n = 1L,
  order = NULL,
  run_lengths = NULL,
  fill = NULL,
  recursive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag__+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="lag__+3A_n">n</code></td>
<td>
<p>Number of lags. Negative values are accepted. <br />
<code>lag2_</code> accepts a vector of dynamic lags and leads
which gets recycled to the length of x.</p>
</td></tr>
<tr><td><code id="lag__+3A_fill">fill</code></td>
<td>
<p>Value used to fill first n values. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="lag__+3A_set">set</code></td>
<td>
<p>Should x be updated by reference? If <code>TRUE</code> no copy is made and
x is updated in place. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lag__+3A_recursive">recursive</code></td>
<td>
<p>Should list elements be lagged as well?
If <code>TRUE</code>, this is useful for data frames and will return row lags.
If <code>FALSE</code> this will return a plain lagged list.</p>
</td></tr>
<tr><td><code id="lag__+3A_order">order</code></td>
<td>
<p>Optionally specify an ordering with which to apply the lags.
This is useful for example when applying lags chronologically using an unsorted
time variable.</p>
</td></tr>
<tr><td><code id="lag__+3A_run_lengths">run_lengths</code></td>
<td>
<p>Optional integer vector of run lengths that defines the size of each
lag run. For example, supplying <code>c(5, 5)</code> applies lags to the first 5 elements and
then essentially resets the bounds and applies lags to the next 5 elements as if
they were an entirely separate and standalone vector. <br />
This is particularly useful in conjunction with the <code>order</code> argument
to perform a by-group lag. See the examples for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most applications, it is more efficient and recommended to use <code>lag_()</code>.
For anything that requires dynamic lags, lag by order of another variable,
or by-group lags, one can use <code>lag2_()</code>. <br />
To do cyclic lags, see the examples below for an implementation.
</p>


<h4><code>lag2_</code></h4>

<p><code>lag2_</code> is a generalised form of <code>lag_</code> that by default performs
simple lags and leads. <br />
It has 3 additional features but does not support updating by reference or
long vectors. <br />
</p>
<p>These extra features include:
</p>

<ul>
<li> <p><code>n</code> - This shares the same name as the <code>n</code> argument in <code>lag_</code>
for consistency. The difference is that <code>lag_</code> accepts a
lag vector of length 1 whereas
this accepts a vector of dynamic lags allowing for
flexible combinations of variable sized lags and leads.
These are recycled to the length of the data and will always align
with the data, meaning that if you supply a custom <code>order</code> argument, this
ordering is applied both to <code>x</code> and the recycled lag vector <code>n</code> simultaneously.
</p>
</li>
<li> <p><code>order</code> - Apply lags in any order you wish. This can be useful for
reverse order lags, lags against unsorted time variables, and by-group lags.
</p>
</li>
<li> <p><code>run_lengths</code> - Specify the size of individual lag runs. For example, if you
specify <code>run_lengths = c(3, 4, 2)</code>, this will apply your lags to the first 3 elements and
then reset, applying lags to the next 4 elements, to reset again and apply lags to the
final 2 elements. Each time the reset occurs, it treats each run length sized 'chunk' as
a unique and separate vector. See the examples for a showcase.
</p>
</li></ul>




<h4>Table of differences between <code>lag_</code> and <code>lag2_</code></h4>


<table>
<tr>
 <td style="text-align: center;">
   Description </td><td style="text-align: center;"> <code>lag_</code> </td><td style="text-align: center;"> <code>lag2_</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   Lags </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Leads </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Long vector support </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> No </td>
</tr>
<tr>
 <td style="text-align: center;">
   Lag by reference </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> No </td>
</tr>
<tr>
 <td style="text-align: center;">
   Dynamic vectorised lags </td><td style="text-align: center;"> No </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Data frame row lags </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Alternative order lags </td><td style="text-align: center;"> No </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>




<h3>Value</h3>

<p>A lagged object the same size as x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# A use-case for data.table
# Adding 0 because can't update ALTREP by reference
df &lt;- data.frame(x = 1:10^5 + 0L)

# Normal data frame lag
sset(lag_(df), 1:10)

# Lag these behind by 3 rows
sset(lag_(df, 3, set = TRUE), 1:10)

df$x[1:10] # x variable was updated by reference!

# The above can be used naturally in data.table to lag data
# without any copies

# To perform regular R row lags, just make sure set is `FALSE`

sset(lag_(as.data.frame(EuStockMarkets), 5), 1:10)

# lag2_ is a generalised version of lag_ that allows
# for much more complex lags

x &lt;- 1:10

# lag every 2nd element
lag2_(x, n = c(1, 0)) # lag vector is recycled

# Explicit Lag(3) using a vector of lags
lags &lt;- lag_sequence(length(x), 3, partial = FALSE)
lag2_(x, n = lags)

# Alternating lags and leads
lag2_(x, c(1, -1))

# Lag only the 3rd element
lags &lt;- integer(length(x))
lags[3] &lt;- 1L
lag2_(x, lags)

# lag in descending order (same as a lead)

lag2_(x, order = 10:1)

# lag that resets after index 5
lag2_(x, run_lengths = c(5, 5))

# lag with a time index
years &lt;- sample(2011:2020)
lag2_(x, order = order(years))

# Example of how to do a cyclical lag
n &lt;- length(x)

# When k &gt;= 0
k &lt;- min(3, n)
lag2_(x, c(rep(-n + k, k), rep(k, n - k)))
# When k &lt; 0
k &lt;- max(-3, -n)
lag2_(x, c(rep(k, n + k), rep(n + k, -k)))

# As it turns out, we can do a grouped lag
# by supplying group sizes as run lengths and group order as the order

set.seed(45)
g &lt;- sample(c("a", "b"), 10, TRUE)

# NOTE: collapse::flag will not work unless g is already sorted!
# This is not an issue with lag2_()
collapse::flag(x, g = g)
lag2_(x, order = order(g), run_lengths = collapse::GRP(g)$group.sizes)

# For production code, we can of course make
# this more optimised by using collapse::radixorderv()
# Which calculates the order and group sizes all at once

o &lt;- collapse::radixorderv(g, group.sizes = TRUE)
lag2_(x, order = o, run_lengths = attr(o, "group.sizes"))

# Let's finally wrap this up in a nice grouped-lag function

grouped_lag &lt;- function(x, n = 1, g = integer(length(x))){
  o &lt;- collapse::radixorderv(g, group.sizes = TRUE, sort = FALSE)
  lag2_(x, n, order = o, run_lengths = attr(o, "group.sizes"))
}

# And voila!
grouped_lag(x, g = g)

# A method to extract this information from dplyr

## We can actually get this information easily from a `grouped_df` object
## Uncomment the below code to run the implementation
# library(dplyr)
# library(timeplyr)
# eu_stock &lt;- EuStockMarkets |&gt;
#   ts_as_tibble() |&gt;
#   group_by(stock_index = group)
# groups &lt;- group_data(eu_stock) # Group information
# group_order &lt;- unlist(groups$.rows) # Order of groups
# group_sizes &lt;- lengths_(groups$.rows) # Group sizes
#
# # by-stock index lag
# lag2_(eu_stock$value, order = group_order, run_lengths = group_sizes)
#
# # Verifying this output is correct
# eu_stock |&gt;
#   ungroup() |&gt;
#   mutate(lag1 = lag_(value), .by = stock_index) |&gt;
#   mutate(lag2 = lag2_(value, order = group_order, run_lengths = group_sizes)) |&gt;
#   summarise(lags_are_equal = identical(lag1, lag2))

# Let's compare this to data.table

library(data.table)
default_threads &lt;- getDTthreads()
setDTthreads(1)
dt &lt;- data.table(x = 1:10^5,
                 g = sample.int(10^4, 10^5, TRUE))

bench::mark(dt[, y := shift(x), by = g][][["y"]],
            grouped_lag(dt$x, g = dt$g),
            iterations = 10)
setDTthreads(default_threads)
</code></pre>

<hr>
<h2 id='lengths_'>List utilities</h2><span id='topic+lengths_'></span><span id='topic+unlisted_length'></span><span id='topic+new_list'></span>

<h3>Description</h3>

<p>Functions to help work with lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lengths_(x)

unlisted_length(x)

new_list(length = 0L, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lengths__+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="lengths__+3A_length">length</code></td>
<td>
<p>Length of list.</p>
</td></tr>
<tr><td><code id="lengths__+3A_default">default</code></td>
<td>
<p>Default value for each list element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lengths_()</code> returns the list lengths. <br />
<code>unlisted_length()</code> is an alternative to <code>length(unlist(x))</code>. <br />
<code>new_list()</code> is like <code>vector("list", length)</code> but also allows you to specify
a default value for each list element. This can be useful for
initialising with a catch-all value so that when you unlist you're guaranteed
a list of length &gt;= to the specified length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
l &lt;- list(1:10,
          NULL,
          list(integer(), NA_integer_, 2:10))

lengths_(l) # Faster lengths()
unlisted_length(l) # length of vector if we unlist
paste0("length: ", length(print(unlist(l))))

unlisted_length(l) - num_na(l) # Number of non-NA elements

# We can create and initialise a new list with a default value
l &lt;- new_list(20, 0L)
l[1:5]
# This works well with vctrs_list_of objects
vctrs::new_list_of(l, ptype = integer())[1:5]
</code></pre>

<hr>
<h2 id='overview'>An alternative to <code>summary()</code> inspired by the skimr package</h2><span id='topic+overview'></span><span id='topic+overview.default'></span><span id='topic+overview.logical'></span><span id='topic+overview.numeric'></span><span id='topic+overview.character'></span><span id='topic+overview.factor'></span><span id='topic+overview.Date'></span><span id='topic+overview.POSIXt'></span><span id='topic+overview.ts'></span><span id='topic+overview.zoo'></span><span id='topic+overview.data.frame'></span>

<h3>Description</h3>

<p>A cheaper <code>summary()</code> function, designed for larger data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## Default S3 method:
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'logical'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'numeric'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'character'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'factor'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'Date'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'POSIXt'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'ts'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'zoo'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'data.frame'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overview_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="overview_+3A_hist">hist</code></td>
<td>
<p>Should in-line histograms be returned? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="overview_+3A_digits">digits</code></td>
<td>
<p>How many decimal places should the summary statistics be
printed as? Default is 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No rounding of statistics is done except in printing which can be controlled
either through the <code>digits</code> argument in <code>overview()</code>, or by setting the
option <code>options(cheapr.digits)</code>. <br />
To access the underlying data, for example the numeric summary,
just use <code style="white-space: pre;">&#8288;$numeric&#8288;</code>, e.g. <code>overview(rnorm(30))$numeric</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;overview&quot;.
Under the hood this is just a list of data frames.
Key summary statistics are reported in each data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
overview(iris)

# With histograms
overview(airquality, hist = TRUE)

# Round to 0 decimal places
overview(airquality, digits = 0)

# We can set an option for all overviews
options(cheapr.digits = 1)
overview(rnorm(100))
options(cheapr.digits = 2) # The default
</code></pre>

<hr>
<h2 id='recycle'>Recycle objects to a common size</h2><span id='topic+recycle'></span>

<h3>Description</h3>

<p>A convenience function to recycle R objects to either a common or specified
size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle(..., length = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recycle_+3A_...">...</code></td>
<td>
<p>Objects to recycle.</p>
</td></tr>
<tr><td><code id="recycle_+3A_length">length</code></td>
<td>
<p>Optional length to recycle objects to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data frames are recycled by recycling their rows. <br />
<code>recycle()</code> is optimised to only recycle objects that need recycling. <br />
<code>NULL</code> objects are ignored and not recycled or returned.
</p>


<h3>Value</h3>

<p>A list of recycled R objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)

recycle(Sys.Date(), 1:10)

# Any vectors of zero-length are all recycled to zero-length
recycle(integer(), 1:10)

# Data frame rows are recycled
recycle(sset(iris, 1:3), length = 3 * 3)

# To recycle list items, use `do.call()`
my_list &lt;- list(from = 1L, to = 10L, by = seq(0.1, 1, 0.1))
do.call(recycle, my_list)

</code></pre>

<hr>
<h2 id='sequence_'>Utilities for creating many sequences</h2><span id='topic+sequence_'></span><span id='topic+seq_id'></span><span id='topic+seq_'></span><span id='topic+seq_size'></span><span id='topic+window_sequence'></span><span id='topic+lag_sequence'></span><span id='topic+lead_sequence'></span>

<h3>Description</h3>

<p><code>sequence_</code> is an extension to <a href="base.html#topic+sequence">sequence</a> which
accepts decimal number increments. <br />
<code>seq_id</code> can be paired with <code>sequence_</code> to group individual sequences. <br />
<code>seq_</code> is a vectorised version of <a href="base.html#topic+seq">seq</a>. <br />
<code>window_sequence</code> creates a vector of window sizes for rolling calculations. <br />
<code>lag_sequence</code> creates a vector of lags for rolling calculations. <br />
<code>lead_sequence</code> creates a vector of leads for rolling calculations. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_(size, from = 1L, by = 1L, add_id = FALSE)

seq_id(size)

seq_(from = 1L, to = 1L, by = 1L, add_id = FALSE)

seq_size(from, to, by = 1L)

window_sequence(size, k, partial = TRUE, ascending = TRUE, add_id = FALSE)

lag_sequence(size, k, partial = TRUE, add_id = FALSE)

lead_sequence(size, k, partial = TRUE, add_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequence__+3A_size">size</code></td>
<td>
<p>Vector of sequence lengths.</p>
</td></tr>
<tr><td><code id="sequence__+3A_from">from</code></td>
<td>
<p>Start of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_by">by</code></td>
<td>
<p>Unit increment of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_add_id">add_id</code></td>
<td>
<p>Should the ID numbers of the sequences be added as names?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sequence__+3A_to">to</code></td>
<td>
<p>End of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_k">k</code></td>
<td>
<p>Window/lag size.</p>
</td></tr>
<tr><td><code id="sequence__+3A_partial">partial</code></td>
<td>
<p>Should partial windows/lags be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sequence__+3A_ascending">ascending</code></td>
<td>
<p>Should window sequence be ascending? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sequence_()</code> works in the same way as <code>sequence()</code> but can accept
non-integer <code>by</code> values.
It also recycles <code>from</code> and <code>to</code>, in the same way as <code>sequence()</code>. <br />
If any of the sequences contain values &gt; <code>.Machine$integer.max</code>,
then the result will always be a double vector.
</p>
<p><code>from</code> can be also be a date, date-time, or any object that supports
addition and multiplication.
</p>
<p><code>seq_()</code> is a vectorised version of <code>seq()</code> that strictly accepts
only the arguments <code>from</code>, <code>to</code> and <code>by</code>. <br />
</p>


<h3>Value</h3>

<p>A vector of length <code>sum(size)</code> except for <code>seq_</code> which
returns a vector of size <code>sum((to - from) / (by + 1))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
sequence(1:3)
sequence_(1:3)

sequence(1:3, by = 0.1)
sequence_(1:3, by = 0.1)

# Add IDs to the sequences
sequence_(1:3, by = 0.1, add_id = TRUE)
# Turn this quickly into a data frame
enframe_(sequence_(1:3, by = 0.1, add_id = TRUE))

sequence(c(3, 2), by = c(-0.1, 0.1))
sequence_(c(3, 2), by = c(-0.1, 0.1))


# Vectorised version of seq()
seq_(1, 10, by = c(1, 0.5))
# Same as below
c(seq(1, 10, 1), seq(1, 10, 0.5))

# Programmers may use seq_size() to determine final sequence lengths

sizes &lt;- seq_size(1, 10, by = c(1, 0.5))
print(paste(c("sequence sizes: (", sizes, ") total size:", sum(sizes)),
            collapse = " "))

# We can group sequences using seq_id

from &lt;- Sys.Date()
to &lt;- from + 10
by &lt;- c(1, 2, 3)
x &lt;- seq_(from, to, by, add_id = TRUE)
class(x) &lt;- "Date"
x

# Utilities for rolling calculations

window_sequence(c(3, 5), 3)
window_sequence(c(3, 5), 3, partial = FALSE)
window_sequence(c(3, 5), 3, partial = TRUE, ascending = FALSE)
# One can for example use these in data.table::frollsum

</code></pre>

<hr>
<h2 id='set_abs'>Math operations by reference - <b>Experimental</b></h2><span id='topic+set_abs'></span><span id='topic+set_floor'></span><span id='topic+set_ceiling'></span><span id='topic+set_trunc'></span><span id='topic+set_exp'></span><span id='topic+set_sqrt'></span><span id='topic+set_change_sign'></span><span id='topic+set_round'></span><span id='topic+set_log'></span><span id='topic+set_pow'></span><span id='topic+set_add'></span><span id='topic+set_subtract'></span><span id='topic+set_multiply'></span><span id='topic+set_divide'></span>

<h3>Description</h3>

<p>These functions transform your variable by reference, with no copies being made.
It is advisable to only use these if you know what you are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_abs(x)

set_floor(x)

set_ceiling(x)

set_trunc(x)

set_exp(x)

set_sqrt(x)

set_change_sign(x)

set_round(x, digits = 0)

set_log(x, base = exp(1))

set_pow(x, y)

set_add(x, y)

set_subtract(x, y)

set_multiply(x, y)

set_divide(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_abs_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="set_abs_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to.</p>
</td></tr>
<tr><td><code id="set_abs_+3A_base">base</code></td>
<td>
<p>Logarithm base.</p>
</td></tr>
<tr><td><code id="set_abs_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are particularly useful for situations
where you have made a copy and then
wish to perform further operations without creating more copies. <br />
<code>NA</code> and <code>NaN</code> values are ignored though in some instances <code>NaN</code> values may
be replaced with <code>NA</code>.
These functions will <b>not work</b> on <b>any</b> classed objects, meaning they
only work on standard integer and numeric vectors and matrices. <br />
</p>


<h4>When a copy has to be made</h4>

<p>A copy is only made in certain instances, e.g. when passing an integer vector
to <code>set_log()</code>. A warning will always be thrown in this instance alerting the user
to assign the output to an object because <code>x</code> has not been updated by reference. <br />
To ensure consistent and expected outputs, always assign the output to the same object, <br /> e.g.
<code>x &lt;- set_log(x)</code> (<b>do this</b>) <br />
<code>set_log(x)</code> (<b>don't do this</b>) <br />
<code>x2 &lt;- set_log(x)</code> (Don't do this either) <br />
<br /> No copy is made here unless x is an integer vector.
</p>



<h3>Value</h3>

<p>The exact same object with no copy made, just transformed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

x &lt;- rnorm(2e05)
options(cheapr.cores = 2)
mark(
  base = exp(log(abs(x))),
  cheapr = set_exp(set_log(set_abs(x)))
)
options(cheapr.cores = 1)

</code></pre>

<hr>
<h2 id='setdiff_'>Extra utilities</h2><span id='topic+setdiff_'></span><span id='topic+intersect_'></span><span id='topic+cut_numeric'></span><span id='topic++25in_+25'></span><span id='topic++25+21in_+25'></span><span id='topic+enframe_'></span><span id='topic+deframe_'></span><span id='topic+na_rm'></span><span id='topic+sample_'></span>

<h3>Description</h3>

<p>Extra utilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setdiff_(x, y, dups = TRUE)

intersect_(x, y, dups = TRUE)

cut_numeric(
  x,
  breaks,
  labels = NULL,
  include.lowest = FALSE,
  right = TRUE,
  dig.lab = 3L,
  ordered_result = FALSE,
  ...
)

x %in_% table

x %!in_% table

enframe_(x, name = "name", value = "value")

deframe_(x)

na_rm(x)

sample_(x, size = cpp_vec_length(x), replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setdiff__+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_dups">dups</code></td>
<td>
<p>Should duplicates be kept? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_breaks">breaks</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_labels">labels</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_include.lowest">include.lowest</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_right">right</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_dig.lab">dig.lab</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_ordered_result">ordered_result</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_...">...</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_table">table</code></td>
<td>
<p>See <code>?collapse::fmatch</code></p>
</td></tr>
<tr><td><code id="setdiff__+3A_name">name</code></td>
<td>
<p>The column name to assign the names of a vector.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_value">value</code></td>
<td>
<p>The column name to assign the values of a vector.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_size">size</code></td>
<td>
<p>See <code>?sample</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_replace">replace</code></td>
<td>
<p>See <code>?sample</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_prob">prob</code></td>
<td>
<p>See <code>?sample</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>intersect_()</code> and <code>setdiff_()</code> are faster and more efficient
alternatives to <code>intersect()</code> and <code>setdiff()</code> respectively. <br />
<code>enframe_()</code> and <code>deframe_()</code> are faster alternatives to
<code>tibble::enframe()</code> and <code>tibble::deframe()</code> respectively. <br />
<code>cut_numeric()</code> is a faster and more efficient alternative to
<code>cut.default()</code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;enframe()_&#8288;</code> converts a vector to a data frame. <br />
<code style="white-space: pre;">&#8288;deframe()_&#8288;</code> converts a 1-2 column data frame to a vector. <br />
<code>intersect_()</code> returns a vector of common values between <code>x</code> and <code>y</code>. <br />
<code>setdiff_()</code> returns a vector of values in <code>x</code> but not <code>y</code>. <br />
<code>cut_numeric()</code> places values of a numeric vector into buckets, defined
through the <code>breaks</code> argument and returns a factor unless <code>labels = FALSE</code>,
in which case an integer vector of break indices is returned. <br />
<code style="white-space: pre;">&#8288;%in_%&#8288;</code> and <code style="white-space: pre;">&#8288;%!in_%&#8288;</code> both return a logical vector signifying if the values of
<code>x</code> exist or don't exist in <code>table</code> respectively. <br />
<code>na_rm()</code> is a convenience function that removes <code>NA</code> values and
empty rows in the case of data frames.
For more advanced <code>NA</code> handling, see <code>?is_na</code>. <br />
<code>sample_()</code> is an alternative to <code>sample()</code> that natively samples
data frame rows through <code>sset()</code>. It also does not have a special case when
<code>length(x)</code> is 1.
</p>

<hr>
<h2 id='sset'>Cheaper subset</h2><span id='topic+sset'></span><span id='topic+sset.Date'></span><span id='topic+sset.POSIXct'></span><span id='topic+sset.factor'></span><span id='topic+sset.data.frame'></span><span id='topic+sset.tbl_df'></span><span id='topic+sset.POSIXlt'></span><span id='topic+sset.data.table'></span><span id='topic+sset.sf'></span>

<h3>Description</h3>

<p>Cheaper alternative to <code>[</code> that consistently subsets data frame
rows, always returning a data frame. There are explicit methods for
enhanced data frames like tibbles, data.tables and sf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sset(x, ...)

## S3 method for class 'Date'
sset(x, i, ...)

## S3 method for class 'POSIXct'
sset(x, i, ...)

## S3 method for class 'factor'
sset(x, i, ...)

## S3 method for class 'data.frame'
sset(x, i, j, ...)

## S3 method for class 'tbl_df'
sset(x, i, j, ...)

## S3 method for class 'POSIXlt'
sset(x, i, j, ...)

## S3 method for class 'data.table'
sset(x, i, j, ...)

## S3 method for class 'sf'
sset(x, i, j, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sset_+3A_x">x</code></td>
<td>
<p>Vector or data frame.</p>
</td></tr>
<tr><td><code id="sset_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>[</code>.</p>
</td></tr>
<tr><td><code id="sset_+3A_i">i</code></td>
<td>
<p>A logical or vector of indices. <br /></p>
</td></tr>
<tr><td><code id="sset_+3A_j">j</code></td>
<td>
<p>Column indices, names or logical vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sset</code> is an S3 generic.
You can either write methods for <code>sset</code> or <code>[</code>. <br />
<code>sset</code> will fall back on using <code>[</code> when no suitable method is found.
</p>
<p>To get into more detail, using <code>sset()</code> on a data frame, a new
list is always allocated through <code>new_list()</code>.
</p>


<h4>Difference to base R</h4>

<p>When <code>i</code> is a logical vector, it is passed directly to <code>which_()</code>. <br />
This means that <code>NA</code> values are ignored and this also means that <code>i</code>
is not recycled, so it is good practice to make sure the logical vector
matches the length of x. To return <code>NA</code> values, use <code>sset(x, NA_integer_)</code>.
</p>



<h4>ALTREP range subsetting</h4>

<p>When <code>i</code> is an ALTREP compact sequence which can be commonly created
using e.g. <code>1:10</code> or using <code>seq_len</code>, <code>seq_along</code> and <code>seq.int</code>,
<code>sset</code> internally uses a range-based subsetting method which is faster and doesn't
allocate <code>i</code> into memory.
</p>



<h3>Value</h3>

<p>A new vector, data frame, list, matrix or other R object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# Selecting columns
sset(airquality, j = "Temp")
sset(airquality, j = 1:2)

# Selecting rows
sset(iris, 1:5)

# Rows and columns
sset(iris, 1:5, 1:5)
sset(iris, iris$Sepal.Length &gt; 7, c("Species", "Sepal.Length"))

# Comparison against base
x &lt;- rnorm(10^4)

mark(x[1:10^3], sset(x, 1:10^3))
mark(x[x &gt; 0], sset(x, x &gt; 0))

df &lt;- data.frame(x = x)

mark(df[df$x &gt; 0, , drop = FALSE],
     sset(df, df$x &gt; 0),
     check = FALSE) # Row names are different


## EXTRA: An easy way to incorporate cheapr into dplyr's filter()
# cheapr_filter &lt;- function(.data, ..., .by = NULL, .preserve = FALSE){
#   filter_df &lt;- .data |&gt;
#     dplyr::mutate(..., .by = {{ .by }}, .keep = "none")
#   groups &lt;- dplyr::group_vars(filter_df)
#   filter_df &lt;- cheapr::sset(filter_df, j = setdiff(names(filter_df), groups))
#   n_filters &lt;- ncol(filter_df)
#   if (n_filters &lt; 1){
#     .data
#   } else {
#     dplyr::dplyr_row_slice(.data, cheapr::which_(Reduce(`&amp;`, filter_df)),
#                            preserve = .preserve)
#   }
# }
</code></pre>

<hr>
<h2 id='which_'>Memory-efficient alternative to <code>which()</code></h2><span id='topic+which_'></span>

<h3>Description</h3>

<p>Exactly the same as <code>which()</code> but more memory efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_(x, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which__+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+logical">logical</a> vector.</p>
</td></tr>
<tr><td><code id="which__+3A_invert">invert</code></td>
<td>
<p>If <code>TRUE</code>, indices of values that are not <code>TRUE</code> are returned
(including <code>NA</code>). If <code>FALSE</code> (the default), only <code>TRUE</code> indices are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is similar in speed to <code>which()</code>
but usually more memory efficient.
</p>


<h3>Value</h3>

<p>An unnamed integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)
x &lt;- sample(c(TRUE, FALSE), 1e05, TRUE)
x[sample.int(1e05, round(1e05/3))] &lt;- NA

mark(which_(TRUE), which(TRUE))
mark(which_(FALSE), which(FALSE))
mark(which_(logical()), which(logical()))
mark(which_(x), which(x), iterations = 20)
mark(base = which(is.na(match(x, TRUE))),
     collapse = collapse::whichv(x, TRUE, invert = TRUE),
     cheapr = which_(x, invert = TRUE),
     iterations = 20)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
