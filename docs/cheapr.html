<!DOCTYPE html><html lang="en"><head><title>Help for package cheapr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cheapr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cheapr-package'><p>cheapr: Simple Functions to Save Time and Memory</p></a></li>
<li><a href='#as_discrete'><p>Turn continuous data into discrete bins</p></a></li>
<li><a href='#bin'><p>A sometimes cheaper but argument richer alternative to <code>.bincode()</code></p></a></li>
<li><a href='#case'><p>A cheapr case-when and switch</p></a></li>
<li><a href='#cheapr_if_else'><p>Cheaper version of <code>ifelse()</code></p></a></li>
<li><a href='#cheapr_table'><p>Fast frequency tables - Still experimental</p></a></li>
<li><a href='#factor_'><p>A cheaper version of <code>factor()</code> along with cheaper utilities</p></a></li>
<li><a href='#gcd'><p>Greatest common divisor and smallest common multiple</p></a></li>
<li><a href='#get_breaks'><p>Pretty break-points for continuous (numeric) data</p></a></li>
<li><a href='#int_sign'><p>A fast and integer-based <code>sign()</code></p></a></li>
<li><a href='#is_na'><p>Efficient functions for dealing with missing values.</p></a></li>
<li><a href='#lag_'><p>Lagged operations.</p></a></li>
<li><a href='#lengths_'><p>List utilities</p></a></li>
<li><a href='#named_list'><p>Turn dot-dot-dot (<code>...</code>) into a named list</p></a></li>
<li><a href='#new_df'><p>Fast data frame constructors</p></a></li>
<li><a href='#overview'><p>An alternative to <code>summary()</code> inspired by the skimr package</p></a></li>
<li><a href='#recycle'><p>Recycle objects to a common size</p></a></li>
<li><a href='#sequence_'><p>Utilities for creating many sequences</p></a></li>
<li><a href='#set_abs'><p>Math operations by reference - <b>Experimental</b></p></a></li>
<li><a href='#setdiff_'><p>Extra utilities</p></a></li>
<li><a href='#sset'><p>Cheaper subset</p></a></li>
<li><a href='#sset_df'><p>Fast functions for data frame subsetting</p></a></li>
<li><a href='#val_count'><p>Efficient functions for counting, finding, replacing and removing scalars</p></a></li>
<li><a href='#which_'><p>Memory-efficient alternative to <code>which()</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simple Functions to Save Time and Memory</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nick Christofides &lt;nick.christofides.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and memory-efficient (or 'cheap') tools to facilitate
    efficient programming, saving time and memory. It aims to provide
    'cheaper' alternatives to common base R functions, as well as some
    additional functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NicChr/cheapr/issues">https://github.com/NicChr/cheapr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>collapse (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, data.table, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 06:36:55 UTC; Nmc5</td>
</tr>
<tr>
<td>Author:</td>
<td>Nick Christofides <a href="https://orcid.org/0000-0002-9743-7342"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-13 07:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='cheapr-package'>cheapr: Simple Functions to Save Time and Memory</h2><span id='topic+cheapr'></span><span id='topic+cheapr-package'></span>

<h3>Description</h3>

<p>In this package, 'cheap' means fast and efficient.
</p>
<p>cheapr aims to provide a set of functions for programmers to write
cheaper code, saving time and memory.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nick Christofides <a href="mailto:nick.christofides.r@gmail.com">nick.christofides.r@gmail.com</a> (<a href="https://orcid.org/0000-0002-9743-7342">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/NicChr/cheapr/issues">https://github.com/NicChr/cheapr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_discrete'>Turn continuous data into discrete bins</h2><span id='topic+as_discrete'></span><span id='topic+as_discrete.numeric'></span><span id='topic+as_discrete.integer64'></span>

<h3>Description</h3>

<p>This is a cheapr version of <code>cut.numeric()</code> which is more efficient and
prioritises pretty-looking breaks by default through
the use of <code>get_breaks()</code>.
Out-of-bounds values can be included naturally through the
<code>include_oob</code> argument. Left-closed (right-open) intervals are
returned by default in contrast to cut's default right-closed intervals.
Furthermore there is flexibility in formatting the interval bins,
allowing the user to specify formatting functions and symbols for
the interval close and open symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_discrete(x, ...)

## S3 method for class 'numeric'
as_discrete(
  x,
  breaks = if (left_closed) get_breaks(x) else cheapr_rev(-get_breaks(-x)),
  left_closed = TRUE,
  include_endpoint = FALSE,
  include_oob = FALSE,
  ordered = FALSE,
  intv_start_fun = prettyNum,
  intv_end_fun = prettyNum,
  intv_closers = c("[", "]"),
  intv_openers = c("(", ")"),
  intv_sep = ",",
  inf_label = NULL,
  ...
)

## S3 method for class 'integer64'
as_discrete(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_discrete_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_...">...</code></td>
<td>
<p>Extra arguments passed onto methods.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_breaks">breaks</code></td>
<td>
<p>Break-points.
The default option creates pretty looking breaks.
Unlike <code>cut()</code>, the <code>breaks</code> arg cannot be a number denoting the number
of breaks you want. To generate breakpoints this way use <code>get_breaks()</code>.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_left_closed">left_closed</code></td>
<td>
<p>Left-closed intervals or right-closed intervals?</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_include_endpoint">include_endpoint</code></td>
<td>
<p>Include endpoint? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_include_oob">include_oob</code></td>
<td>
<p>Include out-of-bounds values? Default is <code>FALSE</code>.
This is equivalent to <code>breaks = c(breaks, Inf)</code> or
<code>breaks = c(-Inf, breaks)</code> when <code>left_closed = FALSE</code>.
If <code>include_endpoint = TRUE</code>, the endpoint interval is prioritised before
the out-of-bounds interval.
This behaviour cannot be replicated easily with <code>cut()</code>.
For example, these 2 expressions are not equivalent: <br />
</p>
<pre>cut(10, c(9, 10, Inf), right = F, include.lowest = T) !=
as_discrete(10, c(9, 10), include_endpoint = T, include_oob = T)</pre></td></tr>
<tr><td><code id="as_discrete_+3A_ordered">ordered</code></td>
<td>
<p>Should result be an ordered factor? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_intv_start_fun">intv_start_fun</code></td>
<td>
<p>Function used to format interval start points.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_intv_end_fun">intv_end_fun</code></td>
<td>
<p>Function used to format interval end points.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_intv_closers">intv_closers</code></td>
<td>
<p>A length 2 character vector denoting the symbol
to use for closing either left or right closed intervals.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_intv_openers">intv_openers</code></td>
<td>
<p>A length 2 character vector denoting the symbol to
use for opening either left or right closed intervals.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_intv_sep">intv_sep</code></td>
<td>
<p>A length 1 character vector used to separate the start and
end points.</p>
</td></tr>
<tr><td><code id="as_discrete_+3A_inf_label">inf_label</code></td>
<td>
<p>Label to use for intervals that include infinity.
If left <code>NULL</code> the Unicode infinity symbol is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor of discrete bins (intervals of start/end pairs).
</p>


<h3>See Also</h3>

<p><a href="#topic+bin">bin</a> <a href="#topic+get_breaks">get_breaks</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)

# `as_discrete()` is very similar to `cut()`
# but more flexible as it allows you to supply
# formatting functions and symbols for the discrete bins

# Here is an example of how to use the formatting functions to
# categorise age groups nicely

ages &lt;- 1:100

age_group &lt;- function(x, breaks){
  age_groups &lt;- as_discrete(
    x,
    breaks = breaks,
    intv_sep = "-",
    intv_end_fun = function(x) x - 1,
    intv_openers = c("", ""),
    intv_closers = c("", ""),
    include_oob = TRUE,
    ordered = TRUE
  )

  # Below is just renaming the last age group

  lvls &lt;- levels(age_groups)
  n_lvls &lt;- length(lvls)
  max_ages &lt;- paste0(max(breaks), "+")
  attr(age_groups, "levels") &lt;- c(lvls[-n_lvls], max_ages)
  age_groups
}

age_group(ages, seq(0, 80, 20))
age_group(ages, seq(0, 25, 5))
age_group(ages, 5)

# To closely replicate `cut()` with `as_discrete()` we can use the following

cheapr_cut &lt;- function(x, breaks, right = TRUE,
                       include.lowest = FALSE,
                       ordered.result = FALSE){
  if (length(breaks) == 1){
    breaks &lt;- get_breaks(x, breaks, pretty = FALSE,
                         expand_min = FALSE, expand_max = FALSE)
    adj &lt;- diff(range(breaks)) * 0.001
    breaks[1] &lt;- breaks[1] - adj
    breaks[length(breaks)] &lt;- breaks[length(breaks)] + adj
  }
  as_discrete(x, breaks, left_closed = !right,
              include_endpoint = include.lowest,
              ordered = ordered.result,
              intv_start_fun = function(x) formatC(x, digits = 3, width = 1),
              intv_end_fun = function(x) formatC(x, digits = 3, width = 1))
}

x &lt;- rnorm(100)
cheapr_cut(x, 10)
identical(cut(x, 10), cheapr_cut(x, 10))

</code></pre>

<hr>
<h2 id='bin'>A sometimes cheaper but argument richer alternative to <code>.bincode()</code></h2><span id='topic+bin'></span>

<h3>Description</h3>

<p>When <code>x</code> is an integer vector, <code>bin()</code> is cheaper than <code>.bincode()</code> as
no coercion to a double vector occurs. This alternative also has more
arguments that allow you to return the start values of the binned vector,
as well as including out-of-bounds intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin(
  x,
  breaks,
  left_closed = TRUE,
  include_endpoint = FALSE,
  include_oob = FALSE,
  codes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="bin_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of breaks.</p>
</td></tr>
<tr><td><code id="bin_+3A_left_closed">left_closed</code></td>
<td>
<p>Should intervals be left-closed (and right-open)?
Default is <code>TRUE</code>. If <code>FALSE</code> they are left-open (and right-closed).</p>
</td></tr>
<tr><td><code id="bin_+3A_include_endpoint">include_endpoint</code></td>
<td>
<p>Equivalent to <code>include.lowest</code> in  <code>?.bincode</code>.</p>
</td></tr>
<tr><td><code id="bin_+3A_include_oob">include_oob</code></td>
<td>
<p>Should out-of-bounds interval be included?
Default is <code>FALSE</code>. This is the equivalent of adding <code>Inf</code> as
the last value of the breaks, or <code>-Inf</code> as the
first value of the breaks if <code>left_closed = FALSE</code>. When <code>TRUE</code>,
this essentially becomes <code>findInterval()</code>.</p>
</td></tr>
<tr><td><code id="bin_+3A_codes">codes</code></td>
<td>
<p>Should an integer vector indicating which bin the values
fall into be returned? Default is <code>TRUE</code>. If <code>FALSE</code> the
start values of the respective bin intervals are returned, i.e the
corresponding breaks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either an integer vector of codes indicating which bin the values fall
into, or the start of the intervals for which each value falls into.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_breaks">get_breaks</a> <a href="#topic+as_discrete">as_discrete</a>
</p>

<hr>
<h2 id='case'>A cheapr case-when and switch</h2><span id='topic+case'></span><span id='topic+val_match'></span>

<h3>Description</h3>

<p><code>case</code> and <code>val_match</code> are cheaper alternatives to <code>dplyr::case_when</code> and
<code>dplyr::case_match</code> respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case(..., .default = NULL)

val_match(.x, ..., .default = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="case_+3A_...">...</code></td>
<td>
<p>Logical expressions or scalar values in the case of <code>val_match</code>.</p>
</td></tr>
<tr><td><code id="case_+3A_.default">.default</code></td>
<td>
<p>Catch-all value or vector.</p>
</td></tr>
<tr><td><code id="case_+3A_.x">.x</code></td>
<td>
<p>Vector used to switch values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>val_match()</code> is a very efficient special case of the
<code>case()</code> function when all lhs expressions are scalars,
i.e. length-1 vectors. RHS expressions can be vectors the
same length as <code>.x</code>.
The below 2 expressions are equivalent.
</p>
<pre>
val_match(
  x,
  1 ~ "one",
  2 ~ "two",
  .default = "Unknown"
 )
case(
  x == 1 ~ "one",
  x == 2 ~ "two",
  .default = "Unknown"
 )
</pre>


<h3>Value</h3>

<p>A vector the same length as <code>.x</code> or same length as the first condition in the
case of <code>case</code>, unless the condition length is smaller than the
rhs, in which case the length of the rhs is used.
</p>


<h3>See Also</h3>

<p><a href="#topic+cheapr_if_else">cheapr_if_else</a>
</p>

<hr>
<h2 id='cheapr_if_else'>Cheaper version of <code>ifelse()</code></h2><span id='topic+cheapr_if_else'></span>

<h3>Description</h3>

<p>Cheaper version of <code>ifelse()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheapr_if_else(condition, true, false, na = false[NA_integer_])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cheapr_if_else_+3A_condition">condition</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> A condition which will be used to
evaluate the if else operation.</p>
</td></tr>
<tr><td><code id="cheapr_if_else_+3A_true">true</code></td>
<td>
<p>Value(s) to replace <code>TRUE</code> instances.</p>
</td></tr>
<tr><td><code id="cheapr_if_else_+3A_false">false</code></td>
<td>
<p>Value(s) to replace <code>FALSE</code> instances.</p>
</td></tr>
<tr><td><code id="cheapr_if_else_+3A_na">na</code></td>
<td>
<p>Catch-all value(s) to replace all other instances,
where <code>is.na(condition)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as condition,
using a common type between <code>true</code>, <code>false</code> and <code>default</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+case">case</a> <a href="#topic+val_match">val_match</a>
</p>

<hr>
<h2 id='cheapr_table'>Fast frequency tables - Still experimental</h2><span id='topic+cheapr_table'></span>

<h3>Description</h3>

<p>This is not a one-to-one copy of <code>base::table()</code> as some behaviours differ.
It is more flexible as it accepts inputs such as data frames and
<code>vctrs_rcrd</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cheapr_table(
  ...,
  names = TRUE,
  order = FALSE,
  na_exclude = FALSE,
  classed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cheapr_table_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&gt;=1&#8288;</code> objects that can be converted to a factor through
<code>cheapr::factor_()</code>.</p>
</td></tr>
<tr><td><code id="cheapr_table_+3A_names">names</code></td>
<td>
<p>Should level names be kept? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cheapr_table_+3A_order">order</code></td>
<td>
<p>Should result be ordered by level names? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cheapr_table_+3A_na_exclude">na_exclude</code></td>
<td>
<p>Should <code>NA</code> values be excluded? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cheapr_table_+3A_classed">classed</code></td>
<td>
<p>Should a <code>table</code> object be returned? Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named integer vector if one object is supplied, otherwise an
array.
</p>

<hr>
<h2 id='factor_'>A cheaper version of <code>factor()</code> along with cheaper utilities</h2><span id='topic+factor_'></span><span id='topic+as_factor'></span><span id='topic+levels_factor'></span><span id='topic+levels_used'></span><span id='topic+levels_unused'></span><span id='topic+levels_rm'></span><span id='topic+levels_add'></span><span id='topic+levels_add_na'></span><span id='topic+levels_drop_na'></span><span id='topic+levels_drop'></span><span id='topic+levels_reorder'></span><span id='topic+levels_rename'></span><span id='topic+levels_lump'></span><span id='topic+levels_count'></span>

<h3>Description</h3>

<p>A fast version of <code>factor()</code> using the collapse package. <br />
</p>
<p>There are some additional utilities, most of which begin with the prefix
'levels_', such as
<code>as_factor()</code> which is an efficient way to coerce both vectors and factors,
<code>levels_factor()</code> which returns the levels of a factor, as a factor,
<code>levels_used()</code> which returns the used levels of a factor,
<code>levels_unused()</code> which returns the unused levels of a factor,
<code>levels_add()</code> adds the specified levels onto the existing levels,
<code>levels_rm()</code> removes the specified levels,
<code>levels_add_na()</code> which adds an explicit <code>NA</code> level,
<code>levels_drop_na()</code> which drops the <code>NA</code> level,
<code>levels_drop()</code> which drops unused factor levels,
<code>levels_rename()</code> for renaming levels,
<code>levels_lump()</code> which returns top n levels and lumps all others into the
same category, <br />
<code>levels_count()</code> which returns the counts of each level,
and finally <code>levels_reorder()</code> which reorders the levels of <code>x</code>
based on <code>y</code> using the ordered median values of <code>y</code> for each level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_(
  x = integer(),
  levels = NULL,
  order = TRUE,
  na_exclude = TRUE,
  ordered = is.ordered(x)
)

as_factor(x)

levels_factor(x)

levels_used(x)

levels_unused(x)

levels_rm(x, levels)

levels_add(x, levels, where = c("last", "first"))

levels_add_na(x, name = NA, where = c("last", "first"))

levels_drop_na(x)

levels_drop(x)

levels_reorder(x, order_by, decreasing = FALSE)

levels_rename(x, ..., .fun = NULL)

levels_lump(
  x,
  n,
  prop,
  other_category = "Other",
  ties = c("min", "average", "first", "last", "random", "max")
)

levels_count(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factor__+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="factor__+3A_levels">levels</code></td>
<td>
<p>Optional factor levels.</p>
</td></tr>
<tr><td><code id="factor__+3A_order">order</code></td>
<td>
<p>Should factor levels be sorted? Default is <code>TRUE</code>.
It typically is faster to set this to <code>FALSE</code>, in which case the levels
are sorted by order of first appearance.</p>
</td></tr>
<tr><td><code id="factor__+3A_na_exclude">na_exclude</code></td>
<td>
<p>Should <code>NA</code> values be excluded from the factor levels?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="factor__+3A_ordered">ordered</code></td>
<td>
<p>Should the result be an ordered factor?</p>
</td></tr>
<tr><td><code id="factor__+3A_where">where</code></td>
<td>
<p>Where should <code>NA</code> level be placed? Either first or last.</p>
</td></tr>
<tr><td><code id="factor__+3A_name">name</code></td>
<td>
<p>Name of <code>NA</code> level.</p>
</td></tr>
<tr><td><code id="factor__+3A_order_by">order_by</code></td>
<td>
<p>A vector to order the levels of <code>x</code> by using the medians of
<code>order_by</code>.</p>
</td></tr>
<tr><td><code id="factor__+3A_decreasing">decreasing</code></td>
<td>
<p>Should the reordered levels be in decreasing order?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="factor__+3A_...">...</code></td>
<td>
<p>Key-value pairs where the key is the new name and
value is the name to replace that with the new name. For example
<code>levels_rename(x, new = old)</code> replaces the level &quot;old&quot; with the
level &quot;new&quot;.</p>
</td></tr>
<tr><td><code id="factor__+3A_.fun">.fun</code></td>
<td>
<p>Renaming function applied to each level.</p>
</td></tr>
<tr><td><code id="factor__+3A_n">n</code></td>
<td>
<p>Top n number of levels to calculate.</p>
</td></tr>
<tr><td><code id="factor__+3A_prop">prop</code></td>
<td>
<p>Top proportion of levels to calculate.
This is a proportion of the total unique levels in x.</p>
</td></tr>
<tr><td><code id="factor__+3A_other_category">other_category</code></td>
<td>
<p>Name of 'other' category.</p>
</td></tr>
<tr><td><code id="factor__+3A_ties">ties</code></td>
<td>
<p>Ties method to use. See <code>?rank</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operates similarly to <code>collapse::qF()</code>. <br />
The main difference internally is that <code>collapse::funique()</code> is used
and therefore s3 methods can be written for it. <br />
Furthermore, for date-times <code>factor_</code> differs in that it differentiates
all instances in time whereas <code>factor</code> differentiates calendar times.
Using a daylight savings example where the clocks go back: <br />
<code>factor(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 4 levels whereas <br />
<code>factor_(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 5 levels.
</p>
<p><code>levels_lump()</code> is a cheaper version of <code>forcats::lump_n()</code> but returns
levels in order of highest frequency to lowest. This can be very useful
for plotting.
</p>


<h3>Value</h3>

<p>A <code>factor</code> or <code>character</code> in the case of <code>levels_used</code> and <code>levels_unused</code>.
<code>levels_count</code> returns a data frame of counts and proportions for each level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)

x &lt;- factor_(sample(letters[sample.int(26, 10)], 100, TRUE), levels = letters)
x
# Used/unused levels

levels_used(x)
levels_unused(x)

# Drop unused levels
levels_drop(x)

# Top 3 letters by by frequency
lumped_letters &lt;- levels_lump(x, 3)
levels_count(lumped_letters)

# To remove the "other" category, use `levels_rm()`

levels_count(levels_rm(lumped_letters, "Other"))

# We can use levels_lump to create a generic top n function for non-factors too

get_top_n &lt;- function(x, n){
  f &lt;- levels_lump(factor_(x, order = FALSE), n = n)
  levels_count(f)
}

get_top_n(x, 3)

# A neat way to order the levels of a factor by frequency
# is the following:

levels(levels_lump(x, prop = 1)) # Highest to lowest
levels(levels_lump(x, prop = -1)) # Lowest to highest

</code></pre>

<hr>
<h2 id='gcd'>Greatest common divisor and smallest common multiple</h2><span id='topic+gcd'></span><span id='topic+scm'></span><span id='topic+gcd2'></span><span id='topic+scm2'></span>

<h3>Description</h3>

<p>Fast greatest common divisor and smallest common multiple
using the Euclidean algorithm.
</p>
<p><code>gcd()</code> returns the greatest common divisor. <br />
<code>scm()</code> returns the smallest common multiple. <br />
<code>gcd2()</code> is a vectorised binary version of <code>gcd</code>. <br />
<code>scm2()</code> is a vectorised binary version of <code>scm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd(
  x,
  tol = sqrt(.Machine$double.eps),
  na_rm = TRUE,
  round = TRUE,
  break_early = TRUE
)

scm(x, tol = sqrt(.Machine$double.eps), na_rm = TRUE)

gcd2(x, y, tol = sqrt(.Machine$double.eps), na_rm = TRUE)

scm2(x, y, tol = sqrt(.Machine$double.eps), na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcd_+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+numeric">numeric</a> vector.</p>
</td></tr>
<tr><td><code id="gcd_+3A_tol">tol</code></td>
<td>
<p>Tolerance. This must
be a single positive number strictly less than 1.</p>
</td></tr>
<tr><td><code id="gcd_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code> the default, <code>NA</code> values are ignored.</p>
</td></tr>
<tr><td><code id="gcd_+3A_round">round</code></td>
<td>
<p>If <code>TRUE</code> the output is rounded as
<code>round(gcd, digits)</code> where digits is
<code>ceiling(abs(log10(tol))) + 1</code>. <br />
This can potentially reduce floating point errors on
further calculations. <br />
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_break_early">break_early</code></td>
<td>
<p>This is experimental and
applies only to floating-point numbers.
When <code>TRUE</code> the algorithm will end once <code>gcd &gt; 0 &amp;&amp; gcd &lt; 2 * tol</code>.
This can offer a tremendous speed improvement.
If <code>FALSE</code> the algorithm finishes once it has gone through all elements of <code>x</code>.
The default is <code>TRUE</code>. <br />
For integers, the algorithm always breaks early once <code>gcd &gt; 0 &amp;&amp; gcd &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_y">y</code></td>
<td>
<p>A <a href="base.html#topic+numeric">numeric</a> vector.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>



<h5>GCD (Greatest Common Divisor)</h5>

<p>The GCD is calculated using a binary function that takes input
<code>GCD(gcd, x[i + 1])</code> where the output of this function is passed as input
back into the same function iteratively along the length of <code>x</code>.
The first gcd value is <code>x[1]</code>.
</p>
<p>Zeroes are handled in the following way: <br />
<code>GCD(0, 0) = 0</code> <br />
<code>GCD(a, 0) = a</code> <br />
</p>
<p>This has the nice property that zeroes are essentially ignored.
</p>



<h5>SCM (Smallest Common Multiple)</h5>

<p>This is calculated using the GCD and the formula is: <br />
<code>SCM(x, y) = (abs(x) / GCD(x, y) ) * abs(y)</code>
</p>
<p>If you want to calculate the gcd &amp; lcm for 2 values
or across 2 vectors of values, use <code>gcd2</code> and <code>scm2</code>.
</p>



<h5>A note on performance</h5>

<p>A very common solution to finding the GCD of a vector of values is to use
<code>Reduce()</code> along with a binary function like <code>gcd2()</code>. <br />
e.g. <code>Reduce(gcd2, seq(5, 20, 5))</code>. <br />
This is exactly identical to <code>gcd(seq(5, 20, 5))</code>, with <code>gcd()</code> being much
faster and overall cheaper as it is written in C++ and heavily optimised.
Therefore it is recommended to always use <code>gcd()</code>.
</p>
<p>For example we can compare the two approaches below, <br />
<code>x &lt;- seq(5L, length = 10^6, by = 5L)</code> <br />
<code>bench::mark(Reduce(gcd2, x), gcd(x))</code> <br />
This example code shows <code>gcd()</code> being ~200x faster on my machine than
the <code>Reduce</code> + <code>gcd2</code> approach, even though <code>gcd2</code> itself is written in C++
and has little overhead.
</p>




<h3>Value</h3>

<p>A number representing the GCD or SCM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# Binary versions
gcd2(15, 25)
gcd2(15, seq(5, 25, 5))
scm2(15, seq(5, 25, 5))
scm2(15, 25)

# GCD across a vector
gcd(c(0, 5, 25))
mark(gcd(c(0, 5, 25)))

x &lt;- rnorm(10^5)
gcd(x)
gcd(x, round = FALSE)
mark(gcd(x))
</code></pre>

<hr>
<h2 id='get_breaks'>Pretty break-points for continuous (numeric) data</h2><span id='topic+get_breaks'></span><span id='topic+get_breaks.default'></span><span id='topic+get_breaks.numeric'></span><span id='topic+get_breaks.integer64'></span>

<h3>Description</h3>

<p>The distances between break-points are always equal in this implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_breaks(x, n = 10, ...)

## Default S3 method:
get_breaks(x, n = 10, ...)

## S3 method for class 'numeric'
get_breaks(
  x,
  n = 10,
  pretty = TRUE,
  expand_min = FALSE,
  expand_max = pretty,
  ...
)

## S3 method for class 'integer64'
get_breaks(x, n = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_breaks_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="get_breaks_+3A_n">n</code></td>
<td>
<p>Number of breakpoints. You may get less or more than requested.</p>
</td></tr>
<tr><td><code id="get_breaks_+3A_...">...</code></td>
<td>
<p>Extra arguments passed onto methods.</p>
</td></tr>
<tr><td><code id="get_breaks_+3A_pretty">pretty</code></td>
<td>
<p>Should pretty break-points be prioritised? Default is <code>TRUE</code>.
If <code>FALSE</code> bin-widths will be calculated as <code>diff(range(x)) / n</code>.</p>
</td></tr>
<tr><td><code id="get_breaks_+3A_expand_min">expand_min</code></td>
<td>
<p>Should smallest break be extended beyond the
minimum of the data? Default is <code>FALSE</code>.
If <code>TRUE</code> then <code>min(get_breaks(x))</code> is ensured to be less than <code>min(x)</code>.</p>
</td></tr>
<tr><td><code id="get_breaks_+3A_expand_max">expand_max</code></td>
<td>
<p>Should largest break be extended beyond the maximum
of the data? Default is <code>TRUE</code>.
If <code>TRUE</code> then <code>max(get_breaks(x))</code> is ensured
to be greater than <code>max(x)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of break-points.
</p>


<h3>See Also</h3>

<p><a href="#topic+bin">bin</a> <a href="#topic+as_discrete">as_discrete</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)

set.seed(123)
ages &lt;- sample(0:80, 100, TRUE)

# Pretty
get_breaks(ages, n = 10)
# Not-pretty
# bin-width is diff(range(ages)) / n_breaks
get_breaks(ages, n = 10, pretty = FALSE)

# `get_breaks()` is left-biased in a sense, meaning that
# the first break is always &lt;= `min(x)` but the last break
# may be &lt; `max(x)`

# To get right-biased breaks we can use a helper like so..

right_breaks &lt;- function(x, ...){
  -get_breaks(-x, ...)
}

get_breaks(4:24, 10)
right_breaks(4:24, 10)

# Use `rev()` to ensure they are in ascending order
rev(right_breaks(4:24, 10))

</code></pre>

<hr>
<h2 id='int_sign'>A fast and integer-based <code>sign()</code></h2><span id='topic+int_sign'></span>

<h3>Description</h3>

<p>A fast and integer-based <code>sign()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_sign(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int_sign_+3A_x">x</code></td>
<td>
<p>Integer or double vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector denoting the sign, -1 for negatives, 1 for positives and 0
for when <code>x == 0</code>.
</p>

<hr>
<h2 id='is_na'>Efficient functions for dealing with missing values.</h2><span id='topic+is_na'></span><span id='topic+is_na.default'></span><span id='topic+is_na.POSIXlt'></span><span id='topic+is_na.vctrs_rcrd'></span><span id='topic+is_na.data.frame'></span><span id='topic+num_na'></span><span id='topic+which_na'></span><span id='topic+which_not_na'></span><span id='topic+any_na'></span><span id='topic+all_na'></span><span id='topic+row_na_counts'></span><span id='topic+col_na_counts'></span><span id='topic+row_all_na'></span><span id='topic+col_all_na'></span><span id='topic+row_any_na'></span><span id='topic+col_any_na'></span>

<h3>Description</h3>

<p><code>is_na()</code> is a parallelised alternative to <code>is.na()</code>. <br />
<code>num_na(x)</code> is a faster and more efficient <code>sum(is.na(x))</code>. <br />
<code>which_na(x)</code> is a more efficient <code>which(is.na(x))</code> <br />
<code>which_not_na(x)</code> is a more efficient <code>which(!is.na(x))</code> <br />
<code>row_na_counts(x)</code> is a more efficient <code>rowSums(is.na(x))</code> <br />
<code>row_all_na()</code> returns a logical vector indicating which rows are empty
and have only <code>NA</code> values. <br />
<code>row_any_na()</code> returns a logical vector indicating which rows have at least
1 <code>NA</code> value. <br />
The <code>col_</code> variants are the same, but operate by-column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_na(x)

## Default S3 method:
is_na(x)

## S3 method for class 'POSIXlt'
is_na(x)

## S3 method for class 'vctrs_rcrd'
is_na(x)

## S3 method for class 'data.frame'
is_na(x)

num_na(x, recursive = TRUE)

which_na(x)

which_not_na(x)

any_na(x, recursive = TRUE)

all_na(x, recursive = TRUE)

row_na_counts(x, names = FALSE)

col_na_counts(x, names = FALSE)

row_all_na(x, names = FALSE)

col_all_na(x, names = FALSE)

row_any_na(x, names = FALSE)

col_any_na(x, names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_na_+3A_x">x</code></td>
<td>
<p>A vector, list, data frame or matrix.</p>
</td></tr>
<tr><td><code id="is_na_+3A_recursive">recursive</code></td>
<td>
<p>Should the function be applied recursively to lists?
The default is <code>TRUE</code>. Setting this to <code>TRUE</code> is actually much cheaper because
when <code>FALSE</code>, the other <code>NA</code> functions rely on calling <code>is_na()</code>,
therefore allocating a vector. This is so that alternative objects with
<code>is.na</code> methods can be supported.</p>
</td></tr>
<tr><td><code id="is_na_+3A_names">names</code></td>
<td>
<p>Should row/col names be added?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed primarily for programmers, to increase the speed
and memory-efficiency of <code>NA</code> handling. <br />
Most of these functions can be parallelised through <code>options(cheapr.cores)</code>. <br />
</p>


<h4>Common use-cases</h4>

<p>To replicate <code>complete.cases(x)</code>, use <code>!row_any_na(x)</code>. <br />
To find rows with any empty values,
use <code>which_(row_any_na(df))</code>. <br />
To find empty rows use <code>which_(row_all_na(df))</code> or <code>which_na(df)</code>.
To drop empty rows use <code>na_rm(df)</code> or <code>sset(df, which_(row_all_na(df), TRUE))</code>.
</p>



<h4><code>is_na</code></h4>

<p><code>is_na</code> Is an S3 generic function. It will internally fall back on
using <code>is.na</code> if it can't find a suitable method.
Alternatively you can write your own <code>is_na</code> method.
For example there is a method for <code>vctrs_rcrd</code>
objects that simply converts it to a data frame and then calls <code>row_all_na()</code>.
There is also a <code>POSIXlt</code> method for <code>is_na</code> that is much faster than <code>is.na</code>.
</p>



<h4>Lists</h4>

<p>When <code>x</code> is a list, <code>num_na</code>, <code>any_na</code> and <code>all_na</code> will recursively search
the list for <code>NA</code> values. If <code>recursive = F</code> then <code>is_na()</code> is used to
find <code>NA</code> values. <br />
<code>is_na</code> differs to <code>is.na</code> in 2 ways:
</p>

<ul>
<li><p> List elements are counted as <code>NA</code> if either that value is <code>NA</code>, or
if it's a list, then all values of that list are <code>NA</code>.
</p>
</li>
<li><p> When called on a data frame, it returns <code>TRUE</code> for empty rows that contain
only <code>NA</code> values.
</p>
</li></ul>




<h3>Value</h3>

<p>Number or location of <code>NA</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

x &lt;- 1:10
x[c(1, 5, 10)] &lt;- NA
num_na(x)
which_na(x)
which_not_na(x)

row_nas &lt;- row_na_counts(airquality, names = TRUE)
col_nas &lt;- col_na_counts(airquality, names = TRUE)
row_nas
col_nas

df &lt;- sset(airquality, j = 1:2)

# Number of NAs in data
num_na(df)
# Which rows are empty?
row_na &lt;- row_all_na(df)
sset(df, row_na)

# Removing the empty rows
sset(df, which_(row_na, invert = TRUE))
# Or
na_rm(df)
# Or
sset(df, row_na_counts(df) &lt; ncol(df))
</code></pre>

<hr>
<h2 id='lag_'>Lagged operations.</h2><span id='topic+lag_'></span><span id='topic+lag2_'></span>

<h3>Description</h3>

<p>Fast lags and leads optionally using dynamic vectorised lags, ordering and
run lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_(x, n = 1L, fill = NULL, set = FALSE, recursive = TRUE)

lag2_(
  x,
  n = 1L,
  order = NULL,
  run_lengths = NULL,
  fill = NULL,
  recursive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lag__+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="lag__+3A_n">n</code></td>
<td>
<p>Number of lags. Negative values are accepted. <br />
<code>lag2_</code> accepts a vector of dynamic lags and leads
which gets recycled to the length of x.</p>
</td></tr>
<tr><td><code id="lag__+3A_fill">fill</code></td>
<td>
<p>Value used to fill first n values. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="lag__+3A_set">set</code></td>
<td>
<p>Should x be updated by reference? If <code>TRUE</code> no copy is made and
x is updated in place. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lag__+3A_recursive">recursive</code></td>
<td>
<p>Should list elements be lagged as well?
If <code>TRUE</code>, this is useful for data frames and will return row lags.
If <code>FALSE</code> this will return a plain lagged list.</p>
</td></tr>
<tr><td><code id="lag__+3A_order">order</code></td>
<td>
<p>Optionally specify an ordering with which to apply the lags.
This is useful for example when applying lags chronologically using an unsorted
time variable.</p>
</td></tr>
<tr><td><code id="lag__+3A_run_lengths">run_lengths</code></td>
<td>
<p>Optional integer vector of run lengths that defines the size of each
lag run. For example, supplying <code>c(5, 5)</code> applies lags to the first 5 elements and
then essentially resets the bounds and applies lags to the next 5 elements as if
they were an entirely separate and standalone vector. <br />
This is particularly useful in conjunction with the <code>order</code> argument
to perform a by-group lag. See the examples for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most applications, it is more efficient and recommended to use <code>lag_()</code>.
For anything that requires dynamic lags, lag by order of another variable,
or by-group lags, one can use <code>lag2_()</code>. <br />
To do cyclic lags, see the examples below for an implementation.
</p>


<h4><code>lag2_</code></h4>

<p><code>lag2_</code> is a generalised form of <code>lag_</code> that by default performs
simple lags and leads. <br />
It has 3 additional features but does not support updating by reference or
long vectors. <br />
</p>
<p>These extra features include:
</p>

<ul>
<li> <p><code>n</code> - This shares the same name as the <code>n</code> argument in <code>lag_</code>
for consistency. The difference is that <code>lag_</code> accepts a
lag vector of length 1 whereas
this accepts a vector of dynamic lags allowing for
flexible combinations of variable sized lags and leads.
These are recycled to the length of the data and will always align
with the data, meaning that if you supply a custom <code>order</code> argument, this
ordering is applied both to <code>x</code> and the recycled lag vector <code>n</code> simultaneously.
</p>
</li>
<li> <p><code>order</code> - Apply lags in any order you wish. This can be useful for
reverse order lags, lags against unsorted time variables, and by-group lags.
</p>
</li>
<li> <p><code>run_lengths</code> - Specify the size of individual lag runs. For example, if you
specify <code>run_lengths = c(3, 4, 2)</code>, this will apply your lags to the first 3 elements and
then reset, applying lags to the next 4 elements, to reset again and apply lags to the
final 2 elements. Each time the reset occurs, it treats each run length sized 'chunk' as
a unique and separate vector. See the examples for a showcase.
</p>
</li></ul>




<h4>Table of differences between <code>lag_</code> and <code>lag2_</code></h4>


<table>
<tr>
 <td style="text-align: center;">
   Description </td><td style="text-align: center;"> <code>lag_</code> </td><td style="text-align: center;"> <code>lag2_</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   Lags </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Leads </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Long vector support </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> No </td>
</tr>
<tr>
 <td style="text-align: center;">
   Lag by reference </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> No </td>
</tr>
<tr>
 <td style="text-align: center;">
   Dynamic vectorised lags </td><td style="text-align: center;"> No </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Data frame row lags </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
   Alternative order lags </td><td style="text-align: center;"> No </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>




<h3>Value</h3>

<p>A lagged object the same size as x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# A use-case for data.table
# Adding 0 because can't update ALTREP by reference
df &lt;- data.frame(x = 1:10^5 + 0L)

# Normal data frame lag
sset(lag_(df), 1:10)

# Lag these behind by 3 rows
sset(lag_(df, 3, set = TRUE), 1:10)

df$x[1:10] # x variable was updated by reference!

# The above can be used naturally in data.table to lag data
# without any copies

# To perform regular R row lags, just make sure set is `FALSE`

sset(lag_(as.data.frame(EuStockMarkets), 5), 1:10)

# lag2_ is a generalised version of lag_ that allows
# for much more complex lags

x &lt;- 1:10

# lag every 2nd element
lag2_(x, n = c(1, 0)) # lag vector is recycled

# Explicit Lag(3) using a vector of lags
lags &lt;- lag_sequence(length(x), 3, partial = FALSE)
lag2_(x, n = lags)

# Alternating lags and leads
lag2_(x, c(1, -1))

# Lag only the 3rd element
lags &lt;- integer(length(x))
lags[3] &lt;- 1L
lag2_(x, lags)

# lag in descending order (same as a lead)

lag2_(x, order = 10:1)

# lag that resets after index 5
lag2_(x, run_lengths = c(5, 5))

# lag with a time index
years &lt;- sample(2011:2020)
lag2_(x, order = order(years))

# Example of how to do a cyclical lag
n &lt;- length(x)

# When k &gt;= 0
k &lt;- min(3, n)
lag2_(x, c(rep(-n + k, k), rep(k, n - k)))
# When k &lt; 0
k &lt;- max(-3, -n)
lag2_(x, c(rep(k, n + k), rep(n + k, -k)))

# As it turns out, we can do a grouped lag
# by supplying group sizes as run lengths and group order as the order

set.seed(45)
g &lt;- sample(c("a", "b"), 10, TRUE)

# NOTE: collapse::flag will not work unless g is already sorted!
# This is not an issue with lag2_()
collapse::flag(x, g = g)
lag2_(x, order = order(g), run_lengths = collapse::GRP(g)$group.sizes)

# For production code, we can of course make
# this more optimised by using collapse::radixorderv()
# Which calculates the order and group sizes all at once

o &lt;- collapse::radixorderv(g, group.sizes = TRUE)
lag2_(x, order = o, run_lengths = attr(o, "group.sizes"))

# Let's finally wrap this up in a nice grouped-lag function

grouped_lag &lt;- function(x, n = 1, g = integer(length(x))){
  o &lt;- collapse::radixorderv(g, group.sizes = TRUE, sort = FALSE)
  lag2_(x, n, order = o, run_lengths = attr(o, "group.sizes"))
}

# And voila!
grouped_lag(x, g = g)

# A method to extract this information from dplyr

## We can actually get this information easily from a `grouped_df` object
## Uncomment the below code to run the implementation
# library(dplyr)
# library(timeplyr)
# eu_stock &lt;- EuStockMarkets |&gt;
#   ts_as_tibble() |&gt;
#   group_by(stock_index = group)
# groups &lt;- group_data(eu_stock) # Group information
# group_order &lt;- unlist(groups$.rows) # Order of groups
# group_sizes &lt;- lengths_(groups$.rows) # Group sizes
#
# # by-stock index lag
# lag2_(eu_stock$value, order = group_order, run_lengths = group_sizes)
#
# # Verifying this output is correct
# eu_stock |&gt;
#   ungroup() |&gt;
#   mutate(lag1 = lag_(value), .by = stock_index) |&gt;
#   mutate(lag2 = lag2_(value, order = group_order, run_lengths = group_sizes)) |&gt;
#   summarise(lags_are_equal = identical(lag1, lag2))

# Let's compare this to data.table

library(data.table)
default_threads &lt;- getDTthreads()
setDTthreads(1)
dt &lt;- data.table(x = 1:10^5,
                 g = sample.int(10^4, 10^5, TRUE))

bench::mark(dt[, y := shift(x), by = g][][["y"]],
            grouped_lag(dt$x, g = dt$g),
            iterations = 10)
setDTthreads(default_threads)
</code></pre>

<hr>
<h2 id='lengths_'>List utilities</h2><span id='topic+lengths_'></span><span id='topic+unlisted_length'></span><span id='topic+new_list'></span>

<h3>Description</h3>

<p>Functions to help work with lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lengths_(x, names = FALSE)

unlisted_length(x)

new_list(length = 0L, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lengths__+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="lengths__+3A_names">names</code></td>
<td>
<p>Should names of list elements be added? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lengths__+3A_length">length</code></td>
<td>
<p>Length of list.</p>
</td></tr>
<tr><td><code id="lengths__+3A_default">default</code></td>
<td>
<p>Default value for each list element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lengths_()</code> returns the list lengths. <br />
<code>unlisted_length()</code> is an alternative to <code>length(unlist(x))</code>. <br />
<code>new_list()</code> is like <code>vector("list", length)</code> but also allows you to specify
a default value for each list element. This can be useful for
initialising with a catch-all value so that when you unlist you're guaranteed
a list of length &gt;= to the specified length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
l &lt;- list(1:10,
          NULL,
          list(integer(), NA_integer_, 2:10))

lengths_(l) # Faster lengths()
unlisted_length(l) # length of vector if we unlist
paste0("length: ", length(print(unlist(l))))

unlisted_length(l) - na_count(l) # Number of non-NA elements

# We can create and initialise a new list with a default value
l &lt;- new_list(20, 0L)
l[1:5]
# This works well with vctrs_list_of objects
</code></pre>

<hr>
<h2 id='named_list'>Turn dot-dot-dot (<code>...</code>) into a named list</h2><span id='topic+named_list'></span>

<h3>Description</h3>

<p>A fast and useful function for always returning a named list from <code>...</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_list(..., .keep_null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="named_list_+3A_...">...</code></td>
<td>
<p>Key-value pairs.</p>
</td></tr>
<tr><td><code id="named_list_+3A_.keep_null">.keep_null</code></td>
<td>
<p>Should <code>NULL</code> entries be kept? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>

<hr>
<h2 id='new_df'>Fast data frame constructors</h2><span id='topic+new_df'></span><span id='topic+as_df'></span><span id='topic+fast_df'></span>

<h3>Description</h3>

<p>Fast data frame constructors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_df(..., .nrows = NULL, .recycle = FALSE, .name_repair = FALSE)

as_df(x)

fast_df(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_df_+3A_...">...</code></td>
<td>
<p>Key-value pairs.</p>
</td></tr>
<tr><td><code id="new_df_+3A_.nrows">.nrows</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code> - (Optional) number of rows. <br />
Commonly used to initialise a 0-column data frame with rows.</p>
</td></tr>
<tr><td><code id="new_df_+3A_.recycle">.recycle</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> - Should arguments be recycled?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="new_df_+3A_.name_repair">.name_repair</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> - Should duplicate names be made unique?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="new_df_+3A_x">x</code></td>
<td>
<p>An object to coerce to a <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fast_df()</code> is a very fast bare-bones version of <code>new_df()</code> that
performs no checks and no recycling or name tidying.
All variables must be named and of equal length.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>

<hr>
<h2 id='overview'>An alternative to <code>summary()</code> inspired by the skimr package</h2><span id='topic+overview'></span><span id='topic+overview.default'></span><span id='topic+overview.logical'></span><span id='topic+overview.integer'></span><span id='topic+overview.numeric'></span><span id='topic+overview.integer64'></span><span id='topic+overview.character'></span><span id='topic+overview.factor'></span><span id='topic+overview.Date'></span><span id='topic+overview.POSIXt'></span><span id='topic+overview.ts'></span><span id='topic+overview.zoo'></span><span id='topic+overview.data.frame'></span>

<h3>Description</h3>

<p>A cheaper <code>summary()</code> function, designed for larger data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overview(x, digits = getOption("cheapr.digits", 2), ...)

## Default S3 method:
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'logical'
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'integer'
overview(x, digits = getOption("cheapr.digits", 2), hist = TRUE, ...)

## S3 method for class 'numeric'
overview(x, digits = getOption("cheapr.digits", 2), hist = TRUE, ...)

## S3 method for class 'integer64'
overview(x, digits = getOption("cheapr.digits", 2), hist = TRUE, ...)

## S3 method for class 'character'
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'factor'
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'Date'
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'POSIXt'
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'ts'
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'zoo'
overview(x, digits = getOption("cheapr.digits", 2), ...)

## S3 method for class 'data.frame'
overview(x, digits = getOption("cheapr.digits", 2), hist = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overview_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="overview_+3A_digits">digits</code></td>
<td>
<p>How many decimal places should the summary statistics be
printed as? Default is 2.</p>
</td></tr>
<tr><td><code id="overview_+3A_...">...</code></td>
<td>
<p>Further arguments passed onto methods. Currently unused.</p>
</td></tr>
<tr><td><code id="overview_+3A_hist">hist</code></td>
<td>
<p>Should in-line histograms be returned? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No rounding of statistics is done except in printing which can be controlled
either through the <code>digits</code> argument in <code>overview()</code>, or by setting the
option <code>options(cheapr.digits)</code>. <br />
To access the underlying data, for example the numeric summary,
just use <code style="white-space: pre;">&#8288;$numeric&#8288;</code>, e.g. <code>overview(rnorm(30))$numeric</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;overview&quot;.
Under the hood this is just a list of data frames.
Key summary statistics are reported in each data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
overview(iris)

# With histograms
overview(airquality, hist = TRUE)

# Round to 0 decimal places
overview(airquality, digits = 0)

# We can set an option for all overviews
options(cheapr.digits = 1)
overview(rnorm(100))
options(cheapr.digits = 2) # The default

</code></pre>

<hr>
<h2 id='recycle'>Recycle objects to a common size</h2><span id='topic+recycle'></span>

<h3>Description</h3>

<p>A convenience function to recycle R objects to either a common or specified
size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle(..., length = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recycle_+3A_...">...</code></td>
<td>
<p>Objects to recycle.</p>
</td></tr>
<tr><td><code id="recycle_+3A_length">length</code></td>
<td>
<p>Optional length to recycle objects to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data frames are recycled by recycling their rows. <br />
<code>recycle()</code> is optimised to only recycle objects that need recycling. <br />
<code>NULL</code> objects are ignored and not recycled or returned.
</p>


<h3>Value</h3>

<p>A list of recycled R objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)

recycle(Sys.Date(), 1:10)

# Any vectors of zero-length are all recycled to zero-length
recycle(integer(), 1:10)

# Data frame rows are recycled
recycle(sset(iris, 1:3), length = 3 * 3)

# To recycle list items, use `do.call()`
my_list &lt;- list(from = 1L, to = 10L, by = seq(0.1, 1, 0.1))
do.call(recycle, my_list)

</code></pre>

<hr>
<h2 id='sequence_'>Utilities for creating many sequences</h2><span id='topic+sequence_'></span><span id='topic+seq_id'></span><span id='topic+seq_'></span><span id='topic+seq_size'></span><span id='topic+window_sequence'></span><span id='topic+lag_sequence'></span><span id='topic+lead_sequence'></span>

<h3>Description</h3>

<p><code>sequence_</code> is an extension to <a href="base.html#topic+sequence">sequence</a> which
accepts decimal number increments. <br />
<code>seq_id</code> can be paired with <code>sequence_</code> to group individual sequences. <br />
<code>seq_</code> is a vectorised version of <a href="base.html#topic+seq">seq</a>. <br />
<code>window_sequence</code> creates a vector of window sizes for rolling calculations. <br />
<code>lag_sequence</code> creates a vector of lags for rolling calculations. <br />
<code>lead_sequence</code> creates a vector of leads for rolling calculations. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_(size, from = 1L, by = 1L, add_id = FALSE)

seq_id(size)

seq_(from = 1L, to = 1L, by = 1L, add_id = FALSE)

seq_size(from, to, by = 1L)

window_sequence(size, k, partial = TRUE, ascending = TRUE, add_id = FALSE)

lag_sequence(size, k, partial = TRUE, add_id = FALSE)

lead_sequence(size, k, partial = TRUE, add_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequence__+3A_size">size</code></td>
<td>
<p>Vector of sequence lengths.</p>
</td></tr>
<tr><td><code id="sequence__+3A_from">from</code></td>
<td>
<p>Start of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_by">by</code></td>
<td>
<p>Unit increment of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_add_id">add_id</code></td>
<td>
<p>Should the ID numbers of the sequences be added as names?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sequence__+3A_to">to</code></td>
<td>
<p>End of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_k">k</code></td>
<td>
<p>Window/lag size.</p>
</td></tr>
<tr><td><code id="sequence__+3A_partial">partial</code></td>
<td>
<p>Should partial windows/lags be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sequence__+3A_ascending">ascending</code></td>
<td>
<p>Should window sequence be ascending? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sequence_()</code> works in the same way as <code>sequence()</code> but can accept
non-integer <code>by</code> values.
It also recycles <code>from</code> and <code>to</code>, in the same way as <code>sequence()</code>. <br />
If any of the sequences contain values &gt; <code>.Machine$integer.max</code>,
then the result will always be a double vector.
</p>
<p><code>from</code> can be also be a date, date-time, or any object that supports
addition and multiplication.
</p>
<p><code>seq_()</code> is a vectorised version of <code>seq()</code> that strictly accepts
only the arguments <code>from</code>, <code>to</code> and <code>by</code>. <br />
</p>


<h3>Value</h3>

<p>A vector of length <code>sum(size)</code> except for <code>seq_</code> which
returns a vector of size <code>sum((to - from) / (by + 1))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
sequence(1:3)
sequence_(1:3)

sequence(1:3, by = 0.1)
sequence_(1:3, by = 0.1)

# Add IDs to the sequences
sequence_(1:3, by = 0.1, add_id = TRUE)
# Turn this quickly into a data frame
seqs &lt;- sequence_(1:3, by = 0.1, add_id = TRUE)
new_df(name = names(seqs), seq = seqs)

sequence(c(3, 2), by = c(-0.1, 0.1))
sequence_(c(3, 2), by = c(-0.1, 0.1))


# Vectorised version of seq()
seq_(1, 10, by = c(1, 0.5))
# Same as below
c(seq(1, 10, 1), seq(1, 10, 0.5))

# Programmers may use seq_size() to determine final sequence lengths

sizes &lt;- seq_size(1, 10, by = c(1, 0.5))
print(paste(c("sequence sizes: (", sizes, ") total size:", sum(sizes)),
            collapse = " "))

# We can group sequences using seq_id

from &lt;- Sys.Date()
to &lt;- from + 10
by &lt;- c(1, 2, 3)
x &lt;- seq_(from, to, by, add_id = TRUE)
class(x) &lt;- "Date"
x

# Utilities for rolling calculations

window_sequence(c(3, 5), 3)
window_sequence(c(3, 5), 3, partial = FALSE)
window_sequence(c(3, 5), 3, partial = TRUE, ascending = FALSE)
# One can for example use these in data.table::frollsum

</code></pre>

<hr>
<h2 id='set_abs'>Math operations by reference - <b>Experimental</b></h2><span id='topic+set_abs'></span><span id='topic+set_floor'></span><span id='topic+set_ceiling'></span><span id='topic+set_trunc'></span><span id='topic+set_exp'></span><span id='topic+set_sqrt'></span><span id='topic+set_change_sign'></span><span id='topic+set_round'></span><span id='topic+set_log'></span><span id='topic+set_pow'></span><span id='topic+set_add'></span><span id='topic+set_subtract'></span><span id='topic+set_multiply'></span><span id='topic+set_divide'></span>

<h3>Description</h3>

<p>These functions transform your variable by reference, with no copies being made.
It is advisable to only use these if you know what you are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_abs(x)

set_floor(x)

set_ceiling(x)

set_trunc(x)

set_exp(x)

set_sqrt(x)

set_change_sign(x)

set_round(x, digits = 0)

set_log(x, base = exp(1))

set_pow(x, y)

set_add(x, y)

set_subtract(x, y)

set_multiply(x, y)

set_divide(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_abs_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="set_abs_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round to.</p>
</td></tr>
<tr><td><code id="set_abs_+3A_base">base</code></td>
<td>
<p>Logarithm base.</p>
</td></tr>
<tr><td><code id="set_abs_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are particularly useful for situations
where you have made a copy and then
wish to perform further operations without creating more copies. <br />
<code>NA</code> and <code>NaN</code> values are ignored though in some instances <code>NaN</code> values may
be replaced with <code>NA</code>.
These functions will <b>not work</b> on <b>any</b> classed objects, meaning they
only work on standard integer and numeric vectors and matrices. <br />
</p>


<h4>When a copy has to be made</h4>

<p>A copy is only made in certain instances, e.g. when passing an integer vector
to <code>set_log()</code>. A warning will always be thrown in this instance alerting the user
to assign the output to an object because <code>x</code> has not been updated by reference. <br />
To ensure consistent and expected outputs, always assign the output to the same object, <br /> e.g.
<code>x &lt;- set_log(x)</code> (<b>do this</b>) <br />
<code>set_log(x)</code> (<b>don't do this</b>) <br />
<code>x2 &lt;- set_log(x)</code> (Don't do this either) <br />
<br /> No copy is made here unless x is an integer vector.
</p>



<h3>Value</h3>

<p>The exact same object with no copy made, just transformed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

x &lt;- rnorm(2e05)
options(cheapr.cores = 2)
mark(
  base = exp(log(abs(x))),
  cheapr = set_exp(set_log(set_abs(x)))
)
options(cheapr.cores = 1)

</code></pre>

<hr>
<h2 id='setdiff_'>Extra utilities</h2><span id='topic+setdiff_'></span><span id='topic+intersect_'></span><span id='topic+cut_numeric'></span><span id='topic++25in_+25'></span><span id='topic++25+21in_+25'></span><span id='topic+enframe_'></span><span id='topic+deframe_'></span><span id='topic+sample_'></span><span id='topic+val_insert'></span><span id='topic+na_insert'></span><span id='topic+vector_length'></span><span id='topic+cheapr_var'></span><span id='topic+cheapr_rev'></span><span id='topic+with_local_seed'></span>

<h3>Description</h3>

<p>Extra utilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setdiff_(x, y, dups = TRUE)

intersect_(x, y, dups = TRUE)

cut_numeric(
  x,
  breaks,
  labels = NULL,
  include.lowest = FALSE,
  right = TRUE,
  dig.lab = 3L,
  ordered_result = FALSE,
  ...
)

x %in_% table

x %!in_% table

enframe_(x, name = "name", value = "value")

deframe_(x)

sample_(x, size = vector_length(x), replace = FALSE, prob = NULL)

val_insert(x, value, n = NULL, prop = NULL)

na_insert(x, n = NULL, prop = NULL)

vector_length(x)

cheapr_var(x, na.rm = TRUE)

cheapr_rev(x)

with_local_seed(expr, .seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setdiff__+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_dups">dups</code></td>
<td>
<p>Should duplicates be kept? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_breaks">breaks</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_labels">labels</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_include.lowest">include.lowest</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_right">right</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_dig.lab">dig.lab</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_ordered_result">ordered_result</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_...">...</code></td>
<td>
<p>Further arguments passed onto <code>cut</code> or <code>set.seed</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_table">table</code></td>
<td>
<p>See <code>?collapse::fmatch</code></p>
</td></tr>
<tr><td><code id="setdiff__+3A_name">name</code></td>
<td>
<p>The column name to assign the names of a vector.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_value">value</code></td>
<td>
<p>The column name to assign the values of a vector.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_size">size</code></td>
<td>
<p>See <code>?sample</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_replace">replace</code></td>
<td>
<p>See <code>?sample</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_prob">prob</code></td>
<td>
<p>See <code>?sample</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_n">n</code></td>
<td>
<p>Number of scalar values (or <code>NA</code>) to insert
randomly into your vector.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_prop">prop</code></td>
<td>
<p>Proportion of scalar values (or <code>NA</code>) values to insert
randomly into your vector.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> values be ignored in <code>cheapr_var()</code> Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_expr">expr</code></td>
<td>
<p>Expression that will be evaluated with a local seed that
is independent and has absolutely no effect on the global RNG state.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_.seed">.seed</code></td>
<td>
<p>A local seed to set which is only used inside
<code>with_local_seed()</code>. After the execution of the expression the original
seed is reset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;enframe()_&#8288;</code> converts a vector to a data frame. <br />
<code style="white-space: pre;">&#8288;deframe()_&#8288;</code> converts a 1-2 column data frame to a vector. <br />
<code>intersect_()</code> returns a vector of common values between <code>x</code> and <code>y</code>. <br />
<code>setdiff_()</code> returns a vector of values in <code>x</code> but not <code>y</code>. <br />
<code>cut_numeric()</code> places values of a numeric vector into buckets, defined
through the <code>breaks</code> argument and returns a factor unless <code>labels = FALSE</code>,
in which case an integer vector of break indices is returned. <br />
<code style="white-space: pre;">&#8288;%in_%&#8288;</code> and <code style="white-space: pre;">&#8288;%!in_%&#8288;</code> both return a logical vector signifying if the values of
<code>x</code> exist or don't exist in <code>table</code> respectively. <br />
<code>sample_()</code> is an alternative to <code>sample()</code> that natively samples
data frame rows through <code>sset()</code>. It also does not have a special case when
<code>length(x)</code> is 1. <br />
<code>val_insert</code> inserts scalar values randomly into your vector.
Useful for replacing lots of data with a single value. <br />
<code>na_insert</code> inserts <code>NA</code> values randomly into your vector.
Useful for generating missing data. <br />
<code>vector_length</code> behaves mostly like <code>NROW()</code> except
for matrices in which it matches <code>length()</code>.
<code>cheapr_var</code> returns the variance of a numeric vector.
No coercion happens for integer vectors and so is very cheap. <br />
<code>cheapr_rev</code> is a much cheaper version of <code>rev()</code>. <br />
<code>with_local_seed</code> offers no speed improvements but is extremely handy
in executing random number based expressions like <code>rnorm()</code> without
affecting the global RNG state. It allows you to run these expressions in a
sort of independent 'container' and with an optional seed for that
'container' for reproducibility.
The rationale for including this in 'cheapr' is that it can reduce the need
to set many seed values,
especially for multiple output comparisons of RNG expressions.
Another way of thinking about it is that <code>with_local_seed()</code> is a helper
that allows you to write reproducible code without side-effects, which
traditionally cannot be avoided when calling <code>set.seed()</code> directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)

# Using `with_local_seed()`

# The below 2 statements are equivalent

# Statement 1
set.seed(123456789)
res &lt;- rnorm(10)

# Statement 2
res2 &lt;- with_local_seed(rnorm(10), .seed = 123456789)

# They are the same
identical(res, res2)

# As an example we can see that the RNG is unaffected by generating
# random uniform deviates in batches between calls to `with_local_seed()`
# and comparing to the first result

set.seed(123456789)
batch1 &lt;- rnorm(2)

with_local_seed(runif(10))
batch2 &lt;- rnorm(2)
with_local_seed(runif(10))
batch3 &lt;- rnorm(1)
with_local_seed(runif(10))
batch4 &lt;- rnorm(5)

# Combining the batches produces the same result
# therefore `with_local_seed` did not interrupt the rng sequence
identical(c(batch1, batch2, batch3, batch4), res)

# It can be useful in multiple comparisons
out1 &lt;- with_local_seed(rnorm(5))
out2 &lt;- with_local_seed(rnorm(5))
out3 &lt;- with_local_seed(rnorm(5))

identical(out1, out2)
identical(out1, out3)

</code></pre>

<hr>
<h2 id='sset'>Cheaper subset</h2><span id='topic+sset'></span><span id='topic+sset.data.frame'></span><span id='topic+sset.tbl_df'></span><span id='topic+sset.POSIXlt'></span><span id='topic+sset.data.table'></span><span id='topic+sset.sf'></span>

<h3>Description</h3>

<p>Cheaper alternative to <code>[</code> that consistently subsets data frame
rows, always returning a data frame. There are explicit methods for
enhanced data frames like tibbles, data.tables and sf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sset(x, ...)

## S3 method for class 'data.frame'
sset(x, i = NULL, j = NULL, ...)

## S3 method for class 'tbl_df'
sset(x, i = NULL, j = NULL, ...)

## S3 method for class 'POSIXlt'
sset(x, i = NULL, j = NULL, ...)

## S3 method for class 'data.table'
sset(x, i = NULL, j = NULL, ...)

## S3 method for class 'sf'
sset(x, i = NULL, j = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sset_+3A_x">x</code></td>
<td>
<p>Vector or data frame.</p>
</td></tr>
<tr><td><code id="sset_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>[</code>.</p>
</td></tr>
<tr><td><code id="sset_+3A_i">i</code></td>
<td>
<p>A logical or vector of indices. <br /></p>
</td></tr>
<tr><td><code id="sset_+3A_j">j</code></td>
<td>
<p>Column indices, names or logical vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sset</code> is an S3 generic.
You can either write methods for <code>sset</code> or <code>[</code>. <br />
<code>sset</code> will fall back on using <code>[</code> when no suitable method is found.
</p>
<p>To get into more detail, using <code>sset()</code> on a data frame, a new
list is always allocated through <code>new_list()</code>.
</p>


<h4>Difference to base R</h4>

<p>When <code>i</code> is a logical vector, it is passed directly to <code>which_()</code>. <br />
This means that <code>NA</code> values are ignored and this also means that <code>i</code>
is not recycled, so it is good practice to make sure the logical vector
matches the length of x. To return <code>NA</code> values, use <code>sset(x, NA_integer_)</code>.
</p>



<h4>ALTREP range subsetting</h4>

<p>When <code>i</code> is an ALTREP compact sequence which can be commonly created
using e.g. <code>1:10</code> or using <code>seq_len</code>, <code>seq_along</code> and <code>seq.int</code>,
<code>sset</code> internally uses a range-based subsetting method which is faster and doesn't
allocate <code>i</code> into memory.
</p>



<h3>Value</h3>

<p>A new vector, data frame, list, matrix or other R object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# Selecting columns
sset(airquality, j = "Temp")
sset(airquality, j = 1:2)

# Selecting rows
sset(iris, 1:5)

# Rows and columns
sset(iris, 1:5, 1:5)
sset(iris, iris$Sepal.Length &gt; 7, c("Species", "Sepal.Length"))

# Comparison against base
x &lt;- rnorm(10^4)

mark(x[1:10^3], sset(x, 1:10^3))
mark(x[x &gt; 0], sset(x, x &gt; 0))

df &lt;- data.frame(x = x)

mark(df[df$x &gt; 0, , drop = FALSE],
     sset(df, df$x &gt; 0),
     check = FALSE) # Row names are different

</code></pre>

<hr>
<h2 id='sset_df'>Fast functions for data frame subsetting</h2><span id='topic+sset_df'></span><span id='topic+sset_row'></span><span id='topic+sset_col'></span>

<h3>Description</h3>

<p>These functions are for developers that need minimal overhead when
filtering on rows and/or cols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sset_df(x, i = NULL, j = NULL, keep_attrs = FALSE)

sset_row(x, i = NULL)

sset_col(x, j = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sset_df_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="sset_df_+3A_i">i</code></td>
<td>
<p>Rows - If <code>NULL</code> all rows are returned.</p>
</td></tr>
<tr><td><code id="sset_df_+3A_j">j</code></td>
<td>
<p>Cols - If <code>NULL</code> all cols are returned.</p>
</td></tr>
<tr><td><code id="sset_df_+3A_keep_attrs">keep_attrs</code></td>
<td>
<p>Should all attributes (except for <code>names</code> and <code>row.names</code>)
be kept as is? The default is <code>FALSE</code> which returns a plain data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are unsure which functions to use then it is recommended to use
<code>sset()</code>. These low-overhead helpers do not work well with data.tables
but should work well with basic data frames and basic tibbles.
</p>


<h3>Value</h3>

<p>A data frame subsetted on rows <code>i</code> and cols <code>j</code>.
</p>

<hr>
<h2 id='val_count'>Efficient functions for counting, finding, replacing and removing scalars</h2><span id='topic+val_count'></span><span id='topic+val_find'></span><span id='topic+which_val'></span><span id='topic+val_replace'></span><span id='topic+na_replace'></span><span id='topic+val_rm'></span><span id='topic+na_count'></span><span id='topic+na_find'></span><span id='topic+na_rm'></span>

<h3>Description</h3>

<p>These are primarily intended as very fast scalar-based functions
for developers.
They are particularly useful for working with <code>NA</code> values in a fast
and efficient manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val_count(x, value, recursive = TRUE)

val_find(x, value, invert = FALSE)

which_val(x, value, invert = FALSE)

val_replace(x, value, replace, recursive = TRUE)

na_replace(x, replace, recursive = TRUE)

val_rm(x, value)

na_count(x, recursive = TRUE)

na_find(x, invert = FALSE)

na_rm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="val_count_+3A_x">x</code></td>
<td>
<p>A vector, list, data frame or matrix.</p>
</td></tr>
<tr><td><code id="val_count_+3A_value">value</code></td>
<td>
<p>A scalar value to count, find, replace or remove.</p>
</td></tr>
<tr><td><code id="val_count_+3A_recursive">recursive</code></td>
<td>
<p>Should values in a list be counted or replaced recursively?
Default is <code>TRUE</code> and very useful for data frames.</p>
</td></tr>
<tr><td><code id="val_count_+3A_invert">invert</code></td>
<td>
<p>Should <code>which_val</code> find locations of
everything except specified value? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="val_count_+3A_replace">replace</code></td>
<td>
<p>Replacement scalar value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>val_</code> functions allow you to very efficiently work with
scalars, i.e length 1 vectors. Many common common operations like
counting the occurrence of <code>NA</code> or zeros, e.g. <code>sum(x == 0)</code> or
<code>sum(is.na(x))</code> can be replaced more efficiently with
<code>val_count(x, 0)</code> and <code>na_count(x)</code> respectively.
</p>
<p>At the moment these functions only work for
integer, double and character vectors with the exception of the <code>NA</code>
functions.
They are intended mainly for developers who wish to write cheaper code
and reduce expensive vector operations.
</p>

<ul>
<li> <p><code>val_count()</code> - Counts occurrences of a value
</p>
</li>
<li> <p><code>val_find()</code> Finds locations (indices) of a value
</p>
</li>
<li> <p><code>val_replace()</code> - Replaces value with another value
</p>
</li>
<li> <p><code>val_rm()</code> - Removes occurrences of value from an object
</p>
</li></ul>

<p>There are <code>NA</code> equivalent convenience functions.
</p>

<ul>
<li> <p><code>na_count()</code> == <code>val_count(x, NA)</code>
</p>
</li>
<li> <p><code>na_find()</code> == <code>val_find(x, NA)</code>
</p>
</li>
<li> <p><code>na_replace()</code> == <code>val_replace(x, NA)</code>
</p>
</li>
<li> <p><code>na_rm()</code> == <code>val_rm(x, NA)</code>
</p>
</li></ul>

<p><code>val_count()</code> and <code>val_replace()</code> can work recursively. For example,
when applied to a data frame, <code>na_replace</code> will replace <code>NA</code> values across
the entire data frame with the specified replacement value.
</p>
<p>In 'cheapr' function-naming conventions have not been consistent but
going forward
all scalar functions (including the <code>NA</code> convenience functions) will be
prefixed with 'val_' and 'na_' respectively.
Functions named with the older naming scheme like <code>which_na</code> may be
removed at some point in the future.
</p>


<h3>Value</h3>

<p><code>val_count()</code> returns the number of times a scalar value appears in a vector
or list. <br />
<code>val_find()</code> returns the index locations of that scalar value. <br />
<code>val_replace()</code> replaces a specified scalar value with a replacement scalar
value. If no instances of said value are found then the input x is returned
as is. <br />
<code>na_replace()</code> is a convenience function
equivalent to <code>val_replace(x, NA, ...)</code>. <br />
<code>val_rm()</code> removes all instances of a specified scalar value.
If no instances are found, the original input x is returned as is.
</p>

<hr>
<h2 id='which_'>Memory-efficient alternative to <code>which()</code></h2><span id='topic+which_'></span>

<h3>Description</h3>

<p>Exactly the same as <code>which()</code> but more memory efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_(x, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which__+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+logical">logical</a> vector.</p>
</td></tr>
<tr><td><code id="which__+3A_invert">invert</code></td>
<td>
<p>If <code>TRUE</code>, indices of values that are not <code>TRUE</code> are returned
(including <code>NA</code>). If <code>FALSE</code> (the default), only <code>TRUE</code> indices are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is similar in speed to <code>which()</code>
but usually more memory efficient.
</p>


<h3>Value</h3>

<p>An unnamed integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)
x &lt;- sample(c(TRUE, FALSE), 1e05, TRUE)
x[sample.int(1e05, round(1e05/3))] &lt;- NA

mark(which_(TRUE), which(TRUE))
mark(which_(FALSE), which(FALSE))
mark(which_(logical()), which(logical()))
mark(which_(x), which(x), iterations = 20)
mark(base = which(is.na(match(x, TRUE))),
     collapse = collapse::whichv(x, TRUE, invert = TRUE),
     cheapr = which_(x, invert = TRUE),
     iterations = 20)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
