<!DOCTYPE html><html><head><title>Help for package cheapr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cheapr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cheapr-package'><p>cheapr: Simple Functions to Save Time and Memory</p></a></li>
<li><a href='#count_val'><p>Count the number of occurrences of a value.</p></a></li>
<li><a href='#factor_'><p>A faster version of <code>factor()</code></p></a></li>
<li><a href='#gcd'><p>Greatest common divisor and smallest common multiple</p></a></li>
<li><a href='#is_na'><p>Efficient functions for dealing with missing values.</p></a></li>
<li><a href='#lengths_'><p>List utilities</p></a></li>
<li><a href='#overview'><p>An alternative to <code>summary()</code> inspired by the skimr package</p></a></li>
<li><a href='#sequence_'><p>Utilities for creating many sequences</p></a></li>
<li><a href='#setdiff_'><p>Extra utilities</p></a></li>
<li><a href='#sset'><p>Cheaper subset</p></a></li>
<li><a href='#which_'><p>Memory-efficient alternative to <code>which()</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simple Functions to Save Time and Memory</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nick Christofides &lt;nick.christofides.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and memory-efficient (or 'cheap') tools to facilitate
    efficient programming, saving time and memory. It aims to provide
    'cheaper' alternatives to common base R functions, as well as some
    additional functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NicChr/cheapr/issues">https://github.com/NicChr/cheapr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>collapse (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, testthat (&ge; 3.0.0), vctrs</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-05 12:18:15 UTC; Nmc5</td>
</tr>
<tr>
<td>Author:</td>
<td>Nick Christofides <a href="https://orcid.org/0000-0002-9743-7342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-05 12:32:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='cheapr-package'>cheapr: Simple Functions to Save Time and Memory</h2><span id='topic+cheapr'></span><span id='topic+cheapr-package'></span>

<h3>Description</h3>

<p>In this package, 'cheap' means fast and efficient.
</p>
<p>cheapr aims to provide a set of functions for programmers to write
cheaper code, saving time and memory.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nick Christofides <a href="mailto:nick.christofides.r@gmail.com">nick.christofides.r@gmail.com</a> (<a href="https://orcid.org/0000-0002-9743-7342">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/NicChr/cheapr/issues">https://github.com/NicChr/cheapr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='count_val'>Count the number of occurrences of a value.</h2><span id='topic+count_val'></span>

<h3>Description</h3>

<p>This is a programmer's version of <code>sum(x == value)</code> to count the number of
occurrences of a value without creating a potentially large logical vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_val(x, value, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_val_+3A_x">x</code></td>
<td>
<p>A vector, list, data frame or matrix.</p>
</td></tr>
<tr><td><code id="count_val_+3A_value">value</code></td>
<td>
<p>A value with which to count the frequency of.</p>
</td></tr>
<tr><td><code id="count_val_+3A_recursive">recursive</code></td>
<td>
<p>Should the function be applied recursively to lists?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of <code>num_na()</code> and as such the identity
<code>count_val(x, NA) == num_na(x)</code> will always hold.
</p>


<h3>Value</h3>

<p>A count of the number of times <code>value</code> appears in <code>x</code>.
</p>

<hr>
<h2 id='factor_'>A faster version of <code>factor()</code></h2><span id='topic+factor_'></span><span id='topic+levels_factor'></span><span id='topic+used_levels'></span><span id='topic+unused_levels'></span>

<h3>Description</h3>

<p>A fast version of <code>factor()</code> using the collapse package.
There are some additional utilities such as
<code>levels_factor()</code> which returns the levels of a factor, as a factor,
<code>used_levels()</code> which returns the used levels of a factor,
and <code>unused_levels()</code> which returns the unused levels of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_(
  x = integer(),
  levels = NULL,
  order = TRUE,
  na_exclude = TRUE,
  ordered = is.ordered(x)
)

levels_factor(x)

used_levels(x)

unused_levels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor__+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="factor__+3A_levels">levels</code></td>
<td>
<p>Optional factor levels.</p>
</td></tr>
<tr><td><code id="factor__+3A_order">order</code></td>
<td>
<p>Should factor levels be sorted? Default is <code>TRUE</code>.
It typically is faster to set this to <code>FALSE</code>, in which case the levels
are sorted by order of first appearance.</p>
</td></tr>
<tr><td><code id="factor__+3A_na_exclude">na_exclude</code></td>
<td>
<p>Should <code>NA</code> values be excluded from the factor levels?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="factor__+3A_ordered">ordered</code></td>
<td>
<p>Should the result be an ordered factor?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operates similarly to <code>collapse::qF()</code>. <br />
The main difference internally is that <code>collapse::funique()</code> is used
and therefore s3 methods can be written for it. <br />
Furthermore, for date-times <code>factor_</code> differs in that it differentiates
all instances in time whereas <code>factor</code> differentiates calendar times.
Using a daylight savings example where the clocks go back: <br />
<code>factor(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 4 levels whereas <br />
<code>factor_(as.POSIXct(1729984360, tz = "Europe/London") + 3600 *(1:5))</code>
produces 5 levels.
</p>


<h3>Value</h3>

<p>A <code>factor</code> or <code>character</code> in the case of <code>used_levels</code> and <code>unused_levels</code>.
</p>

<hr>
<h2 id='gcd'>Greatest common divisor and smallest common multiple</h2><span id='topic+gcd'></span><span id='topic+scm'></span><span id='topic+gcd2'></span><span id='topic+scm2'></span>

<h3>Description</h3>

<p>Fast greatest common divisor and smallest common multiple
using the Euclidean algorithm.
</p>
<p><code>gcd()</code> returns the greatest common divisor. <br />
<code>scm()</code> returns the smallest common multiple. <br />
<code>gcd2()</code> is a vectorised binary version of <code>gcd</code>. <br />
<code>scm2()</code> is a vectorised binary version of <code>scm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd(
  x,
  tol = sqrt(.Machine$double.eps),
  na_rm = TRUE,
  round = TRUE,
  break_early = TRUE
)

scm(x, tol = sqrt(.Machine$double.eps), na_rm = TRUE)

gcd2(x, y, tol = sqrt(.Machine$double.eps), na_rm = TRUE)

scm2(x, y, tol = sqrt(.Machine$double.eps), na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcd_+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+numeric">numeric</a> vector.</p>
</td></tr>
<tr><td><code id="gcd_+3A_tol">tol</code></td>
<td>
<p>Tolerance. This must
be a single positive number strictly less than 1.</p>
</td></tr>
<tr><td><code id="gcd_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code> the default, <code>NA</code> values are ignored.</p>
</td></tr>
<tr><td><code id="gcd_+3A_round">round</code></td>
<td>
<p>If <code>TRUE</code> the output is rounded as
<code>round(gcd, digits)</code> where digits is
<code>ceiling(abs(log10(tol))) + 1</code>. <br />
This can potentially reduce floating point errors on
further calculations. <br />
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_break_early">break_early</code></td>
<td>
<p>This is experimental and
applies only to floating-point numbers.
When <code>TRUE</code> the algorithm will end once <code>gcd &gt; 0 &amp;&amp; gcd &lt; 2 * tol</code>.
This can offer a tremendous speed improvement.
If <code>FALSE</code> the algorithm finishes once it has gone through all elements of <code>x</code>.
The default is <code>TRUE</code>. <br />
For integers, the algorithm always breaks early once <code>gcd &gt; 0 &amp;&amp; gcd &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="gcd_+3A_y">y</code></td>
<td>
<p>A <a href="base.html#topic+numeric">numeric</a> vector.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Method</h4>



<h5>GCD</h5>

<p>The GCD is calculated using a binary function that takes input
<code>GCD(gcd, x[i + 1])</code> where the output of this function is passed as input
back into the same function iteratively along the length of <code>x</code>.
The first gcd value is <code>x[1]</code>.
</p>
<p>Zeroes are handled in the following way: <br />
<code>GCD(0, 0) = 0</code> <br />
<code>GCD(a, 0) = a</code> <br />
</p>
<p>This has the nice property that zeroes are essentially ignored.
</p>



<h5>SCM</h5>

<p>This is calculated using the GCD and the formula is: <br />
<code>SCM(x, y) = (abs(x) / GCD(x, y) ) * abs(y)</code>
</p>
<p>If you want to calculate the gcd &amp; lcm for 2 values
or across 2 vectors of values, use <code>gcd2</code> and <code>scm2</code>.
</p>




<h3>Value</h3>

<p>A number representing the GCD or SCM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# Binary versions
gcd2(15, 25)
gcd2(15, seq(5, 25, 5))
scm2(15, seq(5, 25, 5))
scm2(15, 25)

# GCD across a vector
gcd(c(0, 5, 25))
mark(gcd(c(0, 5, 25)))

x &lt;- rnorm(10^5)
gcd(x)
gcd(x, round = FALSE)
mark(gcd(x))
</code></pre>

<hr>
<h2 id='is_na'>Efficient functions for dealing with missing values.</h2><span id='topic+is_na'></span><span id='topic+is_na.default'></span><span id='topic+is_na.POSIXlt'></span><span id='topic+is_na.vctrs_rcrd'></span><span id='topic+is_na.data.frame'></span><span id='topic+num_na'></span><span id='topic+which_na'></span><span id='topic+which_not_na'></span><span id='topic+any_na'></span><span id='topic+all_na'></span><span id='topic+row_na_counts'></span><span id='topic+col_na_counts'></span><span id='topic+row_all_na'></span><span id='topic+col_all_na'></span><span id='topic+row_any_na'></span><span id='topic+col_any_na'></span>

<h3>Description</h3>

<p><code>is_na()</code> is a parallelised alternative to <code>is.na()</code>. <br />
<code>num_na(x)</code> is a faster and more efficient <code>sum(is.na(x))</code>. <br />
<code>which_na(x)</code> is a more efficient <code>which(is.na(x))</code> <br />
<code>which_not_na(x)</code> is a more efficient <code>which(!is.na(x))</code> <br />
<code>row_na_counts(x)</code> is a more efficient <code>rowSums(is.na(x))</code> <br />
<code>row_all_na()</code> returns a logical vector indicating which rows are empty
and have only <code>NA</code> values. <br />
<code>row_any_na()</code> returns a logical vector indicating which rows have at least
1 <code>NA</code> value. <br />
The <code>col_</code> variants are the same, but operate by-column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_na(x)

## Default S3 method:
is_na(x)

## S3 method for class 'POSIXlt'
is_na(x)

## S3 method for class 'vctrs_rcrd'
is_na(x)

## S3 method for class 'data.frame'
is_na(x)

num_na(x, recursive = TRUE)

which_na(x)

which_not_na(x)

any_na(x, recursive = TRUE)

all_na(x, recursive = TRUE)

row_na_counts(x)

col_na_counts(x)

row_all_na(x)

col_all_na(x)

row_any_na(x)

col_any_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_na_+3A_x">x</code></td>
<td>
<p>A vector, list, data frame or matrix.</p>
</td></tr>
<tr><td><code id="is_na_+3A_recursive">recursive</code></td>
<td>
<p>Should the function be applied recursively to lists?
The default is <code>TRUE</code>. Setting this to <code>TRUE</code> is actually much cheaper because
when <code>FALSE</code>, the other <code>NA</code> functions rely on calling <code>is_na()</code>,
therefore allocating a vector. This is so that alternative objects with
<code>is.na</code> methods can be supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed primarily for programmers, to increase the speed
and memory-efficiency of <code>NA</code> handling. <br />
Most of these functions can be parallelised through <code>options(cheapr.cores)</code>. <br />
</p>


<h4>Common use-cases</h4>

<p>To replicate <code>complete.cases(x)</code>, use <code>!row_any_na(x)</code>. <br />
To find rows with any empty values,
use <code>which_(row_any_na(df))</code>. <br />
To find empty rows use <code>which_(row_all_na(df))</code> or <code>which_na(df)</code>.
To drop empty rows use <code>na_rm(df)</code> or <code>sset(df, which_(row_all_na(df), TRUE))</code>.
</p>



<h4><code>is_na</code></h4>

<p><code>is_na</code> Is an S3 generic function. It will internally fall back on
using <code>is.na</code> if it can't find a suitable method.
Alternatively you can write your own <code>is_na</code> method.
For example there is a method for <code>vctrs_rcrd</code>
objects that simply converts it to a data frame and then calls <code>row_all_na()</code>.
There is also a <code>POSIXlt</code> method for <code>is_na</code> that is much faster than <code>is.na</code>.
</p>



<h4>Lists</h4>

<p>When <code>x</code> is a list, <code>num_na</code>, <code>any_na</code> and <code>all_na</code> will recursively search
the list for <code>NA</code> values. If <code>recursive = F</code> then <code>is_na()</code> is used to
find <code>NA</code> values. <br />
<code>is_na</code> differs to <code>is.na</code> in 2 ways:
</p>

<ul>
<li><p> List elements are counted as <code>NA</code> if either that value is <code>NA</code>, or
if it's a list, then all values of that list are <code>NA</code>.
</p>
</li>
<li><p> When called on a data frame, it returns <code>TRUE</code> for empty rows that contain
only <code>NA</code> values.
</p>
</li></ul>




<h3>Value</h3>

<p>Number or location of <code>NA</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

x &lt;- 1:10
x[c(1, 5, 10)] &lt;- NA
num_na(x)
which_na(x)
which_not_na(x)

row_nas &lt;- row_na_counts(airquality)
col_nas &lt;- col_na_counts(airquality)
names(row_nas) &lt;- rownames(airquality)
names(col_nas) &lt;- colnames(airquality)
row_nas
col_nas

df &lt;- airquality[, 1:2]

# Number of NAs in data
num_na(df)
# Which rows are empty?
row_na &lt;- row_all_na(df)
df[which_(row_na), ]

# Removing the empty rows
df[which_(row_na, invert = TRUE), ]

</code></pre>

<hr>
<h2 id='lengths_'>List utilities</h2><span id='topic+lengths_'></span><span id='topic+unlisted_length'></span><span id='topic+new_list'></span>

<h3>Description</h3>

<p>Functions to help work with lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lengths_(x)

unlisted_length(x)

new_list(length = 0L, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lengths__+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="lengths__+3A_length">length</code></td>
<td>
<p>Length of list.</p>
</td></tr>
<tr><td><code id="lengths__+3A_default">default</code></td>
<td>
<p>Default value for each list element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lengths_()</code> returns the list lengths. <br />
<code>unlisted_length()</code> is an alternative to <code>length(unlist(x))</code>. <br />
<code>new_list()</code> is like <code>vector("list", length)</code> but also allows you to specify
a default value for each list element. This can be useful for
initialising with a catch-all value so that when you unlist you're guaranteed
a list of length &gt;= to the specified length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
l &lt;- list(1:10,
          NULL,
          list(integer(), NA_integer_, 2:10))

lengths_(l) # Faster lengths()
unlisted_length(l) # length of vector if we unlist
paste0("length: ", length(print(unlist(l))))

unlisted_length(l) - num_na(l) # Number of non-NA elements

# We can create and initialise a new list with a default value
l &lt;- new_list(20, 0L)
l[1:5]
# This works well with vctrs_list_of objects
vctrs::new_list_of(l, ptype = integer())[1:5]
</code></pre>

<hr>
<h2 id='overview'>An alternative to <code>summary()</code> inspired by the skimr package</h2><span id='topic+overview'></span><span id='topic+overview.default'></span><span id='topic+overview.logical'></span><span id='topic+overview.numeric'></span><span id='topic+overview.character'></span><span id='topic+overview.factor'></span><span id='topic+overview.Date'></span><span id='topic+overview.POSIXt'></span><span id='topic+overview.ts'></span><span id='topic+overview.zoo'></span><span id='topic+overview.data.frame'></span>

<h3>Description</h3>

<p>A cheaper <code>summary()</code> function, designed for larger data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## Default S3 method:
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'logical'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'numeric'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'character'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'factor'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'Date'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'POSIXt'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'ts'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'zoo'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))

## S3 method for class 'data.frame'
overview(x, hist = FALSE, digits = getOption("cheapr.digits", 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overview_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="overview_+3A_hist">hist</code></td>
<td>
<p>Should in-line histograms be returned? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="overview_+3A_digits">digits</code></td>
<td>
<p>How many decimal places should the summary statistics be
printed as? Default is 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No rounding of statistics is done except in printing which can be controlled
either through the <code>digits</code> argument in <code>overview()</code>, or by setting the
option <code>options(cheapr.digits)</code>. <br />
To access the underlying data, for example the numeric summary,
just use <code style="white-space: pre;">&#8288;$numeric&#8288;</code>, e.g. <code>overview(rnorm(30))$numeric</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;overview&quot;.
Under the hood this is just a list of data frames.
Key summary statistics are reported in each data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
overview(iris)

# With histograms
overview(airquality, hist = TRUE)

# Round to 0 decimal places
overview(airquality, digits = 0)

# We can set an option for all overviews
options(cheapr.digits = 1)
overview(rnorm(100))
options(cheapr.digits = 2) # The default
</code></pre>

<hr>
<h2 id='sequence_'>Utilities for creating many sequences</h2><span id='topic+sequence_'></span><span id='topic+seq_id'></span><span id='topic+seq_'></span><span id='topic+seq_size'></span><span id='topic+window_sequence'></span><span id='topic+lag_sequence'></span><span id='topic+lead_sequence'></span>

<h3>Description</h3>

<p><code>sequence_</code> is an extension to <a href="base.html#topic+sequence">sequence</a> which
accepts decimal number increments. <br />
<code>seq_id</code> can be paired with <code>sequence_</code> to group individual sequences. <br />
<code>seq_</code> is a vectorised version of <a href="base.html#topic+seq">seq</a>. <br />
<code>window_sequence</code> creates a vector of window sizes for rolling calculations. <br />
<code>lag_sequence</code> creates a vector of lags for rolling calculations. <br />
<code>lead_sequence</code> creates a vector of leads for rolling calculations. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_(size, from = 1L, by = 1L, add_id = FALSE)

seq_id(size)

seq_(from = 1L, to = 1L, by = 1L, add_id = FALSE)

seq_size(from, to, by = 1L)

window_sequence(size, k, partial = TRUE, ascending = TRUE, add_id = FALSE)

lag_sequence(size, k, partial = TRUE, add_id = FALSE)

lead_sequence(size, k, partial = TRUE, add_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequence__+3A_size">size</code></td>
<td>
<p>Vector of sequence lengths.</p>
</td></tr>
<tr><td><code id="sequence__+3A_from">from</code></td>
<td>
<p>Start of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_by">by</code></td>
<td>
<p>Unit increment of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_add_id">add_id</code></td>
<td>
<p>Should the ID numbers of the sequences be added as names?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sequence__+3A_to">to</code></td>
<td>
<p>End of sequence(s).</p>
</td></tr>
<tr><td><code id="sequence__+3A_k">k</code></td>
<td>
<p>Window/lag size.</p>
</td></tr>
<tr><td><code id="sequence__+3A_partial">partial</code></td>
<td>
<p>Should partial windows/lags be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sequence__+3A_ascending">ascending</code></td>
<td>
<p>Should window sequence be ascending? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sequence_()</code> works in the same way as <code>sequence()</code> but can accept
non-integer <code>by</code> values.
It also recycles <code>from</code> and <code>to</code>, in the same way as <code>sequence()</code>. <br />
If any of the sequences contain values &gt; <code>.Machine$integer.max</code>,
then the result will always be a double vector.
</p>
<p><code>from</code> can be also be a date, date-time, or any object that supports
addition and multiplication.
</p>
<p><code>seq_()</code> is a vectorised version of <code>seq()</code> that strictly accepts
only the arguments <code>from</code>, <code>to</code> and <code>by</code>. <br />
</p>


<h3>Value</h3>

<p>A vector of length <code>sum(size)</code> except for <code>seq_</code> which
returns a vector of size <code>sum((to - from) / (by + 1))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
sequence(1:3)
sequence_(1:3)

sequence(1:3, by = 0.1)
sequence_(1:3, by = 0.1)

# Add IDs to the sequences
sequence_(1:3, by = 0.1, add_id = TRUE)
# Turn this quickly into a data frame
enframe_(sequence_(1:3, by = 0.1, add_id = TRUE))

sequence(c(3, 2), by = c(-0.1, 0.1))
sequence_(c(3, 2), by = c(-0.1, 0.1))


# Vectorised version of seq()
seq_(1, 10, by = c(1, 0.5))
# Same as below
c(seq(1, 10, 1), seq(1, 10, 0.5))

# Programmers may use seq_size() to determine final sequence lengths

sizes &lt;- seq_size(1, 10, by = c(1, 0.5))
print(paste(c("sequence sizes: (", sizes, ") total size:", sum(sizes)),
            collapse = " "))

# We can group sequences using seq_id

from &lt;- Sys.Date()
to &lt;- from + 10
by &lt;- c(1, 2, 3)
x &lt;- seq_(from, to, by, add_id = TRUE)
class(x) &lt;- "Date"
x

# Utilities for rolling calculations

window_sequence(c(3, 5), 3)
window_sequence(c(3, 5), 3, partial = FALSE)
window_sequence(c(3, 5), 3, partial = TRUE, ascending = FALSE)
# One can for example use these in data.table::frollsum

</code></pre>

<hr>
<h2 id='setdiff_'>Extra utilities</h2><span id='topic+setdiff_'></span><span id='topic+intersect_'></span><span id='topic+cut_numeric'></span><span id='topic++25in_+25'></span><span id='topic++25+21in_+25'></span><span id='topic+enframe_'></span><span id='topic+deframe_'></span><span id='topic+na_rm'></span>

<h3>Description</h3>

<p>Extra utilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setdiff_(x, y, dups = TRUE)

intersect_(x, y, dups = TRUE)

cut_numeric(
  x,
  breaks,
  labels = NULL,
  include.lowest = FALSE,
  right = TRUE,
  dig.lab = 3L,
  ordered_result = FALSE,
  ...
)

x %in_% table

x %!in_% table

enframe_(x, name = "name", value = "value")

deframe_(x)

na_rm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setdiff__+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_y">y</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_dups">dups</code></td>
<td>
<p>Should duplicates be kept? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_breaks">breaks</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_labels">labels</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_include.lowest">include.lowest</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_right">right</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_dig.lab">dig.lab</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_ordered_result">ordered_result</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_...">...</code></td>
<td>
<p>See <code>?cut</code>.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_table">table</code></td>
<td>
<p>See <code>?collapse::fmatch</code></p>
</td></tr>
<tr><td><code id="setdiff__+3A_name">name</code></td>
<td>
<p>The column name to assign the names of a vector.</p>
</td></tr>
<tr><td><code id="setdiff__+3A_value">value</code></td>
<td>
<p>The column name to assign the values of a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>intersect_()</code> and <code>setdiff_()</code> are faster and more efficient
alternatives to <code>intersect()</code> and <code>setdiff()</code> respectively. <br />
<code>enframe_()</code> and <code>deframe_()</code> are faster alternatives to
<code>tibble::enframe()</code> and <code>tibble::deframe()</code> respectively. <br />
<code>cut_numeric()</code> is a faster and more efficient alternative to
<code>cut.default()</code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;enframe()_&#8288;</code> converts a vector to a data frame. <br />
<code style="white-space: pre;">&#8288;deframe()_&#8288;</code> converts a 1-2 column data frame to a vector. <br />
<code>intersect_()</code> returns a vector of common values between <code>x</code> and <code>y</code>. <br />
<code>setdiff_()</code> returns a vector of values in <code>x</code> but not <code>y</code>. <br />
<code>cut_numeric()</code> places values of a numeric vector into buckets, defined
through the <code>breaks</code> argument and returns a factor unless <code>labels = FALSE</code>,
in which case an integer vector of break indices is returned. <br />
<code style="white-space: pre;">&#8288;%in_%&#8288;</code> and <code style="white-space: pre;">&#8288;%!in_%&#8288;</code> both return a logical vector signifying if the values of
<code>x</code> exist or don't exist in <code>table</code> respectively. <br />
<code>na_rm()</code> is a convenience function that removes <code>NA</code> values and
works only on vectors. For more advanced <code>NA</code> handling, see <code>?is_na</code>.
</p>

<hr>
<h2 id='sset'>Cheaper subset</h2><span id='topic+sset'></span><span id='topic+sset.Date'></span><span id='topic+sset.POSIXct'></span><span id='topic+sset.factor'></span><span id='topic+sset.data.frame'></span><span id='topic+sset.tbl_df'></span><span id='topic+sset.POSIXlt'></span><span id='topic+sset.data.table'></span><span id='topic+sset.sf'></span>

<h3>Description</h3>

<p>Cheaper alternative to <code>[</code> that consistently subsets data frame
rows, always returning a data frame. There are explicit methods for
enhanced data frames like tibbles, data.tables and sf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sset(x, ...)

## S3 method for class 'Date'
sset(x, i, ...)

## S3 method for class 'POSIXct'
sset(x, i, ...)

## S3 method for class 'factor'
sset(x, i, ...)

## S3 method for class 'data.frame'
sset(x, i, j = seq_along(x), ...)

## S3 method for class 'tbl_df'
sset(x, i, j = seq_along(x), ...)

## S3 method for class 'POSIXlt'
sset(x, i, j, ...)

## S3 method for class 'data.table'
sset(x, i, j = seq_along(x), ...)

## S3 method for class 'sf'
sset(x, i, j = seq_along(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sset_+3A_x">x</code></td>
<td>
<p>Vector or data frame.</p>
</td></tr>
<tr><td><code id="sset_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>[</code>.</p>
</td></tr>
<tr><td><code id="sset_+3A_i">i</code></td>
<td>
<p>A logical or vector of indices. <br /></p>
</td></tr>
<tr><td><code id="sset_+3A_j">j</code></td>
<td>
<p>Column indices, names or logical vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sset</code> is an S3 generic.
You can either write methods for <code>sset</code> or <code>[</code>. <br />
<code>sset</code> will fall back on using <code>[</code> when no suitable method is found.
</p>
<p>To get into more detail, using <code>sset()</code> on a data frame, a new
list is always allocated through <code>new_list()</code>.
</p>


<h4>Difference to base R</h4>

<p>When <code>i</code> is a logical vector, it is passed directly to <code>which_()</code>. <br />
This means that <code>NA</code> values are ignored and this also means that <code>i</code>
is not recycled, so it is good practice to make sure the logical vector
matches the length of x. To return <code>NA</code> values, use <code>x[NA_integer_]</code>.
</p>



<h4>ALTREP range subsetting</h4>

<p>When <code>i</code> is an ALTREP compact integer sequence which can be commonly created
using e.g. <code>1:10</code> or using <code>seq_len</code>, <code>seq_along</code> and <code>seq.int</code>,
<code>sset</code> internally uses a range-based subsetting which is faster and doesn't
allocate <code>i</code> into memory.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)

# Selecting columns
sset(airquality, j = "Temp")
sset(airquality, j = 1:2)

# Selecting rows
sset(iris, 1:5)

# Rows and columns
sset(iris, 1:5, 1:5)
sset(iris, iris$Sepal.Length &gt; 7, c("Species", "Sepal.Length"))

# Comparison against base
x &lt;- rnorm(10^4)

mark(x[1:10^3], sset(x, 1:10^3))
mark(x[x &gt; 0], sset(x, x &gt; 0))

df &lt;- data.frame(x = x)

mark(df[df$x &gt; 0, , drop = FALSE],
     sset(df, df$x &gt; 0),
     check = FALSE) # Row names are different

</code></pre>

<hr>
<h2 id='which_'>Memory-efficient alternative to <code>which()</code></h2><span id='topic+which_'></span>

<h3>Description</h3>

<p>Exactly the same as <code>which()</code> but more memory efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_(x, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which__+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+logical">logical</a> vector.</p>
</td></tr>
<tr><td><code id="which__+3A_invert">invert</code></td>
<td>
<p>If <code>TRUE</code>, indices of values that are not <code>TRUE</code> are returned
(including <code>NA</code>). If <code>FALSE</code> (the default), only <code>TRUE</code> indices are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is similar in speed to <code>which()</code>
but usually more memory efficient.
</p>


<h3>Value</h3>

<p>An unnamed integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cheapr)
library(bench)
x &lt;- sample(c(TRUE, FALSE), 1e05, TRUE)
x[sample.int(1e05, round(1e05/3))] &lt;- NA

mark(which_(TRUE), which(TRUE))
mark(which_(FALSE), which(FALSE))
mark(which_(logical()), which(logical()))
mark(which_(x), which(x), iterations = 20)
mark(base = which(is.na(match(x, TRUE))),
     collapse = collapse::whichv(x, TRUE, invert = TRUE),
     cheapr = which_(x, invert = TRUE),
     iterations = 20)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
