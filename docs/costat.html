<!DOCTYPE html><html lang="en"><head><title>Help for package costat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {costat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#costat-package'><p>Computes localized autocovariance and searches for costationary</p>
solutions to bivariate time series.</a></li>
<li><a href='#AntiAR'><p>Undo autoreflection action for an EWS object (wd stationary)</p></a></li>
<li><a href='#BootTOS'><p>Perform bootstrap stationarity test for time series</p></a></li>
<li><a href='#COEFbothscale'><p>Produces plots from output of findstysol that attempt to</p>
group different solutions.</a></li>
<li><a href='#coeftofn'><p>Convert wavelet coefficients for two time-varying functions</p>
into two functions with respect to time.</a></li>
<li><a href='#EWSsmoothRM'><p>Perform running mean smoothing of an EWS object</p></a></li>
<li><a href='#extractCS'><p>Extractor function for <code>csFSS</code> object.</p></a></li>
<li><a href='#findstysols'><p>Given two time series find some time-varying linear combinations</p>
that are stationary.</a></li>
<li><a href='#fret'><p>Particular section of FTSE log-return series.</p></a></li>
<li><a href='#getpvals'><p>Form a particular linear combination of two time series and</p>
assess the combination's stationarity p-value</a></li>
<li><a href='#lacv'><p>Computes localized (wavelet) autocovariance function</p></a></li>
<li><a href='#LCTS'><p>Computes a Linear Combination Test Statistics</p></a></li>
<li><a href='#LCTSres'><p>Plots solutions that are identified by findstysols</p></a></li>
<li><a href='#localvar'><p>Compute the time-localized (unconditional) variance for a time series</p></a></li>
<li><a href='#mergexy'><p>Concatenate a set of solution results into one set</p></a></li>
<li><a href='#plot.BootTOS'><p>Plots results of a Bootstrap Test of Stationarity</p></a></li>
<li><a href='#plot.csBiFunction'><p>Plot a <code>csBiFunction</code> object</p></a></li>
<li><a href='#plot.csFSS'><p>Plot a <code>csFSS</code> object.</p></a></li>
<li><a href='#plot.csFSSgr'><p>Produce plots from a <code>csFSSgr</code> object.</p></a></li>
<li><a href='#plot.lacv'><p>Plot localized autocovariance (lacv) object.</p></a></li>
<li><a href='#plotBS'><p>Compute p-value for parametric Monte Carlo test and optionally</p>
plot test statistic values</a></li>
<li><a href='#print.csBiFunction'><p>Print a <code>csBiFunction</code> object.</p></a></li>
<li><a href='#print.csFSS'>
<p>Print a<code>csFSS</code> object.</p></a></li>
<li><a href='#print.csFSSgr'><p>Print <code>csFSSgr</code> object.</p></a></li>
<li><a href='#print.lacv'><p>Print lacv class object</p></a></li>
<li><a href='#prodcomb'><p>Combine two time series using a time-varying linear combination.</p></a></li>
<li><a href='#SP500FTSElr'><p>Log-returns time series of the SP500 and FTSE100 indices</p></a></li>
<li><a href='#sret'><p>Particular section of SP500 log-returns series.</p></a></li>
<li><a href='#summary.csBiFunction'><p>Summarize a <code>csBiFunction</code> object.</p></a></li>
<li><a href='#summary.csFSS'><p>Summarize a <code>csFSS</code> object.</p></a></li>
<li><a href='#summary.csFSSgr'><p>Summarize a <code>csFSSgr</code> object.</p></a></li>
<li><a href='#summary.lacv'><p>Summarizes a lacv object</p></a></li>
<li><a href='#TOSts'><p>A test statistic for stationarity</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Costationarity Determination</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14), wavethresh (&ge; 4.6.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions that can determine whether a time series
	is second-order stationary or not (and hence evidence for
	locally stationarity). Given two non-stationary series (i.e.
	locally stationary series) this package can then discover
	time-varying linear combinations that are second-order stationary.
	Cardinali, A. and Nason, G.P. (2013)
	&lt;<a href="https://doi.org/10.18637%2Fjss.v055.i01">doi:10.18637/jss.v055.i01</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 14:08:43 UTC; guynason</td>
</tr>
<tr>
<td>Author:</td>
<td>Guy Nason [aut, cre],
  Alessandro Cardinali [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guy Nason &lt;g.nason@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 21:32:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='costat-package'>Computes localized autocovariance and searches for costationary
solutions to bivariate time series.
</h2><span id='topic+costat-package'></span><span id='topic+costat'></span>

<h3>Description</h3>

<p>Computes a time-varying autocovariance and associated
plots for plotting this. Also can search for costationary
solutions between two time series.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+findstysols">findstysols</a></code> for help page for main function.
</p>


<h3>Author(s)</h3>

<p>Guy Nason, &lt;g.nason@imperial.ac.uk&gt;
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>, <code><a href="#topic+lacv">lacv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Compute localized acv
#
x &lt;- c(rnorm(128, sd=1), rnorm(128, sd=3))
xlacv &lt;- lacv(x, lag.max=30)
#
# Plot the time-varying autocovariance at time t=100
#
## Not run: plot(xlacv, type="acf", the.time=100, plotcor=FALSE)
#
# Plot the time-varying autocovariance at time t=400
#
## Not run: plot(xlacv, type="acf", the.time=400, plotcor=FALSE)
#
# See examples for findstysols for other examples
#
</code></pre>

<hr>
<h2 id='AntiAR'>Undo autoreflection action for an EWS object (wd stationary)
</h2><span id='topic+AntiAR'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+BootTOS">BootTOS</a></code> function has the ability to
deal with boundary conditions by augmenting the right-hand end of a time
series by a reflected version of that series. So, the series doubles
in length and the new vector has periodic boundary conditions. One
can then compute a local spectrum on this data which returns an EWS
in a <code>wd</code> object, usually with a type attribute of &quot;station&quot;.
This function can take this <code>wd</code> object and properly can return
the first half of it, which corresponds to the boundary-correct spectrum
of the original series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AntiAR(S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AntiAR_+3A_s">S</code></td>
<td>
<p>A <code>wd</code> class object of type &quot;station&quot;. This corresponds
to a EWS estimate on a reflected time series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function arises because using spectral estimation functions,
like <code>ewspec</code> from the <code>wavethresh</code> package doesn't
always work that well at the boundaries. This is because
the wavelet functions in <code>wavethresh</code> usually assume
periodic boundary conditions and this is not appropriate for
a discrete time series where time 1 and time T are usually
very different (and cannot be assumed to be the same).
</p>
<p>Hence, a previous function could generate a new time series by taking the
original, e.g. <code>x</code>, reflecting it with <code>rev(x)</code> and then
sticking the reflected onto the right-hand end of the original. 
Spectral estimation, (e.g. using <code>ewspec</code>) can then be applied
to this new reflected/augmented series and the boundaries are now
roughly correct as the start and end of the series correspond to time 1.
</p>
<p>The spectral estimate so obtained though is double the size of the
the one that is needed, and contains the spectrum of the reflected series.
Hence, this function obtains the first half of the estimate and returns
it.
</p>
<p>Not usually intended for the casual user
</p>


<h3>Value</h3>

<p>A <code>wd</code> class object containing the boundary-corrected
estimate of the spectrum for the original series.
</p>


<h3>Author(s)</h3>

<p>G. P. Nason.
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootTOS">BootTOS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate example, temporary series
#
x &lt;- rnorm(128)	
#
# Reflect it about its end point
#
x2 &lt;- c(x, rev(x))
#
# Compute EWS estimate
#
x2ews &lt;- ewspec(x2)
#
# Now get bit corresponding to x into object
#
xews &lt;- AntiAR(x2ews$S)
</code></pre>

<hr>
<h2 id='BootTOS'>Perform bootstrap stationarity test for time series</h2><span id='topic+BootTOS'></span>

<h3>Description</h3>

<p>Given a time series this function runs a bootstrap hypothesis
test to see whether it is stationary. The null hypothesis is that
the series is stationary, the alternative is that it is not -
and hence possesses a time-varying evolutionary wavelet spectrum
if deemed non-stationary. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootTOS(x, Bsims = 100, WPsmooth = TRUE, verbose = FALSE, plot.avspec = FALSE,
        plot.avsim = FALSE, theTS = TOSts, AutoReflect=TRUE, lapplyfn=lapply)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootTOS_+3A_x">x</code></td>
<td>
<p>Time series to test. Must have a power of two length</p>
</td></tr>
<tr><td><code id="BootTOS_+3A_bsims">Bsims</code></td>
<td>
<p>Number of bootstrap simulations to carry out</p>
</td></tr>
<tr><td><code id="BootTOS_+3A_wpsmooth">WPsmooth</code></td>
<td>
<p>Whether or not to carry out wavelet periodogram smoothing</p>
</td></tr>
<tr><td><code id="BootTOS_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> informative messages are printed</p>
</td></tr>
<tr><td><code id="BootTOS_+3A_plot.avspec">plot.avspec</code></td>
<td>
<p>If <code>TRUE</code> then the &lsquo;average&rsquo; evolutionary
wavelet spectrum (EWS) is plotted. This is called
<code class="reqn">\bar{S}_j</code> in the Cardinali and Nason paper.</p>
</td></tr>
<tr><td><code id="BootTOS_+3A_plot.avsim">plot.avsim</code></td>
<td>
<p>If <code>TRUE</code> for each bootstrap simulation
plot the time series of the simulated time series from the
average EWS (the one that might be plotted by <code>plot.avspec=TRUE</code></p>
</td></tr>
<tr><td><code id="BootTOS_+3A_thets">theTS</code></td>
<td>
<p>Specifies the particular test statistic to be used</p>
</td></tr>
<tr><td><code id="BootTOS_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>If TRUE then the series is reflected and augmented
by its end point on the RH-side, and the spectral quantities
are evaluated on that. Everything returned though applies only
to the original series, the reflection is merely to ensure that
the periodic wavelet algorithms can be used on non-periodic data</p>
</td></tr>
<tr><td><code id="BootTOS_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>List processing function. Parallel processing of
the bootstrap simulations can be achieved by using the <code>multicore</code>
package and the <code>mclapply</code> function. Sequential processing
can be achieved using the standard <code>lapply</code> function.
So, if you can't run multicore then you should use <code>lapply</code>,
otherwise try and use <code>mclapply</code> for
faster execution times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details of our testing methodology are set out in the
Cardinali and Nason paper referenced below.
</p>
<p>Essentially, the testing process works as follows. First, one
has to define a test statistic. Given a time series this has
return a statistic that measures &lsquo;degree of nonstationarity&rsquo;.
For example, estimating the EWS, and then computing the
sum of the sample variances of each scale is such as
measure (and known as the <code class="reqn">T_{vS}</code> statistic).
This statistic is zero for a constant spectrum and positive
for non-constant spectrum (and generally larger for larger variations
of the spectrum).
</p>
<p>Once a test statistic T is selected then a parametric Monte Carlo
test can be used. First, T is computed on the series itself.
Then, for statistical assessment of the &lsquo;significance&rsquo; of the test
statistic the following procedure is carried out. Assuming, for
a moment that the time series is stationary, we estimate its
evolutionary wavelet spectrum (EWS) and then average this over
time (<code class="reqn">\bar{S}_j</code>). Then we use the function
<code>LSWsim</code> to simulate a time series whose EWS is the
constant, stationary, spectral estimate. Then we compute our
test statistic, <code class="reqn">T_b</code>, on this simulated series. 
</p>
<p>Then we calculate <code class="reqn">T_b</code> for <code>Bsim-1</code> simulations. The function
then returns <code>BSim</code> numbers. The first is the test statistic
computed on the actual data. The remaining ones are the test
statistic computed on the simulated stationary series.
</p>
<p>The idea being that if the time series is really stationary then
the first value will be comparable to the ones obtained by simulation.
If the time series is not stationary then the first test statistic
will be much larger than the ones obtained by simulation (since
the actual data T will have been computed on a time series with
varying spectrum, whereas the simulated ones are all computed on
constant spectra, and their variation is only due to sampling
variation).
</p>
<p>The test statistic supplied to this function (as argument
<code>theTS</code>) should take an EWS object as an argument.
For example, the WaveThresh function <code>ewspec</code>
produces a suitable spectral estimate in its <code>$S</code>
argument (both objects are actually examples of a 
non-decimated wavelet transform object, class <code>wd</code>).
</p>
<p>The function <code>plotBS</code> can be used the present the results
of this function in an interpretable form and calculate the
p-value of the test, although you should use the
generic <code>plot</code> function to call this.
</p>


<h3>Value</h3>

<p>A vector of length <code>Bsim</code>. The first entry is the value
of the test statistic computed on the data. The remaining
entries are boostrap values computed on the &lsquo;averaged&rsquo; EWS estimate
with constant spectrum.
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TOSts">TOSts</a></code>, <code><a href="#topic+plotBS">plotBS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Calculate test of stationarity on example we know to be stationary,
# a series of iid values
#
plot(BootTOS(rnorm(64), Bsims=10), plot=FALSE)
#
# The following text is what gets printed
#
#Realized Bootstrap is  0.04543729 
#p-value is  0.93 
#Series was stationary
#[1] 0.93
#
# The realized bootstrap value is the value of the test statistic on the
# actual data (0.0454 here).
#
# The p-value is also printed (this is just the number of simulated series
# test statistic values less than the actual test statistic) and returned.
#
# The text "Series is stationary" just means that the empirical p-value
# was greater than the nominal test size (alpha=0.05, by default).
#
# Let's now try another example with the series sret: note that if you
# have a slow single core machine, this can take a long time, so we don't
# run it in the examples. However, on a fastish machine it is quick, on
# a fast multicore machine it is really quick!
#
## Not run: plot(BootTOS(sret))
#
#Realized Bootstrap is  2.662611e-09 
#p-value is  0 
#Series was NOT stationary
#[1] 0
#
# In contrast to the previous example, the p-value is 0, hence indicative
# of non-stationarity.
#
</code></pre>

<hr>
<h2 id='COEFbothscale'>Produces plots from output of findstysol that attempt to
group different solutions.</h2><span id='topic+COEFbothscale'></span>

<h3>Description</h3>

<p>Uses hierarchical clustering and multidimensional scaling
to produce a plot of all the convergence stationary
solutions. These plots are designed to aid the user in
identifying &lsquo;unique&rsquo; sets of stationary solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COEFbothscale(l, plotclustonly = FALSE, StyPval=0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="COEFbothscale_+3A_l">l</code></td>
<td>
<p>An object returned by <code><a href="#topic+findstysols">findstysols</a></code>,
of class <code>csFSS</code>,
which contains the results of an optimization
to find solutions that correspond to stationary
series which are the time-varying linear combination
of two locally stationary time series.</p>
</td></tr>
<tr><td><code id="COEFbothscale_+3A_plotclustonly">plotclustonly</code></td>
<td>
<p>If <code>TRUE</code> then only produce the hierarchical
clustering plot.</p>
</td></tr>
<tr><td><code id="COEFbothscale_+3A_stypval">StyPval</code></td>
<td>
<p>The p-value by which solutions are deemed to be
stationary or not for inclusion into plots. If the p-value
for a particular solution is greater than <code>StyPval</code> then
the solution is deemed stationary and included.</p>
</td></tr>
<tr><td><code id="COEFbothscale_+3A_...">...</code></td>
<td>
<p> Additional arguments to the hierarchical clustering plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+findstysols">findstysols</a></code> uses numerical
optimization to try and discover time-varying linear combinations
of two time series to find a combination which is stationary.
Like many numerical optimizations the optimizer is supplied with
starting coordinates and proceeds through an optimization
routine to end coordinates which are located at the minimum
(in this case). So, the user has a choice over where to start
each optimization.
</p>
<p>A priori there is no recipe for knowing where to start the
optimizer, so such situations are usually handled by running
the optimizer many time each time starting in a different position.
The solution here is to start from a set of different randomly
chosen starting points. After the optimizer is run from these
different starting positions it ends up in the same number of
potentially different ending positions.
</p>
<p>However, some of the ending solutions might be identical,
some might be very close, some might be reflections (e.g.
the if the coefficients (a,b) result in a stationary solution then
so does (-a, -b)). Morally, though, all of these cases would
reference the same solution.
</p>
<p>Hence, we require some method for identifying the set of unique
solutions. We can be considerably aided in this task by
multidimensional scaling (which uses inter-solution distances
to produce a map of how close solution sets really are)
or hierarchical clustering (which can produce a nice picture
to indicate how the solutions might be related).
</p>
<p>In other words, the solution vectors can be viewed as a
multivariate data set where the cases correspond to the results
of different optimization runs and the variables correspond	
to the coefficients of the time-varying linear combinations.
</p>
<p>Both multidimensional scaling (<code>cmdscale</code>) and
hiearchical clustering (<code>hclust</code>) are used to determine
possible clusterings of solutions. Then, representative members
from these clusters can be further investigated with a function
such as <code><a href="#topic+LCTSres">LCTSres</a></code>
</p>


<h3>Value</h3>

<p>An object of class <code>csFSSgr</code> is returned containing the
following components: the results of the multidimensional scaling
and hierarchical
clustering are returned as list with two components
<code>epscale</code> and <code>epclust</code> respectively, and
the input <code>l</code> object is returned as component <code>x</code>
and the <code>StyPval</code> object is returned as a component.  </p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>, <code><a href="#topic+LCTSres">LCTSres</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example in findstysols
#
</code></pre>

<hr>
<h2 id='coeftofn'>Convert wavelet coefficients for two time-varying functions
into two functions with respect to time.</h2><span id='topic+coeftofn'></span>

<h3>Description</h3>

<p>In much of the costationarity code the combination functions
are represented in terms of wavelet coefficients. At certain
points the actual combination functions themselves are required
(in the time domain) for purposes such as actually forming the
linear combination. This function turns the coefficients, for
the two combination functions, into their time domain functional
representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeftofn(alpha, beta, n = 256, filter.number = 1,
	family = c("DaubExPhase", "DaubLeAsymm"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coeftofn_+3A_alpha">alpha</code></td>
<td>
<p>One set of coefficients for one of the combination functions</p>
</td></tr>
<tr><td><code id="coeftofn_+3A_beta">beta</code></td>
<td>
<p>The other set of coefficients</p>
</td></tr>
<tr><td><code id="coeftofn_+3A_n">n</code></td>
<td>
<p>The length of resulting function that you require</p>
</td></tr>
<tr><td><code id="coeftofn_+3A_filter.number">filter.number</code></td>
<td>
<p>The type of wavelet (the number of vanishing moments)</p>
</td></tr>
<tr><td><code id="coeftofn_+3A_family">family</code></td>
<td>
<p>The type of wavelet (the wavelet family)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A degree of efficiency is built into the code. Typically, for
forming stationary linear combinations then only a few (or at least
a medium number) of coarser scale coefficients need to be
manipulated (eg modified in the optimizer). However, the
actual length of the function (time series length) is typically
much longer (e.g. n=256, n=512, or higher). So, this function
pads out the small number of coarse coefficients with zeros
before forming the combination functions which end up at the
correct length, n.  
</p>


<h3>Value</h3>

<p>An object of class <code>csBiFunction</code> which is
list containing two components:
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>A vector, of length n, containing one of the time-varying
combination functions</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Same as <code>alpha</code>, but contains the other combination
function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCTS">LCTS</a></code>, <code><a href="#topic+LCTSres">LCTSres</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Very artifical example
#
tmp.a &lt;- c(1, -1)
tmp.b &lt;- c(0.5, 0.5)
#
#
#
ans &lt;- coeftofn(tmp.a, tmp.b)
#
# Print it out
#
ans
#Class 'csBiFunction' : Contains two sampled functions:
#       ~~~~  : List with 2 components with names
#              alpha beta 
#
#
#summary(.):
#----------
#Length of functions is:  256 
</code></pre>

<hr>
<h2 id='EWSsmoothRM'>Perform running mean smoothing of an EWS object
</h2><span id='topic+EWSsmoothRM'></span>

<h3>Description</h3>

<p>Performs running mean smoothing of bandwidth s of
an EWS, such as that returned by the <code>ewspec</code> function
of <code>wavethresh</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EWSsmoothRM(S, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EWSsmoothRM_+3A_s">S</code></td>
<td>
<p>The spectrum to smooth
</p>
</td></tr>
<tr><td><code id="EWSsmoothRM_+3A_s">s</code></td>
<td>
<p>The bandwidth (or number of ordinates to include in the
running mean) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each level of the EWS is subject to a running mean smooth.
After smoothing a level the resultant smooth is shorter than
the original level (due to the mean not being able to
overlap the boundaries). This deficit is made up by augmenting
the start of the smooth with a right number of smoothed values
taken from the first smoothed value.
</p>


<h3>Value</h3>

<p>A EWS object contained in a <code>wd</code> object of type &quot;station&quot;
which contains the smoothed spectrum.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lacv">lacv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make dummy time series
#
x &lt;- rnorm(128)
#
# Compute spectrum, but don't do smoothing
#
xews &lt;- ewspec(x, WPsmooth=FALSE)$S
#
# Now smooth the spectrum using running mean smoothing with bandwidth of 5
#
ans &lt;- EWSsmoothRM(xews, s=5)
</code></pre>

<hr>
<h2 id='extractCS'>Extractor function for <code>csFSS</code> object.</h2><span id='topic+extractCS'></span>

<h3>Description</h3>

<p>Get much information from the slots of a <code>csFSS</code>.
Each slot can carry information from multiple solutions
per slot. This function permits an arbitrary selection of
solutions for information from a slot.	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCS(object, slot=c("startpar", "endpar", "convergence",
	"minvar", "pvals", "lcts"), coeftype=c("all", "alpha", "beta",
	"alphafunc", "betafunc"), solno, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCS_+3A_object">object</code></td>
<td>
<p>The <code>csFSS</code> object that you want to extract
information from.</p>
</td></tr>
<tr><td><code id="extractCS_+3A_slot">slot</code></td>
<td>
<p>The slot that you want to get information on. These
are <code>startpar</code>: the starting parameters for
the optimization for each solution;
<code>endpar</code>: the final parameters calculated by the
optimization for each solution;
<code>convergence</code>: the status codes returned by
the optimization for each solution;
<code>minvar</code>: the minimum variance of the spectral
estimate at the optimial solution, one for each
solution;
<code>pvals</code>: the p-values for the test of stationarity
for the final optimal parameter set;
<code>lcts</code>: the (time-varying) linear combination of
the time series, one for each solution. These are the Z_t
time series, the combined series which are meant to be
stationary.
</p>
<p>The <code>startpar</code>, <code>endpar</code> and <code>lcts</code> slots return
result in
one vector for each solution requested, organized as a matrix.
Each row of the matrix corresponds to one of the solutions
requested. The remaining slots return numbers, one number for
each solution organized as a vector.</p>
</td></tr>
<tr><td><code id="extractCS_+3A_coeftype">coeftype</code></td>
<td>
<p>For the slots that return coefficients, these can
be returned in various ways. Each coefficient vector (one per
solution) actually stores two sets of coefficients: one associated
with the alpha_t linear combination and the other with
the beta_t linear combination. Setting <code>coeftype</code> to
the following causes the following to happen:
<code>all</code>: the complete vector of coefficients is returned
(these are actually wavelet coefficients corresponding to
the wavelet specification in the <code>csFSS</code> object);
<code>alpha</code>: only the alpha_t coefficients are returned;
<code>beta</code>: only the beta_t coefficients are returned;
<code>alphafunc</code>: the alpha_t function (in the time domain)
is returned, ie as a function in time rather than a set of
transform coefficients;
<code>betafunc</code>: as for <code>alphafunc</code> but for the beta_t
function.
</p>
</td></tr>
<tr><td><code id="extractCS_+3A_solno">solno</code></td>
<td>
<p>The indices of which solutions you want the information
on</p>
</td></tr>
<tr><td><code id="extractCS_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+coeftofn">coeftofn</a></code>. For example,
by default the length of the functional representations of
alpha_t and beta_t is 256 caused by the default <code>n=256</code>
of the <code><a href="#topic+coeftofn">coeftofn</a></code></p>
</td></tr></table>
<p> argument. 
</p>


<h3>Details</h3>

<p>Extracts slot information from <code>csFSS</code> objects.
</p>


<h3>Value</h3>

<p>Information from the relevant slot, as a number, vector or
matrix depending on what it is that is requested as described
in the various arguments above.
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>, <code><a href="#topic+coeftofn">coeftofn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create dummy data
#
x1 &lt;- rnorm(32)
y1 &lt;- rnorm(32)
#
# Find stationary combinations
# Note: we don't run this example in installation/package formation as
# it takes a long time. However, this precise command IS run in
# the help to findstysols
#
## Not run: ans &lt;- findstysols(Nsims=100, tsx=x1, tsy=y1)
#
# Get the optimal (endpar) alphas for the first 10 solutions
#
## Not run: extractCS(ans, slot="endpar", coeftype="alpha", solno=1:10)
#
# Plot the beta_t associate with the optimal solution for solution 29
#
## Not run: ts.plot(extractCS(ans, slot="endpar", coeftype="betafunc",
	solno=29))
## End(Not run)
#
# Get the p-value associated with solution 29
#
## Not run: extractCS(ans, slot="pvals", solno=29)
</code></pre>

<hr>
<h2 id='findstysols'>Given two time series find some time-varying linear combinations
that are stationary.
</h2><span id='topic+findstysols'></span>

<h3>Description</h3>

<p>Find some time-varying linear combinations of two
time series that are stationary. The complexity of the
time-varying combinations is restricted by the <code>Ncoefs</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findstysols(Nsims = 100, Ncoefs = 3, tsx, tsy, sf=100, plot.it = FALSE,
        print.it=FALSE, verbose = FALSE, lctsfn=LCTS, prodcomb.fn=prodcomb,
        filter.number=1, family=c("DaubExPhase", "DaubLeAsymm"),
	my.maxit=500, spec.filter.number=1,
	spec.family=c("DaubExPhase","DaubLeAsymm"),
        optim.control=list(maxit=my.maxit, reltol=1e-6),
        irng=rnorm, lapplyfn=lapply, Bsims=200, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findstysols_+3A_nsims">Nsims</code></td>
<td>
<p>Number of searches attempted</p>
</td></tr> 
<tr><td><code id="findstysols_+3A_ncoefs">Ncoefs</code></td>
<td>
<p>Number of Haar wavelet coefficients to use. Must be
&gt;= 1. Should only increase in steps of powers of two. E.g.
can only supply the values 1, 3, 7, 15, etc. So, &quot;1&quot; means
only one coarse scale coefficient (corresponds to piecewise constant
with one centrally located jump), &quot;3&quot; means one coarse, and two
next coarse scale coefficients (corresponds to piecewise constant
with 4 equally sized piece with jumps at 1/4, 1/2 and 3/4), &quot;7&quot;
means one coarse, two next coarse, four next coarse, and so on. </p>
</td></tr>
<tr><td><code id="findstysols_+3A_tsx">tsx</code></td>
<td>
<p>One of the time series</p>
</td></tr>
<tr><td><code id="findstysols_+3A_tsy">tsy</code></td>
<td>
<p>The other time series,  values at the same time locations
as <code>tsx</code></p>
</td></tr>
<tr><td><code id="findstysols_+3A_sf">sf</code></td>
<td>
<p>A scale factor to multiply both time series by (not really
of much use)</p>
</td></tr>
<tr><td><code id="findstysols_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> then the <code>plot.it</code> argument passed
to <code><a href="#topic+LCTS">LCTS</a></code> via <code>optim</code> is made <code>TRUE</code>.
This has the effect of plotting the results of every trial in
the optimation (what actually is plotted is described in the
help to <code><a href="#topic+LCTS">LCTS</a></code></p>
</td></tr>
<tr><td><code id="findstysols_+3A_print.it">print.it</code></td>
<td>
<p>Not currently used in this function, reserved for
future use</p>
</td></tr>
<tr><td><code id="findstysols_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then helpful messages get printed.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_lctsfn">lctsfn</code></td>
<td>
<p>The function to compute the 'linear combination
test of stationarity'. I.e. it is the function that
combines the two series and returns the value of the test
statistic on the combination.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_prodcomb.fn">prodcomb.fn</code></td>
<td>
<p>The function that can produce the linear combination
of the two time series and return the combination, and optionally
vectors containing the combination functions.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_filter.number">filter.number</code></td>
<td>
<p>Gets passed to <code>lctsfn</code> and <code>prodcomb.fn</code></p>
</td></tr>
<tr><td><code id="findstysols_+3A_family">family</code></td>
<td>
<p>Gets passed to <code>lctsfn</code> and <code>prodcomb.fn</code></p>
</td></tr>
<tr><td><code id="findstysols_+3A_my.maxit">my.maxit</code></td>
<td>
<p>Maximum number of iterations in the optimization.
May need to be increased to, e.g. 1000 or 2000 for longer
time series (e.g. T=2048)</p>
</td></tr>
<tr><td><code id="findstysols_+3A_spec.filter.number">spec.filter.number</code></td>
<td>
<p>Wavelet filter number. This argument
gets passed to the <code>lctsfn</code> and is used for the wavelet
for all spectral smoothing.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_spec.family">spec.family</code></td>
<td>
<p>Same as <code>spec.filter.number</code> but for the wavelet
family.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_optim.control">optim.control</code></td>
<td>
<p>Argument passed to the <code>optim</code> optimizer as
its <code>control</code> argument. <code>optim</code> 
performs optimization. See help page for <code>optim</code>.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_irng">irng</code></td>
<td>
<p>Random number generator used to generate coefficients
for starting parameters for the linear combination of time
series (actually wavelet coefficients of the combination
functions)</p>
</td></tr>
<tr><td><code id="findstysols_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>Function to use to process lists. If this argument
is <code>mclapply</code> then the multicore library function 
<code>mclapply</code> is used to parallel process the lists.
If you don't have multicore then the <code>lapply</code> function
can be used to process things sequentially.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_bsims">Bsims</code></td>
<td>
<p>The number of bootstrap simulations for the (single)
test of stationarity <code><a href="#topic+BootTOS">BootTOS</a></code>.</p>
</td></tr>
<tr><td><code id="findstysols_+3A_...">...</code></td>
<td>
<p>Other arguments, passed to the <code>optim</code> call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches for time-varying linear combinations of
two time series, <code>tsa</code> and <code>tsy</code>, such that the combination
is stationary (according to the <code><a href="#topic+TOSts">TOSts</a></code> test statistic).
</p>
<p>Each linear combination is parametrised by a coarse scale
Haar wavelet decomposition (controlled by <code>Ncoefs</code>).
Initially, the Haar wavelet coefficients (up to a fixed finite scale,
controlled by <code>Ncoefs</code>) are randomly chosen. These coefficients
are converted to functions <code class="reqn">\alpha_t, \beta_t</code>
by the <code><a href="#topic+coeftofn">coeftofn</a></code> function and then a linear combination
with the time series is formed out of those and the time series,
i.e.
<code class="reqn">Z_t = \alpha_t x_t + \beta_t y_t</code>
The non-stationarity of <code class="reqn">Z_t</code> is measured using the
<code><a href="#topic+TOSts">TOSts</a></code> test statistic and this value is minimized
over the coarse scale Haar wavelet coefficients.
</p>
<p>This optimization procedure is repeated <code>Nsims</code> times.
If the <code>lapplyfn</code> is set to <code>mclapply</code> then this
function from the <code>multicore</code> package is used to process
the lists in parallel. 
</p>
<p>This function can be called multiple times (e.g. on different
processors in a multiprocessor environment. The result sets from
different runs can be combined using the
<code><a href="#topic+mergexy">mergexy</a></code> function.
</p>
<p>The variance <code>Ncoefs</code> is very important, it controls the
complexity of the linear combinations. If it is too big the
linear combinations themselves can be extremely oscillatory and
stationarity is easy to obtain. Small values of <code>Ncoefs</code>
results in piecewise constant functions with fewer jumps.
</p>
<p>The <code>Ncoefs</code> value must take the value of
<code class="reqn">2^k - 1</code>. If this is the case the <code class="reqn">k</code>
is the number of scale levels present in the Haar representation
of the combining function <code class="reqn">\alpha_t, \beta_t</code>
(excluding the scaling function coefficient, just the wavelet
coefficients from the coarsest scale).
</p>
<p>The functions to compute the linear combination and also the
test statistic on that combination, and just to compute the
combination and return also (optionally) the combination
vectors are supplied in <code>lctsfn</code> and <code>prodcomb.fn</code>.
By default, these are just the <code>LCTS</code> and <code>prodcomb</code>
functions. However, it is possible to recode these to
look at operating on combinations that operate on portfolios.
I.e. rather than look at linear combinations of log-returns
(which if <code>tsx</code> and <code>tsy</code> were) one can look at
linear combinations of actual series (ie portfolios) and
then look for stationarity of log-returns of the portfolios.
These functions will be made available in a later package.
</p>


<h3>Value</h3>

<p>An object of class <code>csFSS</code> which is a
list with the following components.
</p>
<table role = "presentation">
<tr><td><code>startpar</code></td>
<td>
<p>A matrix with <code>Nsims</code> rows and <code>2*Ncoefs</code>
columns containing the initial random coefficients of the
linear combination functions, one row for each optimization
run. The first <code>Ncoefs</code> numbers on each row correspond to
the <code class="reqn">\alpha_t</code> coefficients, the second <code>Ncoefs</code>
numbers correspond to the <code class="reqn">\beta_t</code> coefficients.</p>
</td></tr>
<tr><td><code>endpar</code></td>
<td>
<p>Same dimension as <code>startpar</code> except containing
the final coefficients obtained after running the optimizer.
If, for a particuar run, the optimizer converged and the p-value
is less than 0.05 then one can say that this solution represents
a valid time-varying linear combination where the combination
is stationary (coefficient storage format as for <code>startpar</code>).</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A vector of length <code>Nsims</code>. Reports the convergence
code from <code>optim</code> for each optimization run. A value of
0 indicates successful convergence.</p>
</td></tr>
<tr><td><code>minvar</code></td>
<td>
<p>A vector of length <code>Nsims</code>. Contains the minimum
variance achieved on each run.</p>
</td></tr>
<tr><td><code>pvals</code></td>
<td>
<p>A vector of length <code>Nsims</code>. Contains the p-values
achieved on each run.</p>
</td></tr>
<tr><td><code>tsx</code></td>
<td>
<p>The <code>tsx</code> time series that was supplied to this function</p>
</td></tr>
<tr><td><code>tsy</code></td>
<td>
<p>The <code>tsy</code> time series that was supplied to this function</p>
</td></tr>
<tr><td><code>tsxname</code></td>
<td>
<p>The name of the <code>tsx</code> object that was supplied</p>
</td></tr>
<tr><td><code>tsyname</code></td>
<td>
<p>The name of the <code>tsy</code> object that was supplied</p>
</td></tr>
<tr><td><code>filter.number</code></td>
<td>
<p>The filter number that was used</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The wavelet family that was used</p>
</td></tr>
<tr><td><code>spec.filter.number</code></td>
<td>
<p>The filter number that was used</p>
</td></tr>
<tr><td><code>spec.family</code></td>
<td>
<p>The wavelet family that was used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LCTS">LCTS</a></code>, <code><a href="#topic+BootTOS">BootTOS</a></code>,<code><a href="#topic+plotBS">plotBS</a></code>, <code><a href="#topic+prodcomb">prodcomb</a></code>, <code><a href="#topic+COEFbothscale">COEFbothscale</a></code>,
<code><a href="#topic+LCTSres">LCTSres</a></code>, <code><a href="#topic+print.csFSS">print.csFSS</a></code>, <code><a href="#topic+summary.csFSS">summary.csFSS</a></code>,
<code><a href="#topic+plot.csFSS">plot.csFSS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Find some stationary solutions with \code{Ncoefs=3}.
#
# Note: this is a toy example
#
tsx1 &lt;- rnorm(32)	# A x time series
tsy1 &lt;- rnorm(32)	# A y time series
#
# Find costationary solutions, but only from 2 random starts
#
# Typically, the length of tsx and tsy would be bigger (eg sret, fret are
# other examples you might use). Also, Nsims would be bigger, you need
# to use many random starts to ensure good coverage of the solution
# space, e.g. Nsims=100
#
# Note: the following examples are not run so as to adhere to CRAN
# requirements for package execution timings
#
## Not run: ans &lt;- findstysols(Nsims=3, tsx=tsx1, tsy=tsy1)
#
# Print out a summary of the results
#
## Not run: ans
#Class 'csFSS' : Stationary Solutions Object from costat:
#       ~~~~~  : List with 13 components with names
#              startpar endpar convergence minvar pvals tsx tsy tsxname tsyname
#		filter.number family spec.filter.number spec.family 
#
#
#summary(.):
#----------
#Name of X time series:  tsx1 
#Name of Y time series:  tsy1 
#Length of input series:  32 
#There are  3  sets of solutions
#Each solution vector is based on  3  coefficients
#Some solutions did not converge, check convergence component for more information.
#Zero indicates successful convergence, other values mean different things and
#you should consult the help page for `optim' to discover what they mean
#For size level:  0.05 
#	 0  solutions appear NOT to be stationary
#	 3  solutions appear to be stationary
#Range of p-values: ( 0.93 , 0.995 )
#
#Wavelet filter for combinations:  1   DaubExPhase 
#Wavelet filter for spectrum:  1   DaubExPhase 
#
#______________
#
# Ok. The printout above suggests that some solutions did not converge.
# Which ones?
#
## Not run: ans$convergence
# [1] 0 1 0 
#
# The second one did not converge, the others did. Good. The printout
# above also indicates that all the resultant solutions were stationary
# (this is not surprising for this example, as the inputs tsx1 and tsy1
# are stationary, and indeed iid).
#
# Let's see how the solutions compare. For example, let's plot the
# hierarchical cluster analysis of the final solutions (those that
# converged and are stationary)
#
## Not run: plot(ans, ALLplotscale=FALSE)
#
# My cluster shows that solution 1 and 3 are similar. Let's
# view solution 3.
#
## Not run: oldpar &lt;- par(mfrow=c(2,2))
## Not run: plot(ans, solno=3)
## Not run: par(oldpar)
</code></pre>

<hr>
<h2 id='fret'>Particular section of FTSE log-return series.</h2><span id='topic+fret'></span>

<h3>Description</h3>

<p>Observations 256:767 from the SP500 log-returns series
stored in <code><a href="#topic+SP500FTSElr">SP500FTSElr</a></code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fret)</code></pre>


<h3>Format</h3>

<p>A vector of 512 observations of the FTSE100 log-returns series
</p>


<h3>Details</h3>

<p>Its just more convenient to refer to <code>fret</code> than to
<code>SP500FTSElr[256:767,3]</code>.
</p>


<h3>Source</h3>

<p>Yahoo! Finance
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ts.plot(fret)
</code></pre>

<hr>
<h2 id='getpvals'>Form a particular linear combination of two time series and
assess the combination's stationarity p-value
</h2><span id='topic+getpvals'></span>

<h3>Description</h3>

<p>Given two time series, a set of combination coefficients,
a function to combine them, this function makes the combination,
tests the combination for stationarity, and returns the pvalue.
Effectively, returns &quot;how stationary&quot; the combination is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpvals(par, prodcomb.fn, tsx, tsy, filter.number,
	family=c("DaubExPhase", "DaubLeAsymm"),
	verbose, tos = BootTOS, Bsims = 100, lapplyfn = lapply)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpvals_+3A_par">par</code></td>
<td>
<p>The coefficients used to make the combination via the
<code>prodcomb.fn</code> function.
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_prodcomb.fn">prodcomb.fn</code></td>
<td>
<p>The function which computes the combination given
the two time series and the combination parameters.
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_tsx">tsx</code></td>
<td>
<p>One of the time series.
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_tsy">tsy</code></td>
<td>
<p>The other time series.
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_filter.number">filter.number</code></td>
<td>
<p>Wavelet smoothness to be used in the time series
combination.
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_family">family</code></td>
<td>
<p>Wavelet family to be used in the time series combination.
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_verbose">verbose</code></td>
<td>
<p>Supplied directly to the call to <code>plotBS</code> function.
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_tos">tos</code></td>
<td>
<p>The function the computes a test of stationarity
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_bsims">Bsims</code></td>
<td>
<p>Number of bootstrap simulations the test uses (if it does)
</p>
</td></tr>
<tr><td><code id="getpvals_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>The function used to process lists. Can be the regular
<code>lapply</code>. If you have <code>multicore</code> package then can
be the <code>mclapply</code> parallel processing to process the bootstraps
in parallel.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number between zero and one indicating the p-value from
the hypothesis test of stationarity of the combination.
</p>


<h3>Author(s)</h3>

<p>G. P. Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate two toy time series data sets
#
x1 &lt;- rnorm(32)
y1 &lt;- rnorm(32)
#
# Generate two toy sets of parameters (for combination)
#
tmp.a &lt;- c(1,-1)
tmp.b &lt;- c(0.5, 0.5)
#
# Call the function and find out the degree of stationarity of this
# combination
#
## Not run: ans &lt;- getpvals(c(tmp.a, tmp.b), prodcomb.fn=prodcomb, tsx=x1, tsy=y1,
        filter.number=1, family="DaubExPhase")
## End(Not run)
#
# What is the p-value?
#
## Not run: ans
# [1] 0.53
</code></pre>

<hr>
<h2 id='lacv'>Computes localized (wavelet) autocovariance function</h2><span id='topic+lacv'></span>

<h3>Description</h3>

<p>Compute the LACV function for a locally
stationary wavelet process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lacv(x, filter.number = 10,
	family = c("DaubExPhase", "DaubLeAsymm"), smooth.dev=var,
	AutoReflect=TRUE, lag.max=NULL, smooth.RM=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lacv_+3A_x">x</code></td>
<td>
<p>The time series you want to compute the LACV for</p>
</td></tr>
<tr><td><code id="lacv_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet that you wish to compute the LACV
with respect to</p>
</td></tr>
<tr><td><code id="lacv_+3A_family">family</code></td>
<td>
<p>The wavelet family</p>
</td></tr>
<tr><td><code id="lacv_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>The deviance used in smoothing if running mean smoothing
is not used, ie in the call to <code>ewspec</code>.</p>
</td></tr>
<tr><td><code id="lacv_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>If TRUE then the spectrum is computed on a boundary-corrected series, overcoming the lack of periodicity in the time series.</p>
</td></tr>
<tr><td><code id="lacv_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum lag that the function computes. If this option
is <code>NULL</code> then the largest possible will be computed and used</p>
</td></tr>
<tr><td><code id="lacv_+3A_smooth.rm">smooth.RM</code></td>
<td>
<p>If this is zero then regular wavelet smoothing of the
periodogram will be used. If not zero then running mean smoothing
of the periodogram will be used with a bandwidth given by
this argument.</p>
</td></tr>
<tr><td><code id="lacv_+3A_...">...</code></td>
<td>
<p> Additional arguments to the spectrum computation
contained within</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A locally stationary wavelet process is a particular kind
of non-stationary time series constructed out of wavelet
atoms, with a time-varying spectrum (slowly varying).
This kind of model is useful for time series whose spectral
properties change over time. 
</p>
<p>The time-varying spectrum can be computed from within the
WaveThresh library by the <code>ewspec</code> function. However,
just as in the classical stationary case, where the
spectrum and autocovariance are a Fourier transform pair, the
paper Nason, von Sachs, Kroisandt (2000) [NvSK2000] shows that the
evolutionary wavelet spectrum is paired to a localized
autocovariance function using a wavelet-like transform.
This is expressed in formula (14) of the NvSK2000 paper.
</p>
<p>This function computes the localized autocovariance by
first computing the estimate of the evolutionary spectrum,
and then directly transforming it using formula (14) via
the autocorrelation wavelet transform.
</p>


<h3>Value</h3>

<p>An object of class <code>lacv</code>. This is a list with the following
components: <code>lacv</code> which is a matrix that contains the localized
autocovariance.
If the original time series was of length T, then the number
of rows of the returned matrix is also T, one row for each time
point.
The columns of the array correspond to the lag. The number of
columns, 2K+1,  depends both on the length of the time series and
also the order of the wavelet (smoother wavelets return
lacv matrices with larger number of lags). Lag 0 is always
the centre column, with negative lags from -K to -1 are
the leftmost columns, lags from 1 to K are the rightmost columns;
<code>lacr</code>: a matrix, with the same dimensions as <code>lacv</code>
but containing the local autocorrelations; <code>date</code>: the date
this function was executed.
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>
<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (2000) Wavelet
processes and adaptive estimation of the evolutionary wavelet
spectrum. <em>J. R. Statist. Soc. B</em>, <b>62</b>, 271-292.
</p>


<h3>See Also</h3>

<p><code>ewspec</code>, <code><a href="#topic+print.lacv">print.lacv</a></code>, <code><a href="#topic+plot.lacv">plot.lacv</a></code>,
<code><a href="#topic+summary.lacv">summary.lacv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate an AR(1) time series
#
vsim &lt;- arima.sim(model=list(ar=0.8), n=1024)
#
# Compute the ACF of this stationary series
#
vsim.acf &lt;- acf(vsim, plot=FALSE)
#
# Compute the localized autocovariance. We'll use
# a reasonably smooth wavelet.
#
vsim.lacv &lt;- lacv(vsim, filter.number=4, lag.max=30)
#
# Now plot the time-varying autocorrelations, only the first 5 lags
#
## Not run: plot(vsim.lacv, lags=0:5)
#
# Now plot the localized autocorrelation at time t=100, a plot similar
# to the usual R acf plot.
#
## Not run: plot(vsim.lacv, type="acf", the.time=100)
</code></pre>

<hr>
<h2 id='LCTS'>Computes a Linear Combination Test Statistics</h2><span id='topic+LCTS'></span>

<h3>Description</h3>

<p>Given a particular linear combination, specified in terms of
coefficients, cfs, this functions forms the linear combination of
two time series, tsx, tsy and returns the result of a stationarity
test statistic on the combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCTS(cfs, tsx, tsy, filter.number = 1,
	family = c("DaubExPhase", "DaubLeAsymm"), plot.it = FALSE,
        spec.filter.number = 1,
	spec.family = c("DaubExPhase", "DaubLeAsymm"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCTS_+3A_cfs">cfs</code></td>
<td>
<p>Coefficients describing the linear combination vectors.
The first half correspond to the first vector (alpha) the second
half to the beta vector. Hence this vector must have an even length,
and each half has a length a power of two minus one.</p>
</td></tr>
<tr><td><code id="LCTS_+3A_tsx">tsx</code></td>
<td>
<p>The x time series</p>
</td></tr>
<tr><td><code id="LCTS_+3A_tsy">tsy</code></td>
<td>
<p>The y time series</p>
</td></tr>
<tr><td><code id="LCTS_+3A_filter.number">filter.number</code></td>
<td>
<p>This function turns the coefficients into a linear
combination function (e.g. alpha). This argument specifies the
filter.number of the inverse wavelet transform that turns coefficients	
into a lc function.</p>
</td></tr>
<tr><td><code id="LCTS_+3A_family">family</code></td>
<td>
<p>Same as filter.number but for the wavelet family</p>
</td></tr>
<tr><td><code id="LCTS_+3A_plot.it">plot.it</code></td>
<td>
<p>If TRUE then various things are plotted: both of the linear
combination vectors/time series, the combined time series and
its EWS estimate</p>
</td></tr>
<tr><td><code id="LCTS_+3A_spec.filter.number">spec.filter.number</code></td>
<td>
<p>The wavelet filter used to compute the EWS
estimate</p>
</td></tr>
<tr><td><code id="LCTS_+3A_spec.family">spec.family</code></td>
<td>
<p>The wavelet family used to compute the EWS estimate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function forms a time-varying linear combination of two
times series to form a third time series. Then a 'stationarity
test' test statistic is applied to the third time series to
compute how stationary (or non-stationary it is). This function
is called by <code><a href="#topic+findstysols">findstysols</a></code> and actually does the work
of forming the lc of two time series and gauging the stationarity</p>


<h3>Value</h3>

<p>A single number which is the value of the test of stationarity
for the combined time series. This is the result of <code><a href="#topic+TOSts">TOSts</a></code>
but normalized for the squared coefficient norm</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>, <code><a href="#topic+TOSts">TOSts</a></code>,
<code><a href="#topic+coeftofn">coeftofn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Apply this function to random combination coefficients.
#
# The combination coefficients: comprised of two vectors each of length 3
# Note that 3 = 2^2 - 1, vectors need to be of length a power two minus 1 
#
#	sret, fret are two time series in the package
#
data(sret)
data(fret)
LCTS( c(rnorm(3), rnorm(3)), sret, fret)
#[1] 1.571728e-13
#
# The value of the test statistic is 1.57e-13
</code></pre>

<hr>
<h2 id='LCTSres'>Plots solutions that are identified by findstysols</h2><span id='topic+LCTSres'></span>

<h3>Description</h3>

<p>Plots lots of useful information concerning solutions
identified using findstysols. It only plots those where the
optimizer converged. Can additionally return the time-varying
linear combination associated with any solution if plots are
turned off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCTSres(res, tsx, tsy, inc = 0, solno = 1:nrow(res$endpar), filter.number = 1,
  family = c("DaubExPhase", "DaubLeAsymm"), plot.it = FALSE,
  spec.filter.number = 1,
  spec.family = c("DaubExPhase", "DaubLeAsymm"), plotcoef = FALSE,
  sameplot = TRUE, norm = FALSE, plotstystat = FALSE,
  plotsolinfo = TRUE, onlyacfs = FALSE,
  acfdatatrans = I, xlab = "Time", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCTSres_+3A_res">res</code></td>
<td>
<p>Solution set returned by findstysols</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_tsx">tsx</code></td>
<td>
<p>The <code>x</code> time series</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_tsy">tsy</code></td>
<td>
<p>The <code>y</code> time series</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_inc">inc</code></td>
<td>
<p>Adds an increment to the x-axis values.</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_solno">solno</code></td>
<td>
<p>Which solution number to look at. This can be a vector of
solution numbers. The default is to look at all solutions (which
can be a lot, depending on how many you've got)</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter number to use in reconstructing
the linear combination function</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_family">family</code></td>
<td>
<p>The wavelet family to use in reconstructing the linear
combination function.</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_plot.it">plot.it</code></td>
<td>
<p>Currently unused in this function</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_spec.filter.number">spec.filter.number</code></td>
<td>
<p>This function computes the linear combination
time series and also then computes its EWS. 
The wavelet (<code>spec.filter.number</code> is the filter number of
this wavelet) used to compute the EWS can be different to the
one used to compute the linear combination, as the latter is
only a means to an end - e.g. in principle, other basis functions
could be use in the linear combination. Also the spectrum
computed is only used to assess its constancy, so could be
a locally stationary Fourier one.
</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_spec.family">spec.family</code></td>
<td>
<p>The family of the wavelet used to compute the spectrum</p>
</td></tr> 
<tr><td><code id="LCTSres_+3A_plotcoef">plotcoef</code></td>
<td>
<p>If TRUE then only the linear combination functions
are plotted. If FALSE then a (set of potentially multiple)
composite plot(s) are produced. These composite plots are what
are usually most useful.</p>
</td></tr> 
<tr><td><code id="LCTSres_+3A_sameplot">sameplot</code></td>
<td>
<p>If TRUE then the linear combination functions are plotted
on the same plot.</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_norm">norm</code></td>
<td>
<p>If TRUE then the linear combination functions are normalized
before plotting if <code>sameplot</code> is TRUE. This is so as to
be able to compare the patterns in each function without regard
to their overall size.</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_plotstystat">plotstystat</code></td>
<td>
<p>If TRUE (and if <code>plotcoef=FALSE</code>) this option
causes the function to plot statistics associated with the
stationary solution, <code class="reqn">Z_t</code>. The acf and partial acf are always
plotted. The time series plot of <code class="reqn">Z_t</code> and its spectrum are
optionally plotted too if <code>onlyacfs=FALSE</code>.</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_plotsolinfo">plotsolinfo</code></td>
<td>
<p>If TRUE (and if <code>plotsolinfo=FALSE</code>) this
option plots the <code class="reqn">\alpha_t</code> linear combination function,
the <code class="reqn">\beta_t</code> one (ie both of them),
the stationary linear combination
<code class="reqn">Z_t</code>,
and an estimate of the EWS of <code class="reqn">Z_t</code> computed using the
<code>spec.filter.number</code> and <code>spec.family</code> wavelet.
The variance associated with <code class="reqn">Z_t</code> (the minimizing variance from
the optimizer in <code><a href="#topic+findstysols">findstysols</a></code> and the p-value	
associated with the solution are displayed as plot titles.</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_onlyacfs">onlyacfs</code></td>
<td>
<p>Only plot the two acfs if <code>plotstystat=TRUE</code></p>
</td></tr>
<tr><td><code id="LCTSres_+3A_acfdatatrans">acfdatatrans</code></td>
<td>
<p>A function (e.g. <code>log</code>) to transform the series
before taking and displaying the acf functions.</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_xlab">xlab</code></td>
<td>
<p>An x label for the time series plots, and spectral plots</p>
</td></tr>
<tr><td><code id="LCTSres_+3A_...">...</code></td>
<td>
<p>Extra arguments for the acf plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+findstysols">findstysols</a></code> takes two time series
and attempts to find time-varying linear combinations of the
two that are stationary. If one is found, we call it <code class="reqn">Z_t</code>.
However, <code><a href="#topic+findstysols">findstysols</a></code> works by numerical optimization,
typically from random starts, and, generally, there is no unique
stationary solution. 
</p>
<p>This function takes the results obtained by <code><a href="#topic+findstysols">findstysols</a></code>
in an object called <code>res</code> and then for a set of solutions
already identifed by the user, and supplied to this function
via <code>solno</code>, this function takes each identified solution
in turn and produces a set of plots.
</p>
<p>Determining which solutions are interesting is another problem.
The <code><a href="#topic+COEFbothscale">COEFbothscale</a></code> is a useful function which
can analyze all solution sets simultaneously and, usually, arrange
them into groups which are mutually similar. Then representative
members from each group can be further analyzed by
<code>LCTSres</code>.
</p>
<p>Probably the most useful set of options is
<code>plotcoef=FALSE</code> and to issue a
<code>par(mfrow=c(2,2))</code> command prior to running
<code>LCTSres</code>. This produces the plots, four to a page,
and enables interesting features to be compared from plot to plot.
</p>
<p>The <code>plotcoef=FALSE</code> option causes four plots to be produced
(on the same page if <code>mfrow</code> is set as the previous paragraph
suggests). The first two are the (potentially) time-varying linear 
combination functions, the next is the stationary linear
combination, <code class="reqn">Z_t</code>, itself and the final plot is an estimate of
the <code class="reqn">Z_t</code>'s evolutionary wavelet spectrum. The titles of the latter
two plots display the process variance of <code class="reqn">Z_t</code> (the global
unconditional variance, because <code class="reqn">Z_t</code> is assumed to be stationary)
and the p-value associated the the hypothesis test of stationarity
of <code class="reqn">Z_t</code>. The spectral estimate show exhibit near constancy because
of the stationarity (as assessed by hypothesis test) of <code class="reqn">Z_t</code>.
</p>
<p>If <code>plotstystat=TRUE</code> then further plots are produced 
of the results of various classical time series analyses of <code class="reqn">Z_t</code>.
If <code>onlyacfs=TRUE</code> then only the acf and partial acf of <code class="reqn">Z_t</code>
are plotted, otherwise <code class="reqn">Z_t</code> and its classical spectrum are also
plotted (remember, <code class="reqn">Z_t</code>, has tested to be stationary and so these
classical methods are valid).
</p>
<p>If more than one solution is to be plotted, then the <code>scan()</code>
function is employed to pause the plots between plots.
</p>


<h3>Value</h3>

<p>The stationary solution, <code class="reqn">Z_t</code>, associated with the last solution
to be plotted is returned. Of course, if there is only one
solution to be plotted then it is the only possibility. Hence,
if all the <code>plot</code> arguments are FALSE then no plots are 
produced and the stationary linear combination of the (last)
solution number is returned.
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See examples in findstysols (the plot method for the results of
# findstysols make use of LCTSres)
</code></pre>

<hr>
<h2 id='localvar'>Compute the time-localized (unconditional) variance for a time series</h2><span id='topic+localvar'></span>

<h3>Description</h3>

<p>Compute the time localized variance from an evolutionary
wavelet spectrum of a time series</p>


<h3>Usage</h3>

<pre><code class='language-R'>localvar(spec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localvar_+3A_spec">spec</code></td>
<td>
<p>An evolutionary wavelet spectrum, such as that computed
by <code>ewspec</code> in WaveThresh.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One can compute the local variance of a time series by first
computing its evolutionary wavelet spectrum, e.g., by using
<code>ewspec</code>, and then applying <code>localvar</code> on the
<code>S</code> component of that returned by <code>ewspec</code>.
</p>


<h3>Value</h3>

<p>A vector representing the local variance estimate at successive
times.
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code>ewspec</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's look at a iid standard normal sequence, variance should be 1, always
# for all times.
#
zsim &lt;- rnorm(64)
#
# Note, in the following I use var as the method of deviance estimation,
# as described in the help there it can be more accurate when transformations
# are not used.
#
z.ews &lt;- ewspec(zsim, smooth.dev=var)$S
#
# Compute the local variance
#
z.lv &lt;- localvar(z.ews)
#
# Plot the local variance against time
#
## Not run: ts.plot(z.lv)
#
# Should be around 1. Note, the vertical scale of the plot might be
# deceptive, as R plots expand the function to the maximum available
# space. If you look again it should be quite close to 1 (e.g. on the
# example I am looking at now the variance is within +/- 0.15 of 1.
#
# However, it might not be close to 1 because the sample size is quite small,
# only 64, so repeat the above analysis with a larger sample size, e.g. 1024.
#
</code></pre>

<hr>
<h2 id='mergexy'>Concatenate a set of solution results into one set</h2><span id='topic+mergexy'></span>

<h3>Description</h3>

<p>Merges several sets of optimization results from
multiple calls to <code><a href="#topic+findstysols">findstysols</a></code> into 
a single object for further analysis</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergexy(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergexy_+3A_...">...</code></td>
<td>
<p>An unspecified number of arguments of class <code>csFSS</code>.
(usually a set of objects containing a set of optimization solutions,
such as that returned by <code><a href="#topic+findstysols">findstysols</a></code>)</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The return object from an invocation of the
<code><a href="#topic+findstysols">findstysols</a></code> is a list containing a number
of interesting components containing information about
the starting parameters, the (hopefully optimal) ending
parameters, convergence status, minimum variance achieved
and p-value associated with the final test of stationarity
after an optimization.
</p>
<p>It is possible to ask <code><a href="#topic+findstysols">findstysols</a></code> to execute
multiple optimization runs in the same function, by choice of
the <code>Nsims</code> parameter. However, for truly large runs,
it can be convenient to run multiple copies of
<code><a href="#topic+findstysols">findstysols</a></code>, for example on multiple processors
simultaneously (a coarse grained parallelism).
</p>
<p>In particular, for large time series, it can be useful to run
<code><a href="#topic+findstysols">findstysols</a></code> for <b>one</b> optimization run
(as running more than one for a very large series can cause the
software to fail as R can run out of memory. Actually, for very
very large series even one optmization run can fail for memory
reasons). 
</p>
<p>In this way multiple optimization runs can be executed with each
one producing its own set of results. This function
(<code>mergexy</code>) takes a list of object names of all of the results,
and merges the results into one object as if a single call
to <code><a href="#topic+findstysols">findstysols</a></code> had been executed. Such a single
set of results can then be passed on to further analysis
routines, such as <code><a href="#topic+COEFbothscale">COEFbothscale</a></code> or
<code><a href="#topic+LCTSres">LCTSres</a></code>.
</p>


<h3>Value</h3>

<p>A set of optimization solutions in the same format as
those returned by <code><a href="#topic+findstysols">findstysols</a></code></p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>, <code><a href="#topic+LCTSres">LCTSres</a></code>,
<code><a href="#topic+COEFbothscale">COEFbothscale</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate two dummy time series
#
x1 &lt;- rnorm(32)
y1 &lt;- rnorm(32)
#
# Run two optimizations 
#
## Not run: solnset1 &lt;- findstysols(Nsims=1, tsx=x1, tsy=y1)
## Not run: solnset2 &lt;- findstysols(Nsims=1, tsx=x1, tsy=y1)
#
# Merge them
#
## Not run: solnset &lt;- mergexy(solnset1, solnset2)
</code></pre>

<hr>
<h2 id='plot.BootTOS'>Plots results of a Bootstrap Test of Stationarity 
</h2><span id='topic+plot.BootTOS'></span>

<h3>Description</h3>

<p>Produces Bootstrap simulation result as a histogram
with a vertical line indicating the test statistic computed
on the actual data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BootTOS'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.BootTOS_+3A_x">x</code></td>
<td>
<p>The object you wish to get a plot on.
</p>
</td></tr>
<tr><td><code id="plot.BootTOS_+3A_...">...</code></td>
<td>
<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a histogram of all the bootstrap statistics
and the test statistic computed on the true data.
Also produces a vertical line indicating the position
of the true statistic.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootTOS">BootTOS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
v &lt;- rnorm(512)
## Not run: v.BootTOS &lt;- BootTOS(v)
## Not run: plot(v.BootTOS)
</code></pre>

<hr>
<h2 id='plot.csBiFunction'>Plot a <code>csBiFunction</code> object </h2><span id='topic+plot.csBiFunction'></span>

<h3>Description</h3>

<p>A <code>csBiFunction</code> object contains representations of
two functions. This function plots the two functions superimposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csBiFunction'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.csBiFunction_+3A_x">x</code></td>
<td>
<p>An object of class <code>csBiFunction</code>
</p>
</td></tr>
<tr><td><code id="plot.csBiFunction_+3A_...">...</code></td>
<td>
<p>Other arguments to plot call
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coeftofn">coeftofn</a></code>, <code><a href="#topic+print.csBiFunction">print.csBiFunction</a></code>,
<code><a href="#topic+summary.csBiFunction">summary.csBiFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: plot(coeftofn(c(1,-1), c(0.5, 0.5)))
</code></pre>

<hr>
<h2 id='plot.csFSS'>Plot a <code>csFSS</code> object.
</h2><span id='topic+plot.csFSS'></span>

<h3>Description</h3>

<p>Produces two types of plot from the information in
a <code>csFSS</code> object, such as that returned by
<code><a href="#topic+findstysols">findstysols</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csFSS'
plot(x, solno = NULL, ALLplotclust = TRUE, ALLplotscale = TRUE, sollabels=TRUE,
    SNinc = 0, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.csFSS_+3A_x">x</code></td>
<td>
<p>The <code>csFSS</code> object you wish to produce plots for.
</p>
</td></tr>
<tr><td><code id="plot.csFSS_+3A_solno">solno</code></td>
<td>
<p>If missing then the plot produces plots that show information
on all solutions at once, first in a scatter plot, then in a
dendrogram. If provided then the plot produces information
on that specific solution.
</p>
</td></tr>
<tr><td><code id="plot.csFSS_+3A_allplotclust">ALLplotclust</code></td>
<td>
<p>If TRUE then the dendrogram is plotted, if FALSE
it is not.
</p>
</td></tr>
<tr><td><code id="plot.csFSS_+3A_allplotscale">ALLplotscale</code></td>
<td>
<p>If TRUE then the two-dimensional scaling solution
is plotted. If FALSE, it is not.
</p>
</td></tr>
<tr><td><code id="plot.csFSS_+3A_sollabels">sollabels</code></td>
<td>
<p>If TRUE then solution numbers are plotted on the scaling
plot, if produced.
</p>
</td></tr>
<tr><td><code id="plot.csFSS_+3A_sninc">SNinc</code></td>
<td>
<p>An argument passed to the <code><a href="#topic+LCTSres">LCTSres</a></code> function
if called. When plotting add an increment on where to start
looking at the time series/solutions from.
</p>
</td></tr>
<tr><td><code id="plot.csFSS_+3A_...">...</code></td>
<td>
<p>Other arguments passed to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can produce either a scatterplot, which indicates
the two-dimensional scaling picture of the optimization solution 
sets, or a dendrogram showing putative clustering of solutions.
In both cases it is a plot considering ALL solutions at once.
These plots are delegated to the <code><a href="#topic+plot.csFSSgr">plot.csFSSgr</a></code>
function.
</p>
<p>If the argument <code>solno</code> is provided then plots are produced
which show information on a single solution. This plot is
delegated to the <code><a href="#topic+LCTSres">LCTSres</a></code> function.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>G.P.Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>,
<code><a href="#topic+LCTSres">LCTSres</a></code>,
<code><a href="#topic+plot.csFSSgr">plot.csFSSgr</a></code>, <code><a href="#topic+print.csFSS">print.csFSS</a></code>,
<code><a href="#topic+summary.csFSS">summary.csFSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create dummy data
#
x1 &lt;- rnorm(32)
y1 &lt;- rnorm(32)
#
# Find stationary combinations
# Note: we don't run this example in installation/package formation as
# it takes a long time. However, this precise command IS run in
# the help to findstysols
#
## Not run: ans &lt;- findstysols(Nsims=100, tsx=x1, tsy=y1)
#
# Produce dendrogram
#
## Not run: plot(ans)
#
# Produce four pictures relating to solution 3 (can also do
# par(mfrow=c(2,2)) to make a nice 4 plot on one page.)
#
## Not run: plot(ans, solno=3)
#solno is  3 
#3 
#1: 
</code></pre>

<hr>
<h2 id='plot.csFSSgr'>Produce plots from a <code>csFSSgr</code> object.
</h2><span id='topic+plot.csFSSgr'></span>

<h3>Description</h3>

<p>A <code>csFSS</code> object contains a set of solutions obtained
from a series of optimizations. Each solution corresponds to
a time-varying linear combination of two time series (or
rather the wavelet coefficients of such combinations) where
the combination has found to be stationary and the optimizer that
got there converged. Often one wishes to interrogate the results,
such as seeing how the solutions cluster, or what their low-dimensional
scaling solution projection looks like, such analyses are produced
by the <code><a href="#topic+COEFbothscale">COEFbothscale</a></code> function and the whole
plot is marshalled by the <code><a href="#topic+plot.csFSS">plot.csFSS</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csFSSgr'
plot(x, plotclust = TRUE, plotscale = TRUE, sollabels=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.csFSSgr_+3A_x">x</code></td>
<td>
<p>The <code>csFSSgr</code> object to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.csFSSgr_+3A_plotclust">plotclust</code></td>
<td>
<p>If TRUE then the dendrogram clustering is plotted,
if FALSE it is not.
</p>
</td></tr>
<tr><td><code id="plot.csFSSgr_+3A_plotscale">plotscale</code></td>
<td>
<p>If TRUE then the scaling solution picture is plotted,
if FALSE it is not.
</p>
</td></tr>
<tr><td><code id="plot.csFSSgr_+3A_sollabels">sollabels</code></td>
<td>
<p>If TRUE then solution numbers are plotted on the scaling
plot, if produced.
</p>
</td></tr>
<tr><td><code id="plot.csFSSgr_+3A_...">...</code></td>
<td>
<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.csFSS">plot.csFSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# This function is a helper function for plot.csFSS so see the example there.
#
</code></pre>

<hr>
<h2 id='plot.lacv'>Plot localized autocovariance (lacv) object.
</h2><span id='topic+plot.lacv'></span>

<h3>Description</h3>

<p>Produces various ways of looking at a localized autocovariance
(lacv) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacv'
plot(x, plotcor = TRUE, type = "line",
        lags = 0:min(as.integer(10 * log10(nrow(x$lacv))), ncol(x$lacv) - 1),
        tcex = 1, lcol = 1, llty = 1, the.time = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lacv_+3A_x">x</code></td>
<td>
<p>The localized autocovariance object you want to plot (lacv)
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_plotcor">plotcor</code></td>
<td>
<p>If TRUE then plot autocorrelations, otherwise plot
autocovariances.
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_type">type</code></td>
<td>
<p>The lacv objects are fairly complex and so there are
different ways you can plot them. The <code>type</code>s are
<code>line</code>, <code>persp</code> or <code>acf</code>, see the details for
description. Note that the <code>line</code> plot only works with
correlations currently.
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_lags">lags</code></td>
<td>
<p>The <code>lags</code> that you wish included in the plot.
The default is all the lags from 0 up to the maximum that
is used in the R acf plot 
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_tcex">tcex</code></td>
<td>
<p>In the <code>line</code> plot lines are plotted that indicate
the time-varying correlation. Each lag gets a different line
and the lines are differentiated by the lag id being placed
at intervals along the line. This argument changes the
size of those ids (numbers).
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_lcol">lcol</code></td>
<td>
<p>Controls the colours of the lines in the <code>line</code>
plot.
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_llty">llty</code></td>
<td>
<p>Controls the line types of the lines in the <code>line</code>
plot.
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_the.time">the.time</code></td>
<td>
<p>If the <code>acf</code> plot is chosen then you have to specify
a time point about which to plot the acf. I.e. in general this
funcion's lacv argument is a 2D function: <code class="reqn">c(t, \tau)</code>, the
<code>acf</code> plot produces a plot like the regular acf function
and so you have to turn the 2D <code class="reqn">c(t, \tau)</code> into a
1D function <code class="reqn">c(t_0, \tau)</code> by specifying a fixed time
point <code class="reqn">t_0</code>.
</p>
</td></tr>
<tr><td><code id="plot.lacv_+3A_...">...</code></td>
<td>
<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces pictures of the
two-dimensional time-varying autocovariance
or autocorrelation, <code class="reqn">c(t, \tau)</code>,
of a locally stationary time series.
There are three types of plot depending on the argument to
the <code>type</code> argument.
</p>
<p>The <code>line</code> plot draws the autocorrelations as a series of
lines, one for each lag, as lines over time. E.g. a sequence
#of lines <code class="reqn">c(t, \tau_i)</code> is drawn, one for each <code class="reqn">\tau_i</code>.
The zeroth lag line is the autocorrelation at lag 0 which is
always 1. By default all the lags are drawn which can result
in a confusing picture. Often, one is only interested in the low
level lags, so only these can be plotted by changing the <code>lags</code>
argument and any selection of lags can be plotted. The colour
and line type of the plotted lines can be changed with the
<code>lcol</code> and the <code>llty</code> arguments.
</p>
<p>The <code>acf</code> plot produces pictures similar to the standard
R <code>acf()</code> function plot. However, the regular acf is a
1D function, since it is defined to be constant over all time.
The time-varying acf supplied to this function is not constant
over all time (except for stationary processes, theoretically).
So, this type of plot requires the user to specify a fixed
time at which to produce the plot, and this is supplied by
the <code>the.time</code> argument.
</p>
<p>The <code>persp</code> plot plots the 2D function <code class="reqn">c(t, \tau)</code>
as a perspective plot. 
</p>


<h3>Value</h3>

<p>For the <code>acf</code> type plot the acf values are returned
invisibly. For the other types nothing is returned.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lacv">lacv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make some dummy data, e.g. white noise
#
v &lt;- rnorm(256)
#
# Compute the localized autocovariance (ok, the input is stationary
# but this is just an example. More interesting things could be achieved
# by putting the results of simulating from a LSW process, or piecewise
# stationary by concatenating different stationary realizations, etc.
#
vlacv &lt;- lacv(v, lag.max=30)
#
# Now let's do some plotting of the localized autocovariance
#
## Not run: plot(vlacv, lags=0:6)
#
# Should get a plot where lag 0 is all up at value 1, and all other
# autocorrelations are near zero (since its white noise).
#
#
# How about just looking at lags 0, 2 and 4, and some different colours.
#
## Not run: plot(vlacv, lags=c(0,2,4), lcol=c(1,2,3))
#
# O.k. Let's concentrate on time t=200, let's look at a standard acf
# plot near there.
#
## Not run: plot(vlacv, type="acf", the.time=200)
#
# Now plot the autocovariance, rather than the autocorrelation.
#
## Not run: plot(vlacv, type="acf", the.time=200, plotcor=FALSE)
#
# Actually, the plot doesn't look a lot different as the series is white
# noise, but it is different if you look closely.
</code></pre>

<hr>
<h2 id='plotBS'>Compute p-value for parametric Monte Carlo test and optionally
plot test statistic values</h2><span id='topic+plotBS'></span>

<h3>Description</h3>

<p>Computes and returns a p-value for the result of a parametric
Monte Carlo test. Optionally, plots a histogram of the test
statistics (on the original data, and using test statistics resulting
from simulations from the null hypothesis distribution). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBS(BS, alpha = 0.05, plot = TRUE, verbose = FALSE, main = "Bootstrap Histogram",
        xlab = "Test Statistic Values", ylab = "Frequency")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBS_+3A_bs">BS</code></td>
<td>
<p>The results from a Monte Carlo test. This should be a vector
of arbitrary length. The first value must be the value of the test
statistic computed on the data. The remaining values are the
test statistics computed on simulations constructed under the
null hypothesis.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_alpha">alpha</code></td>
<td>
<p>A nominal size for the test. This only effects the reporting.
If the computed p-value is less than <code>alpha</code> then the function
prints out that the series is not stationary.</p>
</td></tr> 
<tr><td><code id="plotBS_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code> then a histogram of all the test statistics
is produced, with a vertical line showing the position of the test
statistic computed on the actual data. If the vertical line is much
larger than all the histogram values then this is indicative of
stationarity. If the vertical line is well within the histogram
values then this is indicative of no evidence against stationarity.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then the p-value is printed and a sentence
declaring &quot;stationary&quot; or &quot;not stationary&quot; is printed (relative
to the nominal p-value)</p>
</td></tr>
<tr><td><code id="plotBS_+3A_main">main</code></td>
<td>
<p>A <code>main</code> label for the plot, if produced</p>
</td></tr>
<tr><td><code id="plotBS_+3A_xlab">xlab</code></td>
<td>
<p>An <code>xlab</code> x axis label for the plot, if produced</p>
</td></tr>
<tr><td><code id="plotBS_+3A_ylab">ylab</code></td>
<td>
<p>An <code>ylab</code> y axis label for the plot, if produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value computed from the Monte Carlo test results is returned
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getpvals">getpvals</a></code>,<code><a href="#topic+BootTOS">BootTOS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example in \code{\link{BootTOS}}.
#
</code></pre>

<hr>
<h2 id='print.csBiFunction'>Print a <code>csBiFunction</code> object.  </h2><span id='topic+print.csBiFunction'></span>

<h3>Description</h3>

<p>A <code>csBiFunction</code> object contains representations of
two functions. This function prints information about the object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csBiFunction'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.csBiFunction_+3A_x">x</code></td>
<td>
<p>The object you want printed.
</p>
</td></tr>
<tr><td><code id="print.csBiFunction_+3A_...">...</code></td>
<td>
<p>Other arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.csBiFunction">plot.csBiFunction</a></code>, <code><a href="#topic+summary.csBiFunction">summary.csBiFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(coeftofn(c(1,-1), c(0.5, 0.5)))
#Class 'csBiFunction' : Contains two sampled functions:
#       ~~~~  : List with 2 components with names
#              alpha beta 
#
#
#summary(.):
#----------
#Length of functions is:  256 
</code></pre>

<hr>
<h2 id='print.csFSS'>
Print a<code>csFSS</code> object.
</h2><span id='topic+print.csFSS'></span>

<h3>Description</h3>

<p>Print information about a <code>csFSS</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csFSS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.csFSS_+3A_x">x</code></td>
<td>
<p>The <code>csFSS</code> object you want printed.
</p>
</td></tr>
<tr><td><code id="print.csFSS_+3A_...">...</code></td>
<td>
<p>Other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>, <code><a href="#topic+plot.csFSS">plot.csFSS</a></code>,
<code><a href="#topic+summary.csFSS">summary.csFSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create dummy data
#
x1 &lt;- rnorm(32)
y1 &lt;- rnorm(32)
#
# Find stationary combinations. Note: normally Nsims would be much bigger
#
## Not run: ans &lt;- findstysols(Nsims=100, tsx=x1, tsy=y1)
#
# Print this csFSS object
#
## Not run: print(ans)
#Class 'csFSS' : Stationary Solutions Object from costat:
#       ~~~~~  : List with 13 components with names
#              startpar endpar convergence minvar pvals tsx tsy tsxname tsyname filter.number
#              family spec.filter.number spec.family 
#
#
#summary(.):
#----------
#Name of X time series:  x1 
#Name of Y time series:  y1 
#Length of input series:  32 
#There are  100  sets of solutions
#Each solution vector is based on  3  coefficients
#Some solutions did not converge, check convergence component for more information.
#Zero indicates successful convergence, other values mean different things and
#you should consult the help page for `optim' to discover what they mean
#For size level:  0.05 
#        0  solutions appear NOT to be stationary
#        97  solutions appear to be stationary
#Range of p-values: ( 0.885 , 0.975 )
#
#Wavelet filter for combinations:  1   DaubExPhase 
#Wavelet filter for spectrum:  1   DaubExPhase 
</code></pre>

<hr>
<h2 id='print.csFSSgr'>Print <code>csFSSgr</code> object.
</h2><span id='topic+print.csFSSgr'></span>

<h3>Description</h3>

<p>Prints out information on a <code>csFSSgr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csFSSgr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.csFSSgr_+3A_x">x</code></td>
<td>
<p>The <code>csFSSgr</code> object you wish to print.
</p>
</td></tr>
<tr><td><code id="print.csFSSgr_+3A_...">...</code></td>
<td>
<p>Other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.csFSSgr">plot.csFSSgr</a></code>, <code><a href="#topic+summary.csFSSgr">summary.csFSSgr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The user should normally never need to use this function as the
# csFSSgr object is only ever internally produced and used.
#
</code></pre>

<hr>
<h2 id='print.lacv'>Print lacv class object
</h2><span id='topic+print.lacv'></span>

<h3>Description</h3>

<p>Prints information about lacv class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lacv_+3A_x">x</code></td>
<td>
<p>The lacv class object you want to print
</p>
</td></tr>
<tr><td><code id="print.lacv_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lacv">lacv</a></code>, <code><a href="#topic+plot.lacv">plot.lacv</a></code>, <code><a href="#topic+summary.lacv">summary.lacv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make some dummy data, e.g. white noise
#
v &lt;- rnorm(256)
#
# Compute the localized autocovariance (ok, the input is stationary
# but this is just an example. More interesting things could be achieved
# by putting the results of simulating from a LSW process, or piecewise
# stationary by concatenating different stationary realizations, etc.
#
vlacv &lt;- lacv(v, lag.max=30)
#
# Now let's print the lacv object 
#
print(vlacv)
#Class 'lacv' : Localized Autocovariance/correlation Object:
#       ~~~~  : List with 3 components with names
#             lacv lacr date 
#
#
#summary(.):
#----------
#Name of originating time series:  
#Date produced:  Thu Oct 25 12:11:29 2012 
#Number of times:  256 
#Number of lags:  30 
</code></pre>

<hr>
<h2 id='prodcomb'>Combine two time series using a time-varying linear combination.</h2><span id='topic+prodcomb'></span>

<h3>Description</h3>

<p>This function takes the <code>cfs</code> vector and splits it
into two halves. The first half contains the wavelet coefficients
for the <code>alpha</code> linear combination function, and the second
half for the <code>beta</code> one. Then the functions themselves are
generated by using the <code>coeftofn</code> function. Then, the
coefficient functions are multiplied by the respective time
series (<code>tsx</code> by <code>alpha</code> and <code>tsy</code> by <code>beta</code>)
and the result returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prodcomb(cfs, tsx, tsy, filter.number = 1,
	family = c("DaubExPhase", "DaubLeAsymm"), all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prodcomb_+3A_cfs">cfs</code></td>
<td>
<p>Wavelet coefficients of the two combination functions.
The coefficients for alpha/beta combination functions
are stored in the first/last half of the vector.</p>
</td></tr>
<tr><td><code id="prodcomb_+3A_tsx">tsx</code></td>
<td>
<p>The x time series to combine</p>
</td></tr>
<tr><td><code id="prodcomb_+3A_tsy">tsy</code></td>
<td>
<p>The y time series to combine</p>
</td></tr>
<tr><td><code id="prodcomb_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet filter to use to obtain functions from
coefficients</p>
</td></tr>
<tr><td><code id="prodcomb_+3A_family">family</code></td>
<td>
<p> The wavelet family to do the same.</p>
</td></tr>
<tr><td><code id="prodcomb_+3A_all">all</code></td>
<td>
<p> If TRUE then a list containing the combined series
in the component <code>lcts</code> and the combination functions
in components <code>alpha</code> and <code>beta</code>. Although the 
combined series is the thing that is usually later tested for
stationarity, it is often useful to see, at some stage,
what the combination functions are, as these provide
interpretation as to what the combination might mean.
If FALSE then just the combined series is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code><a href="#topic+findstysols">findstysols</a></code> and makes
use of <code><a href="#topic+coeftofn">coeftofn</a></code> to turn coefficients into a 
function used in the combination.
</p>


<h3>Value</h3>

<p>If <code>all=TRUE</code> then a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>lcts</code></td>
<td>
<p>The combined series, <code class="reqn">\alpha_t X_t + \beta_t Y_t</code></p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The <code class="reqn">\alpha_t</code> combination function.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The <code class="reqn">\beta_t</code> combination function.</p>
</td></tr>
</table>
<p>If <code>all=FALSE</code> then only <code>lcts</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>, <code><a href="#topic+coeftofn">coeftofn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Toy example
#
tmp.a &lt;- c(1, -1)
tmp.b &lt;- c(0.5, 0.5)
#
# Generate toy time series
#
xxx &lt;- rnorm(256)
yyy &lt;- rnorm(256)
#
# Combine xxx and yyy using the functions produced by inverse wavelet
# transform of tmp.a and tmp.b
#
## Not run: tmp &lt;- prodcomb(c(tmp.a, tmp.b), tsx=xxx, tsy=yyy)
#
# E.g. plot combination
#
## Not run: ts.plot(tmp)
#
# Potentially test its stationarity.... etc
#
</code></pre>

<hr>
<h2 id='SP500FTSElr'>Log-returns time series of the SP500 and FTSE100 indices</h2><span id='topic+SP500FTSElr'></span>

<h3>Description</h3>

<p>Log-returns of the SP500 and FTSE indices between
21th June 1995 until 2nd October 2002. Only trading days where
both indices were recorded are stored. There are 2048
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SP500FTSElr)</code></pre>


<h3>Format</h3>

<p>A data frame with 2048 observations on the following 3 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>The trading day that the index was recorded.</p>
</dd>
<dt><code>SP500lr</code></dt><dd><p>The log-return for SP500</p>
</dd>
<dt><code>FTSElr</code></dt><dd><p>The log-return for FTSE100</p>
</dd>
</dl>



<h3>Source</h3>

<p>Downloaded from Yahoo! Finance
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Plot the log-returns for the SP500
#
## Not run: ts.plot(SP500FTSElr[,2])
</code></pre>

<hr>
<h2 id='sret'>Particular section of SP500 log-returns series.</h2><span id='topic+sret'></span>

<h3>Description</h3>

<p>Observations 256:767 from the SP500 log-return series
stored in <code><a href="#topic+SP500FTSElr">SP500FTSElr</a></code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sret)</code></pre>


<h3>Format</h3>

<p>A vector of 512 observations of the SP500 log-returns series.
</p>


<h3>Details</h3>

<p>Its just more convenient to refer to <code>sret</code> than to
<code>SP500FTSElr[256:767,2]</code>.
</p>


<h3>Source</h3>

<p>Yahoo! Finance</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ts.plot(sret)
</code></pre>

<hr>
<h2 id='summary.csBiFunction'>Summarize a <code>csBiFunction</code> object.
</h2><span id='topic+summary.csBiFunction'></span>

<h3>Description</h3>

<p>Summarize a <code>csBiFunction</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csBiFunction'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.csBiFunction_+3A_object">object</code></td>
<td>
<p>The object to summarize
</p>
</td></tr>
<tr><td><code id="summary.csBiFunction_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.csBiFunction">plot.csBiFunction</a></code>, <code><a href="#topic+print.csBiFunction">print.csBiFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example to print.csBiFunction, as this calls summary(.)
#
</code></pre>

<hr>
<h2 id='summary.csFSS'>Summarize a <code>csFSS</code> object.
</h2><span id='topic+summary.csFSS'></span>

<h3>Description</h3>

<p>Summarizes a <code>csFSS</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csFSS'
summary(object, size = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.csFSS_+3A_object">object</code></td>
<td>
<p>Object you wish to summarize.
</p>
</td></tr>
<tr><td><code id="summary.csFSS_+3A_size">size</code></td>
<td>
<p>A hypothesis test size. The <code>csFSS</code> object contains a
number of p-values, this argument controls what is considered
significant (but not corrected for multiple tests)
</p>
</td></tr>
<tr><td><code id="summary.csFSS_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findstysols">findstysols</a></code>,<code><a href="#topic+plot.csFSS">plot.csFSS</a></code>, <code><a href="#topic+print.csFSS">print.csFSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example to print.csFSS which calls summary(.)
#
</code></pre>

<hr>
<h2 id='summary.csFSSgr'>Summarize a <code>csFSSgr</code> object.
</h2><span id='topic+summary.csFSSgr'></span>

<h3>Description</h3>

<p>Summarizes a <code>csFSSgr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'csFSSgr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.csFSSgr_+3A_object">object</code></td>
<td>
<p>The <code>csFSSgr</code> object you wish to summarize.
</p>
</td></tr>
<tr><td><code id="summary.csFSSgr_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.csFSSgr">plot.csFSSgr</a></code>, <code><a href="#topic+print.csFSSgr">print.csFSSgr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example for print.csFSSgr which calls summary(.)
</code></pre>

<hr>
<h2 id='summary.lacv'>Summarizes a lacv object
</h2><span id='topic+summary.lacv'></span>

<h3>Description</h3>

<p>Summarizes a lacv object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacv'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lacv_+3A_object">object</code></td>
<td>
<p>The lacv object you wish summarized.
</p>
</td></tr>
<tr><td><code id="summary.lacv_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lacv">lacv</a></code>, <code><a href="#topic+plot.lacv">plot.lacv</a></code>, <code><a href="#topic+print.lacv">print.lacv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make some dummy data, e.g. white noise
#
v &lt;- rnorm(256)
#
# Compute the localized autocovariance (ok, the input is stationary
# but this is just an example. More interesting things could be achieved
# by putting the results of simulating from a LSW process, or piecewise
# stationary by concatenating different stationary realizations, etc.
#
vlacv &lt;- lacv(v, lag.max=20)
#
# Now let's summarize the lacv object
#
summary(vlacv)
#Name of originating time series:  
#Date produced:  Thu Oct 25 12:11:29 2012 
#Number of times:  256 
#Number of lags:  20  
</code></pre>

<hr>
<h2 id='TOSts'>A test statistic for stationarity</h2><span id='topic+TOSts'></span>

<h3>Description</h3>

<p>The <code class="reqn">T_{\mbox{vS}}</code> test statistic from
the Cardinali and Nason article. Measures the degree of
non-stationarity using the estimated evolutionary wavelet
spectrum (EWS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOSts(spec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TOSts_+3A_spec">spec</code></td>
<td>
<p>An EWS estimate, e.g. from the <code>$S</code> component from
<code>ewspec</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an EWS estimate. This computes the sample variance of
the estimate for each scale level and then returns the sum
of these variances.
</p>


<h3>Value</h3>

<p>A single number which is the sum of the sample variances of
each scale level from an EWS estimate. If the EWS estimate is
constant for each scale then the return value is zero. 
</p>


<h3>Author(s)</h3>

<p>Guy Nason</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, Guy P. (2013) Costationarity of
Locally Stationary Time Series Using costat.
<em>Journal of Statistical Software</em>, <b>55</b>, Issue 1.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootTOS">BootTOS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Compute a spectral estimate on an sample time series (just use iid data)
#
xsim &lt;- rnorm(128)
xews &lt;- ewspec(xsim, smooth.dev=var)$S
#
# You could plot this spectral estimate if you liked
#
## Not run: plot(xews)
#
# Compute test statistic
#
TOSts(xews)
#[1] 0.1199351
#
# Although the time series x here is a realization from a stationary process
# the test statistic is not zero (this is because of the estimation error
# inherent in this small sample). 
#
# This is why the bootstrap test, \code{\link{BootTOS}} is required to
# assess the significance of the test statistic value.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
