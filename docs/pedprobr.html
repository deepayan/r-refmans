<!DOCTYPE html><html><head><title>Help for package pedprobr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pedprobr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allGenotypes'><p>Genotype matrix</p></a></li>
<li><a href='#genoCombinations'><p>Genotype combinations</p></a></li>
<li><a href='#haldane'><p>Genetic map functions</p></a></li>
<li><a href='#HWprob'><p>Hardy-Weinberg probabilities</p></a></li>
<li><a href='#likelihood'><p>Pedigree likelihood</p></a></li>
<li><a href='#lumpAlleles'><p>Allele lumping</p></a></li>
<li><a href='#merlin'><p>Pedigree likelihoods computed by MERLIN</p></a></li>
<li><a href='#oneMarkerDistribution'><p>Genotype distribution for a single marker</p></a></li>
<li><a href='#pedprobr-package'><p>pedprobr: Probability Computations on Pedigrees</p></a></li>
<li><a href='#setMutationModel'><p>Set a mutation model</p></a></li>
<li><a href='#twoMarkerDistribution'><p>Genotype distribution for two linked markers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probability Computations on Pedigrees</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.3</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the Elston-Stewart algorithm for
    calculating pedigree likelihoods given genetic marker data (Elston and
    Stewart (1971) &lt;<a href="https://doi.org/10.1159%2F000152448">doi:10.1159/000152448</a>&gt;). The standard algorithm is
    extended to allow inbred founders. 'pedprobr' is part of the 'ped
    suite', a collection of packages for pedigree analysis in R. In
    particular, 'pedprobr' depends on 'pedtools' for pedigree
    manipulations and 'pedmut' for mutation modelling. For more
    information, see 'Pedigree Analysis in R' (Vigeland, 2021,
    ISBN:9780128244302).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/magnusdv/pedprobr">https://github.com/magnusdv/pedprobr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/magnusdv/pedprobr/issues">https://github.com/magnusdv/pedprobr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), pedtools (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>pedmut (&ge; 0.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>MERLIN (https://csg.sph.umich.edu/abecasis/merlin/)
for calculations involving multiple linked markers.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-02 08:19:18 UTC; magnu</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Dehli Vigeland
    <a href="https://orcid.org/0000-0002-9134-4962"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Dehli Vigeland &lt;m.d.vigeland@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-02 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allGenotypes'>Genotype matrix</h2><span id='topic+allGenotypes'></span>

<h3>Description</h3>

<p>An autosomal marker with <code>n</code> alleles has <code>choose(n+1, 2)</code> possible
unordered genotypes. This function returns these as rows in a
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allGenotypes(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allGenotypes_+3A_n">n</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix with two columns and <code>choose(n+1, 2)</code> rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>allGenotypes(3)

</code></pre>

<hr>
<h2 id='genoCombinations'>Genotype combinations</h2><span id='topic+genoCombinations'></span>

<h3>Description</h3>

<p>Returns the possible genotype combinations in a pedigree, given partial
marker data. This function is mainly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoCombinations(x, partialmarker = x$MARKERS[[1]], ids, make.grid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genoCombinations_+3A_x">x</code></td>
<td>
<p>a <code><a href="pedtools.html#topic+ped">ped()</a></code> object.</p>
</td></tr>
<tr><td><code id="genoCombinations_+3A_partialmarker">partialmarker</code></td>
<td>
<p>a <code><a href="pedtools.html#topic+marker">marker()</a></code> object compatible with <code>x</code>.</p>
</td></tr>
<tr><td><code id="genoCombinations_+3A_ids">ids</code></td>
<td>
<p>a vector with ID labels of one or more pedigree members.</p>
</td></tr>
<tr><td><code id="genoCombinations_+3A_make.grid">make.grid</code></td>
<td>
<p>a logical indicating if the result should be simplified to a
matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>make.grid = FALSE</code> (the default) the function returns a list of
integer vectors, one vector for each element of <code>ids</code>. Each integer
represents a genotype, in the form of a row number of the matrix
<code>allGenotypes(n)</code>, where <code>n</code> is the number of alleles of the marker.
</p>
<p>If <code>make.grid = TRUE</code>, the Cartesian product of the vectors is taken,
resulting in a matrix with one column for each element of <code>ids</code>.
</p>

<hr>
<h2 id='haldane'>Genetic map functions</h2><span id='topic+haldane'></span><span id='topic+kosambi'></span>

<h3>Description</h3>

<p>Simple implementations of the classical map functions of Haldane and Kosambi,
relating the genetic distance and the recombination rate between two linked loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haldane(cM = NULL, rho = NULL)

kosambi(cM = NULL, rho = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haldane_+3A_cm">cM</code></td>
<td>
<p>A numeric vector with genetic distances in centiMorgan, or NULL.</p>
</td></tr>
<tr><td><code id="haldane_+3A_rho">rho</code></td>
<td>
<p>A numeric vector with recombination rates, or NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric of the same length as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cM = 0:200
dat = cbind(Haldane = haldane(cM = cM),
            Kosambi = kosambi(cM = cM))
matplot(cM, dat, ylab = "Recombination rate", type = "l")
legend("topleft", legend = colnames(dat), col = 1:2, lty = 1:2)


rho = seq(0, 0.49, length = 50)
dat2 = cbind(Haldane = haldane(rho = rho),
             Kosambi = kosambi(rho = rho))
matplot(rho, dat2, xlab = "Recombination rate", ylab = "cM", type = "l")
legend("topleft", legend = colnames(dat), col = 1:2, lty = 1:2)

</code></pre>

<hr>
<h2 id='HWprob'>Hardy-Weinberg probabilities</h2><span id='topic+HWprob'></span>

<h3>Description</h3>

<p>Hardy-Weinberg probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HWprob(allele1, allele2, afreq, f = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HWprob_+3A_allele1">allele1</code>, <code id="HWprob_+3A_allele2">allele2</code></td>
<td>
<p>Vectors of equal length, containing alleles in the
form of indices of <code>afreq</code></p>
</td></tr>
<tr><td><code id="HWprob_+3A_afreq">afreq</code></td>
<td>
<p>A numeric vector with allele frequencies</p>
</td></tr>
<tr><td><code id="HWprob_+3A_f">f</code></td>
<td>
<p>A single number in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>; the inbreeding coefficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>allele1</code> and  <code>allele2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = 0.1; q = 1-p
hw = HWprob(c(1,1,2), c(1,2,2), c(p, q))
stopifnot(all.equal(hw, c(p^2, 2*p*q, q^2)))

</code></pre>

<hr>
<h2 id='likelihood'>Pedigree likelihood</h2><span id='topic+likelihood'></span><span id='topic+likelihood.ped'></span><span id='topic+likelihood.list'></span><span id='topic+likelihood2'></span><span id='topic+likelihood2.ped'></span><span id='topic+likelihood2.list'></span>

<h3>Description</h3>

<p>The <code>likelihood()</code> and <code>likelihood2()</code> functions constitute the heart of
<strong>pedprobr</strong>. The former computes the pedigree likelihood for each indicated
marker. The latter computes the likelihood for a pair of linked markers
separated by a given recombination rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood(x, ...)

## S3 method for class 'ped'
likelihood(
  x,
  markers = NULL,
  peelOrder = NULL,
  lump = TRUE,
  eliminate = 0,
  logbase = NULL,
  loopBreakers = NULL,
  allX = NULL,
  verbose = FALSE,
  theta = 0,
  ...
)

## S3 method for class 'list'
likelihood(x, markers = NULL, logbase = NULL, ...)

likelihood2(x, ...)

## S3 method for class 'ped'
likelihood2(
  x,
  marker1,
  marker2,
  rho = NULL,
  peelOrder = NULL,
  eliminate = 0,
  logbase = NULL,
  loopBreakers = NULL,
  verbose = FALSE,
  ...
)

## S3 method for class 'list'
likelihood2(x, marker1, marker2, logbase = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object, a <code>singleton</code> object, or a list of such objects.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_markers">markers</code></td>
<td>
<p>One or several markers compatible with <code>x</code>. Several input
forms are possible:
</p>

<ul>
<li><p> A <code><a href="pedtools.html#topic+marker">marker()</a></code> object compatible with <code>x</code>.
</p>
</li>
<li><p> A list of marker objects.
</p>
</li>
<li><p> A vector of names or indices of markers attached to <code>x</code>. If <code>x</code> is a
list, this is the only valid input.
</p>
</li></ul>
</td></tr>
<tr><td><code id="likelihood_+3A_peelorder">peelOrder</code></td>
<td>
<p>For internal use.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_lump">lump</code></td>
<td>
<p>Activate allele lumping, i.e., merging unobserved alleles. This
is an important time saver, and should be applied in nearly all cases. (The
parameter exists mainly for debugging purposes.) The lumping algorithm will
detect (and complain) if any markers use a non-lumpable mutation model.
Default: TRUE.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_eliminate">eliminate</code></td>
<td>
<p>Deprecated, not used.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_logbase">logbase</code></td>
<td>
<p>Either NULL (default) or a positive number indicating the
basis for logarithmic output. Typical values are <code>exp(1)</code> and 10.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_loopbreakers">loopBreakers</code></td>
<td>
<p>A vector of ID labels indicating loop breakers. If NULL
(default), automatic selection of loop breakers will be performed. See
<code><a href="pedtools.html#topic+breakLoops">breakLoops()</a></code>.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_allx">allX</code></td>
<td>
<p>For internal use; set to TRUE if all markers are X-chromosomal.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_theta">theta</code></td>
<td>
<p>Theta correction.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_marker1">marker1</code>, <code id="likelihood_+3A_marker2">marker2</code></td>
<td>
<p>Single markers compatible with <code>x</code>.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_rho">rho</code></td>
<td>
<p>The recombination rate between <code>marker1</code> and <code>marker2</code>. To make
biological sense <code>rho</code> should be between 0 and 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is based on the peeling algorithm of Elston and Stewart
(1971). A variety of situations are covered; see the Examples section for
some demonstrations.
</p>

<ul>
<li><p> autosomal and X-linked markers
</p>
</li>
<li><p> 1 marker or 2 linked markers
</p>
</li>
<li><p> complex inbred pedigrees
</p>
</li>
<li><p> markers with mutation models
</p>
</li>
<li><p> pedigrees with inbred founders
</p>
</li></ul>

<p>For more than two linked markers, see <code><a href="#topic+likelihoodMerlin">likelihoodMerlin()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric with the same length as the number of markers indicated by
<code>markers</code>. If <code>logbase</code> is a positive number, the output is
<code>log(likelihood, logbase)</code>.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>References</h3>

<p>Elston and Stewart (1971). <em>A General Model for the Genetic
Analysis of Pedigree Data</em>. <a href="https://doi.org/10.1159/000152448">doi:10.1159/000152448</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likelihoodMerlin">likelihoodMerlin()</a></code>, for likelihoods involving more than 2 linked markers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Simple likelihood ###
p = 0.1
q = 1 - p
afr = c("1" = p, "2" = q)

# Singleton
s = singleton() |&gt; addMarker(geno = "1/2", afreq = afr)

stopifnot(all.equal(likelihood(s), 2*p*q))

# Trio
trio = nuclearPed() |&gt;
  addMarker(geno = c("1/1", "1/2", "1/1"), afreq = afr)

stopifnot(all.equal(likelihood(trio), p^2 * 2*p*q * 0.5))


### Example of calculation with inbred founders ###

### Case 1: Trio with inbred father
x = cousinPed(0, child = TRUE)
x = addSon(x, 5)
x = relabel(x, old = 5:7, new = c("father", "mother", "child"))

# Add equifrequent SNP; father homozygous, child heterozygous
x = addMarker(x, father = "1/1", child = "1/2")

# Plot with genotypes
plot(x, marker = 1)

# Compute the likelihood
lik1 = likelihood(x, markers = 1)


### Case 2: Using founder inbreeding
# Remove ancestry of father
y = subset(x, c("father", "mother", "child"))

# Indicate that the father has inbreeding coefficient 1/4
founderInbreeding(y, "father") = 1/4

# Plot (notice the inbreeding coefficient)
plot(y, marker = 1)

# Likelihood should be the same as above
lik2 = likelihood(y, markers = 1)

stopifnot(all.equal(lik1, lik2))



</code></pre>

<hr>
<h2 id='lumpAlleles'>Allele lumping</h2><span id='topic+lumpAlleles'></span>

<h3>Description</h3>

<p>Perform allele lumping (i.e., merging unobserved alleles) for all markers
attached to the input pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lumpAlleles(x, markers = NULL, always = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lumpAlleles_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="lumpAlleles_+3A_markers">markers</code></td>
<td>
<p>A vector of names or indices referring to markers attached to
<code>x</code>. (Default: All markers.)</p>
</td></tr>
<tr><td><code id="lumpAlleles_+3A_always">always</code></td>
<td>
<p>A logical. If TRUE, lumping is always attempted. By default
(FALSE) lumping is skipped for markers where all individuals are genotyped.</p>
</td></tr>
<tr><td><code id="lumpAlleles_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object similar to <code>x</code>, but whose attached markers have reduced
allele set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = nuclearPed() |&gt; addMarker(geno = c("1/1", NA, NA), alleles = 1:4)

# Before lumping
afreq(x, 1)

# Lump
y = lumpAlleles(x, verbose = TRUE)
afreq(y, 1)

</code></pre>

<hr>
<h2 id='merlin'>Pedigree likelihoods computed by MERLIN</h2><span id='topic+merlin'></span><span id='topic+likelihoodMerlin'></span><span id='topic+checkMerlin'></span>

<h3>Description</h3>

<p>These functions enable users to call MERLIN (Abecasis et al., 2002) from
within R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merlin(
  x,
  options,
  markers = NULL,
  linkageMap = NULL,
  verbose = TRUE,
  generateFiles = TRUE,
  cleanup = TRUE,
  dir = tempdir(),
  logfile = NULL,
  merlinpath = NULL,
  checkpath = TRUE
)

likelihoodMerlin(
  x,
  markers = NULL,
  linkageMap = NULL,
  rho = NULL,
  logbase = NULL,
  perChrom = FALSE,
  options = "--likelihood --bits:100 --megabytes:4000 --quiet",
  ...
)

checkMerlin(program = NULL, version = TRUE, error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merlin_+3A_x">x</code></td>
<td>
<p>A <code><a href="pedtools.html#topic+ped">ped</a></code> object.</p>
</td></tr>
<tr><td><code id="merlin_+3A_options">options</code></td>
<td>
<p>A single string containing all arguments to merlin except for
the input file indications.</p>
</td></tr>
<tr><td><code id="merlin_+3A_markers">markers</code></td>
<td>
<p>A vector of names or indices of markers attached to <code>x</code>.
(Default: all markers).</p>
</td></tr>
<tr><td><code id="merlin_+3A_linkagemap">linkageMap</code></td>
<td>
<p>A data frame with three columns (chromosome; marker name;
centiMorgan position) to be used as the marker map by MERLIN.</p>
</td></tr>
<tr><td><code id="merlin_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="merlin_+3A_generatefiles">generateFiles</code></td>
<td>
<p>A logical. If TRUE (default), input files to MERLIN
named '_merlin.ped', '_merlin.dat', '_merlin.map', and '_merlin.freq' are
created in the directory indicated by <code>dir</code>. If FALSE, no files are
created.</p>
</td></tr>
<tr><td><code id="merlin_+3A_cleanup">cleanup</code></td>
<td>
<p>A logical. If TRUE (default), the MERLIN input files are
deleted after the call to MERLIN.</p>
</td></tr>
<tr><td><code id="merlin_+3A_dir">dir</code></td>
<td>
<p>The name of the directory where input files should be written.</p>
</td></tr>
<tr><td><code id="merlin_+3A_logfile">logfile</code></td>
<td>
<p>A character. If this is given, the MERLIN screen output will
be dumped to a file with this name.</p>
</td></tr>
<tr><td><code id="merlin_+3A_merlinpath">merlinpath</code></td>
<td>
<p>The path to the folder containing the merlin executables.
If the executables are on the system's search path, this can be left as
NULL (default).</p>
</td></tr>
<tr><td><code id="merlin_+3A_checkpath">checkpath</code></td>
<td>
<p>A logical indicating whether to check that the merlin
executable is found.</p>
</td></tr>
<tr><td><code id="merlin_+3A_rho">rho</code></td>
<td>
<p>A vector of length one less than the number of markers, specifying
the recombination rate between each consecutive pair.</p>
</td></tr>
<tr><td><code id="merlin_+3A_logbase">logbase</code></td>
<td>
<p>Either NULL (default) or a positive number indicating the
basis for logarithmic output. Typical values are <code>exp(1)</code> and 10.</p>
</td></tr>
<tr><td><code id="merlin_+3A_perchrom">perChrom</code></td>
<td>
<p>A logical; if TRUE, likelihoods are reported per chromosome.</p>
</td></tr>
<tr><td><code id="merlin_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>merlin()</code>.</p>
</td></tr>
<tr><td><code id="merlin_+3A_program">program</code></td>
<td>
<p>A character containing &quot;merlin&quot;, &quot;minx&quot; or both (default),
optionally including full paths.</p>
</td></tr>
<tr><td><code id="merlin_+3A_version">version</code></td>
<td>
<p>A logical. If TRUE (default), it is checked that running
<code>program</code> produces a printout starting with &quot;MERLIN 1.1.2&quot;.</p>
</td></tr>
<tr><td><code id="merlin_+3A_error">error</code></td>
<td>
<p>A logical, indicating if an error should be raised if <code>program</code>
is not found. Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For these functions to work, the program MERLIN must be installed (see link
in the Reference section below) and correctly pointed to in the PATH
variable. The <code>merlin()</code> function is a general wrapper which runs MERLIN with
the indicated options, after creating the appropriate input files. For
convenience, MERLIN's &quot;&ndash;likelihood&quot; functionality is wrapped in a separate
function.
</p>
<p>The <code>merlin()</code> function creates input files &quot;_merlin.ped&quot;, &quot;_merlin.dat&quot;,
&quot;_merlin.map&quot; and &quot;_merlin.freq&quot; in the <code>dir</code> directory, and then runs the
following command through a call to <code><a href="base.html#topic+system">system()</a></code>:
</p>
<pre>merlin -p _merlin.ped -d _merlin.dat -m _merlin.map -f
_merlin.freq  &lt;options&gt; </pre>
<p><code>likelihoodMerlin()</code> first runs <code>merlin()</code> with <code>options = "--likelihood --bits:100 --megabytes:4000 --quiet"</code>, and then extracts the likelihood
values from the MERLIN output. Note that the output is the <em>total</em> likelihood
including all markers.
</p>
<p>For likelihood computations with linked markers, the argument <code>rho</code> should
indicate the recombination fractions between each consecutive pair of markers
(i.e., <code>rho[i]</code> is the recombination rate between markers <code>i-1</code> and <code>i</code>).
These will be converted to centiMorgan distances using Haldane's map
function, and used to create genetic marker map in a MERLIN-friendly format.
</p>


<h3>Value</h3>

<p><code>merlin()</code> returns the screen output of MERLIN invisibly.
</p>
<p><code>likelihoodMerlin()</code> returns a single number; the total likelihood using
all indicated markers.
</p>
<p><code>checkMerlin()</code> returns TRUE if the MERLIN executable indicated by
<code>program</code> is found on the system. Otherwise FALSE, or (if <code>error = TRUE</code>)
an error is raised.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>References</h3>

<p>Abecasis et al. (2002) Nat Gen 30:97-101.
<a href="https://csg.sph.umich.edu/abecasis/merlin/">https://csg.sph.umich.edu/abecasis/merlin/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(checkMerlin()) {

### Trivial example for validation
x = nuclearPed(1) |&gt;
  addMarker("1" = "1/2") |&gt;            # likelihood = 1/2
  addMarker("1" = "1/1", "3" = "1/2")  # likelihood = 1/8

# MERLIN likelihoods
lik1 = likelihoodMerlin(x, markers = 1, verbose = FALSE)
lik2 = likelihoodMerlin(x, markers = 2, verbose = FALSE)
likTot = likelihoodMerlin(x, verbose = FALSE)
stopifnot(all.equal(
  round(c(lik1, lik2, likTot), c(3,3,4)), c(1/2, 1/8, 1/16)))

# Example with ped lists
y = singletons(1:2) |&gt;
  addMarker(`1` = "1/2", `2` = "1/1", alleles = 1:2)
lik = likelihoodMerlin(y, verbose = FALSE)
stopifnot(all.equal(round(lik, 3), 1/8))

### Linked markers
z = nuclearPed(2)
m = marker(z, geno = c("1/1", "1/2", "1/2", "1/2"))
z = setMarkers(z, list(m, m))

# By MERLIN...
L1 = likelihoodMerlin(z, markers = 1:2, rho = 0.25, verbose = FALSE)

# ...and by pedprobr
L2 = likelihood2(z, marker1 = 1, marker2 = 2, rho = 0.25)

# stopifnot(all.equal(signif(L1, 3), signif(L2, 3)))
}

</code></pre>

<hr>
<h2 id='oneMarkerDistribution'>Genotype distribution for a single marker</h2><span id='topic+oneMarkerDistribution'></span>

<h3>Description</h3>

<p>Computes the genotype probability distribution of one or several pedigree
members, possibly conditional on known genotypes for the marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneMarkerDistribution(
  x,
  ids,
  partialmarker,
  loopBreakers = NULL,
  eliminate = 0,
  grid.subset = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneMarkerDistribution_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels of one or more members of <code>x</code>.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_partialmarker">partialmarker</code></td>
<td>
<p>Either a <code>marker</code> object or the name (or index) of a
marker attached to <code>x</code>. If <code>x</code> has multiple components, only the latter is
allowed.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_loopbreakers">loopBreakers</code></td>
<td>
<p>(Only relevant if the pedigree has loops). A vector with
ID labels of individuals to be used as loop breakers. If NULL (default)
loop breakers are selected automatically. See <code><a href="pedtools.html#topic+breakLoops">breakLoops()</a></code>.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_eliminate">eliminate</code></td>
<td>
<p>Deprecated, not used.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_grid.subset">grid.subset</code></td>
<td>
<p>(Optional; not relevant for most users.) A numeric matrix
describing a subset of all marker genotype combinations for the <code>ids</code>
individuals. The matrix should have one column for each of the <code>ids</code>
individuals, and one row for each combination: The genotypes are described
in terms of the matrix <code>M = allGenotypes(n)</code>, where <code>n</code> is the number of
alleles for the marker. If the entry in column <code>j</code> is the integer <code>k</code>, this
means that the genotype of individual <code>ids[j]</code> is row <code>k</code> of <code>M</code>.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>k</code>-dimensional array, where <code>k = length(ids)</code>, with the
joint genotype distribution for the <code>ids</code> individuals. The probabilities
are conditional on the known genotypes and the allele frequencies of
<code>partialmarker</code>.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twoMarkerDistribution">twoMarkerDistribution()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Trivial example giving Hardy-Weinberg probabilities
s = singleton(id = 1)
m = marker(s, alleles = 1:2) # equifrequent SNP
oneMarkerDistribution(s, ids = 1, partialmarker = m)

# Conditioning on a partial genotype
genotype(m, id = 1) = "1/-"
oneMarkerDistribution(s, ids = 1, partialmarker = m)

# Genotype distribution for a child of heterozygous parents
trio = nuclearPed(father = "fa", mother = "mo", child = "ch")
m1 = marker(trio, fa = "1/2", mo = "1/2")
oneMarkerDistribution(trio, ids = "ch", partialmarker = m1)

# Joint distribution of the parents, given that the child is heterozygous
m2 = marker(trio, ch = "1/2", afreq = c("1" = 0.5, "2" = 0.5))
oneMarkerDistribution(trio, ids = c("fa", "mo"), partialmarker = m2)

# A different example: The genotype distribution of an individual (id = 8)
# whose half cousin (id = 9) is homozygous for a rare allele.
y = halfCousinPed(degree = 1) |&gt;
  addMarker("9" = "a/a", afreq = c(a = 0.01, b = 0.99))

oneMarkerDistribution(y, ids = 8, partialmarker = 1)

</code></pre>

<hr>
<h2 id='pedprobr-package'>pedprobr: Probability Computations on Pedigrees</h2><span id='topic+pedprobr'></span><span id='topic+pedprobr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>An implementation of the Elston-Stewart algorithm for calculating pedigree likelihoods given genetic marker data (Elston and Stewart (1971) <a href="https://doi.org/10.1159/000152448">doi:10.1159/000152448</a>). The standard algorithm is extended to allow inbred founders. 'pedprobr' is part of the 'ped suite', a collection of packages for pedigree analysis in R. In particular, 'pedprobr' depends on 'pedtools' for pedigree manipulations and 'pedmut' for mutation modelling. For more information, see 'Pedigree Analysis in R' (Vigeland, 2021, ISBN:9780128244302).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Magnus Dehli Vigeland <a href="mailto:m.d.vigeland@medisin.uio.no">m.d.vigeland@medisin.uio.no</a> (<a href="https://orcid.org/0000-0002-9134-4962">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/magnusdv/pedprobr">https://github.com/magnusdv/pedprobr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/magnusdv/pedprobr/issues">https://github.com/magnusdv/pedprobr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='setMutationModel'>Set a mutation model</h2><span id='topic+setMutationModel'></span>

<h3>Description</h3>

<p><em><strong>NB: This function has been replaced by <code><a href="pedtools.html#topic+setMutmod">pedtools::setMutmod()</a></code>.</strong></em>
This function attaches mutation models to a pedigree with marker data,
calling <code><a href="pedmut.html#topic+mutationModel">pedmut::mutationModel()</a></code> for creating the models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMutationModel(x, model, markers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMutationModel_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="setMutationModel_+3A_model">model</code></td>
<td>
<p>A model name implemented by <code><a href="pedmut.html#topic+mutationModel">pedmut::mutationModel()</a></code> (see
Details), or NULL.</p>
</td></tr>
<tr><td><code id="setMutationModel_+3A_markers">markers</code></td>
<td>
<p>A vector of names or indices referring to markers attached to
<code>x</code>. (Default: All markers.)</p>
</td></tr>
<tr><td><code id="setMutationModel_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to <code><a href="pedmut.html#topic+mutationModel">pedmut::mutationModel()</a></code>, e.g., <code>rate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the following models are handled:
</p>

<ul>
<li> <p><code>equal</code> :  All mutations equally likely; probability <code class="reqn">1-rate</code> of no
mutation
</p>
</li>
<li> <p><code>proportional</code> : Mutation probabilities are proportional to the target
allele frequencies
</p>
</li>
<li> <p><code>onestep</code>: A mutation model for microsatellite markers, allowing mutations
only to the nearest neighbours in the allelic ladder. For example, '10' may
mutate to either '9' or '11', unless '10' is the lowest allele, in which case
'11' is the only option. This model is not applicable to loci with
non-integral microvariants.
</p>
</li>
<li> <p><code>stepwise</code>: A common model in forensic genetics, allowing different
mutation rates between integer alleles (like '16') and non-integer
&quot;microvariants&quot; like '9.3'). Mutations also depend on the size of the
mutation if the parameter 'range' differs from 1.
</p>
</li>
<li> <p><code>custom</code> : Allows any mutation matrix to be provided by the user, in the
<code>matrix</code> parameter
</p>
</li>
<li> <p><code>random</code> : This produces a matrix of random numbers, where each row is
normalised so that it sums to 1
</p>
</li>
<li> <p><code>trivial</code> : The identity matrix; i.e. no mutations are possible.
</p>
</li></ul>



<h3>Value</h3>

<p>An object similar to <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example requires the pedmut package ###
if (requireNamespace("pedmut", quietly = TRUE)){

# A pedigree with data from a single marker
x = nuclearPed(1) |&gt;
  addMarker(geno = c("a/a", NA, "b/b")) # mutation!

# Set `equal` model
y = setMutationModel(x, marker = 1, model = "equal", rate = 0.01)

# Inspect model
mutmod(y, 1)

# Likelihood
likelihood(y, 1)

# Remove mutation model
z = setMutationModel(y, model = NULL)
stopifnot(identical(z, x))
}

</code></pre>

<hr>
<h2 id='twoMarkerDistribution'>Genotype distribution for two linked markers</h2><span id='topic+twoMarkerDistribution'></span>

<h3>Description</h3>

<p>Computes the joint genotype distribution of two markers for a specified
pedigree member, conditional on known genotypes and the recombination rate
between the markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoMarkerDistribution(
  x,
  id,
  partialmarker1,
  partialmarker2,
  rho = NULL,
  loopBreakers = NULL,
  eliminate = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoMarkerDistribution_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_id">id</code></td>
<td>
<p>A single ID label.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_partialmarker1">partialmarker1</code>, <code id="twoMarkerDistribution_+3A_partialmarker2">partialmarker2</code></td>
<td>
<p>Either a <code>marker</code> object, or the name (or
index) of a marker attached to <code>x</code>.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_rho">rho</code></td>
<td>
<p>A single numeric in the interval <code style="white-space: pre;">&#8288;[0, 0.5]&#8288;</code>: the recombination
fraction between the two markers.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_loopbreakers">loopBreakers</code></td>
<td>
<p>(Only relevant if the pedigree has loops). A vector with
ID labels of individuals to be used as loop breakers. If NULL (default)
loop breakers are selected automatically. See <code><a href="pedtools.html#topic+breakLoops">breakLoops()</a></code>.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_eliminate">eliminate</code></td>
<td>
<p>Deprecated, not used.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named matrix giving the joint genotype distribution.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oneMarkerDistribution">oneMarkerDistribution()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A sib-pair pedigree
x = nuclearPed(children = c("bro1", "bro2"))

# Two SNP markers; first brother homozygous for the `1` allele
SNP1 = SNP2 = marker(x, bro1 = "1/1", afreq = c("1" = 0.5, "2" = 0.5))

plot(x, marker = list(SNP1, SNP2))

# Genotype distribution for the brother depends on linkage
twoMarkerDistribution(x, id = "bro2", SNP1, SNP2, rho = 0)
twoMarkerDistribution(x, id = "bro2", SNP1, SNP2, rho = 0.5)

# X-linked
chrom(SNP1) = chrom(SNP2) = "X"

plot(x, marker = list(SNP1, SNP2))

twoMarkerDistribution(x, id = "bro2", SNP1, SNP2, rho = 0)
twoMarkerDistribution(x, id = "bro2", SNP1, SNP2, rho = 0.5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
