<!DOCTYPE html><html><head><title>Help for package sparseDFM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparseDFM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#exports'><p>UK Trade in Goods (Exports) Dataset</p></a></li>
<li><a href='#fillNA'><p>Interpolation of missing data</p></a></li>
<li><a href='#inflation'><p>UK Inflation Dataset</p></a></li>
<li><a href='#kalmanMultivariate'><p>Classic Multivariate KFS Equations</p></a></li>
<li><a href='#kalmanUnivariate'><p>Univariate filtering (sequential processing) for fast KFS</p></a></li>
<li><a href='#logspace'><p>logspace</p></a></li>
<li><a href='#missing_data_plot'><p>Plot the missing data in a data matrix/frame</p></a></li>
<li><a href='#plot.sparseDFM'><p>sparseDFM Plot Outputs</p></a></li>
<li><a href='#predict.sparseDFM'><p>Forecasting factor estimates and data series.</p></a></li>
<li><a href='#raggedEdge'><p>Generate a ragged edge structure for a data matrix</p></a></li>
<li><a href='#residuals.sparseDFM'><p>sparseDFM Residuals and Fitted Values</p></a></li>
<li><a href='#sparseDFM'><p>Estimate a Sparse Dynamic Factor Model</p></a></li>
<li><a href='#summary.sparseDFM'><p>sparseDFM Summary Outputs</p></a></li>
<li><a href='#transformData'><p>Transform data to make it stationary</p></a></li>
<li><a href='#tuneFactors'><p>Tune for the number of factors to use</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimate Dynamic Factor Models with Sparse Loadings</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of various estimation methods for dynamic factor models (DFMs) including principal components analysis (PCA) Stock and Watson (2002) &lt;<a href="https://doi.org/10.1198%2F016214502388618960">doi:10.1198/016214502388618960</a>&gt;, 2Stage Giannone et al. (2008) &lt;<a href="https://doi.org/10.1016%2Fj.jmoneco.2008.05.010">doi:10.1016/j.jmoneco.2008.05.010</a>&gt;, expectation-maximisation (EM) Banbura and Modugno (2014) &lt;<a href="https://doi.org/10.1002%2Fjae.2306">doi:10.1002/jae.2306</a>&gt;, and the novel EM-sparse approach for sparse DFMs Mosley et al. (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2303.11892">doi:10.48550/arXiv.2303.11892</a>&gt;. Options to use classic multivariate Kalman filter and smoother (KFS) equations from Shumway and Stoffer (1982) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.1982.tb00349.x">doi:10.1111/j.1467-9892.1982.tb00349.x</a>&gt; or fast univariate KFS equations from Koopman and Durbin (2000) &lt;<a href="https://doi.org/10.1111%2F1467-9892.00186">doi:10.1111/1467-9892.00186</a>&gt;, and options for independent and identically distributed (IID) white noise or auto-regressive (AR(1)) idiosyncratic errors. Algorithms coded in 'C++' and linked to R via 'RcppArmadillo'.   </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), Matrix, ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, gridExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-23 10:36:30 UTC; mosleyl</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Mosley [aut],
  Tak-Shing Chan [aut],
  Alex Gibberd [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Gibberd &lt;a.gibberd@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-23 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='exports'>UK Trade in Goods (Exports) Dataset</h2><span id='topic+exports'></span>

<h3>Description</h3>

<p>A full dataset used for nowcasting UK trade in goods (Exports) including the 9 export target series and 436 monthly indicator series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exports
</code></pre>


<h3>Format</h3>



<h4><code>exports</code></h4>

<p>A data frame with 226 observations and 445 variables:
</p>

<dl>
<dt>columns</dt><dd><p>Export target series (9) and monthly indicators (436).</p>
</dd>
<dt>rows</dt><dd><p>Monthly values from Jan 2004 to Oct 2022.</p>
</dd>
</dl>
<p>...

</p>



<h3>Source</h3>

<p><a href="https://www.ons.gov.uk/">https://www.ons.gov.uk/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load exports data 
data = exports 

</code></pre>

<hr>
<h2 id='fillNA'>Interpolation of missing data</h2><span id='topic+fillNA'></span>

<h3>Description</h3>

<p>Internal missing data is filled in using a cubic spline.
Start and end of sample missing data is filled in using the median of the series and then
smoothed with an MA(3) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillNA(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillNA_+3A_x">X</code></td>
<td>
<p>n x p numeric matrix of stationary and standardized time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X <code class="reqn">n \times p</code> numeric matrix with missing data interpolated
</p>
<p>idx.na <code class="reqn">n \times p</code> logical matrix with <code>TRUE</code> if missing and <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='inflation'>UK Inflation Dataset</h2><span id='topic+inflation'></span>

<h3>Description</h3>

<p>A subset of quarterly CPI Index data from the ONS Inflation data (Q4 2022 release).
</p>
<p>A subset of quarterly CPI Index data from the ONS Inflation data (Q4 2022 release).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inflation

inflation
</code></pre>


<h3>Format</h3>



<h4><code>inflation</code></h4>

<p>A data frame with 135 observations and 36 variables:
</p>

<dl>
<dt>columns</dt><dd><p>Different classes of inflation index</p>
</dd>
<dt>rows</dt><dd><p>Quarterly values of the relevant CPI index, benchmarked to 2015=100</p>
</dd>
</dl>
<p>...

</p>



<h4><code>inflation</code></h4>

<p>A data frame with 135 observations and 36 variables:
</p>

<dl>
<dt>columns</dt><dd><p>Different classes of inflation index</p>
</dd>
<dt>rows</dt><dd><p>Quarterly values of the relevant CPI index, benchmarked to 2015=100</p>
</dd>
</dl>
<p>...

</p>



<h3>Source</h3>

<p><a href="https://www.ons.gov.uk/economy/inflationandpriceindices/datasets/consumerpriceindices">https://www.ons.gov.uk/economy/inflationandpriceindices/datasets/consumerpriceindices</a>
</p>
<p><a href="https://www.ons.gov.uk/economy/inflationandpriceindices/datasets/consumerpriceindices">https://www.ons.gov.uk/economy/inflationandpriceindices/datasets/consumerpriceindices</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = inflation 

# load inflation data 
data = inflation 

</code></pre>

<hr>
<h2 id='kalmanMultivariate'>Classic Multivariate KFS Equations</h2><span id='topic+kalmanMultivariate'></span>

<h3>Description</h3>

<p>Implementation of the classic multivariate Kalman filter and smoother equations of Shumway and Stoffer (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalmanMultivariate(X, a0_0, P0_0, A, Lambda, Sig_e, Sig_u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalmanMultivariate_+3A_x">X</code></td>
<td>
<p>n x p, numeric matrix of (stationary) time series</p>
</td></tr>
<tr><td><code id="kalmanMultivariate_+3A_a0_0">a0_0</code></td>
<td>
<p>k x 1, initial state mean vector</p>
</td></tr>
<tr><td><code id="kalmanMultivariate_+3A_p0_0">P0_0</code></td>
<td>
<p>k x k, initial state covariance matrix</p>
</td></tr>
<tr><td><code id="kalmanMultivariate_+3A_a">A</code></td>
<td>
<p>k x k, state transition matrix</p>
</td></tr>
<tr><td><code id="kalmanMultivariate_+3A_lambda">Lambda</code></td>
<td>
<p>p x k, measurement matrix</p>
</td></tr>
<tr><td><code id="kalmanMultivariate_+3A_sig_e">Sig_e</code></td>
<td>
<p>p x p, measurement equation residuals covariance matrix (diagonal)</p>
</td></tr>
<tr><td><code id="kalmanMultivariate_+3A_sig_u">Sig_u</code></td>
<td>
<p>k x k, state equation residuals covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For full details of the classic multivariate KFS approach, please refer to Mosley et al. (2023). Note that <code class="reqn">n</code> is the number of observations, <code class="reqn">p</code> is the number of time series, and <code class="reqn">k</code> is the number of states.
</p>


<h3>Value</h3>

<p>logl log-likelihood of the innovations from the Kalman filter
</p>
<p>at_t <code class="reqn">k \times n</code>, filtered state mean vectors
</p>
<p>Pt_t <code class="reqn">k \times k \times n</code>, filtered state covariance matrices
</p>
<p>at_n <code class="reqn">k \times n</code>, smoothed state mean vectors
</p>
<p>Pt_n <code class="reqn">k \times k \times n</code>, smoothed state covariance matrices
</p>
<p>Pt_tlag_n <code class="reqn">k \times k \times n</code>, smoothed state covariance with lag
</p>


<h3>References</h3>

<p>Mosley, L., Chan, TS., &amp; Gibberd, A. (2023). sparseDFM: An R Package to Estimate Dynamic Factor Models with Sparse Loadings.
</p>
<p>Shumway, R. H., &amp; Stoffer, D. S. (1982). An approach to time series smoothing and forecasting using the EM algorithm. <em>Journal of time series analysis, 3</em>(4), 253-264.
</p>

<hr>
<h2 id='kalmanUnivariate'>Univariate filtering (sequential processing) for fast KFS</h2><span id='topic+kalmanUnivariate'></span>

<h3>Description</h3>

<p>Univariate treatment (sequential processing) of the multivariate Kalman filter and smoother equations for fast implementation. Refer to Koopman and Durbin (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalmanUnivariate(X, a0_0, P0_0, A, Lambda, Sig_e, Sig_u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalmanUnivariate_+3A_x">X</code></td>
<td>
<p>n x p, numeric matrix of (stationary) time series</p>
</td></tr>
<tr><td><code id="kalmanUnivariate_+3A_a0_0">a0_0</code></td>
<td>
<p>k x 1, initial state mean vector</p>
</td></tr>
<tr><td><code id="kalmanUnivariate_+3A_p0_0">P0_0</code></td>
<td>
<p>k x k, initial state covariance matrix</p>
</td></tr>
<tr><td><code id="kalmanUnivariate_+3A_a">A</code></td>
<td>
<p>k x k, state transition matrix</p>
</td></tr>
<tr><td><code id="kalmanUnivariate_+3A_lambda">Lambda</code></td>
<td>
<p>p x k, measurement matrix</p>
</td></tr>
<tr><td><code id="kalmanUnivariate_+3A_sig_e">Sig_e</code></td>
<td>
<p>p x p, measurement equation residuals covariance matrix (diagonal)</p>
</td></tr>
<tr><td><code id="kalmanUnivariate_+3A_sig_u">Sig_u</code></td>
<td>
<p>k x k, state equation residuals covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For full details of the univariate filtering approach, please refer to Mosley et al. (2023). Note that <code class="reqn">n</code> is the number of observations, <code class="reqn">p</code> is the number of time series, and <code class="reqn">k</code> is the number of states.
</p>


<h3>Value</h3>

<p>logl log-likelihood of the innovations from the Kalman filter
</p>
<p>at_t <code class="reqn">k \times n</code>, filtered state mean vectors
</p>
<p>Pt_t <code class="reqn">k \times k \times n</code>, filtered state covariance matrices
</p>
<p>at_n <code class="reqn">k \times n</code>, smoothed state mean vectors
</p>
<p>Pt_n <code class="reqn">k \times k \times n</code>, smoothed state covariance matrices
</p>
<p>Pt_tlag_n <code class="reqn">k \times k \times n</code>, smoothed state covariance with lag
</p>


<h3>References</h3>

<p>Koopman, S. J., &amp; Durbin, J. (2000). Fast filtering and smoothing for multivariate state space models. <em>Journal of Time Series Analysis, 21</em>(3), 281-296.
</p>
<p>Mosley, L., Chan, TS., &amp; Gibberd, A. (2023). sparseDFM: An R Package to Estimate Dynamic Factor Models with Sparse Loadings.
</p>

<hr>
<h2 id='logspace'>logspace</h2><span id='topic+logspace'></span>

<h3>Description</h3>

<p>Produce a vector of log10 space values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logspace(x1, x2, n = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logspace_+3A_x1">x1</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="logspace_+3A_x2">x2</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="logspace_+3A_n">n</code></td>
<td>
<p>length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of log10 spaced values of length n
</p>

<hr>
<h2 id='missing_data_plot'>Plot the missing data in a data matrix/frame</h2><span id='topic+missing_data_plot'></span>

<h3>Description</h3>

<p>Visualise the amount of missing data in a data matrix or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_data_plot(
  data,
  present.colour = "grey80",
  missing.colour = "grey20",
  use.names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_data_plot_+3A_data">data</code></td>
<td>
<p>Numeric matrix or data frame with NA for missing values.</p>
</td></tr>
<tr><td><code id="missing_data_plot_+3A_present.colour">present.colour</code></td>
<td>
<p>The colour for data that is present. Default is 'grey80'.</p>
</td></tr>
<tr><td><code id="missing_data_plot_+3A_missing.colour">missing.colour</code></td>
<td>
<p>The colour for data that is missing. Default is 'grey20'.</p>
</td></tr>
<tr><td><code id="missing_data_plot_+3A_use.names">use.names</code></td>
<td>
<p>Logical. Label the axis with data variables names. Default is TRUE. Set to FALSE to remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix plot showing where missing data is present.
</p>

<hr>
<h2 id='plot.sparseDFM'>sparseDFM Plot Outputs</h2><span id='topic+plot.sparseDFM'></span>

<h3>Description</h3>

<p>Make plots for the output of sparseDFM(). Options include:
</p>

<ul>
<li> <p><code>factor</code> - plot factor estimate series on top of the original standardized stationary data
</p>
</li>
<li> <p><code>loading.heatmap</code> - make a heatmap of the loadings matrix
</p>
</li>
<li> <p><code>loading.lineplot</code> - make a lineplot of variable loadings for a given factor
</p>
</li>
<li> <p><code>loading.grouplineplot</code> - separate variable groups into colours for better visualisation
</p>
</li>
<li> <p><code>residual</code> - boxplot or scatterplot of residuals
</p>
</li>
<li> <p><code>lasso.bic</code> - BIC values for the LASSO tuning parameter
</p>
</li>
<li> <p><code>em.convergence</code> - log-likelihood convergence of EM iterations
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseDFM'
plot(
  x,
  type = "factor",
  which.factors = 1:(dim(x$state$factors)[2]),
  scale.factors = TRUE,
  which.series = 1:(dim(x$params$Lambda)[1]),
  loading.factor = 1,
  series.col = "grey",
  factor.col = "black",
  factor.lwd = 2,
  factor.lab = NULL,
  use.series.names = FALSE,
  series.lab = NULL,
  series.labpos = NULL,
  colorkey = TRUE,
  col.regions = NULL,
  group.names = NULL,
  group.cols = NULL,
  group.legend = TRUE,
  residual.type = "boxplot",
  scatter.series = 1,
  min.bic.col = "red",
  alpha_index = "best",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparseDFM_+3A_x">x</code></td>
<td>
<p>an object of class 'sparseDFM'.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_type">type</code></td>
<td>
<p>character. The type of plot: <code>"factor"</code>, <code>"loading.heatmap"</code>, <code>"loading.lineplot"</code>, <code>"loading.grouplineplot"</code> or <code>"residual"</code>. Default is <code>"factor"</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_which.factors">which.factors</code></td>
<td>
<p>numeric vector of integers representing which factors should be plotted in <code>"factor"</code> and <code>"loading.heatmap"</code>. Default is <code>which.factors</code>=<code>1:(dim(x$state$factors)[2])</code>, plotting them all. Accepts a single integer if just one factor required.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_scale.factors">scale.factors</code></td>
<td>
<p>logical. Standardize the factor estimates when plotting in <code>"factor"</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_which.series">which.series</code></td>
<td>
<p>numeric vector of integers representing which series should be plotted in <code>"loading.heatmap"</code>, <code>"loading.lineplot"</code>, <code>"loading.grouplineplot"</code> and <code>"residual"</code>. Default is <code>which.series</code> = <code>1:(dim(x$params$Lambda)[1])</code>, plotting them all.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_loading.factor">loading.factor</code></td>
<td>
<p>integer. The factor to use in <code>"loading.lineplot"</code> and <code>"loading.grouplineplot"</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_series.col">series.col</code></td>
<td>
<p>character. The colour of the background series plotted in <code>"factor"</code>. Default is <code>series.col</code> = <code>"grey"</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_factor.col">factor.col</code></td>
<td>
<p>character. The colour of the factor estimate line in <code>"factor"</code>. Default is <code>factor.col</code> = <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_factor.lwd">factor.lwd</code></td>
<td>
<p>integer. The line width of the factor estimate line in <code>"factor"</code>. Default is <code>factor.lwd</code> = 2.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_factor.lab">factor.lab</code></td>
<td>
<p>vector of characters to label each factor in <code>"loading.heatmap"</code>. Default is <code>NULL</code> for standard labeling.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_use.series.names">use.series.names</code></td>
<td>
<p>logical. Set to TRUE if plot should display series names in the data matrix X. Default is <code>FALSE</code> for numbered series.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_series.lab">series.lab</code></td>
<td>
<p>vector of characters to label each data series in <code>"loading.heatmap"</code>. Default is <code>NULL</code> for standard labeling.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_series.labpos">series.labpos</code></td>
<td>
<p>numeric vector of integers representing which series are labeled by <code>series.lab</code>. Default is <code>NULL</code> for standard labeling.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_colorkey">colorkey</code></td>
<td>
<p>logical. Display the colour key of the heatmap in <code>"loading.heatmap"</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_col.regions">col.regions</code></td>
<td>
<p>vector of gradually varying colors for <code>"loading.heatmap"</code>, see levelplot package. Default is <code>NULL</code> for standard colours.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_group.names">group.names</code></td>
<td>
<p>vector of characters of the same dimension as <code>which.series</code> to represent the name of the group for each series in <code>"loading.grouplineplot"</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_group.cols">group.cols</code></td>
<td>
<p>vector of characters of the same dimension as the number of different groups in <code>"loading.grouplineplot"</code> to represent the colours of the groups.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_group.legend">group.legend</code></td>
<td>
<p>logical. Display the legend. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_residual.type">residual.type</code></td>
<td>
<p>character. The type of residual plot: <code>"boxplot"</code> or <code>"scatterplot"</code>. Default is <code>"boxplot"</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_scatter.series">scatter.series</code></td>
<td>
<p>integer. The series to plot when <code>residual.type</code> = <code>"scatterplot"</code>. Default is series 1.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_min.bic.col">min.bic.col</code></td>
<td>
<p>character. Colour for the best <code class="reqn">\alpha</code> point. Default is <code>'red'</code>.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_alpha_index">alpha_index</code></td>
<td>
<p>Choose which L1 penalty parameter to display the results for. Default is 'best'. Otherwise, input a number between 1:length(alpha_grid) that indicates the required alpha parameter.</p>
</td></tr>
<tr><td><code id="plot.sparseDFM_+3A_...">...</code></td>
<td>
<p>for <code>plot.sparseDFM</code>. Further plot arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots for the output of sparseDFM().
</p>

<hr>
<h2 id='predict.sparseDFM'>Forecasting factor estimates and data series.</h2><span id='topic+predict.sparseDFM'></span><span id='topic+print.sparseDFM_forecast'></span>

<h3>Description</h3>

<p>Predict the next h steps ahead for the factor estimates and the data series. Given information up to time <code class="reqn">t</code>, a h-step ahead forecast is <code class="reqn">\bm{X}_{t+h}=\bm{\Lambda}\bm{A}^{h}\bm{F}_t+\bm{\Phi}^h\bm{\epsilon}_t</code>, where <code class="reqn">\bm{\Phi}=0</code> for the IID idiosyncratic error case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseDFM'
predict(object, h = 1, standardize = FALSE, alpha_index = "best", ...)

## S3 method for class 'sparseDFM_forecast'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sparseDFM_+3A_object">object</code></td>
<td>
<p>an object of class 'sparseDFM'.</p>
</td></tr>
<tr><td><code id="predict.sparseDFM_+3A_h">h</code></td>
<td>
<p>integer. The number of steps ahead to compute the forecast for. Default is <code class="reqn">h=1</code>.</p>
</td></tr>
<tr><td><code id="predict.sparseDFM_+3A_standardize">standardize</code></td>
<td>
<p>logical. Returns data series forecasts in the original data scale if set to <code>FALSE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.sparseDFM_+3A_alpha_index">alpha_index</code></td>
<td>
<p>Choose which L1 penalty parameter to display the results for. Default is 'best'. Otherwise, input a number between 1:length(alpha_grid) that indicates the required alpha parameter.</p>
</td></tr>
<tr><td><code id="predict.sparseDFM_+3A_...">...</code></td>
<td>
<p>Further <code>print</code> arguments.</p>
</td></tr>
<tr><td><code id="predict.sparseDFM_+3A_x">x</code></td>
<td>
<p>an object of class 'sparseDFM_forecast' from <code>predict.sparseDFM</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X_hat <code class="reqn">h \times p</code> numeric matrix of data series forecasts.
</p>
<p>F_hat <code class="reqn">h \times r</code> numeric matrix of factor forecasts.
</p>
<p>e_hat <code class="reqn">h \times p</code> numeric matrix of AR(1) idiosyncratic error forecasts if <code>err</code>=<code>AR1</code> in <code>sparseDFM</code>.
</p>
<p>h forecasts produced for h steps ahead.
</p>
<p>err the type of idiosyncratic errors used in <code>sparseDFM</code>.
</p>
<p>Prints out the h-step ahead forecast from <code>predict.sparseDFM</code>.
</p>

<hr>
<h2 id='raggedEdge'>Generate a ragged edge structure for a data matrix</h2><span id='topic+raggedEdge'></span>

<h3>Description</h3>

<p>Generate a ragged edge structure for a data matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raggedEdge(X, lags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raggedEdge_+3A_x">X</code></td>
<td>
<p>numeric data matrix</p>
</td></tr>
<tr><td><code id="raggedEdge_+3A_lags">lags</code></td>
<td>
<p>vector of integers representing publication lag of each variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ragged edge version of X
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = matrix(rnorm(100),ncol=10)
pub_lags = c(rep(2,5),rep(1,3),rep(0,2))
new_data = raggedEdge(data, pub_lags)


</code></pre>

<hr>
<h2 id='residuals.sparseDFM'>sparseDFM Residuals and Fitted Values</h2><span id='topic+residuals.sparseDFM'></span><span id='topic+fitted.sparseDFM'></span><span id='topic+resid.sparseDFM'></span>

<h3>Description</h3>

<p>Obtain the residuals or fitted values of the <code>sparseDFM</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseDFM'
fitted(object, standardize = FALSE, alpha_index = "best", ...)

## S3 method for class 'sparseDFM'
residuals(object, standardize = FALSE, alpha_index = "best", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.sparseDFM_+3A_object">object</code></td>
<td>
<p>an object of class 'sparseDFM'.</p>
</td></tr>
<tr><td><code id="residuals.sparseDFM_+3A_standardize">standardize</code></td>
<td>
<p>logical. The residuals and fitted values should be standardized. Default is <code>FALSE</code>, values returned in the original data <code class="reqn">\bm{X}</code> scale.</p>
</td></tr>
<tr><td><code id="residuals.sparseDFM_+3A_alpha_index">alpha_index</code></td>
<td>
<p>Choose which L1 penalty parameter to display the results for. Default is 'best'. Otherwise, input a number between 1:length(alpha_grid) that indicates the required alpha parameter.</p>
</td></tr>
<tr><td><code id="residuals.sparseDFM_+3A_...">...</code></td>
<td>
<p>Further <code>residuals</code> arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals or fitted values of <code>sparseDFM</code>.
</p>

<hr>
<h2 id='sparseDFM'>Estimate a Sparse Dynamic Factor Model</h2><span id='topic+sparseDFM'></span>

<h3>Description</h3>

<p>Main function to allow estimation of a DFM or a sparse DFM (with sparse loadings) on stationary data that may have arbitrary patterns of missing data. We allow the user:
</p>

<ul>
<li><p> an option for estimation method - <code>"PCA"</code>, <code>"2Stage"</code>, <code>"EM"</code> or <code>"EM-sparse"</code>
</p>
</li>
<li><p> an option for <code>IID</code> or <code>AR1</code> idiosyncratic errors
</p>
</li>
<li><p> an option for Kalman Filter/Smoother estimation using standard <code>multivariate</code> equations or fast <code>univariate</code> filtering equations
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sparseDFM(
  X,
  r,
  q = 0,
  alphas = logspace(-2, 3, 100),
  alg = "EM-sparse",
  err = "IID",
  kalman = "univariate",
  store.parameters = FALSE,
  standardize = TRUE,
  max_iter = 100,
  threshold = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseDFM_+3A_x">X</code></td>
<td>
<p><code>n x p</code> numeric data matrix or data frame of (stationary) time series.</p>
</td></tr>
<tr><td><code id="sparseDFM_+3A_r">r</code></td>
<td>
<p>Integer. Number of factors.</p>
</td></tr>
<tr><td><code id="sparseDFM_+3A_q">q</code></td>
<td>
<p>Integer. The first q series (columns of X) should not be made sparse. Default q = 0.</p>
</td></tr>
<tr><td><code id="sparseDFM_+3A_alphas">alphas</code></td>
<td>
<p>Numeric vector or value of LASSO regularisation parameters. Default is alphas = logspace(-2,3,100).</p>
</td></tr>
<tr><td><code id="sparseDFM_+3A_alg">alg</code></td>
<td>
<p>Character. Option for estimation algorithm. Default is <code>"EM-sparse"</code>. Options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"PCA"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> principle components analysis (PCA) for static factors seen in Stock and Watson (2002). </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"2Stage"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the two-stage framework of PCA plus Kalman filter/smoother seen in Giannone et al. (2008) and Doz et al. (2011). </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"EM"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the quasi-maximum likelihood approach using the EM algorithm to handle arbitrary patterns of missing data seen in Banbura and Modugno (2014). </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"EM-sparse"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the novel sparse EM approach allowing LASSO regularisation on factor loadings seen in (cite our paper). </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="sparseDFM_+3A_err">err</code></td>
<td>
<p>Character. Option for idiosyncratic errors. Default is <code>"IID"</code>. Options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"IID"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> errors are IID white noise. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"AR1"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> errors follow an AR(1) process. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="sparseDFM_+3A_kalman">kalman</code></td>
<td>
<p>Character. Option for Kalman filter and smoother equations. Default is <code>"univariate"</code>. Options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"multivariate"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> classic Kalman filter and smoother equations seen in Shumway and Stoffer (1982). </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"univaraite"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> univariate treatment (sequential processing) of the multivariate equations for fast Kalman filter and smoother seen in Koopman and Durbin (2000). </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="sparseDFM_+3A_store.parameters">store.parameters</code></td>
<td>
<p>Logical. Store outputs for every alpha L1 penalty parameter. Default is FALSE.</p>
</td></tr>
<tr><td><code id="sparseDFM_+3A_standardize">standardize</code></td>
<td>
<p>Logical. Standardize the data before estimating the model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sparseDFM_+3A_max_iter">max_iter</code></td>
<td>
<p>Integer. Maximum number of EM iterations. Default is 100.</p>
</td></tr>
<tr><td><code id="sparseDFM_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. Tolerance on EM iterates. Default is 1e-4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For full details of the model please refer to Mosley et al. (2023).
</p>


<h3>Value</h3>

<p>A list-of-lists-like S3 object of class 'sparseDFM' with the following elements:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>A list containing information about the data with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>X</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is the original <code class="reqn">n \times p</code> numeric data matrix of (stationary) time series. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>standardize</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a logical value indicating whether the original data was standardized.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>X.mean</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a p-dimensional numeric vector of column means of <code class="reqn">X</code>.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>X.sd</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a p-dimensional numeric vector of column standard deviations of <code class="reqn">X</code>.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>X.bal</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a <code class="reqn">n \times p</code> numeric data matrix of the original <code class="reqn">X</code> with missing data interpolated using <code>fillNA()</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>eigen</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is the eigen decomposition of <code>X.bal</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>fitted</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is the <code class="reqn">n \times p</code> predicted data matrix using the estimated parameters: <code class="reqn">\hat{\Lambda}\hat{F}</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>fitted.unscaled</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is the <code class="reqn">n \times p</code> predicted data matrix using the estimated parameters: <code class="reqn">\hat{\Lambda}\hat{F}</code> that has been unscaled back to original data scale if <code>standardize</code> is <code>TRUE</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>method</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the estimation algorithm used (<code>alg</code>). </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>err</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the type of idiosyncratic errors assumed. Either <code>IID</code> or <code>AR1</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>call</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> call object obtained from <code>match.call()</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

</td></tr>
<tr><td><code>params</code></td>
<td>
<p>A list containing the estimated parameters of the model with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>A</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the <code class="reqn">r \times r</code> factor transition matrix. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Phi</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the p-dimensional vector of AR(1) coefficients for the idiosyncratic errors. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Lambda</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the <code class="reqn">p \times r</code> loadings matrix. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Sigma_u</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the <code class="reqn">r \times r</code> factor transition error covariance matrix. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Sigma_epsilon</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the p-dimensional vector of idiosyncratic error variances. As <code class="reqn">\bm{\Sigma}_{\epsilon}</code> is assumed to be diagonal. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

</td></tr>
<tr><td><code>state</code></td>
<td>
<p>A list containing the estimated states and state covariances with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>factors</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the <code class="reqn">n \times r</code> matrix of factor estimates. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>errors</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the <code class="reqn">n \times p</code> matrix of AR(1) idiosyncratic error estimates. For err = AR1 only. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>factors.cov</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the <code class="reqn">r \times r \times n</code> covariance matrices of the factor estimates. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>errors.cov</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the <code class="reqn">p \times p \times n</code> covariance matrices of the AR(1) idiosyncratic error estimates. For err = AR1 only. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

</td></tr>
<tr><td><code>em</code></td>
<td>
<p>A list containing information about the EM algorithm with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>converged</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> a logical value indicating whether the EM algorithm converged. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>alpha_grid</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> a numerical vector containing the LASSO tuning parameters considered in BIC evaluation before stopping. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>alpha_opt</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the optimal LASSO tuning parameter used. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bic</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> a numerical vector containing BIC values for the corresponding LASSO tuning parameter in <code>alpha_grid</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>loglik</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> the log-likelihood of the innovations from the Kalman filter in the final model. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>num_iter</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> number of iterations taken by the EM algorithm. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tol</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> tolerance for EM convergence. Matches <code>threshold</code> in the input. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>max_iter</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> maximum number of iterations allowed for the EM algorithm. Matches <code>max_iter</code> in the input. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>em_time</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> time taken for EM convergence </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

</td></tr>
<tr><td><code>alpha.output</code></td>
<td>
<p>Parameter and state outputs for each L1-norm penalty parameter in <code>alphas</code> if <code>store.parameters = TRUE</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Banbura, M., &amp; Modugno, M. (2014). Maximum likelihood estimation of factor models on datasets with arbitrary pattern of missing data. <em>Journal of Applied Econometrics, 29</em>(1), 133-160.
</p>
<p>Doz, C., Giannone, D., &amp; Reichlin, L. (2011). A two-step estimator for large approximate dynamic factor models based on Kalman filtering. <em>Journal of Econometrics, 164</em>(1), 188-205.
</p>
<p>Giannone, D., Reichlin, L., &amp; Small, D. (2008). Nowcasting: The real-time informational content of macroeconomic data. <em>Journal of monetary economics, 55</em>(4), 665-676.
</p>
<p>Koopman, S. J., &amp; Durbin, J. (2000). Fast filtering and smoothing for multivariate state space models. <em>Journal of Time Series Analysis, 21</em>(3), 281-296.
</p>
<p>Mosley, L., Chan, TS., &amp; Gibberd, A. (2023). sparseDFM: An R Package to Estimate Dynamic Factor Models with Sparse Loadings.
</p>
<p>Shumway, R. H., &amp; Stoffer, D. S. (1982). An approach to time series smoothing and forecasting using the EM algorithm. <em>Journal of time series analysis, 3</em>(4), 253-264.
</p>
<p>Stock, J. H., &amp; Watson, M. W. (2002). Forecasting using principal components from a large number of predictors. <em>Journal of the American statistical association, 97</em>(460), 1167-1179.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load inflation data set 
data = inflation

# reduce the size for these examples - full data found in vignette 
data = data[1:60,]

# make stationary by taking first differences 
new_data = transformData(data, rep(2,ncol(data)))

# tune for the number of factors to use 
tuneFactors(new_data, type = 2)

# fit a PCA using 3 PC's
fit.pca &lt;- sparseDFM(new_data, r = 3, alg = 'PCA')

# fit a DFM using the two-stage approach 
fit.2stage &lt;- sparseDFM(new_data, r = 3, alg = '2Stage')

# fit a DFM using EM algorithm with 3 factors 
fit.dfm &lt;- sparseDFM(new_data, r = 3, alg = 'EM')

# fit a Sparse DFM with 3 factors
fit.sdfm &lt;- sparseDFM(new_data, r = 3, alg = 'EM-sparse')

# observe the factor loadings of the sparse DFM
plot(fit.sdfm, type = 'loading.heatmap')

# observe the factors 
plot(fit.sdfm, type = 'factor')

# observe the residuals 
plot(fit.sdfm, type = 'residual')

# observe the LASSO parameter selected and BIC values 
plot(fit.sdfm, type = 'lasso.bic')

# predict 3 steps ahead 
predict(fit.sdfm, h = 3)

 
</code></pre>

<hr>
<h2 id='summary.sparseDFM'>sparseDFM Summary Outputs</h2><span id='topic+summary.sparseDFM'></span><span id='topic+print.sparseDFM'></span>

<h3>Description</h3>

<p>Summary and print outputs for class 'sparseDFM'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseDFM'
print(x, ...)

## S3 method for class 'sparseDFM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sparseDFM_+3A_x">x</code></td>
<td>
<p>an object of class 'sparseDFM'</p>
</td></tr>
<tr><td><code id="summary.sparseDFM_+3A_...">...</code></td>
<td>
<p>Further <code>summary</code> arguments.</p>
</td></tr>
<tr><td><code id="summary.sparseDFM_+3A_object">object</code></td>
<td>
<p>an object of class 'sparseDFM'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information on the model fitted.
</p>
<p>Summary information on estimation details.
</p>

<hr>
<h2 id='transformData'>Transform data to make it stationary</h2><span id='topic+transformData'></span>

<h3>Description</h3>

<p>Methods to transform the data to make it stationary. Input a <code class="reqn">n \times p</code> numeric data matrix and what transform is required for each data series. Returns a <code class="reqn">n \times p</code> matrix of the transformed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformData(X, stationary_transform)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformData_+3A_x">X</code></td>
<td>
<p>n x p numeric data matrix</p>
</td></tr>
<tr><td><code id="transformData_+3A_stationary_transform">stationary_transform</code></td>
<td>
<p>p-dimensional vector filled with numbers from <code class="reqn">\{1,2,3,4,5,6,7\}</code> representing:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>1</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> no change </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> first difference <code class="reqn">X_{i,t} - X_{i,t-1}</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>3</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> second difference <code class="reqn">(X_{i,t} - X_{i,t-1}) - (X_{i,t-1} - X_{i,t-2})</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>4</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> log first difference <code class="reqn">log(X_{i,t}) - log(X_{i,t-1})</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>5</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> log second difference <code class="reqn">(log(X_{i,t}) - log(X_{i,t-1})) - (log(X_{i,t-1}) - log(X_{i,t-2}))</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>6</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> growth rate <code class="reqn">(X_{i,t} - X_{i,t-1})/X_{i,t-1}</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>7</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> log growth rate <code class="reqn">(log(X_{i,t}) - log(X_{i,t-1}))/log(X_{i,t-1})</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
</table>


<h3>Value</h3>

<p>Transformed stationary version of <code class="reqn">\bm{X}</code>.
</p>

<hr>
<h2 id='tuneFactors'>Tune for the number of factors to use</h2><span id='topic+tuneFactors'></span>

<h3>Description</h3>

<p>Uses Bai and Ng (2002) information criteria approach. Missing data is interpolated using the <code>fillNA</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuneFactors(
  X,
  type = 2,
  standardize = TRUE,
  r.max = min(15, ncol(X) - 1),
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuneFactors_+3A_x">X</code></td>
<td>
<p><code>n x p</code> numeric data matrix or data frame of (stationary) time series.</p>
</td></tr>
<tr><td><code id="tuneFactors_+3A_type">type</code></td>
<td>
<p>Character. Option for which information criteria to use. Default is 2.</p>
</td></tr>
<tr><td><code id="tuneFactors_+3A_standardize">standardize</code></td>
<td>
<p>Logical. Standardize the data before estimating the model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tuneFactors_+3A_r.max">r.max</code></td>
<td>
<p>Integer. Maximum number of factors to search for. Default is min(15,ncol(X)-1).</p>
</td></tr>
<tr><td><code id="tuneFactors_+3A_plot">plot</code></td>
<td>
<p>Logical. Make a plot showing the IC value for each of the number of factors considered. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate the number of factors to use in the model, the information criteria approach of Bai and Ng (2002) is used. This can be done before <code>sparseDFM</code> is fitted to the data to determine <code>r</code>. Bai and Ng (2002) consider 3 types of information criteria with different penalties of the form:
</p>
<p style="text-align: center;"><code class="reqn">IC_1(r) = log\left(V_r(\hat{\bm{F}},\hat{\bm{\Lambda}})\right) + r \left( \frac{n+p}{np}\right)log\left( \frac{np}{n+p}\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">IC_2(r) = log\left(V_r(\hat{\bm{F}},\hat{\bm{\Lambda}})\right) + r \left( \frac{n+p}{np} \right)log\left( min\{n,p\}\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">IC_3(r) = log\left(V_r(\hat{\bm{F}},\hat{\bm{\Lambda}})\right) + r \frac{log\left( min\{n,p\}\right)}{min\{n,p\}}</code>
</p>

<p>The sum of squared residuals for <code class="reqn">r</code> factors <code class="reqn">V_r(\hat{\bm{F}},\hat{\bm{\Lambda}}) = \sum_{i=1}^p\sum_{t=1}^n E[\hat{\epsilon}_{i,t}^2]/np</code> with <code class="reqn">\hat{\epsilon}_{i,t} = X_{t,i}-\hat{\bm{F}}_t\hat{\bm{\Lambda}}_i</code> is found using PCA on the standardized data set <code class="reqn">\bm{X}</code>. The estimated factors <code class="reqn">\hat{\bm{F}}</code> corresponding to the principle components and the estimated loadings <code class="reqn">\hat{\bm{\Lambda}}</code> corresponding to the eigenvectors. Should the data contain missing values, then the missing data is interpolated using <code>fillNA</code>.
</p>
<p>The number of factors to use will correspond to <code class="reqn">argmin_r IC_i(r)</code> for <code class="reqn">i=1,2</code> or <code class="reqn">3</code>. Type 2 is the highest when working in finite samples and therefore is set to default.
</p>


<h3>Value</h3>

<p>The number of factors to use according to Bai and Ng (2002) information criteria.
</p>


<h3>References</h3>

<p>Bai, J., &amp; Ng, S. (2002). Determining the number of factors in approximate factor models. <em>Econometrica, 70</em>(1), 191-221.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
