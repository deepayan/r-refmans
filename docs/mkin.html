<!DOCTYPE html><html><head><title>Help for package mkin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mkin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.mmkin'><p>Subsetting method for mmkin objects</p></a></li>
<li><a href='#add_err'><p>Add normally distributed errors to simulated kinetic degradation data</p></a></li>
<li><a href='#AIC.mmkin'><p>Calculate the AIC for a column of an mmkin object</p></a></li>
<li><a href='#anova.saem.mmkin'><p>Anova method for saem.mmkin objects</p></a></li>
<li><a href='#aw'><p>Calculate Akaike weights for model averaging</p></a></li>
<li><a href='#CAKE_export'><p>Export a list of datasets format to a CAKE study file</p></a></li>
<li><a href='#confint.mkinfit'><p>Confidence intervals for parameters of mkinfit objects</p></a></li>
<li><a href='#create_deg_func'><p>Create degradation functions for known analytical solutions</p></a></li>
<li><a href='#D24_2014'><p>Aerobic soil degradation data on 2,4-D from the EU assessment in 2014</p></a></li>
<li><a href='#DFOP.solution'><p>Double First-Order in Parallel kinetics</p></a></li>
<li><a href='#dimethenamid_2018'><p>Aerobic soil degradation data on dimethenamid and dimethenamid-P from the EU assessment in 2018</p></a></li>
<li><a href='#ds_mixed'><p>Synthetic data for hierarchical kinetic degradation models</p></a></li>
<li><a href='#endpoints'><p>Function to calculate endpoints for further use from kinetic models fitted</p>
with mkinfit</a></li>
<li><a href='#experimental_data_for_UBA_2019'>
<p>Experimental datasets used for development and testing of error models</p></a></li>
<li><a href='#f_time_norm_focus'><p>Normalisation factors for aerobic soil degradation according to FOCUS guidance</p></a></li>
<li><a href='#FOCUS_2006_datasets'>
<p>Datasets A to F from the FOCUS Kinetics report from 2006</p></a></li>
<li><a href='#FOCUS_2006_DFOP_ref_A_to_B'>
<p>Results of fitting the DFOP model to Datasets A to B of FOCUS (2006)</p></a></li>
<li><a href='#FOCUS_2006_FOMC_ref_A_to_F'>
<p>Results of fitting the FOMC model to Datasets A to F of FOCUS (2006)</p></a></li>
<li><a href='#FOCUS_2006_HS_ref_A_to_F'>
<p>Results of fitting the HS model to Datasets A to F of FOCUS (2006)</p></a></li>
<li><a href='#FOCUS_2006_SFO_ref_A_to_F'>
<p>Results of fitting the SFO model to Datasets A to F of FOCUS (2006)</p></a></li>
<li><a href='#focus_soil_moisture'><p>FOCUS default values for soil moisture contents at field capacity, MWHC and 1/3 bar</p></a></li>
<li><a href='#FOMC.solution'><p>First-Order Multi-Compartment kinetics</p></a></li>
<li><a href='#get_deg_func'><p>Retrieve a degradation function from the mmkin namespace</p></a></li>
<li><a href='#hierarchical_kinetics'><p>Hierarchical kinetics template</p></a></li>
<li><a href='#HS.solution'><p>Hockey-Stick kinetics</p></a></li>
<li><a href='#illparms'><p>Method to get the names of ill-defined parameters</p></a></li>
<li><a href='#ilr'><p>Function to perform isometric log-ratio transformation</p></a></li>
<li><a href='#intervals.saem.mmkin'><p>Confidence intervals for parameters in saem.mmkin objects</p></a></li>
<li><a href='#IORE.solution'><p>Indeterminate order rate equation kinetics</p></a></li>
<li><a href='#llhist'><p>Plot the distribution of log likelihoods from multistart objects</p></a></li>
<li><a href='#loftest'><p>Lack-of-fit test for models fitted to data with replicates</p></a></li>
<li><a href='#logistic.solution'><p>Logistic kinetics</p></a></li>
<li><a href='#logLik.mkinfit'><p>Calculated the log-likelihood of a fitted mkinfit object</p></a></li>
<li><a href='#logLik.saem.mmkin'><p>logLik method for saem.mmkin objects</p></a></li>
<li><a href='#lrtest.mkinfit'><p>Likelihood ratio test for mkinfit models</p></a></li>
<li><a href='#max_twa_parent'><p>Function to calculate maximum time weighted average concentrations from</p>
kinetic models fitted with mkinfit</a></li>
<li><a href='#mccall81_245T'>
<p>Datasets on aerobic soil metabolism of 2,4,5-T in six soils</p></a></li>
<li><a href='#mean_degparms'><p>Calculate mean degradation parameters for an mmkin row object</p></a></li>
<li><a href='#mhmkin'><p>Fit nonlinear mixed-effects models built from one or more kinetic</p>
degradation models and one or more error models</a></li>
<li><a href='#mixed'><p>Create a mixed effects model from an mmkin row object</p></a></li>
<li><a href='#mkin_long_to_wide'><p>Convert a dataframe from long to wide format</p></a></li>
<li><a href='#mkin_wide_to_long'><p>Convert a dataframe with observations over time into long format</p></a></li>
<li><a href='#mkinds'><p>A dataset class for mkin</p></a></li>
<li><a href='#mkindsg'><p>A class for dataset groups for mkin</p></a></li>
<li><a href='#mkinerrmin'><p>Calculate the minimum error to assume in order to pass the variance test</p></a></li>
<li><a href='#mkinerrplot'><p>Function to plot squared residuals and the error model for an mkin object</p></a></li>
<li><a href='#mkinfit'><p>Fit a kinetic model to data with one or more state variables</p></a></li>
<li><a href='#mkinmod'><p>Function to set up a kinetic model with one or more state variables</p></a></li>
<li><a href='#mkinparplot'><p>Function to plot the confidence intervals obtained using mkinfit</p></a></li>
<li><a href='#mkinplot'><p>Plot the observed data and the fitted model of an mkinfit object</p></a></li>
<li><a href='#mkinpredict'><p>Produce predictions from a kinetic model using specific parameters</p></a></li>
<li><a href='#mkinresplot'><p>Function to plot residuals stored in an mkin object</p></a></li>
<li><a href='#mmkin'><p>Fit one or more kinetic models with one or more state variables to one or</p>
more datasets</a></li>
<li><a href='#multistart'><p>Perform a hierarchical model fit with multiple starting values</p></a></li>
<li><a href='#nafta'><p>Evaluate parent kinetics using the NAFTA guidance</p></a></li>
<li><a href='#NAFTA_SOP_2015'>
<p>Example datasets from the NAFTA SOP published 2015</p></a></li>
<li><a href='#NAFTA_SOP_Attachment'>
<p>Example datasets from Attachment 1 to the NAFTA SOP published 2015</p></a></li>
<li><a href='#nlme_function'><p>Helper functions to create nlme models from mmkin row objects</p></a></li>
<li><a href='#nlme.mmkin'><p>Create an nlme model for an mmkin row object</p></a></li>
<li><a href='#nobs.mkinfit'><p>Number of observations on which an mkinfit object was fitted</p></a></li>
<li><a href='#parms'><p>Extract model parameters</p></a></li>
<li><a href='#parplot'><p>Plot parameter variability of multistart objects</p></a></li>
<li><a href='#plot.mixed.mmkin'><p>Plot predictions from a fitted nonlinear mixed model obtained via an mmkin row object</p></a></li>
<li><a href='#plot.mkinfit'><p>Plot the observed data and the fitted model of an mkinfit object</p></a></li>
<li><a href='#plot.mmkin'><p>Plot model fits (observed and fitted) and the residuals for a row or column</p>
of an mmkin object</a></li>
<li><a href='#plot.nafta'><p>Plot the results of the three models used in the NAFTA scheme.</p></a></li>
<li><a href='#read_spreadsheet'><p>Read datasets and relevant meta information from a spreadsheet file</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.mkinfit'><p>Extract residuals from an mkinfit model</p></a></li>
<li><a href='#saem'><p>Fit nonlinear mixed models with SAEM</p></a></li>
<li><a href='#schaefer07_complex_case'>
<p>Metabolism data set used for checking the software quality of KinGUI</p></a></li>
<li><a href='#set_nd_nq'><p>Set non-detects and unquantified values in residue series without replicates</p></a></li>
<li><a href='#SFO.solution'><p>Single First-Order kinetics</p></a></li>
<li><a href='#SFORB.solution'><p>Single First-Order Reversible Binding kinetics</p></a></li>
<li><a href='#sigma_twocomp'><p>Two-component error model</p></a></li>
<li><a href='#status'><p>Method to get status information for fit array objects</p></a></li>
<li><a href='#summary_listing'><p>Display the output of a summary function according to the output format</p></a></li>
<li><a href='#summary.mkinfit'><p>Summary method for class &quot;mkinfit&quot;</p></a></li>
<li><a href='#summary.mmkin'><p>Summary method for class &quot;mmkin&quot;</p></a></li>
<li><a href='#summary.nlme.mmkin'><p>Summary method for class &quot;nlme.mmkin&quot;</p></a></li>
<li><a href='#summary.saem.mmkin'><p>Summary method for class &quot;saem.mmkin&quot;</p></a></li>
<li><a href='#synthetic_data_for_UBA_2014'>
<p>Synthetic datasets for one parent compound with two metabolites</p></a></li>
<li><a href='#test_data_from_UBA_2014'>
<p>Three experimental datasets from two water sediment systems and one soil</p></a></li>
<li><a href='#transform_odeparms'><p>Functions to transform and backtransform kinetic parameters for fitting</p></a></li>
<li><a href='#update.mkinfit'><p>Update an mkinfit model with different arguments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kinetic Evaluation of Chemical Degradation Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculation routines based on the FOCUS Kinetics Report (2006,
  2014).  Includes a function for conveniently defining differential equation
  models, model solution based on eigenvalues if possible or using numerical
  solvers.  If a C compiler (on windows: 'Rtools') is installed, differential
  equation models are solved using automatically generated C functions.
  Heteroscedasticity can be taken into account using variance by variable or
  two-component error models as described by Ranke and Meinecke (2018)
  &lt;<a href="https://doi.org/10.3390%2Fenvironments6120124">doi:10.3390/environments6120124</a>&gt;.  Hierarchical degradation models can
  be fitted using nonlinear mixed-effects model packages as a back end as
  described by Ranke et al. (2021) &lt;<a href="https://doi.org/10.3390%2Fenvironments8080071">doi:10.3390/environments8080071</a>&gt;.  Please
  note that no warranty is implied for correctness of results or fitness for a
  particular purpose.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1),</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, methods, parallel, deSolve (&ge; 1.35), R6,
inline (&ge; 0.3.19), numDeriv, lmtest, pkgbuild, nlme (&ge;
3.1-151), saemix (&ge; 3.2), rlang, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rbenchmark, tikzDevice, testthat, rmarkdown, covr,
vdiffr, benchmarkme, tibble, stats4, readxl</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jranke/mkin/issues/">https://github.com/jranke/mkin/issues/</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pkgdown.jrwb.de/mkin/">https://pkgdown.jrwb.de/mkin/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-13 14:46:15 UTC; jranke</td>
</tr>
<tr>
<td>Author:</td>
<td>Johannes Ranke <a href="https://orcid.org/0000-0003-4371-6538"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Katrin Lindenberger [ctb] (contributed to mkinresplot()),
  René Lehmann [ctb] (ilr() and invilr()),
  Eurofins Regulatory AG [cph] (copyright for some of the contributions
    of JR 2012-2014)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johannes Ranke &lt;johannes.ranke@jrwb.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-14 12:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.mmkin'>Subsetting method for mmkin objects</h2><span id='topic++5B.mmkin'></span>

<h3>Description</h3>

<p>Subsetting method for mmkin objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmkin'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.mmkin_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+mmkin">mmkin</a> object</code></p>
</td></tr>
<tr><td><code id="+2B5B.mmkin_+3A_i">i</code></td>
<td>
<p>Row index selecting the fits for specific models</p>
</td></tr>
<tr><td><code id="+2B5B.mmkin_+3A_j">j</code></td>
<td>
<p>Column index selecting the fits to specific datasets</p>
</td></tr>
<tr><td><code id="+2B5B.mmkin_+3A_...">...</code></td>
<td>
<p>Not used, only there to satisfy the generic method definition</p>
</td></tr>
<tr><td><code id="+2B5B.mmkin_+3A_drop">drop</code></td>
<td>
<p>If FALSE, the method always returns an mmkin object, otherwise
either a list of mkinfit objects or a single mkinfit object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+mmkin">mmkin</a></code>.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Only use one core, to pass R CMD check --as-cran
  fits &lt;- mmkin(c("SFO", "FOMC"), list(B = FOCUS_2006_B, C = FOCUS_2006_C),
                cores = 1, quiet = TRUE)
  fits["FOMC", ]
  fits[, "B"]
  fits["SFO", "B"]

  head(
    # This extracts an mkinfit object with lots of components
    fits[["FOMC", "B"]]
  )
</code></pre>

<hr>
<h2 id='add_err'>Add normally distributed errors to simulated kinetic degradation data</h2><span id='topic+add_err'></span>

<h3>Description</h3>

<p>Normally distributed errors are added to data predicted for a specific
degradation model using <code><a href="#topic+mkinpredict">mkinpredict</a></code>. The variance of the error
may depend on the predicted value and is specified as a standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_err(
  prediction,
  sdfunc,
  secondary = c("M1", "M2"),
  n = 10,
  LOD = 0.1,
  reps = 2,
  digits = 1,
  seed = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_err_+3A_prediction">prediction</code></td>
<td>
<p>A prediction from a kinetic model as produced by
<code><a href="#topic+mkinpredict">mkinpredict</a></code>.</p>
</td></tr>
<tr><td><code id="add_err_+3A_sdfunc">sdfunc</code></td>
<td>
<p>A function taking the predicted value as its only argument and
returning a standard deviation that should be used for generating the
random error terms for this value.</p>
</td></tr>
<tr><td><code id="add_err_+3A_secondary">secondary</code></td>
<td>
<p>The names of state variables that should have an initial
value of zero</p>
</td></tr>
<tr><td><code id="add_err_+3A_n">n</code></td>
<td>
<p>The number of datasets to be generated.</p>
</td></tr>
<tr><td><code id="add_err_+3A_lod">LOD</code></td>
<td>
<p>The limit of detection (LOD). Values that are below the LOD after
adding the random error will be set to NA.</p>
</td></tr>
<tr><td><code id="add_err_+3A_reps">reps</code></td>
<td>
<p>The number of replicates to be generated within the datasets.</p>
</td></tr>
<tr><td><code id="add_err_+3A_digits">digits</code></td>
<td>
<p>The number of digits to which the values will be rounded.</p>
</td></tr>
<tr><td><code id="add_err_+3A_seed">seed</code></td>
<td>
<p>The seed used for the generation of random numbers. If NA, the
seed is not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of datasets compatible with <code><a href="#topic+mmkin">mmkin</a></code>, i.e. the
components of the list are datasets compatible with <code><a href="#topic+mkinfit">mkinfit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>References</h3>

<p>Ranke J and Lehmann R (2015) To t-test or not to t-test, that is
the question. XV Symposium on Pesticide Chemistry 2-4 September 2015,
Piacenza, Italy
https://jrwb.de/posters/piacenza_2015.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The kinetic model
m_SFO_SFO &lt;- mkinmod(parent = mkinsub("SFO", "M1"),
                     M1 = mkinsub("SFO"), use_of_ff = "max")

# Generate a prediction for a specific set of parameters
sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)

# This is the prediction used for the "Type 2 datasets" on the Piacenza poster
# from 2015
d_SFO_SFO &lt;- mkinpredict(m_SFO_SFO,
                         c(k_parent = 0.1, f_parent_to_M1 = 0.5,
                           k_M1 = log(2)/1000),
                         c(parent = 100, M1 = 0),
                         sampling_times)

# Add an error term with a constant (independent of the value) standard deviation
# of 10, and generate three datasets
d_SFO_SFO_err &lt;- add_err(d_SFO_SFO, function(x) 10, n = 3, seed = 123456789 )

# Name the datasets for nicer plotting
names(d_SFO_SFO_err) &lt;- paste("Dataset", 1:3)

# Name the model in the list of models (with only one member in this case) for
# nicer plotting later on.  Be quiet and use only one core not to offend CRAN
# checks
## Not run: 
f_SFO_SFO &lt;- mmkin(list("SFO-SFO" = m_SFO_SFO),
                   d_SFO_SFO_err, cores = 1,
                   quiet = TRUE)

plot(f_SFO_SFO)

# We would like to inspect the fit for dataset 3 more closely
# Using double brackets makes the returned object an mkinfit object
# instead of a list of mkinfit objects, so plot.mkinfit is used
plot(f_SFO_SFO[[3]], show_residuals = TRUE)

# If we use single brackets, we should give two indices (model and dataset),
# and plot.mmkin is used
plot(f_SFO_SFO[1, 3])

## End(Not run)

</code></pre>

<hr>
<h2 id='AIC.mmkin'>Calculate the AIC for a column of an mmkin object</h2><span id='topic+AIC.mmkin'></span><span id='topic+BIC.mmkin'></span>

<h3>Description</h3>

<p>Provides a convenient way to compare different kinetic models fitted to the
same dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmkin'
AIC(object, ..., k = 2)

## S3 method for class 'mmkin'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.mmkin_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+mmkin">mmkin</a></code>, containing only one
column.</p>
</td></tr>
<tr><td><code id="AIC.mmkin_+3A_...">...</code></td>
<td>
<p>For compatibility with the generic method</p>
</td></tr>
<tr><td><code id="AIC.mmkin_+3A_k">k</code></td>
<td>
<p>As in the generic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As in the generic method (a numeric value for single fits, or a
dataframe if there are several fits in the column).
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run:  # skip, as it takes &gt; 10 s on winbuilder
  f &lt;- mmkin(c("SFO", "FOMC", "DFOP"),
    list("FOCUS A" = FOCUS_2006_A,
         "FOCUS C" = FOCUS_2006_C), cores = 1, quiet = TRUE)
  # We get a warning because the FOMC model does not converge for the
  # FOCUS A dataset, as it is well described by SFO

  AIC(f["SFO", "FOCUS A"]) # We get a single number for a single fit
  AIC(f[["SFO", "FOCUS A"]]) # or when extracting an mkinfit object

  # For FOCUS A, the models fit almost equally well, so the higher the number
  # of parameters, the higher (worse) the AIC
  AIC(f[, "FOCUS A"])
  AIC(f[, "FOCUS A"], k = 0) # If we do not penalize additional parameters, we get nearly the same
  BIC(f[, "FOCUS A"])        # Comparing the BIC gives a very similar picture

  # For FOCUS C, the more complex models fit better
  AIC(f[, "FOCUS C"])
  BIC(f[, "FOCUS C"])
  
## End(Not run)

</code></pre>

<hr>
<h2 id='anova.saem.mmkin'>Anova method for saem.mmkin objects</h2><span id='topic+anova.saem.mmkin'></span>

<h3>Description</h3>

<p>Generate an anova object. The method to calculate the BIC is that from the
saemix package. As in other prominent anova methods, models are sorted by
number of parameters, and the tests (if requested) are always relative to
the model on the previous line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'saem.mmkin'
anova(
  object,
  ...,
  method = c("is", "lin", "gq"),
  test = FALSE,
  model.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.saem.mmkin_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+saem.mmkin">saem.mmkin</a> object</p>
</td></tr>
<tr><td><code id="anova.saem.mmkin_+3A_...">...</code></td>
<td>
<p>further such objects</p>
</td></tr>
<tr><td><code id="anova.saem.mmkin_+3A_method">method</code></td>
<td>
<p>Method for likelihood calculation: &quot;is&quot; (importance sampling),
&quot;lin&quot; (linear approximation), or &quot;gq&quot; (Gaussian quadrature). Passed
to <a href="saemix.html#topic+logLik">saemix::logLik.SaemixObject</a></p>
</td></tr>
<tr><td><code id="anova.saem.mmkin_+3A_test">test</code></td>
<td>
<p>Should a likelihood ratio test be performed? If TRUE,
the alternative models are tested against the first model. Should
only be done for nested models.</p>
</td></tr>
<tr><td><code id="anova.saem.mmkin_+3A_model.names">model.names</code></td>
<td>
<p>Optional character vector of model names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &quot;anova&quot; data frame; the traditional (S3) result of anova()
</p>

<hr>
<h2 id='aw'>Calculate Akaike weights for model averaging</h2><span id='topic+aw'></span><span id='topic+aw.mkinfit'></span><span id='topic+aw.mmkin'></span><span id='topic+aw.mixed.mmkin'></span><span id='topic+aw.multistart'></span>

<h3>Description</h3>

<p>Akaike weights are calculated based on the relative
expected Kullback-Leibler information as specified
by Burnham and Anderson (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aw(object, ...)

## S3 method for class 'mkinfit'
aw(object, ...)

## S3 method for class 'mmkin'
aw(object, ...)

## S3 method for class 'mixed.mmkin'
aw(object, ...)

## S3 method for class 'multistart'
aw(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aw_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+mmkin">mmkin</a> column object, containing two or more
<a href="#topic+mkinfit">mkinfit</a> models that have been fitted to the same data,
or an mkinfit object. In the latter case, further mkinfit
objects fitted to the same data should be specified
as dots arguments.</p>
</td></tr>
<tr><td><code id="aw_+3A_...">...</code></td>
<td>
<p>Not used in the method for <a href="#topic+mmkin">mmkin</a> column objects,
further <a href="#topic+mkinfit">mkinfit</a> objects in the method for mkinfit objects.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Burnham KP and Anderson DR (2004) Multimodel
Inference: Understanding AIC and BIC in Model Selection.
<em>Sociological Methods &amp; Research</em> <strong>33</strong>(2) 261-304
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f_sfo &lt;- mkinfit("SFO", FOCUS_2006_D, quiet = TRUE)
f_dfop &lt;- mkinfit("DFOP", FOCUS_2006_D, quiet = TRUE)
aw_sfo_dfop &lt;- aw(f_sfo, f_dfop)
sum(aw_sfo_dfop)
aw_sfo_dfop # SFO gets more weight as it has less parameters and a similar fit
f &lt;- mmkin(c("SFO", "FOMC", "DFOP"), list("FOCUS D" = FOCUS_2006_D), cores = 1, quiet = TRUE)
aw(f)
sum(aw(f))
aw(f[c("SFO", "DFOP")])

## End(Not run)
</code></pre>

<hr>
<h2 id='CAKE_export'>Export a list of datasets format to a CAKE study file</h2><span id='topic+CAKE_export'></span>

<h3>Description</h3>

<p>In addition to the datasets, the pathways in the degradation model can be
specified as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAKE_export(
  ds,
  map = c(parent = "Parent"),
  links = NA,
  filename = "CAKE_export.csf",
  path = ".",
  overwrite = FALSE,
  study = "Degradinol aerobic soil degradation",
  description = "",
  time_unit = "days",
  res_unit = "% AR",
  comment = "",
  date = Sys.Date(),
  optimiser = "IRLS"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAKE_export_+3A_ds">ds</code></td>
<td>
<p>A named list of datasets in long format as compatible with
<code><a href="#topic+mkinfit">mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_map">map</code></td>
<td>
<p>A character vector with CAKE compartment names (Parent, A1, ...),
named with the names used in the list of datasets.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_links">links</code></td>
<td>
<p>An optional character vector of target compartments, named with
the names of the source compartments. In order to make this easier, the
names are used as in the datasets supplied.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_filename">filename</code></td>
<td>
<p>Where to write the result. Should end in .csf in order to be
compatible with CAKE.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_path">path</code></td>
<td>
<p>An optional path to the output file.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, existing files are overwritten.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_study">study</code></td>
<td>
<p>The name of the study.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_description">description</code></td>
<td>
<p>An optional description.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_time_unit">time_unit</code></td>
<td>
<p>The time unit for the residue data.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_res_unit">res_unit</code></td>
<td>
<p>The unit used for the residues.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_comment">comment</code></td>
<td>
<p>An optional comment.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_date">date</code></td>
<td>
<p>The date of file creation.</p>
</td></tr>
<tr><td><code id="CAKE_export_+3A_optimiser">optimiser</code></td>
<td>
<p>Can be OLS or IRLS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>

<hr>
<h2 id='confint.mkinfit'>Confidence intervals for parameters of mkinfit objects</h2><span id='topic+confint.mkinfit'></span>

<h3>Description</h3>

<p>The default method 'quadratic' is based on the quadratic approximation of
the curvature of the likelihood function at the maximum likelihood parameter
estimates.
The alternative method 'profile' is based on the profile likelihood for each
parameter. The 'profile' method uses two nested optimisations and can take a
very long time, even if parallelized by specifying 'cores' on unixoid
platforms. The speed of the method could likely be improved by using the
method of Venzon and Moolgavkar (1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
confint(
  object,
  parm,
  level = 0.95,
  alpha = 1 - level,
  cutoff,
  method = c("quadratic", "profile"),
  transformed = TRUE,
  backtransform = TRUE,
  cores = parallel::detectCores(),
  rel_tol = 0.01,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.mkinfit_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+mkinfit">mkinfit</a></code> object</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_parm">parm</code></td>
<td>
<p>A vector of names of the parameters which are to be given
confidence intervals. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_level">level</code></td>
<td>
<p>The confidence level required</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_alpha">alpha</code></td>
<td>
<p>The allowed error probability, overrides 'level' if specified.</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_cutoff">cutoff</code></td>
<td>
<p>Possibility to specify an alternative cutoff for the difference
in the log-likelihoods at the confidence boundary. Specifying an explicit
cutoff value overrides arguments 'level' and 'alpha'</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_method">method</code></td>
<td>
<p>The 'quadratic' method approximates the likelihood function at
the optimised parameters using the second term of the Taylor expansion,
using a second derivative (hessian) contained in the object.
The 'profile' method searches the parameter space for the
cutoff of the confidence intervals by means of a likelihood ratio test.</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_transformed">transformed</code></td>
<td>
<p>If the quadratic approximation is used, should it be
applied to the likelihood based on the transformed parameters?</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_backtransform">backtransform</code></td>
<td>
<p>If we approximate the likelihood in terms of the
transformed parameters, should we backtransform the parameters with
their confidence intervals?</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for multicore processing.
On Windows machines, cores &gt; 1 is currently not supported.</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_rel_tol">rel_tol</code></td>
<td>
<p>If the method is 'profile', what should be the accuracy
of the lower and upper bounds, relative to the estimate obtained from
the quadratic method?</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_quiet">quiet</code></td>
<td>
<p>Should we suppress the message &quot;Profiling the likelihood&quot;</p>
</td></tr>
<tr><td><code id="confint.mkinfit_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns giving lower and upper confidence limits for
each parameter.
</p>


<h3>References</h3>

<p>Bates DM and Watts GW (1988) Nonlinear regression analysis &amp; its applications
</p>
<p>Pawitan Y (2013) In all likelihood - Statistical modelling and
inference using likelihood. Clarendon Press, Oxford.
</p>
<p>Venzon DJ and Moolgavkar SH (1988) A Method for Computing
Profile-Likelihood Based Confidence Intervals, Applied Statistics, 37,
87–94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- mkinfit("SFO", FOCUS_2006_C, quiet = TRUE)
confint(f, method = "quadratic")

## Not run: 
confint(f, method = "profile")

# Set the number of cores for the profiling method for further examples
if (identical(Sys.getenv("NOT_CRAN"), "true")) {
  n_cores &lt;- parallel::detectCores() - 1
} else {
  n_cores &lt;- 1
}
if (Sys.getenv("TRAVIS") != "") n_cores = 1
if (Sys.info()["sysname"] == "Windows") n_cores = 1

SFO_SFO &lt;- mkinmod(parent = mkinsub("SFO", "m1"), m1 = mkinsub("SFO"),
  use_of_ff = "min", quiet = TRUE)
SFO_SFO.ff &lt;- mkinmod(parent = mkinsub("SFO", "m1"), m1 = mkinsub("SFO"),
  use_of_ff = "max", quiet = TRUE)
f_d_1 &lt;- mkinfit(SFO_SFO, subset(FOCUS_2006_D, value != 0), quiet = TRUE)
system.time(ci_profile &lt;- confint(f_d_1, method = "profile", cores = 1, quiet = TRUE))
# Using more cores does not save much time here, as parent_0 takes up most of the time
# If we additionally exclude parent_0 (the confidence of which is often of
# minor interest), we get a nice performance improvement if we use at least 4 cores
system.time(ci_profile_no_parent_0 &lt;- confint(f_d_1, method = "profile",
  c("k_parent_sink", "k_parent_m1", "k_m1_sink", "sigma"), cores = n_cores))
ci_profile
ci_quadratic_transformed &lt;- confint(f_d_1, method = "quadratic")
ci_quadratic_transformed
ci_quadratic_untransformed &lt;- confint(f_d_1, method = "quadratic", transformed = FALSE)
ci_quadratic_untransformed
# Against the expectation based on Bates and Watts (1988), the confidence
# intervals based on the internal parameter transformation are less
# congruent with the likelihood based intervals. Note the superiority of the
# interval based on the untransformed fit for k_m1_sink
rel_diffs_transformed &lt;- abs((ci_quadratic_transformed - ci_profile)/ci_profile)
rel_diffs_untransformed &lt;- abs((ci_quadratic_untransformed - ci_profile)/ci_profile)
rel_diffs_transformed &lt; rel_diffs_untransformed
signif(rel_diffs_transformed, 3)
signif(rel_diffs_untransformed, 3)


# Investigate a case with formation fractions
f_d_2 &lt;- mkinfit(SFO_SFO.ff, subset(FOCUS_2006_D, value != 0), quiet = TRUE)
ci_profile_ff &lt;- confint(f_d_2, method = "profile", cores = n_cores)
ci_profile_ff
ci_quadratic_transformed_ff &lt;- confint(f_d_2, method = "quadratic")
ci_quadratic_transformed_ff
ci_quadratic_untransformed_ff &lt;- confint(f_d_2, method = "quadratic", transformed = FALSE)
ci_quadratic_untransformed_ff
rel_diffs_transformed_ff &lt;- abs((ci_quadratic_transformed_ff - ci_profile_ff)/ci_profile_ff)
rel_diffs_untransformed_ff &lt;- abs((ci_quadratic_untransformed_ff - ci_profile_ff)/ci_profile_ff)
# While the confidence interval for the parent rate constant is closer to
# the profile based interval when using the internal parameter
# transformation, the interval for the metabolite rate constant is 'better
# without internal parameter transformation.
rel_diffs_transformed_ff &lt; rel_diffs_untransformed_ff
rel_diffs_transformed_ff
rel_diffs_untransformed_ff

# The profiling for the following fit does not finish in a reasonable time,
# therefore we use the quadratic approximation
m_synth_DFOP_par &lt;- mkinmod(parent = mkinsub("DFOP", c("M1", "M2")),
  M1 = mkinsub("SFO"),
  M2 = mkinsub("SFO"),
  use_of_ff = "max", quiet = TRUE)
DFOP_par_c &lt;- synthetic_data_for_UBA_2014[[12]]$data
f_tc_2 &lt;- mkinfit(m_synth_DFOP_par, DFOP_par_c, error_model = "tc",
  error_model_algorithm = "direct", quiet = TRUE)
confint(f_tc_2, method = "quadratic")
confint(f_tc_2, "parent_0", method = "quadratic")

## End(Not run)
</code></pre>

<hr>
<h2 id='create_deg_func'>Create degradation functions for known analytical solutions</h2><span id='topic+create_deg_func'></span>

<h3>Description</h3>

<p>Create degradation functions for known analytical solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_deg_func(spec, use_of_ff = c("min", "max"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_deg_func_+3A_spec">spec</code></td>
<td>
<p>List of model specifications as contained in mkinmod objects</p>
</td></tr>
<tr><td><code id="create_deg_func_+3A_use_of_ff">use_of_ff</code></td>
<td>
<p>Minimum or maximum use of formation fractions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Degradation function to be attached to mkinmod objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SFO_SFO &lt;- mkinmod(
  parent = mkinsub("SFO", "m1"),
  m1 = mkinsub("SFO"))
FOCUS_D &lt;- subset(FOCUS_2006_D, value != 0) # to avoid warnings
fit_1 &lt;- mkinfit(SFO_SFO, FOCUS_D, solution_type = "analytical", quiet = TRUE)
## Not run: 
fit_2 &lt;- mkinfit(SFO_SFO, FOCUS_D, solution_type = "deSolve", quiet = TRUE)
if (require(rbenchmark))
  benchmark(
    analytical = mkinfit(SFO_SFO, FOCUS_D, solution_type = "analytical", quiet = TRUE),
    deSolve = mkinfit(SFO_SFO, FOCUS_D, solution_type = "deSolve", quiet = TRUE),
    replications = 2)
  DFOP_SFO &lt;- mkinmod(
    parent = mkinsub("DFOP", "m1"),
    m1 = mkinsub("SFO"))
  benchmark(
    analytical = mkinfit(DFOP_SFO, FOCUS_D, solution_type = "analytical", quiet = TRUE),
    deSolve = mkinfit(DFOP_SFO, FOCUS_D, solution_type = "deSolve", quiet = TRUE),
    replications = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='D24_2014'>Aerobic soil degradation data on 2,4-D from the EU assessment in 2014</h2><span id='topic+D24_2014'></span>

<h3>Description</h3>

<p>The five datasets were extracted from the active substance evaluation dossier
published by EFSA. Kinetic evaluations shown for these datasets are intended
to illustrate and advance kinetic modelling. The fact that these data and
some results are shown here does not imply a license to use them in the
context of pesticide  registrations, as the use of the data may be
constrained by data protection regulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D24_2014
</code></pre>


<h3>Format</h3>

<p>An <a href="#topic+mkindsg">mkindsg</a> object grouping five datasets
</p>


<h3>Details</h3>

<p>Data for the first dataset are from p. 685. Data for the other four
datasets were used in the preprocessed versions given in the kinetics
section (p. 761ff.), with the exception of residues smaller than 1 for DCP
in the soil from Site I2, where the values given on p. 694 were used.
</p>
<p>The R code used to create this data object is installed with this package
in the 'dataset_generation' directory. In the code, page numbers are given for
specific pieces of information in the comments.
</p>


<h3>Source</h3>

<p>Hellenic Ministry of Rural Development and Agriculture (2014)
Final addendum to the Renewal Assessment Report - public version - 2,4-D
Volume 3 Annex B.8 Fate and behaviour in the environment
https://open.efsa.europa.eu/study-inventory/EFSA-Q-2013-00811
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(D24_2014)
## Not run: 
print(D24_2014$ds[[1]], data = TRUE)
m_D24 = mkinmod(D24 = mkinsub("SFO", to = "DCP"),
  DCP = mkinsub("SFO", to = "DCA"),
  DCA = mkinsub("SFO"))
print(m_D24)
m_D24_2 = mkinmod(D24 = mkinsub("DFOP", to = "DCP"),
  DCP = mkinsub("SFO", to = "DCA"),
  DCA = mkinsub("SFO"))
print(m_D24_2)

## End(Not run)
</code></pre>

<hr>
<h2 id='DFOP.solution'>Double First-Order in Parallel kinetics</h2><span id='topic+DFOP.solution'></span>

<h3>Description</h3>

<p>Function describing decline from a defined starting value using the sum of
two exponential decline functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFOP.solution(t, parent_0, k1, k2, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFOP.solution_+3A_t">t</code></td>
<td>
<p>Time.</p>
</td></tr>
<tr><td><code id="DFOP.solution_+3A_parent_0">parent_0</code></td>
<td>
<p>Starting value for the response variable at time zero.</p>
</td></tr>
<tr><td><code id="DFOP.solution_+3A_k1">k1</code></td>
<td>
<p>First kinetic constant.</p>
</td></tr>
<tr><td><code id="DFOP.solution_+3A_k2">k2</code></td>
<td>
<p>Second kinetic constant.</p>
</td></tr>
<tr><td><code id="DFOP.solution_+3A_g">g</code></td>
<td>
<p>Fraction of the starting value declining according to the first
kinetic constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the response variable at time <code>t</code>.
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>See Also</h3>

<p>Other parent solutions: 
<code><a href="#topic+FOMC.solution">FOMC.solution</a>()</code>,
<code><a href="#topic+HS.solution">HS.solution</a>()</code>,
<code><a href="#topic+IORE.solution">IORE.solution</a>()</code>,
<code><a href="#topic+SFO.solution">SFO.solution</a>()</code>,
<code><a href="#topic+SFORB.solution">SFORB.solution</a>()</code>,
<code><a href="#topic+logistic.solution">logistic.solution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  plot(function(x) DFOP.solution(x, 100, 5, 0.5, 0.3), 0, 4, ylim = c(0,100))

</code></pre>

<hr>
<h2 id='dimethenamid_2018'>Aerobic soil degradation data on dimethenamid and dimethenamid-P from the EU assessment in 2018</h2><span id='topic+dimethenamid_2018'></span>

<h3>Description</h3>

<p>The datasets were extracted from the active substance evaluation dossier
published by EFSA. Kinetic evaluations shown for these datasets are intended
to illustrate and advance kinetic modelling. The fact that these data and
some results are shown here does not imply a license to use them in the
context of pesticide  registrations, as the use of the data may be
constrained by data protection regulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimethenamid_2018
</code></pre>


<h3>Format</h3>

<p>An <a href="#topic+mkindsg">mkindsg</a> object grouping seven datasets with some meta information
</p>


<h3>Details</h3>

<p>The R code used to create this data object is installed with this package
in the 'dataset_generation' directory. In the code, page numbers are given for
specific pieces of information in the comments.
</p>


<h3>Source</h3>

<p>Rapporteur Member State Germany, Co-Rapporteur Member State Bulgaria (2018)
Renewal Assessment Report Dimethenamid-P Volume 3 - B.8 Environmental fate and behaviour
Rev. 2 - November 2017
https://open.efsa.europa.eu/study-inventory/EFSA-Q-2014-00716
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(dimethenamid_2018)
dmta_ds &lt;- lapply(1:7, function(i) {
  ds_i &lt;- dimethenamid_2018$ds[[i]]$data
  ds_i[ds_i$name == "DMTAP", "name"] &lt;-  "DMTA"
  ds_i$time &lt;- ds_i$time * dimethenamid_2018$f_time_norm[i]
  ds_i
})
names(dmta_ds) &lt;- sapply(dimethenamid_2018$ds, function(ds) ds$title)
dmta_ds[["Elliot"]] &lt;- rbind(dmta_ds[["Elliot 1"]], dmta_ds[["Elliot 2"]])
dmta_ds[["Elliot 1"]] &lt;- NULL
dmta_ds[["Elliot 2"]] &lt;- NULL
## Not run: 
# We don't use DFOP for the parent compound, as this gives numerical
# instabilities in the fits
sfo_sfo3p &lt;- mkinmod(
 DMTA = mkinsub("SFO", c("M23", "M27", "M31")),
 M23 = mkinsub("SFO"),
 M27 = mkinsub("SFO"),
 M31 = mkinsub("SFO", "M27", sink = FALSE),
 quiet = TRUE
)
dmta_sfo_sfo3p_tc &lt;- mmkin(list("SFO-SFO3+" = sfo_sfo3p),
  dmta_ds, error_model = "tc", quiet = TRUE)
print(dmta_sfo_sfo3p_tc)
# The default (test_log_parms = FALSE) gives an undue
# influence of ill-defined rate constants that have
# extremely small values:
plot(mixed(dmta_sfo_sfo3p_tc), test_log_parms = FALSE)
# If we disregards ill-defined rate constants, the results
# look more plausible, but the truth is likely to be in
# between these variants
plot(mixed(dmta_sfo_sfo3p_tc), test_log_parms = TRUE)
# We can also specify a default value for the failing
# log parameters, to mimic FOCUS guidance
plot(mixed(dmta_sfo_sfo3p_tc), test_log_parms = TRUE,
  default_log_parms = log(2)/1000)
# As these attempts are not satisfying, we use nonlinear mixed-effects models
# f_dmta_nlme_tc &lt;- nlme(dmta_sfo_sfo3p_tc)
# nlme reaches maxIter = 50 without convergence
f_dmta_saem_tc &lt;- saem(dmta_sfo_sfo3p_tc)
# I am commenting out the convergence plot as rendering them
# with pkgdown fails (at least without further tweaks to the
# graphics device used)
#saemix::plot(f_dmta_saem_tc$so, plot.type = "convergence")
summary(f_dmta_saem_tc)
# As the confidence interval for the random effects of DMTA_0
# includes zero, we could try an alternative model without
# such random effects
# f_dmta_saem_tc_2 &lt;- saem(dmta_sfo_sfo3p_tc,
#   covariance.model = diag(c(0, rep(1, 7))))
# saemix::plot(f_dmta_saem_tc_2$so, plot.type = "convergence")
# This does not perform better judged by AIC and BIC
# saemix::compare.saemix(f_dmta_saem_tc$so, f_dmta_saem_tc_2$so)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds_mixed'>Synthetic data for hierarchical kinetic degradation models</h2><span id='topic+ds_mixed'></span><span id='topic+ds_sfo'></span><span id='topic+ds_fomc'></span><span id='topic+ds_dfop'></span><span id='topic+ds_hs'></span><span id='topic+ds_dfop_sfo'></span>

<h3>Description</h3>

<p>The R code used to create this data object is installed with this package in
the 'dataset_generation' directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sfo_mmkin &lt;- mmkin("SFO", ds_sfo, quiet = TRUE, error_model = "tc", cores = 15)
  sfo_saem &lt;- saem(sfo_mmkin, no_random_effect = "parent_0")
  plot(sfo_saem)

## End(Not run)

# This is the code used to generate the datasets
cat(readLines(system.file("dataset_generation/ds_mixed.R", package = "mkin")), sep = "\n")
</code></pre>

<hr>
<h2 id='endpoints'>Function to calculate endpoints for further use from kinetic models fitted
with mkinfit</h2><span id='topic+endpoints'></span>

<h3>Description</h3>

<p>This function calculates DT50 and DT90 values as well as formation fractions
from kinetic models fitted with mkinfit. If the SFORB model was specified
for one of the parents or metabolites, the Eigenvalues are returned. These
are equivalent to the rate constants of the DFOP model, but with the
advantage that the SFORB model can also be used for metabolites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endpoints(fit, covariates = NULL, covariate_quantile = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endpoints_+3A_fit">fit</code></td>
<td>
<p>An object of class <a href="#topic+mkinfit">mkinfit</a>, <a href="#topic+nlme.mmkin">nlme.mmkin</a> or <a href="#topic+saem.mmkin">saem.mmkin</a>, or
another object that has list components mkinmod containing an <a href="#topic+mkinmod">mkinmod</a>
degradation model, and two numeric vectors, bparms.optim and bparms.fixed,
that contain parameter values for that model.</p>
</td></tr>
<tr><td><code id="endpoints_+3A_covariates">covariates</code></td>
<td>
<p>Numeric vector with covariate values for all variables in
any covariate models in the object. If given, it overrides 'covariate_quantile'.</p>
</td></tr>
<tr><td><code id="endpoints_+3A_covariate_quantile">covariate_quantile</code></td>
<td>
<p>This argument only has an effect if the fitted
object has covariate models. If so, the default is to show endpoints
for the median of the covariate values (50th percentile).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional DT50 values are calculated from the FOMC DT90 and k1 and k2 from
HS and DFOP, as well as from Eigenvalues b1 and b2 of any SFORB models
</p>


<h3>Value</h3>

<p>A list with a matrix of dissipation times named distimes, and, if
applicable, a vector of formation fractions named ff and, if the SFORB model
was in use, a vector of eigenvalues of these SFORB models, equivalent to
DFOP rate constants
</p>


<h3>Note</h3>

<p>The function is used internally by <a href="#topic+summary.mkinfit">summary.mkinfit</a>,
<a href="#topic+summary.nlme.mmkin">summary.nlme.mmkin</a> and <a href="#topic+summary.saem.mmkin">summary.saem.mmkin</a>.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  fit &lt;- mkinfit("FOMC", FOCUS_2006_C, quiet = TRUE)
  endpoints(fit)
  ## Not run: 
    fit_2 &lt;- mkinfit("DFOP", FOCUS_2006_C, quiet = TRUE)
    endpoints(fit_2)
    fit_3 &lt;- mkinfit("SFORB", FOCUS_2006_C, quiet = TRUE)
    endpoints(fit_3)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='experimental_data_for_UBA_2019'>
Experimental datasets used for development and testing of error models
</h2><span id='topic+experimental_data_for_UBA_2019'></span>

<h3>Description</h3>

<p>The 12 datasets were extracted from active substance evaluation dossiers published
by EFSA. Kinetic evaluations shown for these datasets are intended to illustrate
and advance error model specifications. The fact that these data and some
results are shown here do not imply a license to use them in the context of
pesticide registrations, as the use of the data may be constrained by
data protection regulations.
</p>
<p>Preprocessing of data was performed based on the recommendations of the FOCUS
kinetics workgroup (FOCUS, 2014) as described below.
</p>
<p>Datasets 1 and 2 are from the Renewal Assessment Report (RAR) for imazamox
(France, 2015, p. 15). For setting values reported as zero, an LOQ of 0.1
was assumed. Metabolite residues reported for day zero were added to the
parent compound residues.
</p>
<p>Datasets 3 and 4 are from the Renewal Assessment Report (RAR) for isofetamid
(Belgium, 2014, p. 8) and show the data for two different radiolabels. For
dataset 4, the value given for the metabolite in the day zero sampling
in replicate B was added to the parent compound, following the respective
FOCUS recommendation.
</p>
<p>Dataset 5 is from the Renewal Assessment Report (RAR) for ethofumesate
(Austria, 2015, p. 16).
</p>
<p>Datasets 6 to 10 are from the Renewal Assessment Report (RAR) for glyphosate
(Germany, 2013, pages 8, 28, 50, 51). For the initial sampling,
the residues given for the metabolite were added to the parent
value, following the recommendation of the FOCUS kinetics workgroup.
</p>
<p>Dataset 11 is from the Renewal Assessment Report (RAR) for 2,4-D
(Hellas, 2013, p. 644). Values reported as zero were set to NA, with
the exception of the day three sampling of metabolite A2, which was set
to one half of the LOD reported to be 1% AR.
</p>
<p>Dataset 12 is from the Renewal Assessment Report (RAR) for thifensulfuron-methyl
(United Kingdom, 2014, p. 81).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>experimental_data_for_UBA_2019</code></pre>


<h3>Format</h3>

<p>A list containing twelve datasets as an R6 class defined by <code><a href="#topic+mkinds">mkinds</a></code>,
each containing, among others, the following components
</p>

<dl>
<dt><code>title</code></dt><dd><p>The name of the dataset, e.g. <code>Soil 1</code></p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame with the data in the form expected by <code><a href="#topic+mkinfit">mkinfit</a></code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Austria (2015). Ethofumesate Renewal Assessment Report Volume 3 Annex B.8 (AS)
</p>
<p>Belgium (2014). Isofetamid (IKF-5411) Draft Assessment Report Volume 3 Annex B.8 (AS)
</p>
<p>France (2015). Imazamox Draft Renewal Assessment Report Volume 3 Annex B.8 (AS)
</p>
<p>FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence and
Degradation Kinetics from Environmental Fate Studies on Pesticides in EU
Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>
<p>Germany (2013). Renewal Assessment Report Glyphosate Volume 3 Annex B.8: Environmental Fate
and Behaviour
</p>
<p>Hellas (2013). Renewal Assessment Report 2,4-D Volume 3 Annex B.8: Fate and behaviour in the
environment
</p>
<p>Ranke (2019) Documentation of results obtained for the error model expertise
written for the German Umweltbundesamt.
</p>
<p>United Kingdom (2014). Thifensulfuron-methyl - Annex B.8 (Volume 3) to the Report and Proposed
Decision of the United Kingdom made to the European Commission under Regulation (EC) No.
1141/2010 for renewal of an active substance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Model definitions
sfo_sfo &lt;- mkinmod(
  parent = mkinsub("SFO", to = "A1"),
  A1 = mkinsub("SFO"),
  use_of_ff = "max"
)

dfop_sfo &lt;- mkinmod(
  parent = mkinsub("DFOP", to = "A1"),
  A1 = mkinsub("SFO"),
  use_of_ff = "max"
)

sfo_sfo_sfo &lt;- mkinmod(
  parent = mkinsub("SFO", to = "A1"),
  A1 = mkinsub("SFO", to = "A2"),
  A2 = mkinsub("SFO"),
  use_of_ff = "max"
)

dfop_sfo_sfo &lt;- mkinmod(
  parent = mkinsub("DFOP", to = "A1"),
  A1 = mkinsub("SFO", to = "A2"),
  A2 = mkinsub("SFO"),
  use_of_ff = "max"
)
d_1_2 &lt;- lapply(experimental_data_for_UBA_2019[1:2], function(x) x$data)
names(d_1_2) &lt;- paste("Soil", 1:2)


f_1_2_tc &lt;- mmkin(list("DFOP-SFO-SFO" = dfop_sfo_sfo), d_1_2, error_model = "tc")

plot(f_1_2_tc, resplot = "errmod")


## End(Not run)</code></pre>

<hr>
<h2 id='f_time_norm_focus'>Normalisation factors for aerobic soil degradation according to FOCUS guidance</h2><span id='topic+f_time_norm_focus'></span><span id='topic+f_time_norm_focus.numeric'></span><span id='topic+f_time_norm_focus.mkindsg'></span>

<h3>Description</h3>

<p>Time step normalisation factors for aerobic soil degradation as described
in Appendix 8 to the FOCUS kinetics guidance (FOCUS 2014, p. 369).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_time_norm_focus(object, ...)

## S3 method for class 'numeric'
f_time_norm_focus(
  object,
  moisture = NA,
  field_moisture = NA,
  temperature = object,
  Q10 = 2.58,
  walker = 0.7,
  f_na = NA,
  ...
)

## S3 method for class 'mkindsg'
f_time_norm_focus(
  object,
  study_moisture_ref_source = c("auto", "meta", "focus"),
  Q10 = 2.58,
  walker = 0.7,
  f_na = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_time_norm_focus_+3A_object">object</code></td>
<td>
<p>An object containing information used for the calculations</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_moisture">moisture</code></td>
<td>
<p>Numeric vector of moisture contents in \% w/w</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_field_moisture">field_moisture</code></td>
<td>
<p>Numeric vector of moisture contents at field capacity
(pF2) in \% w/w</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_temperature">temperature</code></td>
<td>
<p>Numeric vector of temperatures in °C</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_q10">Q10</code></td>
<td>
<p>The Q10 value used for temperature normalisation</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_walker">walker</code></td>
<td>
<p>The Walker exponent used for moisture normalisation</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_f_na">f_na</code></td>
<td>
<p>The factor to use for NA values. If set to NA, only factors
for complete cases will be returned.</p>
</td></tr>
<tr><td><code id="f_time_norm_focus_+3A_study_moisture_ref_source">study_moisture_ref_source</code></td>
<td>
<p>Source for the reference value
used to calculate the study moisture. If 'auto', preference is given
to a reference moisture given in the meta information, otherwise
the focus soil moisture for the soil class is used</p>
</td></tr>
</table>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+focus_soil_moisture">focus_soil_moisture</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_time_norm_focus(25, 20, 25) # 1.37, compare FOCUS 2014 p. 184

D24_2014$meta
# No moisture normalisation in the first dataset, so we use f_na = 1 to get
# temperature only normalisation as in the EU evaluation
f_time_norm_focus(D24_2014, study_moisture_ref_source = "focus", f_na = 1)
</code></pre>

<hr>
<h2 id='FOCUS_2006_datasets'>
Datasets A to F from the FOCUS Kinetics report from 2006
</h2><span id='topic+FOCUS_2006_A'></span><span id='topic+FOCUS_2006_B'></span><span id='topic+FOCUS_2006_C'></span><span id='topic+FOCUS_2006_D'></span><span id='topic+FOCUS_2006_E'></span><span id='topic+FOCUS_2006_F'></span>

<h3>Description</h3>

<p>Data taken from FOCUS (2006), p. 258.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  FOCUS_2006_A
  FOCUS_2006_B
  FOCUS_2006_C
  FOCUS_2006_D
  FOCUS_2006_E
  FOCUS_2006_F
</code></pre>


<h3>Format</h3>

<p>6 datasets with observations on the following variables.
</p>

<dl>
<dt><code>name</code></dt><dd><p>a factor containing the name of the observed variable</p>
</dd>
<dt><code>time</code></dt><dd><p>a numeric vector containing time points</p>
</dd>
<dt><code>value</code></dt><dd><p>a numeric vector containing concentrations in percent of applied radioactivity</p>
</dd>
</dl>



<h3>Source</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence and
Degradation Kinetics from Environmental Fate Studies on Pesticides in EU
Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FOCUS_2006_C
</code></pre>

<hr>
<h2 id='FOCUS_2006_DFOP_ref_A_to_B'>
Results of fitting the DFOP model to Datasets A to B of FOCUS (2006)
</h2><span id='topic+FOCUS_2006_DFOP_ref_A_to_B'></span>

<h3>Description</h3>

<p>A table with the fitted parameters and the resulting DT50 and DT90 values
generated with different software packages. Taken directly from FOCUS (2006).
The results from fitting the data with the Topfit software was removed, as
the initial concentration of the parent compound was fixed to a value of 100
in this fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOCUS_2006_DFOP_ref_A_to_B</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables.
</p>

<dl>
<dt><code>package</code></dt><dd><p>a factor giving the name of the software package</p>
</dd>
<dt><code>M0</code></dt><dd><p>The fitted initial concentration of the parent compound</p>
</dd>
<dt><code>f</code></dt><dd><p>The fitted f parameter</p>
</dd>
<dt><code>k1</code></dt><dd><p>The fitted k1 parameter</p>
</dd>
<dt><code>k2</code></dt><dd><p>The fitted k2 parameter</p>
</dd>
<dt><code>DT50</code></dt><dd><p>The resulting half-life of the parent compound</p>
</dd>
<dt><code>DT90</code></dt><dd><p>The resulting DT90 of the parent compound</p>
</dd>
<dt><code>dataset</code></dt><dd><p>The FOCUS dataset that was used</p>
</dd>
</dl>



<h3>Source</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence and
Degradation Kinetics from Environmental Fate Studies on Pesticides in EU
Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FOCUS_2006_DFOP_ref_A_to_B)
</code></pre>

<hr>
<h2 id='FOCUS_2006_FOMC_ref_A_to_F'>
Results of fitting the FOMC model to Datasets A to F of FOCUS (2006)
</h2><span id='topic+FOCUS_2006_FOMC_ref_A_to_F'></span>

<h3>Description</h3>

<p>A table with the fitted parameters and the resulting DT50 and DT90 values
generated with different software packages. Taken directly from FOCUS (2006).
The results from fitting the data with the Topfit software was removed, as
the initial concentration of the parent compound was fixed to a value of 100
in this fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOCUS_2006_FOMC_ref_A_to_F</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables.
</p>

<dl>
<dt><code>package</code></dt><dd><p>a factor giving the name of the software package</p>
</dd>
<dt><code>M0</code></dt><dd><p>The fitted initial concentration of the parent compound</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The fitted alpha parameter</p>
</dd>
<dt><code>beta</code></dt><dd><p>The fitted beta parameter</p>
</dd>
<dt><code>DT50</code></dt><dd><p>The resulting half-life of the parent compound</p>
</dd>
<dt><code>DT90</code></dt><dd><p>The resulting DT90 of the parent compound</p>
</dd>
<dt><code>dataset</code></dt><dd><p>The FOCUS dataset that was used</p>
</dd>
</dl>



<h3>Source</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence and
Degradation Kinetics from Environmental Fate Studies on Pesticides in EU
Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FOCUS_2006_FOMC_ref_A_to_F)
</code></pre>

<hr>
<h2 id='FOCUS_2006_HS_ref_A_to_F'>
Results of fitting the HS model to Datasets A to F of FOCUS (2006)
</h2><span id='topic+FOCUS_2006_HS_ref_A_to_F'></span>

<h3>Description</h3>

<p>A table with the fitted parameters and the resulting DT50 and DT90 values
generated with different software packages. Taken directly from FOCUS (2006).
The results from fitting the data with the Topfit software was removed, as
the initial concentration of the parent compound was fixed to a value of 100
in this fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOCUS_2006_HS_ref_A_to_F</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables.
</p>

<dl>
<dt><code>package</code></dt><dd><p>a factor giving the name of the software package</p>
</dd>
<dt><code>M0</code></dt><dd><p>The fitted initial concentration of the parent compound</p>
</dd>
<dt><code>tb</code></dt><dd><p>The fitted tb parameter</p>
</dd>
<dt><code>k1</code></dt><dd><p>The fitted k1 parameter</p>
</dd>
<dt><code>k2</code></dt><dd><p>The fitted k2 parameter</p>
</dd>
<dt><code>DT50</code></dt><dd><p>The resulting half-life of the parent compound</p>
</dd>
<dt><code>DT90</code></dt><dd><p>The resulting DT90 of the parent compound</p>
</dd>
<dt><code>dataset</code></dt><dd><p>The FOCUS dataset that was used</p>
</dd>
</dl>



<h3>Source</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence and
Degradation Kinetics from Environmental Fate Studies on Pesticides in EU
Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FOCUS_2006_HS_ref_A_to_F)
</code></pre>

<hr>
<h2 id='FOCUS_2006_SFO_ref_A_to_F'>
Results of fitting the SFO model to Datasets A to F of FOCUS (2006)
</h2><span id='topic+FOCUS_2006_SFO_ref_A_to_F'></span>

<h3>Description</h3>

<p>A table with the fitted parameters and the resulting DT50 and DT90 values
generated with different software packages. Taken directly from FOCUS (2006).
The results from fitting the data with the Topfit software was removed, as
the initial concentration of the parent compound was fixed to a value of 100
in this fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOCUS_2006_SFO_ref_A_to_F</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables.
</p>

<dl>
<dt><code>package</code></dt><dd><p>a factor giving the name of the software package</p>
</dd>
<dt><code>M0</code></dt><dd><p>The fitted initial concentration of the parent compound</p>
</dd>
<dt><code>k</code></dt><dd><p>The fitted first-order degradation rate constant</p>
</dd>
<dt><code>DT50</code></dt><dd><p>The resulting half-life of the parent compound</p>
</dd>
<dt><code>DT90</code></dt><dd><p>The resulting DT90 of the parent compound</p>
</dd>
<dt><code>dataset</code></dt><dd><p>The FOCUS dataset that was used</p>
</dd>
</dl>



<h3>Source</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence and
Degradation Kinetics from Environmental Fate Studies on Pesticides in EU
Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FOCUS_2006_SFO_ref_A_to_F)
</code></pre>

<hr>
<h2 id='focus_soil_moisture'>FOCUS default values for soil moisture contents at field capacity, MWHC and 1/3 bar</h2><span id='topic+focus_soil_moisture'></span>

<h3>Description</h3>

<p>The value were transcribed from p. 36. The table assumes field capacity
corresponds to pF2, MWHC to pF 1 and 1/3 bar to pF 2.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focus_soil_moisture
</code></pre>


<h3>Format</h3>

<p>A matrix with upper case USDA soil classes as row names, and water tension
('pF1', 'pF2', 'pF 2.5') as column names
</p>


<h3>Source</h3>

<p>Anonymous (2014) Generic Guidance for Tier 1 FOCUS Ground Water Assessment
Version 2.2, May 2014 <a href="https://esdac.jrc.ec.europa.eu/projects/ground-water">https://esdac.jrc.ec.europa.eu/projects/ground-water</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>focus_soil_moisture
</code></pre>

<hr>
<h2 id='FOMC.solution'>First-Order Multi-Compartment kinetics</h2><span id='topic+FOMC.solution'></span>

<h3>Description</h3>

<p>Function describing exponential decline from a defined starting value, with
a decreasing rate constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOMC.solution(t, parent_0, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FOMC.solution_+3A_t">t</code></td>
<td>
<p>Time.</p>
</td></tr>
<tr><td><code id="FOMC.solution_+3A_parent_0">parent_0</code></td>
<td>
<p>Starting value for the response variable at time zero.</p>
</td></tr>
<tr><td><code id="FOMC.solution_+3A_alpha">alpha</code></td>
<td>
<p>Shape parameter determined by coefficient of variation of rate
constant values.</p>
</td></tr>
<tr><td><code id="FOMC.solution_+3A_beta">beta</code></td>
<td>
<p>Location parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The form given here differs slightly from the original reference by
Gustafson and Holden (1990). The parameter <code>beta</code> corresponds to 1/beta
in the original equation.
</p>


<h3>Value</h3>

<p>The value of the response variable at time <code>t</code>.
</p>


<h3>Note</h3>

<p>The solution of the FOMC kinetic model reduces to the
<code><a href="#topic+SFO.solution">SFO.solution</a></code> for large values of <code>alpha</code> and <code>beta</code>
with <code class="reqn">k = \frac{\beta}{\alpha}</code>.
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>
<p>FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>
<p>Gustafson DI and Holden LR (1990) Nonlinear pesticide dissipation in soil:
A new model based on spatial variability. <em>Environmental Science and
Technology</em> <b>24</b>, 1032-1038
</p>


<h3>See Also</h3>

<p>Other parent solutions: 
<code><a href="#topic+DFOP.solution">DFOP.solution</a>()</code>,
<code><a href="#topic+HS.solution">HS.solution</a>()</code>,
<code><a href="#topic+IORE.solution">IORE.solution</a>()</code>,
<code><a href="#topic+SFO.solution">SFO.solution</a>()</code>,
<code><a href="#topic+SFORB.solution">SFORB.solution</a>()</code>,
<code><a href="#topic+logistic.solution">logistic.solution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  plot(function(x) FOMC.solution(x, 100, 10, 2), 0, 2, ylim = c(0, 100))

</code></pre>

<hr>
<h2 id='get_deg_func'>Retrieve a degradation function from the mmkin namespace</h2><span id='topic+get_deg_func'></span>

<h3>Description</h3>

<p>Retrieve a degradation function from the mmkin namespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_deg_func()
</code></pre>


<h3>Value</h3>

<p>A function that was likely previously assigned from within
nlme.mmkin
</p>

<hr>
<h2 id='hierarchical_kinetics'>Hierarchical kinetics template</h2><span id='topic+hierarchical_kinetics'></span>

<h3>Description</h3>

<p>R markdown format for setting up hierarchical kinetics based on a template
provided with the mkin package. This format is based on <a href="rmarkdown.html#topic+pdf_document">rmarkdown::pdf_document</a>.
Chunk options are adapted. Echoing R code from code chunks and caching are
turned on per default. character for prepending output from code chunks is
set to the empty string, code tidying is off, figure alignment defaults to
centering, and positioning of figures is set to &quot;H&quot;, which means that
figures will not move around in the document, but stay where the user
includes them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchical_kinetics(..., keep_tex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarchical_kinetics_+3A_...">...</code></td>
<td>
<p>Arguments to <code>rmarkdown::pdf_document</code></p>
</td></tr>
<tr><td><code id="hierarchical_kinetics_+3A_keep_tex">keep_tex</code></td>
<td>
<p>Keep the intermediate tex file used in the conversion to PDF</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The latter feature (positioning the figures with &quot;H&quot;) depends on the LaTeX
package 'float'. In addition, the LaTeX package 'listing' is used in the
template for showing model fit summaries in the Appendix. This means that
the LaTeX packages 'float' and 'listing' need to be installed in the TeX
distribution used.
</p>
<p>On Windows, the easiest way to achieve this (if no TeX distribution
is present before) is to install the 'tinytex' R package, to run
'tinytex::install_tinytex()' to get the basic tiny Tex distribution,
and then to run 'tinytex::tlmgr_install(c(&quot;float&quot;, &quot;listing&quot;))'.
</p>


<h3>Value</h3>

<p>R Markdown output format to pass to
<code><a href="rmarkdown.html#topic+render">render</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(rmarkdown)
# The following is now commented out after the relase of v1.2.3 for the generation
# of online docs, as the command creates a directory and opens an editor
#draft("example_analysis.rmd", template = "hierarchical_kinetics", package = "mkin")

## End(Not run)

</code></pre>

<hr>
<h2 id='HS.solution'>Hockey-Stick kinetics</h2><span id='topic+HS.solution'></span>

<h3>Description</h3>

<p>Function describing two exponential decline functions with a break point
between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HS.solution(t, parent_0, k1, k2, tb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HS.solution_+3A_t">t</code></td>
<td>
<p>Time.</p>
</td></tr>
<tr><td><code id="HS.solution_+3A_parent_0">parent_0</code></td>
<td>
<p>Starting value for the response variable at time zero.</p>
</td></tr>
<tr><td><code id="HS.solution_+3A_k1">k1</code></td>
<td>
<p>First kinetic constant.</p>
</td></tr>
<tr><td><code id="HS.solution_+3A_k2">k2</code></td>
<td>
<p>Second kinetic constant.</p>
</td></tr>
<tr><td><code id="HS.solution_+3A_tb">tb</code></td>
<td>
<p>Break point. Before this time, exponential decline according to
<code>k1</code> is calculated, after this time, exponential decline proceeds
according to <code>k2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the response variable at time <code>t</code>.
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>See Also</h3>

<p>Other parent solutions: 
<code><a href="#topic+DFOP.solution">DFOP.solution</a>()</code>,
<code><a href="#topic+FOMC.solution">FOMC.solution</a>()</code>,
<code><a href="#topic+IORE.solution">IORE.solution</a>()</code>,
<code><a href="#topic+SFO.solution">SFO.solution</a>()</code>,
<code><a href="#topic+SFORB.solution">SFORB.solution</a>()</code>,
<code><a href="#topic+logistic.solution">logistic.solution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  plot(function(x) HS.solution(x, 100, 2, 0.3, 0.5), 0, 2, ylim=c(0,100))

</code></pre>

<hr>
<h2 id='illparms'>Method to get the names of ill-defined parameters</h2><span id='topic+illparms'></span><span id='topic+illparms.mkinfit'></span><span id='topic+print.illparms.mkinfit'></span><span id='topic+illparms.mmkin'></span><span id='topic+print.illparms.mmkin'></span><span id='topic+illparms.saem.mmkin'></span><span id='topic+print.illparms.saem.mmkin'></span><span id='topic+illparms.mhmkin'></span><span id='topic+print.illparms.mhmkin'></span>

<h3>Description</h3>

<p>The method for generalised nonlinear regression fits as obtained
with <a href="#topic+mkinfit">mkinfit</a> and <a href="#topic+mmkin">mmkin</a> checks if the degradation parameters
pass the Wald test (in degradation kinetics often simply called t-test) for
significant difference from zero. For this test, the parameterisation
without parameter transformations is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illparms(object, ...)

## S3 method for class 'mkinfit'
illparms(object, conf.level = 0.95, ...)

## S3 method for class 'illparms.mkinfit'
print(x, ...)

## S3 method for class 'mmkin'
illparms(object, conf.level = 0.95, ...)

## S3 method for class 'illparms.mmkin'
print(x, ...)

## S3 method for class 'saem.mmkin'
illparms(
  object,
  conf.level = 0.95,
  random = TRUE,
  errmod = TRUE,
  slopes = TRUE,
  ...
)

## S3 method for class 'illparms.saem.mmkin'
print(x, ...)

## S3 method for class 'mhmkin'
illparms(object, conf.level = 0.95, random = TRUE, errmod = TRUE, ...)

## S3 method for class 'illparms.mhmkin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illparms_+3A_object">object</code></td>
<td>
<p>The object to investigate</p>
</td></tr>
<tr><td><code id="illparms_+3A_...">...</code></td>
<td>
<p>For potential future extensions</p>
</td></tr>
<tr><td><code id="illparms_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for checking p values</p>
</td></tr>
<tr><td><code id="illparms_+3A_x">x</code></td>
<td>
<p>The object to be printed</p>
</td></tr>
<tr><td><code id="illparms_+3A_random">random</code></td>
<td>
<p>For hierarchical fits, should random effects be tested?</p>
</td></tr>
<tr><td><code id="illparms_+3A_errmod">errmod</code></td>
<td>
<p>For hierarchical fits, should error model parameters be
tested?</p>
</td></tr>
<tr><td><code id="illparms_+3A_slopes">slopes</code></td>
<td>
<p>For hierarchical <a href="#topic+saem">saem</a> fits using saemix as backend,
should slope parameters in the covariate model(starting with 'beta_') be
tested?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for hierarchical model fits, also known as nonlinear
mixed-effects model fits as obtained with <a href="#topic+saem">saem</a> and <a href="#topic+mhmkin">mhmkin</a>
checks if any of the confidence intervals for the random
effects expressed as standard deviations include zero, and if
the confidence intervals for the error model parameters include
zero.
</p>


<h3>Value</h3>

<p>For <a href="#topic+mkinfit">mkinfit</a> or <a href="#topic+saem">saem</a> objects, a character vector of parameter
names. For <a href="#topic+mmkin">mmkin</a> or <a href="#topic+mhmkin">mhmkin</a> objects, a matrix like object of class
'illparms.mmkin' or 'illparms.mhmkin'.
</p>


<h3>Note</h3>

<p>All return objects have printing methods. For the single fits, printing
does not output anything in the case no ill-defined parameters are found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- mkinfit("FOMC", FOCUS_2006_A, quiet = TRUE)
illparms(fit)
## Not run: 
fits &lt;- mmkin(
  c("SFO", "FOMC"),
  list("FOCUS A" = FOCUS_2006_A,
       "FOCUS C" = FOCUS_2006_C),
  quiet = TRUE)
illparms(fits)

## End(Not run)
</code></pre>

<hr>
<h2 id='ilr'>Function to perform isometric log-ratio transformation</h2><span id='topic+ilr'></span><span id='topic+invilr'></span>

<h3>Description</h3>

<p>This implementation is a special case of the class of isometric log-ratio
transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilr(x)

invilr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ilr_+3A_x">x</code></td>
<td>
<p>A numeric vector. Naturally, the forward transformation is only
sensible for vectors with all elements being greater than zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the forward or backward transformation. The returned
components always sum to 1 for the case of the inverse log-ratio
transformation.
</p>


<h3>Author(s)</h3>

<p>René Lehmann and Johannes Ranke
</p>


<h3>References</h3>

<p>Peter Filzmoser, Karel Hron (2008) Outlier Detection for
Compositional Data Using Robust Methods. Math Geosci 40 233-248
</p>


<h3>See Also</h3>

<p>Another implementation can be found in R package
<code>robCompositions</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Order matters
ilr(c(0.1, 1, 10))
ilr(c(10, 1, 0.1))
# Equal entries give ilr transformations with zeros as elements
ilr(c(3, 3, 3))
# Almost equal entries give small numbers
ilr(c(0.3, 0.4, 0.3))
# Only the ratio between the numbers counts, not their sum
invilr(ilr(c(0.7, 0.29, 0.01)))
invilr(ilr(2.1 * c(0.7, 0.29, 0.01)))
# Inverse transformation of larger numbers gives unequal elements
invilr(-10)
invilr(c(-10, 0))
# The sum of the elements of the inverse ilr is 1
sum(invilr(c(-10, 0)))
# This is why we do not need all elements of the inverse transformation to go back:
a &lt;- c(0.1, 0.3, 0.5)
b &lt;- invilr(a)
length(b) # Four elements
ilr(c(b[1:3], 1 - sum(b[1:3]))) # Gives c(0.1, 0.3, 0.5)

</code></pre>

<hr>
<h2 id='intervals.saem.mmkin'>Confidence intervals for parameters in saem.mmkin objects</h2><span id='topic+intervals.saem.mmkin'></span>

<h3>Description</h3>

<p>Confidence intervals for parameters in saem.mmkin objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'saem.mmkin'
intervals(object, level = 0.95, backtransform = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.saem.mmkin_+3A_object">object</code></td>
<td>
<p>The fitted saem.mmkin object</p>
</td></tr>
<tr><td><code id="intervals.saem.mmkin_+3A_level">level</code></td>
<td>
<p>The confidence level. Must be the default of 0.95 as this is what
is available in the saemix object</p>
</td></tr>
<tr><td><code id="intervals.saem.mmkin_+3A_backtransform">backtransform</code></td>
<td>
<p>In case the model was fitted with mkin transformations,
should we backtransform the parameters where a one to one correlation
between transformed and backtransformed parameters exists?</p>
</td></tr>
<tr><td><code id="intervals.saem.mmkin_+3A_...">...</code></td>
<td>
<p>For compatibility with the generic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with 'intervals.saem.mmkin' and 'intervals.lme' in the
class attribute
</p>

<hr>
<h2 id='IORE.solution'>Indeterminate order rate equation kinetics</h2><span id='topic+IORE.solution'></span>

<h3>Description</h3>

<p>Function describing exponential decline from a defined starting value, with
a concentration dependent rate constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IORE.solution(t, parent_0, k__iore, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IORE.solution_+3A_t">t</code></td>
<td>
<p>Time.</p>
</td></tr>
<tr><td><code id="IORE.solution_+3A_parent_0">parent_0</code></td>
<td>
<p>Starting value for the response variable at time zero.</p>
</td></tr>
<tr><td><code id="IORE.solution_+3A_k__iore">k__iore</code></td>
<td>
<p>Rate constant. Note that this depends on the concentration
units used.</p>
</td></tr>
<tr><td><code id="IORE.solution_+3A_n">N</code></td>
<td>
<p>Exponent describing the nonlinearity of the rate equation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the response variable at time <code>t</code>.
</p>


<h3>Note</h3>

<p>The solution of the IORE kinetic model reduces to the
<code><a href="#topic+SFO.solution">SFO.solution</a></code> if N = 1.  The parameters of the IORE model can
be transformed to equivalent parameters of the FOMC mode - see the NAFTA
guidance for details.
</p>


<h3>References</h3>

<p>NAFTA Technical Working Group on Pesticides (not dated) Guidance
for Evaluating and Calculating Degradation Kinetics in Environmental Media
</p>


<h3>See Also</h3>

<p>Other parent solutions: 
<code><a href="#topic+DFOP.solution">DFOP.solution</a>()</code>,
<code><a href="#topic+FOMC.solution">FOMC.solution</a>()</code>,
<code><a href="#topic+HS.solution">HS.solution</a>()</code>,
<code><a href="#topic+SFO.solution">SFO.solution</a>()</code>,
<code><a href="#topic+SFORB.solution">SFORB.solution</a>()</code>,
<code><a href="#topic+logistic.solution">logistic.solution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  plot(function(x) IORE.solution(x, 100, 0.2, 1.3), 0, 2, ylim = c(0, 100))
  ## Not run: 
    fit.fomc &lt;- mkinfit("FOMC", FOCUS_2006_C, quiet = TRUE)
    fit.iore &lt;- mkinfit("IORE", FOCUS_2006_C, quiet = TRUE)
    fit.iore.deS &lt;- mkinfit("IORE", FOCUS_2006_C, solution_type = "deSolve", quiet = TRUE)

    print(data.frame(fit.fomc$par, fit.iore$par, fit.iore.deS$par,
                     row.names = paste("model par", 1:4)))
    print(rbind(fomc = endpoints(fit.fomc)$distimes, iore = endpoints(fit.iore)$distimes,
                iore.deS = endpoints(fit.iore)$distimes))
  
## End(Not run)

</code></pre>

<hr>
<h2 id='llhist'>Plot the distribution of log likelihoods from multistart objects</h2><span id='topic+llhist'></span>

<h3>Description</h3>

<p>Produces a histogram of log-likelihoods. In addition, the likelihood of the
original fit is shown as a red vertical line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llhist(object, breaks = "Sturges", lpos = "topleft", main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llhist_+3A_object">object</code></td>
<td>
<p>The <a href="#topic+multistart">multistart</a> object</p>
</td></tr>
<tr><td><code id="llhist_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+hist">hist</a></p>
</td></tr>
<tr><td><code id="llhist_+3A_lpos">lpos</code></td>
<td>
<p>Positioning of the legend.</p>
</td></tr>
<tr><td><code id="llhist_+3A_main">main</code></td>
<td>
<p>Title of the plot</p>
</td></tr>
<tr><td><code id="llhist_+3A_...">...</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+hist">hist</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+multistart">multistart</a>
</p>

<hr>
<h2 id='loftest'>Lack-of-fit test for models fitted to data with replicates</h2><span id='topic+loftest'></span><span id='topic+loftest.mkinfit'></span>

<h3>Description</h3>

<p>This is a generic function with a method currently only defined for mkinfit
objects. It fits an anova model to the data contained in the object and
compares the likelihoods using the likelihood ratio test
<code><a href="lmtest.html#topic+lrtest.default">lrtest.default</a></code> from the lmtest package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loftest(object, ...)

## S3 method for class 'mkinfit'
loftest(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loftest_+3A_object">object</code></td>
<td>
<p>A model object with a defined loftest method</p>
</td></tr>
<tr><td><code id="loftest_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The anova model is interpreted as the simplest form of an mkinfit model,
assuming only a constant variance about the means, but not enforcing any
structure of the means, so we have one model parameter for every mean
of replicate samples.
</p>


<h3>See Also</h3>

<p>lrtest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
test_data &lt;- subset(synthetic_data_for_UBA_2014[[12]]$data, name == "parent")
sfo_fit &lt;- mkinfit("SFO", test_data, quiet = TRUE)
plot_res(sfo_fit) # We see a clear pattern in the residuals
loftest(sfo_fit)  # We have a clear lack of fit
#
# We try a different model (the one that was used to generate the data)
dfop_fit &lt;- mkinfit("DFOP", test_data, quiet = TRUE)
plot_res(dfop_fit) # We don't see systematic deviations, but heteroscedastic residuals
# therefore we should consider adapting the error model, although we have
loftest(dfop_fit) # no lack of fit
#
# This is the anova model used internally for the comparison
test_data_anova &lt;- test_data
test_data_anova$time &lt;- as.factor(test_data_anova$time)
anova_fit &lt;- lm(value ~ time, data = test_data_anova)
summary(anova_fit)
logLik(anova_fit) # We get the same likelihood and degrees of freedom
#
test_data_2 &lt;- synthetic_data_for_UBA_2014[[12]]$data
m_synth_SFO_lin &lt;- mkinmod(parent = list(type = "SFO", to = "M1"),
  M1 = list(type = "SFO", to = "M2"),
  M2 = list(type = "SFO"), use_of_ff = "max")
sfo_lin_fit &lt;- mkinfit(m_synth_SFO_lin, test_data_2, quiet = TRUE)
plot_res(sfo_lin_fit) # not a good model, we try parallel formation
loftest(sfo_lin_fit)
#
m_synth_SFO_par &lt;- mkinmod(parent = list(type = "SFO", to = c("M1", "M2")),
  M1 = list(type = "SFO"),
  M2 = list(type = "SFO"), use_of_ff = "max")
sfo_par_fit &lt;- mkinfit(m_synth_SFO_par, test_data_2, quiet = TRUE)
plot_res(sfo_par_fit) # much better for metabolites
loftest(sfo_par_fit)
#
m_synth_DFOP_par &lt;- mkinmod(parent = list(type = "DFOP", to = c("M1", "M2")),
  M1 = list(type = "SFO"),
  M2 = list(type = "SFO"), use_of_ff = "max")
dfop_par_fit &lt;- mkinfit(m_synth_DFOP_par, test_data_2, quiet = TRUE)
plot_res(dfop_par_fit) # No visual lack of fit
loftest(dfop_par_fit)  # no lack of fit found by the test
#
# The anova model used for comparison in the case of transformation products
test_data_anova_2 &lt;- dfop_par_fit$data
test_data_anova_2$variable &lt;- as.factor(test_data_anova_2$variable)
test_data_anova_2$time &lt;- as.factor(test_data_anova_2$time)
anova_fit_2 &lt;- lm(observed ~ time:variable - 1, data = test_data_anova_2)
summary(anova_fit_2)

## End(Not run)
</code></pre>

<hr>
<h2 id='logistic.solution'>Logistic kinetics</h2><span id='topic+logistic.solution'></span>

<h3>Description</h3>

<p>Function describing exponential decline from a defined starting value, with
an increasing rate constant, supposedly caused by microbial growth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.solution(t, parent_0, kmax, k0, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.solution_+3A_t">t</code></td>
<td>
<p>Time.</p>
</td></tr>
<tr><td><code id="logistic.solution_+3A_parent_0">parent_0</code></td>
<td>
<p>Starting value for the response variable at time zero.</p>
</td></tr>
<tr><td><code id="logistic.solution_+3A_kmax">kmax</code></td>
<td>
<p>Maximum rate constant.</p>
</td></tr>
<tr><td><code id="logistic.solution_+3A_k0">k0</code></td>
<td>
<p>Minimum rate constant effective at time zero.</p>
</td></tr>
<tr><td><code id="logistic.solution_+3A_r">r</code></td>
<td>
<p>Growth rate of the increase in the rate constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the response variable at time <code>t</code>.
</p>


<h3>Note</h3>

<p>The solution of the logistic model reduces to the
<code><a href="#topic+SFO.solution">SFO.solution</a></code> if <code>k0</code> is equal to <code>kmax</code>.
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>See Also</h3>

<p>Other parent solutions: 
<code><a href="#topic+DFOP.solution">DFOP.solution</a>()</code>,
<code><a href="#topic+FOMC.solution">FOMC.solution</a>()</code>,
<code><a href="#topic+HS.solution">HS.solution</a>()</code>,
<code><a href="#topic+IORE.solution">IORE.solution</a>()</code>,
<code><a href="#topic+SFO.solution">SFO.solution</a>()</code>,
<code><a href="#topic+SFORB.solution">SFORB.solution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Reproduce the plot on page 57 of FOCUS (2014)
  plot(function(x) logistic.solution(x, 100, 0.08, 0.0001, 0.2),
       from = 0, to = 100, ylim = c(0, 100),
       xlab = "Time", ylab = "Residue")
  plot(function(x) logistic.solution(x, 100, 0.08, 0.0001, 0.4),
       from = 0, to = 100, add = TRUE, lty = 2, col = 2)
  plot(function(x) logistic.solution(x, 100, 0.08, 0.0001, 0.8),
       from = 0, to = 100, add = TRUE, lty = 3, col = 3)
  plot(function(x) logistic.solution(x, 100, 0.08, 0.001, 0.2),
       from = 0, to = 100, add = TRUE, lty = 4, col = 4)
  plot(function(x) logistic.solution(x, 100, 0.08, 0.08, 0.2),
       from = 0, to = 100, add = TRUE, lty = 5, col = 5)
  legend("topright", inset = 0.05,
         legend = paste0("k0 = ", c(0.0001, 0.0001, 0.0001, 0.001, 0.08),
                         ", r = ", c(0.2, 0.4, 0.8, 0.2, 0.2)),
         lty = 1:5, col = 1:5)

  # Fit with synthetic data
  logistic &lt;- mkinmod(parent = mkinsub("logistic"))

  sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)
  parms_logistic &lt;- c(kmax = 0.08, k0 = 0.0001, r = 0.2)
  d_logistic &lt;- mkinpredict(logistic,
    parms_logistic, c(parent = 100),
    sampling_times)
  d_2_1 &lt;- add_err(d_logistic,
    sdfunc = function(x) sigma_twocomp(x, 0.5, 0.07),
    n = 1, reps = 2, digits = 5, LOD = 0.1, seed = 123456)[[1]]

  m &lt;- mkinfit("logistic", d_2_1, quiet = TRUE)
  plot_sep(m)
  summary(m)$bpar
  endpoints(m)$distimes

</code></pre>

<hr>
<h2 id='logLik.mkinfit'>Calculated the log-likelihood of a fitted mkinfit object</h2><span id='topic+logLik.mkinfit'></span>

<h3>Description</h3>

<p>This function returns the product of the likelihood densities of each
observed value, as calculated as part of the fitting procedure using
<code><a href="stats.html#topic+dnorm">dnorm</a></code>, i.e. assuming normal distribution, and with the means
predicted by the degradation model, and the standard deviations predicted by
the error model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.mkinfit_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+mkinfit">mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.mkinfit_+3A_...">...</code></td>
<td>
<p>For compatibility with the generic method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total number of estimated parameters returned with the value of the
likelihood is calculated as the sum of fitted degradation model parameters
and the fitted error model parameters.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+logLik">logLik</a></code> with the number of estimated
parameters (degradation model parameters plus variance model parameters)
as attribute.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>See Also</h3>

<p>Compare the AIC of columns of <code><a href="#topic+mmkin">mmkin</a></code> objects using
<code><a href="#topic+AIC.mmkin">AIC.mmkin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  sfo_sfo &lt;- mkinmod(
    parent = mkinsub("SFO", to = "m1"),
    m1 = mkinsub("SFO")
  )
  d_t &lt;- subset(FOCUS_2006_D, value != 0)
  f_nw &lt;- mkinfit(sfo_sfo, d_t, quiet = TRUE) # no weighting (weights are unity)
  f_obs &lt;- update(f_nw, error_model = "obs")
  f_tc &lt;- update(f_nw, error_model = "tc")
  AIC(f_nw, f_obs, f_tc)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='logLik.saem.mmkin'>logLik method for saem.mmkin objects</h2><span id='topic+logLik.saem.mmkin'></span>

<h3>Description</h3>

<p>logLik method for saem.mmkin objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'saem.mmkin'
logLik(object, ..., method = c("is", "lin", "gq"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.saem.mmkin_+3A_object">object</code></td>
<td>
<p>The fitted <a href="#topic+saem.mmkin">saem.mmkin</a> object</p>
</td></tr>
<tr><td><code id="logLik.saem.mmkin_+3A_...">...</code></td>
<td>
<p>Passed to <a href="saemix.html#topic+logLik">saemix::logLik.SaemixObject</a></p>
</td></tr>
<tr><td><code id="logLik.saem.mmkin_+3A_method">method</code></td>
<td>
<p>Passed to <a href="saemix.html#topic+logLik">saemix::logLik.SaemixObject</a></p>
</td></tr>
</table>

<hr>
<h2 id='lrtest.mkinfit'>Likelihood ratio test for mkinfit models</h2><span id='topic+lrtest.mkinfit'></span><span id='topic+lrtest.mmkin'></span>

<h3>Description</h3>

<p>Compare two mkinfit models based on their likelihood. If two fitted
mkinfit objects are given as arguments, it is checked if they have been
fitted to the same data. It is the responsibility of the user to make sure
that the models are nested, i.e. one of them has less degrees of freedom
and can be expressed by fixing the parameters of the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
lrtest(object, object_2 = NULL, ...)

## S3 method for class 'mmkin'
lrtest(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrtest.mkinfit_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+mkinfit">mkinfit</a></code> object, or an <code><a href="#topic+mmkin">mmkin</a></code> column
object containing two fits to the same data.</p>
</td></tr>
<tr><td><code id="lrtest.mkinfit_+3A_object_2">object_2</code></td>
<td>
<p>Optionally, another mkinfit object fitted to the same data.</p>
</td></tr>
<tr><td><code id="lrtest.mkinfit_+3A_...">...</code></td>
<td>
<p>Argument to <code><a href="#topic+mkinfit">mkinfit</a></code>, passed to
<code><a href="#topic+update.mkinfit">update.mkinfit</a></code> for creating the alternative fitted object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternatively, an argument to mkinfit can be given which is then passed
to <code><a href="#topic+update.mkinfit">update.mkinfit</a></code> to obtain the alternative model.
</p>
<p>The comparison is then made by the <code><a href="lmtest.html#topic+lrtest.default">lrtest.default</a></code>
method from the lmtest package. The model with the higher number of fitted
parameters (alternative hypothesis) is listed first, then the model with the
lower number of fitted parameters (null hypothesis).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
test_data &lt;- subset(synthetic_data_for_UBA_2014[[12]]$data, name == "parent")
sfo_fit &lt;- mkinfit("SFO", test_data, quiet = TRUE)
dfop_fit &lt;- mkinfit("DFOP", test_data, quiet = TRUE)
lrtest(dfop_fit, sfo_fit)
lrtest(sfo_fit, dfop_fit)

# The following two examples are commented out as they fail during
# generation of the static help pages by pkgdown
#lrtest(dfop_fit, error_model = "tc")
#lrtest(dfop_fit, fixed_parms = c(k2 = 0))

# However, this equivalent syntax also works for static help pages
lrtest(dfop_fit, update(dfop_fit, error_model = "tc"))
lrtest(dfop_fit, update(dfop_fit, fixed_parms = c(k2 = 0)))

## End(Not run)
</code></pre>

<hr>
<h2 id='max_twa_parent'>Function to calculate maximum time weighted average concentrations from
kinetic models fitted with mkinfit</h2><span id='topic+max_twa_parent'></span><span id='topic+max_twa_sfo'></span><span id='topic+max_twa_fomc'></span><span id='topic+max_twa_dfop'></span><span id='topic+max_twa_hs'></span>

<h3>Description</h3>

<p>This function calculates maximum moving window time weighted average
concentrations (TWAs) for kinetic models fitted with <code><a href="#topic+mkinfit">mkinfit</a></code>.
Currently, only calculations for the parent are implemented for the SFO,
FOMC, DFOP and HS models, using the analytical formulas given in the PEC
soil section of the FOCUS guidance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_twa_parent(fit, windows)

max_twa_sfo(M0 = 1, k, t)

max_twa_fomc(M0 = 1, alpha, beta, t)

max_twa_dfop(M0 = 1, k1, k2, g, t)

max_twa_hs(M0 = 1, k1, k2, tb, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_twa_parent_+3A_fit">fit</code></td>
<td>
<p>An object of class <code><a href="#topic+mkinfit">mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_windows">windows</code></td>
<td>
<p>The width of the time windows for which the TWAs should be
calculated.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_m0">M0</code></td>
<td>
<p>The initial concentration for which the maximum time weighted
average over the decline curve should be calculated. The default is to use
a value of 1, which means that a relative maximum time weighted average
factor (f_twa) is calculated.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_k">k</code></td>
<td>
<p>The rate constant in the case of SFO kinetics.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_t">t</code></td>
<td>
<p>The width of the time window.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_alpha">alpha</code></td>
<td>
<p>Parameter of the FOMC model.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_beta">beta</code></td>
<td>
<p>Parameter of the FOMC model.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_k1">k1</code></td>
<td>
<p>The first rate constant of the DFOP or the HS kinetics.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_k2">k2</code></td>
<td>
<p>The second rate constant of the DFOP or the HS kinetics.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_g">g</code></td>
<td>
<p>Parameter of the DFOP model.</p>
</td></tr>
<tr><td><code id="max_twa_parent_+3A_tb">tb</code></td>
<td>
<p>Parameter of the HS model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>max_twa_parent</code>, a numeric vector, named using the
<code>windows</code> argument.  For the other functions, a numeric vector of
length one (also known as 'a number').
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  fit &lt;- mkinfit("FOMC", FOCUS_2006_C, quiet = TRUE)
  max_twa_parent(fit, c(7, 21))

</code></pre>

<hr>
<h2 id='mccall81_245T'>
Datasets on aerobic soil metabolism of 2,4,5-T in six soils
</h2><span id='topic+mccall81_245T'></span>

<h3>Description</h3>

<p>Time course of 2,4,5-trichlorophenoxyacetic acid, and the corresponding
2,4,5-trichlorophenol and 2,4,5-trichloroanisole as recovered in diethylether
extracts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mccall81_245T</code></pre>


<h3>Format</h3>

<p>A dataframe containing the following variables.
</p>

<dl>
<dt><code>name</code></dt><dd><p>the name of the compound observed. Note that T245 is used as
an acronym for 2,4,5-T. T245 is a legitimate object name
in R, which is necessary for specifying models using
<code><a href="#topic+mkinmod">mkinmod</a></code>.</p>
</dd>
<dt><code>time</code></dt><dd><p>a numeric vector containing sampling times in days after
treatment</p>
</dd>
<dt><code>value</code></dt><dd><p>a numeric vector containing concentrations in percent of applied radioactivity</p>
</dd>
<dt><code>soil</code></dt><dd><p>a factor containing the name of the soil</p>
</dd>
</dl>



<h3>Source</h3>

<p>McCall P, Vrona SA, Kelley SS (1981) Fate of uniformly carbon-14 ring labelled 2,4,5-Trichlorophenoxyacetic acid and 2,4-dichlorophenoxyacetic acid. J Agric Chem 29, 100-107
<a href="https://doi.org/10.1021/jf00103a026">doi:10.1021/jf00103a026</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  SFO_SFO_SFO &lt;- mkinmod(T245 = list(type = "SFO", to = "phenol"),
    phenol = list(type = "SFO", to = "anisole"),
    anisole = list(type = "SFO"))
  ## Not run: 
    fit.1 &lt;- mkinfit(SFO_SFO_SFO, subset(mccall81_245T, soil == "Commerce"), quiet = TRUE)
    summary(fit.1)$bpar
    endpoints(fit.1)
    # formation fraction from phenol to anisol is practically 1. As we cannot
    # fix formation fractions when using the ilr transformation, we can turn of
    # the sink in the model generation
    SFO_SFO_SFO_2 &lt;- mkinmod(T245 = list(type = "SFO", to = "phenol"),
      phenol = list(type = "SFO", to = "anisole", sink = FALSE),
      anisole = list(type = "SFO"))
    fit.2 &lt;- mkinfit(SFO_SFO_SFO_2, subset(mccall81_245T, soil == "Commerce"),
      quiet = TRUE)
    summary(fit.2)$bpar
    endpoints(fit.1)
    plot_sep(fit.2)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='mean_degparms'>Calculate mean degradation parameters for an mmkin row object</h2><span id='topic+mean_degparms'></span>

<h3>Description</h3>

<p>Calculate mean degradation parameters for an mmkin row object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_degparms(
  object,
  random = FALSE,
  test_log_parms = FALSE,
  conf.level = 0.6,
  default_log_parms = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_degparms_+3A_object">object</code></td>
<td>
<p>An mmkin row object containing several fits of the same model to different datasets</p>
</td></tr>
<tr><td><code id="mean_degparms_+3A_random">random</code></td>
<td>
<p>Should a list with fixed and random effects be returned?</p>
</td></tr>
<tr><td><code id="mean_degparms_+3A_test_log_parms">test_log_parms</code></td>
<td>
<p>If TRUE, log parameters are only considered in
the mean calculations if their untransformed counterparts (most likely
rate constants) pass the t-test for significant difference from zero.</p>
</td></tr>
<tr><td><code id="mean_degparms_+3A_conf.level">conf.level</code></td>
<td>
<p>Possibility to adjust the required confidence level
for parameter that are tested if requested by 'test_log_parms'.</p>
</td></tr>
<tr><td><code id="mean_degparms_+3A_default_log_parms">default_log_parms</code></td>
<td>
<p>If set to a numeric value, this is used
as a default value for the tested log parameters that failed the
t-test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If random is FALSE (default), a named vector containing mean values
of the fitted degradation model parameters. If random is TRUE, a list with
fixed and random effects, in the format required by the start argument of
nlme for the case of a single grouping variable ds.
</p>

<hr>
<h2 id='mhmkin'>Fit nonlinear mixed-effects models built from one or more kinetic
degradation models and one or more error models</h2><span id='topic+mhmkin'></span><span id='topic+mhmkin.mmkin'></span><span id='topic+mhmkin.list'></span><span id='topic++5B.mhmkin'></span><span id='topic+print.mhmkin'></span>

<h3>Description</h3>

<p>The name of the methods expresses that (<strong>m</strong>ultiple) <strong>h</strong>ierarchichal
(also known as multilevel) <strong>m</strong>ulticompartment <strong>kin</strong>etic models are
fitted. Our kinetic models are nonlinear, so we can use various nonlinear
mixed-effects model fitting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhmkin(objects, ...)

## S3 method for class 'mmkin'
mhmkin(objects, ...)

## S3 method for class 'list'
mhmkin(
  objects,
  backend = "saemix",
  algorithm = "saem",
  no_random_effect = NULL,
  ...,
  cores = if (Sys.info()["sysname"] == "Windows") 1 else parallel::detectCores(),
  cluster = NULL
)

## S3 method for class 'mhmkin'
x[i, j, ..., drop = FALSE]

## S3 method for class 'mhmkin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mhmkin_+3A_objects">objects</code></td>
<td>
<p>A list of <a href="#topic+mmkin">mmkin</a> objects containing fits of the same
degradation models to the same data, but using different error models.
Alternatively, a single <a href="#topic+mmkin">mmkin</a> object containing fits of several
degradation models to the same data</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed to the nonlinear mixed-effects
model fitting function.</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_backend">backend</code></td>
<td>
<p>The backend to be used for fitting. Currently, only saemix is
supported</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to be used for fitting (currently not used)</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_no_random_effect">no_random_effect</code></td>
<td>
<p>Default is NULL and will be passed to <a href="#topic+saem">saem</a>. If a
character vector is supplied, it will be passed to all calls to <a href="#topic+saem">saem</a>,
which will exclude random effects for all matching parameters. Alternatively,
a list of character vectors or an object of class <a href="#topic+illparms.mhmkin">illparms.mhmkin</a> can be
specified. They have to have the same dimensions that the return object of
the current call will have, i.e. the number of rows must match the number
of degradation models in the mmkin object(s), and the number of columns must
match the number of error models used in the mmkin object(s).</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for multicore processing. This
is only used when the <code>cluster</code> argument is <code>NULL</code>. On Windows
machines, cores &gt; 1 is not supported, you need to use the <code>cluster</code>
argument to use multiple logical processors. Per default, all cores detected
by <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code> are used, except on Windows where the default
is 1.</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_cluster">cluster</code></td>
<td>
<p>A cluster as returned by <a href="parallel.html#topic+makeCluster">makeCluster</a> to be used for
parallel execution.</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+mhmkin">mhmkin</a> object.</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_i">i</code></td>
<td>
<p>Row index selecting the fits for specific models</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_j">j</code></td>
<td>
<p>Column index selecting the fits to specific datasets</p>
</td></tr>
<tr><td><code id="mhmkin_+3A_drop">drop</code></td>
<td>
<p>If FALSE, the method always returns an mhmkin object, otherwise
either a list of fit objects or a single fit object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-dimensional <a href="base.html#topic+array">array</a> of fit objects and/or try-errors that can
be indexed using the degradation model names for the first index (row index)
and the error model names for the second index (column index), with class
attribute 'mhmkin'.
</p>
<p>An object inheriting from <code><a href="#topic+mhmkin">mhmkin</a></code>.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>See Also</h3>

<p><code><a href="#topic++5B.mhmkin">[.mhmkin</a></code> for subsetting <a href="#topic+mhmkin">mhmkin</a> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# We start with separate evaluations of all the first six datasets with two
# degradation models and two error models
f_sep_const &lt;- mmkin(c("SFO", "FOMC"), ds_fomc[1:6], cores = 2, quiet = TRUE)
f_sep_tc &lt;- update(f_sep_const, error_model = "tc")
# The mhmkin function sets up hierarchical degradation models aka
# nonlinear mixed-effects models for all four combinations, specifying
# uncorrelated random effects for all degradation parameters
f_saem_1 &lt;- mhmkin(list(f_sep_const, f_sep_tc), cores = 2)
status(f_saem_1)
# The 'illparms' function shows that in all hierarchical fits, at least
# one random effect is ill-defined (the confidence interval for the
# random effect expressed as standard deviation includes zero)
illparms(f_saem_1)
# Therefore we repeat the fits, excluding the ill-defined random effects
f_saem_2 &lt;- update(f_saem_1, no_random_effect = illparms(f_saem_1))
status(f_saem_2)
illparms(f_saem_2)
# Model comparisons show that FOMC with two-component error is preferable,
# and confirms our reduction of the default parameter model
anova(f_saem_1)
anova(f_saem_2)
# The convergence plot for the selected model looks fine
saemix::plot(f_saem_2[["FOMC", "tc"]]$so, plot.type = "convergence")
# The plot of predictions versus data shows that we have a pretty data-rich
# situation with homogeneous distribution of residuals, because we used the
# same degradation model, error model and parameter distribution model that
# was used in the data generation.
plot(f_saem_2[["FOMC", "tc"]])
# We can specify the same parameter model reductions manually
no_ranef &lt;- list("parent_0", "log_beta", "parent_0", c("parent_0", "log_beta"))
dim(no_ranef) &lt;- c(2, 2)
f_saem_2m &lt;- update(f_saem_1, no_random_effect = no_ranef)
anova(f_saem_2m)

## End(Not run)
</code></pre>

<hr>
<h2 id='mixed'>Create a mixed effects model from an mmkin row object</h2><span id='topic+mixed'></span><span id='topic+mixed.mmkin'></span><span id='topic+print.mixed.mmkin'></span>

<h3>Description</h3>

<p>Create a mixed effects model from an mmkin row object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed(object, ...)

## S3 method for class 'mmkin'
mixed(object, method = c("none"), ...)

## S3 method for class 'mixed.mmkin'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixed_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+mmkin">mmkin</a> row object</p>
</td></tr>
<tr><td><code id="mixed_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="mixed_+3A_method">method</code></td>
<td>
<p>The method to be used</p>
</td></tr>
<tr><td><code id="mixed_+3A_x">x</code></td>
<td>
<p>A mixed.mmkin object to print</p>
</td></tr>
<tr><td><code id="mixed_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'mixed.mmkin' which has the observed data in a
single dataframe which is convenient for plotting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)
n_biphasic &lt;- 8
err_1 = list(const = 1, prop = 0.07)

DFOP_SFO &lt;- mkinmod(
  parent = mkinsub("DFOP", "m1"),
  m1 = mkinsub("SFO"),
  quiet = TRUE)

set.seed(123456)
log_sd &lt;- 0.3
syn_biphasic_parms &lt;- as.matrix(data.frame(
  k1 = rlnorm(n_biphasic, log(0.05), log_sd),
  k2 = rlnorm(n_biphasic, log(0.01), log_sd),
  g = plogis(rnorm(n_biphasic, 0, log_sd)),
  f_parent_to_m1 = plogis(rnorm(n_biphasic, 0, log_sd)),
  k_m1 = rlnorm(n_biphasic, log(0.002), log_sd)))

ds_biphasic_mean &lt;- lapply(1:n_biphasic,
  function(i) {
    mkinpredict(DFOP_SFO, syn_biphasic_parms[i, ],
      c(parent = 100, m1 = 0), sampling_times)
  }
)

set.seed(123456L)
ds_biphasic &lt;- lapply(ds_biphasic_mean, function(ds) {
  add_err(ds,
    sdfunc = function(value) sqrt(err_1$const^2 + value^2 * err_1$prop^2),
    n = 1, secondary = "m1")[[1]]
})

## Not run: 
f_mmkin &lt;- mmkin(list("DFOP-SFO" = DFOP_SFO), ds_biphasic, error_model = "tc", quiet = TRUE)

f_mixed &lt;- mixed(f_mmkin)
print(f_mixed)
plot(f_mixed)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkin_long_to_wide'>Convert a dataframe from long to wide format</h2><span id='topic+mkin_long_to_wide'></span>

<h3>Description</h3>

<p>This function takes a dataframe in the long form, i.e. with a row for each
observed value, and converts it into a dataframe with one independent
variable and several dependent variables as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkin_long_to_wide(long_data, time = "time", outtime = "time")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkin_long_to_wide_+3A_long_data">long_data</code></td>
<td>
<p>The dataframe must contain one variable called &quot;time&quot; with
the time values specified by the <code>time</code> argument, one column called
&quot;name&quot; with the grouping of the observed values, and finally one column of
observed values called &quot;value&quot;.</p>
</td></tr>
<tr><td><code id="mkin_long_to_wide_+3A_time">time</code></td>
<td>
<p>The name of the time variable in the long input data.</p>
</td></tr>
<tr><td><code id="mkin_long_to_wide_+3A_outtime">outtime</code></td>
<td>
<p>The name of the time variable in the wide output data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe in wide format.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mkin_long_to_wide(FOCUS_2006_D)

</code></pre>

<hr>
<h2 id='mkin_wide_to_long'>Convert a dataframe with observations over time into long format</h2><span id='topic+mkin_wide_to_long'></span>

<h3>Description</h3>

<p>This function simply takes a dataframe with one independent variable and
several dependent variable and converts it into the long form as required by
<code><a href="#topic+mkinfit">mkinfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkin_wide_to_long(wide_data, time = "t")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkin_wide_to_long_+3A_wide_data">wide_data</code></td>
<td>
<p>The dataframe must contain one variable with the time
values specified by the <code>time</code> argument and usually more than one
column of observed values.</p>
</td></tr>
<tr><td><code id="mkin_wide_to_long_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe in long format as needed for <code><a href="#topic+mkinfit">mkinfit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
wide &lt;- data.frame(t = c(1,2,3), x = c(1,4,7), y = c(3,4,5))
mkin_wide_to_long(wide)

</code></pre>

<hr>
<h2 id='mkinds'>A dataset class for mkin</h2><span id='topic+mkinds'></span><span id='topic+print.mkinds'></span>

<h3>Description</h3>

<p>At the moment this dataset class is hardly used in mkin. For example,
mkinfit does not take mkinds datasets as argument, but works with dataframes
such as the on contained in the data field of mkinds objects. Some datasets
provided by this package come as mkinds objects nevertheless.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinds'
print(x, data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinds_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+mkinds">mkinds</a> object.</p>
</td></tr>
<tr><td><code id="mkinds_+3A_data">data</code></td>
<td>
<p>Should the data be printed?</p>
</td></tr>
<tr><td><code id="mkinds_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>title</code></dt><dd><p>A full title for the dataset</p>
</dd>
<dt><code>sampling_times</code></dt><dd><p>The sampling times</p>
</dd>
<dt><code>time_unit</code></dt><dd><p>The time unit</p>
</dd>
<dt><code>observed</code></dt><dd><p>Names of the observed variables</p>
</dd>
<dt><code>unit</code></dt><dd><p>The unit of the observations</p>
</dd>
<dt><code>replicates</code></dt><dd><p>The maximum number of replicates per sampling time</p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame with at least the columns name, time
and value in order to be compatible with mkinfit</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-mkinds-new"><code>mkinds$new()</code></a>
</p>
</li>
<li> <p><a href="#method-mkinds-clone"><code>mkinds$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-mkinds-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new mkinds object
</p>


<h5>Usage</h5>

<div class="r"><pre>mkinds$new(title = "", data, time_unit = NA, unit = NA)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>title</code></dt><dd><p>The dataset title</p>
</dd>
<dt><code>data</code></dt><dd><p>The data</p>
</dd>
<dt><code>time_unit</code></dt><dd><p>The time unit</p>
</dd>
<dt><code>unit</code></dt><dd><p>The unit of the observations</p>
</dd>
</dl>

</div>


<hr>
<a id="method-mkinds-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>mkinds$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
mds &lt;- mkinds$new("FOCUS A", FOCUS_2006_A)
print(mds)

</code></pre>

<hr>
<h2 id='mkindsg'>A class for dataset groups for mkin</h2><span id='topic+mkindsg'></span><span id='topic+print.mkindsg'></span>

<h3>Description</h3>

<p>A container for working with datasets that share at least one compound,
so that combined evaluations are desirable.
</p>
<p>Time normalisation factors are initialised with a value of 1 for each
dataset if no data are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkindsg'
print(x, data = FALSE, verbose = data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkindsg_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+mkindsg">mkindsg</a> object.</p>
</td></tr>
<tr><td><code id="mkindsg_+3A_data">data</code></td>
<td>
<p>Should the mkinds objects be printed with their data?</p>
</td></tr>
<tr><td><code id="mkindsg_+3A_verbose">verbose</code></td>
<td>
<p>Should the mkinds objects be printed?</p>
</td></tr>
<tr><td><code id="mkindsg_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>title</code></dt><dd><p>A title for the dataset group</p>
</dd>
<dt><code>ds</code></dt><dd><p>A list of mkinds objects</p>
</dd>
<dt><code>observed_n</code></dt><dd><p>Occurrence counts of compounds in datasets</p>
</dd>
<dt><code>f_time_norm</code></dt><dd><p>Time normalisation factors</p>
</dd>
<dt><code>meta</code></dt><dd><p>A data frame with a row for each dataset,
containing additional information in the form
of categorical data (factors) or numerical data
(e.g. temperature, moisture,
or covariates like soil pH).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-mkindsg-new"><code>mkindsg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-mkindsg-clone"><code>mkindsg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-mkindsg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new mkindsg object
</p>


<h5>Usage</h5>

<div class="r"><pre>mkindsg$new(title = "", ds, f_time_norm = rep(1, length(ds)), meta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>title</code></dt><dd><p>The title</p>
</dd>
<dt><code>ds</code></dt><dd><p>A list of mkinds objects</p>
</dd>
<dt><code>f_time_norm</code></dt><dd><p>Time normalisation factors</p>
</dd>
<dt><code>meta</code></dt><dd><p>The meta data</p>
</dd>
</dl>

</div>


<hr>
<a id="method-mkindsg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>mkindsg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
mdsg &lt;- mkindsg$new("Experimental X", experimental_data_for_UBA_2019[6:10])
print(mdsg)
print(mdsg, verbose = TRUE)
print(mdsg, verbose = TRUE, data = TRUE)

</code></pre>

<hr>
<h2 id='mkinerrmin'>Calculate the minimum error to assume in order to pass the variance test</h2><span id='topic+mkinerrmin'></span>

<h3>Description</h3>

<p>This function finds the smallest relative error still resulting in passing
the chi-squared test as defined in the FOCUS kinetics report from 2006.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinerrmin(fit, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinerrmin_+3A_fit">fit</code></td>
<td>
<p>an object of class <code><a href="#topic+mkinfit">mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="mkinerrmin_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level chosen for the chi-squared test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <code><a href="#topic+summary.mkinfit">summary.mkinfit</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe with the following components: </p>
<table>
<tr><td><code>err.min</code></td>
<td>
<p>The
relative error, expressed as a fraction.</p>
</td></tr> <tr><td><code>n.optim</code></td>
<td>
<p>The number of
optimised parameters attributed to the data series.</p>
</td></tr> <tr><td><code>df</code></td>
<td>
<p>The number of
remaining degrees of freedom for the chi2 error level calculations.  Note
that mean values are used for the chi2 statistic and therefore every time
point with observed values in the series only counts one time.</p>
</td></tr></table>
<p> The
dataframe has one row for the total dataset and one further row for each
observed state variable in the model.
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in EU
Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics, EC
Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SFO_SFO = mkinmod(parent = mkinsub("SFO", to = "m1"),
                  m1 = mkinsub("SFO"),
                  use_of_ff = "max")

fit_FOCUS_D = mkinfit(SFO_SFO, FOCUS_2006_D, quiet = TRUE)
round(mkinerrmin(fit_FOCUS_D), 4)
## Not run: 
  fit_FOCUS_E = mkinfit(SFO_SFO, FOCUS_2006_E, quiet = TRUE)
  round(mkinerrmin(fit_FOCUS_E), 4)

## End(Not run)

</code></pre>

<hr>
<h2 id='mkinerrplot'>Function to plot squared residuals and the error model for an mkin object</h2><span id='topic+mkinerrplot'></span>

<h3>Description</h3>

<p>This function plots the squared residuals for the specified subset of the
observed variables from an mkinfit object. In addition, one or more dashed
line(s) show the fitted error model.  A combined plot of the fitted model
and this error model plot can be obtained with <code><a href="#topic+plot.mkinfit">plot.mkinfit</a></code>
using the argument <code>show_errplot = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinerrplot(
  object,
  obs_vars = names(object$mkinmod$map),
  xlim = c(0, 1.1 * max(object$data$predicted)),
  xlab = "Predicted",
  ylab = "Squared residual",
  maxy = "auto",
  legend = TRUE,
  lpos = "topright",
  col_obs = "auto",
  pch_obs = "auto",
  frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinerrplot_+3A_object">object</code></td>
<td>
<p>A fit represented in an <code><a href="#topic+mkinfit">mkinfit</a></code> object.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_obs_vars">obs_vars</code></td>
<td>
<p>A character vector of names of the observed variables for
which residuals should be plotted. Defaults to all observed variables in
the model</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_xlim">xlim</code></td>
<td>
<p>plot range in x direction.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x axis.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y axis.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_maxy">maxy</code></td>
<td>
<p>Maximum value of the residuals. This is used for the scaling of
the y axis and defaults to &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_legend">legend</code></td>
<td>
<p>Should a legend be plotted?</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_lpos">lpos</code></td>
<td>
<p>Where should the legend be placed? Default is &quot;topright&quot;. Will
be passed on to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_col_obs">col_obs</code></td>
<td>
<p>Colors for the observed variables.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_pch_obs">pch_obs</code></td>
<td>
<p>Symbols to be used for the observed variables.</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_frame">frame</code></td>
<td>
<p>Should a frame be drawn around the plots?</p>
</td></tr>
<tr><td><code id="mkinerrplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned by this function, as it is called for its side
effect, namely to produce a plot.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkinplot">mkinplot</a></code>, for a way to plot the data and the fitted
lines of the mkinfit object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
model &lt;- mkinmod(parent = mkinsub("SFO", "m1"), m1 = mkinsub("SFO"))
fit &lt;- mkinfit(model, FOCUS_2006_D, error_model = "tc", quiet = TRUE)
mkinerrplot(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='mkinfit'>Fit a kinetic model to data with one or more state variables</h2><span id='topic+mkinfit'></span>

<h3>Description</h3>

<p>This function maximises the likelihood of the observed data using the Port
algorithm <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>, and the specified initial or fixed
parameters and starting values.  In each step of the optimisation, the
kinetic model is solved using the function <code><a href="#topic+mkinpredict">mkinpredict()</a></code>, except
if an analytical solution is implemented, in which case the model is solved
using the degradation function in the <a href="#topic+mkinmod">mkinmod</a> object. The
parameters of the selected error model are fitted simultaneously with the
degradation model parameters, as both of them are arguments of the
likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinfit(
  mkinmod,
  observed,
  parms.ini = "auto",
  state.ini = "auto",
  err.ini = "auto",
  fixed_parms = NULL,
  fixed_initials = names(mkinmod$diffs)[-1],
  from_max_mean = FALSE,
  solution_type = c("auto", "analytical", "eigen", "deSolve"),
  method.ode = "lsoda",
  use_compiled = "auto",
  control = list(eval.max = 300, iter.max = 200),
  transform_rates = TRUE,
  transform_fractions = TRUE,
  quiet = FALSE,
  atol = 1e-08,
  rtol = 1e-10,
  error_model = c("const", "obs", "tc"),
  error_model_algorithm = c("auto", "d_3", "direct", "twostep", "threestep", "fourstep",
    "IRLS", "OLS"),
  reweight.tol = 1e-08,
  reweight.max.iter = 10,
  trace_parms = FALSE,
  test_residuals = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinfit_+3A_mkinmod">mkinmod</code></td>
<td>
<p>A list of class <a href="#topic+mkinmod">mkinmod</a>, containing the kinetic
model to be fitted to the data, or one of the shorthand names (&quot;SFO&quot;,
&quot;FOMC&quot;, &quot;DFOP&quot;, &quot;HS&quot;, &quot;SFORB&quot;, &quot;IORE&quot;). If a shorthand name is given, a
parent only degradation model is generated for the variable with the
highest value in <code>observed</code>.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_observed">observed</code></td>
<td>
<p>A dataframe with the observed data.  The first column called
&quot;name&quot; must contain the name of the observed variable for each data point.
The second column must contain the times of observation, named &quot;time&quot;.
The third column must be named &quot;value&quot; and contain the observed values.
Zero values in the &quot;value&quot; column will be removed, with a warning, in
order to avoid problems with fitting the two-component error model. This
is not expected to be a problem, because in general, values of zero are
not observed in degradation data, because there is a lower limit of
detection.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_parms.ini">parms.ini</code></td>
<td>
<p>A named vector of initial values for the parameters,
including parameters to be optimised and potentially also fixed parameters
as indicated by <code>fixed_parms</code>.  If set to &quot;auto&quot;, initial values for
rate constants are set to default values.  Using parameter names that are
not in the model gives an error.
</p>
<p>It is possible to only specify a subset of the parameters that the model
needs. You can use the parameter lists &quot;bparms.ode&quot; from a previously
fitted model, which contains the differential equation parameters from
this model.  This works nicely if the models are nested. An example is
given below.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_state.ini">state.ini</code></td>
<td>
<p>A named vector of initial values for the state variables of
the model. In case the observed variables are represented by more than one
model variable, the names will differ from the names of the observed
variables (see <code>map</code> component of <a href="#topic+mkinmod">mkinmod</a>). The default
is to set the initial value of the first model variable to the mean of the
time zero values for the variable with the maximum observed value, and all
others to 0.  If this variable has no time zero observations, its initial
value is set to 100.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_err.ini">err.ini</code></td>
<td>
<p>A named vector of initial values for the error model
parameters to be optimised.  If set to &quot;auto&quot;, initial values are set to
default values.  Otherwise, inital values for all error model parameters
must be given.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_fixed_parms">fixed_parms</code></td>
<td>
<p>The names of parameters that should not be optimised but
rather kept at the values specified in <code>parms.ini</code>. Alternatively,
a named numeric vector of parameters to be fixed, regardless of the values
in parms.ini.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_fixed_initials">fixed_initials</code></td>
<td>
<p>The names of model variables for which the initial
state at time 0 should be excluded from the optimisation. Defaults to all
state variables except for the first one.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_from_max_mean">from_max_mean</code></td>
<td>
<p>If this is set to TRUE, and the model has only one
observed variable, then data before the time of the maximum observed value
(after averaging for each sampling time) are discarded, and this time is
subtracted from all remaining time values, so the time of the maximum
observed mean value is the new time zero.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_solution_type">solution_type</code></td>
<td>
<p>If set to &quot;eigen&quot;, the solution of the system of
differential equations is based on the spectral decomposition of the
coefficient matrix in cases that this is possible. If set to &quot;deSolve&quot;, a
numerical <a href="deSolve.html#topic+ode">ode solver from package deSolve</a> is used. If
set to &quot;analytical&quot;, an analytical solution of the model is used. This is
only implemented for relatively simple degradation models.  The default is
&quot;auto&quot;, which uses &quot;analytical&quot; if possible, otherwise &quot;deSolve&quot; if a
compiler is present, and &quot;eigen&quot; if no compiler is present and the model
can be expressed using eigenvalues and eigenvectors.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_method.ode">method.ode</code></td>
<td>
<p>The solution method passed via <code><a href="#topic+mkinpredict">mkinpredict()</a></code>
to <code><a href="deSolve.html#topic+ode">deSolve::ode()</a></code> in case the solution type is &quot;deSolve&quot;. The default
&quot;lsoda&quot; is performant, but sometimes fails to converge.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_use_compiled">use_compiled</code></td>
<td>
<p>If set to <code>FALSE</code>, no compiled version of the
<a href="#topic+mkinmod">mkinmod</a> model is used in the calls to <code><a href="#topic+mkinpredict">mkinpredict()</a></code> even if a compiled
version is present.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_control">control</code></td>
<td>
<p>A list of control arguments passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_transform_rates">transform_rates</code></td>
<td>
<p>Boolean specifying if kinetic rate constants should
be transformed in the model specification used in the fitting for better
compliance with the assumption of normal distribution of the estimator. If
TRUE, also alpha and beta parameters of the FOMC model are
log-transformed, as well as k1 and k2 rate constants for the DFOP and HS
models and the break point tb of the HS model.  If FALSE, zero is used as
a lower bound for the rates in the optimisation.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_transform_fractions">transform_fractions</code></td>
<td>
<p>Boolean specifying if formation fractions
should be transformed in the model specification used in the fitting for
better compliance with the assumption of normal distribution of the
estimator. The default (TRUE) is to do transformations. If TRUE,
the g parameter of the DFOP model is also transformed. Transformations
are described in <a href="#topic+transform_odeparms">transform_odeparms</a>.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_quiet">quiet</code></td>
<td>
<p>Suppress printing out the current value of the negative
log-likelihood after each improvement?</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_atol">atol</code></td>
<td>
<p>Absolute error tolerance, passed to <code><a href="deSolve.html#topic+ode">deSolve::ode()</a></code>. Default
is 1e-8, which is lower than the default in the <code><a href="deSolve.html#topic+lsoda">deSolve::lsoda()</a></code>
function which is used per default.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_rtol">rtol</code></td>
<td>
<p>Absolute error tolerance, passed to <code><a href="deSolve.html#topic+ode">deSolve::ode()</a></code>. Default
is 1e-10, much lower than in <code><a href="deSolve.html#topic+lsoda">deSolve::lsoda()</a></code>.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_error_model">error_model</code></td>
<td>
<p>If the error model is &quot;const&quot;, a constant standard
deviation is assumed.
</p>
<p>If the error model is &quot;obs&quot;, each observed variable is assumed to have its
own variance.
</p>
<p>If the error model is &quot;tc&quot; (two-component error model), a two component
error model similar to the one described by Rocke and Lorenzato (1995) is
used for setting up the likelihood function.  Note that this model
deviates from the model by Rocke and Lorenzato, as their model implies
that the errors follow a lognormal distribution for large values, not a
normal distribution as assumed by this method.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_error_model_algorithm">error_model_algorithm</code></td>
<td>
<p>If &quot;auto&quot;, the selected algorithm depends on
the error model.  If the error model is &quot;const&quot;, unweighted nonlinear
least squares fitting (&quot;OLS&quot;) is selected. If the error model is &quot;obs&quot;, or
&quot;tc&quot;, the &quot;d_3&quot; algorithm is selected.
</p>
<p>The algorithm &quot;d_3&quot; will directly minimize the negative log-likelihood
and independently also use the three step algorithm described below.
The fit with the higher likelihood is returned.
</p>
<p>The algorithm &quot;direct&quot; will directly minimize the negative log-likelihood.
</p>
<p>The algorithm &quot;twostep&quot; will minimize the negative log-likelihood after an
initial unweighted least squares optimisation step.
</p>
<p>The algorithm &quot;threestep&quot; starts with unweighted least squares, then
optimizes only the error model using the degradation model parameters
found, and then minimizes the negative log-likelihood with free
degradation and error model parameters.
</p>
<p>The algorithm &quot;fourstep&quot; starts with unweighted least squares, then
optimizes only the error model using the degradation model parameters
found, then optimizes the degradation model again with fixed error model
parameters, and finally minimizes the negative log-likelihood with free
degradation and error model parameters.
</p>
<p>The algorithm &quot;IRLS&quot; (Iteratively Reweighted Least Squares) starts with
unweighted least squares, and then iterates optimization of the error
model parameters and subsequent optimization of the degradation model
using those error model parameters, until the error model parameters
converge.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_reweight.tol">reweight.tol</code></td>
<td>
<p>Tolerance for the convergence criterion calculated from
the error model parameters in IRLS fits.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_reweight.max.iter">reweight.max.iter</code></td>
<td>
<p>Maximum number of iterations in IRLS fits.</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_trace_parms">trace_parms</code></td>
<td>
<p>Should a trace of the parameter values be listed?</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_test_residuals">test_residuals</code></td>
<td>
<p>Should the residuals be tested for normal distribution?</p>
</td></tr>
<tr><td><code id="mkinfit_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed on to
<code><a href="deSolve.html#topic+ode">deSolve::ode()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Per default, parameters in the kinetic models are internally transformed in
order to better satisfy the assumption of a normal distribution of their
estimators.
</p>


<h3>Value</h3>

<p>A list with &quot;mkinfit&quot; in the class attribute.
</p>


<h3>Note</h3>

<p>When using the &quot;IORE&quot; submodel for metabolites, fitting with
&quot;transform_rates = TRUE&quot; (the default) often leads to failures of the
numerical ODE solver. In this situation it may help to switch off the
internal rate transformation.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>References</h3>

<p>Rocke DM and Lorenzato S (1995) A two-component model
for measurement error in analytical chemistry. <em>Technometrics</em> 37(2), 176-184.
</p>
<p>Ranke J and Meinecke S (2019) Error Models for the Kinetic Evaluation of Chemical
Degradation Data. <em>Environments</em> 6(12) 124
<a href="https://doi.org/10.3390/environments6120124">doi:10.3390/environments6120124</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.mkinfit">summary.mkinfit</a>, <a href="#topic+plot.mkinfit">plot.mkinfit</a>, <a href="#topic+parms">parms</a> and <a href="#topic+lrtest">lrtest</a>.
</p>
<p>Comparisons of models fitted to the same data can be made using
<code><a href="stats.html#topic+AIC">AIC</a></code> by virtue of the method <code><a href="#topic+logLik.mkinfit">logLik.mkinfit</a></code>.
</p>
<p>Fitting of several models to several datasets in a single call to
<code><a href="#topic+mmkin">mmkin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use shorthand notation for parent only degradation
fit &lt;- mkinfit("FOMC", FOCUS_2006_C, quiet = TRUE)
summary(fit)

# One parent compound, one metabolite, both single first order.
# We remove zero values from FOCUS dataset D in order to avoid warnings
FOCUS_D &lt;- subset(FOCUS_2006_D, value != 0)
# Use mkinsub for convenience in model formulation. Pathway to sink included per default.
SFO_SFO &lt;- mkinmod(
  parent = mkinsub("SFO", "m1"),
  m1 = mkinsub("SFO"))

# Fit the model quietly to the FOCUS example dataset D using defaults
fit &lt;- mkinfit(SFO_SFO, FOCUS_D, quiet = TRUE)
plot_sep(fit)
# As lower parent values appear to have lower variance, we try an alternative error model
fit.tc &lt;- mkinfit(SFO_SFO, FOCUS_D, quiet = TRUE, error_model = "tc")
# This avoids the warning, and the likelihood ratio test confirms it is preferable
lrtest(fit.tc, fit)
# We can also allow for different variances of parent and metabolite as error model
fit.obs &lt;- mkinfit(SFO_SFO, FOCUS_D, quiet = TRUE, error_model = "obs")
# The two-component error model has significantly higher likelihood
lrtest(fit.obs, fit.tc)
parms(fit.tc)
endpoints(fit.tc)

# We can show a quick (only one replication) benchmark for this case, as we
# have several alternative solution methods for the model. We skip
# uncompiled deSolve, as it is so slow. More benchmarks are found in the
# benchmark vignette
## Not run: 
if(require(rbenchmark)) {
  benchmark(replications = 1, order = "relative", columns = c("test", "relative", "elapsed"),
    deSolve_compiled = mkinfit(SFO_SFO, FOCUS_D, quiet = TRUE, error_model = "tc",
      solution_type = "deSolve", use_compiled = TRUE),
    eigen = mkinfit(SFO_SFO, FOCUS_D, quiet = TRUE, error_model = "tc",
      solution_type = "eigen"),
    analytical = mkinfit(SFO_SFO, FOCUS_D, quiet = TRUE, error_model = "tc",
      solution_type = "analytical"))
}

## End(Not run)

# Use stepwise fitting, using optimised parameters from parent only fit, FOMC-SFO
## Not run: 
FOMC_SFO &lt;- mkinmod(
  parent = mkinsub("FOMC", "m1"),
  m1 = mkinsub("SFO"))
fit.FOMC_SFO &lt;- mkinfit(FOMC_SFO, FOCUS_D, quiet = TRUE)
# Again, we get a warning and try a more sophisticated error model
fit.FOMC_SFO.tc &lt;- mkinfit(FOMC_SFO, FOCUS_D, quiet = TRUE, error_model = "tc")
# This model has a higher likelihood, but not significantly so
lrtest(fit.tc, fit.FOMC_SFO.tc)
# Also, the missing standard error for log_beta and the t-tests for alpha
# and beta indicate overparameterisation
summary(fit.FOMC_SFO.tc, data = FALSE)

# We can easily use starting parameters from the parent only fit (only for illustration)
fit.FOMC = mkinfit("FOMC", FOCUS_2006_D, quiet = TRUE, error_model = "tc")
fit.FOMC_SFO &lt;- mkinfit(FOMC_SFO, FOCUS_D, quiet = TRUE,
  parms.ini = fit.FOMC$bparms.ode, error_model = "tc")

## End(Not run)
</code></pre>

<hr>
<h2 id='mkinmod'>Function to set up a kinetic model with one or more state variables</h2><span id='topic+mkinmod'></span><span id='topic+print.mkinmod'></span><span id='topic+mkinsub'></span>

<h3>Description</h3>

<p>This function is usually called using a call to <code><a href="#topic+mkinsub">mkinsub()</a></code> for each observed
variable, specifying the corresponding submodel as well as outgoing pathways
(see examples).
</p>
<p>Print mkinmod objects in a way that the user finds his way to get to its
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinmod(
  ...,
  use_of_ff = "max",
  name = NULL,
  speclist = NULL,
  quiet = FALSE,
  verbose = FALSE,
  dll_dir = NULL,
  unload = FALSE,
  overwrite = FALSE
)

## S3 method for class 'mkinmod'
print(x, ...)

mkinsub(submodel, to = NULL, sink = TRUE, full_name = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinmod_+3A_...">...</code></td>
<td>
<p>For each observed variable, a list as obtained by <code><a href="#topic+mkinsub">mkinsub()</a></code>
has to be specified as an argument (see examples).  Currently, single
first order kinetics &quot;SFO&quot;, indeterminate order rate equation kinetics
&quot;IORE&quot;, or single first order with reversible binding &quot;SFORB&quot; are
implemented for all variables, while &quot;FOMC&quot;, &quot;DFOP&quot;, &quot;HS&quot; and &quot;logistic&quot;
can additionally be chosen for the first variable which is assumed to be
the source compartment.
Additionally, <code><a href="#topic+mkinsub">mkinsub()</a></code> has an argument <code>to</code>, specifying names of
variables to which a transfer is to be assumed in the model.
If the argument <code>use_of_ff</code> is set to &quot;min&quot;
and the model for the compartment is &quot;SFO&quot; or &quot;SFORB&quot;, an
additional <code><a href="#topic+mkinsub">mkinsub()</a></code> argument can be <code>sink = FALSE</code>, effectively
fixing the flux to sink to zero.
In print.mkinmod, this argument is currently not used.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_use_of_ff">use_of_ff</code></td>
<td>
<p>Specification of the use of formation fractions in the
model equations and, if applicable, the coefficient matrix.  If &quot;max&quot;,
formation fractions are always used (default).  If &quot;min&quot;, a minimum use of
formation fractions is made, i.e. each first-order pathway to a metabolite
has its own rate constant.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_name">name</code></td>
<td>
<p>A name for the model. Should be a valid R object name.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_speclist">speclist</code></td>
<td>
<p>The specification of the observed variables and their
submodel types and pathways can be given as a single list using this
argument. Default is NULL.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_quiet">quiet</code></td>
<td>
<p>Should messages be suppressed?</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, passed to <code><a href="inline.html#topic+cfunction">inline::cfunction()</a></code> if
applicable to give detailed information about the C function being built.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_dll_dir">dll_dir</code></td>
<td>
<p>Directory where an DLL object, if generated internally by
<code><a href="inline.html#topic+cfunction">inline::cfunction()</a></code>, should be saved.  The DLL will only be stored in a
permanent location for use in future sessions, if 'dll_dir' and 'name'
are specified. This is helpful if fit objects are cached e.g. by knitr,
as the cache remains functional across sessions if the DLL is stored in
a user defined location.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_unload">unload</code></td>
<td>
<p>If a DLL from the target location in 'dll_dir' is already
loaded, should that be unloaded first?</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_overwrite">overwrite</code></td>
<td>
<p>If a file exists at the target DLL location in 'dll_dir',
should this be overwritten?</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+mkinmod">mkinmod</a></code> object.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_submodel">submodel</code></td>
<td>
<p>Character vector of length one to specify the submodel type.
See <code><a href="#topic+mkinmod">mkinmod</a></code> for the list of allowed submodel names.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_to">to</code></td>
<td>
<p>Vector of the names of the state variable to which a
transformation shall be included in the model.</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_sink">sink</code></td>
<td>
<p>Should a pathway to sink be included in the model in addition to
the pathways to other state variables?</p>
</td></tr>
<tr><td><code id="mkinmod_+3A_full_name">full_name</code></td>
<td>
<p>An optional name to be used e.g. for plotting fits
performed with the model.  You can use non-ASCII characters here, but then
your R code will not be portable, <em>i.e.</em> may produce unintended plot
results on other operating systems or system configurations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the definition of model types and their parameters, the equations given
in the FOCUS and NAFTA guidance documents are used.
</p>
<p>For kinetic models with more than one observed variable, a symbolic solution
of the system of differential equations is included in the resulting
mkinmod object in some cases, speeding up the solution.
</p>
<p>If a C compiler is found by <code><a href="pkgbuild.html#topic+has_compiler">pkgbuild::has_compiler()</a></code> and there
is more than one observed variable in the specification, C code is generated
for evaluating the differential equations, compiled using
<code><a href="inline.html#topic+cfunction">inline::cfunction()</a></code> and added to the resulting mkinmod object.
</p>


<h3>Value</h3>

<p>A list of class <code>mkinmod</code> for use with <code><a href="#topic+mkinfit">mkinfit()</a></code>,
containing, among others,
</p>
<table>
<tr><td><code>diffs</code></td>
<td>

<p>A vector of string representations of differential equations, one for
each modelling variable.
</p>
</td></tr>
<tr><td><code>map</code></td>
<td>

<p>A list containing named character vectors for each observed variable,
specifying the modelling variables by which it is represented.
</p>
</td></tr>
<tr><td><code>use_of_ff</code></td>
<td>

<p>The content of <code>use_of_ff</code> is passed on in this list component.
</p>
</td></tr>
<tr><td><code>deg_func</code></td>
<td>

<p>If generated, a function containing the solution of the degradation
model.
</p>
</td></tr>
<tr><td><code>coefmat</code></td>
<td>

<p>The coefficient matrix, if the system of differential equations can be
represented by one.
</p>
</td></tr>
<tr><td><code>cf</code></td>
<td>

<p>If generated, a compiled function calculating the derivatives as
returned by cfunction.
</p>
</td></tr>
</table>
<p>A list for use with <code><a href="#topic+mkinmod">mkinmod</a></code>.
</p>


<h3>Note</h3>

<p>The IORE submodel is not well tested for metabolites. When using this
model for metabolites, you may want to read the note in the help
page to <a href="#topic+mkinfit">mkinfit</a>.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>
<p>NAFTA Technical Working Group on Pesticides (not dated) Guidance for
Evaluating and Calculating Degradation Kinetics in Environmental Media
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Specify the SFO model (this is not needed any more, as we can now mkinfit("SFO", ...)
SFO &lt;- mkinmod(parent = mkinsub("SFO"))

# One parent compound, one metabolite, both single first order
SFO_SFO &lt;- mkinmod(
  parent = mkinsub("SFO", "m1"),
  m1 = mkinsub("SFO"))
print(SFO_SFO)

## Not run: 
 fit_sfo_sfo &lt;- mkinfit(SFO_SFO, FOCUS_2006_D, quiet = TRUE, solution_type = "deSolve")

 # Now supplying compound names used for plotting, and write to user defined location
 # We need to choose a path outside the session tempdir because this gets removed
 DLL_dir &lt;- "~/.local/share/mkin"
 if (!dir.exists(DLL_dir)) dir.create(DLL_dir)
 SFO_SFO.2 &lt;- mkinmod(
   parent = mkinsub("SFO", "m1", full_name = "Test compound"),
   m1 = mkinsub("SFO", full_name = "Metabolite M1"),
   name = "SFO_SFO", dll_dir = DLL_dir, unload = TRUE, overwrite = TRUE)
# Now we can save the model and restore it in a new session
saveRDS(SFO_SFO.2, file = "~/SFO_SFO.rds")
# Terminate the R session here if you would like to check, and then do
library(mkin)
SFO_SFO.3 &lt;- readRDS("~/SFO_SFO.rds")
fit_sfo_sfo &lt;- mkinfit(SFO_SFO.3, FOCUS_2006_D, quiet = TRUE, solution_type = "deSolve")

# Show details of creating the C function
SFO_SFO &lt;- mkinmod(
  parent = mkinsub("SFO", "m1"),
  m1 = mkinsub("SFO"), verbose = TRUE)

# The symbolic solution which is available in this case is not
# made for human reading but for speed of computation
SFO_SFO$deg_func

# If we have several parallel metabolites
# (compare tests/testthat/test_synthetic_data_for_UBA_2014.R)
m_synth_DFOP_par &lt;- mkinmod(
 parent = mkinsub("DFOP", c("M1", "M2")),
 M1 = mkinsub("SFO"),
 M2 = mkinsub("SFO"),
 quiet = TRUE)

fit_DFOP_par_c &lt;- mkinfit(m_synth_DFOP_par,
  synthetic_data_for_UBA_2014[[12]]$data,
  quiet = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='mkinparplot'>Function to plot the confidence intervals obtained using mkinfit</h2><span id='topic+mkinparplot'></span>

<h3>Description</h3>

<p>This function plots the confidence intervals for the parameters fitted using
<code><a href="#topic+mkinfit">mkinfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinparplot(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinparplot_+3A_object">object</code></td>
<td>
<p>A fit represented in an <code><a href="#topic+mkinfit">mkinfit</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned by this function, as it is called for its side
effect, namely to produce a plot.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
model &lt;- mkinmod(
  T245 = mkinsub("SFO", to = c("phenol"), sink = FALSE),
  phenol = mkinsub("SFO", to = c("anisole")),
  anisole = mkinsub("SFO"), use_of_ff = "max")
fit &lt;- mkinfit(model, subset(mccall81_245T, soil == "Commerce"), quiet = TRUE)
mkinparplot(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkinplot'>Plot the observed data and the fitted model of an mkinfit object</h2><span id='topic+mkinplot'></span>

<h3>Description</h3>

<p>Deprecated function. It now only calls the plot method
<code><a href="#topic+plot.mkinfit">plot.mkinfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinplot(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinplot_+3A_fit">fit</code></td>
<td>
<p>an object of class <code><a href="#topic+mkinfit">mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="mkinplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+plot.mkinfit">plot.mkinfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>

<hr>
<h2 id='mkinpredict'>Produce predictions from a kinetic model using specific parameters</h2><span id='topic+mkinpredict'></span><span id='topic+mkinpredict.mkinmod'></span><span id='topic+mkinpredict.mkinfit'></span>

<h3>Description</h3>

<p>This function produces a time series for all the observed variables in a
kinetic model as specified by <a href="#topic+mkinmod">mkinmod</a>, using a specific set of
kinetic parameters and initial values for the state variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinpredict(x, odeparms, odeini, outtimes, ...)

## S3 method for class 'mkinmod'
mkinpredict(
  x,
  odeparms = c(k_parent_sink = 0.1),
  odeini = c(parent = 100),
  outtimes = seq(0, 120, by = 0.1),
  solution_type = "deSolve",
  use_compiled = "auto",
  use_symbols = FALSE,
  method.ode = "lsoda",
  atol = 1e-08,
  rtol = 1e-10,
  maxsteps = 20000L,
  map_output = TRUE,
  na_stop = TRUE,
  ...
)

## S3 method for class 'mkinfit'
mkinpredict(
  x,
  odeparms = x$bparms.ode,
  odeini = x$bparms.state,
  outtimes = seq(0, 120, by = 0.1),
  solution_type = "deSolve",
  use_compiled = "auto",
  method.ode = "lsoda",
  atol = 1e-08,
  rtol = 1e-10,
  map_output = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinpredict_+3A_x">x</code></td>
<td>
<p>A kinetic model as produced by <a href="#topic+mkinmod">mkinmod</a>, or a kinetic fit as
fitted by <a href="#topic+mkinfit">mkinfit</a>. In the latter case, the fitted parameters are used for
the prediction.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_odeparms">odeparms</code></td>
<td>
<p>A numeric vector specifying the parameters used in the
kinetic model, which is generally defined as a set of ordinary differential
equations.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_odeini">odeini</code></td>
<td>
<p>A numeric vector containing the initial values of the state
variables of the model. Note that the state variables can differ from the
observed variables, for example in the case of the SFORB model.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_outtimes">outtimes</code></td>
<td>
<p>A numeric vector specifying the time points for which model
predictions should be generated.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the ode solver in case such a
solver is used.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_solution_type">solution_type</code></td>
<td>
<p>The method that should be used for producing the
predictions. This should generally be &quot;analytical&quot; if there is only one
observed variable, and usually &quot;deSolve&quot; in the case of several observed
variables. The third possibility &quot;eigen&quot; is fast in comparison to uncompiled
ODE models, but not applicable to some models, e.g. using FOMC for the
parent compound.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_use_compiled">use_compiled</code></td>
<td>
<p>If set to <code>FALSE</code>, no compiled version of the
<a href="#topic+mkinmod">mkinmod</a> model is used, even if is present.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_use_symbols">use_symbols</code></td>
<td>
<p>If set to <code>TRUE</code> (default), symbol info present in
the <a href="#topic+mkinmod">mkinmod</a> object is used if available for accessing compiled code</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_method.ode">method.ode</code></td>
<td>
<p>The solution method passed via <a href="#topic+mkinpredict">mkinpredict</a> to <a href="deSolve.html#topic+ode">ode</a>] in
case the solution type is &quot;deSolve&quot; and we are not using compiled code.
When using compiled code, only lsoda is supported.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_atol">atol</code></td>
<td>
<p>Absolute error tolerance, passed to the ode solver.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_rtol">rtol</code></td>
<td>
<p>Absolute error tolerance, passed to the ode solver.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_maxsteps">maxsteps</code></td>
<td>
<p>Maximum number of steps, passed to the ode solver.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_map_output">map_output</code></td>
<td>
<p>Boolean to specify if the output should list values for
the observed variables (default) or for all state variables (if set to
FALSE). Setting this to FALSE has no effect for analytical solutions,
as these always return mapped output.</p>
</td></tr>
<tr><td><code id="mkinpredict_+3A_na_stop">na_stop</code></td>
<td>
<p>Should it be an error if <a href="deSolve.html#topic+ode">ode</a> returns NaN values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the numeric solution in wide format
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SFO &lt;- mkinmod(degradinol = mkinsub("SFO"))
# Compare solution types
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      solution_type = "analytical")
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      solution_type = "deSolve")
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      solution_type = "deSolve", use_compiled = FALSE)
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      solution_type = "eigen")

# Compare integration methods to analytical solution
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      solution_type = "analytical")[21,]
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      method = "lsoda", use_compiled = FALSE)[21,]
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      method = "ode45", use_compiled = FALSE)[21,]
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100), 0:20,
      method = "rk4", use_compiled = FALSE)[21,]
# rk4 is not as precise here

# The number of output times used to make a lot of difference until the
# default for atol was adjusted
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100),
      seq(0, 20, by = 0.1))[201,]
mkinpredict(SFO, c(k_degradinol = 0.3), c(degradinol = 100),
      seq(0, 20, by = 0.01))[2001,]

# Comparison of the performance of solution types
SFO_SFO = mkinmod(parent = list(type = "SFO", to = "m1"),
                  m1 = list(type = "SFO"), use_of_ff = "max")
if(require(rbenchmark)) {
  benchmark(replications = 10, order = "relative", columns = c("test", "relative", "elapsed"),
    eigen = mkinpredict(SFO_SFO,
      c(k_parent = 0.15, f_parent_to_m1 = 0.5, k_m1 = 0.01),
      c(parent = 100, m1 = 0), seq(0, 20, by = 0.1),
      solution_type = "eigen")[201,],
    deSolve_compiled = mkinpredict(SFO_SFO,
      c(k_parent = 0.15, f_parent_to_m1 = 0.5, k_m1 = 0.01),
      c(parent = 100, m1 = 0), seq(0, 20, by = 0.1),
      solution_type = "deSolve")[201,],
    deSolve = mkinpredict(SFO_SFO,
      c(k_parent = 0.15, f_parent_to_m1 = 0.5, k_m1 = 0.01),
      c(parent = 100, m1 = 0), seq(0, 20, by = 0.1),
      solution_type = "deSolve", use_compiled = FALSE)[201,],
    analytical = mkinpredict(SFO_SFO,
      c(k_parent = 0.15, f_parent_to_m1 = 0.5, k_m1 = 0.01),
      c(parent = 100, m1 = 0), seq(0, 20, by = 0.1),
      solution_type = "analytical", use_compiled = FALSE)[201,])
}

## Not run: 
  # Predict from a fitted model
  f &lt;- mkinfit(SFO_SFO, FOCUS_2006_C, quiet = TRUE)
  f &lt;- mkinfit(SFO_SFO, FOCUS_2006_C, quiet = TRUE, solution_type = "deSolve")
  head(mkinpredict(f))

## End(Not run)

</code></pre>

<hr>
<h2 id='mkinresplot'>Function to plot residuals stored in an mkin object</h2><span id='topic+mkinresplot'></span>

<h3>Description</h3>

<p>This function plots the residuals for the specified subset of the observed
variables from an mkinfit object. A combined plot of the fitted model and
the residuals can be obtained using <code><a href="#topic+plot.mkinfit">plot.mkinfit</a></code> using the
argument <code>show_residuals = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkinresplot(
  object,
  obs_vars = names(object$mkinmod$map),
  xlim = c(0, 1.1 * max(object$data$time)),
  standardized = FALSE,
  xlab = "Time",
  ylab = ifelse(standardized, "Standardized residual", "Residual"),
  maxabs = "auto",
  legend = TRUE,
  lpos = "topright",
  col_obs = "auto",
  pch_obs = "auto",
  frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkinresplot_+3A_object">object</code></td>
<td>
<p>A fit represented in an <code><a href="#topic+mkinfit">mkinfit</a></code> object.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_obs_vars">obs_vars</code></td>
<td>
<p>A character vector of names of the observed variables for
which residuals should be plotted. Defaults to all observed variables in
the model</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_xlim">xlim</code></td>
<td>
<p>plot range in x direction.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_standardized">standardized</code></td>
<td>
<p>Should the residuals be standardized by dividing by the
standard deviation given by the error model of the fit?</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x axis.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y axis.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_maxabs">maxabs</code></td>
<td>
<p>Maximum absolute value of the residuals. This is used for the
scaling of the y axis and defaults to &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_legend">legend</code></td>
<td>
<p>Should a legend be plotted?</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_lpos">lpos</code></td>
<td>
<p>Where should the legend be placed? Default is &quot;topright&quot;. Will
be passed on to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_col_obs">col_obs</code></td>
<td>
<p>Colors for the observed variables.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_pch_obs">pch_obs</code></td>
<td>
<p>Symbols to be used for the observed variables.</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_frame">frame</code></td>
<td>
<p>Should a frame be drawn around the plots?</p>
</td></tr>
<tr><td><code id="mkinresplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned by this function, as it is called for its side
effect, namely to produce a plot.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke and Katrin Lindenberger
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkinplot">mkinplot</a></code>, for a way to plot the data and the fitted
lines of the mkinfit object, and <code><a href="#topic+plot_res">plot_res</a></code> for a function
combining the plot of the fit and the residual plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- mkinmod(parent = mkinsub("SFO", "m1"), m1 = mkinsub("SFO"))
fit &lt;- mkinfit(model, FOCUS_2006_D, quiet = TRUE)
mkinresplot(fit, "m1")

</code></pre>

<hr>
<h2 id='mmkin'>Fit one or more kinetic models with one or more state variables to one or
more datasets</h2><span id='topic+mmkin'></span><span id='topic+print.mmkin'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+mkinfit">mkinfit</a></code> on all combinations of models and
datasets specified in its first two arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmkin(
  models = c("SFO", "FOMC", "DFOP"),
  datasets,
  cores = if (Sys.info()["sysname"] == "Windows") 1 else parallel::detectCores(),
  cluster = NULL,
  ...
)

## S3 method for class 'mmkin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmkin_+3A_models">models</code></td>
<td>
<p>Either a character vector of shorthand names like
<code>c("SFO", "FOMC", "DFOP", "HS", "SFORB")</code>, or an optionally named
list of <code><a href="#topic+mkinmod">mkinmod</a></code> objects.</p>
</td></tr>
<tr><td><code id="mmkin_+3A_datasets">datasets</code></td>
<td>
<p>An optionally named list of datasets suitable as observed
data for <code><a href="#topic+mkinfit">mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="mmkin_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for multicore processing. This
is only used when the <code>cluster</code> argument is <code>NULL</code>. On Windows
machines, cores &gt; 1 is not supported, you need to use the <code>cluster</code>
argument to use multiple logical processors. Per default, all cores
detected by <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code> are used, except on Windows where
the default is 1.</p>
</td></tr>
<tr><td><code id="mmkin_+3A_cluster">cluster</code></td>
<td>
<p>A cluster as returned by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> to be used
for parallel execution.</p>
</td></tr>
<tr><td><code id="mmkin_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mmkin_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+mmkin">mmkin</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-dimensional <code><a href="base.html#topic+array">array</a></code> of <code><a href="#topic+mkinfit">mkinfit</a></code>
objects and/or try-errors that can be indexed using the model names for the
first index (row index) and the dataset names for the second index (column
index).
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>See Also</h3>

<p><code><a href="#topic++5B.mmkin">[.mmkin</a></code> for subsetting, <code><a href="#topic+plot.mmkin">plot.mmkin</a></code> for
plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
m_synth_SFO_lin &lt;- mkinmod(parent = mkinsub("SFO", "M1"),
                           M1 = mkinsub("SFO", "M2"),
                           M2 = mkinsub("SFO"), use_of_ff = "max")

m_synth_FOMC_lin &lt;- mkinmod(parent = mkinsub("FOMC", "M1"),
                            M1 = mkinsub("SFO", "M2"),
                            M2 = mkinsub("SFO"), use_of_ff = "max")

models &lt;- list(SFO_lin = m_synth_SFO_lin, FOMC_lin = m_synth_FOMC_lin)
datasets &lt;- lapply(synthetic_data_for_UBA_2014[1:3], function(x) x$data)
names(datasets) &lt;- paste("Dataset", 1:3)

time_default &lt;- system.time(fits.0 &lt;- mmkin(models, datasets, quiet = TRUE))
time_1 &lt;- system.time(fits.4 &lt;- mmkin(models, datasets, cores = 1, quiet = TRUE))

time_default
time_1

endpoints(fits.0[["SFO_lin", 2]])

# plot.mkinfit handles rows or columns of mmkin result objects
plot(fits.0[1, ])
plot(fits.0[1, ], obs_var = c("M1", "M2"))
plot(fits.0[, 1])
# Use double brackets to extract a single mkinfit object, which will be plotted
# by plot.mkinfit and can be plotted using plot_sep
plot(fits.0[[1, 1]], sep_obs = TRUE, show_residuals = TRUE, show_errmin = TRUE)
plot_sep(fits.0[[1, 1]])
# Plotting with mmkin (single brackets, extracting an mmkin object) does not
# allow to plot the observed variables separately
plot(fits.0[1, 1])

# On Windows, we can use multiple cores by making a cluster first
cl &lt;- parallel::makePSOCKcluster(12)
f &lt;- mmkin(c("SFO", "FOMC", "DFOP"),
  list(A = FOCUS_2006_A, B = FOCUS_2006_B, C = FOCUS_2006_C, D = FOCUS_2006_D),
  cluster = cl, quiet = TRUE)
print(f)
# We get false convergence for the FOMC fit to FOCUS_2006_A because this
# dataset is really SFO, and the FOMC fit is overparameterised
parallel::stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='multistart'>Perform a hierarchical model fit with multiple starting values</h2><span id='topic+multistart'></span><span id='topic+multistart.saem.mmkin'></span><span id='topic+print.multistart'></span><span id='topic+best'></span><span id='topic+best.default'></span><span id='topic+which.best'></span><span id='topic+which.best.default'></span>

<h3>Description</h3>

<p>The purpose of this method is to check if a certain algorithm for fitting
nonlinear hierarchical models (also known as nonlinear mixed-effects models)
will reliably yield results that are sufficiently similar to each other, if
started with a certain range of reasonable starting parameters. It is
inspired by the article on practical identifiabiliy in the frame of nonlinear
mixed-effects models by Duchesne et al (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multistart(
  object,
  n = 50,
  cores = if (Sys.info()["sysname"] == "Windows") 1 else parallel::detectCores(),
  cluster = NULL,
  ...
)

## S3 method for class 'saem.mmkin'
multistart(object, n = 50, cores = 1, cluster = NULL, ...)

## S3 method for class 'multistart'
print(x, ...)

best(object, ...)

## Default S3 method:
best(object, ...)

which.best(object, ...)

## Default S3 method:
which.best(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multistart_+3A_object">object</code></td>
<td>
<p>The fit object to work with</p>
</td></tr>
<tr><td><code id="multistart_+3A_n">n</code></td>
<td>
<p>How many different combinations of starting parameters should be
used?</p>
</td></tr>
<tr><td><code id="multistart_+3A_cores">cores</code></td>
<td>
<p>How many fits should be run in parallel (only on posix platforms)?</p>
</td></tr>
<tr><td><code id="multistart_+3A_cluster">cluster</code></td>
<td>
<p>A cluster as returned by <a href="parallel.html#topic+makeCluster">parallel::makeCluster</a> to be used
for parallel execution.</p>
</td></tr>
<tr><td><code id="multistart_+3A_...">...</code></td>
<td>
<p>Passed to the update function.</p>
</td></tr>
<tr><td><code id="multistart_+3A_x">x</code></td>
<td>
<p>The multistart object to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <a href="#topic+saem.mmkin">saem.mmkin</a> objects, with class attributes
'multistart.saem.mmkin' and 'multistart'.
</p>
<p>The object with the highest likelihood
</p>
<p>The index of the object with the highest likelihood
</p>


<h3>References</h3>

<p>Duchesne R, Guillemin A, Gandrillon O, Crauste F. Practical
identifiability in the frame of nonlinear mixed effects models: the example
of the in vitro erythropoiesis. BMC Bioinformatics. 2021 Oct 4;22(1):478.
doi: 10.1186/s12859-021-04373-4.
</p>


<h3>See Also</h3>

<p><a href="#topic+parplot">parplot</a>, <a href="#topic+llhist">llhist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mkin)
dmta_ds &lt;- lapply(1:7, function(i) {
  ds_i &lt;- dimethenamid_2018$ds[[i]]$data
  ds_i[ds_i$name == "DMTAP", "name"] &lt;-  "DMTA"
  ds_i$time &lt;- ds_i$time * dimethenamid_2018$f_time_norm[i]
  ds_i
})
names(dmta_ds) &lt;- sapply(dimethenamid_2018$ds, function(ds) ds$title)
dmta_ds[["Elliot"]] &lt;- rbind(dmta_ds[["Elliot 1"]], dmta_ds[["Elliot 2"]])
dmta_ds[["Elliot 1"]] &lt;- dmta_ds[["Elliot 2"]] &lt;- NULL

f_mmkin &lt;- mmkin("DFOP", dmta_ds, error_model = "tc", cores = 7, quiet = TRUE)
f_saem_full &lt;- saem(f_mmkin)
f_saem_full_multi &lt;- multistart(f_saem_full, n = 16, cores = 16)
parplot(f_saem_full_multi, lpos = "topleft")
illparms(f_saem_full)

f_saem_reduced &lt;- update(f_saem_full, no_random_effect = "log_k2")
illparms(f_saem_reduced)
# On Windows, we need to create a PSOCK cluster first and refer to it
# in the call to multistart()
library(parallel)
cl &lt;- makePSOCKcluster(12)
f_saem_reduced_multi &lt;- multistart(f_saem_reduced, n = 16, cluster = cl)
parplot(f_saem_reduced_multi, lpos = "topright", ylim = c(0.5, 2))
stopCluster(cl)

## End(Not run)
</code></pre>

<hr>
<h2 id='nafta'>Evaluate parent kinetics using the NAFTA guidance</h2><span id='topic+nafta'></span><span id='topic+print.nafta'></span>

<h3>Description</h3>

<p>The function fits the SFO, IORE and DFOP models using <code><a href="#topic+mmkin">mmkin</a></code>
and returns an object of class <code>nafta</code> that has methods for printing
and plotting.
</p>
<p>Print nafta objects. The results for the three models are printed in the
order of increasing model complexity, i.e. SFO, then IORE, and finally DFOP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nafta(ds, title = NA, quiet = FALSE, ...)

## S3 method for class 'nafta'
print(x, quiet = TRUE, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nafta_+3A_ds">ds</code></td>
<td>
<p>A dataframe that must contain one variable called &quot;time&quot; with the
time values specified by the <code>time</code> argument, one column called
&quot;name&quot; with the grouping of the observed values, and finally one column of
observed values called &quot;value&quot;.</p>
</td></tr>
<tr><td><code id="nafta_+3A_title">title</code></td>
<td>
<p>Optional title of the dataset</p>
</td></tr>
<tr><td><code id="nafta_+3A_quiet">quiet</code></td>
<td>
<p>Should the evaluation text be shown?</p>
</td></tr>
<tr><td><code id="nafta_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+mmkin">mmkin</a></code> (not for the
printing method).</p>
</td></tr>
<tr><td><code id="nafta_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+nafta">nafta</a></code> object.</p>
</td></tr>
<tr><td><code id="nafta_+3A_digits">digits</code></td>
<td>
<p>Number of digits to be used for printing parameters and
dissipation times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list of class <code>nafta</code>. The list element named &quot;mmkin&quot; is the
<code><a href="#topic+mmkin">mmkin</a></code> object containing the fits of the three models. The
list element named &quot;title&quot; contains the title of the dataset used. The
list element &quot;data&quot; contains the dataset used in the fits.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Source</h3>

<p>NAFTA (2011) Guidance for evaluating and calculating degradation
kinetics in environmental media. NAFTA Technical Working Group on
Pesticides
<a href="https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/guidance-evaluating-and-calculating-degradation">https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/guidance-evaluating-and-calculating-degradation</a>
accessed 2019-02-22
</p>
<p>US EPA (2015) Standard Operating Procedure for Using the NAFTA Guidance to
Calculate Representative Half-life Values and Characterizing Pesticide
Degradation
<a href="https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/standard-operating-procedure-using-nafta-guidance">https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/standard-operating-procedure-using-nafta-guidance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  nafta_evaluation &lt;- nafta(NAFTA_SOP_Appendix_D, cores = 1)
  print(nafta_evaluation)
  plot(nafta_evaluation)

</code></pre>

<hr>
<h2 id='NAFTA_SOP_2015'>
Example datasets from the NAFTA SOP published 2015
</h2><span id='topic+NAFTA_SOP_Appendix_B'></span><span id='topic+NAFTA_SOP_Appendix_D'></span>

<h3>Description</h3>

<p>Data taken from US EPA (2015), p. 19 and 23.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  NAFTA_SOP_Appendix_B
  NAFTA_SOP_Appendix_D
</code></pre>


<h3>Format</h3>

<p>2 datasets with observations on the following variables.
</p>

<dl>
<dt><code>name</code></dt><dd><p>a factor containing the name of the observed variable</p>
</dd>
<dt><code>time</code></dt><dd><p>a numeric vector containing time points</p>
</dd>
<dt><code>value</code></dt><dd><p>a numeric vector containing concentrations</p>
</dd>
</dl>



<h3>Source</h3>

<p>NAFTA (2011) Guidance for evaluating and calculating degradation kinetics
in environmental media. NAFTA Technical Working Group on Pesticides
<a href="https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/guidance-evaluating-and-calculating-degradation">https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/guidance-evaluating-and-calculating-degradation</a>
accessed 2019-02-22
</p>
<p>US EPA (2015) Standard Operating Procedure for Using the NAFTA Guidance to
Calculate Representative Half-life Values and Characterizing Pesticide
Degradation
<a href="https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/standard-operating-procedure-using-nafta-guidance">https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/standard-operating-procedure-using-nafta-guidance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nafta_evaluation &lt;- nafta(NAFTA_SOP_Appendix_D, cores = 1)
  print(nafta_evaluation)
  plot(nafta_evaluation)
</code></pre>

<hr>
<h2 id='NAFTA_SOP_Attachment'>
Example datasets from Attachment 1 to the NAFTA SOP published 2015
</h2><span id='topic+NAFTA_SOP_Attachment'></span>

<h3>Description</h3>

<p>Data taken from from Attachment 1 of the SOP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NAFTA_SOP_Attachment</code></pre>


<h3>Format</h3>

<p>A list (NAFTA_SOP_Attachment) containing 16 datasets suitable
for the evaluation with <code><a href="#topic+nafta">nafta</a></code>
</p>


<h3>Source</h3>

<p>NAFTA (2011) Guidance for evaluating and calculating degradation kinetics
in environmental media. NAFTA Technical Working Group on Pesticides
<a href="https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/guidance-evaluating-and-calculating-degradation">https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/guidance-evaluating-and-calculating-degradation</a>
accessed 2019-02-22
</p>
<p>US EPA (2015) Standard Operating Procedure for Using the NAFTA Guidance to
Calculate Representative Half-life Values and Characterizing Pesticide
Degradation
<a href="https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/standard-operating-procedure-using-nafta-guidance">https://www.epa.gov/pesticide-science-and-assessing-pesticide-risks/standard-operating-procedure-using-nafta-guidance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nafta_att_p5a &lt;- nafta(NAFTA_SOP_Attachment[["p5a"]], cores = 1)
  print(nafta_att_p5a)
  plot(nafta_att_p5a)
</code></pre>

<hr>
<h2 id='nlme_function'>Helper functions to create nlme models from mmkin row objects</h2><span id='topic+nlme_function'></span><span id='topic+nlme_data'></span>

<h3>Description</h3>

<p>These functions facilitate setting up a nonlinear mixed effects model for
an mmkin row object. An mmkin row object is essentially a list of mkinfit
objects that have been obtained by fitting the same model to a list of
datasets. They are used internally by the <code><a href="#topic+nlme.mmkin">nlme.mmkin()</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlme_function(object)

nlme_data(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlme_function_+3A_object">object</code></td>
<td>
<p>An mmkin row object containing several fits of the same model to different datasets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that can be used with nlme
</p>
<p>A <code><a href="nlme.html#topic+groupedData">groupedData</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme.mmkin">nlme.mmkin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)
m_SFO &lt;- mkinmod(parent = mkinsub("SFO"))
d_SFO_1 &lt;- mkinpredict(m_SFO,
  c(k_parent = 0.1),
  c(parent = 98), sampling_times)
d_SFO_1_long &lt;- mkin_wide_to_long(d_SFO_1, time = "time")
d_SFO_2 &lt;- mkinpredict(m_SFO,
  c(k_parent = 0.05),
  c(parent = 102), sampling_times)
d_SFO_2_long &lt;- mkin_wide_to_long(d_SFO_2, time = "time")
d_SFO_3 &lt;- mkinpredict(m_SFO,
  c(k_parent = 0.02),
  c(parent = 103), sampling_times)
d_SFO_3_long &lt;- mkin_wide_to_long(d_SFO_3, time = "time")

d1 &lt;- add_err(d_SFO_1, function(value) 3, n = 1)
d2 &lt;- add_err(d_SFO_2, function(value) 2, n = 1)
d3 &lt;- add_err(d_SFO_3, function(value) 4, n = 1)
ds &lt;- c(d1 = d1, d2 = d2, d3 = d3)

f &lt;- mmkin("SFO", ds, cores = 1, quiet = TRUE)
mean_dp &lt;- mean_degparms(f)
grouped_data &lt;- nlme_data(f)
nlme_f &lt;- nlme_function(f)
# These assignments are necessary for these objects to be
# visible to nlme and augPred when evaluation is done by
# pkgdown to generate the html docs.
assign("nlme_f", nlme_f, globalenv())
assign("grouped_data", grouped_data, globalenv())

library(nlme)
m_nlme &lt;- nlme(value ~ nlme_f(name, time, parent_0, log_k_parent_sink),
  data = grouped_data,
  fixed = parent_0 + log_k_parent_sink ~ 1,
  random = pdDiag(parent_0 + log_k_parent_sink ~ 1),
  start = mean_dp)
summary(m_nlme)
plot(augPred(m_nlme, level = 0:1), layout = c(3, 1))
# augPred does not work on fits with more than one state
# variable
#
# The procedure is greatly simplified by the nlme.mmkin function
f_nlme &lt;- nlme(f)
plot(f_nlme)
</code></pre>

<hr>
<h2 id='nlme.mmkin'>Create an nlme model for an mmkin row object</h2><span id='topic+nlme.mmkin'></span><span id='topic+print.nlme.mmkin'></span><span id='topic+update.nlme.mmkin'></span>

<h3>Description</h3>

<p>This functions sets up a nonlinear mixed effects model for an mmkin row
object. An mmkin row object is essentially a list of mkinfit objects that
have been obtained by fitting the same model to a list of datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmkin'
nlme(
  model,
  data = "auto",
  fixed = lapply(as.list(names(mean_degparms(model))), function(el) eval(parse(text =
    paste(el, 1, sep = "~")))),
  random = pdDiag(fixed),
  groups,
  start = mean_degparms(model, random = TRUE, test_log_parms = TRUE),
  correlation = NULL,
  weights = NULL,
  subset,
  method = c("ML", "REML"),
  na.action = na.fail,
  naPattern,
  control = list(),
  verbose = FALSE
)

## S3 method for class 'nlme.mmkin'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'nlme.mmkin'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlme.mmkin_+3A_model">model</code></td>
<td>
<p>An <a href="#topic+mmkin">mmkin</a> row object.</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_data">data</code></td>
<td>
<p>Ignored, data are taken from the mmkin model</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_fixed">fixed</code></td>
<td>
<p>Ignored, all degradation parameters fitted in the
mmkin model are used as fixed parameters</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_random">random</code></td>
<td>
<p>If not specified, no correlations between random effects are
set up for the optimised degradation model parameters. This is
achieved by using the <a href="nlme.html#topic+pdDiag">nlme::pdDiag</a> method.</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_groups">groups</code></td>
<td>
<p>See the documentation of nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_start">start</code></td>
<td>
<p>If not specified, mean values of the fitted degradation
parameters taken from the mmkin object are used</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_correlation">correlation</code></td>
<td>
<p>See the documentation of nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_weights">weights</code></td>
<td>
<p>passed to nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_subset">subset</code></td>
<td>
<p>passed to nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_method">method</code></td>
<td>
<p>passed to nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_na.action">na.action</code></td>
<td>
<p>passed to nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_napattern">naPattern</code></td>
<td>
<p>passed to nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_control">control</code></td>
<td>
<p>passed to nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_verbose">verbose</code></td>
<td>
<p>passed to nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_x">x</code></td>
<td>
<p>An nlme.mmkin object to print</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for printing</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_...">...</code></td>
<td>
<p>Update specifications passed to update.nlme</p>
</td></tr>
<tr><td><code id="nlme.mmkin_+3A_object">object</code></td>
<td>
<p>An nlme.mmkin object to update</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the convergence of the nlme algorithms depends on the quality
of the data. In degradation kinetics, we often only have few datasets
(e.g. data for few soils) and complicated degradation models, which may
make it impossible to obtain convergence with nlme.
</p>


<h3>Value</h3>

<p>Upon success, a fitted 'nlme.mmkin' object, which is an nlme object
with additional elements. It also inherits from 'mixed.mmkin'.
</p>


<h3>Note</h3>

<p>As the object inherits from <a href="nlme.html#topic+nlme">nlme::nlme</a>, there is a wealth of
methods that will automatically work on 'nlme.mmkin' objects, such as
<code><a href="nlme.html#topic+intervals">nlme::intervals()</a></code>, <code><a href="nlme.html#topic+anova.lme">nlme::anova.lme()</a></code> and <code><a href="nlme.html#topic+coef.lme">nlme::coef.lme()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme_function">nlme_function()</a></code>, <a href="#topic+plot.mixed.mmkin">plot.mixed.mmkin</a>, <a href="#topic+summary.nlme.mmkin">summary.nlme.mmkin</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- lapply(experimental_data_for_UBA_2019[6:10],
 function(x) subset(x$data[c("name", "time", "value")], name == "parent"))

## Not run: 
  f &lt;- mmkin(c("SFO", "DFOP"), ds, quiet = TRUE, cores = 1)
  library(nlme)
  f_nlme_sfo &lt;- nlme(f["SFO", ])
  f_nlme_dfop &lt;- nlme(f["DFOP", ])
  anova(f_nlme_sfo, f_nlme_dfop)
  print(f_nlme_dfop)
  plot(f_nlme_dfop)
  endpoints(f_nlme_dfop)

  ds_2 &lt;- lapply(experimental_data_for_UBA_2019[6:10],
   function(x) x$data[c("name", "time", "value")])
  m_sfo_sfo &lt;- mkinmod(parent = mkinsub("SFO", "A1"),
    A1 = mkinsub("SFO"), use_of_ff = "min", quiet = TRUE)
  m_sfo_sfo_ff &lt;- mkinmod(parent = mkinsub("SFO", "A1"),
    A1 = mkinsub("SFO"), use_of_ff = "max", quiet = TRUE)
  m_dfop_sfo &lt;- mkinmod(parent = mkinsub("DFOP", "A1"),
    A1 = mkinsub("SFO"), quiet = TRUE)

  f_2 &lt;- mmkin(list("SFO-SFO" = m_sfo_sfo,
   "SFO-SFO-ff" = m_sfo_sfo_ff,
   "DFOP-SFO" = m_dfop_sfo),
    ds_2, quiet = TRUE)

  f_nlme_sfo_sfo &lt;- nlme(f_2["SFO-SFO", ])
  plot(f_nlme_sfo_sfo)

  # With formation fractions this does not coverge with defaults
  # f_nlme_sfo_sfo_ff &lt;- nlme(f_2["SFO-SFO-ff", ])
  #plot(f_nlme_sfo_sfo_ff)

  # For the following, we need to increase pnlsMaxIter and the tolerance
  # to get convergence
  f_nlme_dfop_sfo &lt;- nlme(f_2["DFOP-SFO", ],
    control = list(pnlsMaxIter = 120, tolerance = 5e-4))

  plot(f_nlme_dfop_sfo)

  anova(f_nlme_dfop_sfo, f_nlme_sfo_sfo)

  endpoints(f_nlme_sfo_sfo)
  endpoints(f_nlme_dfop_sfo)

  if (length(findFunction("varConstProp")) &gt; 0) { # tc error model for nlme available
    # Attempts to fit metabolite kinetics with the tc error model are possible,
    # but need tweeking of control values and sometimes do not converge

    f_tc &lt;- mmkin(c("SFO", "DFOP"), ds, quiet = TRUE, error_model = "tc")
    f_nlme_sfo_tc &lt;- nlme(f_tc["SFO", ])
    f_nlme_dfop_tc &lt;- nlme(f_tc["DFOP", ])
    AIC(f_nlme_sfo, f_nlme_sfo_tc, f_nlme_dfop, f_nlme_dfop_tc)
    print(f_nlme_dfop_tc)
  }

  f_2_obs &lt;- update(f_2, error_model = "obs")
  f_nlme_sfo_sfo_obs &lt;- nlme(f_2_obs["SFO-SFO", ])
  print(f_nlme_sfo_sfo_obs)
  f_nlme_dfop_sfo_obs &lt;- nlme(f_2_obs["DFOP-SFO", ],
    control = list(pnlsMaxIter = 120, tolerance = 5e-4))

  f_2_tc &lt;- update(f_2, error_model = "tc")
  # f_nlme_sfo_sfo_tc &lt;- nlme(f_2_tc["SFO-SFO", ]) # No convergence with 50 iterations
  # f_nlme_dfop_sfo_tc &lt;- nlme(f_2_tc["DFOP-SFO", ],
  #  control = list(pnlsMaxIter = 120, tolerance = 5e-4)) # Error in X[, fmap[[nm]]] &lt;- gradnm

  anova(f_nlme_dfop_sfo, f_nlme_dfop_sfo_obs)


## End(Not run)
</code></pre>

<hr>
<h2 id='nobs.mkinfit'>Number of observations on which an mkinfit object was fitted</h2><span id='topic+nobs.mkinfit'></span>

<h3>Description</h3>

<p>Number of observations on which an mkinfit object was fitted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.mkinfit_+3A_object">object</code></td>
<td>
<p>An mkinfit object</p>
</td></tr>
<tr><td><code id="nobs.mkinfit_+3A_...">...</code></td>
<td>
<p>For compatibility with the generic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of rows in the data included in the mkinfit object
</p>

<hr>
<h2 id='parms'>Extract model parameters</h2><span id='topic+parms'></span><span id='topic+parms.mkinfit'></span><span id='topic+parms.mmkin'></span><span id='topic+parms.multistart'></span><span id='topic+parms.saem.mmkin'></span>

<h3>Description</h3>

<p>This function returns degradation model parameters as well as error
model parameters per default, in order to avoid working with a fitted model
without considering the error structure that was assumed for the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parms(object, ...)

## S3 method for class 'mkinfit'
parms(object, transformed = FALSE, errparms = TRUE, ...)

## S3 method for class 'mmkin'
parms(object, transformed = FALSE, errparms = TRUE, ...)

## S3 method for class 'multistart'
parms(object, exclude_failed = TRUE, ...)

## S3 method for class 'saem.mmkin'
parms(object, ci = FALSE, covariates = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parms_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="parms_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="parms_+3A_transformed">transformed</code></td>
<td>
<p>Should the parameters be returned as used internally
during the optimisation?</p>
</td></tr>
<tr><td><code id="parms_+3A_errparms">errparms</code></td>
<td>
<p>Should the error model parameters be returned
in addition to the degradation parameters?</p>
</td></tr>
<tr><td><code id="parms_+3A_exclude_failed">exclude_failed</code></td>
<td>
<p>For <a href="#topic+multistart">multistart</a> objects, should rows for failed fits
be removed from the returned parameter matrix?</p>
</td></tr>
<tr><td><code id="parms_+3A_ci">ci</code></td>
<td>
<p>Should a matrix with estimates and confidence interval boundaries
be returned? If FALSE (default), a vector of estimates is returned if no
covariates are given, otherwise a matrix of estimates is returned, with
each column corresponding to a row of the data frame holding the covariates</p>
</td></tr>
<tr><td><code id="parms_+3A_covariates">covariates</code></td>
<td>
<p>A data frame holding covariate values for which to
return parameter values. Only has an effect if 'ci' is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the object, a numeric vector of fitted model parameters,
a matrix (e.g. for mmkin row objects), or a list of matrices (e.g. for
mmkin objects with more than one row).
</p>


<h3>See Also</h3>

<p><a href="#topic+saem">saem</a>, <a href="#topic+multistart">multistart</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mkinfit objects
fit &lt;- mkinfit("SFO", FOCUS_2006_C, quiet = TRUE)
parms(fit)
parms(fit, transformed = TRUE)

# mmkin objects
ds &lt;- lapply(experimental_data_for_UBA_2019[6:10],
 function(x) subset(x$data[c("name", "time", "value")]))
names(ds) &lt;- paste("Dataset", 6:10)
## Not run: 
fits &lt;- mmkin(c("SFO", "FOMC", "DFOP"), ds, quiet = TRUE, cores = 1)
parms(fits["SFO", ])
parms(fits[, 2])
parms(fits)
parms(fits, transformed = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='parplot'>Plot parameter variability of multistart objects</h2><span id='topic+parplot'></span><span id='topic+parplot.multistart.saem.mmkin'></span>

<h3>Description</h3>

<p>Produces a boxplot with all parameters from the multiple runs, scaled
either by the parameters of the run with the highest likelihood,
or by their medians as proposed in the paper by Duchesne et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parplot(object, ...)

## S3 method for class 'multistart.saem.mmkin'
parplot(
  object,
  llmin = -Inf,
  llquant = NA,
  scale = c("best", "median"),
  lpos = "bottomleft",
  main = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parplot_+3A_object">object</code></td>
<td>
<p>The <a href="#topic+multistart">multistart</a> object</p>
</td></tr>
<tr><td><code id="parplot_+3A_...">...</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+boxplot">boxplot</a></p>
</td></tr>
<tr><td><code id="parplot_+3A_llmin">llmin</code></td>
<td>
<p>The minimum likelihood of objects to be shown</p>
</td></tr>
<tr><td><code id="parplot_+3A_llquant">llquant</code></td>
<td>
<p>Fractional value for selecting only the fits with higher
likelihoods. Overrides 'llmin'.</p>
</td></tr>
<tr><td><code id="parplot_+3A_scale">scale</code></td>
<td>
<p>By default, scale parameters using the best
available fit.
If 'median', parameters are scaled using the median parameters from all fits.</p>
</td></tr>
<tr><td><code id="parplot_+3A_lpos">lpos</code></td>
<td>
<p>Positioning of the legend.</p>
</td></tr>
<tr><td><code id="parplot_+3A_main">main</code></td>
<td>
<p>Title of the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting values of degradation model parameters and error model parameters
are shown as green circles. The results obtained in the original run
are shown as red circles.
</p>


<h3>References</h3>

<p>Duchesne R, Guillemin A, Gandrillon O, Crauste F. Practical
identifiability in the frame of nonlinear mixed effects models: the example
of the in vitro erythropoiesis. BMC Bioinformatics. 2021 Oct 4;22(1):478.
doi: 10.1186/s12859-021-04373-4.
</p>


<h3>See Also</h3>

<p><a href="#topic+multistart">multistart</a>
</p>

<hr>
<h2 id='plot.mixed.mmkin'>Plot predictions from a fitted nonlinear mixed model obtained via an mmkin row object</h2><span id='topic+plot.mixed.mmkin'></span>

<h3>Description</h3>

<p>Plot predictions from a fitted nonlinear mixed model obtained via an mmkin row object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixed.mmkin'
plot(
  x,
  i = 1:ncol(x$mmkin),
  obs_vars = names(x$mkinmod$map),
  standardized = TRUE,
  covariates = NULL,
  covariate_quantiles = c(0.5, 0.05, 0.95),
  xlab = "Time",
  xlim = range(x$data$time),
  resplot = c("predicted", "time"),
  pop_curves = "auto",
  pred_over = NULL,
  test_log_parms = FALSE,
  conf.level = 0.6,
  default_log_parms = NA,
  ymax = "auto",
  maxabs = "auto",
  ncol.legend = ifelse(length(i) &lt;= 3, length(i) + 1, ifelse(length(i) &lt;= 8, 3, 4)),
  nrow.legend = ceiling((length(i) + 1)/ncol.legend),
  rel.height.legend = 0.02 + 0.07 * nrow.legend,
  rel.height.bottom = 1.1,
  pch_ds = 1:length(i),
  col_ds = pch_ds + 1,
  lty_ds = col_ds,
  frame = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mixed.mmkin_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+mixed.mmkin">mixed.mmkin</a>, <a href="#topic+saem.mmkin">saem.mmkin</a> or <a href="#topic+nlme.mmkin">nlme.mmkin</a></p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_i">i</code></td>
<td>
<p>A numeric index to select datasets for which to plot the individual predictions,
in case plots get too large</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_obs_vars">obs_vars</code></td>
<td>
<p>A character vector of names of the observed variables for
which the data and the model should be plotted. Defauls to all observed
variables in the model.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_standardized">standardized</code></td>
<td>
<p>Should the residuals be standardized? Only takes effect if
<code>resplot = "time"</code>.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_covariates">covariates</code></td>
<td>
<p>Data frame with covariate values for all variables in
any covariate models in the object. If given, it overrides 'covariate_quantiles'.
Each line in the data frame will result in a line drawn for the population.
Rownames are used in the legend to label the lines.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_covariate_quantiles">covariate_quantiles</code></td>
<td>
<p>This argument only has an effect if the fitted
object has covariate models. If so, the default is to show three population
curves, for the 5th percentile, the 50th percentile and the 95th percentile
of the covariate values used for fitting the model.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_xlim">xlim</code></td>
<td>
<p>Plot range in x direction.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_resplot">resplot</code></td>
<td>
<p>Should the residuals plotted against time or against
predicted values?</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_pop_curves">pop_curves</code></td>
<td>
<p>Per default, one population curve is drawn in case
population parameters are fitted by the model, e.g. for saem objects.
In case there is a covariate model, the behaviour depends on the value
of 'covariates'</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_pred_over">pred_over</code></td>
<td>
<p>Named list of alternative predictions as obtained
from <a href="#topic+mkinpredict">mkinpredict</a> with a compatible <a href="#topic+mkinmod">mkinmod</a>.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_test_log_parms">test_log_parms</code></td>
<td>
<p>Passed to <a href="#topic+mean_degparms">mean_degparms</a> in the case of an
<a href="#topic+mixed.mmkin">mixed.mmkin</a> object</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_conf.level">conf.level</code></td>
<td>
<p>Passed to <a href="#topic+mean_degparms">mean_degparms</a> in the case of an
<a href="#topic+mixed.mmkin">mixed.mmkin</a> object</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_default_log_parms">default_log_parms</code></td>
<td>
<p>Passed to <a href="#topic+mean_degparms">mean_degparms</a> in the case of an
<a href="#topic+mixed.mmkin">mixed.mmkin</a> object</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_ymax">ymax</code></td>
<td>
<p>Vector of maximum y axis values</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_maxabs">maxabs</code></td>
<td>
<p>Maximum absolute value of the residuals. This is used for the
scaling of the y axis and defaults to &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>Number of columns to use in the legend</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_nrow.legend">nrow.legend</code></td>
<td>
<p>Number of rows to use in the legend</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_rel.height.legend">rel.height.legend</code></td>
<td>
<p>The relative height of the legend shown on top</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_rel.height.bottom">rel.height.bottom</code></td>
<td>
<p>The relative height of the bottom plot row</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_pch_ds">pch_ds</code></td>
<td>
<p>Symbols to be used for plotting the data.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_col_ds">col_ds</code></td>
<td>
<p>Colors used for plotting the observed data and the
corresponding model prediction lines for the different datasets.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_lty_ds">lty_ds</code></td>
<td>
<p>Line types to be used for the model predictions.</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_frame">frame</code></td>
<td>
<p>Should a frame be drawn around the plots?</p>
</td></tr>
<tr><td><code id="plot.mixed.mmkin_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is called for its side effect.
</p>


<h3>Note</h3>

<p>Covariate models are currently only supported for saem.mmkin objects.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- lapply(experimental_data_for_UBA_2019[6:10],
 function(x) x$data[c("name", "time", "value")])
names(ds) &lt;- paste0("ds ", 6:10)
dfop_sfo &lt;- mkinmod(parent = mkinsub("DFOP", "A1"),
  A1 = mkinsub("SFO"), quiet = TRUE)
## Not run: 
f &lt;- mmkin(list("DFOP-SFO" = dfop_sfo), ds, quiet = TRUE)
plot(f[, 3:4], standardized = TRUE)

# For this fit we need to increase pnlsMaxiter, and we increase the
# tolerance in order to speed up the fit for this example evaluation
# It still takes 20 seconds to run
f_nlme &lt;- nlme(f, control = list(pnlsMaxIter = 120, tolerance = 1e-3))
plot(f_nlme)

f_saem &lt;- saem(f, transformations = "saemix")
plot(f_saem)

f_obs &lt;- mmkin(list("DFOP-SFO" = dfop_sfo), ds, quiet = TRUE, error_model = "obs")
f_nlmix &lt;- nlmix(f_obs)
plot(f_nlmix)

# We can overlay the two variants if we generate predictions
pred_nlme &lt;- mkinpredict(dfop_sfo,
  f_nlme$bparms.optim[-1],
  c(parent = f_nlme$bparms.optim[[1]], A1 = 0),
  seq(0, 180, by = 0.2))
plot(f_saem, pred_over = list(nlme = pred_nlme))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.mkinfit'>Plot the observed data and the fitted model of an mkinfit object</h2><span id='topic+plot.mkinfit'></span><span id='topic+plot_sep'></span><span id='topic+plot_res'></span><span id='topic+plot_err'></span>

<h3>Description</h3>

<p>Solves the differential equations with the optimised and fixed parameters
from a previous successful call to <code><a href="#topic+mkinfit">mkinfit</a></code> and plots the
observed data together with the solution of the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
plot(
  x,
  fit = x,
  obs_vars = names(fit$mkinmod$map),
  xlab = "Time",
  ylab = "Residue",
  xlim = range(fit$data$time),
  ylim = "default",
  col_obs = 1:length(obs_vars),
  pch_obs = col_obs,
  lty_obs = rep(1, length(obs_vars)),
  add = FALSE,
  legend = !add,
  show_residuals = FALSE,
  show_errplot = FALSE,
  maxabs = "auto",
  sep_obs = FALSE,
  rel.height.middle = 0.9,
  row_layout = FALSE,
  lpos = "topright",
  inset = c(0.05, 0.05),
  show_errmin = FALSE,
  errmin_digits = 3,
  frame = TRUE,
  ...
)

plot_sep(
  fit,
  show_errmin = TRUE,
  show_residuals = ifelse(identical(fit$err_mod, "const"), TRUE, "standardized"),
  ...
)

plot_res(
  fit,
  sep_obs = FALSE,
  show_errmin = sep_obs,
  standardized = ifelse(identical(fit$err_mod, "const"), FALSE, TRUE),
  ...
)

plot_err(fit, sep_obs = FALSE, show_errmin = sep_obs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mkinfit_+3A_x">x</code></td>
<td>
<p>Alias for fit introduced for compatibility with the generic S3
method.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_fit">fit</code></td>
<td>
<p>An object of class <code><a href="#topic+mkinfit">mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_obs_vars">obs_vars</code></td>
<td>
<p>A character vector of names of the observed variables for
which the data and the model should be plotted. Defauls to all observed
variables in the model.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_xlim">xlim</code></td>
<td>
<p>Plot range in x direction.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_ylim">ylim</code></td>
<td>
<p>Plot range in y direction. If given as a list, plot ranges
for the different plot rows can be given for row layout.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_col_obs">col_obs</code></td>
<td>
<p>Colors used for plotting the observed data and the
corresponding model prediction lines.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_pch_obs">pch_obs</code></td>
<td>
<p>Symbols to be used for plotting the data.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_lty_obs">lty_obs</code></td>
<td>
<p>Line types to be used for the model predictions.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_add">add</code></td>
<td>
<p>Should the plot be added to an existing plot?</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_legend">legend</code></td>
<td>
<p>Should a legend be added to the plot?</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_show_residuals">show_residuals</code></td>
<td>
<p>Should residuals be shown? If only one plot of the
fits is shown, the residual plot is in the lower third of the plot.
Otherwise, i.e. if &quot;sep_obs&quot; is given, the residual plots will be located
to the right of the plots of the fitted curves. If this is set to
'standardized', a plot of the residuals divided by the standard deviation
given by the fitted error model will be shown.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_show_errplot">show_errplot</code></td>
<td>
<p>Should squared residuals and the error model be shown?
If only one plot of the fits is shown, this plot is in the lower third of
the plot.  Otherwise, i.e. if &quot;sep_obs&quot; is given, the residual plots will
be located to the right of the plots of the fitted curves.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_maxabs">maxabs</code></td>
<td>
<p>Maximum absolute value of the residuals. This is used for the
scaling of the y axis and defaults to &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_sep_obs">sep_obs</code></td>
<td>
<p>Should the observed variables be shown in separate subplots?
If yes, residual plots requested by &quot;show_residuals&quot; will be shown next
to, not below the plot of the fits.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_rel.height.middle">rel.height.middle</code></td>
<td>
<p>The relative height of the middle plot, if more
than two rows of plots are shown.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_row_layout">row_layout</code></td>
<td>
<p>Should we use a row layout where the residual plot or the
error model plot is shown to the right?</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_lpos">lpos</code></td>
<td>
<p>Position(s) of the legend(s). Passed to <code><a href="graphics.html#topic+legend">legend</a></code> as
the first argument.  If not length one, this should be of the same length
as the obs_var argument.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_inset">inset</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+legend">legend</a></code> if applicable.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_show_errmin">show_errmin</code></td>
<td>
<p>Should the FOCUS chi2 error value be shown in the upper
margin of the plot?</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_errmin_digits">errmin_digits</code></td>
<td>
<p>The number of significant digits for rounding the FOCUS
chi2 error percentage.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_frame">frame</code></td>
<td>
<p>Should a frame be drawn around the plots?</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mkinfit_+3A_standardized">standardized</code></td>
<td>
<p>When calling 'plot_res', should the residuals be
standardized in the residual plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the current plot device is a <code><a href="tikzDevice.html#topic+tikz">tikz</a></code> device, then
latex is being used for the formatting of the chi2 error level, if
<code>show_errmin = TRUE</code>.
</p>


<h3>Value</h3>

<p>The function is called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# One parent compound, one metabolite, both single first order, path from
# parent to sink included
## Not run: 
SFO_SFO &lt;- mkinmod(parent = mkinsub("SFO", "m1", full = "Parent"),
                   m1 = mkinsub("SFO", full = "Metabolite M1" ))
fit &lt;- mkinfit(SFO_SFO, FOCUS_2006_D, quiet = TRUE)
fit &lt;- mkinfit(SFO_SFO, FOCUS_2006_D, quiet = TRUE, error_model = "tc")
plot(fit)
plot_res(fit)
plot_res(fit, standardized = FALSE)
plot_err(fit)

# Show the observed variables separately, with residuals
plot(fit, sep_obs = TRUE, show_residuals = TRUE, lpos = c("topright", "bottomright"),
     show_errmin = TRUE)

# The same can be obtained with less typing, using the convenience function plot_sep
plot_sep(fit, lpos = c("topright", "bottomright"))

# Show the observed variables separately, with the error model
plot(fit, sep_obs = TRUE, show_errplot = TRUE, lpos = c("topright", "bottomright"),
     show_errmin = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.mmkin'>Plot model fits (observed and fitted) and the residuals for a row or column
of an mmkin object</h2><span id='topic+plot.mmkin'></span>

<h3>Description</h3>

<p>When x is a row selected from an mmkin object (<code><a href="#topic++5B.mmkin">[.mmkin</a></code>), the
same model fitted for at least one dataset is shown. When it is a column,
the fit of at least one model to the same dataset is shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmkin'
plot(
  x,
  main = "auto",
  legends = 1,
  resplot = c("time", "errmod"),
  ylab = "Residue",
  standardized = FALSE,
  show_errmin = TRUE,
  errmin_var = "All data",
  errmin_digits = 3,
  cex = 0.7,
  rel.height.middle = 0.9,
  ymax = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mmkin_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+mmkin">mmkin</a></code>, with either one row or one
column.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_main">main</code></td>
<td>
<p>The main title placed on the outer margin of the plot.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_legends">legends</code></td>
<td>
<p>An index for the fits for which legends should be shown.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_resplot">resplot</code></td>
<td>
<p>Should the residuals plotted against time, using
<code><a href="#topic+mkinresplot">mkinresplot</a></code>, or as squared residuals against predicted
values, with the error model, using <code><a href="#topic+mkinerrplot">mkinerrplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_standardized">standardized</code></td>
<td>
<p>Should the residuals be standardized? This option
is passed to <code><a href="#topic+mkinresplot">mkinresplot</a></code>, it only takes effect if
<code>resplot = "time"</code>.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_show_errmin">show_errmin</code></td>
<td>
<p>Should the chi2 error level be shown on top of the plots
to the left?</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_errmin_var">errmin_var</code></td>
<td>
<p>The variable for which the FOCUS chi2 error value should
be shown.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_errmin_digits">errmin_digits</code></td>
<td>
<p>The number of significant digits for rounding the FOCUS
chi2 error percentage.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_cex">cex</code></td>
<td>
<p>Passed to the plot functions and <code><a href="graphics.html#topic+mtext">mtext</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_rel.height.middle">rel.height.middle</code></td>
<td>
<p>The relative height of the middle plot, if more
than two rows of plots are shown.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_ymax">ymax</code></td>
<td>
<p>Maximum y axis value for <code><a href="#topic+plot.mkinfit">plot.mkinfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mmkin_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+plot.mkinfit">plot.mkinfit</a></code> and
<code><a href="#topic+mkinresplot">mkinresplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the current plot device is a <code><a href="tikzDevice.html#topic+tikz">tikz</a></code> device, then
latex is being used for the formatting of the chi2 error level.
</p>


<h3>Value</h3>

<p>The function is called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: 
  # Only use one core not to offend CRAN checks
  fits &lt;- mmkin(c("FOMC", "HS"),
                list("FOCUS B" = FOCUS_2006_B, "FOCUS C" = FOCUS_2006_C), # named list for titles
                cores = 1, quiet = TRUE, error_model = "tc")
  plot(fits[, "FOCUS C"])
  plot(fits["FOMC", ])
  plot(fits["FOMC", ], show_errmin = FALSE)

  # We can also plot a single fit, if we like the way plot.mmkin works, but then the plot
  # height should be smaller than the plot width (this is not possible for the html pages
  # generated by pkgdown, as far as I know).
  plot(fits["FOMC", "FOCUS C"]) # same as plot(fits[1, 2])

  # Show the error models
  plot(fits["FOMC", ], resplot = "errmod")
  
## End(Not run)

</code></pre>

<hr>
<h2 id='plot.nafta'>Plot the results of the three models used in the NAFTA scheme.</h2><span id='topic+plot.nafta'></span>

<h3>Description</h3>

<p>The plots are ordered with increasing complexity of the model in this
function (SFO, then IORE, then DFOP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nafta'
plot(x, legend = FALSE, main = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nafta_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+nafta">nafta</a></code>.</p>
</td></tr>
<tr><td><code id="plot.nafta_+3A_legend">legend</code></td>
<td>
<p>Should a legend be added?</p>
</td></tr>
<tr><td><code id="plot.nafta_+3A_main">main</code></td>
<td>
<p>Possibility to override the main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.nafta_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+plot.mmkin">plot.mmkin</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code><a href="#topic+plot.mmkin">plot.mmkin</a></code>.
</p>


<h3>Value</h3>

<p>The function is called for its side effect.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>

<hr>
<h2 id='read_spreadsheet'>Read datasets and relevant meta information from a spreadsheet file</h2><span id='topic+read_spreadsheet'></span>

<h3>Description</h3>

<p>This function imports one dataset from each sheet of a spreadsheet file.
These sheets are selected based on the contents of a sheet 'Datasets', with
a column called 'Dataset Number', containing numbers identifying the dataset
sheets to be read in. In the second column there must be a grouping
variable, which will often be named 'Soil'. Optionally, time normalization
factors can be given in columns named 'Temperature' and 'Moisture'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_spreadsheet(
  path,
  valid_datasets = "all",
  parent_only = FALSE,
  normalize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_spreadsheet_+3A_path">path</code></td>
<td>
<p>Absolute or relative path to the spreadsheet file</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_valid_datasets">valid_datasets</code></td>
<td>
<p>Optional numeric index of the valid datasets, default is
to use all datasets</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_parent_only">parent_only</code></td>
<td>
<p>Should only the parent data be used?</p>
</td></tr>
<tr><td><code id="read_spreadsheet_+3A_normalize">normalize</code></td>
<td>
<p>Should the time scale be normalized using temperature
and moisture normalisation factors in the sheet 'Datasets'?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There must be a sheet 'Compounds', with columns 'Name' and 'Acronym'.
The first row read after the header read in from this sheet is assumed
to contain name and acronym of the parent compound.
</p>
<p>The dataset sheets should be named using the dataset numbers read in from
the 'Datasets' sheet, i.e. '1', '2', ... . In each dataset sheet, the name
of the observed variable (e.g. the acronym of the parent compound or
one of its transformation products) should be in the first column,
the time values should be in the second colum, and the observed value
in the third column.
</p>
<p>In case relevant covariate data are available, they should be given
in a sheet 'Covariates', containing one line for each value of the grouping
variable specified in 'Datasets'. These values should be in the first
column and the column must have the same name as the second column in
'Datasets'. Covariates will be read in from columns four and higher.
Their names should preferably not contain special characters like spaces,
so they can be easily used for specifying covariate models.
</p>
<p>A similar data structure is defined as the R6 class <a href="#topic+mkindsg">mkindsg</a>, but
is probably more complicated to use.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+intervals'></span><span id='topic+lrtest'></span><span id='topic+nlme'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lmtest</dt><dd><p><code><a href="lmtest.html#topic+lrtest">lrtest</a></code></p>
</dd>
<dt>nlme</dt><dd><p><code><a href="nlme.html#topic+intervals">intervals</a></code>, <code><a href="nlme.html#topic+nlme">nlme</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.mkinfit'>Extract residuals from an mkinfit model</h2><span id='topic+residuals.mkinfit'></span>

<h3>Description</h3>

<p>Extract residuals from an mkinfit model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
residuals(object, standardized = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mkinfit_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+mkinfit">mkinfit</a></code> object</p>
</td></tr>
<tr><td><code id="residuals.mkinfit_+3A_standardized">standardized</code></td>
<td>
<p>Should the residuals be standardized by dividing by the
standard deviation obtained from the fitted error model?</p>
</td></tr>
<tr><td><code id="residuals.mkinfit_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- mkinfit("DFOP", FOCUS_2006_C, quiet = TRUE)
residuals(f)
residuals(f, standardized = TRUE)
</code></pre>

<hr>
<h2 id='saem'>Fit nonlinear mixed models with SAEM</h2><span id='topic+saem'></span><span id='topic+saem.mmkin'></span><span id='topic+print.saem.mmkin'></span><span id='topic+saemix_model'></span><span id='topic+saemix_data'></span>

<h3>Description</h3>

<p>This function uses <code><a href="saemix.html#topic+saemix">saemix::saemix()</a></code> as a backend for fitting nonlinear mixed
effects models created from <a href="#topic+mmkin">mmkin</a> row objects using the Stochastic Approximation
Expectation Maximisation algorithm (SAEM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saem(object, ...)

## S3 method for class 'mmkin'
saem(
  object,
  transformations = c("mkin", "saemix"),
  error_model = "auto",
  degparms_start = numeric(),
  test_log_parms = TRUE,
  conf.level = 0.6,
  solution_type = "auto",
  covariance.model = "auto",
  omega.init = "auto",
  covariates = NULL,
  covariate_models = NULL,
  no_random_effect = NULL,
  error.init = c(1, 1),
  nbiter.saemix = c(300, 100),
  control = list(displayProgress = FALSE, print = FALSE, nbiter.saemix = nbiter.saemix,
    save = FALSE, save.graphs = FALSE),
  verbose = FALSE,
  quiet = FALSE,
  ...
)

## S3 method for class 'saem.mmkin'
print(x, digits = max(3, getOption("digits") - 3), ...)

saemix_model(
  object,
  solution_type = "auto",
  transformations = c("mkin", "saemix"),
  error_model = "auto",
  degparms_start = numeric(),
  covariance.model = "auto",
  no_random_effect = NULL,
  omega.init = "auto",
  covariates = NULL,
  covariate_models = NULL,
  error.init = numeric(),
  test_log_parms = FALSE,
  conf.level = 0.6,
  verbose = FALSE,
  ...
)

saemix_data(object, covariates = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saem_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+mmkin">mmkin</a> row object containing several fits of the same
<a href="#topic+mkinmod">mkinmod</a> model to different datasets</p>
</td></tr>
<tr><td><code id="saem_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <a href="saemix.html#topic+saemixModel">saemix::saemixModel</a>.</p>
</td></tr>
<tr><td><code id="saem_+3A_transformations">transformations</code></td>
<td>
<p>Per default, all parameter transformations are done
in mkin. If this argument is set to 'saemix', parameter transformations
are done in 'saemix' for the supported cases, i.e. (as of version 1.1.2)
SFO, FOMC, DFOP and HS without fixing <code>parent_0</code>, and SFO or DFOP with
one SFO metabolite.</p>
</td></tr>
<tr><td><code id="saem_+3A_error_model">error_model</code></td>
<td>
<p>Possibility to override the error model used in the mmkin object</p>
</td></tr>
<tr><td><code id="saem_+3A_degparms_start">degparms_start</code></td>
<td>
<p>Parameter values given as a named numeric vector will
be used to override the starting values obtained from the 'mmkin' object.</p>
</td></tr>
<tr><td><code id="saem_+3A_test_log_parms">test_log_parms</code></td>
<td>
<p>If TRUE, an attempt is made to use more robust starting
values for population parameters fitted as log parameters in mkin (like
rate constants) by only considering rate constants that pass the t-test
when calculating mean degradation parameters using <a href="#topic+mean_degparms">mean_degparms</a>.</p>
</td></tr>
<tr><td><code id="saem_+3A_conf.level">conf.level</code></td>
<td>
<p>Possibility to adjust the required confidence level
for parameter that are tested if requested by 'test_log_parms'.</p>
</td></tr>
<tr><td><code id="saem_+3A_solution_type">solution_type</code></td>
<td>
<p>Possibility to specify the solution type in case the
automatic choice is not desired</p>
</td></tr>
<tr><td><code id="saem_+3A_covariance.model">covariance.model</code></td>
<td>
<p>Will be passed to <code><a href="saemix.html#topic+saemixModel">saemix::saemixModel()</a></code>. Per
default, uncorrelated random effects are specified for all degradation
parameters.</p>
</td></tr>
<tr><td><code id="saem_+3A_omega.init">omega.init</code></td>
<td>
<p>Will be passed to <code><a href="saemix.html#topic+saemixModel">saemix::saemixModel()</a></code>. If using
mkin transformations and the default covariance model with optionally
excluded random effects, the variances of the degradation parameters
are estimated using <a href="#topic+mean_degparms">mean_degparms</a>, with testing of untransformed
log parameters for significant difference from zero. If not using
mkin transformations or a custom covariance model, the default
initialisation of <a href="saemix.html#topic+saemixModel">saemix::saemixModel</a> is used for omega.init.</p>
</td></tr>
<tr><td><code id="saem_+3A_covariates">covariates</code></td>
<td>
<p>A data frame with covariate data for use in
'covariate_models', with dataset names as row names.</p>
</td></tr>
<tr><td><code id="saem_+3A_covariate_models">covariate_models</code></td>
<td>
<p>A list containing linear model formulas with one explanatory
variable, i.e. of the type 'parameter ~ covariate'. Covariates must be available
in the 'covariates' data frame.</p>
</td></tr>
<tr><td><code id="saem_+3A_no_random_effect">no_random_effect</code></td>
<td>
<p>Character vector of degradation parameters for
which there should be no variability over the groups. Only used
if the covariance model is not explicitly specified.</p>
</td></tr>
<tr><td><code id="saem_+3A_error.init">error.init</code></td>
<td>
<p>Will be passed to <code><a href="saemix.html#topic+saemixModel">saemix::saemixModel()</a></code>.</p>
</td></tr>
<tr><td><code id="saem_+3A_nbiter.saemix">nbiter.saemix</code></td>
<td>
<p>Convenience option to increase the number of
iterations</p>
</td></tr>
<tr><td><code id="saem_+3A_control">control</code></td>
<td>
<p>Passed to <a href="saemix.html#topic+saemix">saemix::saemix</a>.</p>
</td></tr>
<tr><td><code id="saem_+3A_verbose">verbose</code></td>
<td>
<p>Should we print information about created objects of
type <a href="saemix.html#topic+SaemixModel-class">saemix::SaemixModel</a> and <a href="saemix.html#topic+SaemixData-class">saemix::SaemixData</a>?</p>
</td></tr>
<tr><td><code id="saem_+3A_quiet">quiet</code></td>
<td>
<p>Should we suppress the messages saemix prints at the beginning
and the end of the optimisation process?</p>
</td></tr>
<tr><td><code id="saem_+3A_x">x</code></td>
<td>
<p>An saem.mmkin object to print</p>
</td></tr>
<tr><td><code id="saem_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for printing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An mmkin row object is essentially a list of mkinfit objects that have been
obtained by fitting the same model to a list of datasets using <a href="#topic+mkinfit">mkinfit</a>.
</p>
<p>Starting values for the fixed effects (population mean parameters, argument
psi0 of <code><a href="saemix.html#topic+saemixModel">saemix::saemixModel()</a></code> are the mean values of the parameters found
using <a href="#topic+mmkin">mmkin</a>.
</p>


<h3>Value</h3>

<p>An S3 object of class 'saem.mmkin', containing the fitted
<a href="saemix.html#topic+SaemixObject-class">saemix::SaemixObject</a> as a list component named 'so'. The
object also inherits from 'mixed.mmkin'.
</p>
<p>An <a href="saemix.html#topic+SaemixModel-class">saemix::SaemixModel</a> object.
</p>
<p>An <a href="saemix.html#topic+SaemixData-class">saemix::SaemixData</a> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.saem.mmkin">summary.saem.mmkin</a> <a href="#topic+plot.mixed.mmkin">plot.mixed.mmkin</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds &lt;- lapply(experimental_data_for_UBA_2019[6:10],
 function(x) subset(x$data[c("name", "time", "value")]))
names(ds) &lt;- paste("Dataset", 6:10)
f_mmkin_parent_p0_fixed &lt;- mmkin("FOMC", ds,
  state.ini = c(parent = 100), fixed_initials = "parent", quiet = TRUE)
f_saem_p0_fixed &lt;- saem(f_mmkin_parent_p0_fixed)

f_mmkin_parent &lt;- mmkin(c("SFO", "FOMC", "DFOP"), ds, quiet = TRUE)
f_saem_sfo &lt;- saem(f_mmkin_parent["SFO", ])
f_saem_fomc &lt;- saem(f_mmkin_parent["FOMC", ])
f_saem_dfop &lt;- saem(f_mmkin_parent["DFOP", ])
anova(f_saem_sfo, f_saem_fomc, f_saem_dfop)
anova(f_saem_sfo, f_saem_dfop, test = TRUE)
illparms(f_saem_dfop)
f_saem_dfop_red &lt;- update(f_saem_dfop, no_random_effect = "g_qlogis")
anova(f_saem_dfop, f_saem_dfop_red, test = TRUE)

anova(f_saem_sfo, f_saem_fomc, f_saem_dfop)
# The returned saem.mmkin object contains an SaemixObject, therefore we can use
# functions from saemix
library(saemix)
compare.saemix(f_saem_sfo$so, f_saem_fomc$so, f_saem_dfop$so)
plot(f_saem_fomc$so, plot.type = "convergence")
plot(f_saem_fomc$so, plot.type = "individual.fit")
plot(f_saem_fomc$so, plot.type = "npde")
plot(f_saem_fomc$so, plot.type = "vpc")

f_mmkin_parent_tc &lt;- update(f_mmkin_parent, error_model = "tc")
f_saem_fomc_tc &lt;- saem(f_mmkin_parent_tc["FOMC", ])
anova(f_saem_fomc, f_saem_fomc_tc, test = TRUE)

sfo_sfo &lt;- mkinmod(parent = mkinsub("SFO", "A1"),
  A1 = mkinsub("SFO"))
fomc_sfo &lt;- mkinmod(parent = mkinsub("FOMC", "A1"),
  A1 = mkinsub("SFO"))
dfop_sfo &lt;- mkinmod(parent = mkinsub("DFOP", "A1"),
  A1 = mkinsub("SFO"))
# The following fit uses analytical solutions for SFO-SFO and DFOP-SFO,
# and compiled ODEs for FOMC that are much slower
f_mmkin &lt;- mmkin(list(
    "SFO-SFO" = sfo_sfo, "FOMC-SFO" = fomc_sfo, "DFOP-SFO" = dfop_sfo),
  ds, quiet = TRUE)
# saem fits of SFO-SFO and DFOP-SFO to these data take about five seconds
# each on this system, as we use analytical solutions written for saemix.
# When using the analytical solutions written for mkin this took around
# four minutes
f_saem_sfo_sfo &lt;- saem(f_mmkin["SFO-SFO", ])
f_saem_dfop_sfo &lt;- saem(f_mmkin["DFOP-SFO", ])
# We can use print, plot and summary methods to check the results
print(f_saem_dfop_sfo)
plot(f_saem_dfop_sfo)
summary(f_saem_dfop_sfo, data = TRUE)

# The following takes about 6 minutes
f_saem_dfop_sfo_deSolve &lt;- saem(f_mmkin["DFOP-SFO", ], solution_type = "deSolve",
  nbiter.saemix = c(200, 80))

#anova(
#  f_saem_dfop_sfo,
#  f_saem_dfop_sfo_deSolve))

# If the model supports it, we can also use eigenvalue based solutions, which
# take a similar amount of time
#f_saem_sfo_sfo_eigen &lt;- saem(f_mmkin["SFO-SFO", ], solution_type = "eigen",
#  control = list(nbiter.saemix = c(200, 80), nbdisplay = 10))

## End(Not run)
</code></pre>

<hr>
<h2 id='schaefer07_complex_case'>
Metabolism data set used for checking the software quality of KinGUI
</h2><span id='topic+schaefer07_complex_case'></span><span id='topic+schaefer07_complex_results'></span>

<h3>Description</h3>

<p>This dataset was used for a comparison of KinGUI and ModelMaker to check the
software quality of KinGUI in the original publication (Schäfer et al., 2007).
The results from the fitting are also included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schaefer07_complex_case</code></pre>


<h3>Format</h3>

<p>The data set is a data frame with 8 observations on the following 6 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>parent</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>A1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>B1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>A2</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>

<p>The results are a data frame with 14 results for different parameter values
</p>


<h3>References</h3>

<p>Schäfer D, Mikolasch B, Rainbird P and Harvey B (2007). KinGUI: a new kinetic
software tool for evaluations according to FOCUS degradation kinetics. In: Del
Re AAM, Capri E, Fragoulis G and Trevisan M (Eds.). Proceedings of the XIII
Symposium Pesticide Chemistry, Piacenza, 2007, p. 916-923.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mkin_wide_to_long(schaefer07_complex_case, time = "time")
model &lt;- mkinmod(
  parent = list(type = "SFO", to = c("A1", "B1", "C1"), sink = FALSE),
  A1 = list(type = "SFO", to = "A2"),
  B1 = list(type = "SFO"),
  C1 = list(type = "SFO"),
  A2 = list(type = "SFO"), use_of_ff = "max")
  ## Not run: 
    fit &lt;- mkinfit(model, data, quiet = TRUE)
    plot(fit)
    endpoints(fit)
  
## End(Not run)
 # Compare with the results obtained in the original publication
 print(schaefer07_complex_results)
</code></pre>

<hr>
<h2 id='set_nd_nq'>Set non-detects and unquantified values in residue series without replicates</h2><span id='topic+set_nd_nq'></span><span id='topic+set_nd_nq_focus'></span>

<h3>Description</h3>

<p>This function automates replacing unquantified values in residue time and
depth series. For time series, the function performs part of the residue
processing proposed in the FOCUS kinetics guidance for parent compounds
and metabolites. For two-dimensional residue series over time and depth,
it automates the proposal of Boesten et al (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_nd_nq(res_raw, lod, loq = NA, time_zero_presence = FALSE)

set_nd_nq_focus(
  res_raw,
  lod,
  loq = NA,
  set_first_sample_nd = TRUE,
  first_sample_nd_value = 0,
  ignore_below_loq_after_first_nd = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_nd_nq_+3A_res_raw">res_raw</code></td>
<td>
<p>Character vector of a residue time series, or matrix of
residue values with rows representing depth profiles for a specific sampling
time, and columns representing time series of residues at the same depth.
Values below the limit of detection (lod) have to be coded as &quot;nd&quot;, values
between the limit of detection and the limit of quantification, if any, have
to be coded as &quot;nq&quot;. Samples not analysed have to be coded as &quot;na&quot;. All
values that are not &quot;na&quot;, &quot;nd&quot; or &quot;nq&quot; have to be coercible to numeric</p>
</td></tr>
<tr><td><code id="set_nd_nq_+3A_lod">lod</code></td>
<td>
<p>Limit of detection (numeric)</p>
</td></tr>
<tr><td><code id="set_nd_nq_+3A_loq">loq</code></td>
<td>
<p>Limit of quantification(numeric). Must be specified if the FOCUS rule to
stop after the first non-detection is to be applied</p>
</td></tr>
<tr><td><code id="set_nd_nq_+3A_time_zero_presence">time_zero_presence</code></td>
<td>
<p>Do we assume that residues occur at time zero?
This only affects samples from the first sampling time that have been
reported as &quot;nd&quot; (not detected).</p>
</td></tr>
<tr><td><code id="set_nd_nq_+3A_set_first_sample_nd">set_first_sample_nd</code></td>
<td>
<p>Should the first sample be set to &quot;first_sample_nd_value&quot;
in case it is a non-detection?</p>
</td></tr>
<tr><td><code id="set_nd_nq_+3A_first_sample_nd_value">first_sample_nd_value</code></td>
<td>
<p>Value to be used for the first sample if it is a non-detection</p>
</td></tr>
<tr><td><code id="set_nd_nq_+3A_ignore_below_loq_after_first_nd">ignore_below_loq_after_first_nd</code></td>
<td>
<p>Should we ignore values below the LOQ after the first
non-detection that occurs after the quantified values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, if a vector was supplied, or a numeric matrix otherwise
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>set_nd_nq_focus()</code>: Set non-detects in residue time series according to FOCUS rules
</p>
</li></ul>


<h3>References</h3>

<p>Boesten, J. J. T. I., van der Linden, A. M. A., Beltman, W. H.
J. and Pol, J. W. (2015). Leaching of plant protection products and their
transformation products; Proposals for improving the assessment of leaching
to groundwater in the Netherlands — Version 2. Alterra report 2630, Alterra
Wageningen UR (University &amp; Research centre)
</p>
<p>FOCUS (2014) Generic Guidance for Estimating Persistence and Degradation
Kinetics from Environmental Fate Studies on Pesticides in EU Registration, Version 1.1,
18 December 2014, p. 251
</p>


<h3>Examples</h3>

<pre><code class='language-R'># FOCUS (2014) p. 75/76 and 131/132
parent_1 &lt;- c(.12, .09, .05, .03, "nd", "nd", "nd", "nd", "nd", "nd")
set_nd_nq(parent_1, 0.02)
parent_2 &lt;- c(.12, .09, .05, .03, "nd", "nd", .03, "nd", "nd", "nd")
set_nd_nq(parent_2, 0.02)
set_nd_nq_focus(parent_2, 0.02, loq = 0.05)
parent_3 &lt;- c(.12, .09, .05, .03, "nd", "nd", .06, "nd", "nd", "nd")
set_nd_nq(parent_3, 0.02)
set_nd_nq_focus(parent_3, 0.02, loq = 0.05)
metabolite &lt;- c("nd", "nd", "nd", 0.03, 0.06, 0.10, 0.11, 0.10, 0.09, 0.05, 0.03, "nd", "nd")
set_nd_nq(metabolite, 0.02)
set_nd_nq_focus(metabolite, 0.02, 0.05)
#
# Boesten et al. (2015), p. 57/58
table_8 &lt;- matrix(
  c(10, 10, rep("nd", 4),
    10, 10, rep("nq", 2), rep("nd", 2),
    10, 10, 10, "nq", "nd", "nd",
    "nq", 10, "nq", rep("nd", 3),
    "nd", "nq", "nq", rep("nd", 3),
    rep("nd", 6), rep("nd", 6)),
  ncol = 6, byrow = TRUE)
set_nd_nq(table_8, 0.5, 1.5, time_zero_presence = TRUE)
table_10 &lt;- matrix(
  c(10, 10, rep("nd", 4),
    10, 10, rep("nd", 4),
    10, 10, 10, rep("nd", 3),
    "nd", 10, rep("nd", 4),
    rep("nd", 18)),
  ncol = 6, byrow = TRUE)
set_nd_nq(table_10, 0.5, time_zero_presence = TRUE)
</code></pre>

<hr>
<h2 id='SFO.solution'>Single First-Order kinetics</h2><span id='topic+SFO.solution'></span>

<h3>Description</h3>

<p>Function describing exponential decline from a defined starting value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SFO.solution(t, parent_0, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SFO.solution_+3A_t">t</code></td>
<td>
<p>Time.</p>
</td></tr>
<tr><td><code id="SFO.solution_+3A_parent_0">parent_0</code></td>
<td>
<p>Starting value for the response variable at time zero.</p>
</td></tr>
<tr><td><code id="SFO.solution_+3A_k">k</code></td>
<td>
<p>Kinetic rate constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the response variable at time <code>t</code>.
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>See Also</h3>

<p>Other parent solutions: 
<code><a href="#topic+DFOP.solution">DFOP.solution</a>()</code>,
<code><a href="#topic+FOMC.solution">FOMC.solution</a>()</code>,
<code><a href="#topic+HS.solution">HS.solution</a>()</code>,
<code><a href="#topic+IORE.solution">IORE.solution</a>()</code>,
<code><a href="#topic+SFORB.solution">SFORB.solution</a>()</code>,
<code><a href="#topic+logistic.solution">logistic.solution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: plot(function(x) SFO.solution(x, 100, 3), 0, 2)

</code></pre>

<hr>
<h2 id='SFORB.solution'>Single First-Order Reversible Binding kinetics</h2><span id='topic+SFORB.solution'></span>

<h3>Description</h3>

<p>Function describing the solution of the differential equations describing
the kinetic model with first-order terms for a two-way transfer from a free
to a bound fraction, and a first-order degradation term for the free
fraction.  The initial condition is a defined amount in the free fraction
and no substance in the bound fraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SFORB.solution(t, parent_0, k_12, k_21, k_1output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SFORB.solution_+3A_t">t</code></td>
<td>
<p>Time.</p>
</td></tr>
<tr><td><code id="SFORB.solution_+3A_parent_0">parent_0</code></td>
<td>
<p>Starting value for the response variable at time zero.</p>
</td></tr>
<tr><td><code id="SFORB.solution_+3A_k_12">k_12</code></td>
<td>
<p>Kinetic constant describing transfer from free to bound.</p>
</td></tr>
<tr><td><code id="SFORB.solution_+3A_k_21">k_21</code></td>
<td>
<p>Kinetic constant describing transfer from bound to free.</p>
</td></tr>
<tr><td><code id="SFORB.solution_+3A_k_1output">k_1output</code></td>
<td>
<p>Kinetic constant describing degradation of the free
fraction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the response variable, which is the sum of free and
bound fractions at time <code>t</code>.
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
FOCUS (2014) &ldquo;Generic guidance for Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
Version 1.1, 18 December 2014
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>See Also</h3>

<p>Other parent solutions: 
<code><a href="#topic+DFOP.solution">DFOP.solution</a>()</code>,
<code><a href="#topic+FOMC.solution">FOMC.solution</a>()</code>,
<code><a href="#topic+HS.solution">HS.solution</a>()</code>,
<code><a href="#topic+IORE.solution">IORE.solution</a>()</code>,
<code><a href="#topic+SFO.solution">SFO.solution</a>()</code>,
<code><a href="#topic+logistic.solution">logistic.solution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Not run: plot(function(x) SFORB.solution(x, 100, 0.5, 2, 3), 0, 2)

</code></pre>

<hr>
<h2 id='sigma_twocomp'>Two-component error model</h2><span id='topic+sigma_twocomp'></span>

<h3>Description</h3>

<p>Function describing the standard deviation of the measurement error in
dependence of the measured value <code class="reqn">y</code>:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_twocomp(y, sigma_low, rsd_high)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma_twocomp_+3A_y">y</code></td>
<td>
<p>The magnitude of the observed value</p>
</td></tr>
<tr><td><code id="sigma_twocomp_+3A_sigma_low">sigma_low</code></td>
<td>
<p>The asymptotic minimum of the standard deviation for low
observed values</p>
</td></tr>
<tr><td><code id="sigma_twocomp_+3A_rsd_high">rsd_high</code></td>
<td>
<p>The coefficient describing the increase of the standard
deviation with the magnitude of the observed value</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\sigma = \sqrt{ \sigma_{low}^2 + y^2 * {rsd}_{high}^2}</code>
</p>
<p> sigma =
sqrt(sigma_low^2 + y^2 * rsd_high^2)
</p>
<p>This is the error model used for example by Werner et al. (1978). The model
proposed by Rocke and Lorenzato (1995) can be written in this form as well,
but assumes approximate lognormal distribution of errors for high values of
y.
</p>


<h3>Value</h3>

<p>The standard deviation of the response variable.
</p>


<h3>References</h3>

<p>Werner, Mario, Brooks, Samuel H., and Knott, Lancaster B. (1978)
Additive, Multiplicative, and Mixed Analytical Errors. Clinical Chemistry
24(11), 1895-1898.
</p>
<p>Rocke, David M. and Lorenzato, Stefan (1995) A two-component model for
measurement error in analytical chemistry. Technometrics 37(2), 176-184.
</p>
<p>Ranke J and Meinecke S (2019) Error Models for the Kinetic Evaluation of Chemical
Degradation Data. <em>Environments</em> 6(12) 124
<a href="https://doi.org/10.3390/environments6120124">doi:10.3390/environments6120124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times &lt;- c(0, 1, 3, 7, 14, 28, 60, 90, 120)
d_pred &lt;- data.frame(time = times, parent = 100 * exp(- 0.03 * times))
set.seed(123456)
d_syn &lt;- add_err(d_pred, function(y) sigma_twocomp(y, 1, 0.07),
  reps = 2, n = 1)[[1]]
f_nls &lt;- nls(value ~ SSasymp(time, 0, parent_0, lrc), data = d_syn,
 start = list(parent_0 = 100, lrc = -3))
library(nlme)
f_gnls &lt;- gnls(value ~ SSasymp(time, 0, parent_0, lrc),
  data = d_syn, na.action = na.omit,
  start = list(parent_0 = 100, lrc = -3))
if (length(findFunction("varConstProp")) &gt; 0) {
  f_gnls_tc &lt;- update(f_gnls, weights = varConstProp())
  f_gnls_tc_sf &lt;- update(f_gnls_tc, control = list(sigma = 1))
}
f_mkin &lt;- mkinfit("SFO", d_syn, error_model = "const", quiet = TRUE)
f_mkin_tc &lt;- mkinfit("SFO", d_syn, error_model = "tc", quiet = TRUE)
plot_res(f_mkin_tc, standardized = TRUE)
AIC(f_nls, f_gnls, f_gnls_tc, f_gnls_tc_sf, f_mkin, f_mkin_tc)
</code></pre>

<hr>
<h2 id='status'>Method to get status information for fit array objects</h2><span id='topic+status'></span><span id='topic+status.mmkin'></span><span id='topic+print.status.mmkin'></span><span id='topic+status.mhmkin'></span><span id='topic+print.status.mhmkin'></span>

<h3>Description</h3>

<p>Method to get status information for fit array objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(object, ...)

## S3 method for class 'mmkin'
status(object, ...)

## S3 method for class 'status.mmkin'
print(x, ...)

## S3 method for class 'mhmkin'
status(object, ...)

## S3 method for class 'status.mhmkin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_+3A_object">object</code></td>
<td>
<p>The object to investigate</p>
</td></tr>
<tr><td><code id="status_+3A_...">...</code></td>
<td>
<p>For potential future extensions</p>
</td></tr>
<tr><td><code id="status_+3A_x">x</code></td>
<td>
<p>The object to be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with the same dimensions as the fit array
suitable printing method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fits &lt;- mmkin(
  c("SFO", "FOMC"),
  list("FOCUS A" = FOCUS_2006_A,
       "FOCUS B" = FOCUS_2006_C),
  quiet = TRUE)
status(fits)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary_listing'>Display the output of a summary function according to the output format</h2><span id='topic+summary_listing'></span><span id='topic+tex_listing'></span><span id='topic+html_listing'></span>

<h3>Description</h3>

<p>This function is intended for use in a R markdown code chunk with the chunk
option <code>results = "asis"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_listing(object, caption = NULL, label = NULL, clearpage = TRUE)

tex_listing(object, caption = NULL, label = NULL, clearpage = TRUE)

html_listing(object, caption = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_listing_+3A_object">object</code></td>
<td>
<p>The object for which the summary is to be listed</p>
</td></tr>
<tr><td><code id="summary_listing_+3A_caption">caption</code></td>
<td>
<p>An optional caption</p>
</td></tr>
<tr><td><code id="summary_listing_+3A_label">label</code></td>
<td>
<p>An optional label, ignored in html output</p>
</td></tr>
<tr><td><code id="summary_listing_+3A_clearpage">clearpage</code></td>
<td>
<p>Should a new page be started after the listing? Ignored in html output</p>
</td></tr>
</table>

<hr>
<h2 id='summary.mkinfit'>Summary method for class &quot;mkinfit&quot;</h2><span id='topic+summary.mkinfit'></span><span id='topic+print.summary.mkinfit'></span>

<h3>Description</h3>

<p>Lists model equations, initial parameter values, optimised parameters with
some uncertainty statistics, the chi2 error levels calculated according to
FOCUS guidance (2006) as defined therein, formation fractions, DT50 values
and optionally the data, consisting of observed, predicted and residual
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
summary(object, data = TRUE, distimes = TRUE, alpha = 0.05, ...)

## S3 method for class 'summary.mkinfit'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mkinfit_+3A_object">object</code></td>
<td>
<p>an object of class <a href="#topic+mkinfit">mkinfit</a>.</p>
</td></tr>
<tr><td><code id="summary.mkinfit_+3A_data">data</code></td>
<td>
<p>logical, indicating whether the data should be included in the
summary.</p>
</td></tr>
<tr><td><code id="summary.mkinfit_+3A_distimes">distimes</code></td>
<td>
<p>logical, indicating whether DT50 and DT90 values should be
included.</p>
</td></tr>
<tr><td><code id="summary.mkinfit_+3A_alpha">alpha</code></td>
<td>
<p>error level for confidence interval estimation from t
distribution</p>
</td></tr>
<tr><td><code id="summary.mkinfit_+3A_...">...</code></td>
<td>
<p>optional arguments passed to methods like <code>print</code>.</p>
</td></tr>
<tr><td><code id="summary.mkinfit_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.mkinfit</code>.</p>
</td></tr>
<tr><td><code id="summary.mkinfit_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary function returns a list with components, among others
</p>
<table>
<tr><td><code>version</code>, <code>Rversion</code></td>
<td>
<p>The mkin and R versions used</p>
</td></tr>
<tr><td><code>date.fit</code>, <code>date.summary</code></td>
<td>
<p>The dates where the fit and the summary were
produced</p>
</td></tr>
<tr><td><code>diffs</code></td>
<td>
<p>The differential equations used in the model</p>
</td></tr>
<tr><td><code>use_of_ff</code></td>
<td>
<p>Was maximum or minimum use made of formation fractions</p>
</td></tr>
<tr><td><code>bpar</code></td>
<td>
<p>Optimised and backtransformed
parameters</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data (see Description above).</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>The starting values and bounds, if applicable, for optimised
parameters.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>The values of fixed parameters.</p>
</td></tr>
<tr><td><code>errmin</code></td>
<td>
<p>The chi2 error levels for
each observed variable.</p>
</td></tr>
<tr><td><code>bparms.ode</code></td>
<td>
<p>All backtransformed ODE
parameters, for use as starting parameters for related models.</p>
</td></tr>
<tr><td><code>errparms</code></td>
<td>
<p>Error model parameters.</p>
</td></tr>
<tr><td><code>ff</code></td>
<td>
<p>The estimated formation fractions derived from the fitted
model.</p>
</td></tr>
<tr><td><code>distimes</code></td>
<td>
<p>The DT50 and DT90 values for each observed variable.</p>
</td></tr>
<tr><td><code>SFORB</code></td>
<td>
<p>If applicable, eigenvalues and fractional eigenvector component
g of SFORB systems in the model.</p>
</td></tr>
</table>
<p>The print method is called for its side effect, i.e. printing the summary.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>References</h3>

<p>FOCUS (2006) &ldquo;Guidance Document on Estimating Persistence
and Degradation Kinetics from Environmental Fate Studies on Pesticides in
EU Registration&rdquo; Report of the FOCUS Work Group on Degradation Kinetics,
EC Document Reference Sanco/10058/2005 version 2.0, 434 pp,
<a href="http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics">http://esdac.jrc.ec.europa.eu/projects/degradation-kinetics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  summary(mkinfit("SFO", FOCUS_2006_A, quiet = TRUE))

</code></pre>

<hr>
<h2 id='summary.mmkin'>Summary method for class &quot;mmkin&quot;</h2><span id='topic+summary.mmkin'></span><span id='topic+print.summary.mmkin'></span>

<h3>Description</h3>

<p>Shows status information on the <a href="#topic+mkinfit">mkinfit</a> objects contained in the object
and gives an overview of ill-defined parameters calculated by <a href="#topic+illparms">illparms</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmkin'
summary(object, conf.level = 0.95, ...)

## S3 method for class 'summary.mmkin'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mmkin_+3A_object">object</code></td>
<td>
<p>an object of class <a href="#topic+mmkin">mmkin</a></p>
</td></tr>
<tr><td><code id="summary.mmkin_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for testing parameters</p>
</td></tr>
<tr><td><code id="summary.mmkin_+3A_...">...</code></td>
<td>
<p>optional arguments passed to methods like <code>print</code>.</p>
</td></tr>
<tr><td><code id="summary.mmkin_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.mmkin</code>.</p>
</td></tr>
<tr><td><code id="summary.mmkin_+3A_digits">digits</code></td>
<td>
<p>number of digits to use for printing</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
fits &lt;- mmkin(
  c("SFO", "FOMC"),
  list("FOCUS A" = FOCUS_2006_A,
       "FOCUS C" = FOCUS_2006_C),
  quiet = TRUE, cores = 1)
  summary(fits)

</code></pre>

<hr>
<h2 id='summary.nlme.mmkin'>Summary method for class &quot;nlme.mmkin&quot;</h2><span id='topic+summary.nlme.mmkin'></span><span id='topic+print.summary.nlme.mmkin'></span>

<h3>Description</h3>

<p>Lists model equations, initial parameter values, optimised parameters
for fixed effects (population), random effects (deviations from the
population mean) and residual error model, as well as the resulting
endpoints such as formation fractions and DT50 values. Optionally
(default is FALSE), the data are listed in full.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlme.mmkin'
summary(
  object,
  data = FALSE,
  verbose = FALSE,
  distimes = TRUE,
  alpha = 0.05,
  ...
)

## S3 method for class 'summary.nlme.mmkin'
print(x, digits = max(3, getOption("digits") - 3), verbose = x$verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nlme.mmkin_+3A_object">object</code></td>
<td>
<p>an object of class <a href="#topic+nlme.mmkin">nlme.mmkin</a></p>
</td></tr>
<tr><td><code id="summary.nlme.mmkin_+3A_data">data</code></td>
<td>
<p>logical, indicating whether the full data should be included in
the summary.</p>
</td></tr>
<tr><td><code id="summary.nlme.mmkin_+3A_verbose">verbose</code></td>
<td>
<p>Should the summary be verbose?</p>
</td></tr>
<tr><td><code id="summary.nlme.mmkin_+3A_distimes">distimes</code></td>
<td>
<p>logical, indicating whether DT50 and DT90 values should be
included.</p>
</td></tr>
<tr><td><code id="summary.nlme.mmkin_+3A_alpha">alpha</code></td>
<td>
<p>error level for confidence interval estimation from the t
distribution</p>
</td></tr>
<tr><td><code id="summary.nlme.mmkin_+3A_...">...</code></td>
<td>
<p>optional arguments passed to methods like <code>print</code>.</p>
</td></tr>
<tr><td><code id="summary.nlme.mmkin_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+summary.nlme.mmkin">summary.nlme.mmkin</a></p>
</td></tr>
<tr><td><code id="summary.nlme.mmkin_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary function returns a list based on the <a href="#topic+nlme">nlme</a> object
obtained in the fit, with at least the following additional components
</p>
<table>
<tr><td><code>nlmeversion</code>, <code>mkinversion</code>, <code>Rversion</code></td>
<td>
<p>The nlme, mkin and R versions used</p>
</td></tr>
<tr><td><code>date.fit</code>, <code>date.summary</code></td>
<td>
<p>The dates where the fit and the summary were
produced</p>
</td></tr>
<tr><td><code>diffs</code></td>
<td>
<p>The differential equations used in the degradation model</p>
</td></tr>
<tr><td><code>use_of_ff</code></td>
<td>
<p>Was maximum or minimum use made of formation fractions</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data</p>
</td></tr>
<tr><td><code>confint_trans</code></td>
<td>
<p>Transformed parameters as used in the optimisation, with confidence intervals</p>
</td></tr>
<tr><td><code>confint_back</code></td>
<td>
<p>Backtransformed parameters, with confidence intervals if available</p>
</td></tr>
<tr><td><code>ff</code></td>
<td>
<p>The estimated formation fractions derived from the fitted
model.</p>
</td></tr>
<tr><td><code>distimes</code></td>
<td>
<p>The DT50 and DT90 values for each observed variable.</p>
</td></tr>
<tr><td><code>SFORB</code></td>
<td>
<p>If applicable, eigenvalues of SFORB components of the model.</p>
</td></tr>
</table>
<p>The print method is called for its side effect, i.e. printing the summary.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke for the mkin specific parts
José Pinheiro and Douglas Bates for the components inherited from nlme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate five datasets following SFO kinetics
sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)
dt50_sfo_in_pop &lt;- 50
k_in_pop &lt;- log(2) / dt50_sfo_in_pop
set.seed(1234)
k_in &lt;- rlnorm(5, log(k_in_pop), 0.5)
SFO &lt;- mkinmod(parent = mkinsub("SFO"))

pred_sfo &lt;- function(k) {
  mkinpredict(SFO,
    c(k_parent = k),
    c(parent = 100),
    sampling_times)
}

ds_sfo_mean &lt;- lapply(k_in, pred_sfo)
names(ds_sfo_mean) &lt;- paste("ds", 1:5)

set.seed(12345)
ds_sfo_syn &lt;- lapply(ds_sfo_mean, function(ds) {
  add_err(ds,
    sdfunc = function(value) sqrt(1^2 + value^2 * 0.07^2),
    n = 1)[[1]]
})

## Not run: 
# Evaluate using mmkin and nlme
library(nlme)
f_mmkin &lt;- mmkin("SFO", ds_sfo_syn, quiet = TRUE, error_model = "tc", cores = 1)
f_nlme &lt;- nlme(f_mmkin)
summary(f_nlme, data = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.saem.mmkin'>Summary method for class &quot;saem.mmkin&quot;</h2><span id='topic+summary.saem.mmkin'></span><span id='topic+print.summary.saem.mmkin'></span>

<h3>Description</h3>

<p>Lists model equations, initial parameter values, optimised parameters
for fixed effects (population), random effects (deviations from the
population mean) and residual error model, as well as the resulting
endpoints such as formation fractions and DT50 values. Optionally
(default is FALSE), the data are listed in full.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'saem.mmkin'
summary(
  object,
  data = FALSE,
  verbose = FALSE,
  covariates = NULL,
  covariate_quantile = 0.5,
  distimes = TRUE,
  ...
)

## S3 method for class 'summary.saem.mmkin'
print(x, digits = max(3, getOption("digits") - 3), verbose = x$verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.saem.mmkin_+3A_object">object</code></td>
<td>
<p>an object of class <a href="#topic+saem.mmkin">saem.mmkin</a></p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_data">data</code></td>
<td>
<p>logical, indicating whether the full data should be included in
the summary.</p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_verbose">verbose</code></td>
<td>
<p>Should the summary be verbose?</p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_covariates">covariates</code></td>
<td>
<p>Numeric vector with covariate values for all variables in
any covariate models in the object. If given, it overrides 'covariate_quantile'.</p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_covariate_quantile">covariate_quantile</code></td>
<td>
<p>This argument only has an effect if the fitted
object has covariate models. If so, the default is to show endpoints
for the median of the covariate values (50th percentile).</p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_distimes">distimes</code></td>
<td>
<p>logical, indicating whether DT50 and DT90 values should be
included.</p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_...">...</code></td>
<td>
<p>optional arguments passed to methods like <code>print</code>.</p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+summary.saem.mmkin">summary.saem.mmkin</a></p>
</td></tr>
<tr><td><code id="summary.saem.mmkin_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary function returns a list based on the <a href="saemix.html#topic+SaemixObject-class">saemix::SaemixObject</a>
obtained in the fit, with at least the following additional components
</p>
<table>
<tr><td><code>saemixversion</code>, <code>mkinversion</code>, <code>Rversion</code></td>
<td>
<p>The saemix, mkin and R versions used</p>
</td></tr>
<tr><td><code>date.fit</code>, <code>date.summary</code></td>
<td>
<p>The dates where the fit and the summary were
produced</p>
</td></tr>
<tr><td><code>diffs</code></td>
<td>
<p>The differential equations used in the degradation model</p>
</td></tr>
<tr><td><code>use_of_ff</code></td>
<td>
<p>Was maximum or minimum use made of formation fractions</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data</p>
</td></tr>
<tr><td><code>confint_trans</code></td>
<td>
<p>Transformed parameters as used in the optimisation, with confidence intervals</p>
</td></tr>
<tr><td><code>confint_back</code></td>
<td>
<p>Backtransformed parameters, with confidence intervals if available</p>
</td></tr>
<tr><td><code>confint_errmod</code></td>
<td>
<p>Error model parameters with confidence intervals</p>
</td></tr>
<tr><td><code>ff</code></td>
<td>
<p>The estimated formation fractions derived from the fitted
model.</p>
</td></tr>
<tr><td><code>distimes</code></td>
<td>
<p>The DT50 and DT90 values for each observed variable.</p>
</td></tr>
<tr><td><code>SFORB</code></td>
<td>
<p>If applicable, eigenvalues of SFORB components of the model.</p>
</td></tr>
</table>
<p>The print method is called for its side effect, i.e. printing the summary.
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke for the mkin specific parts
saemix authors for the parts inherited from saemix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate five datasets following DFOP-SFO kinetics
sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)
dfop_sfo &lt;- mkinmod(parent = mkinsub("DFOP", "m1"),
 m1 = mkinsub("SFO"), quiet = TRUE)
set.seed(1234)
k1_in &lt;- rlnorm(5, log(0.1), 0.3)
k2_in &lt;- rlnorm(5, log(0.02), 0.3)
g_in &lt;- plogis(rnorm(5, qlogis(0.5), 0.3))
f_parent_to_m1_in &lt;- plogis(rnorm(5, qlogis(0.3), 0.3))
k_m1_in &lt;- rlnorm(5, log(0.02), 0.3)

pred_dfop_sfo &lt;- function(k1, k2, g, f_parent_to_m1, k_m1) {
  mkinpredict(dfop_sfo,
    c(k1 = k1, k2 = k2, g = g, f_parent_to_m1 = f_parent_to_m1, k_m1 = k_m1),
    c(parent = 100, m1 = 0),
    sampling_times)
}

ds_mean_dfop_sfo &lt;- lapply(1:5, function(i) {
  mkinpredict(dfop_sfo,
    c(k1 = k1_in[i], k2 = k2_in[i], g = g_in[i],
      f_parent_to_m1 = f_parent_to_m1_in[i], k_m1 = k_m1_in[i]),
    c(parent = 100, m1 = 0),
    sampling_times)
})
names(ds_mean_dfop_sfo) &lt;- paste("ds", 1:5)

ds_syn_dfop_sfo &lt;- lapply(ds_mean_dfop_sfo, function(ds) {
  add_err(ds,
    sdfunc = function(value) sqrt(1^2 + value^2 * 0.07^2),
    n = 1)[[1]]
})

## Not run: 
# Evaluate using mmkin and saem
f_mmkin_dfop_sfo &lt;- mmkin(list(dfop_sfo), ds_syn_dfop_sfo,
  quiet = TRUE, error_model = "tc", cores = 5)
f_saem_dfop_sfo &lt;- saem(f_mmkin_dfop_sfo)
print(f_saem_dfop_sfo)
illparms(f_saem_dfop_sfo)
f_saem_dfop_sfo_2 &lt;- update(f_saem_dfop_sfo,
  no_random_effect = c("parent_0", "log_k_m1"))
illparms(f_saem_dfop_sfo_2)
intervals(f_saem_dfop_sfo_2)
summary(f_saem_dfop_sfo_2, data = TRUE)
# Add a correlation between random effects of g and k2
cov_model_3 &lt;- f_saem_dfop_sfo_2$so@model@covariance.model
cov_model_3["log_k2", "g_qlogis"] &lt;- 1
cov_model_3["g_qlogis", "log_k2"] &lt;- 1
f_saem_dfop_sfo_3 &lt;- update(f_saem_dfop_sfo,
  covariance.model = cov_model_3)
intervals(f_saem_dfop_sfo_3)
# The correlation does not improve the fit judged by AIC and BIC, although
# the likelihood is higher with the additional parameter
anova(f_saem_dfop_sfo, f_saem_dfop_sfo_2, f_saem_dfop_sfo_3)

## End(Not run)

</code></pre>

<hr>
<h2 id='synthetic_data_for_UBA_2014'>
Synthetic datasets for one parent compound with two metabolites
</h2><span id='topic+synthetic_data_for_UBA_2014'></span>

<h3>Description</h3>

<p>The 12 datasets were generated using four different models and three different
variance components. The four models are either the SFO or the DFOP model with either
two sequential or two parallel metabolites.
</p>
<p>Variance component 'a' is based on a normal distribution with standard deviation of 3,
Variance component 'b' is also based on a normal distribution, but with a standard deviation of 7.
Variance component 'c' is based on the error model from Rocke and Lorenzato (1995), with the
minimum standard deviation (for small y values) of 0.5, and a proportionality constant of 0.07
for the increase of the standard deviation with y. Note that this is a simplified version
of the error model proposed by Rocke and Lorenzato (1995), as in their model the error of the
measured values approximates lognormal distribution for high values, whereas we are using
normally distributed error components all along.
</p>
<p>Initial concentrations for metabolites and all values where adding the variance component resulted
in a value below the assumed limit of detection of 0.1 were set to <code>NA</code>.
</p>
<p>As an example, the first dataset has the title <code>SFO_lin_a</code> and is based on the SFO model
with two sequential metabolites (linear pathway), with added variance component 'a'.
</p>
<p>Compare also the code in the example section to see the degradation models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic_data_for_UBA_2014</code></pre>


<h3>Format</h3>

<p>A list containing twelve datasets as an R6 class defined by <code><a href="#topic+mkinds">mkinds</a></code>,
each containing, among others, the following components
</p>

<dl>
<dt><code>title</code></dt><dd><p>The name of the dataset, e.g. <code>SFO_lin_a</code></p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame with the data in the form expected by <code><a href="#topic+mkinfit">mkinfit</a></code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Ranke (2014) Prüfung und Validierung von Modellierungssoftware als Alternative
zu ModelMaker 4.0, Umweltbundesamt Projektnummer 27452
</p>
<p>Rocke, David M. und Lorenzato, Stefan (1995) A two-component model for
measurement error in analytical chemistry. Technometrics 37(2), 176-184.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The data have been generated using the following kinetic models
m_synth_SFO_lin &lt;- mkinmod(parent = list(type = "SFO", to = "M1"),
                           M1 = list(type = "SFO", to = "M2"),
                           M2 = list(type = "SFO"), use_of_ff = "max")


m_synth_SFO_par &lt;- mkinmod(parent = list(type = "SFO", to = c("M1", "M2"),
                                         sink = FALSE),
                           M1 = list(type = "SFO"),
                           M2 = list(type = "SFO"), use_of_ff = "max")

m_synth_DFOP_lin &lt;- mkinmod(parent = list(type = "DFOP", to = "M1"),
                            M1 = list(type = "SFO", to = "M2"),
                            M2 = list(type = "SFO"), use_of_ff = "max")

m_synth_DFOP_par &lt;- mkinmod(parent = list(type = "DFOP", to = c("M1", "M2"),
                                          sink = FALSE),
                            M1 = list(type = "SFO"),
                            M2 = list(type = "SFO"), use_of_ff = "max")

# The model predictions without intentional error were generated as follows
sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)

d_synth_SFO_lin &lt;- mkinpredict(m_synth_SFO_lin,
                               c(k_parent = 0.7, f_parent_to_M1 = 0.8,
                                 k_M1 = 0.3, f_M1_to_M2 = 0.7,
                                 k_M2 = 0.02),
                               c(parent = 100, M1 = 0, M2 = 0),
                               sampling_times)

d_synth_DFOP_lin &lt;- mkinpredict(m_synth_DFOP_lin,
                                c(k1 = 0.2, k2 = 0.02, g = 0.5,
                                  f_parent_to_M1 = 0.5, k_M1 = 0.3,
                                  f_M1_to_M2 = 0.7, k_M2 = 0.02),
                                 c(parent = 100, M1 = 0, M2 = 0),
                                 sampling_times)

d_synth_SFO_par &lt;- mkinpredict(m_synth_SFO_par,
                               c(k_parent = 0.2,
                                 f_parent_to_M1 = 0.8, k_M1 = 0.01,
                                 f_parent_to_M2 = 0.2, k_M2 = 0.02),
                                 c(parent = 100, M1 = 0, M2 = 0),
                                 sampling_times)

d_synth_DFOP_par &lt;- mkinpredict(m_synth_DFOP_par,
                               c(k1 = 0.3, k2 = 0.02, g = 0.7,
                                 f_parent_to_M1 = 0.6, k_M1 = 0.04,
                                 f_parent_to_M2 = 0.4, k_M2 = 0.01),
                                 c(parent = 100, M1 = 0, M2 = 0),
                                 sampling_times)

# Construct names for datasets with errors
d_synth_names = paste0("d_synth_", c("SFO_lin", "SFO_par",
                                     "DFOP_lin", "DFOP_par"))

# Original function used or adding errors. The add_err function now published
# with this package is a slightly generalised version where the names of
# secondary compartments that should have an initial value of zero (M1 and M2
# in this case) are not hardcoded any more.
# add_err = function(d, sdfunc, LOD = 0.1, reps = 2, seed = 123456789)
# {
#   set.seed(seed)
#   d_long = mkin_wide_to_long(d, time = "time")
#   d_rep = data.frame(lapply(d_long, rep, each = 2))
#   d_rep$value = rnorm(length(d_rep$value), d_rep$value, sdfunc(d_rep$value))
#
#   d_rep[d_rep$time == 0 &amp; d_rep$name %in% c("M1", "M2"), "value"] &lt;- 0
#   d_NA &lt;- transform(d_rep, value = ifelse(value &lt; LOD, NA, value))
#   d_NA$value &lt;- round(d_NA$value, 1)
#   return(d_NA)
# }

# The following is the simplified version of the two-component model of Rocke
# and Lorenzato (1995)
sdfunc_twocomp = function(value, sd_low, rsd_high) {
  sqrt(sd_low^2 + value^2 * rsd_high^2)
}

# Add the errors.
for (d_synth_name in d_synth_names)
{
  d_synth = get(d_synth_name)
  assign(paste0(d_synth_name, "_a"), add_err(d_synth, function(value) 3))
  assign(paste0(d_synth_name, "_b"), add_err(d_synth, function(value) 7))
  assign(paste0(d_synth_name, "_c"), add_err(d_synth,
                           function(value) sdfunc_twocomp(value, 0.5, 0.07)))

}

d_synth_err_names = c(
  paste(rep(d_synth_names, each = 3), letters[1:3], sep = "_")
)

# This is just one example of an evaluation using the kinetic model used for
# the generation of the data
  fit &lt;- mkinfit(m_synth_SFO_lin, synthetic_data_for_UBA_2014[[1]]$data,
                 quiet = TRUE)
  plot_sep(fit)
  summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='test_data_from_UBA_2014'>
Three experimental datasets from two water sediment systems and one soil
</h2><span id='topic+test_data_from_UBA_2014'></span>

<h3>Description</h3>

<p>The datasets were used for the comparative validation of several kinetic evaluation
software packages (Ranke, 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_data_from_UBA_2014</code></pre>


<h3>Format</h3>

<p>A list containing three datasets as an R6 class defined by <code><a href="#topic+mkinds">mkinds</a></code>.
Each dataset has, among others, the following components
</p>

<dl>
<dt><code>title</code></dt><dd><p>The name of the dataset, e.g. <code>UBA_2014_WS_river</code></p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame with the data in the form expected by <code><a href="#topic+mkinfit">mkinfit</a></code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Ranke (2014) Prüfung und Validierung von Modellierungssoftware als Alternative
zu ModelMaker 4.0, Umweltbundesamt Projektnummer 27452
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  # This is a level P-II evaluation of the dataset according to the FOCUS kinetics
  # guidance. Due to the strong correlation of the parameter estimates, the
  # covariance matrix is not returned. Note that level P-II evaluations are
  # generally considered deprecated due to the frequent occurrence of such
  # large parameter correlations, among other reasons (e.g. the adequacy of the
  # model).
  m_ws &lt;- mkinmod(parent_w = mkinsub("SFO", "parent_s"),
                  parent_s = mkinsub("SFO", "parent_w"))
  f_river &lt;- mkinfit(m_ws, test_data_from_UBA_2014[[1]]$data, quiet = TRUE)
  plot_sep(f_river)

  summary(f_river)$bpar
  mkinerrmin(f_river)

  # This is the evaluation used for the validation of software packages
  # in the expertise from 2014
  m_soil &lt;- mkinmod(parent = mkinsub("SFO", c("M1", "M2")),
                    M1 = mkinsub("SFO", "M3"),
                    M2 = mkinsub("SFO", "M3"),
                    M3 = mkinsub("SFO"),
                    use_of_ff = "max")

  f_soil &lt;- mkinfit(m_soil, test_data_from_UBA_2014[[3]]$data, quiet = TRUE)
  plot_sep(f_soil, lpos = c("topright", "topright", "topright", "bottomright"))
  summary(f_soil)$bpar
  mkinerrmin(f_soil)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='transform_odeparms'>Functions to transform and backtransform kinetic parameters for fitting</h2><span id='topic+transform_odeparms'></span><span id='topic+backtransform_odeparms'></span>

<h3>Description</h3>

<p>The transformations are intended to map parameters that should only take on
restricted values to the full scale of real numbers. For kinetic rate
constants and other parameters that can only take on positive values, a
simple log transformation is used. For compositional parameters, such as the
formations fractions that should always sum up to 1 and can not be negative,
the <a href="#topic+ilr">ilr</a> transformation is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_odeparms(
  parms,
  mkinmod,
  transform_rates = TRUE,
  transform_fractions = TRUE
)

backtransform_odeparms(
  transparms,
  mkinmod,
  transform_rates = TRUE,
  transform_fractions = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_odeparms_+3A_parms">parms</code></td>
<td>
<p>Parameters of kinetic models as used in the differential
equations.</p>
</td></tr>
<tr><td><code id="transform_odeparms_+3A_mkinmod">mkinmod</code></td>
<td>
<p>The kinetic model of class <a href="#topic+mkinmod">mkinmod</a>, containing
the names of the model variables that are needed for grouping the
formation fractions before <a href="#topic+ilr">ilr</a> transformation, the parameter
names and the information if the pathway to sink is included in the model.</p>
</td></tr>
<tr><td><code id="transform_odeparms_+3A_transform_rates">transform_rates</code></td>
<td>
<p>Boolean specifying if kinetic rate constants should
be transformed in the model specification used in the fitting for better
compliance with the assumption of normal distribution of the estimator. If
TRUE, also alpha and beta parameters of the FOMC model are
log-transformed, as well as k1 and k2 rate constants for the DFOP and HS
models and the break point tb of the HS model.</p>
</td></tr>
<tr><td><code id="transform_odeparms_+3A_transform_fractions">transform_fractions</code></td>
<td>
<p>Boolean specifying if formation fractions
constants should be transformed in the model specification used in the
fitting for better compliance with the assumption of normal distribution
of the estimator. The default (TRUE) is to do transformations.
The g parameter of the DFOP model is also seen as a fraction.
If a single fraction is transformed (g parameter of DFOP or only a single
target variable e.g. a single metabolite plus a pathway to sink), a
logistic transformation is used <code><a href="stats.html#topic+Logistic">stats::qlogis()</a></code>. In other cases, i.e. if
two or more formation fractions need to be transformed whose sum cannot
exceed one, the <a href="#topic+ilr">ilr</a> transformation is used.</p>
</td></tr>
<tr><td><code id="transform_odeparms_+3A_transparms">transparms</code></td>
<td>
<p>Transformed parameters of kinetic models as used in the
fitting procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation of sets of formation fractions is fragile, as it supposes
the same ordering of the components in forward and backward transformation.
This is no problem for the internal use in <a href="#topic+mkinfit">mkinfit</a>.
</p>


<h3>Value</h3>

<p>A vector of transformed or backtransformed parameters
</p>


<h3>Author(s)</h3>

<p>Johannes Ranke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SFO_SFO &lt;- mkinmod(
  parent = list(type = "SFO", to = "m1", sink = TRUE),
  m1 = list(type = "SFO"), use_of_ff = "min")

# Fit the model to the FOCUS example dataset D using defaults
FOCUS_D &lt;- subset(FOCUS_2006_D, value != 0) # remove zero values to avoid warning
fit &lt;- mkinfit(SFO_SFO, FOCUS_D, quiet = TRUE)
fit.s &lt;- summary(fit)
# Transformed and backtransformed parameters
print(fit.s$par, 3)
print(fit.s$bpar, 3)

## Not run: 
# Compare to the version without transforming rate parameters (does not work
# with analytical solution, we get NA values for m1 in predictions)
fit.2 &lt;- mkinfit(SFO_SFO, FOCUS_D, transform_rates = FALSE,
  solution_type = "deSolve", quiet = TRUE)
fit.2.s &lt;- summary(fit.2)
print(fit.2.s$par, 3)
print(fit.2.s$bpar, 3)

## End(Not run)

initials &lt;- fit$start$value
names(initials) &lt;- rownames(fit$start)
transformed &lt;- fit$start_transformed$value
names(transformed) &lt;- rownames(fit$start_transformed)
transform_odeparms(initials, SFO_SFO)
backtransform_odeparms(transformed, SFO_SFO)

## Not run: 
# The case of formation fractions (this is now the default)
SFO_SFO.ff &lt;- mkinmod(
  parent = list(type = "SFO", to = "m1", sink = TRUE),
  m1 = list(type = "SFO"),
  use_of_ff = "max")

fit.ff &lt;- mkinfit(SFO_SFO.ff, FOCUS_D, quiet = TRUE)
fit.ff.s &lt;- summary(fit.ff)
print(fit.ff.s$par, 3)
print(fit.ff.s$bpar, 3)
initials &lt;- c("f_parent_to_m1" = 0.5)
transformed &lt;- transform_odeparms(initials, SFO_SFO.ff)
backtransform_odeparms(transformed, SFO_SFO.ff)

# And without sink
SFO_SFO.ff.2 &lt;- mkinmod(
  parent = list(type = "SFO", to = "m1", sink = FALSE),
  m1 = list(type = "SFO"),
  use_of_ff = "max")


fit.ff.2 &lt;- mkinfit(SFO_SFO.ff.2, FOCUS_D, quiet = TRUE)
fit.ff.2.s &lt;- summary(fit.ff.2)
print(fit.ff.2.s$par, 3)
print(fit.ff.2.s$bpar, 3)

## End(Not run)

</code></pre>

<hr>
<h2 id='update.mkinfit'>Update an mkinfit model with different arguments</h2><span id='topic+update.mkinfit'></span>

<h3>Description</h3>

<p>This function will return an updated mkinfit object. The fitted degradation
model parameters from the old fit are used as starting values for the
updated fit. Values specified as 'parms.ini' and/or 'state.ini' will
override these starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkinfit'
update(object, ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.mkinfit_+3A_object">object</code></td>
<td>
<p>An mkinfit object to be updated</p>
</td></tr>
<tr><td><code id="update.mkinfit_+3A_...">...</code></td>
<td>
<p>Arguments to <code><a href="#topic+mkinfit">mkinfit</a></code> that should replace
the arguments from the original call. Arguments set to NULL will
remove arguments given in the original call</p>
</td></tr>
<tr><td><code id="update.mkinfit_+3A_evaluate">evaluate</code></td>
<td>
<p>Should the call be evaluated or returned as a call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- mkinfit("SFO", subset(FOCUS_2006_D, value != 0), quiet = TRUE)
parms(fit)
plot_err(fit)
fit_2 &lt;- update(fit, error_model = "tc")
parms(fit_2)
plot_err(fit_2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
