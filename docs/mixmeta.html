<!DOCTYPE html><html lang="en"><head><title>Help for package mixmeta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mixmeta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mixmeta-package'>
<p>An Extended Mixed-Effects Framework for Meta-Analysis</p></a></li>
<li><a href='#alcohol'><p> Alcohol Intake and Colorectal Cancer</p></a></li>
<li><a href='#bcg'><p> Efficacy of BCG Vaccine in the Prevention of Tuberculosis</p></a></li>
<li><a href='#bdiagMat'><p> Block-Diagonal Expansion of a List of Matrices</p></a></li>
<li><a href='#berkey98'><p> Five Published Trials on Periodontal Disease</p></a></li>
<li><a href='#blup'><p> Best Linear Unbiased Predictions</p></a></li>
<li><a href='#blup.mixmeta'><p> Best Linear Unbiased Predictions from mixmeta Models</p></a></li>
<li><a href='#coef.mixmeta'><p> Extract Coefficients and (Co)Variance Matrix from mixmeta Objects</p></a></li>
<li><a href='#dbs'><p> Deep-Brain Stimulation for Patients with Parkinson's Disease</p></a></li>
<li><a href='#fibrinogen'><p> Fibrinogen Studies Collaboration</p></a></li>
<li><a href='#gliomas'><p> Randomized Trials on Therapies for Malignant Gliomas</p></a></li>
<li><a href='#hsls'><p> High School Longitudinal Study</p></a></li>
<li><a href='#hyp'><p> Ten Studies Assessing an Hypertension Treatment</p></a></li>
<li><a href='#inputcov'><p> Input (Co)Variance Matrices</p></a></li>
<li><a href='#inputna'><p> Input Missing Values</p></a></li>
<li><a href='#logLik.mixmeta'><p> Extract Log-Likelihood from mixmeta Objects</p></a></li>
<li><a href='#mixmeta'><p> Fitting Standard and Extended Meta-Analysis and Meta-Regression Models</p></a></li>
<li><a href='#mixmeta.control'><p> Ancillary Parameters for Controlling the Fit in mixmeta Models</p></a></li>
<li><a href='#mixmeta.fixed'><p> Fixed-Effects Estimator for mixmeta Models</p></a></li>
<li><a href='#mixmeta.ml'><p> ML and REML Estimators for mixmeta Models</p></a></li>
<li><a href='#mixmeta.mm'><p> Method of Moments Estimator for mixmeta Models</p></a></li>
<li><a href='#mixmeta.vc'><p> Variance Components Estimator for mixmeta Models</p></a></li>
<li><a href='#mixmetaCovStruct'><p> (Co)variance Structures for mixmeta Models</p></a></li>
<li><a href='#mixmetaFormula'><p> Formulae in mixmeta Models</p></a></li>
<li><a href='#mixmetaObject'><p> mixmeta Objects</p></a></li>
<li><a href='#mixmetaSim'><p> Simulating Responses for mixmeta Models</p></a></li>
<li><a href='#ml.igls'><p> IGLS and RIGLS Iterative Algorithms for mixmeta Models</p></a></li>
<li><a href='#ml.loglik.fn'><p> Likelihood Functions for mixmeta Models</p></a></li>
<li><a href='#ml.newton'><p> Quasi-Newton Iterative Algorithms for mixmeta Models</p></a></li>
<li><a href='#model.frame.mixmeta'><p> Extract Model Frame and Design Matrix from mixmeta Objects</p></a></li>
<li><a href='#na.omit.data.frame.mixmeta'><p> Handling Missing Values in mixmeta Models</p></a></li>
<li><a href='#p53'><p> Mutant p53 Gene and Squamous Cell Carcinoma</p></a></li>
<li><a href='#predict.mixmeta'><p> Predicted Values from mixmeta Models</p></a></li>
<li><a href='#qtest'><p> Cochran Q Test of Heterogeneity</p></a></li>
<li><a href='#qtest.mixmeta'><p> Cochran Q Test of Heterogeneity for mixmeta Models</p></a></li>
<li><a href='#school'><p> Studies on Modified School Calendar and Student Achievement</p></a></li>
<li><a href='#smoking'><p> Meta-Analysis of Interventions to Promote Smoking Cessation</p></a></li>
<li><a href='#summary.mixmeta'><p> Summarizing mixmeta Models</p></a></li>
<li><a href='#terms.mixmeta'><p> Extract Model Terms from mixmeta Objects</p></a></li>
<li><a href='#thrombolytic'><p> Randomized Trials of Thrombolytic Therapy</p></a></li>
<li><a href='#vechMat'><p> Vectorization and Expansion of Symmetric Matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-10</td>
</tr>
<tr>
<td>Title:</td>
<td>An Extended Mixed-Effects Framework for Meta-Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to perform various meta-analytical models
  through a unified mixed-effects framework, including standard univariate
  fixed and random-effects meta-analysis and meta-regression, and non-standard
  extensions such as multivariate, multilevel, longitudinal, and dose-response
  models.</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Gasparrini [aut, cre],
  Francesco Sera [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Gasparrini &lt;antonio.gasparrini@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>metafor, meta, rmeta, dosresmeta, nlme, MASS, dlnm</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gasparrini/mixmeta">https://github.com/gasparrini/mixmeta</a>,
<a href="http://www.ag-myresearch.com/package-mixmeta">http://www.ag-myresearch.com/package-mixmeta</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-16 14:22:56 UTC; anton</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-16 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mixmeta-package'>
An Extended Mixed-Effects Framework for Meta-Analysis
</h2><span id='topic+mixmeta-package'></span>

<h3>Description</h3>

<p>The package <span class="pkg">mixmeta</span> consists of a collection of functions to perform various meta-analytical models in <span class="rlang"><b>R</b></span> through a unified mixed-effects framework, including standard univariate fixed and random-effects meta-analysis and meta-regression, and non-standard extensions such as multivariate, multilevel, longitudinal, and dose-response models.
</p>


<h3>Modelling framework</h3>

<p>Standard applications of meta-analysis amount to the pooling of estimates of a single effect size, here defined generally as outcome, collected as unique observations in a set of independent studies, together with a measure of uncertainty (usually standard errors). Fixed-effects models do not assume heterogeneity across studies, and the estimates are conditional on the set of studies collected in the meta-analysis. Random-effects meta-analysis, instead, allows a degree of heterogeneity among studies, assuming the (true but unobserved) study-specific outcomes as randomly sampled from a (usually hypothetical) population of studies. Meta-regression extends both fixed and random-effects methods by allowing the pooled outcome to depend on study-level meta-predictors.
</p>
<p>However, this traditional setting can be limited for many modern applications of meta-analysis. For instance, studies can provide estimates of different outcomes. Alternatively, studies can collect multiple estimates of the same outcome, either longitudinally or referring to different groups or levels of a continuous variable. Similarly, studies can be clustered, or being characterized by a hierarchical structure (i.e., by country). In all these instances, the key assumption of independence across estimates is not met, and basic models must be extended to consider potentially complex correlation structures within and between studies. This leads to extension to multivariate, multilevel, longitudinal, or dose-response models for meta-analysis, among others.
</p>
<p>A unified modelling framework can be defined by casting the meta-analytical problem as a linear mixed model. In general terms, we assume that there is a set of <code class="reqn">n</code> observations of <code class="reqn">k</code> different outcomes, representing <em>units</em> of analysis aggregated in <code class="reqn">i = 1,\dots,m</code> <em>groups</em> that are considered independent. An extended random-effects meta-regression model for the <code class="reqn">\boldsymbol{y}_i</code> outcomes in group <code class="reqn">i</code> can be generally written as:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_i = \boldsymbol{X}_i\boldsymbol{\beta} +  \boldsymbol{Z}_i\boldsymbol{b} + \boldsymbol{\epsilon}_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{b} \sim \mbox{N}(\boldsymbol{0},\boldsymbol{\Psi}) , \boldsymbol{\epsilon}_i \sim \mbox{N}(\boldsymbol{0},\boldsymbol{S}_i)</code>
</p>

<p>Here, <code class="reqn">\boldsymbol{X}_i\boldsymbol{\beta}</code> defines the fixed effects that represent the population-averaged outcomes in terms of <code class="reqn">p</code> unit-level predictors in the design matrix <code class="reqn">\boldsymbol{X}_i</code> with fixed-effects coefficients <code class="reqn">\boldsymbol{\beta}</code>. The random part of the model <code class="reqn">\boldsymbol{Z}_i\boldsymbol{b}</code> describes the deviation from the population averages in terms of <code class="reqn">q</code> unit-level predictors in the design matrix <code class="reqn">\boldsymbol{Z}_i</code> and random-effects coefficients <code class="reqn">\boldsymbol{b}</code>. The marginal (co)variance matrix <code class="reqn">\boldsymbol{\Sigma}_i = \boldsymbol{Z}\boldsymbol{\Psi}\boldsymbol{Z}^t + \boldsymbol{S}_i</code> is given by the sum of within (assumed known) and between-group contributions, defined by (co)variance matrices <code class="reqn">\boldsymbol{S}_i</code> and <code class="reqn">\boldsymbol{\Psi}</code>, respectively.
</p>
<p>All the models mentioned above, and other extensions, can be described as special cases of this unified framework. Specifically, in the standard random-effects univariate meta-analysis or meta-regression, each group represents a study with a single observation (<code class="reqn">n=m</code>), where <code class="reqn">\boldsymbol{Z_i=1}</code> (<code class="reqn">q=1</code>), and <code class="reqn">\boldsymbol{y}_i</code>, <code class="reqn">\boldsymbol{S}_i</code> and <code class="reqn">\boldsymbol{\Psi}</code> are scalars. In fixed-effects models, <code class="reqn">\boldsymbol{\Psi}</code> and <code class="reqn">\boldsymbol{Z_i}</code> do not exist. In multivariate models, the <code class="reqn">k</code>-dimensional <code class="reqn">\boldsymbol{y}_i</code> represents the different outcomes from study <code class="reqn">i</code>, <code class="reqn">\boldsymbol{X}_i</code> is Kronecker-expanded to <code class="reqn">k \times kp</code>, and <code class="reqn">\boldsymbol{S}_i</code> and <code class="reqn">\boldsymbol{\Psi}</code> are <code class="reqn">k \times k</code> matrices representing within and between-study correlations among outcomes, respectively. In multilevel models, where additional inner levels of grouping exist within each of the <code class="reqn">m</code> outer-level groups, <code class="reqn">q</code> is the sum of level-specific meta-predictors, while <code class="reqn">\boldsymbol{\Psi}</code> and <code class="reqn">\boldsymbol{Z}_i</code> have a block-diagonal and column-binded (and expanded) forms, respectively, with each part referring to a different level. In longitudinal and dose-response models, repeated measures are accomodated in a similar way through random-effects grouping.
</p>


<h3>Estimation methods</h3>

<p>The aim is to estimate the <code class="reqn">kp</code> coefficients <code class="reqn">\boldsymbol{\beta}</code> and, for random-effects models, the components of the between-group (co)variance matrix <code class="reqn">\boldsymbol{\Psi}</code>. The parameters for the random part depend on the number of random-effects levels, and for each of them, on the number of random-effects meta-predictors and the structure of the related part of the (co)variance matrix, with a maximum of <code class="reqn">kq(kq+1)/2</code> for single-level unstructured <code class="reqn">\boldsymbol{\Psi}</code>.
</p>
<p>Different estimators are implemented in the package <span class="pkg">mixmeta</span>. The options available in the current version are:
</p>

<ul>
<li> <p><b>Fixed-effects</b>
</p>
</li>
<li> <p><b>Maximum likelihood</b> (ML)
</p>
</li>
<li> <p><b>Restricted maximum likelihood</b> (REML)
</p>
</li>
<li> <p><b>Method of moments</b>
</p>
</li>
<li> <p><b>Variance components</b>
</p>
</li></ul>

<p>The fixed-effects model is fitted through generalized least squares (GLS), assuming the (co)variance structure, composed by the within-study errors only, as completely known. Likelihood-based random-effects estimators, ML and REML, represent the most comprehensive implementation of the modelling framework, and allow the specification all the various models described in the previous section through a flexible definition of the random-effects structure. They rely on two alternative iterative optimization procedures, based on Newton-type and (restricted) iterative generalized least squares (IGLS and RIGLS) algorithms, respectively. Estimators based on semiparametric alternatives such as the non-iterative method of moments or the iterative variance components are also included, although they are only available for models with a basic random-effects structure. Further details on estimation methods are given in the related help pages.
</p>


<h3>Functions included in the package</h3>

<p>The main function in the package is <code><a href="#topic+mixmeta">mixmeta</a></code>, which performs the various models illustrated above. This function resembles standard regression functions in <span class="rlang"><b>R</b></span>, and specifies the model through regression formulae for fixed and random-effects (see <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>). The function returns a list object of class <code>"mixmeta"</code> (see <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>).
</p>
<p>The estimation is carried out internally through <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code>, a wrapper which accepts data in a specific format, then prepares the various data components and calls ad hoc estimation functions for fitting the models. Specifically, <code><a href="#topic+mixmeta.fixed">mixmeta.fixed</a></code> is applied for fixed-effects models, while estimators for random-effects models are implemented in the functions <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> and <code><a href="#topic+mixmeta.reml">mixmeta.reml</a></code> for (restricted) maximum likelihood, <code><a href="#topic+mixmeta.mm">mixmeta.mm</a></code> for the method of moments, and <code><a href="#topic+mixmeta.vc">mixmeta.vc</a></code> for variance components. For likelihood-based methods, alternative iterative optimizations methods are provided in two sets of functions implementing <code><a href="#topic+ml.newton">Newton-type</a></code> and <code><a href="#topic+ml.igls">(R)IGLS</a></code> algorithms used for maximizing the (restricted) likelihood. The former method applies specific <code><a href="#topic+ml.loglik.fn">likelihood functions</a></code>. Various types of likelihood-based models are defined by separate regression formulae for fixed and random-effects (see <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>). Specific <code><a href="#topic+mixmetaCovStruct">(co)variance structures</a></code> for the between-group random effects at single or multiple levels are available. Fitting parameter options are set by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.
</p>
<p>Method functions are available for objects of class <code>"mixmeta"</code> (see <code><a href="#topic+mixmetaObject">mixmetaObject</a></code> for a complete list). The method <code><a href="#topic+summary.mixmeta">summary</a></code> produces a list of class <code>"summary.mixmeta"</code> for summarizing the fit of the model and providing additional results. The method function <code><a href="#topic+predict.mixmeta">predict</a></code> computes predicted values, optionally for a set of new values of the predictors. <code><a href="#topic+blup.mixmeta">blup</a></code> gives the (empirical) best linear unbiased predictions for the set of studies used for estimation. Other default or specific method functions for regression can be used on objects of class <code>"mixmeta"</code>, such as <code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+logLik.mixmeta">logLik</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>, or <code><a href="stats.html#topic+drop1">drop1</a></code> and <code><a href="stats.html#topic+add1">add1</a></code>, among others.
</p>
<p>Methods for <code><a href="#topic+model.frame.mixmeta">model.frame</a></code>, <code><a href="#topic+model.matrix.mixmeta">model.matrix</a></code>, and <code><a href="#topic+terms.mixmeta">terms</a></code> are used to extract or construct the model frame, the design matrix, or the terms of the regression meta-analytical model, respectively. These specific methods for objects of class <code>"mixmeta"</code> are needed to appropriately deal with missing values and to account for model frames that include terms for both the fixed and random parts. In particular, methods for <code><a href="#topic+na.omit.data.frame.mixmeta">na.omit</a></code> and <code><a href="#topic+na.exclude.data.frame.mixmeta">na.exclude</a></code> are used to handle correctly missing values.
</p>
<p>Simulations can be produced using the function <code><a href="#topic+mixmetaSim">mixmetaSim</a></code> and the method function <code><a href="#topic+simulate.mixmeta">simulate</a></code>, which return one or multiple sets of simulated outcomes for a group of studies. The function <code><a href="#topic+inputna">inputna</a></code> and <code><a href="#topic+inputcov">inputcov</a></code> are used internally to augment the missing data values and to input missing correlations, respectively.
</p>
<p>The method function <code><a href="#topic+qtest.mixmeta">qtest.mixmeta</a></code> (producing an object with class of the same name) performs the (multivariate) Cochran Q test for (residual) heterogeneity. For multivariate models, the function returns both an overall estimate and those for each single outcome. The generic method function is <code><a href="#topic+qtest">qtest</a></code>.
</p>
<p>Printing functions for the objects of classes defined above are also provided. Other functions are used internally in the source code, and not exported in the namespace. For users interested in getting into details of the package structure, these functions can be displayed using the triple colon ('<code>:::</code>') operator. For instance, <code>mixmeta:::glsfit</code> displays the code of the function <code>glsfit</code>. Also, some comments are added in the original source code.
</p>


<h3>Datasets and applications</h3>

<p>The package includes several datasets used for applications of the extended meta-analytical framework. The related help pages provide examples of specific models, and fully demonstrate the flexibility of the extended meta-analytical framework. In particular:
</p>

<ul>
<li> <p><b>Standard meta-analysis</b> is illustrated using the dataset <code><a href="#topic+bcg">bcg</a></code>, including examples of meta-regression.
</p>
</li>
<li> <p><b>Multivariate meta-analysis</b> is performed using various datasets, including bivariate models (<code><a href="#topic+berkey98">berkey98</a></code>, <code><a href="#topic+hyp">hyp</a></code>, <code><a href="#topic+p53">p53</a></code>) and multivariate models with three or more outcomes (<code><a href="#topic+fibrinogen">fibrinogen</a></code> and <code><a href="#topic+hsls">hsls</a></code>). The examples describe also how to deal with missing data or missing within-group correlations, and multivariate meta-regression.
</p>
</li>
<li> <p><b>Network meta-analysis</b> is shown in the dataset <code><a href="#topic+smoking">smoking</a></code>. The examples illustrate an indirect mixed-treatment comparison including consistency and inconsistency models.
</p>
</li>
<li> <p><b>Multilevel meta-analysis</b> is displayed in the examples of the datasets <code><a href="#topic+school">school</a></code> and <code><a href="#topic+thrombolytic">thrombolytic</a></code>, and include data with multiple nested levels of grouping and/or repeated measures within each group.
</p>
</li>
<li> <p><b>Dose-response meta-analysis</b> is illustrated in the dataset <code><a href="#topic+alcohol">alcohol</a></code>, using the recently proposed one-stage approach.
</p>
</li>
<li> <p><b>Longitudinal meta-analysis</b> is performed using the datasets <code><a href="#topic+dbs">dbs</a></code> and <code><a href="#topic+gliomas">gliomas</a></code>. The two sets of examples present different cases using data in wide and long format, respectively.
</p>
</li></ul>



<h3>Additional information</h3>

<p>The <span class="pkg">mixmeta</span> package is available on the Comprehensive R Archive Network (CRAN), with info at the related web page (<a href="https://CRAN.R-project.org/package=mixmeta">CRAN.R-project.org/package=mixmeta</a>). A development website is available on GitHub (<a href="https://github.com/gasparrini/mixmeta">github.com/gasparrini/mixmeta</a>). General information on the development and applications of this extended meta-analytical modelling framework, together with an updated version of the <span class="rlang"><b>R</b></span> scripts for running the examples in published papers, can be found in GitHub (<a href="https://github.com/gasparrini">github.com/gasparrini</a>) or at the personal web page of the package maintainer (<a href="http://www.ag-myresearch.com">www.ag-myresearch.com</a>).
</p>
<p>The package <span class="pkg">mixmeta</span> is an extension of the package <span class="pkg">mvmeta</span>, previously developed to perform multivariate meta-analytical models. The latter now depends on the former, and while both are still maintained, users are encouraged to switch to <span class="pkg">mixmeta</span> as it represents a more general and updated option. A list of changes included in the current and previous versions of <span class="pkg">mixmeta</span> can be found by typing:
</p>
<p><code>news(package="mixmeta")</code>
</p>
<p>Use <code>citation("mixmeta")</code> to cite this package.
</p>


<h3>Warnings</h3>

<p>This release of the package <span class="pkg">mixmeta</span> has been tested with different simulated and real datasets. The functions generally perform well under several scenarios, and comparisons with alternative software implementations show good agreement. However, bugs and bad performance under un-tested conditions may not be excluded. Please report any error or unexpected behaviour to the e-mail address below.
</p>


<h3>Note</h3>

<p>The package <span class="pkg">mixmeta</span> provides a unified modelling framework to perform standard and non-standard meta-analytical models. However, some of these can also be fitted using routines available in other <span class="rlang"><b>R</b></span> packages.
</p>
<p>For instance, many packages such as <span class="pkg">metafor</span>, <span class="pkg">meta</span>, <span class="pkg">rmeta</span> provide a more exhaustive and efficient set of methods for standard univariate meta-analysis and meta-regression, including a wide range or functions for specific plots and statistical tests.
</p>
<p>Specific modelling extensions are also provided by other packages. For example, multivariate or multilevel models can be also be fitted using functions in <span class="pkg">metafor</span> and <span class="pkg">metaSEM</span>, while dose-response meta-analysis and meta-analysis of diagnostic measures can be performed using <span class="pkg">dosresmeta</span> and <span class="pkg">mada</span>, respectively.
</p>
<p>See the CRAN Task View <a href="https://cran.r-project.org/view=MetaAnalysis">Meta-Analysis</a> for a comprehensive illustration of methods available in various <span class="rlang"><b>R</b></span> packages.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini and Francesco Sera
</p>
<p>Maintainer: Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;
</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Gasparrini A, Armstrong B, Kenward MG (2012). Multivariate meta-analysis for non-linear and other multi-parameter associations. <em>Statistics in Medicine</em>. <b>31</b>(29):3821&ndash;3839. [Freely available <a href="http://www.ag-myresearch.com/2012_gasparrini_statmed.html"><b>here</b></a>].
</p>
<p>Pinheiro JC and Bates DM (2000). <em>Mixed-Effects Models in S and S-PLUS</em>. New York, Springer Verlag.
</p>
<p>Lindstrom MJ and Bates DM (1988). Newton-Raphson and EM algorithms for linear mixed-effects models for repeated-measures data. <em>Journal of the American Statistical Association</em>. <b>83</b>(404):1014&ndash;1022.
</p>
<p>Goldstein H (1986). Multilevel mixed linear model analysis using iterative generalized least squares. <em>Biometrika</em>. <b>73</b>(1):43&ndash;56.
</p>
<p>Goldstein H (1992). Efficient computational procedures for the estimation of parameters in multilevel models based on iterative generalized least squares. <em>Computational Statistics \&amp; Data Analysis</em>. <b>13</b>(1):63&ndash;71.
</p>
<p>Stram DO (1996). Meta-analysis of published data using a linear mixed-effects model. <em>Biometrics</em>. <b>52</b>(2):536&ndash;544.
</p>
<p>Stevens JR, Taylor AM. Hierarchical dependence in meta-analysis. <em>Journal of Educational and Behavioral Statistics</em>. <b>34</b>(1):46&ndash;73.
</p>
<p>Jackson D, Riley R, White IR (2011). Multivariate meta-analysis: Potential and promise. <em>Statistics in Medicine</em>. <b>30</b>(20);2481&ndash;2498.
</p>
<p>Goldstein H, et al (2000). Meta-analysis using multilevel models with an application to the study of class size effects. <em>Journal of the Royal Statistical Society: Series C (Applied Statistics)</em>. <b>49</b>(3):399&ndash;412.
</p>
<p>Crippa A, et al (2019). One-stage dose-response meta-analysis for aggregated data. <em>Statistical Methods in Medical Research</em>.  <b>28</b>(5):1579&ndash;1596.
</p>
<p>Ishak KJ, Platt RW, Joseph L, et al (2007). Meta-analysis of longitudinal studies. <em>Clinical Trials</em>. <b>4</b>(5):525&ndash;539.
</p>

<hr>
<h2 id='alcohol'> Alcohol Intake and Colorectal Cancer </h2><span id='topic+alcohol'></span>

<h3>Description</h3>

<p>The dataset contains the data on 8 cohort studies participating in the Pooling Project of Prospective Studies of Diet and Cancer. A total of 3,646 cases and 2,511,424 person-years were included in the analysis. Each study estimated the incidence relative rate in different categories of alcohol intake while controlling for a set of potential confounders, using non-drinkers as the reference. The categories where then converted in a dose by assigning to each the median value of individual consumptions, with studies reporting estimates at different levels in a continuous scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alcohol</code></pre>


<h3>Format</h3>

<p>A data frame with 48 observations on the following 7 variables:
</p>

<ul>
<li><p><code>id</code>: label for each study, derived from the first author's name.
</p>
</li>
<li><p><code>type</code>: code for study design (cohort estimating incidence rate).
</p>
</li>
<li><p><code>dose</code>: assigned dose level (gr/day of alcohol intake).
</p>
</li>
<li><p><code>cases</code>: number of cases for each dose category.
</p>
</li>
<li><p><code>peryears</code>: amount of person-time for each dose category.
</p>
</li>
<li><p><code>logrr</code>: estimated logarithm of the incidence relative rate.
</p>
</li>
<li><p><code>se</code>: standard error of the estimates.
</p>
</li></ul>



<h3>Details</h3>

<p>The data are stored in a <em>long</em> format, with each record reporting the information for each dose categories and studies including multiple records. The reference category for each study included, although the log-RR is fixed to 0 with no standard error (comparing the category with itself). The information on these reference categories is needed to compute the approximate correlations between estimates in the same study.
</p>


<h3>Note</h3>

<p>The data provide an example of application of dose-response meta-analysis, with repeated measurements of the effect size associated to different doses within each study. This requires a modelling structure that accounts for both within and between-study correlations of repeated measurements. The within-study correlations are usually reconstructed from published data using specific methods. Results can be compared with those reported by Crippa and Orsini (2016) and Orsini and colleagues (2012), although they are not identical: while the original analysis used a two-stage approach, the modelling framework applied here follows the more recent one-stage dose-response meta-analysis proposed by Crippa and collegues (2019).
</p>
<p>The dataset is also available in the same format in the dataframe <code>alcohol_crc</code> of the package <span class="pkg">dosresmeta</span>.
</p>


<h3>Source</h3>

<p>Crippa A, et al (2019). One-stage dose-response meta-analysis for aggregated data. <em>Statistical Methods in Medical Research</em>.  <b>28</b>(5):1579&ndash;1596.
</p>
<p>Crippa A, Orsini N (2016). Multivariate dose-response meta-analysis: The dosresmeta R package. <em>Journal of Statistical Software</em>. <b>72</b>(1):1&ndash;15.
</p>
<p>Orsini N, et al (2012). Meta-analysis for linear and nonlinear dose-response relations: examples, an evaluation of approximations, and software. <em>American Journal of Epidemiology</em>. <b>175</b>(1):66&ndash;73.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN CRIPPA ET AL (2016) AND ORSINI ET AL (2012)

# LOAD THE PACKAGE dosresmeta AND splines
library(dosresmeta) ; library(splines)

# COMPUTE THE WITHIN-STUDY CORRELATIONS EXCLUDING THE REFERENCE
addS &lt;- lapply(split(alcohol, alcohol$id), function(x)
  covar.logrr(y=logrr, v=se^2, cases=cases, n=peryears, type=type, data=x))
sub &lt;- subset(alcohol, !is.na(se))

# NOT ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
nocor &lt;- mixmeta(logrr ~ 0 + dose, S=se^2, random= ~ 0 + dose|id, data=sub,
  method="ml")
summary(nocor)

# ACCOUNTING FOR WITHIN-STUDY CORRELATIONS
lin &lt;- mixmeta(logrr ~ 0 + dose, random= ~ 0 + dose|id, data=sub, method="ml",
  control=list(addSlist=addS))
summary(lin)

# ALLOWING NON-LINEARITY IN BOTH FIXED AND RANDOM PARTS
nonlin &lt;- mixmeta(logrr ~ 0 + ns(dose, knots=c(10,25)), data=sub, 
  random= ~ 0 + ns(dose, knots=c(10,25))|id, method="ml",
  control=list(addSlist=addS))
summary(nonlin)

# SIMPLIFY THE MODEL BY ASSUMING LINEARITY IN THE RANDOM PART
nonlin2 &lt;- update(nonlin, random= ~ 0 + dose|id)
summary(nonlin2)

# FIXED-EFFECTS MODEL (TRICK: random TO DEFINE THE GROUPING, THEN FIX IT TO 0)
nonlinfix &lt;- mixmeta(logrr ~ 0 + ns(dose, knots=c(10,25)), random= ~ 1|id,
  data=sub, method="ml",bscov="fixed", control=list(addSlist=addS, Psifix=0))
summary(nonlinfix)

# COMPARE THE MODELS
AIC(nocor, lin, nonlin, nonlin2, nonlinfix)

# PREDICT THE RR FOR 12g/day FOM TWO MODELS
exp(predict(nocor, newdata=data.frame(dose=12), ci=TRUE))
exp(predict(lin, newdata=data.frame(dose=12), ci=TRUE))

# PREDICT (RECREATE SPLINES FOR EASY CODING)
predlin &lt;- exp(predict(lin, newdata=data.frame(dose=0:60), ci=TRUE))
prednonlin &lt;- exp(predict(nonlin, newdata=data.frame(dose=0:60), ci=TRUE))

# DISPLAY THE NON-LINEAR EFFECT
col1 &lt;- do.call(rgb, c(as.list(col2rgb("blue") / 255), list(0.2)))
col2 &lt;- do.call(rgb, c(as.list(col2rgb("green") / 255), list(0.2)))
plot(0:60, predlin[,1], type="l", ylim=c(0.85,1.9), ylab="RR",
  xlab="Alcohol intake (gr/day)", main="Dose-response")
polygon(c(0:60,60:0), c(predlin[,2], rev(predlin[,3])), col=col1, border=NA)
lines(0:60,prednonlin[,1], lty=5)
polygon(c(0:60,60:0), c(prednonlin[,2],rev(prednonlin[,3])), col=col2, border=NA)
</code></pre>

<hr>
<h2 id='bcg'> Efficacy of BCG Vaccine in the Prevention of Tuberculosis </h2><span id='topic+bcg'></span>

<h3>Description</h3>

<p>The dataset contains the data on 13 prospective clinical trials that compared the rates of tubercolosis in groups vaccinated with the Bacillus Calmette-Guerin (BCG) vaccine and non-vaccinated control populations. The outcome here is reported as both relative risk (RR) and odds ratio (OR), with associated uncertanty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcg</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 13 variables:
</p>

<ul>
<li><p><code>trial</code>: sequence identifying the trial.
</p>
</li>
<li><p><code>author</code>: label identifying the author(s).
</p>
</li>
<li><p><code>year</code>: year of publication.
</p>
</li>
<li><p><code>tpos, tneg</code>: number of positive and negative TB cases in the treated (vaccinated) group.
</p>
</li>
<li><p><code>cpos, cneg</code>: number of positive and negative TB cases in the control (non-vaccinated) group.
</p>
</li>
<li><p><code>ablat</code>: absolute latitude of the study location (in degrees).
</p>
</li>
<li><p><code>alloc</code>: method of treatment allocation (random, alternate, or systematic assignment).
</p>
</li></ul>



<h3>Note</h3>

<p>The data provide an example of application of standard univariate meta-analysis and meta-regression, with independent studies providing a single estimate of a single effect size. Interestingly, the data can be analyzed also as a multivariate meta-analysis, using a bivariate outcome where risks or odds of TB can be measured separaterly in treatment and control groups. Results can be compared with those reported van Houwelingen, Arends, and Stijnen (2002).
</p>
<p>The dataset is also available in the same format in the dataframe <code>dat.colditz1994</code> of the package <span class="pkg">metafor</span>.
</p>


<h3>Source</h3>

<p>van Houwelingen HC, Arends LR, Stijnen T (2002). Advanced methods in meta-analysis: multivariate approach and meta-regression. <em>Statistics in Medicine</em>. <b>21</b>(4):589&ndash;624.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN VAN HOUWELINGEN ET AL (2002)

# FIXED-EFFECTS META-ANALYSIS (SECTION 3.1.1)
unifix &lt;- mixmeta(logor, logorvar, data=bcg, method="fixed")
print(summary(unifix), digits=3)

# RANDOM-EFFECTS META-ANALYSIS WITH MAXIMUM LIKELIHOOD (SECTION 3.1.2)
uniran &lt;- mixmeta(logor, logorvar, data=bcg, method="ml")
print(summary(uniran), digits=3, report="var")

# ORIGINAL ESTIMATES AND BEST-LINEAR UNBIASED PREDICTIONS (FIGURE 3)
pred &lt;- with(bcg, cbind(logor, logor-1.96*sqrt(logorvar),
  logor+1.96*sqrt(logorvar)))
blup &lt;- blup(uniran, pi=TRUE)
plot(pred[,1], rev(bcg$trial)+0.2, xlim=c(-3,3), ylim=c(0,14), pch=18,
  axes=FALSE, xlab="Log odds ratio", ylab="Trial", main="Forest plot")
axis(1)
axis(2, at=bcg$trial, labels=rev(bcg$trial), lty=0, las=1)
abline(v=coef(uniran))
segments(pred[,2], rev(bcg$trial)+0.2, pred[,3], rev(bcg$trial)+0.2, lty=5)
points(blup[,1], rev(bcg$trial)-0.2, pch=19)
segments(blup[,2], rev(bcg$trial)-0.2, blup[,3], rev(bcg$trial)-0.2)

# COMPUTE THE OUTCOME SEPARATELY FOR TREATMENT AND CONTROL GROUPS
y &lt;- with(bcg, log(cbind(tpos/tneg, cpos/cneg)))
S &lt;- with(bcg, cbind(1/tpos+1/tneg, 1/cpos+1/cneg))

# BIVARIATE RANDOM-EFFECTS META-ANALYSIS (SECTION 4)
mvran &lt;- mixmeta(y, S, method="ml")
print(summary(mvran), digits=3, report="var")

# META-REGRESSION (SECTION 5)
uniranlat &lt;- update(uniran, .~. + ablat)
print(summary(uniranlat), digits=3, report="var")
drop1(uniranlat, test="Chisq")
</code></pre>

<hr>
<h2 id='bdiagMat'> Block-Diagonal Expansion of a List of Matrices </h2><span id='topic+bdiagMat'></span>

<h3>Description</h3>

<p>The function <code>bdiagMat</code> builds a single matrix with block-diagonal from a list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiagMat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bdiagMat_+3A_x">x</code></td>
<td>
<p> a list of matrices, or a single matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with block-diagonal form if <code>x</code> is a list, or otherwise <code>x</code> itself if a matrix.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

 
<p>See functions <code>bldiag</code> in package <span class="pkg">metafor</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GENERATE A LIST OF MATRICES, AND CREATE THE BLOCK-DIAGONAL MATRIX
(matlist &lt;- list(matrix(1:4,2), matrix(1:8,2)))
bdiagMat(matlist)
</code></pre>

<hr>
<h2 id='berkey98'> Five Published Trials on Periodontal Disease </h2><span id='topic+berkey98'></span>

<h3>Description</h3>

<p>The dataset contains the results of 5 published trials comparing surgical and non-surgical treatments for medium-severity periodontal disease, one year after treatment. The 2 estimated outcomes are average improvements (surgical minus non-surgical, in mm) in probing depth (PD) and attachment level (AL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkey98</code></pre>


<h3>Format</h3>

<p>A data frame with 5 observations on the following 7 variables:
</p>

<dl>
<dt><code>pubyear</code></dt><dd><p> publication year of the trial.</p>
</dd>
<dt><code>npat</code></dt><dd><p> number of patients included in the trial.</p>
</dd>
<dt><code>PD</code></dt><dd><p> estimated improvement of surgical versus non-surgical treatments in probing depth (mm).</p>
</dd>
<dt><code>AL</code></dt><dd><p> estimated improvement of surgical versus non-surgical treatments in attachment level (mm).</p>
</dd>
<dt><code>var_PD</code></dt><dd><p> variance of the estimated outcome for <code>PD</code>.</p>
</dd>
<dt><code>cov_PD_AL</code></dt><dd><p> covariance of the estimated outcomes for <code>PD</code> and <code>AL</code>.</p>
</dd>
<dt><code>var_AL</code></dt><dd><p> variance of the estimated outcome for <code>AL</code>.</p>
</dd>
</dl>

<p>Row names specify the author of the paper reporting the results of each trial.
</p>


<h3>Source</h3>

<p>Berkey CS, et al. (1998). Meta-analysis of multiple outcomes by regression with random effects. <em>Statistics in Medicine</em>. <b>17</b>:2537&ndash;2550.
</p>
<p>Berkey CS., et al. (1995). Multiple-outcomes meta-analysis of treatments for periodontal disease. <em>Journal of Dental Research</em>. <b>74</b>(4):1030&ndash;1039.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN BERKEY ET AL. (1998)

# INSPECT THE DATA
berkey98

# FIXED-EFFECTS
year &lt;- berkey98$pubyear - 1983
mod1 &lt;- mixmeta(cbind(PD,AL) ~ year, S=berkey98[5:7], data=berkey98,
  method="fixed")
print(summary(mod1), digits=3)

# GLS MODEL (VARIANCE COMPONENTS)
mod2 &lt;- mixmeta(cbind(PD,AL) ~ year, S=berkey98[5:7], data=berkey98,
  method="vc",  control=list(vc.adj=FALSE))
print(summary(mod2), digits=3)
round(mod2$Psi, 3)

# ML MODEL
mod3 &lt;- mixmeta(cbind(PD,AL) ~ year, S=berkey98[5:7], data=berkey98, method="ml")
print(summary(mod3), digits=3)
round(mod3$Psi, 3)
</code></pre>

<hr>
<h2 id='blup'> Best Linear Unbiased Predictions </h2><span id='topic+blup'></span>

<h3>Description</h3>

<p>This is a generic function for generating best linear unbiased predictions (BLUPs) from the results of various fitting functions for meta-analytical models. The function invokes particular methods which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument. Currently, specific methods exist for several meta-analytical models in various packages: <code><a href="#topic+blup.mixmeta">blup.mixmeta</a></code>, <code><a href="metafor.html#topic+blup.rma.uni">blup.rma.uni</a></code>, <code><a href="mvmeta.html#topic+blup.mvmeta">blup.mvmeta</a></code>, and <code><a href="dosresmeta.html#topic+blup.dosresmeta">blup.dosresmeta</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blup(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blup_+3A_object">object</code></td>
<td>
<p> a model object for which BLUPs are desired.</p>
</td></tr>
<tr><td><code id="blup_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic method function <code>blup</code> calls specific method functions to produces (empirical) best linear unbiased predictions (BLUPs) from model objects.
</p>
<p>These predictions are a shrunk version of unit-specific realizations, where unit-specific estimates borrow strength from the assumption of an underlying (potentially multivariate) distribution in a (usually hypothetical) population. The amount of shrinkage depends from the relative size of the within and between-unit covariance matrices.
</p>


<h3>Value</h3>

<p>The form of the value returned by <code>blup</code> depends on the class of its argument. See the documentation of the particular methods for details of what is produced by that method. Usually, the results consist of point estimates of BLUPs and optionally some measure of their uncertainty.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Verbeke G, Molenberghs G. <em>Linear Mixed Models for Longitudinal Data</em>. Springer; 1997.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>Specific methods for various classes: <code><a href="#topic+blup.mixmeta">blup.mixmeta</a></code>, <code><a href="metafor.html#topic+blup.rma.uni">blup.rma.uni</a></code>, <code><a href="mvmeta.html#topic+blup.mvmeta">blup.mvmeta</a></code>, and <code><a href="dosresmeta.html#topic+blup.dosresmeta">blup.dosresmeta</a></code>.
</p>

<hr>
<h2 id='blup.mixmeta'> Best Linear Unbiased Predictions from mixmeta Models </h2><span id='topic+blup.mixmeta'></span>

<h3>Description</h3>

<p>This method function computes (empirical) best linear unbiased predictions from fitted random-effects meta-analytical models represented in objects of class <code>"mixmeta"</code>. Quantities can represent prediction of outcomes given both fixed and random effects, or just random-effects residuals from the fixed-effects estimates. Predictions are optionally accompanied by standard errors, prediction intervals or the entire (co)variance matrix of the predicted outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
blup(object, se=FALSE, pi=FALSE, vcov=FALSE, pi.level=0.95, type="outcome",
  level, format, aggregate="stat", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blup.mixmeta_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_se">se</code></td>
<td>
<p> logical switch indicating if standard errors must be included.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_pi">pi</code></td>
<td>
<p> logical switch indicating if prediction intervals must be included.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_vcov">vcov</code></td>
<td>
<p> logical switch indicating if the (co)variance matrix must be included.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_pi.level">pi.level</code></td>
<td>
<p> a numerical value between 0 and 1, specifying the confidence level for the computation of prediction intervals.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_type">type</code></td>
<td>
<p> the type of prediction. This can be either <code>outcome</code> (default) or <code>residual</code>. See Details.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_level">level</code></td>
<td>
<p> level of random-effects grouping for which predictions are to be computed. Default to the highest (inner) level, with 0 corresponding to fixed-effects predictions obtained through <code><a href="#topic+predict.mixmeta">predict</a></code>.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_format">format</code></td>
<td>
<p> the format for the returned results. See Value.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_aggregate">aggregate</code></td>
<td>
<p> when <code>format="matrix"</code> and <code>se</code> or <code>ci</code> are required, the results may be aggregated by statistic or by outcome. See Value.</p>
</td></tr>
<tr><td><code id="blup.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method function <code>blup</code> produces (empirical) best linear unbiased predictions from <code>mixmeta</code> objects. These can represent outcomes, given by the sum of fixed and random parts, or just random-effects residuals representing deviations from the fixed-effects estimated outcomes. In non-standard models with multiple hierarchies of random effects, the argument <code>level</code> can be used to determine the level of grouping for which predictions are to be computed.
</p>
<p>These predictions are a shrunk version of unit-specific realizations, where unit-specific estimates borrow strength from the assumption of an underlying (potentially multivariate) distribution of outcomes or residuals in a (usually hypothetical) population. The amount of shrinkage depends from the relative size of the within and between-unit covariance matrices reported as components <code>S</code> and <code>Psi</code> in <code>mixmeta</code> objects (see <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>).
</p>
<p>Fixed-effects models do not assume random effects, and the results of <code>blup</code> for these models are identical to <code><a href="#topic+predict.mixmeta">predict</a></code> (for <code>type="oucome"</code>) or just 0's (for <code>type="residuals"</code>).
</p>
<p>How to handle predictions for units removed from estimation due to invalid missing pattern is determined by the <code>na.action</code> argument used in <code><a href="#topic+mixmeta">mixmeta</a></code> to produce <code>object</code>. If <code>na.action=na.omit</code>, units excluded from estimation will not appear, whereas if <code>na.action=na.exclude</code> they will appear, with values set to <code>NA</code> for all the outcomes. This step is performed by <code><a href="stats.html#topic+napredict">napredict</a></code>. See Note below.
</p>
<p>In the presence of missing values in the outcomes <code>y</code> of the fitted model, correspondent values of point estimates and covariance terms are set to 0, while the variance terms are set to <code>1e+10</code>. In this case, in practice, the unit-specific estimates do not provide any information (their weight is virtually 0), and the prediction tends to the value returned by <code><a href="#topic+predict.mixmeta">predict</a></code> with <code>interval="prediction"</code>, when applied to a new but identical set of predictors. See also Note below.
</p>


<h3>Value</h3>

<p>(Empirical) best linear unbiased predictions of outcomes or random-effects residuals. The results may be aggregated in matrices (the default), or returned as lists, depending on the argument <code>format</code>. For multivariate models, the aggregation is ruled by the argument <code>aggregate</code>, and the results may be grouped by statistic or by outcome. If <code>vcov=TRUE</code>, lists are always returned.
</p>


<h3>Note</h3>

<p>The definition of missing in model frames used for estimation in <code><a href="#topic+mixmeta">mixmeta</a></code> is different than that commonly adopted in other regression models such as <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>. See info on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code> in <code><a href="#topic+mixmeta">mixmeta</a></code>.
</p>
<p>Differently from <code><a href="#topic+predict.mixmeta">predict</a></code>, this method function computes the predicted values in the presence of partially missing outcomes. Interestingly, BLUPs for missing outcomes may be slightly different than predictions returned by <code><a href="#topic+predict.mixmeta">predict</a></code> on a new but identical set of predictors, as the BLUP also depends on the random part of the model. Specifically, the function uses information from the random-effects (co)variance to predict missing outcomes given the observed ones.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Verbeke G, Molenberghs G. <em>Linear Mixed Models for Longitudinal Data</em>. Springer; 1997.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+predict.mixmeta">predict</a></code> for standard predictions. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ 1, S=berkey98[5:7], data=berkey98)

# ONLY BLUP
blup(model)

# BLUP AND SE
blup(model, se=TRUE)

# SAME AS ABOVE, AGGREGATED BY OUTCOME, WITH PREDICTION INTERVALS
blup(model, se=TRUE, pi=TRUE, aggregate="outcome")

# WITH VCOV, FORCED TO A LIST
blup(model, se=TRUE, pi=TRUE, vcov=TRUE, aggregate="outcome")

# PREDICTING ONLY THE RANDOM-EFFECT RESIDUALS
blup(model, type="residual")
</code></pre>

<hr>
<h2 id='coef.mixmeta'> Extract Coefficients and (Co)Variance Matrix from mixmeta Objects </h2><span id='topic+coef.mixmeta'></span><span id='topic+vcov.mixmeta'></span>

<h3>Description</h3>

<p>These method functions return the estimated fixed-effects coefficients and their (co)variance matrix for fitted meta-analytical models represented in objects of class <code>"mixmeta"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
coef(object, format=c("vector","matrix"), ...)

## S3 method for class 'mixmeta'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.mixmeta_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="coef.mixmeta_+3A_format">format</code></td>
<td>
<p> format of the returned object.</p>
</td></tr>
<tr><td><code id="coef.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>coef</code>, by default a vector (default)with the estimated fixed-effects coefficients. For multivariate models, a matrix can also be returned.
</p>
<p>For <code>vcov</code>, the (co)variance matrix of the estimated fixed-effects coefficients.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98)

# COEFFICIENTS
model$coef
coef(model)
coef(model, format="matrix")
summary(model)$coef

# (CO)VARIANCE MATRIX
vcov(model)
</code></pre>

<hr>
<h2 id='dbs'> Deep-Brain Stimulation for Patients with Parkinson's Disease </h2><span id='topic+dbs'></span>

<h3>Description</h3>

<p>The dataset contains the data on 46 studies published between 1980 and 2004 that assessed the effect of deep-brain stimulation on the relief of symptoms of Parkinson's disease. The outcome is reported as a score motor function, defined with the Unified Parkinson's Disease Rating Scale (UPDRS-part III), with lower values indicating better prognosis. Changes in the score were measured at 3, 6, 12 months and long-term after the implantation of the stimulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbs</code></pre>


<h3>Format</h3>

<p>A data frame with 68 observations on the following 12 variables:
</p>

<ul>
<li><p><code>author</code>: label identifying the study.
</p>
</li>
<li><p><code>year</code>: year of publication.
</p>
</li>
<li><p><code>eff_month3,  var_month3</code>: point estimate and variance of the change in the score at 3 months.
</p>
</li>
<li><p><code>eff_month6,  var_month6</code>: point estimate and variance of the change in the score at 6 months.
</p>
</li>
<li><p><code>eff_month12,  var_month12</code>: point estimate and variance of the change in the score at 12 months.
</p>
</li>
<li><p><code>eff_long,  var_long</code>: point estimate and variance of the change in the score in the long term.
</p>
</li>
<li><p><code>duration</code>: average disease duration (years).
</p>
</li>
<li><p><code>baseline</code>: average baseline score of the patients.
</p>
</li></ul>



<h3>Details</h3>

<p>The data are stored in a <em>wide</em> format, with each record belonging to a single study and different variables providing estimates of the outcome at different times. Each study report results at one or multiple times, with the remaining times set to missing. See the dataset <a href="#topic+gliomas">gliomas</a> for an example of similar dataset stored in <em>long</em> format.
</p>


<h3>Note</h3>

<p>The data provide an example of application of longitudinal meta-analysis, with repeated measurements of the effect size taken at various time point within each study. This requires a modelling structure that accounts for both within and between-study correlations of repeated measurements. In this case, the analysis is performed in the wide-format dataset using a multivariate meta-analysis. However, a long format is better suited for longitudinal meta-analysis, as it is applicable even when estimates are reported at different times in each study (see the examples in the help page of the dataset <code><a href="#topic+gliomas">gliomas</a></code>). Results can be compared with those reported Ishak and colleagues (2007).
</p>


<h3>Source</h3>

<p>Ishak KJ, et al (2007). Meta-analysis of effect sizes reported at multiple time points using general linear mixed model. <em>Clinical Trials</em>. <b>4</b>(5):525&ndash;39.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN ISHAK ET AL (2007), TABLES 1 AND 2

# CREATE THE OUTCOME AND WITHIN-STUDY MATRICES (THE LATTER WITHOUT CORRELATION)
y &lt;- as.matrix(dbs[1:4*2+1])
S &lt;- as.matrix(dbs[1:4*2+2])

# INDEPENDENT RANDOM EFFECTS (TABLE 1, FIRST MODEL)
mv1 &lt;- mixmeta(y ~ 1, S, bscov="diag", data=dbs)
print(summary(mv1), digits=1, report="var")

# HETEROGENEOUS AR1 RANDOM-EFFECTS (TABLE 1, THIRD MODEL)
mv3 &lt;- mixmeta(y ~ 1, S, bscov="har1", data=dbs)
print(summary(mv3), digits=1, report="var")

# BUILD THE LIST HETEROGENEOUS AR1 WITHIN-STUDY ERRORS (CORRELATION AT 0.97)
cormat &lt;- 0.97^abs(col(matrix(1,4,4)) - row(col(matrix(1,4,4))))
addS &lt;- lapply(seq(nrow(S)), function(i) inputcov(sqrt(S[i,]), cormat))
addS &lt;- lapply(addS, function(x) x[apply(!is.na(x),1,any), apply(!is.na(x),2,any)])

# ADD HAR1 WITHIN-STUDY ERRORS (TABLE 1, FOURTH MODEL) USING addSlist
## Not run: 
mv4 &lt;- mixmeta(y ~ 1, bscov="har1", data=dbs, control=list(addSlist=addS))
print(summary(mv4), digits=1, report="var")
## End(Not run)

## Not run: 
### USE A LONG FORMAT, AS MORE FLEXIBLE AND ALLOWS MORE COMPLEX MODELS

# RESHAPE THE DATASET
long &lt;- reshape(dbs, direction="long", idvar="author", v.names=c("eff","var"),
  varying=list(1:4*2+1, 1:4*2+2))

# RE-RUN THE LAST (FOURTH) MODEL
mv4b &lt;- mixmeta(eff ~ factor(time) - 1, random = ~ factor(time) -1 | author,
  bscov="har1", data=long, control=list(addSlist=addS))
print(summary(mv4b), digits=1, report="var")

# COMMON RANDOM EFFECTS (TABLE 1, SECOND MODEL)
mv2 &lt;- mixmeta(eff ~ factor(time) - 1, var, random = ~ factor(time) -1 | author,
  bscov="id", data=long)
print(summary(mv2), digits=1, report="var")

# FOURTH MODEL WITH ADDITIONAL CENTERED META-PREDICTORS (TABLE 2)
mv4plus &lt;- mixmeta(eff ~ factor(time) - 1 + I(duration-14) + I(baseline-52),
  random = ~ factor(time) -1 | author, bscov="har1", data=long,
  control=list(addSlist=addS))
print(summary(mv4plus), digits=1, report="var")
## End(Not run)


### SEE help(gliomas) FOR A COMPLEMENTARY EXAMPLE
</code></pre>

<hr>
<h2 id='fibrinogen'> Fibrinogen Studies Collaboration </h2><span id='topic+fibrinogen'></span>

<h3>Description</h3>

<p>The Fibrinogen Studies Collaboration is a meta-analysis of individual data on 154,012 adults from 31 prospective cohort studies with information on plasma fibrinogen and major disease outcomes. The dataset reports a subset of the results of a first-stage analysis consisting of the log-hazard ratio of coronary heart disease for categories of levels of fibrinogen versus a baseline category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibrinogen</code></pre>


<h3>Format</h3>

<p>A data frame with 31 observations on the following 15 variables:
</p>

<ul>
<li><p><code>cohort</code>: study ID.
</p>
</li>
<li><p><code>b2, b3, b4, b5</code>: estimated log-hazard ratios for the second to fifth categories versus the baseline category.
</p>
</li>
<li><p><code>V_2_2, V_3_3, V_4_4, V_5_5</code>: variances of the estimated log-hazard ratios.
</p>
</li>
<li><p><code>V_2_3, V_2_4, V_2_5, V_3_4, V_3_5, V_4_5</code>: covariances of the estimated log-hazard ratios.
</p>
</li></ul>



<h3>Details</h3>

<p>The published analysis adopted a fixed-effects model on 10 categories of fibrinogen (Fibrinogen Studies Collaboration 2004, 2005). Here a subset of the results of the first-stage analysis is reported, namely the log-hazard ratio for 4 categories and associated (co)variance terms, ordered as the lower triangular elements of the (co)variance matrix taken by column. Details on the first-stage model and the second-stage meta-analysis are provided in White (2009) and Jackson and colleagues (2010).
</p>


<h3>Note</h3>

<p>The data provide an example of application of multivariate meta-analysis for multi-parameter association, where a relationship is defined by functions specified by several coefficients. In this case, the coefficients refer to log-hazard ratio for strata of the original variable versus a baseline category. A general overview of the application of multivariate meta-analysis in this setting is provided by Gasparrini and colleagues (2012).
</p>


<h3>Source</h3>

<p>Fibrinogen Studies Collaboration (2004). Collaborative meta-analysis of prospective studies of plasma fibrinogen and cardiovascular disease. <em>European Journal of Cardiovascular Prevention and Rehabilitation</em>. <b>11</b>:9&ndash;17.
</p>
<p>Fibrinogen Studies Collaboration (2005). Plasma fibrinogen level and the risk of major cardiovascular diseases and nonvascular mortality: an individual participant meta-analysis. <em>Journal of the American Medical Association</em>. <b>294</b>:1799&ndash;1809.
</p>
<p>White IR (2009). Multivariate random-effects meta-analysis. <em>Stata Journal</em>. <b>9</b>(1):40&ndash;56.
</p>
<p>Jackson D, White IR, Thompson SG (2010). Extending DerSimonian and Laird's methodology to perform multivariate random effects meta-analyses. <em>Statistics in Medicine</em>. <b>29</b>(12):1282&ndash;1297.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN WHITE (2009) AND JACKSON ET AL. (2010)

# INSPECT THE DATA
head(fibrinogen)

# REML MODEL
y &lt;- as.matrix(fibrinogen[2:5])
S &lt;- as.matrix(fibrinogen[6:15])
model &lt;- mixmeta(y, S)

# SUMMARIZE THE RESULTS
print(summary(model), digits=3)
round(model$Psi, 3)
</code></pre>

<hr>
<h2 id='gliomas'> Randomized Trials on Therapies for Malignant Gliomas </h2><span id='topic+gliomas'></span>

<h3>Description</h3>

<p>The dataset contains the data on 17 randomized controlled trials comparing post-operative radiation therapy plus chemotherapy versus radiation therapy alone in patients with malignant gliomas. The outcome of interest is the probability of survival along time, measured as odds ratio at 6, 12, 18, and 24 months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gliomas</code></pre>


<h3>Format</h3>

<p>A data frame with 68 observations on the following 8 variables:
</p>

<ul>
<li><p><code>study</code>: number identifying the trial.
</p>
</li>
<li><p><code>time</code>: time (months) since the start of the treatment at which survival status is assessed.
</p>
</li>
<li><p><code>ntreat, streat</code>: number of total patients at the beginning of the study and surviving patients at specific times, respectively, in the treatment group (radiation therapy plus chemotherapy).
</p>
</li>
<li><p><code>dcontr, ncontr</code>: number of total patients at the beginning of the study and surviving patients at specific times, respectively, in the control group (radiation alone).
</p>
</li>
<li><p><code>logOR, varOR</code>: log-odds ratio of survival between treatment and control groups.
</p>
</li></ul>



<h3>Details</h3>

<p>The data are stored in a <em>long</em> format, with each record providing the estimate at a single time and each study providing multiple records. There were missing data for study 17 at months 6 and 18. There were no survivors in the control group at month 24 for studies 3 and 10, although this still allows computation of the OR. See the dataset <code><a href="#topic+dbs">dbs</a></code> for an example of similar dataset stored in <em>wide</em> format.
</p>
<p>The log-odds ratio is computed empirically as <code class="reqn">\log(s_t \times (n_t-s_t) / ((n_c-s_c) \times s_c)</code>. Its variance is simply computed as <code class="reqn">1/s_t + 1/(n_t-s_t) + 1/(n_c-s_c) + 1/s_c</code>.
</p>


<h3>Note</h3>

<p>The data provide an example of application of longitudinal meta-analysis, with repeated measurements of the effect size taken at various time points within each study. This requires a modelling structure that accounts for both within and between-study correlations of repeated measurements. In this case, the same analysis can be performed in a wide-format dataset using a multivariate meta-analysis (see the examples in the help page of the dataset <code><a href="#topic+dbs">dbs</a></code>). However, the long format is better suited for longitudinal meta-analysis, as it is applicable even when estimates are reported at different times in each study. Results can be compared with those reported Musekiwa and colleagues (2016). The same dataset was also used by Trikalinos and Olkin (2012), using a similar modelling scheme.
</p>


<h3>Source</h3>

<p>Musekiwa A, et al (2012). Meta-analysis of effect sizes reported at multiple time points using general linear mixed model. <em>Plos One</em>. <b>11</b>(10):e0164898.
</p>
<p>Trikalinos TA, Olkin I (2012). Meta-analysis of effect sizes reported at multiple time points: a multivariate approach. <em>Clinical Trials</em>. <b>9</b>(5):610&ndash;620.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN MUSEKIWA ET AL (2012), TABLES 3 AND 4

# INDEPENDENT RANDOM EFFECTS, NO WITHIN-STUDY CORRELATION (MODEL 1)
mod1 &lt;- mixmeta(logOR~0+factor(time), S=logORvar, random=~0+factor(time)|study,
  bscov="diag", data=gliomas)
print(summary(mod1), digits=2, report="var")

# COMPOUND-SYMMETRY RANDOM EFFECTS, NO WITHIN-STUDY CORRELATION (MODEL 2)
# NB: THIS REQUIRES A TWO-LEVEL MODEL WITH THE INNER-LEVEL VARIANCE FIXED TO 0
unit &lt;- factor(seq(nrow(gliomas)))
mod2 &lt;- mixmeta(logOR~0+factor(time), S=logORvar, random=~1|study/unit,
  bscov=c("unstr","fixed"), data=gliomas, control=list(Psifix=list(unit=0)))
print(summary(mod2), digits=2, report="var")

# BUILD THE HETEROGENEOUS AR1 WITHIN-STUDY ERRORS (CORRELATION AT 0.61)
cormat &lt;- 0.61^abs(col(matrix(1,4,4)) - row(col(matrix(1,4,4))))
addS &lt;- lapply(split(sqrt(gliomas$logORvar), gliomas$study), inputcov, cormat)
addS &lt;- lapply(addS, function(x) x[apply(!is.na(x),1,any), apply(!is.na(x),2,any)])

# INDEPENDENT RANDOM EFFECTS, HAR1 WITHIN-STUDY CORRELATION (MODEL 4)
mod4 &lt;- mixmeta(logOR~0+factor(time), random=~0+factor(time)|study,
  bscov="diag", data=gliomas, control=list(addSlist=addS))
print(summary(mod4), digits=2, report="var")

# UNSTRUCTURED RANDOM EFFECTS, HAR1 WITHIN-STUDY CORRELATION (MODEL 6)
mod6 &lt;- update(mod4, bscov="unstr")
print(summary(mod6), digits=2, report="var")

# COMPARE THE FIT
AIC(mod1, mod2, mod4, mod6)

## Not run: 
### MORE FLEXIBLE MODELLING OF RANDOM EFFECTS

# RE-RUN BEST FITTING MODEL WITH ML (ALLOWS TESTING OF FIXED EFFECTS)
mod4ml &lt;- update(mod4, method="ml")

# RANDOM-SLOPE MODEL WITH TIME AS CONTINUOUS (CENTERED IN random)
modnew &lt;- mixmeta(logOR~time, random=~I(time-15)|study, bscov="diag",
  method="ml", data=gliomas, control=list(addSlist=addS, maxiter=200))
print(summary(modnew), digits=2, report="var")

# COMPARE
AIC(mod4ml, modnew)
## End(Not run)


### SEE help(dbs) FOR A COMPLEMENTARY EXAMPLE
</code></pre>

<hr>
<h2 id='hsls'> High School Longitudinal Study </h2><span id='topic+hsls'></span>

<h3>Description</h3>

<p>This is a nationally representative, longitudinal study of more than 21,000 9th graders in 944 schools who will be followed through their secondary and postsecondary years. The data are used for testing whether sex, socioeconomic status and sex by socio-economic status interaction are predictive of the mathematics standardized score in each of the eight race groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsls</code></pre>


<h3>Format</h3>

<p>A data frame with 8 observations on the following 10 variables:
</p>

<ul>
<li><p><code>race</code>: race group.
</p>
</li>
<li><p><code>b1, b2, b3</code>: estimated regression coefficients for sex, socio-economic status and sex by socio-economic status interaction, respectively, on the mathematics standardized score.
</p>
</li>
<li><p><code>V11, V22, V33</code>: variances of the estimated coefficients.
</p>
</li>
<li><p><code>V12, V13, V23</code>: covariances of the estimated coefficients.
</p>
</li></ul>



<h3>Source</h3>

<p>Chen H, Manning AK, Dupuis J (2012). A method of moments estimator for random effect multivariate meta-analysis. <em>Biometrics</em>. <b>68</b>(4):1278&ndash;1284.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN CHEN ET AL. (2012)

# INSPECT THE DATA
hsls

# FIXED-EFFECTS MODEL
S &lt;- as.matrix(hsls[5:10])
mod1 &lt;- mixmeta(cbind(b1,b2,b3), S, data=hsls, method="fixed")
summary(mod1)

# MM MODEL
mod2 &lt;- mixmeta(cbind(b1,b2,b3), S,data=hsls, method="mm")
summary(mod2)
mod2$Psi
</code></pre>

<hr>
<h2 id='hyp'> Ten Studies Assessing an Hypertension Treatment </h2><span id='topic+hyp'></span>

<h3>Description</h3>

<p>The dataset contains the results of ten studies that assess the effectiveness of hypertension treatment for lowering blood pressure. Each study provides complete data on two treatment effects, the difference in systolic blood pressure (SBP) and diastolic blood pressure (DBP) between the treatment and the control groups, where these differences are adjusted for the participants' baseline blood pressures. The within-study correlations of the two outcomes are known. Some trials are conducted on patients with isolated systolic hypertension (ISH).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyp</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 7 variables:
</p>

<ul>
<li><p><code>study</code>: study ID.
</p>
</li>
<li><p><code>sbp, sbp_se</code>: estimated difference and its standard error in systolic blood pressure.
</p>
</li>
<li><p><code>dbp, dbp_se</code>: estimated difference and its standard error in diastolic blood pressure.
</p>
</li>
<li><p><code>rho</code>: within-study correlation between the estimated differences in systolic and diastolic blood pressure.
</p>
</li>
<li><p><code>ish</code>: indicator for studies on patients with isolated systolic hypertension.
</p>
</li></ul>



<h3>Note</h3>

<p>The standard errors for the two outcomes are wrongly reported as variances in the original article by Jackson and colleagues (2013).
</p>


<h3>Source</h3>

<p>Jackson D, White IR, Riley RD (2013). A matrix based method of moments for fitting the multivariate random effects model for meta-analysis and meta-regression. <em>Biometrical Journal</em>. <b>55</b>(2):231&ndash;45.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN JACKSON ET AL. (2013)

# INSPECT THE DATA
hyp

# INPUT THE CORRELATION (CAN ALSO BE INPUTTED DIRECTLY, SEE BELOW)
(S &lt;- inputcov(hyp[c("sbp_se", "dbp_se")], cor=hyp$rho))
# CHECK WITH THE FIRST STUDY
cov2cor(xpndMat(S[1,]))

# META-ANALYSIS, REML MODEL
mod1 &lt;- mixmeta(cbind(sbp,dbp), S=S, data=hyp)
print(summary(mod1), digits=2)
round(mod1$Psi,2)

# META-ANALYSIS, REML MODEL (INPUTTING THE CORRELATION DIRECTLY)
mod2 &lt;- mixmeta(cbind(sbp,dbp), S=cbind(sbp_se,dbp_se)^2, data=hyp,
  control=list(Scor=hyp$rho))
print(summary(mod2), digits=2)

# META-ANALYSIS, MM MODEL
mod3 &lt;- mixmeta(cbind(sbp,dbp), S=S, data=hyp, method="mm")
print(summary(mod3), digits=2)
round(mod3$Psi,2)

# META-REGRESSION, REML MODEL
mod4 &lt;- mixmeta(cbind(sbp,dbp) ~ ish, S=S, data=hyp)
print(summary(mod4), digits=2)

# META-REGRESSION, MM MODEL
mod5 &lt;- mixmeta(cbind(sbp,dbp) ~ ish, S=S, data=hyp, method="mm")
print(summary(mod5), digits=2)
</code></pre>

<hr>
<h2 id='inputcov'> Input (Co)Variance Matrices </h2><span id='topic+inputcov'></span>

<h3>Description</h3>

<p>This function inputs (co)variance matrices of a set of outcomes given the corresponding standard deviation and correlation values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputcov(sd, cor=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inputcov_+3A_sd">sd</code></td>
<td>
<p> a <code class="reqn">m \times k</code> matrix of standard deviations for <code class="reqn">k</code> outcomes in <code class="reqn">m</code> matrices, or a vector for <code class="reqn">k</code> outcomes in a single matrix.</p>
</td></tr>
<tr><td><code id="inputcov_+3A_cor">cor</code></td>
<td>
<p> either a vector of length 1, <code class="reqn">m</code> or <code class="reqn">k(k-1)/2</code>, or alternatively a <code class="reqn">k \times k</code> or <code class="reqn">m \times k(k-1)/2</code> matrix. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending the number of outcomes <code class="reqn">k</code> and matrices <code class="reqn">m</code>, the argument <code>cor</code> is interpreted as:
</p>

<ul>
<li><p> if a vector of length 1 (a scalar), the same correlation for all the <code class="reqn">k</code> outcomes for all the <code class="reqn">m</code> matrices;
</p>
</li>
<li><p> if a vector of length <code class="reqn">m</code>, the same correlation for all the <code class="reqn">k</code> outcomes for each of the <code class="reqn">m</code> matrices;
</p>
</li>
<li><p> if a vector of length <code class="reqn">k(k-1)/2</code>, the lower triangular elements (without diagonal, taken by column) of the correlation matrix of the <code class="reqn">k</code> outcomes, the same for all the <code class="reqn">m</code> matrices;
</p>
</li>
<li><p> if a <code class="reqn">k \times k</code> matrix, the correlation matrix for the single matrix (only when <code class="reqn">m</code>=1);
</p>
</li>
<li><p> if a <code class="reqn">m \times k(k-1)/2</code> matrix, each row represents the lower triangular elements (without diagonal, taken by column) of the correlation matrix of the <code class="reqn">k</code> outcomes for each of the <code class="reqn">m</code> matrices.
</p>
</li></ul>



<h3>Value</h3>

<p>For a single matrix, the (co)variance matrix itself. For multiple matrices, a <code class="reqn">m \times k(k+1)/2</code> matrix, where each row represents the vectorized entries of the lower triangle (with diagonal, taken by column) of the related (co)variance matrix (see <code><a href="#topic+vechMat">vechMat</a></code>).
</p>


<h3>Note</h3>

<p>This function is called internally by <code><a href="#topic+mixmeta">mixmeta</a></code> for multivariate models to input the correlation(s) when only the within-unit variances are provided through the argument <code>S</code>. In this case, the correlation values are set through the argument <code>Scor</code> in the control list (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>).
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+xpndMat">xpndMat</a></code>. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SOME RANDOM SD FOR A SINGLE MATRIX, WITH CONSTANT CORRELATION
(M &lt;- inputcov(runif(4, 0.1, 3), 0.7))
# CHECK CORRELATION
cov2cor(M)

# NOW WITH A MORE COMPLEX CORRELATION STRUCTURE
(M &lt;- inputcov(runif(3, 0.1, 3), c(0.7,0.2,0.4)))
cov2cor(M)

# MULTIPLE MATRICES
(V &lt;- matrix(runif(5*3, 0.1, 3), 5, 3,
  dimnames=list(1:5, paste("V", 1:3, sep=""))))
inputcov(V, 0.6)

# WITH REAL DATA WHEN CORRELATIONS AVAILABLE
hyp
(S &lt;- inputcov(hyp[c("sbp_se","dbp_se")], cor=hyp$rho))
# CHECK FIRST STUDY
cov2cor(xpndMat(S[1,]))

# USED INTERNALLY IN mixmeta
p53
inputcov(sqrt(p53[c("V1","V2")]), 0.5)
model &lt;- mixmeta(cbind(y1,y2), S=cbind(V1,V2), data=p53, control=list(Scor=0.5))
model$S
</code></pre>

<hr>
<h2 id='inputna'> Input Missing Values </h2><span id='topic+inputna'></span>

<h3>Description</h3>

<p>This function augment data by replacing missing values. It can be used internally in <code><a href="#topic+mixmeta">mixmeta</a></code> through the <code><a href="#topic+mixmeta.control">control</a></code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inputna(y, S, inputvar=10^4)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">n</code> units and <code class="reqn">k</code> outcomes:
</p>
<table role = "presentation">
<tr><td><code id="inputna_+3A_y">y</code></td>
<td>
<p> a <code class="reqn">n</code>-dimensional vector (for univariate models) or <code class="reqn">m \times k</code> matrix (for multivariate models) of outcomes.</p>
</td></tr>
<tr><td><code id="inputna_+3A_s">S</code></td>
<td>
<p> series of within-unit variances (or (co)variance matrices for multivariate models) of the estimated outcome(s). For univariate models, this is usually a <code class="reqn">n</code>-dimensional vector. For multivariate models, it can be provided as: a <code class="reqn">m</code>-dimensional list of <code class="reqn">k \times k</code> matrices; a tri-dimensional <code class="reqn">k \times k \times m</code> array; a matrix or data frame with <code class="reqn">n</code> rows and <code class="reqn">k(k+1)/2</code> or <code class="reqn">k</code> columns, depending on the availability of the within-unit correlations.</p>
</td></tr>
<tr><td><code id="inputna_+3A_inputvar">inputvar</code></td>
<td>
<p> multiplier for inputting the missing variances in <code>S</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function augments the data by replacing missing values in the outcomes and the associated (co)variances. Specifically, it replaces missing outcomes and missing covariances (if provided) with 0, and missing variances with the largest observed variance multiplied by <code>inputvar</code>. This value is expected to be very high, by default <code class="reqn">10^4</code>, so that the corresponding observation contributes only negligibly to the final estimate.
</p>


<h3>Value</h3>

<p>A matrix with the first <code class="reqn">k</code> column corresponding to the augmented outcomes, and the remaining <code class="reqn">k(k+1)/2</code> or <code class="reqn">k</code> columns (depending on the availability of the within-study covariances) corresponding to vectorized entries of the lower triangle of the related (co)variance matrices.
</p>


<h3>Note</h3>

<p>Data augmentation used to be the approach to deal with missing values in the first implementation of <span class="pkg">mixmeta</span>. The current algorithms directly account for missing.
</p>
<p>Inputting missing values can be useful when two or more outcomes are never observed jointly, and the estimation is entirely based on indirect comparison. This method can be applied in network meta-analysis, also called indirect treatment comparison.
</p>
<p>This approach can produce different results than standard methods, especially when the occurrence of missing is substantial. Preliminary analyses indicate that likelihood-based estimation methods do not seem to be affected, while non-iterative estimators such as method of moments and variance components are more sensitive. The user should be careful on the application of missing augmentation.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Gasparrini A, Armstrong B, Kenward MG (2012). Multivariate meta-analysis for non-linear and other multi-parameter associations. <em>Statistics in Medicine</em>. <b>31</b>(29):3821&ndash;3839. [Freely available <a href="http://www.ag-myresearch.com/2012_gasparrini_statmed.html"><b>here</b></a>].
</p>
<p>Jackson D, Riley R, White IR (2011). Multivariate meta-analysis: Potential and promise. <em>Statistics in Medicine</em>. <b>30</b>(20);2481&ndash;2498.
</p>
<p>White IR (2009). Multivariate random-effects meta-analysis. <em>Stata Journal</em>. <b>9</b>(1):40&ndash;56.
</p>
<p>White IR (2011). Multivariate random-effects meta-regression: updates to mvmeta. <em>Stata Journal</em>. <b>11</b>(2):255-270.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+inputcov">inputcov</a></code> for inputting (co)variance matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># INSPECT THE DATA
head(smoking)

# STANDARD APPROACH TO MISSING DATA
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
mod1 &lt;- mixmeta(y, S)
summary(mod1)

# WITH DATA AUGMENTATION
augdata &lt;- inputna(y, S)
y &lt;- augdata[,1:3]
S &lt;- augdata[,-c(1:3)]
mod2 &lt;- mixmeta(y, S)
summary(mod2)
# NB: SAME PARAMETER ESTIMATES, BUT WRONG NYUMBER OF OBS

# USED INTERNALLY IN mixmeta
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
mod3 &lt;- mixmeta(y, S, control=list(inputna=TRUE))
summary(mod3)
# NOW RIGHT NUMBER OF OBS
</code></pre>

<hr>
<h2 id='logLik.mixmeta'> Extract Log-Likelihood from mixmeta Objects </h2><span id='topic+logLik.mixmeta'></span>

<h3>Description</h3>

<p>This method function returns the (restricted) log-likelihood for fitted meta-analytical models represented in objects of class <code>"mixmeta"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.mixmeta_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="logLik.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar of class <code>"logLik"</code> with attributes, providing the (restricted) log likelihood of the model. Attributes correspond to the component <code>df</code> of <code>mixmeta</code> objects, namely the following scalars: <code>nall</code> (number of observations used for estimation, excluding missing values), <code>nobs</code> (equal to <code>nall</code>, minus the number of fixed-effects coefficients for REML models, <code>fixed</code> (number of estimated fixed-effects coefficients), <code>random</code> (number of estimated (co)variance terms).
</p>


<h3>Note</h3>

<p>This functions is called by <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code> for computing the Akaike and Bayesian information criteria.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See the default method <code><a href="stats.html#topic+logLik">logLik</a></code>. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL)~pubyear,S=berkey98[5:7],data=berkey98)

# LOG-LIKELIHOOD
ll &lt;- logLik(model)
ll
attributes(ll)

# AIC and BIC
AIC(model)
BIC(model)
</code></pre>

<hr>
<h2 id='mixmeta'> Fitting Standard and Extended Meta-Analysis and Meta-Regression Models </h2><span id='topic+mixmeta'></span><span id='topic+mixmeta.fit'></span>

<h3>Description</h3>

<p>The function <code>mixmeta</code> performs various meta-analytical models under a common mixed-effects framework, including standard univariate fixed and random-effects meta-analysis and meta-regression, and non-standard extensions such as multivariate, multilevel, longitudinal, and dose-response models. The function <code>mixmeta.fit</code> is a wrapper for actual fitting functions based on different estimation methods, usually called internally. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmeta(formula, S, data, random, method="reml", bscov="unstr", offset, subset,
  contrasts=NULL, na.action, model=TRUE, control=list())

mixmeta.fit(X, Z, y, S, groups, method, bscov, control)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">n</code> units aggregated within <code class="reqn">m</code> (outer-level) groups, <code class="reqn">k</code> outcomes, <code class="reqn">p</code> fixed-effects predictors, and <code class="reqn">q</code> random-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="mixmeta_+3A_formula">formula</code></td>
<td>
<p> an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that can be coerced to that class) offering a symbolic description of the linear predictor for the fixed-effects part of the model. Alternatively, for meta-analysis with no fixed-effects predictors, a single  vector (for univariate models) or matrix-type object (for multivariate models). Terms in <code>formula</code> must be vector or matrix-type objects, optionally provided in the <code>data</code> argument below. See <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_s">S</code></td>
<td>
<p> series of within-unit variances (or (co)variance matrices for multivariate models) of the estimated outcome(s). For univariate models, this is usually a <code class="reqn">n</code>-dimensional vector. For multivariate models, it can be provided as: a <code class="reqn">m</code>-dimensional list of <code class="reqn">k \times k</code> matrices; a tri-dimensional <code class="reqn">k \times k \times m</code> array; a matrix or data frame with <code class="reqn">n</code> rows and <code class="reqn">k(k+1)/2</code> or <code class="reqn">k</code> columns, depending on the availability of the within-unit correlations. <code>mixmeta.fit</code> accepts only the last option. Optionally, for more complex error structures, this argument can be omitted and passed through <code>addSlist</code> in <code>control</code>. See Details below.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_data">data</code></td>
<td>
<p> an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in <code>formula</code> and <code>random</code>. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>mixmeta</code> is called.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_random">random</code></td>
<td>
<p> a one-sided formula (or a list of formulae for multilevel models) offering a symbolic description of the linear predictor(s) and grouping structure for the random-effects part of the model. The usual form is <code>~ z1 + ... + zq | g</code>, with the grouping factor separated from the linear predictor by the symbol <code>'|'</code>. Multiple levels with the same linear predictor can be defined by separating multiple grouping factors using the symbol <code>'/'</code>. Alternatively, in a list form the grouping factors can also be provided as list names. In both cases, the levels are considered nested (from outer to inner following the order). See <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code> and Details below.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_method">method</code></td>
<td>
<p> estimation method: <code>"fixed"</code> for fixed-effects models, <code>"ml"</code> or <code>"reml"</code> for random-effects models fitted through (restricted) maximum likelihood, <code>"mm"</code> for random-effects models fitted through method of moments, and <code>"vc"</code> for random-effects models fitted through variance components. See Details below. If <code>"model.frame"</code>, the model frame is returned, as in <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_bscov">bscov</code></td>
<td>
<p> a character vector defining the structure of the random-effects (co)variance matrices. Default to <code>"unstr"</code> (unstructured). Names corresponding to grouping factors (see <code>random</code> above) can be used to refer to specific random-effects levels for non-default values. If unnamed, the values can be recycled. Among various <code><a href="#topic+mixmetaCovStruct">(co)variance structures</a></code>, the user can select <code>"diag"</code> (diagonal), <code>"cs"</code> (compound symmetry), <code>"hcs"</code> (heterogeneous compound symmetry), <code>"ar1"</code> (autoregressive of first order), or <code>"fixed"</code> (fixed). See also Details.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_offset">offset</code></td>
<td>
<p> optionally, a <code class="reqn">n</code>-dimensional numeric vector used to specify an a priori known component in the linear predictor. One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or as well. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_contrasts">contrasts</code></td>
<td>
<p> an optional list. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data contain <code>NA</code>s. Default to <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, usually <code><a href="#topic+na.omit.data.frame.mixmeta">na.omit</a></code>. <code><a href="#topic+na.exclude.data.frame.mixmeta">na.exclude</a></code> can be useful. See details on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code> in <code>mixmeta</code>.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_model">model</code></td>
<td>
<p> a logical value indicating whether the model frame should be included as a component of the returned value. See the <code><a href="#topic+model.frame.mixmeta">model.frame</a></code> method function.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_control">control</code></td>
<td>
<p> list of parameters for controlling the fitting process. These are passed to  <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to replace otherwise selected default values.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_x">X</code></td>
<td>
<p> a <code class="reqn">n \times p</code> design matrix containing the <code class="reqn">p</code> fixed-effects predictors, appropriately ordered by <code>groups</code>. Usually produced internally by <code>mixmeta</code> from <code>formula</code> above.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_z">Z</code></td>
<td>
<p> a <code class="reqn">n \times q</code> design matrix (or a list of design matrices for multilevel models) containing the <code class="reqn">q</code> random-effects predictors, appropriately ordered by <code>groups</code>. Usually produced internally by <code>mixmeta</code> from <code>random</code> above.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_y">y</code></td>
<td>
<p> a <code class="reqn">n</code>-dimensional vector (for univariate models) or <code class="reqn">m \times k</code> matrix (for multivariate models) of outcomes, appropriately ordered by <code>groups</code>. Usually produced internally by <code>mixmeta</code> from <code>formula</code> above.</p>
</td></tr>
<tr><td><code id="mixmeta_+3A_groups">groups</code></td>
<td>
<p> matrix with <code class="reqn">n</code> rows, with each column identifying the groups for each level of random-effects, appropriately ordered. Usually produced internally by <code>mixmeta</code> from <code>random</code> above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mixmeta</code> resembles standard regression functions in <span class="rlang"><b>R</b></span>. See <code><a href="nlme.html#topic+lme">lme</a></code> in particular, or <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>, for information on most of the arguments. Internally, this function assembles the data components, defines the (potentially multiple) grouping levels and re-order the data accordingly, and then pass them to <code>mixmeta.fit</code>. This is a wrapper for actual fitting functions that are automatically selected. Functions other than <code>mixmeta</code> are not expected to be called directly for model fitting.
</p>
<p>Fixed or random-effects models for meta-analysis are simply defined using <code>y ~ 1</code> in <code>formula</code>, where <code>y</code> is a response vector optionally stored in <code>data</code>. In  meta-regression models, other terms are added in the right-hand side of the formula as <code>y ~ x1 + ... + xp</code>, defining the linear meta-predictor. Factors, variable transformations and interactions are allowed, following the usual formula specification (see <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>).
</p>
<p>In this standard usage, each of the <code class="reqn">n</code> rows is assumed to represent a single estimate of an outcome from a set of independent studies. In random-effects models, the grouping structure is automatically derived by assigning a group to each row of data (with <code class="reqn">m=n</code>). Extensions to multivariate models (<code class="reqn">k&gt;1</code>) are straightforward, and only require using a matrix in the left-hand side, where each of the <code class="reqn">k</code> columns represents a different outcome, or the form <code>cbind(y1, ..., yk) ~ 1</code>. See <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>.
</p>
<p>Non-standard random-effects models can be specified through the optional argument <code>random</code>. This is commonly represented by a one-sided formula, whose basic random-intercept form is <code>~ 1 | g</code>, where <code>g</code> is a grouping factor. A more complex linear meta-predictor for the random-effects part can be also specified by <code>~ z1 + ... + zq | g</code>.  The argument <code>random</code> also accepts a list of one-sided formulae referring to multiple random-effects levels (see <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>). The use of <code>random</code> extends the standard meta-analytical setting by relaxing the assumption of independence between units, allowing multiple estimates from the same group (with <code class="reqn">m&lt;n</code>) and multiple nested grouping levels. This provides the possibility to fit longitudinal, multilevel, and dose-response meta-analysis, among other extensions. See the examples below.
</p>
<p>The argument <code>bscov</code> allows the definition of specific structures for the random-effects (co)variance matrices corresponding the each level. The default unstructured form requires <code>kq(kq+1)/2</code> parameters for a single-level meta-analysis. The choice of other structures reduces the number of parameters, although requiring stronger assumptions. More information and complete list of options is available at a specific help page (see <code><a href="#topic+mixmetaCovStruct">mixmetaCovStruct</a></code>).
</p>
<p>The within-unit (co)variances are provided through the argument <code>S</code>, usually as a matrix. If the correlations are available, each of the <code class="reqn">m</code> row represents the <code class="reqn">k(k+1)/2</code> vectorized entries of the lower triangle of the related (co)variance matrix, taken by column (see <code><a href="#topic+xpndMat">xpndMat</a></code>). If correlations are not available, each row represents the <code class="reqn">k</code> variances, and the correlations are inputted internally through the argument <code>Scor</code> of the <code>control</code> list (see <code><a href="#topic+inputcov">inputcov</a></code>). For more complex error structures that span multiple units, the argument <code>S</code> can be omitted and passed through <code>addSlist</code> in <code>control</code>, although requiring the observations to be re-ordered accordingly to groups (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>).
</p>
<p>Different estimator are available in the package <code>mixmeta</code> and chosen through the argument <code>method</code>, with related fitting functions called internally. In the current version, the options are:
</p>

<ul>
<li> <p><code>method="fixed"</code>: <code><a href="#topic+mixmeta.fixed">Fixed-effects estimator</a></code>
</p>
</li>
<li> <p><code>method="ml"</code>: <code><a href="#topic+mixmeta.ml">Maximum likelihood (ML) estimator</a></code>
</p>
</li>
<li> <p><code>method="reml"</code>: <code><a href="#topic+mixmeta.reml">Restricted maximum likelihood (REML) estimator</a></code>
</p>
</li>
<li> <p><code>method="mm"</code>: <code><a href="#topic+mixmeta.mm">Method of moments estimator</a></code>
</p>
</li>
<li> <p><code>method="vc"</code>: <code><a href="#topic+mixmeta.vc">Variance components estimator</a></code>
</p>
</li></ul>

<p>Note that non-standard random-effects models and the use of structured (co)variance matrices are only available for <code>"ml"</code> and <code>"reml"</code> methods. See their help pages for further details on the estimation procedures, following the links above.
</p>
<p>Missing values are allowed in both sides of <code>formula</code>. In the case of missing predictors (right-hand side of <code>formula</code>), the related unit is entirely excluded from estimation. In contrast, a unit still contributes to estimation if at least outcome is non-missing. This behaviour is different from standard regression functions such as <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>. Before the call to <code>mixmeta.fit</code>, units matching such stricter missing definition are removed from the the model frame. The missing pattern in <code>S</code> must be consistent with that in <code>y</code>. See further details on handling <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code> in <code>mixmeta</code>.
</p>
<p>The fitting procedure can be controlled through the additional terms specified in <code>control</code>, which are passed to the function <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.
</p>


<h3>Value</h3>

<p>The <code>mixmeta</code> function typically returns a list object of class <code>"mixmeta"</code> representing the meta-analytical model fit, as described in <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>. When <code>method="data.frame"</code>, the model is not fitted and the model frame is returned, namely a data frame with special attributes (see the default method <code><a href="stats.html#topic+model.frame">model.frame</a></code>) and, in this case, the additional class <code>"data.frame.mixmeta"</code>.
</p>
<p>The wrapper function <code>mixmeta.fit</code> is usually called internally in <code>mixmeta</code>, and returns an intermediate list object with some of the components expected in the <code>"mixmeta"</code> class.
</p>
<p>Several method functions for regression objects are available, either default or specifically written for the <code>"mixmeta"</code> class. See <code><a href="#topic+mixmetaObject">mixmetaObject</a></code> for a complete list.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Gasparrini A. (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Gasparrini A, Armstrong B, Kenward MG (2012). Multivariate meta-analysis for non-linear and other multi-parameter associations. <em>Statistics in Medicine</em>. <b>31</b>(29):3821&ndash;3839. [Freely available <a href="http://www.ag-myresearch.com/2012_gasparrini_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See additional info on the estimation procedures at the related page of the fitting functions See <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code> for the use of formulae to define the fixed and random parts of the model. See alternative <code><a href="#topic+mixmetaCovStruct">(co)variance structures</a></code> for likelihood-based estimation methods. See handling of <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code> in <code>mixmeta</code>. See <code><a href="nlme.html#topic+lme">lme</a></code>, <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> for standard regression functions. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of this modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### STANDARD MODELS

# RANDOM-EFFECTS META-ANALYSIS, ESTIMATED WITH REML
model &lt;- mixmeta(logor, logorvar, data=bcg)
summary(model)

# RANDOM-EFFECTS META-REGRESSION, ESTIMATED WITH ML
model &lt;- mixmeta(logor~ablat, logorvar, data=bcg, method="ml")
summary(model)


### MAIN METHOD FUNCTIONS

# COEFFICIENTS AND (CO)VARIANCE MATRIX
coef(model)
vcov(model)

# RESIDUALS AND FITTED VALUES
residuals(model)
fitted(model)

# MODEL FRAME AND MODEL MATRIX
model.frame(model)
model.matrix(model)

# LOG-LIKELIHOOD AND AIC VALUE
logLik(model)
AIC(model)

# COCHRAN Q TEST FOR RESIDUAL HETEROGENEITY
qtest(model)


### PREDICTIONS

# PREDICTED EFFECTS
predict(model)
predict(model, se=TRUE)
predict(model, newdata=data.frame(ablat=2:5*10), ci=TRUE)

# BEST LINEAR UNBIASED PREDICTION
blup(model)
blup(model, pi=TRUE)

# SEE help(predict.mixmeta) AND help(BLUP.mixmeta) FOR MORE INFO


### MULTIVARIATE MODELS

### BIVARIATE MODELS
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98)
summary(model)
residuals(model)

### MULTIVARIATE META-ANALYSIS WITH MORE THAN 2 OUTCOMES
y &lt;- as.matrix(fibrinogen[2:5])
S &lt;- as.matrix(fibrinogen[6:15])
model &lt;- mixmeta(y, S)
summary(model)
predict(model, se=TRUE)
predict(model, se=TRUE, aggregate="outcome")


### OTHER EXTENSIONS

# MULTILEVEL META-ANALYSIS
model &lt;- mixmeta(effect, var, random= ~ 1|district/study, data=school)
summary(model)
# SEE help(school) AND help(thrombolytic) FOR MORE EXAMPLES

# DOSE-RESPONSE META-ANALYSIS (SIMPLIFIED)
model &lt;- mixmeta(logrr ~ 0 + dose, S=se^2, random= ~ 0 + dose|id, data=alcohol,
 subset=!is.na(se))
summary(model)
# SEE help(alcohol) FOR MORE EXAMPLES

# LONGITUDINAL META-ANALYSIS
model &lt;- mixmeta(logOR~time, S=logORvar, random=~I(time-15)|study, data=gliomas)
summary(model)
# SEE help(gliomas) AND help(dbs) FOR MORE EXAMPLES


### FIXED-EFFECTS MODELS AND ALTERNATIVE ESTIMATORS

# FIXED-EFFECTS MODEL
model &lt;- mixmeta(sbp~ish, S=sbp_se^2, data=hyp, method="fixed")
summary(model)

# METHOD OF MOMENTS
S &lt;- as.matrix(hsls[5:10])
model &lt;- mixmeta(cbind(b1,b2,b3), S, data=hsls, method="mm")
summary(model)

# VARIANCE COMPONENTS ESTIMATOR
model &lt;- mixmeta(cbind(PD,AL)~pubyear, S=berkey98[5:7], data=berkey98,
  method="vc")
summary(model)


### IN THE PRESENCE OF MISSING VALUES

# RUN THE MODEL
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
model &lt;- mixmeta(y, S)
summary(model)
model.frame(model)

# SEE help(na.omit.data.frame.mixmeta) FOR MORE EXAMPLES


### WHEN WITHIN-STUDY COVIARIANCES ARE NOT AVAILABLE AND/OR NEED TO BE INPUTTED

# GENERATE S
(S &lt;- inputcov(hyp[c("sbp_se","dbp_se")], cor=hyp$rho))

# RUN THE MODEL
model &lt;- mixmeta(cbind(sbp,dbp), S=S, data=hyp)

# INPUTTING THE CORRELATION DIRECTLY IN THE MODEL
model &lt;- mixmeta(cbind(y1,y2), cbind(V1,V2), data=p53, control=list(Scor=0.95))
summary(model)

# SEE help(hyp) AND help(p53) FOR MORE EXAMPLES


### STRUCTURING THE BETWEEN-STUDY (CO)VARIANCE

# DIAGONAL
S &lt;- as.matrix(hsls[5:10])
model &lt;- mixmeta(cbind(b1,b2,b3), S, data=hsls, bscov="diag")
summary(model)
model$Psi

# COMPOUND SYMMETRY
model &lt;- mixmeta(cbind(b1,b2,b3), S, data=hsls, bscov="cs")
summary(model)
model$Psi

# SEE help(mixmetaCovStruct) FOR DETAILS AND ADDITIONAL EXAMPLES


### USE OF THE CONTROL LIST

# PRINT THE ITERATIONS AND CHANGE THE DEFAULT FOR STARTING VALUES
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
model &lt;- mixmeta(y, S, control=list(showiter=TRUE, igls.inititer=20))

# SEE help(mixmeta.control) FOR FURTHER DETAILS
</code></pre>

<hr>
<h2 id='mixmeta.control'> Ancillary Parameters for Controlling the Fit in mixmeta Models </h2><span id='topic+mixmeta.control'></span>

<h3>Description</h3>

<p>This internal function sets the parameter options used for fitting meta-analytical models, commonly to pre-specified default values. It is usually internally called by <code><a href="#topic+mixmeta">mixmeta</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmeta.control(optim=list(), showiter=FALSE, maxiter=100, initPsi=NULL, Psifix=NULL,
  Scor=NULL, addSlist=NULL, inputna=FALSE, inputvar=10^4, loglik.iter="hybrid",
  igls.inititer=10, hessian=FALSE, vc.adj=TRUE, reltol=sqrt(.Machine$double.eps),
  checkPD=NULL, set.negeigen=sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixmeta.control_+3A_optim">optim</code></td>
<td>
<p> list of parameters passed to the <code>control</code> argument of the function <code><a href="stats.html#topic+optim">optim</a></code>, which performs the <code><a href="#topic+ml.newton">quasi-Newton optimization</a></code> in likelihood-based random-effects models. See <code><a href="stats.html#topic+optim">optim</a></code> for the list of arguments. See Details for additional info.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_showiter">showiter</code></td>
<td>
<p> logical. If <code>TRUE</code>, the progress of iterative optimization is shown.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_maxiter">maxiter</code></td>
<td>
<p> positive interger value. Maximum number of iterations in methods involving optimization procedures.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_initpsi">initPsi</code></td>
<td>
<p> either a matrix or a vector of its lower triangular elements (with diagonal, taken by column), or optionally a named list with one or more of such objects. Used as starting values of random-effects parameters in likelihood-based optimization routines. See Details.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_psifix">Psifix</code></td>
<td>
<p> either a matrix or a vector of its lower triangular elements (with diagonal, taken by column), or optionally a named list with one or more of such objects. Used to define fixed parts of the random-effects <code><a href="#topic+mixmetaCovStruct">(co)variance structures</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_scor">Scor</code></td>
<td>
<p> either a scalar, vector or matrix representing the within-unit correlation(s) to be inputted when the covariances are not provided in multivariate models, and ignored if they are. See <code><a href="#topic+inputcov">inputcov</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_addslist">addSlist</code></td>
<td>
<p> a list of <code class="reqn">m</code> matrices for the (outer-level) groups of units defining the (known) error (co)variance structure, when this cannot be passed through the argument <code>S</code> of <code><a href="#topic+mixmeta">mixmeta</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_inputna">inputna</code></td>
<td>
<p> logical. If missing values must be internally inputted. To be used with caution. See <code><a href="#topic+inputna">inputna</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_inputvar">inputvar</code></td>
<td>
<p> multiplier for inputting the missing variances, to be passed as an argument to <code><a href="#topic+inputna">inputna</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_loglik.iter">loglik.iter</code></td>
<td>
<p> iterative scheme used in in likelihood-based optimization routines. Options are <code>"hybrid"</code>, <code>"newton"</code>, and <code>"igls"</code> or <code>"RIGLS"</code>. See <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_igls.inititer">igls.inititer</code></td>
<td>
<p> number of iterations of the (restricted) iterative generalized least square algorithm when used in the initial phase of hybrid optimization procedure of likelihood-based estimators. See <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_hessian">hessian</code></td>
<td>
<p> logical. If <code>TRUE</code>, the Hessian matrix of the parameters estimated in the optimization process is computed and returned. Only applicable to likelihood-based estimation methods. For details, see the info provided in the help pages of the <code><a href="#topic+ml.loglik.fn">optimizations algorithms</a></code> and <code><a href="#topic+mixmetaCovStruct">(co)variance structures</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_vc.adj">vc.adj</code></td>
<td>
<p> logical. If <code>TRUE</code>, an adjustement to the way the marginal variance part is computed in the (co)variance components estimator is applied in the variance components estimator. See <code><a href="#topic+mixmeta.vc">mixmeta.vc</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_reltol">reltol</code></td>
<td>
<p> relative convergence tolerance in methods involving optimization procedures. The algorithm stops if it is unable to reduce the value by a factor of <code>reltol * (abs(val) + reltol)</code> at a step.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_checkpd">checkPD</code></td>
<td>
<p> logical. Determines if the semi-positiveness of within-unit error or random-effects (co)variance matrices must be checked.</p>
</td></tr>
<tr><td><code id="mixmeta.control_+3A_set.negeigen">set.negeigen</code></td>
<td>
<p> positive value. Value to which negative eigenvalues are to be set in estimators where such method is used to force semi-positive definiteness of the estimated between-study (co)variance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has default values for most of the arguments, some of them set internally. Non-default values are passed through the control argument of <code><a href="#topic+mixmeta">mixmeta</a></code>. Many arguments refer to specific fitting procedures. See the help page of the related estimator for details.
</p>
<p>The function automatically sets non-default values for some control arguments for <code><a href="stats.html#topic+optim">optim</a></code>, unless explicitly set in the list passed to it. Specifically, the function selects <code>fnscale=-1</code>, <code>maxit=maxiter</code> and <code>reltol=reltol</code>, where the latter two are specified by other arguments of this function.
</p>
<p>The arguments <code>initPsi</code> and <code>Psifix</code> are used to provide information for estimation procedures of the random-effects parameters in likelihood-based methods. Specifically, the former is used to choose non-default starting values (see <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code>), and the latter for defining the fixed (known) part of specific <code><a href="#topic+mixmetaCovStruct">(co)variance structures</a></code>. In multilevel models, these arguments must be lists with named components referring to one or more levels of grouping defined by the argument <code>random</code> of <code><a href="#topic+mixmeta">mixmeta</a></code>.
</p>
<p>The argument <code>addSlist</code> can be used to define more complex (known) error structures of the outcome(s) that are usually provided through the argument <code>S</code> of <code><a href="#topic+mixmeta">mixmeta</a></code> as within-unit variances (or (co)variance matrices for multivariate models). This can be useful when these error structures spans multiple units (rows), and the between-unit correlation cannot be defined through <code>S</code>, for instance in dose-response meta-analysis (see examples in <code><a href="#topic+mixmeta">mixmeta</a></code>). Note that this information is passed internally after the data have be re-ordered following the grouping defined by <code>random</code> in <code><a href="#topic+mixmeta">mixmeta</a></code>, and this should be consistent in <code>addSlist</code>. Specifically, the grouping variables are assumed as factors and therefore the groups are taken in alphabetical/numeric order. It is suggested to re-order the data according to this order of the groups before fitting the model, so to ensure consistency between the grouped data and <code>addSlist</code>.
</p>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>Note</h3>

<p>The function is expected to be extended and/or modified at every release of the package <span class="pkg">mixmeta</span>. It is strongly suggested to check the arguments of this function at every release.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code>. See also <code><a href="stats.html#topic+glm.control">glm.control</a></code>. See the help pages of the related fitting functions for details on each parameter. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of this modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># PRINT THE ITERATIONS (SEE ?optim) AND CHANGE THE DEFAULT FOR STARTING VALUES
mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98,
  control=list(showiter=TRUE, igls.inititer=20))

# INPUT THE CORRELATION
mixmeta(cbind(y1,y2), S=cbind(V1,V2), data=p53, control=list(Scor=0.5))

# FIX (PARTS OF) THE RANDOM-EFFECTS (CO)VARIANCE MATRIX
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
mixmeta(y, S, bscov="prop", control=list(Psifix=diag(3)+1))
</code></pre>

<hr>
<h2 id='mixmeta.fixed'> Fixed-Effects Estimator for mixmeta Models </h2><span id='topic+mixmeta.fixed'></span>

<h3>Description</h3>

<p>This function implements a generalized least square estimator for fixed-effects meta-analysis and meta-regression, including standard univariate models and non-standard multivariate extensions. It is meant to be used internally and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmeta.fixed(Xlist, ylist, Slist, nall, control, ...)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">m</code> independent groups (usually studies) providing a single estimate (unit of analysis), <code class="reqn">k</code> outcomes and <code class="reqn">p</code> fixed-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="mixmeta.fixed_+3A_xlist">Xlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the fixed-effects part of the model. Rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.fixed_+3A_ylist">ylist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific vectors of estimated outcomes. Entries corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.fixed_+3A_slist">Slist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of within-group (co)variance matrices of estimated outcomes. Rows and columns corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.fixed_+3A_nall">nall</code></td>
<td>
<p> numeric scalar with the total number of observations (excluding missing).</p>
</td></tr>
<tr><td><code id="mixmeta.fixed_+3A_control">control</code></td>
<td>
<p> list of parameters for controlling the fitting process, usually internally set to default values by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.fixed_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation involves only the <code class="reqn">kp</code> fixed-effects coefficients. Note that, in this fixed-effects estimator, each unit is assumed independent from the others, and therefore the number of groups (the length of the lists) is identical to the number of units (<code>m=n</code>). However, this is not important in fixed-effects models, where no random (and therefore grouping) structure is used.
</p>
<p>The routine is based on a standard generalized least square (GLS) algorithm implemented in the internal function <code>glsfit</code>. The between-study (co)variance matrix is set to zero, so the marginal (co)variance matrix, composed only by elements of the within-unit component, is assumed as completely known. Similarly to the likelihood-based estimators implemented in  <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> and <code><a href="#topic+mixmeta.reml">mixmeta.reml</a></code>, the computation involves Cholesky and and QR decompositions for computational stability and efficiency. The method is described in details in Gasparrini and collaborators (2012) (see references below).
</p>


<h3>Value</h3>

<p>These functions return an intermediate list object, with some components then processed and some others added later within <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> and <code><a href="#topic+mixmeta">mixmeta</a></code> to finalize an object of class <code>"mixmeta"</code>. See <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>.
</p>


<h3>Note</h3>

<p>As stated earlier, this function is called internally by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code>, and is not meant to be used directly. In particular, its code does not contain any check on the arguments provided, which are expected in specific formats. The function is however exported in the namespace and documented for completeness.
</p>
<p>The arguments above are prepared by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> from its arguments <code>X</code>, <code>y</code> and <code>S</code>. The list structure, although requiring more elaborate coding, is computationally more efficient, as it avoids the specification of sparse block-diagonal matrices, especially for meta-analysis involving a large number of studies.
</p>
<p>Some parameters of the fitting procedures are determined by the <code>control</code> argument, with default set by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>. No missing values are accepted in the fitting functions. See details on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Gasparrini A, Armstrong B, Kenward MG (2012). Multivariate meta-analysis for non-linear and other multi-parameter associations. <em>Statistics in Medicine</em>. <b>31</b>(29):3821&ndash;3839. [Freely available <a href="http://www.ag-myresearch.com/2012_gasparrini_statmed.html"><b>here</b></a>].
</p>
<p>Berkey CS, Anderson JJ, Hoaglin DC (1996). Multiple-outcome meta-analysis of clinical trials. <em>Statistics in Medicine</em>. <b>15</b>(5):537&ndash;547.
</p>
<p>Berkey CS, et al. (1998). Meta-analysis of multiple outcomes by regression with random effects. <em>Statistics in Medicine</em>. <b>17</b>(22):2537&ndash;2550.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code> for the general usage of the functions. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to determine specific parameters of the fitting procedures. Use the triple colon operator ('<code>:::</code>') to access the code of the internal functions, such as <code>glsfit</code>. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># UNIVARIATE FIXED-EFFECTS MODEL
mod1 &lt;- mixmeta(yC, S=SCC, data=smoking, method="fixed")
summary(mod1)

# MULTIVARIATE FIXED-EFFECTS MODEL
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
mod2 &lt;- mixmeta(y, S, method="fixed")
summary(mod2)

# MULTIVARIATE FIXED-EFFECTS MODEL: REPLICATE THE RESULTS IN BERKEY ET AL. 1998
mod3 &lt;- mixmeta(cbind(PD,AL) ~ I(pubyear-1983), S=berkey98[5:7], data=berkey98,
  method="fixed")
summary(mod3)
</code></pre>

<hr>
<h2 id='mixmeta.ml'> ML and REML Estimators for mixmeta Models </h2><span id='topic+mixmeta.ml'></span><span id='topic+mixmeta.reml'></span>

<h3>Description</h3>

<p>These functions implement maximum likelihood (ML) and restricted maximum likelihood (REML) estimators for random-effects meta-analysis and meta-regression, including standard univariate models, and non-standard extensions such as multivariate, multilevel, longitudinal, and dose-response models. These functions are meant to be used internally and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmeta.ml(Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, bscov, control, ...)

mixmeta.reml(Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, bscov, control, ...)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">n</code> units aggregated within <code class="reqn">m</code> (outer-level) groups, <code class="reqn">k</code> outcomes, <code class="reqn">p</code> fixed-effects predictors, and <code class="reqn">q</code> random-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="mixmeta.ml_+3A_xlist">Xlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the fixed-effects part of the model. Rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_zlist">Zlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the random-effects part of the model. Each element of this list represents a list of matrices correponding to the (optionally multiple) grouping levels of random effects. In each matrix, rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_ylist">ylist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific vectors of estimated outcomes. Entries corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_slist">Slist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of within-group (co)variance matrices of estimated outcomes. Rows and columns corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_nalist">nalist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific logical vectors, identifying missing outcomes.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_rep">rep</code></td>
<td>
<p> matrix with <code class="reqn">m</code> rows where each column identifies the number of repetitions (number of groups) for each grouping level. The first column (outer level) is by definition a vector of 1's.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_k">k</code>, <code id="mixmeta.ml_+3A_q">q</code>, <code id="mixmeta.ml_+3A_nall">nall</code></td>
<td>
<p> number of outcomes, number of random-effects predictors (including the intercept), total number of observations (excluding missing), respectively. While usually all are scalars, in the case of multilevel models <code>q</code> can be a numeric vector representing the number of predictors for each level.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_bscov">bscov</code></td>
<td>
<p> a character vector defining the structure of the (co)variance matrix for each level or random effects. See <code><a href="#topic+mixmeta">mixmeta</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_control">control</code></td>
<td>
<p> list of parameters for controlling the fitting process, usually internally set to default values by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.ml_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation involves <code class="reqn">kp</code> fixed-effects coefficients and random-effects parameters, whose number depends on the number of grouping levels and, for each of them, on the chosen <code><a href="#topic+mixmetaCovStruct">(co)variance structure</a></code> for the between-study (co)variance matrices. A maximum of <code class="reqn">kq(kq+1)/2</code> parameters are needed in the case of or single-level models with unstructured form for the random-effects (co)variance matrix.
</p>
<p>(Restricted) maximum likelihood estimators implemented in <span class="pkg">mixmeta</span> rely on two iterative algorithms: <code><a href="#topic+ml.igls">(R)IGLS</a></code> and <code><a href="#topic+ml.newton">quasi-Newton</a></code> iterative methods. The former implements a (restricted) iterative generalized least squares method, while the latter is based on a Newton-type maximization routine using specific <code><a href="#topic+ml.loglik.fn">likelihood functions</a></code>. The default estimation method is based on a hybrid procedure, with few runs of of the (R)IGLS algorithm and then quasi-Newton iterations until convergence. This approach is optimal in exploiting the properties of both algorithms, with (R)IGLS being robust to the choice of initial values and quick in getting near the maximum, while the quasi-Newton is fast to converge from that point. Full (R)IGLS or quasi-Newton methods can be alternatively selected using the <code>control</code> argument of <code><a href="#topic+mixmeta">mixmeta</a></code> (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>). Follow the links above for details on each iterative algorithm.
</p>
<p>Both estimation algorithms adopt a profiled (or concentrated) approach, where the optimization is expressed only in terms of the random-effects parameters. Cholesky and and QR decompositions are used for computational stability and efficiency, and for assuring the positive-definiteness of the estimated between-study (co)variance matrix. The method is described in details in Gasparrini and collaborators (2012) (see references below).
</p>


<h3>Value</h3>

<p>These functions return an intermediate list object, with some components then processed and some others added later within <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> and <code><a href="#topic+mixmeta">mixmeta</a></code> to finalize an object of class <code>"mixmeta"</code>. See <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>.
</p>


<h3>Note</h3>

<p>As stated earlier, these functions are called internally by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code>, and are not meant to be used directly. In particular, their code does not contain any check on the arguments provided, which are expected in specific formats. The functions are not exported in the namespace, and only documented for completeness.
</p>
<p>The arguments above are prepared by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> from its arguments <code>X</code>, <code>Z</code>, <code>y</code>, <code>S</code>, <code>groups</code>, and <code>bscov</code>. The list structure, although requiring more elaborate coding, is computationally more efficient, as it avoids the specification of sparse block-diagonal matrices, especially for meta-analysis involving a large number of studies.
</p>
<p>Some parameters of the fitting procedures are determined by the <code>control</code> argument, with default set by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>. No missing values are accepted in the fitting functions. See details on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Gasparrini A, Armstrong B, Kenward MG (2012). Multivariate meta-analysis for non-linear and other multi-parameter associations. <em>Statistics in Medicine</em>. <b>31</b>(29):3821&ndash;3839. [Freely available <a href="http://www.ag-myresearch.com/2012_gasparrini_statmed.html"><b>here</b></a>].
</p>
<p>Pinheiro JC and Bates DM (2000). <em>Mixed-Effects Models in S and S-PLUS</em>. New York, Springer Verlag.
</p>
<p>Lindstrom MJ and Bates DM (1988). Newton-Raphson and EM algorithms for linear mixed-effects models for repeated-measures data. <em>Journal of the American Statistical Association</em>. <b>83</b>(404):1014&ndash;1022.
</p>
<p>Goldstein H (1986). Multilevel mixed linear model analysis using iterative generalized least squares. <em>Biometrika</em>. <b>73</b>(1):43.
</p>
<p>Goldstein H (1992). Efficient computational procedures for the estimation of parameters in multilevel models based on iterative generalized least squares. <em>Computational Statistics \&amp; Data Analysis</em>. <b>13</b>(1):63&ndash;71.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code> for the general usage of the functions. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to determine specific parameters of the fitting procedures. Use the triple colon operator ('<code>:::</code>') to access the code of the internal functions, such as <code>glsfit</code>. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># REML ESTIMATOR: UNIVARIATE MODEL
mod1 &lt;- mixmeta(yC, S=SCC, data=smoking)
summary(mod1)

# ML ESTIMATOR: MULTIVARIATE MODEL
year &lt;- berkey98$pubyear - 1983
mod2 &lt;- mixmeta(cbind(PD,AL) ~ year, S=berkey98[5:7], data=berkey98,method="ml")
print(summary(mod2), digits=3)
round(mod2$Psi,3)

# STRUCTURED BETWEEN-STUDY (CO)VARIANCE
y &lt;- as.matrix(fibrinogen[2:5])
S &lt;- as.matrix(fibrinogen[6:15])
mod3 &lt;- mixmeta(y, S, bscov="hcs")
summary(mod3)

# MULTILEVEL MODEL
mod4 &lt;- mixmeta(effect, var, random= ~ 1|district/study, data=school)
summary(mod4)

# LONGITUDINAL MODEL
mod5 &lt;- mixmeta(logOR~time, S=logORvar, random=~I(time-15)|study, bscov="diag",
  method="ml", data=gliomas)
summary(mod5)
</code></pre>

<hr>
<h2 id='mixmeta.mm'> Method of Moments Estimator for mixmeta Models </h2><span id='topic+mixmeta.mm'></span>

<h3>Description</h3>

<p>This function implements a method of moments estimator for multivariate and univariate  random-effects meta-analysis and meta-regression. It is meant to be used internally and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmeta.mm(Xlist, ylist, Slist, nalist, k, m, p, nall, control, ...)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">m</code> independent groups (usually studies) providing a single estimate (unit of analysis), <code class="reqn">k</code> outcomes and <code class="reqn">p</code> fixed-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="mixmeta.mm_+3A_xlist">Xlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the fixed-effects part of the model. Rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.mm_+3A_ylist">ylist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific vectors of estimated outcomes. Entries corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.mm_+3A_slist">Slist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of within-group (co)variance matrices of estimated outcomes. Rows and columns corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.mm_+3A_nalist">nalist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific logical vectors, identifying missing outcomes.</p>
</td></tr>
<tr><td><code id="mixmeta.mm_+3A_k">k</code>, <code id="mixmeta.mm_+3A_m">m</code>, <code id="mixmeta.mm_+3A_p">p</code>, <code id="mixmeta.mm_+3A_nall">nall</code></td>
<td>
<p> numeric scalars: number of outcomes, number of groups included in estimation (equal to the length of lists above), number of predictors (including the intercept), total number of observations (excluding missing).</p>
</td></tr>
<tr><td><code id="mixmeta.mm_+3A_control">control</code></td>
<td>
<p> list of parameters for controlling the fitting process, usually internally set to default values by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.mm_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this method of moments estimator, only a basic random-effects structure is allowed, where each group (usually corresponding to an independent study) provides a single estimate (unit of analysis) for one or multiple outcomes. This implies that the number of groups (<em>i.e.</em>, the length of the lists) is identical to the number of units (<code>m=n</code>). In addition, only an unstructured form for the(co)variance matrix of the single level of random effects is permitted. Therefore, the estimation involves <code class="reqn">kp</code> fixed-effects coefficients and <code class="reqn">k(k+1)/2</code> random-effects parameters, corresponding to the lower triangular entries of the between-study (co)variance matrix.
</p>
<p>The method of moment estimator implemented here represents a multivariate extension of the traditional estimator proposed by DerSimonian and Laird (1986), and simplifies to the standard method in the univariate case. The estimator used here is described in Jackson and collaborators (2013) as a generalization of that developed by Chen and collaborators (2012). However, this general version is computationally more intensive, and may turn out to be slow when applied to meta-analysis of a relatively high number of studies. An alternative and computationally faster method of moment estimator was previously proposed by Jackson and collaborators (2010), although it is not invariant to reparameterization. This latter estimator is currently not implemented in <span class="pkg">mixmeta</span>. See references below.
</p>
<p>This method of moments estimator is not bounded to provide a positive semi-definite random-effects (co)variance matrix, as shown in the simulation study by Liu and colleagues (2009). Here positive semi-definiteness is forced by setting the negative eigenvalues of the estimated matrix to a positive value close to zero at each iteration (see <code><a href="#topic+mixmeta.control">control</a></code>). Little is known about the impact of such constraint.
</p>


<h3>Value</h3>

<p>This function returns an intermediate list object, with some components then processed and some others added later within <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> and <code><a href="#topic+mixmeta">mixmeta</a></code> to finalize an object of class <code>"mixmeta"</code>. See <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>.
</p>


<h3>Note</h3>

<p>As stated earlier, this function is called internally by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code>, and is not meant to be used directly. In particular, its code does not contain any check on the arguments provided, which are expected in specific formats. The function is however exported in the namespace and documented for completeness.
</p>
<p>The arguments above are prepared by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> from its arguments <code>X</code>, <code>y</code> and <code>S</code>. The list structure, although requiring more elaborate coding, is computationally more efficient, as it avoids the specification of sparse block-diagonal matrices, especially for meta-analysis involving a large number of studies.
</p>
<p>Some parameters of the fitting procedures are determined by the <code>control</code> argument, with default set by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>. No missing values are accepted in the fitting functions. See details on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Gasparrini A, Armstrong B, Kenward MG (2012). Multivariate meta-analysis for non-linear and other multi-parameter associations. <em>Statistics in Medicine</em>. <b>31</b>(29):3821&ndash;3839. [Freely available <a href="http://www.ag-myresearch.com/2012_gasparrini_statmed.html"><b>here</b></a>].
</p>
<p>Jackson D, White IR, Riley RD (2013). A matrix based method of moments for fitting the multivariate random effects model for meta-analysis and meta-regression. <em>Biometrical Journal</em>. <b>55</b>(2):231&ndash;45.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code> for the general usage of the functions. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to determine specific parameters of the fitting procedures. Use the triple colon operator ('<code>:::</code>') to access the code of the internal functions, such as <code>fbtr</code>. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MM ESTIMATOR: UNIVARIATE MODEL
mod1 &lt;- mixmeta(PD ~ pubyear, S=berkey98[,5], data=berkey98, method="mm")
summary(mod1)

# MULTIVARIATE MODEL: REPRODUCE THE RESULTS IN CHEN ET AL. (2012)
S &lt;- as.matrix(hsls[5:10])
mod2 &lt;- mixmeta(cbind(b1,b2,b3), S, data=hsls, method="mm")
summary(mod2)

# MULTIVARIATE MODEL: REPRODUCE THE RESULTS IN JACKSON ET AL. (2013)
S &lt;- inputcov(hyp[c("sbp_se","dbp_se")], cor=hyp$rho)
mod3 &lt;- mixmeta(cbind(sbp,dbp), S=S, data=hyp, method="mm")
summary(mod3)
</code></pre>

<hr>
<h2 id='mixmeta.vc'> Variance Components Estimator for mixmeta Models </h2><span id='topic+mixmeta.vc'></span>

<h3>Description</h3>

<p>This function implements a variance components estimator for multivariate and univariate  random-effects meta-analysis and meta-regression. It is meant to be used internally and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmeta.vc(Xlist, ylist, Slist, nalist, k, m, p, nall, control, ...)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">m</code> independent groups (usually studies) providing a single estimate (unit of analysis), <code class="reqn">k</code> outcomes and <code class="reqn">p</code> fixed-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="mixmeta.vc_+3A_xlist">Xlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the fixed-effects part of the model. Rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.vc_+3A_ylist">ylist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific vectors of estimated outcomes. Entries corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.vc_+3A_slist">Slist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of within-group (co)variance matrices of estimated outcomes. Rows and columns corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="mixmeta.vc_+3A_nalist">nalist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific logical vectors, identifying missing outcomes.</p>
</td></tr>
<tr><td><code id="mixmeta.vc_+3A_k">k</code>, <code id="mixmeta.vc_+3A_m">m</code>, <code id="mixmeta.vc_+3A_p">p</code>, <code id="mixmeta.vc_+3A_nall">nall</code></td>
<td>
<p> numeric scalars: number of outcomes, number of groups included in estimation (equal to the length of lists above), number of predictors (including the intercept), total number of observations (excluding missing).</p>
</td></tr>
<tr><td><code id="mixmeta.vc_+3A_control">control</code></td>
<td>
<p> list of parameters for controlling the fitting process, usually internally set to default values by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.</p>
</td></tr>
<tr><td><code id="mixmeta.vc_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this variance components estimator, only a basic random-effects structure is allowed, where each group (usually corresponding to an independent study) provides a single estimate (unit of analysis) for one or multiple outcomes. This implies that the number of groups (<em>i.e.</em>, the length of the lists) is identical to the number of units (<code>m=n</code>). In addition, only an unstructured form for the(co)variance matrix of the single level of random effects is permitted. Therefore, the estimation involves <code class="reqn">kp</code> fixed-effects coefficients and <code class="reqn">k(k+1)/2</code> random-effects parameters, corresponding to the lower triangular entries of the between-study (co)variance matrix.
</p>
<p>The procedure is based on the estimate of the between-group (co)variance as the difference between the marginal (co)variance and the average within-group (co)variance. This in turn requires the estimate of the marginal (co)variance, obtained by the residuals of the fitted model. The procedure is iterative, with the current estimate of the between-group (co)variance plugged into a generalized least square (GLS) routine. Starting values are provided by a fixed-effects estimator (see <code><a href="#topic+mixmeta.fixed">mixmeta.fixed</a></code>). The algorithm is fast and generally converges with few iterations.
</p>
<p>Similar versions of this estimator has been previously proposed. Berkey and collaborators (1998) simply called it GLS method, and a non-iterative approach was proposed by Ritz and collaborators (2008), referred to as MVEE3 in their article. A non-iterative version for univariate models is discussed in Sidik and Jonkman (2007). The results from Berkey and collaborators (1998) are reproduced in the example below.
</p>
<p>In the original approach, the estimate of the marginal (co)variance is obtained from the sum of the residual components using a denominator equal to <code>m-p</code>. Following the development proposed by Kauermann and Carroll (2001) and Fay and Graubard (2001) in the context of sandwich (co)variance estimators, then discussed by Lu and collaborators (2007), an adjusted denominator can be computed as a quantity derived from the hat matrix. This method is expected to perform better in the presence of missing values and small data sets. This alternative adjustment is chosen by default by setting <code>vc.adj=TRUE</code> in the <code>control</code> argument.
</p>
<p>This variance component estimator is not bounded to provide a positive semi-definite between-study (co)variance matrix, as shown in the simulation study by Liu and colleagues (2009). Here positive semi-definiteness is forced by setting the negative eigenvalues of the estimated matrix to a value close to zero at each iteration (see <code><a href="#topic+mixmeta.control">control</a></code>). Little is known about the impact of such constraint.
</p>


<h3>Value</h3>

<p>This function returns an intermediate list object, with some components then processed and some others added later within <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> and <code><a href="#topic+mixmeta">mixmeta</a></code> to finalize an object of class <code>"mixmeta"</code>. See <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>.
</p>


<h3>Note</h3>

<p>As stated earlier, this function is called internally by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code>, and is not meant to be used directly. In particular, its code does not contain any check on the arguments provided, which are expected in specific formats. The function is however exported in the namespace and documented for completeness.
</p>
<p>The arguments above are prepared by <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> from its arguments <code>X</code>, <code>y</code> and <code>S</code>. The list structure, although requiring more elaborate coding, is computationally more efficient, as it avoids the specification of sparse block-diagonal matrices, especially for meta-analysis involving a large number of studies.
</p>
<p>Some parameters of the fitting procedures are determined by the <code>control</code> argument, with default set by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>. No missing values are accepted in the fitting functions. See details on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Gasparrini A, Armstrong B, Kenward MG (2012). Multivariate meta-analysis for non-linear and other multi-parameter associations. <em>Statistics in Medicine</em>. <b>31</b>(29):3821&ndash;3839. [Freely available <a href="http://www.ag-myresearch.com/2012_gasparrini_statmed.html"><b>here</b></a>].
</p>
<p>Ritz J, Demidenko E, Spiegelman G (2008). Multivariate meta-analysis for data consortia, individual patient meta-analysis, and pooling projects. <em>Journal of Statistical Planning and Inference</em>. <b>139</b>(7):1919&ndash;1933.
</p>
<p>Berkey CS, et al. (1998). Meta-analysis of multiple outcomes by regression with random effects. <em>Statistics in Medicine</em>. <b>17</b>(22):2537&ndash;2550.
</p>
<p>Liu Q, et al (2009). A two-stage hierarchical regression model for meta-analysis of epidemiologic nonlinear dose-response data. <em>Computational Statistics and Data Analysis</em>. <b>53</b>(12):4157&ndash;4167
</p>
<p>Sidik K, Jonkman JN (2007). A comparison of heterogeneity variance estimators in combining results of studies. <em>Statistics in  Medicine</em>. <b>26</b>(9):1964&ndash;81.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code> for the general usage of the functions. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to determine specific parameters of the fitting procedures. Use the triple colon operator ('<code>:::</code>') to access the code of the internal functions, such as <code>sumlist</code>. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># VC ESTIMATOR: UNIVARIATE MODEL
mod1 &lt;- mixmeta(PD ~ pubyear, S=berkey98[,5], data=berkey98, method="vc")
summary(mod1)

# VC ESTIMATOR: MULTIVARIATE MODEL
mod2 &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98,
  method="vc")
summary(mod2)

# VC ESTIMATOR: NON-ITERATIVE VERSION
mod3 &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98,
  method="vc", control=list(maxiter=1))
summary(mod3)

# VARIANCE COMPONENTS ESTIMATOR: REPLICATE THE RESULTS IN BERKEY ET AL. (1998)
mod4 &lt;- mixmeta(cbind(PD,AL) ~ I(pubyear-1983), S=berkey98[5:7], data=berkey98,
  method="vc", control=list(vc.adj=FALSE))
summary(mod4)
</code></pre>

<hr>
<h2 id='mixmetaCovStruct'> (Co)variance Structures for mixmeta Models </h2><span id='topic+mixmetaCovStruct'></span>

<h3>Description</h3>

<p>Alternative options for the (co)variance structure of the random effects random effects in meta-analytical models, usually defined through the argument <code>bscov</code> of the function <code><a href="#topic+mixmeta">mixmeta</a></code>.
</p>


<h3>Options</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">k</code> outcomes, for each grouping level with <code class="reqn">q</code> random-effects predictors the matrix can be specified in various forms listed below. For multivariate models with multiple predictors, the order implies a sequence of <code class="reqn">q</code> parameters for each <code class="reqn">k</code> outcomes. These are the options:
</p>

<ul>
<li> <p><code>unstr</code>: an unstructured form for a general positive-definite matrix. The matrix is represented by <code class="reqn">kq(kq+1)/2</code> unrestricted parameters defined as the upper triangular entries of its Cholesky decomposition.
</p>
</li>
<li> <p><code>diag</code>: a diagonal positive-definite matrix. The matrix is represented by <code class="reqn">kq</code> unrestricted parameters defined as the logarithm of the diagonal values.
</p>
</li>
<li> <p><code>id</code>: a multiple of the identity positive-definite matrix. The matrix is represented by a single unrestricted parameter defined as the logarithm of the diagonal value.
</p>
</li>
<li> <p><code>cs</code>: a positive-definite matrix with compound symmetry structure. The matrix is represented by 2 unrestricted parameters defined as the logarithm of the identical diagonal value and the transformed correlation. The latter is parameterized so to obtain a correlation value between <code class="reqn">-1/(kq-1)</code> and 1, in order to ensure positive-definiteness.
</p>
</li>
<li> <p><code>hcs</code>: a positive-definite matrix with heterogeneous compound symmetry structure. The matrix is represented by <code class="reqn">kq+1</code> unrestricted parameters defined as the logarithm of the diagonal values and the transformed correlation. The latter is parameterized so to obtain a correlation value between <code class="reqn">-1/(kq-1)</code> and 1, in order to ensure positive-definiteness.
</p>
</li>
<li> <p><code>ar1</code>: a positive-definite matrix with autoregressive structure of first order. The matrix is represented by 2 unrestricted parameters defined as the logarithm of the identical diagonal value and the logistic transformed correlation. The latter is parameterized so to obtain a correlation value between -1 and 1.
</p>
</li>
<li> <p><code>har1</code>: a positive-definite matrix with heterogeneous autoregressive structure of first order. The matrix is represented by <code class="reqn">kq+1</code> unrestricted parameters defined as the logarithm of the diagonal value and the logistic transformed correlation. The latter is parameterized so to obtain a correlation value between -1 and 1.
</p>
</li>
<li> <p><code>prop</code>: a positive-definite matrix proportional to that provided by the user through the argument <code>Psifix</code> in the control list (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>). The matrix is represented by 1 unrestricted parameter defined as the logarithm of the multiplier.
</p>
</li>
<li> <p><code>cor</code>: a positive-definite matrix with correlation structure provided by the user through the argument <code>Psifix</code> (with <code><a href="stats.html#topic+cov2cor">cov2cor</a></code>) in the control list (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>). The matrix is represented by <code class="reqn">k</code> unrestricted parameters defined as the logarithm of the diagonal values.
</p>
</li>
<li> <p><code>fixed</code>: a known matrix provided by the user through the argument <code>Psifix</code> in the control list (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>). The matrix is known and no parameters are needed to represent it.
</p>
</li></ul>



<h3>Details</h3>

<p>Structures other than <code>unstr</code> are only available for models estimated through (restricted) maximum likelihood.
</p>
<p>The unrestricted parameters defining the random-effects (co)variance matrix (or matrices for multilvel models) are estimated in the iterative optimization algorithm (see <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code>). Although rarely needed and not recommeded, the user can provided a starting value of the (co)variance matrix, from which the parameters are derived (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>).
</p>


<h3>Note</h3>

<p>The choice of structures can affect the performance of the optimization procedure, determining forms of likelihood surfaces which induce convergence to local maxima. In particular, structures such as multiple of identity or proportional to a fixed matrix are based on strong assumptions and should be used with caution.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Pinheiro JC and Bates DM (2000). <em>Mixed-Effects Models in S and S-PLUS</em>. New York, Springer Verlag.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code>. See <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> for standard regression functions. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of this modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># UNSTRUCTURED AND STRUCTURED BETWEEN-STUDY (CO)VARIANCE
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
mod1 &lt;- mixmeta(y, S)
summary(mod1)
mod1$Psi

# DIAGONAL
mod2 &lt;- mixmeta(y, S, bscov="diag")
summary(mod2)
mod2$Psi

# HETEROGENEOUS COMPOUND SYMMETRY
mod3 &lt;- mixmeta(y, S, bscov="hcs")
summary(mod3)
mod3$Psi

# PROPORTIONAL
mod4 &lt;- mixmeta(y, S, bscov="prop", control=list(Psifix=diag(3)+1))
summary(mod4)
mod4$Psi

# CORRELATION
Psicor &lt;- matrix(0.2, 3, 3) ; diag(Psicor) &lt;- 1
mod5 &lt;- mixmeta(y, S, bscov="cor", control=list(Psifix=Psicor))
summary(mod5)
mod5$Psi
</code></pre>

<hr>
<h2 id='mixmetaFormula'> Formulae in mixmeta Models </h2><span id='topic+mixmetaFormula'></span>

<h3>Description</h3>

<p>Meta-analytical models fitted with <code><a href="#topic+mixmeta">mixmeta</a></code> are defined by specific formulae in its arguments <code>formula</code> and <code>random</code>. The formulae offer compact symbolic expressions with form <code>y ~ x + z</code>, where the response <code>y</code> in the left-hand side of the operator <code>~</code> is modelled in terms of meta-predictors <code>x</code> and <code>z</code> in the right-hand side. Terms are separated by <code>+</code>, and additional syntactic operators and existing functions can be used within a formula to specify transformations such as categorization and interactions, among others, as in standard formula expressions (see <code><a href="stats.html#topic+formula">formula</a></code> for details). The usage of formulae in <span class="pkg">mixmeta</span> for the random-effects part follows closely the definition in the the <span class="pkg">nlme</span> package.
</p>


<h3>Fixed-effects formula</h3>

<p>The argument <code>formula</code> of <code><a href="#topic+mixmeta">mixmeta</a></code> defines the fixed-effects part. Models for meta-analysis with no meta-predictors can be specified using the form <code>y ~ 1</code>, or alternatively including only the term <code>y</code> (in this case, the formula is reconstructed internally). Multivariate models can be defined by using a matrix-type <code>y</code>, with columns as multiple outcomes, or directly in the formula with form <code>cbind(y1 + y2) ~ 1</code>. In  meta-regression models, other terms are added in the right-hand side of the formula as <code>y ~ x1 + ... + xp</code>, defining the linear meta-predictor. In multivariate meta-regression, the same linear predictor is specified for each outcome.
</p>


<h3>Random-effects formula or formulae</h3>

<p>The argument <code>random</code> of <code><a href="#topic+mixmeta">mixmeta</a></code> defines the random-effects part. When this is not specified, it is assumed that each row of data is from an independent study and assigned to a different group, as in standard meta-analytical models. If provided, this is usually represented by a one-sided formula whose basic random-intercept form is <code>~ 1 | g</code>. The term <code>g</code> at the right-hand side of the special operator <code>|</code> is the grouping factor, always required in a single random-effects formula. A more complex random-effects part can be also specified by <code>~ z1 + ... + zq | g</code>, where the terms in the left-hand side defines a linear meta-predictor, with syntax identical to the usual formulae.
</p>
<p>The argument <code>random</code> also accepts a list of one-sided formulae referring to multiple random-effects levels in multilevel meta-analytical models. In this case, levels are assumed to be nested in the order of the list, from the lowest (outer) to the highest (inner), consistently with the grouping factors. These are usually defined by different terms in the right-hand side of the <code>|</code> operator, although in the list form can also be provided as names of the list components. This information is used internally to reconstruct the grouping structure and the random-effects design matrices. Each level can have different linear predictors, but if these are identical across levels the random-effects part can be defined by a single equation <code>~ z | g1 / g2</code>, where the special operator <code>/</code> separates the grouping factors <code>g2</code> nested in <code>g1</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code>. See <code><a href="stats.html#topic+formula">formula</a></code> for standard regression formulae. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of this modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STANDARD RANDOM-EFFECTS META-ANALYSIS (WITH DIFFERENT SYNTAXES)
mixmeta(logor, logorvar, data=bcg)
mixmeta(logor ~ 1, logorvar, data=bcg)

# META-REGRESSION
mixmeta(logor ~ ablat, logorvar, data=bcg)

# MULTIVARIATE MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98)

# NON-STANDARD MODEL: REPEATED MEASURED WITHING THE SAME GROUPS
mixmeta(effect, var, random= ~ 1|district, data=school)
mixmeta(absrisk, var, random= ~ 1|trial, data=thrombolytic)

# NON-STANDARD MODEL: MORE COMPLEX RANDOM-EFFECTS PREDICTOR
mixmeta(logOR~time, logORvar, random= ~ I(time-15)|study, data=gliomas)

# MULTILEVEL MODEL (WITH DIFFERENT SYNTAXES)
mixmeta(effect, var, random= ~ 1|district/study, data=school)
mixmeta(effect, var, random=list(~ 1|district, ~ 1|study), data=school)
mixmeta(effect, var, random=list(district = ~ 1, study = ~ 1), data=school)
</code></pre>

<hr>
<h2 id='mixmetaObject'> mixmeta Objects </h2><span id='topic+mixmetaObject'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+mixmeta">mixmeta</a></code> function, inheriting from class <code>"mixmeta"</code>, and representing a fitted univariate or multivariate meta-analytical model.
</p>


<h3>Value</h3>

<p>Objects of class <code>"mixmeta"</code> are lists with defined components. Dimensions of such components may refer to <code class="reqn">k</code> outcome parameters, <code class="reqn">p</code> fixed-effects and <code class="reqn">q</code> random-effects predictors, <code class="reqn">m</code> groups and <code class="reqn">n</code> units used for fitting the model (the latter can be different from those originally selected due to missing). Depending on the type of meta-analytical model, the following components can bu included in a legitimate <code>mixmeta</code> object:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> a <code class="reqn">kp</code>-dimensional vector of the fixed-effects coefficients.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p> estimated <code class="reqn">kp \times kp</code> (co)variance matrix of the fixed-effects coefficients.</p>
</td></tr>
<tr><td><code>Psi</code></td>
<td>
<p> the estimated <code class="reqn">kq \times kq</code> random-effects (co)variance matrix, or a list of matrices for multilevel models. Only for random-effects models.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> a <code class="reqn">n</code>-dimensional vector (for univariate models) or <code class="reqn">n \times k</code> matrix (for multivariate models) of residuals, that is observed minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> a <code class="reqn">n</code>-dimensional vector (for univariate models) or <code class="reqn">n \times k</code> matrix (for multivariate models) of fitted mean values.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p> the residual degrees of freedom.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p> the numeric rank of the fixed-effects part of the fitted model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p> the (restricted) log-likelihood of the fitted model. Set to <code>NA</code> for non-likelihood models.</p>
</td></tr>
<tr><td><code>converged</code>, <code>niter</code></td>
<td>
<p> for models with iterative estimation methods, logical scalar indicating if the algorithm eventually converged and number or iterations, respectively.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p> parameters estimated in the optimization process when using likelihood-based estimators. These correspond to trasformations of entries of the random-effects (co)variance matrix, dependent on chosen <code><a href="#topic+mixmetaCovStruct">(co)variance structure</a></code>. For multilevel models, the vector includes the parameters of multiple matrices. Returned also for full (R)IGLS optimization, even if not directly used. See also the <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> for details.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> Hessian matrix of the estimated parameters in <code>par</code> above, only returned if <code>hessian=TRUE</code> in <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>. See the related <code><a href="#topic+ml.loglik.fn">optimizations algorithms</a></code> for details.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p> list with the following components: <code>k</code> (scalar, number of outcome parameters), <code>n</code> (scalar, number of units included in estimation, which could be lower than the total number in the presence of missing values), <code>m</code> (scalar, number of outer-level groups), <code>p</code> (scalar, number of fixed-effects predictors), <code>q</code> (scalar or vector,number of random-effects predictors).</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p> list with the following scalar components: <code>nall</code> (number of observations used for estimation, excluding missing values), <code>nobs</code> (equal to <code>nall</code>, minus the number of fixed-effects coefficients in REML models), <code>fixed</code> (number of estimated fixed-effects coefficients), <code>random</code> (number of estimated random-effects (co)variance terms).</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p> list with the following label vectors: <code>k</code> for the outcome parameters, and <code>p</code> and <code>q</code> for the fixed and random-effects predictors, respectively (including intercept). The last one can be a list for multilevel models.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p> a <code class="reqn">n \times k(k+1)/2</code> matrix, where each row represents the vectorized entries of the lower triangle of the related within-unit (co)variance error matrix, taken by column. See <code><a href="#topic+mixmeta">mixmeta</a></code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the function call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> the formula for the fixed-effects part of the model. See <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> the model frame used for fitting. Reported if <code>model=TRUE</code> in <code><a href="#topic+mixmeta">mixmeta</a></code>. See <code><a href="#topic+model.frame.mixmeta">model.frame</a></code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the <code><a href="#topic+terms.mixmeta">terms</a></code> object representing the fixed-effects part of the fitted model.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p> (where relevant) the contrasts used.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p> (where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p> (where relevant) information returned by <code><a href="#topic+model.frame.mixmeta">model.frame</a></code> on the special handling of NAs. See info on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> the estimation method.</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p> the formula (or list of formulae for multilevel models) for the random-effects part of the model. See <code><a href="#topic+mixmetaFormula">mixmetaFormula</a></code>.</p>
</td></tr>
<tr><td><code>bscov</code></td>
<td>
<p> a string defining the random-effects (co)variance structure in likelihood based models. See <code><a href="#topic+model.frame.mixmeta">model.frame.mixmeta</a></code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p> a list with the values of the control arguments used, as returned by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>A number of methods functions are available for <code>mixmeta</code> objects, most of them common to other regression functions.
</p>
<p>Specifically-written method functions are defined for <code><a href="#topic+predict.mixmeta">predict</a></code> (standard predictions) and <code><a href="#topic+blup.mixmeta">blup</a></code> (best linear unbiased predictions). The method function <code><a href="#topic+simulate.mixmeta">simulate</a></code> produces simulated outcomes from a fitted model, while <code><a href="#topic+qtest.mixmeta">qtest</a></code> performs the Cochran Q test for heterogeneity. Other methods have been produced for <code><a href="#topic+summary.mixmeta">summary</a></code>, <code><a href="#topic+logLik.mixmeta">logLik</a></code>, <code><a href="#topic+coef.mixmeta">coef</a></code>, and <code><a href="#topic+vcov.mixmeta">vcov</a></code>.
</p>
<p>Specific methods are also available for <code><a href="#topic+model.frame.mixmeta">model.frame</a></code> and <code><a href="#topic+model.matrix.mixmeta">model.matrix</a></code>. In particular, the former produces the model frame (a data frame with special attributes storing the variables used for fitting) with the additional class <code>"data.frame.mixmeta"</code>. A method <code><a href="#topic+terms.mixmeta">terms</a></code> is also available for extracting the terms object (only for fixed-effects or full). Methods <code><a href="#topic+na.omit.data.frame.mixmeta">na.omit</a></code> and <code><a href="#topic+na.exclude.data.frame.mixmeta">na.exclude</a></code> for this class are useful for the handling of missing values in <code>mixmeta</code> objects.
</p>
<p>Printing functions for the objects of classes defined above are also provided. <code>anova</code> methods for performing tests in <code>mixmeta</code> objects are in development.
</p>
<p>All the methods above are visible (exported from the namespace) and documented. In additions, several default method functions for regression are also  applicable to objects of class <code>"mixmeta"</code>, such as <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>, <code><a href="stats.html#topic+drop1">drop1</a></code> and <code><a href="stats.html#topic+add1">add1</a></code>, or <code><a href="stats.html#topic+update">update</a></code>, among others.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code>. See <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> for standard regression functions. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of this modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL)~pubyear, S=berkey98[5:7], data=berkey98)

# INSPECT THE OBJECT
names(model)

# LABELS
model$lab

# FORMULA
model$formula

# CONVERGED?
model$converged
</code></pre>

<hr>
<h2 id='mixmetaSim'> Simulating Responses for mixmeta Models </h2><span id='topic+mixmetaSim'></span><span id='topic+simulate.mixmeta'></span>

<h3>Description</h3>

<p>These functions simulate sets of responses (either univariate or multivariate) for a group of units, in terms of their mean (expected) values and within and between-group (co)variances. These sets of outcomes can be used in meta-analytical models for simulation purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixmetaSim(y, S, Psi, random, data, nsim=1, seed=NULL, ...)

## S3 method for class 'mixmeta'
simulate(object, nsim=1, seed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<p>In order to simulate <code class="reqn">k</code> outcomes for <code class="reqn">n</code> units:
</p>
<table role = "presentation">
<tr><td><code id="mixmetaSim_+3A_y">y</code></td>
<td>
<p> a <code class="reqn">n</code>-dimensional vector (for simulating univariate responses) or <code class="reqn">m \times k</code> matrix (for simulating multivariate responses) of mean (expected) outcomes.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_s">S</code></td>
<td>
<p> series of within-unit variances (or (co)variance matrices for multivariate models) of the estimated outcome(s). For the list of accepted format, see the argument with the same name in <code><a href="#topic+mixmeta">mixmeta</a></code>. Covariances or more complex error structures can be passed through additional arguments. See Details below.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_psi">Psi</code></td>
<td>
<p> the random-effects (co)variance matrix (or a list of matrices for multilevel models) of the outcomes. Dimension must be consistent with the specification of the random-effects structure in <code>random</code>.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_random">random</code></td>
<td>
<p> a one-sided formula (or a list of formulae for multilevel models) offering a symbolic description of the linear predictor(s) and grouping structure for the random-effects part of the model. See the argument with the same name in <code><a href="#topic+mixmeta">mixmeta</a></code>.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_data">data</code></td>
<td>
<p> an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame), optionally containing the variables in <code>y</code>, <code>S</code>, and <code>random</code>.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_nsim">nsim</code></td>
<td>
<p> number of simulation sets.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_seed">seed</code></td>
<td>
<p> an object specifying if and how the random number generator should be initialized.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_object">object</code></td>
<td>
<p>  an object of class <code>"mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="mixmetaSim_+3A_...">...</code></td>
<td>
<p> further optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set(s) of responses can be simulated either from a fitted model, using the method function <code>simulate</code> for objects of class <code>"mixmeta"</code>, or directly through the function <code>mixmetaSim</code>. In the former case, the fitted values from the model are used as mean (expected) outcomes, together with the within-unit and estimated random-effects (co)variance structure. In the latter option, this information need to be provided by the user in the correct dimensions and forms.
</p>
<p>Additional arguments can be passed in <code>'...'</code>. Specifically, arguments <code>Scor</code> and <code>addSlist</code> can be added to input missing within-unit error covariances, or to specify more complex within-unit error structures, respectively. Another argument can be <code>checkPD</code> (logical), that checks the semi-positive definiteness of the matrices). See  <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> for details.
</p>
<p>The functions simulate the responses for each study separately from a marginal multivariate normal distribution with mean equal to the expected values and (co)variance equal to the sum of the within-unit errors and random-effects components. The computation is identical to that implemented in the function <code>mvrnorm</code> of the package <span class="pkg">MASS</span>, involving a eigen decomposition of the marginal (co)variance matrix. Numerical negative definiteness is checked, and positive semi-definiteness then forced by truncating the eigenvalues at a value close to zero (see <code><a href="#topic+mixmeta.control">control</a></code>).
</p>


<h3>Value</h3>

<p>If <code>nsim=1</code>, a matrix or vector of simulated <code class="reqn">k</code> outcomes for the <code class="reqn">n</code> units. If more simulation sets are required (<code>nsim</code> higher than 1), a list of matrices or vectors.
</p>


<h3>Note</h3>

<p>Studies with missing values in the fitted values or in the components of the within (co)variances are excluded by <code>simulate</code>. Missing values are instead not accepted in <code>metaSim</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+simulate">simulate</a></code> for the general method function. See <code><a href="#topic+inputcov">inputcov</a></code> for inputting correlations. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN A MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98)

# SIMULATE A NEW SET OF OUTCOMES
simulate(model)

# SIMULATE FROM SCRATCH: 3 OUTCOMES, 8 STUDIES
(y &lt;- matrix(0, 8, 3))
(S &lt;- inputcov(matrix(runif(8*3, 0.1, 2), 8, 3, dimnames=list(NULL,
  c("V1","V2","V3"))), cor=c(0,0.5,0.7)))
(Psi &lt;- inputcov(1:3, cor=0.3))
mixmetaSim(y, S, Psi)

# 2 SIMULATION SETS
mixmetaSim(y, S, Psi, nsim=2)
</code></pre>

<hr>
<h2 id='ml.igls'> IGLS and RIGLS Iterative Algorithms for mixmeta Models </h2><span id='topic+ml.igls'></span><span id='topic+reml.rigls'></span><span id='topic+igls.iter'></span><span id='topic+rigls.iter'></span>

<h3>Description</h3>

<p>These functions implements (restricted) iterative generalized least squares (IGLS and RIGLS) algorithms for (restricted) maximum likelihood estimators for random-effects meta-analytical models. They are meant to be used internally and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ml.igls(Psi, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const, bscov,
  fix, control)

reml.rigls(Psi, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const, bscov,
  fix, control)

igls.iter(Psi, Qlist, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, bscov,
  fix, control)

rigls.iter(Psi, Qlist, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, bscov,
  fix,  control)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">n</code> units aggregated within <code class="reqn">m</code> (outer-level) groups, <code class="reqn">k</code> outcomes, <code class="reqn">p</code> fixed-effects predictors, and <code class="reqn">q</code> random-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="ml.igls_+3A_psi">Psi</code></td>
<td>
<p> a matrix (or a list of matrices for multilevel models) representing the initial estimate of the random-effects (co)variance matrix.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_xlist">Xlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the fixed-effects part of the model. Rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_zlist">Zlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the random-effects part of the model. Each element of this list represents a list of matrices correponding to the (optionally multiple) grouping levels of random effects. In each matrix, rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_qlist">Qlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices mapping the random-effects parameters to be estimated in <code>Psi</code>. See references below for details.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_ylist">ylist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific vectors of estimated outcomes. Entries corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_slist">Slist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of within-group (co)variance matrices of estimated outcomes. Rows and columns corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_nalist">nalist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific logical vectors, identifying missing outcomes.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_rep">rep</code></td>
<td>
<p> matrix with <code class="reqn">m</code> rows where each column identifies the number of repetitions (number of groups) for each grouping level. The first column (outer level) is by definition a vector of 1's.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_k">k</code>, <code id="ml.igls_+3A_q">q</code>, <code id="ml.igls_+3A_nall">nall</code></td>
<td>
<p> number of outcomes, number of random-effects predictors (including the intercept), total number of observations (excluding missing), respectively. While usually all are scalars, in the case of multilevel models <code>q</code> can be a numeric vector representing the number of predictors for each level.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_const">const</code></td>
<td>
<p> value of the constant to be included in the (restricted) likelihood, therefore not computed in the iterative algorithms.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_bscov">bscov</code></td>
<td>
<p> a character vector defining the structure of the (co)variance matrix for each level or random effects. See <code><a href="#topic+mixmeta">mixmeta</a></code>.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_fix">fix</code></td>
<td>
<p> a matrix (or optionally a list of matrices for multilevel models) defining the fixed components of the random-effects part of the model. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="ml.igls_+3A_control">control</code></td>
<td>
<p> list of parameters for controlling the fitting process, usually internally set to default values by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called internally by the fitting functions <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> and <code><a href="#topic+mixmeta.reml">mixmeta.reml</a></code> to perform (R)IGLS optimization algorithms for estimating random-effects meta-analytical models.
</p>
<p>These estimators are not sensitive to the choice of the starting values, and quickly converge to the vicinity of the (restricted) maximum likelihood. The starting values in <code>Psi</code> are therefore defined by default as a matrix (or matrices) with a diagonal form and 0.001 variances, or otherwise selected by the user in the <code>control</code> argument of <code><a href="#topic+mixmeta">mixmeta</a></code> (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>).
</p>
<p>The functions <code>ml.igls</code> and <code>reml.rigls</code> first produce a design matrix that maps the entries of <code>Psi</code>, and then call <code>iter.igls</code> and <code>iter.rigls</code>, respectively, to obtain updated results at each iteration following a (R)IGLS procedure described in Goldstein and colleagues (1992). Convergence is assessed as (lack of) changes in <code>Psi</code>. Positive semi-definiteness is forced by setting the negative eigenvalues of the estimated matrix to a value close to 0 at each iteration (see <code><a href="#topic+mixmeta.control">control</a></code>).
</p>


<h3>Value</h3>

<p>The functions <code>ml.igls</code> and <code>reml.rigls</code> return an intermediate list object, with components corresponding to the estimated random-effects (co)variance matrix (or list of matrices), its parameters, the maximum (restricted) log-likelihood value, an indicator of convergence, and the number of iterations. These are then re-processed, with other components added later within other functions to finalize an object of class <code>"mixmeta"</code> (see <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>). The functions <code>iter.igls</code> and <code>iter.rigls</code> return an updated version of <code>Psi</code>.
</p>


<h3>Note</h3>

<p>As stated earlier, these functions are called internally by <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> and <code><a href="#topic+mixmeta.reml">mixmeta.reml</a></code>, and are not meant to be used directly. In particular, their code does not contain any check on the arguments provided, which are expected in specific formats. They are however exported in the namespace and documented for completeness.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Goldstein H (1992). Efficient computational procedures for the estimation of parameters in multilevel models based on iterative generalized least squares. <em>Computational Statistics \&amp; Data Analysis</em>. <b>13</b>(1):63&ndash;71.
</p>
<p>Goldstein H (1986). Multilevel mixed linear model analysis using iterative generalized least squares. <em>Biometrika</em>. <b>73</b>(1):43&ndash;56.
</p>
<p>Goldstein H (1989). Restricted unbiased iterative generalized least-squares estimation. <em>Biometrika</em>. <b>76</b>(3):622&ndash;623.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> and <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> for additional info on the fitting procedures. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to determine specific parameters of the fitting procedures. See <code><a href="#topic+mixmetaCovStruct">mixmetaCovStruct</a></code> for (co)variance structures.
See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>

<hr>
<h2 id='ml.loglik.fn'> Likelihood Functions for mixmeta Models </h2><span id='topic+ml.loglik.fn'></span><span id='topic+reml.loglik.fn'></span><span id='topic+ml.loglik.gr'></span><span id='topic+reml.loglik.gr'></span>

<h3>Description</h3>

<p>These functions compute the value of the log-likelihood and the related vectors of first partial derivatives for random-effects meta-analytical models, in terms of model parameters. They are meant to be used internally and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ml.loglik.fn(par, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const,
  bscov, fix)
ml.loglik.gr(par, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const,
  bscov, fix)

reml.loglik.fn(par, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const,
  bscov, fix)
reml.loglik.gr(par, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const,
  bscov, fix)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">n</code> units aggregated within <code class="reqn">m</code> (outer-level) groups, <code class="reqn">k</code> outcomes, <code class="reqn">p</code> fixed-effects predictors, and <code class="reqn">q</code> random-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="ml.loglik.fn_+3A_par">par</code></td>
<td>
<p> a vector representing the random-effects parameters defining the random-effects (co)variance matrix (or multiple matrices for multilevel models).</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_xlist">Xlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the fixed-effects part of the model. Rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_zlist">Zlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the random-effects part of the model. Each element of this list represents a list of matrices correponding to the (optionally multiple) grouping levels of random effects. In each matrix, rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_ylist">ylist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific vectors of estimated outcomes. Entries corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_slist">Slist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of within-group (co)variance matrices of estimated outcomes. Rows and columns corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_nalist">nalist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific logical vectors, identifying missing outcomes.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_rep">rep</code></td>
<td>
<p> matrix with <code class="reqn">m</code> rows where each column identifies the number of repetitions (number of groups) for each grouping level. The first column (outer level) is by definition a vector of 1's.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_k">k</code>, <code id="ml.loglik.fn_+3A_q">q</code>, <code id="ml.loglik.fn_+3A_nall">nall</code></td>
<td>
<p> number of outcomes, number of random-effects predictors (including the intercept), total number of observations (excluding missing), respectively. While usually all are scalars, in the case of multilevel models <code>q</code> can be a numeric vector representing the number of predictors for each level.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_const">const</code></td>
<td>
<p> value of the constant to be included in the (restricted) likelihood, therefore not computed in the <code><a href="#topic+ml.igls">iterative algorithms</a></code>.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_bscov">bscov</code></td>
<td>
<p> a character vector defining the structure of the (co)variance matrix for each level or random effects. See <code><a href="#topic+mixmeta">mixmeta</a></code>.</p>
</td></tr>
<tr><td><code id="ml.loglik.fn_+3A_fix">fix</code></td>
<td>
<p> a matrix (or optionally a list of matrices for multilevel models) defining the fixed components of the random-effects part of the model. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called internally by fitting functions, in particular <code><a href="#topic+ml.newton">ml.newton</a></code> and <code><a href="#topic+reml.newton">reml.newton</a></code>, to compute the (restricted) log-likelihood and its first partial derivatives in terms of random-effects parameters for meta-analytical models.
</p>
<p>These functions actually specify the <em>profiled</em> version of the (restricted) likelihood, expressed only in terms of random-effects parameters, while the estimate of the fixed-effects coefficients is computed at each iteration using a generalized least squares estimator, based on the current value of the between-study (co)variance matrix. At convergence, the value of this profiled version is identical to the full (restricted) likelihood. This approach is computationally efficient, as it reduces the number of parameters in the optimization routine, especially for meta-regression models.
</p>
<p>The random-effects parameters in <code>par</code> depends on the chosen <code><a href="#topic+mixmetaCovStruct">structure(s)</a></code> for the random-effects (co)variance matrix (or multiple matrices for multilevel models). The parameterization ensures positive-definiteness. A Cholesky decomposition is then performed on the marginal (co)variance matrix in order to re-express the problem as standard least square equations, an approach which speeds up the computation of matrix inverses and determinants. These equations are finally solved through a QR decomposition, which guarantees stability. More details are provided in the references below.
</p>
<p>Some parameters of the fitting procedures are determined through <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>. Specifically, the user can obtain the Hessian matrix of the estimated parameters (appropriately transformed, see <code><a href="#topic+mixmetaCovStruct">mixmetaCovStruct</a></code>) in the optimization function by setting <code>hessian=TRUE</code>, and specific settings of the optimization process can be defined by the control list argument <code>optim</code>. These values are passed to the optimization function <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Value</h3>

<p><code>ml.loglik.fn</code> and <code>reml.loglik.fn</code> return the value of the (restricted) log-likelihood for a given set of parameters in <code>par</code>. <code>ml.loglik.gr</code> and <code>reml.loglik.gr</code> return instead the related vector of first partial derivatives.
</p>


<h3>Note</h3>

<p>As stated earlier, these functions are called internally by <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> and <code><a href="#topic+mixmeta.reml">mixmeta.reml</a></code>, and are not meant to be used directly. In particular, their code does not contain any check on the arguments provided, which are expected in specific formats. They are however exported in the namespace and documented for completeness.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Lindstrom MJ and Bates DM (1988). Newton-Raphson and EM algorithms for linear mixed-effects models for repeated-measures data. <em>Journal of the American Statistical Association</em>. <b>83</b>(404):1014&ndash;1022.
</p>
<p>Harville DA (1977) Maximum likelihood approaches to variance component estimation and to related problems. <em>Journal of
the American Statistical Association</em>. <b>72</b>(358):320&ndash;338.
</p>
<p>Pinheiro JC and Bates DM (2000). <em>Mixed-Effects Models in S and S-PLUS</em>. New York, Springer Verlag.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> and <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> for additional info on the fitting procedures. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to determine specific parameters of the fitting procedures. See <code><a href="#topic+mixmetaCovStruct">mixmetaCovStruct</a></code> for (co)variance structures. See <code><a href="base.html#topic+chol">chol</a></code> and <code><a href="base.html#topic+qr">qr</a></code> for info on the Cholesky and QR decomposition.
See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>

<hr>
<h2 id='ml.newton'> Quasi-Newton Iterative Algorithms for mixmeta Models </h2><span id='topic+ml.newton'></span><span id='topic+reml.newton'></span>

<h3>Description</h3>

<p>These functions implement quasi-Newton iterative algorithms for (restricted) maximum likelihood estimators for random-effects meta-analytical models. They are meant to be used internally and not directly run by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ml.newton(Psi, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const,
  bscov, fix, control)

reml.newton(Psi, Xlist, Zlist, ylist, Slist, nalist, rep, k, q, nall, const,
  bscov, fix, control)
</code></pre>


<h3>Arguments</h3>

<p>Assuming a meta-analysis or meta-regression based on <code class="reqn">n</code> units aggregated within <code class="reqn">m</code> (outer-level) groups, <code class="reqn">k</code> outcomes, <code class="reqn">p</code> fixed-effects predictors, and <code class="reqn">q</code> random-effects predictors:
</p>
<table role = "presentation">
<tr><td><code id="ml.newton_+3A_psi">Psi</code></td>
<td>
<p> a matrix (or a list of matrices for multilevel models) representing the initial estimate of the random-effects (co)variance matrix.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_xlist">Xlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the fixed-effects part of the model. Rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_zlist">Zlist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific design matrices for the random-effects part of the model. Each element of this list represents a list of matrices correponding to the (optionally multiple) grouping levels of random effects. In each matrix, rows corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_ylist">ylist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific vectors of estimated outcomes. Entries corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_slist">Slist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of within-group (co)variance matrices of estimated outcomes. Rows and columns corresponding to missing outcomes have been excluded.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_nalist">nalist</code></td>
<td>
<p> a <code class="reqn">m</code>-dimensional list of group-specific logical vectors, identifying missing outcomes.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_rep">rep</code></td>
<td>
<p> matrix with <code class="reqn">m</code> rows where each column identifies the number of repetitions (number of groups) for each grouping level. The first column (outer level) is by definition a vector of 1's.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_k">k</code>, <code id="ml.newton_+3A_q">q</code>, <code id="ml.newton_+3A_nall">nall</code></td>
<td>
<p> number of outcomes, number of random-effects predictors (including the intercept), total number of observations (excluding missing), respectively. While usually all are scalars, in the case of multilevel models <code>q</code> can be a numeric vector representing the number of predictors for each level.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_const">const</code></td>
<td>
<p> value of the constant to be included in the (restricted) likelihood, therefore not computed in the iterative algorithms.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_bscov">bscov</code></td>
<td>
<p> a character vector defining the structure of the (co)variance matrix for each level or random effects. See <code><a href="#topic+mixmeta">mixmeta</a></code>.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_fix">fix</code></td>
<td>
<p> a matrix (or optionally a list of matrices for multilevel models) defining the fixed components of the random-effects part of the model. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="ml.newton_+3A_control">control</code></td>
<td>
<p> list of parameters for controlling the fitting process, usually internally set to default values by <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called internally by the fitting functions <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> and <code><a href="#topic+mixmeta.reml">mixmeta.reml</a></code> to perform quasi-Newton iterative optimization algorithms for estimating random-effects meta-analytical models.
</p>
<p>Starting values for the iterations are defined by <code>Psi</code>, representing a random-effects (co)variance matrix (or a list of matrices for multilevel models). In the default hybrid procedure (see <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code>), these are provided using few iterations of a <code><a href="#topic+ml.igls">(R)IGLS</a></code> algorithm. If a full quasi-Newton method is used, the starting values are instead defined by default as a matrix (or matrices) with a diagonal form and 0.001 variances, or otherwise selected by the user in the <code>control</code> argument of <code><a href="#topic+mixmeta">mixmeta</a></code> (see <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>).
</p>
<p>The functions first re-define <code>Psi</code> as a set of random-effects parameters, depending on the chosen <code><a href="#topic+mixmetaCovStruct">structure(s)</a></code>, using parameterizations that ensure the positive-definiteness of the estimated matrix (or matrices). Then, the function <code><a href="stats.html#topic+optim">optim</a></code> with <code>method="BFGS"</code> is called internally to perform the quasi-Newton optimization, using specific <code><a href="#topic+ml.loglik.fn">likelihood functions</a></code> that compute the value of the (restricted) likelihood and (optionally) the vector of its first partial derivatives. The latter are used only in the case of basic random-effects structures, or otherwise the derivatives are computed numerically.
</p>
<p>Some parameters of the optimization procedures are determined through <code><a href="#topic+mixmeta.control">mixmeta.control</a></code>. Specifically, the user can obtain the Hessian matrix of the estimated parameters (appropriately transformed, see <code><a href="#topic+mixmetaCovStruct">mixmetaCovStruct</a></code>) in the optimization function by setting <code>hessian=TRUE</code>, and specific settings of the optimization process can be defined by the control list argument <code>optim</code>. These values are passed to the optimization function <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Value</h3>

<p>These functions return an intermediate list object, with components corresponding to the estimated random-effects (co)variance matrix (or list of matrices), the maximum (restricted) log-likelihood value, an indicator of convergence, the number of iterations, and optionally the Hessian matrix. These are then re-processed, with other components added later within other functions to finalize an object of class <code>"mixmeta"</code>. See <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>.
</p>


<h3>Note</h3>

<p>As stated earlier, these functions are called internally by <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> and <code><a href="#topic+mixmeta.reml">mixmeta.reml</a></code>, and are not meant to be used directly. In particular, their code does not contain any check on the arguments provided, which are expected in specific formats. They are however exported in the namespace and documented for completeness.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Lindstrom MJ and Bates DM (1988). Newton-Raphson and EM algorithms for linear mixed-effects models for repeated-measures data. <em>Journal of the American Statistical Association</em>. <b>83</b>(404):1014&ndash;1022.
</p>
<p>Harville DA (1977) Maximum likelihood approaches to variance component estimation and to related problems. <em>Journal of
the American Statistical Association</em>. <b>72</b>(358):320&ndash;338.
</p>
<p>Pinheiro JC and Bates DM (2000). <em>Mixed-Effects Models in S and S-PLUS</em>. New York, Springer Verlag.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta.fit">mixmeta.fit</a></code> and <code><a href="#topic+mixmeta.ml">mixmeta.ml</a></code> for additional info on the fitting procedures. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> to determine specific parameters of the fitting procedures. See <code><a href="#topic+mixmetaCovStruct">mixmetaCovStruct</a></code> for (co)variance structures. See <code><a href="base.html#topic+chol">chol</a></code> and <code><a href="base.html#topic+qr">qr</a></code> for info on the Cholesky and QR decomposition.
See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>

<hr>
<h2 id='model.frame.mixmeta'> Extract Model Frame and Design Matrix from mixmeta Objects </h2><span id='topic+model.frame.mixmeta'></span><span id='topic+model.matrix.mixmeta'></span>

<h3>Description</h3>

<p>These method functions return the model frame and design matrix for meta-analytical models represented in objects of class <code>"mixmeta"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
model.frame(formula, ...)

## S3 method for class 'mixmeta'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.frame.mixmeta_+3A_object">object</code>, <code id="model.frame.mixmeta_+3A_formula">formula</code></td>
<td>
<p> an object of class <code>"mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="model.frame.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model frame is produced by <code><a href="#topic+mixmeta">mixmeta</a></code> when fitting the meta-analytical model, and stored in the <code>mixmeta</code> object if argument <code>model=TRUE</code>. Alternatively, the model frame is directly returned from a call to <code><a href="#topic+mixmeta">mixmeta</a></code> with argument <code>method="model.frame"</code>. The method function <code>model.frame</code> simply extracts the saved model frame if available, or otherwise evaluates a call to <code><a href="#topic+mixmeta">mixmeta</a></code> when <code>method="model.frame"</code>.
</p>
<p>The method function <code>model.matrix</code> extracts the design matrix for the fixed-effects part of a fitted meta-analytical model. It first extract the model frame by calling <code>model.frame</code>, and then passes the call to the default method.
</p>
<p>Note that the model frame of <code>mixmeta</code> models consist of terms for both the fixed and random-effects parts, the latter including also the grouping factors. This information can be used to reconstruct the proper model frame or matrix for each part.
</p>
<p>These methods functions are similar to those provided for regression objects <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Value</h3>

<p>For <code>model.frame</code>, a data.frame with special attributes (see the default method <code><a href="stats.html#topic+model.frame">model.frame</a></code>) and the additional class <code>"data.frame.mixmeta"</code>.
</p>
<p>For <code>model.matrix</code>, the design matrix used to fit the model.
</p>


<h3>Note</h3>

<p>The reason why these specific method functions are made available for class <code>mixmeta</code>, and in particular why a new class <code>"data.frame.mixmeta"</code> has been defined for model frames, lies in the special handling of missing values in multivariate meta-analysis models fitted with <code><a href="#topic+mixmeta">mixmeta</a></code>. Methods <code><a href="#topic+na.omit.data.frame.mixmeta">na.omit</a></code> and <code><a href="#topic+na.exclude.data.frame.mixmeta">na.exclude</a></code> for class <code>"data.frame.mixmeta"</code> are useful for properly accounting for missing values when fitting these models.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p>See the default methods <code><a href="stats.html#topic+model.frame">model.frame</a></code> and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. See <code><a href="#topic+na.omit.data.frame.mixmeta">na.omit</a></code> and <code><a href="#topic+na.exclude.data.frame.mixmeta">na.exclude</a></code> on the handling of missing values. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL AND SUMMARIZE THE RESULTS
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98,
  method="ml")

# MODEL FRAME
model$model
model.frame(model)
update(model, method="model.frame")
class(model.frame(model))

# MODEL MATRIX
model.matrix(model)
</code></pre>

<hr>
<h2 id='na.omit.data.frame.mixmeta'> Handling Missing Values in mixmeta Models </h2><span id='topic+na.omit.data.frame.mixmeta'></span><span id='topic+na.exclude.data.frame.mixmeta'></span>

<h3>Description</h3>

<p>These method functions exclude rows corresponding to units with invalid missing pattern from model frames of class <code>"data.frame.mixmeta"</code>. This guarantees the correct handling of missing values while fitting meta-analytical models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame.mixmeta'
na.omit(object, ...)

## S3 method for class 'data.frame.mixmeta'
na.exclude(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na.omit.data.frame.mixmeta_+3A_object">object</code></td>
<td>
<p> an object of class <code>"data.frame.mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="na.omit.data.frame.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A model frame of class <code>"data.frame.mixmeta"</code> is produced by <code><a href="#topic+mixmeta">mixmeta</a></code>. A call to <code>na.omit</code> or <code>na.exclude</code> removes from the model frame the rows corresponding to studies with invalid missing pattern. In addition, a <code>na.action</code> attribute is added to the model frame, namely a numeric vector corresponding to the removed rows and class <code>"omit"</code> or <code>"exclude"</code>, respectively. This information is used by <code><a href="stats.html#topic+naresid">naresid</a></code> and <code><a href="stats.html#topic+napredict">napredict</a></code> to deal with missing values in functions such as <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+predict.mixmeta">predict</a></code> and <code><a href="#topic+blup.mixmeta">blup</a></code>, among others.
</p>
<p>The definition of missing, identifying an invalid missing pattern, is different in meta-analytical models performed through <code><a href="#topic+mixmeta">mixmeta</a></code> if compared to other regression functions such as <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>, in particular for the multivariate case. Specifically, while a unit is removed if at least an observation for one predictor is missing, partially missing outcomes do not prevent the unit to contribute to estimation (see <code><a href="#topic+mixmeta">mixmeta</a></code>). Specific methods <code>na.omit</code> and <code>na.exclude</code> for class <code>"data.frame.mixmeta"</code> allow  this different definition.
</p>


<h3>Value</h3>

<p>These functions returns the model frame <code>object</code> with rows corresponding to units with invalid missing pattern being removed. They also add the related <code>na.action</code> attribute as explained above.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+na.action">na.action</a></code>, <code><a href="stats.html#topic+naresid">naresid</a></code> and <code><a href="stats.html#topic+napredict">napredict</a></code>. See <code><a href="#topic+model.frame.mixmeta">model.frame</a></code>.
See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># INPUT MISSING VALUES IN PREDICTOR AND ONE RESPONSE
data &lt;- berkey98
data[2,1] &lt;- data[4,3] &lt;- NA
data

# RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=data[5:7], data=data, method="ml")

# SUMMARIZE: NOTE THE NUMBER OF STUDIES AND OBSERVATIONS
summary(model)
df.residual(model)

# EXTRACT THE MODEL FRAME WITH na.pass
model.frame(model, na.action="na.pass")
# EXTRACT THE MODEL FRAME WITH na.omit (DEFAULT)
model.frame(model, na.action="na.omit")

# COMPARE WITH DEFAULT METHOD FOR na.omit
frame &lt;- model.frame(model, na.action="na.pass")
na.omit(frame)
class(frame)
class(frame) &lt;- "data.frame"
na.omit(frame)

# WITH na.exclude
residuals(model)
residuals(update(model, na.action="na.exclude"))
</code></pre>

<hr>
<h2 id='p53'> Mutant p53 Gene and Squamous Cell Carcinoma </h2><span id='topic+p53'></span>

<h3>Description</h3>

<p>The dataset includes studies providing evidence about whether the presence of mutant p53 tumour suppressor gene is a prognostic factor for patients presenting with squamous cell carcinoma arising from the oropharynx cavity. Unadjusted estimates of log hazard ratios of mutant p53 to normal p53 for disease-free and overall survival, together with the associated variances, are collected from 6 observational studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p53</code></pre>


<h3>Format</h3>

<p>A data frame with 6 observations on the following 5 variables:
</p>

<ul>
<li><p><code>study</code>: study ID.
</p>
</li>
<li><p><code>y1, V1</code>: estimate and associated variance of the log hazard ratio for disease-free survival.
</p>
</li>
<li><p><code>y2, V2</code>: estimate and associated variance of the log hazard ratio for overall survival.
</p>
</li></ul>



<h3>Details</h3>

<p>Only 3 studies provide estimates for disease-free survival. The within-study correlations are not reported in the original studies but are expected to be highly positively correlated. The original data are described in Tandon and colleagues (2010) and used as an example by Jackson and colleagues (2011).
</p>


<h3>Note</h3>

<p>The data provide an example of application of multivariate meta-analysis when the within-study correlations are not known. These correlations can be inputted directly in the <code><a href="#topic+mixmeta">mixmeta</a></code> function through the <code>control</code> argument. See <code><a href="#topic+mixmeta.control">mixmeta.control</a></code> for details.
</p>


<h3>Source</h3>

<p>Jackson D, Riley R, White IR (2011). Multivariate meta-analysis: Potential and promise. <em>Statistics in Medicine</em>. <b>30</b>(20);2481&ndash;2498.
</p>
<p>Tandon S, Tudur-Smith C, Riley RD, et al. (2010). A systematic review of p53 as a prognostic factor of survival in squamous cell carcinoma of the four main anatomical subsites of the head and neck. <em>Cancer Epidemiology, Biomarkers and Prevention</em>. <b>19</b>(2):574&ndash;587.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS OF EXAMPLE 3 IN JACKSON ET AL. (2011)

# INSPECT THE DATA
p53

# REML MODEL WITH INPUTTED CORRELATION EQUAL TO 0.95
model &lt;- mixmeta(cbind(y1,y2), cbind(V1,V2), data=p53, control=list(Scor=0.95))
print(summary(model), digits=2)
</code></pre>

<hr>
<h2 id='predict.mixmeta'> Predicted Values from mixmeta Models </h2><span id='topic+predict.mixmeta'></span>

<h3>Description</h3>

<p>This method function computes predictions from fitted univariate or multivariate meta-analytical models represented in objects of class <code>"mixmeta"</code>, optionally for a new set of predictor values in meta-regression models. Predictions are optionally accompanied by standard errors, confidence intervals or the entire (co)variance matrix of the predicted outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
predict(object, newdata, se=FALSE, ci=FALSE, vcov=FALSE, ci.level=0.95,
  format, aggregate="stat", na.action=na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mixmeta_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_newdata">newdata</code></td>
<td>
<p> An optional data frame in which to look for variables values with which to predict from meta-regression models.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_se">se</code></td>
<td>
<p> logical switch indicating if standard errors must be included.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_ci">ci</code></td>
<td>
<p> logical switch indicating if confidence intervals must be included.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_vcov">vcov</code></td>
<td>
<p> logical switch indicating if the (co)variance matrix must be included.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_ci.level">ci.level</code></td>
<td>
<p> a numerical value between 0 and 1, specifying the confidence level for the computation of confidence intervals.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_format">format</code></td>
<td>
<p> the format for the returned results. See Value.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_aggregate">aggregate</code></td>
<td>
<p> when <code>format="matrix"</code> and <code>se</code> or <code>ci</code> are required, the results may be aggregated by statistic or by outcome. See Value</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data contain <code>NA</code>s. The default to the value saved in <code>object</code>. See Note.</p>
</td></tr>
<tr><td><code id="predict.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method function <code>predict</code> produces predicted values from <code>mixmeta</code> objects, obtained by evaluating the original call to <code><a href="#topic+mixmeta">mixmeta</a></code> in the frame <code>newdata</code>. For both fixed and random-effects models, estimated predictions are only based on the fixed part of the model, ignoring study-specific deviations, differently from <code><a href="#topic+blup.mixmeta">blup</a></code>.
</p>
<p>If <code>newdata</code> is omitted, the predictions are based on the data used for the fit. In that case how to handle predictions for units removed from estimation due to invalid missing pattern is determined by the <code>na.action</code> argument used in <code><a href="#topic+mixmeta">mixmeta</a></code> to produce <code>object</code>. If <code>na.action=na.omit</code>, units excluded from estimation will not appear, whereas if <code>na.action=na.exclude</code> they will appear, with values set to <code>NA</code> for all the outcomes. This step is performed by <code><a href="stats.html#topic+napredict">napredict</a></code>. See Notes.
</p>


<h3>Value</h3>

<p>The results may be aggregated in matrices (the default), or returned as lists, depending on the argument <code>format</code>. For multivariate models, the aggregation is ruled by the argument <code>aggregate</code>, and the results may be grouped by statistic or by outcome. If <code>vcov=TRUE</code>, lists are always returned.
</p>


<h3>Note</h3>

<p>The definition of missing in model frames used for estimation in <code><a href="#topic+mixmeta">mixmeta</a></code> is different than that commonly adopted in other regression models such as <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>. See info on <code><a href="#topic+na.omit.data.frame.mixmeta">missing values</a></code> in <code><a href="#topic+mixmeta">mixmeta</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+blup.mixmeta">blup</a></code> for best linear unbiased predictions. See the default method <code><a href="stats.html#topic+predict">predict</a></code>. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98)

# PREDICTED FROM YEAR 1985 TO 1987, WITH LABELS
newdata &lt;- data.frame(pubyear=1985:1987, row.names=1985:1987)

# AVERAGED OUTOCOMES AND SE
predict(model, newdata, se=TRUE)

# SAME AS ABOVE, AGGREGATED BY OUTCOME
predict(model, newdata, se=TRUE, aggregate="outcome")

# WITH VCOV, FORCED TO A LIST
predict(model, newdata, se=TRUE, vcov=TRUE, aggregate="outcome")
</code></pre>

<hr>
<h2 id='qtest'> Cochran Q Test of Heterogeneity </h2><span id='topic+qtest'></span>

<h3>Description</h3>

<p>This is a generic function to perform a Cochran Q test of (residual) heterogeneity. The function invokes particular <code><a href="utils.html#topic+methods">methods</a></code> which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument. Currently, specific methods exist for several meta-analytical models in various packages: <code><a href="#topic+qtest.mixmeta">qtest.mixmeta</a></code>, <code><a href="mvmeta.html#topic+qtest.mvmeta">qtest.mvmeta</a></code>, and <code><a href="dosresmeta.html#topic+qtest.dosresmeta">qtest.dosresmeta</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtest(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtest_+3A_object">object</code></td>
<td>
<p> an object for which the test is desired</p>
</td></tr>
<tr><td><code id="qtest_+3A_...">...</code></td>
<td>
<p> further arguments passed to specific methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test assesses the null hypothesis that the variability in the distribution of the outcomes is explained only in terms of within-unit estimation errors. This corresponds to a test on the hypotesis that there is no variation attributable to random-effects terms.
</p>


<h3>Value</h3>

<p>Returned values depend on the specific class. Usually, the results of the test.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Cochran WG (1950). The comparison of percentages in matched samples&quot;. <em>Biometrika</em>. <b>37</b>(3/4):256&ndash;266.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>Specific methods for various classes: <code><a href="#topic+qtest.mixmeta">qtest.mixmeta</a></code>, <code><a href="mvmeta.html#topic+qtest.mvmeta">qtest.mvmeta</a></code>, and <code><a href="dosresmeta.html#topic+qtest.dosresmeta">qtest.dosresmeta</a></code>.</p>

<hr>
<h2 id='qtest.mixmeta'> Cochran Q Test of Heterogeneity for mixmeta Models </h2><span id='topic+qtest.mixmeta'></span><span id='topic+print.qtest.mixmeta'></span>

<h3>Description</h3>

<p>This method function performs a Cochran Q test of (residual) heterogeneity on fitted meta-analytical models represented in objects of class <code>"mixmeta"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
qtest(object, ...)

## S3 method for class 'qtest.mixmeta'
print(x, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtest.mixmeta_+3A_object">object</code>, <code id="qtest.mixmeta_+3A_x">x</code></td>
<td>
<p> objects of classes <code>"mixmeta"</code> and <code>"qtest.mixmeta"</code>, respectively.</p>
</td></tr>
<tr><td><code id="qtest.mixmeta_+3A_digits">digits</code></td>
<td>
<p>  an integer specifying the number of digits to which printed results must be rounded.</p>
</td></tr>
<tr><td><code id="qtest.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test assesses the null hypothesis that the variability in the distribution of the outcomes is explained only in terms of estimation error in each unit, measured by the within-unit (co)variance matrices stored in the component <code>S</code> of <code>mixmeta</code> objects. This is equal to test the hypothesis that the random-effects (co)variance matrix (or all matrices in multilevel models) is a zero matrix, and there is no random deviation in unit-specific estimates. For multivariate models, tests for single outcome parameters, comparable to estimates from multiple univariate meta-analysis, are also reported. This test reduces to the standard Q test in univariate single-level models.
</p>
<p>The function compute the statistics by actually fitting the related fixed-effects model, re-evaluating the call of the model with <code>method</code> changed to <code>"fixed"</code>.
</p>


<h3>Value</h3>

<p>A list object of class <code>"qtest.mixmeta"</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Q</code></td>
<td>
<p> the vector of test statistics for overall and outcome-specific tests, distributed under the null hypothesis as a Chi-square with degrees of freedom <code>df</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p> the vector of degrees of freedom of the null distribution for overall and outcome-specific tests. For the overall test, equal to the number of observations used for estimation minus the number of coefficients in the fixed part of the model. For outcome-specific test, equal to number of observed values minus the number of coefficients.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p> the vector of p-values for overall and outcome-specific tests.</p>
</td></tr>
<tr><td><code>residual</code></td>
<td>
<p> logical switch indicating if a meta-regression model is assessed, meaning that the tested heterogeneity is residual.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p> dimensionality of the overall test, that is the number of outcome parameters in the model.</p>
</td></tr>
</table>
<p>As usual, the <code>print</code> method function for class <code>"qtest.mixmeta"</code> does not return any value.
</p>


<h3>Note</h3>

<p>In multivariate models, tests on single outcome parameters are performed by extracting the related estimates and variances, but they do not account for the correlation between them, which nevertheless has been considered in estimation. These tests are not therefore comparable with those performed by running a univariate model on each outcome parameter.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>
<p>Cochran WG (1950). The comparison of percentages in matched samples&quot;. <em>Biometrika</em>. <b>37</b>(3/4):256&ndash;266.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+qtest">qtest</a></code> for the generic method function. See <code><a href="#topic+mixmeta-package">mixmeta-package</a></code> for an overview of the package and modelling framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ 1, S=berkey98[5:7], data=berkey98)

# MULTIVARIATE COCHRAN Q TEST FOR HETEROGENEITY
test &lt;- qtest(model)
print(test, digits=2)
unclass(test)
</code></pre>

<hr>
<h2 id='school'> Studies on Modified School Calendar and Student Achievement </h2><span id='topic+school'></span>

<h3>Description</h3>

<p>The dataset contains the results of 56 studies that evaluate the effect of a modified school calendar on student achievement. The studies assessed students from grade 1 to 9 and reported standardized reading achievement differences between schools that follow a year-round versus the traditional nine-month calendar. The studies were performed in separate school districts, with at least three studies in each district.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>school</code></pre>


<h3>Format</h3>

<p>A data frame with 56 observations on the following 5 variables:
</p>

<ul>
<li><p><code>district, study</code>: numbers identifying the school district and study, respectively.
</p>
</li>
<li><p><code>effect</code>: estimated standardized effect, reported as difference in reading achievement expressed in standard deviation units.
</p>
</li>
<li><p><code>var</code>: within-study variance of the estimated effects.
</p>
</li>
<li><p><code>year</code>: year when the study was performed.
</p>
</li></ul>



<h3>Note</h3>

<p>The data provide an example of application of multilevel meta-analysis with multiple nested random-effects levels, where effect sizes are correlated between studies within school district. This more complex correlation structure is modelled by two levels of random effects. Results can be compared with the so-called three-level model in Kostantopoulos (2011), that is defined as a two-level meta-analysis here.
</p>


<h3>Source</h3>

<p>Kostantopoulos S (2011). Fixed effects and variance components estimation in three-level meta-analysis. <em>Research Synthesis Methods</em>. <b>2</b>(1):61&ndash;76.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN KOSTANTOPOULOS (2011), TABLES 4 AND 5

# STANDARD META-ANALYSIS (NB: random NOT STRICTLY NEEDED HERE)
mod1 &lt;- mixmeta(effect, var, random= ~ 1|study, data=school, method="ml")
print(summary(mod1), digits=3, report="var")

# STANDARD META-REGRESSION
yearcen &lt;- school$year - mean(school$year)
mod2 &lt;- mixmeta(effect ~ yearcen, var, random= ~ 1|study, data=school,
  method="ml")
print(summary(mod2), digits=3, report="var")

# TWO-LEVEL META-ANALYSIS
mod3 &lt;- mixmeta(effect, var, random= ~ 1|district/study, data=school,
  method="ml")
print(summary(mod3), digits=3, report="var")

# TWO-LEVEL META-REGRESSION
yearcen2 &lt;- with(school, year - mean(tapply(year, district, mean)))
mod4 &lt;- mixmeta(effect ~ yearcen2, var, random= ~ 1|district/study, data=school,
  method="ml")
print(summary(mod4), digits=3, report="var")

### SEE help(thrombolytic) FOR A COMPLEMENTARY EXAMPLE
</code></pre>

<hr>
<h2 id='smoking'> Meta-Analysis of Interventions to Promote Smoking Cessation </h2><span id='topic+smoking'></span>

<h3>Description</h3>

<p>The dataset contains the results of 24 trials comparing four alternative interventions to promote smoking cessation. The trials have different designs, comparing two or three different interventions. The data consist of the number of successes out of the total participants, and the estimated log-odds ratio for arms B (self-help), C (individual counselling), and D (group counselling) relative to arm A (no contact), as well as the (co)variance matrix of these three estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoking</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 19 variables:
</p>

<ul>
<li><p><code>study</code>: study ID.
</p>
</li>
<li><p><code>design</code>: design of the trial, reporting the interventions being compared.
</p>
</li>
<li><p><code>dA, dB, dC, dD</code>: number of successes for each intervention.
</p>
</li>
<li><p><code>nA, nB, nC, nD</code>: number of participants for each intervention.
</p>
</li>
<li><p><code>yB, yC, yD</code>: estimated log-odds ratios for interventions B, C and D versus intervention A.
</p>
</li>
<li><p><code>SBB, SBC, SBD, SCC, SCD, SDD</code>: variances and co-variances of the estimated log-odds ratios for interventions B, C and D versus intervention A. The order corresponds to the lower triangular elements of the (co)variance matrix taken by column.
</p>
</li></ul>



<h3>Details</h3>

<p>Intervention A is chosen as the reference category. Trials without an arm A (trials 2 and 21-24) are augmented with an arm A with 0.01 individuals and 0.001 successes. Trials containing zero cells (trials 9 and 20) have 1 individual with 0.5 successes added to each intervention. Details on the data augmentation and estimation of (co)variances of the log-odds ratios are provided by White (2011).
</p>


<h3>Note</h3>

<p>The data provide an example of application of network meta-analysis, also referred to as indirect mixed-treatment comparison. Additional information using examples based on these data are provided by Lu and Ades (2006), White (2011) and Higgins and colleagues (2012).
</p>


<h3>Source</h3>

<p>Lu G and Ades AE (2006). Assessing evidence inconsistency in mixed treatment comparisons. <em>Journal of the American Statistical Association</em>. <b>101</b>:447&ndash;459.
</p>
<p>Higgins JPT, et al. (2012). Consistency and inconsistency in network meta-analysis: concepts and models for multi-arm studies. <em>Research Synthesis Methods</em>. <b>3</b>(2):98&ndash;110.
</p>
<p>White IR (2011). Multivariate random-effects meta-regression. <em>The Stata Journal</em>. <b>11</b>:255&ndash;270.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN WHITE (2011)

# INSPECT THE DATA
head(smoking)
names(smoking)

# CONSISTENCY MODEL, UNSTRUCTURED BETWEEN-STUDY (CO)VARIANCE
y &lt;- as.matrix(smoking[11:13])
S &lt;- as.matrix(smoking[14:19])
mod1 &lt;- mixmeta(y, S)
summary(mod1)

# CONSISTENCY MODEL, STRUCTURED BETWEEN-STUDY (CO)VARIANCE (PROPORTIONAL)
mod2 &lt;- mixmeta(y, S, bscov="prop", control=list(Psifix=diag(3)+1))
summary(mod2)

# TRANSFORM IN LONG FORMAT, WITH S AS LIST (EXCLUDING MISSING)
long &lt;- na.omit(reshape(smoking[,c(1,2,11:13)], varying=list(3:5), idvar="study", 
  v.names="y", timevar="outcome", times=colnames(y), direction="long"))
Slist &lt;- lapply(lapply(seq(nrow(S)), function(i) xpndMat(S[i,])), function(x)
  x[!is.na(diag(x)), !is.na(diag(x)), drop=FALSE])

# THE MODELS ABOVE CAN BE REPLICATED IN THE LONG FORMAT
mod2b &lt;- mixmeta(y ~ 0 + factor(outcome), random= ~ 0 + factor(outcome)|study,
  data=long, bscov="prop", control=list(addS=Slist, Psifix=diag(3)+1))
summary(mod2b)

# DEFINE AND ADD INDICATORS FOR OUTCOME AND DESIGN
dummy &lt;- cbind(model.matrix(~0+outcome, long), model.matrix(~0+design, long))
colnames(dummy) &lt;- c(levels(factor(long$outcome)), levels(long$design))
long &lt;- cbind(long, data.frame(dummy))

# INCONSISTENCY MODEL (SPECIAL PARAMETERIZATION OF OUTCOME-BY-DESIGN INTERACTION)
formula &lt;- y ~ 0 + yB + yC + yC:acd + yC:bc + yC:bcd + yD + yD:acd + yD:bcd + 
  yD:bd + yD:cd
mod3 &lt;- update(mod2b, formula=formula)
summary(mod3)
</code></pre>

<hr>
<h2 id='summary.mixmeta'> Summarizing mixmeta Models </h2><span id='topic+summary.mixmeta'></span><span id='topic+print.mixmeta'></span><span id='topic+print.summary.mixmeta'></span>

<h3>Description</h3>

<p>Print and summary method functions for fitted meta-analytical models represented in objects of class <code>"mixmeta"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
summary(object, ci.level=0.95, ...)

## S3 method for class 'summary.mixmeta'
print(x, digits=4, report=c("sd","var"), ...)

## S3 method for class 'mixmeta'
print(x, digits=4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mixmeta_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mixmeta"</code> produced by a call to <code><a href="#topic+mixmeta">mixmeta</a></code>.</p>
</td></tr>
<tr><td><code id="summary.mixmeta_+3A_x">x</code></td>
<td>
<p> an object of class <code>"mixmeta"</code> or <code>"summary.mixmeta"</code>, produced by calls to <code><a href="#topic+mixmeta">mixmeta</a></code> or <code>summary.mixmeta</code>, respectively.</p>
</td></tr>
<tr><td><code id="summary.mixmeta_+3A_ci.level">ci.level</code></td>
<td>
<p> a numerical value between 0 and 1, specifying the confidence level for the computation of confidence intervals.</p>
</td></tr>
<tr><td><code id="summary.mixmeta_+3A_digits">digits</code></td>
<td>
<p> an integer specifying the number of digits to which printed results must be rounded.</p>
</td></tr>
<tr><td><code id="summary.mixmeta_+3A_report">report</code></td>
<td>
<p> if standard deviations (<code>sd</code>) or variances (<code>var</code>) must be reported for summarizing the random-effects (co)variance structure.</p>
</td></tr>
<tr><td><code id="summary.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method function for class <code>"mixmeta"</code> only returns basic information on the fitted model, namely the call, estimated fixed-effects coefficients, dimensions and fit statistics (log-likelihood, AIC, BIC).
</p>
<p>The <code>summary</code> method function computes additional statistics and tests, and produces a list object of class <code>"summary.mixmeta"</code>. The <code>print</code> method function for this class shows additional information, such as tables reporting the estimates for the fixed and random-effects parts of the model, Cochran Q test for heterogeneity and I-squared.
</p>


<h3>Value</h3>

<p>The <code>summary</code> method function for <code>mixmeta</code> objects produces a list of class <code>"summary.mixmeta"</code>. The components of the lists are some of those stored in the related <code>mixmeta</code> object, plus the following:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> a matrix reporting point estimates, standard errors, z statistics and related p-values of the test, and confidence intervals for the <code class="reqn">kp</code> fixed-effects coefficients. Note this is different than the component with the same name stored in <code>mixmeta</code> objects, simply reporting the point estimates (see <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>).</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p> the value of the Akaike information criterion for the fitted <code>mixmeta</code> model, obtained through a call to <code><a href="stats.html#topic+AIC">AIC</a></code>.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>  the value of the Bayesian information criterion for the fitted <code>mixmeta</code> model, obtained through a call to <code><a href="stats.html#topic+BIC">BIC</a></code>.</p>
</td></tr>
<tr><td><code>corFixed</code></td>
<td>
<p> the <code class="reqn">kp \times kp</code> correlation matrix of the fixed-effects coefficients, obtained from the (co)variance matrix <code>vcov</code> (see <code><a href="#topic+mixmetaObject">mixmetaObject</a></code> and <code><a href="#topic+vcov.mixmeta">vcov</a></code>).</p>
</td></tr>
<tr><td><code>corRandom</code></td>
<td>
<p> the <code class="reqn">kq \times kq</code> correlation matrix of the random effects, obtained from the random-effects (co)variance matrix <code>Psi</code>, or a list of multiple matrices for multilevel models. See <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>.</p>
</td></tr>
<tr><td><code>qstat</code></td>
<td>
<p> results from the Cochran Q test for heterogeneity, namely a list corresponding to a <code>qtest.mixmeta</code> object without its class, obtained through <code><a href="#topic+qtest.mixmeta">qtest</a></code>.</p>
</td></tr>
<tr><td><code>i2stat</code></td>
<td>
<p> I-squared statistic for the meta-analytical model.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p> the confidence level used for defining the confidence intervals for the estimates of the fixed-effects coefficients.</p>
</td></tr>
</table>
<p>As usual, the <code>print</code> method functions for classes <code>"mixmeta"</code> and <code>"summary.mixmeta"</code> do not return any value.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt; and Francesco Sera &lt;<a href="mailto:francesco.sera@lshtm.ac.uk">francesco.sera@lshtm.ac.uk</a>&gt;</p>


<h3>References</h3>

<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mixmeta">mixmeta</a></code> and <code><a href="#topic+mixmetaObject">mixmetaObject</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN THE MODEL
model &lt;- mixmeta(cbind(PD,AL) ~ pubyear, S=berkey98[5:7], data=berkey98)

# SIMPLE PRINT
model

# DEFINE DIGITS
print(model, digit=2)

# SUMMARY WITH 80TH CONFIDENCE INTERVALS
summary(model, ci.level=0.80)

# REPORT RANDOM EFFECTS IN TERMS OF VARIANCES (USE print)
print(summary(model), report="var")
</code></pre>

<hr>
<h2 id='terms.mixmeta'> Extract Model Terms from mixmeta Objects </h2><span id='topic+terms.mixmeta'></span>

<h3>Description</h3>

<p>These method function returns the terms object that defines meta-analytical models represented in objects of class <code>"mixmeta"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mixmeta'
terms(x, type="fixed", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terms.mixmeta_+3A_x">x</code></td>
<td>
<p> an object of class <code>"mixmeta"</code>.</p>
</td></tr>
<tr><td><code id="terms.mixmeta_+3A_type">type</code></td>
<td>
<p> the type of terms. Either <code>"fixed"</code> or <code>"full"</code>. See Details.</p>
</td></tr>
<tr><td><code id="terms.mixmeta_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>terms</code> object is produced by <code><a href="#topic+mixmeta">mixmeta</a></code> when fitting the meta-analytical model, and stored as an attribute of the <code><a href="#topic+model.frame.mixmeta">model.frame</a></code>. Note that this object consists of terms for both the fixed and random-effects parts, the latter including also the grouping factors.
</p>
<p>By using the default <code>type="fixed"</code>, this method function removes the random-effects terms. This can then be used, for instance, for creating the <code><a href="#topic+model.matrix.mixmeta">model.matrix</a></code> for the fixed effects. Otherwise with <code>type="full"</code>, the full set of terms is returned.
</p>


<h3>Value</h3>

<p>An object of class <code>c("terms","formula")</code> which contains the terms representation of a symbolic meta-analytical model. See <code><a href="stats.html#topic+terms.object">terms.object</a></code> for its structure.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

<p>See the  methods <code><a href="#topic+model.frame.mixmeta">model.frame</a></code> and <code><a href="#topic+model.matrix.mixmeta">model.matrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># RUN A MODEL
model &lt;- mixmeta(effect, var, random= ~ 1|district/study, data=school)

# TERMS (FIXED AND FULL)
terms(model)
terms(model, "full")
attr(model.frame(model), "terms")
</code></pre>

<hr>
<h2 id='thrombolytic'> Randomized Trials of Thrombolytic Therapy </h2><span id='topic+thrombolytic'></span>

<h3>Description</h3>

<p>The dataset contains the data on 20 randomized trials of thrombolytic therapy, which evaluated effect on short-term mortality after a myocardial infarction (up to 35 days) in 50,246 patients in relation to treatment delay. The hypothesis is that the thrombolytic therapy reduces the mortality risk following the myocardial infarction, and that the benefit is particularly substantial for very early treatment. Some of the trials report separate results according to treatment delay, generating 38 observations from full trials or subgroups of trials. Effect sizes were reported as absolute risk reduction computed as the difference between treated and control groups in each trial or subgroup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thrombolytic</code></pre>


<h3>Format</h3>

<p>A data frame with 38 observations on the following 10 variables:
</p>

<ul>
<li><p><code>trial</code>: label identifying the trial.
</p>
</li>
<li><p><code>time2treat</code>: treatment delay after the onset of the symptoms of a myocardial infaction, reported in hours.
</p>
</li>
<li><p><code>dtreat, ntreat</code>: number of deaths and total patients in the treated group, respectively.
</p>
</li>
<li><p><code>dcontr, ncontr</code>: number of deaths and total patients in the control group, respectively.
</p>
</li>
<li><p><code>risktreat, riskcontr</code>: risk of death in the treatment and control groups, respectively.
</p>
</li>
<li><p><code>absrisk</code>: absolute risk difference of death between the treatment and control groups. See Details.
</p>
</li>
<li><p><code>var</code>: variance of the absolute risk difference. See Details.
</p>
</li></ul>



<h3>Details</h3>

<p>The absolute risk is simply the difference in risk, which is computed empirically as ratio of the number of deaths and the number of total patients in treated and control groups (<code class="reqn">p_1=d_1/N_1</code> and <code class="reqn">p_0=d_0/N_0</code>, respectively). The variance of the absolute risk difference is computed as <code class="reqn">p_0(1-p_0)/N_0+p_1(1-p_1)/N_1</code>. See Thompson and colleagues (2001) for details.
</p>


<h3>Note</h3>

<p>The data provide an example of application of multilevel meta-analysis with repeated observations in an inner level within an outer level, corresponding here to treatment subgroups within each trial. This more complex correlation structure is modelled by two levels of random effects, including meta-predictors that can explain part of the heterogeneity at each level. Results can be compared with those reported by Thompson and colleagues (2001).
</p>


<h3>Source</h3>

<p>Thompson SG, Turner RM, Warn DE (2001). Multilevel models for meta-analysis, and their application to absolute risk differences. <em>Statistical Methods in Medical Research</em>. <b>10</b>(6):375&ndash;392.
</p>
<p>Sera F, Armstrong B, Blangiardo M, Gasparrini A (2019). An extended mixed-effects framework for meta-analysis.<em>Statistics in Medicine</em>. 2019;38(29):5429-5444. [Freely available <a href="http://www.ag-myresearch.com/2019_sera_statmed.html"><b>here</b></a>].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### REPRODUCE THE RESULTS IN THOMPSON ET AL (2001), TABLES 2, 3, AND 4

# STANDARD FIXED-EFFECTS META-ANALYSIS
mod1 &lt;- mixmeta(absrisk, var, data=thrombolytic, method="fixed")
print(summary(mod1), digits=5)

# STANDARD RANDOM-EFFECTS META-ANALYSIS
subtrial &lt;- seq(nrow(thrombolytic))
mod2 &lt;- mixmeta(absrisk, var, random= ~ 1|subtrial, data=thrombolytic)
print(summary(mod2), digits=5)

# TWO-LEVEL RANDOM-EFFECTS META-ANALYSIS
mod3 &lt;- mixmeta(absrisk, var, random= ~ 1|trial/subtrial, data=thrombolytic)
print(summary(mod3), digits=5)

# TWO-LEVEL RANDOM-EFFECTS META-REGRESSION
mod4 &lt;- mixmeta(absrisk~time2treat, var, random= ~ 1|trial/subtrial,
  data=thrombolytic)
print(summary(mod4), digits=5)

# TWO-LEVEL RANDOM-EFFECTS META-REGRESSION WITH NON-LINEAR TERM
mod5 &lt;- mixmeta(absrisk ~ time2treat + I(1/time2treat), var,
  random= ~ 1|trial/subtrial, data=thrombolytic)
print(summary(mod5), digits=5)

### SEE help(school) FOR A COMPLEMENTARY EXAMPLE
</code></pre>

<hr>
<h2 id='vechMat'> Vectorization and Expansion of Symmetric Matrices </h2><span id='topic+vechMat'></span><span id='topic+xpndMat'></span>

<h3>Description</h3>

<p>The function <code>vechMat</code> transforms a symmetric matrix in a vector containing its lower triangular elements, taken by column. The function <code>xpndMat</code> reverses this transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vechMat(mat, diag=TRUE)

xpndMat(vech)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vechMat_+3A_mat">mat</code></td>
<td>
<p> a square matrix.</p>
</td></tr>
<tr><td><code id="vechMat_+3A_vech">vech</code></td>
<td>
<p> a vector.</p>
</td></tr>
<tr><td><code id="vechMat_+3A_diag">diag</code></td>
<td>
<p> a logical switch indicating if the diagonal entries must be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector for <code>vechMat</code>, a symmetric matrix for <code>xnpdMat</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Gasparrini &lt;<a href="mailto:antonio.gasparrini@lshtm.ac.uk">antonio.gasparrini@lshtm.ac.uk</a>&gt;</p>


<h3>See Also</h3>

 
<p>See functions <code>vech</code> and <code>xpnd</code> in package <span class="pkg">MCMCpack</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GENERATE A POSITIVE-DEFINITE MATRIX, VECTORIZE IT AND THEN RE-EXPAND
(M &lt;- crossprod(matrix(rnorm(9),3)))
(v &lt;- vechMat(M))
xpndMat(v)

# EXTRACT VECTORIZED S, EXPAND TO A LIST, AND RE-VECTORIZE
(S &lt;- as.matrix(berkey98[5:7]))
(Slist &lt;- lapply(seq(nrow(S)), function(i) xpndMat(S[i,])))
t(sapply(Slist,vechMat))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
