<!DOCTYPE html><html><head><title>Help for package qad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#D1'><p>Calculate the D1 distance between two dependence structures</p></a></li>
<li><a href='#ECBC'><p>Calculate empirical checkerboard copula</p></a></li>
<li><a href='#emp_c_copula'><p>The empirical checkerboard copula</p></a></li>
<li><a href='#heatmap.qad'><p>Heatmap of dependence measures</p></a></li>
<li><a href='#pairwise.qad'><p>Pairwise quantification of (asymmetric and directed) dependencies</p></a></li>
<li><a href='#PlantDiversity'><p>Plant diversity</p></a></li>
<li><a href='#plot_density'><p>Plot density of empirical checkerboard copula</p></a></li>
<li><a href='#plot.qad'><p>Plot conditional probabilites</p></a></li>
<li><a href='#predict.qad'><p>Predict conditional probabilities</p></a></li>
<li><a href='#qad'><p>Measure of (asymmetric and directed) dependence</p></a></li>
<li><a href='#qad_distribution'><p>Distribution of qad (H0: independence)</p></a></li>
<li><a href='#qad-package'>
<p>Quantification of Asymmetric Dependencies</p></a></li>
<li><a href='#summary.qad'><p>Summarize a qad object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantification of Asymmetric Dependence</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Thimo Kasper &lt;thimo.kasper@plus.ac.at&gt;,
  Florian Griessenberger &lt;florian.griessenberger@plus.ac.at&gt;,
  Robert R. Junker &lt;&gt;,
  Valentin Petzel &lt;valetin.petzel@sbg.ac.at&gt;,
  Wolfgang Trutschnig &lt;wolfgang.trutschnig@plus.ac.at&gt;    </td>
</tr>
<tr>
<td>Description:</td>
<td>A copula-based measure for quantifying asymmetry in dependence and associations. Documentation and theory about 'qad' is provided
    by the paper by Junker, Griessenberger &amp; Trutschnig (2021, &lt;<a href="https://doi.org/10.1016%2Fj.csda.2020.107058">doi:10.1016/j.csda.2020.107058</a>&gt;), and the paper by Trutschnig (2011, &lt;<a href="https://doi.org/10.1016%2Fj.jmaa.2011.06.013">doi:10.1016/j.jmaa.2011.06.013</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/griefl/qad">https://github.com/griefl/qad</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/griefl/qad/issues">https://github.com/griefl/qad/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, data.table, copula, viridis, ggExtra, dplyr, cowplot,
Rcpp (&ge; 1.0.6)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, reshape2, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-13 15:45:30 UTC; EXT99500</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Dietrich &lt;nicolaspascal.dietrich@plus.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-14 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='D1'>Calculate the D1 distance between two dependence structures</h2><span id='topic+D1'></span><span id='topic+D1.ECBC'></span><span id='topic+zeta1'></span>

<h3>Description</h3>

<p>Computation of the D1 distance between two checkerboard copulas A and B, corresponding to the random vectors (X1,Y1) and (X2,Y2), respectively.
The function <code>D1()</code> computes the difference between the dependence structures of two random vectors. The function <code>D1.ECBC()</code> computes the D1-distance between two checkerboard copulas with the same resolution.
The function <code>zeta1()</code> is defined as 3D1(A,Pi), where Pi denotes the independence copula and returns the dependence measure computed in qad.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D1(x1, y1, x2, y2, resolution = NULL)

D1.ECBC(A, B)

zeta1(X, Y, resolution = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D1_+3A_x1">x1</code></td>
<td>
<p>a (non-empty) numeric vector of data values for the first random vector (first coordinate)</p>
</td></tr>
<tr><td><code id="D1_+3A_y1">y1</code></td>
<td>
<p>a (non-empty) numeric vector of data values for the first random vector (second coordinate)</p>
</td></tr>
<tr><td><code id="D1_+3A_x2">x2</code></td>
<td>
<p>a (non-empty) numeric vector of data values for the second random vector (first coordinate)</p>
</td></tr>
<tr><td><code id="D1_+3A_y2">y2</code></td>
<td>
<p>a (non-empty) numeric vector of data values for the second random vector (second coordinate)</p>
</td></tr>
<tr><td><code id="D1_+3A_resolution">resolution</code></td>
<td>
<p>integer indicating the resolution of the checkerboard copula. (default = NULL)</p>
</td></tr>
<tr><td><code id="D1_+3A_a">A</code></td>
<td>
<p>Numeric matrix of dimension NxN indicating the mass of the first N-checkerboad copula</p>
</td></tr>
<tr><td><code id="D1_+3A_b">B</code></td>
<td>
<p>Numeric matrix of dimension NxN indicating the mass of the second N-checkerboad copula</p>
</td></tr>
<tr><td><code id="D1_+3A_x">X</code></td>
<td>
<p>Numeric vector of values in the first coordinate</p>
</td></tr>
<tr><td><code id="D1_+3A_y">Y</code></td>
<td>
<p>Numeric vector of values in the second coordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>D1()</code> returns the D1 distance, introduced in (Trutschnig, 2011).
</p>
<p><code>D1.ECBC()</code> returns the D1-distance between to checkerboard copulas A and B with same resolution
</p>
<p><code>zeta1()</code> returns the directed dependence from x to y.
</p>


<h3>References</h3>

<p>Trutschnig, W. (2011). On a strong metric on the space of copulas and its induced dependence measure. Journal of Mathematical Analysis and Applications. 384 (2), 690-705.
</p>
<p>Junker, R.R., Griessenberger, F. and Trutschnig, W. (2021). Estimating scale-invariant directed dependence of bivariate distributions. Computational Statistics and Data Analysis, 153, 107058.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 100
x1 &lt;- runif(n)
y1 &lt;- x1
x2 &lt;- runif(n)
y2 &lt;- 1-x2
D1(x1,y1,x2,y2)

n &lt;- 1000
x &lt;- runif(n, 0, 1)
y1 &lt;- ifelse(x &lt; 0.5, runif(length(x &lt; 0.5), 0,0.5), runif(length(x &gt;= 0.5), 0.5, 1))
y2 &lt;- ifelse(x &gt; 0.5, runif(length(x &lt; 0.5), 0,0.5), runif(length(x &gt;= 0.5), 0.5, 1))
A &lt;- ECBC(x,y1, resolution = 50)
B &lt;- ECBC(x,y2, resolution = 50)
#plot_density(A)
#plot_density(B)
D1.ECBC(A,B)
</code></pre>

<hr>
<h2 id='ECBC'>Calculate empirical checkerboard copula</h2><span id='topic+ECBC'></span><span id='topic+ECBC.eval'></span>

<h3>Description</h3>

<p>The function <code>ECBC()</code> computes the mass distribution of the
empirical (checkerboard) copula, given a bi-variate sample.
If resolution equals sample size, the bi-linearly extended empirical copula is returned.
Note, if there are ties in the sample an adjusted empirical copula is calculated. The function
<code>ECBC.eval()</code> evaluates the checkerboard copula at given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECBC(X, Y, resolution = NULL)

ECBC.eval(CB, eval.points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECBC_+3A_x">X</code></td>
<td>
<p>Numeric vector of values in the first coordinate</p>
</td></tr>
<tr><td><code id="ECBC_+3A_y">Y</code></td>
<td>
<p>Numeric vector of values in the second coordinate</p>
</td></tr>
<tr><td><code id="ECBC_+3A_resolution">resolution</code></td>
<td>
<p>Integer indicating the resolution of the checkerboard aggregation, i.e.
the number of vertical/horizontal strips of the checkerboard copula. (default = NULL, sets resolution = floor(sqrt(sample size)))</p>
</td></tr>
<tr><td><code id="ECBC_+3A_cb">CB</code></td>
<td>
<p>A numeric mass matrix of a checkerboard copula (ECBC)</p>
</td></tr>
<tr><td><code id="ECBC_+3A_eval.points">eval.points</code></td>
<td>
<p>A numeric matrix or data.frame indicating the eval.points (x,y)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the observations are drawn from a continuous distribution (no ties in the sample),
the function <code>ECBC()</code> returns the commonly used empirical checkerboard copula.
If there are ties in the sample, the empirical copula is adjusted and calculated in the following way: <br />
Let (u_i,v_i) := (F_n(x_i),G_n(y_i)) be the pseudo-observations for i in {1,...,n} and (u_1',v_1'),..., (u_m',v_m') the distinct pairs of pseudo-observations with m leq n. Moreover set S_1:={0, u_1, ..., u_m_1} and S_2:={0, v_1,..., v_m_2} and define the quantities t_i,r_i and s_i for i=1,..., m by
</p>
<p style="text-align: center;"><code class="reqn">t_i := sum_{j=1}^n 1_{(u_i',v_i')}(u_j,v_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_i := sum_{j=1}^n 1_{u_i}(u_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">s_i := sum_{j=1}^n 1_{v_i}(v_j)</code>
</p>

<p>where 1 defines the indicator function.
Define the empirical subcopula A'_n: S_1 x S_2 to {0,1/n, ..., (n-1)/n,1} by
</p>
<p style="text-align: center;"><code class="reqn">A'_n(s_1,s_2)= 1/n  sum_{i=1}^m t_i * 1_{[0,s_1] x [0,s_2]} (u_i', v_i')=1/n sum_{i=1}^n 1_{[0,s_1] x [0,s_2]} (u_i, v_i)</code>
</p>

<p>for all s_1 in S_1 and s_2 in S_2. <br />
We extend the subcopula A'_n to a copula by defining the transformations w_i:[0,1]^2 to [u_i'-r_i/n,u_i'] x [v_i'-s_i/n,v_i'] by
</p>
<p style="text-align: center;"><code class="reqn">w_i(x,y)=(u_i'-r_i/n+r_i*x/n, v_i'-s_i/n + s_iy/n)</code>
</p>

<p>and set the measure of the empirical copula mu_A_n^B := 1/n sum_i=1^m t_i mu_B^w_i, where B denotes the product copula.
</p>


<h3>Value</h3>

<p><code>ECBC()</code> returns a matrix with the mass distribution of the empirical
(checkerboard) copula.
</p>


<h3>References</h3>

<p>Deheuvels, P. (1979). La fonction de dependance empirique et ses proprietas: un test non parametrique d'independance, Acad. Roy. Belg. Bull. Cl. Sci., 5th Ser. 65, 274-292.
</p>
<p>Li, X., Mikusinski, P. and Taylor, M.D. (1998). Strong approximation of copulas, Journal of Mathematical Analysis and Applications, 255, 608-623.
</p>
<p>Genest, C., Neshlehova J.G. and Remillard, B. (2014). On the empirical multilinear copula process for count data. Bernoulli, 20 (3), 1344-1371.
</p>
<p>Junker, R.R., Griessenberger, F. and Trutschnig, W. (2021). Estimating scale-invariant directed dependence of bivariate distributions. Computational Statistics and Data Analysis, 153, 107058.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate data drawn from the product copula and compute the empirical (checkerboard) copula
n &lt;- 100
x &lt;- runif(n, 0, 1)
y &lt;- runif(n, 0, 1)
mass &lt;- ECBC(x,y, resolution = 10)
plot_density(mass)
mass &lt;- ECBC(x,y, resolution = n)
plot_density(mass)

## Compute empirical checkerboard copula of a sample with ties and plot density
n &lt;- 100
x &lt;- sample(runif(n, -1, 1), n, replace=TRUE)
y &lt;- x^2 + rnorm(n, 0, 1)
mass &lt;- ECBC(x,y)
plot_density(mass)
</code></pre>

<hr>
<h2 id='emp_c_copula'>The empirical checkerboard copula</h2><span id='topic+emp_c_copula'></span><span id='topic+emp_c_copula_eval'></span>

<h3>Description</h3>

<p>The function <code>emp_c_copula()</code> computes the mass distribution of the
empirical (checkerboard) copula, given a bivariate sample. <code>emp_c_copula_eval()</code> evaluates the
the empirical (checkerboard) copula at given points.
If <code>smoothing</code> = FALSE, the empirical copula is computed (if there are ties in the sample an adjusted empirical copula is computed),
otherwise the empirical checkerboard copula - a smoothed version of the empirical copula - is computed. For more information of the calculations, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp_c_copula(X, smoothing = TRUE, resolution)

emp_c_copula_eval(X, u, smoothing = TRUE, resolution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp_c_copula_+3A_x">X</code></td>
<td>
<p>a data frame with two columns containing the observations of the sample. Each row contains
one observation.</p>
</td></tr>
<tr><td><code id="emp_c_copula_+3A_smoothing">smoothing</code></td>
<td>
<p>a logial indicating whether the checkerboard aggregation is computed (default = TRUE).</p>
</td></tr>
<tr><td><code id="emp_c_copula_+3A_resolution">resolution</code></td>
<td>
<p>an integer indicating the resolution of the checkerboard aggregation, i.e.
the number of vertical/horizontal strips of the checkerboard copula.</p>
</td></tr>
<tr><td><code id="emp_c_copula_+3A_u">u</code></td>
<td>
<p>a data.frame with two columns containing the evaluation points. Each row consists of a x and y value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the observations come from a distribution with continuous margins,
i.e. there are no ties in the sample, the function <code>emp_c_copula()</code> gives the same result
as the function <code>C.n()</code> in the <code>copula</code> package.
If there are ties in the sample, the empirical copula is adjusted and calculated in the following way: <br />
Let (u_i,v_i) := (F_n(x_i),G_n(y_i)) be the pseudo-observations for i in {1,...,n} and (u_1',v_1'),..., (u_m',v_m') the distinct pairs of pseudo-observations with m leq n. Moreover set S_1:={0, u_1, ..., u_m_1} and S_2:={0, v_1,..., v_m_2} and define the quantities t_i,r_i and s_i for i=1,..., m by
</p>
<p style="text-align: center;"><code class="reqn">t_i := sum_{j=1}^n 1_{(u_i',v_i')}(u_j,v_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">r_i := sum_{j=1}^n 1_{u_i}(u_j)</code>
</p>

<p style="text-align: center;"><code class="reqn">s_i := sum_{j=1}^n 1_{v_i}(v_j)</code>
</p>

<p>where 1 defines the indicator function.
Define the empirical subcopula A'_n: S_1 x S_2 to {0,1/n, ..., (n-1)/n,1} by
</p>
<p style="text-align: center;"><code class="reqn">A'_n(s_1,s_2)= 1/n  sum_{i=1}^m t_i * 1_{[0,s_1] x [0,s_2]} (u_i', v_i')=1/n sum_{i=1}^n 1_{[0,s_1] x [0,s_2]} (u_i, v_i)</code>
</p>

<p>for all s_1 in S_1 and s_2 in S_2. <br />
We extend the subcopula A'_n to a copula by defining the transformations w_i:[0,1]^2 to [u_i'-r_i/n,u_i'] x [v_i'-s_i/n,v_i'] by
</p>
<p style="text-align: center;"><code class="reqn">w_i(x,y)=(u_i'-r_i/n+r_i*x/n, v_i'-s_i/n + s_iy/n)</code>
</p>

<p>and set the measure of the empirical copula mu_A_n^B := 1/n sum_i=1^m t_i mu_B^w_i, where B denotes the product copula.
</p>
<p>The checkerboard aggregation is computed as usual (see references).
</p>


<h3>Value</h3>

<p><code>emp_c_copula()</code> returns a matrix with the mass distribution of the empirical
(checkerboard) copula.
</p>
<p><code>emp_c_copula_eval()</code> returns a vector of evaluations of the empirical
(checkerboard) copula.
</p>


<h3>Note</h3>

<p>The calculation of the empirical copula with a high sample size (and resolution rate) can take time.
</p>


<h3>References</h3>

<p>Deheuvels, P. (1979). La fonction de dependance empirique et ses proprietas: un test non parametrique d'independance, Acad. Roy. Belg. Bull. Cl. Sci., 5th Ser. 65, 274-292.
</p>
<p>Li, X., Mikusinski, P. and Taylor, M.D. (1998). Strong approximation of copulas, Journal of Mathematical Analysis and Applications, 255, 608-623.
</p>
<p>Genest, C., Neshlehova J.G. and Remillard, B. (2014). On the empirical multilinear copula process for count data. Bernoulli, 20 (3), 1344-1371.
</p>

<hr>
<h2 id='heatmap.qad'>Heatmap of dependence measures</h2><span id='topic+heatmap.qad'></span>

<h3>Description</h3>

<p>The pairwise computed dependence measures (output of the function <code>pairwise.qad()</code>) are illustrated by a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap.qad(
  pw_qad,
  select = c("dependence", "max.dependence", "asymmetry"),
  fontsize = 4,
  significance = FALSE,
  use_p.adjust = TRUE,
  sign.level = 0.05,
  scale = "abs",
  color = "plasma",
  white_font = 0.7,
  rb_values = c(10, 0.315, 0.15),
  title = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap.qad_+3A_pw_qad">pw_qad</code></td>
<td>
<p>output of the function <code>pairwise.qad</code>().</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_select">select</code></td>
<td>
<p>a character indicating which dependence value is plotted.
Options are c(&quot;dependence&quot;, &quot;max.dependence&quot;, &quot;asymmetry&quot;).</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_fontsize">fontsize</code></td>
<td>
<p>a numeric specifying the font size of the values.</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_significance">significance</code></td>
<td>
<p>a logical indicating whether significant values with respect to the (adjusted) qad p.values are denoted by a star.</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_use_p.adjust">use_p.adjust</code></td>
<td>
<p>a logical indicating if the adjusted p.values are used (default = TRUE).</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_sign.level">sign.level</code></td>
<td>
<p>numeric value indicating the significance level.</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_scale">scale</code></td>
<td>
<p>character indicating whether the heatmap uses a relative or absolute scale. Options are 'rel' or 'abs' (default).</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_color">color</code></td>
<td>
<p>Select the color palette. Options are c(&quot;plasma&quot; (default), &quot;viridis&quot;, &quot;inferno&quot;, &quot;magma&quot;, &quot;cividis&quot;, &quot;rainbow&quot;).</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_white_font">white_font</code></td>
<td>
<p>numeric between 0 and 1 denoting the start value for white text font (default = 0.7)</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_rb_values">rb_values</code></td>
<td>
<p>a vector of size 3 with number of values, start value and end value in the rainbow colors space (if color = 'rainbow').</p>
</td></tr>
<tr><td><code id="heatmap.qad_+3A_title">title</code></td>
<td>
<p>The text for the title</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the output of <code>pairwise.qad</code>() contains p-values, significant values can be highlighted by stars by setting significance=TRUE.
</p>


<h3>Value</h3>

<p>a heatmap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x1 &lt;- runif(n, 0, 1)
x2 &lt;- x1^2 + rnorm(n, 0, 0.1)
x3 &lt;- runif(n, 0, 1)
x4 &lt;- x3 - x2 + rnorm(n, 0, 0.1)
sample_df &lt;- data.frame(x1,x2,x3,x4)
#Fit qad
model &lt;- pairwise.qad(sample_df, p.value = FALSE)
heatmap.qad(model, select = "dependence", fontsize = 6)
</code></pre>

<hr>
<h2 id='pairwise.qad'>Pairwise quantification of (asymmetric and directed) dependencies</h2><span id='topic+pairwise.qad'></span>

<h3>Description</h3>

<p>Pairwise computation of the function <code>qad</code>(). <code>qad</code>() is applied on each pair of variables of a numeric data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.qad(
  data_df,
  remove.00 = FALSE,
  min.res = 3,
  p.value = TRUE,
  nperm = 1000,
  p.adjust.method = "fdr",
  p.value_asymmetry = FALSE,
  nboot = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.qad_+3A_data_df">data_df</code></td>
<td>
<p>a data frame containing numeric columns with the observations of the sample.</p>
</td></tr>
<tr><td><code id="pairwise.qad_+3A_remove.00">remove.00</code></td>
<td>
<p>a logical indicating whether double 0 entries should be excluded (default = FALSE)</p>
</td></tr>
<tr><td><code id="pairwise.qad_+3A_min.res">min.res</code></td>
<td>
<p>an integer indicating the necessary minimum resolution of the checkerboard grid to compute qad, otherwise the result is NA (default = 3).</p>
</td></tr>
<tr><td><code id="pairwise.qad_+3A_p.value">p.value</code></td>
<td>
<p>a logical indicating whether to return a p-value of rejecting independence (based on permutation).</p>
</td></tr>
<tr><td><code id="pairwise.qad_+3A_nperm">nperm</code></td>
<td>
<p>an integer indicating the number of permutation runs.</p>
</td></tr>
<tr><td><code id="pairwise.qad_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>a character string denoting the p.value correction method (see function p.adjust in stats). Options are c('holm', 'hochberg', 'hommel', 'bonferroni', 'BH', 'BY', 'fdr' (default), 'none')</p>
</td></tr>
<tr><td><code id="pairwise.qad_+3A_p.value_asymmetry">p.value_asymmetry</code></td>
<td>
<p>a logical indicating whether a p-value (based on bootstrap) is computed for the measure of asymmetry.</p>
</td></tr>
<tr><td><code id="pairwise.qad_+3A_nboot">nboot</code></td>
<td>
<p>an integer indicating the number of bootstrapping runs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, containing data.frames with the dependence measures, corresponding p.values, the resolution of the checkerboard aggregation and the number of removed double zero entries (only if remove.00 = TRUE).
The output of pairwise.qad() can be illustrated using the function <code>heatmap.qad()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x1 &lt;- runif(n, 0, 1)
x2 &lt;- x1^2 + rnorm(n, 0, 0.1)
x3 &lt;- runif(n, 0, 1)
x4 &lt;- x3 - x2 + rnorm(n, 0, 0.1)
sample_df &lt;- data.frame(x1,x2,x3,x4)
#Fit qad
model &lt;- pairwise.qad(sample_df, p.value = TRUE, p.adjust.method = "fdr")
heatmap.qad(model, select = "dependence", fontsize = 6)
</code></pre>

<hr>
<h2 id='PlantDiversity'>Plant diversity</h2><span id='topic+PlantDiversity'></span>

<h3>Description</h3>

<p>A dataset containing 140 plots with estimated year of deglaciation and plant Shannon diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlantDiversity
</code></pre>


<h3>Format</h3>

<p>A data frame with 140 rows and 2 variables:
</p>

<dl>
<dt>deglacYear</dt><dd><p>estimated year of deglaciation</p>
</dd>
<dt>div</dt><dd><p>Shannon diversity of plant ecology</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set contains the estimated year of deglaciation and plant diversity of 140 plots along the successional gradient of the forefield of the Ödenwinkelkees glacier (Austria).
The plots (1 to 135) were established within the glacier forefield, the plots (136 to 140) were established outside the glacier forefield (i.e., age greater than 170 years).
Since qad is invariant w.r.t. transformations the estimated year of these 5 plots is set to 1800.
</p>
<p>#' @source <a href="https://doi.org/10.5194/we-20-95-2020">doi:10.5194/we-20-95-2020</a>
</p>

<hr>
<h2 id='plot_density'>Plot density of empirical checkerboard copula</h2><span id='topic+plot_density'></span>

<h3>Description</h3>

<p>Plots the density/mass of the empirical checkerboard copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_density(
  mass_matrix,
  density = TRUE,
  color = "plasma",
  rb_values = c(10, 0.315, 0.15)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_density_+3A_mass_matrix">mass_matrix</code></td>
<td>
<p>a squared matrix containing the mass distribution, e.g. output of the function <code>emp_c_copula()</code>.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_density">density</code></td>
<td>
<p>a logical (TRUE = default) whether the density or the mass is plotted.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_color">color</code></td>
<td>
<p>Select the color palette. Options are c(&quot;plasma&quot; (default), &quot;viridis&quot;, &quot;inferno&quot;, &quot;magma&quot;, &quot;cividis&quot;).</p>
</td></tr>
<tr><td><code id="plot_density_+3A_rb_values">rb_values</code></td>
<td>
<p>a vector of size 3 with number of values, start value and end value in the rainbow colors space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a density plot (or mass distribution)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
x &lt;- runif(n,0,1)
y &lt;- runif(n,0,1)
plot(x,y,pch = 16)

mass &lt;- ECBC(x,y,resolution = 10)
plot_density(mass, density=TRUE)
plot_density(mass, density=FALSE)
</code></pre>

<hr>
<h2 id='plot.qad'>Plot conditional probabilites</h2><span id='topic+plot.qad'></span>

<h3>Description</h3>

<p>Visualizes the conditional probabilities for each strip of the checkerboard copula in the copula setting or in the retransformed sample setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qad'
plot(
  x,
  addSample = FALSE,
  copula = FALSE,
  density = FALSE,
  margins = FALSE,
  title = "",
  x.axis = "X1",
  y.axis = "X2",
  point.size = 0.9,
  panel.grid = TRUE,
  color = "plasma",
  rb_values = c(10, 0.315, 0.15),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qad_+3A_x">x</code></td>
<td>
<p>an object of class qad.</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_addsample">addSample</code></td>
<td>
<p>a logical indicating whether the observations are returned. In the copula setting the mass squares of the empirical copula are added too. (default = FALSE).</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_copula">copula</code></td>
<td>
<p>a logical indicating whether the plot depicts the conditional probabilities
of the empirical checkerboard copula or of the retransformed data setting (default = FALSE).</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_density">density</code></td>
<td>
<p>a logical indicating whether the density should be plotted instead of the conditional probabilites (default = FALSE).
Only works in the copula setting, i.e. if copula = TRUE.</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_margins">margins</code></td>
<td>
<p>a logical indicating whether the margin distribution is added in form of a rug plot.</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_title">title</code></td>
<td>
<p>The text for the title</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_x.axis">x.axis</code></td>
<td>
<p>The text for the x-axis</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_y.axis">y.axis</code></td>
<td>
<p>The text for the y-axis</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_point.size">point.size</code></td>
<td>
<p>a numeric specifying the point size of the sample (relevant if addSample = TRUE).</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_panel.grid">panel.grid</code></td>
<td>
<p>a logical indicating whether the panel grid is plotted. (default = TRUE)</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_color">color</code></td>
<td>
<p>a color palette of the viridis package or rainbow. options are c(&quot;viridis&quot;, &quot;magma&quot;, &quot;inferno&quot;, &quot;plasma&quot;, &quot;cividis&quot;, &quot;rainbow&quot;)</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_rb_values">rb_values</code></td>
<td>
<p>a vector of size 3 with number of values, start value and end value in the rainbow colors space.</p>
</td></tr>
<tr><td><code id="plot.qad_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The conditional probabilities are constant at squares in the copula setting. If the squares are retransformed in the data setting, the resulting objects are rectangles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
n &lt;- 100
x &lt;- runif(n, 0, 1)
y &lt;- runif(n, 0, 1)
sample &lt;- data.frame(x, y)

#qad
fit &lt;- qad(sample)
plot(fit, addSample = TRUE, copula = FALSE)

## Example 2
n &lt;- 100
x &lt;- runif(n, -1, 1)
y &lt;- x^2 + rnorm(n, 0, 0.1)
sample &lt;- data.frame(x, y)

#qad
fit &lt;- qad(sample)
plot(fit, addSample = TRUE, copula = TRUE)
plot(fit, addSample = TRUE, copula = FALSE)

</code></pre>

<hr>
<h2 id='predict.qad'>Predict conditional probabilities</h2><span id='topic+predict.qad'></span>

<h3>Description</h3>

<p>The function <code>predict.qad()</code> can be utilized to predict the probabilities of the event that Y lies in
specific intervals given X=x, or vice versa. Thereby, the intervals are calculated as retransformed intervals (by using the empirical quantil function) defining the checkerboard grid. Additionally, the mass of the conditional distribution functions are plotted.
The prediction can be computed in the sample setting as well as in the copula setting (pseudo-observation in the unit square).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qad'
predict(
  object,
  values,
  conditioned = "x1",
  nr_intervals = NULL,
  prediction_interval = NULL,
  copula = FALSE,
  pred_plot = FALSE,
  panel.grid = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.qad_+3A_object">object</code></td>
<td>
<p>an object of class 'qad', which determines the underlying checkerboard aggregation.</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_values">values</code></td>
<td>
<p>a vector containing the x or the y values for which the conditional probabilities should be predicted.</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_conditioned">conditioned</code></td>
<td>
<p>a character specifying on which variable is conditioned. Options are &quot;x1&quot; (default) or &quot;x2&quot;.</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_nr_intervals">nr_intervals</code></td>
<td>
<p>an integer, which determines a different number of intervals for the prediction (only possible in the copula setting).</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_prediction_interval">prediction_interval</code></td>
<td>
<p>a vector specifying the interval boundaries for which the conditional probability is computed. Options are NULL (default) to predict the conditional probabilities for all intervals or a vector c(lower boundary, upper boundary) indicating the boundaries.</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_copula">copula</code></td>
<td>
<p>a logical (default = FALSE) determining whether the empirical checkerboard copula is used or the retransformed data.</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_pred_plot">pred_plot</code></td>
<td>
<p>a logical indicating if the conditional probabilities are plotted.</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_panel.grid">panel.grid</code></td>
<td>
<p>a logical indicating whether the panel.grid is plotted.</p>
</td></tr>
<tr><td><code id="predict.qad_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a data.frame with the computed intervals (lower and upper boundaries) and the prediction probabilities (i.e., the probability that Y lies in the interval Ii given X = x).
Furthermore, a heatmap depicting the mass of the conditional distribution functions is returned.
</p>


<h3>Note</h3>

<p>Predictions are only possible for values within the range of the sample (or between 0 and 1 in the copula setting). For given values exceeding the range NA is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 100
x &lt;- runif(n, -4 ,4)
y &lt;- x^2 + rnorm(n, 0, 1)
sample &lt;- data.frame(x, y)

##(Not Run)
qad.fit &lt;- qad(sample)
predict.qad(qad.fit, values = c(-2,0.6), conditioned = "x1", pred_plot = TRUE)
predict.qad(qad.fit, values = c(1,9), conditioned = "x2", pred_plot = TRUE)
predict.qad(qad.fit, values = c(-2,0.6), conditioned = "x1", pred_plot = FALSE,
        nr_intervals = 4)
predict.qad(qad.fit, values = c(-2,0.6), conditioned = "x1", pred_plot = FALSE,
            prediction_interval = c(4,6))
predict.qad(qad.fit, values = c(4,0.6), conditioned = "x2", pred_plot = FALSE,
            prediction_interval = c(2,3))

qad.pred &lt;- predict.qad(qad.fit, values = c(-2,0.6), conditioned = "x1", pred_plot = FALSE)
qad.pred$prediction
qad.pred$plot


</code></pre>

<hr>
<h2 id='qad'>Measure of (asymmetric and directed) dependence</h2><span id='topic+qad'></span><span id='topic+qad.data.frame'></span><span id='topic+qad.numeric'></span>

<h3>Description</h3>

<p>Quantification of (asymmetric and directed) dependence structures between two random variables X and Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qad(x, ...)

## S3 method for class 'data.frame'
qad(
  x,
  resolution = NULL,
  p.value = TRUE,
  nperm = 1000,
  p.value_asymmetry = FALSE,
  nboot = 1000,
  print = TRUE,
  remove.00 = FALSE,
  ...
)

## S3 method for class 'numeric'
qad(
  x,
  y,
  resolution = NULL,
  p.value = TRUE,
  nperm = 1000,
  p.value_asymmetry = FALSE,
  nboot = 1000,
  print = TRUE,
  remove.00 = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qad_+3A_x">x</code></td>
<td>
<p>a data.frame containing two columns with the observations of the bi-variate sample or a (non-empty) numeric vector of data values</p>
</td></tr>
<tr><td><code id="qad_+3A_...">...</code></td>
<td>
<p>Further arguments passed to 'qad' will be ignored</p>
</td></tr>
<tr><td><code id="qad_+3A_resolution">resolution</code></td>
<td>
<p>an integer indicating the number of strips for the checkerboard aggregation (see <a href="#topic+ECBC">ECBC</a>). We recommend to use the default value (resolution = NULL)</p>
</td></tr>
<tr><td><code id="qad_+3A_p.value">p.value</code></td>
<td>
<p>a logical indicating whether to return a p-value of rejecting independence (based on permutation).</p>
</td></tr>
<tr><td><code id="qad_+3A_nperm">nperm</code></td>
<td>
<p>an integer indicating the number of permutation runs (if p.value = TRUE)</p>
</td></tr>
<tr><td><code id="qad_+3A_p.value_asymmetry">p.value_asymmetry</code></td>
<td>
<p>a logical indicating whether to return a (heuristic) p-value for the measure of asymmetry (based on bootstrap).</p>
</td></tr>
<tr><td><code id="qad_+3A_nboot">nboot</code></td>
<td>
<p>an integer indicating the number of runs for the bootstrap.</p>
</td></tr>
<tr><td><code id="qad_+3A_print">print</code></td>
<td>
<p>a logical indicating whether the result of qad is printed.</p>
</td></tr>
<tr><td><code id="qad_+3A_remove.00">remove.00</code></td>
<td>
<p>a logical indicating whether double 0 entries should be excluded (default = FALSE)</p>
</td></tr>
<tr><td><code id="qad_+3A_y">y</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>qad is the implementation of a strongly consistent estimator of the copula based dependence measure zeta_1 introduced in Trutschnig 2011.
We first compute the empirical copula of a two-dimensional sample, aggregate it to the so called empirical checkerboard copula (ECBC), and
calculate zeta_1 of the ECBC and its transpose. In order to test for independence (in both directions), a built-in p-value
is implemented (a permutation test with nperm permutation runs to estimate the p-value).
Furthermore, a (heuristic) bootstrap test with nboot runs can be applied to estimate a p-value for the measure of asymmetry a.
</p>


<h3>Value</h3>

<p>qad returns an object of class qad containing the following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> a data.frame containing the input data.</p>
</td></tr>
<tr><td><code>q(X</code>, <code>Y)</code></td>
<td>
<p>influence of X on Y</p>
</td></tr>
<tr><td><code>q(Y</code>, <code>X)</code></td>
<td>
<p>influence of Y on X</p>
</td></tr>
<tr><td><code>max.dependence</code></td>
<td>
<p>maximal dependence</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p> a data.frame containing the results of the dependence measures.</p>
</td></tr>
<tr><td><code>mass_matrix</code></td>
<td>
<p> a matrix containing the mass distribution of the empirical checkerboard copula.</p>
</td></tr>
<tr><td><code>resolution</code></td>
<td>
<p>an integer containing the used resolution of the checkerboard aggregation.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Trutschnig, W. (2011). On a strong metric on the space of copulas and its induced dependence measure, Journal of Mathematical Analysis and Applications 384, 690-705.
</p>
<p>Junker, R., Griessenberger, F. and Trutschnig, W. (2021). Estimating scale-invariant directed dependence of bivariate distributions.  Computational Statistics and Data Analysis, 153.
</p>


<h3>See Also</h3>

<p>A tutorial can be found at <a href="http://www.trutschnig.net/software.html">http://www.trutschnig.net/software.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1 (independence)

n &lt;- 100
x &lt;- runif(n,0,1)
y &lt;- runif(n,0,1)
sample &lt;- data.frame(x,y)
qad(sample)

###

#Example 2 (mutual complete dependence)

n &lt;- 500
x &lt;- runif(n,0,1)
y &lt;- x^2
sample &lt;- data.frame(x,y)
qad(sample)

#Example 3 (complete dependence)

n &lt;- 1000
x &lt;- runif(n,-10,10)
y &lt;- sin(x)
sample &lt;- data.frame(x,y)
qad(sample)

#Example 4 (Asymmetry)

n &lt;- 100
x &lt;- runif(n,0,1)
y &lt;- (2*x) %% 1
qad(x, y)
</code></pre>

<hr>
<h2 id='qad_distribution'>Distribution of qad (H0: independence)</h2><span id='topic+qad_distribution'></span><span id='topic+pqad'></span><span id='topic+qqad'></span>

<h3>Description</h3>

<p>Distribution function - P_H0(qad &lt;= q) - and quantile function for the qad distribution with regard
to the null hypthesis (H0) stating independence between X and Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pqad(q, n, R = 1000, resolution = NULL)

qqad(p, n, R = 1000, resolution = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qad_distribution_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="qad_distribution_+3A_n">n</code></td>
<td>
<p>number of observations (or minimum of unique values, if ties occur).</p>
</td></tr>
<tr><td><code id="qad_distribution_+3A_r">R</code></td>
<td>
<p>number of repetitions (default R = 1000)</p>
</td></tr>
<tr><td><code id="qad_distribution_+3A_resolution">resolution</code></td>
<td>
<p>resolution of checkerboard copula (default  = NULL)</p>
</td></tr>
<tr><td><code id="qad_distribution_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution of qad in the setting of independence, i.e., the random variables
X and Y are independent. The distribution is calculated in the following way: Samples of size n
are drawn from independent random variables. Then qad is calculated. The procedure is repeated R times. #'
</p>


<h3>Value</h3>

<p><code>pqad</code> gives the distribution function, i.e. P(qad &lt;= q). <code>qqad</code> gives the quantile function.
The length of the result is determined by the length of q or p, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pqad(0.3, 45)
qqad(0.5, 30)
</code></pre>

<hr>
<h2 id='qad-package'>
Quantification of Asymmetric Dependencies
</h2><span id='topic+qad-package'></span>

<h3>Description</h3>

<p>A copula-based measure for quantifying asymmetry in dependence and associations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qad</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-02-26</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Florian Griessenberger: <a href="mailto:florian.griessenberger@sbg.ac.at">florian.griessenberger@sbg.ac.at</a>,<br />
Robert R. Junker: <a href="mailto:Robert.Junker@sbg.ac.at">Robert.Junker@sbg.ac.at</a>,<br />
Valentin Petztel,<br />
Wolfgang Trutschnig: <a href="mailto:Wolfgang.Trutschnig@sbg.ac.at">Wolfgang.Trutschnig@sbg.ac.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># #Create data set
# n &lt;- 100
# x &lt;- rnorm(n,0,2)
# y &lt;- x^2 + rnorm(n)
# sample &lt;- data.frame(x,y)
# plot(sample, pch = 16)
#
#
# #Function: qad()
# qad(sample, p.value = TRUE, p.value_asymmetry = TRUE)
# fit &lt;- qad(sample)
# plot(fit)
# plot(fit, copula = TRUE)
# plot(fit, copula = TRUE, addSample = T)
#
# #Functions: summary(), coef()
# summary(fit)
# coef(fit)
#
# #Function: predict()
# values &lt;- c(-2.4,1,0,2.6)
# predict.qad(fit, values = values, conditioned = 'x1')
# predict(fit, values, conditioned = "x1", pred_plot = TRUE, panel.grid = FALSE)
#
# values &lt;- c(0.1,0.5)
# predict(fit, values, conditioned = "x2", copula = TRUE, pred_plot = TRUE)
#
# #Function: pairwise.qad and heatmap.qad
# df &lt;- iris[1:4]
# mod &lt;- pairwise.qad(df)
# heatmap.qad(mod, select = 'dependence')
</code></pre>

<hr>
<h2 id='summary.qad'>Summarize a qad object</h2><span id='topic+summary.qad'></span><span id='topic+coef.qad'></span>

<h3>Description</h3>

<p>Summary and coefficients of a <code>qad</code> output. The function
<code>summary()</code> prints the dependence measures, sample size and resolution of
the checkerboard copula and returns a list with the mentioned values.
The function <code>coef()</code> returns a named vector with the selected values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qad'
summary(object, ...)

## S3 method for class 'qad'
coef(
  object,
  select = c("q(x1,x2)", "q(x2,x1)", "max.dependence", "asymmetry", "p.q(x1,x2)",
    "p.q(x2,x1)", "p.max.dependence", "p.asymmetry"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.qad_+3A_object">object</code></td>
<td>
<p>an object of class 'qad'</p>
</td></tr>
<tr><td><code id="summary.qad_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional arguments. None are used in this method.</p>
</td></tr>
<tr><td><code id="summary.qad_+3A_select">select</code></td>
<td>
<p>a vector of strings indicating which dependence measure should be returned. Options are c('q(x1,x2)', 'q(x2,x1)', 'max.dependence', 'asymmetry')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object containing the calculated values of a <code>qad</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x &lt;- runif(n, 0, 1)
y &lt;- x^2 + rnorm(n, 0, 0.1)
sample &lt;- data.frame(x, y)
##(Not Run)
fit &lt;- qad(sample)
summary(fit)
coef(fit)
coef(fit, select = c('q(x1,x2)','p.q(x1,x2)'))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
