<!DOCTYPE html><html><head><title>Help for package matchmaker</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matchmaker}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#match_df'><p>Check and clean spelling or codes of multiple variables in a data frame</p></a></li>
<li><a href='#match_vec'><p>Rename values in a vector based on a dictionary</p></a></li>
<li><a href='#matchmaker_example'><p>show the path to a matchmaker example file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Flexible Dictionary-Based Cleaning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides flexible dictionary-based
    cleaning that allows users to specify implicit and explicit missing data,
    regular expressions for both data and columns, and global matches, while
    respecting ordering of factors. This package is part of the 'RECON'
    (<a href="https://www.repidemicsconsortium.org/">https://www.repidemicsconsortium.org/</a>) toolkit for outbreak analysis.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.repidemicsconsortium.org/matchmaker">https://www.repidemicsconsortium.org/matchmaker</a>,
<a href="https://github.com/reconhub/matchmaker">https://github.com/reconhub/matchmaker</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, forcats, cli</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-21 18:12:33 UTC; zhian</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Thibaut Jombart [ctb],
  Patrick Barks [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhian N. Kamvar &lt;zkamvar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-21 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='match_df'>Check and clean spelling or codes of multiple variables in a data frame</h2><span id='topic+match_df'></span>

<h3>Description</h3>

<p>This function allows you to clean your data according to
pre-defined rules encapsulated in either a data frame or list of data frames.
It has application for addressing mis-spellings and recoding variables (e.g.
from electronic survey data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_df(
  x = data.frame(),
  dictionary = list(),
  from = 1,
  to = 2,
  by = 3,
  order = NULL,
  warn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_df_+3A_x">x</code></td>
<td>
<p>a character or factor vector</p>
</td></tr>
<tr><td><code id="match_df_+3A_dictionary">dictionary</code></td>
<td>
<p>a data frame or named list of data frames with at least two
columns defining the word list to be used. If this is a data frame, a third
column must be present to split the dictionary by column in <code>x</code> (see
<code>by</code>).</p>
</td></tr>
<tr><td><code id="match_df_+3A_from">from</code></td>
<td>
<p>a column name or position defining words or keys to be replaced</p>
</td></tr>
<tr><td><code id="match_df_+3A_to">to</code></td>
<td>
<p>a column name or position defining replacement values</p>
</td></tr>
<tr><td><code id="match_df_+3A_by">by</code></td>
<td>
<p>character or integer. If <code>dictionary</code> is a data frame,
then this column in defines the columns in <code>x</code> corresponding to each
section of the <code>dictionary</code> data frame. This defaults to <code>3</code>, indicating the
third column is to be used.</p>
</td></tr>
<tr><td><code id="match_df_+3A_order">order</code></td>
<td>
<p>a character the column to be used for sorting the values in
each data frame. If the incoming variables are factors, this determines how
the resulting factors will be sorted.</p>
</td></tr>
<tr><td><code id="match_df_+3A_warn">warn</code></td>
<td>
<p>if <code>TRUE</code>, warnings and errors from <code><a href="#topic+match_vec">match_vec()</a></code> will be
shown as a single warning. Defaults to <code>FALSE</code>, which shows nothing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this applies the function <code><a href="#topic+match_vec">match_vec()</a></code> to all
columns specified by the column names listed in <code>by</code>, or, if a
global dictionary is used, this includes all <code>character</code> and <code>factor</code>
columns as well.
</p>


<h4><code>by</code> column</h4>

<p>Spelling variables within <code>dictionary</code> represent keys that you want to match
to column names in <code>x</code> (the data set). These are expected to match exactly
with the exception of two reserved keywords that starts with a full stop:
</p>

<ul>
<li> <p><code>.regex [pattern]</code>: any column whose name is matched by <code style="white-space: pre;">&#8288;[pattern]&#8288;</code>. The
<code style="white-space: pre;">&#8288;[pattern]&#8288;</code> should be an unquoted, valid, PERL-flavored regular expression.
</p>
</li>
<li> <p><code>.global</code>: any column (see Section <em>Global dictionary</em>)
</p>
</li></ul>




<h4>Global dictionary</h4>

<p>A global dictionary is a set of definitions applied to all valid columns of
<code>x</code> indiscriminantly.
</p>

<ul>
<li> <p><strong>.global keyword in <code>by</code></strong>: If you want to apply a set of definitions to
all valid columns in addition to specified columns, then you can include a
<code>.global</code> group in the <code>by</code> column of your <code>dictionary</code> data frame. This is
useful for setting up a dictionary of common spelling errors. <em>NOTE:
specific variable definitions will override global defintions.</em> For
example: if you have a column for cardinal directions and a definiton for
<code>N = North</code>, then the global variable <code>N = no</code> will not override that. See
Example.
</p>
</li>
<li> <p><strong><code>by = NULL</code></strong>: If you want your data frame to be applied to
all character/factor columns indiscriminantly, then setting
<code>by = NULL</code> will use that dictionary globally.
</p>
</li></ul>




<h3>Value</h3>

<p>a data frame with re-defined data based on the dictionary
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>
<p>Patrick Barks
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_vec">match_vec()</a></code>, which this function wraps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read in dictionary and coded date examples --------------------

dict &lt;- read.csv(matchmaker_example("spelling-dictionary.csv"),
  stringsAsFactors = FALSE)
dat &lt;- read.csv(matchmaker_example("coded-data.csv"),
  stringsAsFactors = FALSE)
dat$date &lt;- as.Date(dat$date)

# Clean spelling based on dictionary -----------------------------

dict # show the dict
head(dat) # show the data

res1 &lt;- match_df(dat,
  dictionary = dict,
  from = "options",
  to = "values",
  by = "grp")
head(res1)

# Show warnings/errors from each column --------------------------
# Internally, the `match_vec()` function can be quite noisy with warnings for
# various reasons. Thus, by default, the `match_df()` function will keep
# these quiet, but you can have them printed to your console if you use the
# warn = TRUE option:

res1 &lt;- match_df(dat,
  dictionary = dict,
  from = "options",
  to = "values",
  by = "grp",
  warn = TRUE)
head(res1)


# You can ensure the order of the factors are correct by specifying
# a column that defines order.

dat[] &lt;- lapply(dat, as.factor)
as.list(head(dat))
res2 &lt;- match_df(dat,
  dictionary = dict,
  from = "options",
  to = "values",
  by = "grp",
  order = "orders")
head(res2)
as.list(head(res2))
</code></pre>

<hr>
<h2 id='match_vec'>Rename values in a vector based on a dictionary</h2><span id='topic+match_vec'></span>

<h3>Description</h3>

<p>This function provides an interface for <code><a href="forcats.html#topic+fct_recode">forcats::fct_recode()</a></code>,
<code><a href="forcats.html#topic+fct_explicit_na">forcats::fct_explicit_na()</a></code>, and <code><a href="forcats.html#topic+fct_relevel">forcats::fct_relevel()</a></code> in such a way that
a data dictionary can be imported from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_vec(
  x = character(),
  dictionary = data.frame(),
  from = 1,
  to = 2,
  quiet = FALSE,
  warn_default = TRUE,
  anchor_regex = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_vec_+3A_x">x</code></td>
<td>
<p>a character or factor vector</p>
</td></tr>
<tr><td><code id="match_vec_+3A_dictionary">dictionary</code></td>
<td>
<p>a matrix or data frame defining mis-spelled words or keys
in one column (<code>from</code>) and replacement values (<code>to</code>) in another
column. There are keywords that can be appended to the <code>from</code> column for
addressing default values and missing data.</p>
</td></tr>
<tr><td><code id="match_vec_+3A_from">from</code></td>
<td>
<p>a column name or position defining words or keys to be replaced</p>
</td></tr>
<tr><td><code id="match_vec_+3A_to">to</code></td>
<td>
<p>a column name or position defining replacement values</p>
</td></tr>
<tr><td><code id="match_vec_+3A_quiet">quiet</code></td>
<td>
<p>a <code>logical</code> indicating if warnings should be issued if no
replacement is made; if <code>FALSE</code>, these warnings will be disabled</p>
</td></tr>
<tr><td><code id="match_vec_+3A_warn_default">warn_default</code></td>
<td>
<p>a <code>logical</code>. When a <code>.default</code> keyword is set and
<code>warn_default = TRUE</code>, a warning will be issued listing the variables
that were changed to the default value. This can be used to update your
dictionary.</p>
</td></tr>
<tr><td><code id="match_vec_+3A_anchor_regex">anchor_regex</code></td>
<td>
<p>a <code>logical</code>. When <code>TRUE</code> (default), any regex within
the keywork</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Keys (<code>from</code> column)</h4>

<p>The <code>from</code> column of the dictionary will contain the keys that you want to
match in your current data set. These are expected to match exactly with
the exception of three reserved keywords that start with a full stop:
</p>

<ul>
<li> <p><code>.regex [pattern]</code>: will replace anything matching <code style="white-space: pre;">&#8288;[pattern]&#8288;</code>. <strong>This
is executed before any other replacements are made</strong>. The <code style="white-space: pre;">&#8288;[pattern]&#8288;</code>
should be an unquoted, valid, PERL-flavored regular expression. Any
whitespace padding the regular expression is discarded.
</p>
</li>
<li> <p><code>.missing</code>: replaces any missing values (see NOTE)
</p>
</li>
<li> <p><code>.default</code>: replaces <strong>ALL</strong> values that are not defined in the dictionary
and are not missing.
</p>
</li></ul>




<h4>Values (<code>to</code> column)</h4>

<p>The values will replace their respective keys exactly as they are presented.
</p>
<p>There is currently one recognised keyword that can be placed in the <code>to</code>
column of your dictionary:
</p>

<ul>
<li> <p><code>.na</code>: Replace keys with missing data. When used in combination with the
<code>.missing</code> keyword (in column 1), it can allow you to differentiate
between explicit and implicit missing data.
</p>
</li></ul>




<h3>Value</h3>

<p>a vector of the same type as <code>x</code> with mis-spelled labels cleaned.
Note that factors will be arranged by the order presented in the data
dictionary; other levels will appear afterwards.
</p>


<h3>Note</h3>

<p>If there are any missing values in the <code>from</code> column (keys), then they
are automatically converted to the character &quot;NA&quot; with a warning. If you want
to target missing data with your dictionary, use the <code>.missing</code> keyword. The
<code>.regex</code> keyword uses <code><a href="base.html#topic+gsub">gsub()</a></code> with the <code>perl = TRUE</code> option for replacement.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_df">match_df()</a></code> for an implementation that acts across
multiple variables in a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
corrections &lt;- data.frame(
  bad = c("foubar", "foobr", "fubar", "unknown", ".missing"),
  good = c("foobar", "foobar", "foobar", ".na", "missing"),
  stringsAsFactors = FALSE
)
corrections

# create some fake data
my_data &lt;- c(letters[1:5], sample(corrections$bad[-5], 10, replace = TRUE))
my_data[sample(6:15, 2)] &lt;- NA  # with missing elements

match_vec(my_data, corrections)

# You can use regular expressions to simplify your list
corrections &lt;- data.frame(
  bad =  c(".regex f[ou][^m].+?r$", "unknown", ".missing"),
  good = c("foobar",                ".na",     "missing"),
  stringsAsFactors = FALSE
)

# You can also set a default value
corrections_with_default &lt;- rbind(corrections, c(bad = ".default", good = "unknown"))
corrections_with_default

# a warning will be issued about the data that were converted
match_vec(my_data, corrections_with_default)

# use the warn_default = FALSE, if you are absolutely sure you don't want it.
match_vec(my_data, corrections_with_default, warn_default = FALSE)

# The function will give you a warning if the dictionary does not
# match the data
match_vec(letters, corrections)

# The can be used for translating survey output

words &lt;- data.frame(
  option_code = c(".regex ^[yY][eE]?[sS]?",
    ".regex ^[nN][oO]?",
    ".regex ^[uU][nN]?[kK]?",
    ".missing"),
  option_name = c("Yes", "No", ".na", "Missing"),
  stringsAsFactors = FALSE
)
match_vec(c("Y", "Y", NA, "No", "U", "UNK", "N"), words)
</code></pre>

<hr>
<h2 id='matchmaker_example'>show the path to a matchmaker example file</h2><span id='topic+matchmaker_example'></span>

<h3>Description</h3>

<p>show the path to a matchmaker example file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchmaker_example(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchmaker_example_+3A_name">name</code></td>
<td>
<p>the name of a matchmaker example file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a path to a matchmaker example file
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matchmaker_example() # list all of the example files

# read in example spelling dictionary
sd &lt;- matchmaker_example("spelling-dictionary.csv")
read.csv(sd, stringsAsFactors = FALSE)

# read in example coded data
coded_data &lt;- matchmaker_example("coded-data.csv")
coded_data &lt;- read.csv(coded_data, stringsAsFactors = FALSE)
str(coded_data)
coded_data$date &lt;- as.Date(coded_data$date)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
