<!DOCTYPE html><html lang="en"><head><title>Help for package lineup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lineup}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc.locallod'><p>Calculate LOD score at physical position of each gene</p></a></li>
<li><a href='#combinedist'><p>Combine distance matrices into a single such</p></a></li>
<li><a href='#corbetw2mat'><p>Calculate correlations between columns of two matrices</p></a></li>
<li><a href='#distee'><p>Calculate distance between two gene expression data sets</p></a></li>
<li><a href='#disteg'><p>Calculate distance between two gene expression data sets</p></a></li>
<li><a href='#expr-data'><p>Example gene expression data</p></a></li>
<li><a href='#f2cross'><p>Example experimental cross data</p></a></li>
<li><a href='#find.gene.pseudomarker'><p>Find nearest peudomarker to each gene</p></a></li>
<li><a href='#findCommonID'><p>Find individuals in common between a cross and a phenotype matrix</p></a></li>
<li><a href='#fscale'><p>Standardize the columns of a matrix</p></a></li>
<li><a href='#genepos'><p>Genomic positions of genes in simulated expression data</p></a></li>
<li><a href='#lineupversion'><p>Installed version of R/lineup</p></a></li>
<li><a href='#omitdiag'><p>Replace the diagonal in a distance matrix with missing values</p></a></li>
<li><a href='#plot.lineupdist'><p>Plot summary of inter-individual distances</p></a></li>
<li><a href='#plot2dist'><p>Plot two sets of inter-individual distances against one another</p></a></li>
<li><a href='#plotEGclass'><p>Plot classifier of eQTL genotype from expression data</p></a></li>
<li><a href='#pmap'><p>Physical map of markers</p></a></li>
<li><a href='#pulldiag'><p>Pull out the diagonal from a distance matrix</p></a></li>
<li><a href='#subset.lineupdist'><p>Subsetting distance matrix</p></a></li>
<li><a href='#summary.lineupdist'><p>Summarize inter-individual distances</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.44</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Lining Up Two Sets of Measurements</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for detecting and correcting sample mix-ups between two sets
    of measurements, such as between gene expression data on two tissues.
    Broman et al. (2015) &lt;<a href="https://doi.org/10.1534%2Fg3.115.019778">doi:10.1534/g3.115.019778</a>&gt;.</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl W Broman <a href="https://orcid.org/0000-0002-4914-6671"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karl W Broman &lt;broman@wisc.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kbroman/lineup">https://github.com/kbroman/lineup</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kbroman/lineup/issues">https://github.com/kbroman/lineup/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>qtl (&ge; 1.20-15), class, graphics, grDevices, utils, stats,
parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, knitr, rmarkdown, devtools, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-15 19:32:19 UTC; kbroman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-15 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc.locallod'>Calculate LOD score at physical position of each gene</h2><span id='topic+calc.locallod'></span>

<h3>Description</h3>

<p>For gene expression data with physical positions of the genes, calculate the
LOD score at those positions to assess evidence for local eQTL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.locallod(
  cross,
  pheno,
  pmark,
  addcovar = NULL,
  intcovar = NULL,
  verbose = TRUE,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.locallod_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>"cross"</code> containing data for a QTL
experiment.  See the help file for <code><a href="qtl.html#topic+read.cross">qtl::read.cross()</a></code> in the
R/qtl package (<a href="https://rqtl.org">https://rqtl.org</a>).  There must be a phenotype named
<code>"id"</code> or <code>"ID"</code> that contains the individual identifiers.</p>
</td></tr>
<tr><td><code id="calc.locallod_+3A_pheno">pheno</code></td>
<td>
<p>A data frame of phenotypes (generally gene expression data),
stored as individuals x phenotypes.  The row names must contain individual
identifiers.</p>
</td></tr>
<tr><td><code id="calc.locallod_+3A_pmark">pmark</code></td>
<td>
<p>Pseudomarkers that are closest to the genes in <code>pheno</code>, as
output by <code><a href="#topic+find.gene.pseudomarker">find.gene.pseudomarker()</a></code>.</p>
</td></tr>
<tr><td><code id="calc.locallod_+3A_addcovar">addcovar</code></td>
<td>
<p>Additive covariates passed to <code><a href="qtl.html#topic+scanone">qtl::scanone()</a></code>.</p>
</td></tr>
<tr><td><code id="calc.locallod_+3A_intcovar">intcovar</code></td>
<td>
<p>Interactive covariates passed to <code><a href="qtl.html#topic+scanone">qtl::scanone()</a></code>.</p>
</td></tr>
<tr><td><code id="calc.locallod_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print tracing information.</p>
</td></tr>
<tr><td><code id="calc.locallod_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of CPU cores to use in the calculations. With
<code>n.cores=0</code>, <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code> is used to
detect the number of available cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cross</code> and <code>pheno</code> must contain exactly the same individuals in
the same order.  (Use <code><a href="#topic+findCommonID">findCommonID()</a></code> to line them up.)
</p>
<p>We consider the expression phenotypes in batches: those whose closest
pseudomarker is the same.
</p>
<p>We use Haley-Knott regression to calculate the LOD scores.
</p>
<p>Actually, we use a bit of a contortion of the data to force the
<code><a href="qtl.html#topic+scanone">qtl::scanone()</a></code> function in R/qtl to calculate the LOD score at a
single position.
</p>
<p>We omit any transcripts that map to the X chromosome; we can only handle
autosomal loci for now.
</p>


<h3>Value</h3>

<p>A vector of LOD scores.  The names indicate the gene names (columns in
<code>pheno</code>).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find.gene.pseudomarker">find.gene.pseudomarker()</a></code>, <code><a href="#topic+plotEGclass">plotEGclass()</a></code>,
<code><a href="#topic+findCommonID">findCommonID()</a></code>, <code><a href="#topic+disteg">disteg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(f2cross, expr1, genepos, pmap)
library(qtl)

# calc QTL genotype probabilities
f2cross &lt;- calc.genoprob(f2cross, step=1)

# find nearest pseudomarkers
pmark &lt;- find.gene.pseudomarker(f2cross, pmap, genepos, "prob")

# line up f2cross and expr1
id &lt;- findCommonID(f2cross, expr1)

# calculate LOD score for local eQTL
locallod &lt;- calc.locallod(f2cross[,id$first], expr1[id$second,], pmark)

</code></pre>

<hr>
<h2 id='combinedist'>Combine distance matrices into a single such</h2><span id='topic+combinedist'></span>

<h3>Description</h3>

<p>Combine multiple distance matrices into a single distance matrix providing
an overall summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinedist(..., method = c("median", "mean"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combinedist_+3A_...">...</code></td>
<td>
<p>Set of distance matrices, as calculated by <code><a href="#topic+distee">distee()</a></code>
or <code><a href="#topic+disteg">disteg()</a></code>.</p>
</td></tr>
<tr><td><code id="combinedist_+3A_method">method</code></td>
<td>
<p>Indicates whether to summarize using the median or the mean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The row and column names of the input distance matrices define the
individual IDs.
</p>
<p>If the input distance matrices all have an attribute <code>"denom"</code> (for
denominator) and <code>method="mean"</code>, we use a weighted mean, weighted by
the denominators.  This could be used to calculate an overall proportion.
</p>


<h3>Value</h3>

<p>A distance matrix, with class <code>"lineupdist"</code>.  The individual
IDs are in the row and column names.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distee">distee()</a></code>, <code><a href="#topic+disteg">disteg()</a></code>,
<code><a href="#topic+summary.lineupdist">summary.lineupdist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)

# load example data
data(f2cross, expr1, expr2, pmap, genepos)


# calculate QTL genotype probabilities
f2cross &lt;- calc.genoprob(f2cross, step=1)

# find nearest pseudomarkers
pmark &lt;- find.gene.pseudomarker(f2cross, pmap, genepos)

# line up individuals
id1 &lt;- findCommonID(f2cross, expr1)
id2 &lt;- findCommonID(f2cross, expr2)

# calculate LOD score for local eQTL
locallod1 &lt;- calc.locallod(f2cross[,id1$first], expr1[id1$second,], pmark)
locallod2 &lt;- calc.locallod(f2cross[,id2$first], expr2[id2$second,], pmark)

# take those with LOD &gt; 25
expr1s &lt;- expr1[,locallod1&gt;25,drop=FALSE]
expr2s &lt;- expr2[,locallod2&gt;25,drop=FALSE]

# calculate distance between individuals
#     (prop'n mismatches between obs and inferred eQTL geno)
d1 &lt;- disteg(f2cross, expr1s, pmark)
d2 &lt;- disteg(f2cross, expr2s, pmark)

# combine distances
d &lt;- combinedist(d1, d2)

# summary of problem samples
summary(d)

</code></pre>

<hr>
<h2 id='corbetw2mat'>Calculate correlations between columns of two matrices</h2><span id='topic+corbetw2mat'></span>

<h3>Description</h3>

<p>For matrices x and y, calculate the correlation between columns of x and
columns of y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corbetw2mat(
  x,
  y,
  what = c("paired", "bestright", "bestpairs", "all"),
  corthresh = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corbetw2mat_+3A_x">x</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="corbetw2mat_+3A_y">y</code></td>
<td>
<p>A numeric matrix with the same number of rows as <code>x</code>.</p>
</td></tr>
<tr><td><code id="corbetw2mat_+3A_what">what</code></td>
<td>
<p>Indicates which correlations to calculate and return.  See
value, below.</p>
</td></tr>
<tr><td><code id="corbetw2mat_+3A_corthresh">corthresh</code></td>
<td>
<p>Threshold on correlations if <code>what="bestpairs"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (<code>NA</code>) are ignored, and we calculate the correlation
using all complete pairs, as in <code><a href="stats.html#topic+cor">stats::cor()</a></code> with
<code>use="pairwise.complete.obs"</code>.
</p>


<h3>Value</h3>

<p>If <code>what="paired"</code>, the return value is a vector of
correlations, between columns of <code>x</code> and the corresponding column of
<code>y</code>.  <code>x</code> and <code>y</code> must have the same number of columns.
</p>
<p>If <code>what="bestright"</code>, we return a data frame of size <code>ncol(x)</code> by
<code>3</code>, with the <code class="reqn">i</code>th row being the maximum correlation between
column <code class="reqn">i</code> of <code>x</code> and a column of <code>y</code>, and then the
<code>y</code>-column index and <code>y</code>-column name with that correlation.  (In
case of ties, we give the first one.)
</p>
<p>If <code>what="bestpairs"</code>, we return a data frame with five columns,
containing all pairs of columns (with one in <code>x</code> and one in <code>y</code>)
with correlation <code class="reqn">\ge</code> <code>corthresh</code>.  Each row corresponds to a
column pair, and contains the correlation and then the <code>x</code>- and
<code>y</code>-column indices followed by the <code>x</code>- and <code>y</code>-column names.
</p>
<p>If <code>what="all"</code>, the output is a matrix of size <code>ncol(x)</code> by
<code>ncol(y)</code>, with all correlations between columns of <code>x</code> and
columns of <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distee">distee()</a></code>, <code><a href="#topic+findCommonID">findCommonID()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(expr1, expr2)


# correlations with paired columns
r &lt;- corbetw2mat(expr1, expr2)
# top 10, by absolute value
r[order(abs(r), decreasing=TRUE)[1:10]]

# all pairs of columns with correlation &gt;= 0.8
r_allpairs &lt;- corbetw2mat(expr1, expr2, what="bestpairs", corthresh=0.6)

# for each column in left matrix, most-correlated column in right matrix
r_bestright &lt;- corbetw2mat(expr1, expr2, what="bestright")

</code></pre>

<hr>
<h2 id='distee'>Calculate distance between two gene expression data sets</h2><span id='topic+distee'></span>

<h3>Description</h3>

<p>Calculate a distance between all pairs of individuals for two gene
expression data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distee(
  e1,
  e2 = NULL,
  d.method = c("rmsd", "cor"),
  labels = c("e1", "e2"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distee_+3A_e1">e1</code></td>
<td>
<p>Numeric matrix of gene expression data, as individuals x genes.
The row and column names must contain individual and gene identifiers.</p>
</td></tr>
<tr><td><code id="distee_+3A_e2">e2</code></td>
<td>
<p>(Optional) Like <code>e1</code>.  An appreciable number of individuals
and genes must be in common.</p>
</td></tr>
<tr><td><code id="distee_+3A_d.method">d.method</code></td>
<td>
<p>Calculate inter-individual distance as RMS difference or as
correlation.</p>
</td></tr>
<tr><td><code id="distee_+3A_labels">labels</code></td>
<td>
<p>Two character strings, to use as labels for the two data
matrices in subsequent output.</p>
</td></tr>
<tr><td><code id="distee_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, give verbose output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We calculate the pairwise distance between all individuals (rows) in
<code>e1</code> and all individuals in <code>e2</code>.  This distance is either the RMS
difference (<code>d.method="rmsd"</code>) or the correlation
(<code>d.method="cor"</code>).
</p>


<h3>Value</h3>

<p>A matrix with <code>nrow(e1)</code> rows and <code>nrow(e2)</code> columns,
containing the distances.  The individual IDs are in the row and column
names.  The matrix is assigned class <code>"lineupdist"</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulldiag">pulldiag()</a></code>, <code><a href="#topic+omitdiag">omitdiag()</a></code>,
<code><a href="#topic+summary.lineupdist">summary.lineupdist()</a></code>, <code><a href="#topic+plot2dist">plot2dist()</a></code>,
<code><a href="#topic+disteg">disteg()</a></code>, <code><a href="#topic+corbetw2mat">corbetw2mat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load the example data
data(expr1, expr2)


# find samples in common
id &lt;- findCommonID(expr1, expr2)

# calculate correlations between cols of x and cols of y
thecor &lt;- corbetw2mat(expr1[id$first,], expr2[id$second,])

# subset at genes with corr &gt; 0.8 and scale values
expr1s &lt;- expr1[,thecor &gt; 0.8]/1000
expr2s &lt;- expr2[,thecor &gt; 0.8]/1000

# calculate distance (using "RMS difference" as a measure)
d1 &lt;- distee(expr1s, expr2s, d.method="rmsd", labels=c("1","2"))

# calculate distance (using "correlation" as a measure...really similarity)
d2 &lt;- distee(expr1s, expr2s, d.method="cor", labels=c("1", "2"))

# pull out the smallest 8 self-self correlations
sort(pulldiag(d2))[1:8]

# summary of results
summary(d1)
summary(d2)

# plot histograms of RMS distances
plot(d1)

# plot histograms of correlations
plot(d2)

# plot distances against one another
plot2dist(d1, d2)

</code></pre>

<hr>
<h2 id='disteg'>Calculate distance between two gene expression data sets</h2><span id='topic+disteg'></span>

<h3>Description</h3>

<p>Calculate a distance between all pairs of individuals for two gene
expression data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disteg(
  cross,
  pheno,
  pmark,
  min.genoprob = 0.99,
  k = 20,
  min.classprob = 0.8,
  classprob2drop = 1,
  repeatKNN = TRUE,
  max.selfd = 0.3,
  phenolabel = "phenotype",
  weightByLinkage = FALSE,
  map.function = c("haldane", "kosambi", "c-f", "morgan"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disteg_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>"cross"</code> containing data for a QTL
experiment.  See the help file for <code><a href="qtl.html#topic+read.cross">qtl::read.cross()</a></code> in the
R/qtl package (<a href="https://rqtl.org">https://rqtl.org</a>).  There must be a phenotype named
<code>"id"</code> or <code>"ID"</code> that contains the individual identifiers.</p>
</td></tr>
<tr><td><code id="disteg_+3A_pheno">pheno</code></td>
<td>
<p>A data frame of phenotypes (generally gene expression data),
stored as individuals x phenotypes.  The row names must contain individual
identifiers.</p>
</td></tr>
<tr><td><code id="disteg_+3A_pmark">pmark</code></td>
<td>
<p>Pseudomarkers that are closest to the genes in <code>pheno</code>, as
output by <code><a href="#topic+find.gene.pseudomarker">find.gene.pseudomarker()</a></code>.</p>
</td></tr>
<tr><td><code id="disteg_+3A_min.genoprob">min.genoprob</code></td>
<td>
<p>Threshold on genotype probabilities; if maximum
probability is less than this, observed genotype taken as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="disteg_+3A_k">k</code></td>
<td>
<p>Number of nearest neighbors to consider in forming a k-nearest
neighbor classifier.</p>
</td></tr>
<tr><td><code id="disteg_+3A_min.classprob">min.classprob</code></td>
<td>
<p>Minimum proportion of neighbors with a common class to
make a class prediction.</p>
</td></tr>
<tr><td><code id="disteg_+3A_classprob2drop">classprob2drop</code></td>
<td>
<p>If an individual is inferred to have a genotype
mismatch with classprob &gt; this value, treat as an outlier and drop from the
analysis and then repeat the KNN construction without it.</p>
</td></tr>
<tr><td><code id="disteg_+3A_repeatknn">repeatKNN</code></td>
<td>
<p>If TRUE, repeat k-nearest neighbor a second time, after
omitting individuals who seem to not be self-self matches</p>
</td></tr>
<tr><td><code id="disteg_+3A_max.selfd">max.selfd</code></td>
<td>
<p>Min distance from self (as proportion of mismatches between
observed and predicted eQTL genotypes) to be excluded from the second round
of k-nearest neighbor.</p>
</td></tr>
<tr><td><code id="disteg_+3A_phenolabel">phenolabel</code></td>
<td>
<p>Label for expression phenotypes to place in the output
distance matrix.</p>
</td></tr>
<tr><td><code id="disteg_+3A_weightbylinkage">weightByLinkage</code></td>
<td>
<p>If TRUE, weight the eQTL to account for their
relative positions (for example, two tightly linked eQTL would each count
about 1/2 of an isolated eQTL)</p>
</td></tr>
<tr><td><code id="disteg_+3A_map.function">map.function</code></td>
<td>
<p>Used if <code>weightByLinkage</code> is TRUE</p>
</td></tr>
<tr><td><code id="disteg_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, give verbose output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the expression phenotypes in batches, by which pseudomarker they
are closest to.  For each batch, we pull the genotype probabilities at the
corresponding pseudomarker and use the individuals that are in common
between <code>cross</code> and <code>pheno</code> and whose maximum genotype probability
is above <code>min.genoprob</code>, to form a classifier of eQTL genotype from
expression values, using k-nearest neighbor (the function
<code><a href="class.html#topic+knn">class::knn()</a></code>). The classifier is applied to all individuals with
expression data, to give a predicted eQTL genotype. (If the proportion of
the k nearest neighbors with a common class is less than
<code>min.classprob</code>, the predicted eQTL genotype is left as <code>NA</code>.)
</p>
<p>If <code>repeatKNN</code> is TRUE, we repeat the construction of the k-nearest
neighbor classifier after first omitting individuals whose proportion of
mismatches between observed and inferred eQTL genotypes is greater than
<code>max.selfd</code>.
</p>
<p>Finally, we calculate the distance between the observed eQTL genotypes for
each individual in <code>cross</code> and the inferred eQTL genotypes for each
individual in <code>pheno</code>, as the proportion of mismatches between the
observed and inferred eQTL genotypes.
</p>
<p>If <code>weightByLinkage</code> is <code>TRUE</code>, we use weights on the mismatch
proportions for the various eQTL, taking into account their linkage. Two
tightly linked eQTL will each be given half the weight of a single isolated
eQTL.
</p>


<h3>Value</h3>

<p>A matrix with <code>nind(cross)</code> rows and <code>nrow(pheno)</code>
columns, containing the distances.  The individual IDs are in the row and
column names.  The matrix is assigned class <code>"lineupdist"</code>.
</p>
<p>The names of the genes that were used to construct the classifier are saved
in an attribute <code>"retained"</code>.
</p>
<p>The observed and inferred eQTL genotypes are saved as attributes
<code>"obsg"</code> and <code>"infg"</code>.
</p>
<p>The denominators of the proportions that form the inter-individual distances
are in the attribute <code>"denom"</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distee">distee()</a></code>, <code><a href="#topic+summary.lineupdist">summary.lineupdist()</a></code>,
<code><a href="#topic+pulldiag">pulldiag()</a></code>, <code><a href="#topic+omitdiag">omitdiag()</a></code>, <code><a href="#topic+findCommonID">findCommonID()</a></code>,
<code><a href="#topic+find.gene.pseudomarker">find.gene.pseudomarker()</a></code>, <code><a href="#topic+calc.locallod">calc.locallod()</a></code>,
<code><a href="#topic+plot.lineupdist">plot.lineupdist()</a></code>, <code><a href="class.html#topic+knn">class::knn()</a></code>,
<code><a href="#topic+plotEGclass">plotEGclass()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)

# load example data
data(f2cross, expr1, pmap, genepos)


# calculate QTL genotype probabilities
f2cross &lt;- calc.genoprob(f2cross, step=1)

# find nearest pseudomarkers
pmark &lt;- find.gene.pseudomarker(f2cross, pmap, genepos)

# line up individuals
id &lt;- findCommonID(f2cross, expr1)

# calculate LOD score for local eQTL
locallod &lt;- calc.locallod(f2cross[,id$first], expr1[id$second,], pmark)

# take those with LOD &gt; 25
expr1s &lt;- expr1[,locallod&gt;25,drop=FALSE]

# calculate distance between individuals
#     (prop'n mismatches between obs and inferred eQTL geno)
d &lt;- disteg(f2cross, expr1s, pmark)

# plot distances
plot(d)

# summary of apparent mix-ups
summary(d)

# plot of classifier for and second eQTL
par(mfrow=c(2,1), las=1)
plotEGclass(d)
plotEGclass(d, 2)

</code></pre>

<hr>
<h2 id='expr-data'>Example gene expression data</h2><span id='topic+expr-data'></span><span id='topic+expr1'></span><span id='topic+expr2'></span>

<h3>Description</h3>

<p>Matrices of simulated gene expression data, each for 98 individuals
at 5,000 genes. Think of <code>expr1</code> and <code>expr2</code> as
expression data on two different tissues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(expr1)
data(expr2)
</code></pre>


<h3>Format</h3>

<p>A matrix of integers, individuals as rows and genes as columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genepos">genepos()</a></code>, <code><a href="#topic+f2cross">f2cross()</a></code>, <code><a href="#topic+pmap">pmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(expr1)
data(expr2)

# identify the common individuals
id &lt;- findCommonID(rownames(expr1), rownames(expr2))

# correlation between tissues for each gene
rho &lt;- corbetw2mat(expr1[id$first,], expr2[id$second,])
hist(rho, breaks=100)
</code></pre>

<hr>
<h2 id='f2cross'>Example experimental cross data</h2><span id='topic+f2cross'></span>

<h3>Description</h3>

<p>Simulated experimental cross data with some sample mix-ups. The
only phenotype is an individual ID. There are 100 individuals
genotyped at 1000 markers on 19 autosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(f2cross)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"cross"</code>. See
<code><a href="qtl.html#topic+read.cross">qtl::read.cross()</a></code> in the R/qtl package for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expr1">expr1()</a></code>, <code><a href="#topic+expr2">expr2()</a></code>, <code><a href="#topic+genepos">genepos()</a></code>, <code><a href="#topic+pmap">pmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)
data(f2cross)
summary(f2cross)
</code></pre>

<hr>
<h2 id='find.gene.pseudomarker'>Find nearest peudomarker to each gene</h2><span id='topic+find.gene.pseudomarker'></span>

<h3>Description</h3>

<p>Pull out the pseudomarker that is closest to the position of each of a
series of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.gene.pseudomarker(cross, pmap, geneloc, where = c("prob", "draws"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.gene.pseudomarker_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>"cross"</code> containing data for a QTL
experiment.  See the help file for <code><a href="qtl.html#topic+read.cross">qtl::read.cross()</a></code> in the
R/qtl package (<a href="https://rqtl.org">https://rqtl.org</a>).</p>
</td></tr>
<tr><td><code id="find.gene.pseudomarker_+3A_pmap">pmap</code></td>
<td>
<p>A physical map of the markers in <code>cross</code>, with locations in
Mbp.  This is a list whose components are the marker locations on each
chromosome.</p>
</td></tr>
<tr><td><code id="find.gene.pseudomarker_+3A_geneloc">geneloc</code></td>
<td>
<p>A data frame specifying the physical locations of the genes.
There should be two columns, <code>chr</code> for chromosome and <code>pos</code> for
position in Mbp.  The rownames should indicate the gene names.</p>
</td></tr>
<tr><td><code id="find.gene.pseudomarker_+3A_where">where</code></td>
<td>
<p>Indicates whether to pull pseudomarkers from the genotype
probabilities (produced by <code><a href="qtl.html#topic+calc.genoprob">qtl::calc.genoprob()</a></code>) or from the
imputed genotypes (produced by <code><a href="qtl.html#topic+sim.geno">qtl::sim.geno()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We first convert positions (by interpolation) from those contained within
<code>cross</code> to physical coordinates contained in <code>pmap</code>.  We then use
<code><a href="qtl.html#topic+find.pseudomarker">qtl::find.pseudomarker()</a></code> to identify the closest pseudomarker to
each gene location.
</p>
<p>We also include the positions of the pseudomarkers, and we print a warning
message if pseudomarkers are &gt; 2 Mbp from the respective gene.
</p>


<h3>Value</h3>

<p>A data frame with columns <code>chr</code> (the chromosome) and
<code>pmark</code> (the name of the pseudomarker).  The third column <code>pos</code>
contains the Mbp position of the pseudomarker.  The final column is the
signed distance between the gene and the pseudomarker.  The rownames
indicate the gene names.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="qtl.html#topic+find.pseudomarker">qtl::find.pseudomarker()</a></code>,
<code><a href="qtl.html#topic+qtl-internal">qtl::find.pseudomarkerpos()</a></code>, <code><a href="#topic+plotEGclass">plotEGclass()</a></code>,
<code><a href="#topic+disteg">disteg()</a></code>, <code><a href="#topic+calc.locallod">calc.locallod()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(f2cross, expr1, genepos, pmap)
library(qtl)

# calc QTL genotype probabilities
f2cross &lt;- calc.genoprob(f2cross, step=1)

# find nearest pseudomarkers
pmark &lt;- find.gene.pseudomarker(f2cross, pmap, genepos, "prob")

</code></pre>

<hr>
<h2 id='findCommonID'>Find individuals in common between a cross and a phenotype matrix</h2><span id='topic+findCommonID'></span>

<h3>Description</h3>

<p>Identify which individuals are in common between a QTL mapping data set and
a matrix of phenotypes, series of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCommonID(id1, id2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findCommonID_+3A_id1">id1</code></td>
<td>
<p>A character vector of individual IDs.  This can also be a QTL
cross object (see <code><a href="qtl.html#topic+read.cross">qtl::read.cross()</a></code>), in which case
<code><a href="qtl.html#topic+getid">qtl::getid()</a></code> is used to grab individual IDs, or a matrix or data
frame, in which case the rownames are taken to be IDs.</p>
</td></tr>
<tr><td><code id="findCommonID_+3A_id2">id2</code></td>
<td>
<p>Like <code>id1</code>, can be a character vector, a cross or a
matrix/data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components:
</p>
<p>First, a data frame with rows corresponding to all individuals (across the
two sets of individual IDs) and three columns: <code>indexInFirst</code> and
<code>indexInSecond</code> contain numeric indices to the locations of the
individuals within <code>cross</code> and <code>pheno</code>, and <code>inBoth</code> is a
logical vector to indicate which individuals appear in both crosses.  The
row names are the individual identifiers.
</p>
<p>The second and third components are vectors of indices in <code>id1</code> and
<code>id2</code>, respectively, indicating the paired locations of the individuals
that are in common.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc.locallod">calc.locallod()</a></code>, <code><a href="#topic+corbetw2mat">corbetw2mat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(f2cross, expr1)

# align IDs
id &lt;- findCommonID(f2cross, expr1)

# aligned data
f2cross_aligned &lt;- f2cross[,id$first]
expr1_aligned &lt;- expr1[id$second,]

</code></pre>

<hr>
<h2 id='fscale'>Standardize the columns of a matrix</h2><span id='topic+fscale'></span>

<h3>Description</h3>

<p>Standardize each column in a matrix, so that the columns have mean 0 and SD
1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fscale(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fscale_+3A_x">x</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (<code>NA</code>) are ignored and left as is.
</p>
<p>If there is just 1 non-missing value in a column, it is left as is.
</p>
<p>This function uses a one-pass algorithm to calculate the mean and SD, which
is fast but can show a bit of round-off error.
</p>


<h3>Value</h3>

<p>A matrix of the same form as the input, but with columns transformed
to have mean 0 and SD 1.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">base::scale()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(1:10, ncol=2)
y &lt;- fscale(x)

</code></pre>

<hr>
<h2 id='genepos'>Genomic positions of genes in simulated expression data</h2><span id='topic+genepos'></span>

<h3>Description</h3>

<p>A table with the genomic positions of genes in the simulated
expression data, <code><a href="#topic+expr1">expr1()</a></code> and <code><a href="#topic+expr2">expr2()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(genepos)
</code></pre>


<h3>Format</h3>

<p>A data frame with two columns, chromosome and physical position (in Mbp).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expr1">expr1()</a></code>, <code><a href="#topic+expr2">expr2()</a></code>, <code><a href="#topic+f2cross">f2cross()</a></code>, <code><a href="#topic+pmap">pmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genepos)

# interplot genetic positions
library(qtl)
data(pmap)
data(f2cross)
genepos_interp &lt;- interpPositions(genepos, pmap, pull.map(f2cross))
genepos[1:5,] # 'newpos' column is the interpolated cM position
</code></pre>

<hr>
<h2 id='lineupversion'>Installed version of R/lineup</h2><span id='topic+lineupversion'></span>

<h3>Description</h3>

<p>Print the version number of the currently installed version of R/lineup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineupversion()
</code></pre>


<h3>Value</h3>

<p>A character string with the version number of the currently
installed version of R/lineup.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  lineupversion()

</code></pre>

<hr>
<h2 id='omitdiag'>Replace the diagonal in a distance matrix with missing values</h2><span id='topic+omitdiag'></span>

<h3>Description</h3>

<p>Replace the diagonal (that is, self-self distances) from a distance matrix
calculated by <code><a href="#topic+distee">distee()</a></code> or <code><a href="#topic+disteg">disteg()</a></code> with missing
values (so that only self-nonself distances are left).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omitdiag(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omitdiag_+3A_d">d</code></td>
<td>
<p>A distance matrix calculated by <code><a href="#topic+distee">distee()</a></code> or
<code><a href="#topic+disteg">disteg()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use the row and column names to identify which entries are self-self.
</p>


<h3>Value</h3>

<p>A matrix of the same form as the input, but with self-self distances
replaced with <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulldiag">pulldiag()</a></code>, <code><a href="#topic+distee">distee()</a></code>, <code><a href="#topic+disteg">disteg()</a></code>,
<code><a href="#topic+summary.lineupdist">summary.lineupdist()</a></code>, <code><a href="#topic+plot2dist">plot2dist()</a></code>,
<code><a href="#topic+plot.lineupdist">plot.lineupdist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(expr1, expr2)



# distance as RMS difference
d &lt;- distee(expr1, expr2)

# focus on the self-nonself distances
# (replace self-self distances with NA)
d_selfnonself &lt;- omitdiag(d)

</code></pre>

<hr>
<h2 id='plot.lineupdist'>Plot summary of inter-individual distances</h2><span id='topic+plot.lineupdist'></span>

<h3>Description</h3>

<p>Plot histograms of self-self and self-nonself distances from a distance
matrix calculated by <code><a href="#topic+distee">distee()</a></code> or <code><a href="#topic+disteg">disteg()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lineupdist'
plot(x, breaks = NULL, add.rug = TRUE, what = c("both", "ss", "sn"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lineupdist_+3A_x">x</code></td>
<td>
<p>Output of <code><a href="#topic+distee">distee()</a></code> or <code><a href="#topic+disteg">disteg()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lineupdist_+3A_breaks">breaks</code></td>
<td>
<p>Optional vector of breaks, passed to
<code><a href="graphics.html#topic+hist">graphics::hist()</a></code>, though if it is length 1, we interpret it as
the number of breaks and ensure that both histograms use the same set of
breaks.</p>
</td></tr>
<tr><td><code id="plot.lineupdist_+3A_add.rug">add.rug</code></td>
<td>
<p>If true, also include <code><a href="graphics.html#topic+rug">graphics::rug()</a></code> below
histograms.</p>
</td></tr>
<tr><td><code id="plot.lineupdist_+3A_what">what</code></td>
<td>
<p>Indicates whether to plot both self-self and self-nonself
distances (or correlations) or just one or the other.  (<code>"ss"</code>
indicates self-self and <code>"sn"</code> indicates self-nonself.)</p>
</td></tr>
<tr><td><code id="plot.lineupdist_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We call <code><a href="#topic+pulldiag">pulldiag()</a></code> and <code><a href="#topic+omitdiag">omitdiag()</a></code> to get the
self-self and self-nonself distances.
</p>
<p>If all of the self-self distances are missing, we plot just the self-nonself
distances.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulldiag">pulldiag()</a></code>, <code><a href="#topic+distee">distee()</a></code>,
<code><a href="#topic+plot2dist">plot2dist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(expr1, expr2)



# distance as correlation
d &lt;- distee(expr1, expr2, "cor")

# plot histograms of self-self and self-nonself correlations
plot(d)

</code></pre>

<hr>
<h2 id='plot2dist'>Plot two sets of inter-individual distances against one another</h2><span id='topic+plot2dist'></span>

<h3>Description</h3>

<p>Plot two sets of inter-individual distances against one another, colored by
self and non-self distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2dist(
  d1,
  d2,
  hirow = NULL,
  hicol = NULL,
  xlab = NULL,
  ylab = NULL,
  smoothScatter = FALSE,
  colself = "black",
  colnonself = "gray",
  colhirow = "green",
  colhicol = "orange",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot2dist_+3A_d1">d1</code></td>
<td>
<p>Output of <code><a href="#topic+distee">distee()</a></code>.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_d2">d2</code></td>
<td>
<p>Output of <code><a href="#topic+distee">distee()</a></code>.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_hirow">hirow</code></td>
<td>
<p>Names of rows to highlight in green.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_hicol">hicol</code></td>
<td>
<p>Names of columns to highlight in orange.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label (optional)</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label (optional)</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_smoothscatter">smoothScatter</code></td>
<td>
<p>If TRUE, plot non-self distances with
<code><a href="graphics.html#topic+smoothScatter">graphics::smoothScatter()</a></code>; if FALSE, use <code>base::plot()</code>.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_colself">colself</code></td>
<td>
<p>Color to use for the self-self points.  If NULL, these aren't
plotted.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_colnonself">colnonself</code></td>
<td>
<p>Color to use for the non-self points.  If NULL, these
aren't plotted.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_colhirow">colhirow</code></td>
<td>
<p>Color to use for the <code>hirow</code> points.  If NULL, these
aren't plotted.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_colhicol">colhicol</code></td>
<td>
<p>Color to use for the <code>hicol</code> points.  If NULL, these
aren't plotted.</p>
</td></tr>
<tr><td><code id="plot2dist_+3A_...">...</code></td>
<td>
<p>Passed to <code>base::plot()</code> and
<code><a href="graphics.html#topic+points">graphics::points()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulldiag">pulldiag()</a></code>, <code><a href="#topic+distee">distee()</a></code>,
<code><a href="#topic+summary.lineupdist">summary.lineupdist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(expr1, expr2)



# distances as RMS difference and correlation
d_rmsd &lt;- distee(expr1, expr2, "rmsd")
d_cor &lt;- distee(expr1, expr2, "cor")

# plot distances against one another
plot2dist(d_rmsd, d_cor)

</code></pre>

<hr>
<h2 id='plotEGclass'>Plot classifier of eQTL genotype from expression data</h2><span id='topic+plotEGclass'></span>

<h3>Description</h3>

<p>Diagnostic plot of one of the eQTL classifiers from the results of
<code><a href="#topic+disteg">disteg()</a></code>: generally expression phenotype against observed eQTL
genotype, colored by inferred eQTL genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEGclass(
  d,
  eqtl = 1,
  outercol = "inferred",
  innercol = "observed",
  thecolors = c("#7B68ED", "#1B9E78", "#CA3767", "#E59E00"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotEGclass_+3A_d">d</code></td>
<td>
<p>Output of <code><a href="#topic+disteg">disteg()</a></code>.</p>
</td></tr>
<tr><td><code id="plotEGclass_+3A_eqtl">eqtl</code></td>
<td>
<p>Numeric index or a character vector (of the form &quot;1@102.35&quot;)
indicating the eQTL to consider.</p>
</td></tr>
<tr><td><code id="plotEGclass_+3A_outercol">outercol</code></td>
<td>
<p>Indicates how to color the outer edge of the points:
<code>"observed"</code> indicates to color based on observed genotypes;
<code>"inferred"</code> indicates to color based on inferred genotypes; otherwise,
give a color.</p>
</td></tr>
<tr><td><code id="plotEGclass_+3A_innercol">innercol</code></td>
<td>
<p>Like <code>outercol</code>, but indicating the interior of the
points.</p>
</td></tr>
<tr><td><code id="plotEGclass_+3A_thecolors">thecolors</code></td>
<td>
<p>The colors to use in the plot.  The last element (after the
number of genotypes) indicates the color to use for missing values.</p>
</td></tr>
<tr><td><code id="plotEGclass_+3A_...">...</code></td>
<td>
<p>Passed to <code>base::plot()</code> and
<code><a href="graphics.html#topic+points">graphics::points()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a diagnostic plot for studying one of the k-nearest
neighbor classifiers underlying the output from <code><a href="#topic+disteg">disteg()</a></code>.
</p>
<p>In the case of one expression phenotype attached to the selected eQTL, the
plot is a dot plot of gene expression against observed eQTL genotype.
</p>
<p>In the case of two expression phenotypes, the plot is a scatterplot of the
two expression phenotypes against each other.
</p>
<p>In the case of more than two expression phenotypes, we use
<code><a href="graphics.html#topic+pairs">graphics::pairs()</a></code> to produce a matrix of scatterplots.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+disteg">disteg()</a></code>, <code><a href="#topic+plot.lineupdist">plot.lineupdist()</a></code>,
<code><a href="#topic+plot2dist">plot2dist()</a></code>, <code><a href="class.html#topic+knn">class::knn()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)

# load example data
data(f2cross, expr1, pmap, genepos)


# calculate QTL genotype probabilities
f2cross &lt;- calc.genoprob(f2cross, step=1)

# find nearest pseudomarkers
pmark &lt;- find.gene.pseudomarker(f2cross, pmap, genepos)

# line up individuals
id &lt;- findCommonID(f2cross, expr1)

# calculate LOD score for local eQTL
locallod &lt;- calc.locallod(f2cross[,id$first], expr1[id$second,], pmark)

# take those with LOD &gt; 25
expr1s &lt;- expr1[,locallod&gt;25,drop=FALSE]

# calculate distance between individuals
#     (prop'n mismatches between obs and inferred eQTL geno)
d &lt;- disteg(f2cross, expr1s, pmark)

# plot of classifier for and second eQTL
par(mfrow=c(2,1), las=1)
plotEGclass(d)
plotEGclass(d, 2)

</code></pre>

<hr>
<h2 id='pmap'>Physical map of markers</h2><span id='topic+pmap'></span>

<h3>Description</h3>

<p>Physical map (Mbp positions) of the markers in <code><a href="#topic+f2cross">f2cross()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pmap)
</code></pre>


<h3>Format</h3>

<p>A list of vectors, each containing the locations of markers in Mbp.
(Technically, an object of class <code>"map"</code>.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expr1">expr1()</a></code>, <code><a href="#topic+expr2">expr2()</a></code>, <code><a href="#topic+f2cross">f2cross()</a></code>, <code><a href="#topic+genepos">genepos()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pmap)
summary(pmap)
plot(pmap)
</code></pre>

<hr>
<h2 id='pulldiag'>Pull out the diagonal from a distance matrix</h2><span id='topic+pulldiag'></span>

<h3>Description</h3>

<p>Pull out the diagonal from a distance matrix calculated by
<code><a href="#topic+distee">distee()</a></code> (that is, self-self distances).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulldiag(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pulldiag_+3A_d">d</code></td>
<td>
<p>A distance matrix calculated by <code><a href="#topic+distee">distee()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use the row and column names to identify which entries are self-self.
</p>


<h3>Value</h3>

<p>A vector with the self-self distances.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omitdiag">omitdiag()</a></code>, <code><a href="#topic+distee">distee()</a></code>, <code><a href="#topic+disteg">disteg()</a></code>,
<code><a href="#topic+summary.lineupdist">summary.lineupdist()</a></code>, <code><a href="#topic+plot2dist">plot2dist()</a></code>,
<code><a href="#topic+plot.lineupdist">plot.lineupdist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(expr1, expr2)



# distance as RMS difference
d &lt;- distee(expr1, expr2)

# pull out the self-self distances
d_selfself &lt;- pulldiag(d)

# samples with smallest self-self correlation
sort(d_selfself)[1:10]

</code></pre>

<hr>
<h2 id='subset.lineupdist'>Subsetting distance matrix</h2><span id='topic+subset.lineupdist'></span><span id='topic++5B.lineupdist'></span>

<h3>Description</h3>

<p>Pull out a specified set of rows and columns from a distance matrix
calculated by <code><a href="#topic+distee">distee()</a></code> or <code><a href="#topic+disteg">disteg()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lineupdist'
subset(x, rows = NULL, cols = NULL, ...)

## S3 method for class 'lineupdist'
x[rows = NULL, cols = NULL]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.lineupdist_+3A_x">x</code></td>
<td>
<p>A distance matrix object as obtained from <code><a href="#topic+distee">distee()</a></code> or
<code><a href="#topic+disteg">disteg()</a></code>.</p>
</td></tr>
<tr><td><code id="subset.lineupdist_+3A_rows">rows</code></td>
<td>
<p>Optional vector of selected rows.</p>
</td></tr>
<tr><td><code id="subset.lineupdist_+3A_cols">cols</code></td>
<td>
<p>Optional vector of selected columns.</p>
</td></tr>
<tr><td><code id="subset.lineupdist_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input distance matrix object, but with only the specified subset
of the data.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+disteg">disteg()</a></code>, <code><a href="#topic+distee">distee()</a></code>, <code><a href="#topic+pulldiag">pulldiag()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(expr1, expr2)


# find samples in common
id &lt;- findCommonID(expr1, expr2)

# calculate correlations between cols of x and cols of y
thecor &lt;- corbetw2mat(expr1[id$first,], expr2[id$second,])

expr1s &lt;- expr1[,thecor &gt; 0.8]/1000
expr2s &lt;- expr2[,thecor &gt; 0.8]/1000

# calculate correlations among samples
d &lt;- distee(expr1s, expr2s, d.method="cor")

# pull out distances for samples 24, 92, 44, 66
samp &lt;- c("24", "92", "44", "66")
d[samp, samp]

</code></pre>

<hr>
<h2 id='summary.lineupdist'>Summarize inter-individual distances</h2><span id='topic+summary.lineupdist'></span>

<h3>Description</h3>

<p>Summarize the results of <code><a href="#topic+distee">distee()</a></code> or <code><a href="#topic+disteg">disteg()</a></code>, with
inter-individual distances between two sets of gene expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lineupdist'
summary(
  object,
  cutoff = NULL,
  dropmatches = TRUE,
  reorder = c("alignmatches", "bydistance", "no"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lineupdist_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+distee">distee()</a></code> or <code><a href="#topic+disteg">disteg()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lineupdist_+3A_cutoff">cutoff</code></td>
<td>
<p>(Optional) Cutoff on correlation/distance, with rows in the
results only being kept if the best distance/correlation is above this
cutoff or the self-self result is not missing and is above this cutoff.</p>
</td></tr>
<tr><td><code id="summary.lineupdist_+3A_dropmatches">dropmatches</code></td>
<td>
<p>If TRUE, omit rows for which an individual's best match
is itself.</p>
</td></tr>
<tr><td><code id="summary.lineupdist_+3A_reorder">reorder</code></td>
<td>
<p>If <code>"bydistance"</code>, reorder rows by increasing distance
(or decreasing correlation) to the best match and then by decreasing
distance (or decreasing correlation) to self; if <code>"alignmatches"</code>,
group related errors together; if <code>"no"</code>, leave as is.</p>
</td></tr>
<tr><td><code id="summary.lineupdist_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+print.dataframe">base::print.data.frame()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components: the distances summarized by row and the
distances summarized by column.
</p>
<p>For each individual, we calculate the minimum distance to others,
next-smallest distance, the self-self distance, the mean and SD of the
distances to others, and finally indicate the individual (or individuals)
that is closest.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:broman@wisc.edu">broman@wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulldiag">pulldiag()</a></code>, <code><a href="#topic+omitdiag">omitdiag()</a></code>,
<code><a href="#topic+distee">distee()</a></code>, <code><a href="#topic+disteg">disteg()</a></code>, <code><a href="#topic+plot2dist">plot2dist()</a></code>,
<code><a href="#topic+plot.lineupdist">plot.lineupdist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(expr1, expr2)



# distance as correlation
d &lt;- distee(expr1, expr2, "cor")

# summary of potential problems
summary(d)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
