<!DOCTYPE html><html><head><title>Help for package randtoolbox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {randtoolbox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#randtoolbox-package'>
<p>General remarks on toolbox for pseudo and quasi random number generation</p></a></li>
<li><a href='#auxiliary'><p>Auxiliary functions for 'randtoolbox' package.</p></a></li>
<li><a href='#coll.test'><p>the Collision test</p></a></li>
<li><a href='#coll.test.sparse'><p>the Collision test</p></a></li>
<li><a href='#freq.test'><p>the Frequency test</p></a></li>
<li><a href='#gap.test'><p>the Gap test</p></a></li>
<li><a href='#get.primes'><p>Get primes for quasi random number generation</p></a></li>
<li><a href='#getWELLState'><p>Get the state of a WELL generator implemented in randtoolbox package.</p></a></li>
<li><a href='#order.test'><p>the Order test</p></a></li>
<li><a href='#poker.test'><p>the Poker test</p></a></li>
<li><a href='#pseudoRNG'><p>Toolbox for pseudo and quasi random number generation</p></a></li>
<li><a href='#quasiRNG'><p>Toolbox for quasi random number generation</p></a></li>
<li><a href='#rngWELLScriptR'><p>An implementation of the recurrence of WELL generators in R language</p></a></li>
<li><a href='#runifInterface'><p>Functions for using runif() and rnorm() with randtoolbox generators</p></a></li>
<li><a href='#serial.test'><p>the Serial test</p></a></li>
<li><a href='#soboltestfunctions'><p>Some test functions for Sobol sequences</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolbox for Pseudo and Quasi Random Number Generation and Random
Generator Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>R code by Yohan Chalabi [ctb], Christophe Dutang [aut, cre], Petr Savicky [aut], 
    Diethelm Wuertz [aut]; C code of Knuth-TAOCP RNG by Donald Knuth [aut];
    C code of Torus, Halton and Sobol sequences by Christophe Dutang [aut, cre];
    C code of SFMT algorithm by Makoto Matsumoto [aut], Mutsuo Saito [aut]. </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Dutang &lt;dutangc@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides (1) pseudo random generators - general linear congruential generators, 
    multiple recursive generators and generalized feedback shift register (SF-Mersenne Twister
    algorithm (&lt;<a href="https://doi.org/10.1007%2F978-3-540-74496-2_36">doi:10.1007/978-3-540-74496-2_36</a>&gt;) and WELL (&lt;<a href="https://doi.org/10.1145%2F1132973.1132974">doi:10.1145/1132973.1132974</a>&gt;) 
    generators); (2) quasi random generators - the Torus algorithm, the
    Sobol sequence, the Halton sequence (including the Van der Corput sequence) and (3) some
    generator tests - the gap test, the serial test, the poker test, see, e.g., 
    Gentle (2003) &lt;<a href="https://doi.org/10.1007%2Fb97336">doi:10.1007/b97336</a>&gt;. 
    Take a look at the Distribution task view of types and tests of random number generators.
    The package can be provided without the 'rngWELL' dependency on demand.
    Package in Memoriam of Diethelm and Barbara Wuertz.</td>
</tr>
<tr>
<td>Depends:</td>
<td>rngWELL (&ge; 0.10-1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/rmetrics/">https://r-forge.r-project.org/projects/rmetrics/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-28 13:28:58 UTC; dutang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-28 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='randtoolbox-package'>
General remarks on toolbox for pseudo and quasi random number generation
</h2><span id='topic+randtoolbox-package'></span><span id='topic+randtoolbox'></span>

<h3>Description</h3>

<p>The randtoolbox-package started in 2007 
during a student working group at ISFA (France). From then, it
grew quickly thanks to the contribution of Diethelm Wuertz
and Petr Savicky. It was presented at a Rmetrics 
workshop in 2009 in Meielisalp, Switzerland. 
</p>
<p>This package provides state-of-the-art pseudo RNGs 
for simulations as well as the usual quasi RNGs.
See <code><a href="#topic+pseudoRNG">pseudoRNG</a></code> and <code><a href="#topic+quasiRNG">quasiRNG</a></code>, respectively. 
There are also some RNG tests. 
</p>
<p>We recommend first users to take a look at the vignette 'Quick introduction of randtoolbox',
whereas advanced users whould have a look at the vigentte 'A note on random number generation'.
</p>
<p>The stable version is available on CRAN 
<a href="https://CRAN.R-project.org/package=randtoolbox">https://CRAN.R-project.org/package=randtoolbox</a>,
while the development version is hosted on R-forge in the rmetrics project
at <a href="https://r-forge.r-project.org/projects/rmetrics/">https://r-forge.r-project.org/projects/rmetrics/</a>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> randtoolbox</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> BSD_3_clause + file LICENSE</td>
</tr>
<tr>
 <td style="text-align: left;">
Warning 1: in this version, scrambling is disabled for Sobol sequences
in <code>sobol</code>.
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Christophe Dutang and Petr Savicky.
</p>

<hr>
<h2 id='auxiliary'>Auxiliary functions for 'randtoolbox' package.</h2><span id='topic+auxiliary'></span><span id='topic+stirling'></span><span id='topic+permut'></span>

<h3>Description</h3>

<p>Stirling numbers of the second kind and permutation of positive integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stirling(n)
permut(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxiliary_+3A_n">n</code></td>
<td>
<p>a positive integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stirling</code> computes stirling numbers of second kind i.e.
</p>
<p style="text-align: center;"><code class="reqn">Stirl_n^k = k * Stirl_{n-1}^k + Stirl_{n-1}^{k-1}</code>
</p>

<p>with <code class="reqn">Stirl_n^1 = Stirl_n^n = 1</code>.
e.g. 
</p>

<ul>
<li><p><code class="reqn">n = 0</code>, returns 1
</p>
</li>
<li><p><code class="reqn">n = 1</code>, returns a vector with 0,1
</p>
</li>
<li><p><code class="reqn">n = 2</code>, returns a vector with 0,1,1
</p>
</li>
<li><p><code class="reqn">n = 3</code>, returns a vector with 0,1,3,1
</p>
</li>
<li><p><code class="reqn">n = 4</code>, returns a vector with 0,1,7,6,1...
</p>
</li></ul>

<p>Go to wikipedia for more details.
</p>
<p><code>permut</code> compute permutation of <code class="reqn">{1, ..., n}</code> and store it
in a matrix.
e.g. 
</p>

<ul>
<li><p><code class="reqn">n=1</code>, returns a matrix with </p>

<table>
<tr>
 <td style="text-align: center;">1</td>
</tr>

</table>

</li>
<li><p><code class="reqn">n=2</code>, returns a matrix with </p>

<table>
<tr>
 <td style="text-align: center;">
	1 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
	2 </td><td style="text-align: center;"> 1 </td>
</tr>

</table>

</li>
<li><p><code class="reqn">n=3</code> returns a matrix with </p>

<table>
<tr>
 <td style="text-align: center;">
	3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2</td>
</tr>
<tr>
 <td style="text-align: center;">
	3 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 1</td>
</tr>
<tr>
 <td style="text-align: center;">
	1 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 2</td>
</tr>
<tr>
 <td style="text-align: center;">
	2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 1</td>
</tr>
<tr>
 <td style="text-align: center;">
	1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3</td>
</tr>
<tr>
 <td style="text-align: center;">
	2 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 3</td>
</tr>

</table>

</li></ul>



<h3>Value</h3>

<p>a vector with stirling numbers.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+choose">choose</a></code> for combination numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# should be 1
stirling(0)

#  should be 0,1,7,6,1
stirling(4)
</code></pre>

<hr>
<h2 id='coll.test'>the Collision test</h2><span id='topic+coll.test'></span>

<h3>Description</h3>

<p>The Collision test for testing random number generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coll.test(rand, lenSample = 2^14, segments = 2^10, tdim = 2, 
nbSample = 1000, echo = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coll.test_+3A_rand">rand</code></td>
<td>
<p>a function generating random numbers. its first argument must be
the 'number of observation' argument as in <code>runif</code>.</p>
</td></tr>
<tr><td><code id="coll.test_+3A_lensample">lenSample</code></td>
<td>
<p>numeric for the length of generated samples.</p>
</td></tr>
<tr><td><code id="coll.test_+3A_segments">segments</code></td>
<td>
<p>numeric for the number of segments to which the interval <code>[0, 1]</code> is split.</p>
</td></tr>
<tr><td><code id="coll.test_+3A_tdim">tdim</code></td>
<td>
<p>numeric for the length of the disjoint t-tuples.</p>
</td></tr>
<tr><td><code id="coll.test_+3A_nbsample">nbSample</code></td>
<td>
<p>numeric for the overall sample number.</p>
</td></tr>
<tr><td><code id="coll.test_+3A_echo">echo</code></td>
<td>
<p>logical to plot detailed results, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="coll.test_+3A_...">...</code></td>
<td>
<p>further arguments to pass to function rand</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider outputs of multiple calls to a random number generator <code>rand</code>.  
Let us denote by <code class="reqn">n</code> the length of samples (i.e. <code>lenSample</code> argument),
<code class="reqn">k</code> the number of cells (i.e. <code>nbCell</code> argument) and
<code class="reqn">m</code> the number of samples (i.e. <code>nbSample</code> argument).
</p>
<p>A collision is defined as
when a random number falls in a cell where there are
already random numbers. Let us note <code class="reqn">C</code> the number of collisions
</p>
<p>The distribution of collision number <code class="reqn">C</code> is given by 
</p>
<p style="text-align: center;"><code class="reqn">
            P(C = c) = \prod_{i=0}^{n-c-1}\frac{k-i}{k} \frac{1}{k^c} {}_2S_n^{n-c}, 
        </code>
</p>

<p>where <code class="reqn">{}_2S_n^k</code> denotes the Stirling number of the second kind
and <code class="reqn">c=0,\dots,n-1</code>.
</p>
<p>But we cannot use this formula for large <code class="reqn">n</code> since the Stirling number
need <code class="reqn">O(n\log(n))</code> time to be computed. We use
a Gaussian approximation if 
<code class="reqn">\frac{n}{k}&gt;\frac{1}{32}</code> and <code class="reqn">n\geq 2^8</code>,
a Poisson approximation if <code class="reqn">\frac{n}{k} &lt; \frac{1}{32}</code> and the exact formula
otherwise.
</p>
<p>Finally we compute <code class="reqn">m</code> samples of random numbers, on which we calculate
the number of collisions. Then we are able to compute a chi-squared statistic.
</p>


<h3>Value</h3>

<p>a list with the following components :
</p>
<p><code>statistic</code>	 the value of the chi-squared statistic.
</p>
<p><code>p.value</code>	 	 the p-value of the test.
</p>
<p><code>observed</code>	 the observed counts.
</p>
<p><code>expected</code>	 the expected counts under the null hypothesis.
</p>
<p><code>residuals</code>	 the Pearson residuals, (observed - expected) / sqrt(expected).
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang.
</p>


<h3>References</h3>

<p>Planchet F., Jacquemin J. (2003), <em>L'utilisation de methodes de 
simulation en assurance</em>. Bulletin Francais d'Actuariat, vol. 6, 11, 3-69. (available online)
</p>
<p>L'Ecuyer P. (2001), <em>Software for uniform random number
generation distinguishing the good and the bad</em>. Proceedings of the 2001 
Winter Simulation Conference. <a href="https://doi.org/10.1109/WSC.2001.977250">doi:10.1109/WSC.2001.977250</a>
</p>
<p>L'Ecuyer P. (2007), <em>Test U01: a C library for empirical testing of 
random number generators.</em> ACM Trans. on Mathematical 
Software 33(4), 22. <a href="https://doi.org/10.1145/1268776.1268777">doi:10.1145/1268776.1268777</a>
</p>


<h3>See Also</h3>

<p>other tests of this package <code><a href="#topic+coll.test.sparse">coll.test.sparse</a></code>, <code><a href="#topic+freq.test">freq.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>, <code><a href="#topic+poker.test">poker.test</a></code>,
<code><a href="#topic+order.test">order.test</a></code> and <code><a href="#topic+gap.test">gap.test</a></code>
</p>
<p><code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov Smirnov test and <code><a href="stats.html#topic+acf">acf</a></code> for
the autocorrelation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) poisson approximation
#
coll.test(runif, 2^7, 2^10, 1, 100)

# (2) exact distribution
#
coll.test(SFMT, 2^7, 2^10, 1, 100)

</code></pre>

<hr>
<h2 id='coll.test.sparse'>the Collision test</h2><span id='topic+coll.test.sparse'></span>

<h3>Description</h3>

<p>The Collision test for testing random number generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coll.test.sparse(rand, lenSample = 2^14, segments = 2^10, tdim = 2, 
nbSample = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coll.test.sparse_+3A_rand">rand</code></td>
<td>
<p>a function generating random numbers. its first argument must be
the 'number of observation' argument as in <code>runif</code>.</p>
</td></tr>
<tr><td><code id="coll.test.sparse_+3A_lensample">lenSample</code></td>
<td>
<p>numeric for the length of generated samples.</p>
</td></tr>
<tr><td><code id="coll.test.sparse_+3A_segments">segments</code></td>
<td>
<p>numeric for the number of segments to which the interval <code>[0, 1]</code> is split.</p>
</td></tr>
<tr><td><code id="coll.test.sparse_+3A_tdim">tdim</code></td>
<td>
<p>numeric for the length of the disjoint t-tuples.</p>
</td></tr>
<tr><td><code id="coll.test.sparse_+3A_nbsample">nbSample</code></td>
<td>
<p>numeric for the number of repetitions of the test.</p>
</td></tr>
<tr><td><code id="coll.test.sparse_+3A_...">...</code></td>
<td>
<p>further arguments to pass to function rand</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider outputs of multiple calls to a random number generator <code>rand</code>.  
Let us denote by <code class="reqn">n</code> the length of samples (i.e. <code>lenSample</code> argument),
<code class="reqn">k</code> the number of cells (i.e. <code>nbCell</code> argument).
</p>
<p>A collision is defined as
when a random number falls in a cell where there are
already random numbers. Let us note <code class="reqn">C</code> the number of collisions
</p>
<p>The distribution of collision number <code class="reqn">C</code> is given by 
</p>
<p style="text-align: center;"><code class="reqn">
            P(C = c) = \prod_{i=0}^{n-c-1}\frac{k-i}{k} \frac{1}{k^c} {}_2S_n^{n-c}, 
        </code>
</p>

<p>where <code class="reqn">{}_2S_n^k</code> denotes the Stirling number of the second kind
and <code class="reqn">c=0,\dots,n-1</code>.
</p>
<p>This formula cannot be used for large <code class="reqn">n</code> since the Stirling number
need <code class="reqn">O(n\log(n))</code> time to be computed. We use
a Poisson approximation if <code class="reqn">\frac{n}{k} &lt; \frac{1}{32}</code> and
the exact formula otherwise.
</p>
<p>The test is repeated <code>nbSample</code> times and the result of each
repetition forms a row in the output table. 
</p>


<h3>Value</h3>

<p>A data frame with <code>nbSample</code> rows and the following columns.
</p>
<p><code>observed</code>	 the observed counts.
</p>
<p><code>p.value</code>   the p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang, Petr Savicky.
</p>


<h3>References</h3>

<p>P. L'Ecuyer, R. Simard, S. Wegenkittl, Sparse serial tests
of uniformity for random number generators.
SIAM Journal on Scientific Computing, 24, 2 (2002), 652-668. 
<a href="https://doi.org/10.1137/S1064827598349033">doi:10.1137/S1064827598349033</a>
</p>
<p>L'Ecuyer P. (2007), Test U01: a C library for empirical testing of 
random number generators. ACM Trans. on Mathematical 
Software 33(4), 22. <a href="https://doi.org/10.1145/1268776.1268777">doi:10.1145/1268776.1268777</a>
</p>


<h3>See Also</h3>

<p>other tests of this package <code><a href="#topic+coll.test">coll.test</a></code>, <code><a href="#topic+freq.test">freq.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>, <code><a href="#topic+poker.test">poker.test</a></code>,
<code><a href="#topic+order.test">order.test</a></code> and <code><a href="#topic+gap.test">gap.test</a></code>
</p>
<p><code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov Smirnov test and <code><a href="stats.html#topic+acf">acf</a></code> for
the autocorrelation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) poisson approximation
#
coll.test.sparse(runif)

# (2) exact distribution
#
coll.test.sparse(SFMT, lenSample=2^7, segments=2^5, tdim=2, nbSample=10)

## Not run: 
#A generator with too uniform distribution (too small number of collisions)
#produces p-values close to 1
set.generator(name="congruRand", mod="2147483647", mult="742938285", incr="0", seed=1)
coll.test.sparse(runif, lenSample=300000, segments=50000, tdim=2)

#Park-Miller generator has too many collisions and produces small p-values
set.generator(name="congruRand", mod="2147483647", mult="16807", incr="0", seed=1)
coll.test.sparse(runif, lenSample=300000, segments=50000, tdim=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='freq.test'>the Frequency test</h2><span id='topic+freq.test'></span>

<h3>Description</h3>

<p>The Frequency test for testing random number generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq.test(u, seq = 0:15, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq.test_+3A_u">u</code></td>
<td>
<p>sample of random numbers in ]0,1[.</p>
</td></tr>
<tr><td><code id="freq.test_+3A_echo">echo</code></td>
<td>
<p>logical to plot detailed results, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="freq.test_+3A_seq">seq</code></td>
<td>
<p>a vector of contiguous integers, default <code>0:15</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider a vector <code>u</code>, realisation of i.i.d. uniform random
variables <code class="reqn">U_1, \dots, U_n</code>.
</p>
<p>The frequency test works on a serie <code>seq</code> of ordered contiguous integers 
(<code class="reqn">s_1,\dots,s_d</code>), where <code class="reqn">s_j\in  Z\!\!Z</code>. From the
sample <code>u</code>, we compute observed integers as
</p>
<p style="text-align: center;"><code class="reqn">d_i = \lfloor u_i * ( s_d + 1 ) + s_1 \rfloor,
		  </code>
</p>
 
<p>(i.e. <code class="reqn">d_i</code> are uniformely distributed in
<code class="reqn">\{s_1,\dots,s_d\}</code>). The expected number of integers equals to 
<code class="reqn">j</code> is <code class="reqn">m= \frac{1}{s_d - s_1+1}\times n</code>. Finally, the
chi-squared statistic is 
</p>
<p style="text-align: center;"><code class="reqn"> S = \sum_{j=1}^d \frac{(card(d_i=s_j) - m)^2}{m}.
		</code>
</p>



<h3>Value</h3>

<p>a list with the following components :
</p>
<p><code>statistic</code>	 the value of the chi-squared statistic.
</p>
<p><code>p.value</code>	 	 the p-value of the test.
</p>
<p><code>observed</code>	 the observed counts.
</p>
<p><code>expected</code>	 the expected counts under the null hypothesis.
</p>
<p><code>residuals</code>	 the Pearson residuals, (observed - expected) / sqrt(expected).
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang.
</p>


<h3>References</h3>

<p>Planchet F., Jacquemin J. (2003), <em>L'utilisation de methodes de 
simulation en assurance</em>. Bulletin Francais d'Actuariat, vol. 6, 11, 3-69. (available online)
</p>
<p>L'Ecuyer P. (2001), <em>Software for uniform random number
generation distinguishing the good and the bad</em>. Proceedings of the 2001 
Winter Simulation Conference. <a href="https://doi.org/10.1109/WSC.2001.977250">doi:10.1109/WSC.2001.977250</a>
</p>
<p>L'Ecuyer P. (2007), <em>Test U01: a C library for empirical testing of 
random number generators.</em> ACM Trans. on Mathematical 
Software 33(4), 22. <a href="https://doi.org/10.1145/1268776.1268777">doi:10.1145/1268776.1268777</a>
</p>


<h3>See Also</h3>

<p>other tests of this package <code><a href="#topic+gap.test">gap.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>, <code><a href="#topic+poker.test">poker.test</a></code>,
<code><a href="#topic+order.test">order.test</a></code> and <code><a href="#topic+coll.test">coll.test</a></code>
</p>
<p><code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov Smirnov test and <code><a href="stats.html#topic+acf">acf</a></code> for
the autocorrelation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) 
#
freq.test(runif(1000))
print( freq.test( runif(10000), echo=FALSE) )

# (2) 
#
freq.test(runif(1000), 1:4)

freq.test(runif(1000), 10:40)

</code></pre>

<hr>
<h2 id='gap.test'>the Gap test</h2><span id='topic+gap.test'></span>

<h3>Description</h3>

<p>The Gap test for testing random number generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gap.test(u, lower = 0, upper = 1/2, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gap.test_+3A_u">u</code></td>
<td>
<p>sample of random numbers in ]0,1[.</p>
</td></tr>
<tr><td><code id="gap.test_+3A_lower">lower</code></td>
<td>
<p>numeric for the lower bound, default <code>0</code>.</p>
</td></tr>
<tr><td><code id="gap.test_+3A_upper">upper</code></td>
<td>
<p>numeric for the upper bound, default <code>1/2</code>.</p>
</td></tr>
<tr><td><code id="gap.test_+3A_echo">echo</code></td>
<td>
<p>logical to plot detailed results, default <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider a vector <code>u</code>, realisation of i.i.d. uniform random
variables <code class="reqn">U_1, \dots, U_n</code>.
</p>
<p>The gap test works on the 'gap' variables defined as
</p>
<p style="text-align: center;"><code class="reqn"> G_ i = 
	       	\left\{  
		\begin{array}{cl}
	       	 1 &amp; \textrm{if~} lower \leq U_i \leq upper\\
		 0 &amp; \textrm{otherwise}\\
		 \end{array}
		 \right.
		</code>
</p>

<p>Let <code class="reqn">p</code> the probability that <code class="reqn">G_i</code> equals to one.
Then we compute the length of zero gaps and denote by <code class="reqn">n_j</code> the number
of zero gaps of length <code class="reqn">j</code>. The chi-squared statistic is given by
</p>
<p style="text-align: center;"><code class="reqn"> S = \sum_{j=1}^m \frac{(n_j - n p_j)^2}{n p_j},
		</code>
</p>

<p>where <code class="reqn">p_j</code> stands for the probability the length of zero gaps equals 
to <code class="reqn">j</code> (<code class="reqn"> (1-p)^2 p^j
	   	   </code>) and <code class="reqn">m</code> the max number of lengths (at least
<code class="reqn">\left\lfloor \frac{ \log( 10^{-1} ) - 2\log(1- p)-log(n) }{ \log( p )} \right\rfloor
		</code> ).
</p>


<h3>Value</h3>

<p>a list with the following components :
</p>
<p><code>statistic</code>	 the value of the chi-squared statistic.
</p>
<p><code>p.value</code>	 	 the p-value of the test.
</p>
<p><code>observed</code>	 the observed counts.
</p>
<p><code>expected</code>	 the expected counts under the null hypothesis.
</p>
<p><code>residuals</code>	 the Pearson residuals, (observed - expected) / sqrt(expected).
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang.
</p>


<h3>References</h3>

<p>Planchet F., Jacquemin J. (2003), <em>L'utilisation de methodes de 
simulation en assurance</em>. Bulletin Francais d'Actuariat, vol. 6, 11, 3-69. (available online)
</p>
<p>L'Ecuyer P. (2001), <em>Software for uniform random number
generation distinguishing the good and the bad</em>. Proceedings of the 2001 
Winter Simulation Conference. <a href="https://doi.org/10.1109/WSC.2001.977250">doi:10.1109/WSC.2001.977250</a>
</p>
<p>L'Ecuyer P. (2007), <em>Test U01: a C library for empirical testing of 
random number generators.</em> ACM Trans. on Mathematical 
Software 33(4), 22. <a href="https://doi.org/10.1145/1268776.1268777">doi:10.1145/1268776.1268777</a>
</p>


<h3>See Also</h3>

<p>other tests of this package <code><a href="#topic+freq.test">freq.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>, <code><a href="#topic+poker.test">poker.test</a></code>,
<code><a href="#topic+order.test">order.test</a></code> and <code><a href="#topic+coll.test">coll.test</a></code>
</p>
<p><code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov Smirnov test and <code><a href="stats.html#topic+acf">acf</a></code> for
the autocorrelation function. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) 
#
gap.test(runif(1000))
print( gap.test( runif(1000000), echo=FALSE ) )

# (2) 
#
gap.test(runif(1000), 1/3, 2/3)


</code></pre>

<hr>
<h2 id='get.primes'>Get primes for quasi random number generation</h2><span id='topic+get.primes'></span>

<h3>Description</h3>

<p>Provides a vector of a specified number of smallest primes from the
internal table of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.primes(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.primes_+3A_n">n</code></td>
<td>
<p>The required number of primes. Should be at most 100 000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package contains an internal table of the smallest 100 000 primes,
which may be used in <code>torus</code> algorithm.
</p>


<h3>Value</h3>

<p>Vector of <code>min(n, 100000)</code> smallest primes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+torus">torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- get.primes(20)
torus(5,dim=10,prime=p[11:20])
</code></pre>

<hr>
<h2 id='getWELLState'>Get the state of a WELL generator implemented in randtoolbox package.</h2><span id='topic+getWELLState'></span>

<h3>Description</h3>

<p>Get the state of a WELL generator implemented in randtoolbox package
to be used in function <code>rngWELLScriptR()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
  getWELLState()
</code></pre>


<h3>Value</h3>

<p>A 0,1-matrix, whose columns represent 32-bit integers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rngWELLScriptR">rngWELLScriptR</a></code>
</p>

<hr>
<h2 id='order.test'>the Order test</h2><span id='topic+order.test'></span>

<h3>Description</h3>

<p>The Order test for testing random number generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.test(u, d = 3, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.test_+3A_u">u</code></td>
<td>
<p>sample of random numbers in ]0,1[.</p>
</td></tr>
<tr><td><code id="order.test_+3A_echo">echo</code></td>
<td>
<p>logical to plot detailed results, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="order.test_+3A_d">d</code></td>
<td>
<p>a numeric for the dimension, see details. When necessary 
we assume that <code>d</code> is a multiple of the length of <code>u</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider a vector <code>u</code>, realisation of i.i.d. uniform random
variables <code class="reqn">U_1, \dots, U_n</code>.
</p>
<p>The Order test works on a sequence of d-uplets (<code class="reqn">x,y,z</code> when
<code>d=3</code>) of uniform i.i.d. 
random variables. The triplet is build from the vector <code class="reqn">u</code>. The number of 
permutation among the components of a triplet is <code class="reqn">3!=6</code>, i.e. <code class="reqn">x&lt;y&lt;z</code>,
<code class="reqn">x&lt;z&lt;y</code>, <code class="reqn">y&lt;x&lt;z</code>, <code class="reqn">y&lt;z&lt;x</code>, <code class="reqn">z&lt;x&lt;y</code> and <code class="reqn">z&lt;y&lt;x</code>. The
Marsaglia test computes the empirical of the different permutations as well
as the theoretical one <code class="reqn">n/6</code> where <code class="reqn">n</code> is the number of triplets.
Finally the chi-squared statistic is 
</p>
<p style="text-align: center;"><code class="reqn"> S = \sum_{j=0}^{6} \frac{n_j - n/6)^2}{n/6}.
		</code>
</p>



<h3>Value</h3>

<p>a list with the following components :
</p>
<p><code>statistic</code>	 the value of the chi-squared statistic.
</p>
<p><code>p.value</code>	 	 the p-value of the test.
</p>
<p><code>observed</code>	 the observed counts.
</p>
<p><code>expected</code>	 the expected counts under the null hypothesis.
</p>
<p><code>residuals</code>	 the Pearson residuals, (observed - expected) / sqrt(expected).
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang.
</p>


<h3>References</h3>

<p>Planchet F., Jacquemin J. (2003), <em>L'utilisation de methodes de 
simulation en assurance</em>. Bulletin Francais d'Actuariat, vol. 6, 11, 3-69. (available online)
</p>
<p>L'Ecuyer P. (2001), <em>Software for uniform random number
generation distinguishing the good and the bad</em>. Proceedings of the 2001 
Winter Simulation Conference. <a href="https://doi.org/10.1109/WSC.2001.977250">doi:10.1109/WSC.2001.977250</a>
</p>
<p>L'Ecuyer P. (2007), <em>Test U01: a C library for empirical testing of 
random number generators.</em> ACM Trans. on Mathematical 
Software 33(4), 22. <a href="https://doi.org/10.1145/1268776.1268777">doi:10.1145/1268776.1268777</a>
</p>


<h3>See Also</h3>

<p>other tests of this package <code><a href="#topic+freq.test">freq.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>, <code><a href="#topic+poker.test">poker.test</a></code>,
<code><a href="#topic+gap.test">gap.test</a></code> and <code><a href="#topic+coll.test">coll.test</a></code>
</p>
<p><code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov Smirnov test and <code><a href="stats.html#topic+acf">acf</a></code> for
the autocorrelation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) mersenne twister vs torus
#
order.test(runif(6000))
order.test(torus(6000))

# (2) 
#
order.test(runif(4000), 4)
order.test(torus(4000), 4)

# (3) 
#
order.test(runif(5000), 5)
order.test(torus(5000), 5)


</code></pre>

<hr>
<h2 id='poker.test'>the Poker test</h2><span id='topic+poker.test'></span>

<h3>Description</h3>

<p>The Poker test for testing random number generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poker.test(u , nbcard = 5, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poker.test_+3A_u">u</code></td>
<td>
<p>sample of random numbers in ]0,1[.</p>
</td></tr>
<tr><td><code id="poker.test_+3A_echo">echo</code></td>
<td>
<p>logical to plot detailed results, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="poker.test_+3A_nbcard">nbcard</code></td>
<td>
<p>a numeric for the number of cards,  
we assume that the length of <code>u</code> is a multiple of <code>nbcard</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider a vector <code>u</code>, realisation of i.i.d. uniform random
variables <code class="reqn">U_1, \dots, U_n</code>.
</p>
<p>Let us note <code class="reqn">k</code> the card number (i.e. <code>nbcard</code>).
The poker test computes a serie of 'hands' in <code class="reqn">\{0, \dots, k-1\}</code>
from the sample <code class="reqn">h_i = \lfloor u_i d\rfloor</code> (<code>u</code> must have a length dividable by <code class="reqn">k</code>). Let
<code class="reqn">n_j</code> be the number of 'hands' with (exactly) <code class="reqn">j</code> different cards. The
probability is </p>
<p style="text-align: center;"><code class="reqn"> p_j = \frac{k!}{k^k (k-j)!* S_k^j} 
	* (\frac{j}{k})^(k-j),  </code>
</p>

<p>where <code class="reqn">S_k^j</code> denotes the Stirling numbers of the second kind. Finally the 
chi-squared statistic is 
</p>
<p style="text-align: center;"><code class="reqn"> S = \sum_{j=0}^{k-1} \frac{n_j - np_j/k)^2}{np_j/k}.
		</code>
</p>



<h3>Value</h3>

<p>a list with the following components :
</p>
<p><code>statistic</code>	 the value of the chi-squared statistic.
</p>
<p><code>p.value</code>	 	 the p-value of the test.
</p>
<p><code>observed</code>	 the observed counts.
</p>
<p><code>expected</code>	 the expected counts under the null hypothesis.
</p>
<p><code>residuals</code>	 the Pearson residuals, (observed - expected) / sqrt(expected).
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang.
</p>


<h3>References</h3>

<p>Planchet F., Jacquemin J. (2003), <em>L'utilisation de methodes de 
simulation en assurance</em>. Bulletin Francais d'Actuariat, vol. 6, 11, 3-69. (available online)
</p>
<p>L'Ecuyer P. (2001), <em>Software for uniform random number
generation distinguishing the good and the bad</em>. Proceedings of the 2001 
Winter Simulation Conference. <a href="https://doi.org/10.1109/WSC.2001.977250">doi:10.1109/WSC.2001.977250</a>
</p>
<p>L'Ecuyer P. (2007), <em>Test U01: a C library for empirical testing of 
random number generators.</em> ACM Trans. on Mathematical 
Software 33(4), 22. <a href="https://doi.org/10.1145/1268776.1268777">doi:10.1145/1268776.1268777</a>
</p>


<h3>See Also</h3>

<p>other tests of this package <code><a href="#topic+freq.test">freq.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>, <code><a href="#topic+gap.test">gap.test</a></code>,
<code><a href="#topic+order.test">order.test</a></code> and <code><a href="#topic+coll.test">coll.test</a></code>
</p>
<p><code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov Smirnov test and <code><a href="stats.html#topic+acf">acf</a></code> for
the autocorrelation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) hands of 5 'cards'
#
poker.test(runif(50000))

# (2) hands of 4 'cards'
#
poker.test(runif(40000), 4)

# (3) hands of 42 'cards'
#
poker.test(runif(420000), 42)

</code></pre>

<hr>
<h2 id='pseudoRNG'>Toolbox for pseudo and quasi random number generation</h2><span id='topic+pseudoRNG'></span><span id='topic+congruRand'></span><span id='topic+SFMT'></span><span id='topic+WELL'></span><span id='topic+knuthTAOCP'></span><span id='topic+setSeed'></span><span id='topic+pseudo.randtoolbox'></span>

<h3>Description</h3>

<p>General linear congruential generators such as Park Miller sequence,
generalized feedback shift register such as SF-Mersenne Twister algorithm
and WELL generator.
</p>
<p>The list of supported generators consists of generators available via
direct functions and generators available via <code>set.generator()</code> and
<code>runif()</code> interface. Most of the generators belong to both these groups,
but some generators are only available directly (SFMT) and some only via
<code>runif()</code> interface (Mersenne Twister 2002). This help page describes
the list of all the supported generators and the functions for the direct
access to those, which are available in this way. See <code>set.generator()</code>
for the generators available via <code>runif()</code> interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruRand(n, dim = 1, mod = 2^31-1, mult = 16807, incr = 0, echo)
SFMT(n, dim = 1, mexp = 19937, usepset = TRUE, withtorus = FALSE, 
usetime = FALSE)
WELL(n, dim = 1, order = 512, temper = FALSE, version = "a")
knuthTAOCP(n, dim = 1)
setSeed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoRNG_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, 
the length is taken to be the required number.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_dim">dim</code></td>
<td>
<p>dimension of observations (must be &lt;=100 000, default 1).</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as a positive integer for the seed. e.g.
append your day, your month and your year of birth.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_mod">mod</code></td>
<td>
<p>an integer defining the modulus of the linear congruential generator.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_mult">mult</code></td>
<td>
<p>an integer defining the multiplier of the linear congruential generator.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_incr">incr</code></td>
<td>
<p>an integer defining the increment of the linear congruential generator.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_echo">echo</code></td>
<td>
<p>a logical to plot the seed while computing the sequence.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_mexp">mexp</code></td>
<td>
<p>an integer for the Mersenne exponent of SFMT algorithm. See details</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_withtorus">withtorus</code></td>
<td>
<p>a numeric in ]0,1] defining the proportion of the torus
sequence appended to the SFMT sequence; 
or a logical equals to FALSE (default).</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_usepset">usepset</code></td>
<td>
<p>a logical to use a set of 12 parameters set for SFMT. default TRUE.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_usetime">usetime</code></td>
<td>
<p>a logical to use the machine time to start the Torus sequence, 
default TRUE. if FALSE, the Torus sequence start from the first term.</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_order">order</code></td>
<td>
<p>a positive integer for the order of the characteristic polynomial. see details</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_temper">temper</code></td>
<td>
<p>a logical if you want to do a tempering stage. see details</p>
</td></tr>
<tr><td><code id="pseudoRNG_+3A_version">version</code></td>
<td>
<p>a character either 'a' or 'b'. see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The currently available generator are given below.
</p>

<dl>
<dt><b>Linear congruential generators:</b></dt><dd>	
<p>The <code class="reqn">k</code>th term of a linear congruential generator is defined as
</p>
<p style="text-align: center;"><code class="reqn">u_k = \frac{ ( a * u_{k-1} + c ) \textrm{~mod~} m }{m}</code>
</p>

<p>where <code class="reqn">a</code> denotes the multiplier, <code class="reqn">c</code> the increment and <code class="reqn">m</code> 
the modulus, with the constraint <code class="reqn">0 &lt;= a &lt; m </code> and <code class="reqn">0 &lt;= c &lt; m </code>.
The default setting is the Park Miller sequence with <code class="reqn">a=16807</code>, 
<code class="reqn">m=2^31-1</code> and <code class="reqn">c=0</code>.</p>
</dd>
<dt><b>Knuth TAOCP 2002 (double version):</b></dt><dd>
<p>The Knuth-TACOP-2002 is a Fibonnaci-lagged 
generator invented by Knuth(2002), based on the
following recurrence.
</p>
<p style="text-align: center;"><code class="reqn">x_n = (x_{n-37} + x_{n-100}) \textrm{~mod~} 2^{30},</code>
</p>
	
<p>In R, there is the integer version of this generator.	
</p>
<p>All the C code for this generator called <code>RANARRAY</code> by Knuth is the code of 
D. Knuth (cf. Knuth's webpage)
except some C code, we add, to <em>interface</em> with R.</p>
</dd>
<dt><b>Mersenne Twister 2002 generator:</b></dt><dd>
<p>The generator suggested by Makoto Matsumoto and Takuji Nishimura with
the improved initialization from 2002. See Matsumoto's webpage
for more information on the generator itself. This generator is available
only via <code>set.generator()</code> and <code>runif()</code> interface. Mersenne Twister
generator used in base R is the same generator (the recurrence), but with
a different initialization and the output transformation. The implementation
included in randtoolbox allows to generate the same random numbers as
in Matlab, see examples in <code>set.generator()</code>.
</p>
</dd>
<dt><b>SF Mersenne-Twister algorithm:</b></dt><dd>
<p><code>SFMT</code> function implements the SIMD-oriented Fast Mersenne Twister algorithm
(cf. Matsumoto's webpage).	
The SFMT generator has a period of length <code class="reqn">2^m-1</code> where <code class="reqn">m</code> is a
Mersenne exponent. In the function <code>SFMT</code>, <code class="reqn">m</code> is given through
<code>mexp</code> argument. By default it is 19937 like the &rdquo;old&rdquo; MT algorithm.
The possible values for the Mersenne exponent are 607, 1279, 2281, 4253, 
11213, 19937, 44497, 86243, 132049, 216091. 
</p>
<p>There are numerous parameters 
for the SFMT algorithm (see the article for details). By default, we use
a different set of parameters (among 32 sets) 
at <em>each call</em> of <code>SFMT</code> (<code>usepset=TRUE</code>).
The user can use a fixed set of parameters with <code>usepset=FALSE</code>. Let us
note there is for the moment just <em>one</em> set of parameters for 44497, 86243, 132049, 
216091 mersenne exponent.
Sets of parameters can be found in appendix of the vignette. 
</p>
<p>The use of different parameter sets is motivated by the following 
citation of Matsumoto and Saito on this topic :
</p>
<p>&quot;<em>Using one same pesudorandom number generator for generating multiple independent
streams by changing the initial values may cause a problem (with
negligibly small probability). To avoid the problem, using
diffrent parameters for each generation is prefered. 
See Matsumoto M. and Nishimura T. (1998) for detailed information.</em>&quot;
</p>
<p>All the C code for SFMT algorithm used in this 
package is the code of M. Matsumoto and M. Saito (cf. Matsumoto's webpage), except we add
some C code to <em>interface</em> with R. Streaming SIMD Extensions 2 (SSE2) 
operations are not yet supported.</p>
</dd>
<dt><b>WELL generator:</b></dt><dd>
<p>The WELL (which stands for Well Equidistributed Long-period Linear) is in a sentence
a generator with better equidistribution than Mersenne Twister algorithm but this
gain of quality has to be paid by a slight higher cost of time. 
See Panneton et al. (2006) for	details. 
</p>
<p>The <code>order</code> argument of <code>WELL</code>
generator is the order of the characteristic polynomial, which is denoted by <code class="reqn">k</code> in 
Paneton F., L'Ecuyer P. and Matsumoto M. (2006). Possible values for <code>order</code> 	
are 512, 521, 607, 1024 where no tempering are needed (thus possible).
Order can also be 800, 19937, 21071, 23209, 44497 where a tempering stage
is possible through the <code>temper</code> argument. 
Furthermore a possible 'b' version of WELL RNGs are possible for the 
following order 521, 607, 1024, 800, 19937, 23209 with the <code>version</code>
argument.
</p>
<p>All the C code for WELL generator used in this 
package is the code of P. L'Ecuyer (cf. L'Ecuyer's webpage), except
some C code, we add, to <em>interface</em> with R.</p>
</dd>
<dt><b>Set the seed:</b></dt><dd>
<p>The function <code>setSeed</code> is similar to the function <code>set.seed</code> in R. It sets
the seed to the one given by the user. Do not use a seed with too few ones in its
binary representation. Generally, we append our day, our month and our year of birth or
append a day, a month and a year. We recall by default with use the machine time
to set the seed except for quasi random number generation.
</p>
</dd>
<dt><b>Set the generator:</b></dt><dd>
<p>Some of the generators are available using <code>runif()</code> interface. See
<code>set.generator()</code> for more information.</p>
</dd>
</dl>

<p>See the pdf vignette for details.
</p>


<h3>Value</h3>

<p><code>SFMT</code>, <code>WELL</code>, <code>congruRand</code> and <code>knuthTAOCP</code> generate random variables in ]0,1[,  [0,1[ and [0,1[ respectively. It returns a <code class="reqn">n</code>x<code class="reqn">dim</code> matrix, when <code>dim</code>&gt;1 otherwise a vector of length <code>n</code>.
</p>
<p><code>congruRand</code> may raise an error code if parameters are not correctly specified: 
<code>-1</code> if the multiplier is zero;
<code>-2</code> if the multiplier is greater or equal than the modulus;
<code>-3</code> if the increment is greater or equal than the modulus;
<code>-4</code> if the multiplier times the modulus minus 1 is greater than <code>2^64-1</code> minus the increment;
<code>-5</code> if the seed is greater or equal than the modulus.
</p>
<p><code>setSeed</code> sets the seed of the <code>randtoolbox</code> package 
(i.e. both for the <code>knuthTAOCP</code>, <code>SFMT</code>, <code>WELL</code> and <code>congruRand</code> functions).
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang and Petr Savicky
</p>


<h3>References</h3>

<p>Knuth D. (1997), <em>The Art of Computer Programming V2 Seminumerical Algorithms</em>, Third Edition, Massachusetts: Addison-Wesley.
</p>
<p>Matsumoto M. and Nishimura T. (1998), <em>Dynamic Creation of Pseudorandom Number Generators</em>,
Monte Carlo and Quasi-Monte Carlo Methods, Springer, pp 56&ndash;69. <a href="https://doi.org/10.1007/978-3-642-59657-5_3">doi:10.1007/978-3-642-59657-5_3</a>
</p>
<p>Matsumoto M., Saito M. (2008), <em>SIMD-oriented Fast Mersenne Twister: a 128-bit Pseudorandom Number Generator</em>. <a href="https://doi.org/10.1007/978-3-540-74496-2_36">doi:10.1007/978-3-540-74496-2_36</a>
</p>
<p>Paneton F., L'Ecuyer P. and Matsumoto M. (2006), <em>Improved Long-Period Generators 
Based on Linear Recurrences Modulo 2</em>, ACM Transactions on Mathematical Software. 
<a href="https://doi.org/10.1145/1132973.1132974">doi:10.1145/1132973.1132974</a>
</p>
<p>Park S. K., Miller K. W. (1988), <em>Random number generators: good
ones are hard to find</em>. Association for Computing Machinery, vol. 31, 10, pp 1192-2001. 
<a href="https://doi.org/10.1145/63039.63042">doi:10.1145/63039.63042</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> for what is done in R about random number generation and <code><a href="#topic+runifInterface">runifInterface</a></code> for the <code>runif</code> interface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(rngWELL)

# (1) the Park Miller sequence
#

# Park Miller sequence, i.e. mod = 2^31-1, mult = 16807, incr=0
# the first 10 seeds used in Park Miller sequence
# 16807          1
# 282475249          2
# 1622650073          3
# 984943658          4
# 1144108930          5
# 470211272          6
# 101027544          7
# 1457850878          8
# 1458777923          9
# 2007237709         10
setSeed(1)
congruRand(10, echo=TRUE)

# the 9998+ th terms 
# 925166085       9998
# 1484786315       9999
# 1043618065      10000
# 1589873406      10001
# 2010798668      10002
setSeed(1614852353) #seed for the 9997th term
congruRand(5, echo=TRUE)

# (2) the SF Mersenne Twister algorithm
SFMT(1000)

#Kolmogorov Smirnov test
#KS statistic should be around 0.037
ks.test(SFMT(1000), punif) 
	
#KS statistic should be around 0.0076
ks.test(SFMT(10000), punif) 

#different mersenne exponent with a fixed parameter set
#
SFMT(10, mexp = 607, usepset = FALSE)
SFMT(10, mexp = 1279, usepset = FALSE)
SFMT(10, mexp = 2281, usepset = FALSE)
SFMT(10, mexp = 4253, usepset = FALSE)
SFMT(10, mexp = 11213, usepset = FALSE)
SFMT(10, mexp = 19937, usepset = FALSE)
SFMT(10, mexp = 44497, usepset = FALSE)
SFMT(10, mexp = 86243, usepset = FALSE)
SFMT(10, mexp = 132049, usepset = FALSE)
SFMT(10, mexp = 216091, usepset = FALSE)

#use different sets of parameters [default when possible]
#
for(i in 1:7) print(SFMT(1, mexp = 607))
for(i in 1:7) print(SFMT(1, mexp = 2281))
for(i in 1:7) print(SFMT(1, mexp = 4253))
for(i in 1:7) print(SFMT(1, mexp = 11213))
for(i in 1:7) print(SFMT(1, mexp = 19937))

#use a fixed set and a fixed seed
#should be the same output
setSeed(08082008)
SFMT(1, usepset = FALSE)
setSeed(08082008)
SFMT(1, usepset = FALSE)


# (3) withtorus argument
# 

# one third of outputs comes from Torus algorithm
u &lt;- SFMT(1000, with=1/3)
# the third term of the following code is the first term of torus sequence
print(u[666:670] )

# (4) WELL generator
#

# 'basic' calls
# WELL512
WELL(10, order = 512)
# WELL1024
WELL(10, order = 1024)
# WELL19937
WELL(10, order = 19937)
# WELL44497
WELL(10, order = 44497)
# WELL19937 with tempering 
WELL(10, order = 19937, temper = TRUE)
# WELL44497 with tempering
WELL(10, order = 44497, temper = TRUE)

# tempering vs no tempering
setSeed4WELL(08082008)
WELL(10, order =19937)
setSeed4WELL(08082008)
WELL(10, order =19937, temper=TRUE)

# (5) Knuth TAOCP generator
#
knuthTAOCP(10)
knuthTAOCP(10, 2) 


# (6) How to set the seed?
# all example is duplicated to ensure setSeed works

# congruRand
setSeed(1302)
congruRand(1)
setSeed(1302)
congruRand(1)
# SFMT
setSeed(1302)
SFMT(1, usepset=FALSE)
setSeed(1302)
SFMT(1, usepset=FALSE)
# BEWARE if you do not set usepset to FALSE
setSeed(1302)
SFMT(1)
setSeed(1302)
SFMT(1)
# WELL
setSeed(1302)
WELL(1)
setSeed(1302)
WELL(1)
# Knuth TAOCP
setSeed(1302)
knuthTAOCP(1)
setSeed(1302)
knuthTAOCP(1)



# (7) computation times on a 2022 macbook (2017 macbook / 2007 macbook), mean of 1000 runs
#

## Not run: 
# algorithm			time in seconds for n=10^6
# classical Mersenne Twister  0.005077 (0.028155 / 0.066) 
# SF Mersenne Twister  	      0.003994 (0.008223 / 0.044) 
# WELL generator				      0.006653 (0.006407 / 0.065)
# Knuth TAOCP				        	0.001574 (0.002923 / 0.046)
# Park Miller  		      			0.007479 (0.015635 / 0.108)
n &lt;- 1e+06
mean( replicate( 1000, system.time( runif(n), gcFirst=TRUE)[3]) )
mean( replicate( 1000, system.time( SFMT(n), gcFirst=TRUE)[3]) )
mean( replicate( 1000, system.time( WELL(n), gcFirst=TRUE)[3]) )
mean( replicate( 1000, system.time( knuthTAOCP(n), gcFirst=TRUE)[3]) )
mean( replicate( 1000, system.time( congruRand(n), gcFirst=TRUE)[3]) )
	
## End(Not run)

</code></pre>

<hr>
<h2 id='quasiRNG'>Toolbox for quasi random number generation</h2><span id='topic+quasiRNG'></span><span id='topic+torus'></span><span id='topic+sobol'></span><span id='topic+runif.sobol'></span><span id='topic+halton'></span><span id='topic+runif.halton'></span><span id='topic+quasi.randtoolbox'></span>

<h3>Description</h3>

<p>the Torus algorithm, the Sobol and Halton sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torus(n, dim = 1, prime, init = TRUE, mixed = FALSE, usetime = FALSE, 
                  normal = FALSE, mexp = 19937, start = 1)
sobol(n, dim = 1, init = TRUE, scrambling = 0, seed = NULL, normal = FALSE,
                   mixed = FALSE, method = "C", mexp = 19937, start = 1,
                   maxit = 10)
halton(n, dim = 1, init = TRUE, normal = FALSE, usetime = FALSE, 
                    mixed = FALSE, method = "C", mexp = 19937, start = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quasiRNG_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, 
the length is taken to be the required number.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_dim">dim</code></td>
<td>
<p>dimension of observations default 1.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_init">init</code></td>
<td>
<p>a logical, if <code>TRUE</code> the sequence is initialized and 
restarts to the <code>start</code> value, otherwise not. By default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_normal">normal</code></td>
<td>
<p>a logical if normal deviates are needed, default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_scrambling">scrambling</code></td>
<td>

<p>an integer value, if 1, 2 or 3 the sequence is scrambled
otherwise not. If <code>scrambling=1</code>, Owen type type of scrambling is 
applied, if <code>scrambling=2</code>, Faure-Tezuka type of scrambling, is
applied, and if <code>scrambling=3</code>, both Owen+Faure-Tezuka type of
scrambling is applied. By default 0.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_seed">seed</code></td>
<td>

<p>an integer value, the random seed for initialization
of the scrambling process (only for <code>sobol</code>
with <code>scrambling&gt;0</code>). 
If <code>NULL</code>, set to <code>4711</code>. </p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_prime">prime</code></td>
<td>
<p>a single prime number or a vector of prime numbers to be used
in the Torus sequence. (optional argument).</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_mixed">mixed</code></td>
<td>
<p>a logical to combine the QMC algorithm with the SFMT algorithm, default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_usetime">usetime</code></td>
<td>
<p>a logical to use the machine time to start the Torus sequence, 
default <code>FALSE</code>, i.e. when <code>usetime=FALSE</code> the Torus sequence start from the first term.
<code>usetime</code> is only used when <code>mixed=FALSE</code>.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_method">method</code></td>
<td>
<p>a character string either <code>"C"</code>.
Note that <code>mixed=TRUE</code> is only available when <code>method="C"</code>.</p>
</td></tr>		 
<tr><td><code id="quasiRNG_+3A_mexp">mexp</code></td>
<td>
<p>an integer for the Mersenne exponent of SFMT algorithm,
only used when <code>mixed=TRUE</code>.</p>
</td></tr>    
<tr><td><code id="quasiRNG_+3A_start">start</code></td>
<td>
<p>an integer 0 or 1 to initiliaze the sequence, default to 1,
only used when <code>init=TRUE</code>.</p>
</td></tr>
<tr><td><code id="quasiRNG_+3A_maxit">maxit</code></td>
<td>
<p>a positive integer used to control inner loops both
for generating randomized seed and for controlling
outputs (when needed).</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>Scrambling is temporarily disabled and will be reintroduced in a future release.
</p>
<p>The currently available generator are given below.
Whatever the sequence, when <code>normal=TRUE</code>, outputs are transformed with
the quantile of the standard normal distribution <code><a href="stats.html#topic+qnorm">qnorm</a></code>.
If <code>init=TRUE</code>, the default, unscrambled and unmixed-SFMT quasi-random 
sequences start from <code>start</code>.
If <code>start != 0</code> and <code>normal=FALSE</code>, 
we suggest to use 0 as recommended by Owen (2020). 
One must handle the starting value (0) correctly if a quantile
function of a non-lower-bounded distribution is used.
</p>

<dl>
<dt><b>Torus algorithm:</b></dt><dd>
<p>The <code class="reqn">k</code>th term of the Torus algorithm in d dimension is given by
</p>
<p style="text-align: center;"><code class="reqn">u_k = \left(frac(k \sqrt{p_1}), ..., frac(k \sqrt{p_d}) \right)</code>
</p>

<p>where <code class="reqn">p_i</code> denotes the ith prime number, <code class="reqn">frac</code> the fractional part
(i.e. <code class="reqn">frac(x) = x-floor(x)</code>). We use the 100 000 first prime numbers
from <a href="https://primes.utm.edu/">https://primes.utm.edu/</a>, thus the dimension is limited to 100 000. 
If the user supplys prime numbers through
the argument <code>prime</code>, we do NOT check for primality and we cast numerics
to integers, (i.e. <code>prime=7.1234</code> will be cast to <code>prime=7</code> before
computing Torus sequence).
The Torus sequence starts from <code class="reqn">k=1</code> when initialized with 
<code>init = TRUE</code> and so not depending on machine time 
<code>usetime = FALSE</code>. This is the default. When <code>init = FALSE</code>, the sequence
is not initialized (to 1) and starts from the last term. 
We can also use the machine time to start the sequence with <code>usetime = TRUE</code>, 
which overrides <code>init</code> or a randomized when <code>mixed = TRUE</code>.</p>
</dd>
<dt><b>(scrambled) Sobol sequences</b></dt><dd>
<p>Computes uniform Sobol low discrepancy numbers. 
The sequence starts from <code class="reqn">k=1</code> when initialized with 
<code>init = TRUE</code> (default).
When <code>scrambling &gt; 0</code>, a scrambling is performed
or when <code>mixed = TRUE</code>, a randomized seed is performed.
If some number of Sobol sequences are generated outside [0,1) with scrambling,
the seed is randomized until we obtain all numbers in [0,1).
One version of Sobol sequences is available the current version in 
Fortran (<code>method = "Fortran"</code>) since <code>method = "C"</code> is under development.
</p>
</dd>
<dt><b>Halton sequences</b></dt><dd>
<p>Calculates a matrix of uniform or normal deviated halton low 
discrepancy numbers. Let us note that Halton sequence in dimension is the
Van Der Corput sequence.
The Halton sequence starts from <code class="reqn">k=1</code> when initialized with 
<code>init = TRUE</code> (default) and no not depending on machine time 
<code>usetime = FALSE</code>. 
When <code>init = FALSE</code>, the sequence
is not initialized (to 1) and starts from the last term. We can also use the
machine time to start the sequence with <code>usetime = TRUE</code>, which overrides
<code>init</code>.
Two versions of Halton sequences are available the historical version in 
Fortran (<code>method = "Fortran"</code>) and the new version in C (<code>method = "C"</code>).
If <code>method = "C"</code>, <code>mixed</code> argument can be used to randomized
the Halton sequences.
</p>
</dd>	
</dl>

<p>See the pdf vignette for details.
</p>


<h3>Value</h3>

<p><code>torus</code>, <code>halton</code> and <code>sobol</code> generates random variables in [0,1). 
It returns a <code class="reqn">n</code>x<code class="reqn">dim</code> matrix, when <code>dim&gt;1</code> 
otherwise a vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang and Diethelm Wuertz
</p>


<h3>References</h3>

<p>Bratley P., Fox B.L. (1988),
<em>Algorithm 659: Implementing Sobol's Quasirandom Sequence Generator</em>,
ACM Transactions on Mathematical Software 14, 88&ndash;100.
<a href="https://doi.org/10.1145/42288.214372">doi:10.1145/42288.214372</a>
</p>
<p>Joe S., Kuo F.Y. (2003),
<em>Remark on Algorithm 659: Implementing Sobol's Quaisrandom Seqence Generator</em>,
ACM Transactions on Mathematical Software 29, 49&ndash;57.
<a href="https://doi.org/10.1145/641876.641879">doi:10.1145/641876.641879</a>
</p>
<p>Joe S., Kuo F.Y. (2008),
<em>Constructing Sobol sequences with better two-dimensional projections</em>,
SIAM J. Sci. Comput. 30, 2635&ndash;2654,
<a href="https://doi.org/10.1137/070709359">doi:10.1137/070709359</a>.    
</p>
<p>Owen A.B. (2020), <em>On dropping the first Sobol' point</em>,
<a href="https://doi.org/10.1007/978-3-030-98319-2_4">doi:10.1007/978-3-030-98319-2_4</a>.
</p>
<p>Planchet F., Jacquemin J. (2003), 
<em>L'utilisation de methodes de simulation en assurance</em>. 
Bulletin Francais d'Actuariat, vol. 6, 11, 3-69. (available online)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pseudoRNG">pseudoRNG</a></code> for pseudo random number generation, 
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> for what is done in R about random number generation. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) the Torus algorithm
#
torus(100)

# example of setting the seed
setSeed(1)
torus(5)
setSeed(6)
torus(5)
#the same
setSeed(1)
torus(10)

#no use of the machine time
torus(10, use=FALSE)

#Kolmogorov Smirnov test
#KS statistic should be around 0.0019
ks.test(torus(1000), punif) 
	
#KS statistic should be around 0.0003
ks.test(torus(10000), punif) 

#the mixed Torus sequence
torus(10, mixed=TRUE)
## Not run: 
  par(mfrow = c(1,2))
  acf(torus(10^6))
  acf(torus(10^6, mixed=TRUE))

## End(Not run)

#usage of the init argument
torus(5)
torus(5, init=FALSE)

#should be equal to the combination of the two
#previous call
torus(10)

# (2) Halton sequences
#

# uniform variate
halton(n = 10, dim = 5)

# normal variate
halton(n = 10, dim = 5, normal = TRUE)

#usage of the init argument
halton(5)
halton(5, init=FALSE)

#should be equal to the combination of the two
#previous call
halton(10)

# some plots
par(mfrow = c(2, 2), cex = 0.75)
hist(halton(n = 500, dim = 1), main = "Uniform Halton", 
  xlab = "x", col = "steelblue3", border = "white")

hist(halton(n = 500, dim = 1, norm = TRUE), main = "Normal Halton", 
  xlab = "x", col = "steelblue3", border = "white")
   
# (3) Sobol sequences
#

# uniform variate
sobol(n = 10, dim = 5)

# normal variate
sobol(n = 10, dim = 5, normal = TRUE)

# some plots
hist(sobol(500, 1), main = "Uniform Sobol", 
  xlab = "x", col = "steelblue3", border = "white")

hist(sobol(500, 1, normal = TRUE), main = "Normal Sobol", 
  xlab = "x", col = "steelblue3", border = "white")

#usage of the init argument
sobol(5)
sobol(5, init=FALSE)

#should be equal to the combination of the two
#previous call
sobol(10)

# (4) computation times on a 2022 macbook (2017 macbook / 2007 macbook), mean of 1000 runs
#

## Not run: 
# algorithm			time in seconds for n=10^6
# Torus algo					  0.00689 (0.012 / 0.058)
# mixed Torus algo 	    0.009354 (0.018 / 0.087)
# Halton sequence				0.023575 (0.180 / 0.878)
# Sobol sequence				0.010444 (0.027 / 0.214)
n &lt;- 1e+06
mean( replicate( 1000, system.time( torus(n), gcFirst=TRUE)[3]) )
mean( replicate( 1000, system.time( torus(n, mixed=TRUE), gcFirst=TRUE)[3]) )
mean( replicate( 1000, system.time( halton(n), gcFirst=TRUE)[3]) )
mean( replicate( 1000, system.time( sobol(n), gcFirst=TRUE)[3]) )
	
## End(Not run)

</code></pre>

<hr>
<h2 id='rngWELLScriptR'>An implementation of the recurrence of WELL generators in R language</h2><span id='topic+rngWELLScriptR'></span>

<h3>Description</h3>

<p>An implementation of the recurrence of WELL generators in R language
for testing purposes. It is too slow to be used for random number
generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
  rngWELLScriptR(n, s, generator, includeState=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rngWELLScriptR_+3A_n">n</code></td>
<td>
<p> Integer. The length of the output sequence.</p>
</td></tr>
<tr><td><code id="rngWELLScriptR_+3A_s">s</code></td>
<td>
<p> An 0,1-matrix representing the state of the required WELL generator
as obtained by <code>getWELLState()</code>.</p>
</td></tr>
<tr><td><code id="rngWELLScriptR_+3A_generator">generator</code></td>
<td>
<p> Character string. Name of the generator from the list
<code>"512a", "521a", "521b", "607a", "607b", "800a", "800b", "1024a", "1024b", "19937a",
  "19937c", "19937b", "21701a", "23209a", "23209b", "44497a", "44497b"</code>.
</p>
</td></tr>
<tr><td><code id="rngWELLScriptR_+3A_includestate">includeState</code></td>
<td>
<p> Logical. Controls, whether the output should contain
the final internal state additionally to the numerical output or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>includeState=FALSE</code>, a numeric vector of length <code>n</code> containing
the numerical output of the generator.
If <code>includeState=TRUE</code>, a list with components <code>x</code> (the numerical
output) and <code>state</code> (the final internal state of the generator).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getWELLState">getWELLState</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.generator("WELL", order=512, version="a", seed=123456)
  s &lt;- getWELLState()
  x &lt;- runif(500)
  y &lt;- rngWELLScriptR(500, s, "512a")
  all(x == y)
  # [1] TRUE
</code></pre>

<hr>
<h2 id='runifInterface'>Functions for using runif() and rnorm() with randtoolbox generators</h2><span id='topic+runifInterface'></span><span id='topic+set.generator'></span><span id='topic+put.description'></span><span id='topic+get.description'></span>

<h3>Description</h3>

<p>These functions allow to set some of the random number generators from randtoolbox
package to be used instead of the standard generator in the functions, which use
random numbers, for example <code>runif()</code>, <code>rnorm()</code>, <code>sample()</code>
and <code>set.seed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.generator(name=c("WELL", "MersenneTwister", "default"),
              parameters=NULL, seed=NULL, ..., only.dsc=FALSE)

put.description(description)		

get.description()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifInterface_+3A_name">name</code></td>
<td>
<p>A character string for the RNG name.</p>
</td></tr>
<tr><td><code id="runifInterface_+3A_parameters">parameters</code></td>
<td>
<p>A numeric or character vector describing a specific RNG from the
family specified by the <code>name</code>.</p>
</td></tr>
<tr><td><code id="runifInterface_+3A_seed">seed</code></td>
<td>
<p>A number, whose value is an integer between <code>0</code> and <code>2^32 - 1</code>,
to be used as a seed.</p>
</td></tr>
<tr><td><code id="runifInterface_+3A_...">...</code></td>
<td>
<p>Arguments describing named components of the vector of parameters,
if argument <code>parameters</code> is missing or <code>NULL</code>.</p>
</td></tr>	
<tr><td><code id="runifInterface_+3A_only.dsc">only.dsc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a description of the specified RNG is returned
and the generator is not initialized.</p>
</td></tr>
<tr><td><code id="runifInterface_+3A_description">description</code></td>
<td>
<p>A list describing a specific RNG as created by
<code>set.generator(,only.dsc=TRUE)</code> or <code>get.description()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random number generators provided by R extension packages are set using
<code>RNGkind("user-supplied")</code>. The package <span class="pkg">randtoolbox</span> assumes that
this function is not called by the user directly and is called from
the functions <code>set.generator()</code> and <code>put.description()</code>.
</p>
<p>Random number generators in <span class="pkg">randtoolbox</span> are represented at the R level by a list
containing mandatory components <code>name, parameters, state</code> and possibly an
optional component <code>authors</code>. The function <code>set.generator()</code> internally
creates this list from the user supplied information and then runs <code>put.description()</code>
on this list, which initializes the generator. If the generator is initialized, then the
function <code>get.description()</code> may be used to get the actual state of the generator,
which may be stored in an R object and used later in <code>put.description()</code> to continue
the sequence of the random numbers from the point, where <code>get.description()</code>
was called. This may be used to generate several independent streams of random numbers
generated by different generators.
</p>
<p>The component <code>parameters</code> is a character or a numeric vector, whose structure
is different for different types of the generators. This vector may be passed
to <code>set.generator()</code>, if it is prepared before its call, however, it is
also possible to pass its named components via the <code>...</code> parametr of
<code>set.generator()</code> and the vector <code>parameters</code> is created internally.
If the vector <code>parameters</code> is not supplied and the arguments in <code>...</code>
are not sufficient to create it, an error message is produced.
</p>


<h4>Linear congruential generators</h4>

<p>Currently disabled.
</p>
<p>Parameters for the linear congruential generators (<code>name="congruRand"</code>)
are integers represented either as a character or a numeric vector. The
components are
</p>

<dl>
<dt>mod</dt><dd><p>The modulus.</p>
</dd>
<dt>mult</dt><dd><p>The multiplier.</p>
</dd>
<dt>incr</dt><dd><p>The increment.</p>
</dd>
</dl>




<h4>WELL generators</h4>

<p>Parameters for the WELL generators is a character vector with components
</p>

<dl>
<dt>order</dt><dd><p>The number of bits in the internal state.
Possible values are 512, 521, 607, 800, 1024, 19937, 21701, 23209, 44497.</p>
</dd>
<dt>version</dt><dd><p>The version letter &quot;a&quot;, &quot;b&quot;, or &quot;c&quot; to be appended to the order.</p>
</dd>
</dl>

<p>The concatenation of <code>order</code> and <code>version</code> should belong to
<code>"512a", "521a", "521b", "607a", "607b", "800a", "800b", "1024a", "1024b",
"19937a", "19937b", "19937c", "21701a", "23209a", "23209b", "44497a", "44497b"</code>.
When order and version are specified in <code>...</code> parametr of <code>set.generator()</code>,
then the parameter <code>order</code> is optional and if missing, it is assumed that the
parameter <code>version</code> contains also the number of bits in the internal state
and the combination belongs to the list above.
</p>



<h4>Mersenne Twister 2002 generator</h4>

<p>Parameters for the Mersenne Twister 2002 is a character vector with components
</p>

<dl>
<dt>initialization</dt><dd><p>Either &quot;init2002&quot; or &quot;array2002&quot;. The initialization to be used.</p>
</dd>
<dt>resolution</dt><dd><p>Either 53 or 32. The number of random bits in each number.</p>
</dd>
</dl>




<h3>Value</h3>

<p><code>set.generator()</code> with the parameter <code>only.dsc=TRUE</code> and
<code>get.description()</code> return the list describing a generator.
<code>put.description()</code> with the parameter <code>only.dsc=TRUE</code> (the default)
and <code>put.description()</code> return <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Petr Savicky and Christophe Dutang
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+RNGkind">RNGkind</a></code> and <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> for random number generation in R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#set WELL19937a
set.generator("WELL", version="19937a", seed=12345)
runif(5)

#Store the current state  and generate 10 random numbers
storedState &lt;- get.description()
x &lt;- runif(10)

#Park Miller congruential generator
set.generator(name="congruRand", mod=2^31-1, mult=16807, incr=0, seed=12345)
runif(5)
setSeed(12345)
congruRand(5, dim=1, mod=2^31-1, mult=16807, incr=0)

# the Knuth Lewis RNG
set.generator(name="congruRand", mod="4294967296", mult="1664525", incr="1013904223", seed=1)
runif(5)
setSeed(1)
congruRand(5, dim=1, mod=4294967296, mult=1664525, incr=1013904223)

#Restore the generator from storedState and regenerate the same numbers
put.description(storedState)
x == runif(10)

# generate the same random numbers as in Matlab
set.generator("MersenneTwister", initialization="init2002", resolution=53, seed=12345)
runif(5)
# [1] 0.9296161 0.3163756 0.1839188 0.2045603 0.5677250
# Matlab commands rand('twister', 12345); rand(1, 5) generate the same numbers,
# which in short format are   0.9296    0.3164    0.1839    0.2046    0.5677

#Restore the original R setting
set.generator("default")
RNGkind()

</code></pre>

<hr>
<h2 id='serial.test'>the Serial test</h2><span id='topic+serial.test'></span>

<h3>Description</h3>

<p>The Serial test for testing random number generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serial.test(u , d = 8, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serial.test_+3A_u">u</code></td>
<td>
<p>sample of random numbers in ]0,1[.</p>
</td></tr>
<tr><td><code id="serial.test_+3A_echo">echo</code></td>
<td>
<p>logical to plot detailed results, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="serial.test_+3A_d">d</code></td>
<td>
<p>a numeric for the dimension, see details. When necessary 
we assume that <code>d</code> is a multiple of the length of <code>u</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider a vector <code>u</code>, realisation of i.i.d. uniform random
variables <code class="reqn">U_1, \dots, U_n</code>.
</p>
<p>The serial test computes a serie of integer pairs <code class="reqn">(p_i,p_{i+1})</code> 
from the sample <code>u</code> with <code class="reqn">p_i = \lfloor u_i d\rfloor</code> (<code>u</code> must have an even length). 
Let <code class="reqn">n_j</code> be the number of pairs such that
<code class="reqn">j=p_i \times d + p_{i+1}</code>. If <code>d=2</code>, we count
the number of pairs equals to <code class="reqn">00, 01, 10</code> and <code class="reqn">11</code>. Since 
all the combination of two elements in <code class="reqn">\{0, \dots, d-1\}</code>
are equiprobable, the chi-squared statistic is
</p>
<p style="text-align: center;"><code class="reqn"> S = \sum_{j=0}^{d-1} \frac{n_j - n/(2 d^2))^2}{n/(2 d^2)}.
		</code>
</p>



<h3>Value</h3>

<p>a list with the following components :
</p>
<p><code>statistic</code>	 the value of the chi-squared statistic.
</p>
<p><code>p.value</code>	 	 the p-value of the test.
</p>
<p><code>observed</code>	 the observed counts.
</p>
<p><code>expected</code>	 the expected counts under the null hypothesis.
</p>
<p><code>residuals</code>	 the Pearson residuals, (observed - expected) / sqrt(expected).
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang.
</p>


<h3>References</h3>

<p>Planchet F., Jacquemin J. (2003), <em>L'utilisation de methodes de 
simulation en assurance</em>. Bulletin Francais d'Actuariat, vol. 6, 11, 3-69. (available online)
</p>
<p>L'Ecuyer P. (2001), <em>Software for uniform random number
generation distinguishing the good and the bad</em>. Proceedings of the 2001 
Winter Simulation Conference. <a href="https://doi.org/10.1109/WSC.2001.977250">doi:10.1109/WSC.2001.977250</a>
</p>
<p>L'Ecuyer P. (2007), <em>Test U01: a C library for empirical testing of 
random number generators.</em> ACM Trans. on Mathematical 
Software 33(4), 22. <a href="https://doi.org/10.1145/1268776.1268777">doi:10.1145/1268776.1268777</a>
</p>


<h3>See Also</h3>

<p>other tests of this package <code><a href="#topic+freq.test">freq.test</a></code>, <code><a href="#topic+gap.test">gap.test</a></code>, <code><a href="#topic+poker.test">poker.test</a></code>,
<code><a href="#topic+order.test">order.test</a></code> and <code><a href="#topic+coll.test">coll.test</a></code>
</p>
<p><code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov Smirnov test and <code><a href="stats.html#topic+acf">acf</a></code> for
the autocorrelation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) 
#
serial.test(runif(1000))
print( serial.test( runif(1000000), d=2, e=FALSE) )

# (2) 
#
serial.test(runif(5000), 5) 

</code></pre>

<hr>
<h2 id='soboltestfunctions'>Some test functions for Sobol sequences</h2><span id='topic+sobol.R'></span><span id='topic+int2bit'></span><span id='topic+bit2int'></span><span id='topic+bit2unitreal'></span>

<h3>Description</h3>

<p>Some test functions for Sobol sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol.R(n, d, echo=FALSE)

int2bit(x)
bit2int(x)
bit2unitreal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soboltestfunctions_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="soboltestfunctions_+3A_d">d</code></td>
<td>
<p>dimension of observations.</p>
</td></tr>
<tr><td><code id="soboltestfunctions_+3A_echo">echo</code></td>
<td>
<p>a logical to show some traces.</p>
</td></tr>
<tr><td><code id="soboltestfunctions_+3A_x">x</code></td>
<td>
<p>an integer to convert in base 2 or its binary representation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sobol.R</code> computes Sobol sequences but not using Gray code so points are
not in the same order as in <code>sobol</code>.
</p>
<p><code>sobol.basic</code> compute the Sobol sequence in one dimension according to a primitive
polynomial and specified integers <code class="reqn">m_j</code>.
</p>
<p><code>int2bit</code> computes the binary representation of the integer part of a real,
<code>bit2int</code> computes an integer from its binary representation.
<code>bit2unitreal</code> computes the radical inverse function in base 2.
</p>


<h3>Value</h3>

<p>a vector of length <code>n</code> or a matrix for <code>sobol.R</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>Glasserman P., (2003);
<em>Monte Carlo Methods in Financial Engineering</em>,
Springer. <a href="https://doi.org/10.1007/978-0-387-21617-1">doi:10.1007/978-0-387-21617-1</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quasiRNG">quasiRNG</a></code> for quasi random number generation. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#page 306 of Glassermann
sobol.R(10,2)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
