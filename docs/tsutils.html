<!DOCTYPE html><html><head><title>Help for package tsutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tsutils-package'><p>tsutils: Time Series Exploration, Modelling and Forecasting</p></a></li>
<li><a href='#abc'><p>ABC analysis</p></a></li>
<li><a href='#abcxyz'><p>ABC-XYZ visualisation</p></a></li>
<li><a href='#cmav'><p>Centred moving average</p></a></li>
<li><a href='#coxstuart'><p>Cox-Stuart test</p></a></li>
<li><a href='#decomp'><p>Classical time series decomposition</p></a></li>
<li><a href='#geomean'><p>Geometric mean</p></a></li>
<li><a href='#getOptK'><p>Optimal temporal aggregation level for AR(1), MA(1), ARMA(1,1)</p></a></li>
<li><a href='#lagmatrix'><p>Create lead/lags of a variable</p></a></li>
<li><a href='#lambdaseq'><p>Generate sequence of lambda for LASSO regression</p></a></li>
<li><a href='#leadtrail'><p>Remove leading/training zeros/NAs</p></a></li>
<li><a href='#mseastest'><p>Multiplicative seasonality test</p></a></li>
<li><a href='#nemenyi'><p>Nonparametric multiple comparisons (Nemenyi test)</p></a></li>
<li><a href='#plotSthief'><p>Plot temporal hierarchy</p></a></li>
<li><a href='#referrals'><p>NHS A&amp;E Referrals</p></a></li>
<li><a href='#residout'><p>Residuals control chart</p></a></li>
<li><a href='#seasdummy'><p>Create seasonal dummy variables.</p></a></li>
<li><a href='#seasplot'><p>Seasonal plots with simplistic trend/season tests</p></a></li>
<li><a href='#Sthief'><p>Temporal hierarchy S matrix</p></a></li>
<li><a href='#theta'><p>Theta method</p></a></li>
<li><a href='#trendtest'><p>Test a time series for trend</p></a></li>
<li><a href='#tsutils'><p>tsutils: Time Series Exploration, Modelling and Forecasting</p></a></li>
<li><a href='#wins'><p>Winsorise</p></a></li>
<li><a href='#xyz'><p>XYZ analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Exploration, Modelling and Forecasting</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes: (i) tests and visualisations that can help the modeller explore time series components and perform decomposition; (ii) modelling shortcuts, such as functions to construct lagmatrices and seasonal dummy variables of various forms; (iii) an implementation of the Theta method; (iv) tools to facilitate the design of the forecasting process, such as ABC-XYZ analyses; and (v) "quality of life" functions, such as treating time series for trailing and leading values.</td>
</tr>
<tr>
<td>Imports:</td>
<td>RColorBrewer, forecast, MAPA, plotrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>thief</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/trnnick/tsutils/">https://github.com/trnnick/tsutils/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 23:19:17 UTC; Nikos</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolaos Kourentzes [aut, cre],
  Ivan Svetunkov [ctb],
  Oliver Schaer [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolaos Kourentzes &lt;nikolaos@kourentzes.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-15 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tsutils-package'>tsutils: Time Series Exploration, Modelling and Forecasting</h2><span id='topic+tsutils-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Includes: (i) tests and visualisations that can help the modeller explore time series components and perform decomposition; (ii) modelling shortcuts, such as functions to construct lagmatrices and seasonal dummy variables of various forms; (iii) an implementation of the Theta method; (iv) tools to facilitate the design of the forecasting process, such as ABC-XYZ analyses; and (v) &quot;quality of life&quot; functions, such as treating time series for trailing and leading values.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nikolaos Kourentzes <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Ivan Svetunkov <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a> [contributor]
</p>
</li>
<li><p> Oliver Schaer <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/trnnick/tsutils/">https://github.com/trnnick/tsutils/</a>
</p>
</li></ul>


<hr>
<h2 id='abc'>ABC analysis</h2><span id='topic+abc'></span><span id='topic+plot.abc'></span>

<h3>Description</h3>

<p>Perform ABC analysis on a set of time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abc(x, prc = c(0.2, 0.3, 0.5))

## S3 method for class 'abc'
plot(x, cex.prc = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abc_+3A_x">x</code></td>
<td>
<p>this can either be an array, where each column is a series, or a vector of values. If <code>x</code> is an array of time series, then the importance of each series is calculated as the mean of the observations (sales volume). Otherwise, value can be whatever quantity is provided.</p>
</td></tr>
<tr><td><code id="abc_+3A_prc">prc</code></td>
<td>
<p>a vector of percentages indicating how many items are included in each class. By default this is <code>c(0.2,0.3,0.5)</code>, but any set of percentage values can be used as long as <code>0&lt;=prc[i]&lt;=1</code> and <code>sum(prc)==1</code>.</p>
</td></tr>
<tr><td><code id="abc_+3A_cex.prc">cex.prc</code></td>
<td>
<p>font size of percentages reported in plot.</p>
</td></tr>
<tr><td><code id="abc_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return object of class <code>abc</code> and contains:
</p>

<ul>
<li> <p><code>value</code>: a vector containing the importance value of each series.
</p>
</li>
<li> <p><code>class</code>: a vector containing the class membership of each series.
</p>
</li>
<li> <p><code>rank</code>: a vector containing the rank of each series, with 1 being the highest ranking series.
</p>
</li>
<li> <p><code>conc</code>: the importance concentration of each class, as percentage of total value.
</p>
</li></ul>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot(abc)</code>: plot ABC or XYZ analyses.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Ord K., Fildes R., Kourentzes N. (2017) <a href="https://kourentzes.com/forecasting/2017/10/16/new-forecasting-book-principles-of-business-forecasting-2e/">Principles of Business Forecasting, 2e</a>. <em>Wessex Press Publishing Co.</em>, p.515-518.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyz">xyz</a></code>, <code><a href="#topic+abcxyz">abcxyz</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- abs(matrix(cumsum(rnorm(5400,0,1)),36,150))
z &lt;- abc(x)
print(z)
plot(z)

</code></pre>

<hr>
<h2 id='abcxyz'>ABC-XYZ visualisation</h2><span id='topic+abcxyz'></span>

<h3>Description</h3>

<p>Jointly visualise ABC and XYZ analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcxyz(imp, frc, outplot = c(TRUE, FALSE), error = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abcxyz_+3A_imp">imp</code></td>
<td>
<p>an obkect of class <code>abc</code> that is the output of function <code><a href="#topic+abc">abc</a></code>.</p>
</td></tr>
<tr><td><code id="abcxyz_+3A_frc">frc</code></td>
<td>
<p>an obkect of class <code>abc</code> that is the output of function <code><a href="#topic+xyz">xyz</a></code>.</p>
</td></tr>
<tr><td><code id="abcxyz_+3A_outplot">outplot</code></td>
<td>
<p>if <code>TRUE</code>, then provide a visualisation of the analyses.</p>
</td></tr>
<tr><td><code id="abcxyz_+3A_error">error</code></td>
<td>
<p>vector of forecast errors for each series that will be distributed in each class, presented as an average.</p>
</td></tr>
<tr><td><code id="abcxyz_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>class</code>: a matrix containing the number of time series in each class.
</p>
</li>
<li> <p><code>error</code>: a matrix containing the averaged error for each class, if the argument <code>error</code> was used.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Ord K., Fildes R., Kourentzes N. (2017) <a href="https://kourentzes.com/forecasting/2017/10/16/new-forecasting-book-principles-of-business-forecasting-2e/">Principles of Business Forecasting, 2e</a>. <em>Wessex Press Publishing Co.</em>, p.515-518.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abc">abc</a></code>, <code><a href="#topic+xyz">xyz</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- abs(matrix(cumsum(rnorm(5400,0,1)),36,150))
abcxyz(abc(x),xyz(x,type="cv"))

</code></pre>

<hr>
<h2 id='cmav'>Centred moving average</h2><span id='topic+cmav'></span>

<h3>Description</h3>

<p>Calculate the Centred Moving Average (CMA) for time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmav(
  y,
  ma = NULL,
  fill = c(TRUE, FALSE),
  outplot = c(FALSE, TRUE),
  fast = c(TRUE, FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmav_+3A_y">y</code></td>
<td>
<p>input time series. Can be <code>ts</code> or <code>msts</code> object.</p>
</td></tr>
<tr><td><code id="cmav_+3A_ma">ma</code></td>
<td>
<p>length of centred moving average. If <code>y</code> is a <code>ts</code> object then the default is its frequency. If it is a <code>msts</code> object the default is the maximum frequency.</p>
</td></tr>
<tr><td><code id="cmav_+3A_fill">fill</code></td>
<td>
<p>if <code>TRUE</code>, then fill first and last ma/2 observations using exponential smoothing.</p>
</td></tr>
<tr><td><code id="cmav_+3A_outplot">outplot</code></td>
<td>
<p>if <code>TRUE</code>, then output a plot of the time series and the moving average.</p>
</td></tr>
<tr><td><code id="cmav_+3A_fast">fast</code></td>
<td>
<p>if <code>TRUE</code>, then only a limited set of models are evaluated for CMA extrapolation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Centred moving average. If y is a ts object, then cma has the same properties.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Ord K., Fildes R., Kourentzes N. (2017) <a href="https://kourentzes.com/forecasting/2017/10/16/new-forecasting-book-principles-of-business-forecasting-2e/">Principles of Business Forecasting, 2e</a>. <em>Wessex Press Publishing Co.</em>, p.109.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmav(referrals,outplot=TRUE)

</code></pre>

<hr>
<h2 id='coxstuart'>Cox-Stuart test</h2><span id='topic+coxstuart'></span>

<h3>Description</h3>

<p>Perform Cox-Stuart test for location or dispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxstuart(y, type = c("trend", "deviation", "dispersion"), alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxstuart_+3A_y">y</code></td>
<td>
<p>input data.</p>
</td></tr>
<tr><td><code id="coxstuart_+3A_type">type</code></td>
<td>
<p>type of test. Can be:
</p>

<ul>
<li> <p><code>"trend"</code>: test for changes in trend.
</p>
</li>
<li> <p><code>"deviation"</code>: test for changes in deviation.
</p>
</li>
<li> <p><code>"dispersion"</code>: test for changes in dispersion (range).
</p>
</li></ul>
</td></tr>
<tr><td><code id="coxstuart_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>H</code>: hypothesis outcome.
</p>
</li>
<li> <p><code>p.value</code>: corresponding p-value.
</p>
</li>
<li> <p><code>Htxt</code>: textual description of the hypothesis outcome.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coxstuart(referrals)

</code></pre>

<hr>
<h2 id='decomp'>Classical time series decomposition</h2><span id='topic+decomp'></span>

<h3>Description</h3>

<p>Perform classical time series decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp(
  y,
  m = NULL,
  s = NULL,
  trend = NULL,
  outplot = c(FALSE, TRUE),
  decomposition = c("multiplicative", "additive", "auto"),
  h = 0,
  type = c("mean", "median", "pure.seasonal"),
  w = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp_+3A_y">y</code></td>
<td>
<p>input time series. Can be <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="decomp_+3A_m">m</code></td>
<td>
<p>seasonal period. If <code>y</code> is a <code>ts</code> object then the default is its frequency.</p>
</td></tr>
<tr><td><code id="decomp_+3A_s">s</code></td>
<td>
<p>starting period in the season. If <code>y</code> is a <code>ts</code> object then this is picked up from <code>y</code>.</p>
</td></tr>
<tr><td><code id="decomp_+3A_trend">trend</code></td>
<td>
<p>vector of the level/trend of <code>y</code>. Use <code>NULL</code> to estimate internally.</p>
</td></tr>
<tr><td><code id="decomp_+3A_outplot">outplot</code></td>
<td>
<p>if <code>TRUE</code>, then provide a plot of the decomposed components.</p>
</td></tr>
<tr><td><code id="decomp_+3A_decomposition">decomposition</code></td>
<td>
<p>type of decomposition. This can be <code>"multiplicative"</code>, <code>"additive"</code> or <code>"auto"</code>. If <code>y</code> contains non-positive values then this is forced to <code>"additive"</code>.</p>
</td></tr>
<tr><td><code id="decomp_+3A_h">h</code></td>
<td>
<p>forecast horizon for seasonal component.</p>
</td></tr>
<tr><td><code id="decomp_+3A_type">type</code></td>
<td>
<p>calculation for seasonal component:
</p>

<ul>
<li> <p><code>"mean"</code>: the mean of each seasonal period.
</p>
</li>
<li> <p><code>"median"</code>: the median of each seasonal period.
</p>
</li>
<li> <p><code>"pure.seasonal"</code>: estimate using a pure seasonal model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="decomp_+3A_w">w</code></td>
<td>
<p>percentage or number of observations to winsorise in the calculation of mean seasonal indices. If w&gt;1 then it is the number of observations, otherwise it is a percentage. If <code>type != "mean"</code> then this is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>trend</code>: trend component.
</p>
</li>
<li> <p><code>season</code>: season component.
</p>
</li>
<li> <p><code>irregular</code>: irregular component.
</p>
</li>
<li> <p><code>f.season</code>: forecasted seasonal component if <code>h&gt;0</code>.
</p>
</li>
<li> <p><code>g</code>: pure seasonal model parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Ord K., Fildes R., Kourentzes N. (2017) <a href="https://kourentzes.com/forecasting/2017/10/16/new-forecasting-book-principles-of-business-forecasting-2e/">Principles of Business Forecasting, 2e</a>. <em>Wessex Press Publishing Co.</em>, p.106-111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decomp(referrals)

</code></pre>

<hr>
<h2 id='geomean'>Geometric mean</h2><span id='topic+geomean'></span>

<h3>Description</h3>

<p>Calculate the geometric mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomean(x, na.rm = c(FALSE, TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomean_+3A_x">x</code></td>
<td>
<p>input data (will be considered as a vector).</p>
</td></tr>
<tr><td><code id="geomean_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="geomean_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The geometirc mean of the values in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geomean(c(0.5,1,1.5))

</code></pre>

<hr>
<h2 id='getOptK'>Optimal temporal aggregation level for AR(1), MA(1), ARMA(1,1)</h2><span id='topic+getOptK'></span>

<h3>Description</h3>

<p>Calculate the theoretically optimal temporal aggregation level for AR(1), MA(1) and ARMA(1,1) time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOptK(y, m = 12, type = c("ar", "ma", "arma"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOptK_+3A_y">y</code></td>
<td>
<p>a time series that must be of either <code>ts</code> or <code>msts</code> class.</p>
</td></tr>
<tr><td><code id="getOptK_+3A_m">m</code></td>
<td>
<p>maximum aggregation level.</p>
</td></tr>
<tr><td><code id="getOptK_+3A_type">type</code></td>
<td>
<p>type of data generating process. Can be:
</p>

<ul>
<li> <p><code>"ar"</code>: For AR(1) series.
</p>
</li>
<li> <p><code>"ma"</code>: For MA(1) series.
</p>
</li>
<li> <p><code>"arma"</code>: For ARMA(1,1) series.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Identified optimal temporal aggregation level.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>


<ul>
<li><p> Kourentzes, N., Rostami-Tabar, B., &amp; Barrow, D. K. (2017). <a href="https://kourentzes.com/forecasting/2017/04/22/demand-forecasting-by-temporal-aggregation-using-optimal-or-multiple-aggregation-levels/">Demand forecasting by temporal aggregation: using optimal or multiple aggregation levels?</a>. Journal of Business Research, 78, 1-9.
</p>
</li>
<li><p> Rostami-Tabar, B., Babai, M. Z., Syntetos, A., &amp; Ducq, Y. (2013). Demand forecasting by temporal aggregation. Naval Research Logistics (NRL), 60(6), 479-498.
</p>
</li>
<li><p> Rostami-Tabar, B., Babai, M. Z., Syntetos, A., &amp; Ducq, Y. (2014). A note on the forecast performance of temporal aggregation. Naval Research Logistics (NRL), 61(7), 489-500.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>getOptK(referrals)

</code></pre>

<hr>
<h2 id='lagmatrix'>Create lead/lags of a variable</h2><span id='topic+lagmatrix'></span>

<h3>Description</h3>

<p>Create an array with lead/lags of an input variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagmatrix(x, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagmatrix_+3A_x">x</code></td>
<td>
<p>input variable.</p>
</td></tr>
<tr><td><code id="lagmatrix_+3A_lag">lag</code></td>
<td>
<p>vector of leads and lags. Positive numbers are lags, negative are leads. O is the original <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with the resulting leads and lags (columns).
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(10)
  lagmatrix(x,c(0,1,-1))

</code></pre>

<hr>
<h2 id='lambdaseq'>Generate sequence of lambda for LASSO regression</h2><span id='topic+lambdaseq'></span>

<h3>Description</h3>

<p>Calculates the <code>lambdaMax</code> value, which is the penalty term (lambda) beyond which coefficients are guaranteed to be all zero and provides a sequence of <code>nLambda</code> values to <code>lambdaMin</code> in logarithmic descent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaseq(
  x,
  y,
  weight = NA,
  alpha = 1,
  standardise = TRUE,
  lambdaRatio = 1e-04,
  nLambda = 100,
  addZeroLambda = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaseq_+3A_x">x</code></td>
<td>
<p>matrix of regressors. See <code>glmnet</code>.</p>
</td></tr>
<tr><td><code id="lambdaseq_+3A_y">y</code></td>
<td>
<p>response variable. See <code>glmnet</code>.</p>
</td></tr>
<tr><td><code id="lambdaseq_+3A_weight">weight</code></td>
<td>
<p>vector of <code>length(nrow(y))</code> for weighted LASSO estimation. See <code>glmnet</code>.</p>
</td></tr>
<tr><td><code id="lambdaseq_+3A_alpha">alpha</code></td>
<td>
<p>elastic net mixing value. See <code>glmnet</code>.</p>
</td></tr>
<tr><td><code id="lambdaseq_+3A_standardise">standardise</code></td>
<td>
<p>if <code>TRUE</code>, then variables are standardised.</p>
</td></tr>
<tr><td><code id="lambdaseq_+3A_lambdaratio">lambdaRatio</code></td>
<td>
<p>ratio between <code>lambdaMax</code> and <code>lambdaMin</code>. That is, <code>lambdaMin &lt;- lambdaMax * lambdaRatio</code>.</p>
</td></tr>
<tr><td><code id="lambdaseq_+3A_nlambda">nLambda</code></td>
<td>
<p>length of the lambda sequence.</p>
</td></tr>
<tr><td><code id="lambdaseq_+3A_addzerolambda">addZeroLambda</code></td>
<td>
<p>if <code>TRUE</code>, then set the last value in the lambda sequence to 0, which is the OLS solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
</p>

<ul>
<li> <p><code>lambda</code>: sequence of lambda values, from <code>lambdaMax</code> to <code>lambdaMin</code>.
</p>
</li>
<li> <p><code>lambdaMin</code>: minimal lambda value.
</p>
</li>
<li> <p><code>lambdaMax</code>: maximal lambda value.
</p>
</li>
<li> <p><code>nullMSE</code>: MSE of the fit using just a constant term.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Hastie, T., Tibshirani, R., &amp; Wainwright, M. (2015). Statistical learning with sparsity: the lasso and generalizations. CRC press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- mtcars[,1]
x &lt;- as.matrix(mtcars[,2:11])
lambda &lt;- lambdaseq(x, y)$lambda

## Not run: 
  library(glmnet)
  fit.lasso &lt;- cv.glmnet(x, y, lambda = lambda)
  coef.lasso &lt;- coef(fit.lasso, s = "lambda.1se")

## End(Not run)

</code></pre>

<hr>
<h2 id='leadtrail'>Remove leading/training zeros/NAs</h2><span id='topic+leadtrail'></span>

<h3>Description</h3>

<p>Remove leading or trailing zeros or NAs from a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leadtrail(
  x,
  rm = c("zeros", "na"),
  lead = c(TRUE, FALSE),
  trail = c(TRUE, FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leadtrail_+3A_x">x</code></td>
<td>
<p>vector of values to check.</p>
</td></tr>
<tr><td><code id="leadtrail_+3A_rm">rm</code></td>
<td>
<p>what to remove, can be <code>"zeros"</code> or <code>"na"</code>.</p>
</td></tr>
<tr><td><code id="leadtrail_+3A_lead">lead</code></td>
<td>
<p>If <code>TRUE</code>, then leading values are removed.</p>
</td></tr>
<tr><td><code id="leadtrail_+3A_trail">trail</code></td>
<td>
<p>If <code>TRUE</code>, then trailing values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Resulting vector.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rep(0,5),rnorm(100),rep(0,5))
leadtrail(x)

</code></pre>

<hr>
<h2 id='mseastest'>Multiplicative seasonality test</h2><span id='topic+mseastest'></span>

<h3>Description</h3>

<p>correlation based multiplicative seasonality test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseastest(
  y,
  m = NULL,
  type = c("pearson", "spearman", "kendall"),
  cma = NULL,
  sn = 1,
  alpha = 0.05,
  outplot = c(0, 1, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseastest_+3A_y">y</code></td>
<td>
<p>input time series. Can be <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="mseastest_+3A_m">m</code></td>
<td>
<p>seasonal period. If <code>y</code> is a <code>ts</code> object then the default is its frequency.</p>
</td></tr>
<tr><td><code id="mseastest_+3A_type">type</code></td>
<td>
<p>type of correlation
</p>

<ul>
<li><p><code>"pearson"</code>
</p>
</li>
<li><p><code>"spearman"</code>
</p>
</li>
<li><p><code>"kendall"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="mseastest_+3A_cma">cma</code></td>
<td>
<p>input precalculated level/trend for the analysis. Use <code>NULL</code> to calculate internally.</p>
</td></tr>
<tr><td><code id="mseastest_+3A_sn">sn</code></td>
<td>
<p>number of seasonal periods of decreasing magnitude to consider for the test.</p>
</td></tr>
<tr><td><code id="mseastest_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
<tr><td><code id="mseastest_+3A_outplot">outplot</code></td>
<td>
<p>type of output plot:
</p>

<ul>
<li> <p><code>0</code>: none.
</p>
</li>
<li> <p><code>1</code>: scatter plot.
</p>
</li>
<li> <p><code>2</code>: time series plot.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following:
</p>

<ul>
<li> <p><code>is.multiplicative</code>: if <code>TRUE</code> the test found evidence of multiplicative seasonality.
</p>
</li>
<li> <p><code>statistic</code>: test statistic.
</p>
</li>
<li> <p><code>pvalue</code>: p-value of the test.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mseastest(referrals)

</code></pre>

<hr>
<h2 id='nemenyi'>Nonparametric multiple comparisons (Nemenyi test)</h2><span id='topic+nemenyi'></span>

<h3>Description</h3>

<p>Perform nonparametric multiple comparisons, across columns, using the Friedman and the post-hoc Nemenyi tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nemenyi(
  data,
  conf.level = 0.95,
  sort = c(TRUE, FALSE),
  plottype = c("vline", "none", "mcb", "vmcb", "line", "matrix"),
  select = NULL,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nemenyi_+3A_data">data</code></td>
<td>
<p>an array that includes values to be compared for several treatments (in columns) for several observations (rows), of size n x k. For example, if these are forecast errors, different methods should be in columns and errors for different time series or forecast origins in rows.</p>
</td></tr>
<tr><td><code id="nemenyi_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level used for the comparison. Default is 0.95.</p>
</td></tr>
<tr><td><code id="nemenyi_+3A_sort">sort</code></td>
<td>
<p>if <code>TRUE</code>, then function sorts the outputted values of mean ranks. If plots are request, this is forced to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nemenyi_+3A_plottype">plottype</code></td>
<td>
<p>type of plot to produce:
</p>

<ul>
<li> <p><code>"none"</code>: no plot.
</p>
</li>
<li> <p><code>"mcb"</code>: <em>Multiple Comparison with the Best</em> style plot.
</p>
</li>
<li> <p><code>"vmcb"</code>: vertical <em>MCB</em> plot.
</p>
</li>
<li> <p><code>"line"</code>: summarised <em>line</em> plot.
</p>
</li>
<li> <p><code>"vline"</code>: vertical <em>line</em> plot.
</p>
</li>
<li> <p><code>"matrix"</code>: complete <em>matrix</em> visualisation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nemenyi_+3A_select">select</code></td>
<td>
<p>highlight selected treatment (column). Number 1 to k. Use NULL for no highlighting.</p>
</td></tr>
<tr><td><code id="nemenyi_+3A_labels">labels</code></td>
<td>
<p>optional labels for models. If NULL column names of <code>data</code> will be used.</p>
</td></tr>
<tr><td><code id="nemenyi_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return object of class <code>nemenyi</code> and contains:
</p>

<ul>
<li> <p><code>means</code>: mean rank of each treatment.
</p>
</li>
<li> <p><code>intervals</code>: intervals within there is no evidence of significance difference according to the Nemenyi test at requested confidence level.
</p>
</li>
<li> <p><code>fpavl</code>: Friedman test p-value.
</p>
</li>
<li> <p><code>fH</code>: Friedman test hypothesis outcome.
</p>
</li>
<li> <p><code>cd</code>: Nemenyi critical distance. Output <code>intervals</code> is calculate as <code>means</code> +/- <code>cd</code>.
</p>
</li>
<li> <p><code>conf.level</code>: confidence level used for testing.
</p>
</li>
<li> <p><code>k</code>: number of treatments (columns).
</p>
</li>
<li> <p><code>n</code>: number of observations (rows).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>,
</p>
<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>.
</p>


<h3>References</h3>


<ul>
<li><p> The tests are deailed by Hollander, M., Wolfe, D.A. and Chicken, E. (2014) Nonparametric Statistical Methods. 3rd Edition, John Wiley &amp; Sons, Inc., New York.
</p>
</li>
<li><p> The <em>line</em> plot is introduced <a href="https://kourentzes.com/forecasting/wp-content/uploads/2014/04/ISF2012_Tests_Kourentzes.pdf">here</a> and a first example of its use, along with a short description is provided by Kourentzes, N. (2013). <a href="https://kourentzes.com/forecasting/2013/04/19/intermittent-demand-forecasts-with-neural-networks/">Intermittent demand forecasts with neural networks</a>. International Journal of Production Economics, 143(1), 198-206.
</p>
</li>
<li><p> The <em>matrix</em> plot is introduced by Kourentzes, N., &amp; Athanasopoulos, G. (2018). Cross-temporal coherent forecasts for Australian tourism (No. 24/18). Monash University, Department of Econometrics and Business Statistics.
</p>
</li>
<li><p> The <em>MCB</em> plot is described by Koning, A. J., Franses, P. H., Hibon, M., &amp; Stekler, H. O. (2005). The M3 competition: Statistical tests of the results. International Journal of Forecasting, 21(3), 397-409.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( rnorm(50*4,mean=0,sd=1), 50, 4)
x[,2] &lt;- x[,2]+1
x[,3] &lt;- x[,3]+0.7
x[,4] &lt;- x[,4]+0.5
colnames(x) &lt;- c("Method A","Method B","Method C - long name","Method D")
nemenyi(x,conf.level=0.95,plottype="vline")

</code></pre>

<hr>
<h2 id='plotSthief'>Plot temporal hierarchy</h2><span id='topic+plotSthief'></span>

<h3>Description</h3>

<p>Plots the temporal hierarchy for a given time series of seasonal periodicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSthief(y, labels = c(TRUE, FALSE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSthief_+3A_y">y</code></td>
<td>
<p>input time series (a <code>ts</code> object) or an integer.</p>
</td></tr>
<tr><td><code id="plotSthief_+3A_labels">labels</code></td>
<td>
<p>if <code>TRUE</code> labels will be added for the temporal aggregation levels if the seasonal period is 4 (quarters), 7 (days in a week), 12 (months), 24 (hours), 48 (half-hours), 52 (weeks) or 364 (days).</p>
</td></tr>
<tr><td><code id="plotSthief_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a plot of the temporal hierarchy.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Athanasopoulos, G., Hyndman, R. J., Kourentzes, N., &amp; Petropoulos, F. (2017). <a href="https://kourentzes.com/forecasting/2017/02/27/forecasting-with-temporal-hierarchies-3/">Forecasting with temporal hierarchies</a>. European Journal of Operational Research, 262(1), 60-74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotSthief(AirPassengers)

</code></pre>

<hr>
<h2 id='referrals'>NHS A&amp;E Referrals</h2><span id='topic+referrals'></span>

<h3>Description</h3>

<p>Monthly Accident &amp; Emergency referrals for England and Wales.
</p>


<h3>References</h3>

<p><a href="https://www.england.nhs.uk/statistics/statistical-work-areas/ae-waiting-times-and-activity/">https://www.england.nhs.uk/statistics/statistical-work-areas/ae-waiting-times-and-activity/</a>
</p>

<hr>
<h2 id='residout'>Residuals control chart</h2><span id='topic+residout'></span>

<h3>Description</h3>

<p>Create a control chart of residuals and identify outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residout(resid, t = 2, outplot = c(TRUE, FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residout_+3A_resid">resid</code></td>
<td>
<p>vector of residuals.</p>
</td></tr>
<tr><td><code id="residout_+3A_t">t</code></td>
<td>
<p>threshold value over which standardised residuals are regarded as outliers.</p>
</td></tr>
<tr><td><code id="residout_+3A_outplot">outplot</code></td>
<td>
<p>if <code>TRUE</code>, then a control chart of the standardised residuals is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>location</code>: locations of outliers.
</p>
</li>
<li> <p><code>outliers</code>: values of outliers.
</p>
</li>
<li> <p><code>residuals</code>: standardised residuals.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>residout(rnorm(50), outplot=TRUE)

</code></pre>

<hr>
<h2 id='seasdummy'>Create seasonal dummy variables.</h2><span id='topic+seasdummy'></span>

<h3>Description</h3>

<p>Create binary or trigonometric seasonal dummies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasdummy(n, m = NULL, y = NULL, type = c("bin", "trg"), full = c(FALSE, TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasdummy_+3A_n">n</code></td>
<td>
<p>number of observations to create.</p>
</td></tr>
<tr><td><code id="seasdummy_+3A_m">m</code></td>
<td>
<p>seasonal periodicity. If <code>NULL</code> it will take the information from the provided time series (<code>y</code> argument). See notes.</p>
</td></tr>
<tr><td><code id="seasdummy_+3A_y">y</code></td>
<td>
<p>this is an optional time series input that can be used to get seasonal periodicity (<code>m</code>) and the start point.</p>
</td></tr>
<tr><td><code id="seasdummy_+3A_type">type</code></td>
<td>
<p>type of seasonal dummies to create.
</p>

<ul>
<li> <p><code>"bin}: binary dummies.
\item \code{"trg</code>: trigonometric dummies. See notes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="seasdummy_+3A_full">full</code></td>
<td>
<p>If full is <code>TRUE</code>, then keeps the m-th dummy that is co-linear to the rest. See notes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with seasonal dummies, where rows correspond observations and columns to dummy variables.
</p>


<h3>Note</h3>

<p>If the seasonal periodicity is fractional then the the type will be overriden to trigonometric and only two seasonal dummies with be produced. One cosine and one sine.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seasdummy(24,12)

</code></pre>

<hr>
<h2 id='seasplot'>Seasonal plots with simplistic trend/season tests</h2><span id='topic+seasplot'></span>

<h3>Description</h3>

<p>Construct seasonal plots of various styles for a given time series. The series can automatically detrended as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasplot(
  y,
  m = NULL,
  s = NULL,
  trend = NULL,
  colour = NULL,
  alpha = 0.05,
  outplot = c(1, 0, 2, 3, 4, 5),
  decomposition = c("multiplicative", "additive", "auto"),
  cma = NULL,
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasplot_+3A_y">y</code></td>
<td>
<p>input time series. Can be <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_m">m</code></td>
<td>
<p>seasonal period. If <code>y</code> is a <code>ts</code> object then the default is its frequency.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_s">s</code></td>
<td>
<p>starting period in the season. If <code>y</code> is a <code>ts</code> object then this is picked up from <code>y</code>.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_trend">trend</code></td>
<td>
<p>if <code>TRUE</code>, then presence of trend is assumed and removed. If <code>FALSE</code> no trend is assumed. Use <code>NULL</code> to identify automatically.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_colour">colour</code></td>
<td>
<p>single colour override for plots.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_alpha">alpha</code></td>
<td>
<p>significance level for statistical tests.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_outplot">outplot</code></td>
<td>
<p>type of seasonal plot
</p>

<ul>
<li> <p><code>0</code>: none.
</p>
</li>
<li> <p><code>1</code>: seasonal diagram.
</p>
</li>
<li> <p><code>2</code>: seasonal boxplots.
</p>
</li>
<li> <p><code>3</code>: seasonal subseries.
</p>
</li>
<li> <p><code>4</code>: seasonal distribution.
</p>
</li>
<li> <p><code>5</code>: seasonal density.
</p>
</li></ul>
</td></tr>
<tr><td><code id="seasplot_+3A_decomposition">decomposition</code></td>
<td>
<p>type of seasonal decomposition. This can be <code>"multiplicative"</code>, <code>"additive"</code> or <code>"auto"</code>. If <code>y</code> contains non-positive values then this is forced to <code>"additive"</code>.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_cma">cma</code></td>
<td>
<p>input precalculated level/trend for the analysis. This overrides <code>trend=NULL</code>.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_labels">labels</code></td>
<td>
<p>external labels for the seasonal periods. Use <code>NULL</code> for none. If <code>length(labels) &lt; m</code>, then this input is ignored.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plotting functions. For example, use <code>main=""</code> to replace the title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>seasexpl</code> containing:
</p>

<ul>
<li> <p><code>season</code>: matrix of (detrended) seasonal elements.
</p>
</li>
<li> <p><code>season.exist</code>: <code>TRUE</code>/<code>FALSE</code> results of seasonality test.
</p>
</li>
<li> <p><code>season.pval</code>: p-value of seasonality test (Friedman test).
</p>
</li>
<li> <p><code>trend</code>: CMA estimate (using <code><a href="#topic+cmav">cmav</a></code>) or <code>NULL</code> if <code>trend=FALSE</code>.
</p>
</li>
<li> <p><code>trend.exist</code>: <code>TRUE</code>/<code>FALSE</code> results of trend test.
</p>
</li>
<li> <p><code>trend.pval</code>: p-value of trend test (Cox-Stuart).
</p>
</li>
<li> <p><code>decomposition</code>: type of decomposition used.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seasplot(referrals,outplot=1)

</code></pre>

<hr>
<h2 id='Sthief'>Temporal hierarchy S matrix</h2><span id='topic+Sthief'></span>

<h3>Description</h3>

<p>Calculate the temporal hierarchy summing matrix S for a given time series of seasonal periodicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sthief(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sthief_+3A_y">y</code></td>
<td>
<p>input time series (a <code>ts</code> object) or an integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S matrix.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Athanasopoulos, G., Hyndman, R. J., Kourentzes, N., &amp; Petropoulos, F. (2017). <a href="https://kourentzes.com/forecasting/2017/02/27/forecasting-with-temporal-hierarchies-3/">Forecasting with temporal hierarchies</a>. European Journal of Operational Research, 262(1), 60-74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sthief(AirPassengers)

</code></pre>

<hr>
<h2 id='theta'>Theta method</h2><span id='topic+theta'></span><span id='topic+forecast.theta'></span><span id='topic+plot.theta'></span><span id='topic+theta.thief'></span>

<h3>Description</h3>

<p>Estimate Theta method.
</p>
<p>Forecast with fitted Theta method.
</p>
<p>Produce a plot of the fitted Theta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta(
  y,
  m = NULL,
  sign.level = 0.05,
  cost0 = c("MSE", "MdSE", "MAE", "MdAE"),
  cost2 = c("MSE", "MdSE", "MAE", "MdAE"),
  costs = c("MSE", "MdSE", "MAE", "MdAE"),
  multiplicative = c("multiplicative", "additive", "auto"),
  cma = NULL,
  outliers = NULL
)

## S3 method for class 'theta'
forecast(object, h = NULL, ...)

## S3 method for class 'theta'
plot(x, thetalines = c(TRUE, FALSE), ...)

theta.thief(y, h = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_+3A_y">y</code></td>
<td>
<p>input time series. Can be <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="theta_+3A_m">m</code></td>
<td>
<p>seasonal period. If <code>y</code> is a <code>ts</code> object then the default is its frequency.</p>
</td></tr>
<tr><td><code id="theta_+3A_sign.level">sign.level</code></td>
<td>
<p>significance level for trend and seasonality tests.</p>
</td></tr>
<tr><td><code id="theta_+3A_cost0">cost0</code></td>
<td>
<p>cost function of theta0 line. Can be:
</p>

<ul>
<li> <p><code>"MSE"</code>: mean squared error.
</p>
</li>
<li> <p><code>"MdSE"</code>: median squared error.
</p>
</li>
<li> <p><code>"MAE"</code>: mean absolute error.
</p>
</li>
<li> <p><code>"MdAE"</code>: median absolute error.
</p>
</li></ul>
</td></tr>
<tr><td><code id="theta_+3A_cost2">cost2</code></td>
<td>
<p>cost function of theta2 line. Same options as <code>cost0</code>.</p>
</td></tr>
<tr><td><code id="theta_+3A_costs">costs</code></td>
<td>
<p>cost function of seasonal element. Same options as <code>cost0</code>.</p>
</td></tr>
<tr><td><code id="theta_+3A_multiplicative">multiplicative</code></td>
<td>
<p>type of seasonal decomposition. This can be <code>"multiplicative"</code>, <code>"additive"</code> or <code>"auto"</code>. If <code>y</code> contains non-positive values then this is forced to <code>"additive"</code>.</p>
</td></tr>
<tr><td><code id="theta_+3A_cma">cma</code></td>
<td>
<p>input precalculated level/trend for the analysis. Use <code>NULL</code> to estimate internally.</p>
</td></tr>
<tr><td><code id="theta_+3A_outliers">outliers</code></td>
<td>
<p>provide vector of location of observations that are considered outliers (see <code><a href="#topic+residout">residout</a></code>). These will be considered in the estimation of theta0. For no outliers use <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="theta_+3A_object">object</code></td>
<td>
<p>object of class <code>theta</code>.</p>
</td></tr>
<tr><td><code id="theta_+3A_h">h</code></td>
<td>
<p>forecast horizon. If <code>h</code> is <code>NULL</code>, then the horizon is set equal to the the seasonal frequency.</p>
</td></tr>
<tr><td><code id="theta_+3A_...">...</code></td>
<td>
<p>additional arguments passed to functions.</p>
</td></tr>
<tr><td><code id="theta_+3A_x">x</code></td>
<td>
<p>object of class <code>theta</code>.</p>
</td></tr>
<tr><td><code id="theta_+3A_thetalines">thetalines</code></td>
<td>
<p>if <code>TRUE</code>, then theta lines are included in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of the Theta method tests automatically for seasonality and trend. Seasonal decomposition can be done either additively or multiplicatively and the seasonality is treated as a pure seasonal model. The various Theta components can be optimised using different cost functions. The originally proposed Theta method always assumed multiplicative seasonality and presence of trend, while all theta lines were optimised using MSE and seasonality was estimated using classical decomposition.
</p>


<h3>Value</h3>

<p>An object of class <code>theta</code>, containing:
</p>

<ul>
<li> <p><code>"method"</code>: &quot;Theta&quot;.
</p>
</li>
<li> <p><code>"y"</code>: the input time series.
</p>
</li>
<li> <p><code>"m"</code>: seasonal periods.
</p>
</li>
<li> <p><code>"exist"</code>: Statistical testing results, <code>exist[1]</code> is the result for trend, <code>exist[2]</code> is for season.
</p>
</li>
<li> <p><code>"multiplicative"</code>: If <code>TRUE</code>, then seasonality is modelled multiplicatively.
</p>
</li>
<li> <p><code>"theta0"</code>: fitted theta0 line values.
</p>
</li>
<li> <p><code>"theta2"</code>: fitted theta2 line values.
</p>
</li>
<li> <p><code>"season"</code>: fitted season values.
</p>
</li>
<li> <p><code>"x.out"</code>: modelled outliers.
</p>
</li>
<li> <p><code>"cost"</code>: cost functions for theta0, theta2 and season components.
</p>
</li>
<li> <p><code>"a"</code>: SES parameters of theta2.
</p>
</li>
<li> <p><code>"b"</code>: regression parameters of theta0.
</p>
</li>
<li> <p><code>"p"</code>: coefficients of outliers from theta0 and theta2 estimation.
</p>
</li>
<li> <p><code>"g"</code>: pure seasonal exponential smoothing parameters.
</p>
</li>
<li> <p><code>"fitted"</code>: fitted values.
</p>
</li>
<li> <p><code>"residuals"</code>: in-sample residuals.
</p>
</li>
<li> <p><code>"MSE"</code>: in-sample Mean Squared Error.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>theta.thief()</code>: Wrapper function to use Theta with <code><a href="thief.html#topic+thief">thief</a></code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>


<ul>
<li><p> The original Theta method was proposed by: Assimakopoulos, V., &amp; Nikolopoulos, K. (2000). The theta model: a decomposition approach to forecasting. International journal of forecasting, 16(4), 521-530. See details in how the implementation here differs.
</p>
</li>
<li><p> The THieF forecasting methodology used for <code>theta.thief</code> is proposed by: Athanasopoulos, G., Hyndman, R. J., Kourentzes, N., &amp; Petropoulos, F. (2017). Forecasting with temporal hierarchies. European Journal of Operational Research, 262(1), 60-74.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- theta(referrals)
plot(fit)

forecast.theta(fit,h=12) # Or simply use forecast(fit)

## Not run: 
library(thief)
thief(referrals,forecastfunction=theta.thief)

## End(Not run)

</code></pre>

<hr>
<h2 id='trendtest'>Test a time series for trend</h2><span id='topic+trendtest'></span>

<h3>Description</h3>

<p>Test a time series for trend by either fitting exponential smoothing models and comparing then using the AICc, or by using the non-parametric Cox-Stuart test. The tests can be augmented by using multiple temporal aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trendtest(
  y,
  extract = c("FALSE", "TRUE"),
  type = c("aicc", "cs"),
  mta = c(FALSE, TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trendtest_+3A_y">y</code></td>
<td>
<p>a time series that must be of either <code>ts</code> or <code>msts</code> class.</p>
</td></tr>
<tr><td><code id="trendtest_+3A_extract">extract</code></td>
<td>
<p>if <code>TRUE</code> then the centred moving average of the time series is calculated and the test is performed on that. Otherwise, the test is performed on the raw data.</p>
</td></tr>
<tr><td><code id="trendtest_+3A_type">type</code></td>
<td>
<p>type of test. Can be:
</p>

<ul>
<li> <p><code>"aicc"</code>: test by comparing the AICc of exponential smoothing models. See details.
</p>
</li>
<li> <p><code>"cs"</code>: test by using the Cox-Stuart test. See details.&lt;
</p>
</li></ul>
</td></tr>
<tr><td><code id="trendtest_+3A_mta">mta</code></td>
<td>
<p>If <code>TRUE</code> augment testing by using Multiple Temporal Aggregation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All tests are performed at 5
</p>


<h3>Value</h3>

<p>The function returns <code>TRUE</code> when there is evidence of trend and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>The multiple temporal aggregation follows the construction approach suggested by Kourentzes, N., Petropoulos, F., &amp; Trapero, J. R. (2014). <a href="https://kourentzes.com/forecasting/2014/04/19/improving-forecasting-by-estimating-time-series-structural-components-across-multiple-frequencies/">Improving forecasting by estimating time series structural components across multiple frequencies</a>. International Journal of Forecasting, 30(2), 291-302.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trendtest(referrals,TRUE)

</code></pre>

<hr>
<h2 id='tsutils'>tsutils: Time Series Exploration, Modelling and Forecasting</h2><span id='topic+tsutils'></span>

<h3>Description</h3>

<p>The <span class="pkg">tsutils</span> package provides functions to support various aspects of time series and forecasting modelling. In particular this package includes: (i) tests and visualisations that can help the modeller explore time series components and perform decomposition; (ii) modelling shortcuts, such as functions to construct lagmatrices and seasonal dummy variables of various forms; (iii) an implementation of the Theta method; (iv) tools to facilitate the design of the forecasting process, such as ABC-XYZ analyses; and (v) &quot;quality of life&quot; tools, such as treating time series for trailing and leading values.
</p>


<h3>Time series exploration</h3>


<ul>
<li> <p><code><a href="#topic+cmav">cmav</a></code>: centred moving average.
</p>
</li>
<li> <p><code><a href="#topic+coxstuart">coxstuart</a></code>: Cox-Stuart test for location/dispersion.
</p>
</li>
<li> <p><code><a href="#topic+decomp">decomp</a></code>: classical time series decomposition.
</p>
</li>
<li> <p><code><a href="#topic+seasplot">seasplot</a></code>: construct seasonal plots.
</p>
</li>
<li> <p><code><a href="#topic+trendtest">trendtest</a></code>: test a time series for trend.
</p>
</li></ul>



<h3>Time series modelling</h3>


<ul>
<li> <p><code><a href="#topic+getOptK">getOptK</a></code>: optimal temporal aggregation level for AR(1), MA(1), ARMA(1,1).
</p>
</li>
<li> <p><code><a href="#topic+lagmatrix">lagmatrix</a></code>: create leads/lags of variable.
</p>
</li>
<li> <p><code><a href="#topic+nemenyi">nemenyi</a></code>: nonparametric multiple comparisons.
</p>
</li>
<li> <p><code><a href="#topic+residout">residout</a></code>: construct control chart of residuals.
</p>
</li>
<li> <p><code><a href="#topic+seasdummy">seasdummy</a></code>: create seasonal dummies.
</p>
</li>
<li> <p><code><a href="#topic+theta">theta</a></code>: Theta method.
</p>
</li></ul>



<h3>Hierarchical time series</h3>


<ul>
<li> <p><code><a href="#topic+Sthief">Sthief</a></code>: temporal hierarchy S matrix.
</p>
</li>
<li> <p><code><a href="#topic+plotSthief">plotSthief</a></code>: plot temporal hierarchy S matrix.
</p>
</li></ul>



<h3>Forecasting process modelling</h3>


<ul>
<li> <p><code><a href="#topic+abc">abc</a></code>: ABC analysis.
</p>
</li>
<li> <p><code><a href="#topic+xyz">xyz</a></code>: XYZ analysis.
</p>
</li>
<li> <p><code><a href="#topic+abcxyz">abcxyz</a></code>: ABC-XYZ analyses visualisation.
</p>
</li></ul>



<h3>Quality of life</h3>


<ul>
<li> <p><code><a href="#topic+geomean">geomean</a></code>: geometric mean.
</p>
</li>
<li> <p><code><a href="#topic+lambdaseq">lambdaseq</a></code>: generate sequence of lambda for LASSO regression.
</p>
</li>
<li> <p><code><a href="#topic+leadtrail">leadtrail</a></code>: remove leading/training zeros/NAs.
</p>
</li>
<li> <p><code><a href="#topic+wins">wins</a></code>: winsorisation, including vectorised versions <code>colWins</code> and <code>rowWins</code>.
</p>
</li></ul>



<h3>Time series data</h3>


<ul>
<li> <p><code><a href="#topic+referrals">referrals</a></code>: A&amp;E monthly referrals.
</p>
</li></ul>


<hr>
<h2 id='wins'>Winsorise</h2><span id='topic+wins'></span><span id='topic+colWins'></span><span id='topic+rowWins'></span>

<h3>Description</h3>

<p>Winsorise either by number or percentage of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wins(x, p = 0.05)

colWins(x, p = 0.05)

rowWins(x, p = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wins_+3A_x">x</code></td>
<td>
<p>input data. NAs will be removed.</p>
</td></tr>
<tr><td><code id="wins_+3A_p">p</code></td>
<td>
<p>percentage or number of observations to be winsorised. If value is &lt;1 then it is used as a percentages. Otherwise it is the number of observations to winsorise. If the resulting p &gt; floor((length(x)-1)/2), then it is set equal to floor((length(x)-1)/2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Winsorised vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>colWins()</code>: Vectorised version of wins by columns.
</p>
</li>
<li> <p><code>rowWins()</code>: Vectorised version of wins by rows.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100,mean=0,sd=1)
xW &lt;- wins(x)

</code></pre>

<hr>
<h2 id='xyz'>XYZ analysis</h2><span id='topic+xyz'></span>

<h3>Description</h3>

<p>Perform XYZ analysis on a set of time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz(x, m = NULL, prc = c(0.2, 0.3, 0.5), type = c("naive", "ets", "cv"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz_+3A_x">x</code></td>
<td>
<p>this can either be an array, where each column is a series, or a vector of values. If <code>x</code> is a vector of values forecastability is not calculated and the input is used as such.</p>
</td></tr>
<tr><td><code id="xyz_+3A_m">m</code></td>
<td>
<p>seasonal length for time series. Required when type is <code>"naive"</code> or <code>"ets"</code>.</p>
</td></tr>
<tr><td><code id="xyz_+3A_prc">prc</code></td>
<td>
<p>a vector of percentages indicating how many items are included in each class. By default this is <code>c(0.2,0.3,0.5)</code>, but any set of percentage values can be used as long as <code>0&lt;=prc[i]&lt;=1</code> and <code>sum(prc)==1</code>.</p>
</td></tr>
<tr><td><code id="xyz_+3A_type">type</code></td>
<td>
<p>the type of forecastability calculation. This can be:
</p>

<ul>
<li> <p><code>"naive"</code>: fit naive and seasonal naive and calculate forecastability using RMSE/mean level.
</p>
</li>
<li> <p><code>"ets"</code>: fit ets and calculate and calculate forecastability using RMSE/mean level.
</p>
</li>
<li> <p><code>"cv"</code>: use coefficient of variation as a proxy of forecastability.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Return object of class <code>abc</code> and contains:
</p>

<ul>
<li> <p><code>value</code>: a vector containing the forecastability value of each series.
</p>
</li>
<li> <p><code>class</code>: a vector containing the class membership of each series.
</p>
</li>
<li> <p><code>rank</code>: a vector containing the rank of each series, with 1 being the lowest forecastability series.
</p>
</li>
<li> <p><code>conc</code>: the forecastability concentration of each class, as percentage of total value.
</p>
</li>
<li> <p><code>model</code>: fitted model for each series.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>.
</p>


<h3>References</h3>

<p>Ord K., Fildes R., Kourentzes N. (2017) <a href="https://kourentzes.com/forecasting/2017/10/16/new-forecasting-book-principles-of-business-forecasting-2e/">Principles of Business Forecasting, 2e</a>. <em>Wessex Press Publishing Co.</em>, p.515-518.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abc">abc</a></code>, <code><a href="#topic+plot.abc">plot.abc</a></code>, <code><a href="#topic+abcxyz">abcxyz</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- abs(matrix(cumsum(rnorm(5400,0,1)),36,150))
z &lt;- xyz(x,m=12)
print(z)
plot(z)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
