<!DOCTYPE html><html lang="en"><head><title>Help for package tidyselect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyselect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyselect-package'><p>tidyselect: Select from a Set of Strings</p></a></li>
<li><a href='#all_of'><p>Select variables from character vectors</p></a></li>
<li><a href='#eval_relocate'><p>Evaluate an expression to relocate variables</p></a></li>
<li><a href='#eval_rename'><p>Evaluate an expression with tidyselect semantics</p></a></li>
<li><a href='#everything'><p>Select all variables or the last variable</p></a></li>
<li><a href='#faq-external-vector'><p>FAQ - Note: Using an external vector in selections is ambiguous</p></a></li>
<li><a href='#faq-selection-context'><p>FAQ - Error: Must be used within a <em>selecting</em> function</p></a></li>
<li><a href='#language'><p>Selection language</p></a></li>
<li><a href='#one_of'><p>Superseded selection helpers</p></a></li>
<li><a href='#peek_vars'><p>Peek at variables in the selection context</p></a></li>
<li><a href='#poke_vars'><p>Replace or get current variables</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#starts_with'><p>Select variables that match a pattern</p></a></li>
<li><a href='#tidyselect_data_proxy'><p>tidyselect methods for custom types</p></a></li>
<li><a href='#vars_pull'><p>Select variable</p></a></li>
<li><a href='#vars_select'><p>Select or rename variables</p></a></li>
<li><a href='#vars_select_helpers'><p>List of selection helpers</p></a></li>
<li><a href='#where'><p>Select variables with a function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Select from a Set of Strings</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A backend for the selecting functions of the 'tidyverse'.  It
    makes it easy to implement select-like functions in your own packages
    in a way that is consistent with other 'tidyverse' interfaces for
    selection.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tidyselect.r-lib.org">https://tidyselect.r-lib.org</a>, <a href="https://github.com/r-lib/tidyselect">https://github.com/r-lib/tidyselect</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/tidyselect/issues">https://github.com/r-lib/tidyselect/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.3.0), glue (&ge; 1.3.0), lifecycle (&ge; 1.0.3), rlang
(&ge; 1.0.4), vctrs (&ge; 0.5.2), withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, crayon, dplyr, knitr, magrittr, rmarkdown, stringr,
testthat (&ge; 3.1.1), tibble (&ge; 2.1.3)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-11 11:46:04 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Lionel Henry [aut, cre],
  Hadley Wickham [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lionel Henry &lt;lionel@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-11 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyselect-package'>tidyselect: Select from a Set of Strings</h2><span id='topic+tidyselect'></span><span id='topic+tidyselect-package'></span>

<h3>Description</h3>

<p>A backend for the selecting functions of the 'tidyverse'. It makes it easy to implement select-like functions in your own packages in a way that is consistent with other 'tidyverse' interfaces for selection.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lionel Henry <a href="mailto:lionel@posit.co">lionel@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tidyselect.r-lib.org">https://tidyselect.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/tidyselect">https://github.com/r-lib/tidyselect</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/tidyselect/issues">https://github.com/r-lib/tidyselect/issues</a>
</p>
</li></ul>


<hr>
<h2 id='all_of'>Select variables from character vectors</h2><span id='topic+all_of'></span><span id='topic+any_of'></span>

<h3>Description</h3>

<p>These <a href="#topic+language">selection helpers</a> select variables
contained in a character vector. They are especially useful for
programming with selecting functions.
</p>

<ul>
<li> <p><code><a href="#topic+all_of">all_of()</a></code> is for strict selection. If any of the variables in
the character vector is missing, an error is thrown.
</p>
</li>
<li> <p><code><a href="#topic+any_of">any_of()</a></code> doesn't check for missing variables. It is especially
useful with negative selections, when you would like to make sure
a variable is removed.
</p>
</li></ul>

<p>The order of selected columns is determined by the order in the
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_of(x)

any_of(x, ..., vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_of_+3A_x">x</code></td>
<td>
<p>A vector of character names or numeric locations.</p>
</td></tr>
<tr><td><code id="all_of_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="all_of_+3A_vars">vars</code></td>
<td>
<p>A character vector of variable names. If not supplied,
the variables are taken from the current selection context (as
established by functions like <code>select()</code> or <code>pivot_longer()</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Selection helpers can be used in functions like <code>dplyr::select()</code>
or <code>tidyr::pivot_longer()</code>. Let's first attach the tidyverse:
</p>
<div class="sourceCode r"><pre>library(tidyverse)

# For better printing
iris &lt;- as_tibble(iris)
</pre></div>
<p>It is a common to have a names of variables in a vector.
</p>
<div class="sourceCode r"><pre>vars &lt;- c("Sepal.Length", "Sepal.Width")

iris[, vars]
#&gt; # A tibble: 150 x 2
#&gt;   Sepal.Length Sepal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5
#&gt; 2          4.9         3  
#&gt; 3          4.7         3.2
#&gt; 4          4.6         3.1
#&gt; # i 146 more rows
</pre></div>
<p>To refer to these variables in selecting function, use <code>all_of()</code>:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(all_of(vars))
#&gt; # A tibble: 150 x 2
#&gt;   Sepal.Length Sepal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5
#&gt; 2          4.9         3  
#&gt; 3          4.7         3.2
#&gt; 4          4.6         3.1
#&gt; # i 146 more rows

iris %&gt;% pivot_longer(all_of(vars))
#&gt; # A tibble: 300 x 5
#&gt;   Petal.Length Petal.Width Species name         value
#&gt;          &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1          1.4         0.2 setosa  Sepal.Length   5.1
#&gt; 2          1.4         0.2 setosa  Sepal.Width    3.5
#&gt; 3          1.4         0.2 setosa  Sepal.Length   4.9
#&gt; 4          1.4         0.2 setosa  Sepal.Width    3  
#&gt; # i 296 more rows
</pre></div>
<p>If any of the variable is missing from the data frame, that's an error:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(all_of(vars))
#&gt; Error:
#&gt; i In argument: `all_of(vars)`.
#&gt; Caused by error in `all_of()` at rlang/R/eval-tidy.R:121:3:
#&gt; ! Can't subset elements that don't exist.
#&gt; x Elements `Sepal.Length` and `Sepal.Width` don't exist.
</pre></div>
<p>Use <code>any_of()</code> to allow missing variables:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(any_of(vars))
#&gt; # A tibble: 87 x 0
</pre></div>
<p><code>any_of()</code> is especially useful to remove variables from a data
frame because calling it again does not cause an error:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(-any_of(vars))
#&gt; # A tibble: 150 x 3
#&gt;   Petal.Length Petal.Width Species
#&gt;          &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1          1.4         0.2 setosa 
#&gt; 2          1.4         0.2 setosa 
#&gt; 3          1.3         0.2 setosa 
#&gt; 4          1.5         0.2 setosa 
#&gt; # i 146 more rows

iris %&gt;% select(-any_of(vars)) %&gt;% select(-any_of(vars))
#&gt; # A tibble: 150 x 3
#&gt;   Petal.Length Petal.Width Species
#&gt;          &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1          1.4         0.2 setosa 
#&gt; 2          1.4         0.2 setosa 
#&gt; 3          1.3         0.2 setosa 
#&gt; 4          1.5         0.2 setosa 
#&gt; # i 146 more rows
</pre></div>


<h3>See Also</h3>

<p>The <a href="#topic+language">selection language</a> page, which includes links to other selection helpers.
</p>

<hr>
<h2 id='eval_relocate'>Evaluate an expression to relocate variables</h2><span id='topic+eval_relocate'></span>

<h3>Description</h3>

<p><code>eval_relocate()</code> is a variant of <code><a href="#topic+eval_select">eval_select()</a></code> that moves a selection to
a new location. Either <code>before</code> or <code>after</code> can be provided to specify where
to move the selection to. This powers <code>dplyr::relocate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_relocate(
  expr,
  data,
  ...,
  before = NULL,
  after = NULL,
  strict = TRUE,
  name_spec = NULL,
  allow_rename = TRUE,
  allow_empty = TRUE,
  allow_predicates = TRUE,
  before_arg = "before",
  after_arg = "after",
  env = caller_env(),
  error_call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_relocate_+3A_expr">expr</code></td>
<td>
<p>Defused R code describing a selection according to the
tidyselect syntax.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_data">data</code></td>
<td>
<p>A named list, data frame, or atomic vector.
Technically, <code>data</code> can be any vector with <code>names()</code> and <code>"[["</code>
implementations.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_before">before</code>, <code id="eval_relocate_+3A_after">after</code></td>
<td>
<p>Defused R code describing a selection according to the
tidyselect syntax. The selection represents the destination of the
selection provided through <code>expr</code>. Supplying neither of these will move the
selection to the left-hand side. Supplying both of these is an error.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, out-of-bounds errors are thrown if <code>expr</code>
attempts to select or rename a variable that doesn't exist. If
<code>FALSE</code>, failed selections or renamings are ignored.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_name_spec">name_spec</code></td>
<td>
<p>A name specification describing how to combine or
propagate names. This is used only in case nested <code>c()</code>
expressions like <code>c(foo = c(bar = starts_with("foo")))</code>. See the
<code>name_spec</code> argument of <code><a href="vctrs.html#topic+vec_c">vctrs::vec_c()</a></code> for a description of
valid name specs.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_allow_rename">allow_rename</code></td>
<td>
<p>If <code>TRUE</code> (the default), the renaming syntax
<code>c(foo = bar)</code> is allowed. If <code>FALSE</code>, it causes an error. This
is useful to implement purely selective behaviour.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_allow_empty">allow_empty</code></td>
<td>
<p>If <code>TRUE</code> (the default), it is ok for <code>expr</code> to result
in an empty selection. If <code>FALSE</code>, will error if <code>expr</code> yields an empty
selection.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_allow_predicates">allow_predicates</code></td>
<td>
<p>If <code>TRUE</code> (the default), it is ok for <code>expr</code> to
use predicates (i.e. in <code>where()</code>). If <code>FALSE</code>, will error if <code>expr</code> uses a
predicate. Will automatically be set to <code>FALSE</code> if <code>data</code> does not
support predicates (as determined by <code><a href="#topic+tidyselect_data_has_predicates">tidyselect_data_has_predicates()</a></code>).</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_before_arg">before_arg</code>, <code id="eval_relocate_+3A_after_arg">after_arg</code></td>
<td>
<p>Argument names for <code>before</code> and <code>after</code>. These
are used in error messages.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>. Discarded
if <code>expr</code> is a <a href="rlang.html#topic+enquo">quosure</a>.</p>
</td></tr>
<tr><td><code id="eval_relocate_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of numeric locations with length equal to <code>length(data)</code>.
Each position in <code>data</code> will be represented exactly once.
</p>
<p>The names are normally the same as in the input data, except when the user
supplied named selections with <code>c()</code>. In the latter case, the names reflect
the new names chosen by the user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rlang)

# Interpret defused code as a request to relocate
x &lt;- expr(c(mpg, disp))
after &lt;- expr(wt)
eval_relocate(x, mtcars, after = after)

# Supplying neither `before` nor `after` will move the selection to the
# left-hand side
eval_relocate(x, mtcars)

# Within a function, use `enquo()` to defuse a single argument.
# Note that `before` and `after` must also be defused with `enquo()`.
my_relocator &lt;- function(x, expr, before = NULL, after = NULL) {
  eval_relocate(enquo(expr), x, before = enquo(before), after = enquo(after))
}

my_relocator(mtcars, vs, before = hp)

# Here is an example of using `eval_relocate()` to implement `relocate()`.
# Note that the dots are passed on as a defused call to `c(...)`.
relocate &lt;- function(.x, ..., .before = NULL, .after = NULL) {
  pos &lt;- eval_relocate(
    expr(c(...)),
    .x,
    before = enquo(.before),
    after = enquo(.after)
  )
  set_names(.x[pos], names(pos))
}

relocate(mtcars, vs, .before = hp)
relocate(mtcars, starts_with("d"), .after = last_col())
</code></pre>

<hr>
<h2 id='eval_rename'>Evaluate an expression with tidyselect semantics</h2><span id='topic+eval_rename'></span><span id='topic+eval_select'></span>

<h3>Description</h3>

<p><code>eval_select()</code> and <code>eval_rename()</code> evaluate defused R code
(i.e. quoted expressions) according to the special rules of the
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>. They
power functions like <code>dplyr::select()</code>, <code>dplyr::rename()</code>, or
<code>tidyr::pivot_longer()</code>.
</p>
<p>See the <a href="https://tidyselect.r-lib.org/articles/tidyselect.html">Get started</a>
vignette to learn how to use <code>eval_select()</code> and <code>eval_rename()</code> in
your packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_rename(
  expr,
  data,
  env = caller_env(),
  ...,
  strict = TRUE,
  name_spec = NULL,
  allow_predicates = TRUE,
  error_call = caller_env()
)

eval_select(
  expr,
  data,
  env = caller_env(),
  ...,
  include = NULL,
  exclude = NULL,
  strict = TRUE,
  name_spec = NULL,
  allow_rename = TRUE,
  allow_empty = TRUE,
  allow_predicates = TRUE,
  error_call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_rename_+3A_expr">expr</code></td>
<td>
<p>Defused R code describing a selection according to the
tidyselect syntax.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_data">data</code></td>
<td>
<p>A named list, data frame, or atomic vector.
Technically, <code>data</code> can be any vector with <code>names()</code> and <code>"[["</code>
implementations.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>. Discarded
if <code>expr</code> is a <a href="rlang.html#topic+enquo">quosure</a>.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, out-of-bounds errors are thrown if <code>expr</code>
attempts to select or rename a variable that doesn't exist. If
<code>FALSE</code>, failed selections or renamings are ignored.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_name_spec">name_spec</code></td>
<td>
<p>A name specification describing how to combine or
propagate names. This is used only in case nested <code>c()</code>
expressions like <code>c(foo = c(bar = starts_with("foo")))</code>. See the
<code>name_spec</code> argument of <code><a href="vctrs.html#topic+vec_c">vctrs::vec_c()</a></code> for a description of
valid name specs.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_allow_predicates">allow_predicates</code></td>
<td>
<p>If <code>TRUE</code> (the default), it is ok for <code>expr</code> to
use predicates (i.e. in <code>where()</code>). If <code>FALSE</code>, will error if <code>expr</code> uses a
predicate. Will automatically be set to <code>FALSE</code> if <code>data</code> does not
support predicates (as determined by <code><a href="#topic+tidyselect_data_has_predicates">tidyselect_data_has_predicates()</a></code>).</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_include">include</code>, <code id="eval_rename_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of column names to always
include or exclude from the selection.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_allow_rename">allow_rename</code></td>
<td>
<p>If <code>TRUE</code> (the default), the renaming syntax
<code>c(foo = bar)</code> is allowed. If <code>FALSE</code>, it causes an error. This
is useful to implement purely selective behaviour.</p>
</td></tr>
<tr><td><code id="eval_rename_+3A_allow_empty">allow_empty</code></td>
<td>
<p>If <code>TRUE</code> (the default), it is ok for <code>expr</code> to result
in an empty selection. If <code>FALSE</code>, will error if <code>expr</code> yields an empty
selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The select and rename variants take the same types of inputs and
have the same type of return value. However <code>eval_rename()</code> has a
few extra constraints. It requires named inputs, and will fail if a
data frame column is renamed to another existing column name. See
the <a href="https://tidyselect.r-lib.org/articles/syntax.html">selecting versus renaming</a>
section in the syntax vignette for a description of the
differences.
</p>


<h3>Value</h3>

<p>A named vector of numeric locations, one for each of the
selected elements.
</p>
<p>The names are normally the same as in the input data, except when
the user supplied named selections with <code>c()</code>. In the latter
case, the names reflect the new names chosen by the user.
</p>
<p>A given element may be selected multiple times under different
names, in which case the vector might contain duplicate
locations.
</p>


<h3>See Also</h3>

<p><a href="https://tidyselect.r-lib.org/articles/syntax.html">https://tidyselect.r-lib.org/articles/syntax.html</a> or
<code>vignette("syntax", package = "tidyselect")</code> for a technical
description of the rules of evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rlang)

# Interpret defused code as selection:
x &lt;- expr(mpg:cyl)
eval_select(x, mtcars)

# Interpret defused code as a renaming selection. All inputs must
# be named within `c()`:
try(eval_rename(expr(mpg), mtcars))
eval_rename(expr(c(foo = mpg)), mtcars)


# Within a function, use `enquo()` to defuse one argument:
my_function &lt;- function(x, expr) {
  eval_select(enquo(expr), x)
}

# If your function takes dots, evaluate a defused call to `c(...)`
# with `expr(c(...))`:
my_function &lt;- function(.x, ...) {
  eval_select(expr(c(...)), .x)
}

# If your function takes dots and a named argument, use `{{ }}`
# inside the defused expression to tunnel it inside the tidyselect DSL:
my_function &lt;- function(.x, .expr, ...) {
  eval_select(expr(c({{ .expr }}, ...)), .x)
}

# Note that the trick above works because `expr({{ arg }})` is the
# same as `enquo(arg)`.


# The evaluators return a named vector of locations. Here are
# examples of using these location vectors to implement `select()`
# and `rename()`:
select &lt;- function(.x, ...) {
  pos &lt;- eval_select(expr(c(...)), .x)
  set_names(.x[pos], names(pos))
}
rename &lt;- function(.x, ...) {
  pos &lt;- eval_rename(expr(c(...)), .x)
  names(.x)[pos] &lt;- names(pos)
  .x
}

select(mtcars, mpg:cyl)
rename(mtcars, foo = mpg)
</code></pre>

<hr>
<h2 id='everything'>Select all variables or the last variable</h2><span id='topic+everything'></span><span id='topic+last_col'></span>

<h3>Description</h3>

<p>These functions are <a href="#topic+language">selection helpers</a>.
</p>

<ul>
<li> <p><code><a href="#topic+everything">everything()</a></code> selects all variable. It is also useful in
combination with other tidyselect operators.
</p>
</li>
<li> <p><code><a href="#topic+last_col">last_col()</a></code> selects the last variable.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>everything(vars = NULL)

last_col(offset = 0L, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="everything_+3A_vars">vars</code></td>
<td>
<p>A character vector of variable names. If not supplied,
the variables are taken from the current selection context (as
established by functions like <code>select()</code> or <code>pivot_longer()</code>).</p>
</td></tr>
<tr><td><code id="everything_+3A_offset">offset</code></td>
<td>
<p>Set it to <code>n</code> to select the nth var from the end.</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Selection helpers can be used in functions like <code>dplyr::select()</code>
or <code>tidyr::pivot_longer()</code>. Let's first attach the tidyverse:
</p>
<div class="sourceCode r"><pre>library(tidyverse)

# For better printing
iris &lt;- as_tibble(iris)
mtcars &lt;- as_tibble(mtcars)
</pre></div>
<p>Use <code>everything()</code> to select all variables:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(everything())
#&gt; # A tibble: 150 x 5
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1          5.1         3.5          1.4         0.2 setosa 
#&gt; 2          4.9         3            1.4         0.2 setosa 
#&gt; 3          4.7         3.2          1.3         0.2 setosa 
#&gt; 4          4.6         3.1          1.5         0.2 setosa 
#&gt; # i 146 more rows

mtcars %&gt;% pivot_longer(everything())
#&gt; # A tibble: 352 x 2
#&gt;   name  value
#&gt;   &lt;chr&gt; &lt;dbl&gt;
#&gt; 1 mpg      21
#&gt; 2 cyl       6
#&gt; 3 disp    160
#&gt; 4 hp      110
#&gt; # i 348 more rows
</pre></div>
<p>Use <code>last_col()</code> to select the last variable:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(last_col())
#&gt; # A tibble: 150 x 1
#&gt;   Species
#&gt;   &lt;fct&gt;  
#&gt; 1 setosa 
#&gt; 2 setosa 
#&gt; 3 setosa 
#&gt; 4 setosa 
#&gt; # i 146 more rows

mtcars %&gt;% pivot_longer(last_col())
#&gt; # A tibble: 32 x 12
#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear name  value
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4 carb      4
#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4 carb      4
#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4 carb      1
#&gt; 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3 carb      1
#&gt; # i 28 more rows
</pre></div>
<p>Supply an offset <code>n</code> to select a variable located <code>n</code> positions
from the end:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% select(1:last_col(5))
#&gt; # A tibble: 32 x 6
#&gt;     mpg   cyl  disp    hp  drat    wt
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  21       6   160   110  3.9   2.62
#&gt; 2  21       6   160   110  3.9   2.88
#&gt; 3  22.8     4   108    93  3.85  2.32
#&gt; 4  21.4     6   258   110  3.08  3.22
#&gt; # i 28 more rows
</pre></div>


<h3>See Also</h3>

<p>The <a href="#topic+language">selection language</a> page, which includes links to other selection helpers.
</p>

<hr>
<h2 id='faq-external-vector'>FAQ - Note: Using an external vector in selections is ambiguous</h2><span id='topic+faq-external-vector'></span>

<h3>Description</h3>



<h4>Ambiguity between columns and external variables</h4>

<p>With selecting functions like <code>dplyr::select()</code> or
<code>tidyr::pivot_longer()</code>, you can refer to variables by name:
</p>
<div class="sourceCode r"><pre>mtcars %&gt;% select(cyl, am, vs)
#&gt; # A tibble: 32 x 3
#&gt;     cyl    am    vs
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     6     1     0
#&gt; 2     6     1     0
#&gt; 3     4     1     1
#&gt; 4     6     0     1
#&gt; # i 28 more rows

mtcars %&gt;% select(mpg:disp)
#&gt; # A tibble: 32 x 3
#&gt;     mpg   cyl  disp
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1  21       6   160
#&gt; 2  21       6   160
#&gt; 3  22.8     4   108
#&gt; 4  21.4     6   258
#&gt; # i 28 more rows
</pre></div>
<p>For historical reasons, it is also possible to refer an external vector
of variable names. You get the correct result, but with a warning
informing you that selecting with an external variable is ambiguous
because it is not clear whether you want a data frame column or an
external object.
</p>
<div class="sourceCode r"><pre>vars &lt;- c("cyl", "am", "vs")
result &lt;- mtcars %&gt;% select(vars)
#&gt; Warning: Using an external vector in selections was deprecated in tidyselect
#&gt; 1.1.0.
#&gt; i Please use `all_of()` or `any_of()` instead.
#&gt;   # Was:
#&gt;   data %&gt;% select(vars)
#&gt; 
#&gt;   # Now:
#&gt;   data %&gt;% select(all_of(vars))
#&gt; 
#&gt; See
#&gt; &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.
#&gt; This warning is displayed once every 8 hours.
#&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this
#&gt; warning was generated.
</pre></div>
<p>We have decided to deprecate this particular approach to using external
vectors because they introduce ambiguity. Imagine that the data frame
contains a column with the same name as your external variable.
</p>
<div class="sourceCode r"><pre>some_df &lt;- mtcars[1:4, ]
some_df$vars &lt;- 1:nrow(some_df)
</pre></div>
<p>These are very different objects but it isn’t a problem if the context
forces you to be specific about where to find <code>vars</code>:
</p>
<div class="sourceCode r"><pre>vars
#&gt; [1] "cyl" "am"  "vs"

some_df$vars
#&gt; [1] 1 2 3 4
</pre></div>
<p>In a selection context however, the column wins:
</p>
<div class="sourceCode r"><pre>some_df %&gt;% select(vars)
#&gt; # A tibble: 4 x 1
#&gt;    vars
#&gt;   &lt;int&gt;
#&gt; 1     1
#&gt; 2     2
#&gt; 3     3
#&gt; 4     4
</pre></div>



<h4>Fixing the ambiguity</h4>

<p>To make your selection code more robust and silence the message, use
<code>all_of()</code> to force the external vector:
</p>
<div class="sourceCode r"><pre>some_df %&gt;% select(all_of(vars))
#&gt; # A tibble: 4 x 3
#&gt;     cyl    am    vs
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     6     1     0
#&gt; 2     6     1     0
#&gt; 3     4     1     1
#&gt; 4     6     0     1
</pre></div>
<p>For more information or if you have comments about this, please see the
<a href="https://github.com/r-lib/tidyselect/issues/76">Github issue</a> tracking
the deprecation process.
</p>


<hr>
<h2 id='faq-selection-context'>FAQ - Error: Must be used within a <em>selecting</em> function</h2><span id='topic+faq-selection-context'></span>

<h3>Description</h3>

<p>Functions like <code>starts_with()</code>, <code>contains()</code> or <code>matches()</code> are
<strong>selection helpers</strong> that only work in a selection context, e.g.
<code>dplyr::select()</code> or the <code>cols</code> argument of <code>tidyr::pivot_longer()</code>.
</p>
<p>Using a selection helper anywhere else results in an error:
</p>
<div class="sourceCode r"><pre>starts_with("foo")
#&gt; Error:
#&gt; ! `starts_with()` must be used within a *selecting* function.
#&gt; i See
#&gt;   &lt;https://tidyselect.r-lib.org/reference/faq-selection-context.html&gt;
#&gt;   for details.

mtcars[contains("foo")]
#&gt; Error:
#&gt; ! `contains()` must be used within a *selecting* function.
#&gt; i See
#&gt;   &lt;https://tidyselect.r-lib.org/reference/faq-selection-context.html&gt;
#&gt;   for details.

subset(mtcars, select = matches("foo"))
#&gt; Error:
#&gt; ! `matches()` must be used within a *selecting* function.
#&gt; i See
#&gt;   &lt;https://tidyselect.r-lib.org/reference/faq-selection-context.html&gt;
#&gt;   for details.
</pre></div>
<p>If you see this error, you may have used a selection helper in the wrong
place, possibly as the result of a typo (e.g. misplaced comma or wrong
argument name). Alternatively, you may be deliberately trying to reduce
duplication in your code by extracting out a selection into a variable:
</p>
<div class="sourceCode r"><pre>my_vars &lt;- c(name, species, ends_with("color"))
#&gt; Error in eval(expr, envir, enclos): object 'name' not found
</pre></div>
<p>To make this work you’ll need to do two things:
</p>

<ul>
<li><p> Wrap the whole thing in a function
</p>
</li>
<li><p> Use <code>any_of()</code> or <code>all_of()</code> instead of bare variable names
</p>
</li></ul>

<div class="sourceCode r"><pre>my_vars &lt;- function() {
  c(any_of(c("name", "species")), ends_with("color"))
}
dplyr::select(starwars, my_vars())
#&gt; # A tibble: 87 x 5
#&gt;   name           species hair_color skin_color  eye_color
#&gt;   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    
#&gt; 1 Luke Skywalker Human   blond      fair        blue     
#&gt; 2 C-3PO          Droid   &lt;NA&gt;       gold        yellow   
#&gt; 3 R2-D2          Droid   &lt;NA&gt;       white, blue red      
#&gt; 4 Darth Vader    Human   none       white       yellow   
#&gt; # i 83 more rows
</pre></div>

<hr>
<h2 id='language'>Selection language</h2><span id='topic+language'></span><span id='topic+select_helpers'></span>

<h3>Description</h3>



<h4>Overview of selection features:</h4>

<p>tidyselect implements a DSL for selecting variables. It provides helpers
for selecting variables:
</p>

<ul>
<li> <p><code>var1:var10</code>: variables lying between <code>var1</code> on the left and <code>var10</code> on the right.
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+starts_with">starts_with(&quot;a&quot;)</a></code>: names that start with <code>"a"</code>.
</p>
</li>
<li> <p><code><a href="#topic+ends_with">ends_with(&quot;z&quot;)</a></code>: names that end with <code>"z"</code>.
</p>
</li>
<li> <p><code><a href="#topic+contains">contains(&quot;b&quot;)</a></code>: names that contain <code>"b"</code>.
</p>
</li>
<li> <p><code><a href="#topic+matches">matches(&quot;x.y&quot;)</a></code>: names that match regular expression <code>x.y</code>.
</p>
</li>
<li> <p><code><a href="#topic+num_range">num_range(x, 1:4)</a></code>: names following the pattern, <code>x1</code>, <code>x2</code>, ..., <code>x4</code>.
</p>
</li>
<li> <p><code><a href="#topic+all_of">all_of(vars)</a></code>/<code><a href="#topic+any_of">any_of(vars)</a></code>:
matches names stored in the character vector <code>vars</code>. <code>all_of(vars)</code> will
error if the variables aren't present; <code>any_of(var)</code> will match just the
variables that exist.
</p>
</li>
<li> <p><code><a href="#topic+everything">everything()</a></code>: all variables.
</p>
</li>
<li> <p><code><a href="#topic+last_col">last_col()</a></code>: furthest column on the right.
</p>
</li>
<li> <p><code><a href="#topic+where">where(is.numeric)</a></code>: all variables where
<code>is.numeric()</code> returns <code>TRUE</code>.
</p>
</li></ul>

<p>As well as operators for combining those selections:
</p>

<ul>
<li> <p><code>!selection</code>: only variables that don't match <code>selection</code>.
</p>
</li>
<li> <p><code>selection1 &amp; selection2</code>: only variables included in both <code>selection1</code> and <code>selection2</code>.
</p>
</li>
<li> <p><code>selection1 | selection2</code>: all variables that match either <code>selection1</code> or <code>selection2</code>.
</p>
</li></ul>

<p>When writing code inside packages you can substitute <code>"var"</code> for <code>var</code> to avoid <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> notes.
</p>



<h3>Simple examples</h3>

<p>Here we show the usage for the basic selection operators. See the
specific help pages to learn about helpers like <code><a href="#topic+starts_with">starts_with()</a></code>.
</p>
<p>The selection language can be used in functions like
<code>dplyr::select()</code> or <code>tidyr::pivot_longer()</code>. Let's first attach
the tidyverse:
</p>
<div class="sourceCode r"><pre>library(tidyverse)

# For better printing
iris &lt;- as_tibble(iris)
</pre></div>
<p>Select variables by name:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(height)
#&gt; # A tibble: 87 x 1
#&gt;   height
#&gt;    &lt;int&gt;
#&gt; 1    172
#&gt; 2    167
#&gt; 3     96
#&gt; 4    202
#&gt; # i 83 more rows

iris %&gt;% pivot_longer(Sepal.Length)
#&gt; # A tibble: 150 x 6
#&gt;   Sepal.Width Petal.Length Petal.Width Species name         value
#&gt;         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1         3.5          1.4         0.2 setosa  Sepal.Length   5.1
#&gt; 2         3            1.4         0.2 setosa  Sepal.Length   4.9
#&gt; 3         3.2          1.3         0.2 setosa  Sepal.Length   4.7
#&gt; 4         3.1          1.5         0.2 setosa  Sepal.Length   4.6
#&gt; # i 146 more rows
</pre></div>
<p>Select multiple variables by separating them with commas. Note how
the order of columns is determined by the order of inputs:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(homeworld, height, mass)
#&gt; # A tibble: 87 x 3
#&gt;   homeworld height  mass
#&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt;
#&gt; 1 Tatooine     172    77
#&gt; 2 Tatooine     167    75
#&gt; 3 Naboo         96    32
#&gt; 4 Tatooine     202   136
#&gt; # i 83 more rows
</pre></div>
<p>Functions like <code>tidyr::pivot_longer()</code> don't take variables with
dots. In this case use <code>c()</code> to select multiple variables:
</p>
<div class="sourceCode r"><pre>iris %&gt;% pivot_longer(c(Sepal.Length, Petal.Length))
#&gt; # A tibble: 300 x 5
#&gt;   Sepal.Width Petal.Width Species name         value
#&gt;         &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;dbl&gt;
#&gt; 1         3.5         0.2 setosa  Sepal.Length   5.1
#&gt; 2         3.5         0.2 setosa  Petal.Length   1.4
#&gt; 3         3           0.2 setosa  Sepal.Length   4.9
#&gt; 4         3           0.2 setosa  Petal.Length   1.4
#&gt; # i 296 more rows
</pre></div>


<h4>Operators:</h4>

<p>The <code>:</code> operator selects a range of consecutive variables:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(name:mass)
#&gt; # A tibble: 87 x 3
#&gt;   name           height  mass
#&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt;
#&gt; 1 Luke Skywalker    172    77
#&gt; 2 C-3PO             167    75
#&gt; 3 R2-D2              96    32
#&gt; 4 Darth Vader       202   136
#&gt; # i 83 more rows
</pre></div>
<p>The <code>!</code> operator negates a selection:
</p>
<div class="sourceCode r"><pre>starwars %&gt;% select(!(name:mass))
#&gt; # A tibble: 87 x 11
#&gt;   hair_color skin_color  eye_color birth_year sex   gender    homeworld species
#&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;  
#&gt; 1 blond      fair        blue            19   male  masculine Tatooine  Human  
#&gt; 2 &lt;NA&gt;       gold        yellow         112   none  masculine Tatooine  Droid  
#&gt; 3 &lt;NA&gt;       white, blue red             33   none  masculine Naboo     Droid  
#&gt; 4 none       white       yellow          41.9 male  masculine Tatooine  Human  
#&gt; # i 83 more rows
#&gt; # i 3 more variables: films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;

iris %&gt;% select(!c(Sepal.Length, Petal.Length))
#&gt; # A tibble: 150 x 3
#&gt;   Sepal.Width Petal.Width Species
#&gt;         &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1         3.5         0.2 setosa 
#&gt; 2         3           0.2 setosa 
#&gt; 3         3.2         0.2 setosa 
#&gt; 4         3.1         0.2 setosa 
#&gt; # i 146 more rows

iris %&gt;% select(!ends_with("Width"))
#&gt; # A tibble: 150 x 3
#&gt;   Sepal.Length Petal.Length Species
#&gt;          &lt;dbl&gt;        &lt;dbl&gt; &lt;fct&gt;  
#&gt; 1          5.1          1.4 setosa 
#&gt; 2          4.9          1.4 setosa 
#&gt; 3          4.7          1.3 setosa 
#&gt; 4          4.6          1.5 setosa 
#&gt; # i 146 more rows
</pre></div>
<p><code>&amp;</code> and <code>|</code> take the intersection or the union of two selections:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with("Petal") &amp; ends_with("Width"))
#&gt; # A tibble: 150 x 1
#&gt;   Petal.Width
#&gt;         &lt;dbl&gt;
#&gt; 1         0.2
#&gt; 2         0.2
#&gt; 3         0.2
#&gt; 4         0.2
#&gt; # i 146 more rows

iris %&gt;% select(starts_with("Petal") | ends_with("Width"))
#&gt; # A tibble: 150 x 3
#&gt;   Petal.Length Petal.Width Sepal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          1.4         0.2         3.5
#&gt; 2          1.4         0.2         3  
#&gt; 3          1.3         0.2         3.2
#&gt; 4          1.5         0.2         3.1
#&gt; # i 146 more rows
</pre></div>
<p>To take the difference between two selections, combine the <code>&amp;</code> and
<code>!</code> operators:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with("Petal") &amp; !ends_with("Width"))
#&gt; # A tibble: 150 x 1
#&gt;   Petal.Length
#&gt;          &lt;dbl&gt;
#&gt; 1          1.4
#&gt; 2          1.4
#&gt; 3          1.3
#&gt; 4          1.5
#&gt; # i 146 more rows
</pre></div>



<h3>Details</h3>

<p>The order of selected columns is determined by the inputs.
</p>

<ul>
<li> <p><code>all_of(c("foo", "bar"))</code> selects <code>"foo"</code> first.
</p>
</li>
<li> <p><code>c(starts_with("c"), starts_with("d"))</code> selects all columns
starting with <code>"c"</code> first, then all columns starting with <code>"d"</code>.
</p>
</li></ul>


<hr>
<h2 id='one_of'>Superseded selection helpers</h2><span id='topic+one_of'></span>

<h3>Description</h3>

<p><code>one_of()</code> is superseded in favour of the more precise <code><a href="#topic+any_of">any_of()</a></code> and
<code><a href="#topic+all_of">all_of()</a></code> selectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_of(..., .vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="one_of_+3A_...">...</code></td>
<td>
<p>One or more character vectors.</p>
</td></tr>
<tr><td><code id="one_of_+3A_.vars">.vars</code></td>
<td>
<p>A character vector of variable names. When called
from inside selecting functions like <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> these are
automatically set to the names of the table.</p>
</td></tr>
</table>

<hr>
<h2 id='peek_vars'>Peek at variables in the selection context</h2><span id='topic+peek_vars'></span><span id='topic+peek_data'></span>

<h3>Description</h3>


<ul>
<li> <p><code>peek_vars()</code> returns the vector of names of the variables
currently available for selection.
</p>
</li>
<li> <p><code>peek_data()</code> returns the whole input vector (only available with
<code><a href="#topic+eval_select">eval_select()</a></code>).
</p>
</li></ul>

<p>Read the <a href="https://tidyselect.r-lib.org/articles/tidyselect.html">Get started</a> for
examples of how to create selection helpers with <code>peek_vars()</code>.
</p>
<p>The variable names in a selection context are registered
automatically by <code><a href="#topic+eval_select">eval_select()</a></code> and <code><a href="#topic+eval_rename">eval_rename()</a></code> for the
duration of the evaluation. <code>peek_vars()</code> is the glue that connects
<a href="#topic+language">selection helpers</a> to the current selection
context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek_vars(..., fn = NULL)

peek_data(..., fn = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peek_vars_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="peek_vars_+3A_fn">fn</code></td>
<td>
<p>The name of the function to use in error messages when
the helper is used in the wrong context. If not supplied, a
generic error message is used instead.</p>
</td></tr>
</table>

<hr>
<h2 id='poke_vars'>Replace or get current variables</h2><span id='topic+poke_vars'></span><span id='topic+scoped_vars'></span><span id='topic+with_vars'></span><span id='topic+has_vars'></span>

<h3>Description</h3>

<p>Variables are made available to <a href="#topic+language">select helpers</a> by
registering them in a special placeholder.
</p>

<ul>
<li> <p><code>scoped_vars()</code> changes the current variables and sets up a
function exit hook that automatically restores the previous
variables once the current function returns.
</p>
</li>
<li> <p><code>with_vars()</code> takes an expression to be evaluated in a variable
context.
</p>
</li>
<li> <p><code>poke_vars()</code> changes the contents of the placeholder with a new
set of variables. It returns the previous variables invisibly and
it is your responsibility to restore them after you are
done. This is for expert use only.
</p>
</li>
<li> <p><code>peek_vars()</code> returns the variables currently registered.
</p>
</li>
<li> <p><code>has_vars()</code> returns <code>TRUE</code> if a variable context has been set,
<code>FALSE</code> otherwise.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>poke_vars(vars)

scoped_vars(vars, frame = caller_env())

with_vars(vars, expr)

has_vars()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poke_vars_+3A_vars">vars</code></td>
<td>
<p>A character vector of variable names.</p>
</td></tr>
<tr><td><code id="poke_vars_+3A_frame">frame</code></td>
<td>
<p>The frame environment where the exit hook for
restoring the old variables should be registered.</p>
</td></tr>
<tr><td><code id="poke_vars_+3A_expr">expr</code></td>
<td>
<p>An expression to be evaluated within the variable
context.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>poke_vars()</code> and <code>scoped_vars()</code>, the old variables
invisibly. For <code>peek_vars()</code>, the variables currently
registered.
</p>


<h3>See Also</h3>

<p>peek_vars
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poke_vars(letters)
peek_vars()

# Now that the variables are registered, the helpers can figure out
# the locations of elements within the variable vector:
all_of(c("d", "z"))

# In a function be sure to restore the previous variables. An exit
# hook is the best way to do it:
fn &lt;- function(vars) {
  old &lt;- poke_vars(vars)
  on.exit(poke_vars(old))

  all_of("d")
}
fn(letters)
fn(letters[3:5])

# The previous variables are still registered after fn() was
# called:
peek_vars()


# It is recommended to use the scoped variant as it restores the
# state automatically when the function returns:
fn &lt;- function(vars) {
  scoped_vars(vars)
  starts_with("r")
}
fn(c("red", "blue", "rose"))

# The with_vars() helper makes it easy to pass an expression that
# should be evaluated in a variable context. Thanks to lazy
# evaluation, you can just pass the expression argument from your
# wrapper to with_vars():
fn &lt;- function(expr) {
  vars &lt;- c("red", "blue", "rose")
  with_vars(vars, expr)
}
fn(starts_with("r"))
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+quo'></span><span id='topic+quos'></span><span id='topic+enquo'></span><span id='topic+quo_name'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+enquo">enquo</a></code>, <code><a href="rlang.html#topic+defusing-advanced">quo</a></code>, <code><a href="rlang.html#topic+quo_label">quo_name</a></code>, <code><a href="rlang.html#topic+defusing-advanced">quos</a></code></p>
</dd>
</dl>

<hr>
<h2 id='starts_with'>Select variables that match a pattern</h2><span id='topic+starts_with'></span><span id='topic+ends_with'></span><span id='topic+contains'></span><span id='topic+matches'></span><span id='topic+num_range'></span>

<h3>Description</h3>

<p>These <a href="#topic+language">selection helpers</a> match variables according
to a given pattern.
</p>

<ul>
<li> <p><code><a href="#topic+starts_with">starts_with()</a></code>: Starts with an exact prefix.
</p>
</li>
<li> <p><code><a href="#topic+ends_with">ends_with()</a></code>: Ends with an exact suffix.
</p>
</li>
<li> <p><code><a href="#topic+contains">contains()</a></code>: Contains a literal string.
</p>
</li>
<li> <p><code><a href="#topic+matches">matches()</a></code>: Matches a regular expression.
</p>
</li>
<li> <p><code><a href="#topic+num_range">num_range()</a></code>: Matches a numerical range like x01, x02, x03.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>starts_with(match, ignore.case = TRUE, vars = NULL)

ends_with(match, ignore.case = TRUE, vars = NULL)

contains(match, ignore.case = TRUE, vars = NULL)

matches(match, ignore.case = TRUE, perl = FALSE, vars = NULL)

num_range(prefix, range, suffix = "", width = NULL, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="starts_with_+3A_match">match</code></td>
<td>
<p>A character vector. If length &gt; 1, the union of the
matches is taken.
</p>
<p>For <code>starts_with()</code>, <code>ends_with()</code>, and <code>contains()</code> this is an exact
match. For <code>matches()</code> this is a regular expression, and can be a
stringr pattern.</p>
</td></tr>
<tr><td><code id="starts_with_+3A_ignore.case">ignore.case</code></td>
<td>
<p>If <code>TRUE</code>, the default, ignores case when matching
names.</p>
</td></tr>
<tr><td><code id="starts_with_+3A_vars">vars</code></td>
<td>
<p>A character vector of variable names. If not supplied,
the variables are taken from the current selection context (as
established by functions like <code>select()</code> or <code>pivot_longer()</code>).</p>
</td></tr>
<tr><td><code id="starts_with_+3A_perl">perl</code></td>
<td>
<p>Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="starts_with_+3A_prefix">prefix</code>, <code id="starts_with_+3A_suffix">suffix</code></td>
<td>
<p>A prefix/suffix added before/after the numeric range.</p>
</td></tr>
<tr><td><code id="starts_with_+3A_range">range</code></td>
<td>
<p>A sequence of integers, like <code>1:5</code>.</p>
</td></tr>
<tr><td><code id="starts_with_+3A_width">width</code></td>
<td>
<p>Optionally, the &quot;width&quot; of the numeric range. For example,
a range of 2 gives &quot;01&quot;, a range of three &quot;001&quot;, etc.</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Selection helpers can be used in functions like <code>dplyr::select()</code>
or <code>tidyr::pivot_longer()</code>. Let's first attach the tidyverse:
</p>
<div class="sourceCode r"><pre>library(tidyverse)

# For better printing
iris &lt;- as_tibble(iris)
</pre></div>
<p><code>starts_with()</code> selects all variables matching a prefix and
<code>ends_with()</code> matches a suffix:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with("Sepal"))
#&gt; # A tibble: 150 x 2
#&gt;   Sepal.Length Sepal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5
#&gt; 2          4.9         3  
#&gt; 3          4.7         3.2
#&gt; 4          4.6         3.1
#&gt; # i 146 more rows

iris %&gt;% select(ends_with("Width"))
#&gt; # A tibble: 150 x 2
#&gt;   Sepal.Width Petal.Width
#&gt;         &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1         3.5         0.2
#&gt; 2         3           0.2
#&gt; 3         3.2         0.2
#&gt; 4         3.1         0.2
#&gt; # i 146 more rows
</pre></div>
<p>You can supply multiple prefixes or suffixes. Note how the order of
variables depends on the order of the suffixes and prefixes:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(starts_with(c("Petal", "Sepal")))
#&gt; # A tibble: 150 x 4
#&gt;   Petal.Length Petal.Width Sepal.Length Sepal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          1.4         0.2          5.1         3.5
#&gt; 2          1.4         0.2          4.9         3  
#&gt; 3          1.3         0.2          4.7         3.2
#&gt; 4          1.5         0.2          4.6         3.1
#&gt; # i 146 more rows

iris %&gt;% select(ends_with(c("Width", "Length")))
#&gt; # A tibble: 150 x 4
#&gt;   Sepal.Width Petal.Width Sepal.Length Petal.Length
#&gt;         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
#&gt; 1         3.5         0.2          5.1          1.4
#&gt; 2         3           0.2          4.9          1.4
#&gt; 3         3.2         0.2          4.7          1.3
#&gt; 4         3.1         0.2          4.6          1.5
#&gt; # i 146 more rows
</pre></div>
<p><code>contains()</code> selects columns whose names contain a word:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(contains("al"))
#&gt; # A tibble: 150 x 4
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5          1.4         0.2
#&gt; 2          4.9         3            1.4         0.2
#&gt; 3          4.7         3.2          1.3         0.2
#&gt; 4          4.6         3.1          1.5         0.2
#&gt; # i 146 more rows
</pre></div>
<p><code>starts_with()</code>, <code>ends_with()</code>, and <code>contains()</code> do not use regular expressions. To select with a
regexp use <code>matches()</code>:
</p>
<div class="sourceCode r"><pre># [pt] is matched literally:
iris %&gt;% select(contains("[pt]al"))
#&gt; # A tibble: 150 x 0

# [pt] is interpreted as a regular expression
iris %&gt;% select(matches("[pt]al"))
#&gt; # A tibble: 150 x 4
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5          1.4         0.2
#&gt; 2          4.9         3            1.4         0.2
#&gt; 3          4.7         3.2          1.3         0.2
#&gt; 4          4.6         3.1          1.5         0.2
#&gt; # i 146 more rows
</pre></div>
<p><code>starts_with()</code> selects all variables starting with a prefix. To
select a range, use <code>num_range()</code>. Compare:
</p>
<div class="sourceCode r"><pre>billboard %&gt;% select(starts_with("wk"))
#&gt; # A tibble: 317 x 76
#&gt;     wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8   wk9  wk10  wk11  wk12  wk13
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1    87    82    72    77    87    94    99    NA    NA    NA    NA    NA    NA
#&gt; 2    91    87    92    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
#&gt; 3    81    70    68    67    66    57    54    53    51    51    51    51    47
#&gt; 4    76    76    72    69    67    65    55    59    62    61    61    59    61
#&gt; # i 313 more rows
#&gt; # i 63 more variables: wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;,
#&gt; #   wk18 &lt;dbl&gt;, wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, ...

billboard %&gt;% select(num_range("wk", 10:15))
#&gt; # A tibble: 317 x 6
#&gt;    wk10  wk11  wk12  wk13  wk14  wk15
#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1    NA    NA    NA    NA    NA    NA
#&gt; 2    NA    NA    NA    NA    NA    NA
#&gt; 3    51    51    51    47    44    38
#&gt; 4    61    61    59    61    66    72
#&gt; # i 313 more rows
</pre></div>


<h3>See Also</h3>

<p>The <a href="#topic+language">selection language</a> page, which includes links to other selection helpers.
</p>

<hr>
<h2 id='tidyselect_data_proxy'>tidyselect methods for custom types</h2><span id='topic+tidyselect_data_proxy'></span><span id='topic+tidyselect_data_has_predicates'></span>

<h3>Description</h3>


<ul>
<li> <p><code>tidyselect_data_proxy()</code> returns a data frame.
</p>
</li>
<li> <p><code>tidyselect_data_has_predicates()</code> returns <code>TRUE</code> or <code>FALSE</code>
</p>
</li></ul>

<p>If your doesn't support predicate functions, return a 0-row data frame
from <code>tidyselect_data_proxy()</code> and <code>FALSE</code> from
<code>tidyselect_data_has_predicates()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyselect_data_proxy(x)

tidyselect_data_has_predicates(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidyselect_data_proxy_+3A_x">x</code></td>
<td>
<p>A data-frame like object passed to <code><a href="#topic+eval_select">eval_select()</a></code>,
<code><a href="#topic+eval_rename">eval_rename()</a></code>, and friends.</p>
</td></tr>
</table>

<hr>
<h2 id='vars_pull'>Select variable</h2><span id='topic+vars_pull'></span>

<h3>Description</h3>

<p>This function powers <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code> and various functions of the
tidyr package. It is similar to <code><a href="#topic+vars_select">vars_select()</a></code> but returns only
one column name and has slightly different semantics: it allows
negative numbers to select columns from the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_pull(
  vars,
  var = -1,
  error_call = caller_env(),
  error_arg = caller_arg(var)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_pull_+3A_vars">vars</code></td>
<td>
<p>A character vector of existing column names.</p>
</td></tr>
<tr><td><code id="vars_pull_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last column (on the assumption that's the
column you've created most recently).
</p>
<p>This argument is taken by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names and column locations).</p>
</td></tr>
<tr><td><code id="vars_pull_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vars_pull_+3A_error_arg">error_arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The selected column name as an unnamed string.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>, <code><a href="#topic+vars_select">vars_select()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># It takes its argument by expression:
vars_pull(letters, c)

# Negative numbers select from the end:
vars_pull(letters, -3)

# You can unquote variables:
var &lt;- 10
vars_pull(letters, !!var)
</code></pre>

<hr>
<h2 id='vars_select'>Select or rename variables</h2><span id='topic+vars_select'></span><span id='topic+vars_rename'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p>Please use <code><a href="#topic+eval_select">eval_select()</a></code> and <code><a href="#topic+eval_rename">eval_rename()</a></code> instead. See
<code>vignette("tidyselect")</code> to get started.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_select(
  .vars,
  ...,
  .include = character(),
  .exclude = character(),
  .strict = TRUE
)

vars_rename(.vars, ..., .strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_select_+3A_.vars">.vars</code></td>
<td>
<p>A character vector of existing column names.</p>
</td></tr>
<tr><td><code id="vars_select_+3A_...">...</code></td>
<td>
<p>Selection inputs. See the help for <a href="#topic+language">selection helpers</a>.</p>
</td></tr>
<tr><td><code id="vars_select_+3A_.include">.include</code>, <code id="vars_select_+3A_.exclude">.exclude</code></td>
<td>
<p>Character vector of column names to always
include/exclude.</p>
</td></tr>
<tr><td><code id="vars_select_+3A_.strict">.strict</code></td>
<td>
<p>If <code>TRUE</code>, will throw an error if you attempt to select or
rename a variable that doesn't exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector. Values are existing column names,
names are new names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vars_pull">vars_pull()</a></code>
</p>

<hr>
<h2 id='vars_select_helpers'>List of selection helpers</h2><span id='topic+vars_select_helpers'></span>

<h3>Description</h3>

<p>This list contains all selection helpers exported in tidyselect. It
was useful when you wanted to embed the helpers in your API without
having to track addition of new helpers in tidyselect. However the
selection helpers are now always embedded in the DSL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_select_helpers
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 11.
</p>

<hr>
<h2 id='where'>Select variables with a function</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>This <a href="#topic+language">selection helper</a> selects the variables for which a
function returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(fn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="where_+3A_fn">fn</code></td>
<td>
<p>A function that returns <code>TRUE</code> or <code>FALSE</code> (technically, a
<em>predicate</em> function). Can also be a purrr-like formula.</p>
</td></tr>
</table>


<h3>Examples</h3>

<p>Selection helpers can be used in functions like <code>dplyr::select()</code>
or <code>tidyr::pivot_longer()</code>. Let's first attach the tidyverse:
</p>
<div class="sourceCode r"><pre>library(tidyverse)

# For better printing
iris &lt;- as_tibble(iris)
</pre></div>
<p><code>where()</code> takes a function and returns all variables for which the
function returns <code>TRUE</code>:
</p>
<div class="sourceCode r"><pre>is.factor(iris[[4]])
#&gt; [1] FALSE

is.factor(iris[[5]])
#&gt; [1] TRUE

iris %&gt;% select(where(is.factor))
#&gt; # A tibble: 150 x 1
#&gt;   Species
#&gt;   &lt;fct&gt;  
#&gt; 1 setosa 
#&gt; 2 setosa 
#&gt; 3 setosa 
#&gt; 4 setosa 
#&gt; # i 146 more rows

is.numeric(iris[[4]])
#&gt; [1] TRUE

is.numeric(iris[[5]])
#&gt; [1] FALSE

iris %&gt;% select(where(is.numeric))
#&gt; # A tibble: 150 x 4
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5          1.4         0.2
#&gt; 2          4.9         3            1.4         0.2
#&gt; 3          4.7         3.2          1.3         0.2
#&gt; 4          4.6         3.1          1.5         0.2
#&gt; # i 146 more rows
</pre></div>


<h4>The formula shorthand</h4>

<p>You can use purrr-like formulas as a shortcut for creating a
function on the spot. These expressions are equivalent:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(where(is.numeric))
#&gt; # A tibble: 150 x 4
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5          1.4         0.2
#&gt; 2          4.9         3            1.4         0.2
#&gt; 3          4.7         3.2          1.3         0.2
#&gt; 4          4.6         3.1          1.5         0.2
#&gt; # i 146 more rows

iris %&gt;% select(where(function(x) is.numeric(x)))
#&gt; # A tibble: 150 x 4
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5          1.4         0.2
#&gt; 2          4.9         3            1.4         0.2
#&gt; 3          4.7         3.2          1.3         0.2
#&gt; 4          4.6         3.1          1.5         0.2
#&gt; # i 146 more rows

iris %&gt;% select(where(~ is.numeric(.x)))
#&gt; # A tibble: 150 x 4
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width
#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
#&gt; 1          5.1         3.5          1.4         0.2
#&gt; 2          4.9         3            1.4         0.2
#&gt; 3          4.7         3.2          1.3         0.2
#&gt; 4          4.6         3.1          1.5         0.2
#&gt; # i 146 more rows
</pre></div>
<p>The shorthand is useful for adding logic inline. Here we select all
numeric variables whose mean is greater than 3.5:
</p>
<div class="sourceCode r"><pre>iris %&gt;% select(where(~ is.numeric(.x) &amp;&amp; mean(.x) &gt; 3.5))
#&gt; # A tibble: 150 x 2
#&gt;   Sepal.Length Petal.Length
#&gt;          &lt;dbl&gt;        &lt;dbl&gt;
#&gt; 1          5.1          1.4
#&gt; 2          4.9          1.4
#&gt; 3          4.7          1.3
#&gt; 4          4.6          1.5
#&gt; # i 146 more rows
</pre></div>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
