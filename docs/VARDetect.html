<!DOCTYPE html><html><head><title>Help for package VARDetect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VARDetect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backward.selection'><p>Backward selection function for the second screening step</p></a></li>
<li><a href='#BIC'><p>BIC and HBIC function</p></a></li>
<li><a href='#block.finder'><p>cluster the points by neighborhood size a_n</p></a></li>
<li><a href='#break.var.local.new'><p>Compute local loss function.</p></a></li>
<li><a href='#break.var.lps'><p>Auxiliary function to calculate loss at the estimated change points</p></a></li>
<li><a href='#cv.detect.LpS'><p>Single change point detection for low-rank plus sparse model with cross-validation</p></a></li>
<li><a href='#cv.separate'><p>cross-validation index function, separate train and test sets</p></a></li>
<li><a href='#cv.tuning.selection'><p>a function to apply cross-validation to select tuning parameter by minimizing SSE</p></a></li>
<li><a href='#detect.LpS'><p>Single change point detection for low-rank plus sparse model structure</p></a></li>
<li><a href='#detection_check'><p>Function for detection performance check</p></a></li>
<li><a href='#eeg'><p>EEG signal data</p></a></li>
<li><a href='#eval_func'><p>Evaluation function, return the performance of simulation results</p></a></li>
<li><a href='#f.func'><p>Main loss function for quardratic loss</p></a></li>
<li><a href='#first.step.blocks'><p>block fused lasso step (first step for BSS).</p></a></li>
<li><a href='#first.step.blocks.group'><p>block fused sparse group lasso step (first step).</p></a></li>
<li><a href='#first.step.detect'><p>First step rolling window function</p></a></li>
<li><a href='#fista.LpS'><p>A function to solve low rank plus sparse model estimation using FISTA algorithm</p></a></li>
<li><a href='#fista.nuclear'><p>A helper function for implementing FISTA algorithm to estimate low-rank matrix</p></a></li>
<li><a href='#gradf.func'><p>Gradient function of quardratic loss</p></a></li>
<li><a href='#hausdorff_check'><p>Function for Hausdorff distance computation</p></a></li>
<li><a href='#lag_selection'><p>Select the lag of the VAR model using total BIC method</p></a></li>
<li><a href='#lstsp'><p>Main function for the low rank plus sparse structure VAR model</p></a></li>
<li><a href='#nuclear.pen'><p>Nuclear norm penalty for low-rank component</p></a></li>
<li><a href='#obj.func'><p>Objective function</p></a></li>
<li><a href='#plot_density'><p>Function to plot the sparsity levels for estimated model parameters</p></a></li>
<li><a href='#plot_granger'><p>Function to plot Granger causality networks</p></a></li>
<li><a href='#plot_matrix'><p>Plot the AR coefficient matrix</p></a></li>
<li><a href='#plot.VARDetect.result'><p>Plotting the output from VARDetect.result class</p></a></li>
<li><a href='#pred'><p>Prediction function (single observation)</p></a></li>
<li><a href='#pred.block'><p>Prediction function (block)</p></a></li>
<li><a href='#print.VARDetect.result'><p>Function to print the change points estimated by VARDetect</p></a></li>
<li><a href='#prox.nuclear.func'><p>Proximal function with nuclear norm penalty updating</p></a></li>
<li><a href='#prox.nuclear.func.fLS'><p>Proximal function for nuclear norm penalty</p></a></li>
<li><a href='#prox.sparse.func'><p>Proximal function with l1-norm penalty updating</p></a></li>
<li><a href='#Q.func'><p>An auxiliary function in FISTA algorithm</p></a></li>
<li><a href='#remove.extra.pts'><p>helper function for detection check</p></a></li>
<li><a href='#second.step.detect'><p>Backward elimination algorithm for screening in the second step</p></a></li>
<li><a href='#second.step.local'><p>local screening step (second step).</p></a></li>
<li><a href='#shrinkage'><p>Shrinkage function for sparse soft-thresholding</p></a></li>
<li><a href='#shrinkage.lr'><p>Shrinkage function for low-rank soft-thresholding</p></a></li>
<li><a href='#simu_lstsp'><p>Function to deploy simulation with LSTSP algorithm</p></a></li>
<li><a href='#simu_tbss'><p>Simulation function for TBSS algorithm</p></a></li>
<li><a href='#simu_var'><p>Generate VAR(p) model data with break points</p></a></li>
<li><a href='#sparse.pen'><p>L1-norm penalty for sparse component</p></a></li>
<li><a href='#summary.VARDetect.result'><p>Function to summarize the change points estimated by VARDetect</p></a></li>
<li><a href='#summary.VARDetect.simu.result'><p>A function to summarize the results for simulation</p></a></li>
<li><a href='#tbss'><p>Block segmentation scheme (BSS).</p></a></li>
<li><a href='#third.step.exhaustive.search'><p>Exhaustive search step (third step).</p></a></li>
<li><a href='#weekly'><p>weekly stock price data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Change Point Detection in Structural VAR Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Yue Bai [aut, cre],
  Peiliang Bai [aut],
  Abolfazl Safikhani [aut],
  George Michailidis [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yue Bai &lt;baiyue69@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of Thresholded Block Segmentation Scheme (TBSS) and Low-rank plus Sparse Two Step Procedure (LSTSP) algorithms for detecting multiple changes in structural VAR models. The package aims to address the problem of change point detection in piece-wise stationary VAR models, under different settings regarding the structure of their transition matrices (autoregressive dynamics); specifically, the following cases are included: (i) (weakly) sparse, (ii) structured sparse, and (iii) low rank plus sparse. It includes multiple algorithms and related extensions from Safikhani and Shojaie (2020) &lt;<a href="https://doi.org/10.1080%2F01621459.2020.1770097">doi:10.1080/01621459.2020.1770097</a>&gt; and Bai, Safikhani and Michailidis (2020) &lt;<a href="https://doi.org/10.1109%2FTSP.2020.2993145">doi:10.1109/TSP.2020.2993145</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MTS, igraph, pracma, graphics, mvtnorm, sparsevar,
lattice, Rcpp (&ge; 1.0.7)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-15 14:53:50 UTC; baipl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-15 18:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='backward.selection'>Backward selection function for the second screening step</h2><span id='topic+backward.selection'></span>

<h3>Description</h3>

<p>Backward elimination algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backward.selection(data, pts, lambda, mu, alpha_L = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backward.selection_+3A_data">data</code></td>
<td>
<p>A n by p dataset matrix</p>
</td></tr>
<tr><td><code id="backward.selection_+3A_pts">pts</code></td>
<td>
<p>A numeric vector, which includes all candidate change points obtained from the first step</p>
</td></tr>
<tr><td><code id="backward.selection_+3A_lambda">lambda</code></td>
<td>
<p>Tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="backward.selection_+3A_mu">mu</code></td>
<td>
<p>Tuning parameter for low-rank component</p>
</td></tr>
<tr><td><code id="backward.selection_+3A_alpha_l">alpha_L</code></td>
<td>
<p>Constraint space for low rank component, default is 0.25</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, containing
</p>

<dl>
<dt>L.n</dt><dd><p>Value of objective function</p>
</dd>
<dt>L.n.current</dt><dd><p>Current value of objective function</p>
</dd>
</dl>


<hr>
<h2 id='BIC'>BIC and HBIC function</h2><span id='topic+BIC'></span>

<h3>Description</h3>

<p>BIC and HBIC function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIC(residual, phi, gamma.val = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC_+3A_residual">residual</code></td>
<td>
<p>residual matrix</p>
</td></tr>
<tr><td><code id="BIC_+3A_phi">phi</code></td>
<td>
<p>estimated coefficient matrix of the model</p>
</td></tr>
<tr><td><code id="BIC_+3A_gamma.val">gamma.val</code></td>
<td>
<p>hyperparameter for HBIC, if HBIC == TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which contains the followings
</p>

<dl>
<dt>BIC</dt><dd><p>BIC value</p>
</dd>
<dt>HBIC</dt><dd><p>HBIC value</p>
</dd>
</dl>


<hr>
<h2 id='block.finder'>cluster the points by neighborhood size a_n</h2><span id='topic+block.finder'></span>

<h3>Description</h3>

<p>helper function for determining the clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block.finder(pts, an)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block.finder_+3A_pts">pts</code></td>
<td>
<p>vector of candidate change points</p>
</td></tr>
<tr><td><code id="block.finder_+3A_an">an</code></td>
<td>
<p>radius of the cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of change points clusters
</p>

<hr>
<h2 id='break.var.local.new'>Compute local loss function.</h2><span id='topic+break.var.local.new'></span>

<h3>Description</h3>

<p>Compute local loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>break.var.local.new(
  method = "sparse",
  data,
  eta,
  q,
  max.iteration = 1000,
  tol = 10^(-4),
  pts,
  an,
  group.case = "columnwise",
  group.index = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="break.var.local.new_+3A_method">method</code></td>
<td>
<p>method: sparse, group sparse</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_data">data</code></td>
<td>
<p>input data matrix, with each column representing the time series component</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_eta">eta</code></td>
<td>
<p>tuning parameter eta for lasso</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_q">q</code></td>
<td>
<p>the AR order</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_max.iteration">max.iteration</code></td>
<td>
<p>max number of iteration for the fused lasso</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_tol">tol</code></td>
<td>
<p>tolerance for the fused lasso</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_pts">pts</code></td>
<td>
<p>the selected break points after the first step</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_an">an</code></td>
<td>
<p>the neighborhood size a_n</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_group.case">group.case</code></td>
<td>
<p>group sparse pattern: columnwise, rowwise.</p>
</td></tr>
<tr><td><code id="break.var.local.new_+3A_group.index">group.index</code></td>
<td>
<p>group index for group sparse case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list oject, which contains the followings
</p>

<dl>
<dt>L.n.1</dt><dd><p>A vector of loss functions that include some break point</p>
</dd>
<dt>L.n.2</dt><dd><p>A vector of loss functions that exclude some break point</p>
</dd>
</dl>


<hr>
<h2 id='break.var.lps'>Auxiliary function to calculate loss at the estimated change points</h2><span id='topic+break.var.lps'></span>

<h3>Description</h3>

<p>Function to calculate loss function at the estimated change points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>break.var.lps(data, pts, lambda, mu, alpha_L = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="break.var.lps_+3A_data">data</code></td>
<td>
<p>A n by p dataset, n is the number of observations, p is the number of variables</p>
</td></tr>
<tr><td><code id="break.var.lps_+3A_pts">pts</code></td>
<td>
<p>a vector of change points</p>
</td></tr>
<tr><td><code id="break.var.lps_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="break.var.lps_+3A_mu">mu</code></td>
<td>
<p>tuning parameter for low-rank component</p>
</td></tr>
<tr><td><code id="break.var.lps_+3A_alpha_l">alpha_L</code></td>
<td>
<p>a positive number, indicating the value of constraint space of low rank component, default is 0.25</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, including
</p>

<dl>
<dt>L.n</dt><dd><p>Value of objective function</p>
</dd>
</dl>


<hr>
<h2 id='cv.detect.LpS'>Single change point detection for low-rank plus sparse model with cross-validation</h2><span id='topic+cv.detect.LpS'></span>

<h3>Description</h3>

<p>single change point detection with cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.detect.LpS(
  data,
  lambda.1.seq = NULL,
  mu.1.seq = NULL,
  alpha_L = 0.25,
  skip = 50,
  nfold = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.detect.LpS_+3A_data">data</code></td>
<td>
<p>a n by p datatset matrix</p>
</td></tr>
<tr><td><code id="cv.detect.LpS_+3A_lambda.1.seq">lambda.1.seq</code></td>
<td>
<p>a numeric vector, the sequence of tuning parameter for sparse component for the left segment</p>
</td></tr>
<tr><td><code id="cv.detect.LpS_+3A_mu.1.seq">mu.1.seq</code></td>
<td>
<p>a numeric vector, the sequence of tuning parameter for low rank component for the left segment</p>
</td></tr>
<tr><td><code id="cv.detect.LpS_+3A_alpha_l">alpha_L</code></td>
<td>
<p>a numeric value, indicates the constraint space of low rank component</p>
</td></tr>
<tr><td><code id="cv.detect.LpS_+3A_skip">skip</code></td>
<td>
<p>a positive integer, indicates the number of time points should be skipped close to the boundary</p>
</td></tr>
<tr><td><code id="cv.detect.LpS_+3A_nfold">nfold</code></td>
<td>
<p>a positive integer, the number of folds for cross validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, including
</p>

<dl>
<dt>cp</dt><dd><p>Estimated change point</p>
</dd>
<dt>S_hat1</dt><dd><p>Estimated sparse component for the left-handed side</p>
</dd>
<dt>S_hat2</dt><dd><p>Estimated sparse component for the right-handed side</p>
</dd>
<dt>L_hat1</dt><dd><p>Estimated low rank component for the left-handed side</p>
</dd>
<dt>L_hat2</dt><dd><p>Estimated low rank component for the right-handed side</p>
</dd>
<dt>sse</dt><dd><p>The sum of squared errors for all passed time points</p>
</dd>
</dl>


<hr>
<h2 id='cv.separate'>cross-validation index function, separate train and test sets</h2><span id='topic+cv.separate'></span>

<h3>Description</h3>

<p>a function to setup training and testing datasets, select data point in test every nfold time points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.separate(period, nfold = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.separate_+3A_period">period</code></td>
<td>
<p>an input dataset with size of n by p</p>
</td></tr>
<tr><td><code id="cv.separate_+3A_nfold">nfold</code></td>
<td>
<p>an positive integer, indicates the number of folds in cv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object, includes
</p>

<dl>
<dt>train</dt><dd><p>training dataset</p>
</dd>
<dt>test</dt><dd><p>test dataset</p>
</dd>
</dl>


<hr>
<h2 id='cv.tuning.selection'>a function to apply cross-validation to select tuning parameter by minimizing SSE</h2><span id='topic+cv.tuning.selection'></span>

<h3>Description</h3>

<p>a function to apply cross-validation to select tuning parameter by minimizing SSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.tuning.selection(data, lambda.seq, mu.seq, alpha_L = 0.25, nfold = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.tuning.selection_+3A_data">data</code></td>
<td>
<p>a n by p dataset matrix</p>
</td></tr>
<tr><td><code id="cv.tuning.selection_+3A_lambda.seq">lambda.seq</code></td>
<td>
<p>a numeric vector, indicates the sequence of tuning parameters of sparse components</p>
</td></tr>
<tr><td><code id="cv.tuning.selection_+3A_mu.seq">mu.seq</code></td>
<td>
<p>a numeric vector, the sequence of tuning parameters of low rank components</p>
</td></tr>
<tr><td><code id="cv.tuning.selection_+3A_alpha_l">alpha_L</code></td>
<td>
<p>a positive numeric value, indicating the constraint space of low rank components</p>
</td></tr>
<tr><td><code id="cv.tuning.selection_+3A_nfold">nfold</code></td>
<td>
<p>a positive integer, the number of folds for cv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of object, including
</p>

<dl>
<dt>grid</dt><dd><p>the grid of lamdbas and mus</p>
</dd>
<dt>lambda</dt><dd><p>final selected tuning parameter for sparse</p>
</dd>
<dt>mu</dt><dd><p>final selected tuning parameter for low rank</p>
</dd>
</dl>


<hr>
<h2 id='detect.LpS'>Single change point detection for low-rank plus sparse model structure</h2><span id='topic+detect.LpS'></span>

<h3>Description</h3>

<p>Single change point detection for low-rank plus sparse model using minimizing SSE method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.LpS(data, lambda, mu, alpha_L, skip = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect.LpS_+3A_data">data</code></td>
<td>
<p>A n by p dataset, n is the number of observations, p is the number of variables</p>
</td></tr>
<tr><td><code id="detect.LpS_+3A_lambda">lambda</code></td>
<td>
<p>A 2-d vector recording tuning parameters for sparse components left/right</p>
</td></tr>
<tr><td><code id="detect.LpS_+3A_mu">mu</code></td>
<td>
<p>A 2-d vector recording tuning parameters for low rank components left/right</p>
</td></tr>
<tr><td><code id="detect.LpS_+3A_alpha_l">alpha_L</code></td>
<td>
<p>A numeric value, a positive number indicating the constraint space for low rank matrix</p>
</td></tr>
<tr><td><code id="detect.LpS_+3A_skip">skip</code></td>
<td>
<p>The number of observations at the boundaries we should skip</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which includes the followings:
</p>

<dl>
<dt>cp</dt><dd><p>A vector recording all estimated change points</p>
</dd>
<dt>S_hat1</dt><dd><p>Estimated sparse component for the left-handed side</p>
</dd>
<dt>S_hat2</dt><dd><p>Estimated sparse component for the right-handed side</p>
</dd>
<dt>L_hat1</dt><dd><p>Estimated low rank component for the left-handed side</p>
</dd>
<dt>L_hat2</dt><dd><p>Estimated low rank component for the right-handed side</p>
</dd>
<dt>sse</dt><dd><p>The sum of squared errors for all passed time points</p>
</dd>
</dl>


<hr>
<h2 id='detection_check'>Function for detection performance check</h2><span id='topic+detection_check'></span>

<h3>Description</h3>

<p>Function for detection performance check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detection_check(pts.final, brk, nob, critval = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detection_check_+3A_pts.final">pts.final</code></td>
<td>
<p>a list of estimated change points</p>
</td></tr>
<tr><td><code id="detection_check_+3A_brk">brk</code></td>
<td>
<p>the true change points</p>
</td></tr>
<tr><td><code id="detection_check_+3A_nob">nob</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="detection_check_+3A_critval">critval</code></td>
<td>
<p>critical value for selection rate. Default value is 5. Specifically, to compute the selection rate,  a selected break point is counted as a &ldquo;success&rdquo; for the <code class="reqn">j</code>-th true break point, <code class="reqn">t_j</code>, if it falls in the interval <code class="reqn">[t_j - {(t_{j} - t_{j-1})}/{critval}, t_j + {(t_{j+1} - t_{j})}/{critval}]</code>, <code class="reqn">j = 1,\dots, m_0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of detection summary results, including the absolute error, selection rate and relative location. The absolute error of the locations of the estimated break points is defined as <code class="reqn">{error}_j =|\tilde{t}_j^f - t_j|</code>, <code class="reqn">j = 1,\dots, m_0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># an example of 10 replicates result
set.seed(1)
nob &lt;- 1000
brk &lt;- c(333, 666, nob+1)
cp.list &lt;- vector('list', 10)
for(i in 1:10){
    cp.list[[i]] &lt;-  brk[1:2] + sample(c(-50:50),1)
}
# some replicate fails to detect all the change point
cp.list[[2]] &lt;- cp.list[[2]][1]
cp.list[4] &lt;- list(NULL)      # setting 4'th element to NULL.
# some replicate overestimate the number of change point
cp.list[[3]] &lt;- c(cp.list[[3]], 800)
cp.list
res &lt;- detection_check(cp.list, brk, nob, critval = 5)
res
# use a stricter critical value
res &lt;- detection_check(cp.list, brk, nob, critval = 10)
res

</code></pre>

<hr>
<h2 id='eeg'>EEG signal data</h2><span id='topic+eeg'></span>

<h3>Description</h3>

<p>EEG signal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eeg)
</code></pre>


<h3>Format</h3>

<p>An dataframe of EEG signal data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eeg)
head(eeg)
</code></pre>

<hr>
<h2 id='eval_func'>Evaluation function, return the performance of simulation results</h2><span id='topic+eval_func'></span>

<h3>Description</h3>

<p>Evaluation function, return the performance of simulation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_func(true_mats, est_mats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_func_+3A_true_mats">true_mats</code></td>
<td>
<p>a list of true matrices for all segments, the length of list equals to the true number of segments</p>
</td></tr>
<tr><td><code id="eval_func_+3A_est_mats">est_mats</code></td>
<td>
<p>a list of estimated matrices for all simulation replications, for each element, it is a list of numeric matrices,
representing the estimated matrices for segments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing the results for all measurements
</p>

<dl>
<dt>sensitivity</dt><dd><p>A numeric vector, containing all the results for sensitivity over all replications</p>
</dd>
<dt>specificity</dt><dd><p>A numeric vector, including all the results for specificity over all replications</p>
</dd>
<dt>accuracy</dt><dd><p>A numeric vector, the results for accuracy over all replications</p>
</dd>
<dt>mcc</dt><dd><p>A numeric vector, the results for Matthew's correlation coefficients over all replications</p>
</dd>
<dt>false_reps</dt><dd><p>An integer vector, recording all the replications which falsely detects the change points, over-detect or under-detect</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>true_mats &lt;- vector('list', 2)
true_mats[[1]] &lt;- matrix(c(1, 0, 0.5, 0.8), 2, 2, byrow = TRUE)
true_mats[[2]] &lt;- matrix(c(0, 0, 0, 0.75), 2, 2, byrow = TRUE)
est_mats &lt;- vector('list', 5)
for(i in 1:5){
    est_mats[[i]] &lt;- vector('list', 2)
    est_mats[[i]][[1]] &lt;- matrix(sample(c(0, 1, 2), size = 4, replace = TRUE), 2, 2, byrow = TRUE)
    est_mats[[i]][[2]] &lt;- matrix(sample(c(0, 1), size = 4, replace = TRUE), 2, 2, byrow = TRUE)
}
perf_eval &lt;- eval_func(true_mats, est_mats)
</code></pre>

<hr>
<h2 id='f.func'>Main loss function for quardratic loss</h2><span id='topic+f.func'></span>

<h3>Description</h3>

<p>Main loss function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.func(x, A, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f.func_+3A_x">x</code></td>
<td>
<p>Model parameters</p>
</td></tr>
<tr><td><code id="f.func_+3A_a">A</code></td>
<td>
<p>Design matrix with size of n by p</p>
</td></tr>
<tr><td><code id="f.func_+3A_b">b</code></td>
<td>
<p>Correspond vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of objective function
</p>

<hr>
<h2 id='first.step.blocks'>block fused lasso step (first step for BSS).</h2><span id='topic+first.step.blocks'></span>

<h3>Description</h3>

<p>Perform the block fused lasso to detect candidate break points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first.step.blocks(
  data.temp,
  lambda.1.cv,
  lambda.2.cv,
  q,
  max.iteration = max.iteration,
  tol = tol,
  cv.index,
  blocks
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first.step.blocks_+3A_data.temp">data.temp</code></td>
<td>
<p>input data matrix, with each column representing the time series component</p>
</td></tr>
<tr><td><code id="first.step.blocks_+3A_lambda.1.cv">lambda.1.cv</code></td>
<td>
<p>tuning parameter lambda_1 for fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks_+3A_lambda.2.cv">lambda.2.cv</code></td>
<td>
<p>tuning parameter lambda_2 for fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks_+3A_q">q</code></td>
<td>
<p>the AR order</p>
</td></tr>
<tr><td><code id="first.step.blocks_+3A_max.iteration">max.iteration</code></td>
<td>
<p>max number of iteration for the fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks_+3A_tol">tol</code></td>
<td>
<p>tolerance for the fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks_+3A_cv.index">cv.index</code></td>
<td>
<p>the index of time points for cross-validation</p>
</td></tr>
<tr><td><code id="first.step.blocks_+3A_blocks">blocks</code></td>
<td>
<p>the blocks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which contains the followings
</p>

<dl>
<dt>brk.points</dt><dd><p>a set of selected break point after the first block fused lasso step</p>
</dd>
<dt>cv</dt><dd><p>the cross validation values for tuning parmeter selection</p>
</dd>
<dt>cv1.final</dt><dd><p>the selected lambda_1</p>
</dd>
<dt>cv2.final</dt><dd><p>the selected lambda_2</p>
</dd>
</dl>


<hr>
<h2 id='first.step.blocks.group'>block fused sparse group lasso step (first step).</h2><span id='topic+first.step.blocks.group'></span>

<h3>Description</h3>

<p>Perform the block fused lasso to detect candidate break points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first.step.blocks.group(
  data.temp,
  lambda.1.cv,
  lambda.2.cv,
  q,
  max.iteration = max.iteration,
  tol = tol,
  cv.index,
  blocks,
  group.case = "columnwise",
  group.index
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first.step.blocks.group_+3A_data.temp">data.temp</code></td>
<td>
<p>input data matrix, with each column representing the time series component</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_lambda.1.cv">lambda.1.cv</code></td>
<td>
<p>tuning parmaeter lambda_1 for fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_lambda.2.cv">lambda.2.cv</code></td>
<td>
<p>tuning parmaeter lambda_2 for fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_q">q</code></td>
<td>
<p>the AR order</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_max.iteration">max.iteration</code></td>
<td>
<p>max number of iteration for the fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_tol">tol</code></td>
<td>
<p>tolerance for the fused lasso</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_cv.index">cv.index</code></td>
<td>
<p>the index of time points for cross-validation</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_blocks">blocks</code></td>
<td>
<p>the blocks</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_group.case">group.case</code></td>
<td>
<p>group sparse pattern: column, row.</p>
</td></tr>
<tr><td><code id="first.step.blocks.group_+3A_group.index">group.index</code></td>
<td>
<p>group index for group sparse case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which contains the followings
</p>

<dl>
<dt>brk.points</dt><dd><p>a set of selected break point after the first block fused lasso step</p>
</dd>
<dt>cv</dt><dd><p>the cross validation values for tuning parmeter selection</p>
</dd>
<dt>cv1.final</dt><dd><p>the selected lambda_1</p>
</dd>
<dt>cv2.final</dt><dd><p>the selected lambda_2</p>
</dd>
</dl>


<hr>
<h2 id='first.step.detect'>First step rolling window function</h2><span id='topic+first.step.detect'></span>

<h3>Description</h3>

<p>Rolling window scheme function for the first step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first.step.detect(
  data,
  h,
  step.size = NULL,
  lambda,
  mu,
  alpha_L = 0.25,
  skip = 3,
  lambda.1.seq = NULL,
  mu.1.seq = NULL,
  cv = FALSE,
  nfold = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first.step.detect_+3A_data">data</code></td>
<td>
<p>the whole data matrix</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_h">h</code></td>
<td>
<p>window size</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_step.size">step.size</code></td>
<td>
<p>rolling step size, default is NULL. If Null, the step size is 1/4 of the window size</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_lambda">lambda</code></td>
<td>
<p>a 2-d vector of tuning parameters for sparse components, available when cv is FALSE</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_mu">mu</code></td>
<td>
<p>a 2-d vector of tuning parameters for low rank components, available when cv is FALSE</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_alpha_l">alpha_L</code></td>
<td>
<p>a numeric value, indicates the size of constraint space of low rank component</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_skip">skip</code></td>
<td>
<p>the number of observations we should skip near the boundaries, default is 3</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_lambda.1.seq">lambda.1.seq</code></td>
<td>
<p>the sequence of sparse tuning parameter to the left segment, only available when cv is TRUE</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_mu.1.seq">mu.1.seq</code></td>
<td>
<p>the sequence of low rank tuning, only available for cv is TRUE</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_cv">cv</code></td>
<td>
<p>a boolean argument, indicates whether use cross validation or not</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_nfold">nfold</code></td>
<td>
<p>a positive integer, indicates the number of folds of cross validation</p>
</td></tr>
<tr><td><code id="first.step.detect_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, then all information for current stage are printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector which includes all candidate change points selected by rolling window
</p>

<hr>
<h2 id='fista.LpS'>A function to solve low rank plus sparse model estimation using FISTA algorithm</h2><span id='topic+fista.LpS'></span>

<h3>Description</h3>

<p>A function to solve low rank plus sparse model estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fista.LpS(
  A,
  b,
  lambda,
  mu,
  alpha_L = 0.25,
  niter = 100,
  backtracking = TRUE,
  x.true
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fista.LpS_+3A_a">A</code></td>
<td>
<p>A design matrix with size of n by p</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_b">b</code></td>
<td>
<p>A matrix, (or vector) with size of n by p (or n by 1)</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_lambda">lambda</code></td>
<td>
<p>A positive numeric value, indicating the tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_mu">mu</code></td>
<td>
<p>A positive numeric value, indicating the tuning parameter for low rank component</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_alpha_l">alpha_L</code></td>
<td>
<p>The constraint coefficient of low rank component, default is 0.25</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations required for FISTA</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_backtracking">backtracking</code></td>
<td>
<p>A boolean argument, indicating that use backtracking in the FISTA</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_x.true">x.true</code></td>
<td>
<p>A p by p matrix, the true model parameter. Only available for simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, including the followings
</p>

<dl>
<dt>sparse.comp</dt><dd><p>Estimated sparse component</p>
</dd>
<dt>lr.comp</dt><dd><p>Estimated low-rank component</p>
</dd>
<dt>obj.val</dt><dd><p>Values of objective function</p>
</dd>
<dt>rel.err</dt><dd><p>Relative errors compared with the true model parameters if available</p>
</dd>
</dl>


<hr>
<h2 id='fista.nuclear'>A helper function for implementing FISTA algorithm to estimate low-rank matrix</h2><span id='topic+fista.nuclear'></span>

<h3>Description</h3>

<p>Function to estimate low-rank matrix using FISTA algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fista.nuclear(A, b, lambda, d, niter, backtracking = TRUE, phi.true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fista.nuclear_+3A_a">A</code></td>
<td>
<p>A n by p design matrix</p>
</td></tr>
<tr><td><code id="fista.nuclear_+3A_b">b</code></td>
<td>
<p>A correspond vector, or a matrix</p>
</td></tr>
<tr><td><code id="fista.nuclear_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter</p>
</td></tr>
<tr><td><code id="fista.nuclear_+3A_d">d</code></td>
<td>
<p>model dimension</p>
</td></tr>
<tr><td><code id="fista.nuclear_+3A_niter">niter</code></td>
<td>
<p>the maximum number of iterations required for applying FISTA algorithm</p>
</td></tr>
<tr><td><code id="fista.nuclear_+3A_backtracking">backtracking</code></td>
<td>
<p>a boolean argument, indicate whether use backtracking or not</p>
</td></tr>
<tr><td><code id="fista.nuclear_+3A_phi.true">phi.true</code></td>
<td>
<p>true model parameter, only available for simulations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, including
</p>

<dl>
<dt>phi.hat</dt><dd><p>Estimated low-rank matrix</p>
</dd>
<dt>obj.vals</dt><dd><p>Values of objective function for all iterations</p>
</dd>
<dt>rel.err</dt><dd><p>Relative error to the true model parameter, only available for simulation</p>
</dd>
</dl>


<hr>
<h2 id='gradf.func'>Gradient function of quardratic loss</h2><span id='topic+gradf.func'></span>

<h3>Description</h3>

<p>Gradient function of quardratic loss
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradf.func(x, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradf.func_+3A_x">x</code></td>
<td>
<p>A vector, or matrix, indicating the model parameter</p>
</td></tr>
<tr><td><code id="gradf.func_+3A_ata">AtA</code></td>
<td>
<p>A p by p Gram matrix for corresponding design matrix A</p>
</td></tr>
<tr><td><code id="gradf.func_+3A_atb">Atb</code></td>
<td>
<p>An inner product for design matrix A and corresponding matrix (vector) b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of gradients
</p>

<hr>
<h2 id='hausdorff_check'>Function for Hausdorff distance computation</h2><span id='topic+hausdorff_check'></span>

<h3>Description</h3>

<p>The function includes two Hausdorff distance.
The first one is hausdorff_true_est (<code class="reqn">d(A_n, \tilde{A}_n^f)</code>): for each estimated change point, we find the closest true CP and compute the distance, then take the maximum of distances.
The second one is hausdorff_est_true(<code class="reqn">d(\tilde{A}_n^f, A_n)</code>): for each true change point, find the closest estimated change point and compute the distance, then take the maximum of distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hausdorff_check(pts.final, brk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hausdorff_check_+3A_pts.final">pts.final</code></td>
<td>
<p>a list of estimated change points</p>
</td></tr>
<tr><td><code id="hausdorff_check_+3A_brk">brk</code></td>
<td>
<p>the true change points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hausdorff distance summary results, including mean, standard deviation and median.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## an example of 10 replicates result
set.seed(1)
nob &lt;- 1000
brk &lt;- c(333, 666, nob+1)
cp.list &lt;- vector('list', 10)
for(i in 1:10){
    cp.list[[i]] &lt;-  brk[1:2] + sample(c(-50:50),1)
}
# some replicate fails to detect all the change point
cp.list[[2]] &lt;- cp.list[[2]][1]
cp.list[4] &lt;- list(NULL)      # setting 4'th element to NULL.
# some replicate overestimate the number of change point
cp.list[[3]] &lt;- c(cp.list[[3]], 800)
cp.list
res &lt;- hausdorff_check(cp.list, brk)
res

</code></pre>

<hr>
<h2 id='lag_selection'>Select the lag of the VAR model using total BIC method</h2><span id='topic+lag_selection'></span>

<h3>Description</h3>

<p>Select the lag of the VAR model (if the lag is unknown) using BIC method for total segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_selection(
  data,
  method = c("sparse", "group sparse", "fLS"),
  group.case = c("columnwise", "rowwise"),
  group.index = NULL,
  lambda.1.cv = NULL,
  lambda.2.cv = NULL,
  mu = NULL,
  block.size = NULL,
  blocks = NULL,
  use.BIC = TRUE,
  an.grid = NULL,
  threshold = NULL,
  lag_candidates,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag_selection_+3A_data">data</code></td>
<td>
<p>input data matrix, each column represents the time series component</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_method">method</code></td>
<td>
<p>method is sparse, group sparse and fixed lowrank plus sparse</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_group.case">group.case</code></td>
<td>
<p>two different types of group sparse, column-wise and row-wise, respectively.</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_group.index">group.index</code></td>
<td>
<p>specify group sparse index. Default is NULL.</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_lambda.1.cv">lambda.1.cv</code></td>
<td>
<p>tuning parameter lambda_1 for fused lasso</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_lambda.2.cv">lambda.2.cv</code></td>
<td>
<p>tuning parameter lambda_2 for fused lasso</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_mu">mu</code></td>
<td>
<p>tuning parameter for low rank component, only available when method is set to &quot;fLS&quot;.</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_block.size">block.size</code></td>
<td>
<p>the block size</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_blocks">blocks</code></td>
<td>
<p>the blocks</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_use.bic">use.BIC</code></td>
<td>
<p>use BIC for k-means part</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_an.grid">an.grid</code></td>
<td>
<p>a vector of an for grid searching.</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_threshold">threshold</code></td>
<td>
<p>a numeric argument, give the threshold for estimated model parameter matrices. Default is NULL.</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_lag_candidates">lag_candidates</code></td>
<td>
<p>potential lag selection set</p>
</td></tr>
<tr><td><code id="lag_selection_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean argument, if TRUE, it provides detailed information. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selected lag for VAR series
</p>

<dl>
<dt>select_lag</dt><dd><p>An integer no less than 1 represents the selected lag of time series.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
nob &lt;- 1000; p &lt;- 15
brk &lt;- c(floor(nob / 2), nob + 1)
m &lt;- length(brk)
q.t &lt;- 2 # the lag of VAR model for simulation
signals &lt;- c(-0.8, 0.6, 0.4)
try &lt;- simu_var(method = "sparse", nob = nob, k = p, brk = brk,
                signals = signals, lags_vector = c(1, 2),
                sp_pattern = "off-diagonal")
data &lt;- try$series; data &lt;- as.matrix(data)

# Apply lag selection to determine the lag for the given time series
lag_candi &lt;- c(1, 2, 3, 4)
select_lag &lt;- lag_selection(data = data,
                            method = "sparse", lag_candidates = lag_candi)
print(select_lag)

</code></pre>

<hr>
<h2 id='lstsp'>Main function for the low rank plus sparse structure VAR model</h2><span id='topic+lstsp'></span>

<h3>Description</h3>

<p>Main function for the low-rank plus sparse structure VAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lstsp(
  data,
  lambda.1 = NULL,
  mu.1 = NULL,
  lambda.1.seq = NULL,
  mu.1.seq = NULL,
  lambda.2 = NULL,
  mu.2 = NULL,
  lambda.3 = NULL,
  mu.3 = NULL,
  alpha_L = 0.25,
  omega = NULL,
  h = NULL,
  step.size = NULL,
  tol = 1e-04,
  niter = 100,
  backtracking = TRUE,
  skip = 5,
  cv = FALSE,
  nfold = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lstsp_+3A_data">data</code></td>
<td>
<p>A n by p dataset matrix</p>
</td></tr>
<tr><td><code id="lstsp_+3A_lambda.1">lambda.1</code></td>
<td>
<p>tuning parameter for sparse component for the first step</p>
</td></tr>
<tr><td><code id="lstsp_+3A_mu.1">mu.1</code></td>
<td>
<p>tuning parameter for low rank component for the first step</p>
</td></tr>
<tr><td><code id="lstsp_+3A_lambda.1.seq">lambda.1.seq</code></td>
<td>
<p>a sequence of lambda to the left segment for cross-validation, it's not mandatory to provide</p>
</td></tr>
<tr><td><code id="lstsp_+3A_mu.1.seq">mu.1.seq</code></td>
<td>
<p>a sequence of mu to the left segment, low rank component tuning parameter</p>
</td></tr>
<tr><td><code id="lstsp_+3A_lambda.2">lambda.2</code></td>
<td>
<p>tuning parameter for sparse for the second step</p>
</td></tr>
<tr><td><code id="lstsp_+3A_mu.2">mu.2</code></td>
<td>
<p>tuning parameter for low rank for the second step</p>
</td></tr>
<tr><td><code id="lstsp_+3A_lambda.3">lambda.3</code></td>
<td>
<p>tuning parameter for estimating sparse components</p>
</td></tr>
<tr><td><code id="lstsp_+3A_mu.3">mu.3</code></td>
<td>
<p>tuning parameter for estimating low rank components</p>
</td></tr>
<tr><td><code id="lstsp_+3A_alpha_l">alpha_L</code></td>
<td>
<p>a positive numeric value, indicating the restricted space of low rank component, default is 0.25</p>
</td></tr>
<tr><td><code id="lstsp_+3A_omega">omega</code></td>
<td>
<p>tuning parameter for information criterion, the larger of omega, the fewer final selected change points</p>
</td></tr>
<tr><td><code id="lstsp_+3A_h">h</code></td>
<td>
<p>window size of the first rolling window step</p>
</td></tr>
<tr><td><code id="lstsp_+3A_step.size">step.size</code></td>
<td>
<p>rolling step</p>
</td></tr>
<tr><td><code id="lstsp_+3A_tol">tol</code></td>
<td>
<p>tolerance for the convergence in the second screening step, indicates when to stop</p>
</td></tr>
<tr><td><code id="lstsp_+3A_niter">niter</code></td>
<td>
<p>the number of iterations required for FISTA algorithm</p>
</td></tr>
<tr><td><code id="lstsp_+3A_backtracking">backtracking</code></td>
<td>
<p>A boolean argument to indicate use backtrack to FISTA model</p>
</td></tr>
<tr><td><code id="lstsp_+3A_skip">skip</code></td>
<td>
<p>The number of observations need to skip near the boundaries</p>
</td></tr>
<tr><td><code id="lstsp_+3A_cv">cv</code></td>
<td>
<p>A boolean argument, indicates whether the user will apply cross validation to select tuning parameter, default is FALSE</p>
</td></tr>
<tr><td><code id="lstsp_+3A_nfold">nfold</code></td>
<td>
<p>An positive integer, the number of folds for cross validation</p>
</td></tr>
<tr><td><code id="lstsp_+3A_verbose">verbose</code></td>
<td>
<p>If is TRUE, then it will print all information about current step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object including
</p>

<dl>
<dt>data</dt><dd><p>the original dataset</p>
</dd>
<dt>q</dt><dd><p>the time lag for the time series, in this case, it is 1</p>
</dd>
<dt>cp</dt><dd><p>Final estimated change points</p>
</dd>
<dt>sparse_mats</dt><dd><p>Final estimated sparse components</p>
</dd>
<dt>lowrank_mats</dt><dd><p>Final estimated low rank components</p>
</dd>
<dt>est_phi</dt><dd><p>Final estimated model parameter, equals to sum of low rank and sparse components</p>
</dd>
<dt>time</dt><dd><p>Running time for the LSTSP algorithm</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
nob &lt;- 100
p &lt;- 15
brk &lt;- c(50, nob+1)
rank &lt;- c(1, 3)
signals &lt;- c(-0.7, 0.8)
singular_vals &lt;- c(1, 0.75, 0.5)
info_ratio &lt;- rep(0.35, 2)
try &lt;- simu_var(method = "LS", nob = nob, k = p, lags = 1, brk = brk,
                sigma = as.matrix(diag(p)), signals = signals,
                rank = rank, singular_vals = singular_vals, info_ratio = info_ratio,
                sp_pattern = "off-diagonal", spectral_radius = 0.9)
data &lt;- try$series

lambda1 = lambda2 = lambda3 &lt;- c(2.5, 2.5)
mu1 = mu2 = mu3 &lt;- c(15, 15)
fit &lt;- lstsp(data, lambda.1 = lambda1, mu.1 = mu1,
             lambda.2 = lambda2, mu.2 = mu2,
             lambda.3 = lambda3, mu.3 = mu3, alpha_L = 0.25,
             step.size = 5, niter = 20, skip = 5,
             cv = FALSE, verbose = FALSE)
summary(fit)
plot(fit, data, display = "cp")
plot(fit, data, display = "param")

</code></pre>

<hr>
<h2 id='nuclear.pen'>Nuclear norm penalty for low-rank component</h2><span id='topic+nuclear.pen'></span>

<h3>Description</h3>

<p>Nuclear norm penalty for low-rank component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuclear.pen(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nuclear.pen_+3A_x">x</code></td>
<td>
<p>Model parameter</p>
</td></tr>
<tr><td><code id="nuclear.pen_+3A_lambda">lambda</code></td>
<td>
<p>Tuning parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of nuclear norm penalty term
</p>

<hr>
<h2 id='obj.func'>Objective function</h2><span id='topic+obj.func'></span>

<h3>Description</h3>

<p>objective function, main loss function and penalties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.func(x.lr, x.sparse, A, b, lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.func_+3A_x.lr">x.lr</code></td>
<td>
<p>low-rank component</p>
</td></tr>
<tr><td><code id="obj.func_+3A_x.sparse">x.sparse</code></td>
<td>
<p>sparse component</p>
</td></tr>
<tr><td><code id="obj.func_+3A_a">A</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="obj.func_+3A_b">b</code></td>
<td>
<p>correspond vector</p>
</td></tr>
<tr><td><code id="obj.func_+3A_lambda">lambda</code></td>
<td>
<p>a tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="obj.func_+3A_mu">mu</code></td>
<td>
<p>a tuning parameter for low-rank component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of objective function
</p>

<hr>
<h2 id='plot_density'>Function to plot the sparsity levels for estimated model parameters</h2><span id='topic+plot_density'></span>

<h3>Description</h3>

<p>A function to plot lineplot for sparsity levels of estimated model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_density(est_mats, threshold = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_density_+3A_est_mats">est_mats</code></td>
<td>
<p>A list of numeric matrices, the length of list equals to the number of estimated segments</p>
</td></tr>
<tr><td><code id="plot_density_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value, set as a threshold, the function only counts the non-zeros with absolute
magnitudes larger than threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot for sparsity density across over all estimated segments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
est_mats &lt;- list(matrix(rnorm(400, 0, 2), 20, 20), matrix(rnorm(400), 20, 20))
plot_density(est_mats, threshold = 0.25)
</code></pre>

<hr>
<h2 id='plot_granger'>Function to plot Granger causality networks</h2><span id='topic+plot_granger'></span>

<h3>Description</h3>

<p>A function to plot Granger causal network for each segment via estimated sparse component. Note that if it has multiple lags, it only provides the first order Granger causality plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_granger(est_mats, threshold = 0.1, layout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_granger_+3A_est_mats">est_mats</code></td>
<td>
<p>A list of numeric sparse matrices, indicating the estimated sparse components for each segment</p>
</td></tr>
<tr><td><code id="plot_granger_+3A_threshold">threshold</code></td>
<td>
<p>A numeric positive value, used to determine the threshold to present the edges</p>
</td></tr>
<tr><td><code id="plot_granger_+3A_layout">layout</code></td>
<td>
<p>A character string, indicates the layout for the igraph plot argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of plots of Granger networks of VAR model parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
est_mats &lt;- list(matrix(rnorm(400, 0, 1), 20, 20))
plot_granger(est_mats, threshold = 2, layout = "circle")
plot_granger(est_mats, threshold = 2, layout = "star")
plot_granger(est_mats, threshold = 2, layout = "nicely")
</code></pre>

<hr>
<h2 id='plot_matrix'>Plot the AR coefficient matrix</h2><span id='topic+plot_matrix'></span>

<h3>Description</h3>

<p>Plot the AR coefficient matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matrix(phi, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_matrix_+3A_phi">phi</code></td>
<td>
<p>combined coefficient matrices for all lags</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_p">p</code></td>
<td>
<p>number of segments times number of lags</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of AR coefficient matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nob &lt;- 4 * 10^3
p &lt;- 15
brk &lt;- c(floor(nob / 3), floor(2 * nob / 3), nob + 1)
m0 &lt;- length(brk) - 1
q.t &lt;- 2
m &lt;- m0 + 1
sp_density &lt;- rep(0.05, m*q.t) #sparsity level (5%)
try &lt;- simu_var("sparse", nob = nob, k = p, lags = q.t, brk = brk,
                sp_pattern = "random", sp_density = sp_density)
print(plot_matrix(do.call("cbind", try$model_param), m * q.t))

</code></pre>

<hr>
<h2 id='plot.VARDetect.result'>Plotting the output from VARDetect.result class</h2><span id='topic+plot.VARDetect.result'></span>

<h3>Description</h3>

<p>Plotting method for S3 object of class <code>VARDetect.result</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARDetect.result'
plot(
  x,
  display = c("cp", "param", "granger", "density"),
  threshold = 0.1,
  layout = c("circle", "star", "nicely"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.VARDetect.result_+3A_x">x</code></td>
<td>
<p>a <code>VARDetect.result</code> object</p>
</td></tr>
<tr><td><code id="plot.VARDetect.result_+3A_display">display</code></td>
<td>
<p>a character string, indicates the object the user wants to plot; possible values are
</p>

<dl>
<dt><code>"cp"</code></dt><dd><p>input time series together with the estimated change points</p>
</dd>
<dt><code>"param"</code></dt><dd><p>estimated model parameters</p>
</dd>
<dt><code>"granger"</code></dt><dd><p>present the model parameters through Granger causal networks</p>
</dd>
<dt><code>"density"</code></dt><dd><p>plot the sparsity levels across all segments</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.VARDetect.result_+3A_threshold">threshold</code></td>
<td>
<p>a positive numeric value, indicates the threshold to present the entries in the sparse matrices</p>
</td></tr>
<tr><td><code id="plot.VARDetect.result_+3A_layout">layout</code></td>
<td>
<p>a character string, indicating the layout of the Granger network</p>
</td></tr>
<tr><td><code id="plot.VARDetect.result_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot for change points or a series of plots for Granger causal networks for estimated model parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nob &lt;- 1000
p &lt;- 15
brk &lt;- c(floor(nob / 3), floor(2 * nob / 3), nob + 1)
m &lt;- length(brk)
q.t &lt;- 1
try &lt;- simu_var('sparse',nob=nob,k=p,lags=q.t,brk=brk,sp_pattern="off-diagonal",seed = 1)
data &lt;- try$series
data &lt;- as.matrix(data)
fit &lt;- tbss(data, method = "sparse", q = q.t)
plot(fit, display = "cp")
plot(fit, display = "param")
plot(fit, display = "granger", threshold = 0.2, layout = "nicely")
plot(fit, display = "density", threshold = 0.2)
</code></pre>

<hr>
<h2 id='pred'>Prediction function (single observation)</h2><span id='topic+pred'></span>

<h3>Description</h3>

<p>Prediction function (single observation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred(Y, phi, q, nob, p, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_+3A_y">Y</code></td>
<td>
<p>data for prediction</p>
</td></tr>
<tr><td><code id="pred_+3A_phi">phi</code></td>
<td>
<p>parameter matrix</p>
</td></tr>
<tr><td><code id="pred_+3A_q">q</code></td>
<td>
<p>lag</p>
</td></tr>
<tr><td><code id="pred_+3A_nob">nob</code></td>
<td>
<p>total length of data</p>
</td></tr>
<tr><td><code id="pred_+3A_p">p</code></td>
<td>
<p>the dimension of time series components</p>
</td></tr>
<tr><td><code id="pred_+3A_h">h</code></td>
<td>
<p>the h-th observation to predict</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prediction matrix
</p>

<hr>
<h2 id='pred.block'>Prediction function (block)</h2><span id='topic+pred.block'></span>

<h3>Description</h3>

<p>Prediction function (block)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.block(Y, phi, q, nob, p, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.block_+3A_y">Y</code></td>
<td>
<p>data for prediction</p>
</td></tr>
<tr><td><code id="pred.block_+3A_phi">phi</code></td>
<td>
<p>parameter matrix</p>
</td></tr>
<tr><td><code id="pred.block_+3A_q">q</code></td>
<td>
<p>lag</p>
</td></tr>
<tr><td><code id="pred.block_+3A_nob">nob</code></td>
<td>
<p>total length of data</p>
</td></tr>
<tr><td><code id="pred.block_+3A_p">p</code></td>
<td>
<p>the dimension of time series components</p>
</td></tr>
<tr><td><code id="pred.block_+3A_h">h</code></td>
<td>
<p>the length of observation to predict</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prediction matrix
</p>

<hr>
<h2 id='print.VARDetect.result'>Function to print the change points estimated by VARDetect</h2><span id='topic+print.VARDetect.result'></span>

<h3>Description</h3>

<p>Print the estimated change points of class <code>VARDetect.result</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARDetect.result'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.VARDetect.result_+3A_x">x</code></td>
<td>
<p>a <code>VARDetect.result</code> class object</p>
</td></tr>
<tr><td><code id="print.VARDetect.result_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print the estimated change points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nob &lt;- 1000
p &lt;- 15
brk &lt;- c(floor(nob / 3), floor(2 * nob / 3), nob + 1)
m &lt;- length(brk)
q.t &lt;- 1
try &lt;- simu_var('sparse',nob=nob,k=p,lags=q.t,brk=brk,sp_pattern="off-diagonal",seed=1)
data &lt;- try$series
data &lt;- as.matrix(data)
fit &lt;- tbss(data, method = "sparse", q = q.t)
print(fit)
</code></pre>

<hr>
<h2 id='prox.nuclear.func'>Proximal function with nuclear norm penalty updating</h2><span id='topic+prox.nuclear.func'></span>

<h3>Description</h3>

<p>Proximal function with nuclear norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prox.nuclear.func(w1, y, A, b, L, lambda, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prox.nuclear.func_+3A_w1">w1</code></td>
<td>
<p>previously updated model parameter</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_y">y</code></td>
<td>
<p>updated model parameter</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_a">A</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_b">b</code></td>
<td>
<p>correspond vector, or matrix</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_l">L</code></td>
<td>
<p>learning rate</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for low-rank component</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_ata">AtA</code></td>
<td>
<p>Gram matrix of design matrix A</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_atb">Atb</code></td>
<td>
<p>inner product of design matrix A and correspond vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of proximal function with nuclear norm penalty
</p>

<hr>
<h2 id='prox.nuclear.func.fLS'>Proximal function for nuclear norm penalty</h2><span id='topic+prox.nuclear.func.fLS'></span>

<h3>Description</h3>

<p>Proximal function for nuclear norm penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prox.nuclear.func.fLS(y, A, b, L, lambda, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prox.nuclear.func.fLS_+3A_y">y</code></td>
<td>
<p>model parameter</p>
</td></tr>
<tr><td><code id="prox.nuclear.func.fLS_+3A_a">A</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="prox.nuclear.func.fLS_+3A_b">b</code></td>
<td>
<p>correspond vector, or matrix</p>
</td></tr>
<tr><td><code id="prox.nuclear.func.fLS_+3A_l">L</code></td>
<td>
<p>learning rate</p>
</td></tr>
<tr><td><code id="prox.nuclear.func.fLS_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter</p>
</td></tr>
<tr><td><code id="prox.nuclear.func.fLS_+3A_ata">AtA</code></td>
<td>
<p>Gram matrix obtained by design matrix</p>
</td></tr>
<tr><td><code id="prox.nuclear.func.fLS_+3A_atb">Atb</code></td>
<td>
<p>inner product for design matrix A and correspond vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of proximal function
</p>

<hr>
<h2 id='prox.sparse.func'>Proximal function with l1-norm penalty updating</h2><span id='topic+prox.sparse.func'></span>

<h3>Description</h3>

<p>Proximal function with l1-norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prox.sparse.func(w1, y, A, b, L, lambda, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prox.sparse.func_+3A_w1">w1</code></td>
<td>
<p>previously updated model parameter</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_y">y</code></td>
<td>
<p>updated model parameter</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_a">A</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_b">b</code></td>
<td>
<p>correspond vector, or matrix</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_l">L</code></td>
<td>
<p>learning rate</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_ata">AtA</code></td>
<td>
<p>Gram matrix of design matrix A</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_atb">Atb</code></td>
<td>
<p>inner product of design matrix A and correspond vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of proximal function with l1-norm penalty
</p>

<hr>
<h2 id='Q.func'>An auxiliary function in FISTA algorithm</h2><span id='topic+Q.func'></span>

<h3>Description</h3>

<p>Auxiliary function for FISTA implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q.func(x, y, A, b, L, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q.func_+3A_x">x</code></td>
<td>
<p>Model parameter for previous update</p>
</td></tr>
<tr><td><code id="Q.func_+3A_y">y</code></td>
<td>
<p>Model parameter for updating</p>
</td></tr>
<tr><td><code id="Q.func_+3A_a">A</code></td>
<td>
<p>An n by p design matrix</p>
</td></tr>
<tr><td><code id="Q.func_+3A_b">b</code></td>
<td>
<p>A correspond vector, or matrix with size of n by 1 or n by p</p>
</td></tr>
<tr><td><code id="Q.func_+3A_l">L</code></td>
<td>
<p>Learning rate</p>
</td></tr>
<tr><td><code id="Q.func_+3A_ata">AtA</code></td>
<td>
<p>Gram matrix for design matrix A</p>
</td></tr>
<tr><td><code id="Q.func_+3A_atb">Atb</code></td>
<td>
<p>Inner product for design matrix A and correspond vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of function Q
</p>

<hr>
<h2 id='remove.extra.pts'>helper function for detection check</h2><span id='topic+remove.extra.pts'></span>

<h3>Description</h3>

<p>helper function for detection check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.extra.pts(pts, brk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.extra.pts_+3A_pts">pts</code></td>
<td>
<p>the estimated change points</p>
</td></tr>
<tr><td><code id="remove.extra.pts_+3A_brk">brk</code></td>
<td>
<p>the true change points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of time points
</p>

<hr>
<h2 id='second.step.detect'>Backward elimination algorithm for screening in the second step</h2><span id='topic+second.step.detect'></span>

<h3>Description</h3>

<p>Backward elimination algorithm function for screening
</p>


<h3>Usage</h3>

<pre><code class='language-R'>second.step.detect(
  data,
  pts,
  omega,
  lambda,
  mu,
  alpha_L = 0.25,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="second.step.detect_+3A_data">data</code></td>
<td>
<p>a n by p dataset matrix</p>
</td></tr>
<tr><td><code id="second.step.detect_+3A_pts">pts</code></td>
<td>
<p>a vector includes all candidate change points obtained by the first step</p>
</td></tr>
<tr><td><code id="second.step.detect_+3A_omega">omega</code></td>
<td>
<p>tuning parameter for the information criterion function</p>
</td></tr>
<tr><td><code id="second.step.detect_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for sparse component estimation</p>
</td></tr>
<tr><td><code id="second.step.detect_+3A_mu">mu</code></td>
<td>
<p>tuning parameter for low rank component estimation</p>
</td></tr>
<tr><td><code id="second.step.detect_+3A_alpha_l">alpha_L</code></td>
<td>
<p>a numeric value, indicates the size of constraint space of low rank component</p>
</td></tr>
<tr><td><code id="second.step.detect_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, then it provides all information for current stage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object includes
</p>

<dl>
<dt>pts</dt><dd><p>Final selected change points</p>
</dd>
<dt>ic</dt><dd><p>Values of information criterion</p>
</dd>
</dl>


<hr>
<h2 id='second.step.local'>local screening step (second step).</h2><span id='topic+second.step.local'></span>

<h3>Description</h3>

<p>Perform the local screening to &quot;thin out&quot; redundant break points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>second.step.local(
  method = "sparse",
  data,
  eta,
  q,
  max.iteration = 1000,
  tol = 10^(-4),
  pts,
  an,
  phi.est.full = NULL,
  blocks = NULL,
  use.BIC = FALSE,
  group.case = "columnwise",
  group.index = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="second.step.local_+3A_method">method</code></td>
<td>
<p>method: sparse, group sparse</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_data">data</code></td>
<td>
<p>input data matrix, with each column representing the time series component</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_eta">eta</code></td>
<td>
<p>tuning parameter eta for lasso</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_q">q</code></td>
<td>
<p>the AR order</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_max.iteration">max.iteration</code></td>
<td>
<p>max number of iteration for the fused lasso</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_tol">tol</code></td>
<td>
<p>tolerance for the fused lasso</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_pts">pts</code></td>
<td>
<p>the selected break points after the first step</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_an">an</code></td>
<td>
<p>the neighborhood size a_n</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_phi.est.full">phi.est.full</code></td>
<td>
<p>parameter matrix</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_blocks">blocks</code></td>
<td>
<p>a vector of blocks</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_use.bic">use.BIC</code></td>
<td>
<p>use BIC for k-means part</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_group.case">group.case</code></td>
<td>
<p>group sparse pattern: columnwise, rowwise.</p>
</td></tr>
<tr><td><code id="second.step.local_+3A_group.index">group.index</code></td>
<td>
<p>group index for group sparse case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which contains the followings
</p>

<dl>
<dt>pts</dt><dd><p>a set of selected break point after the second local screening step</p>
</dd>
<dt>omega</dt><dd><p>the selected Omega value</p>
</dd>
</dl>


<hr>
<h2 id='shrinkage'>Shrinkage function for sparse soft-thresholding</h2><span id='topic+shrinkage'></span>

<h3>Description</h3>

<p>Shrinkage function for sparse soft-thresholding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkage(y, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrinkage_+3A_y">y</code></td>
<td>
<p>A matrix, or a vector for thresholding</p>
</td></tr>
<tr><td><code id="shrinkage_+3A_tau">tau</code></td>
<td>
<p>A positive number, threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A thresholded matrix, or vector
</p>

<hr>
<h2 id='shrinkage.lr'>Shrinkage function for low-rank soft-thresholding</h2><span id='topic+shrinkage.lr'></span>

<h3>Description</h3>

<p>Shrinkage function for low-rank soft-thresholding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkage.lr(y, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrinkage.lr_+3A_y">y</code></td>
<td>
<p>A matrix, or a vector for thresholding</p>
</td></tr>
<tr><td><code id="shrinkage.lr_+3A_tau">tau</code></td>
<td>
<p>A positive number, threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A thresholded matrix, or vector
</p>

<hr>
<h2 id='simu_lstsp'>Function to deploy simulation with LSTSP algorithm</h2><span id='topic+simu_lstsp'></span>

<h3>Description</h3>

<p>A function to generate simulation with LSTSP algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_lstsp(
  nreps,
  simu_method = c("LS"),
  nob,
  k,
  lags = 1,
  lags_vector = NULL,
  brk,
  sigma,
  skip = 50,
  group_mats = NULL,
  group_type = c("columnwise", "rowwise"),
  group_index = NULL,
  sparse_mats = NULL,
  sp_density = NULL,
  signals = NULL,
  rank = NULL,
  info_ratio = NULL,
  sp_pattern = c("off-diagonal", "diagoanl", "random"),
  singular_vals = NULL,
  spectral_radius = 0.9,
  alpha_L = 0.25,
  lambda.1 = NULL,
  mu.1 = NULL,
  lambda.1.seq = NULL,
  mu.1.seq = NULL,
  lambda.2,
  mu.2,
  lambda.3,
  mu.3,
  omega = NULL,
  h = NULL,
  step.size = NULL,
  tol = 1e-04,
  niter = 100,
  backtracking = TRUE,
  rolling.skip = 5,
  cv = FALSE,
  nfold = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_lstsp_+3A_nreps">nreps</code></td>
<td>
<p>A positive integer, indicating the number of simulation replications</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_simu_method">simu_method</code></td>
<td>
<p>the structure of time series: only available for &quot;LS&quot;</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_nob">nob</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_k">k</code></td>
<td>
<p>dimension of transition matrix</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_lags">lags</code></td>
<td>
<p>lags of VAR time series. Default is 1.</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_lags_vector">lags_vector</code></td>
<td>
<p>a vector of lags of VAR time series for each segment</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_brk">brk</code></td>
<td>
<p>a vector of break points with (nob+1) as the last element</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_sigma">sigma</code></td>
<td>
<p>the variance matrix for error term</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_skip">skip</code></td>
<td>
<p>an argument to control the leading data points to obtain a stationary time series</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_group_mats">group_mats</code></td>
<td>
<p>transition matrix for group sparse case</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_group_type">group_type</code></td>
<td>
<p>type for group lasso: &quot;columnwise&quot;, &quot;rowwise&quot;. Default is &quot;columnwise&quot;.</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_group_index">group_index</code></td>
<td>
<p>group index for group lasso.</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_sparse_mats">sparse_mats</code></td>
<td>
<p>transition matrix for sparse case</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_sp_density">sp_density</code></td>
<td>
<p>if we choose random pattern, we should provide the sparsity density for each segment</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_signals">signals</code></td>
<td>
<p>manually setting signal for each segment (including sign)</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_rank">rank</code></td>
<td>
<p>if we choose method is low rank plus sparse, we need to provide the ranks for each segment</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_info_ratio">info_ratio</code></td>
<td>
<p>the information ratio leverages the signal strength from low rank and sparse components</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_sp_pattern">sp_pattern</code></td>
<td>
<p>a choice of the pattern of sparse component: diagonal, 1-off diagonal, random, custom</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_singular_vals">singular_vals</code></td>
<td>
<p>singular values for the low rank components</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_spectral_radius">spectral_radius</code></td>
<td>
<p>to ensure the time series is piecewise stationary.</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_alpha_l">alpha_L</code></td>
<td>
<p>a positive numeric value, indicating the restricted space of low rank component, default is 0.25</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_lambda.1">lambda.1</code></td>
<td>
<p>tuning parameter for sparse component for the first step</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_mu.1">mu.1</code></td>
<td>
<p>tuning parameter for low rank component for the first step</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_lambda.1.seq">lambda.1.seq</code></td>
<td>
<p>a sequence of lambda to the left segment for cross-validation, it's not mandatory to provide</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_mu.1.seq">mu.1.seq</code></td>
<td>
<p>a sequence of mu to the left segment, low rank component tuning parameter</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_lambda.2">lambda.2</code></td>
<td>
<p>tuning parameter for sparse for the second step</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_mu.2">mu.2</code></td>
<td>
<p>tuning parameter for low rank for the second step</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_lambda.3">lambda.3</code></td>
<td>
<p>tuning parameter for estimating sparse components</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_mu.3">mu.3</code></td>
<td>
<p>tuning parameter for estimating low rank components</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_omega">omega</code></td>
<td>
<p>tuning parameter for information criterion, the larger of omega, the fewer final selected change points</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_h">h</code></td>
<td>
<p>window size of the first rolling window step</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_step.size">step.size</code></td>
<td>
<p>rolling step</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_tol">tol</code></td>
<td>
<p>tolerance for the convergence in the second screening step, indicates when to stop</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_niter">niter</code></td>
<td>
<p>the number of iterations required for FISTA algorithm</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_backtracking">backtracking</code></td>
<td>
<p>A boolean argument to indicate use backtrack to FISTA model</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_rolling.skip">rolling.skip</code></td>
<td>
<p>The number of observations need to skip near the boundaries</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_cv">cv</code></td>
<td>
<p>A boolean argument, indicates whether the user will apply cross validation to select tuning parameter, default is FALSE</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_nfold">nfold</code></td>
<td>
<p>An positive integer, the number of folds for cross validation</p>
</td></tr>
<tr><td><code id="simu_lstsp_+3A_verbose">verbose</code></td>
<td>
<p>If is TRUE, then it will print all information about current step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S3 object of class <code>VARDetect.simu.result</code>, containing the following entries:
</p>

<dl>
<dt>sizes</dt><dd><p>A 2-d numeric vector, indicating the size of time series data</p>
</dd>
<dt>true_lag</dt><dd><p>True time lags for the process, here is fixed to be 1.</p>
</dd>
<dt>true_lagvector</dt><dd><p>A vector recording the time lags for different segments, not available under this model setting,
here is fixed to be NULL</p>
</dd>
<dt>true_cp</dt><dd><p>True change points for simulation, a numeric vector</p>
</dd>
<dt>true_sparse</dt><dd><p>A list of numeric matrices, indicating the true sparse components for all segments</p>
</dd>
<dt>true_lowrank</dt><dd><p>A list of numeric matrices, indicating the true low rank components for all segments</p>
</dd>
<dt>est_cps</dt><dd><p>A list of estimated change points, including all replications</p>
</dd>
<dt>est_lag</dt><dd><p>A numeric value, estimated time lags, which is user specified</p>
</dd>
<dt>est_lagvector</dt><dd><p>A vector for estimated time lags, not available for this model, set as NULL.</p>
</dd>
<dt>est_sparse_mats</dt><dd><p>A list of estimated sparse components for all replications</p>
</dd>
<dt>est_lowrank_mats</dt><dd><p>A list of estimated low rank components for all replications</p>
</dd>
<dt>est_phi_mats</dt><dd><p>A list of estimated model parameters, transition matrices for VAR model</p>
</dd>
<dt>running_times</dt><dd><p>A numeric vector, containing all running times</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
nob &lt;- 100
p &lt;- 15
brk &lt;- c(50, nob+1)
rank &lt;- c(1, 3)
signals &lt;- c(-0.7, 0.8)
singular_vals &lt;- c(1, 0.75, 0.5)
info_ratio &lt;- rep(0.35, 2)
lambda1 = lambda2 = lambda3 &lt;- c(2.5, 2.5)
mu1 = mu2 = mu3 &lt;- c(15, 15)
try_simu &lt;- simu_lstsp(nreps = 3, simu_method = "LS", nob = nob, k = p,
                       brk = brk, sigma = diag(p), signals = signals,
                       rank = rank, singular_vals = singular_vals,
                       info_ratio = info_ratio, sp_pattern = "off-diagonal",
                       spectral_radius = 0.9, lambda.1 = lambda1, mu.1 = mu1,
                       lambda.2 = lambda2, mu.2 = mu2, lambda.3 = lambda3,
                       mu.3 = mu3, step.size = 5, niter = 20, rolling.skip = 5,
                       cv = FALSE, verbose = TRUE)
summary(try_simu, critical = 5)

</code></pre>

<hr>
<h2 id='simu_tbss'>Simulation function for TBSS algorithm</h2><span id='topic+simu_tbss'></span>

<h3>Description</h3>

<p>Function for deploying simulation using TBSS algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_tbss(
  nreps,
  simu_method = c("sparse", "group sparse", "fLS"),
  nob,
  k,
  lags = 1,
  lags_vector = NULL,
  brk,
  sigma,
  skip = 50,
  group_mats = NULL,
  group_type = c("columnwise", "rowwise"),
  group_index = NULL,
  sparse_mats = NULL,
  sp_density = NULL,
  signals = NULL,
  rank = NULL,
  info_ratio = NULL,
  sp_pattern = c("off-diagonal", "diagoanl", "random"),
  singular_vals = NULL,
  spectral_radius = 0.9,
  est_method = c("sparse", "group sparse", "fLS"),
  q = 1,
  tol = 0.01,
  lambda.1.cv = NULL,
  lambda.2.cv = NULL,
  mu = NULL,
  group.index = NULL,
  group.case = c("columnwise", "rowwise"),
  max.iteration = 100,
  refit = FALSE,
  block.size = NULL,
  blocks = NULL,
  use.BIC = TRUE,
  an.grid = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_tbss_+3A_nreps">nreps</code></td>
<td>
<p>A numeric integer number, indicates the number of simulation replications</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_simu_method">simu_method</code></td>
<td>
<p>the structure of time series: &quot;sparse&quot;,&quot;group sparse&quot;, and &quot;fLS&quot;</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_nob">nob</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_k">k</code></td>
<td>
<p>dimension of transition matrix</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_lags">lags</code></td>
<td>
<p>lags of VAR time series. Default is 1.</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_lags_vector">lags_vector</code></td>
<td>
<p>a vector of lags of VAR time series for each segment</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_brk">brk</code></td>
<td>
<p>a vector of break points with (nob+1) as the last element</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_sigma">sigma</code></td>
<td>
<p>the variance matrix for error term</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_skip">skip</code></td>
<td>
<p>an argument to control the leading data points to obtain a stationary time series</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_group_mats">group_mats</code></td>
<td>
<p>transition matrix for group sparse case</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_group_type">group_type</code></td>
<td>
<p>type for group lasso: &quot;columnwise&quot;, &quot;rowwise&quot;. Default is &quot;columnwise&quot;.</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_group_index">group_index</code></td>
<td>
<p>group index for group lasso.</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_sparse_mats">sparse_mats</code></td>
<td>
<p>transition matrix for sparse case</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_sp_density">sp_density</code></td>
<td>
<p>if we choose random pattern, we should provide the sparsity density for each segment</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_signals">signals</code></td>
<td>
<p>manually setting signal for each segment (including sign)</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_rank">rank</code></td>
<td>
<p>if we choose method is low rank plus sparse, we need to provide the ranks for each segment</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_info_ratio">info_ratio</code></td>
<td>
<p>the information ratio leverages the signal strength from low rank and sparse components</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_sp_pattern">sp_pattern</code></td>
<td>
<p>a choice of the pattern of sparse component: diagonal, 1-off diagonal, random, custom</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_singular_vals">singular_vals</code></td>
<td>
<p>singular values for the low rank components</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_spectral_radius">spectral_radius</code></td>
<td>
<p>to ensure the time series is piecewise stationary.</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_est_method">est_method</code></td>
<td>
<p>method: sparse, group sparse, and fixed low rank plus sparse. Default is sparse</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_q">q</code></td>
<td>
<p>the AR order</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_tol">tol</code></td>
<td>
<p>tolerance for the fused lasso</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_lambda.1.cv">lambda.1.cv</code></td>
<td>
<p>tuning parameter lambda_1 for fused lasso</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_lambda.2.cv">lambda.2.cv</code></td>
<td>
<p>tuning parameter lambda_2 for fused lasso</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_mu">mu</code></td>
<td>
<p>tuning parameter for low rank component, only available when method is set to &quot;fLS&quot;</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_group.index">group.index</code></td>
<td>
<p>group index for group sparse case</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_group.case">group.case</code></td>
<td>
<p>group sparse pattern: column, row.</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_max.iteration">max.iteration</code></td>
<td>
<p>max number of iteration for the fused lasso</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_refit">refit</code></td>
<td>
<p>logical; if TRUE, refit the VAR model for parameter estimation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_block.size">block.size</code></td>
<td>
<p>the block size</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_blocks">blocks</code></td>
<td>
<p>the blocks</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_use.bic">use.BIC</code></td>
<td>
<p>use BIC for k-means part</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_an.grid">an.grid</code></td>
<td>
<p>a vector of an for grid searching</p>
</td></tr>
<tr><td><code id="simu_tbss_+3A_verbose">verbose</code></td>
<td>
<p>a Boolean argument; if TRUE, function provides detailed information. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S3 object of class, named <code>VARDetect.simu.result</code>
</p>

<dl>
<dt>est_cps</dt><dd><p>A list of estimated change points, including all replications</p>
</dd>
<dt>est_sparse_mats</dt><dd><p>A list of estimated sparse components for all replications</p>
</dd>
<dt>est_lowrank_mats</dt><dd><p>A list of estimated low rank components for all replications</p>
</dd>
<dt>est_phi_mats</dt><dd><p>A list of estimated model parameters, transition matrices for VAR model</p>
</dd>
<dt>running_times</dt><dd><p>A numeric vector, containing all running times</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
nob &lt;- 4000; p &lt;- 15
brk &lt;- c(floor(nob / 3), floor(2 * nob / 3), nob + 1)
m &lt;- length(brk); q.t &lt;- 1
sp_density &lt;- rep(0.05, m * q.t)
signals &lt;- c(-0.6, 0.6, -0.6)
try_simu &lt;- simu_tbss(nreps = 3, simu_method = "sparse", nob = nob,
                      k = p, lags = q.t, brk = brk, sigma = diag(p),
                      signals = signals, sp_density = sp_density,
                      sp_pattern = "random", est_method = "sparse", q = q.t,
                      refit = TRUE)

</code></pre>

<hr>
<h2 id='simu_var'>Generate VAR(p) model data with break points</h2><span id='topic+simu_var'></span>

<h3>Description</h3>

<p>This function is used for generate simulated time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_var(
  method = c("sparse", "group sparse", "fLS", "LS"),
  nob = 300,
  k = 20,
  lags = 1,
  lags_vector = NULL,
  brk,
  sigma = NULL,
  skip = 50,
  spectral_radius = 0.98,
  seed = NULL,
  sp_density = NULL,
  group_mats = NULL,
  group_index = NULL,
  group_type = c("columnwise", "rowwise"),
  sparse_mats = NULL,
  sp_pattern = c("off-diagonal", "diagonal", "random"),
  rank = NULL,
  info_ratio = NULL,
  signals = NULL,
  singular_vals = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_var_+3A_method">method</code></td>
<td>
<p>the structure of time series: &quot;sparse&quot;,&quot;group sparse&quot;, &quot;fLS&quot;, &quot;LS&quot;</p>
</td></tr>
<tr><td><code id="simu_var_+3A_nob">nob</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simu_var_+3A_k">k</code></td>
<td>
<p>dimension of transition matrix</p>
</td></tr>
<tr><td><code id="simu_var_+3A_lags">lags</code></td>
<td>
<p>lags of VAR time series. Default is 1.</p>
</td></tr>
<tr><td><code id="simu_var_+3A_lags_vector">lags_vector</code></td>
<td>
<p>a vector of lags of VAR time series for each segment</p>
</td></tr>
<tr><td><code id="simu_var_+3A_brk">brk</code></td>
<td>
<p>a vector of break points with (nob+1) as the last element</p>
</td></tr>
<tr><td><code id="simu_var_+3A_sigma">sigma</code></td>
<td>
<p>the variance matrix for error term</p>
</td></tr>
<tr><td><code id="simu_var_+3A_skip">skip</code></td>
<td>
<p>an argument to control the leading data points to obtain a stationary time series</p>
</td></tr>
<tr><td><code id="simu_var_+3A_spectral_radius">spectral_radius</code></td>
<td>
<p>to ensure the time series is piecewise stationary.</p>
</td></tr>
<tr><td><code id="simu_var_+3A_seed">seed</code></td>
<td>
<p>an argument to control the random seed. Default seed is 1.</p>
</td></tr>
<tr><td><code id="simu_var_+3A_sp_density">sp_density</code></td>
<td>
<p>if we choose random pattern, we should provide the sparsity density for each segment</p>
</td></tr>
<tr><td><code id="simu_var_+3A_group_mats">group_mats</code></td>
<td>
<p>transition matrix for group sparse case</p>
</td></tr>
<tr><td><code id="simu_var_+3A_group_index">group_index</code></td>
<td>
<p>group index for group lasso.</p>
</td></tr>
<tr><td><code id="simu_var_+3A_group_type">group_type</code></td>
<td>
<p>type for group lasso: &quot;columnwise&quot;, &quot;rowwise&quot;. Default is &quot;columnwise&quot;.</p>
</td></tr>
<tr><td><code id="simu_var_+3A_sparse_mats">sparse_mats</code></td>
<td>
<p>transition matrix for sparse case</p>
</td></tr>
<tr><td><code id="simu_var_+3A_sp_pattern">sp_pattern</code></td>
<td>
<p>a choice of the pattern of sparse component: diagonal, 1-off diagonal, random, custom</p>
</td></tr>
<tr><td><code id="simu_var_+3A_rank">rank</code></td>
<td>
<p>if we choose method is low rank plus sparse, we need to provide the ranks for each segment</p>
</td></tr>
<tr><td><code id="simu_var_+3A_info_ratio">info_ratio</code></td>
<td>
<p>the information ratio leverages the signal strength from low rank and sparse components</p>
</td></tr>
<tr><td><code id="simu_var_+3A_signals">signals</code></td>
<td>
<p>manually setting signal for each segment (including sign)</p>
</td></tr>
<tr><td><code id="simu_var_+3A_singular_vals">singular_vals</code></td>
<td>
<p>singular values for the low rank components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which contains the followings
</p>

<dl>
<dt>series</dt><dd><p>matrix of timeseries data</p>
</dd>
<dt>noises</dt><dd><p>matrix of noise term data</p>
</dd>
<dt>sparse_mats</dt><dd><p>list of sparse matrix in the transition matrix</p>
</dd>
<dt>lowrank_mats</dt><dd><p>list of low-rank matrix in the transition matrix</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>nob &lt;- (10^3 * 4) # number of time points
p &lt;- 15 # number of time series components
brk &lt;- c(floor(nob / 3), floor(2 * nob / 3), nob + 1)
m0 &lt;- length(brk) - 1 # number of break points
q.t &lt;- 2 # the true AR order
m &lt;- m0 + 1 # number of segments
sp_density &lt;- rep(0.05, m * q.t) # sparsity level (5%)
try &lt;- simu_var("sparse", nob = nob, k = p, lags = q.t, brk = brk,
                sp_pattern = "random", sp_density = sp_density)
print(plot_matrix(do.call("cbind", try$model_param), m * q.t))

</code></pre>

<hr>
<h2 id='sparse.pen'>L1-norm penalty for sparse component</h2><span id='topic+sparse.pen'></span>

<h3>Description</h3>

<p>L1-norm penalty for sparse component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.pen(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse.pen_+3A_x">x</code></td>
<td>
<p>Model parameter</p>
</td></tr>
<tr><td><code id="sparse.pen_+3A_lambda">lambda</code></td>
<td>
<p>Tuning parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of l1-norm penalty term
</p>

<hr>
<h2 id='summary.VARDetect.result'>Function to summarize the change points estimated by VARDetect</h2><span id='topic+summary.VARDetect.result'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>VARDetect.result</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARDetect.result'
summary(object, threshold = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.VARDetect.result_+3A_object">object</code></td>
<td>
<p>a <code>VARDetect.result</code> object</p>
</td></tr>
<tr><td><code id="summary.VARDetect.result_+3A_threshold">threshold</code></td>
<td>
<p>A numeric positive value, used to determine the threshold of nonzero entries</p>
</td></tr>
<tr><td><code id="summary.VARDetect.result_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of summary, including the estimated change points, running time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nob &lt;- 1000
p &lt;- 15
brk &lt;- c(floor(nob / 3), floor(2 * nob / 3), nob + 1)
m &lt;- length(brk)
q.t &lt;- 1
try &lt;- simu_var('sparse',nob=nob,k=p,lags=q.t,brk=brk,sp_pattern="off-diagonal",seed=1)
data &lt;- try$series
data &lt;- as.matrix(data)
fit &lt;- tbss(data, method = "sparse", q = q.t)
summary(fit)
</code></pre>

<hr>
<h2 id='summary.VARDetect.simu.result'>A function to summarize the results for simulation</h2><span id='topic+summary.VARDetect.simu.result'></span>

<h3>Description</h3>

<p>A function to summarize the results for simulation class <code>VARDetect.simu.result</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARDetect.simu.result'
summary(object, critical = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.VARDetect.simu.result_+3A_object">object</code></td>
<td>
<p>A S3 object of class <code>VARDetect.simu.result</code></p>
</td></tr>
<tr><td><code id="summary.VARDetect.simu.result_+3A_critical">critical</code></td>
<td>
<p>A positive integer, set as the critical value defined in selection rate, to control the range of success, default is 5</p>
</td></tr>
<tr><td><code id="summary.VARDetect.simu.result_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of summary, including the selection rate, Hausdorff distance, and statistical measurements, running times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nob &lt;- 4000; p &lt;- 15
brk &lt;- c(floor(nob / 3), floor(2 * nob / 3), nob + 1)
m &lt;- length(brk); q.t &lt;- 1
sp_density &lt;- rep(0.05, m * q.t)
signals &lt;- c(-0.6, 0.6, -0.6)
try_simu &lt;- simu_tbss(nreps = 3, simu_method = "sparse", nob = nob,
                      k = p, lags = q.t, brk = brk, sigma = diag(p),
                      signals = signals, sp_density = sp_density,
                      sp_pattern = "random", est_method = "sparse",
                      q = q.t, refit = TRUE)
summary(try_simu, critical = 5)

</code></pre>

<hr>
<h2 id='tbss'>Block segmentation scheme (BSS).</h2><span id='topic+tbss'></span>

<h3>Description</h3>

<p>Perform the block segmentation scheme (BSS) algorithm to detect the structural breaks
in large scale high-dimensional non-stationary VAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbss(
  data,
  method = c("sparse", "group sparse", "fLS"),
  group.case = c("columnwise", "rowwise"),
  group.index = NULL,
  lambda.1.cv = NULL,
  lambda.2.cv = NULL,
  mu = NULL,
  q = 1,
  max.iteration = 50,
  tol = 10^(-2),
  block.size = NULL,
  blocks = NULL,
  refit = FALSE,
  use.BIC = TRUE,
  an.grid = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbss_+3A_data">data</code></td>
<td>
<p>input data matrix, with each column representing the time series component</p>
</td></tr>
<tr><td><code id="tbss_+3A_method">method</code></td>
<td>
<p>method: sparse, group sparse, and fixed low rank plus sparse. Default is sparse</p>
</td></tr>
<tr><td><code id="tbss_+3A_group.case">group.case</code></td>
<td>
<p>group sparse pattern: column, row.</p>
</td></tr>
<tr><td><code id="tbss_+3A_group.index">group.index</code></td>
<td>
<p>group index for group sparse case</p>
</td></tr>
<tr><td><code id="tbss_+3A_lambda.1.cv">lambda.1.cv</code></td>
<td>
<p>tuning parameter lambda_1 for fused lasso</p>
</td></tr>
<tr><td><code id="tbss_+3A_lambda.2.cv">lambda.2.cv</code></td>
<td>
<p>tuning parameter lambda_2 for fused lasso</p>
</td></tr>
<tr><td><code id="tbss_+3A_mu">mu</code></td>
<td>
<p>tuning parameter for low rank component, only available when method is set to &quot;fLS&quot;</p>
</td></tr>
<tr><td><code id="tbss_+3A_q">q</code></td>
<td>
<p>the VAR lag</p>
</td></tr>
<tr><td><code id="tbss_+3A_max.iteration">max.iteration</code></td>
<td>
<p>max number of iteration for the Fused lasso</p>
</td></tr>
<tr><td><code id="tbss_+3A_tol">tol</code></td>
<td>
<p>tolerance for the fused lasso</p>
</td></tr>
<tr><td><code id="tbss_+3A_block.size">block.size</code></td>
<td>
<p>the block size</p>
</td></tr>
<tr><td><code id="tbss_+3A_blocks">blocks</code></td>
<td>
<p>the blocks</p>
</td></tr>
<tr><td><code id="tbss_+3A_refit">refit</code></td>
<td>
<p>logical; if TRUE, refit the VAR model for parameter estimation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="tbss_+3A_use.bic">use.BIC</code></td>
<td>
<p>use BIC for k-means part</p>
</td></tr>
<tr><td><code id="tbss_+3A_an.grid">an.grid</code></td>
<td>
<p>a vector of an for grid searching</p>
</td></tr>
<tr><td><code id="tbss_+3A_verbose">verbose</code></td>
<td>
<p>a Boolean argument to determine whether provide detailed outputs for each step. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object of class <code>VARDetect.result</code>, which contains the followings
</p>

<dl>
<dt>data</dt><dd><p>the original dataset</p>
</dd>
<dt>q</dt><dd><p>the time lag user specified, a numeric value</p>
</dd>
<dt>cp</dt><dd><p>final estimated change points, a numeric vector</p>
</dd>
<dt>sparse_mats</dt><dd><p>estimated sparse components for each segment, a list of numeric matrices</p>
</dd>
<dt>lowrank_mats</dt><dd><p>estimated low rank components for each segment, a list of numeric matrices</p>
</dd>
<dt>est_phi</dt><dd><p>estimated final model parameters, the summation of the sparse and the low rank components</p>
</dd>
<dt>time</dt><dd><p>computation time for each step</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#### sparse VAR model
nob &lt;- (10^3) # number of time points
p &lt;- 15; # number of time series components
brk &lt;- c(floor(nob/3),floor(2*nob/3),nob+1); # true break points with nob+1 as the last element
m0 &lt;- length(brk) -1; # number of break points
q.t &lt;- 1; # the true AR order
m &lt;- m0+1 #number of segments
try&lt;-simu_var('sparse',nob=nob,k=p,lags=q.t,brk = brk,sp_pattern="off-diagonal",seed=1)
data &lt;- try$series
data &lt;- as.matrix(data)
#run the bss method
fit &lt;- tbss(data, method = "sparse", q = q.t)
print(fit)
summary(fit)
plot(fit, data, display = "cp")
plot(fit, data, display = "param")


###### Example for fixed low rank plus sparse structure VAR model
nob &lt;- 300
p &lt;- 15
brk &lt;- c(floor(nob/3), floor(2*nob/3), nob+1)
m &lt;- length(brk)
q.t &lt;- 1
signals &lt;- c(-0.7, 0.7, -0.7)
rank &lt;- c(2, 2, 2)
singular_vals &lt;- c(1, 0.75)
info_ratio &lt;- rep(0.35, 3)
try &lt;- simu_var(method = "fLS", nob = nob, k = p, lags = 1, brk = brk,
                sigma = as.matrix(diag(p)), signals = signals, seed=1,
                rank = rank, singular_vals = singular_vals, info_ratio = info_ratio,
                sp_pattern = "off-diagonal", spectral_radius = 0.9)
data &lt;- try$series
data &lt;- as.matrix(data)
fit &lt;- tbss(data, method = "fLS", mu = 150)
print(fit)
summary(fit)
plot(fit, data, display = "cp")
plot(fit, data, display = "param")
</code></pre>

<hr>
<h2 id='third.step.exhaustive.search'>Exhaustive search step (third step).</h2><span id='topic+third.step.exhaustive.search'></span>

<h3>Description</h3>

<p>Perform the exhaustive search to select the break point for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>third.step.exhaustive.search(
  data,
  q,
  max.iteration = 1000,
  tol = tol,
  pts.list,
  an,
  phi.est.full = NULL,
  phi.local.1 = NULL,
  phi.local.2 = NULL,
  blocks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="third.step.exhaustive.search_+3A_data">data</code></td>
<td>
<p>input data matrix, with each column representing the time series component</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_q">q</code></td>
<td>
<p>the AR order</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_max.iteration">max.iteration</code></td>
<td>
<p>max number of iteration for the fused lasso</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_tol">tol</code></td>
<td>
<p>tolerance for the fused lasso</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_pts.list">pts.list</code></td>
<td>
<p>the selected break points clustered by a_n after the second step</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_an">an</code></td>
<td>
<p>the neighborhood size a_n</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_phi.est.full">phi.est.full</code></td>
<td>
<p>list of local parameter estimator</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_phi.local.1">phi.local.1</code></td>
<td>
<p>a list of loca parameter estimator</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_phi.local.2">phi.local.2</code></td>
<td>
<p>a list of loca parameter estimator</p>
</td></tr>
<tr><td><code id="third.step.exhaustive.search_+3A_blocks">blocks</code></td>
<td>
<p>the blocks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which contains the followings
</p>

<dl>
<dt>pts</dt><dd><p>a set of final selected break point after the third exhaustive search step</p>
</dd>
</dl>


<hr>
<h2 id='weekly'>weekly stock price data</h2><span id='topic+weekly'></span>

<h3>Description</h3>

<p>weekly stock price data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(weekly)
</code></pre>


<h3>Format</h3>

<p>An dataframe of weekly stock price data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weekly)
head(weekly)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
