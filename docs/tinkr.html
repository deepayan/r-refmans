<!DOCTYPE html><html><head><title>Help for package tinkr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tinkr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tinkr-package'><p>tinkr: Cast '(R)Markdown' Files to 'XML' and Back Again</p></a></li>
<li><a href='#add_md'><p>Add markdown content to an XML object</p></a></li>
<li><a href='#find_between'><p>Find between a pattern</p></a></li>
<li><a href='#md_ns'><p>Aliased namespace prefix for commonmark</p></a></li>
<li><a href='#md_to_xml'><p>Convert markdown to XML</p></a></li>
<li><a href='#protect_curly'><p>Protect curly elements for further processing</p></a></li>
<li><a href='#protect_inline_math'><p>Find and protect all inline math elements</p></a></li>
<li><a href='#protect_math'><p>Protect math elements from commonmark's character escape</p></a></li>
<li><a href='#protect_unescaped'><p>Protect unescaped square brackets from being escaped</p></a></li>
<li><a href='#resolve_anchor_links'><p>Resolve Reference-Style Links</p></a></li>
<li><a href='#stylesheet'><p>The tinkr stylesheet</p></a></li>
<li><a href='#to_md'><p>Write YAML and XML back to disk as (R)Markdown</p></a></li>
<li><a href='#to_xml'><p>Transform file to XML</p></a></li>
<li><a href='#yarn'><p>R6 class containing XML representation of Markdown</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cast '(R)Markdown' Files to 'XML' and Back Again</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Parsing '(R)Markdown' files with numerous regular expressions can
    be fraught with peril, but it does not have to be this way. Converting
    '(R)Markdown' files to 'XML' using the 'commonmark' package allows
    in-memory editing via of 'markdown' elements via 'XPath' through the
    extensible 'R6' class called 'yarn'. These modified 'XML' representations
    can be written to '(R)Markdown' documents via an 'xslt' stylesheet which
    implements an extended version of 'GitHub'-flavoured 'markdown' so that you
    can tinker to your hearts content.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/tinkr/">https://docs.ropensci.org/tinkr/</a>,
<a href="https://github.com/ropensci/tinkr">https://github.com/ropensci/tinkr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/tinkr/issues">https://github.com/ropensci/tinkr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>commonmark (&ge; 1.6), glue, magrittr, purrr, R6, xml2, xslt,
yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, covr, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-28 14:41:03 UTC; zhian</td>
</tr>
<tr>
<td>Author:</td>
<td>Maëlle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jeroen Ooms [aut],
  Nick Wellnhofer [cph] (Nick Wellnhofer wrote the XSLT stylesheet.),
  rOpenSci [fnd] (https://ropensci.org/),
  Peter Daengeli [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhian N. Kamvar &lt;zkamvar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-28 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tinkr-package'>tinkr: Cast '(R)Markdown' Files to 'XML' and Back Again</h2><span id='topic+tinkr'></span><span id='topic+tinkr-package'></span>

<h3>Description</h3>

<p>Parsing '(R)Markdown' files with numerous regular expressions can be fraught with peril, but it does not have to be this way. Converting '(R)Markdown' files to 'XML' using the 'commonmark' package allows in-memory editing via of 'markdown' elements via 'XPath' through the extensible 'R6' class called 'yarn'. These modified 'XML' representations can be written to '(R)Markdown' documents via an 'xslt' stylesheet which implements an extended version of 'GitHub'-flavoured 'markdown' so that you can tinker to your hearts content.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zhian N. Kamvar <a href="mailto:zkamvar@gmail.com">zkamvar@gmail.com</a> (<a href="https://orcid.org/0000-0003-1458-7108">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Maëlle Salmon <a href="mailto:msmaellesalmon@gmail.com">msmaellesalmon@gmail.com</a> (<a href="https://orcid.org/0000-0002-2815-0399">ORCID</a>)
</p>
</li>
<li><p> Jeroen Ooms
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Nick Wellnhofer (Nick Wellnhofer wrote the XSLT stylesheet.) [copyright holder]
</p>
</li>
<li><p> rOpenSci (https://ropensci.org/) [funder]
</p>
</li>
<li><p> Peter Daengeli [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/tinkr/">https://docs.ropensci.org/tinkr/</a>
</p>
</li>
<li> <p><a href="https://github.com/ropensci/tinkr">https://github.com/ropensci/tinkr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/tinkr/issues">https://github.com/ropensci/tinkr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_md'>Add markdown content to an XML object</h2><span id='topic+add_md'></span>

<h3>Description</h3>

<p>Add markdown content to an XML object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_md(body, md, where = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_md_+3A_body">body</code></td>
<td>
<p>an XML object generated via tinkr</p>
</td></tr>
<tr><td><code id="add_md_+3A_md">md</code></td>
<td>
<p>a string of new markdown to insert</p>
</td></tr>
<tr><td><code id="add_md_+3A_where">where</code></td>
<td>
<p>the position in the markdown document to insert the new markdown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a copy of the XML object with the markdown inserted.
</p>

<hr>
<h2 id='find_between'>Find between a pattern</h2><span id='topic+find_between'></span>

<h3>Description</h3>

<p>Helper function to find all nodes between a standard pattern. This is useful
if you want to find unnested pandoc tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_between(
  body,
  ns,
  pattern = "md:paragraph[md:text[starts-with(text(), ':::')]]",
  include = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_between_+3A_body">body</code></td>
<td>
<p>and XML document</p>
</td></tr>
<tr><td><code id="find_between_+3A_ns">ns</code></td>
<td>
<p>the namespace of the document</p>
</td></tr>
<tr><td><code id="find_between_+3A_pattern">pattern</code></td>
<td>
<p>an XPath expression that defines characteristics of nodes
between which you want to extract everything.</p>
</td></tr>
<tr><td><code id="find_between_+3A_include">include</code></td>
<td>
<p>if <code>TRUE</code>, the tags matching <code>pattern</code> will be included in
the output, defaults to <code>FALSE</code>, which only gives you the nodes in between
<code>pattern</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nodeset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>md &lt;- glue::glue("
 h1
 ====

 ::: section

 h2
 ----

 section *text* with [a link](https://ropensci.org/)
 
 :::
")
x &lt;- xml2::read_xml(commonmark::markdown_xml(md))
ns &lt;- xml2::xml_ns_rename(xml2::xml_ns(x), d1 = "md")
res &lt;- find_between(x, ns)
res
xml2::xml_text(res)
xml2::xml_find_all(res, ".//descendant-or-self::md:*", ns = ns)
</code></pre>

<hr>
<h2 id='md_ns'>Aliased namespace prefix for commonmark</h2><span id='topic+md_ns'></span>

<h3>Description</h3>

<p>The commonmark package is used to translate markdown to XML, but it does
not assign a namespace prefix, which means that xml2 will auto-assign a
default prefix of <code>d1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_ns()
</code></pre>


<h3>Details</h3>

<p>This function renames the default prefix to <code>md</code>, so that you can use XPath
queries that are slightly more descriptive.
</p>


<h3>Value</h3>

<p>an <code>xml_namespace</code> object (see <code><a href="xml2.html#topic+xml_ns">xml2::xml_ns()</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tink &lt;- tinkr::to_xml(system.file("extdata", "example1.md", package = "tinkr"))
# with default namespace
xml2::xml_find_all(tink$body, 
  ".//d1:link[starts-with(@destination, 'https://ropensci')]"
)
# with tinkr namespace
xml2::xml_find_all(tink$body, 
  ".//md:link[starts-with(@destination, 'https://ropensci')]",
  tinkr::md_ns()
)

</code></pre>

<hr>
<h2 id='md_to_xml'>Convert markdown to XML</h2><span id='topic+md_to_xml'></span>

<h3>Description</h3>

<p>Convert markdown to XML
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_to_xml(md)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md_to_xml_+3A_md">md</code></td>
<td>
<p>a character vector of markdown text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XML nodeset of the markdown text
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("withr")) {

withr::with_namespace("tinkr", {
md_to_xml(c(
  "## This is a new section of markdown",
  "",
  "Each new element",
  "Is converted to a new line of markdown text",
  "",
  "```{r code-example, echo = FALSE}",
  "cat('code blocks work well here, too')",
  "```",
  "",
  "Neat, right?"
))
})

}
</code></pre>

<hr>
<h2 id='protect_curly'>Protect curly elements for further processing</h2><span id='topic+protect_curly'></span>

<h3>Description</h3>

<p>Protect curly elements for further processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protect_curly(body, ns = md_ns())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protect_curly_+3A_body">body</code></td>
<td>
<p>an XML object</p>
</td></tr>
<tr><td><code id="protect_curly_+3A_ns">ns</code></td>
<td>
<p>an XML namespace object (defaults: <code><a href="#topic+md_ns">md_ns()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Commonmark will render text such as <code>{.unnumbered}</code>
(Pandoc/Quarto option) or
<code style="white-space: pre;">&#8288;{#hello .greeting .message style="color: red;"}&#8288;</code>
(Markdown custom block)
as normal text which might be problematic if trying to extract
real text from the XML.
</p>
<p>If sending the XML to, say, a translation API that allows some tags
to be ignored, you could first transform the text tags with the
attribute <code>curly</code> to <code>curly</code> tags, and then transform them back
to text tags before using <code>to_md()</code>.
</p>


<h3>Value</h3>

<p>a copy of the modified XML object
</p>


<h3>Note</h3>

<p>this function is also a method in the <a href="#topic+yarn">yarn</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- tinkr::to_xml(system.file("extdata", "basic-curly.md", package = "tinkr"))
xml2::xml_child(m$body)
m$body &lt;- protect_curly(m$body)
xml2::xml_child(m$body)
</code></pre>

<hr>
<h2 id='protect_inline_math'>Find and protect all inline math elements</h2><span id='topic+protect_inline_math'></span>

<h3>Description</h3>

<p>Find and protect all inline math elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protect_inline_math(body, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protect_inline_math_+3A_body">body</code></td>
<td>
<p>an XML document</p>
</td></tr>
<tr><td><code id="protect_inline_math_+3A_ns">ns</code></td>
<td>
<p>an XML namespace</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified <em>copy</em> of the original XML document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt &lt;- commonmark::markdown_xml(
  "This sentence contains $I_A$ $\\frac{\\pi}{2}$ inline $\\LaTeX$ math."
)
txt &lt;- xml2::read_xml(txt)
cat(tinkr::to_md(list(body = txt, yaml = "")), sep = "\n")
ns  &lt;- tinkr::md_ns()
if (requireNamespace("withr")) {
protxt &lt;- withr::with_namespace("tinkr", protect_inline_math(txt, ns))
cat(tinkr::to_md(list(body = protxt, yaml = "")), sep = "\n")
}
</code></pre>

<hr>
<h2 id='protect_math'>Protect math elements from commonmark's character escape</h2><span id='topic+protect_math'></span>

<h3>Description</h3>

<p>Protect math elements from commonmark's character escape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protect_math(body, ns = md_ns())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protect_math_+3A_body">body</code></td>
<td>
<p>an XML object</p>
</td></tr>
<tr><td><code id="protect_math_+3A_ns">ns</code></td>
<td>
<p>an XML namespace object (defaults: <code><a href="#topic+md_ns">md_ns()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Commonmark does not know what LaTeX is and will LaTeX equations as
normal text. This means that content surrounded by underscores are
interpreted as <code style="white-space: pre;">&#8288;&lt;emph&gt;&#8288;</code> elements and all backslashes are escaped by default.
This function protects inline and block math elements that use <code>$</code> and <code style="white-space: pre;">&#8288;$$&#8288;</code>
for delimiters, respectively.
</p>


<h3>Value</h3>

<p>a copy of the modified XML object
</p>


<h3>Note</h3>

<p>this function is also a method in the <a href="#topic+yarn">yarn</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- tinkr::to_xml(system.file("extdata", "math-example.md", package = "tinkr"))
txt &lt;- textConnection(tinkr::to_md(m))
cat(tail(readLines(txt)), sep = "\n") # broken math
close(txt)
m$body &lt;- protect_math(m$body)
txt &lt;- textConnection(tinkr::to_md(m))
cat(tail(readLines(txt)), sep = "\n") # fixed math
close(txt)
</code></pre>

<hr>
<h2 id='protect_unescaped'>Protect unescaped square brackets from being escaped</h2><span id='topic+protect_unescaped'></span>

<h3>Description</h3>

<p>Commonmark allows both <code style="white-space: pre;">&#8288;[unescaped]&#8288;</code> and <code style="white-space: pre;">&#8288;\[escaped\]&#8288;</code> square brackets, but
in the XML representation, it makes no note of which square brackets were
originally escaped and thus will escape both in the output. This function
protects brackets that were unescaped in the source document from being
escaped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protect_unescaped(body, txt, ns = md_ns())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protect_unescaped_+3A_body">body</code></td>
<td>
<p>an XML body</p>
</td></tr>
<tr><td><code id="protect_unescaped_+3A_txt">txt</code></td>
<td>
<p>the text of a source file</p>
</td></tr>
<tr><td><code id="protect_unescaped_+3A_ns">ns</code></td>
<td>
<p>an the namespace that resolves the Markdown namespace (defaults to
<code><a href="#topic+md_ns">md_ns()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an <strong>internal function</strong> that is run by default via <code>to_xml()</code> and
<code>yarn$new()</code>. It uses the original document, parsed as text, to find and
protect unescaped square brackets from being escaped in the output.
</p>


<h4>Example: child documents and footnotes</h4>

<p>For example, let's say you have two R Markdown documents, one references the
other as a child, which has a <a href="https://spec.commonmark.org/0.30/#reference-link">reference-style link</a>:
</p>
<p>index.Rmd:
</p>
<div class="sourceCode markdown"><pre>## Title

Without protection reference style links (e.g. \[text\]\[link\]) like this
[outside link][reflink] would be accidentally escaped.
This is a footnote [^1].

[^1]: footnotes are not recognised by commonmark

```{r, child="child.Rmd"}
```
</pre></div>
<p>child.Rmd:
</p>
<div class="sourceCode markdown"><pre>...
[reflink]: https://example.com
</pre></div>
<p>Without protection, the roundtripped index.Rmd document would look like this:
</p>
<div class="sourceCode markdown"><pre>## Title

Without protection reference style links (e.g. \[text\]\[link\]) like this
\[outside link\]\[reflink\] would be accidentally escaped.
This is a footnote \[^1\]

\[^1\]: footnotes are not recognised by commonmark

```{r, child="child.Rmd"}
```
</pre></div>
<p>This function provides the protection that allows these unescaped brackets to
remain unescaped during roundtrip.
</p>



<h3>Note</h3>

<p>Because the This <code>body</code> to be an XML document with <code>sourcepos</code> attributes on the
nodes, which is achieved by using <code>sourcepos = TRUE</code> with <code><a href="#topic+to_xml">to_xml()</a></code> or
<a href="#topic+yarn">yarn</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "link-test.md", package = "tinkr")
md &lt;- yarn$new(f, sourcepos = TRUE, unescaped = FALSE)
md$show()
if (requireNamespace("withr")) {
lines &lt;- readLines(f)[-length(md$yaml)]
lnks &lt;- withr::with_namespace("tinkr", 
  protect_unescaped(body = md$body, txt = lines))
md$body &lt;- lnks
md$show()
}
</code></pre>

<hr>
<h2 id='resolve_anchor_links'>Resolve Reference-Style Links</h2><span id='topic+resolve_anchor_links'></span>

<h3>Description</h3>

<p><a href="https://www.markdownguide.org/basic-syntax/#reference-style-links">Reference style links and images</a>
are a form of markdown syntax that reduces duplication and makes markdown
more readable. They come in two parts:
</p>

<ol>
<li><p> The inline part that uses two pairs of square brackets where the second
pair of square brackets contains the reference for the anchor part of the
link. Example:
</p>
<div class="sourceCode"><pre>[inline text describing link][link-reference]
</pre></div>
</li>
<li><p> The anchor part, which can be anywhere in the document, contains a pair
of square brackets followed by a colon and space with the link and
optionally the link title. Example:
</p>
<div class="sourceCode"><pre>[link-reference]: https://docs.ropensci.org/tinkr/ 'documentation for tinkr'
</pre></div>
</li></ol>

<p>Commonmark treats reference-style links as regular links, which can be a
pain when converting large documents. This function resolves these
links by reading in the source document, finding the reference-style links,
and adding them back at the end of the document with the 'anchor' attribute
and appending the reference to the link with the 'ref' attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_anchor_links(body, txt, ns = md_ns())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_anchor_links_+3A_body">body</code></td>
<td>
<p>an XML body</p>
</td></tr>
<tr><td><code id="resolve_anchor_links_+3A_txt">txt</code></td>
<td>
<p>the text of a source file</p>
</td></tr>
<tr><td><code id="resolve_anchor_links_+3A_ns">ns</code></td>
<td>
<p>an the namespace that resolves the Markdown namespace (defaults to
<code><a href="#topic+md_ns">md_ns()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Nomenclature</h4>

<p>The reference-style link contains two parts, but they don't have common names
(the <a href="https://www.markdownguide.org/basic-syntax/">markdown guide</a> calls
these &quot;first part and second part&quot;), so in this documentation, we call the
link pattern of <code style="white-space: pre;">&#8288;[link text][link-ref]&#8288;</code> as the &quot;inline reference-style link&quot;
and the pattern of <code style="white-space: pre;">&#8288;[link-ref]: &lt;URL&gt;&#8288;</code> as the &quot;anchor references-style link&quot;.
</p>



<h4>Reference-style links in commonmark's XML representation</h4>

<p>A link or image in XML is represented by a node with the following attributes
</p>

<ul>
<li><p> destination: the URL for the link
</p>
</li>
<li><p> title: an optional title for the link
</p>
</li></ul>

<p>For example, this markdown link <code style="white-space: pre;">&#8288;[link text](https://example.com "example  link")&#8288;</code> is represented in XML as text inside of a link node:
</p>
<div class="sourceCode r"><pre>lnk &lt;- "[link text](https://example.com 'example link')"
xml &lt;- xml2::read_xml(commonmark::markdown_xml(lnk))
cat(as.character(xml2::xml_find_first(xml, ".//d1:link")))
#&gt; &lt;link destination="https://example.com" title="example link"&gt;
#&gt;   &lt;text xml:space="preserve"&gt;link text&lt;/text&gt;
#&gt; &lt;/link&gt;
</pre></div>
<p>However, reference-style links are rendered equivalently:
</p>
<div class="sourceCode r"><pre>lnk &lt;- "
[link text][link-ref]

[link-ref]: https://example.com 'example link'
"
xml &lt;- xml2::read_xml(commonmark::markdown_xml(lnk))
cat(as.character(xml2::xml_find_first(xml, ".//d1:link")))
#&gt; &lt;link destination="https://example.com" title="example link"&gt;
#&gt;   &lt;text xml:space="preserve"&gt;link text&lt;/text&gt;
#&gt; &lt;/link&gt;
</pre></div>



<h4>XML attributes of reference-style links</h4>

<p>To preserve the anchor reference-style links, we search the source document
for the destination attribute proceded by <code style="white-space: pre;">&#8288;]: &#8288;</code>, transform that information
into a new link node with the <code>anchor</code> attribute, and add it to the end of
the document. That node looks like this:
</p>
<div class="sourceCode"><pre>&lt;link destination="https://example.com" title="example link" anchor="true"&gt;
  &lt;text&gt;link-ref&lt;/text&gt;
&lt;/link&gt;
</pre></div>
<p>From there, we add the anchor text to the node that is present in our
document as the <code>ref</code> attribute:
</p>
<div class="sourceCode"><pre>&lt;link destination="https://example.com" title="example link" rel="link-ref"&gt;
  &lt;text xml:space="preserve"&gt;link text&lt;/text&gt;
&lt;/link&gt;
</pre></div>



<h3>Note</h3>

<p>this function is internally used in the function <code><a href="#topic+to_xml">to_xml()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "link-test.md", package = "tinkr")
md &lt;- yarn$new(f, sourcepos = TRUE, anchor_links = FALSE)
md$show()
if (requireNamespace("withr")) {
lnks &lt;- withr::with_namespace("tinkr", 
  resolve_anchor_links(md$body, readLines(md$path)))
md$body &lt;- lnks
md$show()
}
</code></pre>

<hr>
<h2 id='stylesheet'>The tinkr stylesheet</h2><span id='topic+stylesheet'></span>

<h3>Description</h3>

<p>This function returns the path to the tinkr stylesheet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stylesheet()
</code></pre>


<h3>Value</h3>

<p>a single element character vector representing the path to the
stylesheet used by tinkr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tinkr::stylesheet()
</code></pre>

<hr>
<h2 id='to_md'>Write YAML and XML back to disk as (R)Markdown</h2><span id='topic+to_md'></span>

<h3>Description</h3>

<p>Write YAML and XML back to disk as (R)Markdown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_md(yaml_xml_list, path = NULL, stylesheet_path = stylesheet())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_md_+3A_yaml_xml_list">yaml_xml_list</code></td>
<td>
<p>result from a call to <code><a href="#topic+to_xml">to_xml()</a></code> and editing.</p>
</td></tr>
<tr><td><code id="to_md_+3A_path">path</code></td>
<td>
<p>path of the new file. Defaults to <code>NULL</code>, which will not write
any file, but will still produce the conversion and pass the output as
a character vector.</p>
</td></tr>
<tr><td><code id="to_md_+3A_stylesheet_path">stylesheet_path</code></td>
<td>
<p>path to the XSL stylesheet</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stylesheet you use will decide whether lists
are built using &quot;*&quot; or &quot;-&quot; for instance. If you're keen to
keep your own Markdown style when using <code><a href="#topic+to_md">to_md()</a></code> after
<code><a href="#topic+to_xml">to_xml()</a></code>, you can tweak the XSL stylesheet a bit and provide
the path to your XSL stylesheet as argument.
</p>


<h3>Value</h3>

<p>the converted document, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "example1.md", package = "tinkr")
yaml_xml_list &lt;- to_xml(path)
names(yaml_xml_list)
library("magrittr")
# transform level 3 headers into level 1 headers
body &lt;- yaml_xml_list$body
body %&gt;%
  xml2::xml_find_all(xpath = './/d1:heading',
                     xml2::xml_ns(.)) %&gt;%
  .[xml2::xml_attr(., "level") == "3"] -&gt; headers3
xml2::xml_set_attr(headers3, "level", 1)
yaml_xml_list$body &lt;- body
# save back and have a look
newmd &lt;- tempfile("newmd", fileext = ".md")
to_md(yaml_xml_list, newmd)
# file.edit("newmd.md")
file.remove(newmd)

</code></pre>

<hr>
<h2 id='to_xml'>Transform file to XML</h2><span id='topic+to_xml'></span>

<h3>Description</h3>

<p>Transform file to XML
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_xml(
  path,
  encoding = "UTF-8",
  sourcepos = FALSE,
  anchor_links = TRUE,
  unescaped = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_xml_+3A_path">path</code></td>
<td>
<p>Path to the file.</p>
</td></tr>
<tr><td><code id="to_xml_+3A_encoding">encoding</code></td>
<td>
<p>Encoding to be used by readLines.</p>
</td></tr>
<tr><td><code id="to_xml_+3A_sourcepos">sourcepos</code></td>
<td>
<p>passed to <code><a href="commonmark.html#topic+commonmark">commonmark::markdown_xml()</a></code>. If <code>TRUE</code>, the
source position of the file will be included as a &quot;sourcepos&quot; attribute.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="to_xml_+3A_anchor_links">anchor_links</code></td>
<td>
<p>if <code>TRUE</code> (default), reference-style links with anchors
(in the style of <code style="white-space: pre;">&#8288;[key]: https://example.com/link "title"&#8288;</code>) will be
preserved as best as possible. If this is <code>FALSE</code>, the anchors disappear
and the links will appear as normal links. See <code><a href="#topic+resolve_anchor_links">resolve_anchor_links()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="to_xml_+3A_unescaped">unescaped</code></td>
<td>
<p>if <code>TRUE</code> (default) AND <code>sourcepos = TRUE</code>, square braces
that were unescaped in the original document will be preserved as best as
possible. If this is <code>FALSE</code>, these braces will be escaped in the output
document. See <code><a href="#topic+protect_unescaped">protect_unescaped()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will take a (R)markdown file, split the yaml header
from the body, and read in the body through <code><a href="commonmark.html#topic+commonmark">commonmark::markdown_xml()</a></code>.
Any RMarkdown code fences will be parsed to expose the chunk options in
XML and tickboxes (aka checkboxes) in GitHub-flavored markdown will be
preserved (both modifications from the commonmark standard).
</p>


<h3>Value</h3>

<p>A list containing the YAML of the file (yaml)
and its body (body) as XML.
</p>


<h3>Note</h3>

<p>Math elements are not protected by default. You can use <code><a href="#topic+protect_math">protect_math()</a></code> to
address this if needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "example1.md", package = "tinkr")
post_list &lt;- to_xml(path)
names(post_list)
path2 &lt;- system.file("extdata", "example2.Rmd", package = "tinkr")
post_list2 &lt;- to_xml(path2)
post_list2
</code></pre>

<hr>
<h2 id='yarn'>R6 class containing XML representation of Markdown</h2><span id='topic+yarn'></span>

<h3>Description</h3>

<p>Wrapper around an XML representation of a Markdown document. It contains four
publicly accessible slots: path, yaml, body, and ns.
</p>


<h3>Details</h3>

<p>This class is a fancy wrapper around the results of <code><a href="#topic+to_xml">to_xml()</a></code> and
has methods that make it easier to add, analyze, remove, or write elements
of your markdown document.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>path</code></dt><dd><p>[<code>character</code>] path to file on disk</p>
</dd>
<dt><code>yaml</code></dt><dd><p>[<code>character</code>] text block at head of file</p>
</dd>
<dt><code>body</code></dt><dd><p>[<code>xml_document</code>] an xml document of the (R)Markdown file.</p>
</dd>
<dt><code>ns</code></dt><dd><p>[<code>xml_document</code>] an xml namespace object defining &quot;md&quot; to
commonmark.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-yarn-new"><code>yarn$new()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-reset"><code>yarn$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-write"><code>yarn$write()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-show"><code>yarn$show()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-head"><code>yarn$head()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-tail"><code>yarn$tail()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-add_md"><code>yarn$add_md()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-protect_math"><code>yarn$protect_math()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-protect_curly"><code>yarn$protect_curly()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-protect_unescaped"><code>yarn$protect_unescaped()</code></a>
</p>
</li>
<li> <p><a href="#method-yarn-clone"><code>yarn$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-yarn-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new yarn document
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$new(path = NULL, encoding = "UTF-8", sourcepos = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>[<code>character</code>] path to a markdown episode file on disk</p>
</dd>
<dt><code>encoding</code></dt><dd><p>[<code>character</code>] encoding passed to <code><a href="base.html#topic+readLines">readLines()</a></code></p>
</dd>
<dt><code>sourcepos</code></dt><dd><p>passed to <code><a href="commonmark.html#topic+commonmark">commonmark::markdown_xml()</a></code>. If <code>TRUE</code>, the
source position of the file will be included as a &quot;sourcepos&quot; attribute.
Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>arguments passed on to <code><a href="#topic+to_xml">to_xml()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new yarn object containing an XML representation of a
(R)Markdown file.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>path &lt;- system.file("extdata", "example1.md", package = "tinkr")
ex1 &lt;- tinkr::yarn$new(path)
ex1
path2 &lt;- system.file("extdata", "example2.Rmd", package = "tinkr")
ex2 &lt;- tinkr::yarn$new(path2)
ex2
</pre>
</div>


<hr>
<a id="method-yarn-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>reset a yarn document from the original file
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$reset()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>
path &lt;- system.file("extdata", "example1.md", package = "tinkr")
ex1 &lt;- tinkr::yarn$new(path)
# OH NO
ex1$body
ex1$body &lt;- xml2::xml_missing()
ex1$reset()
ex1$body
</pre>
</div>


<hr>
<a id="method-yarn-write"></a>



<h4>Method <code>write()</code></h4>

<p>Write a yarn document to Markdown/R Markdown
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$write(path = NULL, stylesheet_path = stylesheet())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>path to the file you want to write</p>
</dd>
<dt><code>stylesheet_path</code></dt><dd><p>path to the xsl stylesheet to convert XML to markdown.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>path &lt;- system.file("extdata", "example1.md", package = "tinkr")
ex1 &lt;- tinkr::yarn$new(path)
ex1
tmp &lt;- tempfile()
try(readLines(tmp)) # nothing in the file
ex1$write(tmp)
head(readLines(tmp)) # now a markdown file
unlink(tmp)
</pre>
</div>


<hr>
<a id="method-yarn-show"></a>



<h4>Method <code>show()</code></h4>

<p>show the markdown contents on the screen
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$show(stylesheet_path = stylesheet())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stylesheet_path</code></dt><dd><p>path to the xsl stylesheet to convert XML to markdown.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a character vector with one line for each line in the output
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>path &lt;- system.file("extdata", "example2.Rmd", package = "tinkr")
ex2 &lt;- tinkr::yarn$new(path)
ex2$head(5)
ex2$tail(5)
ex2$show()
</pre>
</div>


<hr>
<a id="method-yarn-head"></a>



<h4>Method <code>head()</code></h4>

<p>show the head of the markdown contents on the screen
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$head(n = 6L, stylesheet_path = stylesheet())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>the number of elements to show from the top. Negative numbers</p>
</dd>
<dt><code>stylesheet_path</code></dt><dd><p>path to the xsl stylesheet to convert XML to markdown.
exclude lines from the bottom</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a character vector with <code>n</code> elements
</p>


<hr>
<a id="method-yarn-tail"></a>



<h4>Method <code>tail()</code></h4>

<p>show the tail of the markdown contents on the screen
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$tail(n = 6L, stylesheet_path = stylesheet())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>the number of elements to show from the bottom. Negative numbers</p>
</dd>
<dt><code>stylesheet_path</code></dt><dd><p>path to the xsl stylesheet to convert XML to markdown.
exclude lines from the top</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a character vector with <code>n</code> elements
</p>


<hr>
<a id="method-yarn-add_md"></a>



<h4>Method <code>add_md()</code></h4>

<p>add an arbitrary Markdown element to the document
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$add_md(md, where = 0L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>md</code></dt><dd><p>a string of markdown formatted text.</p>
</dd>
<dt><code>where</code></dt><dd><p>the location in the document to add your markdown text.
This is passed on to <code><a href="xml2.html#topic+xml_replace">xml2::xml_add_child()</a></code>. Defaults to 0, which
indicates the very top of the document.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>path &lt;- system.file("extdata", "example2.Rmd", package = "tinkr")
ex &lt;- tinkr::yarn$new(path)
# two headings, no lists
xml2::xml_find_all(ex$body, "md:heading", ex$ns)
xml2::xml_find_all(ex$body, "md:list", ex$ns)
ex$add_md(
  "# Hello\n\nThis is *new* formatted text from `{tinkr}`!",
  where = 1L
)$add_md(
  " - This\n - is\n - a new list",
  where = 2L
)
# three headings
xml2::xml_find_all(ex$body, "md:heading", ex$ns)
xml2::xml_find_all(ex$body, "md:list", ex$ns)
tmp &lt;- tempfile()
ex$write(tmp)
readLines(tmp, n = 20)
</pre>
</div>


<hr>
<a id="method-yarn-protect_math"></a>



<h4>Method <code>protect_math()</code></h4>

<p>Protect math blocks from being escaped
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$protect_math()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>path &lt;- system.file("extdata", "math-example.md", package = "tinkr")
ex &lt;- tinkr::yarn$new(path)
ex$tail() # math blocks are escaped :(
ex$protect_math()$tail() # math blocks are no longer escaped :)
</pre>
</div>


<hr>
<a id="method-yarn-protect_curly"></a>



<h4>Method <code>protect_curly()</code></h4>

<p>Protect curly phrases <code>{likethat}</code> from being escaped
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$protect_curly()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>path &lt;- system.file("extdata", "basic-curly.md", package = "tinkr")
ex &lt;- tinkr::yarn$new(path)
ex$protect_curly()$head()
</pre>
</div>


<hr>
<a id="method-yarn-protect_unescaped"></a>



<h4>Method <code>protect_unescaped()</code></h4>

<p>Protect unescaped square braces from being escaped.
</p>
<p>This is applied by default when you use <code>yarn$new(sourcepos = TRUE)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$protect_unescaped()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>path &lt;- system.file("extdata", "basic-curly.md", package = "tinkr")
ex &lt;- tinkr::yarn$new(path, sourcepos = TRUE, unescaped = FALSE)
ex$tail()
ex$protect_unescaped()$tail()
</pre>
</div>


<hr>
<a id="method-yarn-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>yarn$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>this requires the <code>sourcepos</code> attribute to be recorded when the
object is initialised. See <code><a href="#topic+protect_unescaped">protect_unescaped()</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `yarn$new`
## ------------------------------------------------

path &lt;- system.file("extdata", "example1.md", package = "tinkr")
ex1 &lt;- tinkr::yarn$new(path)
ex1
path2 &lt;- system.file("extdata", "example2.Rmd", package = "tinkr")
ex2 &lt;- tinkr::yarn$new(path2)
ex2

## ------------------------------------------------
## Method `yarn$reset`
## ------------------------------------------------


path &lt;- system.file("extdata", "example1.md", package = "tinkr")
ex1 &lt;- tinkr::yarn$new(path)
# OH NO
ex1$body
ex1$body &lt;- xml2::xml_missing()
ex1$reset()
ex1$body

## ------------------------------------------------
## Method `yarn$write`
## ------------------------------------------------

path &lt;- system.file("extdata", "example1.md", package = "tinkr")
ex1 &lt;- tinkr::yarn$new(path)
ex1
tmp &lt;- tempfile()
try(readLines(tmp)) # nothing in the file
ex1$write(tmp)
head(readLines(tmp)) # now a markdown file
unlink(tmp)

## ------------------------------------------------
## Method `yarn$show`
## ------------------------------------------------

path &lt;- system.file("extdata", "example2.Rmd", package = "tinkr")
ex2 &lt;- tinkr::yarn$new(path)
ex2$head(5)
ex2$tail(5)
ex2$show()

## ------------------------------------------------
## Method `yarn$add_md`
## ------------------------------------------------

path &lt;- system.file("extdata", "example2.Rmd", package = "tinkr")
ex &lt;- tinkr::yarn$new(path)
# two headings, no lists
xml2::xml_find_all(ex$body, "md:heading", ex$ns)
xml2::xml_find_all(ex$body, "md:list", ex$ns)
ex$add_md(
  "# Hello\n\nThis is *new* formatted text from `{tinkr}`!",
  where = 1L
)$add_md(
  " - This\n - is\n - a new list",
  where = 2L
)
# three headings
xml2::xml_find_all(ex$body, "md:heading", ex$ns)
xml2::xml_find_all(ex$body, "md:list", ex$ns)
tmp &lt;- tempfile()
ex$write(tmp)
readLines(tmp, n = 20)

## ------------------------------------------------
## Method `yarn$protect_math`
## ------------------------------------------------

path &lt;- system.file("extdata", "math-example.md", package = "tinkr")
ex &lt;- tinkr::yarn$new(path)
ex$tail() # math blocks are escaped :(
ex$protect_math()$tail() # math blocks are no longer escaped :)

## ------------------------------------------------
## Method `yarn$protect_curly`
## ------------------------------------------------

path &lt;- system.file("extdata", "basic-curly.md", package = "tinkr")
ex &lt;- tinkr::yarn$new(path)
ex$protect_curly()$head()

## ------------------------------------------------
## Method `yarn$protect_unescaped`
## ------------------------------------------------

path &lt;- system.file("extdata", "basic-curly.md", package = "tinkr")
ex &lt;- tinkr::yarn$new(path, sourcepos = TRUE, unescaped = FALSE)
ex$tail()
ex$protect_unescaped()$tail()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
