<!DOCTYPE html><html><head><title>Help for package ResourceSelection</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ResourceSelection}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ResourceSelection-package'>
<p>Resource Selection (Probability) Functions for Use-Availability Data</p></a></li>
<li><a href='#CAIC'>
<p>Consistent AIC</p></a></li>
<li><a href='#goats'>
<p>Mountain Goats Data Set</p></a></li>
<li><a href='#hoslem.test'>
<p>Hosmer-Lemeshow Goodness of Fit (GOF) Test</p></a></li>
<li><a href='#kdepairs'>
<p>Scatterplot Matrix with 2D Kernel Density</p></a></li>
<li><a href='#makeUsedAvail'>
<p>Make a Used-Available Data Frame</p></a></li>
<li><a href='#mep'>
<p>Marginal Effect Plots</p></a></li>
<li><a href='#rsf'>
<p>Resource Selection (Probability) Functions for Use-Availability Data</p></a></li>
<li><a href='#simulateUsedAvail'>
<p>Simulate Used-Available Data</p></a></li>
<li><a href='#sindex'>
<p>Weighted relative suitability index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Resource Selection (Probability) Functions for Use-Availability
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Solymos &lt;psolymos@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Resource Selection (Probability) Functions
  for use-availability wildlife data
  based on weighted distributions as described in
  Lele and Keim (2006) &lt;<a href="https://doi.org/10.1890/0012-9658(2006)87%5B3021:WDAEOR%5D2.0.CO;2">doi:10.1890/0012-9658(2006)87%5B3021:WDAEOR%5D2.0.CO;2</a>&gt;,
  Lele (2009) &lt;<a href="https://doi.org/10.2193%2F2007-535">doi:10.2193/2007-535</a>&gt;,
  and Solymos &amp; Lele (2016) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12432">doi:10.1111/2041-210X.12432</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, pbapply, Matrix</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/psolymos/ResourceSelection">https://github.com/psolymos/ResourceSelection</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/psolymos/ResourceSelection/issues">https://github.com/psolymos/ResourceSelection/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-27 20:35:28 UTC; Peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Subhash R. Lele [aut],
  Jonah L. Keim [aut],
  Peter Solymos <a href="https://orcid.org/0000-0001-7337-1740"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-08 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ResourceSelection-package'>
Resource Selection (Probability) Functions for Use-Availability Data
</h2><span id='topic+ResourceSelection-package'></span><span id='topic+ResourceSelection'></span>

<h3>Description</h3>

<p>Resource Selection (Probability) Functions
for use-availability wildlife data
based on weighted distributions as described in
Lele and Keim (2006), Lele (2009), and Solymos &amp; Lele (2016).
</p>


<h3>Details</h3>

<p><code><a href="#topic+rsf">rsf</a></code>: Resource Selection Functions (RSF)
</p>
<p><code><a href="#topic+rspf">rspf</a></code>: Resource Selection Probability Functions (RSPF)
</p>
<p><code><a href="#topic+hoslem.test">hoslem.test</a></code>: Hosmer-Lemeshow Goodness of Fit (GOF) Test
</p>
<p>Visual summaries: <code><a href="#topic+kdepairs">kdepairs</a></code> for 2D scatterplots and
<code><a href="#topic+mep">mep</a></code> for marginal effect plots based on fitted model objects.
</p>


<h3>Author(s)</h3>

<p>Subhash R. Lele, Jonah L. Keim, Peter Solymos
</p>
<p>Maintainer: Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>References</h3>

<p>Lele, S.R. (2009)
A new method for estimation of resource selection probability function.
Journal of Wildlife Management 73, 122&ndash;127.
&lt;doi:10.2193/2007-535&gt;
</p>
<p>Lele, S. R. &amp;  Keim, J. L. (2006)
Weighted distributions and estimation of resource selection probability function.
Ecology 87, 3021&ndash;3028.
&lt;doi:10.1890/0012-9658(2006)87
</p>
<p>Solymos, P. &amp; Lele, S. R. (2016)
Revisiting resource selection probability functions and single-visit methods:
clarification and extensions.
Methods in Ecology and Evolution 7, 196&ndash;205.
&lt;doi:10.1111/2041-210X.12432&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsf">rsf</a></code>, <code><a href="#topic+rspf">rspf</a></code>, <code><a href="#topic+kdepairs">kdepairs</a></code>, <code><a href="#topic+mep">mep</a></code>,
<code><a href="#topic+hoslem.test">hoslem.test</a></code>
</p>

<hr>
<h2 id='CAIC'>
Consistent AIC
</h2><span id='topic+CAIC'></span><span id='topic+CAICtable'></span><span id='topic+CAIC.default'></span>

<h3>Description</h3>

<p>Consistent AIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAIC(object, ..., alpha)
## Default S3 method:
CAIC(object, ..., alpha)
CAICtable(object, ..., alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAIC_+3A_object">object</code></td>
<td>

<p>A fitted model object.
</p>
</td></tr>
<tr><td><code id="CAIC_+3A_...">...</code></td>
<td>

<p>More fitted model objects.
</p>
</td></tr>
<tr><td><code id="CAIC_+3A_alpha">alpha</code></td>
<td>

<p>Weight factor between 0 and 1 (see Details).
Default value is 0.5.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CAIC = alpha * AIC + (1 - alpha) * BIC
</p>


<h3>Value</h3>

<p>Atomic vector if only one input object provided,
a data frame similar to what is returned by
<code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>
if there are more than one input objects.
</p>
<p><code>CAICtable</code> returns a data frame with
delta CAIC (dCAIC = CAIC - min(CAIC)) and CAIC
weights (wCAIC = exp(-0.5 dCAIC_i) / sum(exp(-0.5 dCAIC_i)))
where i = 1,...,m are candidate models.
</p>


<h3>Author(s)</h3>

<p>Subhash Lele and Peter Solymos
</p>


<h3>References</h3>

<p>Bozdogan, H. 1987.
Model selection and Akaike's information criterion (AIC):
the general theory and its analytical extensions.
Psychometrika, 52, 345-370.
</p>
<p>Taper, M. 2004. Model identification from many candidates.
In: Taper, M. and Lele, S. R. (eds),
The Nature of Scientific Evidence: Statistical, Philosophical,
and Empirical Considerations.
The University of Chicago Press, Chicago, IL, 567 pp.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compare some random models
y &lt;- rnorm(10)
a &lt;- lm(y ~ runif(10))
b &lt;- lm(y ~ runif(10))

0.5*(AIC(a) + BIC(a))
CAIC(a)
AIC(a)
CAIC(a, alpha=1)
BIC(a)
CAIC(a, alpha=0)

CAIC(a, b)
CAIC(a, b, alpha=0.2)

CAICtable(a, b, alpha=1)

## you can use global option
## useful when inside of xv or bootstrap
## no need for extra argument
getOption("CAIC_alpha")
op &lt;- options(CAIC_alpha = 0.2)
getOption("CAIC_alpha")
CAIC(a,b)
options(op)
getOption("CAIC_alpha")
</code></pre>

<hr>
<h2 id='goats'>
Mountain Goats Data Set
</h2><span id='topic+goats'></span>

<h3>Description</h3>

<p>GPS collar data of mountain goats (<em>Oreamnos americanus</em>) from Lele and Keim (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(goats)</code></pre>


<h3>Format</h3>

<p>A data frame with 19014 observations on the following 8 variables.
</p>

<dl>
<dt><code>STATUS</code></dt><dd><p>a numeric vector, 1: used, 0: available</p>
</dd>
<dt><code>ID</code></dt><dd><p>a numeric vector, individuals</p>
</dd>
<dt><code>ELEVATION</code></dt><dd><p>a numeric vector (m)</p>
</dd>
<dt><code>SLOPE</code></dt><dd><p>a numeric vector (degrees, steep)</p>
</dd>
<dt><code>ET</code></dt><dd><p>a numeric vector, access to escape terrain (distance from steep slopes, m)</p>
</dd>
<dt><code>ASPECT</code></dt><dd><p>a numeric vector (degrees)</p>
</dd>
<dt><code>HLI</code></dt><dd><p>a numeric vector, heat load index (0-1)</p>
</dd>
<dt><code>TASP</code></dt><dd><p>a numeric vector, transformed aspect</p>
</dd>
</dl>



<h3>Details</h3>

<p>Mountain goat telemetry data were collected in the
Coast Mountains of northwest British Columbia, Canada,
as described in Lele and Keim (2006).
</p>


<h3>Source</h3>

<p>Ecological Archives E087-181-S1, <a href="http://www.esapubs.org/archive/ecol/E087/181/">http://www.esapubs.org/archive/ecol/E087/181/</a>
</p>


<h3>References</h3>

<p>Lele, S. R. &amp;  Keim, J. L. (2006) 
Weighted distributions and estimation of resource selection probability functions. 
Ecology 87, 3021&ndash;3028.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(goats)
str(goats)
summary(goats)

## Not run: 
goats$exp.HLI &lt;- exp(goats$HLI)
goats$sin.SLOPE &lt;- sin(pi * goats$SLOPE / 180)
goats$ELEVATION &lt;- scale(goats$ELEVATION)
goats$ET &lt;- scale(goats$ET)
goats$TASP &lt;- scale(goats$TASP)
m1 &lt;- rspf(STATUS ~ TASP + sin.SLOPE + ELEVATION, goats, m=0, B = 99)
m2 &lt;- rspf(STATUS ~ TASP + ELEVATION, goats, m=0, B = 99)
summary(m1)
summary(m2)
AIC(m1, m2)
plot(m1)

## End(Not run)
</code></pre>

<hr>
<h2 id='hoslem.test'>
Hosmer-Lemeshow Goodness of Fit (GOF) Test
</h2><span id='topic+hoslem.test'></span>

<h3>Description</h3>

<p>Hosmer-Lemeshow Goodness of Fit (GOF) Test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hoslem.test(x, y, g = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hoslem.test_+3A_x">x</code></td>
<td>

<p>a numeric vector of observations, binary (0/1).
</p>
</td></tr>
<tr><td><code id="hoslem.test_+3A_y">y</code></td>
<td>

<p>expected values.
</p>
</td></tr>
<tr><td><code id="hoslem.test_+3A_g">g</code></td>
<td>

<p>number of bins to use to calculate quantiles.
Needs to be at least 2. The degrees of freedom of the test is <code>g-2</code>
but the number of bins might also depend on the data (i.e. due to identical
quantile values that lead to empty bins). In case when the number of bins 
does not equal <code>g</code>, the degrees of freedom will depend on the
number of bins that is less than <code>g</code>. In such case a warning is produced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hosmer-Lemeshow test is a statistical test for goodness of fit for 
logistic regression models.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components: 
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the chi-squared test statistic,
(<code>sum((observed - expected)^2 / expected)</code>).</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom of the approximate 
chi-squared distribution of the test statistic (<code>g - 2</code>).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>the observed frequencies in a <code>g</code>-by-2 
contingency table.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>the expected frequencies in a <code>g</code>-by-2 
contingency table.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Solymos by adapting code pieces from R help mailing list
</p>


<h3>References</h3>

<p>Hosmer D W, Lemeshow S 2000. 
Applied Logistic Regression. 
New York, USA: John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 500
x &lt;- rnorm(n)
y &lt;- rbinom(n, 1, plogis(0.1 + 0.5*x))
m &lt;- glm(y ~ x, family=binomial)
hoslem.test(m$y, fitted(m))
</code></pre>

<hr>
<h2 id='kdepairs'>
Scatterplot Matrix with 2D Kernel Density
</h2><span id='topic+kdepairs'></span><span id='topic+kdepairs.default'></span><span id='topic+kdepairs.rsf'></span>

<h3>Description</h3>

<p>Scatterplot matrix with 2D kernel density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdepairs(x, ...)

## Default S3 method:
kdepairs(x, n=25, density=TRUE, contour=TRUE, ...)

## S3 method for class 'rsf'
kdepairs(x, n=25, density=TRUE, contour=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdepairs_+3A_x">x</code></td>
<td>

<p>a matrix or data frame (or a fitted model object of class <code>"rsf"</code>
or <code>"rspf"</code>).
</p>
</td></tr>
<tr><td><code id="kdepairs_+3A_n">n</code></td>
<td>

<p>number of bins to be used in kernel density estimation.
</p>
</td></tr>
<tr><td><code id="kdepairs_+3A_density">density</code></td>
<td>

<p>logical, if shades corresponding to densities should be plotted.
</p>
</td></tr>
<tr><td><code id="kdepairs_+3A_contour">contour</code></td>
<td>

<p>logical, if contour on top of shades should be plotted.
</p>
</td></tr>
<tr><td><code id="kdepairs_+3A_...">...</code></td>
<td>

<p>other possible arguments passed to <code><a href="graphics.html#topic+pairs">pairs</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a scatterplot matrix with histograms in diagonal, 2D kernel 
density estimates and contours in the lower half and bivariate scatterplots
with lowess smooth curves and Pearson correlation values 
in the upper half as a side effect.
Returns <code>NULL</code> invisibly.</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="stats.html#topic+lowess">lowess</a></code>, <code><a href="MASS.html#topic+kde2d">kde2d</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kdepairs(iris[1:4])
</code></pre>

<hr>
<h2 id='makeUsedAvail'>
Make a Used-Available Data Frame
</h2><span id='topic+makeUsedAvail'></span><span id='topic+makeUsedAvail.default'></span><span id='topic+makeUsedAvail.formula'></span>

<h3>Description</h3>

<p>Make a used-available data frame from a presence-absence type data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeUsedAvail(x, ...)

## Default S3 method:
makeUsedAvail(x, y, ...)

## S3 method for class 'formula'
makeUsedAvail(formula, data = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeUsedAvail_+3A_x">x</code></td>
<td>

<p>a matrix or data frame.
</p>
</td></tr>
<tr><td><code id="makeUsedAvail_+3A_y">y</code></td>
<td>

<p>a vector with 0/1 entries, 1s are taken as used observations.
</p>
</td></tr>
<tr><td><code id="makeUsedAvail_+3A_formula">formula</code></td>
<td>

<p>two sided model formula of the form <code>y ~ x</code>.
</p>
</td></tr>
<tr><td><code id="makeUsedAvail_+3A_data">data</code></td>
<td>

<p>data.
</p>
</td></tr>
<tr><td><code id="makeUsedAvail_+3A_...">...</code></td>
<td>

<p>other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data frame, where used and available portions of
the input data are bound on top of each other, the first column
refers to <code>y</code>, where used (1) and available (0) locations are
indicated different from the input values.
All locations in the input data are treated as available (0),
while only nonzero observations in <code>y</code> are treated as used (1).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- data.frame(species=rep(1:0,each=4), var1=1:8, var2=11:18))
makeUsedAvail(species ~ var1 + var2, x)
</code></pre>

<hr>
<h2 id='mep'>
Marginal Effect Plots
</h2><span id='topic+mep'></span><span id='topic+mep.default'></span>

<h3>Description</h3>

<p>Scatterplot of marginal effects based on fitted model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mep(object, ...)

## Default S3 method:
mep(object, which=NULL, link=NULL,
    level=0.95, unique=10, n=25, minbucket=5, digits=4,
    col.points, col.lines=c(2, 2), pch=19, lty=c(1, 2), lwd=c(2,2),
    ask, subset=NULL, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mep_+3A_object">object</code></td>
<td>

<p>a fitted model object.
</p>
</td></tr>
<tr><td><code id="mep_+3A_which">which</code></td>
<td>

<p>numeric, logical, or character. Indices for the variables in the model frame
if only one or a subset is desired.
</p>
</td></tr>
<tr><td><code id="mep_+3A_link">link</code></td>
<td>

<p>character accepted by <code><a href="stats.html#topic+make.link">make.link</a></code>,
optional argument to determine scaling.
It is guessed when value cannot be determined based on
<code>family(object)$link</code> (see Details).
</p>
</td></tr>
<tr><td><code id="mep_+3A_level">level</code></td>
<td>

<p>numeric [0, 1], the confidence level required.
</p>
</td></tr>
<tr><td><code id="mep_+3A_unique">unique</code>, <code id="mep_+3A_digits">digits</code></td>
<td>

<p>numeric, the number of unique points above which bins are used.
If the number of unique values is less than or equal to this number,
unique values are used without binning. Unique values are subject to
rounding to <code>digits</code>.
</p>
</td></tr>
<tr><td><code id="mep_+3A_n">n</code>, <code id="mep_+3A_minbucket">minbucket</code></td>
<td>

<p>number of bins (<code>n</code>) to be used in quantile estimation when variable is
not treated as unique points. <code>minbucket</code> is the minimum number of points
within each bin. <code>n</code> is decreased until <code>minbucket</code> condition is
satisfied.
</p>
</td></tr>
<tr><td><code id="mep_+3A_col.points">col.points</code>, <code id="mep_+3A_pch">pch</code></td>
<td>

<p>color and type of points to be plotted.
</p>
</td></tr>
<tr><td><code id="mep_+3A_col.lines">col.lines</code>, <code id="mep_+3A_lty">lty</code>, <code id="mep_+3A_lwd">lwd</code></td>
<td>

<p>color, type, and width of quantile lines to be plotted.
The 1st value correspond to the median, the 2nd value to the upper and lower
quantiles, respectively.
</p>
</td></tr>
<tr><td><code id="mep_+3A_ask">ask</code></td>
<td>

<p>logical. If <code>TRUE</code>, the user is asked before each plot,
see <code><a href="graphics.html#topic+par">par</a>(ask=.)</code>.
</p>
</td></tr>
<tr><td><code id="mep_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of the data to be used for plotting.
</p>
</td></tr>
<tr><td><code id="mep_+3A_ylab">ylab</code></td>
<td>

<p>character or expression, optional y axis label.
</p>
</td></tr>
<tr><td><code id="mep_+3A_...">...</code></td>
<td>

<p>other possible arguments passed to graphical functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input object must have a <code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+model.frame">model.frame</a></code>
method, and possibly a well identifiable family/link component
(<code>family(object)$link</code>).
In the absence of family/link information, the range of the fitted
value will be used to guess the scaling (identity, log, or logit)
unless directly supplied via the <code>link</code> argument.
</p>
<p>Fitted values (f(x) = f(x_1,...,x_i,...,x_p); i = 1,...,p) are plotted against x_i.
The visual display is determined by the type of x_i (un-ordered factor, ordered
factor, unique numeric values, binned numeric values).
For each unique vale or bin, the median and confidence intervals
(quantiles corresponding to <code>level</code>) of f(x) are calculated.
Binned values are smoothed by <code><a href="stats.html#topic+lowess">lowess</a></code> unless <code>n</code> &lt; 3.
</p>
<p>Jitter is added to factor and unique value types.
Jitter is calculated based on kernel <code><a href="stats.html#topic+density">density</a></code>.
</p>
<p>The model frame includes the response variable as well. Plotting f(x)
as a function of the observations might be a useful visualization too
to indicate goodness of fit or the lack of it.
</p>


<h3>Value</h3>

<p>The produces one or several marginal plots as a side effect.
Returns a list of quantiles of fitted values
corresponding to binned/unique values of variables in the input object.</p>


<h3>Author(s)</h3>

<p>Peter Solymos and Subhash Lele
</p>


<h3>References</h3>

<p>Avgar, T., Lele, S. R., Keim, J. L. &amp; Boyce, M. S. (2017)
Relative Selection Strength:
Quantifying effect size in habitat- and step-selection inference.
Ecology and Evolution 7, 5322&ndash;5330.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdepairs">kdepairs</a></code> for 2D kernel density estimates and contours.
</p>
<p><code><a href="stats.html#topic+fitted">fitted</a></code> for fitted values and
<code><a href="stats.html#topic+model.frame">model.frame</a></code> for model frames.
</p>
<p><code><a href="stats.html#topic+density">density</a></code> and <code><a href="stats.html#topic+lowess">lowess</a></code> for smoothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(goats)
goats$ELEVATION &lt;- goats$ELEVATION/1000
goats$TASPc &lt;- cut(goats$TASP, 3, ordered_result=FALSE)
goats$SLOPEc &lt;- cut(goats$SLOPE, 3, ordered_result=TRUE)

fit &lt;- rspf(STATUS ~ TASPc + SLOPEc + ELEVATION + I(ELEVATION^2), goats, m=0, B=0)

op &lt;- par(mfrow=c(2,2))
mep(fit, which=1:4)#, subset=sample.int(nrow(goats), 10^4))
par(op)
</code></pre>

<hr>
<h2 id='rsf'>
Resource Selection (Probability) Functions for Use-Availability Data
</h2><span id='topic+rsf.fit'></span><span id='topic+rsf'></span><span id='topic+rspf'></span><span id='topic+rsf.null'></span>

<h3>Description</h3>

<p>Resource Selection (Probability) Functions for
use-availability wildlife data as described in
Lele and Keim (2006) and Lele (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsf(formula, data, m, B = 99, inits, method = "Nelder-Mead",
control, model = TRUE, x = FALSE, ...)

rspf(formula, data, m, B = 99, link = "logit", inits,
method = "Nelder-Mead", control, model = TRUE, x = FALSE, ...)

rsf.fit(X, Y, m, link = "logit", B = 99,
inits, method = "Nelder-Mead", control, ...)

rsf.null(Y, m, inits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsf_+3A_formula">formula</code></td>
<td>

<p>two sided model formula of the form <code>y ~ x</code>,
where <code>y</code> is a vector of observations,
<code>x</code> is the set of covariates.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_m">m</code></td>
<td>

<p>argument describing the matching of use and available points, see Details.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_data">data</code></td>
<td>

<p>data.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_b">B</code></td>
<td>

<p>number of bootstrap iterations to make.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_link">link</code></td>
<td>

<p>character, type of link function to be used.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_inits">inits</code></td>
<td>

<p>initial values, optional.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_method">method</code></td>
<td>

<p>method to be used in <code><a href="stats.html#topic+optim">optim</a></code> for numerical optimization.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_control">control</code></td>
<td>

<p>control options for <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_model">model</code></td>
<td>

<p>a logical value indicating whether model frame should be included as a component of the returned value
</p>
</td></tr>
<tr><td><code id="rsf_+3A_x">x</code></td>
<td>

<p>logical values indicating whether the model matrix used in the
fitting process should be returned as components of the returned value.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_y">Y</code></td>
<td>

<p>vector of observations.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_x">X</code></td>
<td>

<p>covariate matrix.
</p>
</td></tr>
<tr><td><code id="rsf_+3A_...">...</code></td>
<td>

<p>other arguments passed to the functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rsf</code> function fits the Exponential Resource Selection Function
(RSF) model to presence only data.
</p>
<p>The <code>rspf</code> function fits the Resource Selection Probability Function
(RSPF) model to presence only data Link function <code>"logit"</code>,
<code>"cloglog"</code>, and <code>"probit"</code> can be specified via the
<code>link</code> argument.
</p>
<p>The <code>rsf.fit</code> is the workhorse behind the two functions.
<code>link="log"</code> leads to Exponential RSF.
</p>
<p>The <code>rsf.null</code> function fits the 'no selection' version
of the Exponential Resource Selection Function (RSF) model to presence only data.
</p>
<p>LHS of the <code>formula</code> data must be binary, ones indicating used locations,
while zeros indicating available location.
</p>
<p>All available points are used for each use points if <code>m=0</code>
(global availability). If <code>m</code> is a single value, e.g. <code>m=5</code>,
it is assumed that available data points are grouped in batches of 5,
e.g. with IDs <code>c(1,2)</code> for used point locations and
<code>c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2)</code> for available locations
(local availability, matched use-available design).
Similarly, a vector of matching IDs can also be provided, e.g.
<code>c(1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2)</code> by combining the above two.
This potentially could allow for unbalanced matching
(e.g. <code>c(1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2)</code>)
and for easier subsetting of the data,
but comes with an increased computing time.
Note, the response in the LHS of the formula
should be coded as <code>c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</code>
for all of the above examples. When <code>m</code> is defined as
a mapping vector or the value is 0, the order of course does not matter.
However, ordering matters when <code>m</code> is constant because that
implies a certain structure.
</p>
<p>For model description and estimation details, see Lele and Keim (2006),
Lele (2009), and Solymos and Lele (2016).
</p>


<h3>Value</h3>

<p>A list with class <code>"rsf"</code>, <code>"rsf.null"</code>, or <code>"rspf"</code>
containing the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector from LHS of the formula.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>a named vector of standard errors
for the coefficients.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the maximized pseudo log-likelihood according to Lele 2009.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p><code><a href="stats.html#topic+optim">optim</a></code> results.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>character, value of the link function used.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>control parameters for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>inits</code></td>
<td>
<p>initial values used in optimization.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>value of the <code>m</code> argument with possibly matched
use-available design.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>number of active parameters.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>vector of fitted values. These are relative
selection values for RSF models, and probability of selection for
RSPF models.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of used locations.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>component to store bootstrap results if <code>B</code>&gt;0.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical, indicating convergence of the optimization.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>the contrasts used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested, the model frame.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Subhash R. Lele, Jonah L. Keim, Peter Solymos
</p>


<h3>References</h3>

<p>Lele, S.R. (2009)
A new method for estimation of resource selection probability function.
Journal of Wildlife Management 73, 122&ndash;127.
</p>
<p>Lele, S. R. &amp;  Keim, J. L. (2006)
Weighted distributions and estimation of resource selection probability functions.
Ecology 87, 3021&ndash;3028.
</p>
<p>Solymos, P. &amp; Lele, S. R. (2016)
Revisiting resource selection probability functions and single-visit methods:
clarification and extensions.
Methods in Ecology and Evolution 7, 196&ndash;205.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Simulated data example ---

## settings
n.used &lt;- 1000
m &lt;- 10
n &lt;- n.used * m
set.seed(1234)
x &lt;- data.frame(x1=rnorm(n), x2=runif(n))
cfs &lt;- c(1.5,-1,0.5)
## fitting Exponential RSF model
dat1 &lt;- simulateUsedAvail(x, cfs, n.used, m, link="log")
m1 &lt;- rsf(status ~ .-status, dat1, m=0, B=0)
summary(m1)
## fitting Logistic RSPF model
dat2 &lt;- simulateUsedAvail(x, cfs, n.used, m, link="logit")
m2 &lt;- rspf(status ~ .-status, dat2, m=0, B=0)
summary(m2)

## --- Real data analysis from Lele &amp; Keim 2006 ---

## Not run: 
goats$exp.HLI &lt;- exp(goats$HLI)
goats$sin.SLOPE &lt;- sin(pi * goats$SLOPE / 180)
goats$ELEVATION &lt;- scale(goats$ELEVATION)
goats$ET &lt;- scale(goats$ET)
goats$TASP &lt;- scale(goats$TASP)

## Fit two RSPF models:
## global availability (m=0) and bootstrap (B=99)
m1 &lt;- rspf(STATUS ~ TASP + sin.SLOPE + ELEVATION, goats, m=0, B = 99)
m2 &lt;- rspf(STATUS ~ TASP + ELEVATION, goats, m=0, B = 99)

## Inspect the summaries
summary(m1)
summary(m2)

## Compare models: looks like m1 is better supported
CAIC(m1, m2)

## Visualize the relationships
plot(m1)
mep(m1) # marginal effects similar to plot but with CIs
kdepairs(m1) # 2D kernel density estimates
plot(m2)
kdepairs(m2)
mep(m2)

## fit and compare to null RSF model (not available for RSPF)
m3 &lt;- rsf(STATUS ~ TASP + ELEVATION, goats, m=0, B = 0)
m4 &lt;- rsf.null(Y=goats$STATUS, m=0)
CAIC(m3, m4)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulateUsedAvail'>
Simulate Used-Available Data
</h2><span id='topic+simulateUsedAvail'></span>

<h3>Description</h3>

<p>Simulates used-available data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateUsedAvail(data, parms, n.used, m, link="logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateUsedAvail_+3A_data">data</code></td>
<td>

<p>a matrix or data frame.
</p>
</td></tr>
<tr><td><code id="simulateUsedAvail_+3A_parms">parms</code></td>
<td>

<p>coefficients corresponding to the columns of the design matrix
derived as <code>model.matrix(~., data)</code>.
</p>
</td></tr>
<tr><td><code id="simulateUsedAvail_+3A_n.used">n.used</code>, <code id="simulateUsedAvail_+3A_m">m</code></td>
<td>

<p>number of used points (<code>n.used</code>)
and number of available points for each (<code>m</code>).
</p>
</td></tr>
<tr><td><code id="simulateUsedAvail_+3A_link">link</code></td>
<td>

<p>character, the type of link function to be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A used-available data frame.
</p>


<h3>Author(s)</h3>

<p>Subhash Lele, Peter Solymos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.used &lt;- 1000
m &lt;- 10
n &lt;- n.used * m
set.seed(1234)
x &lt;- data.frame(x1=rnorm(n), x2=runif(n))
cfs &lt;- c(1.5,-1,0.5)
dat1 &lt;- simulateUsedAvail(x, cfs, n.used, m, link="log")
str(dat1)
dat2 &lt;- simulateUsedAvail(x, cfs, n.used, m, link="logit")
str(dat2)
</code></pre>

<hr>
<h2 id='sindex'>
Weighted relative suitability index
</h2><span id='topic+wrsi'></span><span id='topic+sindex'></span>

<h3>Description</h3>

<p>Calculates weighted relative suitability index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sindex(y, x)
wrsi(y, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sindex_+3A_y">y</code></td>
<td>

<p>matrix of observations for <code>sindex</code>,
vector of observations for <code>wrsi</code>.
</p>
</td></tr>
<tr><td><code id="sindex_+3A_x">x</code></td>
<td>

<p>a matrix of proportions (i.e. the values 0 and 1 should have
consistent meaning across the columns, often through a unit sum constraint).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wrsi</code> returns a data frame (class 'wrsi') with the following columns:
</p>

<dl>
<dt><code>WRSI</code></dt><dd><p>weighted relative suitability index, range (0- Inf).</p>
</dd>
<dt><code>zWRSI</code></dt><dd><p>log of <code>WRSI</code> (z-transformed), range (-Inf, Inf).</p>
</dd>
<dt><code>rWRSI</code></dt><dd><p>inverse Fisher z-transformed <code>zWRSI</code>, range (-1, 1).</p>
</dd>
<dt><code>Pused</code> and <code>Pavail</code></dt><dd><p>total proportion of used (<code>y &gt; 0</code>)
and available of each feature (column) in <code>x</code>.</p>
</dd>
<dt><code>Pw</code></dt><dd><p>weighted proportions from <code>y</code>.</p>
</dd>
<dt><code>u</code> and <code>a</code></dt><dd><p>used and available totals
for each feature (column) in <code>x</code>.</p>
</dd>
</dl>

<p><code>sindex</code> returns a data frame (class 'sindex') with
one column for each species, and one row for each feature (column) in <code>x</code>.
Cell values are inverse Fisher z-transformed (<code>zWRSI</code>) indices.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- habitat composition matrix
set.seed(1234)
n &lt;- 1000 # sample size
k &lt;- 5 # habitat classes
s &lt;- runif(n, 1, 5)
p &lt;- plogis(rnorm(n*k, 0, rep(s, k)))
p &lt;- p*t(replicate(n, sample(c(10,4,2,1,1))))
x &lt;- p / rowSums(p)
summary(x)
summary(rowSums(x))

## --- observations
## expected abundance in each habitat class
lam &lt;- c(0.8, 0.6, 0.5, 0.4, 0.1)*1
## sample x habitat level abundances
yy &lt;- t(sapply(seq_len(n), function(i) {
    ## intercept and modifier combined
    rpois(k, (x[i,]*lam))
    }))
## total: sum over habitat classes
## this is what we observe
y &lt;- rowSums(yy)
colSums(yy)
table(y)

## --- wrsi calculations
(w &lt;- wrsi(y, x))
op &lt;- par(mfrow=c(1,2))
## habitat level observations are unknown
plot(lam, colSums(yy) / sum(yy), type="b")
## this is approximated by the wrsi
plot(lam, w$rWRSI, type="b")
abline(h=0, lty=2)
par(op)

## --- sindex calculations for multiple species
y2 &lt;- cbind(Spp1=y, Spp2=rev(y), Spp3=sample(y))
(w2 &lt;- sindex(y2, x))
heatmap(t(as.matrix(w2)), scale="none")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
