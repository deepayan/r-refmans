<!DOCTYPE html><html><head><title>Help for package ClassDiscovery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClassDiscovery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aspectHeatmap'><p>Heatmap with control over the aspect ratio</p></a></li>
<li><a href='#BootstrapClusterTest'><p>Class &quot;BootstrapClusterTest&quot;</p></a></li>
<li><a href='#cluster3'><p> Cluster a Dataset Three Ways</p></a></li>
<li><a href='#ClusterTest-class'><p>Class &quot;ClusterTest&quot;</p></a></li>
<li><a href='#distanceMatrix'><p>Distance Matrix Computation</p></a></li>
<li><a href='#GenePCA'><p>Class &quot;GenePCA&quot;</p></a></li>
<li><a href='#hclust'><p>Class &quot;hclust&quot;</p></a></li>
<li><a href='#justClusters'><p>Get the List of Classes From A Clustering Algorithm</p></a></li>
<li><a href='#mahalanobisQC'><p>Using Mahalanobis Distance and PCA for Quality Control</p></a></li>
<li><a href='#Mosaic'><p>Class &quot;Mosaic&quot;</p></a></li>
<li><a href='#PCanova'><p>Class &quot;PCanova&quot;</p></a></li>
<li><a href='#PerturbationClusterTest'><p>The PerturbationClusterTest Class</p></a></li>
<li><a href='#plotColoredClusters'><p>Plot Dendrograms with Color-Coded Labels</p></a></li>
<li><a href='#SamplePCA'><p>Class &quot;SamplePCA&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-07-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes and Methods for "Class Discovery" with Microarrays or
Proteomics</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), cluster, oompaBase (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, grDevices, mclust, oompaData,
Biobase</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines the classes used for "class discovery" problems
  in the OOMPA project (<a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a>). Class
  discovery primarily consists of unsupervised clustering methods with
  attempts to assess their statistical significance. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Microarray, Clustering</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-16 14:22:47 UTC; KRC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-16 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aspectHeatmap'>Heatmap with control over the aspect ratio</h2><span id='topic+aspectHeatmap'></span>

<h3>Description</h3>

<p>This function replaces the heatmap function in the stats package with
a function with additional features. First, the user can specify an
aspect ratio instead of being forced to accept a square image even
when the matrix is not square. Second, the user can overlay horizontal
or vertical lines to mark out important regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aspectHeatmap(x,
              Rowv=NULL,
              Colv=if (symm) "Rowv" else NULL,
              distfun=dist,
              hclustfun=hclust,
              reorderfun=function(d, w) reorder(d, w),
              add.expr,
              symm=FALSE,
              revC=identical(Colv, "Rowv"),
              scale=c("row", "column", "none"),
              na.rm=TRUE,
              margins=c(5, 5),
              ColSideColors,
              RowSideColors,
              cexRow=0.2 + 1/log10(nr),
              cexCol=0.2 + 1/log10(nc),
              labRow=NULL,
              labCol=NULL,
              main=NULL,
              xlab=NULL,
              ylab=NULL,
              keep.dendro=FALSE,
              verbose=getOption("verbose"),
              hExp=1,
              wExp=1,
              vlines=NULL,
              hlines=NULL,
              lasCol=2,
              ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aspectHeatmap_+3A_x">x</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_rowv">Rowv</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_colv">Colv</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_distfun">distfun</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_hclustfun">hclustfun</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_reorderfun">reorderfun</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_add.expr">add.expr</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_symm">symm</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_revc">revC</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_scale">scale</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_na.rm">na.rm</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_margins">margins</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_colsidecolors">ColSideColors</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_rowsidecolors">RowSideColors</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_cexrow">cexRow</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_cexcol">cexCol</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_labrow">labRow</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_labcol">labCol</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_main">main</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_xlab">xlab</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_ylab">ylab</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_keep.dendro">keep.dendro</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_verbose">verbose</code></td>
<td>
<p> See documentation for <a href="stats.html#topic+heatmap">heatmap</a>.</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_hexp">hExp</code></td>
<td>
<p>height expansion factor (default is <code>1</code>)</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_wexp">wExp</code></td>
<td>
<p>width expansion factor (default is <code>1</code>)</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_vlines">vlines</code></td>
<td>
<p>vector of positions at which to draw vertical lines</p>
</td></tr> 
<tr><td><code id="aspectHeatmap_+3A_hlines">hlines</code></td>
<td>
<p>vector of positions at which to draw horizontal lines</p>
</td></tr> 
<tr><td><code id="aspectHeatmap_+3A_lascol">lasCol</code></td>
<td>
<p>axis label style (las) for columns</p>
</td></tr>
<tr><td><code id="aspectHeatmap_+3A_...">...</code></td>
<td>
<p>additional arguments passed along to the image command</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new arguments <code>hExp</code> and <code>wExp</code> are &quot;expansion factors&quot;
for the height and width of the figure, respectively. They are used
to alter the arguments passed to the layout function internally to
heatmap.
</p>
<p>The new arguments <code>hlines</code> and <code>vlines</code> are used to specify
points at which horizontal or vertical lines, respectively, should be
overlaid on the image.
</p>


<h3>Value</h3>

<p>The same as the <a href="stats.html#topic+heatmap">heatmap</a> function.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+heatmap">heatmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nC &lt;- 30
nR &lt;- 1000
fakeData &lt;- matrix(rnorm(nC*nR), ncol=nC, nrow=nR)
aspectHeatmap(fakeData, scale='none', hExp=2, wExp=1.4, margins=c(6,3))
aspectHeatmap(fakeData, scale='none', hExp=2, wExp=1.4, margins=c(6,3),
              vlines=15.5, hlines=c(100, 300))
</code></pre>

<hr>
<h2 id='BootstrapClusterTest'>Class &quot;BootstrapClusterTest&quot;</h2><span id='topic+BootstrapClusterTest'></span><span id='topic+BootstrapClusterTest-class'></span><span id='topic+summary+2CBootstrapClusterTest-method'></span>

<h3>Description</h3>

<p>Performs a nonparametric bootstrap (sampling with replacement) test to
determine whether the clusters found by an unsupervised method appear
to be robust in a given data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapClusterTest(data, FUN, subsetSize, nTimes=100, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootstrapClusterTest_+3A_data">data</code></td>
<td>
<p>A data matrix, numerical data frame, or
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> object.</p>
</td></tr>
<tr><td><code id="BootstrapClusterTest_+3A_fun">FUN</code></td>
<td>
<p>A <code>function</code> that, given a data matrix,
returns a vector of cluster assignments.  Examples of functions
with this behavior are <code><a href="#topic+cutHclust">cutHclust</a></code>,
<code><a href="#topic+cutKmeans">cutKmeans</a></code>, <code><a href="#topic+cutPam">cutPam</a></code>, and
<code><a href="#topic+cutRepeatedKmeans">cutRepeatedKmeans</a></code>.</p>
</td></tr>
<tr><td><code id="BootstrapClusterTest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the classifying function, <code>FUN</code>.</p>
</td></tr> 
<tr><td><code id="BootstrapClusterTest_+3A_subsetsize">subsetSize</code></td>
<td>
<p>An optional integer argument. If present,
each iteration of the bootstrap selects <code>subsetSize</code> rows
from the original data matrix. If missing, each bootstrap contains
the same number of rows as the original data matrix.</p>
</td></tr> 
<tr><td><code id="BootstrapClusterTest_+3A_ntimes">nTimes</code></td>
<td>
<p>The number of bootstrap samples to collect.</p>
</td></tr>
<tr><td><code id="BootstrapClusterTest_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects should be created using the <code>BootstrapClusterTest</code>
function, which performs the requested bootstrap on the
clusters. Following the standard R paradigm, the resulting object can be
summarized and plotted to determine the results of the test.
</p>


<h3>Slots</h3>


<dl>
<dt><code>f</code>:</dt><dd><p>A <code>function</code> that, given a data matrix,
returns a vector of cluster assignments.  Examples of functions
with this behavior are <code><a href="#topic+cutHclust">cutHclust</a></code>,
<code><a href="#topic+cutKmeans">cutKmeans</a></code>, <code><a href="#topic+cutPam">cutPam</a></code>, and
<code><a href="#topic+cutRepeatedKmeans">cutRepeatedKmeans</a></code>. 
</p>
</dd>
<dt><code>subsetSize</code>:</dt><dd><p> The number of rows to be included in each
bootstrap sample.</p>
</dd>
<dt><code>nTimes</code>:</dt><dd><p>An integer, the number of bootstrap samples
that were collected.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>An object of class <code>call</code>, which records
how the object was produced. </p>
</dd>
<dt><code>result</code>:</dt><dd><p>Object of class <code>matrix</code> containing, for
each pair of columns in the original data, the number of times
they belonged to the same cluster of a bootstrap sample. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+ClusterTest">ClusterTest</a></code>, directly. See that class for
descriptions of the inherited methods <code>image</code> and <code>hist</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = BootstrapClusterTest)</code>:
Write out a summary of the object. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Kerr MK, Churchill GJ.<br />
<em>Bootstrapping cluster analysis: Assessing the reliability of
conclusions from microarray experiments.</em><br />
PNAS 2001; 98:8961-8965.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClusterTest">ClusterTest</a></code>,
<code><a href="#topic+PerturbationClusterTest">PerturbationClusterTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("BootstrapClusterTest")

## simulate data from two different groups
d1 &lt;- matrix(rnorm(100*30, rnorm(100, 0.5)), nrow=100, ncol=30, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*20, rnorm(100, 0.5)), nrow=100, ncol=20, byrow=FALSE)
dd &lt;- cbind(d1, d2)
cols &lt;- rep(c('red', 'green'), times=c(30,20))
colnames(dd) &lt;- paste(cols, c(1:30, 1:20), sep='')
## peform your basic hierarchical clustering...
hc &lt;- hclust(distanceMatrix(dd, 'pearson'), method='complete')

## bootstrap the clusters arising from hclust
bc &lt;- BootstrapClusterTest(dd, cutHclust, nTimes=200, k=3, metric='pearson')
summary(bc)

## look at the distribution of agreement scores
hist(bc, breaks=101)

## let heatmap compute a new dendrogram from the agreement
image(bc, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## plot the agreement matrix with the original dendrogram
image(bc, dendrogram=hc, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## bootstrap the results of PAM
pamc &lt;- BootstrapClusterTest(dd, cutPam, nTimes=200, k=3)
image(pamc, dendrogram=hc, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## contrast the behavior when all the data comes from the same group
xx &lt;- matrix(rnorm(100*50, rnorm(100, 0.5)), nrow=100, ncol=50, byrow=FALSE)
hct &lt;- hclust(distanceMatrix(xx, 'pearson'), method='complete')
bct &lt;- BootstrapClusterTest(xx, cutHclust, nTimes=200, k=4, metric='pearson')
summary(bct)
image(bct, dendrogram=hct, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## cleanup
rm(d1, d2, dd, cols, hc, bc, pamc, xx, hct, bct)
</code></pre>

<hr>
<h2 id='cluster3'> Cluster a Dataset Three Ways </h2><span id='topic+cluster3'></span>

<h3>Description</h3>

<p>Produces and plots dendrograms using three similarity measures:
Euclidean distance, Pearson correlation, and Manhattan distance on
dichotomized data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster3(data, eps=logb(1, 2), name="", labels=dimnames(data)[[2]])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster3_+3A_data">data</code></td>
<td>
<p> A matrix, numeric data.frame, or
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> object.</p>
</td></tr>
<tr><td><code id="cluster3_+3A_eps">eps</code></td>
<td>
<p> A numerical value; the threshold at which to dichotomize
the data</p>
</td></tr>
<tr><td><code id="cluster3_+3A_name">name</code></td>
<td>
<p>A character string to label the plots </p>
</td></tr>
<tr><td><code id="cluster3_+3A_labels">labels</code></td>
<td>
<p>A vector of character strings used to label the items in
the dendrograms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the <code>data</code> object on which it was invoked.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes emailkrc@silicovore.com
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data from two different classes
d1 &lt;- matrix(rnorm(100*30, rnorm(100, 0.5)), nrow=100, ncol=30, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*20, rnorm(100, 0.5)), nrow=100, ncol=20, byrow=FALSE)
dd &lt;- cbind(d1, d2)
## cluster it 3 ways
par(mfrow=c(2,2))
cluster3(dd)
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='ClusterTest-class'>Class &quot;ClusterTest&quot;</h2><span id='topic+ClusterTest'></span><span id='topic+ClusterTest-class'></span><span id='topic+hist+2CClusterTest-method'></span><span id='topic+image+2CClusterTest-method'></span><span id='topic+summary+2CClusterTest-method'></span>

<h3>Description</h3>

<p>This is a base class for tests that attempt to determine whether the groups
found by an unsupervised clustering method are statistically significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClusterTest'
image(x, dendrogram, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusterTest-class_+3A_x">x</code></td>
<td>
<p>An object of the <code>ClusterTest</code> class.</p>
</td></tr>
<tr><td><code id="ClusterTest-class_+3A_dendrogram">dendrogram</code></td>
<td>
<p>An object with S3 class <code>hclust</code>, as returned
by the <code><a href="stats.html#topic+hclust">hclust</a></code> function.</p>
</td></tr>
<tr><td><code id="ClusterTest-class_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to the
standard <code>heatmap</code> function that is used to implement the
<code>image</code> method.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ClusterTest", ...)</code>. 
Most users, however, will only create objects from one of the derived
classes such as <code><a href="#topic+BootstrapClusterTest">BootstrapClusterTest</a></code> or
<code><a href="#topic+PerturbationClusterTest">PerturbationClusterTest</a></code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>An object of class <code>call</code>, which shows
how the object was constructed.</p>
</dd>
<dt><code>result</code>:</dt><dd><p>A symmetric <code>matrix</code> containing the
results of the cluster reproducibility test.  The size of the
matrix corresponds to the number of samples (columns) in the data
set on which the test was performed.  The <code>result</code> matrix
should contain &quot;agreement&quot; values between 0 and 1, representing for
each pair of samples the fraction of times that they were
collected into the same cluster.</p>
</dd> 
</dl>



<h3>Methods</h3>


<dl>
<dt>hist</dt><dd><p><code>signature(x = "ClusterTest")</code>: Produces a
histogram of the agreement fractions.  When a true group structure
exists, one expects a multimodal distribution,with one group of
agreements near 0 (for pairs belonging to different clusters) and
one group of agreements near 1 (for pairs belonging to the same
cluster).</p>
</dd> 
<dt>image</dt><dd><p><code>signature(x = "ClusterTest")</code>: Uses the
<code>heatmap</code> function to display the agreement matrix. The
optional <code>dendrogram</code> argument should be used to display the
extent to which the agreement matrix matches the results of
hierarchical clustering using the full data set.  This method
invisibly returns the result of a call to <code>heatmap</code>; thus, you
can use <code>keep.dendro=TRUE</code> to recover the cluster assignments
from the dendrograms.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "ClusterTest")</code>: Write out a
summary of the object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes emailkrc@silicovore.com
</p>


<h3>References</h3>

<p>Kerr MK, Churchill GJ.<br />
<em>Bootstrapping cluster analysis: Assessing the reliability of
conclusions from microarray experiments.</em><br />
PNAS 2001; 98:8961-8965.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapClusterTest">BootstrapClusterTest</a></code>,
<code><a href="#topic+PerturbationClusterTest">PerturbationClusterTest</a></code>,
<code><a href="stats.html#topic+heatmap">heatmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ClusterTest")

## simulate data from two different classes
d1 &lt;- matrix(rnorm(100*30, rnorm(100, 0.5)), nrow=100, ncol=30, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*20, rnorm(100, 0.5)), nrow=100, ncol=20, byrow=FALSE)
dd &lt;- cbind(d1, d2)

## cluster the data
hc &lt;- hclust(distanceMatrix(dd, 'pearson'), method='average')

## make a fake reproducibility matrix
fraud &lt;- function(x) {
  new('ClusterTest', result=abs(cor(x)), call=match.call())
}

fake &lt;- fraud(dd)
summary(fake)

hist(fake)

image(fake) # let heatmap compute a new dendrogram from the agreements

image(fake, dendrogram=hc) # use the actual dendrogram from the data

image(fake, dendrogram=hc, col=blueyellow(64)) # change the colors

## cleanup
rm(fake, fraud, hc, dd, d1, d2)
</code></pre>

<hr>
<h2 id='distanceMatrix'>Distance Matrix Computation</h2><span id='topic+distanceMatrix'></span>

<h3>Description</h3>

<p>This function computes and returns the distance matrix determined by
using the specified distance metric to compute the distances between
the columns of a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceMatrix(dataset, metric, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceMatrix_+3A_dataset">dataset</code></td>
<td>
<p>A numeric matrix or an <code><a href="Biobase.html#topic+ExpressionSet">ExpressionSet</a></code></p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_metric">metric</code></td>
<td>
<p> A character string defining the distance metric. This
can be <code>pearson</code>, <code>sqrt pearson</code>, <code>spearman</code>,
<code>absolute pearson</code>, <code>uncentered correlation</code>,
<code>weird</code>, <code>cosine</code>,
or any of the metrics accepted by the     <code><a href="stats.html#topic+dist">dist</a></code>
function. At present, the latter function accepts
<code>euclidean</code>, <code>maximum</code>, <code>manhattan</code>, <code>canberra</code>,
<code>binary</code>, or <code>minkowski</code>. Any initial substring that
uniquely defines one of the metrics will work.</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed on to
<code><a href="stats.html#topic+dist">dist</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code><a href="stats.html#topic+dist">dist</a></code> in two ways, both of
which are motivated by common practice in the analysis of microarray
or proteomics data. First, it computes distances between column vectors
instead of between row vectors. In a typical microarray experiment,
the data is organized so the rows represent genes and the columns
represent different biological samples. In many applications,
relations between the biological samples are more interesting than
relationships between genes. Second, <code>distanceMatrix</code> adds
additional distance metrics based on correlation.
</p>

<ul>
<li><p><code>pearson</code>The most common metric used in the microarray literature is
the <code>pearson</code> distance, which can be computed in terms of the
Pearson correlation coefficient as <code>(1-cor(dataset))/2</code>.
</p>
</li>
<li><p><code>uncentered correlation</code>This metric was introduced in
the Cluster and TreeView software from the Eisen lab at
Stanford. It is computed using the formulas for Pearson
correlation, but assuming that both vectors have mean zero.
</p>
</li>
<li><p><code>spearman</code>The <code>spearman</code> metric used the same formula, but
substitutes the Spearman rank correlation for the Pearson
correlation.
</p>
</li>
<li><p><code>absolute pearson</code>The <code>absolute pearson</code> metric used the absolute
correlation coefficient; i.e., <code>(1-abs(cor(dataset)))</code>.
</p>
</li>
<li><p><code>sqrt pearson</code>The <code>sqrt pearson</code> metric used the square root of the
pearson distance metric; i.e., <code>sqrt(1-cor(dataset))</code>.
</p>
</li>
<li><p><code>weird</code>The <code>weird</code> metric uses the Euclidean distance between
the vectors of correlation coefficients; i.e., dist(cor(dataset)).
</p>
</li></ul>



<h3>Value</h3>

<p>A distance matrix in the form of an object of class <code>dist</code>, of
the sort returned by the <code>dist</code> function or the <code>as.dist</code>
function. 
</p>


<h3>BUGS</h3>

<p>It would be good to have a better name for the <code>weird</code> metric.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="stats.html#topic+as.dist">as.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- matrix(rnorm(100*5, rnorm(100)), nrow=100, ncol=5)
distanceMatrix(dd, 'pearson')
distanceMatrix(dd, 'euclid')
distanceMatrix(dd, 'sqrt')
distanceMatrix(dd, 'weird')
rm(dd) # cleanup
</code></pre>

<hr>
<h2 id='GenePCA'>Class &quot;GenePCA&quot;</h2><span id='topic+GenePCA'></span><span id='topic+GenePCA-class'></span><span id='topic+plot+2CGenePCA+2Cmissing-method'></span>

<h3>Description</h3>

<p>Perform principal components analysis on the genes (rows) from a
microarray or proteomics experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenePCA(geneData)
## S4 method for signature 'GenePCA,missing'
plot(x, splitter=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenePCA_+3A_genedata">geneData</code></td>
<td>
<p>A data matrix, with rows interpreted as genes and
columns as samples</p>
</td></tr>
<tr><td><code id="GenePCA_+3A_x">x</code></td>
<td>
<p>a <code>GenePCA</code> object</p>
</td></tr>
<tr><td><code id="GenePCA_+3A_splitter">splitter</code></td>
<td>
<p>A logical vector classifying the genes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a preliminary attempt at a class for principal components
analysis of genes, parallel to the <code><a href="#topic+SamplePCA">SamplePCA</a></code> class for
samples.  The interface will (one hopes) improve markedly in the next
version of the library.
</p>


<h3>Value</h3>

<p>The <code>GenePCA</code> function constructs and returns a valid object of
the <code>GenePCA</code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be created using the <code>GenePCA</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>scores</code>:</dt><dd><p>A <code>matrix</code> of size PxN, where P is the
number of rows and N the number fo columns in the input,
representing the projections of the input rows onto the first N
principal components. </p>
</dd>
<dt><code>variances</code>:</dt><dd><p>A <code>numeric</code> vector of length N; the
amount of the total variance explained by each principal component.</p>
</dd>
<dt><code>components</code>:</dt><dd><p>A <code>matrix</code> of size NxN containing
each of the first P principal components as columns.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = GenePCA, y = missing)</code>: Plot the
genes in the space of the first two principal components. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SamplePCA">SamplePCA</a></code>,
<code><a href="stats.html#topic+princomp">princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GenePCA")

## simulate samples from three different groups, with generic genes
d1 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d3 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
dd &lt;- cbind(d1, d2, d3)

## perform PCA in gene space
gpc &lt;- GenePCA(dd)

## plot the results
plot(gpc)

## cleanup
rm(d1, d2, d3, dd, gpc)
</code></pre>

<hr>
<h2 id='hclust'>Class &quot;hclust&quot;</h2><span id='topic+hclust-class'></span>

<h3>Description</h3>

<p>Creates an S4 class equivalent to the S3 hclust class returned by the
<code>hclust</code> function.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cutree">cutree</a></code>,
<code><a href="stats.html#topic+hclust">hclust</a></code>,
<code><a href="stats.html#topic+heatmap">heatmap</a></code>
</p>

<hr>
<h2 id='justClusters'>Get the List of Classes From A Clustering Algorithm </h2><span id='topic+cutHclust'></span><span id='topic+cutPam'></span><span id='topic+cutKmeans'></span><span id='topic+repeatedKmeans'></span><span id='topic+cutRepeatedKmeans'></span>

<h3>Description</h3>

<p>Unsupervised clustering algorithms, such as partitioning around medoids
(<code><a href="cluster.html#topic+pam">pam</a></code>), K-means (<code><a href="stats.html#topic+kmeans">kmeans</a></code>), or
hierarchical clustering (<code><a href="stats.html#topic+hclust">hclust</a></code>) after cutting the tree,
produce a list of class assignments along with other structure. To
simplify the interface for the <code><a href="#topic+BootstrapClusterTest">BootstrapClusterTest</a></code>  and
<code><a href="#topic+PerturbationClusterTest">PerturbationClusterTest</a></code>, we have written these routines
that simply extract these cluster assignments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutHclust(data, k, method = "average", metric = "pearson")
cutPam(data, k)
cutKmeans(data, k)
cutRepeatedKmeans(data, k, nTimes)

repeatedKmeans(data, k, nTimes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="justClusters_+3A_data">data</code></td>
<td>
<p>A numerical data matrix</p>
</td></tr>
<tr><td><code id="justClusters_+3A_k">k</code></td>
<td>
<p>The number of classes desired from the algorithm</p>
</td></tr>
<tr><td><code id="justClusters_+3A_method">method</code></td>
<td>
<p>Any valid linkage method that can be passed to the
<code><a href="stats.html#topic+hclust">hclust</a></code> function</p>
</td></tr>
<tr><td><code id="justClusters_+3A_metric">metric</code></td>
<td>
<p>Any valid distance metric that can be passed to the
<code><a href="#topic+distanceMatrix">distanceMatrix</a></code> function</p>
</td></tr>
<tr><td><code id="justClusters_+3A_ntimes">nTimes</code></td>
<td>
<p>An integer; the number of times to repeat the K-means
algorithm with a different random starting point</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the clustering routines used here has a different
structure for storing cluster assignments. The <code><a href="stats.html#topic+kmeans">kmeans</a></code>
function stores the assignments in a &lsquo;cluster&rsquo; attribute.  The
<code><a href="cluster.html#topic+pam">pam</a></code> function uses a &lsquo;clustering&rsquo; attribute.  For
<code><a href="stats.html#topic+hclust">hclust</a></code>, the assignments are produced by a call to the
<code><a href="stats.html#topic+cutree">cutree</a></code> function.
</p>
<p>It has been observed that the K-means algorithm can converge to
different solutions depending on the starting values of the group
centers. We also include a routine (<code>repeatedKmeans</code>) that runs
the K-means algorithm repeatedly, using different randomly generated
staring points each time, saving the best results.
</p>


<h3>Value</h3>

<p>Each of the <code>cut...</code> functions returns a vector of integer values
representing the cluster assignments found by the algorithm.
</p>
<p>The <code>repeatedKmeans</code> function returns a list <code>x</code> with three
components.  The component <code>x$kmeans</code> is the result of the call
to the <code>kmeans</code> function that produced the best fit to the
data. The component <code>x$centers</code> is a matrix containing the list
of group centers that were used in the best call to <code>kmeans</code>.
The component <code>x$withinss</code> contains the sum of the within-group
sums of squares, which is used as the measure of fitness.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cutree">cutree</a></code>,
<code><a href="stats.html#topic+hclust">hclust</a></code>,
<code><a href="stats.html#topic+kmeans">kmeans</a></code>,
<code><a href="cluster.html#topic+pam">pam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data from three different groups
d1 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d3 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
dd &lt;- cbind(d1, d2, d3)

cutKmeans(dd, k=3)
cutKmeans(dd, k=4)

cutHclust(dd, k=3)
cutHclust(dd, k=4)

cutPam(dd, k=3)
cutPam(dd, k=4)

cutRepeatedKmeans(dd, k=3, nTimes=10)
cutRepeatedKmeans(dd, k=4, nTimes=10)

# cleanup
rm(d1, d2, d3, dd)
</code></pre>

<hr>
<h2 id='mahalanobisQC'>Using Mahalanobis Distance and PCA for Quality Control</h2><span id='topic+mahalanobisQC'></span>

<h3>Description</h3>

<p>Compute the Mahalanobis distance of each sample from the center of an
<var>N</var>-dimensional principal component space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobisQC(spca, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobisQC_+3A_spca">spca</code></td>
<td>
<p>object of class <code><a href="#topic+SamplePCA">SamplePCA</a></code> representing the
results of a principal components analysis.</p>
</td></tr>
<tr><td><code id="mahalanobisQC_+3A_n">N</code></td>
<td>
<p>integer scalar specifying the number of components to use when
assessing QC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The theory says that, under the null hypothesis that all samples arise
from the same multivariate normal distribution, the distance from the
center of a <var>D</var>-dimensional principal component space should follow a 
chi-squared distribution with <var>D</var> degrees of freedom. This theory lets
us compute p-values associated with the Mahalanobis distances for
each sample. This method can be used for quality control or outlier
identification.
</p>


<h3>Value</h3>

<p>Returns a data frame containing two columns, with the rows
corresponding to the columns of the original data set on which PCA was
performed. First column is the chi-squared statistic, with <code>N</code>
degrees of freedom. Second column is the associated p-value.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Coombes KR, et al.<br />
<em>Quality control and peak finding for proteomics data collected from
nipple aspirate fluid by surface-enhanced laser desorption and ionization.</em>
Clin Chem 2003; 49:1615-23.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(oompaData)
data(lungData)
spca &lt;- SamplePCA(na.omit(lung.dataset))
mc &lt;- mahalanobisQC(spca, 2)
mc[mc$p.value &lt; 0.01,]
</code></pre>

<hr>
<h2 id='Mosaic'>Class &quot;Mosaic&quot;</h2><span id='topic+Mosaic'></span><span id='topic+Mosaic-class'></span><span id='topic+plot+2CMosaic+2Cmissing-method'></span><span id='topic+pltree+2CMosaic-method'></span><span id='topic+summary+2CMosaic-method'></span>

<h3>Description</h3>

<p>Produce &ldquo;Eisen&rdquo; plots of microarray or proteomics data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mosaic(data,
       sampleMetric="pearson",
       sampleLinkage="average",
       geneMetric="euclid",
       geneLinkage="average",
       usecor=FALSE,
       center=FALSE,
       name="My mosaic")
## S4 method for signature 'Mosaic'
pltree(x, colors, labels, ...)
## S4 method for signature 'Mosaic,missing'
plot(x, main=x@name, center=FALSE,
  scale=c("none", "row", "column"), limits=NULL,
  sampleColors=NULL, sampleClasses=NULL,
  geneColors=NULL, geneClasses=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mosaic_+3A_data">data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_samplemetric">sampleMetric</code></td>
<td>
<p>Any valid distance metric that can be passed to the
<code><a href="#topic+distanceMatrix">distanceMatrix</a></code> function</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_samplelinkage">sampleLinkage</code></td>
<td>
<p>Any valid linkage method that can be passed to the
<code><a href="stats.html#topic+hclust">hclust</a></code> function</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_genemetric">geneMetric</code></td>
<td>
<p>Any valid distance metric that can be passed to the
<code><a href="#topic+distanceMatrix">distanceMatrix</a></code> function</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_genelinkage">geneLinkage</code></td>
<td>
<p>Any valid linkage method that can be passed to the
<code><a href="stats.html#topic+hclust">hclust</a></code> function</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_center">center</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, center the data rows.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_usecor">usecor</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, scale the data rows to have
standard deviation one.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_name">name</code></td>
<td>
<p>character string specifying the name of this object</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_x">x</code></td>
<td>
<p>object of class <code>Mosaic</code></p>
</td></tr>
<tr><td><code id="Mosaic_+3A_scale">scale</code></td>
<td>
<p>Same as in <code><a href="stats.html#topic+heatmap">heatmap</a></code>.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_colors">colors</code></td>
<td>
<p>An optional vector of character strings containing color
names to be used when labeling the trees in the dendrogram. If
provided, then the length should equal the number of columns in the
original data matrix.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_labels">labels</code></td>
<td>
<p>An optional vector of character strings used to label
the leaves in the dendrogram. If omitted, the column names are
used.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_main">main</code></td>
<td>
<p>character string specifying the main title for the plot</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_limits">limits</code></td>
<td>
<p>An numeric vector. If provided, the data is truncated
for display purposes, both above and below, at the minimum and
maximum values of <code>limits</code>.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_samplecolors">sampleColors</code></td>
<td>
<p>An optional character vector containing colors
that will be used to label different sample types with a color bar
across the top of the heat map.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_sampleclasses">sampleClasses</code></td>
<td>
<p>A logical vector or factor used to classify the
samples into groups. Alternatively, an integer specifying the number
<code>k</code> of groups into which to cut the sample dendrogram.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_genecolors">geneColors</code></td>
<td>
<p>An optional character vector containing colors
that will be used to label different gene types with a color bar
along the side of the heat map.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_geneclasses">geneClasses</code></td>
<td>
<p>A logical vector or factor used to classify the
genes into groups. Alternatively, an integer specifying the number
<code>k</code> of groups into which to cut the gene dendrogram.</p>
</td></tr>
<tr><td><code id="Mosaic_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>heatmap</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the earliest papers in the microarray literature used
independent clustering of the genes (rows) and samples (columns) to
produce dendrograms that were plotted along with a red-green heat map
of the centered expression values. Since that time, literally thousand
of additional papers have published variations on these red-green
images. R includes a function, <code><a href="stats.html#topic+heatmap">heatmap</a></code> that builds such
figures.  However, that function is general purpose and has numerous
optional parameters to tweak the display. The purpose of the
<code>Mosaic</code> class is to provide a simplified object-oriented wrapper
around <code><a href="stats.html#topic+heatmap">heatmap</a></code>, which as a side benefit allows us to
keep track of the distance metrics and linkage rules that were used to
produce the resulting figure.
</p>


<h3>Value</h3>

<p>The <code>Mosaic</code> function constructs and returns a valid object of
the <code>Mosaic</code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be created with the <code>Mosaic</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>The <code>matrix</code> containing the numerical data </p>
</dd>
<dt><code>samples</code>:</dt><dd><p>A dendrogram of class <code>hclust</code> produced
by clustering the biological samples (columns of <code>data</code>). </p>
</dd>
<dt><code>genes</code>:</dt><dd><p>A dendrogram of class <code>hclust</code> produced by
clustering the genes (columns of <code>data</code>).</p>
</dd>
<dt><code>sampleMetric</code>:</dt><dd><p>A <code>character</code> string; the distance
metric used to cluster the samples. </p>
</dd>
<dt><code>sampleLinkage</code>:</dt><dd><p>A <code>character</code> string; the linkage
rule used to cluster the samples. </p>
</dd>
<dt><code>geneMetric</code>:</dt><dd><p>A <code>character</code> string; the distance
metric used to cluster the genes. </p>
</dd>
<dt><code>geneLinkage</code>:</dt><dd><p>A <code>character</code> string; the linkage
rule used to cluster the genes. </p>
</dd>
<dt><code>call</code>:</dt><dd><p>An object of class <code>call</code> recording how the
object was constructed. </p>
</dd>
<dt><code>name</code>:</dt><dd><p>A <code>character</code> string; the name of this object. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = Mosaic, y = missing)</code>: Produce the
&ldquo;Eisen&rdquo; plot, using <code><a href="stats.html#topic+heatmap">heatmap</a></code>. </p>
</dd>
<dt>pltree</dt><dd><p><code>signature(x = Mosaic)</code>: Plot the sample class
dendrogram in the object. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = Mosaic)</code>: Write out a
summary of the object. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
P. Roebuck <a href="mailto:proebuck@mdanderson.org">proebuck@mdanderson.org</a>
</p>


<h3>References</h3>

<p>Eisen MB, Spellman PT, Brown PO, Botstein D.<br />
<em>Cluster analysis and display of genome-wide expression patterns.</em><br />
Proc Natl Acad Sci U S A. 1998 Dec 8;95(25):14863-8.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cutree">cutree</a></code>,
<code><a href="stats.html#topic+hclust">hclust</a></code>,
<code><a href="stats.html#topic+heatmap">heatmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Mosaic")

## simulate data from three different sample groups
d1 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d3 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
dd &lt;- cbind(d1, d2, d3)
kind &lt;- factor(rep(c('red', 'green', 'blue'), each=10))

## prepare the Mosaic object
m &lt;- Mosaic(dd,
            sampleMetric='pearson',
            geneMetric='spearman',
            center=TRUE,
            usecor=TRUE)
summary(m)

## The default plot with red-green color map
plot(m, col=redgreen(64))

## change to a blue-yellow color map, and mark the four top splits in the
## sample direction with a color bar along the top
plot(m, col=blueyellow(128), sampleClasses=4,
     sampleColors=c('red', 'green', 'blue', 'black'))

## This time, mark the three classes that we know are there
plot(m, col=blueyellow(128), sampleClasses=kind,
     sampleColors=c('red', 'green', 'blue'))

plot(m, col=blueyellow(128),
     geneClasses=3, geneColors=c('red', 'green', 'black'))

## In addition, mark the top 5 splits in the gene dendrogram
plot(m,
     col=blueyellow(128),
     sampleClasses=kind,
     sampleColors=c('red', 'green', 'black'),
     geneClasses=5,
     geneColors=c('cyan', 'magenta', 'royalblue', 'darkgreen', 'orange'))

## plot the sample dendrogram by itself
cols &lt;- as.character(kind)
pltree(m, labels=1:30, colors=cols)

## cleanup
rm(d1, d2, d3, dd, kind, cols, m)
</code></pre>

<hr>
<h2 id='PCanova'>Class &quot;PCanova&quot;</h2><span id='topic+PCanova'></span><span id='topic+PCanova-class'></span><span id='topic+plot+2CPCanova+2Cmissing-method'></span><span id='topic+pltree+2CPCanova-method'></span><span id='topic+summary+2CPCanova-method'></span>

<h3>Description</h3>

<p>Implements the PCANOVA method for determining whether a putative group
structure is truly reflected in multivariate data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCanova(data, classes, labels, colors, usecor=TRUE)

## S4 method for signature 'PCanova,missing'
plot(x, tag='', mscale=1, cex=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCanova_+3A_data">data</code></td>
<td>
<p>either data frame or matrix with numeric values, or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_labels">labels</code></td>
<td>
<p>character vector used to label points in plots. The
length of the <code>labels</code> vector should equal the number of
columns (samples) in the <code>data</code> matrix. Since only the first
character of each label is used in the plots, these should be unique.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_classes">classes</code></td>
<td>
<p> A subset of the <code>labels</code> used to indicate
distinct classes. Again, the method truncates each class indicator
to a single letter.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_colors">colors</code></td>
<td>
<p>character vector containing color names; this should
be the same length as the vector of <code>labels</code>.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_usecor">usecor</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, standardize the rows of the
data matrix before use.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_x">x</code></td>
<td>
<p>object of class <code>PCanova</code></p>
</td></tr>
<tr><td><code id="PCanova_+3A_tag">tag</code></td>
<td>
<p>character string to name the object, used as part of the
plot title.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_mscale">mscale</code></td>
<td>
<p>A real number. This is a hack; for some reason, the
projection of the sample vectors into the principal component space
computed from the matrix of group means seems to be off by a factor
approximately equal to the square root of the average number of
samples per group. Until we sort out the correct formula, this term
can be adjusted until the group means appear to be in the correct
place in the plots.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_cex">cex</code></td>
<td>
<p>Character expansion factor used only in the plot legend on
the plot of PC correlations.</p>
</td></tr>
<tr><td><code id="PCanova_+3A_...">...</code></td>
<td>
<p>additional graphical parameters passed on to <code>plot</code>
when displaying the principal components plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PCANOVA method was developed as part of the submission that won
the award for best presentation at the 2001 conference on the Critical
Assessment of Microarray Data Analysis (CAMDA;
<a href="http://www.camda.info">http://www.camda.info</a>). The idea is to perform the
equivalent of an analysis of variance (ANOVA) in principal component
(PC) space. Let X(i,j) denote the jth column vector belonging to the
ith group of samples. We can model this as X(i,j) = mu + tau(i) +
E(i,j), where mu is the overall mean vector, tau(i) is the
&ldquo;effects&rdquo; vector for the ith group, and E(i,j) is the vector of
residual errors. We can perform principal components analysis on the
full matrix X containing all the columns X(i,j), on the matrix
containing all the group mean vectors mu + tau(i), and on the residual
matrix containing all the E(i,j) vectors. PCANOVA develops a measure
(&ldquo;PC correlation&rdquo;) for comparing these three sets of principal
components. If the PC correlation is close to 1, then two principal
component bases are close together; if the PC correlation is close to
zero, then two principal components bases are dissimilar. Strong group
structures are recognizable because the PC correlation between the
total-matrix PC space and the group-means PC space is much larger than
the PC correlation between the total-matrix PC space and the residual
PC space. Weak or nonexistent group structures are recognizable
because the relative sizes of the PC correlations is reversed.
</p>


<h3>Value</h3>

<p>The <code>PCanova</code> function returns an object of the <code>PCanova</code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be created by calling the <code>PCanova</code> generator function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>orig.pca</code>:</dt><dd><p>A <code>matrix</code> containing the <code>scores</code>
component from PCA performed on the total matrix.  All principal
components analyses are performed using the <code>SamplePCA</code> class.</p>
</dd>
<dt><code>class.pca</code>:</dt><dd><p>A <code>matrix</code> containing the
<code>scores</code> component from PCA performed on the matrix of
group-mean vectors. </p>
</dd>
<dt><code>resid.pca</code>:</dt><dd><p>A <code>matrix</code> containing the
<code>scores</code> component from PCA performed on the matrix of
residuals. </p>
</dd> 
<dt><code>mixed.pca</code>:</dt><dd><p>A <code>matrix</code> containing the projections
of all the original vectoprs into the principal component space
computed from the matrix of group mean vectors. </p>
</dd>
<dt><code>xc</code>:</dt><dd><p>An object produced by performing hierarchical
clustering on the total data matrix, using <code>hclust</code> with
pearson distance and average linkage.  </p>
</dd>
<dt><code>hc</code>:</dt><dd><p>An object produced by performing hierarchical
clustering on the matrix of group means, using <code>hclust</code> with
pearson distance and average linkage.</p>
</dd>
<dt><code>rc</code>:</dt><dd><p>An object produced by performing hierarchical
clustering on the matrix of residuals, using <code>hclust</code> with
pearson distance and average linkage.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>An integer; the number of samples.</p>
</dd>
<dt><code>class2orig</code>:</dt><dd><p>The <code>numeric</code> vector of PC
correlations relating the total-matrix PCA to the group-means PCA.</p>
</dd> 
<dt><code>class2resid</code>:</dt><dd><p>The <code>numeric</code> vector of PC
correlations relating the residual PCA to the group-means PCA.</p>
</dd>
<dt><code>orig2resid</code>:</dt><dd><p>The <code>numeric</code> vector of PC
correlations relating the total-matrix PCA to the residual PCA.</p>
</dd>
<dt><code>labels</code>:</dt><dd><p>A <code>character</code> vector of plot labels to
indicate the group membership of samples.</p>
</dd>
<dt><code>classes</code>:</dt><dd><p>A <code>character</code> vector of labels
identifying the distinct groups. </p>
</dd>
<dt><code>colors</code>:</dt><dd><p>A character vector of color names used to
indicate the group membership fo samples in plots.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>An object of class <code>call</code> that records how
the object was constructed.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = PCanova, y = missing)</code>: Plot the
results of the PCANOVA test on the data. This uses <code>par</code> to
set up a 2x2 layout of plots. The first three plots show the
sample vectors (color-coded and labeled) in the space spanned by
the first two principal components for each of the there PCAs. The
final plot shows the three sets of PC correlations.  Colors in the
first three plots are determined by the <code>colors</code> slot of the
object, which was set when the object was created. Colors in the
PC correlation plot are determined by the current values of
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$OBSERVED</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$EXPECTED</a></code>, and
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$PERMTEST</a></code>
</p>
</dd>
<dt>pltree</dt><dd><p><code>signature(x = PCanova)</code>: Produce dendrograms of
the three hierarchical clusters of the samples, based on all the
data, the group means, and the residuals. Since this method uses
<code>par</code> to put all three dendrograms in the same window, it
cannot be combined with other plots. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = PCanova)</code>: Write out a
summary of the object. </p>
</dd>
</dl>



<h3>BUGS</h3>

<p>[1] The projection of the sample vectors into the principal component
space of the group-means is off by a scale factor.  The <code>mscale</code>
parameter provides a work-around.
</p>
<p>[2] The pltree method fails if you only supply two groups; this may be
a failure in <code>hclust</code> if you only provide two objects to cluster.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Examples of the output of PCANOVA applied to the NCI60 data set can be found
at <a href="http:/silicovore.com/camda01.html">http:/silicovore.com/camda01.html</a>. The full
description has not been published (out of laziness on the part of the
author of this code). The only description that has appeared in print
is an extremely brief description that can be found in the proceedings of
the CAMDA 2001 conference.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SamplePCA">SamplePCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PCanova")

## simulate data from three groups
d1 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d3 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
dd &lt;- cbind(d1, d2, d3)
## colors that match the groups
cols &lt;- rep(c('red', 'green', 'blue'), each=10)

## compute the PCanova object
pan &lt;- PCanova(dd, c('red', 'green', 'blue'), cols, cols)
summary(pan)

## view the PC plots
plot(pan)

## view the dendrograms
pltree(pan, line=-0.5)

## compare the results when there is no underlying group structure
dd &lt;- matrix(rnorm(100*50, rnorm(100, 0.5)), nrow=100, ncol=50, byrow=FALSE)
cols &lt;- rep(c('red', 'green', 'blue', 'orange', 'cyan'), each=10)
pan &lt;- PCanova(dd, unique(cols), cols, cols)
plot(pan, mscale=1/sqrt(10))

pltree(pan, line=-0.5)

## cleanup
rm(d1, d2, d3, dd, cols, pan)
</code></pre>

<hr>
<h2 id='PerturbationClusterTest'>The PerturbationClusterTest Class </h2><span id='topic+PerturbationClusterTest'></span><span id='topic+PerturbationClusterTest-class'></span><span id='topic+summary+2CPerturbationClusterTest-method'></span>

<h3>Description</h3>

<p>Performs a parametric bootstrap test (by adding independent Gaussian
noise) to determine whether the clusters found by an unsupervised
method appear to be robust in a given data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PerturbationClusterTest(data, FUN, nTimes=100, noise=1, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PerturbationClusterTest_+3A_data">data</code></td>
<td>
<p>A data matrix, numerical data frame, or
<code><a href="Biobase.html#topic+ExpressionSet">ExpressionSet</a></code> object.</p>
</td></tr>
<tr><td><code id="PerturbationClusterTest_+3A_fun">FUN</code></td>
<td>
<p>A <code>function</code> that, given a data matrix,
returns a vector of cluster assignments.  Examples of functions
with this behavior are <code><a href="#topic+cutHclust">cutHclust</a></code>,
<code><a href="#topic+cutKmeans">cutKmeans</a></code>, <code><a href="#topic+cutPam">cutPam</a></code>, and
<code><a href="#topic+cutRepeatedKmeans">cutRepeatedKmeans</a></code>.</p>
</td></tr>
<tr><td><code id="PerturbationClusterTest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the classifying function, <code>FUN</code>.</p>
</td></tr> 
<tr><td><code id="PerturbationClusterTest_+3A_noise">noise</code></td>
<td>
<p>An optional numeric argument; the standard deviation of
the mean zero Gaussian noise added to each measurement during each
bootstrap.  Defaults to 1.</p>
</td></tr> 
<tr><td><code id="PerturbationClusterTest_+3A_ntimes">nTimes</code></td>
<td>
<p>The number of bootstrap samples to collect.</p>
</td></tr>
<tr><td><code id="PerturbationClusterTest_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects should be created using the  <code>PerturbationClusterTest</code>
function, which performs the requested bootstrap on the
clusters. Following the standard R paradigm, the resulting object can be
summarized and plotted to determine the results of the test.
</p>


<h3>Slots</h3>


<dl>
<dt><code>f</code>:</dt><dd><p>A <code>function</code> that, given a data matrix,
returns a vector of cluster assignments.  Examples of functions
with this behavior are <code><a href="#topic+cutHclust">cutHclust</a></code>,
<code><a href="#topic+cutKmeans">cutKmeans</a></code>, <code><a href="#topic+cutPam">cutPam</a></code>, and
<code><a href="#topic+cutRepeatedKmeans">cutRepeatedKmeans</a></code>. 
</p>
</dd>
<dt><code>noise</code>:</dt><dd><p> The standard deviation of the Gaussian noise
added during each bootstrap sample.</p>
</dd>
<dt><code>nTimes</code>:</dt><dd><p>An integer, the number of bootstrap samples
that were collected.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>An object of class <code>call</code>, which records
how the object was produced. </p>
</dd>
<dt><code>result</code>:</dt><dd><p>Object of class <code>matrix</code> containing, for
each pair of columns in the original data, the number of times
they belonged to the same cluster of a bootstrap sample. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+ClusterTest">ClusterTest</a></code>, directly. See that class for
descriptions of the inherited methods <code>image</code> and <code>hist</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = PerturbationClusterTest)</code>:
Write out a summary of the object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Kerr MK, Churchill GJ.<br />
<em>Bootstrapping cluster analysis: Assessing the reliability of
conclusions from microarray experiments.</em><br />
PNAS 2001; 98:8961-8965.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BootstrapClusterTest">BootstrapClusterTest</a></code>,
<code><a href="#topic+ClusterTest">ClusterTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PerturbationClusterTest")

## simulate data from two different groups
d1 &lt;- matrix(rnorm(100*30, rnorm(100, 0.5)), nrow=100, ncol=30, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*20, rnorm(100, 0.5)), nrow=100, ncol=20, byrow=FALSE)
dd &lt;- cbind(d1, d2)
cols &lt;- rep(c('red', 'green'), times=c(30,20))
colnames(dd) &lt;- paste(cols, c(1:30, 1:20), sep='')
## peform your basic hierarchical clustering...
hc &lt;- hclust(distanceMatrix(dd, 'pearson'), method='complete')

## bootstrap the clusters arising from hclust
bc &lt;- PerturbationClusterTest(dd, cutHclust, nTimes=200, k=3, metric='pearson')
summary(bc)

## look at the distribution of agreement scores
hist(bc, breaks=101)

## let heatmap compute a new dendrogram from the agreement
image(bc, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## plot the agreement matrix with the original dendrogram
image(bc, dendrogram=hc, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## bootstrap the results of K-means
kmc &lt;- PerturbationClusterTest(dd, cutKmeans, nTimes=200, k=3)
image(kmc, dendrogram=hc, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## contrast the behavior when all the data comes from the same group
xx &lt;- matrix(rnorm(100*50, rnorm(100, 0.5)), nrow=100, ncol=50, byrow=FALSE)
hct &lt;- hclust(distanceMatrix(xx, 'pearson'), method='complete')
bct &lt;- PerturbationClusterTest(xx, cutHclust, nTimes=200, k=4, metric='pearson')
summary(bct)
image(bct, dendrogram=hct, col=blueyellow(64), RowSideColors=cols, ColSideColors=cols)

## cleanup
rm(d1, d2, dd, cols, hc, bc, kmc, xx, hct, bct)
</code></pre>

<hr>
<h2 id='plotColoredClusters'>Plot Dendrograms with Color-Coded Labels</h2><span id='topic+plotColoredClusters'></span><span id='topic+pcc'></span>

<h3>Description</h3>

<p>Provides an interface to the <code>plot</code> method for
<code><a href="stats.html#topic+hclust">hclust</a></code> that makes it easier to plot dendrograms with
labels that are color-coded, usually to indicate the different levels
of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotColoredClusters(hd, labs, cols, cex = 0.8, main = "", line = 0, ...)
pcc(hd, colors=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotColoredClusters_+3A_hd">hd</code></td>
<td>
<p> An object with S3 class <code>hclust</code>, as produced by the
<code>hclust</code> function.</p>
</td></tr>
<tr><td><code id="plotColoredClusters_+3A_labs">labs</code></td>
<td>
<p> A vector of character strings used to label the leaves
in the dendrogram</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="plotColoredClusters_+3A_cols">cols</code></td>
<td>
<p> A vector of color names suitable for passing to the
<code>col</code> argument of graphics routines.</p>
</td></tr>
<tr><td><code id="plotColoredClusters_+3A_cex">cex</code></td>
<td>
<p> A numeric value; the character expansion parameter of
<code>par</code>.</p>
</td></tr>
<tr><td><code id="plotColoredClusters_+3A_main">main</code></td>
<td>
<p> A character string; the plot title</p>
</td></tr>
<tr><td><code id="plotColoredClusters_+3A_line">line</code></td>
<td>
<p> An integer determining how far away to plot the labels;
see <code><a href="graphics.html#topic+mtext">mtext</a></code> for details.</p>
</td></tr>
<tr><td><code id="plotColoredClusters_+3A_colors">colors</code></td>
<td>
<p> A list; see details.</p>
</td></tr>
<tr><td><code id="plotColoredClusters_+3A_...">...</code></td>
<td>
<p>Any additional graphical parameters that can be supplied
when plotting an <code>hclust</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plotColoredClusters</code> function is used to implement the
<code>pltree</code> methods of the 
<code>Mosaic</code> class and the <code>PCanova</code> class.  It simply bundles
a two step process (first plotting the dendrogram with no labels,
followed by writing the labels in the right places with the desired
colors) into a single unit.
</p>
<p>The <code>pcc</code> function also produces dendrograms with colored
annotations.  However, instead of coloring the labels based on a
single factor, it produces color bars for any number of factors.  The
<code>colors</code> argument should be a list with named components, where
each component should correspond to a factor and a color scheme.
Specifically, the components must themselves be lists with two
components named <code>fac</code> (and containing the factor) and <code>col</code>
(containing a named vector specifying colors for each level of the
factor).
</p>


<h3>Value</h3>

<p>The function has no useful return value; it merely produces a plot.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+hclust">hclust</a></code>,
<code><a href="#topic+Mosaic">Mosaic</a></code>, <code><a href="#topic+PCanova">PCanova</a></code>, <code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data from three different groups
d1 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d3 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
dd &lt;- cbind(d1, d2, d3)

# perform hierarchical clustering using correlation
hc &lt;- hclust(distanceMatrix(dd, 'pearson'), method='average')
cols &lt;- rep(c('red', 'green', 'blue'), each=10)
labs &lt;- paste('X', 1:30, sep='')

# plot the dendrogram with color-coded groups
plotColoredClusters(hc, labs=labs, cols=cols)

# simulate another dataset
fakedata &lt;- matrix(rnorm(200*30), ncol=30)
colnames(fakedata) &lt;- paste("P", 1:30, sep='')
# define two basic factors, with colors
faccol &lt;- list(fac=factor(rep(c("A", "B"), each=15)),
               col=c(A='red', B='green'))
fac2col &lt;- list(fac=factor(rep(c("X", "Y", "Z"), times=10)),
               col=c(X='cyan', Y='orange', Z='purple'))
# add another factor that reverses the colors
BA &lt;- faccol
BA$col &lt;- c(A='blue', B='yellow')
# assemble the list of factors
colors &lt;- list(AB=faccol, XYZ=fac2col, "tricky long name"=fac2col,
               another=BA)
# cluster the samples
hc &lt;- hclust(distanceMatrix(fakedata, "pearson"), "ward")
# plot the results
pcc(hc, colors)


#cleanup
rm(d1, d2, d3, dd, hc, cols, labs)
rm(fakedata, faccol, fac2col, BA, colors)
</code></pre>

<hr>
<h2 id='SamplePCA'>Class &quot;SamplePCA&quot;</h2><span id='topic+SamplePCA'></span><span id='topic+SamplePCA-class'></span><span id='topic+plot+2CSamplePCA+2Cmissing-method'></span><span id='topic+predict+2CSamplePCA-method'></span><span id='topic+screeplot+2CSamplePCA-method'></span><span id='topic+summary+2CSamplePCA-method'></span><span id='topic+identify+2CSamplePCA-method'></span><span id='topic+text+2CSamplePCA-method'></span>

<h3>Description</h3>

<p>Perform principal components analysis on the samples (columns) from a
microarray or proteomics experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SamplePCA(data, splitter=0, usecor=FALSE, center=TRUE)
## S4 method for signature 'SamplePCA,missing'
plot(x, splitter=x@splitter, col, main='', which=1:2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SamplePCA_+3A_data">data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_splitter">splitter</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then splitter
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>splitter</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_center">center</code></td>
<td>
<p>A logical value; should the rows of the data matrix be
centered first?</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_usecor">usecor</code></td>
<td>
<p>A logical value; should the rows of the data matrix be
scaled to have standard deviation 1?</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_x">x</code></td>
<td>
<p>A <code>SamplePCA</code> object</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_col">col</code></td>
<td>
<p>A list of colors to represent each level of the
<code>splitter</code> in the plot. If this parameter is missing, the
function will select colors automatically.</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_main">main</code></td>
<td>
<p>A character string; the plot title</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_which">which</code></td>
<td>
<p>A numeric vector of length two specifying which two principal
components should be included in the plot.</p>
</td></tr>
<tr><td><code id="SamplePCA_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters for <code>plot</code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>The main reason for developing the <code>SamplePCA</code> class is that the
<code><a href="stats.html#topic+princomp">princomp</a></code> function is very inefficient when the number of
variables (in the microarray setting, genes) far exceeds the number of
observations (in the microarray setting, biological samples).  The
<code>princomp</code> function begins by computing the full covariance
matrix, which gets rather large in a study involving tens of thousands
of genes.  The <code>SamplePCA</code> class, by contrast, uses singular
value decomposition (<code><a href="base.html#topic+svd">svd</a></code>) on the original data matrix to
compute the principal components.
</p>
<p>The base functions <code>screeplot</code>, which produces  a barplot of the
percentage of variance explained by each component, and <code>plot</code>,
which produces a scatter plot comparing two selected components
(defaulting to the first two), have been generalized as methods for
the <code>SamplePCA</code> class.  You can add sample labels to the scatter
plot using either the <code>text</code> or <code>identify</code> methods.  One
should, however, note that the current implementaiton of these methods
only works when plotting the first two components.
</p>


<h3>Value</h3>

<p>The <code>SamplePCA</code> function constructs and returns an object of the
<code>SamplePCA</code> class.  We assume that the input data matrix has N
columns (of biological samples) and P rows (of genes). 
</p>
<p>The <code>predict</code> method returns a matrix whose size is the number of
columns in the input by the number of principal components.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be created using the <code>SamplePCA</code> function. In the
simplest case, you simply pass in a data matrix and a logical vector,
<code>splitter</code>, assigning classes to the columns, and the constructor
performs principal components analysis on the column.  The
<code>splitter</code> is ignored by the constructor and is simply saved to
be used by the plotting routines.  If you omit the <code>splitter</code>,
then no grouping structure is used in the plots.
</p>
<p>If you pass <code>splitter</code> as a factor instead of a logical vector,
then the plotting routine will distinguish all levels of the factor.
The code is likely to fail, however, if one of the levels of the
factor has zero representatives among the data columns.
</p>
<p>We can also perform PCA on
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> objects 
from the BioConductor libraries. In this case, we pass in an
<code>ExpressionSet</code> object along with a character string containing the
name of a factor to use for splitting the data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>scores</code>:</dt><dd><p>A <code>matrix</code> of size NxN, where N is the
number of columns in the input, representing the projections of
the input columns onto the first N principal components. </p>
</dd>
<dt><code>variances</code>:</dt><dd><p>A <code>numeric</code> vector of length N; the
amount of the total variance explained by each principal component.</p>
</dd>
<dt><code>components</code>:</dt><dd><p>A <code>matrix</code> of size PxN (the same size
as the input matrix) containing each of the first P principal
components as columns.</p>
</dd>
<dt><code>splitter</code>:</dt><dd><p>A logical vector or factor of length N
classifying the columns into known groups.</p>
</dd>
<dt><code>usecor</code>:</dt><dd><p>A <code>logical</code> value; was the data standardized?</p>
</dd>
<dt><code>shift</code>:</dt><dd><p>A <code>numeric</code> vector of length P; the mean
vector of the input data, which is used for centering by the
<code>predict</code> method.</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>A <code>numeric</code> vector of length P; the
standard deviation of the input data, which is used for scaling by
the <code>predict</code> method.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>An object of class <code>call</code> that records
how the object was created. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = SamplePCA, y = missing)</code>: Plot the
samples in a two-dimensional principal component space. </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = SamplePCA)</code>: Project new
data into the principal component space. </p>
</dd>
<dt>screeplot</dt><dd><p><code>signature(x = SamplePCA)</code>: Produce a bar
chart of the variances explained by each principal component. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = SamplePCA)</code>: Write out a
summary of the object.</p>
</dd>
<dt>identify</dt><dd><p><code>signature(object = SamplePCA)</code>: interactively
identify points in the plot of a <code>SamplePCA</code> object.</p>
</dd>
<dt>text</dt><dd><p><code>signature(object = SamplePCA)</code>: Add sample
identifiers to the scatter plot of a <code>SamplePCA</code> object,
using the base <code>text</code> function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+princomp">princomp</a></code>,
<code><a href="#topic+GenePCA">GenePCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SamplePCA")

## simulate data from three different groups
d1 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d2 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
d3 &lt;- matrix(rnorm(100*10, rnorm(100, 0.5)), nrow=100, ncol=10, byrow=FALSE)
dd &lt;- cbind(d1, d2, d3)
kind &lt;- factor(rep(c('red', 'green', 'blue'), each=10))
colnames(dd) &lt;- paste(kind, rep(1:10, 3), sep='')

## perform PCA
spc &lt;- SamplePCA(dd, splitter=kind)

## plot the results
plot(spc, col=levels(kind))

## mark the group centers
x1 &lt;- predict(spc, matrix(apply(d1, 1, mean), ncol=1))
points(x1[1], x1[2], col='red', cex=2)
x2 &lt;- predict(spc, matrix(apply(d2, 1, mean), ncol=1))
points(x2[1], x2[2], col='green', cex=2)
x3 &lt;- predict(spc, matrix(apply(d3, 1, mean), ncol=1))
points(x3[1], x3[2], col='blue', cex=2)

## check out the variances
screeplot(spc)

## cleanup
rm(d1, d2, d3, dd,kind, spc, x1, x2, x3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
