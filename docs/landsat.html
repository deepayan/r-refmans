<!DOCTYPE html><html><head><title>Help for package landsat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {landsat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BSL'>
<p>Bare Soil Line</p></a></li>
<li><a href='#clouds'>
<p>Create a cloud mask from Landsat bands 1 and 6.</p></a></li>
<li><a href='#ddate'>
<p>Decimal Date</p></a></li>
<li><a href='#dem'>
<p>Digital Elevation Model</p></a></li>
<li><a href='#DOS'>
<p>Dark Object Subtraction</p></a></li>
<li><a href='#ESdist'>
<p>Earth-Sun distance for a given date.</p></a></li>
<li><a href='#georef'>
<p>Simple image-matching georeferencing function.</p></a></li>
<li><a href='#geoshift'>
<p>Shift and pad an image</p></a></li>
<li><a href='#histmatch'>
<p>Histogram matching of an image</p></a></li>
<li><a href='#july'>
<p>Sample Landsat ETM+ data</p></a></li>
<li><a href='#lssub'>
<p>Subset a geotiff image.</p></a></li>
<li><a href='#minnaert'>
<p>Whole-image and pixel-based Minnaert topographic correction of remote sensing data.</p></a></li>
<li><a href='#movingwindow'>
<p>Simple moving window function.</p></a></li>
<li><a href='#nov'>
<p>Sample Landsat ETM+ data</p></a></li>
<li><a href='#PIF'>
<p>Pseudo-Invariant Features</p></a></li>
<li><a href='#radiocorr'>
<p>Radiometric correction of Landsat data</p></a></li>
<li><a href='#RCS'>
<p>Radiometric Control Sets</p></a></li>
<li><a href='#relnorm'>
<p>Relative normalization of an image</p></a></li>
<li><a href='#slopeasp'>
<p>Calculate slope and aspect from elevation data.</p></a></li>
<li><a href='#tasscap'>
<p>Tasseled Cap for Landsat data</p></a></li>
<li><a href='#thermalband'>
<p>Thermal band to temperature conversion.</p></a></li>
<li><a href='#topocorr'>
<p>Topographic correction of remote sensing data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Radiometric and Topographic Correction of Satellite Imagery</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Sarah Goslee [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sarah Goslee &lt;sarah.goslee@usda.gov&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), sp (&ge; 2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, methods, lmodel2, mgcv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf</td>
</tr>
<tr>
<td>Description:</td>
<td>Processing of Landsat or other multispectral satellite imagery. Includes relative normalization, image-based radiometric correction, and topographic correction options. The original package description was published as Goslee (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v043.i04">doi:10.18637/jss.v043.i04</a>&gt;, and details of the topographic corrections in Goslee (2012) &lt;<a href="https://doi.org/10.14358%2FPERS.78.9.973">doi:10.14358/PERS.78.9.973</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/phiala/landsat/issues">https://github.com/phiala/landsat/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-01 20:18:38 UTC; sarahg</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 22:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='BSL'>
Bare Soil Line
</h2><span id='topic+BSL'></span>

<h3>Description</h3>

<p>Finds Bare Soil Line (BSL) and maximum vegetation point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BSL(band3, band4, method = "quantile", ulimit = 0.99, llimit = 0.005, maxval = 255)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSL_+3A_band3">band3</code></td>
<td>

<p>File name or image file (matrix, data frame, or SpatialGridDataFrame) for Landsat band 3 DN (red).
</p>
</td></tr>
<tr><td><code id="BSL_+3A_band4">band4</code></td>
<td>

<p>File name or image file (matrix, data frame, or SpatialGridDataFrame) for Landsat band 4 DN (NIR).
</p>
</td></tr>
<tr><td><code id="BSL_+3A_method">method</code></td>
<td>

<p>Either &quot;quantile&quot; or &quot;minimum&quot; &ndash; describes way in which soil line is identified.
</p>
</td></tr>
<tr><td><code id="BSL_+3A_ulimit">ulimit</code></td>
<td>

<p>Upper limit for quantile of band ratios (ulimit &lt; 1).
</p>
</td></tr>
<tr><td><code id="BSL_+3A_llimit">llimit</code></td>
<td>

<p>Lower limit for quantile of band ratios (llimit &gt; 0).
</p>
</td></tr>
<tr><td><code id="BSL_+3A_maxval">maxval</code></td>
<td>

<p>Maximum value for band data; default of 255 for Landsat 5 and 7.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finding the BSL requires identifying the lowest NIR values for each level of red. The quantile method takes the lowest set of points, those with a NIR/red ratio less than the llimit-th quantile. The minimum value method takes the lowest NIR value for each level of red. However they are found, these points with low NIR for their red values are used in a major axis regression to find the Bare Soil Line.
This function also identifies the full canopy point (maximum vegetation), by using the ulimit to identify the top points, with NIR/red ratio greater than the ulimit-th quantile, and with high NIR values. Red or NIR values of 255 (saturated sensor) are omitted when calculating the BSL.
</p>


<h3>Value</h3>

<table>
<tr><td><code>BSL</code></td>
<td>
<p>Regression coefficients for the Bare Soil Line</p>
</td></tr>
<tr><td><code>top</code></td>
<td>
<p>band 3 and band 4 values for the full canopy point</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Maas, S. J. &amp; Rajan, N. 2010. Normalizing and converting image DC data using scatter plot matching. Remote Sensing 2:1644-1661.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(nov3)
	data(nov4)
	nov.bsl &lt;- BSL(nov3, nov4)
	plot(as.vector(as.matrix(nov3)), as.vector(as.matrix(nov4)))
	abline(nov.bsl$BSL, col="red")
	points(nov.bsl$top[1], nov.bsl$top[2], col="green", cex=2, pch=16)
</code></pre>

<hr>
<h2 id='clouds'>
Create a cloud mask from Landsat bands 1 and 6.
</h2><span id='topic+clouds'></span>

<h3>Description</h3>

<p>Uses Landsat band 1 and band 6 to identify clouds and create a cloud mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clouds(band1, band6, level = 0.0014, buffer=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clouds_+3A_band1">band1</code></td>
<td>

<p>File name or image file (matrix, data frame, or SpatialGridDataFrame) for Landsat band 1.
</p>
</td></tr>
<tr><td><code id="clouds_+3A_band6">band6</code></td>
<td>

<p>File name or image file (matrix, data frame, or SpatialGridDataFrame) for Landsat band 6.
</p>
</td></tr>
<tr><td><code id="clouds_+3A_level">level</code></td>
<td>

<p>Threshold level for cloud/noncloud decision. The default threshold is appropriate for reflectance and temperature values, and must be adjusted for use with DN.
</p>
</td></tr>
<tr><td><code id="clouds_+3A_buffer">buffer</code></td>
<td>

<p>Pixel buffer size to expand around thresholded cloud areas.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clouds are reflective (high) in band 1 and cold (low) in band 6, so the ratio of the two bands is high over clouds. The ratio must be adjusted for data type, whether reflectance, radiance, or DN.
</p>


<h3>Value</h3>

<p>Returns a cloud mask in the same format as band1. Clouds are 1; noncloud areas are NA. Cloud areas are expanded by buffer pixels to ensure that cloud edges are captured.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>This function is loosely based on:
Martinuzzi, S., Gould, W.A., Ramos Gonzales, O.M. 2007. Creating Cloud-Free Landsat ETM+ Data Sets in Tropical Landscapes: Cloud and Cloud-Shadow Removal. USDA Forest Service General Technical Report IITF-GTR-32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(july1)
data(july61)
july.cloud &lt;- clouds(july1, july61)

par(mfrow=c(1,2))
image(july1)
image(july.cloud)

</code></pre>

<hr>
<h2 id='ddate'>
Decimal Date
</h2><span id='topic+ddate'></span>

<h3>Description</h3>

<p>Convert a vector containing year, month, day or individual year, month, day arguments into a decimal date in years. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	ddate(year, month, day)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddate_+3A_year">year</code></td>
<td>

<p>Either a numeric year OR a vector in the form of c(year, month, day). The latter option is so that ddate() can be conveniently used with apply().
</p>
</td></tr>
<tr><td><code id="ddate_+3A_month">month</code></td>
<td>

<p>If year is a single value, must contain the number of the month.
</p>
</td></tr>
<tr><td><code id="ddate_+3A_day">day</code></td>
<td>

<p>If year is a single value, must contain the number of the day.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ddate() will accept a vector with the three date components so that it can be conveniently used with apply() on a data frame containing columns for year, month and day.
</p>


<h3>Value</h3>

<p>The decimal date in years.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	ddate(2001, 5, 15)
</code></pre>

<hr>
<h2 id='dem'>
Digital Elevation Model
</h2><span id='topic+dem'></span>

<h3>Description</h3>

<p>A 30-meter resolution elevation model in SpatialGridDataFrame format that matches the Landsat images nov and july.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dem)</code></pre>


<h3>Details</h3>

<p>Elevations are in meters.
</p>


<h3>Source</h3>

<p>Digital Elevation Models for the United States are available from the United States Geologic Survey, http://www.usgs.gov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(dem)
	dem.slopeasp &lt;- slopeasp(dem)

	par(mfrow=c(1,3))
	image(dem)
	image(dem.slopeasp$slope)
	image(dem.slopeasp$aspect)
</code></pre>

<hr>
<h2 id='DOS'>
Dark Object Subtraction
</h2><span id='topic+DOS'></span>

<h3>Description</h3>

<p>Calculates calibration value for the Dark Object Subtraction (DOS) method of radiometric correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOS(sat = 5, scattering.coef = c(-4, -2, -1, -0.7, -0.5), SHV, SHV.band, gain,
	offset, Grescale, Brescale, sunelev, edist, Esun = c(198.3, 179.6, 153.6, 
	103.1, 22, 8.34), blackadjust = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DOS_+3A_sat">sat</code></td>
<td>

<p>Landsat satellite platform: 5 for TM; 7 for ETM+; 8 for OLI.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_scattering.coef">scattering.coef</code></td>
<td>

<p>Atmospheric scattering coefficient; defaults are from Chavez 1988.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_shv">SHV</code></td>
<td>

<p>Starting Haze Value
</p>
</td></tr>
<tr><td><code id="DOS_+3A_shv.band">SHV.band</code></td>
<td>

<p>Band from which the Starting Haze Value was obtained.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_gain">gain</code></td>
<td>

<p>Band-specific sensor gain. Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_offset">offset</code></td>
<td>

<p>Band-specific sensor offset. Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_grescale">Grescale</code></td>
<td>

<p>Band-specific sensor $G_rescale$ (gain). Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_brescale">Brescale</code></td>
<td>

<p>Band-specific sensor $B_rescale$ (bias). Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_sunelev">sunelev</code></td>
<td>

<p>Sun elevation in degrees
</p>
</td></tr>
<tr><td><code id="DOS_+3A_edist">edist</code></td>
<td>

<p>Earth-Sun distance in AU.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_esun">Esun</code></td>
<td>

<p>Exo-atmospheric solar irradiance, as given by Chander et al. 2009 or others.
</p>
</td></tr>
<tr><td><code id="DOS_+3A_blackadjust">blackadjust</code></td>
<td>

<p>By default, implements 1% adjustment value to compensate for lack of perfectly dark pixels. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dark Object Subtraction method assumes that the darkest parts of an image (water, artificial structures) should be black if not for the effects of atmospheric scatter. Corrections to make it possible to use the black value from one band to correct the remaining bands.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DNfinal.mean</code></td>
<td>
<p> The Dark Object Subtraction value for the complete set of scattering coefficients (Table X in Chavez 1989). </p>
</td></tr>
<tr><td><code>DNfinal.approx</code></td>
<td>
<p> The same table as DNfinal.mean, but using a numerical approximation across the band wavelength instead of the mean wavelength. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Chavez, Jr., P. S. 1988. An improved dark-object subtraction technique for atmospheric scattering correction of multispectral data. Remote Sensing of Environment 24:459-479.
</p>
<p>Chavez, Jr., P. S. 1989. Radiometric calibration of Landsat Thematic Mapper multispectral images. Photogrammetric Engineering and Remote Sensing 55: 1285-1294.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radiocorr">radiocorr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	data(july1)
	data(july3)

	# One approach to choosing a Starting Haze Value is to take
	# the lowest DN value with a frequency greater than some 
	# predetermined threshold, in this case 1000 pixels. 
	SHV &lt;- table(july1@data[,1])
	SHV &lt;- min(as.numeric(names(SHV)[SHV &gt; 1000]))
	# this is used as Lhaze in the radiocorr function

	# G_rescale, B_rescale, sun elevation comes from metadata for the SHV band
	july.DOS &lt;- DOS(sat=7, SHV=SHV, SHV.band=1, Grescale=0.77569, 
		Brescale=-6.20000, sunelev=61.4, 
		edist=ESdist("2002-07-20"))$DNfinal.mean

	# DOS() returns results for the complete set of scattering coefficients
	# need to choose the appropriate one based on general atmospheric conditions
		###	-4.0: Very Clear	SHV &lt;= 55
		###	-2.0: Clear		SHV 56-75
		### 	-1.0: Moderate		SHV 76-95
		###	-0.7: Hazy		SHV 96-115
		###	-0.5: Very Hazy		SHV &gt;115
	# for july, SHV == 70, so use -2.0: Clear
	july.DOS &lt;- july.DOS[ , 2]

	# Use DOS value as Lhaze in radiocorr() for DOS correction to reflectance
	july3.DOSrefl &lt;- radiocorr(july3, Grescale=0.77569, Brescale=-6.20000, 
		sunelev=61.4, edist=ESdist("2002-07-20"), Esun=1533, 
		Lhaze=july.DOS[3], method="DOS")

</code></pre>

<hr>
<h2 id='ESdist'>
Earth-Sun distance for a given date.  
</h2><span id='topic+ESdist'></span>

<h3>Description</h3>

<p>Calculates the estimated Earth-Sun distance in Astronomical Units (AU) for a given date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESdist(adate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESdist_+3A_adate">adate</code></td>
<td>

<p>date in &quot;YYYY-MM-DD&quot; format
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns estimated Earth-Sun distance in AU.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	ESdist("2010-08-30")
</code></pre>

<hr>
<h2 id='georef'>
Simple image-matching georeferencing function.
</h2><span id='topic+georef'></span>

<h3>Description</h3>

<p>Finds best fit between target image and tofix image by minimizing RMSE between the two. The tofix image is moved one pixel at a time horizontally or vertically. Simple automated georeferencing is adequate for some image-processing tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>georef(target, tofix, maxdist = 1000, startx = 0, starty = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="georef_+3A_target">target</code></td>
<td>

<p>A georeferenced base image; can be matrix, dataframe or SpatialGridDataFrame.
</p>
</td></tr>
<tr><td><code id="georef_+3A_tofix">tofix</code></td>
<td>

<p>The image to be georeferenced; can be matrix, dataframe or SpatialGridDataFrame.
</p>
</td></tr>
<tr><td><code id="georef_+3A_maxdist">maxdist</code></td>
<td>

<p>The greatest distance to move the tofix image. If this is exceeded, the function will stop. 
</p>
</td></tr>
<tr><td><code id="georef_+3A_startx">startx</code></td>
<td>

<p>Shift the tofix image this many pixels in the x direction before beginning, to avoid local minimum.
</p>
</td></tr>
<tr><td><code id="georef_+3A_starty">starty</code></td>
<td>

<p>Shift the tofix image this many pixels in the y direction before beginning, to avoid local minimum.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers a simplistic approach to georeferencing using an iterative algorithm that at each step moves the tofix image one pixel in the direction that produces the greatest reduction in RMSE. When RMSE no longer decreases or maxdist is reached, the algorithm stops, assuming that the tofix image now matches the reference target image. This algorithm can produce local minima. Results should always be checked visually.
</p>
<p>Note: this algorithm is only effective with images larger than the samples included with this package. The July and November images are already georectified, but this function will show them as needing considerable adjustment. Images of at least 1000x1000 pixels are necessary for adequate results.
</p>


<h3>Value</h3>

<table>
<tr><td><code>shiftx</code></td>
<td>
<p>The x-direction shift to get the best match (lowest RMSE).</p>
</td></tr>
<tr><td><code>shifty</code></td>
<td>
<p>The y-direction shift to get the best match (lowest RMSE).</p>
</td></tr>
<tr><td><code>initrmse</code></td>
<td>
<p>Initial RMSE between target and tofix images.</p>
</td></tr>
<tr><td><code>currrmse</code></td>
<td>
<p>Lowest RMSE, after shiftx and shifty pixel adjustments. Will be 9999 if maxdist is exceeded.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoshift">geoshift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to use for georeferencing
data(nov3)
data(july3)
july.shift &lt;- georef(nov3, july3, maxdist=50) # match july to november
july3.corr &lt;- geoshift(july3, padx=50, pady=50, july.shift$shiftx, july.shift$shifty)

# only need to run georef once for a particular date
# use the same correction for all bands
data(july4)
july4.corr &lt;- geoshift(july4, padx=50, pady=50, july.shift$shiftx, july.shift$shifty)

</code></pre>

<hr>
<h2 id='geoshift'>
Shift and pad an image
</h2><span id='topic+geoshift'></span>

<h3>Description</h3>

<p>Shifts an image vertically or horizontally and adds a padded border.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoshift(mat, padx, pady, shiftx, shifty, nodata = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoshift_+3A_mat">mat</code></td>
<td>

<p>A matrix, data frame or SpatialGridDataFrame
</p>
</td></tr>
<tr><td><code id="geoshift_+3A_padx">padx</code></td>
<td>

<p>Number of pixels to add as padding in the x direction on each side of the image (along the x-axis). Should be larger than the number of pixels to shift to avoid data loss.
</p>
</td></tr>
<tr><td><code id="geoshift_+3A_pady">pady</code></td>
<td>

<p>Number of pixels to add as padding in the y direction on each side of the image (along the y-axis). Should be larger than the number of pixels to shift to avoid data loss.
</p>
</td></tr>
<tr><td><code id="geoshift_+3A_shiftx">shiftx</code></td>
<td>

<p>Number of pixels to shift (positive or negative) in the x direction (along the x-axis).
</p>
</td></tr>
<tr><td><code id="geoshift_+3A_shifty">shifty</code></td>
<td>

<p>Number of pixels to shift (positive or negative) in the y direction (along the y-axis).
</p>
</td></tr>
<tr><td><code id="geoshift_+3A_nodata">nodata</code></td>
<td>

<p>Value to use for missing data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to correct spatially-referenced images that are off by a few pixels in the x or y directions. It does not warp an image, only slide it. Adding padding to the outside edge makes it possible to match several images even if they are not stored with georeferecing information. geoshift() can be used in conjunction with georef() to automatically match up geospatial images. Note: directions are relative to the image as displayed by the image() command, and not the underlying matrix representation.
</p>


<h3>Value</h3>

<p>Returns data in the same format as the function was given: matrix, data frame, or SpatialGridDataFrame.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georef">georef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
testmat &lt;- matrix(1:9, 3, 3)
geoshift(testmat, 5, 10, 0, 0)
geoshift(testmat, 5, 10, 2, 2)

# to use for georeferencing
data(nov3)
data(july3)
july.shift &lt;- georef(nov3, july3, maxdist=50) # match july to november
july3.corr &lt;- geoshift(july3, padx=50, pady=50, july.shift$shiftx, july.shift$shifty)

# only need to run georef once for a particular date
# use the same correction for all bands
data(july4)
july4.corr &lt;- geoshift(july4, padx=50, pady=50, july.shift$shiftx, july.shift$shifty)


</code></pre>

<hr>
<h2 id='histmatch'>
Histogram matching of an image
</h2><span id='topic+histmatch'></span>

<h3>Description</h3>

<p>Force image x to match target image by matching their histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histmatch(master, tofix, mask, minval = 0, maxval = 255, by = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histmatch_+3A_master">master</code></td>
<td>

<p>The target image, in SpatialGridDataFrame, data frame, matrix or vector format.
</p>
</td></tr>
<tr><td><code id="histmatch_+3A_tofix">tofix</code></td>
<td>

<p>The image to be normalized, in any format.
</p>
</td></tr>
<tr><td><code id="histmatch_+3A_mask">mask</code></td>
<td>

<p>Areas to be omitted, if any, such as a cloud mask. Only NA values within the mask will be used.
</p>
</td></tr>
<tr><td><code id="histmatch_+3A_minval">minval</code></td>
<td>

<p>Lower bound of the possible range of values in target and tofix images.
</p>
</td></tr>
<tr><td><code id="histmatch_+3A_maxval">maxval</code></td>
<td>

<p>Upper bound of the possible range of values in target and tofix images.
</p>
</td></tr>
<tr><td><code id="histmatch_+3A_by">by</code></td>
<td>

<p>Step size to use in constructing histograms. Should be appropriate for minval and maxval of the images.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The histogram of the tofix image will be forced to match that of the target image.
</p>


<h3>Value</h3>

<table>
<tr><td><code>recode</code></td>
<td>
<p>The transformation table used to match the histograms.</p>
</td></tr>
<tr><td><code>newimage</code></td>
<td>
<p>The transformed image, in the same format in which tofix was provided.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relnorm">relnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(nov3)
	data(july3)
	par(mfrow=c(2,2))
	image(nov3)
	image(july3)

	nov3.newR &lt;- relnorm(master=july3, tofix=nov3)
	image(nov3.newR$newimage)

	nov3.newH &lt;- histmatch(master=july3, tofix=nov3)
	image(nov3.newH$newimage)

## End(Not run)
</code></pre>

<hr>
<h2 id='july'>
Sample Landsat ETM+ data
</h2><span id='topic+july'></span><span id='topic+july1'></span><span id='topic+july2'></span><span id='topic+july3'></span><span id='topic+july4'></span><span id='topic+july5'></span><span id='topic+july61'></span><span id='topic+july62'></span><span id='topic+july7'></span>

<h3>Description</h3>

<p>SpatialGridDataFrame containing a 300 x 300 pixel subset (1500 x 1500 m) of the Landsat ETM+ image for path 15, row 32, obtained on 20 July 2002. Each band, including both thermal bands, is contained in a separate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(july1)</code></pre>


<h3>Format</h3>

<p>Images are in SpatialGridDataFrame format. More information is available in the documentation for the sp package.
</p>


<h3>Details</h3>

<p>Date: 2002-07-20 <br />
Satellite: Landsat ETM+ (7) <br />
Sun elevation: 61.4 <br />
Sun azimuth: 125.8 <br />
<br />
<br />
&mdash;&mdash;&ndash; <br /> 
band	Grescale	Brescale <br />
1	0.77569		-6.20 <br />
2	0.79569		-6.40 <br />
3	0.61922		-5.00 <br />
4	0.63725		-5.10 <br />
5	0.12573		-1.00 <br />
7	0.04373		-0.35 <br />
</p>


<h3>Source</h3>

<p>Landsat images can be obtained from the United States Geological Survey at http://landsat.usgs.gov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(july3)
	image(july3)
</code></pre>

<hr>
<h2 id='lssub'>
Subset a geotiff image.
</h2><span id='topic+lssub'></span>

<h3>Description</h3>

<p>Uses GDAL tools to reproject (optional) and subset a geotiff given the center point and the desired size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lssub(filename, outname, centerx, centery, centerepsg, widthx, widthy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lssub_+3A_filename">filename</code></td>
<td>

<p>Filename (and path) to a geotiff image.
</p>
</td></tr>
<tr><td><code id="lssub_+3A_outname">outname</code></td>
<td>

<p>Filename (and path) for subset image.
</p>
</td></tr>
<tr><td><code id="lssub_+3A_centerx">centerx</code></td>
<td>

<p>x coordinate of new center point.
</p>
</td></tr>
<tr><td><code id="lssub_+3A_centery">centery</code></td>
<td>

<p>y coordinate of new center point.
</p>
</td></tr>
<tr><td><code id="lssub_+3A_centerepsg">centerepsg</code></td>
<td>

<p>Projection of the center point coordinates as 5-digit EPSG code. If missing, assume that point and geotiff have the same projection.
</p>
</td></tr>
<tr><td><code id="lssub_+3A_widthx">widthx</code></td>
<td>

<p>Desired width of subset image.
</p>
</td></tr>
<tr><td><code id="lssub_+3A_widthy">widthy</code></td>
<td>

<p>Desired height of subset image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new image will be a subset of size (widthx, widthy) with center point (centerx, centery), with the same pixel size. If the center point coordinates are in a different projection than the original image, they will be reprojected. 
</p>


<h3>Value</h3>

<p>The new image is exported as a geotiff. Nothing is returned within R.
</p>


<h3>Note</h3>

<p>Requires gdalinfo and gdaltransform to be available to the operating system. Only known to work on linux. This function was written to speed processing of multiple files for a specific project, and may be dropped in future releases of the landsat package. On my computer, lssub() is over an order of magnitude faster than reading the image into R, subsetting it, and writing out the result.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: lssub("/data/gis/testimage.tif", "/data/gis/subimage.tif", centerx = 260485, 
	centery = 4527220, centerepsg = 26918, widthx = 50, widthy = 50)
## End(Not run)
</code></pre>

<hr>
<h2 id='minnaert'>
Whole-image and pixel-based Minnaert topographic correction of remote sensing data.
</h2><span id='topic+minnaert'></span>

<h3>Description</h3>

<p>Adds several modified Minnaert corrections to the capabilities of topocorr().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minnaert(x, slope, aspect, sunelev, sunazimuth, na.value = NA, GRASS.aspect=FALSE, 
	IL.epsilon=0.000001, slopeclass = c(1, 5, 10, 15, 20, 25, 30, 45), coverclass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minnaert_+3A_x">x</code></td>
<td>

<p>Image to be corrected, in matrix, data frame, or SpatialGridDataFrame format.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_slope">slope</code></td>
<td>

<p>Slope image of same size and resolution as x.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_aspect">aspect</code></td>
<td>

<p>Aspect image of same size and resolution as x.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_sunelev">sunelev</code></td>
<td>

<p>Sun elevation in degrees.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_sunazimuth">sunazimuth</code></td>
<td>

<p>Sun azimuth in degrees.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_na.value">na.value</code></td>
<td>

<p>Value to use for missing data.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_grass.aspect">GRASS.aspect</code></td>
<td>

<p>Whether aspect is measured according to GRASS defaults (counterclockwise from east) or is measured clockwise from north. If GRASS.aspect=TRUE, aspect is converted to clockwise from north before analysis.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_il.epsilon">IL.epsilon</code></td>
<td>

<p>If IL == 0 (Illumination), some methods will give a topographically-corrected value of Inf due to division by zero. If desired, adding a small increment to zero values eliminates this.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_slopeclass">slopeclass</code></td>
<td>

<p>The classes into which the slope will be divided before calculating k separately for each class.
</p>
</td></tr>
<tr><td><code id="minnaert_+3A_coverclass">coverclass</code></td>
<td>

<p>If present, TRUE/FALSE vector indicating which pixels to use when calculating k. This allows k to be determined separately for different cover classes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the Minnaert k coefficients for the whole image and for the individual slope classes.
</p>


<h3>Value</h3>

<table>
<tr><td><code>allcoef</code></td>
<td>

<p>The Minnaert k for the entire image. This is the value used in topocorr() (though the latter may have been truncated).
</p>
</td></tr>
<tr><td><code>classcoef</code></td>
<td>

<p>A data frame containing the slope class midpoints, number of pixels per class, and k for that class (for the desired cover class, if specified).
</p>
</td></tr>
<tr><td><code>xout</code></td>
<td>

<p>A topographically-corrected image in the same format as x.
</p>
</td></tr>
<tr><td><code>xout</code></td>
<td>

<p>A topographically-corrected image in the same format as x.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Lu, D., Ge, H., He, S., Xu, A., Zhou, G., and Du, H. 2008. Pixel-based Minnaert correction method for reducing topographic effects on a Landsat 7 ETM+ image. Photogrammetric Engineering and Remote Sensing 74:1343-1350.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topocorr">topocorr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# require slope and aspect for topographic correction
	data(dem)
	dem.slopeasp &lt;- slopeasp(dem)

	# use cosine method of topographic correction
	data(july4)
	july4.minpix &lt;- minnaert(july4, dem.slopeasp$slope, dem.slopeasp$aspect, 
		sunelev=61.4, sunazimuth=125.8, slopeclass=c(1, 5, 10, 15, 50))
	july4.minpix$classcoef # all coefficients
</code></pre>

<hr>
<h2 id='movingwindow'>
Simple moving window function.
</h2><span id='topic+movingwindow'></span>

<h3>Description</h3>

<p>Very simple function to apply a kernel to a matrix across a moving window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movingwindow(x, kernel, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movingwindow_+3A_x">x</code></td>
<td>

<p>A matrix.
</p>
</td></tr>
<tr><td><code id="movingwindow_+3A_kernel">kernel</code></td>
<td>

<p>The kernel to be applied to the matrix, for example a Sobel kernel.
</p>
</td></tr>
<tr><td><code id="movingwindow_+3A_na.rm">na.rm</code></td>
<td>

<p>NA handling option to be passed to sum(). If TRUE, NA will be returned if any value under the kernel is NA or NaN, otherwise NA values will be omitted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the calculation of slope and aspect by slopeasp().
</p>


<h3>Value</h3>

<p>Returns the transformed matrix.
</p>


<h3>Note</h3>

<p>Should be rewritten in C for greater efficiency.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slopeasp">slopeasp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(dem)
	dem.smoothed &lt;- movingwindow(dem, matrix(c(1,1,1,1,0,1,1,1,1), 3, 3)/8)

	par(mfrow=c(1,2))
	image(dem)
	image(dem.smoothed)
</code></pre>

<hr>
<h2 id='nov'>
Sample Landsat ETM+ data
</h2><span id='topic+nov'></span><span id='topic+nov1'></span><span id='topic+nov2'></span><span id='topic+nov3'></span><span id='topic+nov4'></span><span id='topic+nov5'></span><span id='topic+nov61'></span><span id='topic+nov62'></span><span id='topic+nov7'></span>

<h3>Description</h3>

<p>SpatialGridDataFrame containing a 300 x 300 pixel subset (1500 x 1500 m) of the Landsat ETM+ image for path 15, row 32, obtained on 25 November 2002. Each band, including both thermal bands, is contained in a separate file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nov1)</code></pre>


<h3>Format</h3>

<p>Images are in SpatialGridDataFrame format. More information is available in the documentation for the sp package.
</p>


<h3>Details</h3>

<p>Date: 2002-11-25 <br />
Satellite: Landsat ETM+ (7) <br />
Sun elevation: 26.2 <br />
Sun azimuth: 159.5 <br />
<br />
<br />
&mdash;&mdash;&ndash; <br /> 
</p>
<p>band	Grescale	Brescale <br />
1	0.77569		-6.20 <br />
2	0.79569		-6.40 <br />
3	0.61922		-5.00 <br />
4	0.63725		-5.10 <br />
5	0.12573		-1.00 <br />
7	0.04373		-0.35 <br />
</p>


<h3>Source</h3>

<p>Landsat images can be obtained from the United States Geological Survey at http://landsat.usgs.gov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(nov3)
	image(nov3)
</code></pre>

<hr>
<h2 id='PIF'>
Pseudo-Invariant Features
</h2><span id='topic+PIF'></span>

<h3>Description</h3>

<p>Pseudo-invariant features identification for relative radiometric normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PIF(band3, band4, band7, level = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PIF_+3A_band3">band3</code></td>
<td>

<p>Landsat band 3, as a filename to be imported, a matrix, data frame, or SpatialGridDataFrame.
</p>
</td></tr>
<tr><td><code id="PIF_+3A_band4">band4</code></td>
<td>

<p>Landsat band 4, as a filename to be imported, a matrix, data frame, or SpatialGridDataFrame.
</p>
</td></tr>
<tr><td><code id="PIF_+3A_band7">band7</code></td>
<td>

<p>Landsat band 7, as a filename to be imported, a matrix, data frame, or SpatialGridDataFrame.
</p>
</td></tr>
<tr><td><code id="PIF_+3A_level">level</code></td>
<td>

<p>Threshold level for identifying PIFs. (0 &lt; level &lt; 1)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pseudo-invariant features (PIFs) are areas such as artificial structures that can reasonably be expected to have a constant reflectance over time, rather than varying seasonally as vegetation does. Differences in PIF reflectance between dates can be assumed to be due to varying atmospheric conditions.
</p>


<h3>Value</h3>

<p>Returns a PIF mask in the same format as the input files, with 1 for pseudo-invariant features and 0 for background data.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Schott, J. R.; Salvaggio, C. &amp; Volchok, W. J. 1988. Radiometric scene normalization using pseudoinvariant features. Remote Sensing of Environment 26:1-16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RCS">RCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# identify pseudo-invariant feature
	data(july3)
	data(july4)
	data(july7)
	july.pif &lt;- PIF(july3, july4, july7)

	# use PIFs to related nov to july Landsat data for band 3
	# properly, would also remove cloudy areas first
	data(nov3)
	# use major axis regression: error in both x and y
	nov.correction &lt;- lmodel2:::lmodel2(july3@data[july.pif@data[,1] == 1, 1] ~ 
	nov3@data[july.pif@data[,1] == 1, 1])$regression.results[2, 2:3]
	nov3.corrected &lt;- nov3
	nov3.corrected@data[,1] &lt;- nov3@data[,1] * nov.correction[2] + nov.correction[1]
</code></pre>

<hr>
<h2 id='radiocorr'>
Radiometric correction of Landsat data
</h2><span id='topic+radiocorr'></span>

<h3>Description</h3>

<p>Implements several different methods for absolute radiometric correction of satellite data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiocorr(x, gain, offset, Grescale, Brescale, sunelev, satzenith = 0, edist,
	Esun, Lhaze, method = "apparentreflectance")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiocorr_+3A_x">x</code></td>
<td>

<p>Image to be corrected, in matrix, data frame, or SpatialGridDataFrame format.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_gain">gain</code></td>
<td>

<p>Band-specific sensor gain. Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_offset">offset</code></td>
<td>

<p>Band-specific sensor offset. Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_grescale">Grescale</code></td>
<td>

<p>Band-specific sensor Grescale (gain). Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_brescale">Brescale</code></td>
<td>

<p>Band-specific sensor Brescale (bias). Require either gain and offset or Grescale and Brescale to convert DN to radiance.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_sunelev">sunelev</code></td>
<td>

<p>Sun elevation in degrees
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_satzenith">satzenith</code></td>
<td>

<p>Satellite sensor zenith angle (0 for Landsat)
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_edist">edist</code></td>
<td>

<p>Earth-Sun distance in AU.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_esun">Esun</code></td>
<td>

<p>Exo-atmospheric solar irradiance, as given by Chandler et al. 2009 or others.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_lhaze">Lhaze</code></td>
<td>

<p>Haze value, such as SHV from DOS() function. Not needed for apparent reflectance.
</p>
</td></tr>
<tr><td><code id="radiocorr_+3A_method">method</code></td>
<td>

<p>Radiometric correction method to be used. There are currently four methods available: &quot;apparentreflectance&quot;, &quot;DOS&quot; (Chavez 1989), &quot;COSTZ&quot;  (Chavez 1996), &quot;DOS4&quot; (SWS+2001).  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses one of four image-based radiometric correction methods to adjust a satellite image to compensate for atmospheric conditions.	
</p>


<h3>Value</h3>

<p>Returns a radiometrically-corrected image in the same format as x.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Chavez, Jr., P. S. 1989. Radiometric calibration of Landsat Thematic Mapper multispectral images. Photogrammetric Engineering and Remote Sensing 55:1285-1294.
</p>
<p>Chavez, Jr., P. S. 1996. Image-based atmospheric corrections revisited and improved. Photogrammetric Engineering and Remote Sensing 62:1025-1036.
</p>
<p>Song, C.; Woodcock, C. E.; Seto, K. C.; Lenney, M. P. &amp; Macomber, S. A. 2001. Classification and change detection using Landsat TM data: when and how to correct atmospheric effects? Remote Sensing of Environment 75:230-244.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DOS">DOS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	data(july1)
	data(july3)

	# One approach to choosing a Starting Haze Value is to take the lowest DN value
	# with a frequency greater than some predetermined threshold, in this case 1000 pixels. 
	SHV &lt;- table(july1@data[,1])
	SHV &lt;- min(as.numeric(names(SHV)[SHV &gt; 1000]))
	# this is used as Lhaze in the radiocorr function

	# Grescale, Brescale, sun elevation comes from metadata for the SHV band
	july.DOS &lt;- DOS(sat=7, SHV=SHV, SHV.band=1, Grescale=0.77569, Brescale=-6.20000,
		sunelev=61.4, edist=ESdist("2002-07-20"))$DNfinal.mean

	# DOS() returns results for the complete set of scattering coefficients
	# need to choose the appropriate one based on general atmospheric conditions
		###	-4.0: Very Clear	SHV &lt;= 55
		###	-2.0: Clear		SHV 56-75
		### 	-1.0: Moderate		SHV 76-95
		###	-0.7: Hazy		SHV 96-115
		###	-0.5: Very Hazy		SHV &gt;115
	# for july, SHV == 70, so use -2.0: Clear
	july.DOS &lt;- july.DOS[ , 2]

	# Use DOS value as Lhaze in radiocorr() for DOS correction to reflectance
	july3.DOSrefl &lt;- radiocorr(july3, Grescale=0.77569, Brescale=-6.20000, 
		sunelev=61.4, edist=ESdist("2002-07-20"), Esun=1533, 
		Lhaze=july.DOS[3], method="DOS")


</code></pre>

<hr>
<h2 id='RCS'>
Radiometric Control Sets
</h2><span id='topic+RCS'></span>

<h3>Description</h3>

<p>The Radiometric Control Sets method of relative radiometric correction for Landsat data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCS(data.tc, level = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RCS_+3A_data.tc">data.tc</code></td>
<td>

<p>The output of tasscap().
</p>
</td></tr>
<tr><td><code id="RCS_+3A_level">level</code></td>
<td>

<p>Threshold level to use (0 &lt; level &lt; 1).	
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Radiometric Control Sets (RCSs) are areas such as artificial structures and large bodies of water that can reasonably be expected to have a constant reflectance over time, rather than varying seasonally as vegetation does. Differences in RCS reflectance between dates can be assumed to be due to varying atmospheric conditions.
Pixels with low greenness and either high or low brightness are identified.
</p>


<h3>Value</h3>

<p>Returns an RCS mask file in the format of the original data (vector, matrix, data frame or SpatialGridDataFrame, as preseved by tasscap()) with 1 for RCS pixels and 0 for background.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Hall, F.; Strebel, D.; Nickeson, J. &amp; Goetz, S. 1991. Radiometric rectification: toward a common radiometric response among multidate, multisensor images. Remote Sensing of Environment 35:11-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PIF">PIF</a></code>, <code><a href="#topic+tasscap">tasscap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# identify radiometric control set
	data(july1)
	data(july2)
	data(july3)
	data(july4)
	data(july5)
	data(july7)
	july.tc &lt;- tasscap("july", 7)
	july.rcs &lt;- RCS(july.tc)

	# use RCS to relate nov to july Landsat data for band 3
	# properly, would also remove cloudy areas first
	data(nov3)
	# use major axis regression: error in both x and y
	nov.correction &lt;- lmodel2:::lmodel2(july3@data[july.rcs@data[,1] == 1, 1] ~ 
		nov3@data[july.rcs@data[,1] == 1, 1])$regression.results[2, 2:3]
	nov3.corrected &lt;- nov3
	nov3.corrected@data[,1] &lt;- nov3@data[,1] * nov.correction[2] + nov.correction[1]

</code></pre>

<hr>
<h2 id='relnorm'>
Relative normalization of an image
</h2><span id='topic+relnorm'></span>

<h3>Description</h3>

<p>Use regression methods to adjust distribution of values in image tofix to match those in the master image. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relnorm(master, tofix, mask, method = "MA", nperm = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relnorm_+3A_master">master</code></td>
<td>

<p>The target image, in SpatialGridDataFrame, data frame, matrix or vector format.
</p>
</td></tr>
<tr><td><code id="relnorm_+3A_tofix">tofix</code></td>
<td>

<p>The image to be normalized, in any format.
</p>
</td></tr>
<tr><td><code id="relnorm_+3A_mask">mask</code></td>
<td>

<p>Areas to be omitted, if any, such as a cloud mask. Only NA values within the mask will be used.
</p>
</td></tr>
<tr><td><code id="relnorm_+3A_method">method</code></td>
<td>

<p>Regression method to be used. OLS: Ordinary Least Squares; MA: Major Axis (recommended); SMA: Standard Major Axis.
</p>
</td></tr>
<tr><td><code id="relnorm_+3A_nperm">nperm</code></td>
<td>

<p>Number of permutations to use for significance testing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression coefficients from tofix ~ master will be used to match the distribution of values of tofix to those in the master image.
</p>


<h3>Value</h3>

<table>
<tr><td><code>regression.results</code></td>
<td>
<p>The regression results from lmodel2</p>
</td></tr>
<tr><td><code>newimage</code></td>
<td>
<p>The transformed image, in the same format in which tofix was provided.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+histmatch">histmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(nov3)
	data(july3)
	par(mfrow=c(2,2))
	image(nov3)
	image(july3)

	nov3.newR &lt;- relnorm(master=july3, tofix=nov3)
	image(nov3.newR$newimage)

	nov3.newH &lt;- histmatch(master=july3, tofix=nov3)
	image(nov3.newH$newimage)

## End(Not run)
</code></pre>

<hr>
<h2 id='slopeasp'>
Calculate slope and aspect from elevation data.
</h2><span id='topic+slopeasp'></span>

<h3>Description</h3>

<p>Uses gridded elevation data to calculate slope and aspect, by default using a 3x3 region. The horizontal resolution and vertical resolution must be in the same units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slopeasp(x, EWres, NSres, EWkernel, NSkernel, smoothing=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slopeasp_+3A_x">x</code></td>
<td>

<p>gridded elevation data, either as a SpatialGridDataFrame, dataframe, or matrix.
</p>
</td></tr>
<tr><td><code id="slopeasp_+3A_ewres">EWres</code></td>
<td>

<p>East-West grid resolution. May be omitted if x is a SpatialGridDataFrame and the horizontal units are the same as the vertical units.
</p>
</td></tr>
<tr><td><code id="slopeasp_+3A_nsres">NSres</code></td>
<td>

<p>North-South grid resolution. May be omitted if x is a SpatialGridDataFrame and the horizontal units are the same as the vertical units.
</p>
</td></tr>
<tr><td><code id="slopeasp_+3A_ewkernel">EWkernel</code></td>
<td>

<p>The kernel to use when calculating the East-West component of slope. If missing, a 3x3 kernel will be used.
</p>
</td></tr>
<tr><td><code id="slopeasp_+3A_nskernel">NSkernel</code></td>
<td>

<p>The kernel to use when calculating the North-South component of slope. If missing, a 3x3 kernel will be used.
</p>
</td></tr>
<tr><td><code id="slopeasp_+3A_smoothing">smoothing</code></td>
<td>

<p>A positive integer describing the additional smoothing to be applied, if any. smoothing=1 (default) means no smoothing will be used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, a 3x3 Sobel filter is used (as is standard in many GIS packages). A larger Sobel filter or a different filter will give varying results. This filter provides the third-order finite difference weighted by reciprocal of distance method proposed by Unwin (1981).
</p>


<h3>Value</h3>

<table>
<tr><td><code>slope</code></td>
<td>
<p>The slope of the DEM, in degrees</p>
</td></tr>
<tr><td><code>aspect</code></td>
<td>
<p>The aspect of the DEM, beginning with north and moving clockwise, and with aspect = 0 where slope = 0.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Unwin, D. 1981. Introductory Spatial Analysis. London: Methuen.
Clarke, K.C.and Lee, S.J. 2007. Spatial resolution and algorithm choice as modifiers of downslope flow computed from Digital Elevation Models. Cartography and Geographic Information Science 34:215-230.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+movingwindow">movingwindow</a></code>, <code><a href="#topic+topocorr">topocorr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(dem)
	dem.slopeasp &lt;- slopeasp(dem)

	par(mfrow=c(1,3))
	image(dem)
	image(dem.slopeasp$slope)
	image(dem.slopeasp$aspect)
</code></pre>

<hr>
<h2 id='tasscap'>
Tasseled Cap for Landsat data
</h2><span id='topic+tasscap'></span>

<h3>Description</h3>

<p>Tasseled cap transformation for Landsat TM, ETM+, or OLI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tasscap(basename, sat = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tasscap_+3A_basename">basename</code></td>
<td>

<p>Base filename (string) to which band numbers are appended, eg &quot;july&quot; for files named &quot;july1&quot;, &quot;july2&quot;, &quot;july3&quot;, etc. Data should be at-sensor reflectance.
</p>
</td></tr>
<tr><td><code id="tasscap_+3A_sat">sat</code></td>
<td>

<p>Landsat satellite platform: 5 for TM; 7 for ETM+; 8 for OLI.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Landsat TM, the coefficients are to be applied to &quot;reflectance factors&quot;, which appear to be the DN.
For ETM+ and OLI, the coefficients are for top-of-atmosphere reflectance.
For both TM and ETM+, the bands to be provided are 1, 2, 3, 4, 5, and 7. For OLI, the bands needed are 2 through 7.
Future updates will allow use of a raster stack rather than separate objects.
</p>


<h3>Value</h3>

<p>If the input files are matrices or data frames, returns a data frame with three columns, one for each component. If the input files are SpatialGridDataFrames, returns a list with one element for each component. In either case three components are returned: Brightness, Greenness, Wetness.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Original papers:
</p>
<p>Baig, M. H. A., Zhang, L., Shuai, T. &amp; Tong, Q. 2014. Derivation of a tasselled cap transformation based on Landsat 8 at-satellite reflectance. Remote Sensing Letters 5:423-431.
</p>
<p>Crist, E. P. 1985. A TM tasseled cap equivalent transformation for reflectance factor data. Remote Sensing of Environment 17:301-306.
</p>
<p>Crist, E. &amp; Kauth, R. 1986. The tasseled cap de-mystified. Photogrammetric Engineering and Remote Sensing 52:81-86. 
</p>
<p>Huang, C., Wylie, B., Yang, L., Homer, C. &amp; Zylstra, G. 2002. Derivation of a tasseled cap transformation based on Landsat 7 at-satellite reflectance. International Journal of Remote Sensing 23:1741-1748.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(july1)
data(july2)
data(july3)
data(july4)
data(july5)
data(july7)
july.tc &lt;- tasscap("july", 7)
</code></pre>

<hr>
<h2 id='thermalband'>
Thermal band to temperature conversion.
</h2><span id='topic+thermalband'></span>

<h3>Description</h3>

<p>Converts Landsat thermal band DN (TM or ETM+ band 6-1 and 6-2) to temperature using default coefficients from Chander et al. 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thermalband(x, band)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thermalband_+3A_x">x</code></td>
<td>

<p>Landsat band 6 Digital Number (DN) in matrix, data frame or SpatialGridDataFrame format.
</p>
</td></tr>
<tr><td><code id="thermalband_+3A_band">band</code></td>
<td>

<p>6 for TM; 61 or 62 for the appropriate ETM+ bands. Any other value will fail.	
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a temperature image in the same format as x.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Coefficients from Chander, G., Markham, B.L., Helder, D.L. 2009. Summary of current radiometric calibration coefficients for Landsat MSS, TM, ETM+, and EO-1 ALI sensors. Remote Sensing of Environment 113:893-903.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(nov61)
	nov.temp1 &lt;- thermalband(nov61, 61)
	image(nov.temp1)
</code></pre>

<hr>
<h2 id='topocorr'>
Topographic correction of remote sensing data.
</h2><span id='topic+topocorr'></span>

<h3>Description</h3>

<p>Implements several different methods for topographic correction of remote sensing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topocorr(x, slope, aspect, sunelev, sunazimuth, method = "cosine", na.value = NA,
	GRASS.aspect=FALSE, IL.epsilon=0.000001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topocorr_+3A_x">x</code></td>
<td>

<p>Image to be corrected, in matrix, data frame, or SpatialGridDataFrame format.
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_slope">slope</code></td>
<td>

<p>Slope image of same size and resolution as x.
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_aspect">aspect</code></td>
<td>

<p>Aspect image of same size and resolution as x.
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_sunelev">sunelev</code></td>
<td>

<p>Sun elevation in degrees.
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_sunazimuth">sunazimuth</code></td>
<td>

<p>Sun azimuth in degrees.
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_method">method</code></td>
<td>

<p>Topographic correction method to be used. There are currently eight methods available: &quot;cosine&quot;, &quot;improvedcosine&quot;, &quot;minnaert&quot;, &quot;ccorrection&quot; (first four from Riano et al. 2003), &quot;minslope&quot; (Minnaert with slope correction, also from Riano et al. 2003), &quot;gamma&quot; (from Richter et al. 2009), &quot;SCS&quot; (Gu and Gillespie 1998, Gao and Zhang 2009), &quot;illumination&quot; (uncorrected illumination).
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_na.value">na.value</code></td>
<td>

<p>Value to use for missing data.
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_grass.aspect">GRASS.aspect</code></td>
<td>

<p>Whether aspect is measured according to GRASS defaults (counterclockwise from east) or is measured clockwise from north. If GRASS.aspect=TRUE, aspect is converted to clockwise from north before analysis.
</p>
</td></tr>
<tr><td><code id="topocorr_+3A_il.epsilon">IL.epsilon</code></td>
<td>

<p>If IL == 0 (Illumination), some methods will give a topographically-corrected value of Inf due to division by zero. If desired, adding a small increment to zero values eliminates this.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses one of the available topographic correction methods to compensate for the effects of slope and aspect on reflectance from the land surface.
</p>


<h3>Value</h3>

<p>Returns a topographically-corrected image in the same format as x.
</p>


<h3>Author(s)</h3>

<p>Sarah Goslee
</p>


<h3>References</h3>

<p>Gao, Y. &amp; Zhang, W. 2009. LULC classification and topographic correction of Landsat-7 ETM+ imagery in the Yangjia River Watershed: the influence of DEM resolution. Sensors 9:1980-1995.
</p>
<p>Gu, D. &amp; Gillespie, A. 1998. Topographic normalization of Landsat TM images of forest based on subpixel sun-canopy-sensor geometry. Remote Sensing of Environment 64:166-175.
</p>
<p>Riano, D., Chuvieco, E., Salas, J. &amp; Aguado, I. 2003. Assessment of different topographic corrections in Landsat-TM data for mapping vegetation types. IEEE Transactions on Geoscience and Remote Sensing 41:1056-1061.
</p>
<p>Richter, R., Kellenberger, T. &amp; Kaufmann, H. 2009. Comparison of topographic correction methods. Remote Sensing 1:184-196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slopeasp">slopeasp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# require slope and aspect for topographic correction
	data(dem)
	dem.slopeasp &lt;- slopeasp(dem)

	# use cosine method of topographic correction
	data(july3)
	july3.topo &lt;- topocorr(july3, dem.slopeasp$slope, dem.slopeasp$aspect, 
		sunelev=61.4, sunazimuth=125.8)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
