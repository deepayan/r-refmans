<!DOCTYPE html><html lang="en"><head><title>Help for package lagged</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lagged}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B-methods'><p>Methods for subsetting defined in package 'lagged'</p></a></li>
<li><a href='#+5B+5B-methods'><p>Methods for '[[' in package 'lagged'</p></a></li>
<li><a href='#+5B+5B+26lt+3B+26ndash+3Bmethods'><p>Methods for '[[&lt;-' in package 'lagged'</p></a></li>
<li><a href='#+5B+26lt+3B+26ndash+3Bmethods'><p>Methods for subset assignment</p></a></li>
<li><a href='#acf2Lagged'><p>Convert &quot;acf&quot; objects to &quot;Lagged&quot; objects</p></a></li>
<li><a href='#dataWithLagNames'><p>Lagged data with named lag dimension</p></a></li>
<li><a href='#fill.slMatrix-methods'><p> Methods for Function fill.slMatrix in Package &lsquo;sarima&rsquo;</p></a></li>
<li><a href='#FlexibleLagged-class'><p>Class FlexibleLagged</p></a></li>
<li><a href='#Lagged'><p>Create Lagged objects</p></a></li>
<li><a href='#Lagged-class'><p>Class Lagged</p></a></li>
<li><a href='#Lagged1d-class'><p>Class Lagged1d</p></a></li>
<li><a href='#Lagged2d-class'><p>Class Lagged2d</p></a></li>
<li><a href='#Lagged3d-class'><p>Class Lagged3d</p></a></li>
<li><a href='#maxLag'>
<p>Give the maximal lag in an object</p></a></li>
<li><a href='#maxLag+26lt+3B-'><p>Change the maximal lag in a lagged object</p></a></li>
<li><a href='#nSeasons'><p>Get the number of seasons from an object</p></a></li>
<li><a href='#pc.omitneg'><p>An internal function</p></a></li>
<li><a href='#sl2acfbase'><p>Convert between vector and season-lag representations</p></a></li>
<li><a href='#slMatrix'><p> Function to create objects from class slMatrix</p></a></li>
<li><a href='#slMatrix-class'><p>Class &quot;slMatrix&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes and Methods for Lagged Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides classes and methods for objects, whose indexing
      naturally starts from zero. Subsetting, indexing and mathematical
      operations are defined naturally between lagged objects and lagged
      and base R objects. Recycling is not used, except for singletons.
      The single bracket operator doesn't drop dimensions by default.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GeoBosh/lagged">https://github.com/GeoBosh/lagged</a> (devel),
<a href="https://geobosh.github.io/lagged/">https://geobosh.github.io/lagged/</a> (doc)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/lagged/issues">https://github.com/GeoBosh/lagged/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>lagged.R utils.R pc20slMatrix.r acfutils.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-07 09:26:05 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgi N. Boshnakov [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-07 15:20:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B-methods'>Methods for subsetting defined in package 'lagged'</h2><span id='topic++5B-methods'></span><span id='topic++5B+2CFlexibleLagged+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+2CFlexibleLagged+2Cnumeric+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CFlexibleLagged+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CLagged+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+2CLagged1d+2Cnumeric+2CANY+2CANY-method'></span><span id='topic++5B+2CLagged2d+2Cnumeric+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CLagged2d+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CLagged3d+2Cnumeric+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CLagged3d+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CslMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CLagged2d+2CANY+2CANY+2Ccharacter-method'></span><span id='topic++5B+2CLagged2d+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CLagged2d+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CFlexibleLagged+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CnonStructure+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CLagged2d+2Ccharacter+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CLagged2d+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CLagged2d+2Ccharacter+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2CLagged2d+2Cmissing+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2CLagged2d+2Cnumeric+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2CLagged2d+2Ccharacter+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for subsetting  defined in package 'lagged'.</p>


<h3>Methods</h3>

<p>Subscripting <code>"Lagged"</code> objects always drops the
Lagged-ness.
</p>
<p>When <code>i</code> is missing, <code>x[]</code>, returns the underlying
data. This is equivalent to using <code>x[0:maxLag(x)]</code>.
</p>
<p>Subscripting (with one index) is defined naturally. It returns the
suitably subscripted <code>data</code> slot (for &quot;FlexibleLagged&quot; it is the
data slot of the data slot).  For indices larger than the maximal lag
the values are <code>NA</code>.
</p>
<p>Currently negative indices work similarly to the standard R indexing
in that negative indices are used to drop elements. However, for
<code class="reqn">k&gt;0</code>, using <code class="reqn">-k</code> as an index drops the element for lag
<code class="reqn">k-2</code>, not <code class="reqn">k</code> (since the subsetting is done by something like
<code>x@data[i+1]</code>). This is implementation detail, so it may be
changed and should not be relied upon.
</p>
<p>The following methods for <code>"["</code> are currently defined in package
&quot;lagged&quot;: 
</p>

<dl>
<dt><code>signature(x = "FlexibleLagged", i = "missing", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "FlexibleLagged", i = "numeric", j = "missing", 
          drop = "logical")</code></dt><dd>

</dd><dt><code>signature(x = "FlexibleLagged", i = "numeric", j = "missing", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged", i = "missing", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged1d", i = "numeric", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "numeric", j = "missing", 
          drop = "logical")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "numeric", j = "missing", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged3d", i = "numeric", j = "missing", 
          drop = "logical")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged3d", i = "numeric", j = "missing", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "slMatrix", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "ANY", j = "ANY", drop = "character")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "missing", j = "numeric", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "numeric", j = "numeric", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "FlexibleLagged", i = "missing", j = "missing", 
          drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "ANY", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "nonStructure", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "character", j = "missing", 
          drop = "logical")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "character", j = "missing", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "character", j = "character", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "missing", j = "character", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "numeric", j = "character", 
          drop = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "character", j = "numeric", 
          drop = "missing")</code></dt><dd>

</dd></dl>


<hr>
<h2 id='+5B+5B-methods'>Methods for '[[' in package 'lagged'</h2><span id='topic++5B+5B-methods'></span><span id='topic++5B+5B+2CFlexibleLagged+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CLagged+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+2CLagged2d+2Cnumeric+2Clogical-method'></span><span id='topic++5B+5B+2CLagged2d+2Cnumeric+2Cnumeric-method'></span><span id='topic++5B+5B+2CslMatrix+2Cnumeric+2CANY-method'></span><span id='topic++5B+5B+2CLagged2d+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+5B+2CLagged2d+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+2CFlexibleLagged+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+5B+2CFlexibleLagged+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for '[[' in package 'lagged'.</p>


<h3>Methods</h3>

<p>Indexing with &quot;[[&quot; returns the value for the specified lag.
The index should be a single number. 
</p>
<p>This is the recommended way to extract the value at a single index.
</p>

<dl>
<dt><code>signature(x = "FlexibleLagged", i = "ANY", j = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged", i = "numeric", j = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "numeric", j = "logical")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "numeric", j = "numeric")</code></dt><dd>

</dd><dt><code>signature(x = "slMatrix", i = "numeric", j = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "missing", j = "numeric")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged2d", i = "numeric", j = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "FlexibleLagged", i = "missing", j = "numeric")</code></dt><dd>

</dd><dt><code>signature(x = "FlexibleLagged", i = "numeric", j = "missing")</code></dt><dd>

</dd></dl>


<h3>Examples</h3>

<pre><code class='language-R'>## for 1d objects the difference of '[' and '[[' is not visible
(acv1 &lt;- acf2Lagged(acf(ldeaths, plot = FALSE)))
acv1[1]
acv1[[1]]

## in higher dimenions it matters
acv2 &lt;- acf2Lagged(acf(ts.union(mdeaths, fdeaths), plot = FALSE))
acv2[0]   # array
acv2[[0]] # matrix

## as in standard R conventions, '[' can select arbitrary number of elements
acv2[0:1]
## ... while '[[' selects only one, so this is an error:
## Not run: 
acv2[[0:1]]

## End(Not run)

## Lagged2
m &lt;- matrix(10:49, nrow = 4, byrow = TRUE)
m_lagged &lt;- Lagged(m)
m_lagged

## one index: lag
m_lagged[0:1]
m_lagged[0]   # column vector
m_lagged[[0]] # numeric
## two indices: first is row, second is lag
m_lagged[1 , 0]     # '[' doesn't drop dimensions
m_lagged[1 , 0:3]

m_lagged[[1 , 0]]   # '[[' does drop dimensions
m_lagged[[1 , 0:3]]
m_lagged[[1, TRUE]] # the whole first row, as numeric

m_lagged[1:2 , 0:3] # ok, a matrix
## ... but the first arg. of '[[' must be of length one,
## so this throws error:
## Not run: 
m_lagged[[1:2 , 0:3]]

## End(Not run)
</code></pre>

<hr>
<h2 id='+5B+5B+26lt+3B+26ndash+3Bmethods'>Methods for '[[&lt;-' in package 'lagged'</h2><span id='topic++5B+5B+3C--methods'></span><span id='topic++5B+5B+3C-+2CLagged+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods for '[[&lt;-' in package 'lagged'.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "Lagged", i = "numeric")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic++5B+5B-methods">[[-methods</a></code>
</p>

<hr>
<h2 id='+5B+26lt+3B+26ndash+3Bmethods'>Methods for subset assignment</h2><span id='topic++5B+3C--methods'></span><span id='topic++5B+3C-+2CFlexibleLagged+2Cmissing-method'></span><span id='topic++5B+3C-+2CFlexibleLagged+2Cnumeric-method'></span><span id='topic++5B+3C-+2CLagged1d+2Cnumeric-method'></span><span id='topic++5B+3C-+2CLagged+2Cmissing-method'></span><span id='topic++5B+3C-+2CLagged2d+2Cnumeric-method'></span><span id='topic++5B+3C-+2CLagged3d+2Cnumeric-method'></span><span id='topic++5B+3C-+2CslMatrix+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for subset assignment.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "FlexibleLagged", i = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "FlexibleLagged", i = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(x = "Lagged1d", i = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(x = "Lagged", i = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "Lagged2d", i = "numeric")</code></dt><dd>

</dd><dt><code>signature(x = "Lagged3d", i = "numeric")</code></dt><dd>

</dd><dt><code>signature(x = "slMatrix", i = "ANY")</code></dt><dd>

</dd></dl>

<hr>
<h2 id='acf2Lagged'>Convert &quot;acf&quot; objects to &quot;Lagged&quot; objects</h2><span id='topic+acf2Lagged'></span>

<h3>Description</h3>

<p>Convert &quot;acf&quot; objects to &quot;Lagged&quot; objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf2Lagged(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf2Lagged_+3A_x">x</code></td>
<td>

<p>an object from &quot;S3&quot; class &quot;acf&quot;, typically obtained from
<code>acf()</code> and related functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>acf2Lagged()</code> converts objects produced by <code>acf()</code> and
friends to suitable &quot;Lagged&quot; objects.
</p>
<p>Partial autocorrelations obtained from <code>acf()</code> do not contain
value for lag zero. <code>acf2Lagged()</code> puts the number 1 at lag zero
in the univariate case and a matrix of NA's in the multivariate case.
</p>


<h3>Value</h3>

<p>an object from class &quot;Lagged1d&quot; (univariate case)
or &quot;Lagged3d&quot; (multivariate case)
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## using examples from help(acf)
lh_acf &lt;- acf2Lagged(acf(lh))

lh_acf[0:5]
acf(lh, plot = FALSE)$acf[1 + 0:5] # same

acf(ts.union(mdeaths, fdeaths))$acf[15,,]

deaths_mts &lt;- ts.union(mdeaths, fdeaths)
deaths_acf &lt;- acf2Lagged(acf(deaths_mts))
base_acf &lt;- acf(deaths_mts)

## rho_14
deaths_acf[14]
base_acf$acf[1 + 14, , ] # same
## this is different and maybe surprising to some:
base_acf[14]
## (see also examples in \link{Lagged})
</code></pre>

<hr>
<h2 id='dataWithLagNames'>Lagged data with named lag dimension</h2><span id='topic+dataWithLagNames'></span>

<h3>Description</h3>

<p>Get the data from a Lagged object and ensure that the lag dimension is
named
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataWithLagNames(object, prefix = "Lag_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataWithLagNames_+3A_object">object</code></td>
<td>
<p>an object inheriting from &quot;Lagged&quot;.</p>
</td></tr>
<tr><td><code id="dataWithLagNames_+3A_prefix">prefix</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dataWithLagNames()</code> extracts the data part from a lagged object and
gives names to the lag dimension, if it is not already named.
</p>
<p>This function is mainly used for programming, particularly in
<code>show()</code> methods for lagged objects..
</p>


<h3>Value</h3>

<p>The data part with names as described in Details.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Lagged(drop(acf(ldeaths, plot = FALSE)$acf))
## there are no names for the lags:
names(x) # NULL
## but the print method inserts default "Lag_N" names
x
## This sets the names to their defaults:
x1 &lt;- dataWithLagNames(x)
names(x1)
## ... and this sets non-default prefix:
x2 &lt;- dataWithLagNames(x, "L")
names(x2)
x2
</code></pre>

<hr>
<h2 id='fill.slMatrix-methods'> Methods for Function fill.slMatrix in Package &lsquo;sarima&rsquo; </h2><span id='topic+fill.slMatrix'></span><span id='topic+fill.slMatrix-methods'></span><span id='topic+fill.slMatrix+2CANY+2CANY-method'></span><span id='topic+fill.slMatrix+2Cmatrix+2Cfunction-method'></span><span id='topic+fill.slMatrix+2Cmatrix+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Provides various ways for filling a matrix object with values
according to the conventions of class slMatrix. This is a generic
function. There are methods for values given in a matrix or computed
by a function. The arguments of the function or the indices of the
matrix may follow a variety of conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill.slMatrix(m, f, period, maxlag, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill.slMatrix-methods_+3A_m">m</code></td>
<td>
<p> the matrix to be filled with values </p>
</td></tr>
<tr><td><code id="fill.slMatrix-methods_+3A_f">f</code></td>
<td>
<p> a function whose evaluation produces the entries for m </p>
</td></tr>
<tr><td><code id="fill.slMatrix-methods_+3A_period">period</code></td>
<td>
<p> number of seasons in a cycle </p>
</td></tr>
<tr><td><code id="fill.slMatrix-methods_+3A_maxlag">maxlag</code></td>
<td>
<p> the maximal lag </p>
</td></tr>
<tr><td><code id="fill.slMatrix-methods_+3A_type">type</code></td>
<td>
<p> the indexing convention - &quot;sl&quot; (default) stands for a
standard season-lag pair, &quot;tt&quot; is for time-time pair, &quot;tl&quot; is for
time-lag pair, see ... for details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal representation for autocovariances and other quantities
related to periodic correlation is a matrix with one row for each
season. Methods for this generic provide a way to convert external
structures to this format.
</p>
<p><code>slMatrix</code> calls <code>fill.slMatrix</code> when called with
appropriate argument <code>f</code>.
</p>
<p>todo: need better explanation here!
</p>


<h3>Value</h3>

<p>the matrix filled with the values as required
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(m = "ANY", f = "ANY")</code></dt><dd>
<p>Issue an error message and stop. The default behaviour is not to allow
filling with values from unknown objects.
</p>
</dd>
<dt><code>signature(m = "matrix", f = "function")</code></dt><dd>
<p>Fill the values by evaluating a function.  The arguments of the
function may be in &quot;sl&quot;, &quot;tt&quot; or &quot;tl&quot; format.
</p>
</dd>
<dt><code>signature(m = "matrix", f = "matrix")</code></dt><dd>
<p>Fill the values of the slMatrix object from a matrix. The entries may
be arranged in &quot;sl&quot;, &quot;tt&quot; or &quot;tl&quot; format.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boshnakov GN and Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral
properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), pp. 349&ndash;368.
ISSN 0143-9782, doi: <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">10.1111/j.1467-9892.2009.00617.x</a>.
</p>

<p>Boshnakov GN and Lambert-Lacroix S (2012).
&ldquo;A periodic Levinson-Durbin algorithm for entropy maximization.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>56</b>, pp. 15&ndash;24.
ISSN 0167-9473, doi: <a href="https://doi.org/10.1016/j.csda.2011.07.001">10.1016/j.csda.2011.07.001</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0167947311002556">https://www.sciencedirect.com/science/article/pii/S0167947311002556</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slMatrix">slMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># :todo:
</code></pre>

<hr>
<h2 id='FlexibleLagged-class'>Class FlexibleLagged</h2><span id='topic+FlexibleLagged-class'></span>

<h3>Description</h3>

<p>Class FlexibleLagged.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FlexibleLagged",
  data, ...)</code>,
see also convenience function <code><a href="#topic+Lagged">Lagged</a></code>,
</p>
<p>&quot;FlexibleLagged&quot; is used mainly in programming as a superclass of
classes which need to inherit from all &quot;Lagged&quot; classes.
It can represent objects from any subclass of
&quot;Lagged&quot;. Methods are defined, such that the internal representation is
transparent.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"Lagged"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Lagged-class">Lagged</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "FlexibleLagged", i = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "FlexibleLagged", i = "missing")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "FlexibleLagged", i = "missing")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "FlexibleLagged", i = "numeric")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lagged">Lagged</a></code>,
<code><a href="#topic+Lagged1d-class">Lagged1d</a></code>,
<code><a href="#topic+Lagged2d-class">Lagged2d</a></code>,
<code><a href="#topic+Lagged3d-class">Lagged3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lagged1d
v &lt;- 1:12
v_lagged &lt;- Lagged(v)
v_lagged
identical(v_lagged, new("Lagged1d", data = v)) # TRUE
v_lagged[0:2] # v[1:3]
v_lagged[[0]] # 1

## Lagged2d
m &lt;- matrix(1:12, nrow = 4)
m_lagged &lt;- Lagged(m)
m_lagged
identical(m_lagged, new("Lagged2d", data = m)) # TRUE
m_lagged[0] # matrix with 1  column
m_lagged[[0]] # numeric

## Lagged3d
a &lt;- array(1:24, dim = c(2, 3, 4))
a_lagged &lt;- Lagged(a)
identical(a_lagged, new("Lagged3d", data = a)) # TRUE

dim(a_lagged[0]) # c(2,3,1)
a_lagged[0]
a[ , , 1, drop = FALSE]

dim(a_lagged[[0]]) # c(2,3)
a_lagged[[0]]
a[ , , 1, drop = TRUE]

## as above "FlexibleLagged"
## 1d
v_flex &lt;- new("FlexibleLagged", data = v)
identical(v_flex@data, v_lagged) # TRUE
v_flex[0]   # = v_lagged[0]
v_flex[[0]] # = v_lagged[[0]]

## 2d
m_flex &lt;- new("FlexibleLagged", data = m)
identical(m_flex@data, m_lagged) # TRUE
m_flex[0]   # = m_lagged[0]
m_flex[[0]] # = m_lagged[[0]]

## 3d
a_flex &lt;- new("FlexibleLagged", data = a)
identical(a_flex@data, a_lagged) # TRUE
a_flex[0]   # = a_lagged[0]
a_flex[[0]] # = a_lagged[[0]]
</code></pre>

<hr>
<h2 id='Lagged'>Create Lagged objects</h2><span id='topic+Lagged'></span>

<h3>Description</h3>

<p>Create objects inheriting from Lagged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lagged(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lagged_+3A_data">data</code></td>
<td>
<p>suitable data, see Details.</p>
</td></tr>
<tr><td><code id="Lagged_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>new()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Lagged</code> creates an object inheriting from <code>"Lagged"</code>. The
exact class depends on argument <code>data</code>. This is
the easiest way to create lagged objects.
</p>
<p>If <code>data</code> is a vector, matrix or 3D array, the result is
&quot;Lagged1d&quot;, &quot;Lagged2d&quot; and &quot;Lagged3d&quot;, respectively.
If <code>data</code> inherits from <code>"Lagged"</code>, the result is
&quot;FlexibleLagged&quot;.
</p>


<h3>Value</h3>

<p>a suitable <code>"Lagged"</code> object, as described in Details
</p>


<h3>Note</h3>

<p>I am considering making <code>Lagged</code> generic.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>the specific classes
<code><a href="#topic+Lagged1d-class">Lagged1d</a></code>,
<code><a href="#topic+Lagged2d-class">Lagged2d</a></code>,
<code><a href="#topic+Lagged3d-class">Lagged3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a discrete distribution with outcomes 0,1,2,3,4,5,6:
v &lt;- dbinom(0:6, size = 6, p = 0.5)
bin6 &lt;- Lagged(v)

## names are used, if present:
names(v) &lt;- paste0("P(x=", 0:6, ")")
bin6a &lt;- Lagged(v)
bin6a
## subsetting drops the laggedness:
bin6a[1:3]
bin6a[]
bin6a[0:2]
## to resize (shrink or extend) the object use 'maxLag&lt;-':
s8 &lt;- s2 &lt;- bin6a
maxLag(s2) &lt;- 2
s2
## extending inserts NA's:
maxLag(s8) &lt;- 8
s8
## use assignment to extend with specific values:
s8a &lt;- bin6a
s8a[7:8] &lt;- c("P(x=7)" = 0, "P(x=8)" = 0)
s8a

## adapted from examples for acf()
## acf of univariate ts
acv1 &lt;- acf(ldeaths, plot = FALSE)
class(acv1) # "acf"
a1 &lt;-  drop(acv1$acf) 
class(a1) # numeric

la1 &lt;- Lagged(a1) # 1d lagged object from 'numeric':
Lagged(acv1)      # 1d lagged object from 'acf':

## acf of multivariate ts
acv2 &lt;- acf(ts.union(mdeaths, fdeaths), plot = FALSE)
class(acv2) # "acf"
a2 &lt;-  acv2$acf
class(a2) # 3d array
dim(a2)

la2a &lt;- acf2Lagged(acv2) # explicitly convert 'acf' to lagged object
Lagged(acv2)            # equivalently, just use Lagged()
identical(la2a, Lagged(acv2)) # TRUE

la2a[0]    # R_0,  indexing lagged object
a2[1, , ]  # same, indexing array data from 'cf' object
acv2[0]    # same, indexing 'acf' object

la2a[1]    # R_1
a2[2, , ]  # same
acv2[1/12] # transposed, see end of this example section as to why use 1/12

la2a[2]    # R_1
a2[3, , ]  # same
acv2[2/12] # transposed, see end of this example section as to why use 1/12

## multiple lags
la2a[0:1]        # native indexing with lagged object
a2[1:2, , ]      # different ordering
acv2$acf[1:2, ,] # also different ordering

## '[' doesn't drop a dimension even when it is of length 1:
la2a[0]
la2a[1]

## to get a singleton element, use '[[':
la2a[[0]]
la2a[[1]]

## arithmetic and math operators
-la1
+la1

2*la1
la1^2
la1 + la1^2

abs(la1)
sinpi(la1)
sqrt(abs(la1))

## Summary group
max(la1)
min(la1)
range(la1)
prod(la1)
sum(la1)
any(la1 &lt; 0)
all(la1 &gt;= 0)

## Math2 group
round(la1)
round(la1, 2)
signif(la1)
signif(la1, 4)

## The remaining examples below are only relevant
## for users comparing to indexing of 'acf'
## 
## indexing in base R acf() is somewhat misterious, so an example with
## DIY computation of lag_1 autocovariance matrix
n &lt;- length(mdeaths)
tmpcov &lt;- sum((mdeaths - mean(mdeaths)) * (fdeaths - mean(fdeaths)) ) / n
msd &lt;- sqrt(sum((mdeaths - mean(mdeaths))^2)/n)
fsd &lt;- sqrt(sum((fdeaths - mean(fdeaths))^2)/n)
tmpcov1 &lt;- sum((mdeaths - mean(mdeaths))[2:n] *
               (fdeaths - mean(fdeaths))[1:(n-1)] ) / n
tmpcov1 / (msd * fsd)

la2a[[1]][1,2] - tmpcov1 / (msd * fsd)  # only numerically different
## the raw acf in the 'acf' object is not surprising:
la2a[[1]][1,2] == acv2$acf[2, 1, 2] # TRUE
## ... but this probably is:
acv2[1]
## the ts here is monthly but has unit of lag 'year'
## so acv2[1] asks for lag 1 year = 12 months, thus
acv2[1/12]
all( acv2$acf[13, , ] == drop(acv2[1]$acf) )    # TRUE
all( acv2$acf[2, , ]  == drop(acv2[1/12]$acf) ) # TRUE
all( la2a[[1]]        == drop(acv2[1/12]$acf) ) # TRUE



</code></pre>

<hr>
<h2 id='Lagged-class'>Class Lagged</h2><span id='topic+Lagged-class'></span>

<h3>Description</h3>

<p>Class Lagged.</p>


<h3>Objects from the Class</h3>

<p>This class serves as a base class for objects with natural
indexing starting from zero. It is a virtual class, no objects can be
created from it.
</p>
<p>Arithmetic and other operations are defined. They return objects
strictly from the core &quot;Lagged&quot; classes, even if the arguments are from
classes inheriting from the core &quot;Lagged&quot; classes. Of course, for such classes
specialised methods can be defined to keep the class when appropriate.
For example, the sum of two autocovariance functions is an
autocovariance function, but their difference may not be a valid one.
</p>
<p>In arithmetic operations between &quot;Lagged&quot; objects the arguments are made
of equal length by filling in NA's.  When one of the operands is not
&quot;Lagged&quot;, the recycling rule is applied only if that argument is a
singleton.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"ANY"</code>. Subclasses of
&quot;Lagged&quot; may restrict the class of this slot.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "Lagged", i = "missing", j = "ANY", drop = "ANY")</code>:
In this case (i.e., <code>i</code> is missing) <code>[]</code>, returns the
underlying data. This is equivalent to using
<code>x[1:maxLag(x)]</code>.
</p>
</dd>
<dt>maxLag</dt><dd><p><code>signature(object = "Lagged")</code>:
Gives the maximal lag in the object.
</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "Lagged", i = "numeric")</code>: ... </p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x = "Lagged", i = "numeric")</code>: ... </p>
</dd>

<dt>[&lt;-</dt><dd><p><code>signature(x = "Lagged", i = "missing")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "Lagged", to = "array")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "Lagged", to = "matrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "Lagged", to = "vector")</code>: ... </p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "Lagged")</code>: ... </p>
</dd>
<dt>Math2</dt><dd><p><code>signature(x = "Lagged")</code>: ... </p>
</dd>
<dt>maxLag&lt;-</dt><dd><p><code>signature(object = "Lagged")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "FlexibleLagged", e2 = "Lagged")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "Lagged", e2 = "FlexibleLagged")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "Lagged", e2 = "Lagged")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "Lagged", e2 = "missing")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "Lagged", e2 = "vector")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "vector", e2 = "Lagged")</code>: ... </p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "Lagged")</code>: ... </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>function <code><a href="#topic+Lagged">Lagged</a></code> which creates objects from suitable
subclasses of <code>"Lagged"</code>,
and also
<code><a href="#topic+Lagged1d-class">Lagged1d</a></code>,
<code><a href="#topic+Lagged2d-class">Lagged2d</a></code>,
<code><a href="#topic+Lagged3d-class">Lagged3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lagged(1:12)                   # =&gt; Lagged1d
Lagged(matrix(1:12, ncol = 3)) # =&gt; Lagged2d
Lagged(array(1:24, dim = 2:4))  # =&gt; Lagged3d

## equivalently:       
new("Lagged1d", data = 1:12)                   # =&gt; Lagged1d
new("Lagged2d", data = matrix(1:12, ncol = 3)) # =&gt; Lagged2d
new("Lagged3d", data = array(1:24, dim = 2:4)) # =&gt; Lagged3d
</code></pre>

<hr>
<h2 id='Lagged1d-class'>Class Lagged1d</h2><span id='topic+Lagged1d-class'></span>

<h3>Description</h3>

<p>Class Lagged1d.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Lagged(v)</code> or
<code>new("Lagged1d", data = v)</code>, where <code>v</code> is a vector.
<code>new("Lagged1d", ...)</code> also works.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"vector"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Lagged-class">Lagged</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "Lagged1d", i = "numeric")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "Lagged1d", i = "numeric", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Lagged1d")</code>: ... </p>
</dd>
<dt>whichLagged</dt><dd><p><code>signature(x = "Lagged1d", y = "missing")</code>: ... </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lagged">Lagged</a></code>,
<code><a href="#topic+Lagged2d-class">Lagged2d</a></code>,
<code><a href="#topic+Lagged3d-class">Lagged3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- cos(2*pi*(0:10)/10)
new("Lagged1d", data = v) ## ok, but Lagged() is more convenient
x &lt;- Lagged(v)
class(x) # Lagged1d
x
x[0]
x[0:3]
</code></pre>

<hr>
<h2 id='Lagged2d-class'>Class Lagged2d</h2><span id='topic+Lagged2d-class'></span>

<h3>Description</h3>

<p>Class Lagged2d.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Lagged(m)</code> or
<code>new("Lagged2d", data = m)</code>, where <code>m</code> is a matrix.
<code>new("Lagged2d", ...)</code> also works.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Lagged-class">Lagged</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "Lagged2d", i = "numeric", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "Lagged2d", i = "numeric", j = "missing", drop = "missing")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "Lagged2d", i = "numeric")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Lagged2d")</code>: ... </p>
</dd>
<dt>whichLagged</dt><dd><p><code>signature(x = "Lagged2d", y = "missing")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lagged">Lagged</a></code>,
<code><a href="#topic+Lagged1d-class">Lagged1d</a></code>,
<code><a href="#topic+Lagged3d-class">Lagged3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>powers &lt;- Lagged(outer(1:6, 0:6, `^`))
powers[[0]]
powers[[1]]
powers[[2]]
</code></pre>

<hr>
<h2 id='Lagged3d-class'>Class Lagged3d</h2><span id='topic+Lagged3d-class'></span>

<h3>Description</h3>

<p>Class Lagged3d.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>Lagged(a)</code> or
<code>new("Lagged3d", data = a)</code>, where <code>a</code> is a 3-d array.
<code>new("Lagged3d", ...)</code> also works.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"array"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Lagged-class">Lagged</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "Lagged3d", i = "numeric", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "Lagged3d", i = "numeric", j = "missing", drop = "missing")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "Lagged3d", i = "numeric")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Lagged3d")</code>: ... </p>
</dd>
<dt>whichLagged</dt><dd><p><code>signature(x = "Lagged3d", y = "missing")</code>: ... </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lagged">Lagged</a></code>,
<code><a href="#topic+Lagged1d-class">Lagged1d</a></code>,
<code><a href="#topic+Lagged2d-class">Lagged2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for class "Lagged"
</code></pre>

<hr>
<h2 id='maxLag'>
Give the maximal lag in an object
</h2><span id='topic+maxLag'></span><span id='topic+maxLag-methods'></span><span id='topic+maxLag+2CLagged-method'></span><span id='topic+maxLag+2Carray-method'></span><span id='topic+maxLag+2Cmatrix-method'></span><span id='topic+maxLag+2Cvector-method'></span><span id='topic+maxLag+2CANY-method'></span><span id='topic+maxLag+2CslMatrix-method'></span>

<h3>Description</h3>

<p>Give the maximal lag in an object, such as autocorrelations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLag(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxLag_+3A_object">object</code></td>
<td>
<p>an object, for which the function makes sense.</p>
</td></tr>
<tr><td><code id="maxLag_+3A_...">...</code></td>
<td>
<p> not used? </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>maxLag</code> is a generic function to get the maximal lag for which
information is available in lagged objects.
</p>


<h3>Value</h3>

<p>a non-negative integer
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Lagged")</code></dt><dd>
<p>This method applies to all classes inheriting from <code>"Lagged"</code>.
</p>
</dd>
<dt><code>signature(object = "array")</code></dt><dd>

</dd><dt><code>signature(object = "matrix")</code></dt><dd>

</dd><dt><code>signature(object = "vector")</code></dt><dd>

</dd><dt><code>signature(object = "ANY")</code></dt><dd>

</dd><dt><code>signature(object = "slMatrix")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+maxLag+3C-">maxLag&lt;-</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1d
v &lt;- Lagged(2^(0:6))
v
maxLag(v)
v[c(2,4,6)]
v[8] # NA
## reduce the number of lags in place
maxLag(v) &lt;- 4
v
## extend the object (with NA's)
maxLag(v) &lt;- 6
v
## extend using "["
v[5:8] &lt;- 2^(5:8)
v

## 2d
m &lt;- Lagged(matrix(1:12, nrow = 4))
m
maxLag(m)
maxLag(m) &lt;- 1
m
## maxLag(m) &lt;- 4 # extending this way doesn't work currently
</code></pre>

<hr>
<h2 id='maxLag+26lt+3B-'>Change the maximal lag in a lagged object</h2><span id='topic+maxLag+3C--methods'></span><span id='topic+maxLag+3C-'></span><span id='topic+maxLag+3C-+2CLagged-method'></span><span id='topic+maxLag+3C-+2CFlexibleLagged-method'></span>

<h3>Description</h3>

<p>Change the maximal lag in a lagged object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLag(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxLag+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>an object for which this makes sense.</p>
</td></tr>
<tr><td><code id="maxLag+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="maxLag+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>the new value of the maximal lag, a non-negative integer number.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The replacement version of <code>maxLag()</code> changes the maximal lag in
an object to <code>value</code>. It is a generic function with no default
method. 
</p>
<p>For the core Lagged classes this is done by simply extending or
shrinking the data part to the requested value. Subclasses of
<code>"Lagged"</code> and other classes, in general, may need more elaborate
changes. If so, they should define their own methods.
</p>
<p>When <code>value</code> is larger than the current <code>maxLag(object)</code>,
the entries for the new lags are filled with NA's. 
</p>


<h3>Value</h3>

<p>the object whose maximal lag is modified as described in Details.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "Lagged")</code></dt><dd>
</dd>
<dt><code>signature(object = "FlexibleLagged")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxLag">maxLag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>la1 &lt;- Lagged(drop(acf(ldeaths)$acf))
la3 &lt;- la1
la3
## shrink la3
maxLag(la3) # 18
maxLag(la3) &lt;- 5
la3
maxLag(la3) # 5

## extend la3, new entries are filled with NA's
maxLag(la3) &lt;- 10
la3

## alternatively, use "[&lt;-" which accepts any replacement values
la3[11:13] &lt;- 0
la3
</code></pre>

<hr>
<h2 id='nSeasons'>Get the number of seasons from an object</h2><span id='topic+nSeasons'></span><span id='topic+nSeasons+3C-'></span><span id='topic+nSeasons-methods'></span><span id='topic+nSeasons+2CslMatrix-method'></span>

<h3>Description</h3>

<p>Get the number of seasons from an object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nSeasons(object)
nSeasons(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nSeasons_+3A_object">object</code></td>
<td>

<p>an object for which the notion of number of seasons makes sense.
</p>
</td></tr>
<tr><td><code id="nSeasons_+3A_value">value</code></td>
<td>
<p>a positive integer number.</p>
</td></tr>
<tr><td><code id="nSeasons_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are generic functions. 
</p>
<p>Methods for <code>nSeasons</code> are straightforward when the property
makes sense for objects from a class. In contrast, methods for the
replacement version, <code>`nSeasons&lt;-`</code>, should be defined carefully
and may not even be feasible. 
</p>


<h3>Value</h3>

<p>an integer number
</p>


<h3>Methods</h3>

<p>No methods for <code>`nSeasons&lt;-`</code> are defined in package
<span class="pkg">lagged</span>. The methods defined for <code>nSeasons</code> are given below.
</p>

<dl>
<dt><code>signature(object = "slMatrix")</code></dt><dd>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- slMatrix(matrix(1:12, nrow = 4))
m
nSeasons(m)
</code></pre>

<hr>
<h2 id='pc.omitneg'>An internal function</h2><span id='topic+pc.omitneg'></span>

<h3>Description</h3>

<p>An internal function</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.omitneg(lags, maxlag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc.omitneg_+3A_lags">lags</code></td>
<td>
<p> todo: describe! </p>
</td></tr>
<tr><td><code id="pc.omitneg_+3A_maxlag">maxlag</code></td>
<td>
<p> todo: describe! </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pc.omitneg</code> helps to implement dropping of negative indices in
season-lag objects. It returns its first argument, <code>lags</code>, if all
of its elements are non-negative. Otherwise, all elements of
<code>lags</code> must be non-positive. In this case the function creates the
vector <code>0:maxlag</code> and drops the elements specified by lags.  Note
that the default indexing will not work properly since zero elements in
an index are omitted (and there are such indices in season-lag
objects).
</p>


<h3>Value</h3>

<p>for <code>pc.omitneg</code>, a vector of lags (non-negative integers).
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'># ttmatToslPairs
# pc.omitneg
lagged:::pc.omitneg(0:5,10) # 0:5, unchagend since all values &gt;= 0

lagged:::pc.omitneg(-(0:5),10) # 6:10, works like
(0:10)[-(0:5 +1)]     # same

# don't mix positive and negative numbers in pc.omitneg
## Not run: lagged:::pc.omitneg(c(0,2,3,-4,5), 10)
</code></pre>

<hr>
<h2 id='sl2acfbase'>Convert between vector and season-lag representations</h2><span id='topic+sl2acfbase'></span><span id='topic+acfbase2sl'></span><span id='topic+sl2vecacf'></span>

<h3>Description</h3>

<p>Convert between vector and season-lag representations of
autocovariances of multivariate and periodically correlated time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sl2acfbase(mat, maxlag, fullblocks = FALSE)

acfbase2sl(acf)

sl2vecacf(mat, maxlag, fullblocks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sl2acfbase_+3A_acf">acf</code></td>
<td>
<p>an acf as returned by base R <code>acf</code>.</p>
</td></tr>
<tr><td><code id="sl2acfbase_+3A_mat">mat</code></td>
<td>

<p>a matrix containing autocovariances in season-lag arrangement.
</p>
</td></tr>
<tr><td><code id="sl2acfbase_+3A_maxlag">maxlag</code></td>
<td>
<p>maximal lag, a positive integer.</p>
</td></tr>
<tr><td><code id="sl2acfbase_+3A_fullblocks">fullblocks</code></td>
<td>
<p>if TRUE, keep full blocks only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions rearrange autocovariances and autocorrelations between
the native season-lag arrangement in package &ldquo;pcts&rdquo; and the vector
representations of the corresponding mutivariate models (vector of
seasons representation of periodic models). Variable <code class="reqn">s</code> is taken
be season <code class="reqn">s</code> and vice versa in the opposite direction.
</p>
<p>&ldquo;acfbase&rdquo; in the names of the functions refers to the representation
returned by base function <code>acf</code>.
</p>
<p><code>acfbase2sl</code> rearranges a multivariate acf in season-lag form.
</p>
<p><code>sl2acfbase</code> rearranges a season-lag form into the multivariate
form used by base function <code>acf</code>.
</p>
<p><code>sl2vecacf</code> is similar to <code>sl2acfbase</code> but the result is
such that the lag is in the third dimension and <code>r[ , , k]</code> is
<code class="reqn">Cov(X_{t}, X_{t-k})</code> (not its transpose). See also the examples
below and in <code><a href="#topic+acf2Lagged">acf2Lagged</a></code>.
</p>


<h3>Value</h3>

<p>for <code>acfbase2sl</code>, a matrix.
</p>
<p>for <code>sl2acfbase</code> and <code>sl2vecacf</code>, an array.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use a character matrix to illustrate the positions of the elements
matsl &lt;- rbind(paste0("Ra", 0:3), paste0("Rb", 0:3))
matsl
## convert to what I consider "standard" vec format R(k)=EX_tX_{t-k}'
sl2vecacf(matsl)
## convert to the format from acf() (R(k) is the transposed from mine).
sl2acfbase(matsl)
identical(sl2vecacf(matsl), aperm(sl2acfbase(matsl), c(3, 2, 1))) # TRUE

## by default the conversion is lossles;
## so this contains all values from the original and some NA's:
sl2acfbase(matsl)
## the orignal, matsl, can be restored:
acfbase2sl(sl2acfbase(matsl))
identical(acfbase2sl(sl2acfbase(matsl)), matsl)  # TRUE

## this drops some values (if necessary) to keep complete block only
sl2acfbase(matsl, fullblocks = TRUE)
</code></pre>

<hr>
<h2 id='slMatrix'> Function to create objects from class slMatrix </h2><span id='topic+slMatrix'></span>

<h3>Description</h3>

<p>Provides a flexible way to create objects from class
<code>slMatrix</code>. The entries may be specified in several ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slMatrix(init = NA, period, maxlag, seasonnames = seq(length = period),
         lagnames = as.character(0:maxlag), periodunit = "season",
         lagunit = "lag", f = NA, type = "sl")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slMatrix_+3A_init">init</code></td>
<td>
<p> values for the the autocovariances, see also argument <code>f</code>. </p>
</td></tr>
<tr><td><code id="slMatrix_+3A_period">period</code></td>
<td>
<p> the number of seasons in an epoch </p>
</td></tr>
<tr><td><code id="slMatrix_+3A_maxlag">maxlag</code></td>
<td>
<p> maximum lag to be stored </p>
</td></tr>
<tr><td><code id="slMatrix_+3A_seasonnames">seasonnames</code></td>
<td>
<p> names of seasons (?) </p>
</td></tr>
<tr><td><code id="slMatrix_+3A_lagnames">lagnames</code></td>
<td>
<p> names of lags </p>
</td></tr>
<tr><td><code id="slMatrix_+3A_periodunit">periodunit</code></td>
<td>
<p> name of the period unit  </p>
</td></tr>
<tr><td><code id="slMatrix_+3A_lagunit">lagunit</code></td>
<td>
<p> name of the unit for lags </p>
</td></tr>
<tr><td><code id="slMatrix_+3A_f">f</code></td>
<td>
<p> function to evaluate or matrix to get the values  of the autocovariances.</p>
</td></tr>
<tr><td><code id="slMatrix_+3A_type">type</code></td>
<td>
<p> format  or the arguments of <code>f</code>, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal representation of <code>slMatrix</code> is a matrix slot, <code>m</code>, of size
<code>period x (maxlag+1)</code>. It is created by a call to <code>matrix()</code>
with <code>init</code> supplying the values (may be <code>NA</code>s). If
<code>init</code> is a matrix values for <code>period</code> and <code>maxlag</code>
are deduced (if not supplied) from its size.
</p>
<p>Change on 21/06/2006: Now, if the length of
<code>init</code> is smaller than that of <code>m</code>, the remaining values are
filled with NA's (in the past  the normal recycling rules of
<code>matrix()</code> applied). The previous behaviour used to hide
puzzling and difficult to track errors. I cannot be sure but this
change should not affect old code.
</p>
<p>If <code>f</code> is given it is used to populate the slot
<code>m</code> by a call to <code>fill.slMatrix</code>. Normally in this case
<code>init=NA</code> but this is not required.
</p>
<p>Currently <code>fill.slMatrix</code> has methods for <code>f</code> of class
&quot;matrix&quot; and &quot;function&quot;. The arguments (or the indices)
can be   controlled by the argument <code>type</code>.
</p>
<p><code>type="sl"</code> - standard season-lag pair
</p>
<p><code>type="tt"</code> - time-time pair
</p>
<p><code>type="tl"</code> - standard season-lag pair
</p>


<h3>Value</h3>

<p>An object of class <code>slMatrix</code>
</p>


<h3>Note</h3>

<p> To do: additional work is needed on the case when the dimensions
of init and the result are not the same (see the details section) </p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+slMatrix-class">slMatrix-class</a></code>,
<code><a href="#topic+fill.slMatrix">fill.slMatrix</a></code>
</p>

<hr>
<h2 id='slMatrix-class'>Class &quot;slMatrix&quot; </h2><span id='topic+slMatrix-class'></span>

<h3>Description</h3>

 <p><code>slMatrix</code> is a matrix-like object for storing values
of periodic autocovariance functions, i.e. of functions of two
arguments which are periodic in the first argument,
<code>r[t,k]=r[t+d,k]</code>. The first argument has the meaning of &quot;time&quot; or
&quot;season&quot; (when taken modulo the period),
the second is &quot;lag&quot;.
This class provides various access and assignment methods for
such objects. slMatrix was created as the storage for values of
periodic autocovariance functions and is used for other related quantities.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("slMatrix", m)</code>,
where <code>m</code> is a matrix with m[i,k] giving the values for season i
and lag (k-1), <code class="reqn">k=1,2,\dots</code>.
The number of rows in m is taken to be the number of
seasons. The function <code>slMatrix</code> provides several ways to specify
the data for the slMatrix object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>m</code>:</dt><dd><p>Object of class <code>"matrix"</code>. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "slMatrix", i = "ANY", j = "ANY",
	value = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "slMatrix", i = "ANY", j = "ANY", drop
	= "ANY")</code>:
</p>
<p>The indexing method is quite flexible and allows to extract parts
of <code>slMatrix</code> objects in a variety of ways. It returns an
ordinary matrix or, if <code>drop = TRUE</code>, vector.
</p>
<p>The syntax for indexing is similar to that for ordinary matrices
with some features specific to the periodic nature of the first
index. The named parameters are <code>i</code>, <code>j</code>, and
<code>type</code>. Both <code>i</code> and <code>j</code> can be vectors. The
interpretation of <code>i</code> and <code>j</code> depends on <code>type</code>.
</p>
<p><code>x[i,j]</code> (or <code>x[i,j,type="sl"]</code>) refers to the value for
season <code>i</code> and lag <code>j</code>.  This is referred to as standard
season-lag pair, meaning that the elements of <code>i</code> must be in
the range 1,...,d, where d is the number of seasons and the lags
must be non-negative. Negative indices have the usual effect of
removing the corresponding elements. A zero element for lag is
admissible.
</p>
<p><code>x[i,j,type="tl"]</code> is similar to &quot;sl&quot; but <code>i</code> is allowed
to take any (integer) values. These are reduced modulo the number
of seasons to the 1,...,d, range.
</p>
<p><code>x[i,j,type="tl+-"]</code> This allows also the lags to be
negative.
</p>
<p><code>x[i,j,type="co"]</code> (&quot;co&quot; stands for &quot;coefficient&quot;) This
assumes that the values for negative lags and lags larger than
<code>maxlag</code> are 0. If assignment is attempted for such lags, a
message is issued and the assignment is ignored.
</p>
<p><code>x[i,j,type="tt"]</code> both arguments have the meaning of
time. If <code>i</code> and <code>j</code> are scalars the pair <code>i,j</code> is
converted to standard <code>s,l</code> pair and the value assigned to
the relevant element. If <code>i</code> and/or <code>j</code> are vectors,
they are crossed and the procedure is done for each pair.
</p>
<p>If several values need to be assigned to the same <code>s,l</code> pair
a warning is isssued if these values are not all equal.
</p>
<p>Obviously, whereever negative arguments are allowed, elements to
omit cannot be specified with negative indices.
</p>
<p>see <code><a href="#topic++5B-methods">[-methods</a></code>. 
</p>
</dd>
<dt>maxLag</dt><dd><p><code>signature(x = "slMatrix")</code>:
maximum lag available for storage. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The current implementation of the indexing is inefficient, I simply
added features and patches as the need arose. Maybe some day I will
replace it with <code>C</code> code.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+slMatrix">slMatrix</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- rbind(c(1, 0.81, 0), c(1, 0.4972376, 0.4972376))
x &lt;- slMatrix(m1)
x[1, 0]
x[1:2, 0:1]
x[1:3, 1:3, type = "tt"]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
