<!DOCTYPE html><html lang="en"><head><title>Help for package DiPs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiPs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addcaliper'><p>Add a caliper, that need not be symmetric, to a distance object.</p></a></li>
<li><a href='#addDirectPenalty'><p>Add a directional penalty to a distance object</p></a></li>
<li><a href='#addMagnitudePenalty'><p>Add a directional magnitude penalty to a distance matrix</p></a></li>
<li><a href='#check'><p>Check standardized mean differences (SMDs) of the matched data set.</p></a></li>
<li><a href='#edgenum'><p>Computes the number of edges in the reduced bipartite graph.</p></a></li>
<li><a href='#maha_dense'><p>Creates a robust Mahalanobis distance for matching based on a dense network.</p></a></li>
<li><a href='#maha_sparse'><p>Creates a robust Mahalanobis distance for matching based on a sparse network.</p></a></li>
<li><a href='#match'><p>Minimum-distance near-fine matching.</p></a></li>
<li><a href='#net'><p>Optimal near-fine match from a distance matrix.</p></a></li>
<li><a href='#nh0506Homocysteine'>
<p>Homocysteine and Smoking</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Directional Penalties for Optimal Matching in Observational
Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruoqi Yu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ruoqi Yu &lt;ruoqiyu125@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Improves the balance of optimal matching with near-fine balance by giving penalties on the unbalanced covariates with the unbalanced directions. Many directional penalties can also be viewed as Lagrange multipliers, pushing a matched sample in the direction of satisfying a linear constraint that would not be satisfied without penalization.
    Yu and Rosenbaum (2019) &lt;<a href="https://doi.org/10.1111%2Fbiom.13098">doi:10.1111/biom.13098</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://errickson.net/rrelaxiv/">https://errickson.net/rrelaxiv/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, plyr, mvnfast, methods, rlemon</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optmatch, rrelaxiv</td>
</tr>
<tr>
<td>Note:</td>
<td>One minimum cost flow problem may have several or many solutions
that are equivalent in providing the same minimum total or mean
cost. Minor differences between computers or implementations
may have the minor consequence of altering which equivalent
solution is produced. The optmatch package, which is useful for
running many of the provided functions, may be downloaded from
Github at &lt;https://github.com/markmfredrickson/optmatch&gt; if not
available on CRAN. The rrelaxiv package, which provides an
alternative solver for the underlying network flow problems,
carries an academic license and is not available on CRAN, but
may be downloaded from Github at
&lt;https://github.com/josherrickson/rrelaxiv/&gt;.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-26 04:35:42 UTC; ruoqiyu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-07 14:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='addcaliper'>Add a caliper, that need not be symmetric, to a distance object.</h2><span id='topic+addcaliper'></span>

<h3>Description</h3>

<p>Imposes a caliper, that need not be symmetric, on p using a penalty function, adding the penalty to a distance matrix dmat and returning a new distance matrix.
The symmetric version of this function is discussed in Rosenbaum (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addcaliper(dist, z, dx, rg, stdev = FALSE, penalty = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addcaliper_+3A_dist">dist</code></td>
<td>
<p>A distance object with three components: d, start, end, typically created by maha_dense or maha_sparse. d[i] gives the distance between the (start[i])th treated and the (end[i]-sum(z))th control.</p>
</td></tr>
<tr><td><code id="addcaliper_+3A_z">z</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. Must have treated subjects (z = 1) before controls (z = 0).</p>
</td></tr>
<tr><td><code id="addcaliper_+3A_dx">dx</code></td>
<td>
<p>A vector of with length(z)=length(dx) giving the variable used to define the caliper. For instance, dx might be the propensity score.</p>
</td></tr>
<tr><td><code id="addcaliper_+3A_rg">rg</code></td>
<td>
<p>A vector with length(rg) = 2 such that rg[1] &lt;= 0 &lt;= rg[2]. If the treated-minus-control difference in dx is &lt; rg[1] or &gt; rg[2], then penalty is added to the distance. If treated individuals have dx higher than controls, then you want to set rg[2] &lt; -rg[1], so that you tolerate smaller positive differences and larger negative differences.</p>
</td></tr>
<tr><td><code id="addcaliper_+3A_stdev">stdev</code></td>
<td>
<p>If stdev = TRUE, rg is interpreted in units of an equally weighted pooled
standard deviation; that is,rg is replaced by rg*sp where sp is sqrt((var(dx[z==1])+var(dx[z==0]))/2).</p>
</td></tr>
<tr><td><code id="addcaliper_+3A_penalty">penalty</code></td>
<td>
<p>The number added to a distance when the caliper is violated. A large penalty, like the default value of penalty = 1000, will try to enforce the caliper to the extent that this is feasible. Small penalties can slightly tilt a match in a desired direction. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new distance object whose distance component d is updated by the sum of d and the penalties for caliper violations.</p>


<h3>References</h3>

<p>Yu, R., &amp; Rosenbaum, P. R. (2019). Directional penalties for optimal matching in observational studies. Biometrics, 75(4), 1380-1390.
</p>
<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nh0506Homocysteine")
attach(nh0506Homocysteine)
X&lt;-cbind(female, age, black, education, povertyr, bmi)
p&lt;-glm(z ~ female + age + black + education + povertyr + bmi,
        family = binomial)$fitted.values
d&lt;-cbind(nh0506Homocysteine, p)
detach(nh0506Homocysteine)
dist0&lt;-maha_dense(d$z, X)
#symmetric caliper
dist1&lt;-addcaliper(dist0, d$z, d$p, c(-.3,.3), stdev = TRUE,
                    penalty = 1000)
head(dist1$d)
#asymmetric caliper
dist2&lt;-addcaliper(dist0, d$z, d$p, c(-.5,.1), stdev = TRUE,
                    penalty = 1000)
head(dist2$d)
</code></pre>

<hr>
<h2 id='addDirectPenalty'>Add a directional penalty to a distance object</h2><span id='topic+addDirectPenalty'></span>

<h3>Description</h3>

<p>Add a directional penalty to a distance object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDirectPenalty(dist, z, dx, positive = TRUE, penalty = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addDirectPenalty_+3A_dist">dist</code></td>
<td>
<p>A distance object with three components: d, start, end, typically created by maha_dense or maha_sparse. d[i] gives the distance between the (start[i])th treated and the (end[i]-sum(z))th control.</p>
</td></tr>
<tr><td><code id="addDirectPenalty_+3A_z">z</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. Must have
treated subjects (z = 1) before controls (z = 0).</p>
</td></tr>
<tr><td><code id="addDirectPenalty_+3A_dx">dx</code></td>
<td>
<p>A vector of with length(z) = length(dx) giving the variable used to define the caliper.  For instance, dx might be the propensity score.</p>
</td></tr>
<tr><td><code id="addDirectPenalty_+3A_positive">positive</code></td>
<td>
<p>If positive = TRUE, a treated-minus-control difference in dx that is positive is
increased by penalty, but if positive = FALSE a a treated-minus-control difference in dx that is negative is increased by penalty. Zero differences are never penalized.</p>
</td></tr>
<tr><td><code id="addDirectPenalty_+3A_penalty">penalty</code></td>
<td>
<p>The number added to a distance when the desired direction is violated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new distance matrix that is the sum of dmat and the penalties for direction violations.</p>


<h3>References</h3>

<p>Yu, R., &amp; Rosenbaum, P. R. (2019). Directional penalties for optimal matching in observationals tudies. Biometrics, 75(4), 1380-1390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nh0506Homocysteine")
attach(nh0506Homocysteine)
X&lt;-cbind(female, age, black, education, povertyr, bmi)
p&lt;-glm(z ~ female + age + black + education + povertyr + bmi,
        family=binomial)$fitted.values
d&lt;-cbind(nh0506Homocysteine, p)
detach(nh0506Homocysteine)
dist&lt;-maha_dense(d$z, X)
head(dist$d)
dist&lt;-addDirectPenalty(dist, d$z, d$p, positive=TRUE, penalty = 1)
head(dist$d)
</code></pre>

<hr>
<h2 id='addMagnitudePenalty'>Add a directional magnitude penalty to a distance matrix</h2><span id='topic+addMagnitudePenalty'></span>

<h3>Description</h3>

<p>Adds a penalty to the distance component d of the distance object dist depending upon value of dx. The distance object dist has three components: d, start, end. d[i] gives the distance between the tth treated and the cth control, with t = start[i] and c = end[i]-sum(z). The value of dx for treated unit t, say dxt, is dx[z==1][t] and the value of dx for control c, say dxc, is dx[z==0][c]. Then, d[i] is adjusted using dxt-dxc. If positive=TRUE, the adjustment changes d[i] to
d[i] + multiplier*(max(0, (dxt-dxc)-hstick)). That is, a penalty is imposed if dxt exceeds dxc
by more than hstick. If positive = FALSE, the adjustment changes d[i] to d[i] + multiplier*(max(0, (dxc-dxt)-hstick)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMagnitudePenalty(dist, z, dx, positive = TRUE, hstick = 0,
                      multiplier = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addMagnitudePenalty_+3A_dist">dist</code></td>
<td>
<p>A distance object with three components: d, start, end, typically created by maha_dense or maha_sparse. d[i] gives the distance between the (start[i])th treated and the (end[i]-sum(z))th control.</p>
</td></tr>
<tr><td><code id="addMagnitudePenalty_+3A_z">z</code></td>
<td>
<p> A vector whose ith coordinate is 1 for a treated unit and is 0 for a control.  Must have treated subjects (z=1) before controls (z=0).</p>
</td></tr>
<tr><td><code id="addMagnitudePenalty_+3A_dx">dx</code></td>
<td>
<p> A vector of with length(z)=length(dx) giving the variable used to define the caliper. For instance, dx might be the propensity score.</p>
</td></tr>
<tr><td><code id="addMagnitudePenalty_+3A_positive">positive</code></td>
<td>
<p>If positive = TRUE, a treated-minus-control difference di in dx that is positive is increased by a multiple of |di|, but if positive = FALSE a a treated-minus-control difference in dx that is negative is increased by a multiple of |di|. </p>
</td></tr>
<tr><td><code id="addMagnitudePenalty_+3A_hstick">hstick</code></td>
<td>
<p>Hockey-stick value, which is a nonnegative number. See the description.</p>
</td></tr>
<tr><td><code id="addMagnitudePenalty_+3A_multiplier">multiplier</code></td>
<td>
<p>The magnitide added is multiplier*|di|/s where s is an equally weighted, pooled within group standard deviation of dx.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new distance object whose distance component d is updated by the sum of dmat and the penalties.</p>


<h3>References</h3>

<p>Yu, R., &amp; Rosenbaum, P. R. (2019). Directional penalties for optimal matching in observational studies. Biometrics, 75(4), 1380-1390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(MASS)
data("nh0506Homocysteine")
attach(nh0506Homocysteine)
# Select covariates
X&lt;-cbind(female, age, black, education, povertyr, bmi)
#Propensity score
p&lt;-glm(z ~ female + age + black + education + povertyr + bmi,
        family=binomial)$fitted.values
d&lt;-cbind(nh0506Homocysteine, p)
detach(nh0506Homocysteine)
dist&lt;-maha_dense(d$z, X)
head(dist$d)
# Impose a penalty when a treated individual has a higher propensity
# score than a control
dist&lt;-addMagnitudePenalty(dist, d$z, d$p, positive=TRUE, multiplier = 20)
head(dist$d)

## End(Not run)
</code></pre>

<hr>
<h2 id='check'>Check standardized mean differences (SMDs) of the matched data set.</h2><span id='topic+check'></span>

<h3>Description</h3>

<p>The function is used to create a table of mean and SMDs to check the balance before and after matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(fdata, mdata, fz, mz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_+3A_fdata">fdata</code></td>
<td>
<p>A full data frame with length(fz) rows and columns being variables that need to check SMDs. fdata and mdata must have the same variables with same column names in the same order.</p>
</td></tr>
<tr><td><code id="check_+3A_mdata">mdata</code></td>
<td>
<p>A matched data frame with length(mz) rows and columns being variables that need to check SMDs. fdata and mdata must have the same variables with same column names in the same order.</p>
</td></tr>
<tr><td><code id="check_+3A_fz">fz</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control for subjects in the full data set.</p>
</td></tr>
<tr><td><code id="check_+3A_mz">mz</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control for subjects in the matched data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A matrix with one row for each variable and five columns being the mean of treated group, mean of matched control group, mean of full control group, SMD of matched control group and SMD of full control group.
</p>


<h3>References</h3>

<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To run this example, you must load the optmatch package.
# The optmatch is available on CRAN and Github.

data("nh0506Homocysteine")
attach(nh0506Homocysteine)
X&lt;-cbind(female, age, black, education, povertyr, bmi)
p&lt;-glm(z ~ female + age + black + education + povertyr + bmi,
        family = binomial)$fitted.values
d&lt;-cbind(nh0506Homocysteine, p)
detach(nh0506Homocysteine)
dist&lt;-maha_dense(d$z, X)
o&lt;-match(d$z, dist, d)
matcheddata&lt;-o$data
Xm&lt;-subset(matcheddata, select=c('female', 'age', 'black', 'education',
            'povertyr', 'bmi', 'p'))
check(cbind(X, p), Xm, d$z, matcheddata$z)

</code></pre>

<hr>
<h2 id='edgenum'>Computes the number of edges in the reduced bipartite graph.</h2><span id='topic+edgenum'></span>

<h3>Description</h3>

<p>Computes the number of edges in the reduced bipartite graph after applying the caliper and number of nearest neighbors (constant). Equivalently, this is the number of candidate pairs for matching in the observational study.
</p>
<p>This function can provide users some idea of the required computation time. Smaller caliper and constant removes more edges, hence accelarates computation, but risks infeasibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgenum(z, p, caliper, constant=NULL, exact=NULL, ties.all=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgenum_+3A_z">z</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. </p>
</td></tr>
<tr><td><code id="edgenum_+3A_p">p</code></td>
<td>
<p>A vector of length(z)=length(p) giving the variable used to define the caliper. Typically, p is the propensity score or its rank.</p>
</td></tr>
<tr><td><code id="edgenum_+3A_caliper">caliper</code></td>
<td>
<p>If two individuals differ on p by more than caliper, we will not calculate the distance for this pair.</p>
</td></tr>
<tr><td><code id="edgenum_+3A_constant">constant</code></td>
<td>
<p>If the number of pairs within a caliper is greater than constant, we will select the constant closest ones.</p>
</td></tr>
<tr><td><code id="edgenum_+3A_exact">exact</code></td>
<td>
<p>If not NULL, then a vector of length(z)=length(p) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="edgenum_+3A_ties.all">ties.all</code></td>
<td>
<p>If ties.all is True, include all ties while choosing nearest neighbors. In this case, some treated may have more than constant controls. Otherwise, randomly select one or several controls to make sure there are not more than constant controls for each treated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A given choice of caliper and number of nearest neighbors (constant) removes candidate pairs, so there exists a corresponding reduced bipartite graph.
</p>
<p>Smaller caliper and constant removes more edges from the original dense graph, hence the computation is faster. However, this risks infeasibility. A smallest caliper that permits a feasible match and its corresponding smallest number of nearest neighbors can be computed by functions optcal() and optconstant().
</p>


<h3>Value</h3>

<p>Number of edges in the reduced bipartite graph with the constraints on caliper and number of nearest neighbors (constant).
</p>


<h3>References</h3>

<p>Yu, R., Silber, J. H., &amp; Rosenbaum, P. R. (2020).  Matching methods for observational studies derived from large administrative databases (with Discussion). Statistical Science, 35(3), 338-355.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh0506Homocysteine)
attach(nh0506Homocysteine)
p&lt;-glm(z ~ female + age + black + education + povertyr + bmi,
        family = binomial)$fitted.values
edgenum(z, p, 0.2)
edgenum(z, p, 0.2, 10, exact=female)
detach(nh0506Homocysteine)
</code></pre>

<hr>
<h2 id='maha_dense'>Creates a robust Mahalanobis distance for matching based on a dense network.</h2><span id='topic+maha_dense'></span>

<h3>Description</h3>

<p>Computes a robust Mahalanobis distance list for use in dense matching. In this case, we compute the distance for all possible pairs of treated and control.
</p>
<p>This function and its use are discussed in Rosenbaum (2010).  The robust
Mahalanobis distance in described in Chapter 8 of Rosenbaum (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maha_dense(z, X, exact=NULL, nearexact=NULL, penalty=100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maha_dense_+3A_z">z</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. </p>
</td></tr>
<tr><td><code id="maha_dense_+3A_x">X</code></td>
<td>
<p>A matrix with length(z) rows giving the covariates.  X should be of full column rank.</p>
</td></tr>
<tr><td><code id="maha_dense_+3A_exact">exact</code></td>
<td>
<p>If not NULL, then a vector of length(z) = length(p) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="maha_dense_+3A_nearexact">nearexact</code></td>
<td>
<p>If not NULL, then a vector of length length(z) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="maha_dense_+3A_penalty">penalty</code></td>
<td>
<p>The penalty for a mismatch on nearexact.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual Mahalanobis distance works well for multivariate Normal covariates, but can exhibit odd behavior with typical covariates. Long tails or an outlier in a covariate can yield a large estimated variance, so the usual Mahalanobis distance pays little attention to large differences in this covariate. Rare binary covariates have a small variance, so a mismatch on a rare binary covariate is viewed by the usual Mahalanobis distance as extremely important. If you were matching for binary covariates indicating US state of residence, the usual Mahalanobis distance would regard a mismatch for Wyoming as much worse than a mismatch for California.
</p>
<p>The robust Mahalanobis distance uses ranks of covariates rather than the covariates themselves, but the variances of the ranks are not adjusted for ties, so ties do not make a variable more important. Binary covariates are, of course, heavily tied.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>d</code></td>
<td>
<p> A distance object for each pair of treated and control.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> The treated subject for each distance.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p> The control subject for each distance.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nh0506Homocysteine")
attach(nh0506Homocysteine)
X&lt;-cbind(female, age, black, education, povertyr, bmi)
dist&lt;-maha_dense(z, X)
head(dist$d)
detach(nh0506Homocysteine)
</code></pre>

<hr>
<h2 id='maha_sparse'>Creates a robust Mahalanobis distance for matching based on a sparse network.</h2><span id='topic+maha_sparse'></span>

<h3>Description</h3>

<p>Computes a robust Mahalanobis distance list for use in sparse matching. In this case, we will only calculate the distance for pairs within the caliper on p. If the caliper is too small, the matching may be infeasible. For the smallest caliper that keeps feasiblibity, refer to optcal() in package 'bigmatch'.
</p>
<p>This function and its use are discussed in Rosenbaum (2010). It is preferred when the dataset is large. The robust Mahalanobis distance in described in Chapter 8 of Rosenbaum (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maha_sparse(z, X, p=rep(1,length(z)), caliper=1, stdev=FALSE,
              constant=NULL, ncontrol=1, exact=NULL, nearexact=NULL,
              penalty=100, subX=NULL, ties.all=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maha_sparse_+3A_z">z</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. </p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_x">X</code></td>
<td>
<p>A matrix with length(z) rows giving the covariates. X should be of full column rank.</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_p">p</code></td>
<td>
<p>A vector of length(z) = length(p) giving the variable used to define the caliper. Typically, p is the propensity score or its rank.</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_caliper">caliper</code></td>
<td>
<p>If two individuals differ on p by more than caliper, we will not calculate the distance for this pair. If caliper is a positive number, then a symmetric caliper is applied. If caliper is a vector of a negative number and a positive number, then an asymmetric caliper is applied.</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_stdev">stdev</code></td>
<td>
<p>If stdev = TRUE, caliper is interpreted in units of an equally weighted pooled
standard deviation; that is,caliper is replaced by caliper*sp where sp is sqrt((var(dx[z==1])+var(dx[z==0]))/2).</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_constant">constant</code></td>
<td>
<p>If the number of pairs within a caliper is greater than constant, we will select the constant closest ones.</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_ncontrol">ncontrol</code></td>
<td>
<p>A positive integer giving the number of controls to be matched to each treated subject. If ncontrol is too large, the match will be infeasible.</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_exact">exact</code></td>
<td>
<p>If not NULL, then a vector of length(z) = length(p) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_nearexact">nearexact</code></td>
<td>
<p>If not NULL, then a vector of length length(z) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_penalty">penalty</code></td>
<td>
<p>The penalty for a mismatch on nearexact.</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_subx">subX</code></td>
<td>
<p>If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact = x, subX = x.</p>
</td></tr>
<tr><td><code id="maha_sparse_+3A_ties.all">ties.all</code></td>
<td>
<p>If ties.all is True, include all ties while choosing nearest neighbors. In this case, some treated may have more than constant controls. Otherwise, randomly select one or several controls to make sure there are not more than constant controls for each treated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual Mahalanobis distance works well for multivariate Normal covariates, but can exhibit odd behavior with typical covariates. Long tails or an outlier in a covariate can yield a large estimated variance, so the usual Mahalanobis distance pays little attention to large differences in this covariate. Rare binary covariates have a small variance, so a mismatch on a rare binary covariate is viewed by the usual Mahalanobis distance as extremely important. If you were matching for binary covariates indicating US state of residence, the usual Mahalanobis distance would regard a mismatch for Wyoming as much worse than a mismatch for California.
</p>
<p>The robust Mahalanobis distance uses ranks of covariates rather than the covariates themselves, but the variances of the ranks are not adjusted for ties, so ties do not make a variable more important. Binary covariates are, of course, heavily tied.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>d</code></td>
<td>
<p>A distance list for each pair within the caliper distance and constant constraint.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>The treated subject for each distance.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>The control subject for each distance.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yu, R., Silber, J. H., &amp; Rosenbaum, P. R. (2020).  Matching methods for observational studies derived from large administrative databases (with Discussion). Statistical Science, 35(3), 338-355.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nh0506Homocysteine")
attach(nh0506Homocysteine)
X&lt;-cbind(female, age, black, education, povertyr, bmi)
p&lt;-glm(z ~ female + age + black + education + povertyr + bmi,
        family=binomial)$fitted.values
d&lt;-cbind(nh0506Homocysteine,p)
detach(nh0506Homocysteine)

#apply symmetric caliper 0.15 on propensity score
dist1&lt;-maha_sparse(d$z, X, p, 0.15)
length(dist1$d)

#apply asymmetric caliper c(-0.2,0.1) on propensity score
dist2&lt;-maha_sparse(d$z, X, p, c(-0.2,0.1))
length(dist2$d)
</code></pre>

<hr>
<h2 id='match'>Minimum-distance near-fine matching.</h2><span id='topic+match'></span>

<h3>Description</h3>

<p>The program finds an optimal near-fine match with a given caliper on p, plus directional penalties on dx to offset the distribution imbalances. That is, it finds a near-fine match that minimizes the penalized Mahalanobis distance. In order to avoid the distortion of the original distribution by large penalties, it has the option of apply asymmetric calipers on those covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match(z, dist, dat, p=rep(1,length(z)), exact=NULL,
        fine=rep(1,length(z)), ncontrol=1,
        penalty=round(max(dist$d)*1000), s.cost=100, subX=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_+3A_z">z</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control.</p>
</td></tr>
<tr><td><code id="match_+3A_dist">dist</code></td>
<td>
<p>A distance object with three components: d, start, end, typically created by maha_dense or maha_sparse. d[i] gives the distance between the (start[i])th treated and the (end[i]-sum(z))th control.</p>
</td></tr>
<tr><td><code id="match_+3A_dat">dat</code></td>
<td>
<p>A data frame with length(z) rows.  If the match is feasible, the matched portion of dat is returned with additional columns that define the match.</p>
</td></tr>
<tr><td><code id="match_+3A_p">p</code></td>
<td>
<p>A vector of length(z)=length(p) giving the variable used to define the caliper. Typically, p is the propensity score or its rank. If the dense match is performed, use the default p=rep(1,length(z)).</p>
</td></tr>
<tr><td><code id="match_+3A_exact">exact</code></td>
<td>
<p>If not NULL, then a vector of length(z) = length(p) giving variable that need to be exactly matched. </p>
</td></tr>
<tr><td><code id="match_+3A_fine">fine</code></td>
<td>
<p>A vector of with length(z) = length(fine) giving the nominal levels that are to be nearly-finely balanced.</p>
</td></tr>
<tr><td><code id="match_+3A_ncontrol">ncontrol</code></td>
<td>
<p>A positive integer giving the number of controls to be matched to each treated subject. If ncontrol is too large, the match will be infeasible.</p>
</td></tr>
<tr><td><code id="match_+3A_penalty">penalty</code></td>
<td>
<p>A numeric penalty imposed for each violation of fine balance.</p>
</td></tr>
<tr><td><code id="match_+3A_s.cost">s.cost</code></td>
<td>
<p>The scaling factor for cost of the each pair of treated and control while rounding the cost.</p>
</td></tr>
<tr><td><code id="match_+3A_subx">subX</code></td>
<td>
<p>If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact = x, subX = x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The match minimizes the total distance between treated subjects and their matched controls subject to a near-fine balance constraint imposed as a penalty on imbalances. Another set of directional penalties on dx can be imposed in order to offset the distribution imbalances. In order to avoid the case of matching far pairs to get close means, the user can the option of apply asymmetric calipers on covariates in dx. We add a larger penalty for pairs outside the asymmetric caliper to avoid infeasibility issue. But a match may be infeasible if the caliper on p is too small. In this case, increase the caliper, or find the smallest caliper that gives a feasible matching by using optcal() in package 'bigmatch'.
</p>
<p>For discussion of networks for fine-balance, see Rosenbaum (1989, Section 3) and Rosenbaum (2010).
For near-fine balannce balance, see Yang et al. (2012).
</p>
<p>You MUST install and load the optmatch package to use match().
</p>


<h3>Value</h3>

<p>If the match is infeasible, a warning is issued.  Otherwise, a list of results is returned.
</p>
<p>A match may be infeasible if the caliper or constant on p is too small, or ncontrol is too large, or if exact matching for exact is impossible.
</p>
<table role = "presentation">
<tr><td><code>feasible</code></td>
<td>
<p>Indicator of whether matching is feasible or not.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The matched sample, selected rows of dat.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A vector of indicators of whether each treated-control pair is included in the matched sample.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bertsekas, D. P. and Tseng, P. (1988) The relax codes for linear minimum cost network flow problems. Annals of Operations Research, 13, 125-190.  Fortran and C code: http://www.mit.edu/~dimitrib/home.html. Available in R via the optmatch package.
</p>
<p>Rosenbaum, P.R. (1989) Optimal matching in observational studies. Journal of the American Statistical Association, 84, 1024-1032.
</p>
<p>Rosenbaum, P. R. (2010) Design of Observational Studies. New York: Springer.
</p>
<p>Yang, D., Small, D. S., Silber, J. H., and Rosenbaum, P. R. (2012) Optimal matching with minimal deviation from fine balance in a study of obesity and surgical outcomes. Biometrics, 68, 628-636.
</p>
<p>Yu, R., &amp; Rosenbaum, P. R. (2019). Directional penalties for optimal matching in observational studies. Biometrics, 75(4), 1380-1390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To run this example, you must install and load the optmatch package.
# The optmatch is available on CRAN and Github.

data("nh0506Homocysteine")
attach(nh0506Homocysteine)
X&lt;-cbind(female, age, black, education, povertyr, bmi)
p&lt;-glm(z ~ female + age + black + education + povertyr + bmi,
        family=binomial)$fitted.values
d&lt;-cbind(nh0506Homocysteine,p)
detach(nh0506Homocysteine)
dist&lt;-maha_dense(d$z,X)
dist$d&lt;-dist$d+1000*as.numeric(dist$d&gt;7)
dist&lt;-addcaliper(dist, d$z, d$p, c(-.5,.15), stdev=TRUE, penalty=1000)
dist&lt;-addMagnitudePenalty(dist, d$z, d$p, positive=TRUE, multiplier=20)
dist&lt;-addDirectPenalty(dist, d$z, d$p, positive=TRUE, penalty=1)
dist&lt;-addDirectPenalty(dist, d$z, d$black, positive=FALSE, penalty=2)
dist&lt;-addDirectPenalty(dist, d$z, d$bmi, positive=FALSE, penalty=2)
dist&lt;-addDirectPenalty(dist, d$z, d$female, positive=FALSE, penalty=4)
o&lt;-match(d$z, dist, d, fine=d$education, ncontrol=2)
md&lt;-o$data
head(md)

</code></pre>

<hr>
<h2 id='net'>Optimal near-fine match from a distance matrix.</h2><span id='topic+net'></span>

<h3>Description</h3>

<p>The function creates the network for optimal near-fine matching to be passed via callrelax to the Fortran code for Bertsekas and Tseng's (1988) Relax IV.
</p>
<p>Of limited interest to most users; function netfine() would typically be called by some other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net(z, dist, ncontrol=1, fine=rep(1,length(z)),
      penalty=round(max(dist$d)*100), s.cost=100, subX=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="net_+3A_z">z</code></td>
<td>
<p>A vector whose ith coordinate is 1 for a treated unit and is 0 for a control. </p>
</td></tr>
<tr><td><code id="net_+3A_dist">dist</code></td>
<td>
<p>A distance list with the starting node (treated subjec), ending node (control), the extra distance between them based on directional penalty.</p>
</td></tr>
<tr><td><code id="net_+3A_ncontrol">ncontrol</code></td>
<td>
<p>A positive integer giving the number of controls to be matched to each treated subject.</p>
</td></tr>
<tr><td><code id="net_+3A_fine">fine</code></td>
<td>
<p>A vector of with length(z) = length(fine) giving the nominal levels that are to be nearly-finely balanced.</p>
</td></tr>
<tr><td><code id="net_+3A_penalty">penalty</code></td>
<td>
<p>A numeric penalty imposed for each violation of fine balance.</p>
</td></tr>
<tr><td><code id="net_+3A_s.cost">s.cost</code></td>
<td>
<p>The scaling factor for cost of the each pair of treated and control while rounding the cost. </p>
</td></tr>
<tr><td><code id="net_+3A_subx">subX</code></td>
<td>
<p>If a subset matching is required, the variable that the subset matching is based on. That is, for each level of subX, extra treated will be discarded in order to have the number of matched treated subjects being the minimum size of treated and control groups. If exact matching on a variable x is desired and discarding extra treated is fine if there are more treated than controls for a certain level k, set exact = x, subX = x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network contains a bipartite graph for treated and control subjects plus additional nodes for fine balance categories, plus additional nodes accept needed deviations from fine balance yielding near-fine balance.
</p>
<p>For discussion of fine-balance, see Rosenbaum (1989, Section 3) and Rosenbaum (2010). For near-fine balance balance, see Yang et al. (2012).
</p>


<h3>Value</h3>

<p>A network for optimal near-fine matching.</p>


<h3>References</h3>

<p>Bertsekas, D. P. and Tseng, P. (1988) The relax codes for linear minimum cost
network flow problems. Annals of Operations Research, 13, 125-190.  Fortran
and C code: http://www.mit.edu/~dimitrib/home.html.  Available in R via the
optmatch package.
</p>
<p>Rosenbaum, P.R. (1989) Optimal matching in observational studies. Journal of
the American Statistical Association, 84, 1024-1032.
</p>
<p>Rosenbaum, P. R. (2010) Design of Observational Studies.  New York: Springer.
</p>
<p>Yang, D., Small, D. S., Silber, J. H., and Rosenbaum, P. R. (2012) Optimal
matching with minimal deviation from fine balance in a study of obesity and
surgical outcomes.  Biometrics, 68, 628-636.
</p>

<hr>
<h2 id='nh0506Homocysteine'>
Homocysteine and Smoking
</h2><span id='topic+nh0506Homocysteine'></span>

<h3>Description</h3>

<p>NHANES 2005-2006 data on smoking and homocysteine levels in adults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nh0506Homocysteine")</code></pre>


<h3>Format</h3>

<p>A data frame with 2759 observations on the following 11 variables.
</p>

<dl>
<dt><code>X</code></dt><dd><p>Row number, 1 to 2759</p>
</dd>
<dt><code>SEQN</code></dt><dd><p>NHANES identification number</p>
</dd>
<dt><code>z</code></dt><dd><p>Smoking status, 1 = daily smoker, 0 = never smoker</p>
</dd>
<dt><code>female</code></dt><dd><p>1 = female, 0 = male</p>
</dd>
<dt><code>age</code></dt><dd><p>Age in years, &gt;=20, capped at 85</p>
</dd>
<dt><code>black</code></dt><dd><p>1=black race, 0=other</p>
</dd>
<dt><code>education</code></dt><dd><p>Level of education</p>
</dd>
<dt><code>povertyr</code></dt><dd><p>Ratio of family income to the poverty level, capped at 5 times poverty</p>
</dd>
<dt><code>bmi</code></dt><dd><p>BMI or body-mass-index</p>
</dd>
<dt><code>cigsperday30</code></dt><dd><p>Cigarettes smoked per day, 0 for never smokers</p>
</dd>
<dt><code>cotinine</code></dt><dd><p>Blood cotinine level, a biomarker of recent exposure to tobacco</p>
</dd>
<dt><code>homocysteine</code></dt><dd><p>Level of homocysteine</p>
</dd>
</dl>



<h3>Details</h3>

<p>The following code constructed the data as used here. Attention is confined to adults, excluding children. Also, people who have smoked in the past, but do not now smoke daily, are excluded.
A moderate number of individuals with missing povertyr, cotinine or homocysteine were excluded.
</p>
<p>library(foreign)
</p>
<p>DEMO&lt;-read.xport(&quot;DEMO_D.XPT&quot;)
</p>
<p>HCY&lt;-read.xport(&quot;HCY_D.XPT&quot;)
</p>
<p>SMQ&lt;-read.xport(&quot;SMQ_D.XPT&quot;)
</p>
<p>BMX&lt;-read.xport(&quot;BMX_D.XPT&quot;)
</p>
<p>COT&lt;-read.xport(&quot;COT_D.XPT&quot;)
</p>
<p>d&lt;-merge(DEMO, HCY, by=&quot;SEQN&quot;, all.x=TRUE)
</p>
<p>d&lt;-merge(d, SMQ, by=&quot;SEQN&quot;, all.x=TRUE)
</p>
<p>d&lt;-merge(d, COT, by=&quot;SEQN&quot;, all.x=TRUE)
</p>
<p>d&lt;-merge(d, BMX, by=&quot;SEQN&quot;, all.x=TRUE)
</p>
<p>rm(DEMO, HCY, SMQ, COT, BMX)
</p>
<p>SEQN&lt;-d$SEQN
</p>
<p>age&lt;-d$RIDAGEYR
</p>
<p>race&lt;-d$RIDRETH1
</p>
<p>black&lt;-1*(race==4)
</p>
<p>hispanic&lt;-1*((race==1)|(race==2))
</p>
<p>female&lt;-1*(d$RIAGENDR==2)
</p>
<p>education&lt;-d$DMDEDUC2
</p>
<p>education[education&gt;6]&lt;-NA
</p>
<p>povertyr&lt;-d$INDFMPIR
</p>
<p>homocysteine&lt;-d$LBXHCY
</p>
<p>bmi&lt;-d$BMXBMI
</p>
<p>cotinine&lt;-d$LBXCOT
</p>
<p>cigs100life&lt;-d$SMQ020
</p>
<p>cigs100life[cigs100life&gt;3]&lt;-NA
</p>
<p>cigs100life&lt;-(cigs100life==1)*1
</p>
<p>smokenow&lt;-1*(d$SMQ040&lt;2.5)
</p>
<p>smokenow[cigs100life==0]&lt;-0
</p>
<p>cigsdays30&lt;-d$SMD641
</p>
<p>cigsdays30[cigsdays30&gt;32]&lt;-NA
</p>
<p>cigsdays30[smokenow==0]&lt;-0
</p>
<p>cigsperday30&lt;-d$SMD650
</p>
<p>cigsperday30[cigsperday30&gt;100]&lt;-NA
</p>
<p>cigsperday30[smokenow==0]&lt;-0
</p>
<p>dailysmoker&lt;-1*((cigs100life==1)&amp;(cigsdays30==30)&amp;(smokenow==1)&amp;(cigsperday30&gt;=10))
</p>
<p>neversmoker&lt;-1*((cigs100life==0)&amp;(smokenow==0))
</p>
<p>z&lt;-dailysmoker
</p>
<p>z[(neversmoker==0)&amp;(dailysmoker==0)]&lt;-(-999)
</p>
<p>ds&lt;-data.frame(SEQN, female, age, black, education, povertyr, bmi, homocysteine, cotinine,   cigs100life, smokenow, cigsdays30, cigsperday30, dailysmoker, neversmoker, z)
</p>
<p>use&lt;-age&gt;=20
</p>
<p>ds1&lt;-ds[use,]
</p>
<p>use&lt;-complete.cases(ds1)
</p>
<p>ds1$z[ds1$z==-999]&lt;-NA
</p>
<p>ds2&lt;-ds1[use&amp;!is.na(ds1$z),]
</p>
<p>rm(SEQN, female, age, black, hispanic, education, povertyr, homocysteine, cotinine, cigs100life, smokenow, cigsdays30, cigsperday30, dailysmoker, neversmoker, z, race, use, bmi)
</p>
<p>ds2&lt;-ds2[order(1-ds2$z),]
</p>
<p>attach(ds2)
</p>
<p>nh0505Homocysteine&lt;-data.frame(SEQN, z, female, age, black, education, povertyr, bmi, cigsperday30, cotinine, homocysteine)
</p>
<p>write.csv(nh0506Homocysteine, &quot;nh0506Homocysteine.csv&quot;)
</p>


<h3>Source</h3>

<p>From the NHANES web page, for NHANES 2005-2006.
</p>


<h3>References</h3>

<p>US National Health and Nutrition Examination Survey, 2005-2006.  From the US Center for Health Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh0506Homocysteine)
summary(nh0506Homocysteine)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
