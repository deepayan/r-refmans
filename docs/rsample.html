<!DOCTYPE html><html lang="en"><head><title>Help for package rsample</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsample}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rsample-package'><p>rsample: General Resampling Infrastructure</p></a></li>
<li><a href='#.get_fingerprint'><p>Obtain a identifier for the resamples</p></a></li>
<li><a href='#add_resample_id'><p>Augment a data set with resampling identifiers</p></a></li>
<li><a href='#apparent'><p>Sampling for the Apparent Error Rate</p></a></li>
<li><a href='#as.data.frame.rsplit'><p>Convert an <code>rsplit</code> object to a data frame</p></a></li>
<li><a href='#bootstraps'><p>Bootstrap Sampling</p></a></li>
<li><a href='#clustering_cv'><p>Cluster Cross-Validation</p></a></li>
<li><a href='#complement'><p>Determine the Assessment Samples</p></a></li>
<li><a href='#form_pred'><p>Extract Predictor Names from Formula or Terms</p></a></li>
<li><a href='#get_rsplit'><p>Retrieve individual rsplits objects from an rset</p></a></li>
<li><a href='#group_bootstraps'><p>Group Bootstraps</p></a></li>
<li><a href='#group_mc_cv'><p>Group Monte Carlo Cross-Validation</p></a></li>
<li><a href='#group_vfold_cv'><p>Group V-Fold Cross-Validation</p></a></li>
<li><a href='#initial_split'><p>Simple Training/Test Set Splitting</p></a></li>
<li><a href='#initial_validation_split'><p>Create an Initial Train/Validation/Test Split</p></a></li>
<li><a href='#int_pctl'><p>Bootstrap confidence intervals</p></a></li>
<li><a href='#labels.rset'><p>Find Labels from rset Object</p></a></li>
<li><a href='#labels.rsplit'><p>Find Labels from rsplit Object</p></a></li>
<li><a href='#loo_cv'><p>Leave-One-Out Cross-Validation</p></a></li>
<li><a href='#make_groups'><p>Make groupings for grouped rsplits</p></a></li>
<li><a href='#make_splits'><p>Constructors for split objects</p></a></li>
<li><a href='#make_strata'><p>Create or Modify Stratification Variables</p></a></li>
<li><a href='#manual_rset'><p>Manual resampling</p></a></li>
<li><a href='#mc_cv'><p>Monte Carlo Cross-Validation</p></a></li>
<li><a href='#nested_cv'><p>Nested or Double Resampling</p></a></li>
<li><a href='#new_rset'><p>Constructor for new rset objects</p></a></li>
<li><a href='#permutations'><p>Permutation sampling</p></a></li>
<li><a href='#populate'><p>Add Assessment Indices</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reg_intervals'><p>A convenience function for confidence intervals with linear-ish parametric models</p></a></li>
<li><a href='#reshuffle_rset'><p>&quot;Reshuffle&quot; an rset to re-generate a new rset with the same parameters</p></a></li>
<li><a href='#reverse_splits'><p>Reverse the analysis and assessment sets</p></a></li>
<li><a href='#rolling_origin'><p>Rolling Origin Forecast Resampling</p></a></li>
<li><a href='#rsample-dplyr'><p>Compatibility with dplyr</p></a></li>
<li><a href='#rsample2caret'><p>Convert Resampling Objects to Other Formats</p></a></li>
<li><a href='#rset_reconstruct'><p>Extending rsample with new rset subclasses</p></a></li>
<li><a href='#slide-resampling'><p>Time-based Resampling</p></a></li>
<li><a href='#tidy.rsplit'><p>Tidy Resampling Object</p></a></li>
<li><a href='#validation_set'><p>Create a Validation Split for Tuning</p></a></li>
<li><a href='#validation_split'><p>Create a Validation Set</p></a></li>
<li><a href='#vfold_cv'><p>V-Fold Cross-Validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>General Resampling Infrastructure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and functions to create and summarize different types
    of resampling objects (e.g. bootstrap, cross-validation).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rsample.tidymodels.org">https://rsample.tidymodels.org</a>,
<a href="https://github.com/tidymodels/rsample">https://github.com/tidymodels/rsample</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/rsample/issues">https://github.com/tidymodels/rsample/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr (&ge; 1.1.1), furrr, generics, glue, lifecycle,
methods, pillar, purrr (&ge; 1.0.0), rlang (&ge; 0.4.10), slider
(&ge; 0.1.5), tibble, tidyr, tidyselect, vctrs (&ge; 0.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom, covr, ggplot2, knitr, modeldata, recipes (&ge; 0.1.4),
rmarkdown, stats, testthat (&ge; 3.0.0), utils, whisker, withr,
xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>GGally, nlstools, tidymodels,
tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 09:20:45 UTC; hannah</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah Frick <a href="https://orcid.org/0000-0002-6049-5258"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Fanny Chow [aut],
  Max Kuhn [aut],
  Michael Mahoney <a href="https://orcid.org/0000-0003-2402-304X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Julia Silge <a href="https://orcid.org/0000-0002-3671-836X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Hadley Wickham [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hannah Frick &lt;hannah@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rsample-package'>rsample: General Resampling Infrastructure</h2><span id='topic+rsample'></span><span id='topic+rsample-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Classes and functions to create and summarize different types of resampling objects (e.g. bootstrap, cross-validation).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hannah Frick <a href="mailto:hannah@posit.co">hannah@posit.co</a> (<a href="https://orcid.org/0000-0002-6049-5258">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Fanny Chow <a href="mailto:fannybchow@gmail.com">fannybchow@gmail.com</a>
</p>
</li>
<li><p> Max Kuhn <a href="mailto:max@posit.co">max@posit.co</a>
</p>
</li>
<li><p> Michael Mahoney <a href="mailto:mike.mahoney.218@gmail.com">mike.mahoney.218@gmail.com</a> (<a href="https://orcid.org/0000-0003-2402-304X">ORCID</a>)
</p>
</li>
<li><p> Julia Silge <a href="mailto:julia.silge@posit.co">julia.silge@posit.co</a> (<a href="https://orcid.org/0000-0002-3671-836X">ORCID</a>)
</p>
</li>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://rsample.tidymodels.org">https://rsample.tidymodels.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidymodels/rsample">https://github.com/tidymodels/rsample</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/rsample/issues">https://github.com/tidymodels/rsample/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.get_fingerprint'>Obtain a identifier for the resamples</h2><span id='topic+.get_fingerprint'></span><span id='topic+.get_fingerprint.default'></span><span id='topic+.get_fingerprint.rset'></span>

<h3>Description</h3>

<p>This function returns a hash (or NA) for an attribute that is created when
the <code>rset</code> was initially constructed. This can be used to compare with other
resampling objects to see if they are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_fingerprint(x, ...)

## Default S3 method:
.get_fingerprint(x, ...)

## S3 method for class 'rset'
.get_fingerprint(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_fingerprint_+3A_x">x</code></td>
<td>
<p>An <code>rset</code> or <code>tune_results</code> object.</p>
</td></tr>
<tr><td><code id=".get_fingerprint_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character value or <code>NA_character_</code> if the object was created prior
to <code>rsample</code> version 0.1.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
.get_fingerprint(vfold_cv(mtcars))

set.seed(1)
.get_fingerprint(vfold_cv(mtcars))

set.seed(2)
.get_fingerprint(vfold_cv(mtcars))

set.seed(1)
.get_fingerprint(vfold_cv(mtcars, repeats = 2))
</code></pre>

<hr>
<h2 id='add_resample_id'>Augment a data set with resampling identifiers</h2><span id='topic+add_resample_id'></span>

<h3>Description</h3>

<p>For a data set, <code>add_resample_id()</code> will add at least one new column that
identifies which resample that the data came from. In most cases, a single
column is added but for some resampling methods, two or more are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_resample_id(.data, split, dots = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_resample_id_+3A_.data">.data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="add_resample_id_+3A_split">split</code></td>
<td>
<p>A single <code>rset</code> object.</p>
</td></tr>
<tr><td><code id="add_resample_id_+3A_dots">dots</code></td>
<td>
<p>A single logical: should the id columns be prefixed with a &quot;.&quot;
to avoid name conflicts with <code>.data</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data frame.
</p>


<h3>See Also</h3>

<p>labels.rsplit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

set.seed(363)
car_folds &lt;- vfold_cv(mtcars, repeats = 3)

analysis(car_folds$splits[[1]]) %&gt;%
  add_resample_id(car_folds$splits[[1]]) %&gt;%
  head()

car_bt &lt;- bootstraps(mtcars)

analysis(car_bt$splits[[1]]) %&gt;%
  add_resample_id(car_bt$splits[[1]]) %&gt;%
  head()
</code></pre>

<hr>
<h2 id='apparent'>Sampling for the Apparent Error Rate</h2><span id='topic+apparent'></span>

<h3>Description</h3>

<p>When building a model on a data set and re-predicting the same data, the
performance estimate from those predictions is often called the
&quot;apparent&quot; performance of the model. This estimate can be wildly
optimistic. &quot;Apparent sampling&quot; here means that the analysis and
assessment samples are the same. These resamples are sometimes used in
the analysis of bootstrap samples and should otherwise be
avoided like old sushi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apparent(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apparent_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="apparent_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a single row and classes <code>apparent</code>,
<code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>. The
results include a column for the data split objects and one column
called <code>id</code> that has a character string with the resample identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>apparent(mtcars)
</code></pre>

<hr>
<h2 id='as.data.frame.rsplit'>Convert an <code>rsplit</code> object to a data frame</h2><span id='topic+as.data.frame.rsplit'></span><span id='topic+analysis'></span><span id='topic+analysis.default'></span><span id='topic+analysis.rsplit'></span><span id='topic+assessment'></span><span id='topic+assessment.default'></span><span id='topic+assessment.rsplit'></span>

<h3>Description</h3>

<p>The analysis or assessment code can be returned as a data
frame (as dictated by the <code>data</code> argument) using
<code>as.data.frame.rsplit</code>. <code>analysis</code> and
<code>assessment</code> are shortcuts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rsplit'
as.data.frame(x, row.names = NULL, optional = FALSE, data = "analysis", ...)

analysis(x, ...)

## Default S3 method:
analysis(x, ...)

## S3 method for class 'rsplit'
analysis(x, ...)

assessment(x, ...)

## Default S3 method:
assessment(x, ...)

## S3 method for class 'rsplit'
assessment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.rsplit_+3A_x">x</code></td>
<td>
<p>An <code>rsplit</code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.rsplit_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row names for the data frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.rsplit_+3A_optional">optional</code></td>
<td>
<p>A logical: should the column names of the data be checked for legality?</p>
</td></tr>
<tr><td><code id="as.data.frame.rsplit_+3A_data">data</code></td>
<td>
<p>Either &quot;analysis&quot; or &quot;assessment&quot; to specify which data are returned.</p>
</td></tr>
<tr><td><code id="as.data.frame.rsplit_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
set.seed(104)
folds &lt;- vfold_cv(mtcars)

model_data_1 &lt;- folds$splits[[1]] %&gt;% analysis()
holdout_data_1 &lt;- folds$splits[[1]] %&gt;% assessment()
</code></pre>

<hr>
<h2 id='bootstraps'>Bootstrap Sampling</h2><span id='topic+bootstraps'></span>

<h3>Description</h3>

<p>A bootstrap sample is a sample that is the same size as the original data
set that is made using replacement. This results in analysis samples that
have multiple replicates of some of the original rows of the data. The
assessment set is defined as the rows of the original data that were not
included in the bootstrap sample. This is often referred to as the
&quot;out-of-bag&quot; (OOB) sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstraps(
  data,
  times = 25,
  strata = NULL,
  breaks = 4,
  pool = 0.1,
  apparent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstraps_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="bootstraps_+3A_times">times</code></td>
<td>
<p>The number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="bootstraps_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="bootstraps_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="bootstraps_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="bootstraps_+3A_apparent">apparent</code></td>
<td>
<p>A logical. Should an extra resample be added where the
analysis and holdout subset are the entire data set. This is required for
some estimators used by the <code>summary</code> function that require the apparent
error rate.</p>
</td></tr>
<tr><td><code id="bootstraps_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>apparent</code> enables the option of an additional
&quot;resample&quot; where the analysis and assessment data sets are the same as the
original data set. This can be required for some types of analysis of the
bootstrap results.
</p>
<p>With a <code>strata</code> argument, the random sampling is conducted
<em>within the stratification variable</em>. This can help ensure that the
resamples have equivalent proportions as the original data set. For
a categorical variable, sampling is conducted separately within each class.
For a numeric stratification variable, <code>strata</code> is binned into quartiles,
which are then used to stratify. Strata below 10% of the total are
pooled together; see <code><a href="#topic+make_strata">make_strata()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A tibble with classes <code>bootstraps</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and
<code>data.frame</code>. The results include a column for the data split objects and a
column called <code>id</code> that has a character string with the resample identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bootstraps(mtcars, times = 2)
bootstraps(mtcars, times = 2, apparent = TRUE)

library(purrr)
library(modeldata)
data(wa_churn)

set.seed(13)
resample1 &lt;- bootstraps(wa_churn, times = 3)
map_dbl(
  resample1$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

set.seed(13)
resample2 &lt;- bootstraps(wa_churn, strata = churn, times = 3)
map_dbl(
  resample2$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

set.seed(13)
resample3 &lt;- bootstraps(wa_churn, strata = tenure, breaks = 6, times = 3)
map_dbl(
  resample3$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

</code></pre>

<hr>
<h2 id='clustering_cv'>Cluster Cross-Validation</h2><span id='topic+clustering_cv'></span>

<h3>Description</h3>

<p>Cluster cross-validation splits the data into V groups of
disjointed sets using k-means clustering of some variables.
A resample of the analysis data consists of V-1 of the
folds/clusters while the assessment set contains the final fold/cluster. In
basic cross-validation (i.e. no repeats), the number of resamples
is equal to V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustering_cv(
  data,
  vars,
  v = 10,
  repeats = 1,
  distance_function = "dist",
  cluster_function = c("kmeans", "hclust"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustering_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="clustering_cv_+3A_vars">vars</code></td>
<td>
<p>A vector of bare variable names to use to cluster the data.</p>
</td></tr>
<tr><td><code id="clustering_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions of the data set.</p>
</td></tr>
<tr><td><code id="clustering_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the clustered partitioning.</p>
</td></tr>
<tr><td><code id="clustering_cv_+3A_distance_function">distance_function</code></td>
<td>
<p>Which function should be used for distance calculations?
Defaults to <code><a href="stats.html#topic+dist">stats::dist()</a></code>. You can also provide your own
function; see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="clustering_cv_+3A_cluster_function">cluster_function</code></td>
<td>
<p>Which function should be used for clustering?
Options are either <code>"kmeans"</code> (to use <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>)
or <code>"hclust"</code> (to use <code><a href="stats.html#topic+hclust">stats::hclust()</a></code>). You can also provide your own
function; see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="clustering_cv_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to <code>cluster_function</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variables in the <code>vars</code> argument are used for k-means clustering of
the data into disjointed sets or for hierarchical clustering of the data.
These clusters are used as the folds for cross-validation. Depending on how
the data are distributed, there may not be an equal number of points
in each fold.
</p>
<p>You can optionally provide a custom function to <code>distance_function</code>. The
function should take a data frame (as created via <code>data[vars]</code>) and return
a <code><a href="stats.html#topic+dist">stats::dist()</a></code> object with distances between data points.
</p>
<p>You can optionally provide a custom function to <code>cluster_function</code>. The
function must take three arguments:
</p>

<ul>
<li> <p><code>dists</code>, a <code><a href="stats.html#topic+dist">stats::dist()</a></code> object with distances between data points
</p>
</li>
<li> <p><code>v</code>, a length-1 numeric for the number of folds to create
</p>
</li>
<li> <p><code>...</code>, to pass any additional named arguments to your function
</p>
</li></ul>

<p>The function should return a vector of cluster assignments of length
<code>nrow(data)</code>, with each element of the vector corresponding to the matching
row of the data frame.
</p>


<h3>Value</h3>

<p>A tibble with classes <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>.
The results include a column for the data split objects and
an identification variable <code>id</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")
clustering_cv(ames, vars = c(Sale_Price, First_Flr_SF, Second_Flr_SF), v = 2)

</code></pre>

<hr>
<h2 id='complement'>Determine the Assessment Samples</h2><span id='topic+complement'></span><span id='topic+complement.rsplit'></span><span id='topic+complement.rof_split'></span><span id='topic+complement.sliding_window_split'></span><span id='topic+complement.sliding_index_split'></span><span id='topic+complement.sliding_period_split'></span><span id='topic+complement.apparent_split'></span>

<h3>Description</h3>

<p>This method and function help find which data belong in the analysis and
assessment sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complement(x, ...)

## S3 method for class 'rsplit'
complement(x, ...)

## S3 method for class 'rof_split'
complement(x, ...)

## S3 method for class 'sliding_window_split'
complement(x, ...)

## S3 method for class 'sliding_index_split'
complement(x, ...)

## S3 method for class 'sliding_period_split'
complement(x, ...)

## S3 method for class 'apparent_split'
complement(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complement_+3A_x">x</code></td>
<td>
<p>An <code>rsplit</code> object.</p>
</td></tr>
<tr><td><code id="complement_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an <code>rsplit</code> object, <code>complement()</code> will determine which
of the data rows are contained in the assessment set. To save space,
many of the <code>rsplit</code> objects will not contain indices for the
assessment split.
</p>


<h3>Value</h3>

<p>A integer vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+populate">populate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(28432)
fold_rs &lt;- vfold_cv(mtcars)
head(fold_rs$splits[[1]]$in_id)
fold_rs$splits[[1]]$out_id
complement(fold_rs$splits[[1]])
</code></pre>

<hr>
<h2 id='form_pred'>Extract Predictor Names from Formula or Terms</h2><span id='topic+form_pred'></span>

<h3>Description</h3>

<p><code>all.vars</code> returns all variables used in a formula. This
function only returns the variables explicitly used on the
right-hand side (i.e., it will not resolve dots unless the
object is terms with a data set specified).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_pred(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="form_pred_+3A_object">object</code></td>
<td>
<p>A model formula or <code><a href="stats.html#topic+terms">stats::terms()</a></code>
object.</p>
</td></tr>
<tr><td><code id="form_pred_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+all.vars">all.vars()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>form_pred(y ~ x + z)
form_pred(terms(y ~ x + z))

form_pred(y ~ x + log(z))
form_pred(log(y) ~ x + z)

form_pred(y1 + y2 ~ x + z)
form_pred(log(y1) + y2 ~ x + z)

# will fail:
# form_pred(y ~ .)

form_pred(terms(mpg ~ (.)^2, data = mtcars))
form_pred(terms(~ (.)^2, data = mtcars))
</code></pre>

<hr>
<h2 id='get_rsplit'>Retrieve individual rsplits objects from an rset</h2><span id='topic+get_rsplit'></span><span id='topic+get_rsplit.rset'></span><span id='topic+get_rsplit.default'></span>

<h3>Description</h3>

<p>Retrieve individual rsplits objects from an rset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rsplit(x, index, ...)

## S3 method for class 'rset'
get_rsplit(x, index, ...)

## Default S3 method:
get_rsplit(x, index, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rsplit_+3A_x">x</code></td>
<td>
<p>The <code>rset</code> object to retrieve an rsplit from.</p>
</td></tr>
<tr><td><code id="get_rsplit_+3A_index">index</code></td>
<td>
<p>An integer indicating which rsplit to retrieve: <code>1</code> for the
rsplit in the first row of the rset, <code>2</code> for the second, and so on.</p>
</td></tr>
<tr><td><code id="get_rsplit_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rsplit object in row <code>index</code> of <code>rset</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
(starting_splits &lt;- group_vfold_cv(mtcars, cyl, v = 3))
get_rsplit(starting_splits, 1)

</code></pre>

<hr>
<h2 id='group_bootstraps'>Group Bootstraps</h2><span id='topic+group_bootstraps'></span>

<h3>Description</h3>

<p>Group bootstrapping creates splits of the data based
on some grouping variable (which may have more than a single row
associated with it). A common use of this kind of resampling is when you
have repeated measures of the same subject.
A bootstrap sample is a sample that is the same size as the original data
set that is made using replacement. This results in analysis samples that
have multiple replicates of some of the original rows of the data. The
assessment set is defined as the rows of the original data that were not
included in the bootstrap sample. This is often referred to as the
&quot;out-of-bag&quot; (OOB) sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_bootstraps(
  data,
  group,
  times = 25,
  apparent = FALSE,
  ...,
  strata = NULL,
  pool = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_bootstraps_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="group_bootstraps_+3A_group">group</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used for
grouping observations with the same value to either the analysis or
assessment set within a fold.</p>
</td></tr>
<tr><td><code id="group_bootstraps_+3A_times">times</code></td>
<td>
<p>The number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="group_bootstraps_+3A_apparent">apparent</code></td>
<td>
<p>A logical. Should an extra resample be added where the
analysis and holdout subset are the entire data set. This is required for
some estimators used by the <code>summary</code> function that require the apparent
error rate.</p>
</td></tr>
<tr><td><code id="group_bootstraps_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="group_bootstraps_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="group_bootstraps_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>apparent</code> enables the option of an additional
&quot;resample&quot; where the analysis and assessment data sets are the same as the
original data set. This can be required for some types of analysis of the
bootstrap results.
</p>


<h3>Value</h3>

<p>An tibble with classes <code>group_bootstraps</code> <code>bootstraps</code>, <code>rset</code>,
<code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>. The results include a column for the data
split objects and a column called <code>id</code> that has a character string with the
resample identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")

set.seed(13)
group_bootstraps(ames, Neighborhood, times = 3)
group_bootstraps(ames, Neighborhood, times = 3, apparent = TRUE)

</code></pre>

<hr>
<h2 id='group_mc_cv'>Group Monte Carlo Cross-Validation</h2><span id='topic+group_mc_cv'></span>

<h3>Description</h3>

<p>Group Monte Carlo cross-validation creates splits of the data based
on some grouping variable (which may have more than a single row
associated with it). One resample of Monte Carlo cross-validation takes a
random sample (without replacement) of groups in the original data set to be
used for analysis. All other data points are added to the assessment set.
A common use of this kind of resampling is when you have
repeated measures of the same subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_mc_cv(
  data,
  group,
  prop = 3/4,
  times = 25,
  ...,
  strata = NULL,
  pool = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_mc_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="group_mc_cv_+3A_group">group</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used for
grouping observations with the same value to either the analysis or
assessment set within a fold.</p>
</td></tr>
<tr><td><code id="group_mc_cv_+3A_prop">prop</code></td>
<td>
<p>The proportion of data to be retained for modeling/analysis.</p>
</td></tr>
<tr><td><code id="group_mc_cv_+3A_times">times</code></td>
<td>
<p>The number of times to repeat the sampling.</p>
</td></tr>
<tr><td><code id="group_mc_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="group_mc_cv_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="group_mc_cv_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with classes <code>group_mc_cv</code>,
<code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>.
The results include a column for the data split objects and an
identification variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")

set.seed(123)
group_mc_cv(ames, group = Neighborhood, times = 5)

</code></pre>

<hr>
<h2 id='group_vfold_cv'>Group V-Fold Cross-Validation</h2><span id='topic+group_vfold_cv'></span>

<h3>Description</h3>

<p>Group V-fold cross-validation creates splits of the data based
on some grouping variable (which may have more than a single row
associated with it). The function can create as many splits as
there are unique values of the grouping variable or it can
create a smaller set of splits where more than one group is left
out at a time. A common use of this kind of resampling is when you have
repeated measures of the same subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_vfold_cv(
  data,
  group = NULL,
  v = NULL,
  repeats = 1,
  balance = c("groups", "observations"),
  ...,
  strata = NULL,
  pool = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_vfold_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="group_vfold_cv_+3A_group">group</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used for
grouping observations with the same value to either the analysis or
assessment set within a fold.</p>
</td></tr>
<tr><td><code id="group_vfold_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions of the data set. If left as <code>NULL</code> (the
default), <code>v</code> will be set to the number of unique values in the grouping
variable, creating &quot;leave-one-group-out&quot; splits.</p>
</td></tr>
<tr><td><code id="group_vfold_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the V-fold partitioning.</p>
</td></tr>
<tr><td><code id="group_vfold_cv_+3A_balance">balance</code></td>
<td>
<p>If <code>v</code> is less than the number of unique groups, how should
groups be combined into folds? Should be one of
<code>"groups"</code>, which will assign roughly the same number of groups to each
fold, or <code>"observations"</code>, which will assign roughly the same number of
observations to each fold.</p>
</td></tr>
<tr><td><code id="group_vfold_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="group_vfold_cv_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="group_vfold_cv_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with classes <code>group_vfold_cv</code>,
<code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and <code>data.frame</code>.
The results include a column for the data split objects and an
identification variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")

set.seed(123)
group_vfold_cv(ames, group = Neighborhood, v = 5)
group_vfold_cv(
  ames,
  group = Neighborhood,
  v = 5,
  balance = "observations"
)
group_vfold_cv(ames, group = Neighborhood, v = 5, repeats = 2)

# Leave-one-group-out CV
group_vfold_cv(ames, group = Neighborhood)

library(dplyr)
data(Sacramento, package = "modeldata")

city_strata &lt;- Sacramento %&gt;%
  group_by(city) %&gt;%
  summarize(strata = mean(price)) %&gt;%
  summarize(city = city,
            strata = cut(strata, quantile(strata), include.lowest = TRUE))

sacramento_data &lt;- Sacramento %&gt;%
  full_join(city_strata, by = "city")

group_vfold_cv(sacramento_data, city, strata = strata)

</code></pre>

<hr>
<h2 id='initial_split'>Simple Training/Test Set Splitting</h2><span id='topic+initial_split'></span><span id='topic+initial_time_split'></span><span id='topic+training'></span><span id='topic+training.default'></span><span id='topic+training.rsplit'></span><span id='topic+testing'></span><span id='topic+testing.default'></span><span id='topic+testing.rsplit'></span><span id='topic+group_initial_split'></span>

<h3>Description</h3>

<p><code>initial_split</code> creates a single binary split of the data into a training
set and testing set. <code>initial_time_split</code> does the same, but takes the
<em>first</em> <code>prop</code> samples for training, instead of a random selection.
<code>group_initial_split</code> creates splits of the data based
on some grouping variable, so that all data in a &quot;group&quot; is assigned to
the same split.
<code>training</code> and <code>testing</code> are used to extract the resulting data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_split(data, prop = 3/4, strata = NULL, breaks = 4, pool = 0.1, ...)

initial_time_split(data, prop = 3/4, lag = 0, ...)

training(x, ...)

## Default S3 method:
training(x, ...)

## S3 method for class 'rsplit'
training(x, ...)

testing(x, ...)

## Default S3 method:
testing(x, ...)

## S3 method for class 'rsplit'
testing(x, ...)

group_initial_split(data, group, prop = 3/4, ..., strata = NULL, pool = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_split_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_prop">prop</code></td>
<td>
<p>The proportion of data to be retained for modeling/analysis.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_lag">lag</code></td>
<td>
<p>A value to include a lag between the assessment
and analysis set. This is useful if lagged predictors will be used
during training and testing.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_x">x</code></td>
<td>
<p>An <code>rsplit</code> object produced by <code>initial_split()</code> or
<code>initial_time_split()</code>.</p>
</td></tr>
<tr><td><code id="initial_split_+3A_group">group</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used for
grouping observations with the same value to either the analysis or
assessment set within a fold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a <code>strata</code> argument, the random sampling is conducted
<em>within the stratification variable</em>. This can help ensure that the
resamples have equivalent proportions as the original data set. For
a categorical variable, sampling is conducted separately within each class.
For a numeric stratification variable, <code>strata</code> is binned into quartiles,
which are then used to stratify. Strata below 10% of the total are
pooled together; see <code><a href="#topic+make_strata">make_strata()</a></code> for more details.
</p>


<h3>Value</h3>

<p>An <code>rsplit</code> object that can be used with the <code>training</code> and <code>testing</code>
functions to extract the data in each split.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1353)
car_split &lt;- initial_split(mtcars)
train_data &lt;- training(car_split)
test_data &lt;- testing(car_split)

data(drinks, package = "modeldata")
drinks_split &lt;- initial_time_split(drinks)
train_data &lt;- training(drinks_split)
test_data &lt;- testing(drinks_split)
c(max(train_data$date), min(test_data$date)) # no lag

# With 12 period lag
drinks_lag_split &lt;- initial_time_split(drinks, lag = 12)
train_data &lt;- training(drinks_lag_split)
test_data &lt;- testing(drinks_lag_split)
c(max(train_data$date), min(test_data$date)) # 12 period lag

set.seed(1353)
car_split &lt;- group_initial_split(mtcars, cyl)
train_data &lt;- training(car_split)
test_data &lt;- testing(car_split)

</code></pre>

<hr>
<h2 id='initial_validation_split'>Create an Initial Train/Validation/Test Split</h2><span id='topic+initial_validation_split'></span><span id='topic+initial_validation_time_split'></span><span id='topic+group_initial_validation_split'></span><span id='topic+training.initial_validation_split'></span><span id='topic+testing.initial_validation_split'></span><span id='topic+validation'></span><span id='topic+validation.default'></span><span id='topic+validation.initial_validation_split'></span>

<h3>Description</h3>

<p><code>initial_validation_split()</code> creates a random three-way split of the data
into a training set, a validation set, and a testing set.
<code>initial_validation_time_split()</code> does the same, but instead of a random
selection the training, validation, and testing set are in order of the full
data set, with the first observations being put into the training set.
<code>group_initial_validation_split()</code> creates similar random splits of the data
based on some grouping variable, so that all data in a &quot;group&quot; are assigned
to the same partition.
<code>training()</code>, <code>validation()</code>, and <code>testing()</code> can be used to extract the
resulting data sets.
Use <code><a href="#topic+validation_set">validation_set()</a></code> to create an <code>rset</code> object for use with functions from
the tune package such as <code>tune::tune_grid()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_validation_split(
  data,
  prop = c(0.6, 0.2),
  strata = NULL,
  breaks = 4,
  pool = 0.1,
  ...
)

initial_validation_time_split(data, prop = c(0.6, 0.2), ...)

group_initial_validation_split(
  data,
  group,
  prop = c(0.6, 0.2),
  ...,
  strata = NULL,
  pool = 0.1
)

## S3 method for class 'initial_validation_split'
training(x, ...)

## S3 method for class 'initial_validation_split'
testing(x, ...)

validation(x, ...)

## Default S3 method:
validation(x, ...)

## S3 method for class 'initial_validation_split'
validation(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_validation_split_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="initial_validation_split_+3A_prop">prop</code></td>
<td>
<p>A length-2 vector of proportions of data to be retained for training and
validation data, respectively.</p>
</td></tr>
<tr><td><code id="initial_validation_split_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="initial_validation_split_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="initial_validation_split_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="initial_validation_split_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="initial_validation_split_+3A_group">group</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used for
grouping observations with the same value to either the analysis or
assessment set within a fold.</p>
</td></tr>
<tr><td><code id="initial_validation_split_+3A_x">x</code></td>
<td>
<p>An object of class <code>initial_validation_split</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a <code>strata</code> argument, the random sampling is conducted
<em>within the stratification variable</em>. This can help ensure that the
resamples have equivalent proportions as the original data set. For
a categorical variable, sampling is conducted separately within each class.
For a numeric stratification variable, <code>strata</code> is binned into quartiles,
which are then used to stratify. Strata below 10% of the total are
pooled together; see <code><a href="#topic+make_strata">make_strata()</a></code> for more details.
</p>


<h3>Value</h3>

<p>An <code>initial_validation_split</code> object that can be used with the
<code><a href="#topic+training">training()</a></code>, <code><a href="#topic+validation">validation()</a></code>, and <code><a href="#topic+testing">testing()</a></code> functions to extract the data
in each split.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+validation_set">validation_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1353)
car_split &lt;- initial_validation_split(mtcars)
train_data &lt;- training(car_split)
validation_data &lt;- validation(car_split)
test_data &lt;- testing(car_split)

data(drinks, package = "modeldata")
drinks_split &lt;- initial_validation_time_split(drinks)
train_data &lt;- training(drinks_split)
validation_data &lt;- validation(drinks_split)
c(max(train_data$date), min(validation_data$date))

data(ames, package = "modeldata")
set.seed(1353)
ames_split &lt;- group_initial_validation_split(ames, group = Neighborhood)
train_data &lt;- training(ames_split)
validation_data &lt;- validation(ames_split)
test_data &lt;- testing(ames_split)

</code></pre>

<hr>
<h2 id='int_pctl'>Bootstrap confidence intervals</h2><span id='topic+int_pctl'></span><span id='topic+int_pctl.bootstraps'></span><span id='topic+int_t'></span><span id='topic+int_t.bootstraps'></span><span id='topic+int_bca'></span><span id='topic+int_bca.bootstraps'></span>

<h3>Description</h3>

<p>Calculate bootstrap confidence intervals using various methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_pctl(.data, ...)

## S3 method for class 'bootstraps'
int_pctl(.data, statistics, alpha = 0.05, ...)

int_t(.data, ...)

## S3 method for class 'bootstraps'
int_t(.data, statistics, alpha = 0.05, ...)

int_bca(.data, ...)

## S3 method for class 'bootstraps'
int_bca(.data, statistics, alpha = 0.05, .fn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int_pctl_+3A_.data">.data</code></td>
<td>
<p>A data frame containing the bootstrap resamples created using
<code>bootstraps()</code>. For t- and BCa-intervals, the <code>apparent</code> argument
should be set to <code>TRUE</code>. Even if the <code>apparent</code> argument is set to
<code>TRUE</code> for the percentile method, the apparent data is never used in calculating
the percentile confidence interval.</p>
</td></tr>
<tr><td><code id="int_pctl_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>.fn</code> (<code>int_bca()</code> only).</p>
</td></tr>
<tr><td><code id="int_pctl_+3A_statistics">statistics</code></td>
<td>
<p>An unquoted column name or <code>dplyr</code> selector that identifies
a single column in the data set containing the individual bootstrap
estimates. This must be a list column of tidy tibbles (with columns
<code>term</code> and <code>estimate</code>). For t-intervals, a
standard tidy column (usually called <code>std.err</code>) is required.
See the examples below.</p>
</td></tr>
<tr><td><code id="int_pctl_+3A_alpha">alpha</code></td>
<td>
<p>Level of significance.</p>
</td></tr>
<tr><td><code id="int_pctl_+3A_.fn">.fn</code></td>
<td>
<p>A function to calculate statistic of interest. The
function should take an <code>rsplit</code> as the first argument and the <code>...</code> are
required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Percentile intervals are the standard method of
obtaining confidence intervals but require thousands of
resamples to be accurate. T-intervals may need fewer
resamples but require a corresponding variance estimate.
Bias-corrected and accelerated intervals require the original function
that was used to create the statistics of interest and are
computationally taxing.
</p>


<h3>Value</h3>

<p>Each function returns a tibble with columns <code>.lower</code>,
<code>.estimate</code>, <code>.upper</code>, <code>.alpha</code>, <code>.method</code>, and <code>term</code>.
<code>.method</code> is the type of interval (eg. &quot;percentile&quot;,
&quot;student-t&quot;, or &quot;BCa&quot;). <code>term</code> is the name of the estimate. Note
the <code>.estimate</code> returned from <code>int_pctl()</code>
is the mean of the estimates from the bootstrap resamples
and not the estimate from the apparent model.
</p>


<h3>References</h3>

<p><a href="https://rsample.tidymodels.org/articles/Applications/Intervals.html">https://rsample.tidymodels.org/articles/Applications/Intervals.html</a>
</p>
<p>Davison, A., &amp; Hinkley, D. (1997). <em>Bootstrap Methods and their
Application</em>. Cambridge: Cambridge University Press.
doi:10.1017/CBO9780511802843
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reg_intervals">reg_intervals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(broom)
library(dplyr)
library(purrr)
library(tibble)

lm_est &lt;- function(split, ...) {
  lm(mpg ~ disp + hp, data = analysis(split)) %&gt;%
    tidy()
}

set.seed(52156)
car_rs &lt;-
  bootstraps(mtcars, 500, apparent = TRUE) %&gt;%
  mutate(results = map(splits, lm_est))

int_pctl(car_rs, results)
int_t(car_rs, results)
int_bca(car_rs, results, .fn = lm_est)

# putting results into a tidy format
rank_corr &lt;- function(split) {
  dat &lt;- analysis(split)
  tibble(
    term = "corr",
    estimate = cor(dat$sqft, dat$price, method = "spearman"),
    # don't know the analytical std.err so no t-intervals
    std.err = NA_real_
  )
}

set.seed(69325)
data(Sacramento, package = "modeldata")
bootstraps(Sacramento, 1000, apparent = TRUE) %&gt;%
  mutate(correlations = map(splits, rank_corr)) %&gt;%
  int_pctl(correlations)


</code></pre>

<hr>
<h2 id='labels.rset'>Find Labels from rset Object</h2><span id='topic+labels.rset'></span><span id='topic+labels.vfold_cv'></span>

<h3>Description</h3>

<p>Produce a vector of resampling labels (e.g. &quot;Fold1&quot;) from
an <code>rset</code> object. Currently, <code>nested_cv</code>
is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rset'
labels(object, make_factor = FALSE, ...)

## S3 method for class 'vfold_cv'
labels(object, make_factor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labels.rset_+3A_object">object</code></td>
<td>
<p>An <code>rset</code> object</p>
</td></tr>
<tr><td><code id="labels.rset_+3A_make_factor">make_factor</code></td>
<td>
<p>A logical for whether the results should be
a character or a factor.</p>
</td></tr>
<tr><td><code id="labels.rset_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single character or factor vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labels(vfold_cv(mtcars))
</code></pre>

<hr>
<h2 id='labels.rsplit'>Find Labels from rsplit Object</h2><span id='topic+labels.rsplit'></span>

<h3>Description</h3>

<p>Produce a tibble of identification variables so that single
splits can be linked to a particular resample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rsplit'
labels(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labels.rsplit_+3A_object">object</code></td>
<td>
<p>An <code>rsplit</code> object</p>
</td></tr>
<tr><td><code id="labels.rsplit_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>


<h3>See Also</h3>

<p>add_resample_id
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cv_splits &lt;- vfold_cv(mtcars)
labels(cv_splits$splits[[1]])
</code></pre>

<hr>
<h2 id='loo_cv'>Leave-One-Out Cross-Validation</h2><span id='topic+loo_cv'></span>

<h3>Description</h3>

<p>Leave-one-out (LOO) cross-validation uses one data point in the original
set as the assessment data and all other data points as the analysis set. A
LOO resampling set has as many resamples as rows in the original data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo_cv(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="loo_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An tibble with classes <code>loo_cv</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and
<code>data.frame</code>. The results include a column for the data split objects and
one column called <code>id</code> that has a character string with the resample
identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loo_cv(mtcars)
</code></pre>

<hr>
<h2 id='make_groups'>Make groupings for grouped rsplits</h2><span id='topic+make_groups'></span>

<h3>Description</h3>

<p>This function powers grouped resampling by splitting the data based upon
a grouping variable and returning the assessment set indices for each
split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_groups(
  data,
  group,
  v,
  balance = c("groups", "observations", "prop"),
  strata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_groups_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="make_groups_+3A_group">group</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used for
grouping observations with the same value to either the analysis or
assessment set within a fold.</p>
</td></tr>
<tr><td><code id="make_groups_+3A_v">v</code></td>
<td>
<p>The number of partitions of the data set.</p>
</td></tr>
<tr><td><code id="make_groups_+3A_balance">balance</code></td>
<td>
<p>If <code>v</code> is less than the number of unique groups, how should
groups be combined into folds? Should be one of
<code>"groups"</code>, <code>"observations"</code>, <code>"prop"</code>.</p>
</td></tr>
<tr><td><code id="make_groups_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="make_groups_+3A_...">...</code></td>
<td>
<p>Arguments passed to balance functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all <code>balance</code> options are accepted &ndash; or make sense &ndash; for all resampling
functions. For instance, <code>balance = "prop"</code> assigns groups to folds at
random, meaning that any given observation is not guaranteed to be in one
(and only one) assessment set. That means <code>balance = "prop"</code> can't
be used with <code><a href="#topic+group_vfold_cv">group_vfold_cv()</a></code>, and so isn't an option available for that
function.
</p>
<p>Similarly, <code><a href="#topic+group_mc_cv">group_mc_cv()</a></code> and its derivatives don't assign data to one (and
only one) assessment set, but rather allow each observation to be in an
assessment set zero-or-more times. As a result, those functions don't have
a <code>balance</code> argument, and under the hood always specify <code>balance = "prop"</code>
when they call <code><a href="#topic+make_groups">make_groups()</a></code>.
</p>

<hr>
<h2 id='make_splits'>Constructors for split objects</h2><span id='topic+make_splits'></span><span id='topic+make_splits.default'></span><span id='topic+make_splits.list'></span><span id='topic+make_splits.data.frame'></span>

<h3>Description</h3>

<p>Constructors for split objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_splits(x, ...)

## Default S3 method:
make_splits(x, ...)

## S3 method for class 'list'
make_splits(x, data, class = NULL, ...)

## S3 method for class 'data.frame'
make_splits(x, assessment, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_splits_+3A_x">x</code></td>
<td>
<p>A list of integers with names &quot;analysis&quot; and &quot;assessment&quot;, or a
data frame of analysis or training data.</p>
</td></tr>
<tr><td><code id="make_splits_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="make_splits_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="make_splits_+3A_class">class</code></td>
<td>
<p>An optional class to give the object.</p>
</td></tr>
<tr><td><code id="make_splits_+3A_assessment">assessment</code></td>
<td>
<p>A data frame of assessment or testing data, which can be empty.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  year = 1900:1999,
  value = 10 + 8*1900:1999 + runif(100L, 0, 100)
)
split_from_indices &lt;- make_splits(
  x = list(analysis = which(df$year &lt;= 1980),
           assessment = which(df$year &gt; 1980)),
  data = df
)
split_from_data_frame &lt;- make_splits(
  x = df[df$year &lt;= 1980,],
  assessment = df[df$year &gt; 1980,]
)
identical(split_from_indices, split_from_data_frame)
</code></pre>

<hr>
<h2 id='make_strata'>Create or Modify Stratification Variables</h2><span id='topic+make_strata'></span>

<h3>Description</h3>

<p>This function can create strata from numeric data and make non-numeric data
more conducive for stratification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_strata(x, breaks = 4, nunique = 5, pool = 0.1, depth = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_strata_+3A_x">x</code></td>
<td>
<p>An input vector.</p>
</td></tr>
<tr><td><code id="make_strata_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="make_strata_+3A_nunique">nunique</code></td>
<td>
<p>An integer for the number of unique value threshold in the
algorithm.</p>
</td></tr>
<tr><td><code id="make_strata_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="make_strata_+3A_depth">depth</code></td>
<td>
<p>An integer that is used to determine the best number of
percentiles that should be used. The number of bins are based on
<code>min(5, floor(n / depth))</code> where <code>n = length(x)</code>.
If <code>x</code> is numeric, there must be at least 40 rows in the data set
(when <code>depth = 20</code>) to conduct stratified sampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For numeric data, if the number of unique levels is less than
<code>nunique</code>, the data are treated as categorical data.
</p>
<p>For categorical inputs, the function will find levels of <code>x</code> than
occur in the data with percentage less than <code>pool</code>. The values from
these groups will be randomly assigned to the remaining strata (as will
data points that have missing values in <code>x</code>).
</p>
<p>For numeric data with more unique values than <code>nunique</code>, the data
will be converted to being categorical based on percentiles of the data.
The percentile groups will have no more than 20 percent of the data in
each group. Again, missing values in <code>x</code> are randomly assigned
to groups.
</p>


<h3>Value</h3>

<p>A factor vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(61)
x1 &lt;- rpois(100, lambda = 5)
table(x1)
table(make_strata(x1))

set.seed(554)
x2 &lt;- rpois(100, lambda = 1)
table(x2)
table(make_strata(x2))

# small groups are randomly assigned
x3 &lt;- factor(x2)
table(x3)
table(make_strata(x3))

# `oilType` data from `caret`
x4 &lt;- rep(LETTERS[1:7], c(37, 26, 3, 7, 11, 10, 2))
table(x4)
table(make_strata(x4))
table(make_strata(x4, pool = 0.1))
table(make_strata(x4, pool = 0.0))

# not enough data to stratify
x5 &lt;- rnorm(20)
table(make_strata(x5))

set.seed(483)
x6 &lt;- rnorm(200)
quantile(x6, probs = (0:10) / 10)
table(make_strata(x6, breaks = 10))
</code></pre>

<hr>
<h2 id='manual_rset'>Manual resampling</h2><span id='topic+manual_rset'></span>

<h3>Description</h3>

<p><code>manual_rset()</code> is used for constructing the most minimal rset possible. It
can be useful when you have custom rsplit objects built from
<code><a href="#topic+make_splits">make_splits()</a></code>, or when you want to create a new rset from splits
contained within an existing rset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manual_rset(splits, ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manual_rset_+3A_splits">splits</code></td>
<td>
<p>A list of <code>"rsplit"</code> objects. It is easiest to create these
using <code><a href="#topic+make_splits">make_splits()</a></code>.</p>
</td></tr>
<tr><td><code id="manual_rset_+3A_ids">ids</code></td>
<td>
<p>A character vector of ids. The length of <code>ids</code> must be the same
as the length of <code>splits</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c(1, 2, 3, 4, 5, 6))

# Create an rset from custom indices
indices &lt;- list(
  list(analysis = c(1L, 2L), assessment = 3L),
  list(analysis = c(4L, 5L), assessment = 6L)
)

splits &lt;- lapply(indices, make_splits, data = df)

manual_rset(splits, c("Split 1", "Split 2"))

# You can also use this to create an rset from a subset of an
# existing rset
resamples &lt;- vfold_cv(mtcars)
best_split &lt;- resamples[5, ]
manual_rset(best_split$splits, best_split$id)
</code></pre>

<hr>
<h2 id='mc_cv'>Monte Carlo Cross-Validation</h2><span id='topic+mc_cv'></span>

<h3>Description</h3>

<p>One resample of Monte Carlo cross-validation takes a random sample (without
replacement) of the original data set to be used for analysis. All other
data points are added to the assessment set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_cv(data, prop = 3/4, times = 25, strata = NULL, breaks = 4, pool = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="mc_cv_+3A_prop">prop</code></td>
<td>
<p>The proportion of data to be retained for modeling/analysis.</p>
</td></tr>
<tr><td><code id="mc_cv_+3A_times">times</code></td>
<td>
<p>The number of times to repeat the sampling.</p>
</td></tr>
<tr><td><code id="mc_cv_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="mc_cv_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="mc_cv_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="mc_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a <code>strata</code> argument, the random sampling is conducted
<em>within the stratification variable</em>. This can help ensure that the
resamples have equivalent proportions as the original data set. For
a categorical variable, sampling is conducted separately within each class.
For a numeric stratification variable, <code>strata</code> is binned into quartiles,
which are then used to stratify. Strata below 10% of the total are
pooled together; see <code><a href="#topic+make_strata">make_strata()</a></code> for more details.
</p>


<h3>Value</h3>

<p>An tibble with classes <code>mc_cv</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and
<code>data.frame</code>. The results include a column for the data split objects and a
column called <code>id</code> that has a character string with the resample identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mc_cv(mtcars, times = 2)
mc_cv(mtcars, prop = .5, times = 2)

library(purrr)
data(wa_churn, package = "modeldata")

set.seed(13)
resample1 &lt;- mc_cv(wa_churn, times = 3, prop = .5)
map_dbl(
  resample1$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

set.seed(13)
resample2 &lt;- mc_cv(wa_churn, strata = churn, times = 3, prop = .5)
map_dbl(
  resample2$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

set.seed(13)
resample3 &lt;- mc_cv(wa_churn, strata = tenure, breaks = 6, times = 3, prop = .5)
map_dbl(
  resample3$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

</code></pre>

<hr>
<h2 id='nested_cv'>Nested or Double Resampling</h2><span id='topic+nested_cv'></span>

<h3>Description</h3>

<p><code>nested_cv</code> can be used to take the results of one resampling procedure
and conduct further resamples within each split. Any type of resampling
used in <code>rsample</code> can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_cv(data, outside, inside)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nested_cv_+3A_outside">outside</code></td>
<td>
<p>The initial resampling specification. This can be an already
created object or an expression of a new object (see the examples below).
If the latter is used, the <code>data</code> argument does not need to be
specified and, if it is given, will be ignored.</p>
</td></tr>
<tr><td><code id="nested_cv_+3A_inside">inside</code></td>
<td>
<p>An expression for the type of resampling to be conducted
within the initial procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a bad idea to use bootstrapping as the outer resampling procedure (see
the example below)
</p>


<h3>Value</h3>

<p>An tibble with <code>nested_cv</code> class and any other classes that
outer resampling process normally contains. The results include a
column for the outer data split objects, one or more <code>id</code> columns,
and a column of nested tibbles called <code>inner_resamples</code> with the
additional resamples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using expressions for the resampling procedures:
nested_cv(mtcars, outside = vfold_cv(v = 3), inside = bootstraps(times = 5))

## Using an existing object:
folds &lt;- vfold_cv(mtcars)
nested_cv(mtcars, folds, inside = bootstraps(times = 5))

## The dangers of outer bootstraps:
set.seed(2222)
bad_idea &lt;- nested_cv(mtcars,
  outside = bootstraps(times = 5),
  inside = vfold_cv(v = 3)
)

first_outer_split &lt;- bad_idea$splits[[1]]
outer_analysis &lt;- as.data.frame(first_outer_split)
sum(grepl("Volvo 142E", rownames(outer_analysis)))

## For the 3-fold CV used inside of each bootstrap, how are the replicated
## `Volvo 142E` data partitioned?
first_inner_split &lt;- bad_idea$inner_resamples[[1]]$splits[[1]]
inner_analysis &lt;- as.data.frame(first_inner_split)
inner_assess &lt;- as.data.frame(first_inner_split, data = "assessment")

sum(grepl("Volvo 142E", rownames(inner_analysis)))
sum(grepl("Volvo 142E", rownames(inner_assess)))
</code></pre>

<hr>
<h2 id='new_rset'>Constructor for new rset objects</h2><span id='topic+new_rset'></span>

<h3>Description</h3>

<p>Constructor for new rset objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_rset(splits, ids, attrib = NULL, subclass = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_rset_+3A_splits">splits</code></td>
<td>
<p>A list column of <code>rsplits</code> or a tibble with a single column
called &quot;splits&quot; with a list column of <code>rsplits</code>.</p>
</td></tr>
<tr><td><code id="new_rset_+3A_ids">ids</code></td>
<td>
<p>A character vector or a tibble with one or more columns that
begin with &quot;id&quot;.</p>
</td></tr>
<tr><td><code id="new_rset_+3A_attrib">attrib</code></td>
<td>
<p>An optional named list of attributes to add to the object.</p>
</td></tr>
<tr><td><code id="new_rset_+3A_subclass">subclass</code></td>
<td>
<p>A character vector of subclasses to add.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once the new <code>rset</code> is constructed, an additional attribute called
&quot;fingerprint&quot; is added that is a hash of the <code>rset</code>. This can be used to
make sure other objects have the exact same resamples.
</p>


<h3>Value</h3>

<p>An <code>rset</code> object.
</p>

<hr>
<h2 id='permutations'>Permutation sampling</h2><span id='topic+permutations'></span>

<h3>Description</h3>

<p>A permutation sample is the same size as the original data set and is made
by permuting/shuffling one or more columns. This results in analysis
samples where some columns are in their original order and some columns
are permuted to a random order. Unlike other sampling functions in
<code>rsample</code>, there is no assessment set and calling <code>assessment()</code> on a
permutation split will throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(data, permute = NULL, times = 25, apparent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutations_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="permutations_+3A_permute">permute</code></td>
<td>
<p>One or more columns to shuffle. This argument supports
<code>tidyselect</code> selectors. Multiple expressions can be combined with <code>c()</code>.
Variable names can be used as if they were positions in the data frame, so
expressions like <code>x:y</code> can be used to select a range of variables.
See <code><a href="tidyselect.html#topic+language">language</a></code> for more details.</p>
</td></tr>
<tr><td><code id="permutations_+3A_times">times</code></td>
<td>
<p>The number of permutation samples.</p>
</td></tr>
<tr><td><code id="permutations_+3A_apparent">apparent</code></td>
<td>
<p>A logical. Should an extra resample be added where the
analysis is the standard data set.</p>
</td></tr>
<tr><td><code id="permutations_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>apparent</code> enables the option of an additional
&quot;resample&quot; where the analysis data set is the same as the original data
set. Permutation-based resampling can be especially helpful for computing
a statistic under the null hypothesis (e.g. t-statistic). This forms the
basis of a permutation test, which computes a test statistic under all
possible permutations of the data.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with classes <code>permutations</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and
<code>data.frame</code>. The results include a column for the data split objects and a
column called <code>id</code> that has a character string with the resample
identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>permutations(mtcars, mpg, times = 2)
permutations(mtcars, mpg, times = 2, apparent = TRUE)

library(purrr)
resample1 &lt;- permutations(mtcars, starts_with("c"), times = 1)
resample1$splits[[1]] %&gt;% analysis()

resample2 &lt;- permutations(mtcars, hp, times = 10, apparent = TRUE)
map_dbl(resample2$splits, function(x) {
  t.test(hp ~ vs, data = analysis(x))$statistic
})
</code></pre>

<hr>
<h2 id='populate'>Add Assessment Indices</h2><span id='topic+populate'></span>

<h3>Description</h3>

<p>Many <code>rsplit</code> and <code>rset</code> objects do not contain indicators for
the assessment samples. <code>populate()</code> can be used to fill the slot
for the appropriate indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>populate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="populate_+3A_x">x</code></td>
<td>
<p>A <code>rsplit</code> and <code>rset</code> object.</p>
</td></tr>
<tr><td><code id="populate_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same kind with the integer indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(28432)
fold_rs &lt;- vfold_cv(mtcars)

fold_rs$splits[[1]]$out_id
complement(fold_rs$splits[[1]])

populate(fold_rs$splits[[1]])$out_id

fold_rs_all &lt;- populate(fold_rs)
fold_rs_all$splits[[1]]$out_id
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+contains'></span><span id='topic+select_helpers'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+starts_with'></span><span id='topic+last_col'></span><span id='topic+any_of'></span><span id='topic+all_of'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+all_of">all_of</a></code>, <code><a href="tidyselect.html#topic+all_of">any_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reg_intervals'>A convenience function for confidence intervals with linear-ish parametric models</h2><span id='topic+reg_intervals'></span>

<h3>Description</h3>

<p>A convenience function for confidence intervals with linear-ish parametric models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_intervals(
  formula,
  data,
  model_fn = "lm",
  type = "student-t",
  times = NULL,
  alpha = 0.05,
  filter = term != "(Intercept)",
  keep_reps = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reg_intervals_+3A_formula">formula</code></td>
<td>
<p>An R model formula with one outcome and at least one predictor.</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_model_fn">model_fn</code></td>
<td>
<p>The model to fit. Allowable values are &quot;lm&quot;, &quot;glm&quot;,
&quot;survreg&quot;, and &quot;coxph&quot;. The latter two require that the <code>survival</code> package
be installed.</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_type">type</code></td>
<td>
<p>The type of bootstrap confidence interval. Values of &quot;student-t&quot; and
&quot;percentile&quot; are allowed.</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_times">times</code></td>
<td>
<p>A single integer for the number of bootstrap samples. If left
NULL, 1,001 are used for t-intervals and 2,001 for percentile intervals.</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_alpha">alpha</code></td>
<td>
<p>Level of significance.</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_filter">filter</code></td>
<td>
<p>A logical expression used to remove rows from the final result, or <code>NULL</code> to keep all rows.</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_keep_reps">keep_reps</code></td>
<td>
<p>Should the individual parameter estimates for each bootstrap
sample be retained?</p>
</td></tr>
<tr><td><code id="reg_intervals_+3A_...">...</code></td>
<td>
<p>Options to pass to the model function (such as <code>family</code> for <code>glm()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns &quot;term&quot;, &quot;.lower&quot;, &quot;.estimate&quot;, &quot;.upper&quot;,
&quot;.alpha&quot;, and &quot;.method&quot;. If <code>keep_reps = TRUE</code>, an additional list column
called &quot;.replicates&quot; is also returned.
</p>


<h3>References</h3>

<p>Davison, A., &amp; Hinkley, D. (1997). <em>Bootstrap Methods and their
Application</em>. Cambridge: Cambridge University Press.
doi:10.1017/CBO9780511802843
</p>
<p><em>Bootstrap Confidence Intervals</em>,
<a href="https://rsample.tidymodels.org/articles/Applications/Intervals.html">https://rsample.tidymodels.org/articles/Applications/Intervals.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int_pctl">int_pctl()</a></code>, <code><a href="#topic+int_t">int_t()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)
reg_intervals(mpg ~ I(1 / sqrt(disp)), data = mtcars)

set.seed(1)
reg_intervals(mpg ~ I(1 / sqrt(disp)), data = mtcars, keep_reps = TRUE)


</code></pre>

<hr>
<h2 id='reshuffle_rset'>&quot;Reshuffle&quot; an rset to re-generate a new rset with the same parameters</h2><span id='topic+reshuffle_rset'></span>

<h3>Description</h3>

<p>This function re-generates an rset object, using the same arguments used
to generate the original.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshuffle_rset(rset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reshuffle_rset_+3A_rset">rset</code></td>
<td>
<p>The <code>rset</code> object to be reshuffled</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rset of the same class as <code>rset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
(starting_splits &lt;- group_vfold_cv(mtcars, cyl, v = 3))
reshuffle_rset(starting_splits)

</code></pre>

<hr>
<h2 id='reverse_splits'>Reverse the analysis and assessment sets</h2><span id='topic+reverse_splits'></span><span id='topic+reverse_splits.default'></span><span id='topic+reverse_splits.permutations'></span><span id='topic+reverse_splits.perm_split'></span><span id='topic+reverse_splits.rsplit'></span><span id='topic+reverse_splits.rset'></span>

<h3>Description</h3>

<p>This functions &quot;swaps&quot; the analysis and assessment sets of either a single
<code>rsplit</code> or all <code>rsplit</code>s in the <code>splits</code> column of an <code>rset</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_splits(x, ...)

## Default S3 method:
reverse_splits(x, ...)

## S3 method for class 'permutations'
reverse_splits(x, ...)

## S3 method for class 'perm_split'
reverse_splits(x, ...)

## S3 method for class 'rsplit'
reverse_splits(x, ...)

## S3 method for class 'rset'
reverse_splits(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_splits_+3A_x">x</code></td>
<td>
<p>An <code>rset</code> or <code>rsplit</code> object.</p>
</td></tr>
<tr><td><code id="reverse_splits_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
starting_splits &lt;- vfold_cv(mtcars, v = 3)
reverse_splits(starting_splits)
reverse_splits(starting_splits$splits[[1]])

</code></pre>

<hr>
<h2 id='rolling_origin'>Rolling Origin Forecast Resampling</h2><span id='topic+rolling_origin'></span>

<h3>Description</h3>

<p>This resampling method is useful when the data set has a strong time
component. The resamples are not random and contain data points that are
consecutive values. The function assumes that the original data set are
sorted in time order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_origin(
  data,
  initial = 5,
  assess = 1,
  cumulative = TRUE,
  skip = 0,
  lag = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rolling_origin_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="rolling_origin_+3A_initial">initial</code></td>
<td>
<p>The number of samples used for analysis/modeling in the
initial resample.</p>
</td></tr>
<tr><td><code id="rolling_origin_+3A_assess">assess</code></td>
<td>
<p>The number of samples used for each assessment resample.</p>
</td></tr>
<tr><td><code id="rolling_origin_+3A_cumulative">cumulative</code></td>
<td>
<p>A logical. Should the analysis resample grow beyond the
size specified by <code>initial</code> at each resample?.</p>
</td></tr>
<tr><td><code id="rolling_origin_+3A_skip">skip</code></td>
<td>
<p>A integer indicating how many (if any) <em>additional</em> resamples
to skip to thin the total amount of data points in the analysis resample.
See the example below.</p>
</td></tr>
<tr><td><code id="rolling_origin_+3A_lag">lag</code></td>
<td>
<p>A value to include a lag between the assessment
and analysis set. This is useful if lagged predictors will be used
during training and testing.</p>
</td></tr>
<tr><td><code id="rolling_origin_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main options, <code>initial</code> and <code>assess</code>, control the number of
data points from the original data that are in the analysis and assessment
set, respectively. When <code>cumulative = TRUE</code>, the analysis set will grow as
resampling continues while the assessment set size will always remain
static.
<code>skip</code> enables the function to not use every data point in the resamples.
When <code>skip = 0</code>, the resampling data sets will increment by one position.
Suppose that the rows of a data set are consecutive days. Using <code>skip = 6</code>
will make the analysis data set to operate on <em>weeks</em> instead of days. The
assessment set size is not affected by this option.
</p>


<h3>Value</h3>

<p>An tibble with classes <code>rolling_origin</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>,
and <code>data.frame</code>. The results include a column for the data split objects
and a column called <code>id</code> that has a character string with the resample
identifier.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sliding_window">sliding_window()</a></code>, <code><a href="#topic+sliding_index">sliding_index()</a></code>, and <code><a href="#topic+sliding_period">sliding_period()</a></code> for additional
time based resampling functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1131)
ex_data &lt;- data.frame(row = 1:20, some_var = rnorm(20))
dim(rolling_origin(ex_data))
dim(rolling_origin(ex_data, skip = 2))
dim(rolling_origin(ex_data, skip = 2, cumulative = FALSE))

# You can also roll over calendar periods by first nesting by that period,
# which is especially useful for irregular series where a fixed window
# is not useful. This example slides over 5 years at a time.
library(dplyr)
library(tidyr)
data(drinks, package = "modeldata")

drinks_annual &lt;- drinks %&gt;%
  mutate(year = as.POSIXlt(date)$year + 1900) %&gt;%
  nest(data = c(-year))

multi_year_roll &lt;- rolling_origin(drinks_annual, cumulative = FALSE)

analysis(multi_year_roll$splits[[1]])
assessment(multi_year_roll$splits[[1]])

</code></pre>

<hr>
<h2 id='rsample-dplyr'>Compatibility with dplyr</h2><span id='topic+rsample-dplyr'></span>

<h3>Description</h3>

<p>This page lays out the compatibility between rsample and dplyr. The <code>rset</code>
objects from rsample are a specific subclass of tibbles, hence standard
dplyr operations like joins as well row or column modifications work.
However, whether the operation returns an rset or a tibble depends on the
details of the operation.
</p>
<p>The overarching principle is that any operation which leaves the specific
characteristics of an rset intact will return an rset. If an operation
modifies any of the following characteristics, the result will be a <code>tibble</code>
rather than an <code>rset</code>:
</p>

<ul>
<li><p> Rows: The number of rows needs to remain unchanged to retain the rset
property. For example, you can't have a 10-fold CV object without 10 rows.
The order of the rows can be changed though and the object remains an rset.
</p>
</li>
<li><p> Columns: The <code>splits</code> column and the <code>id</code> column(s) are required for an
rset and need to remain untouched. They cannot be dropped, renamed, or
modified if the result should remain an rset.
</p>
</li></ul>



<h4>Joins</h4>

<p>The following affect all of the dplyr joins, such as <code>left_join()</code>,
<code>right_join()</code>, <code>full_join()</code>, and <code>inner_join()</code>.
</p>
<p>The resulting object is an <code>rset</code> if the number of rows is unaffected.
Rows can be reordered but not added or removed, otherwise the resulting object
is a <code>tibble</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   operation </td><td style="text-align: center;"> same rows, possibly reordered </td><td style="text-align: center;"> add or remove rows </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>join(rset, tbl)</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>Row Operations</h4>

<p>The resulting object is an <code>rset</code> if the number of rows is unaffected.
Rows can be reordered but not added or removed, otherwise the resulting object
is a <code>tibble</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   operation </td><td style="text-align: center;"> same rows, possibly reordered </td><td style="text-align: center;"> add or remove rows </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rset[ind,]</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>slice(rset)</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>filter(rset)</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>arrange(rset)</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>Column Operations</h4>

<p>The resulting object is an <code>rset</code> if the required <code>splits</code> and <code>id</code> columns
remain unaltered. Otherwise the resulting object is a <code>tibble</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   operation </td><td style="text-align: center;"> required columns unaltered </td><td style="text-align: center;"> required columns removed, renamed, or modified </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rset[,ind]</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>select(rset)</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rename(rset)</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mutate(rset)</code> </td><td style="text-align: center;"> <code>rset</code> </td><td style="text-align: center;"> <code>tibble</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<hr>
<h2 id='rsample2caret'>Convert Resampling Objects to Other Formats</h2><span id='topic+rsample2caret'></span><span id='topic+caret2rsample'></span>

<h3>Description</h3>

<p>These functions can convert resampling objects between
<span class="pkg">rsample</span> and <span class="pkg">caret</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsample2caret(object, data = c("analysis", "assessment"))

caret2rsample(ctrl, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsample2caret_+3A_object">object</code></td>
<td>
<p>An <code>rset</code> object. Currently,
<code>nested_cv</code> is not supported.</p>
</td></tr>
<tr><td><code id="rsample2caret_+3A_data">data</code></td>
<td>
<p>The data that was originally used to produce the
<code>ctrl</code> object.</p>
</td></tr>
<tr><td><code id="rsample2caret_+3A_ctrl">ctrl</code></td>
<td>
<p>An object produced by <code>trainControl</code> that has
had the <code>index</code> and <code>indexOut</code> elements populated by
integers. One method of getting this is to extract the
<code>control</code> objects from an object produced by <code>train</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rsample2caret</code> returns a list that mimics the
<code>index</code> and <code>indexOut</code> elements of a
<code>trainControl</code> object. <code>caret2rsample</code> returns an
<code>rset</code> object of the appropriate class.
</p>

<hr>
<h2 id='rset_reconstruct'>Extending rsample with new rset subclasses</h2><span id='topic+rset_reconstruct'></span>

<h3>Description</h3>

<p><code>rset_reconstruct()</code> encapsulates the logic for allowing new rset
subclasses to work properly with vctrs (through <code>vctrs::vec_restore()</code>) and
dplyr (through <code>dplyr::dplyr_reconstruct()</code>). It is intended to be a
developer tool, and is not required for normal usage of rsample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rset_reconstruct(x, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rset_reconstruct_+3A_x">x</code></td>
<td>
<p>A data frame to restore to an rset subclass.</p>
</td></tr>
<tr><td><code id="rset_reconstruct_+3A_to">to</code></td>
<td>
<p>An rset subclass to restore to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rset objects are considered &quot;reconstructable&quot; after a vctrs/dplyr operation
if:
</p>

<ul>
<li> <p><code>x</code> and <code>to</code> both have an identical column named <code>"splits"</code> (column
and row order do not matter).
</p>
</li>
<li> <p><code>x</code> and <code>to</code> both have identical columns prefixed with <code>"id"</code> (column
and row order do not matter).
</p>
</li></ul>



<h3>Value</h3>

<p><code>x</code> restored to the rset subclass of <code>to</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to &lt;- bootstraps(mtcars, times = 25)

# Imitate a vctrs/dplyr operation,
# where the class might be lost along the way
x &lt;- tibble::as_tibble(to)

# Say we added a new column to `x`. Here we mock a `mutate()`.
x$foo &lt;- "bar"

# This is still reconstructable to `to`
rset_reconstruct(x, to)

# Say we lose the first row
x &lt;- x[-1, ]

# This is no longer reconstructable to `to`, as `x` is no longer an rset
# bootstraps object with 25 bootstraps if one is lost!
rset_reconstruct(x, to)
</code></pre>

<hr>
<h2 id='slide-resampling'>Time-based Resampling</h2><span id='topic+slide-resampling'></span><span id='topic+sliding_window'></span><span id='topic+sliding_index'></span><span id='topic+sliding_period'></span>

<h3>Description</h3>

<p>These resampling functions are focused on various forms of <em>time series</em>
resampling.
</p>

<ul>
<li> <p><code>sliding_window()</code> uses the row number when computing the resampling
indices. It is independent of any time index, but is useful with
completely regular series.
</p>
</li>
<li> <p><code>sliding_index()</code> computes resampling indices relative to the <code>index</code>
column. This is often a Date or POSIXct column, but doesn't have to be.
This is useful when resampling irregular series, or for using irregular
lookback periods such as <code>lookback = lubridate::years(1)</code> with daily
data (where the number of days in a year may vary).
</p>
</li>
<li> <p><code>sliding_period()</code> first breaks up the <code>index</code> into less granular groups
based on <code>period</code>, and then uses that to construct the resampling indices.
This is extremely useful for constructing rolling monthly or yearly
windows from daily data.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sliding_window(
  data,
  ...,
  lookback = 0L,
  assess_start = 1L,
  assess_stop = 1L,
  complete = TRUE,
  step = 1L,
  skip = 0L
)

sliding_index(
  data,
  index,
  ...,
  lookback = 0L,
  assess_start = 1L,
  assess_stop = 1L,
  complete = TRUE,
  step = 1L,
  skip = 0L
)

sliding_period(
  data,
  index,
  period,
  ...,
  lookback = 0L,
  assess_start = 1L,
  assess_stop = 1L,
  complete = TRUE,
  step = 1L,
  skip = 0L,
  every = 1L,
  origin = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slide-resampling_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_lookback">lookback</code></td>
<td>
<p>The number of elements to look back from the current element
when computing the resampling indices of the analysis set. The current
row is always included in the analysis set.
</p>

<ul>
<li><p> For <code>sliding_window()</code>, a single integer defining the number of rows to
look back from the current row.
</p>
</li>
<li><p> For <code>sliding_index()</code>, a single object that will be subtracted from the
<code>index</code> as <code>index - lookback</code> to define the boundary of where to start
searching for rows to include in the current resample. This is often
an integer value corresponding to the number of days to look back,
or a lubridate Period object.
</p>
</li>
<li><p> For <code>sliding_period()</code>, a single integer defining the number of groups
to look back from the current group, where the groups were defined from
breaking up the <code>index</code> according to the <code>period</code>.
</p>
</li></ul>

<p>In all cases, <code>Inf</code> is also allowed to force an expanding window.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_assess_start">assess_start</code>, <code id="slide-resampling_+3A_assess_stop">assess_stop</code></td>
<td>
<p>This combination of arguments determines
how far into the future to look when constructing the assessment set.
Together they construct a range of
<code style="white-space: pre;">&#8288;[index + assess_start, index + assess_stop]&#8288;</code> to search for rows to include
in the assessment set.
</p>
<p>Generally, <code>assess_start</code> will always be <code>1</code> to indicate that the first
value to potentially include in the assessment set should start one element
after the current row, but it can be increased to a larger value to
create &quot;gaps&quot; between the analysis and assessment set if you are worried
about high levels of correlation in short term forecasting.
</p>

<ul>
<li><p> For <code>sliding_window()</code>, these are both single integers defining the
number of rows to look forward from the current row.
</p>
</li>
<li><p> For <code>sliding_index()</code>, these are single objects that will be added
to the <code>index</code> to compute the range to search for rows to include
in the assessment set. This is often an integer value corresponding to
the number of days to look forward, or a lubridate Period object.
</p>
</li>
<li><p> For <code>sliding_period()</code>, these are both single integers defining the
number of groups to look forward from the current group, where the groups
were defined from breaking up the <code>index</code> according to the <code>period</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slide-resampling_+3A_complete">complete</code></td>
<td>
<p>A single logical. When using <code>lookback</code> to compute the
analysis sets, should only complete windows be considered? If set to
<code>FALSE</code>, partial windows will be used until it is possible to create
a complete window (based on <code>lookback</code>). This is a way to use an
expanding window up to a certain point, and then switch to a sliding
window.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_step">step</code></td>
<td>
<p>A single positive integer. After computing the resampling
indices, <code>step</code> is used to thin out the results by selecting every
<code>step</code>-th result by subsetting the indices with
<code>seq(1L, n_indices, by = step)</code>. <code>step</code> is applied after <code>skip</code>.
Note that <code>step</code> is independent of any time <code>index</code> used.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_skip">skip</code></td>
<td>
<p>A single positive integer, or zero. After computing the
resampling indices, the first <code>skip</code> results will be dropped by subsetting
the indices with <code>seq(skip + 1L, n_indices)</code>. This can be especially
useful when combined with <code>lookback = Inf</code>, which creates an expanding
window starting from the first row. By skipping forward, you can drop
the first few windows that have very few data points. <code>skip</code> is
applied before <code>step</code>. Note that <code>skip</code> is independent of any time
<code>index</code> used.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_index">index</code></td>
<td>
<p>The index to compute resampling indices relative to, specified
as a bare column name. This must be an existing column in <code>data</code>.
</p>

<ul>
<li><p> For <code>sliding_index()</code>, this is commonly a date vector, but is not
required.
</p>
</li>
<li><p> For <code>sliding_period()</code>, it is required that this is a Date or POSIXct
vector.
</p>
</li></ul>

<p>The <code>index</code> must be an <em>increasing</em> vector, but duplicate values are
allowed. Additionally, the index cannot contain any missing values.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_period">period</code></td>
<td>
<p>The period to group the <code>index</code> by. This is specified as a
single string, such as <code>"year"</code> or <code>"month"</code>. See the <code>.period</code> argument
of <code><a href="slider.html#topic+slide_period">slider::slide_period()</a></code> for the full list of options and further
explanation.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_every">every</code></td>
<td>
<p>A single positive integer. The number of periods to group
together.
</p>
<p>For example, if the <code>period</code> was set to <code>"year"</code> with an <code>every</code>
value of 2, then the years 1970 and 1971 would be placed in the same
group.</p>
</td></tr>
<tr><td><code id="slide-resampling_+3A_origin">origin</code></td>
<td>
<p>The reference date time value. The default when left
as <code>NULL</code> is the epoch time of <code style="white-space: pre;">&#8288;1970-01-01 00:00:00&#8288;</code>,
<em>in the time zone of the index</em>.
</p>
<p>This is generally used to define the anchor time to count from,
which is relevant when the <code>every</code> value is <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rolling_origin">rolling_origin()</a></code>
</p>
<p><code><a href="slider.html#topic+slide">slider::slide()</a></code>, <code><a href="slider.html#topic+slide_index">slider::slide_index()</a></code>, and <code><a href="slider.html#topic+slide_period">slider::slide_period()</a></code>,
which power these resamplers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(vctrs)
library(tibble)
library(modeldata)
data("Chicago")

index &lt;- new_date(c(1, 3, 4, 7, 8, 9, 13, 15, 16, 17))
df &lt;- tibble(x = 1:10, index = index)
df

# Look back two rows beyond the current row, for a total of three rows
# in each analysis set. Each assessment set is composed of the two rows after
# the current row.
sliding_window(df, lookback = 2, assess_stop = 2)

# Same as before, but step forward by 3 rows between each resampling slice,
# rather than just by 1.
rset &lt;- sliding_window(df, lookback = 2, assess_stop = 2, step = 3)
rset

analysis(rset$splits[[1]])
analysis(rset$splits[[2]])

# Now slide relative to the `index` column in `df`. This time we look back
# 2 days from the current row's `index` value, and 2 days forward from
# it to construct the assessment set. Note that this series is irregular,
# so it produces different results than `sliding_window()`. Additionally,
# note that it is entirely possible for the assessment set to contain no
# data if you have a highly irregular series and "look forward" into a
# date range where no data points actually exist!
sliding_index(df, index, lookback = 2, assess_stop = 2)

# With `sliding_period()`, we can break up our date index into less granular
# chunks, and slide over them instead of the index directly. Here we'll use
# the Chicago data, which contains daily data spanning 16 years, and we'll
# break it up into rolling yearly chunks. Three years worth of data will
# be used for the analysis set, and one years worth of data will be held out
# for performance assessment.
sliding_period(
  Chicago,
  date,
  "year",
  lookback = 2,
  assess_stop = 1
)

# Because `lookback = 2`, three years are required to form a "complete"
# window of data. To allow partial windows, set `complete = FALSE`.
# Here that first constructs two expanding windows until a complete three
# year window can be formed, at which point we switch to a sliding window.
sliding_period(
  Chicago,
  date,
  "year",
  lookback = 2,
  assess_stop = 1,
  complete = FALSE
)

# Alternatively, you could break the resamples up by month. Here we'll
# use an expanding monthly window by setting `lookback = Inf`, and each
# assessment set will contain two months of data. To ensure that we have
# enough data to fit our models, we'll `skip` the first 4 expanding windows.
# Finally, to thin out the results, we'll `step` forward by 2 between
# each resample.
sliding_period(
  Chicago,
  date,
  "month",
  lookback = Inf,
  assess_stop = 2,
  skip = 4,
  step = 2
)

</code></pre>

<hr>
<h2 id='tidy.rsplit'>Tidy Resampling Object</h2><span id='topic+tidy.rsplit'></span><span id='topic+tidy.rset'></span><span id='topic+tidy.vfold_cv'></span><span id='topic+tidy.nested_cv'></span>

<h3>Description</h3>

<p>The <code>tidy</code> function from the <span class="pkg">broom</span> package can be used on <code>rset</code> and
<code>rsplit</code> objects to generate tibbles with which rows are in the analysis and
assessment sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rsplit'
tidy(x, unique_ind = TRUE, ...)

## S3 method for class 'rset'
tidy(x, unique_ind = TRUE, ...)

## S3 method for class 'vfold_cv'
tidy(x, ...)

## S3 method for class 'nested_cv'
tidy(x, unique_ind = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.rsplit_+3A_x">x</code></td>
<td>
<p>A  <code>rset</code> or  <code>rsplit</code> object</p>
</td></tr>
<tr><td><code id="tidy.rsplit_+3A_unique_ind">unique_ind</code></td>
<td>
<p>Should unique row identifiers be returned? For example,
if <code>FALSE</code> then bootstrapping results will include multiple rows in the
sample for the same row in the original data.</p>
</td></tr>
<tr><td><code id="tidy.rsplit_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for nested resampling, the rows of the inner resample,
named <code>inner_Row</code>, are <em>relative</em> row indices and do not correspond to the
rows in the original data set.
</p>


<h3>Value</h3>

<p>A tibble with columns <code>Row</code> and <code>Data</code>. The latter has possible
values &quot;Analysis&quot; or &quot;Assessment&quot;. For <code>rset</code> inputs, identification columns
are also returned but their names and values depend on the type of
resampling. <code>vfold_cv</code> contains a column &quot;Fold&quot; and, if repeats are used,
another called &quot;Repeats&quot;. <code>bootstraps</code> and <code>mc_cv</code> use the column
&quot;Resample&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
theme_set(theme_bw())

set.seed(4121)
cv &lt;- tidy(vfold_cv(mtcars, v = 5))
ggplot(cv, aes(x = Fold, y = Row, fill = Data)) +
  geom_tile() +
  scale_fill_brewer()

set.seed(4121)
rcv &lt;- tidy(vfold_cv(mtcars, v = 5, repeats = 2))
ggplot(rcv, aes(x = Fold, y = Row, fill = Data)) +
  geom_tile() +
  facet_wrap(~Repeat) +
  scale_fill_brewer()

set.seed(4121)
mccv &lt;- tidy(mc_cv(mtcars, times = 5))
ggplot(mccv, aes(x = Resample, y = Row, fill = Data)) +
  geom_tile() +
  scale_fill_brewer()

set.seed(4121)
bt &lt;- tidy(bootstraps(mtcars, time = 5))
ggplot(bt, aes(x = Resample, y = Row, fill = Data)) +
  geom_tile() +
  scale_fill_brewer()

dat &lt;- data.frame(day = 1:30)
# Resample by week instead of day
ts_cv &lt;- rolling_origin(dat,
  initial = 7, assess = 7,
  skip = 6, cumulative = FALSE
)
ts_cv &lt;- tidy(ts_cv)
ggplot(ts_cv, aes(x = Resample, y = factor(Row), fill = Data)) +
  geom_tile() +
  scale_fill_brewer()

</code></pre>

<hr>
<h2 id='validation_set'>Create a Validation Split for Tuning</h2><span id='topic+validation_set'></span><span id='topic+analysis.val_split'></span><span id='topic+assessment.val_split'></span><span id='topic+training.val_split'></span><span id='topic+validation.val_split'></span><span id='topic+testing.val_split'></span>

<h3>Description</h3>

<p>Create a Validation Split for Tuning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation_set(split, ...)

## S3 method for class 'val_split'
analysis(x, ...)

## S3 method for class 'val_split'
assessment(x, ...)

## S3 method for class 'val_split'
training(x, ...)

## S3 method for class 'val_split'
validation(x, ...)

## S3 method for class 'val_split'
testing(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validation_set_+3A_split">split</code></td>
<td>
<p>An object of class <code>initial_validation_split</code>, such as resulting
from <code><a href="#topic+initial_validation_split">initial_validation_split()</a></code> or <code><a href="#topic+group_initial_validation_split">group_initial_validation_split()</a></code>.</p>
</td></tr>
<tr><td><code id="validation_set_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validation_set_+3A_x">x</code></td>
<td>
<p>An <code>rsplit</code> object produced by <code>validation_set()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An tibble with classes <code>validation_set</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and
<code>data.frame</code>. The results include a column for the data split object and a
column called <code>id</code> that has a character string with the resample identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1353)
car_split &lt;- initial_validation_split(mtcars)
car_set &lt;- validation_set(car_split)
</code></pre>

<hr>
<h2 id='validation_split'>Create a Validation Set</h2><span id='topic+validation_split'></span><span id='topic+validation_time_split'></span><span id='topic+group_validation_split'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function is deprecated because it's part of an approach to constructing
a training, validation, and testing set by doing a sequence of two binary
splits: testing / not-testing (with <code><a href="#topic+initial_split">initial_split()</a></code> or one of its variants)
and then not-testing split into training/validation with <code>validation_split()</code>.
Instead, now use <code><a href="#topic+initial_validation_split">initial_validation_split()</a></code> or one if its variants to
construct the three sets via one 3-way split.
</p>
<p><code>validation_split()</code> takes a single random sample (without replacement) of
the original data set to be used for analysis. All other data points are
added to the assessment set (to be used as the validation set).
<code>validation_time_split()</code> does the same, but takes the <em>first</em> <code>prop</code> samples
for training, instead of a random selection.
<code>group_validation_split()</code> creates splits of the data based
on some grouping variable, so that all data in a &quot;group&quot; is assigned to
the same split.
</p>
<p>Note that the input <code>data</code> to <code>validation_split()</code>, <code>validation_time_split()</code>,
and <code>group_validation_split()</code> should <em>not</em> contain the testing data. To
create a three-way split directly of the entire data set, use
<code><a href="#topic+initial_validation_split">initial_validation_split()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation_split(data, prop = 3/4, strata = NULL, breaks = 4, pool = 0.1, ...)

validation_time_split(data, prop = 3/4, lag = 0, ...)

group_validation_split(data, group, prop = 3/4, ..., strata = NULL, pool = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validation_split_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="validation_split_+3A_prop">prop</code></td>
<td>
<p>The proportion of data to be retained for modeling/analysis.</p>
</td></tr>
<tr><td><code id="validation_split_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="validation_split_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="validation_split_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="validation_split_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="validation_split_+3A_lag">lag</code></td>
<td>
<p>A value to include a lag between the assessment
and analysis set. This is useful if lagged predictors will be used
during training and testing.</p>
</td></tr>
<tr><td><code id="validation_split_+3A_group">group</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used for
grouping observations with the same value to either the analysis or
assessment set within a fold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a <code>strata</code> argument, the random sampling is conducted
<em>within the stratification variable</em>. This can help ensure that the
resamples have equivalent proportions as the original data set. For
a categorical variable, sampling is conducted separately within each class.
For a numeric stratification variable, <code>strata</code> is binned into quartiles,
which are then used to stratify. Strata below 10% of the total are
pooled together; see <code><a href="#topic+make_strata">make_strata()</a></code> for more details.
</p>


<h3>Value</h3>

<p>An tibble with classes <code>validation_split</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>,
and <code>data.frame</code>. The results include a column for the data split objects
and a column called <code>id</code> that has a character string with the resample
identifier.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initial_validation_split">initial_validation_split()</a></code>, <code><a href="#topic+group_initial_validation_split">group_initial_validation_split()</a></code>,
<code><a href="#topic+validation_set">validation_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cars_split &lt;- initial_split(mtcars)
cars_not_testing &lt;- training(cars_split)
validation_split(cars_not_testing, prop = .9)
group_validation_split(cars_not_testing, cyl)

data(drinks, package = "modeldata")
validation_time_split(drinks[1:200,])

# Alternative
cars_split_3 &lt;- initial_validation_split(mtcars)
validation_set(cars_split_3)

</code></pre>

<hr>
<h2 id='vfold_cv'>V-Fold Cross-Validation</h2><span id='topic+vfold_cv'></span>

<h3>Description</h3>

<p>V-fold cross-validation (also known as k-fold cross-validation) randomly
splits the data into V groups of roughly equal size (called &quot;folds&quot;). A
resample of the analysis data consists of V-1 of the folds while the
assessment set contains the final fold. In basic V-fold cross-validation
(i.e. no repeats), the number of resamples is equal to V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vfold_cv(data, v = 10, repeats = 1, strata = NULL, breaks = 4, pool = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vfold_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="vfold_cv_+3A_v">v</code></td>
<td>
<p>The number of partitions of the data set.</p>
</td></tr>
<tr><td><code id="vfold_cv_+3A_repeats">repeats</code></td>
<td>
<p>The number of times to repeat the V-fold partitioning.</p>
</td></tr>
<tr><td><code id="vfold_cv_+3A_strata">strata</code></td>
<td>
<p>A variable in <code>data</code> (single character or name) used to conduct
stratified sampling. When not <code>NULL</code>, each resample is created within the
stratification variable. Numeric <code>strata</code> are binned into quartiles.</p>
</td></tr>
<tr><td><code id="vfold_cv_+3A_breaks">breaks</code></td>
<td>
<p>A single number giving the number of bins desired to stratify a
numeric stratification variable.</p>
</td></tr>
<tr><td><code id="vfold_cv_+3A_pool">pool</code></td>
<td>
<p>A proportion of data used to determine if a particular group is
too small and should be pooled into another group. We do not recommend
decreasing this argument below its default of 0.1 because of the dangers
of stratifying groups that are too small.</p>
</td></tr>
<tr><td><code id="vfold_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With more than one repeat, the basic V-fold cross-validation is
conducted each time. For example, if three repeats are used with <code>v = 10</code>,
there are a total of 30 splits: three groups of 10 that are generated
separately.
</p>
<p>With a <code>strata</code> argument, the random sampling is conducted
<em>within the stratification variable</em>. This can help ensure that the
resamples have equivalent proportions as the original data set. For
a categorical variable, sampling is conducted separately within each class.
For a numeric stratification variable, <code>strata</code> is binned into quartiles,
which are then used to stratify. Strata below 10% of the total are
pooled together; see <code><a href="#topic+make_strata">make_strata()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A tibble with classes <code>vfold_cv</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>, and
<code>data.frame</code>. The results include a column for the data split objects and
one or more identification variables. For a single repeat, there will be
one column called <code>id</code> that has a character string with the fold identifier.
For repeats, <code>id</code> is the repeat number and an additional column called <code>id2</code>
that contains the fold information (within repeat).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vfold_cv(mtcars, v = 10)
vfold_cv(mtcars, v = 10, repeats = 2)

library(purrr)
data(wa_churn, package = "modeldata")

set.seed(13)
folds1 &lt;- vfold_cv(wa_churn, v = 5)
map_dbl(
  folds1$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

set.seed(13)
folds2 &lt;- vfold_cv(wa_churn, strata = churn, v = 5)
map_dbl(
  folds2$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

set.seed(13)
folds3 &lt;- vfold_cv(wa_churn, strata = tenure, breaks = 6, v = 5)
map_dbl(
  folds3$splits,
  function(x) {
    dat &lt;- as.data.frame(x)$churn
    mean(dat == "Yes")
  }
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
