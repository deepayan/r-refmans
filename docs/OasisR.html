<!DOCTYPE html><html lang="en"><head><title>Help for package OasisR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OasisR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACE'><p>A function to compute the Massey and Denton Absolute Centralisation Index (ACE)</p></a></li>
<li><a href='#ACEDuncan'><p>A function to compute Duncan's Absolute Centralisation Index (ACEDuncan)</p></a></li>
<li><a href='#ACEDuncanPoly'><p>A function to compute Duncan's Polycentric Absolute Centralisation Index</p></a></li>
<li><a href='#ACEDuncanPolyK'><p>A function to compute Duncan's Constrained Absolute Centralisation Index</p></a></li>
<li><a href='#ACEPoly'><p>A function to compute the Massey and Denton Polycentric Absolute Centralisation Index</p></a></li>
<li><a href='#ACL'><p>A function to compute Absolute Clustering Index (ACL)</p></a></li>
<li><a href='#ACO'><p>A function to compute Absolute Concentration index (ACO)</p></a></li>
<li><a href='#area'><p>A function to compute the spatial units' areas</p></a></li>
<li><a href='#Atkinson'><p>A function to compute Atkinson segregation index</p></a></li>
<li><a href='#boundaries'><p>A function to compute the matrix of common boundaries</p></a></li>
<li><a href='#CMulti'><p>A function to compute multigroup squared coefficient of variation index</p></a></li>
<li><a href='#contig'><p>A function to compute the contiguity matrix</p></a></li>
<li><a href='#Delta'><p>A function to compute Delta index</p></a></li>
<li><a href='#DIDuncan'><p>A function to compute Duncan's dissimilarity segregation index</p></a></li>
<li><a href='#DIMorrill'><p>A function to compute Morrill's dissimilarity index</p></a></li>
<li><a href='#DIMorrillK'><p>A function to compute K-th order Morrill's dissimilarity index</p></a></li>
<li><a href='#distance'><p>A function to compute the distance matrix between centroids</p>
of spatial units</a></li>
<li><a href='#distcenter'><p>A function to compute the distance from spatial units centroids</p>
to the center</a></li>
<li><a href='#DIWong'><p>A function to compute Wongs's dissimilarity index</p></a></li>
<li><a href='#DMulti'><p>A function to compute multigroup dissimilarity index</p></a></li>
<li><a href='#DPxx'><p>A function to compute the distance-decay isolation index (DPxx)</p></a></li>
<li><a href='#DPxy'><p>A function to compute the distance-decay interaction index (DPxy)</p></a></li>
<li><a href='#Eta2'><p>A function to compute adjusted isolation index (Eta2)</p></a></li>
<li><a href='#Gini'><p>A function to compute Gini's segregation index</p></a></li>
<li><a href='#Gini2'><p>A function to compute the between group version of segregation Gini index</p></a></li>
<li><a href='#GiniMulti'><p>A function to compute multigroup Gini index</p></a></li>
<li><a href='#Gorard'><p>A function to compute Gorard's segregation index</p></a></li>
<li><a href='#GreHSize'><p>Households distribution by  size in Grenoble urban area in 2011</p></a></li>
<li><a href='#HLoc'><p>A function to compute local diversity index</p></a></li>
<li><a href='#HMulti'><p>A function to compute multigroup entropy segregation index</p></a></li>
<li><a href='#HShannon'><p>A function to compute Shannon-Wiener diversity (entropy) index</p></a></li>
<li><a href='#HTheil'><p>A function to compute Theil's entropy segregation index</p></a></li>
<li><a href='#ISDuncan'><p>A function to compute Duncan &amp; Duncan segregation index</p></a></li>
<li><a href='#ISimpson'><p>A function to compute Simpson's interaction index</p></a></li>
<li><a href='#ISMorrill'><p>A function to compute Morrill's segregation index</p></a></li>
<li><a href='#ISMorrillK'><p>A function to compute K-th order Morrill's segregation index</p></a></li>
<li><a href='#ISWong'><p>A function to compute Wong's segregation index</p></a></li>
<li><a href='#LQ'><p>A function to compute location quotients (LQs)</p></a></li>
<li><a href='#LShannon'><p>A function to compute Shannon-Wiener local diversity (entropy) index</p></a></li>
<li><a href='#LSimpson'><p>A function to compute local Simpson's index</p></a></li>
<li><a href='#NShannon'><p>A function to compute Shannon-Wiener diversity normalized index</p></a></li>
<li><a href='#ordinalseg'><p>A function to compute Reardon multigroup ordinal segregation indices</p></a></li>
<li><a href='#perimeter'><p>A function to compute the spatial units' perimeters</p></a></li>
<li><a href='#PMulti'><p>A function to compute multigroup normalised exposure (PMulti)</p></a></li>
<li><a href='#Poo'><p>A function to compute the mean proximity between</p>
persons without regard to group (Poo)</a></li>
<li><a href='#Pxx'><p>A function to compute the mean proximity between members of a group (Pxx)</p></a></li>
<li><a href='#Pxy'><p>A function to compute the mean proximity between</p>
persons of different groups (Pxy)</a></li>
<li><a href='#rankorderseg'><p>A function to compute rank-ordered segregation indices</p></a></li>
<li><a href='#RCE'><p>A function to compute Duncan's Relative Centralisation Index (RCE)</p></a></li>
<li><a href='#RCEPoly'><p>A function to compute Duncan's Polycentric Relative Centralisation Index</p></a></li>
<li><a href='#RCEPolyK'><p>A function to compute Constrained Polyentric Relative Centralisation Index</p></a></li>
<li><a href='#RCL'><p>A function to compute the relative clustering index (RCL)</p></a></li>
<li><a href='#RCO'><p>A function to compute Relative Concentration index (RCO)</p></a></li>
<li><a href='#RelDivers'><p>A function to compute multigroup relative diversity index</p></a></li>
<li><a href='#ResamplePlot'><p>A function to plot the results of resampling methods</p></a></li>
<li><a href='#ResampleTest'><p>A function to test segregation indices by resampling</p></a></li>
<li><a href='#segdata'><p>Theoretical two groups distribution on a 10x10 grid map.</p></a></li>
<li><a href='#segdataclean'><p>A function to clean and prepare the data for segregation analysis</p></a></li>
<li><a href='#SP'><p>A function to compute the spatial proximity index (SP)</p></a></li>
<li><a href='#xPx'><p>A function to compute Bell's isolation index (xPx)</p></a></li>
<li><a href='#xPy'><p>A function to compute interaction index (xPy)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Outright Tool for the Analysis of Spatial Inequalities and
Segregation</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive set of indexes and tests for social segregation analysis,
              as described in Tivadar (2019) - 'OasisR': An R Package to Bring Some Order
              to the World of Segregation Measurement &lt;<a href="https://doi.org/10.18637%2Fjss.v089.i07">doi:10.18637/jss.v089.i07</a>&gt;.
              The package  is the most complete existing tool and it clarifies
              many ambiguities and errors regarding the definition of segregation
              indices. Additionally, 'OasisR' introduces several resampling methods
              that enable testing their statistical significance
              (randomization tests, bootstrapping, and jackknife methods).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spdep (&ge; 1.3-6), measurements (&ge; 1.5.1), sf (&ge; 1.0-18),
outliers (&ge; 0.15), methods (&ge; 4.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.2.1.1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-04 09:10:46 UTC; mtivadar</td>
</tr>
<tr>
<td>Author:</td>
<td>Mihai Tivadar [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mihai Tivadar &lt;mihai.tivadar@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-06 15:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACE'>A function to compute the Massey and Denton Absolute Centralisation Index (ACE)</h2><span id='topic+ACE'></span>

<h3>Description</h3>

<p>The absolute centralization index measures a group
spatial distribution compared to the distribution of land area 
around the city center. The function can be used in two ways: to provide 
an area vector and a vector containing the distances between spatial units
centroids and  the central spatial unit or a external geographic information 
source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACE(x, a = NULL, dc = NULL, center = 1, 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACE_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ACE_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="ACE_+3A_dc">dc</code></td>
<td>
<p>a numeric vector containing the distances between spatial units
centroids and the central spatial unit</p>
</td></tr>
<tr><td><code id="ACE_+3A_center">center</code></td>
<td>
<p>a numeric value giving the number of the spatial unit that 
represents the center in the table</p>
</td></tr>
<tr><td><code id="ACE_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ACE_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ACE_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Massey and Denton absolute 
centralisation index values for each group
</p>


<h3>References</h3>

<p>Massey D. S. and Denton N. A. (1988) <em>
The dimensions of residential segregation</em>. 
Social Forces 67(2),  pp. 281-315.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACEPoly">ACEPoly</a></code>,
</p>
<p><code><a href="#topic+RCE">RCE</a></code>, <code><a href="#topic+RCEPoly">RCEPoly</a></code>, <code><a href="#topic+RCEPolyK">RCEPolyK</a></code>,
</p>
<p><code><a href="#topic+ACEDuncan">ACEDuncan</a></code>, <code><a href="#topic+ACEDuncanPoly">ACEDuncanPoly</a></code>,
</p>
<p><code><a href="#topic+ACEDuncanPolyK">ACEDuncanPolyK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar&lt;-area(segdata)
distc&lt;- distcenter(segdata, center = 28)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ACE(x, a = ar, dc=distc) 

ACE(x, spatobj = segdata, center = 28) 

ACE(x, folder = foldername, shape = shapename, center = 28) 

</code></pre>

<hr>
<h2 id='ACEDuncan'>A function to compute Duncan's Absolute Centralisation Index (ACEDuncan)</h2><span id='topic+ACEDuncan'></span>

<h3>Description</h3>

<p>Duncan's absolute centralization index measures the 
proportion of a group that should change its localization to 
achieve the same level of centralization as the rest of the population.
The function can be used in two ways: to provide a vector containing 
the distances between spatial/organizational unit centroids or a external geographic 
information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACEDuncan(x, dc = NULL, center = 1, 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACEDuncan_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ACEDuncan_+3A_dc">dc</code></td>
<td>
<p>a numeric vector containing the distances between spatial units
centroids and the central spatial unit</p>
</td></tr>
<tr><td><code id="ACEDuncan_+3A_center">center</code></td>
<td>
<p>a numeric value giving the number of the spatial unit that 
represents the center in the table</p>
</td></tr>
<tr><td><code id="ACEDuncan_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ACEDuncan_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ACEDuncan_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Duncan's absolute centralisation index 
values for each group
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A 
Methodological Analysis of Segregation Indexes</em>. 
American Sociological Review 41, pp. 210-217
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACEDuncanPoly">ACEDuncanPoly</a></code>, <code><a href="#topic+ACEDuncanPolyK">ACEDuncanPolyK</a></code>,
</p>
<p><code><a href="#topic+RCE">RCE</a></code>, <code><a href="#topic+RCEPoly">RCEPoly</a></code>, <code><a href="#topic+RCEPolyK">RCEPolyK</a></code>
</p>
<p><code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+ACEPoly">ACEPoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
distc&lt;- distcenter(segdata, center = 28)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ACEDuncan(x, dc=distc) 

ACEDuncan(x, spatobj = segdata, center = 28) 

ACEDuncan(x, folder = foldername, shape = shapename, center = 28) 

</code></pre>

<hr>
<h2 id='ACEDuncanPoly'>A function to compute Duncan's Polycentric Absolute Centralisation Index</h2><span id='topic+ACEDuncanPoly'></span>

<h3>Description</h3>

<p>Polycentric version of Duncan's absolute centralization index. 
The function can be used in two ways: to provide a vector containing 
the distances between spatial/organizational unit centroids or a 
external geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACEDuncanPoly(x, dc = NULL, center = 1, 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACEDuncanPoly_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ACEDuncanPoly_+3A_dc">dc</code></td>
<td>
<p>a numeric matrix/vector containing the distances between spatial units
centroids and the central spatial unit(s).</p>
</td></tr>
<tr><td><code id="ACEDuncanPoly_+3A_center">center</code></td>
<td>
<p>a numeric vector giving the number of the spatial/organizational units that 
represents the centers in the table</p>
</td></tr>
<tr><td><code id="ACEDuncanPoly_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ACEDuncanPoly_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ACEDuncanPoly_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Duncan's absolute polycentric 
centralisation index value for each group
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A 
Methodological Analysis of Segregation Indexes</em>. 
American Sociological Review 41, pp. 210-217
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACEDuncan">ACEDuncan</a></code>, <code><a href="#topic+ACEDuncanPolyK">ACEDuncanPolyK</a></code>,
</p>
<p><code><a href="#topic+RCE">RCE</a></code>, <code><a href="#topic+RCEPoly">RCEPoly</a></code>, <code><a href="#topic+RCEPolyK">RCEPolyK</a></code>
</p>
<p><code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+ACEPoly">ACEPoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ACEDuncanPoly(x, spatobj = segdata, center = c(28, 83) )

ACEDuncanPoly(x, folder = foldername, shape = shapename, center = c(28, 83))

center &lt;- c(28, 83)
polydist &lt;- matrix(data = NA, nrow = nrow(x), ncol = length(center))
for (i in 1:ncol(polydist))
  polydist[,i] &lt;- distcenter(spatobj = segdata, center = center[i])
ACEDuncanPoly(x, dc = polydist)

distmin &lt;- vector(length = nrow(x))
for (i in 1:nrow(polydist)) distmin[i] &lt;- min(polydist[i,])
ACEDuncan(x, dc = distmin)

</code></pre>

<hr>
<h2 id='ACEDuncanPolyK'>A function to compute Duncan's Constrained Absolute Centralisation Index</h2><span id='topic+ACEDuncanPolyK'></span>

<h3>Description</h3>

<p>Constrained (local) version of Duncan's centralization index.
The function can be used in two ways: to provide a matrix containing 
the distances between spatial/organizational unit centroids or a external geographic 
information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACEDuncanPolyK(x, dc = NULL,  K = NULL, kdist = NULL, center = 1,
                spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACEDuncanPolyK_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ACEDuncanPolyK_+3A_dc">dc</code></td>
<td>
<p>a numeric matrix/vector containing the distances between spatial units
centroids and the central spatial unit(s).</p>
</td></tr>
<tr><td><code id="ACEDuncanPolyK_+3A_k">K</code></td>
<td>
<p>the number of neighbourhoods under the influence of a center</p>
</td></tr>
<tr><td><code id="ACEDuncanPolyK_+3A_kdist">kdist</code></td>
<td>
<p>the maximal distance that defines the neighbourhoods influenced
by a center</p>
</td></tr>
<tr><td><code id="ACEDuncanPolyK_+3A_center">center</code></td>
<td>
<p>a numeric vector  giving the number of the spatial units that 
represent the centers in the table</p>
</td></tr>
<tr><td><code id="ACEDuncanPolyK_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ACEDuncanPolyK_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ACEDuncanPolyK_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Duncan's constrainted absolute 
centralisation index value for each group
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A 
Methodological Analysis of Segregation Indexes</em>. 
American Sociological Review 41, pp. 210-217
</p>
<p>Folch D.C and Rey S. J (2016) <em>The centralization index: 
A measure of local spatial segregation</em>. Papers in Regional 
Science 95 (3), pp. 555-576
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACEDuncan">ACEDuncan</a></code>, <code><a href="#topic+ACEDuncanPoly">ACEDuncanPoly</a></code>,
</p>
<p><code><a href="#topic+RCE">RCE</a></code>, <code><a href="#topic+RCEPoly">RCEPoly</a></code>, <code><a href="#topic+RCEPolyK">RCEPolyK</a></code>
</p>
<p><code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+ACEPoly">ACEPoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ACEDuncanPolyK(x, spatobj = segdata, center = c(28, 83))

ACEDuncanPolyK(x, folder = foldername, shape = shapename, center = c(28, 83), K = 3)

center &lt;- c(28, 83)
polydist &lt;- matrix(data = NA, nrow = nrow(x), ncol = length(center))
for (i in 1:ncol(polydist))
  polydist[,i] &lt;- distcenter(spatobj = segdata, center = center[i])
ACEDuncanPolyK(x, dc = polydist, kdist = 2)

</code></pre>

<hr>
<h2 id='ACEPoly'>A function to compute the Massey and Denton Polycentric Absolute Centralisation Index</h2><span id='topic+ACEPoly'></span>

<h3>Description</h3>

<p>The absolute centralization index measures a group
spatial distribution compared to the distribution of land area 
around the city center. The function can be used in two ways: to provide 
an area vector and a vector containing the distances between spatial units
centroids and  the central spatial unit or a external geographic information 
source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACEPoly(x, a = NULL, dc = NULL, center = 1, 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACEPoly_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ACEPoly_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="ACEPoly_+3A_dc">dc</code></td>
<td>
<p>a numeric matrix containing the distances between spatial units
centroids and the central spatial units</p>
</td></tr>
<tr><td><code id="ACEPoly_+3A_center">center</code></td>
<td>
<p>a numeric vector giving the number of the spatial units that 
represent the centers in the table</p>
</td></tr>
<tr><td><code id="ACEPoly_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ACEPoly_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ACEPoly_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Massey and Denton absolute 
polycentric centralisation index values for each group
</p>


<h3>References</h3>

<p>Massey D. S. and Denton N. A. (1988) <em>
The dimensions of residential segregation</em>. 
Social Forces 67(2),  pp. 281-315.
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+RCE">RCE</a></code>,
</p>
<p><code><a href="#topic+RCEPoly">RCEPoly</a></code>, <code><a href="#topic+RCEPolyK">RCEPolyK</a></code>,
</p>
<p><code><a href="#topic+ACEDuncan">ACEDuncan</a></code>, <code><a href="#topic+ACEDuncanPoly">ACEDuncanPoly</a></code>,
</p>
<p><code><a href="#topic+ACEDuncanPolyK">ACEDuncanPolyK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar&lt;-area(segdata)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ACEPoly(x, spatobj = segdata, center = c(28, 83) )

ACEPoly(x, folder = foldername, shape = shapename, center = c(28, 83))

center &lt;- c(28, 83)
polydist &lt;- matrix(data = NA, nrow = nrow(x), ncol = length(center))
for (i in 1:ncol(polydist))
  polydist[,i] &lt;- distcenter(spatobj = segdata, center = center[i])
ACEPoly(x, a = ar, dc = polydist)

distmin &lt;- vector(length = nrow(x))
for (i in 1:nrow(polydist)) distmin[i] &lt;- min(polydist[i,])
ACE(x, a = ar, dc = distmin)

</code></pre>

<hr>
<h2 id='ACL'>A function to compute Absolute Clustering Index (ACL)</h2><span id='topic+ACL'></span>

<h3>Description</h3>

<p>The absolute clustering index, ACL, expresses the 
average number of a group's members in nearby spatial units, as 
a proportion of the total population in those spatial units. 
The spatial interactions can be expressed as a contiguity matrix 
(with diagonal equal to 1), as an inverse exponential function of the 
distance between spatial units centers (with diagonal equal 
to 0.6 of the square root of each spatial units area) or other 
user specified interaction matrix. The function can be used in two 
ways: to provide a spatial interactions matrix (a contiguity matrix 
or a distance matrix) or a external  geographic information source 
(spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACL(x, spatmat = 'c', c = NULL, queen = FALSE, d = NULL, distin = 'm',  
distout = 'm', diagval = '0', beta = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACL_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ACL_+3A_spatmat">spatmat</code></td>
<td>
<p>the method used for spatial calculations: 'c' for the 
contiguity matrix (by default) or any other user spatial interaction matrix 
and 'd' for the inverse exponential function of the distance.</p>
</td></tr>
<tr><td><code id="ACL_+3A_c">c</code></td>
<td>
<p>a modified binary contiguity (adjacency) symmetric matrix where 
each element <em>Cij</em> equals 1 if <em>i</em>-th and <em>j</em>-th spatial 
units are adjacent or identical, and 0 otherwise.</p>
</td></tr>
<tr><td><code id="ACL_+3A_queen">queen</code></td>
<td>
<p>logical parameter difining criteria used for contiguity 
matrix computation, TRUE for queen, FALSE (by default) for rook</p>
</td></tr>
<tr><td><code id="ACL_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="ACL_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="ACL_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="ACL_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) (White, 1983)</p>
</td></tr>
<tr><td><code id="ACL_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="ACL_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ACL_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ACL_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Absolute Clustering index values 
for each group
</p>


<h3>References</h3>

<p>Massey D. S. and Denton N. A. (1988) <em>
The dimensions of residential segregation</em>. 
Social Forces 67(2),  pp. 281-315.
</p>


<h3>See Also</h3>

<p>Proximity measures: <code><a href="#topic+Pxx">Pxx</a></code>, 
<code><a href="#topic+Pxy">Pxy</a></code>, <code><a href="#topic+Poo">Poo</a></code>, <code><a href="#topic+SP">SP</a></code>
</p>
<p>Relative Clustering Index: <code><a href="#topic+RCL">RCL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
contiguity &lt;- contig(segdata)
diag(contiguity) &lt;- 1
ar&lt;-area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ACL(x, c = contiguity) 

ACL(x, spatobj = segdata)

ACL(x, spatmat = 'd', folder = foldername, shape = shapename) 
 
ACL(x,  spatmat = 'd', diagval = 'a', spatobj = segdata)

ACL(x, d = dist, spatmat = 'd')

</code></pre>

<hr>
<h2 id='ACO'>A function to compute Absolute Concentration index (ACO)</h2><span id='topic+ACO'></span>

<h3>Description</h3>

<p>The absolute concentration index, ACO, computes 
the total area inhabited by a group, and compares the result 
to the minimum and maximum possible areas that could be 
inhabited by that group in the study area. The function can be 
used in two ways: to provide an area vector or a external 
geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACO(x, a = NULL, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACO_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ACO_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="ACO_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ACO_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ACO_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Absolute Concentration index 
values for each group
</p>


<h3>References</h3>

<p>Massey D. S. and Denton N. A. (1988) <em>
The dimensions of residential segregation</em>. 
Social Forces 67(2),  pp. 281-315.
</p>


<h3>See Also</h3>

<p>Delta Index: <code><a href="#topic+Delta">Delta</a></code>
</p>
<p>Relative Concentration Index: <code><a href="#topic+RCO">RCO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- GreHSize@data[ ,3:5]
ar &lt;- area(GreHSize)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'GreHSize'

ACO(x, a = ar) 

ACO(x, spatobj = GreHSize)

ACO(x, folder = foldername, shape = shapename) 

</code></pre>

<hr>
<h2 id='area'>A function to compute the spatial units' areas</h2><span id='topic+area'></span>

<h3>Description</h3>

<p>The function is based on <span class="pkg">sf</span> package and can be 
used with a shape file or an R spatial object (class sf, sfc or sfg).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area(spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="area_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (class sf, sfc or sfg) containing 
geographic information</p>
</td></tr>
<tr><td><code id="area_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile with the geographic information 
is located.</p>
</td></tr>
<tr><td><code id="area_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) which contains the geographic information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the areas of spatial units
</p>


<h3>See Also</h3>

<p>Other spatial functions used for segregation indices 
computation: <code><a href="#topic+contig">contig</a></code>, <code><a href="#topic+perimeter">perimeter</a></code>, 
<code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+distcenter">distcenter</a></code>, 
<code><a href="#topic+boundaries">boundaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> area(segdata) 
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'
area(folder = foldername, shape = shapename)
</code></pre>

<hr>
<h2 id='Atkinson'>A function to compute Atkinson segregation index</h2><span id='topic+Atkinson'></span>

<h3>Description</h3>

<p>The spatial version of Atkinson inequality index is based on 
Lorenz curves. The user can decide wich part of the curve contributes more 
to the index, by choosing the value of the shape parameter, delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Atkinson (x, delta = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Atkinson_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="Atkinson_+3A_delta">delta</code></td>
<td>
<p>an inequality aversion parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Atkinson's segregation index values for each group
</p>


<h3>References</h3>

<p>James, D. and K. E. Taeuber (1985)  <em>Measures 
of Segregation</em>. Sociological Methodology 15, pp. 1-32
</p>


<h3>See Also</h3>

<p>One-group evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,7:8]
Atkinson(x) 
Atkinson(x, 0.1)
Atkinson(x, delta = 0.9)
</code></pre>

<hr>
<h2 id='boundaries'>A function to compute the matrix of common boundaries</h2><span id='topic+boundaries'></span>

<h3>Description</h3>

<p>The function is based on <span class="pkg">sf</span>  
package and it can be used with a shape file 
or an R spatial object (class sf, sfc or sfg).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundaries(spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boundaries_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (class sf, sfc or sfg) containing 
geographic information</p>
</td></tr>
<tr><td><code id="boundaries_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile with the geographic information 
is located.</p>
</td></tr>
<tr><td><code id="boundaries_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) which contains the geographic information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A common boundaries matrix
</p>


<h3>See Also</h3>

<p>Other spatial functions used for segregation indices 
computation:  <code><a href="#topic+area">area</a></code>, <code><a href="#topic+contig">contig</a></code>, 
<code><a href="#topic+perimeter">perimeter</a></code>, <code><a href="#topic+distance">distance</a></code>, 
<code><a href="#topic+distcenter">distcenter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> boundaries(segdata) 
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'
boundaries(folder = foldername, shape = shapename)
</code></pre>

<hr>
<h2 id='CMulti'>A function to compute multigroup squared coefficient of variation index</h2><span id='topic+CMulti'></span>

<h3>Description</h3>

<p>The index can be interpreted as a measure of the variance of the 
spatial representation of the groups accros spatial unite, or as a normalized 
chi-squared measure of association between groups and units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMulti(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CMulti_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multigroup entropy segregation index value (numeric)
</p>


<h3>References</h3>

<p>Reardon S. F. and Firebaugh G. (2002) <em>Measures of multigroup 
segregation</em>. Sociological Methodology, 32, pp. 33-67.
</p>


<h3>See Also</h3>

<p>multigroup indices: 
<code><a href="#topic+PMulti">PMulti</a></code>, <code><a href="#topic+GiniMulti">GiniMulti</a></code>, <code><a href="#topic+DMulti">DMulti</a></code>,  
<code><a href="#topic+HMulti">HMulti</a></code>, <code><a href="#topic+RelDivers">RelDivers</a></code>
</p>
<p>Social diversity indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+NShannon">NShannon</a></code>, 
<code><a href="#topic+ISimpson">ISimpson</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
CMulti(x) 
</code></pre>

<hr>
<h2 id='contig'>A function to compute the contiguity matrix</h2><span id='topic+contig'></span>

<h3>Description</h3>

<p>The function is based on <span class="pkg">sf</span>  
package and can be used with a shape file 
or an R spatial object (class sf, sfc or sfg).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contig(spatobj = NULL, folder = NULL, shape = NULL, queen = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contig_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (class sf, sfc or sfg) containing 
geographic information</p>
</td></tr>
<tr><td><code id="contig_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile with the geographic information 
is located.</p>
</td></tr>
<tr><td><code id="contig_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) which contains the geographic information</p>
</td></tr>
<tr><td><code id="contig_+3A_queen">queen</code></td>
<td>
<p>= TRUE for queen criteria, FALSE (by default)  for rook criteria</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A first order contiguity (adjacency) matrix, where each 
element [<em>i,j</em>] equals 1 if <em>i</em>-th  and <em>j</em>-th  
spatial units are adjacent, 0 otherwise (queen or rook criteria)
</p>


<h3>See Also</h3>

<p>Other spatial functions used for segregation indices 
computation: <code><a href="#topic+area">area</a></code>, <code><a href="#topic+perimeter">perimeter</a></code>, 
<code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+distcenter">distcenter</a></code>, 
<code><a href="#topic+boundaries">boundaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> contig(segdata) 
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'
contig(folder = foldername, shape = shapename)
</code></pre>

<hr>
<h2 id='Delta'>A function to compute Delta index</h2><span id='topic+Delta'></span>

<h3>Description</h3>

<p>The Delta index is a specific application of dissimilarity 
index <code><a href="#topic+DIDuncan">DIDuncan</a></code> which simply measures the dissimilarity
between the spatial distribution of a group and the spatial 
distribution of available land. It can be interpreted as the share of group 
that would have to move to achieve uniform density over all spatial units. 
The function can be used in two ways: to provide an area vector or 
a external geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Delta(x, a = NULL, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Delta_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="Delta_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="Delta_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="Delta_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="Delta_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Delta index values for each group
</p>


<h3>References</h3>

<p>Duncan O. D., Cuzzoert  and Duncan B. (1961) 
<em>Problems in analyzing areal data</em>. Statistical geography, 
Glencoe, Illinois: The free press of Glencoe
</p>


<h3>See Also</h3>

<p>Absolute Concentration Index: <code><a href="#topic+ACO">ACO</a></code>
</p>
<p>Relative Concentration Index: <code><a href="#topic+RCO">RCO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar &lt;- area(segdata)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

Delta(x, a = ar) 

Delta(x, spatobj = segdata)

Delta(x, folder = foldername, shape = shapename) 
</code></pre>

<hr>
<h2 id='DIDuncan'>A function to compute Duncan's dissimilarity segregation index</h2><span id='topic+DIDuncan'></span>

<h3>Description</h3>

<p>Duncan's dissimilarity index is the segregation index 
most commonly used in the literature. It is derived from Lorenz 
curves as the maximum difference between the segregation curve 
and the diagonal. The index measures the unevenness of a group's 
spatial distribution compared to another group. It can be 
interpreted as the share of the group that would have to move to 
achieve an even distribution compared to another group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIDuncan(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DIDuncan_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the dissimilarity index values for each 
pair of groups
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A Methodological 
Analysis of Segregation Indexes</em>. American Sociological Review 41, 
pp. 210-217
</p>


<h3>See Also</h3>

<p>Other one-group  evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+Atkinson">Atkinson</a></code>, <code><a href="#topic+HTheil">HTheil</a></code>, 
<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>, <code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
DIDuncan(x) 
</code></pre>

<hr>
<h2 id='DIMorrill'>A function to compute Morrill's dissimilarity index</h2><span id='topic+DIMorrill'></span>

<h3>Description</h3>

<p>Morrill's dissimilarity index is a development of 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>'s index which takes into account the 
interactions between spatial units(contiguity). The function can 
be used in two ways: to provide a contiguity matrix or a external 
geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIMorrill(x, c = NULL, queen = FALSE, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DIMorrill_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="DIMorrill_+3A_c">c</code></td>
<td>
<p>a standard binary contiguity (adjacency) symmetric matrix where 
each element <em>Cij</em> equals 1 if <em>i</em>-th and <em>j</em>-th spatial 
units are adjacent, and 0 otherwise.</p>
</td></tr>
<tr><td><code id="DIMorrill_+3A_queen">queen</code></td>
<td>
<p>a logical parameter difining criteria used for contiguity 
matrix computation, TRUE for queen, FALSE (by default) for rook</p>
</td></tr>
<tr><td><code id="DIMorrill_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="DIMorrill_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="DIMorrill_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the Morrill's dissimilarity index values 
for each pair of groups
</p>


<h3>References</h3>

<p>Morrill B. (1991) <em>On the measure of geographic 
segregation</em>. Geography research forum, 11, pp. 25-36.
</p>


<h3>See Also</h3>

<p>Other one-group  evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+Atkinson">Atkinson</a></code>, <code><a href="#topic+HTheil">HTheil</a></code>, 
<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>, <code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
contiguity &lt;- contig(segdata)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

DIMorrill(x, c = contiguity) 

DIMorrill(x, spatobj = segdata, queen = FALSE)

DIMorrill(x, folder = foldername, shape = shapename) 
</code></pre>

<hr>
<h2 id='DIMorrillK'>A function to compute K-th order Morrill's dissimilarity index</h2><span id='topic+DIMorrillK'></span>

<h3>Description</h3>

<p>This function compute an adaptation of Morrill's dissimilarity 
index which takes into account the interactions between spatial units
defined by K order contiguity matrix. The function can be used in two ways: 
to provide a contiguity matrix or a external geographic information source 
(spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIMorrillK(x, ck = NULL, queen = FALSE, spatobj = NULL, 
folder = NULL, shape = NULL, K = 2, f = 'exp', beta = 1, prec = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DIMorrillK_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_ck">ck</code></td>
<td>
<p>a list with contiguity matrix for each order (from 1 to K)</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_queen">queen</code></td>
<td>
<p>logical parameter difining criteria used for contiguity 
matrix computation, TRUE for queen, FALSE (by default) for rook</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) .</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_k">K</code></td>
<td>
<p>contiguity matrix order</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_f">f</code></td>
<td>
<p>the distance function, f = 'exp' (by default) for negative 
exponential function and f = 'rec' for reciprocal function</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="DIMorrillK_+3A_prec">prec</code></td>
<td>
<p>precision parameter. If not NULL, the function stop computing
the spatial interaction when the impact on the indice is bellow 10 ^ (-prec)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the Generalized Morrill's dissimilarity index 
values for each pair of groups
</p>


<h3>References</h3>

<p>Morrill B. (1991) <em>On the measure of geographic 
segregation</em>. Geography research forum, 11, pp. 25-36.
</p>


<h3>See Also</h3>

<p>Other one-group  evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+Atkinson">Atkinson</a></code>, <code><a href="#topic+HTheil">HTheil</a></code>, 
<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>, <code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

DIMorrillK(x, spatobj = segdata, queen = FALSE, K = 3)

DIMorrillK(x, folder = foldername, shape = shapename, K = 4, f = 'rec') 
</code></pre>

<hr>
<h2 id='distance'>A function to compute the distance matrix between centroids 
of spatial units</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>The function is based on <span class="pkg">sf</span> 
package and can be used with a shape file or an R spatial object 
(class sf, sfc or sfg).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(spatobj = NULL, folder = NULL, shape = NULL,
distin = 'm',  distout = 'm', diagval = '0')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (class sf, sfc or sfg) containing 
geographic information</p>
</td></tr>
<tr><td><code id="distance_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile with the geographic information 
is located.</p>
</td></tr>
<tr><td><code id="distance_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) which contains the geographic information</p>
</td></tr>
<tr><td><code id="distance_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">measurements</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="distance_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">measurements</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="distance_+3A_diagval">diagval</code></td>
<td>
<p>the user has the choice of the definition of the diagonal: 
diagval = '0'  (by default) for an 'empty' diagonal and diagval = 'a'
to compute  the diagonal as 0.6 * square root (spatial units area) (White, 1983)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the distance between spatial units centroids
</p>


<h3>See Also</h3>

<p>Other spatial functions used for segregation indices 
computation: <code><a href="#topic+area">area</a></code>, <code><a href="#topic+contig">contig</a></code>, 
<code><a href="#topic+perimeter">perimeter</a></code>, <code><a href="#topic+distcenter">distcenter</a></code>, 
<code><a href="#topic+boundaries">boundaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> distance(segdata) 

foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'
distance(folder = foldername, shape = shapename)
</code></pre>

<hr>
<h2 id='distcenter'>A function to compute the distance from spatial units centroids 
to the center</h2><span id='topic+distcenter'></span>

<h3>Description</h3>

<p>The function is based on <span class="pkg">sf</span> 
package and it can be used with a shape file or an R 
spatial object (class sf, sfc or sfg).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distcenter(spatobj = NULL, folder = NULL, shape = NULL, 
center = 1, distin = 'm',  distout = 'm')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distcenter_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (class sf, sfc or sfg) containing 
geographic information</p>
</td></tr>
<tr><td><code id="distcenter_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile with the geographic information 
is located.</p>
</td></tr>
<tr><td><code id="distcenter_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) which contains the geographic information</p>
</td></tr>
<tr><td><code id="distcenter_+3A_center">center</code></td>
<td>
<p>the row number of the center</p>
</td></tr>
<tr><td><code id="distcenter_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">measurements</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="distcenter_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">measurements</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the distance to the center's centroid
</p>


<h3>See Also</h3>

<p>Other spatial functions used for segregation indices 
computation: <code><a href="#topic+area">area</a></code>, <code><a href="#topic+contig">contig</a></code>, 
<code><a href="#topic+perimeter">perimeter</a></code>, <code><a href="#topic+distance">distance</a></code>, 
<code><a href="#topic+boundaries">boundaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distcenter(segdata, center = 46) 
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'
distcenter(folder = foldername, shape = shapename, center = 19)
</code></pre>

<hr>
<h2 id='DIWong'>A function to compute Wongs's dissimilarity index</h2><span id='topic+DIWong'></span>

<h3>Description</h3>

<p>Wong's dissimilarity index is a development of 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>'s which takes into account the interactions 
between spatial units(common boundaries and perimeter/area ratios). 
The function can be used in two ways: to provide spatial data (
boundaries matrix, a perimeter vector and an area vector) 
or a external geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIWong(x, b = NULL,  a = NULL, p = NULL, ptype = 'int', variant = 's', 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DIWong_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
totals because this will be interpreted as a group</p>
</td></tr>
<tr><td><code id="DIWong_+3A_b">b</code></td>
<td>
<p>a common boundaries matrix where each element <em>Bij</em> 
equals the shared boundary of <em>i</em>-th and <em>j</em>-th spatial units.</p>
</td></tr>
<tr><td><code id="DIWong_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="DIWong_+3A_p">p</code></td>
<td>
<p>a numeric vector containing spatial units perimeters.</p>
</td></tr>
<tr><td><code id="DIWong_+3A_ptype">ptype</code></td>
<td>
<p>a string variable giving two options for perimeter calculation
when a spatial object or shapefile is provided: 'int' to use only interior
borders of spatial units, and 'all' to use entire borders, including to
the exterior of the area</p>
</td></tr>
<tr><td><code id="DIWong_+3A_variant">variant</code></td>
<td>
<p>a character variable that allows to choose the index version: 
variant = 's' for the dissimilarity index adjusted for contiguous spatial units
boundary lengths and perimeter/area ratio (by default) and variant = 'w' 
for the version without perimeter/area ratio</p>
</td></tr>
<tr><td><code id="DIWong_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="DIWong_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="DIWong_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the Wong's dissimilarity index values 
for each pair of groups
</p>


<h3>References</h3>

<p>Wong D. W. S. (1993) <em>Spatial Indices of Segregation</em>. 
Urban Studies, 30 (3), pp. 559-572.
</p>


<h3>See Also</h3>

<p>Other one-group  evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+Atkinson">Atkinson</a></code>, <code><a href="#topic+HTheil">HTheil</a></code>, 
'<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>, <code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
bound &lt;- boundaries(segdata)
per &lt;- perimeter(segdata)
ar &lt;- area(segdata)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

DIWong(x, b = bound, p = per, a = ar) 

DIWong(x, spatobj = segdata, variant = 'w') 

DIWong(x, folder = foldername, shape = shapename, ptype ='all') 
</code></pre>

<hr>
<h2 id='DMulti'>A function to compute multigroup dissimilarity index</h2><span id='topic+DMulti'></span>

<h3>Description</h3>

<p>multigroup dissimilarity index, is a multigroup 
version of  Duncan's dissimilarity index (<code><a href="#topic+DIDuncan">DIDuncan</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DMulti(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DMulti_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multigroup dissimilarity index value (numeric)
</p>


<h3>References</h3>

<p>Sakoda J. N. (1981) <em>A generalized Index of 
dissimilarity</em>. Demography,18, 245-250
</p>


<h3>See Also</h3>

<p>multigroup indices: 
<code><a href="#topic+PMulti">PMulti</a></code>, <code><a href="#topic+GiniMulti">GiniMulti</a></code>,   
<code><a href="#topic+HMulti">HMulti</a></code>, <code><a href="#topic+CMulti">CMulti</a></code>, <code><a href="#topic+RelDivers">RelDivers</a></code>
</p>
<p>Social diversity indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+NShannon">NShannon</a></code>, 
<code><a href="#topic+ISimpson">ISimpson</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
DMulti(x) 
</code></pre>

<hr>
<h2 id='DPxx'>A function to compute the distance-decay isolation index (DPxx)</h2><span id='topic+DPxx'></span>

<h3>Description</h3>

<p>The distance decay isolation index, DPxx, is a spatial
adaptation of isolation index <code><a href="#topic+xPx">xPx</a></code>. The function can be 
used in two ways: to provide a distance matrix or a external geographic 
information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DPxx(x, d = NULL, distin = 'm',  distout = 'm', diagval = '0', beta = 1, 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DPxx_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="DPxx_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="DPxx_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="DPxx_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="DPxx_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) 
(White, 1983)</p>
</td></tr>
<tr><td><code id="DPxx_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="DPxx_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="DPxx_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="DPxx_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the distance-decay isolation index values 
for each group
</p>


<h3>References</h3>

<p>Morgan, B. S. (1983) <em>A Distance-Decay Based Interaction 
Index to Measure Residential Segregation</em>. Area 15(3),  pp. 211-217.
</p>


<h3>See Also</h3>

<p>Isolation indices: 
<code><a href="#topic+xPx">xPx</a></code>,  <code><a href="#topic+Eta2">Eta2</a></code>
</p>
<p>Interaction indices: 
<code><a href="#topic+xPy">xPy</a></code>, <code><a href="#topic+DPxy">DPxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar &lt;- area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

DPxx(x, d = dist)

DPxx(x, spatobj = segdata, diagval = 'a')

DPxx(x, folder = foldername, shape = shapename, diagval = '0') 
</code></pre>

<hr>
<h2 id='DPxy'>A function to compute the distance-decay interaction index (DPxy)</h2><span id='topic+DPxy'></span>

<h3>Description</h3>

<p>The distance decay interaction index, DPxy, is a 
spatial adaptation of interaction index <code><a href="#topic+xPy">xPy</a></code>. 
The function can be used in two ways: to provide a distance matrix 
or a external geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DPxy(x, d = NULL, distin = 'm',  distout = 'm', diagval = '0', 
beta = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DPxy_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="DPxy_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="DPxy_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="DPxy_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="DPxy_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) (White, 1983)</p>
</td></tr>
<tr><td><code id="DPxy_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="DPxy_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="DPxy_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="DPxy_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the distance-decay interaction index values 
for each pair of groups
</p>


<h3>References</h3>

<p>Morgan, B. S. (1983) <em>An Alternate Approach to the 
Development of a Distance-Based Measure of Racial Segregation</em>. 
American Journal of Sociology 88,  pp. 1237-1249.
</p>


<h3>See Also</h3>

<p>Isolation indices: 
<code><a href="#topic+xPx">xPx</a></code>, <code><a href="#topic+Eta2">Eta2</a></code>,  <code><a href="#topic+DPxx">DPxx</a></code>
</p>
<p>Interaction index: <code><a href="#topic+xPy">xPy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar &lt;- area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

DPxy(x, d = dist)

DPxy(x, spatobj = segdata, diagval = 'a')

DPxy(x, folder = foldername, shape = shapename, diagval = '0') 
</code></pre>

<hr>
<h2 id='Eta2'>A function to compute adjusted isolation index (Eta2)</h2><span id='topic+Eta2'></span>

<h3>Description</h3>

<p>The adjusted isolation index is the standardized 
version of the isolation index, <code><a href="#topic+xPx">xPx</a></code>, which 
controls for the effect of total population structure. Using 
the approximate version of xPx, the adjusted index is equal 
to Eta2 (the square of the correlation ratio) which, in the 
case of the binomial variable, is identical to the square of 
the mean square contingency coefficient phi. It can be used 
as a segregation score and varies from 0 (minimum segregation) 
to 1 (maximum segregation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eta2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Eta2_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the adjusted isolation index values 
for each group
</p>


<h3>References</h3>

<p>Bell W. (1954) <em>A probability model for the 
measurement of ecological segregation</em>. Social Forces 32(4), 
pp. 357-364
</p>
<p>Duncan O. D. and Duncan B. (1955) <em> 
Residential Distribution and Occupational Stratification.</em>. 
American Journal of Sociology 60 (5), pp. 493-503
</p>


<h3>See Also</h3>

<p>Isolation indices: 
<code><a href="#topic+xPx">xPx</a></code>,  <code><a href="#topic+DPxx">DPxx</a></code>
</p>
<p>Interaction indices: 
<code><a href="#topic+xPy">xPy</a></code>, <code><a href="#topic+DPxy">DPxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
Eta2(x) 
</code></pre>

<hr>
<h2 id='Gini'>A function to compute Gini's segregation index</h2><span id='topic+Gini'></span>

<h3>Description</h3>

<p>The segregation version of the Gini index can be derived from 
the Lorenz curve as the area between the segregation curve and the 
diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gini(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gini_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Gini's segregation index values for each group
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A Methodological 
Analysis of Segregation Indexes</em>. American Sociological Review 41, 
pp. 210-217
</p>


<h3>See Also</h3>

<p>Other one-group  evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Atkinson">Atkinson</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
Gini(x)
</code></pre>

<hr>
<h2 id='Gini2'>A function to compute the between group version of segregation Gini index</h2><span id='topic+Gini2'></span>

<h3>Description</h3>

<p>The between group version of Gini index is obtained 
by computing the index for a subpopulation formed by each pair of groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gini2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gini2_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the between-group Gini index values for 
each pair of groups
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A Methodological 
Analysis of Segregation Indexes</em>. American Sociological Review 41, 
pp. 210-217
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p>Other one-group  evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, 
<code><a href="#topic+Gorard">Gorard</a></code>, <code><a href="#topic+Atkinson">Atkinson</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+DIMorrill">DIMorrill</a></code>, 
<code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
Gini2(x)
</code></pre>

<hr>
<h2 id='GiniMulti'>A function to compute multigroup Gini index</h2><span id='topic+GiniMulti'></span>

<h3>Description</h3>

<p>multigroup Gini is a multigroup version of 
the <code><a href="#topic+Gini">Gini</a></code> index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GiniMulti(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GiniMulti_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multigroup Gini index value (numeric)
</p>


<h3>References</h3>

<p>Reardon S. F. (1998) <em>Measures of racial 
diversity and segregation in multigroup and hierarchical 
structured Populations</em>. Annual meeting of the Eastern 
Sociological Society, Philadelphia
</p>


<h3>See Also</h3>

<p>multigroup indices: 
<code><a href="#topic+PMulti">PMulti</a></code>, <code><a href="#topic+GiniMulti">GiniMulti</a></code>,   
<code><a href="#topic+HMulti">HMulti</a></code>, <code><a href="#topic+CMulti">CMulti</a></code>, <code><a href="#topic+RelDivers">RelDivers</a></code>
</p>
<p>Social diversity indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+NShannon">NShannon</a></code>, 
<code><a href="#topic+ISimpson">ISimpson</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
GiniMulti(x) 
</code></pre>

<hr>
<h2 id='Gorard'>A function to compute Gorard's segregation index</h2><span id='topic+Gorard'></span>

<h3>Description</h3>

<p>Gorard's index is an alternative to <code><a href="#topic+ISDuncan">ISDuncan</a></code>'s 
index, which measures the dissimilarity between the distribution of a 
group and the total population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gorard(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gorard_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
totals because this will be interpreted as a group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Gorard's segregation index values for each group
</p>


<h3>References</h3>

<p>Gorard S. (2000) <em>Education and Social Justice</em>. 
Cardiff, University of Wales Press
</p>


<h3>See Also</h3>

<p>One-group evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Atkinson">Atkinson</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
Gorard(x)
</code></pre>

<hr>
<h2 id='GreHSize'>Households distribution by  size in Grenoble urban area in 2011</h2><span id='topic+GreHSize'></span>

<h3>Description</h3>

<p>This data set gives the households distribution by size in 
Grenoble urban area in 2011, including the area vectorial map at
municipality level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GreHSize)
</code></pre>


<h3>Format</h3>

<p>A Spatial object including 52 polygons corresponding to each municipality of Grenoble Urban Area (Insee definition) and following data attributes:
</p>


<h3>Details</h3>


<ul>
<li><p> code: Municipality code
</p>
</li>
<li><p> name: Municipality name
</p>
</li>
<li><p> small: (1-2 persons household)
</p>
</li>
<li><p> medium: (3-4 persons household)
</p>
</li>
<li><p> big: (more then 5 persons household)
</p>
</li></ul>



<h3>Source</h3>

<p>Insee: Resultats du recensement de la population 2011, <a href="https://www.insee.fr/fr/accueil">Insee</a>
</p>

<hr>
<h2 id='HLoc'>A function to compute local diversity index</h2><span id='topic+HLoc'></span>

<h3>Description</h3>

<p>Local diversity index, HLoc, is a local 
adaptation of Pielou's normalized diversity index <code><a href="#topic+NShannon">NShannon</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HLoc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HLoc_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the local diversity index values for 
each spatial unit
</p>


<h3>References</h3>

<p>Theil H. (1972) <em>Statistical Decomposition Analysis</em>. 
North-Holland, Amsterdam
</p>


<h3>See Also</h3>

<p>Other local indices <code><a href="#topic+LQ">LQ</a></code>
<code><a href="#topic+LShannon">LShannon</a></code>, <code><a href="#topic+LSimpson">LSimpson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
HLoc(x) 
</code></pre>

<hr>
<h2 id='HMulti'>A function to compute multigroup entropy segregation index</h2><span id='topic+HMulti'></span>

<h3>Description</h3>

<p>The multigroup version of Theil's entropy index <code><a href="#topic+HTheil">HTheil</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMulti(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HMulti_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multigroup entropy segregation index value (numeric)
</p>


<h3>References</h3>

<p>Theil H. (1972)  <em>Statistical decomposition analysis: with 
applications in the social and administrative.</em> Amsterdam, North-Holland, 337 p.
</p>


<h3>See Also</h3>

<p>multigroup indices: 
<code><a href="#topic+PMulti">PMulti</a></code>, <code><a href="#topic+GiniMulti">GiniMulti</a></code>, <code><a href="#topic+DMulti">DMulti</a></code>,  
<code><a href="#topic+CMulti">CMulti</a></code>, <code><a href="#topic+RelDivers">RelDivers</a></code>
</p>
<p>Social diversity indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+NShannon">NShannon</a></code>, 
<code><a href="#topic+ISimpson">ISimpson</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
HMulti(x) 
</code></pre>

<hr>
<h2 id='HShannon'>A function to compute Shannon-Wiener diversity (entropy) index</h2><span id='topic+HShannon'></span>

<h3>Description</h3>

<p>The Shannon-Wiener diversity index is based on 
the notion of entropy and measures population heterogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HShannon(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HShannon_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Shannon-Wiener diversity index value (numeric)
</p>


<h3>References</h3>

<p>Shannon C. E. (1948) <em>A mathematical theory 
of communication</em>. Bell System Technical Journal (27)
</p>


<h3>See Also</h3>

<p>Social diversity indices: 
<code><a href="#topic+NShannon">NShannon</a></code>, <code><a href="#topic+ISimpson">ISimpson</a></code>,
</p>
<p>multigroup indices: 
<code><a href="#topic+PMulti">PMulti</a></code>, <code><a href="#topic+GiniMulti">GiniMulti</a></code>, <code><a href="#topic+DMulti">DMulti</a></code>,  
<code><a href="#topic+HMulti">HMulti</a></code>, <code><a href="#topic+CMulti">CMulti</a></code>, <code><a href="#topic+RelDivers">RelDivers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
HShannon(x) 
</code></pre>

<hr>
<h2 id='HTheil'>A function to compute Theil's entropy segregation index</h2><span id='topic+HTheil'></span>

<h3>Description</h3>

<p>The entropy index (also called information index) measures
departure from evenness by assessing each spatial unit deviation from the 
entropy in the area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTheil (x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HTheil_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Theils's segregation index values for each group
</p>


<h3>References</h3>

<p>Theil H. (1972)  <em>Statistical decomposition analysis: with 
applications in the social and administrative.</em> Amsterdam, North-Holland, 337 p.
</p>


<h3>See Also</h3>

<p>One-group evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+Atkinson">Atkinson</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
HTheil(x) 
</code></pre>

<hr>
<h2 id='ISDuncan'>A function to compute Duncan &amp; Duncan segregation index</h2><span id='topic+ISDuncan'></span>

<h3>Description</h3>

<p>Duncan's segregation index is one-group form of 
dissimilarity index <code><a href="#topic+DIDuncan">DIDuncan</a></code> and  
measures the unevenness of a group distribution  
compared to the rest of the population. It can be interpreted
as the share of the group that would have to move to achieve 
an even distribution compared to the rest of the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISDuncan (x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISDuncan_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Duncan's segregation index values 
for each group
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em> 
Residential Distribution and Occupational Stratification</em>. 
American Journal of Sociology 60 (5), pp. 493-503
</p>


<h3>See Also</h3>

<p>One-group evenness indices: 
<code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Atkinson">Atkinson</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ISDuncan(x) 
</code></pre>

<hr>
<h2 id='ISimpson'>A function to compute Simpson's interaction index</h2><span id='topic+ISimpson'></span>

<h3>Description</h3>

<p>Simpson's interaction index measures the probability 
that randomly selected individuals are not in the same group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISimpson(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISimpson_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Simpson's interaction index value (numeric)
</p>


<h3>References</h3>

<p>Simpson E. H. (1949) <em>Measurement of diversity</em>. 
Nature 163:688
</p>


<h3>See Also</h3>

<p>Social diversity indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+NShannon">NShannon</a></code>,
</p>
<p>multigroup indices: 
<code><a href="#topic+PMulti">PMulti</a></code>, <code><a href="#topic+GiniMulti">GiniMulti</a></code>, <code><a href="#topic+DMulti">DMulti</a></code>,  
<code><a href="#topic+HMulti">HMulti</a></code>, <code><a href="#topic+CMulti">CMulti</a></code>, <code><a href="#topic+RelDivers">RelDivers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ISimpson(x) 
</code></pre>

<hr>
<h2 id='ISMorrill'>A function to compute Morrill's segregation index</h2><span id='topic+ISMorrill'></span>

<h3>Description</h3>

<p>Morrill's segregation index is a development of 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>'s index which takes into account the 
interactions between spatial units(contiguity). 
The function can be used in two ways: to provide a contiguity 
matrix or a external geographic information source (spatial object 
or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISMorrill(x, c = NULL, queen = FALSE, 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISMorrill_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ISMorrill_+3A_c">c</code></td>
<td>
<p>a standard binary contiguity (adjacency) symmetric matrix where 
each element <em>Cij</em> equals 1 if <em>i</em>-th and <em>j</em>-th spatial 
units are adjacent, and 0 otherwise.</p>
</td></tr>
<tr><td><code id="ISMorrill_+3A_queen">queen</code></td>
<td>
<p>a logical parameter difining criteria used for the contiguity 
matrix computation, TRUE for queen, FALSE (by default) for rook</p>
</td></tr>
<tr><td><code id="ISMorrill_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ISMorrill_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ISMorrill_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Morrill's segregation index values for 
each group
</p>


<h3>References</h3>

<p>Morrill B. (1991) <em>On the measure of geographic 
segregation</em>. Geography research forum, 11, pp. 25-36.
</p>


<h3>See Also</h3>

<p>One-group evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, <code><a href="#topic+Atkinson">Atkinson</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
contiguity &lt;- contig(segdata)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ISMorrill(x, c = contiguity) 

ISMorrill(x, spatobj = segdata)

ISMorrill(x, folder = foldername, shape = shapename) 

</code></pre>

<hr>
<h2 id='ISMorrillK'>A function to compute K-th order Morrill's segregation index</h2><span id='topic+ISMorrillK'></span>

<h3>Description</h3>

<p>This function computes an adaptation of Morrill's segregation 
index which takes into account the interactions between spatial units 
defined by K-th ordered contiguity matrix. The index can be used in two   
ways: to provide a contiguity units defined by K order contiguity matrix. The 
function can be used in two matrix or a external geographic information source 
(spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISMorrillK(x, ck = NULL, queen = FALSE, spatobj = NULL, folder = NULL, 
shape = NULL, K = 2, f = 'exp', beta = 1, prec = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISMorrillK_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greaterTR than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_ck">ck</code></td>
<td>
<p>a list containing contiguity matrices coresponding to each order 
(from 1 to K)</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_queen">queen</code></td>
<td>
<p>logical parameter defining criteria used for contiguity 
matrix computation, TRUE for queen, FALSE (by default) for rook</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the driveis located.</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_k">K</code></td>
<td>
<p>the order of the contiguity matrix</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_f">f</code></td>
<td>
<p>the distance function, f = 'exp' (by default) for negative 
exponential function and f = 'rec' for reciprocal function</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="ISMorrillK_+3A_prec">prec</code></td>
<td>
<p>precision parameter. If not NULL, the function stop computing
the spatial interaction when the impact on the indice is bellow 10 ^ (-prec)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Generalized Morrill's segregation index 
values for each group
</p>


<h3>References</h3>

<p>Morrill B. (1991) <em>On the measure of geographic 
segregation</em>. Geography research forum, 11, pp. 25-36.
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p>One-group evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, <code><a href="#topic+Atkinson">Atkinson</a></code>, '<code><a href="#topic+ISWong">ISWong</a></code>,
<code><a href="#topic+ISMorrill">ISMorrill</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ISMorrillK(x, spatobj = segdata, queen = FALSE, K = 3)

ISMorrillK(x, folder = foldername, shape = shapename, K = 4, f = 'rec') 

</code></pre>

<hr>
<h2 id='ISWong'>A function to compute Wong's segregation index</h2><span id='topic+ISWong'></span>

<h3>Description</h3>

<p>Wong's segregation index is a development of 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>'s which takes into account the interactions 
between spatial units (common boundaries and perimeter/area ratio). 
The function can be used in two ways: to provide spatial data (
boundaries matrix, a perimeter vector and an area vector) 
or a external geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISWong(x, b = NULL,  a = NULL, p = NULL, ptype = 'int', variant = 's', 
spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISWong_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
totals because this will be interpreted as a group</p>
</td></tr>
<tr><td><code id="ISWong_+3A_b">b</code></td>
<td>
<p>a common boundaries matrix where each element <em>Bij</em> 
equals the shared boundary of <em>i</em>-th and <em>j</em>-th spatial units.</p>
</td></tr>
<tr><td><code id="ISWong_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="ISWong_+3A_p">p</code></td>
<td>
<p>a numeric vector containing spatial units perimeters.</p>
</td></tr>
<tr><td><code id="ISWong_+3A_ptype">ptype</code></td>
<td>
<p>a string variable giving two options for perimeter calculation
when a spatial object or shapefile is provided: 'int' to use only interior
boundaries of spatial units, and 'all' to use entire boundaries, 
including the boundaries to the exterior</p>
</td></tr>
<tr><td><code id="ISWong_+3A_variant">variant</code></td>
<td>
<p>a character variable that allows to choose the index version: 
variant = 's' for the index adjusted for contiguous spatial/organizational units
boundary lengths and perimeter/area ratio (by default) and variant = 'w' 
for the version based only on shared boundaries length</p>
</td></tr>
<tr><td><code id="ISWong_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ISWong_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ISWong_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Wong's segregation index values for each group
</p>


<h3>References</h3>

<p>Wong D. W. S. (1998) <em>Measuring multiethnic spatial 
segregation</em>. Urban Geography, 19 (1), pp. 77-87.
</p>


<h3>See Also</h3>

<p>One-group evenness indices: 
<code><a href="#topic+ISDuncan">ISDuncan</a></code>, <code><a href="#topic+Gini">Gini</a></code>, <code><a href="#topic+Gorard">Gorard</a></code>, 
<code><a href="#topic+HTheil">HTheil</a></code>, '<code><a href="#topic+Atkinson">Atkinson</a></code>, <code><a href="#topic+ISMorrill">ISMorrill</a></code>,
<code><a href="#topic+ISMorrillK">ISMorrillK</a></code>
</p>
<p>Between groups dissimilarity indices: 
<code><a href="#topic+DIDuncan">DIDuncan</a></code>, <code><a href="#topic+Gini2">Gini2</a></code>, 
<code><a href="#topic+DIMorrill">DIMorrill</a></code>, <code><a href="#topic+DIMorrillK">DIMorrillK</a></code>, <code><a href="#topic+DIWong">DIWong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
bound &lt;- boundaries(segdata)
per &lt;- perimeter(segdata)
ar &lt;- area(segdata)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

ISWong(x, b = bound, p = per, a = ar) 

ISWong(x, spatobj = segdata, variant = 's', ptype = 'int')

ISWong(x, folder = foldername, shape = shapename, variant = 'w') 

</code></pre>

<hr>
<h2 id='LQ'>A function to compute location quotients (LQs)</h2><span id='topic+LQ'></span>

<h3>Description</h3>

<p>Location quotients compare the relative part of a 
group in a particular spatial unit, to the relative part of that 
same group in the area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LQ(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LQ_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the location quotients for each group in each spatial unit
</p>


<h3>References</h3>

<p>Isard W. (1960) <em>Methods of regional analysis: 
an introduction to regional science</em>. The MIT Press, Cambridge
</p>


<h3>See Also</h3>

<p>Other local indices <code><a href="#topic+LShannon">LShannon</a></code>
<code><a href="#topic+HLoc">HLoc</a></code>, <code><a href="#topic+LSimpson">LSimpson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
LQ(x) 
</code></pre>

<hr>
<h2 id='LShannon'>A function to compute Shannon-Wiener local diversity (entropy) index</h2><span id='topic+LShannon'></span>

<h3>Description</h3>

<p>The Shannon-Wiener diversity index is based on 
the notion of entropy and measures population heterogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LShannon(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LShannon_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the local Shannon-Wiener diversity index 
values for each spatial unit
</p>


<h3>References</h3>

<p>Shannon C. E. (1948) <em>A mathematical theory 
of communication</em>. Bell System Technical Journal (27)
</p>


<h3>See Also</h3>

<p>Other local indices: <code><a href="#topic+LQ">LQ</a></code>, 
<code><a href="#topic+HLoc">HLoc</a></code>, <code><a href="#topic+LSimpson">LSimpson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
LShannon(x) 
</code></pre>

<hr>
<h2 id='LSimpson'>A function to compute local Simpson's index</h2><span id='topic+LSimpson'></span>

<h3>Description</h3>

<p>Local Simpson's interaction index measures the probability 
that randomly selected individuals are not in the same group in 
each spatial unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LSimpson (x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LSimpson_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the local Simpson's interaction index values 
for each spatial unit
</p>


<h3>References</h3>

<p>Simpson E. H. (1949) <em>Measurement of diversity</em>. 
Nature 163:688
</p>


<h3>See Also</h3>

<p>Other local indices: <code><a href="#topic+LQ">LQ</a></code>, 
<code><a href="#topic+HLoc">HLoc</a></code>, <code><a href="#topic+LShannon">LShannon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
LSimpson (x) 
</code></pre>

<hr>
<h2 id='NShannon'>A function to compute Shannon-Wiener diversity normalized index</h2><span id='topic+NShannon'></span>

<h3>Description</h3>

<p>The Shannon-Wiener diversity index is based on 
the notion of entropy and measures population heterogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NShannon(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NShannon_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Shannon-Wiener normalized diversity index value (numeric)
</p>


<h3>References</h3>

<p>Shannon C. E. (1948) <em>A mathematical theory 
of communication</em>. Bell System Technical Journal (27)
</p>


<h3>See Also</h3>

<p>Other multigroup eveness indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+ISimpson">ISimpson</a></code>, 
<code><a href="#topic+GiniMulti">GiniMulti</a></code>, <code><a href="#topic+DMulti">DMulti</a></code>, <code><a href="#topic+HMulti">HMulti</a></code>, 
<code><a href="#topic+CMulti">CMulti</a></code>
</p>
<p>Other multigroup indices: <code><a href="#topic+PMulti">PMulti</a></code>, 
<code><a href="#topic+RelDivers">RelDivers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
NShannon(x) 
</code></pre>

<hr>
<h2 id='ordinalseg'>A function to compute Reardon multigroup ordinal segregation indices</h2><span id='topic+ordinalseg'></span>

<h3>Description</h3>

<p>A function to compute Reardon (2009) ordinal indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinalseg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinalseg_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group. The rows
represent the nominal categories (spatial units) and the columns the ordinal 
categories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing Reardon's multigroup ordinal segregation indices: 
Lambda1 (the ordinal generalization of the information theory index), 
Lambda2 (the ordinal generalization of the variation ratio index), 
Lambda3 (the ordinal square root index), and
Lambda4 (the ordinal absolute difference index)
</p>


<h3>References</h3>

<p>Reardon S. F. (2009) <em>Measures of ordinal segregation</em>. 
Research on Economic Inequality, 17, pp. 129-155.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rankorderseg">rankorderseg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- GreHSize@data[ ,3:5]
ordinalseg(x) 

x1 &lt;- matrix(nrow = 4, ncol = 3)
x1[1,] &lt;- c(0, 0, 30)
x1[2,] &lt;- c(0, 20, 10)
x1[3,] &lt;- c(10, 20 ,0)
x1[4,] &lt;- c(30, 0 ,0)

x2 &lt;- matrix(nrow = 4, ncol = 3)
x2[1,] &lt;- c(0, 30, 0)
x2[2,] &lt;- c(0, 10, 20)
x2[3,] &lt;- c(10, 0, 20)
x2[4,] &lt;- c(30, 0, 0)

ordinalseg(x1)
ordinalseg(x2)
</code></pre>

<hr>
<h2 id='perimeter'>A function to compute the spatial units' perimeters</h2><span id='topic+perimeter'></span>

<h3>Description</h3>

<p>The function is based on on <span class="pkg">sf</span> package
and can be used with a shape file or an R spatial object 
(class sf, sfc or sfg).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perimeter(spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perimeter_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (class sf, sfc or sfg) containing 
geographic information</p>
</td></tr>
<tr><td><code id="perimeter_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile with the geographic information 
is located.</p>
</td></tr>
<tr><td><code id="perimeter_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension) which contains the geographic information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the perimeter of spatial units
</p>


<h3>See Also</h3>

<p>Other spatial functions used for segregation indices 
computation:  <code><a href="#topic+area">area</a></code>, <code><a href="#topic+contig">contig</a></code>, 
<code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+distcenter">distcenter</a></code>, 
<code><a href="#topic+boundaries">boundaries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> perimeter(segdata)  
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'
perimeter(folder = foldername, shape = shapename)
</code></pre>

<hr>
<h2 id='PMulti'>A function to compute multigroup normalised exposure (PMulti)</h2><span id='topic+PMulti'></span>

<h3>Description</h3>

<p>The multigroup normalised isolation index is a 
multigroup version of the isolation index (<code><a href="#topic+xPx">xPx</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PMulti(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PMulti_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multigroup normalised isolation index value (numeric)
</p>


<h3>References</h3>

<p>James, F. J. (1986) <em>A New Generalized 'Exposure-Based' 
Segregation Index</em>. Sociological Methods and Research, 14, pp. 301-316
</p>
<p>Reardon S. F. and G. Firebaugh (2002) <em>Measures of 
multigroup Segregation</em>. Sociological Methodology, 32(1), pp 33-67
</p>


<h3>See Also</h3>

<p>multigroup indices: 
<code><a href="#topic+GiniMulti">GiniMulti</a></code>, <code><a href="#topic+DMulti">DMulti</a></code>,  
<code><a href="#topic+HMulti">HMulti</a></code>, <code><a href="#topic+CMulti">CMulti</a></code>, <code><a href="#topic+RelDivers">RelDivers</a></code>
</p>
<p>Social diversity indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+NShannon">NShannon</a></code>, 
<code><a href="#topic+ISimpson">ISimpson</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
PMulti(x) 
</code></pre>

<hr>
<h2 id='Poo'>A function to compute the mean proximity between 
persons without regard to group (Poo)</h2><span id='topic+Poo'></span>

<h3>Description</h3>

<p>Mean proximity, Poo, computes the mean distance 
between the individuals in the area with no regard for group.
The function can be used in two ways: to provide a distance matrix 
or a external geographic information source (spatial object 
or shape file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Poo(x, d = NULL, fdist = 'e', distin = 'm',  distout = 'm', diagval = '0', 
itype = 'multi', beta = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Poo_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="Poo_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="Poo_+3A_fdist">fdist</code></td>
<td>
<p>the method used for distance interaction matrix: 
e' for inverse exponential function (by default) and 'l' for linear.</p>
</td></tr>
<tr><td><code id="Poo_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="Poo_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="Poo_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) (White, 1983)</p>
</td></tr>
<tr><td><code id="Poo_+3A_itype">itype</code></td>
<td>
<p>a character string defining the index type:
itype = 'multi' (by default) for the multigroup index (White, 1986)
or itype = 'between' for the between groups version (White, 1983)</p>
</td></tr>
<tr><td><code id="Poo_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="Poo_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="Poo_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="Poo_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Poo index value (numeric)
</p>


<h3>References</h3>

<p>White M. J. (1983) <em>The Measurement of Spatial 
Segregation</em>. American Journal of Sociology, 88, p. 1008-1019
</p>
<p>White, M. J. (1986) <em>Segregation and Diversity Measures 
in Population Distribution</em>E. Population Index 52(2): 198-221.
</p>


<h3>See Also</h3>

<p>Proximity measures: <code><a href="#topic+Pxx">Pxx</a></code>, 
<code><a href="#topic+Pxy">Pxy</a></code>,  <code><a href="#topic+SP">SP</a></code>
</p>
<p>Clustering Indices: 
<code><a href="#topic+ACL">ACL</a></code>, <code><a href="#topic+RCL">RCL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar&lt;-area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

Poo(x, spatobj = segdata)

Poo(x, folder = foldername, shape = shapename, fdist = 'l') 

Poo(x, spatobj = segdata, diagval ='a')

Poo(x, d = dist, fdist = 'e') 

</code></pre>

<hr>
<h2 id='Pxx'>A function to compute the mean proximity between members of a group (Pxx)</h2><span id='topic+Pxx'></span>

<h3>Description</h3>

<p>Mean proximity, Pxx, computes the mean distance 
between the members of a group. The distance matrix can be expressed as  
a linear or as an inverse exponential function of the distance between 
spatial unit centroids.The function can be used in two ways: to provide  
a distance matrix  or a external geographic information source (spatial 
object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pxx(x, d = NULL, fdist = 'e', distin = 'm',  distout = 'm', diagval = '0', 
beta = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pxx_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="Pxx_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="Pxx_+3A_fdist">fdist</code></td>
<td>
<p>the method used for distance interaction matrix: 
e' for inverse exponential function (by default) and 'l' for linear.</p>
</td></tr>
<tr><td><code id="Pxx_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="Pxx_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="Pxx_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) (White, 1983)</p>
</td></tr>
<tr><td><code id="Pxx_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="Pxx_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="Pxx_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="Pxx_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the Pxx index values for each group
</p>


<h3>References</h3>

<p>White M. J. (1983) <em>The Measurement of Spatial 
Segregation</em>. American Journal of Sociology, 88, p. 1008-1019
</p>


<h3>See Also</h3>

<p>Proximity measures: 
<code><a href="#topic+Pxy">Pxy</a></code>, <code><a href="#topic+Poo">Poo</a></code>, <code><a href="#topic+SP">SP</a></code>
</p>
<p>Clustering Indices: 
<code><a href="#topic+ACL">ACL</a></code>, <code><a href="#topic+RCL">RCL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar&lt;-area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

Pxx(x, spatobj = segdata)

Pxx(x, folder = foldername, shape = shapename, fdist = 'l') 

Pxx(x, spatobj = segdata, diagval ='a')

Pxx(x, d = dist, fdist = 'e')

</code></pre>

<hr>
<h2 id='Pxy'>A function to compute the mean proximity between 
persons of different groups (Pxy)</h2><span id='topic+Pxy'></span>

<h3>Description</h3>

<p>Mean proximity, Pxy, computes the mean distance 
between the members of different groups.The function can be used in 
two ways: to provide a distance matrix or a external geographic 
information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pxy(x, d = NULL, fdist = 'e', distin = 'm',  distout = 'm', diagval = '0', 
beta = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pxy_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="Pxy_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="Pxy_+3A_fdist">fdist</code></td>
<td>
<p>the method used for distance interaction matrix: 
e' for inverse exponential function (by default) and 'l' for linear.</p>
</td></tr>
<tr><td><code id="Pxy_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="Pxy_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="Pxy_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) (White, 1983)</p>
</td></tr>
<tr><td><code id="Pxy_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="Pxy_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="Pxy_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="Pxy_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the Pxy index values for each pair of groups
</p>


<h3>References</h3>

<p>White M. J. (1983) <em>The Measurement of 
Spatial Segregation</em>. American Journal of Sociology, 88, p. 1008-1019
</p>


<h3>See Also</h3>

<p>Proximity measures: <code><a href="#topic+Pxx">Pxx</a></code>, 
<code><a href="#topic+Poo">Poo</a></code>,  <code><a href="#topic+SP">SP</a></code>
</p>
<p>Clustering Indices: 
<code><a href="#topic+ACL">ACL</a></code>, <code><a href="#topic+RCL">RCL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar&lt;-area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

Pxy(x, spatobj = segdata)

Pxy(x, folder = foldername, shape = shapename, fdist = 'l') 

Pxy(x, spatobj = segdata, diagval ='a')

Pxy(x, d = dist, fdist = 'e')

</code></pre>

<hr>
<h2 id='rankorderseg'>A function to compute rank-ordered segregation indices</h2><span id='topic+rankorderseg'></span>

<h3>Description</h3>

<p>A function computing Reardon (2011) rank-ordered 
segregation indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankorderseg(x, polorder = 4, pred = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankorderseg_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group. The rows
represent the nominal categories (spatial units) and the columns the population
distribution as ordered groups divided by thresholds</p>
</td></tr>
<tr><td><code id="rankorderseg_+3A_polorder">polorder</code></td>
<td>
<p>order of the polynomial approximation (4 by default)</p>
</td></tr>
<tr><td><code id="rankorderseg_+3A_pred">pred</code></td>
<td>
<p>a numerical vector with percentiles to be predicted. 
If NULL, the predictions are made at threshold levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results for three rank-ordered indices: 
rank-order information theory index (Hr), rank-order variation ratio 
index (Rr) and rank-order square root index (Sr). For each index, a sublist 
is provided, containing: 
Index (the rank-ordered index value), 
Hp/Rp/Sp (a vector containing the ordinal information theory/variance 
ratio/square root segregation index values at thresholds), 
Coefficients (the coefficients extracted from the polynomial estimation model,
including basic statistics), 
Predict (a list containing predicted values of the corresponding ordinal index (fit); 
standard error of predicted means (se.fit); degrees of freedom for residual (df); 
and residual standard deviations (residuale.scale). If pred is NULL, the function 
will return the statistics at thresholds)
</p>


<h3>References</h3>

<p>Reardon S. F. (2011) <em>Measures of Income Segregation
</em>. The Stanford Center on Poverty and Inequality
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalseg">ordinalseg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- matrix(nrow = 4, ncol = 7)
x1[1,] &lt;- c( 10,  10, 10, 20, 30, 40, 50)
x1[2,] &lt;- c( 0, 20, 10, 10, 10, 20, 20)
x1[3,] &lt;- c(10, 20,  10, 10, 10, 0, 0 )
x1[4,] &lt;- c(30, 30,  20, 10, 10, 0, 0 )
x2 &lt;- x1
x2[,c(3,4,6,7)] &lt;- x1[,c(6,7,3,4)]

rankorderseg(x1)
rankorderseg(x2, pred = seq(0, 1, 0.1))

</code></pre>

<hr>
<h2 id='RCE'>A function to compute Duncan's Relative Centralisation Index (RCE)</h2><span id='topic+RCE'></span>

<h3>Description</h3>

<p>The relative centralisation index measures the 
proportion of a group that should change its localization to 
achieve the same level of centralization as another group.
The function can be used in two ways: to provide a vector containing 
the distances between spatial unit centroids or a external geographic 
information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCE(x, dc = NULL, center = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RCE_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="RCE_+3A_dc">dc</code></td>
<td>
<p>a numeric vector containing the distances between spatial units
centroids and the central spatial unit</p>
</td></tr>
<tr><td><code id="RCE_+3A_center">center</code></td>
<td>
<p>a numeric value giving the number of the spatial unit that 
represents the center in the table</p>
</td></tr>
<tr><td><code id="RCE_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="RCE_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="RCE_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the relative centralisation index values 
for each pair of groups
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A 
Methodological Analysis of Segregation Indexes</em>. 
American Sociological Review 41, pp. 210-217
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RCEPoly">RCEPoly</a></code>, <code><a href="#topic+RCEPolyK">RCEPolyK</a></code>,
</p>
<p><code><a href="#topic+ACEDuncan">ACEDuncan</a></code>, <code><a href="#topic+ACEDuncanPoly">ACEDuncanPoly</a></code>,
</p>
<p><code><a href="#topic+ACEDuncanPolyK">ACEDuncanPolyK</a></code>, <code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+ACEPoly">ACEPoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
distc&lt;- distcenter(segdata, center = 28)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

RCE(x, dc=distc) 

RCE(x, spatobj = segdata, center = 28) 

RCE(x, folder = foldername, shape = shapename, center = 28) 

</code></pre>

<hr>
<h2 id='RCEPoly'>A function to compute Duncan's Polycentric Relative Centralisation Index</h2><span id='topic+RCEPoly'></span>

<h3>Description</h3>

<p>The polycentric version of the relative centralisation index. 
The function can be used in two ways: to provide a matrix containing 
the distances between spatial/organizational unit centroids or a external  
geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCEPoly(x, dc = NULL, center = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RCEPoly_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="RCEPoly_+3A_dc">dc</code></td>
<td>
<p>a numeric matrix/vector containing the distances between spatial units
centroids and the central spatial unit(s).</p>
</td></tr>
<tr><td><code id="RCEPoly_+3A_center">center</code></td>
<td>
<p>a numeric vector  giving the number of the spatial units that 
represent the centers in the table</p>
</td></tr>
<tr><td><code id="RCEPoly_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="RCEPoly_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="RCEPoly_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the polycentric relative centralisation index values 
for each pair of groups
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A 
Methodological Analysis of Segregation Indexes</em>. 
American Sociological Review 41, pp. 210-217
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RCE">RCE</a></code>, <code><a href="#topic+RCEPolyK">RCEPolyK</a></code>,
</p>
<p><code><a href="#topic+ACEDuncan">ACEDuncan</a></code>, <code><a href="#topic+ACEDuncanPoly">ACEDuncanPoly</a></code>,
</p>
<p><code><a href="#topic+ACEDuncanPolyK">ACEDuncanPolyK</a></code>, <code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+ACEPoly">ACEPoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

RCEPoly(x, spatobj = segdata, center = c(28, 83) )

RCEPoly(x, folder = foldername, shape = shapename, center = c(28, 83))

center &lt;- c(28, 83)
polydist &lt;- matrix(data = NA, nrow = nrow(x), ncol = length(center))
for (i in 1:ncol(polydist))
  polydist[,i] &lt;- distcenter(spatobj = segdata, center = center[i])
RCEPoly(x, dc = polydist)

distmin &lt;- vector(length = nrow(x))
for (i in 1:nrow(polydist)) distmin[i] &lt;- min(polydist[i,])
RCE(x, dc = distmin)

</code></pre>

<hr>
<h2 id='RCEPolyK'>A function to compute Constrained Polyentric Relative Centralisation Index</h2><span id='topic+RCEPolyK'></span>

<h3>Description</h3>

<p>The constrained (local) version of relative centralization index.
The function can be used in two ways: to provide a matrix containing 
the distances between spatial unit centroids or a external geographic 
information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCEPolyK(x, dc = NULL,  K = NULL, kdist = NULL, center = 1,
                spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RCEPolyK_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="RCEPolyK_+3A_dc">dc</code></td>
<td>
<p>a numeric matrix/vector containing the distances between spatial units
centroids and the central spatial unit(s).</p>
</td></tr>
<tr><td><code id="RCEPolyK_+3A_k">K</code></td>
<td>
<p>the number of neighbourhoods under the influence of a center</p>
</td></tr>
<tr><td><code id="RCEPolyK_+3A_kdist">kdist</code></td>
<td>
<p>the maximal distance that defines the neighbourhoods influenced
by a center</p>
</td></tr>
<tr><td><code id="RCEPolyK_+3A_center">center</code></td>
<td>
<p>a numeric vector  giving the number of the spatial units that 
represent the centers in the table</p>
</td></tr>
<tr><td><code id="RCEPolyK_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="RCEPolyK_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="RCEPolyK_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the constrainted polycentric relative centralisation 
index values for each pair of groups
</p>


<h3>References</h3>

<p>Duncan O. D. and Duncan B. (1955) <em>A 
Methodological Analysis of Segregation Indexes</em>. 
American Sociological Review 41, pp. 210-217
</p>
<p>Folch D.C and Rey S. J (2016) <em>The centralization index: 
A measure of local spatial segregation</em>. Papers in Regional 
Science 95 (3), pp. 555-576
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RCE">RCE</a></code>, <code><a href="#topic+RCEPoly">RCEPoly</a></code>,
</p>
<p><code><a href="#topic+ACEDuncan">ACEDuncan</a></code>, <code><a href="#topic+ACEDuncanPoly">ACEDuncanPoly</a></code>,
</p>
<p><code><a href="#topic+ACEDuncanPolyK">ACEDuncanPolyK</a></code>, <code><a href="#topic+ACE">ACE</a></code>, <code><a href="#topic+ACEPoly">ACEPoly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

RCEPolyK(x, spatobj = segdata, center = c(28, 83))

RCEPolyK(x, folder = foldername, shape = shapename, center = c(28, 83), K = 3)

center &lt;- c(28, 83)
polydist &lt;- matrix(data = NA, nrow = nrow(x), ncol = length(center))
for (i in 1:ncol(polydist))
  polydist[,i] &lt;- distcenter(spatobj = segdata, center = center[i])
RCEPolyK(x, dc = polydist, kdist = 2)

</code></pre>

<hr>
<h2 id='RCL'>A function to compute the relative clustering index (RCL)</h2><span id='topic+RCL'></span>

<h3>Description</h3>

<p>The relative clustering index, RCL, compares the mean 
proximity of a group to the mean proximity of another group. 
The function can be used in two ways: to provide a distance matrix 
or a external geographic information source (spatial object 
or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCL(x, d = NULL, fdist = 'e', distin = 'm',  distout = 'm', diagval = '0', 
beta = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RCL_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="RCL_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="RCL_+3A_fdist">fdist</code></td>
<td>
<p>the method used for distance interaction matrix: 
e' for inverse exponential function (by default) and 'l' for linear.</p>
</td></tr>
<tr><td><code id="RCL_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="RCL_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="RCL_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) (White, 1983)</p>
</td></tr>
<tr><td><code id="RCL_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="RCL_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="RCL_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="RCL_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the relative clustering index values for 
each pair of groups
</p>


<h3>References</h3>

<p>Massey D. S. and Denton N. A. (1988) <em>The dimensions 
of residential segregation</em>. Social Forces 67(2),  pp. 281-315.
</p>


<h3>See Also</h3>

<p>Proximity measures: <code><a href="#topic+Pxx">Pxx</a></code>, 
<code><a href="#topic+Pxy">Pxy</a></code>,  <code><a href="#topic+Poo">Poo</a></code>,  <code><a href="#topic+SP">SP</a></code>
</p>
<p>Clustering Indices: <code><a href="#topic+ACL">ACL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar&lt;-area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

RCL(x, spatobj = segdata)

RCL(x, folder = foldername, shape = shapename, fdist = 'l') 

RCL(x, spatobj = segdata, diagval ='a')

RCL(x, d = dist, fdist = 'e')

</code></pre>

<hr>
<h2 id='RCO'>A function to compute Relative Concentration index (RCO)</h2><span id='topic+RCO'></span>

<h3>Description</h3>

<p>The relative concentration index, measures 
the share of space occupied by a group compared to another group.
The function can be used in two ways: to provide an area vector or a 
external geographic information source (spatial object or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCO(x, a = NULL, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RCO_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="RCO_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="RCO_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="RCO_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="RCO_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the relative concentration index values 
for each pair of groups
</p>


<h3>References</h3>

<p>Massey D. S. and Denton N. A. (1988) <em>
The dimensions of residential segregation</em>. 
Social Forces 67(2),  pp. 281-315.
</p>


<h3>See Also</h3>

<p>one-group concentration indices: 
<code><a href="#topic+Delta">Delta</a></code>,  <code><a href="#topic+ACO">ACO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- GreHSize@data[ ,3:5]
ar &lt;- area(GreHSize)
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'GreHSize'

RCO(x, a = ar) 

RCO(x, spatobj = GreHSize)

RCO(x, folder = foldername, shape = shapename) 

</code></pre>

<hr>
<h2 id='RelDivers'>A function to compute multigroup relative diversity index</h2><span id='topic+RelDivers'></span>

<h3>Description</h3>

<p>The relative diversity index is a multigroup 
index based on Simpson's interaction index <code><a href="#topic+ISimpson">ISimpson</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RelDivers(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RelDivers_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The multigroup relative diversity index value (numeric)
</p>


<h3>References</h3>

<p>Carlson S. M. (1992) <em>Trends in race/sex 
occupational inequality:  conceptual and measurement issues</em>. 
Social Problems, 39, p. 269-290
</p>


<h3>See Also</h3>

<p>multigroup indices: 
<code><a href="#topic+PMulti">PMulti</a></code>, <code><a href="#topic+GiniMulti">GiniMulti</a></code>, <code><a href="#topic+DMulti">DMulti</a></code>,  
<code><a href="#topic+HMulti">HMulti</a></code>, <code><a href="#topic+CMulti">CMulti</a></code>
</p>
<p>Social diversity indices: 
<code><a href="#topic+HShannon">HShannon</a></code>, <code><a href="#topic+NShannon">NShannon</a></code>, 
<code><a href="#topic+ISimpson">ISimpson</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
RelDivers(x) 
</code></pre>

<hr>
<h2 id='ResamplePlot'>A function to plot the results of resampling methods</h2><span id='topic+ResamplePlot'></span>

<h3>Description</h3>

<p>Plot of Monte Carlo simulations results. The function can
be used in two ways: buy providing a ResampleTest object, using <code><a href="#topic+ResampleTest">ResampleTest</a></code> 
or a simulated distribution vector, a value and a name of the index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResamplePlot(ResampleTest, var = 1, coldist = 'red', colind = 'blue', 
legend = TRUE, legendpos = 'top', cex.legend = 1, bty = 'o')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResamplePlot_+3A_resampletest">ResampleTest</code></td>
<td>
<p>- a ResampleTest object prodused with <code><a href="#topic+ResampleTest">ResampleTest</a></code> function</p>
</td></tr>
<tr><td><code id="ResamplePlot_+3A_var">var</code></td>
<td>
<p>the number of the variable to be plot</p>
</td></tr>
<tr><td><code id="ResamplePlot_+3A_coldist">coldist</code></td>
<td>
<p>color used to plot the simulated distribution</p>
</td></tr>
<tr><td><code id="ResamplePlot_+3A_colind">colind</code></td>
<td>
<p>color used to plot the index</p>
</td></tr>
<tr><td><code id="ResamplePlot_+3A_legend">legend</code></td>
<td>
<p>logical parameter, to control the legend's plots</p>
</td></tr>
<tr><td><code id="ResamplePlot_+3A_legendpos">legendpos</code></td>
<td>
<p>a character string giving the legend's position: 
'bottomright', 'bottom', 'bottomleft', 'left', 'topleft', 'top', 
'topright', 'right' and 'center'.</p>
</td></tr>
<tr><td><code id="ResamplePlot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>a numerical value giving the amount by which 
plotting text and symbols in legend should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="ResamplePlot_+3A_bty">bty</code></td>
<td>
<p>a character string which determines the type of box 
of the legend. If bty is one of 'o' (the default), 'l', '7', 'c', 
'u', or ']' the resulting box resembles the corresponding upper 
case letter. A value of 'n' suppresses the box.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with resampling theoretical distribution
</p>


<h3>References</h3>

<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ResampleTest">ResampleTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]

xtest &lt;- ResampleTest (x, fun ='ISMorrill', simtype = 'MonteCarlo', 
                       sampleunit = 'unit', spatobj = segdata)
                       
ResamplePlot(xtest, var = 1)

</code></pre>

<hr>
<h2 id='ResampleTest'>A function to test segregation indices by resampling</h2><span id='topic+ResampleTest'></span>

<h3>Description</h3>

<p>Resampling tests for segregation indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResampleTest(
  x,
  fun,
  var = NULL,
  simtype = "MonteCarlo",
  sampleunit = "unit",
  samplesize = NULL,
  perc = c(0.05, 0.95),
  outl = FALSE,
  outmeth = "bp",
  sdtimes = 2,
  IQRrange = 1.5,
  proba = NULL,
  nsim = NULL,
  spatobj = NULL,
  folder = NULL,
  shape = NULL,
  delta = 0.5,
  exact = FALSE,
  d = NULL,
  c = NULL,
  a = NULL,
  ck = NULL,
  f = "exp",
  b = NULL,
  p = NULL,
  spatmat = "c",
  queen = FALSE,
  distin = "m",
  distout = "m",
  diagval = "0",
  fdist = "e",
  itype = "multi",
  dc = NULL,
  center = 1,
  polorder = 4,
  pred = NULL,
  K = 2,
  ptype = "int",
  variant = "s",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResampleTest_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_fun">fun</code></td>
<td>
<p>a character vector with the segregation function 
to be tested</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_var">var</code></td>
<td>
<p>vector with the variables to be tested</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_simtype">simtype</code></td>
<td>
<p>a character vector with the type of simulation. 
If simtype = 'Boot', the function generates bootstrap replications
If simtype = 'Jack', the function generates jackknife replications
If simtype = 'MonteCarlo', the function produces a randomization test 
using Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_sampleunit">sampleunit</code></td>
<td>
<p>= 'unit' (by default) when the sampling unit is the 
spatial/organisational unit and sampleunit = 'ind' for individual sampling</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_samplesize">samplesize</code></td>
<td>
<p>the size of the sample used for bootstraping. If null, 
the samplesize equals the number of spatial/organizational units(sampleunit = 'unit') or 
the total total population (sampleunit = 'ind')</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_perc">perc</code></td>
<td>
<p>the percentiles for the bootstrap replications</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_outl">outl</code></td>
<td>
<p>logical parameter for jackknife simulations, if TRUE 
the function provides the outliers obtained by jackknife iterations</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_outmeth">outmeth</code></td>
<td>
<p>- a character vector designing the outliers detection method:
outmeth = 'bp' (by default) for boxplot method, 
outmeth = 'sd'  for standard deviation method, 
outmeth = 'z'  for normal scores method,
outmeth = 't'  for t Student scores method,
outmeth = 'chisq'  for chi-squared scores method,
outmeth = 'mad'  for median absolute deviation method.
The estimations based on scoring methods are obtained using outliers package</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_sdtimes">sdtimes</code></td>
<td>
<p>multiplication factor of the standard deviation used for
outliers detection with jackknife simulations (2 by default)</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_iqrrange">IQRrange</code></td>
<td>
<p>determines the boxplot thresholds (1.5 by default) as multiplication of 
IQR (Inter Quartile Range)</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_proba">proba</code></td>
<td>
<p>for Monte Carlo simulations, proba is a vector with location 
probabilities. If proba = NULL, the vector is equiprobable. If outliers are determined 
with jackknife technique, proba indicates the probability (confidence interval) for 
scoring tests.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_delta">delta</code></td>
<td>
<p>an inequality aversion parameter</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_exact">exact</code></td>
<td>
<p>a logical variable to specifiy the index version: 
exact = FALSE (by default) for the approximate version of the index, 
and exact = TRUE for the exact version</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_c">c</code></td>
<td>
<p>a standard binary contiguity (adjacency) symmetric matrix where 
each element <em>Cij</em> equals 1 if <em>i</em>-th and <em>j</em>-th spatial 
units are adjacent, and 0 otherwise.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_ck">ck</code></td>
<td>
<p>a list containing contiguity matrices coresponding to each order 
(from 1 to K)</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_f">f</code></td>
<td>
<p>the distance function, f = 'exp' (by default) for negative 
exponential function and f = 'rec' for reciprocal function</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_b">b</code></td>
<td>
<p>a common boundaries matrix where each element <em>Bij</em></p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_p">p</code></td>
<td>
<p>a numeric vector containing spatial units perimeters.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_spatmat">spatmat</code></td>
<td>
<p>the method used for spatial calculations: 'c' for the 
contiguity matrix (by default) or any other user spatial interaction matrix 
and 'd' for the inverse exponential function of the distance.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_queen">queen</code></td>
<td>
<p>logical parameter defining criteria used for contiguity 
matrix computation, TRUE for queen, FALSE (by default) for rook</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) 
(White, 1983)</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_fdist">fdist</code></td>
<td>
<p>the method used for distance interaction matrix: 
e' for inverse exponential function (by default) and 'l' for linear.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_itype">itype</code></td>
<td>
<p>a character string defining the index type:
itype = 'multi' (by default) for the multigroup index (White, 1986)
or itype = 'between' for the between groups version (White, 1983)</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_dc">dc</code></td>
<td>
<p>a numeric vector containing the distances between spatial units
centroids and the central spatial unit</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_center">center</code></td>
<td>
<p>a numeric value giving the number of the spatial unit that 
represents the center in the table</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_polorder">polorder</code></td>
<td>
<p>order of the polynomial approximation (4 by default)</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_pred">pred</code></td>
<td>
<p>a numerical vector with percentiles to be predicted.</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_k">K</code></td>
<td>
<p>the order of the contiguity matrix</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_ptype">ptype</code></td>
<td>
<p>a string variable giving two options for perimeter calculation
when a spatial object or shapefile is provided: 'int' to use only interior
boundaries of spatial units, and 'all' to use entire boundaries, 
including the boundaries to the exterior</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_variant">variant</code></td>
<td>
<p>a character variable that allows to choose the index version: 
variant = 's' for the dissimilarity index adjusted for contiguous spatial units
boundary lengths and perimeter/area ratio (by default) and variant = 'w' 
for the version without perimeter/area ratio</p>
</td></tr>
<tr><td><code id="ResampleTest_+3A_...">...</code></td>
<td>
<p>other specific parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including: 
the index's name, 
the simulation type, 
the summary statistics of the simulations, 
the simulated index distribution, 
the simulated population distribution,
a matrix with outliers (jackknife), 
a list with outliers values (jackknife)
</p>


<h3>References</h3>

<p>Efron, B., and Tibshirani, R. J. (1993). 
<em>An Introduction to the Bootstrap</em>. New York, Chapman and Hall
</p>
<p>Tivadar M. (2019) 
<em>OasisR: An R Package to Bring Some Order to the World of Segregation Measurement</em>.
Journal of Statistical Software,  89 (7), pp 1-39
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ResamplePlot">ResamplePlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]

xtest &lt;- ResampleTest (x, fun ='ISMorrill', simtype = 'MonteCarlo', 
                       sampleunit = 'ind', spatobj = segdata)
xtest$Summary

xtest &lt;- ResampleTest (x, fun ='ISMorrill', simtype = 'Boot', 
                       sampleunit = 'unit', spatobj = segdata)
xtest$Summary

xtest &lt;- ResampleTest (GreHSize@data[,3:5], fun='ISDuncan', simtype = 'Jack', 
                       sampleunit = 'unit',  spatobj = GreHSize, 
                       outl = TRUE, outmeth = 'sd', sdtimes = 3)
xtest$Summary
xtest$OutliersVal

</code></pre>

<hr>
<h2 id='segdata'>Theoretical two groups distribution on a 10x10 grid map.</h2><span id='topic+segdata'></span>

<h3>Description</h3>

<p>The theoretical examples ( Morrill 1991, Wong 1993) adapted 
from Hong and O'Sullivan (2015). The space is represented by 
a 10x10 checkboard, with different distributions of two social 
groups in the area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(segdata)
</code></pre>


<h3>Format</h3>

<p>A 10x10 grid Spatial object and following data attributes:
</p>


<h3>Details</h3>


<ul>
<li><p> : spatial ID;
</p>
</li>
<li><p> : municipality name;
</p>
</li>
<li><p> : pattern A: minority distribution;
</p>
</li>
<li><p> : pattern A: majority distribution;
</p>
</li>
<li><p> : pattern B: minority distribution;
</p>
</li>
<li><p> : pattern B: majority distribution;
</p>
</li>
<li><p> : pattern C: minority distribution;
</p>
</li>
<li><p> : pattern C: majority distribution;
</p>
</li>
<li><p> : pattern D: minority distribution;
</p>
</li>
<li><p> : pattern D: majority distribution;
</p>
</li>
<li><p> : pattern E: minority distribution;
</p>
</li>
<li><p> : pattern E: majority distribution;
</p>
</li>
<li><p> : pattern F: minority distribution;
</p>
</li>
<li><p> : pattern F: majority distribution;
</p>
</li>
<li><p> : pattern G: minority distribution;
</p>
</li>
<li><p> : pattern G: majority distribution;
</p>
</li>
<li><p> : pattern H: minority distribution;
</p>
</li>
<li><p> : pattern H: majority distribution;
</p>
</li>
<li><p> : pattern I: minority distribution;
</p>
</li>
<li><p> : pattern I: majority distribution;
</p>
</li></ul>


<hr>
<h2 id='segdataclean'>A function to clean and prepare the data for segregation analysis</h2><span id='topic+segdataclean'></span>

<h3>Description</h3>

<p>The function cleans and prepares the data for segregation analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segdataclean (x, c = NULL, b = NULL, a = NULL, p = NULL, 
ck = NULL, d = NULL, dc = NULL, spatobj = NULL, folder = NULL, shape = NULL, 
warnings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segdataclean_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_c">c</code></td>
<td>
<p>a standard binary contiguity (adjacency) symmetric matrix where 
each element <em>Cij</em> equals 1 if <em>i</em>-th and <em>j</em>-th spatial 
units are adjacent, and 0 otherwise.</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_b">b</code></td>
<td>
<p>a common boundaries matrix where each element <em>Bij</em></p>
</td></tr>
<tr><td><code id="segdataclean_+3A_a">a</code></td>
<td>
<p>a numeric vector containing spatial unit areas</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_p">p</code></td>
<td>
<p>a numeric vector containing spatial units perimeters.</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_ck">ck</code></td>
<td>
<p>a list containing contiguity matrices coresponding to each order 
(from 1 to K)</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_dc">dc</code></td>
<td>
<p>a numeric vector containing the distances between spatial units
centroids and the central spatial unit</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
<tr><td><code id="segdataclean_+3A_warnings">warnings</code></td>
<td>
<p>- warning alert (by default TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The objects (data matrix, geographical vectors/matrices, spatial objects)
cleaned from null rows or columns
</p>


<h3>See Also</h3>

<p>Other local indices: <code><a href="#topic+LQ">LQ</a></code>, 
<code><a href="#topic+HLoc">HLoc</a></code>, <code><a href="#topic+LShannon">LShannon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
x[ ,3] &lt;- rep (0 ,100)
x[1:3, ] &lt;- rep (c(0, 0, 0), 3)
x1 &lt;- x
spatobj &lt;- segdata
cldata &lt;- segdataclean(x1, segdata)
x1 &lt;- cldata$x
spatobj &lt;- cldata$spatobj

c &lt;- contig (segdata)
c &lt;- segdataclean(x, c = c)$c

</code></pre>

<hr>
<h2 id='SP'>A function to compute the spatial proximity index (SP)</h2><span id='topic+SP'></span>

<h3>Description</h3>

<p>The spatial proximity index, SP, compares the clustering 
level (mean proximity) of a group compared to another group. 
The function can be used in two ways: to provide a distance matrix 
or a external geographic information source (spatial object 
or shape file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SP(x, d = NULL, fdist = 'e', distin = 'm',  distout = 'm', diagval = '0', 
itype = 'multi', beta = 1, spatobj = NULL, folder = NULL, shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SP_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="SP_+3A_d">d</code></td>
<td>
<p>a matrix of the distances between spatial unit centroids</p>
</td></tr>
<tr><td><code id="SP_+3A_fdist">fdist</code></td>
<td>
<p>the method used for distance interaction matrix: 
e' for inverse exponential function (by default) and 'l' for linear.</p>
</td></tr>
<tr><td><code id="SP_+3A_distin">distin</code></td>
<td>
<p>input metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions from 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="SP_+3A_distout">distout</code></td>
<td>
<p>output metric conversion, based on  <span class="pkg">bink</span> package and 
includes conversions to 'm', 'km', 'inch', 'ft', 'yd', 'mi', 'naut_mi', etc.</p>
</td></tr>
<tr><td><code id="SP_+3A_diagval">diagval</code></td>
<td>
<p>when providing a spatial object or a shape file, 
the user has the choice of the spatial matrix diagonal definition: 
diagval = '0' (by default) for an null diagonal and diagval = 'a' 
to compute the diagonal as 0.6 * square root (spatial/organizational unitsarea) (White, 1983)</p>
</td></tr>
<tr><td><code id="SP_+3A_itype">itype</code></td>
<td>
<p>a character string defining the index type:
itype = 'multi' (by default) for the multigroup index (White, 1986),
itype = 'between' for the between groups version (White, 1983), or
itype = 'one' for the one-group version (Apparicio et al, 2008)</p>
</td></tr>
<tr><td><code id="SP_+3A_beta">beta</code></td>
<td>
<p>distance decay parameter</p>
</td></tr>
<tr><td><code id="SP_+3A_spatobj">spatobj</code></td>
<td>
<p>a spatial object (SpatialPolygonsDataFrame) with 
geographic information</p>
</td></tr>
<tr><td><code id="SP_+3A_folder">folder</code></td>
<td>
<p>a character vector with the folder (directory) 
name indicating where the shapefile is located on the drive</p>
</td></tr>
<tr><td><code id="SP_+3A_shape">shape</code></td>
<td>
<p>a character vector with the name of the shapefile 
(without the .shp extension).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If itype = 'multi' the function returns the multigroup
spatial proximity index value (numeric). If itype = 'between', the 
function returns a matrix containing the between group values of the 
index. If itype = 'one', the function's  output is a numeric vector 
containing the index values for each group
</p>


<h3>References</h3>

<p>White M. J. (1983) <em>The Measurement of Spatial 
Segregation</em>. American Journal of Sociology, 88, p. 1008-1019.
</p>
<p>White, M. J. (1986) <em>Segregation and Diversity Measures 
in Population Distribution</em>E. Population Index 52(2): 198-221.
</p>
<p>Apparicio, P., V. Petkevitch and M. Charron (2008): <em>Segregation 
Analyzer: A C#.Net application for calculating residential segregation indices</em>, 
Cybergeo: European Journal of Geography, 414, 1-27.
</p>


<h3>See Also</h3>

<p>Proximity measures: <code><a href="#topic+Pxx">Pxx</a></code>, 
<code><a href="#topic+Pxy">Pxy</a></code>,  <code><a href="#topic+Poo">Poo</a></code>
</p>
<p>Clustering Indices: 
<code><a href="#topic+ACL">ACL</a></code>, <code><a href="#topic+RCL">RCL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
ar&lt;-area(segdata)
dist &lt;- distance(segdata)
diag(dist)&lt;-sqrt(ar) * 0.6
foldername &lt;- system.file('extdata', package = 'OasisR')
shapename &lt;- 'segdata'

SP(x, spatobj = segdata)

SP(x, folder = foldername, shape = shapename, fdist = 'l', itype = 'between') 

SP(x, spatobj = segdata, diagval ='a', itype = 'one')

SP(x, d = dist, fdist = 'e')

</code></pre>

<hr>
<h2 id='xPx'>A function to compute Bell's isolation index (xPx)</h2><span id='topic+xPx'></span>

<h3>Description</h3>

<p>The isolation index, xPx, is an exposure index 
that measures the probability that two members of a group share 
the same spatial unit. This index can be calculated using the 
approximate or the exact method (see Bell, 1954).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xPx(x, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xPx_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="xPx_+3A_exact">exact</code></td>
<td>
<p>a logical variable to specifiy the index version: 
exact = FALSE (by default) for the approximate version of the index, 
and exact = TRUE for the exact version</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the isolation index values for each group
</p>


<h3>References</h3>

<p>Bell W. (1954) <em>A probability model for the 
measurement of ecological segregation</em>. Social Forces 32(4), 
pp. 357-364
</p>


<h3>See Also</h3>

<p>Isolation indices: 
<code><a href="#topic+Eta2">Eta2</a></code>,  <code><a href="#topic+DPxx">DPxx</a></code>
</p>
<p>Interaction indices: 
<code><a href="#topic+xPy">xPy</a></code>, <code><a href="#topic+DPxy">DPxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,7:8]
xPx(x) 
xPx(x, exact = TRUE)
</code></pre>

<hr>
<h2 id='xPy'>A function to compute interaction index (xPy)</h2><span id='topic+xPy'></span>

<h3>Description</h3>

<p>The interaction index, xPy, is an exposure 
between groups index which measures the probability that a member 
of a group shares the same spatial unit with a member of another 
group. The index can be calculated with the approximate or exact 
method (see Bell, 1954).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xPy(x, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xPy_+3A_x">x</code></td>
<td>
<p>an object of class matrix (or which can be coerced to that class), 
where each column represents the distribution of a group within 
spatial units. The number of columns should be greater than 1 (at least 2 
groups are required). You should not include a column with total 
population, because this will be interpreted as a group.</p>
</td></tr>
<tr><td><code id="xPy_+3A_exact">exact</code></td>
<td>
<p>a logical variable to specifiy the index version: 
exact = FALSE (by default) for the approximate version of the index, 
and exact = TRUE for the exact version</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the interaction index values for each 
pair of groups
</p>


<h3>References</h3>

<p>Bell W. (1954) <em>A probability model for the 
measurement of ecological segregation</em>. Social Forces 32(4),
pp. 357-364
</p>


<h3>See Also</h3>

<p>Isolation indices: 
<code><a href="#topic+xPx">xPx</a></code>, <code><a href="#topic+Eta2">Eta2</a></code>,  <code><a href="#topic+DPxx">DPxx</a></code>
</p>
<p>Distance decay interaction index: <code><a href="#topic+DPxy">DPxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- segdata@data[ ,1:2]
xPy(x) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
