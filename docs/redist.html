<!DOCTYPE html><html><head><title>Help for package redist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {redist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#redist-package'><p>redist: Simulation Methods for Legislative Redistricting</p></a></li>
<li><a href='#add_reference'><p>Add a reference plan to a set of plans</p></a></li>
<li><a href='#avg_by_prec'><p>Average a variable by precinct</p></a></li>
<li><a href='#classify_plans'><p>Hierarchically classify a set of redistricting plans</p></a></li>
<li><a href='#compare_plans'><p>Make a comparison between two sets of plans</p></a></li>
<li><a href='#competitiveness'><p>Compute Competitiveness</p></a></li>
<li><a href='#constraints'><p>Sampling constraints</p></a></li>
<li><a href='#county_splits'><p>Count County Splits</p></a></li>
<li><a href='#distr_compactness'><p>Calculate compactness measures for a set of plans</p></a></li>
<li><a href='#EPSG'><p>EPSG Table</p></a></li>
<li><a href='#fl25'><p>Florida 25 Precinct Shape File</p></a></li>
<li><a href='#fl25_adj'><p>Florida 25 Precinct File</p></a></li>
<li><a href='#fl25_enum'><p>All Partitions of 25 Precincts into 3 Congressional Districts</p>
(No Population Constraint)</a></li>
<li><a href='#fl250'><p>Florida 250 Precinct Shape File</p></a></li>
<li><a href='#fl70'><p>Florida 70 Precinct Shape File</p></a></li>
<li><a href='#freeze'><p>Freeze Parts of a Map</p></a></li>
<li><a href='#get_adj'><p>Get and set the adjacency graph from a <code>redist_map</code> object</p></a></li>
<li><a href='#get_existing'><p>Extract the existing district assignment from a <code>redist_map</code> object</p></a></li>
<li><a href='#get_mh_acceptance_rate'><p>Extract the Metropolis Hastings Acceptance Rate</p></a></li>
<li><a href='#get_plans_matrix'><p>Extract the matrix of district assignments from a redistricting simulation</p></a></li>
<li><a href='#get_plans_weights'><p>Extract the sampling weights from a redistricting simulation.</p></a></li>
<li><a href='#get_pop_tol'><p>Get and set the population tolerance from a <code>redist_map</code> object</p></a></li>
<li><a href='#get_sampling_info'><p>Extract the sampling information from a redistricting simulation</p></a></li>
<li><a href='#get_target'><p>Extract the target district population from a <code>redist_map</code> object</p></a></li>
<li><a href='#group_frac'><p>Calculate Group Proportion by District</p></a></li>
<li><a href='#iowa'><p>Iowa County File</p></a></li>
<li><a href='#is_contiguous'><p>Check that a <code>redist_map</code> object is contiguous</p></a></li>
<li><a href='#is_county_split'><p>Identify which counties are split by a plan</p></a></li>
<li><a href='#last_plan'><p>Extract the last plan from a set of plans</p></a></li>
<li><a href='#make_cores'><p>Identify Cores of a District (Heuristic)</p></a></li>
<li><a href='#match_numbers'><p>Renumber districts to match an existing plan</p></a></li>
<li><a href='#merge_by'><p>Merge map units</p></a></li>
<li><a href='#min_move_parity'><p>Calculates Sparse Population Moves to Minimize Population Deviation</p></a></li>
<li><a href='#muni_splits'><p>Counts the Number of Municipalities Split Between Districts</p></a></li>
<li><a href='#number_by'><p>Renumber districts to match a quantity of interest</p></a></li>
<li><a href='#partisan_metrics'><p>Calculate gerrymandering metrics for a set of plans</p></a></li>
<li><a href='#pl'><p>Access the Current <code>redist_plans()</code> Object</p></a></li>
<li><a href='#plan_distances'><p>Compute Distance between Partitions</p></a></li>
<li><a href='#plans_diversity'><p>Calculate the diversity of a set of plans</p></a></li>
<li><a href='#plot.redist_classified'><p>Plot a plan classification</p></a></li>
<li><a href='#plot.redist_constr'><p>Visualize constraints</p></a></li>
<li><a href='#plot.redist_map'><p>Plot a <code>redist_map</code></p></a></li>
<li><a href='#plot.redist_plans'><p>Summary plots for <code>\link{redist_plans}</code></p></a></li>
<li><a href='#prec_assignment'><p>Extract the district assignments for a precinct across all simulated plans</p></a></li>
<li><a href='#prec_cooccurrence'><p>Compute a matrix of precinct co-occurrences</p></a></li>
<li><a href='#print.redist_classified'><p>Print redist_classified objects</p></a></li>
<li><a href='#print.redist_constr'><p>Generic to print redist_constr</p></a></li>
<li><a href='#print.redist_map'><p>Generic to print redist_map</p></a></li>
<li><a href='#print.redist_plans'><p>Print method for <code>redist_plans</code></p></a></li>
<li><a href='#pullback'><p>Pull back plans to unmerged units</p></a></li>
<li><a href='#rbind.redist_plans'><p>Combine multiple sets of redistricting plans</p></a></li>
<li><a href='#redist_ci'><p>Confidence Intervals for SMC and MCMC Estimates</p></a></li>
<li><a href='#redist_constr'><p>Set up constraints for sampling</p></a></li>
<li><a href='#redist_flip'><p>'Flip' Markov Chain Monte Carlo Redistricting Simulation (Fifield et al. 2020)</p></a></li>
<li><a href='#redist_flip_anneal'><p>Flip MCMC Redistricting Simulator using Simulated Annealing</p></a></li>
<li><a href='#redist_map'><p>Create a <code>redist_map</code> object.</p></a></li>
<li><a href='#redist_mergesplit'><p>Merge-Split/Recombination MCMC Redistricting Sampler (Carter et al. 2019)</p></a></li>
<li><a href='#redist_mergesplit_parallel'><p>Parallel Merge-Split/Recombination MCMC Redistricting Sampler</p></a></li>
<li><a href='#redist_plans'><p>A set of redistricting plans</p></a></li>
<li><a href='#redist_quantile_trunc'><p>Helper function to truncate importance weights</p></a></li>
<li><a href='#redist_shortburst'><p>Redistricting Optimization through Short Bursts</p></a></li>
<li><a href='#redist_smc'><p>SMC Redistricting Sampler (McCartan and Imai 2023)</p></a></li>
<li><a href='#redist.adjacency'><p>Adjacency List functionality for redist</p></a></li>
<li><a href='#redist.calc.frontier.size'><p>Calculate Frontier Size</p></a></li>
<li><a href='#redist.coarsen.adjacency'><p>Coarsen Adjacency List</p></a></li>
<li><a href='#redist.combine.mpi'><p>Combine successive runs of <code>redist.mcmc.mpi</code></p></a></li>
<li><a href='#redist.constraint.helper'><p>Create Constraints for SMC</p></a></li>
<li><a href='#redist.county.id'><p>Create County IDs</p></a></li>
<li><a href='#redist.county.relabel'><p>Relabel Discontinuous Counties</p></a></li>
<li><a href='#redist.crsg'><p>Redistricting via Compact Random Seed and Grow Algorithm</p></a></li>
<li><a href='#redist.diagplot'><p>Diagnostic plotting functionality for MCMC redistricting.</p></a></li>
<li><a href='#redist.dist.pop.overlap'><p>Compare the Population Overlap Across Plans at the District Level</p></a></li>
<li><a href='#redist.district.splits'><p>Counts the Number of Counties within a District</p></a></li>
<li><a href='#redist.enumpart'><p>Enumerate All Parititions (Fifield et al. 2020)</p></a></li>
<li><a href='#redist.find.target'><p>Find Majority Minority Remainder</p></a></li>
<li><a href='#redist.findparams'><p>Run parameter testing for <code>redist_flip</code></p></a></li>
<li><a href='#redist.init.enumpart'><p>Initialize enumpart</p></a></li>
<li><a href='#redist.ipw'><p>Inverse probability reweighting for MCMC Redistricting</p></a></li>
<li><a href='#redist.mcmc.mpi'><p>MCMC Redistricting Simulator using MPI</p></a></li>
<li><a href='#redist.multisplits'><p>Counts the Number of Counties Split Between 3 or More Districts</p></a></li>
<li><a href='#redist.parity'><p>Calculates Maximum Deviation from Population Parity</p></a></li>
<li><a href='#redist.plot.adj'><p>Creates a Graph Overlay</p></a></li>
<li><a href='#redist.plot.cores'><p>Plot Cores</p></a></li>
<li><a href='#redist.plot.distr_qtys'><p>Plot quantities by district</p></a></li>
<li><a href='#redist.plot.hist'><p>Plot a histogram of a summary statistic</p></a></li>
<li><a href='#redist.plot.majmin'><p>Majority Minority Plots</p></a></li>
<li><a href='#redist.plot.map'><p>Plot a Map</p></a></li>
<li><a href='#redist.plot.penalty'><p>(Deprecated) Visualize Group Power Penalty</p></a></li>
<li><a href='#redist.plot.plans'><p>Plot a district assignment</p></a></li>
<li><a href='#redist.plot.scatter'><p>Scatter plot of plan summary statistics</p></a></li>
<li><a href='#redist.plot.trace'><p>Make a traceplot for a summary statistic</p></a></li>
<li><a href='#redist.plot.varinfo'><p>Static Variation of Information Plot</p></a></li>
<li><a href='#redist.plot.wted.adj'><p>Plot Weighted Border Adjacency</p></a></li>
<li><a href='#redist.prec.pop.overlap'><p>Compare the Population Overlap Across Plans at the Precinct Level</p></a></li>
<li><a href='#redist.prep.enumpart'><p>Prepares a run of the enumpart algorithm by ordering edges</p></a></li>
<li><a href='#redist.random.subgraph'><p>Return a random subgraph of a shape</p></a></li>
<li><a href='#redist.read.enumpart'><p>Read Results from enumpart</p></a></li>
<li><a href='#redist.reduce.adjacency'><p>Reduce Adjacency List</p></a></li>
<li><a href='#redist.reorder'><p>Reorders district numbers</p></a></li>
<li><a href='#redist.rsg'><p>Redistricting via Random Seed and Grow Algorithm</p></a></li>
<li><a href='#redist.run.enumpart'><p>Runs the enumpart algorithm</p></a></li>
<li><a href='#redist.sink.plan'><p>Sink Plans to 1:ndists</p></a></li>
<li><a href='#redist.smc_is_ci'><p>(Deprecated) Confidence Intervals for Importance Sampling Estimates</p></a></li>
<li><a href='#redist.subset'><p>Subset a shp</p></a></li>
<li><a href='#redist.uncoarsen'><p>Uncoarsen a District Matrix</p></a></li>
<li><a href='#redist.wted.adj'><p>Create Weighted Adjacency Data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#scorer_group_pct'><p>Scoring functions for <code>redist_shortburst</code></p></a></li>
<li><a href='#scorer-arith'><p>Scoring function arithmetic</p></a></li>
<li><a href='#scorer-combine'><p>Combine scoring functions</p></a></li>
<li><a href='#segregation_index'><p>Segregation index calculation for MCMC redistricting.</p></a></li>
<li><a href='#subset_sampled'><p>Subset to sampled or reference draws</p></a></li>
<li><a href='#summary.redist_plans'><p>Diagnostic information on sampled plans</p></a></li>
<li><a href='#tally_var'><p>Tally a variable by district</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation Methods for Legislative Redistricting</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher T. Kenny &lt;christopherkenny@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables researchers to sample redistricting plans from a pre-specified
    target distribution using Sequential Monte Carlo and Markov Chain Monte Carlo
    algorithms. The package allows for the implementation of various constraints in
    the redistricting process such as geographic compactness and population parity
    requirements. Tools for analysis such as computation of various summary statistics
    and plotting functionality are also included. The package implements the SMC 
    algorithm of McCartan and Imai (2023) &lt;<a href="https://doi.org/10.1214%2F23-AOAS1763">doi:10.1214/23-AOAS1763</a>&gt;, the enumeration 
    algorithm of Fifield, Imai, Kawahara, and Kenny (2020) &lt;<a href="https://doi.org/10.1080%2F2330443X.2020.1791773">doi:10.1080/2330443X.2020.1791773</a>&gt;,
    the Flip MCMC algorithm of Fifield, Higgins, Imai and Tarr (2020) &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1739532">doi:10.1080/10618600.2020.1739532</a>&gt;,
    the Merge-split/Recombination algorithms of Carter et al. (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1911.01503">doi:10.48550/arXiv.1911.01503</a>&gt; 
    and DeFord et al. (2021) &lt;<a href="https://doi.org/10.1162%2F99608f92.eb30390f">doi:10.1162/99608f92.eb30390f</a>&gt;, and the Short-burst 
    optimization algorithm of Cannon et al. (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2011.02288">doi:10.48550/arXiv.2011.02288</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), redistmetrics (&ge; 1.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0), rlang, cli (&ge; 3.1.0), vctrs, tidyselect,
stringr, dplyr (&ge; 1.0.0), sf, doParallel, foreach, doRNG,
servr, sys, ggplot2, patchwork</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, withr, loo, Rmpi, knitr, rmarkdown, rmapshaper, scales,
units, RSpectra, testthat (&ge; 3.0.0), spelling</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppThread, cli, redistmetrics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17, python</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alarm-redist/redist/issues">https://github.com/alarm-redist/redist/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alarm-redist.org/redist/">https://alarm-redist.org/redist/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-12 22:52:40 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher T. Kenny [aut, cre],
  Cory McCartan [aut],
  Ben Fifield [aut],
  Kosuke Imai [aut],
  Jun Kawahara [ctb],
  Alexander Tarr [ctb],
  Michael Higgins [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='redist-package'>redist: Simulation Methods for Legislative Redistricting</h2><span id='topic+redist-package'></span><span id='topic+_PACKAGE'></span><span id='topic+redist'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Enables researchers to sample redistricting plans from a pre-specified target distribution using Sequential Monte Carlo and Markov Chain Monte Carlo algorithms. The package allows for the implementation of various constraints in the redistricting process such as geographic compactness and population parity requirements. Tools for analysis such as computation of various summary statistics and plotting functionality are also included. The package implements the SMC algorithm of McCartan and Imai (2023) <a href="https://doi.org/10.1214/23-AOAS1763">doi:10.1214/23-AOAS1763</a>, the enumeration algorithm of Fifield, Imai, Kawahara, and Kenny (2020) <a href="https://doi.org/10.1080/2330443X.2020.1791773">doi:10.1080/2330443X.2020.1791773</a>, the Flip MCMC algorithm of Fifield, Higgins, Imai and Tarr (2020) <a href="https://doi.org/10.1080/10618600.2020.1739532">doi:10.1080/10618600.2020.1739532</a>, the Merge-split/Recombination algorithms of Carter et al. (2019) <a href="https://arxiv.org/abs/1911.01503">arXiv:1911.01503</a> and DeFord et al. (2021) <a href="https://doi.org/10.1162/99608f92.eb30390f">doi:10.1162/99608f92.eb30390f</a>, and the Short-burst optimization algorithm of Cannon et al. (2020) <a href="https://arxiv.org/abs/2011.02288">arXiv:2011.02288</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Christopher T. Kenny <a href="mailto:christopherkenny@fas.harvard.edu">christopherkenny@fas.harvard.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Cory McCartan <a href="mailto:corymccartan@nyu.edu">corymccartan@nyu.edu</a>
</p>
</li>
<li><p> Ben Fifield <a href="mailto:benfifield@gmail.com">benfifield@gmail.com</a>
</p>
</li>
<li><p> Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Jun Kawahara <a href="mailto:jkawahara@i.kyoto-u.ac.jp">jkawahara@i.kyoto-u.ac.jp</a> [contributor]
</p>
</li>
<li><p> Alexander Tarr <a href="mailto:atarr@princeton.edu">atarr@princeton.edu</a> [contributor]
</p>
</li>
<li><p> Michael Higgins <a href="mailto:mikehiggins@k-state.edu">mikehiggins@k-state.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://alarm-redist.org/redist/">https://alarm-redist.org/redist/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/alarm-redist/redist/issues">https://github.com/alarm-redist/redist/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_reference'>Add a reference plan to a set of plans</h2><span id='topic+add_reference'></span>

<h3>Description</h3>

<p>This function facilitates comparing an existing (i.e., non-simulated)
redistricting plan to a set of simulated plans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_reference(plans, ref_plan, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_reference_+3A_plans">plans</code></td>
<td>
<p>a <code>redist_plans</code> object</p>
</td></tr>
<tr><td><code id="add_reference_+3A_ref_plan">ref_plan</code></td>
<td>
<p>an integer vector containing the reference plan. It will be
renumbered to 1..<code>ndists</code>.</p>
</td></tr>
<tr><td><code id="add_reference_+3A_name">name</code></td>
<td>
<p>a human-readable name for the reference plan. Defaults to the
name of <code>ref_plan</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified <code>redist_plans</code> object containing the reference plan
</p>

<hr>
<h2 id='avg_by_prec'>Average a variable by precinct</h2><span id='topic+avg_by_prec'></span>

<h3>Description</h3>

<p>Takes a column of a <code>redist_plans</code> object and averages it across a set of
<code>draws</code> for each precinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_by_prec(plans, x, draws = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_by_prec_+3A_plans">plans</code></td>
<td>
<p>a <code>redist_plans</code> object</p>
</td></tr>
<tr><td><code id="avg_by_prec_+3A_x">x</code></td>
<td>
<p>an expression to average. Tidy-evaluated in <code>plans</code>.</p>
</td></tr>
<tr><td><code id="avg_by_prec_+3A_draws">draws</code></td>
<td>
<p>which draws to average. <code>NULL</code> will average all draws, including
reference plans. The special value <code>NA</code> will average all sampled draws. An
integer, logical, or character vector indicating specific draws may also be
provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length matching the number of precincts, containing the average.
</p>

<hr>
<h2 id='classify_plans'>Hierarchically classify a set of redistricting plans</h2><span id='topic+classify_plans'></span>

<h3>Description</h3>

<p>Applies hierarchical clustering to a distance matrix computed from a set of
plans and takes the first <code>k</code> splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_plans(dist_mat, k = 8, method = "complete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_plans_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a distance matrix, the output of <code><a href="#topic+plan_distances">plan_distances()</a></code></p>
</td></tr>
<tr><td><code id="classify_plans_+3A_k">k</code></td>
<td>
<p>the number of groupings to create</p>
</td></tr>
<tr><td><code id="classify_plans_+3A_method">method</code></td>
<td>
<p>the clustering method to use. See <code><a href="stats.html#topic+hclust">hclust()</a></code> for options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>redist_classified</code>, which is a list with two
elements:
</p>
<table>
<tr><td><code>groups</code></td>
<td>
<p>A character vector of group labels of the form <code>"I.A.1.a.i"</code>,
one for each plan.</p>
</td></tr>
<tr><td><code>splits</code></td>
<td>
<p>A list of splits in the hierarchical clustering. Each list
element is a list of two mutually exclusive vectors of plan indices, labeled
by their group classification, indicating the plans on each side of the split.</p>
</td></tr>
</table>
<p>Use <code><a href="#topic+plot.redist_classified">plot.redist_classified()</a></code> for a visual summary.
</p>

<hr>
<h2 id='compare_plans'>Make a comparison between two sets of plans</h2><span id='topic+compare_plans'></span>

<h3>Description</h3>

<p>This function provides one way to identify the structural differences between
two sets of redistricting plans. It operates by computing the precinct
co-occurrence matrix (a symmetric matrix where the i,j-th entry is the
fraction of plans where precinct i and j are in the same district) for each
set, and then computing the first eigenvalue of the difference in these two
matrices (in each direction). These eigenvalues identify the important parts
of the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_plans(
  plans,
  set1,
  set2,
  shp = NULL,
  plot = "fill",
  thresh = 0.1,
  labs = c("Set 1", "Set 2"),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_plans_+3A_plans">plans</code></td>
<td>
<p>a <a href="#topic+redist_plans">redist_plans</a> object</p>
</td></tr>
<tr><td><code id="compare_plans_+3A_set1">set1</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> indexing vectors
for the plan draws to compare.  Alternatively, a second <a href="#topic+redist_plans">redist_plans</a>
object to compare to.</p>
</td></tr>
<tr><td><code id="compare_plans_+3A_set2">set2</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> indexing vectors
for the plan draws to compare. Must be mutually exclusive with <code>set1</code>.</p>
</td></tr>
<tr><td><code id="compare_plans_+3A_shp">shp</code></td>
<td>
<p>a shapefile for plotting.</p>
</td></tr>
<tr><td><code id="compare_plans_+3A_plot">plot</code></td>
<td>
<p>If <code>plot="line"</code>, display a plot for each set showing the set of
boundaries which most distinguish it from the other set (the squared
differences in the eigenvector values across the boundary).  If
<code>plot="fill"</code>, plot the eigenvector for each set as a choropleth. If <code>plot = 'adj'</code>,
plot the shows the adjacency graph edges which most distinguish it from the other set.
The adj option is a different graphical option of the same information as the line
option. See below for more information.  Set to <code>FALSE</code> to disable plotting
(or leave out <code>shp</code>).</p>
</td></tr>
<tr><td><code id="compare_plans_+3A_thresh">thresh</code></td>
<td>
<p>the value to threshold the eigenvector at in determining the
relevant set of precincts for comparison.</p>
</td></tr>
<tr><td><code id="compare_plans_+3A_labs">labs</code></td>
<td>
<p>the names of the panels in the plot.</p>
</td></tr>
<tr><td><code id="compare_plans_+3A_ncores">ncores</code></td>
<td>
<p>the number of parallel cores to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The co-occurrence matrices are regularized with a <code class="reqn">Beta(1/ndists, 1-1/ndists)</code>
prior, which is useful for when either <code>set1</code> or <code>set2</code> is small.
</p>


<h3>Value</h3>

<p>If possible, makes a comparison plot according to <code>plot</code>. Otherwise
returns the following list:
</p>
<table>
<tr><td><code>eigen1</code></td>
<td>
<p>A numeric vector containing the first eigenvector of
<code>p1 - p2</code>, where <code>p1</code> and <code>p2</code> are the co-occurrence matrices
for <code>set1</code> and <code>set2</code>, respectively.</p>
</td></tr>
<tr><td><code>eigen2</code></td>
<td>
<p>A numeric vector containing the first eigenvector of
<code>p2 - p1</code>, where <code>p1</code> and <code>p2</code> are the co-occurrence matrices
for <code>set1</code> and <code>set2</code>, respectively.</p>
</td></tr>
<tr><td><code>group_1a</code>, <code>group_1b</code></td>
<td>
<p>Lists of precincts. Compared to <code>set2</code>, in the
<code>set1</code> plans these precincts were much more likely to be in separate
districts. Computed by thresholding <code>eigen1</code> at <code>thresh</code>.</p>
</td></tr>
<tr><td><code>group_2a</code>, <code>group_2b</code></td>
<td>
<p>Lists of precincts. Compared to <code>set1</code>, in the
<code>set2</code> plans these precincts were much more likely to be in separate
districts. Computed by thresholding <code>eigen2</code> at <code>thresh</code>.</p>
</td></tr>
<tr><td><code>cooccur_sep_1</code></td>
<td>
<p>The difference in the average co-occurrence of precincts
in <code>group_1a</code> and <code>group_1b</code> between <code>set2</code> and <code>set1</code>.
Higher indicates better separation.</p>
</td></tr>
<tr><td><code>cooccur_sep_2</code></td>
<td>
<p>The difference in the average co-occurrence of precincts
in <code>group_2a</code> and <code>group_2b</code> between <code>set1</code> and <code>set2</code>.
Higher indicates better separation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
iowa_map &lt;- redist_map(iowa, ndists = 4, pop_tol = 0.05)
plans1 &lt;- redist_smc(iowa_map, 100, silent = TRUE)
plans2 &lt;- redist_mergesplit(iowa_map, 200, warmup = 100, silent = TRUE)
compare_plans(plans1, plans2, shp = iowa_map)
compare_plans(plans2, as.integer(draw) &lt;= 20,
    as.integer(draw) &gt; 20, shp = iowa_map, plot = "line")

</code></pre>

<hr>
<h2 id='competitiveness'>Compute Competitiveness</h2><span id='topic+competitiveness'></span><span id='topic+redist.competitiveness'></span>

<h3>Description</h3>

<p>Currently only implements the competitiveness function in equation (5)
of Cho &amp; Liu 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>competitiveness(map, rvote, dvote, .data = cur_plans())

redist.competitiveness(plans, rvote, dvote, alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="competitiveness_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="competitiveness_+3A_rvote">rvote</code></td>
<td>
<p>A numeric vector with the Republican vote for each precinct.</p>
</td></tr>
<tr><td><code id="competitiveness_+3A_dvote">dvote</code></td>
<td>
<p>A numeric vector with the Democratic vote for each precinct.</p>
</td></tr>
<tr><td><code id="competitiveness_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
<tr><td><code id="competitiveness_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
<tr><td><code id="competitiveness_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value for the alpha parameter for the talisman metric</p>
</td></tr>
<tr><td><code id="competitiveness_+3A_beta">beta</code></td>
<td>
<p>A numeric value for the beta parameter for the talisman metric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with competitiveness scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)
data(fl25_enum)

plans_05 &lt;- fl25_enum$plans[, fl25_enum$pop_dev &lt;= 0.05]
# old: comp &lt;- redist.competitiveness(plans_05, fl25$mccain, fl25$obama)
comp &lt;- compet_talisman(plans_05, fl25, mccain, obama)

</code></pre>

<hr>
<h2 id='constraints'>Sampling constraints</h2><span id='topic+constraints'></span><span id='topic+add_constr_status_quo'></span><span id='topic+add_constr_grp_pow'></span><span id='topic+add_constr_grp_hinge'></span><span id='topic+add_constr_grp_inv_hinge'></span><span id='topic+add_constr_compet'></span><span id='topic+add_constr_incumbency'></span><span id='topic+add_constr_splits'></span><span id='topic+add_constr_multisplits'></span><span id='topic+add_constr_total_splits'></span><span id='topic+add_constr_pop_dev'></span><span id='topic+add_constr_segregation'></span><span id='topic+add_constr_polsby'></span><span id='topic+add_constr_fry_hold'></span><span id='topic+add_constr_log_st'></span><span id='topic+add_constr_edges_rem'></span><span id='topic+add_constr_custom'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+redist_smc">redist_smc()</a></code> and <code><a href="#topic+redist_mergesplit">redist_mergesplit()</a></code> algorithms in this package allow
for additional constraints on the redistricting process to be encoded in the
target distribution for sampling. These functions are provided to specify
these constraints. All arguments are quoted and evaluated in the context of
the data frame provided to <code><a href="#topic+redist_constr">redist_constr()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_constr_status_quo(constr, strength, current)

add_constr_grp_pow(
  constr,
  strength,
  group_pop,
  total_pop = NULL,
  tgt_group = 0.5,
  tgt_other = 0.5,
  pow = 1
)

add_constr_grp_hinge(
  constr,
  strength,
  group_pop,
  total_pop = NULL,
  tgts_group = c(0.55)
)

add_constr_grp_inv_hinge(
  constr,
  strength,
  group_pop,
  total_pop = NULL,
  tgts_group = c(0.55)
)

add_constr_compet(constr, strength, dvote, rvote, pow = 0.5)

add_constr_incumbency(constr, strength, incumbents)

add_constr_splits(constr, strength, admin)

add_constr_multisplits(constr, strength, admin)

add_constr_total_splits(constr, strength, admin)

add_constr_pop_dev(constr, strength)

add_constr_segregation(constr, strength, group_pop, total_pop = NULL)

add_constr_polsby(constr, strength, perim_df = NULL)

add_constr_fry_hold(
  constr,
  strength,
  total_pop = NULL,
  ssdmat = NULL,
  denominator = 1
)

add_constr_log_st(constr, strength, admin = NULL)

add_constr_edges_rem(constr, strength)

add_constr_custom(constr, strength, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints_+3A_constr">constr</code></td>
<td>
<p>A <code><a href="#topic+redist_constr">redist_constr()</a></code> object</p>
</td></tr>
<tr><td><code id="constraints_+3A_strength">strength</code></td>
<td>
<p>The strength of the constraint. Higher values mean a more restrictive constraint.</p>
</td></tr>
<tr><td><code id="constraints_+3A_current">current</code></td>
<td>
<p>The reference map for the status quo constraint.</p>
</td></tr>
<tr><td><code id="constraints_+3A_group_pop">group_pop</code></td>
<td>
<p>A vector of group population</p>
</td></tr>
<tr><td><code id="constraints_+3A_total_pop">total_pop</code></td>
<td>
<p>A vector of total population. Defaults to the population vector used for sampling.</p>
</td></tr>
<tr><td><code id="constraints_+3A_tgt_group">tgt_group</code>, <code id="constraints_+3A_tgt_other">tgt_other</code></td>
<td>
<p>Target group shares for the power-type constraint.</p>
</td></tr>
<tr><td><code id="constraints_+3A_pow">pow</code></td>
<td>
<p>The exponent for the power-type constraint.</p>
</td></tr>
<tr><td><code id="constraints_+3A_tgts_group">tgts_group</code></td>
<td>
<p>A vector of target group shares for the hinge-type constraint.</p>
</td></tr>
<tr><td><code id="constraints_+3A_dvote">dvote</code>, <code id="constraints_+3A_rvote">rvote</code></td>
<td>
<p>A vector of Democratic or Republican vote counts</p>
</td></tr>
<tr><td><code id="constraints_+3A_incumbents">incumbents</code></td>
<td>
<p>A vector of unit indices for incumbents. For example, if
three incumbents live in the precincts that correspond to rows 1, 2, and
100 of your <a href="#topic+redist_map">redist_map</a>, entering incumbents = c(1, 2, 100) would avoid
having two or more incumbents be in the same district.</p>
</td></tr>
<tr><td><code id="constraints_+3A_admin">admin</code></td>
<td>
<p>A vector indicating administrative unit membership</p>
</td></tr>
<tr><td><code id="constraints_+3A_perim_df">perim_df</code></td>
<td>
<p>A dataframe output from <code>redistmetrics::prep_perims</code></p>
</td></tr>
<tr><td><code id="constraints_+3A_ssdmat">ssdmat</code></td>
<td>
<p>Squared distance matrix for Fryer Holden constraint</p>
</td></tr>
<tr><td><code id="constraints_+3A_denominator">denominator</code></td>
<td>
<p>Fryer Holden minimum value to normalize by. Default is 1 (no normalization).</p>
</td></tr>
<tr><td><code id="constraints_+3A_fn">fn</code></td>
<td>
<p>A function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All constraints are fed into a Gibbs measure, with coefficients on each
constraint set by the corresponding <code>strength</code> parameter.
The strength can be any real number, with zero corresponding to no constraint.
Higher and higher <code>strength</code> values will eventually cause the algorithm's
accuracy and efficiency to suffer. Whenever you use constraints, be sure to
check all sampling diagnostics.
</p>
<p>The <code>status_quo</code> constraint adds a term measuring the variation of
information distance between the plan and the reference, rescaled to [0, 1].
</p>
<p>The <code>grp_hinge</code> constraint takes a list of target group percentages. It
matches each district to its nearest target percentage, and then applies a
penalty of the form <code class="reqn">\sqrt{max(0, tgt - grouppct)}</code>, summing across
districts. This penalizes districts which are below their target percentage.
Use <code><a href="#topic+plot.redist_constr">plot.redist_constr()</a></code> to visualize the effect of this constraint and
calibrate <code>strength</code> appropriately.
</p>
<p>The <code>grp_inv_hinge</code> constraint takes a list of target group percentages. It
matches each district to its nearest target percentage, and then applies a
penalty of the form <code class="reqn">\sqrt{max(0, grouppct - tgt)}</code>, summing across
districts. This penalizes districts which are above their target percentage.
Use <code><a href="#topic+plot.redist_constr">plot.redist_constr()</a></code> to visualize the effect of this constraint and
calibrate <code>strength</code> appropriately.
</p>
<p>The <code>grp_pow</code> constraint (for expert use) adds a term of the form
<code class="reqn">(|tgtgroup-grouppct||tgtother-grouppct|)^{pow})</code>, which
encourages districts to have group shares near either <code>tgt_group</code>
or <code>tgt_other</code>.  Values of <code>strength</code> depend heavily on the values of these
parameters and especially the <code>pow</code> parameter.
Use <code><a href="#topic+plot.redist_constr">plot.redist_constr()</a></code> to visualize the effect of this constraint and
calibrate <code>strength</code> appropriately.
</p>
<p>The <code>compet</code> constraint encourages competitiveness by applying the <code>grp_pow</code>
constraint with target percentages set to 50%. For convenience, it is
specified with Democratic and Republican vote shares.
</p>
<p>The <code>incumbency</code> constraint adds a term counting the number of districts
containing paired-up incumbents.
Values of <code>strength</code> should generally be small, given that the underlying values are counts.
</p>
<p>The <code>splits</code> constraint adds a term counting the number of
counties which are split once or more.
Values of <code>strength</code> should generally be small, given that the underlying values are counts.
</p>
<p>The <code>multisplits</code> constraint adds a term counting the number of
counties which are split twice or more.
Values of <code>strength</code> should generally be small, given that the underlying values are counts.
</p>
<p>The <code>total_splits</code> constraint adds a term counting the total number of times
each county is split, summed across counties (i.e., counting the number of
excess district-county pairs). Values of <code>strength</code> should generally be
small, given that the underlying values are counts.
</p>
<p>The <code>edges_rem</code> constraint adds a term counting the number of edges removed from the
adjacency graph. This is only usable with <code>redist_flip()</code>, as other algorithms
implicitly use this via the <code>compactness</code> parameter. Values of <code>strength</code> should
generally be small, given that the underlying values are counts.
</p>
<p>The <code>log_st</code> constraint constraint adds a term counting the log number of spanning
trees. This is only usable with <code>redist_flip()</code>, as other algorithms
implicitly use this via the <code>compactness</code> parameter.
</p>
<p>The <code>polsby</code> constraint adds a term encouraging compactness as defined by the
Polsby Popper metric. Values of <code>strength</code> may be of moderate size.
</p>
<p>The <code>fry_hold</code> constraint adds a term encouraging compactness as defined by the
Fryer Holden metric. Values of <code>strength</code> should be extremely small, as the
underlying values are massive when the true minimum Fryer Holden denominator is not known.
</p>
<p>The <code>segregation</code> constraint adds a term encouraging segregation among minority groups,
as measured by the dissimilarity index.
</p>
<p>The <code>pop_dev</code> constraint adds a term encouraging plans to have smaller population deviations
from the target population.
</p>
<p>The <code>custom</code> constraint allows the user to specify their own constraint using
a function which evaluates districts one at a time. The provided function
<code>fn</code> should take two arguments: a vector describing the current plan
assignment for each unit as its first argument, and an integer describing the
district which to evaluate in the second argument. <code style="white-space: pre;">&#8288;which([plans == distr])&#8288;</code>
would give the indices of the units that are assigned to a district <code>distr</code>
in any iteration. The function must return a single scalar for each plan -
district combination, where a value of 0 indicates no penalty is applied. If
users want to penalize an entire plan, they can have the penalty function
return a scalar that does not depend on the district. It is important that
<code>fn</code> not use information from precincts not included in <code>distr</code>, since in the
case of SMC these precincts may not be assigned any district at all (<code>plan</code>
will take the value of 0 for these precincts). The flexibility of this
constraint comes with an additional computational cost, since the other
constraints are written in C++ and so are more performant.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05)
constr &lt;- redist_constr(iowa_map)
constr &lt;- add_constr_splits(constr, strength = 1.5, admin = name)
constr &lt;- add_constr_grp_hinge(constr, strength = 100,
    dem_08, tot_08, tgts_group = c(0.5, 0.6))
# encourage districts to have the same number of counties
constr &lt;- add_constr_custom(constr, strength = 1000, fn = function(plan, distr) {
    # notice that we only use information on precincts in `distr`
    abs(sum(plan == distr) - 99/4)
})
print(constr)

</code></pre>

<hr>
<h2 id='county_splits'>Count County Splits</h2><span id='topic+county_splits'></span><span id='topic+redist.splits'></span>

<h3>Description</h3>

<p>Count County Splits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>county_splits(map, counties, .data = cur_plans())

redist.splits(plans, counties)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="county_splits_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="county_splits_+3A_counties">counties</code></td>
<td>
<p>A vector of county names or county ids.</p>
</td></tr>
<tr><td><code id="county_splits_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
<tr><td><code id="county_splits_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector with one number for each map
</p>

<hr>
<h2 id='distr_compactness'>Calculate compactness measures for a set of plans</h2><span id='topic+distr_compactness'></span><span id='topic+redist.compactness'></span>

<h3>Description</h3>

<p><code>redist.compactness</code> is used to compute different compactness statistics for a
shapefile. It currently computes the Polsby-Popper, Schwartzberg score, Length-Width Ratio,
Convex Hull score, Reock score, Boyce Clark Index, Fryer Holden score, Edges Removed number,
and the log of the Spanning Trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr_compactness(map, measure = "FracKept", .data = cur_plans(), ...)

redist.compactness(
  shp = NULL,
  plans,
  measure = c("PolsbyPopper"),
  total_pop = NULL,
  adj = NULL,
  draw = 1,
  ncores = 1,
  counties = NULL,
  planarize = 3857,
  ppRcpp,
  perim_path,
  perim_df
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr_compactness_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_measure">measure</code></td>
<td>
<p>A vector with a string for each measure desired. &quot;PolsbyPopper&quot;,
&quot;Schwartzberg&quot;, &quot;LengthWidth&quot;, &quot;ConvexHull&quot;, &quot;Reock&quot;, &quot;BoyceClark&quot;, &quot;FryerHolden&quot;,
&quot;EdgesRemoved&quot;, &quot;FracKept&quot;, and &quot;logSpanningTree&quot; are implemented. Defaults to &quot;PolsbyPopper&quot;. Use &quot;all&quot; to
return all implemented measures.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_...">...</code></td>
<td>
<p>passed on to <code>redist.compactness</code></p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_shp">shp</code></td>
<td>
<p>A SpatialPolygonsDataFrame or sf object. Required unless &quot;EdgesRemoved&quot;
and &quot;logSpanningTree&quot; with adjacency provided.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_total_pop">total_pop</code></td>
<td>
<p>A numeric vector with the population for every observation. Is
only necessary when &quot;FryerHolden&quot; is used for measure. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_adj">adj</code></td>
<td>
<p>A zero-indexed adjacency list. Only used for &quot;PolsbyPopper&quot;,
EdgesRemoved&quot; and &quot;logSpanningTree&quot;. Created with <code>redist.adjacency</code> if not
supplied and needed. Default is NULL.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_draw">draw</code></td>
<td>
<p>A numeric to specify draw number. Defaults to 1 if only one map provided
and the column number if multiple maps given. Can also take a factor input, which will become the
draw column in the output if its length matches the number of entries in plans. If the <code>plans</code> input
is a <code>redist_plans</code> object, it extracts the <code>draw</code> identifier.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel computing. Default is 1.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_counties">counties</code></td>
<td>
<p>A numeric vector from 1:ncounties corresponding to counties. Required for &quot;logSpanningTree&quot;.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_planarize">planarize</code></td>
<td>
<p>a number, indicating the CRS to project the shapefile to if
it is latitude-longitude based. Set to FALSE to avoid planarizing.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_pprcpp">ppRcpp</code></td>
<td>
<p>Boolean, whether to run Polsby Popper and Schwartzberg using Rcpp.
It has a higher upfront cost, but quickly becomes faster.
Becomes TRUE if ncol(district_membership &gt; 8) and not manually set.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_perim_path">perim_path</code></td>
<td>
<p>it checks for an Rds, if no rds exists at the path,
it creates an rds with borders and saves it.
This can be created in advance with <code><a href="redistmetrics.html#topic+prep_perims">prep_perims()</a></code>.</p>
</td></tr>
<tr><td><code id="distr_compactness_+3A_perim_df">perim_df</code></td>
<td>
<p>A dataframe output from <code><a href="redistmetrics.html#topic+prep_perims">prep_perims()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes specified compactness scores for a map.  If
there is more than one shape specified for a single district, it combines
them, if necessary, and computes one score for each district.
</p>
<p>Polsby-Popper is computed as </p>
<p style="text-align: center;"><code class="reqn">\frac{4*\pi*A(d)}{P(d)^2}</code>
</p>
<p> where A is the area
function, the district is d, and P is the perimeter function. All  values are between
0 and 1, where larger values are more compact.
</p>
<p>Schwartzberg is computed as </p>
<p style="text-align: center;"><code class="reqn">\frac{P(d)}{2*\pi*\sqrt{\frac{A(d)}{\pi}}}</code>
</p>

<p>where A is the area function, the district is d, and P is the perimeter function.
All  values are between 0 and 1, where larger values are more compact.
</p>
<p>The Length Width ratio is computed as </p>
<p style="text-align: center;"><code class="reqn">\frac{length}{width}</code>
</p>
<p> where length
is the shorter of the maximum x distance and the maximum y distance. Width is
the longer of the two values. All  values are between 0 and 1, where larger
values are more compact.
</p>
<p>The Convex Hull score is computed as </p>
<p style="text-align: center;"><code class="reqn">\frac{A(d)}{A(CVH)}</code>
</p>
<p> where A is the area
function, d is the district, and CVH is the convex hull of the district. All
values are between 0 and 1, where larger values are more compact.
</p>
<p>The Reock score is computed as </p>
<p style="text-align: center;"><code class="reqn">\frac{A(d)}{A(MBC)}</code>
</p>
<p> where A is the area
function, d is the district, and MBC is the minimum bounding circle of the
district. All values are between 0 and 1, where larger values are more compact.
</p>
<p>The Boyce Clark Index is computed as </p>
<p style="text-align: center;"><code class="reqn">1 - \sum_{1}^{16}\{\frac{|\frac{r_i}{\sum_ir_i}*100-6.25 |\}}{200}</code>
</p>
<p>.
The <code class="reqn">r_i</code> are the distances of the 16 radii computed from the geometric
centroid of the shape to the most outward point of the shape that intersects
the radii, if the centroid is contained within the shape.  If the centroid
lies outside of the shape, a point on the surface is used, which will naturally
incur a penalty to the score. All  values are between 0 and 1,
where larger values are more compact.
</p>
<p>The Fryer Holden score for each district is computed with </p>
<p style="text-align: center;"><code class="reqn">Pop\odot D(precinct)^2</code>
</p>
<p>,
where <code class="reqn">Pop</code> is the population product matrix.  Each element is the
product of the i-th and j-th precinct's populations.  D represents the distance,
where the matrix is the distance between each precinct.  To fully compute this
index, for any map, the sum of these values should be used as the numerator.
The denominator can be calculated from the full enumeration of districts as the
smallest calculated numerator. This produces very large numbers, where smaller
values are more compact.
</p>
<p>The log spanning tree measure is the logarithm of the product of the
number of spanning trees which can be drawn on each district.
</p>
<p>The edges removed measure is number of edges removed from the underlying adjacency graph.
A smaller number of edges removed is more compact.
</p>
<p>The fraction kept measure is the fraction of edges that were not removed from the
underlying adjacency graph. This takes values 0 - 1, where 1 is more compact.
</p>


<h3>Value</h3>

<p>A tibble with a column that specifies the district, a column for
each specified measure, and a column that specifies the map number.
</p>


<h3>References</h3>

<p>Boyce, R., &amp; Clark, W. 1964. The Concept of Shape in Geography.
Geographical Review, 54(4), 561-572.
</p>
<p>Cox, E. 1927. A Method of Assigning Numerical and Percentage Values to the
Degree of Roundness of Sand Grains. Journal of Paleontology, 1(3), 179-183.
</p>
<p>Fryer R, Holden R. 2011. Measuring the Compactness of Political Districting Plans.
Journal of Law and Economics.
</p>
<p>Harris, Curtis C. 1964. “A scientific method of districting”.
Behavioral Science 3(9), 219–225.
</p>
<p>Maceachren, A. 1985. Compactness of Geographic Shape: Comparison and
Evaluation of Measures. Geografiska Annaler. Series B, Human Geography, 67(1),
53-67.
</p>
<p>Polsby, Daniel D., and Robert D. Popper. 1991. “The Third Criterion:
Compactness as a procedural safeguard against partisan gerrymandering.”
Yale Law &amp; Policy Review 9 (2): 301–353.
</p>
<p>Reock, E. 1961. A Note: Measuring Compactness as a Requirement of Legislative
Apportionment. Midwest Journal of Political Science, 5(1), 70-74.
</p>
<p>Schwartzberg, Joseph E. 1966. Reapportionment, Gerrymanders, and the Notion
of Compactness. Minnesota Law Review. 1701.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)
data(fl25_enum)

plans_05 &lt;- fl25_enum$plans[, fl25_enum$pop_dev &lt;= 0.05]

# old redist.compactness(
#     shp = fl25, plans = plans_05[, 1:3],
#     measure = c("PolsbyPopper", "EdgesRemoved")
# )
comp_polsby(plans_05[, 1:3], fl25)
comp_edges_rem(plans_05[, 1:3], fl25, fl25$adj)
</code></pre>

<hr>
<h2 id='EPSG'>EPSG Table</h2><span id='topic+EPSG'></span>

<h3>Description</h3>

<p>This data contains NAD83 (HARN) EPSG codes for every U.S. state.
Since <code>redist</code> uses projected geometries, it is often a good idea to use
projections tailored to a particular state, rather than, for example, a
Mercator projection. Use these codes along with <code><a href="sf.html#topic+st_transform">sf::st_transform()</a></code> to
project your shapefiles nicely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("EPSG")
</code></pre>


<h3>Format</h3>

<p>named list containing EPSG codes for each U.S. state. Codes are
indexed by state abbreviations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EPSG)
EPSG$WA # 2855
</code></pre>

<hr>
<h2 id='fl25'>Florida 25 Precinct Shape File</h2><span id='topic+fl25'></span>

<h3>Description</h3>

<p>This data set contains the 25-precinct shapefile and related data for each precinct.
All possible partitions of the 25 precincts into three contiguous
congressional districts are stored in <code><a href="#topic+fl25_enum">fl25_enum</a></code>, and the
corresponding adjacency graph is stored in <code><a href="#topic+fl25_adj">fl25_adj</a></code>.
This is generally useful for demonstrating basic algorithms locally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fl25")
</code></pre>


<h3>Format</h3>

<p>sf data.frame containing columns for useful data related to the
redistricting process, subsetted from real data in Florida, and sf geometry column.
</p>

<dl>
<dt><code>geoid</code></dt><dd><p> Contains unique identifier for each precinct which can be matched to the full Florida dataset.</p>
</dd>
<dt><code>pop</code></dt><dd><p> Contains the population of each precinct.</p>
</dd>
<dt><code>vap</code></dt><dd><p> Contains the voting age population of each precinct.</p>
</dd>
<dt><code>obama</code></dt><dd><p> Contains the 2012 presidential vote for Obama.</p>
</dd>
<dt><code>mccain</code></dt><dd><p> Contains the 2012 presidential vote for McCain.</p>
</dd>
<dt><code>TotPop</code></dt><dd><p> Contains the population of each precinct. Identical to pop.</p>
</dd>
<dt><code>BlackPop</code></dt><dd><p>Contains the black population of each precinct.</p>
</dd>
<dt><code>HispPop</code></dt><dd><p>Contains the Hispanic population of each precinct.</p>
</dd>
<dt><code>VAP</code></dt><dd><p> Contains the voting age population of each precinct. Identical to vap.</p>
</dd>
<dt><code>BlackVAP</code></dt><dd><p> Contains the voting age population of black constituents of each precinct.</p>
</dd>
<dt><code>HispVAP</code></dt><dd><p> Contains the voting age population of hispanic constituents of each precinct.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> Contains sf geometry of each precinct.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander Tarr.
(2016) &quot;A New Automated Redistricting Simulator Using Markov Chain Monte Carlo.&quot;
Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)

</code></pre>

<hr>
<h2 id='fl25_adj'>Florida 25 Precinct File</h2><span id='topic+fl25_adj'></span>

<h3>Description</h3>

<p>This data set contains the 25-precinct shapefile and related data for each precinct.
All possible partitions of the 25 precincts into three contiguous
congressional districts are stored in <code><a href="#topic+fl25_enum">fl25_enum</a></code>, and the
corresponding adjacency graph is stored in <code><a href="#topic+fl25_adj">fl25_adj</a></code>.
</p>


<h3>Format</h3>

<p>A list storing the adjacency graph for the 25-precinct subset of Florida.
</p>


<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander Tarr.
(2016) &quot;A New Automated Redistricting Simulator Using Markov Chain Monte Carlo.&quot;
Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25_adj)

</code></pre>

<hr>
<h2 id='fl25_enum'>All Partitions of 25 Precincts into 3 Congressional Districts
(No Population Constraint)</h2><span id='topic+fl25_enum'></span>

<h3>Description</h3>

<p>This data set contains demographic and geographic information about 25
contiguous precincts in the state of Florida. The data lists all possible
partitions of the 25 precincts into three contiguous congressional districts.
The 25-precinct shapefile may be found in <code><a href="#topic+fl25">fl25</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fl25_enum")
</code></pre>


<h3>Format</h3>

<p>A list with two entries:
</p>

<dl>
<dt><code>plans</code></dt><dd><p>A matrix containing every partition of the 25 precincts
into three contiguous congressional districts, with no population constraint.</p>
</dd>
<dt><code>pop_dev</code></dt><dd><p>A vector containing the maximum population deviation
across the three districts for each plan.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander Tarr.
(2016) &quot;A New Automated Redistricting Simulator Using Markov Chain Monte Carlo.&quot;
Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>
<p>Massey, Douglas and Nancy Denton. (1987) &quot;The Dimensions of Social Segregation&quot;.
Social Forces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25_enum)

</code></pre>

<hr>
<h2 id='fl250'>Florida 250 Precinct Shape File</h2><span id='topic+fl250'></span>

<h3>Description</h3>

<p>This data set contains the 250 Precinct shapefile and related data for each precinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fl250")
</code></pre>


<h3>Format</h3>

<p>sf data.frame containing columns for useful data related to the
redistricting process, subsetted from real data in Florida, and sf geometry column.
</p>

<dl>
<dt><code>geoid</code></dt><dd><p> Contains unique identifier for each precinct which can be matched to the full Florida dataset.</p>
</dd>
<dt><code>pop</code></dt><dd><p> Contains the population of each precinct.</p>
</dd>
<dt><code>vap</code></dt><dd><p> Contains the voting age population of each precinct.</p>
</dd>
<dt><code>obama</code></dt><dd><p> Contains the 2012 presidential vote for Obama.</p>
</dd>
<dt><code>mccain</code></dt><dd><p> Contains the 2012 presidential vote for McCain.</p>
</dd>
<dt><code>TotPop</code></dt><dd><p> Contains the population of each precinct. Identical to pop.</p>
</dd>
<dt><code>BlackPop</code></dt><dd><p>Contains the black population of each precinct.</p>
</dd>
<dt><code>HispPop</code></dt><dd><p>Contains the Hispanic population of each precinct.</p>
</dd>
<dt><code>VAP</code></dt><dd><p> Contains the voting age population of each precinct. Identical to vap.</p>
</dd>
<dt><code>BlackVAP</code></dt><dd><p> Contains the voting age population of black constituents of each precinct.</p>
</dd>
<dt><code>HispVAP</code></dt><dd><p> Contains the voting age population of hispanic constituents of each precinct.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> Contains sf geometry of each precinct.</p>
</dd>
</dl>



<h3>Details</h3>

<p>It is a random 70 precinct connected subset from Florida's precincts. This was introduced by
<a href="https://doi.org/10.1080/2330443X.2020.1791773">doi:10.1080/2330443X.2020.1791773</a>
</p>


<h3>References</h3>

<p>Benjamin Fifield, Kosuke Imai, Jun Kawahara &amp; Christopher T. Kenny (2020)
The Essential Role of Empirical Validation in Legislative Redistricting Simulation,
Statistics and Public Policy, 7:1, 52-68, doi:10.1080/2330443X.2020.1791773
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl250)

</code></pre>

<hr>
<h2 id='fl70'>Florida 70 Precinct Shape File</h2><span id='topic+fl70'></span>

<h3>Description</h3>

<p>This data set contains the 70 Precinct shapefile and related data for each precinct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fl70")
</code></pre>


<h3>Format</h3>

<p>sf data.frame containing columns for useful data related to the
redistricting process, subsetted from real data in Florida, and sf geometry column.
</p>

<dl>
<dt><code>geoid</code></dt><dd><p> Contains unique identifier for each precinct which can be matched to the full Florida dataset.</p>
</dd>
<dt><code>pop</code></dt><dd><p> Contains the population of each precinct.</p>
</dd>
<dt><code>vap</code></dt><dd><p> Contains the voting age population of each precinct.</p>
</dd>
<dt><code>obama</code></dt><dd><p> Contains the 2012 presidential vote for Obama.</p>
</dd>
<dt><code>mccain</code></dt><dd><p> Contains the 2012 presidential vote for McCain.</p>
</dd>
<dt><code>TotPop</code></dt><dd><p> Contains the population of each precinct. Identical to pop.</p>
</dd>
<dt><code>BlackPop</code></dt><dd><p>Contains the black population of each precinct.</p>
</dd>
<dt><code>HispPop</code></dt><dd><p>Contains the Hispanic population of each precinct.</p>
</dd>
<dt><code>VAP</code></dt><dd><p> Contains the voting age population of each precinct. Identical to vap.</p>
</dd>
<dt><code>BlackVAP</code></dt><dd><p> Contains the voting age population of black constituents of each precinct.</p>
</dd>
<dt><code>HispVAP</code></dt><dd><p> Contains the voting age population of hispanic constituents of each precinct.</p>
</dd>
<dt><code>geometry</code></dt><dd><p> Contains sf geometry of each precinct.</p>
</dd>
</dl>



<h3>Details</h3>

<p>It is a random 70 precinct connected subset from Florida's precincts. This was introduced by
<a href="https://doi.org/10.1080/2330443X.2020.1791773">doi:10.1080/2330443X.2020.1791773</a>
</p>


<h3>References</h3>

<p>Benjamin Fifield, Kosuke Imai, Jun Kawahara &amp; Christopher T. Kenny (2020)
The Essential Role of Empirical Validation in Legislative Redistricting Simulation,
Statistics and Public Policy, 7:1, 52-68, doi:10.1080/2330443X.2020.1791773
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl70)

</code></pre>

<hr>
<h2 id='freeze'>Freeze Parts of a Map</h2><span id='topic+freeze'></span><span id='topic+redist.freeze'></span>

<h3>Description</h3>

<p>Freeze Parts of a Map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freeze(freeze_row, plan, .data = cur_map())

redist.freeze(adj, freeze_row, plan = rep(1, length(adj)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freeze_+3A_freeze_row">freeze_row</code></td>
<td>
<p>Required, logical vector where TRUE freezes and FALSE lets
a precinct stay free or a vector of indices to freeze</p>
</td></tr>
<tr><td><code id="freeze_+3A_plan">plan</code></td>
<td>
<p>A vector of district assignments, which if provided will create
separate groups by district. Recommended. In <code>freeze</code> defaults to the
existing plan, if one exists.</p>
</td></tr>
<tr><td><code id="freeze_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="freeze_+3A_adj">adj</code></td>
<td>
<p>Required, zero indexed adjacency list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector to group by
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(redist)
library(dplyr)
data(fl25)
data(fl25_enum)
data(fl25_adj)
plan &lt;- fl25_enum$plans[, 5118]
freeze_id &lt;- redist.freeze(adj = fl25_adj, freeze_row = (plan == 2),
    plan = plan)

data(iowa)
map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.02)
map &lt;- map %&gt;% merge_by(freeze(cd_2010 == 1, .data = .))

</code></pre>

<hr>
<h2 id='get_adj'>Get and set the adjacency graph from a <code>redist_map</code> object</h2><span id='topic+get_adj'></span><span id='topic+set_adj'></span>

<h3>Description</h3>

<p>Get and set the adjacency graph from a <code>redist_map</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adj(x)

set_adj(x, adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adj_+3A_x">x</code></td>
<td>
<p>the <code>redist_map</code> object</p>
</td></tr>
<tr><td><code id="get_adj_+3A_adj">adj</code></td>
<td>
<p>a new adjacency list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a zero-indexed adjacency list (<code>get_adj</code>)
</p>
<p>the modified <code>redist_map</code> object (<code>set_adj</code>)
</p>

<hr>
<h2 id='get_existing'>Extract the existing district assignment from a <code>redist_map</code> object</h2><span id='topic+get_existing'></span>

<h3>Description</h3>

<p>Extract the existing district assignment from a <code>redist_map</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_existing(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_existing_+3A_x">x</code></td>
<td>
<p>the <code>redist_map</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of district numbers
</p>

<hr>
<h2 id='get_mh_acceptance_rate'>Extract the Metropolis Hastings Acceptance Rate</h2><span id='topic+get_mh_acceptance_rate'></span>

<h3>Description</h3>

<p>Extract the Metropolis Hastings Acceptance Rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mh_acceptance_rate(plans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mh_acceptance_rate_+3A_plans">plans</code></td>
<td>
<p>the <code>redist_plans</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric acceptance rate
</p>

<hr>
<h2 id='get_plans_matrix'>Extract the matrix of district assignments from a redistricting simulation</h2><span id='topic+get_plans_matrix'></span><span id='topic+as.matrix.redist_plans'></span>

<h3>Description</h3>

<p>Extract the matrix of district assignments from a redistricting simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_plans_matrix(x)

## S3 method for class 'redist_plans'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_plans_matrix_+3A_x">x</code></td>
<td>
<p>the <code>redist_plans</code> object</p>
</td></tr>
<tr><td><code id="get_plans_matrix_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>
<p>matrix
</p>

<hr>
<h2 id='get_plans_weights'>Extract the sampling weights from a redistricting simulation.</h2><span id='topic+get_plans_weights'></span><span id='topic+weights.redist_plans'></span>

<h3>Description</h3>

<p>May be <code>NULL</code> if no weights exist (MCMC or optimization methods).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_plans_weights(plans)

## S3 method for class 'redist_plans'
weights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_plans_weights_+3A_plans">plans</code>, <code id="get_plans_weights_+3A_object">object</code></td>
<td>
<p>the <code>redist_plans</code> object</p>
</td></tr>
<tr><td><code id="get_plans_weights_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of weights, with an additional attribute
<code>resampled</code> indicating whether the plans have been resampled according
to these weights. If weights have been resampled, this returns the weights
before resampling (i.e., they do not correspond to the resampled plans).
</p>
<p>numeric vector
</p>

<hr>
<h2 id='get_pop_tol'>Get and set the population tolerance from a <code>redist_map</code> object</h2><span id='topic+get_pop_tol'></span><span id='topic+set_pop_tol'></span>

<h3>Description</h3>

<p>Get and set the population tolerance from a <code>redist_map</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pop_tol(map)

set_pop_tol(map, pop_tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pop_tol_+3A_map">map</code></td>
<td>
<p>the <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="get_pop_tol_+3A_pop_tol">pop_tol</code></td>
<td>
<p>the population tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>get_pop_tol</code>, a single numeric value, the population
tolerance
</p>
<p>For <code>seet_pop_tol</code>, an updated <code><a href="#topic+redist_map">redist_map</a></code> object
</p>

<hr>
<h2 id='get_sampling_info'>Extract the sampling information from a redistricting simulation</h2><span id='topic+get_sampling_info'></span>

<h3>Description</h3>

<p>Extract the sampling information from a redistricting simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sampling_info(plans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sampling_info_+3A_plans">plans</code></td>
<td>
<p>the <code>redist_plans</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of parameters and information about the sampling problem.
</p>

<hr>
<h2 id='get_target'>Extract the target district population from a <code>redist_map</code> object</h2><span id='topic+get_target'></span>

<h3>Description</h3>

<p>Extract the target district population from a <code>redist_map</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_target(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_target_+3A_x">x</code></td>
<td>
<p>the <code>redist_map</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value, the target population
</p>

<hr>
<h2 id='group_frac'>Calculate Group Proportion by District</h2><span id='topic+group_frac'></span><span id='topic+redist.group.percent'></span>

<h3>Description</h3>

<p><code>redist.group.percent</code> computes the proportion that a group makes up in
each district across a matrix of maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_frac(
  map,
  group_pop,
  total_pop = map[[attr(map, "pop_col")]],
  .data = pl()
)

redist.group.percent(plans, group_pop, total_pop, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_frac_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="group_frac_+3A_group_pop">group_pop</code></td>
<td>
<p>A numeric vector with the population of the group for every precinct.</p>
</td></tr>
<tr><td><code id="group_frac_+3A_total_pop">total_pop</code></td>
<td>
<p>A numeric vector with the population for every precinct.</p>
</td></tr>
<tr><td><code id="group_frac_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object or matrix of plans</p>
</td></tr>
<tr><td><code id="group_frac_+3A_plans">plans</code></td>
<td>
<p>A matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
<tr><td><code id="group_frac_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel computing. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with percent for each district
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)
data(fl25_enum)

cd &lt;- fl25_enum$plans[, fl25_enum$pop_dev &lt;= 0.05]
fl25_map = redist_map(fl25, ndists=3, pop_tol=0.1)
fl25_plans = redist_plans(cd, fl25_map, algorithm="enumpart")

group_frac(fl25_map, BlackPop, TotPop, fl25_plans)
</code></pre>

<hr>
<h2 id='iowa'>Iowa County File</h2><span id='topic+iowa'></span>

<h3>Description</h3>

<p>This data contains geographic and demographic information on the 99 counties
of the state of Iowa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("iowa")
</code></pre>


<h3>Format</h3>

<p>sf tibble containing columns for useful data related to the
redistricting process
</p>

<dl>
<dt><code>fips</code></dt><dd><p>The FIPS code for the county.</p>
</dd>
<dt><code>cd_2010</code></dt><dd><p>The 2010 congressional district assignments.</p>
</dd>
<dt><code>pop</code></dt><dd><p>The total population of the precinct, according to the 2010 Census.</p>
</dd>
<dt><code>white</code></dt><dd><p>The non-Hispanic white population of the precinct.</p>
</dd>
<dt><code>black</code></dt><dd><p>The non-Hispanic Black population of the precinct.</p>
</dd>
<dt><code>hisp</code></dt><dd><p>The Hispanic population (of any race) of the precinct.</p>
</dd>
<dt><code>vap</code></dt><dd><p>The voting-age population of the precinct.</p>
</dd>
<dt><code>wvap</code></dt><dd><p>The white voting-age population of the precinct.</p>
</dd>
<dt><code>bvap</code></dt><dd><p>The Black voting-age population of the precinct.</p>
</dd>
<dt><code>hvap</code></dt><dd><p>The Hispanic voting-age population of the precinct.</p>
</dd>
<dt><code>tot_08</code></dt><dd><p>Number of total votes for president in the county in 2008.</p>
</dd>
<dt><code>dem_08</code></dt><dd><p>Number of votes for Barack Obama in 2008.</p>
</dd>
<dt><code>rep_08</code></dt><dd><p>Number of votes for John McCain in 2008.</p>
</dd>
<dt><code>region</code></dt><dd><p>The 28E agency regions for counties.</p>
</dd>
<dt><code>geometry</code></dt><dd><p>The sf geometry column containing the geographic information.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
print(iowa)
</code></pre>

<hr>
<h2 id='is_contiguous'>Check that a <code>redist_map</code> object is contiguous</h2><span id='topic+is_contiguous'></span>

<h3>Description</h3>

<p>Check that a <code>redist_map</code> object is contiguous
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_contiguous(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_contiguous_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if contiguous.
</p>

<hr>
<h2 id='is_county_split'>Identify which counties are split by a plan</h2><span id='topic+is_county_split'></span>

<h3>Description</h3>

<p>Identify which counties are split by a plan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_county_split(plan, counties)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_county_split_+3A_plan">plan</code></td>
<td>
<p>A vector of precinct/unit assignments</p>
</td></tr>
<tr><td><code id="is_county_split_+3A_counties">counties</code></td>
<td>
<p>A vector of county names or county ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector which is <code>TRUE</code> for precincts belonging to
counties which are split
</p>

<hr>
<h2 id='last_plan'>Extract the last plan from a set of plans</h2><span id='topic+last_plan'></span>

<h3>Description</h3>

<p>Extract the last plan from a set of plans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_plan(plans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_plan_+3A_plans">plans</code></td>
<td>
<p>A <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector containing the final plan assignment.
</p>

<hr>
<h2 id='make_cores'>Identify Cores of a District (Heuristic)</h2><span id='topic+make_cores'></span><span id='topic+redist.identify.cores'></span>

<h3>Description</h3>

<p>Creates a grouping ID to unite geographies and perform analysis on a smaller
set of precincts. It identifies all precincts more than <code>boundary</code> edges
of a district district boundary. Each contiguous group of precincts more than
<code>boundary</code> steps away from another district gets it own group. Some
districts may have multiple, disconnected components that make up the core,
but each of these is assigned a separate grouping id so that a call to
<code>sf::st_union()</code> would produce only connected pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_cores(.data = cur_map(), boundary = 1, focus = NULL)

redist.identify.cores(adj, plan, boundary = 1, focus = NULL, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_cores_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="make_cores_+3A_boundary">boundary</code></td>
<td>
<p>Number of steps to check for. Defaults to 1.</p>
</td></tr>
<tr><td><code id="make_cores_+3A_focus">focus</code></td>
<td>
<p>Optional. Integer. A single district to focus on.</p>
</td></tr>
<tr><td><code id="make_cores_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list.</p>
</td></tr>
<tr><td><code id="make_cores_+3A_plan">plan</code></td>
<td>
<p>An integer vector or matrix column of district assignments.</p>
</td></tr>
<tr><td><code id="make_cores_+3A_simplify">simplify</code></td>
<td>
<p>Optional. Logical. Whether to return extra information or just grouping ID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a loose interpretation of the
<a href="https://www.ncsl.org/redistricting-and-census/redistricting-criteria">NCSL's summary</a>
of redistricting criteria to preserve the cores of prior districts. Using the
adjacency graph for a given plan, it will locate the precincts on the
boundary of the district, within <code>boundary</code> steps of the edge. Each of
these  is given their own group. Each remaining entry that is not near the
boundary of the district is given an id that can be used to group the
remainder of the district by connected component. This portion is deemed the
core of the district.
</p>


<h3>Value</h3>

<p>integer vector (if simplify is false). Otherwise it returns a tibble with the grouping
variable as <code>group_id</code> and additional information on connected components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+redist.plot.cores">redist.plot.cores()</a></code> for a plotting function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl250)
fl250_map &lt;- redist_map(fl250, ndists = 4, pop_tol = 0.01)
plan &lt;- as.matrix(redist_smc(fl250_map, 20, silent = TRUE))
core &lt;- redist.identify.cores(adj = fl250_map$adj, plan = plan)
redist.plot.cores(shp = fl250, plan = plan, core = core)

</code></pre>

<hr>
<h2 id='match_numbers'>Renumber districts to match an existing plan</h2><span id='topic+match_numbers'></span>

<h3>Description</h3>

<p>District numbers in simulated plans are by and large random.  This
function attempts to renumber the districts across all simulated plans to
match the numbers in a provided plan, using the Hungarian algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_numbers(
  data,
  plan,
  total_pop = attr(data, "prec_pop"),
  col = "pop_overlap"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_numbers_+3A_data">data</code></td>
<td>
<p>a <code>redist_plans</code> object.</p>
</td></tr>
<tr><td><code id="match_numbers_+3A_plan">plan</code></td>
<td>
<p>a character vector giving the name of the plan to match to (e.g.,
for a reference plan), or an integer vector containing the plan itself.</p>
</td></tr>
<tr><td><code id="match_numbers_+3A_total_pop">total_pop</code></td>
<td>
<p>a vector of population counts. Should not be needed for most
<code>redist_plans</code> objects.</p>
</td></tr>
<tr><td><code id="match_numbers_+3A_col">col</code></td>
<td>
<p>the name of a new column to store the vector of population overlap
with the reference plan: the fraction of the total population who are in
the same district under each plan and the reference plan. Set to
<code>NULL</code> if no column should be created.
renumbering options in any plan.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified <code>redist_plans</code> object. New district numbers will be
stored as an ordered factor variable in the <code>district</code> column. The
district numbers in the plan matrix will match the levels of this factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)

iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05)
plans &lt;- redist_smc(iowa_map, 100, silent = TRUE)
match_numbers(plans, "cd_2010")

</code></pre>

<hr>
<h2 id='merge_by'>Merge map units</h2><span id='topic+merge_by'></span>

<h3>Description</h3>

<p>In performing a county-level or cores-based analysis it is often necessary to
merge several units together into a larger unit.  This function performs this
operation, modifying the adjacency graph as needed and attempting to properly
aggregate other data columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_by(.data, ..., by_existing = TRUE, drop_geom = TRUE, collapse_chr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_by_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="merge_by_+3A_...">...</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_tidy_select">&lt;tidy-select&gt;</a></code> the column(s) to merge by</p>
</td></tr>
<tr><td><code id="merge_by_+3A_by_existing">by_existing</code></td>
<td>
<p>if an existing assignment is present, whether to also group by it</p>
</td></tr>
<tr><td><code id="merge_by_+3A_drop_geom">drop_geom</code></td>
<td>
<p>whether to drop the geometry column. Recommended, as
otherwise a costly geometric merge is required.</p>
</td></tr>
<tr><td><code id="merge_by_+3A_collapse_chr">collapse_chr</code></td>
<td>
<p>if <code>TRUE</code>, preserve character columns by collapsing
their values. For example, a county name column in Iowa might be merged and
have entries such as &quot;Cedar~Clinton~Des Moines&quot;. Set to <code>FALSE</code> to
drop character columns instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged <code><a href="#topic+redist_map">redist_map</a></code> object
</p>

<hr>
<h2 id='min_move_parity'>Calculates Sparse Population Moves to Minimize Population Deviation</h2><span id='topic+min_move_parity'></span>

<h3>Description</h3>

<p>This function computes a minimal set of population moves (e.g., 5 people from
district 1 to district 3) to maximally balance the population between
districts. The moves are only allowed between districts that share the
territory of a county, so that any boundary adjustments are guaranteed to
preserve all unbroken county boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_move_parity(map, plan, counties = NULL, penalty = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_move_parity_+3A_map">map</code></td>
<td>
<p>a <a href="#topic+redist_map">redist_map</a></p>
</td></tr>
<tr><td><code id="min_move_parity_+3A_plan">plan</code></td>
<td>
<p>an integer vector containing the plan to be balanced.
Tidy-evaluated.</p>
</td></tr>
<tr><td><code id="min_move_parity_+3A_counties">counties</code></td>
<td>
<p>an optional vector of counties, whose boundaries will be
preserved. Tidy-evaluated.</p>
</td></tr>
<tr><td><code id="min_move_parity_+3A_penalty">penalty</code></td>
<td>
<p>the larger this value, the more to encourage sparsity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<dl>
<dt><code>moves</code></dt><dd><p>A tibble describing the population moves</p>
</dd>
<dt><code>pop_old</code></dt><dd><p>The current district populations</p>
</dd>
<dt><code>pop_new</code></dt><dd><p>The district populations after the moves</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.01)
min_move_parity(iowa_map, cd_2010)

</code></pre>

<hr>
<h2 id='muni_splits'>Counts the Number of Municipalities Split Between Districts</h2><span id='topic+muni_splits'></span><span id='topic+redist.muni.splits'></span>

<h3>Description</h3>

<p>Counts the total number of municpalities that are split.
Municipalities in this interpretation do not need to cover the entire state, which
differs from counties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muni_splits(map, munis, .data = cur_plans())

redist.muni.splits(plans, munis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muni_splits_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="muni_splits_+3A_munis">munis</code></td>
<td>
<p>A vector of municipality names or ids.</p>
</td></tr>
<tr><td><code id="muni_splits_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
<tr><td><code id="muni_splits_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length ndist by ncol(plans)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
ia &lt;- redist_map(iowa, existing_plan = cd_2010, total_pop = pop, pop_tol = 0.01)
plans &lt;- redist_smc(ia, 50, silent = TRUE)
ia$region[1:10] &lt;- NA
#old redist.muni.splits(plans, ia$region)
splits_sub_admin(plans, ia, region)
</code></pre>

<hr>
<h2 id='number_by'>Renumber districts to match a quantity of interest</h2><span id='topic+number_by'></span>

<h3>Description</h3>

<p>District numbers in simulated plans are by and large random.  This
function will renumber the districts across all simulated plans in order
of a provided quantity of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_by(data, x, desc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_by_+3A_data">data</code></td>
<td>
<p>a <code>redist_plans</code> object</p>
</td></tr>
<tr><td><code id="number_by_+3A_x">x</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the quantity of interest.</p>
</td></tr>
<tr><td><code id="number_by_+3A_desc">desc</code></td>
<td>
<p><code>TRUE</code> if district should be sorted in descending order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified <code>redist_plans</code> object. New district numbers will be
stored as an ordered factor variable in the <code>district</code> column. The
district numbers in the plan matrix will match the levels of this factor.
</p>

<hr>
<h2 id='partisan_metrics'>Calculate gerrymandering metrics for a set of plans</h2><span id='topic+partisan_metrics'></span><span id='topic+redist.metrics'></span>

<h3>Description</h3>

<p><code>redist.metrics</code> is used to compute different gerrymandering metrics for a
set of maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partisan_metrics(map, measure, rvote, dvote, ..., .data = cur_plans())

redist.metrics(
  plans,
  measure = "DSeats",
  rvote,
  dvote,
  tau = 1,
  biasV = 0.5,
  respV = 0.5,
  bandwidth = 0.01,
  draw = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partisan_metrics_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_measure">measure</code></td>
<td>
<p>A vector with a string for each measure desired from list &quot;DSeats&quot;, &quot;DVS&quot;, &quot;EffGap&quot;,
&quot;EffGapEqPop&quot;, &quot;TauGap&quot;, &quot;MeanMedian&quot;, &quot;Bias&quot;, &quot;BiasV&quot;, &quot;Declination&quot;,
&quot;Responsiveness&quot;, &quot;LopsidedWins&quot;, &quot;RankedMarginal&quot;, and &quot;SmoothedSeat&quot;. Use &quot;all&quot; to get all metrics.
&quot;DSeats&quot; and &quot;DVS&quot; are always computed, so it is recommended to always return those values.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_rvote">rvote</code></td>
<td>
<p>A numeric vector with the Republican vote for each precinct.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_dvote">dvote</code></td>
<td>
<p>A numeric vector with the Democratic vote for each precinct.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_...">...</code></td>
<td>
<p>passed on to <code>redist.metrics</code></p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_tau">tau</code></td>
<td>
<p>A non-negative number for calculating Tau Gap. Only used with option &quot;TauGap&quot;. Defaults to 1.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_biasv">biasV</code></td>
<td>
<p>A value between 0 and 1 to compute bias at. Only used with option &quot;BiasV&quot;. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_respv">respV</code></td>
<td>
<p>A value between 0 and 1 to compute responsiveness at. Only used with option &quot;Responsiveness&quot;. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A value between 0 and 1 for computing responsiveness. Only used with option &quot;Responsiveness.&quot; Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="partisan_metrics_+3A_draw">draw</code></td>
<td>
<p>A numeric to specify draw number. Defaults to 1 if only one map provided
and the column number if multiple maps given. Can also take a factor input, which will become the
draw column in the output if its length matches the number of entries in plans. If the <code>plans</code> input
is a <code>redist_plans</code> object, it extracts the <code>draw</code> identifier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes specified compactness scores for a map.  If
there is more than one precinct specified for a map, it aggregates to the district level
and computes one score.
</p>

<ul>
<li><p> DSeats is computed as the expected number of Democratic seats with no change in votes.
</p>
</li>
<li><p> DVS is the Democratic Vote Share, which is the two party vote share with Democratic votes as the numerator.
</p>
</li>
<li><p> EffGap is the Efficiency Gap, calculated with votes directly.
</p>
</li>
<li><p> EffGapEqPop is the Efficiency Gap under an Equal Population assumption, calculated with the DVS.
</p>
</li>
<li><p> TauGap is the Tau Gap, computed with the Equal Population assumption.
</p>
</li>
<li><p> MeanMedian is the Mean Median difference.
</p>
</li>
<li><p> Bias is the Partisan Bias computed at 0.5.
</p>
</li>
<li><p> BiasV is the Partisan Bias computed at value V.
</p>
</li>
<li><p> Declination is the value of declination at 0.5.
</p>
</li>
<li><p> Responsiveness is the responsiveness at the user-supplied value with the user-supplied bandwidth.
</p>
</li>
<li><p> LopsidedWins computed the Lopsided Outcomes value, but does not produce a test statistic.
</p>
</li>
<li><p> RankedMarginal computes the Ranked Marginal Deviation (0-1, smaller is better). This is also known
as the &quot;Gerrymandering Index&quot; and is sometimes presented as this value divided by 10000.
</p>
</li>
<li><p> SmoothedSeat computes the Smoothed Seat Count Deviation (0-1, smaller is R Bias, bigger is D Bias).
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with  a column for each specified measure and
a column that specifies the map number.
</p>


<h3>References</h3>

<p>Jonathan N. Katz, Gary King, and Elizabeth Rosenblatt. 2020.
Theoretical Foundations and Empirical Evaluations of Partisan Fairness in District-Based Democracies.
American Political Science Review, 114, 1, Pp. 164-178.
</p>
<p>Gregory S. Warrington. 2018. &quot;Quantifying Gerrymandering Using the Vote Distribution.&quot;
Election Law Journal: Rules, Politics, and Policy. Pp. 39-57.http://doi.org/10.1089/elj.2017.0447
</p>
<p>Samuel S.-H. Wang. 2016. &quot;Three Tests for Practical Evaluation of Partisan Gerrymandering.&quot;
Stanford Law Review, 68, Pp. 1263 - 1321.
</p>
<p>Gregory Herschlag, Han Sung Kang, Justin Luo, Christy Vaughn Graves, Sachet Bangia,
Robert Ravier &amp; Jonathan C. Mattingly (2020) Quantifying Gerrymandering in North Carolina,
Statistics and Public Policy, 7:1, 30-38, DOI: 10.1080/2330443X.2020.1796400
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)
data(fl25_enum)
plans_05 &lt;- fl25_enum$plans[, fl25_enum$pop_dev &lt;= 0.05]
# old: redist.metrics(plans_05, measure = "DSeats", rvote = fl25$mccain, dvote = fl25$obama)
part_dseats(plans_05, fl25, mccain, obama)

</code></pre>

<hr>
<h2 id='pl'>Access the Current <code>redist_plans()</code> Object</h2><span id='topic+pl'></span>

<h3>Description</h3>

<p>Useful inside piped expressions and <code>dplyr</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pl()
</code></pre>


<h3>Value</h3>

<p>A <code>redist_plans</code> object, or <code>NULL</code> if not called from inside a
<code>dplyr</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pl()

</code></pre>

<hr>
<h2 id='plan_distances'>Compute Distance between Partitions</h2><span id='topic+plan_distances'></span><span id='topic+redist.distances'></span>

<h3>Description</h3>

<p>Compute Distance between Partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plan_distances(plans, measure = "variation of information", ncores = 1)

redist.distances(plans, measure = "Hamming", ncores = 1, total_pop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plan_distances_+3A_plans">plans</code></td>
<td>
<p>A matrix with one row for each precinct and one
column for each map. Required.</p>
</td></tr>
<tr><td><code id="plan_distances_+3A_measure">measure</code></td>
<td>
<p>String vector indicating which distances to compute. Implemented
currently are &quot;Hamming&quot;, &quot;Manhattan&quot;, &quot;Euclidean&quot;, and &quot;variation of information&quot;,
Use &quot;all&quot; to return all implemented measures.  Not case sensitive, and
any unique substring is enough, e.g. &quot;ham&quot; for Hamming, or &quot;info&quot; for
variation of information.</p>
</td></tr>
<tr><td><code id="plan_distances_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel computing. Default is 1.</p>
</td></tr>
<tr><td><code id="plan_distances_+3A_total_pop">total_pop</code></td>
<td>
<p>The vector of precinct populations. Used only if computing
variation of information. If not provided, equal population of precincts
will be assumed, i.e. the VI will be computed with respect to the precincts
themselves, and not the population.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hamming distance measures the number of different precinct assignments
between plans. Manhattan and Euclidean distances are the 1- and 2-norms for
the assignment vectors.  All three of the Hamming, Manhattan, and Euclidean
distances implemented here are not invariant to permutations of the district
labels; permuting will cause large changes in measured distance, and maps
which are identical up to a permutation may be computed to be maximally
distant.
</p>
<p>Variation of Information is a metric on population partitions (i.e.,
districtings) which is invariant to permutations of the district labels, and
arises out of information theory. It is calculated as </p>
<p style="text-align: center;"><code class="reqn">
VI(\xi, \xi') = -\sum_{i=1}^n\sum_{j=1}^n pop(\xi_i \cap \xi'_j)/P
(2log(pop(\xi_i \cap \xi'_j)) - log(pop(\xi_i)) - log(pop(\xi'_j)))
</code>
</p>
<p> where <code class="reqn">\xi,\xi'</code> are the partitions, <code class="reqn">\xi_i,\xi_j</code> the individual
districts, <code class="reqn">pop(\cdot)</code> is the population, and <code class="reqn">P</code> the total
population of the state. VI is also expressible as the difference between
the joint entropy and the mutual information (see references).
</p>


<h3>Value</h3>

<p><code>distance_matrix</code> returns a numeric distance matrix for the
chosen metric.
</p>
<p>a named list of distance matrices, one for each distance measure selected.
</p>


<h3>References</h3>

<p>Cover, T. M. and Thomas, J. A. (2006). <em>Elements of information theory.</em> John Wiley &amp; Sons, 2 edition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)
data(fl25_enum)

plans_05 &lt;- fl25_enum$plans[, fl25_enum$pop_dev &lt;= 0.05]
distances &lt;- redist.distances(plans_05)
distances$Hamming[1:5, 1:5]

</code></pre>

<hr>
<h2 id='plans_diversity'>Calculate the diversity of a set of plans</h2><span id='topic+plans_diversity'></span>

<h3>Description</h3>

<p>Returns the off-diagonal elements of the variation of information distance
matrix for a sample of plans, which can be used as a diagnostic measure to
assess the diversity of a set of plans. While the exact scale varies depending
on the number of precincts and districts, generally diversity is good if most
of the values are greater than 0.5. Conversely, if there are many values
close to zero, then the sample has many similar plans and may not be a good
approximation to the target distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plans_diversity(
  plans,
  chains = 1,
  n_max = 100,
  ncores = 1,
  total_pop = attr(plans, "prec_pop")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plans_diversity_+3A_plans">plans</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object.</p>
</td></tr>
<tr><td><code id="plans_diversity_+3A_chains">chains</code></td>
<td>
<p>For plans objects with multiple chains, which ones to compute
diversity for. Defaults to the first. Specify &quot;all&quot; to use all chains.</p>
</td></tr>
<tr><td><code id="plans_diversity_+3A_n_max">n_max</code></td>
<td>
<p>the maximum number of plans to sample in computing the
distances. Larger numbers will have less sampling error but will require
more computation time.</p>
</td></tr>
<tr><td><code id="plans_diversity_+3A_ncores">ncores</code></td>
<td>
<p>the number of cores to use in computing the distances.</p>
</td></tr>
<tr><td><code id="plans_diversity_+3A_total_pop">total_pop</code></td>
<td>
<p>The vector of precinct populations. Used only if computing
variation of information. If not provided, equal population of precincts
will be assumed, i.e. the VI will be computed with respect to the precincts
themselves, and not the population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of off-diagonal variation of information distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
ia &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.01)
plans &lt;- redist_smc(ia, 100, silent = TRUE)
hist(plans_diversity(plans))

</code></pre>

<hr>
<h2 id='plot.redist_classified'>Plot a plan classification</h2><span id='topic+plot.redist_classified'></span>

<h3>Description</h3>

<p>Plot a plan classification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_classified'
plot(x, plans, shp, type = "fill", which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.redist_classified_+3A_x">x</code></td>
<td>
<p>a <code>redist_classified</code> object, the output of <code><a href="#topic+classify_plans">classify_plans()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.redist_classified_+3A_plans">plans</code></td>
<td>
<p>a <a href="#topic+redist_plans">redist_plans</a> object.</p>
</td></tr>
<tr><td><code id="plot.redist_classified_+3A_shp">shp</code></td>
<td>
<p>a shapefile or <a href="#topic+redist_map">redist_map</a> object.</p>
</td></tr>
<tr><td><code id="plot.redist_classified_+3A_type">type</code></td>
<td>
<p>either <code>"line"</code> or <code>"fill"</code>. Passed on to <code><a href="#topic+compare_plans">compare_plans()</a></code> as
<code>plot</code>.</p>
</td></tr>
<tr><td><code id="plot.redist_classified_+3A_which">which</code></td>
<td>
<p>indices of the splits to plot. Defaults to all</p>
</td></tr>
<tr><td><code id="plot.redist_classified_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+compare_plans">compare_plans()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot comparison plot
</p>

<hr>
<h2 id='plot.redist_constr'>Visualize constraints</h2><span id='topic+plot.redist_constr'></span>

<h3>Description</h3>

<p>Plots the constraint strength versus some running variable. Currently
supports visualizing the <code>grp_hinge</code>, <code>grp_inv_hinge</code>, and <code>grp_pow</code>
constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_constr'
plot(x, y, type = "group", xlim = c(0, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.redist_constr_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+redist_constr">redist_constr</a> object.</p>
</td></tr>
<tr><td><code id="plot.redist_constr_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot.redist_constr_+3A_type">type</code></td>
<td>
<p>What type of constraint to visualize. Currently supports only
<code>"group"</code>, for visualizing constraint strength by group share.</p>
</td></tr>
<tr><td><code id="plot.redist_constr_+3A_xlim">xlim</code></td>
<td>
<p>Range of group shares to visualize.</p>
</td></tr>
<tr><td><code id="plot.redist_constr_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05)
constr &lt;- redist_constr(iowa_map)
constr &lt;- add_constr_grp_hinge(constr, strength = 30,
                               dem_08, tot_08, tgts_group = 0.5)
constr &lt;- add_constr_grp_hinge(constr, strength = -20,
                               dem_08, tot_08, tgts_group = 0.3)
plot(constr)

</code></pre>

<hr>
<h2 id='plot.redist_map'>Plot a <code>redist_map</code></h2><span id='topic+plot.redist_map'></span>

<h3>Description</h3>

<p>Plot a <code>redist_map</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_map'
plot(x, fill = NULL, by_distr = FALSE, adj = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.redist_map_+3A_x">x</code></td>
<td>
<p>the <code>redist_map</code> object</p>
</td></tr>
<tr><td><code id="plot.redist_map_+3A_fill">fill</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> If
present, will be used to color the map units. If using data masking, may
need to explicitly name argument <code>fill=...</code> in non-interactive
contexts to avoid S3 generic issues.</p>
</td></tr>
<tr><td><code id="plot.redist_map_+3A_by_distr">by_distr</code></td>
<td>
<p>if <code>TRUE</code> and <code>fill</code> is not missing and, color by
district and indicate the <code>fill</code> variable by shading.</p>
</td></tr>
<tr><td><code id="plot.redist_map_+3A_adj">adj</code></td>
<td>
<p>if <code>TRUE</code>, force plotting the adjacency graph. Overrides
<code>by_distr</code>.</p>
</td></tr>
<tr><td><code id="plot.redist_map_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+redist.plot.map">redist.plot.map</a></code> (or
<code><a href="#topic+redist.plot.adj">redist.plot.adj</a></code> if <code>adj=TRUE</code>).
Useful parameters may include <code>zoom_to</code>, <code>boundaries</code>, and
<code>title</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)
d &lt;- redist_map(fl25, ndists = 3, pop_tol = 0.05)
plot(d)
plot(d, BlackPop/pop)

data(fl25_enum)
fl25$dist &lt;- fl25_enum$plans[, 5118]
d &lt;- redist_map(fl25, existing_plan = dist)
plot(d)

</code></pre>

<hr>
<h2 id='plot.redist_plans'>Summary plots for <code>\link{redist_plans}</code></h2><span id='topic+plot.redist_plans'></span>

<h3>Description</h3>

<p>If no arguments are passed, defaults to plotting the sampling weights for
the <code><a href="#topic+redist_plans">redist_plans</a></code> object. If no weights exist, plots district
populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_plans'
plot(x, ..., type = "distr_qtys")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.redist_plans_+3A_x">x</code></td>
<td>
<p>the <code>redist_plans</code> object.</p>
</td></tr>
<tr><td><code id="plot.redist_plans_+3A_...">...</code></td>
<td>
<p>passed on to the underlying function</p>
</td></tr>
<tr><td><code id="plot.redist_plans_+3A_type">type</code></td>
<td>
<p>the name of the plotting function to use. Will have
<code>redist.plot.</code>, prepended to it; e.g., use <code>type="plans"</code> to call
<code><a href="#topic+redist.plot.plans">redist.plot.plans</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='prec_assignment'>Extract the district assignments for a precinct across all simulated plans</h2><span id='topic+prec_assignment'></span>

<h3>Description</h3>

<p>Extract the district assignments for a precinct across all simulated plans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prec_assignment(prec, .data = pl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prec_assignment_+3A_prec">prec</code></td>
<td>
<p>the precinct number</p>
</td></tr>
<tr><td><code id="prec_assignment_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector, a row from a plans matrix
</p>

<hr>
<h2 id='prec_cooccurrence'>Compute a matrix of precinct co-occurrences</h2><span id='topic+prec_cooccurrence'></span>

<h3>Description</h3>

<p>For a map with <code>n</code> precincts Returns an <code>n</code>-by-<code>n</code> matrix, where each
entry measures the fraction of the plans in which the row and column
precincts were in the same district.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prec_cooccurrence(plans, which = NULL, sampled_only = TRUE, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prec_cooccurrence_+3A_plans">plans</code></td>
<td>
<p>a <a href="#topic+redist_plans">redist_plans</a> object.</p>
</td></tr>
<tr><td><code id="prec_cooccurrence_+3A_which">which</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> which plans to
compute the co-occurrence over.  Defaults to all.</p>
</td></tr>
<tr><td><code id="prec_cooccurrence_+3A_sampled_only">sampled_only</code></td>
<td>
<p>if <code>TRUE</code>, do not include reference plans.</p>
</td></tr>
<tr><td><code id="prec_cooccurrence_+3A_ncores">ncores</code></td>
<td>
<p>the number of parallel cores to use in the computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric matrix the size of the number of precincts.
</p>

<hr>
<h2 id='print.redist_classified'>Print redist_classified objects</h2><span id='topic+print.redist_classified'></span>

<h3>Description</h3>

<p>Print redist_classified objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_classified'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.redist_classified_+3A_x">x</code></td>
<td>
<p>redist_classified object</p>
</td></tr>
<tr><td><code id="print.redist_classified_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints to console
</p>

<hr>
<h2 id='print.redist_constr'>Generic to print redist_constr</h2><span id='topic+print.redist_constr'></span>

<h3>Description</h3>

<p>Generic to print redist_constr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_constr'
print(x, header = TRUE, details = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.redist_constr_+3A_x">x</code></td>
<td>
<p>redist_constr</p>
</td></tr>
<tr><td><code id="print.redist_constr_+3A_header">header</code></td>
<td>
<p>if FALSE, then suppress introduction / header line</p>
</td></tr>
<tr><td><code id="print.redist_constr_+3A_details">details</code></td>
<td>
<p>if FALSE, then suppress the details of each constraint</p>
</td></tr>
<tr><td><code id="print.redist_constr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints to console and returns input redist_constr
</p>

<hr>
<h2 id='print.redist_map'>Generic to print redist_map</h2><span id='topic+print.redist_map'></span>

<h3>Description</h3>

<p>Generic to print redist_map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_map'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.redist_map_+3A_x">x</code></td>
<td>
<p>redist_map</p>
</td></tr>
<tr><td><code id="print.redist_map_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints to console and returns input redist_map
</p>

<hr>
<h2 id='print.redist_plans'>Print method for <code>redist_plans</code></h2><span id='topic+print.redist_plans'></span>

<h3>Description</h3>

<p>Print method for <code>redist_plans</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_plans'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.redist_plans_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+redist_plans">redist_plans</a> object</p>
</td></tr>
<tr><td><code id="print.redist_plans_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original object, invisibly.
</p>

<hr>
<h2 id='pullback'>Pull back plans to unmerged units</h2><span id='topic+pullback'></span>

<h3>Description</h3>

<p>Merging map units through <code><a href="#topic+merge_by">merge_by</a></code> or <code><a href="dplyr.html#topic+summarize">summarize</a></code>
changes the indexing of each unit.  Use this function to take a set of
redistricting plans from a <code>redist</code> algorithm and re-index them to
be compatible with the original set of units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullback(plans, map = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullback_+3A_plans">plans</code></td>
<td>
<p>a <code>redist_plans</code> object</p>
</td></tr>
<tr><td><code id="pullback_+3A_map">map</code></td>
<td>
<p>optionally, a <code>redist_map</code> object, which will be used to set the new population vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new, re-indexed, <code>redist_plans</code> object
</p>

<hr>
<h2 id='rbind.redist_plans'>Combine multiple sets of redistricting plans</h2><span id='topic+rbind.redist_plans'></span>

<h3>Description</h3>

<p>Only works when all the sets are compatible&mdash;generated from the same map,
with the same number of districts.  Sets of plans will be indexed by the
<code>chain</code> column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_plans'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.redist_plans_+3A_...">...</code></td>
<td>
<p>The <code><a href="#topic+redist_plans">redist_plans</a></code> objects to combine.  If named arguments are
provided, the names will be used in the <code>chain</code> column; otherwise, numbers
will be used for the <code>chain</code> column.</p>
</td></tr>
<tr><td><code id="rbind.redist_plans_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code><a href="#topic+redist_plans">redist_plans</a></code> object.
</p>

<hr>
<h2 id='redist_ci'>Confidence Intervals for SMC and MCMC Estimates</h2><span id='topic+redist_ci'></span><span id='topic+redist_smc_ci'></span><span id='topic+redist_mcmc_ci'></span>

<h3>Description</h3>

<p>Builds a confidence interval for a quantity of interest.
If multiple runs are available, uses the between-run variation to estimate
the standard error. If only one run is available, uses information on the SMC
particle/plan genealogy to estimate the standard error, using a variant of
the method of Olson &amp; Douc (2019). The multiple-run estimator is more
reliable, especially for situations with many districts, and should be used
when parallelism is available.  All reference plans are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_ci(plans, x, district = 1L, conf = 0.9, by_chain = FALSE)

redist_smc_ci(plans, x, district = 1L, conf = 0.9, by_chain = FALSE)

redist_mcmc_ci(plans, x, district = 1L, conf = 0.9, by_chain = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_ci_+3A_plans">plans</code></td>
<td>
<p>a <a href="#topic+redist_plans">redist_plans</a> object.</p>
</td></tr>
<tr><td><code id="redist_ci_+3A_x">x</code></td>
<td>
<p>the quantity to build an interval for. Tidy-evaluated within <code>plans</code>.</p>
</td></tr>
<tr><td><code id="redist_ci_+3A_district">district</code></td>
<td>
<p>for <a href="#topic+redist_plans">redist_plans</a> objects with multiple districts, which
<code>district</code> to subset to. Set to <code>NULL</code> to perform no subsetting.</p>
</td></tr>
<tr><td><code id="redist_ci_+3A_conf">conf</code></td>
<td>
<p>the desired confidence level.</p>
</td></tr>
<tr><td><code id="redist_ci_+3A_by_chain">by_chain</code></td>
<td>
<p>Whether the confidence interval should indicate overall
sampling uncertainty (<code>FALSE</code>) or per-chain sampling uncertainty (<code>TRUE</code>).
In the latter case the intervals will be wider by a factor of <code>sqrt(runs)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with three columns: <code>X</code>, <code>X_lower</code>, and
<code>X_upper</code>, where <code>X</code> is the name of the vector of interest,
containing the mean and confidence interval. When used inside
<code><a href="dplyr.html#topic+summarise">summarize()</a></code> this will create three columns in the
output data.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>redist_smc_ci()</code>: Compute confidence intervals for SMC output.
</p>
</li>
<li> <p><code>redist_mcmc_ci()</code>: Compute confidence intervals for MCMC output.
</p>
</li></ul>


<h3>References</h3>

<p>Lee, A., &amp; Whiteley, N. (2018). Variance estimation in the particle filter.
Biometrika, 105(3), 609-625.
</p>
<p>Olsson, J., &amp; Douc, R. (2019). Numerically stable online estimation of
variance in particle filters. Bernoulli, 25(2), 1504-1535.
</p>
<p>H. P. Chan and T. L. Lai. A general theory of particle filters in hidden
Markov models and some applications. Ann. Statist., 41(6):2877–2904, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(iowa)

iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05)
plans &lt;- redist_mergesplit_parallel(iowa_map, nsims = 200, chains = 2, silent = TRUE) %&gt;%
    mutate(dem = group_frac(iowa_map, dem_08, dem_08 + rep_08)) %&gt;%
    number_by(dem)
redist_smc_ci(plans, dem)

</code></pre>

<hr>
<h2 id='redist_constr'>Set up constraints for sampling</h2><span id='topic+redist_constr'></span>

<h3>Description</h3>

<p><code>redist_constr</code> objects are used to specify constraints when sampling
redistricting plans with <code><a href="#topic+redist_smc">redist_smc()</a></code> and <code><a href="#topic+redist_mergesplit">redist_mergesplit()</a></code>. Each
constraint is specified as a function which scores a given plan. Higher
scores are penalized and sampled less frequently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_constr(map = tibble())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_constr_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map()</a></code> object; the map that will be used in sampling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>redist_constr</code> object keeps track of sampling constraints in a nested list.
You can view the exact structure of this list by calling <code><a href="utils.html#topic+str">str()</a></code>.
Constraints may be added by using one of the following functions:
</p>

<ul>
<li> <p><code><a href="#topic+add_constr_compet">add_constr_compet()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_custom">add_constr_custom()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_edges_rem">add_constr_edges_rem()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_fry_hold">add_constr_fry_hold()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_grp_hinge">add_constr_grp_hinge()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_grp_inv_hinge">add_constr_grp_inv_hinge()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_grp_pow">add_constr_grp_pow()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_incumbency">add_constr_incumbency()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_log_st">add_constr_log_st()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_multisplits">add_constr_multisplits()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_polsby">add_constr_polsby()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_pop_dev">add_constr_pop_dev()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_segregation">add_constr_segregation()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_splits">add_constr_splits()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_status_quo">add_constr_status_quo()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_constr_total_splits">add_constr_total_splits()</a></code>
</p>
</li></ul>

<p>More information about each constraint can be found on the relevant constraint page.
</p>


<h3>Value</h3>

<p>a <code>redist_constr</code> object, which is just a list with a certain nested structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
map_ia &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.01)
constr &lt;- redist_constr(map_ia)
constr &lt;- add_constr_splits(constr, strength = 1.5, admin = region)
print(constr)

</code></pre>

<hr>
<h2 id='redist_flip'>'Flip' Markov Chain Monte Carlo Redistricting Simulation (Fifield et al. 2020)</h2><span id='topic+redist_flip'></span>

<h3>Description</h3>

<p>This function allows users to simulate redistricting plans
using a Markov Chain Monte Carlo algorithm (Fifield, Higgins, Imai, and Tarr 2020). Several
constraints corresponding to substantive requirements in the redistricting
process are implemented, including population parity and geographic
compactness. In addition, the function includes multiple-swap and simulated
tempering functionality to improve the mixing of the Markov Chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_flip(
  map,
  nsims,
  warmup = 0,
  init_plan,
  constraints = add_constr_edges_rem(redist_constr(map), 0.4),
  thin = 1,
  eprob = 0.05,
  lambda = 0,
  temper = FALSE,
  betaseq = "powerlaw",
  betaseqlength = 10,
  betaweights = NULL,
  adapt_lambda = FALSE,
  adapt_eprob = FALSE,
  exact_mh = FALSE,
  adjswaps = TRUE,
  init_name = NULL,
  verbose = TRUE,
  nthin
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_flip_+3A_map">map</code></td>
<td>
<p>A <code><a href="#topic+redist_map">redist_map</a></code> object.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_nsims">nsims</code></td>
<td>
<p>The number of samples to draw, not including warmup.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup samples to discard.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_init_plan">init_plan</code></td>
<td>
<p>A vector containing the congressional district labels
of each geographic unit. The default is <code>NULL</code>. If not provided,
a random initial plan will be generated using <code>redist_smc</code>. You can also
request to initialize using <code>redist.rsg</code> by supplying 'rsg', though this is
not recommended behavior.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_constraints">constraints</code></td>
<td>
<p>A <code>redist_constr</code> object.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_thin">thin</code></td>
<td>
<p>The amount by which to thin the Markov Chain. The
default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_eprob">eprob</code></td>
<td>
<p>The probability of keeping an edge connected. The
default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_lambda">lambda</code></td>
<td>
<p>lambda The parameter determining the number of swaps to attempt
each iteration of the algorithm. The number of swaps each iteration is
equal to Pois(<code>lambda</code>) + 1. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_temper">temper</code></td>
<td>
<p>Whether to use simulated tempering algorithm. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_betaseq">betaseq</code></td>
<td>
<p>Sequence of beta values for tempering. The default is
<code>powerlaw</code> (see Fifield et. al (2020) for details).</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_betaseqlength">betaseqlength</code></td>
<td>
<p>Length of beta sequence desired for
tempering. The default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_betaweights">betaweights</code></td>
<td>
<p>betaweights Sequence of weights for different values of
beta. Allows the user to upweight certain values of beta over
others. The default is <code>NULL</code> (equal weighting).</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_adapt_lambda">adapt_lambda</code></td>
<td>
<p>adapt_lambda Whether to adaptively tune the lambda parameter so that the Metropolis-Hastings
acceptance probability falls between 20% and 40%. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_adapt_eprob">adapt_eprob</code></td>
<td>
<p>eprob Whether to adaptively tune the edgecut probability parameter so that the
Metropolis-Hastings acceptance probability falls between 20% and 40%. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_exact_mh">exact_mh</code></td>
<td>
<p>Whether to use the approximate (FALSE) or exact (TRUE)
Metropolis-Hastings ratio calculation for accept-reject rule. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_adjswaps">adjswaps</code></td>
<td>
<p>Flag to restrict swaps of beta so that only
values adjacent to current constraint are proposed. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_init_name">init_name</code></td>
<td>
<p>a name for the initial plan, or <code>FALSE</code> to not include
the initial plan in the output.  Defaults to the column name of the
existing plan, or &quot;<code>&lt;init&gt;</code>&quot; if the initial plan is sampled.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print initialization statement. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_+3A_nthin">nthin</code></td>
<td>
<p>Deprecated. Use <code>thin</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>redist_flip</code> allows for Gibbs constraints to be supplied via a list object
passed to <code>constraints</code>.
<code>redist_flip</code> uses a small compactness constraint by default, as this improves
the realism of the maps greatly and also leads to large speed improvements.
(One of the most time consuming aspects of the flip MCMC backend is checking for
district shattering, which is slowed down even further by non-compact districts.
As such, it is recommended that all flip simulations use at least a minimal compactness
constraint, even if you weaken it from the default settings.) The default is
a <code>compact</code> constraint using the <code>edges-removed</code> metric with a
weight of 0.6. For very small maps (&lt; 100 precincts), you will likely want to
weaken (lower) this constraint, while for very large maps (&gt; 5000 precincts),
you will likely want to strengthen (increase) this constraint. Otherwise,
for most maps, the default constraint should be a good starting place.
</p>
<p><code>redist_flip</code> samples from a known target distribution which can be described
using the <code>constraints</code>. The following describes the constraints available. The general
advice is to set weights in a way that gets between 20% and 40% acceptance
on average, though more tuning advice is available in the vignette on using
MCMC methods.Having too small of an acceptance rate indicates that the weights
within <code>constraints</code> are too large and will impact sampling efficiency.
If the Metropolis Hastings acceptance rate is too large, this may impact the
target distribution, but may be fine for general exploration of possible maps.
</p>
<p>There are currently 9 implemented constraint types, though '<code>compact</code> and
<code>partisan</code> have sub-types which are specified via a character <code>metric</code>
within their respective list objects. The constraints are as follows:
</p>

<ul>
<li> <p><code>compact</code> - biases the algorithm towards drawing more compact districts.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li><p> metric - which metric to use. Must be one of <code>edges-removed</code> (the default),
<code>polsby-popper</code>, <code>fryer-holden</code>, or <code>log-st</code>. Using Polsby Popper
is generally not recommended, as <code>edges-removed</code> is faster and highly correlated.
<code>log-st</code> can be used to match the target distribution of <code>redist_smc</code> or
<code>redist_mergesplit</code>.
</p>
</li>
<li><p> areas - Only used with <code>polsby-popper</code> - A vector of precinct areas.
</p>
</li>
<li><p> borderlength_mat - Only used with <code>polsby-popper</code> - A matrix of precinct
border lengths.
</p>
</li>
<li><p> ssdmat - Only used with <code>fryer-holden</code> - A matrix of squared distances between
precinct centroids.
</p>
</li>
<li><p> ssd_denom - Only used with <code>fryer-holden</code> - a positive integer to use
as the normalizing constant for the Relative Proximity Index.
</p>
</li>
<li> <p><code>population</code> - A Gibbs constraint to complement the hard population
constraint set by <code>pop_tol</code>. This penalizes moves which move away from smaller
population parity deviations. It is very useful when an <code>init_plan</code> sits
outside of the desired <code>pop_tol</code> but there are substantive reasons to use
that plan. This constraint uses the input to <code>total_pop</code>.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li> <p><code>countysplit</code> This is a Gibbs constraint to minimize county splits. Unlike
SMC's county constraint, this allows for more than <code>ndists - 1</code> splits and
does not require that counties are contiguous.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li> <p><code>hinge</code> This uses the proportion of a group in a district and matches to the
nearest target proportion, and then creates a penalty of
<code class="reqn">\sqrt{max(0, nearest.target - group.pct)}</code>.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li><p> minorityprop - A numeric vector of minority proportions (between 0 and 1) which
districts should aim to have
</p>
</li>
<li> <p><code>vra</code> This takes two target proportions of the presence of a minority group
within a district. <code class="reqn">(|target.min - group.pct||target.other - group.pct|)^{1.5})</code>
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li><p> target_min - the target minority percentage. Often, this is set to 0.55 to encourage
minority majority districts.
</p>
</li>
<li><p> target_other - the target minority percentage for non majority minority districts.
</p>
</li>
<li> <p><code>minority</code> This constraint sorts the districts by the proportion of a group in
a district and compares the highest districts to the entries of minorityprop.
This takes the form <code class="reqn">\sum_{i=1}^{n} \sqrt{|group.pct(i) - minorityprop(i)| }</code> where n
is the length of minorityprop input.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li><p> minorityprop - A numeric vector of minority proportions (between 0 and 1) which
districts should aim to have
</p>
</li>
<li> <p><code>similarity</code> This is a status-quo constraint which penalizes plans which
are very different from the starting place. It is useful for local exploration.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li> <p><code>partisan</code> This is a constraint which minimizes partisan bias, either as
measured as the difference from proportional representation or as the magnitude of
the efficiency gap.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li>
<li><p> rvote - An integer vector of votes for Republicans or other party
</p>
</li>
<li><p> dvote - An integer vector of votes for Democrats or other party
</p>
</li>
<li><p> metric - which metric to use. Must be one of <code>proportional-representation</code>
or <code>efficiency-gap</code>.
</p>
</li>
<li> <p><code>segregation</code> This constraint attempts to minimize the degree of dissimilarity
between districts by group population.
</p>
</li>
<li><p> weight - the coefficient to put on the Gibbs constraint
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="#topic+redist_plans">redist_plans</a></code> object containing the simulated plans.
</p>


<h3>References</h3>

<p>Fifield, B., Higgins, M., Imai, K., &amp; Tarr, A. (2020). Automated
redistricting simulation using Markov chain Monte Carlo. <em>Journal of
Computational and Graphical Statistics</em>, 29(4), 715-728.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
iowa_map &lt;- redist_map(iowa, ndists = 4, existing_plan = cd_2010, total_pop = pop,
    pop_tol = 0.05)
sims &lt;- redist_flip(map = iowa_map, nsims = 100)

</code></pre>

<hr>
<h2 id='redist_flip_anneal'>Flip MCMC Redistricting Simulator using Simulated Annealing</h2><span id='topic+redist_flip_anneal'></span>

<h3>Description</h3>

<p><code>redist_flip_anneal</code> simulates congressional redistricting plans
using Markov chain Monte Carlo methods coupled with simulated annealing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_flip_anneal(
  map,
  nsims,
  warmup = 0,
  init_plan = NULL,
  constraints = redist_constr(),
  num_hot_steps = 40000,
  num_annealing_steps = 60000,
  num_cold_steps = 20000,
  eprob = 0.05,
  lambda = 0,
  adapt_lambda = FALSE,
  adapt_eprob = FALSE,
  exact_mh = FALSE,
  maxiterrsg = 5000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_flip_anneal_+3A_map">map</code></td>
<td>
<p>A <code><a href="#topic+redist_map">redist_map</a></code> object.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_nsims">nsims</code></td>
<td>
<p>The number of samples to draw, not including warmup.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup samples to discard.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_init_plan">init_plan</code></td>
<td>
<p>A vector containing the congressional district labels
of each geographic unit. The default is <code>NULL</code>. If not provided,
a random initial plan will be generated using <code>redist_smc</code>. You can also
request to initialize using <code>redist.rsg</code> by supplying 'rsg', though this is
not recommended behavior.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_constraints">constraints</code></td>
<td>
<p>A <code>redist_constr</code> object.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_num_hot_steps">num_hot_steps</code></td>
<td>
<p>The number of steps to run the simulator at beta = 0.
Default is 40000.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_num_annealing_steps">num_annealing_steps</code></td>
<td>
<p>The number of steps to run the simulator with
linearly changing beta schedule. Default is 60000</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_num_cold_steps">num_cold_steps</code></td>
<td>
<p>The number of steps to run the simulator at beta = 1.
Default is 20000.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_eprob">eprob</code></td>
<td>
<p>The probability of keeping an edge connected. The
default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_lambda">lambda</code></td>
<td>
<p>The parameter determining the number of swaps to attempt
each iteration of the algorithm. The number of swaps each iteration is
equal to Pois(<code>lambda</code>) + 1. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_adapt_lambda">adapt_lambda</code></td>
<td>
<p>Whether to adaptively tune the lambda parameter so that the Metropolis-Hastings
acceptance probability falls between 20% and 40%. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_adapt_eprob">adapt_eprob</code></td>
<td>
<p>Whether to adaptively tune the edgecut probability parameter so that the
Metropolis-Hastings acceptance probability falls between 20% and 40%. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_exact_mh">exact_mh</code></td>
<td>
<p>Whether to use the approximate (0) or exact (1)
Metropolis-Hastings ratio calculation for accept-reject rule. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_maxiterrsg">maxiterrsg</code></td>
<td>
<p>Maximum number of iterations for random seed-and-grow
algorithm to generate starting values. Default is 5000.</p>
</td></tr>
<tr><td><code id="redist_flip_anneal_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print initialization statement.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>redist_plans
</p>

<hr>
<h2 id='redist_map'>Create a <code>redist_map</code> object.</h2><span id='topic+redist_map'></span><span id='topic+as_redist_map'></span>

<h3>Description</h3>

<p>Sets up a redistricting problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_map(
  ...,
  existing_plan = NULL,
  pop_tol = NULL,
  total_pop = c("pop", "population", "total_pop", "POP100"),
  ndists = NULL,
  pop_bounds = NULL,
  adj = NULL,
  adj_col = "adj",
  planarize = 3857
)

as_redist_map(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_map_+3A_...">...</code></td>
<td>
<p>column elements to be bound into a <code>redist_map</code> object or a
single <code>list</code> or <code>data.frame</code>.  These will be passed on to the
<code><a href="dplyr.html#topic+tibble">tibble</a></code> constructor.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_existing_plan">existing_plan</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_tidy_select">&lt;tidy-select&gt;</a></code> the
existing district assignment. Must be numeric or convertible to numeric.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_pop_tol">pop_tol</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the population tolerance.
The percentage deviation from the average population will be constrained to
be no more than this number. If <code>existing_plan</code> is provided, defaults to
the parity of that plan; otherwise, defaults to 0.01.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_total_pop">total_pop</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_tidy_select">&lt;tidy-select&gt;</a></code> the vector
of precinct populations. Defaults to the <code>pop</code>, <code>population</code>, or
<code>total_pop</code> columns, if one exists.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_ndists">ndists</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the integer number of
districts to partition the map into. Must be specified if <code>existing_plan</code> is not supplied.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_pop_bounds">pop_bounds</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> more specific
population bounds, in the form of <code>c(lower, target, upper)</code>.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_adj">adj</code></td>
<td>
<p>the adjacency graph for the object. Defaults to being computed
from the data if it is coercible to a shapefile.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_adj_col">adj_col</code></td>
<td>
<p>the name of the adjacency graph column</p>
</td></tr>
<tr><td><code id="redist_map_+3A_planarize">planarize</code></td>
<td>
<p>a number, indicating the CRS to project the shapefile to if
it is latitude-longitude based. Set to NULL or FALSE to avoid planarizing.</p>
</td></tr>
<tr><td><code id="redist_map_+3A_x">x</code></td>
<td>
<p>an object to be coerced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>redist_map</code> object is a <code><a href="dplyr.html#topic+tibble">tibble</a></code> which contains an
adjacency list and additional information about the number of districts and
population bounds.  It supports all of the <code>dplyr</code> generics, and will
adjust the adjacency list and attributes according to these functions; i.e.,
if we <code>filter</code> to a subset of units, the graph will change to subset to
these units, and the population bounds will adjust accordingly.  If an
existing map is also attached to the object, the number of districts will
also adjust.  Subsetting with <code>`[`</code> and <code>`[[`</code> does not recompute
graphs or attributes.
</p>
<p>Other useful methods for <code>redist_map</code> objects:
</p>

<ul>
<li> <p><code><a href="#topic+merge_by">merge_by</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_adj">get_adj</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.redist_map">plot.redist_map</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>A redist_map object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25)
d &lt;- redist_map(fl25, ndists = 3, pop_tol = 0.05, total_pop = pop)
dplyr::filter(d, pop &gt;= 10e3)

</code></pre>

<hr>
<h2 id='redist_mergesplit'>Merge-Split/Recombination MCMC Redistricting Sampler (Carter et al. 2019)</h2><span id='topic+redist_mergesplit'></span>

<h3>Description</h3>

<p><code>redist_mergesplit</code> uses a Markov Chain Monte Carlo algorithm (Carter et
al. 2019; based on DeFord et. al 2019) to generate congressional or legislative redistricting plans
according to contiguity, population, compactness, and administrative boundary
constraints. The MCMC proposal is the same as is used in the SMC sampler
(McCartan and Imai 2023); it is similar but not identical to those used in
the references.  1-level hierarchical Merge-split is supported through the
<code>counties</code> parameter; unlike in the SMC algorithm, this does not
guarantee a maximum number of county splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_mergesplit(
  map,
  nsims,
  warmup = if (is.null(init_plan)) 10 else max(100, nsims%/%5),
  thin = 1L,
  init_plan = NULL,
  counties = NULL,
  compactness = 1,
  constraints = list(),
  constraint_fn = function(m) rep(0, ncol(m)),
  adapt_k_thresh = 0.99,
  k = NULL,
  init_name = NULL,
  verbose = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_mergesplit_+3A_map">map</code></td>
<td>
<p>A <code><a href="#topic+redist_map">redist_map</a></code> object.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_nsims">nsims</code></td>
<td>
<p>The number of samples to draw, including warmup.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup samples to discard. Recommended to be at
least the first 20% of samples, and in any case no less than around 100
samples, unless initializing from a random plan.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_thin">thin</code></td>
<td>
<p>Save every <code>thin</code>-th sample. Defaults to no thinning (1).</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_init_plan">init_plan</code></td>
<td>
<p>The initial state of the map. If not provided, will default to
the reference map of the <code>map</code> object, or if none exists, will sample
a random initial state using <code><a href="#topic+redist_smc">redist_smc</a></code>. You can also request
a random initial state by setting <code>init_plan="sample"</code>.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_counties">counties</code></td>
<td>
<p>A vector containing county (or other administrative or
geographic unit) labels for each unit, which may be integers ranging from 1
to the number of counties, or a factor or character vector.  If provided,
the algorithm will generate maps tend to follow county lines. There is no
strength parameter associated with this constraint. To adjust the number of
county splits further, or to constrain a second type of administrative
split, consider using <code>add_constr_splits()</code>, <code>add_constr_multisplits()</code>,
and <code>add_constr_total_splits()</code>.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_compactness">compactness</code></td>
<td>
<p>Controls the compactness of the generated districts, with
higher values preferring more compact districts. Must be nonnegative. See the
'Details' section for more information, and computational considerations.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_constraints">constraints</code></td>
<td>
<p>A list containing information on constraints to implement.
See the 'Details' section for more information.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_constraint_fn">constraint_fn</code></td>
<td>
<p>A function which takes in a matrix where each column is
a redistricting plan and outputs a vector of log-weights, which will be
added the the final weights.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_adapt_k_thresh">adapt_k_thresh</code></td>
<td>
<p>The threshold value used in the heuristic to select a
value <code>k_i</code> for each splitting iteration. Set to 0.9999 or 1 if
the algorithm does not appear to be sampling from the target distribution.
Must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_k">k</code></td>
<td>
<p>The number of edges to consider cutting after drawing a spanning
tree. Should be selected automatically in nearly all cases.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_init_name">init_name</code></td>
<td>
<p>a name for the initial plan, or <code>FALSE</code> to not include
the initial plan in the output.  Defaults to the column name of the
existing plan, or &quot;<code>&lt;init&gt;</code>&quot; if the initial plan is sampled.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out intermediate information while sampling.
Recommended.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress all diagnostic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws samples from a specific target measure, controlled by the
<code>map</code>, <code>compactness</code>, and <code>constraints</code> parameters.
</p>
<p>Key to ensuring good performance is monitoring the acceptance rate, which
is reported at the sample level in the output.
Users should also check diagnostics of the sample by running
<code>summary.redist_plans()</code>.
</p>
<p>Higher values of <code>compactness</code> sample more compact districts;
setting this parameter to 1 is computationally efficient and generates nicely
compact districts.
</p>


<h3>Value</h3>

<p><code>redist_mergesplit</code> returns an object of class
<code><a href="#topic+redist_plans">redist_plans</a></code> containing the simulated plans.
</p>


<h3>References</h3>

<p>Carter, D., Herschlag, G., Hunter, Z., and Mattingly, J. (2019). A
merge-split proposal for reversible Monte Carlo Markov chain sampling of
redistricting plans. arXiv preprint arXiv:1911.01503.
</p>
<p>McCartan, C., &amp; Imai, K. (2023). Sequential Monte Carlo for Sampling
Balanced and Compact Redistricting Plans. <em>Annals of Applied Statistics</em> 17(4).
Available at <a href="https://doi.org/10.1214/23-AOAS1763">doi:10.1214/23-AOAS1763</a>.
</p>
<p>DeFord, D., Duchin, M., and Solomon, J. (2019). Recombination: A family of
Markov chains for redistricting. arXiv preprint arXiv:1911.05725.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fl25)

fl_map &lt;- redist_map(fl25, ndists = 3, pop_tol = 0.1)

sampled_basic &lt;- redist_mergesplit(fl_map, 10000)

sampled_constr &lt;- redist_mergesplit(fl_map, 10000, constraints = list(
    incumbency = list(strength = 1000, incumbents = c(3, 6, 25))
))


</code></pre>

<hr>
<h2 id='redist_mergesplit_parallel'>Parallel Merge-Split/Recombination MCMC Redistricting Sampler</h2><span id='topic+redist_mergesplit_parallel'></span>

<h3>Description</h3>

<p><code>redist_mergesplit_parallel()</code> runs <code><a href="#topic+redist_mergesplit">redist_mergesplit()</a></code> on several
chains in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_mergesplit_parallel(
  map,
  nsims,
  chains = 1,
  warmup = if (is.null(init_plan)) 10 else max(100, nsims%/%5),
  thin = 1L,
  init_plan = NULL,
  counties = NULL,
  compactness = 1,
  constraints = list(),
  constraint_fn = function(m) rep(0, ncol(m)),
  adapt_k_thresh = 0.99,
  k = NULL,
  ncores = NULL,
  cl_type = "PSOCK",
  return_all = TRUE,
  init_name = NULL,
  verbose = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_mergesplit_parallel_+3A_map">map</code></td>
<td>
<p>A <code><a href="#topic+redist_map">redist_map</a></code> object.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_nsims">nsims</code></td>
<td>
<p>The number of samples to draw, including warmup.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_chains">chains</code></td>
<td>
<p>the number of parallel chains to run. Each chain will have
<code>nsims</code> draws. If <code>init_plan</code> is sampled, each chain will be initialized
with its own sampled plan.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup samples to discard. Recommended to be at
least the first 20% of samples, and in any case no less than around 100
samples, unless initializing from a random plan.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_thin">thin</code></td>
<td>
<p>Save every <code>thin</code>-th sample. Defaults to no thinning (1).</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_init_plan">init_plan</code></td>
<td>
<p>The initial state of the map, provided as a single vector
to be shared across all chains, or a matrix with <code>chains</code> columns.
If not provided, will default to the reference map of the map object, or if
none exists, will sample a random initial state using redist_smc. You can
also request a random initial state for each chain by setting
init_plan=&quot;sample&quot;.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_counties">counties</code></td>
<td>
<p>A vector containing county (or other administrative or
geographic unit) labels for each unit, which may be integers ranging from 1
to the number of counties, or a factor or character vector.  If provided,
the algorithm will generate maps tend to follow county lines. There is no
strength parameter associated with this constraint. To adjust the number of
county splits further, or to constrain a second type of administrative
split, consider using <code>add_constr_splits()</code>, <code>add_constr_multisplits()</code>,
and <code>add_constr_total_splits()</code>.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_compactness">compactness</code></td>
<td>
<p>Controls the compactness of the generated districts, with
higher values preferring more compact districts. Must be nonnegative. See the
'Details' section for more information, and computational considerations.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_constraints">constraints</code></td>
<td>
<p>A list containing information on constraints to implement.
See the 'Details' section for more information.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_constraint_fn">constraint_fn</code></td>
<td>
<p>A function which takes in a matrix where each column is
a redistricting plan and outputs a vector of log-weights, which will be
added the the final weights.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_adapt_k_thresh">adapt_k_thresh</code></td>
<td>
<p>The threshold value used in the heuristic to select a
value <code>k_i</code> for each splitting iteration. Set to 0.9999 or 1 if
the algorithm does not appear to be sampling from the target distribution.
Must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_k">k</code></td>
<td>
<p>The number of edges to consider cutting after drawing a spanning
tree. Should be selected automatically in nearly all cases.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_ncores">ncores</code></td>
<td>
<p>the number of parallel processes to run. Defaults to the
maximum available.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_cl_type">cl_type</code></td>
<td>
<p>the cluster type (see <code><a href="parallel.html#topic+makeCluster">makeCluster()</a></code>). Safest is <code>"PSOCK"</code>,
but <code>"FORK"</code> may be appropriate in some settings.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_return_all">return_all</code></td>
<td>
<p>if <code>TRUE</code> return all sampled plans; otherwise, just return
the final plan from each chain.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_init_name">init_name</code></td>
<td>
<p>a name for the initial plan, or <code>FALSE</code> to not include
the initial plan in the output.  Defaults to the column name of the
existing plan, or &quot;<code>&lt;init&gt;</code>&quot; if the initial plan is sampled.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out intermediate information while sampling.
Recommended.</p>
</td></tr>
<tr><td><code id="redist_mergesplit_parallel_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress all diagnostic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws samples from a specific target measure, controlled by the
<code>map</code>, <code>compactness</code>, and <code>constraints</code> parameters.
</p>
<p>Key to ensuring good performance is monitoring the acceptance rate, which
is reported at the sample level in the output.
Users should also check diagnostics of the sample by running
<code>summary.redist_plans()</code>.
</p>
<p>Higher values of <code>compactness</code> sample more compact districts;
setting this parameter to 1 is computationally efficient and generates nicely
compact districts.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+redist_plans">redist_plans</a></code> object with all of the simulated plans, and an
additional <code>chain</code> column indicating the chain the plan was drawn from.
</p>


<h3>References</h3>

<p>Carter, D., Herschlag, G., Hunter, Z., and Mattingly, J. (2019). A
merge-split proposal for reversible Monte Carlo Markov chain sampling of
redistricting plans. arXiv preprint arXiv:1911.01503.
</p>
<p>McCartan, C., &amp; Imai, K. (2023). Sequential Monte Carlo for Sampling
Balanced and Compact Redistricting Plans. <em>Annals of Applied Statistics</em> 17(4).
Available at <a href="https://doi.org/10.1214/23-AOAS1763">doi:10.1214/23-AOAS1763</a>.
</p>
<p>DeFord, D., Duchin, M., and Solomon, J. (2019). Recombination: A family of
Markov chains for redistricting. arXiv preprint arXiv:1911.05725.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fl25)
fl_map &lt;- redist_map(fl25, ndists = 3, pop_tol = 0.1)
sampled &lt;- redist_mergesplit_parallel(fl_map, nsims = 100, chains = 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='redist_plans'>A set of redistricting plans</h2><span id='topic+redist_plans'></span>

<h3>Description</h3>

<p>A <code>redist_plans</code> object is essentially a data frame of summary
information on each district and each plan, along with the matrix of district
assignments and information about the simulation process used to generate the
plans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_plans(plans, map, algorithm, wgt = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_plans_+3A_plans">plans</code></td>
<td>
<p>a matrix with <code>n_precinct</code> columns and <code>n_sims</code> rows,
or a single vector of precinct assignments.</p>
</td></tr>
<tr><td><code id="redist_plans_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="redist_plans_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm used to generate the plans (usually &quot;smc&quot; or &quot;mcmc&quot;)</p>
</td></tr>
<tr><td><code id="redist_plans_+3A_wgt">wgt</code></td>
<td>
<p>the weights to use, if any.</p>
</td></tr>
<tr><td><code id="redist_plans_+3A_...">...</code></td>
<td>
<p>Other named attributes to set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two columns of the data frame will be <code>draw</code>, a factor indexing
the simulation draw, and <code>district</code>, an integer indexing the districts
within a plan. The data frame will therefore have <code>n_sims*ndists</code> rows.
As a data frame, the usual <code><a href="dplyr.html#topic+dplyr">dplyr</a></code> methods will work.
</p>
<p>Other useful methods for <code>redist_plans</code> objects:
</p>

<ul>
<li> <p><code><a href="#topic+summary.redist_plans">summary.redist_plans</a></code>
</p>
</li>
<li> <p><code><a href="#topic+add_reference">add_reference</a></code>
</p>
</li>
<li> <p><code><a href="#topic+subset_sampled">subset_sampled</a></code>
</p>
</li>
<li> <p><code><a href="#topic+subset_ref">subset_ref</a></code>
</p>
</li>
<li> <p><code><a href="#topic+pullback">pullback</a></code>
</p>
</li>
<li> <p><code><a href="#topic+number_by">number_by</a></code>
</p>
</li>
<li> <p><code><a href="#topic+match_numbers">match_numbers</a></code>
</p>
</li>
<li> <p><code><a href="#topic+is_county_split">is_county_split</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prec_assignment">prec_assignment</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plan_distances">plan_distances</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_plans_matrix">get_plans_matrix</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_plans_weights">get_plans_weights</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_sampling_info">get_sampling_info</a></code>
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.redist_plans">as.matrix.redist_plans</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.redist_plans">plot.redist_plans</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>a new <code>redist_plans</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)

iowa &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05, total_pop = pop)
rsg_plan &lt;- redist.rsg(iowa$adj, iowa$pop, ndists = 4, pop_tol = 0.05)$plan
redist_plans(rsg_plan, iowa, "rsg")

</code></pre>

<hr>
<h2 id='redist_quantile_trunc'>Helper function to truncate importance weights</h2><span id='topic+redist_quantile_trunc'></span>

<h3>Description</h3>

<p>Defined as <code>pmin(x, quantile(x, 1 - length(x)^(-0.5)))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_quantile_trunc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_quantile_trunc_+3A_x">x</code></td>
<td>
<p>the weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>redist_quantile_trunc(c(1, 2, 3, 4))

</code></pre>

<hr>
<h2 id='redist_shortburst'>Redistricting Optimization through Short Bursts</h2><span id='topic+redist_shortburst'></span>

<h3>Description</h3>

<p>This function uses <code><a href="#topic+redist_mergesplit">redist_mergesplit()</a></code> or <code><a href="#topic+redist_flip">redist_flip()</a></code> to optimize a
redistrict plan according to a user-provided criteria. It does so by running
the Markov chain for &quot;short bursts&quot; of usually 10 iterations, and then
starting the chain anew from the best plan in the burst, according to the
criteria. This implements the ideas in the below-referenced paper, &quot;Voting
Rights, Markov Chains, and Optimization by Short Bursts.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_shortburst(
  map,
  score_fn = NULL,
  stop_at = NULL,
  burst_size = ifelse(backend == "mergesplit", 10L, 50L),
  max_bursts = 500L,
  maximize = TRUE,
  init_plan = NULL,
  counties = NULL,
  constraints = redist_constr(map),
  compactness = 1,
  adapt_k_thresh = 0.95,
  reversible = TRUE,
  fixed_k = NULL,
  return_all = TRUE,
  thin = 1L,
  backend = "mergesplit",
  flip_lambda = 0,
  flip_eprob = 0.05,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_shortburst_+3A_map">map</code></td>
<td>
<p>A <a href="#topic+redist_map">redist_map</a> object.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_score_fn">score_fn</code></td>
<td>
<p>A function which takes a matrix of plans and returns a score
(or, generally, a row vector) for each plan. Can also be a purrr-style
anonymous function. See <code><a href="#topic+scorers">?scorers</a></code> for some function factories
for common scoring rules.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_stop_at">stop_at</code></td>
<td>
<p>A threshold to stop optimization at. When <code>score_fn</code> returns a
row vector per plan, <code>maximize</code> can be an equal-length vector specifying a
threshold for each dimension, which must all be met for the algorithm to
stop.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_burst_size">burst_size</code></td>
<td>
<p>The size of each burst. 10 is recommended for the
<code>mergesplit</code> backend and 50 for the <code>flip</code> backend. Can also provide
burst schedule function which takes the current iteration (an integer)
and returns the desired burst size. This can be a random function.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_max_bursts">max_bursts</code></td>
<td>
<p>The maximum number of bursts to run before returning.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_maximize">maximize</code></td>
<td>
<p>If <code>TRUE</code>, try to maximize the score; otherwise, try to
minimize it. When <code>score_fn</code> returns a row vector per plan, <code>maximize</code> can
be an equal-length vector specifying whether each dimension should be
maximized or minimized.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_init_plan">init_plan</code></td>
<td>
<p>The initial state of the map. If not provided, will default to
the reference map of the <code>map</code> object, or if none exists, will sample
a random initial state using <code><a href="#topic+redist_smc">redist_smc()</a></code>. You can also request
a random initial state by setting <code>init_plan="sample"</code>.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_counties">counties</code></td>
<td>
<p>A vector containing county (or other administrative or
geographic unit) labels for each unit, which may be integers ranging from 1
to the number of counties, or a factor or character vector.  If provided, the
algorithm will only generate maps which split up to <code>ndists-1</code> counties.
If no county-split constraint is desired, this parameter should be left blank.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_constraints">constraints</code></td>
<td>
<p>A <code>redist_constr</code> with Gibbs constraints.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_compactness">compactness</code></td>
<td>
<p>Controls the compactness of the generated districts, with
higher values preferring more compact districts. Must be non-negative. See
<code><a href="#topic+redist_mergesplit">redist_mergesplit</a></code> for more information.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_adapt_k_thresh">adapt_k_thresh</code></td>
<td>
<p>The threshold value used in the heuristic to select a
value <code>k_i</code> for each splitting iteration.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_reversible">reversible</code></td>
<td>
<p>If <code>FALSE</code> and <code>backend="mergesplit"</code>, the Markov chain
used will not be reversible. This may speed up optimization.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_fixed_k">fixed_k</code></td>
<td>
<p>If not <code>NULL</code>, will be used to set the <code>k</code> parameter for the
<code>mergesplit</code> backend. If e.g. <code>k=1</code> then the best edge in each spanning
tree will be used.  Lower values may speed up optimization at the
cost of the Markov chain no longer targeting a known distribution.
Recommended only in conjunction with <code>reversible=FALSE</code>.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_return_all">return_all</code></td>
<td>
<p>Whether to return all the burst results or just the best
one (generally, the Pareto frontier). Recommended for monitoring purposes.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_thin">thin</code></td>
<td>
<p>Save every <code>thin</code>-th sample. Defaults to no thinning (1). Ignored
if <code>return_all=TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_backend">backend</code></td>
<td>
<p>the MCMC algorithm to use within each burst, either
&quot;mergesplit&quot; or &quot;flip&quot;.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_flip_lambda">flip_lambda</code></td>
<td>
<p>The parameter determining the number of swaps to attempt each iteration of flip mcmc.
The number of swaps each iteration is equal to Pois(lambda) + 1. The default is 0.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_flip_eprob">flip_eprob</code></td>
<td>
<p>The probability of keeping an edge connected in flip mcmc. The default is 0.05.</p>
</td></tr>
<tr><td><code id="redist_shortburst_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out intermediate information while sampling.
Recommended for monitoring purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>redist_plans</code> object containing the final best plan
(or the best plans after each burst, if <code>return_all=TRUE</code>.
</p>


<h3>References</h3>

<p>Cannon, S., Goldbloom-Helzner, A., Gupta, V., Matthews, J. N., &amp; Suwal, B.
(2020). Voting Rights, Markov Chains, and Optimization by Short Bursts. arXiv
preprint arXiv:2011.02288.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iowa)

iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.01)
redist_shortburst(iowa_map, scorer_frac_kept(iowa_map), max_bursts = 50)
redist_shortburst(iowa_map, ~ 1 - scorer_frac_kept(iowa_map)(.), max_bursts = 50)


</code></pre>

<hr>
<h2 id='redist_smc'>SMC Redistricting Sampler (McCartan and Imai 2023)</h2><span id='topic+redist_smc'></span>

<h3>Description</h3>

<p><code>redist_smc</code> uses a Sequential Monte Carlo algorithm (McCartan and Imai 2023)
to generate representative samples of congressional or legislative
redistricting plans according to contiguity, population, compactness, and
administrative boundary constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist_smc(
  map,
  nsims,
  counties = NULL,
  compactness = 1,
  constraints = list(),
  resample = TRUE,
  runs = 1L,
  ncores = 0L,
  init_particles = NULL,
  n_steps = NULL,
  adapt_k_thresh = 0.99,
  seq_alpha = 0.5,
  truncate = (compactness != 1),
  trunc_fn = redist_quantile_trunc,
  pop_temper = 0,
  final_infl = 1,
  est_label_mult = 1,
  ref_name = NULL,
  verbose = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_smc_+3A_map">map</code></td>
<td>
<p>A <code><a href="#topic+redist_map">redist_map()</a></code> object.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_nsims">nsims</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_counties">counties</code></td>
<td>
<p>A vector containing county (or other administrative or
geographic unit) labels for each unit, which may be integers ranging from 1
to the number of counties, or a factor or character vector.  If provided,
the algorithm will only generate maps which split up to <code>ndists-1</code>
counties. Even there are fewer counties than <code>ndists - 1</code>, the spanning
trees will change the results of the simulations. There is no strength
parameter associated with this constraint. To adjust the number of county
splits further, or to constrain a second type of administrative split,
consider using <code>add_constr_splits()</code>, <code>add_constr_multisplits()</code>, and
<code>add_constr_total_splits()</code>.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_compactness">compactness</code></td>
<td>
<p>Controls the compactness of the generated districts, with
higher values preferring more compact districts. Must be nonnegative. See
the 'Details' section for more information, and computational
considerations.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_constraints">constraints</code></td>
<td>
<p>A <code><a href="#topic+redist_constr">redist_constr()</a></code> object or a list containing
information on sampling constraints. See <a href="#topic+constraints">constraints</a> for more information.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_resample">resample</code></td>
<td>
<p>Whether to perform a final resampling step so that the
generated plans can be used immediately.  Set this to <code>FALSE</code> to
perform direct importance sampling estimates, or to adjust the weights
manually.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_runs">runs</code></td>
<td>
<p>How many independent parallel runs to conduct. Each run will
have <code>nsims</code> simulations. Multiple runs allows for estimation of simulation
standard errors. Output will only be shown for the first run. For
compatibility with MCMC methods, runs are identified with the <code>chain</code>
column in the output.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_ncores">ncores</code></td>
<td>
<p>How many cores to use to parallelize plan generation within each
run. The default, 0, will use the number of available cores on the machine
as long as <code>nsims</code> and the number of units is large enough. If <code>runs&gt;1</code>
you will need to set this manually. If more than one core is used, the
sampler output will not be fully reproducible with <code>set.seed()</code>. If full
reproducibility is desired, set <code>ncores=1</code>.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_init_particles">init_particles</code></td>
<td>
<p>A matrix of partial plans to begin sampling from. For
advanced use only.  The matrix must have <code>nsims</code> columns and a row for
every precinct. It is important to ensure that the existing districts meet
contiguity and population constraints, or there may be major issues when
sampling.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_n_steps">n_steps</code></td>
<td>
<p>How many steps to run the SMC algorithm for.
Each step splits off a new district. Defaults to all remaining districts.
If fewer than the number of remaining splits, reference plans are disabled.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_adapt_k_thresh">adapt_k_thresh</code></td>
<td>
<p>The threshold value used in the heuristic to select a
value <code>k_i</code> for each splitting iteration. Higher values are more accurate
but may require more computation. Set to 1 for the most conservative
sampling. Must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_seq_alpha">seq_alpha</code></td>
<td>
<p>The amount to adjust the weights by at each resampling step;
higher values prefer exploitation, while lower values prefer exploration.
Must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_truncate">truncate</code></td>
<td>
<p>Whether to truncate the importance sampling weights at the
final step by <code>trunc_fn</code>.  Recommended if <code>compactness</code> is not 1.
Truncation only applied if <code>resample=TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_trunc_fn">trunc_fn</code></td>
<td>
<p>A function which takes in a vector of weights and returns a
truncated vector. If the <a href="loo.html#topic+loo">loo</a> package is installed (strongly
recommended), will default to Pareto-smoothed Importance Sampling (PSIS)
rather than naive truncation.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_pop_temper">pop_temper</code></td>
<td>
<p>The strength of the automatic population tempering. Try
values of 0.01-0.05 to start if the algorithm gets stuck on the final few
splits.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_final_infl">final_infl</code></td>
<td>
<p>A multiplier for the population constraint on the final
iteration. Used to loosen the constraint when the sampler is getting stuck
on the final split. <code>pop_temper</code> should be tried first, since using
<code>final_infl</code> will actually change the target distribution.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_est_label_mult">est_label_mult</code></td>
<td>
<p>A multiplier for the number of importance samples to
use in estimating the number of ways to sequentially label the districts.
Lower values increase speed at the cost of accuracy.  Only applied when
there are more than 13 districts.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_ref_name">ref_name</code></td>
<td>
<p>a name for the existing plan, which will be added as a
reference plan, or <code>FALSE</code> to not include the initial plan in the
output. Defaults to the column name of the existing plan.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out intermediate information while sampling.
Recommended.</p>
</td></tr>
<tr><td><code id="redist_smc_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress all diagnostic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws samples from a specific target measure controlled by
the <code>map</code>, <code>compactness</code>, and <code>constraints</code> parameters.
</p>
<p>Key to ensuring good performance is monitoring the efficiency of the resampling
process at each SMC stage.  Unless <code>silent=FALSE</code>, this function will print
out the effective sample size of each resampling step to allow the user to
monitor the efficiency.  If <code>verbose=TRUE</code> the function will also print
out information on the <code class="reqn">k_i</code> values automatically chosen and the
acceptance rate (based on the population constraint) at each step.
Users should also check diagnostics of the sample by running
<code>summary.redist_plans()</code>.
</p>
<p>Higher values of <code>compactness</code> sample more compact districts;
setting this parameter to 1 is computationally efficient and generates nicely
compact districts.  Values of other than 1 may lead to highly variable
importance sampling weights.  In these cases, these weights are by default
truncated using <code><a href="#topic+redist_quantile_trunc">redist_quantile_trunc()</a></code> to stabilize the resulting
estimates, but if truncation is used, a specific truncation function should
probably be chosen by the user.
</p>


<h3>Value</h3>

<p><code>redist_smc</code> returns a <a href="#topic+redist_plans">redist_plans</a> object containing the simulated
plans.
</p>


<h3>References</h3>

<p>McCartan, C., &amp; Imai, K. (2023). Sequential Monte Carlo for Sampling
Balanced and Compact Redistricting Plans. <em>Annals of Applied Statistics</em> 17(4).
Available at <a href="https://doi.org/10.1214/23-AOAS1763">doi:10.1214/23-AOAS1763</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fl25)

fl_map &lt;- redist_map(fl25, ndists = 3, pop_tol = 0.1)

sampled_basic &lt;- redist_smc(fl_map, 5000)

constr &lt;- redist_constr(fl_map)
constr &lt;- add_constr_incumbency(constr, strength = 100, incumbents = c(3, 6, 25))
sampled_constr &lt;- redist_smc(fl_map, 5000, constraints = constr)

# Multiple parallel independent runs
redist_smc(fl_map, 1000, runs = 2)

# One run with multiple cores
redist_smc(fl_map, 1000, ncores = 2)


</code></pre>

<hr>
<h2 id='redist.adjacency'>Adjacency List functionality for redist</h2><span id='topic+redist.adjacency'></span>

<h3>Description</h3>

<p>Creates an adjacency list that is zero indexed with no skips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.adjacency(shp, plan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.adjacency_+3A_shp">shp</code></td>
<td>
<p>A SpatialPolygonsDataFrame or sf object. Required.</p>
</td></tr>
<tr><td><code id="redist.adjacency_+3A_plan">plan</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjacency list
</p>

<hr>
<h2 id='redist.calc.frontier.size'>Calculate Frontier Size</h2><span id='topic+redist.calc.frontier.size'></span>

<h3>Description</h3>

<p>Calculate Frontier Size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.calc.frontier.size(ordered_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.calc.frontier.size_+3A_ordered_path">ordered_path</code></td>
<td>
<p>path to ordered path created by redist.prep.enumpart</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List, four objects
</p>

<ul>
<li> <p><code>max</code> numeric, maximum frontier size
</p>
</li>
<li> <p><code>average</code> numeric, average frontier size
</p>
</li>
<li> <p><code>average_sq</code> numeric, average((frontier size)^2)
</p>
</li>
<li> <p><code>sequence</code> numeric vector, lists out all sizes for every frontier
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fl25)
adj &lt;- redist.adjacency(fl25)
redist.prep.enumpart(adj, "unordered", "ordered")
redist.calc.frontier.size("ordered")

## End(Not run)
</code></pre>

<hr>
<h2 id='redist.coarsen.adjacency'>Coarsen Adjacency List</h2><span id='topic+redist.coarsen.adjacency'></span>

<h3>Description</h3>

<p>Coarsen Adjacency List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.coarsen.adjacency(adj, groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.coarsen.adjacency_+3A_adj">adj</code></td>
<td>
<p>A zero-indexed adjacency list. Required.</p>
</td></tr>
<tr><td><code id="redist.coarsen.adjacency_+3A_groups">groups</code></td>
<td>
<p>integer vector of elements of adjacency to group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjacency list coarsened
</p>

<hr>
<h2 id='redist.combine.mpi'>Combine successive runs of <code>redist.mcmc.mpi</code></h2><span id='topic+redist.combine.mpi'></span>

<h3>Description</h3>

<p><code>redist.combine.mpi</code> is used to combine successive runs of
<code>redist.mcmc.mpi</code> into a single data object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.combine.mpi(savename, nloop, nthin, tempadj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.combine.mpi_+3A_savename">savename</code></td>
<td>
<p>The name (without the loop or <code>.RData</code> suffix)
of the saved simulations.</p>
</td></tr>
<tr><td><code id="redist.combine.mpi_+3A_nloop">nloop</code></td>
<td>
<p>The number of loops being combined.</p>
</td></tr>
<tr><td><code id="redist.combine.mpi_+3A_nthin">nthin</code></td>
<td>
<p>How much to thin the simulations being combined.</p>
</td></tr>
<tr><td><code id="redist.combine.mpi_+3A_tempadj">tempadj</code></td>
<td>
<p>The temperature adjacency object saved by
<code>redist.mcmc.mpi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to combine multiple successive runs of
<code>redist.mcmc.mpi</code> into a single <code>redist</code> object for analysis.
</p>


<h3>Value</h3>

<p><code>redist.combine.mpi</code> returns an object of class &quot;redist&quot;.
The object <code>redist</code> is a list that contains the following components (the
inclusion of some components is dependent on whether tempering
techniques are used):
</p>
<table>
<tr><td><code>plans</code></td>
<td>
<p>Matrix of congressional district assignments generated by the
algorithm. Each row corresponds to a geographic unit, and each column
corresponds to a simulation.</p>
</td></tr>
<tr><td><code>distance_parity</code></td>
<td>
<p>Vector containing the maximum distance from parity for
a particular simulated redistricting plan.</p>
</td></tr>
<tr><td><code>mhdecisions</code></td>
<td>
<p>A vector specifying whether a proposed redistricting plan
was accepted (1) or rejected (0) in a given iteration.</p>
</td></tr>
<tr><td><code>mhprob</code></td>
<td>
<p>A vector containing the Metropolis-Hastings acceptance
probability for each iteration of the algorithm.</p>
</td></tr>
<tr><td><code>pparam</code></td>
<td>
<p>A vector containing the draw of the <code>p</code> parameter for each
simulation, which dictates the number of swaps attempted.</p>
</td></tr>
<tr><td><code>constraint_pop</code></td>
<td>
<p>A vector containing the value of the population
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_compact</code></td>
<td>
<p>A vector containing the value of the compactness
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_vra</code></td>
<td>
<p>A vector containing the value of the
vra constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_similar</code></td>
<td>
<p>A vector containing the value of the similarity
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_qps</code></td>
<td>
<p>A vector containing the value of the
QPS constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>beta_sequence</code></td>
<td>
<p>A vector containing the value of beta for each iteration
of the algorithm. Returned when tempering is being used.</p>
</td></tr>
<tr><td><code>mhdecisions_beta</code></td>
<td>
<p>A vector specifying whether a proposed beta value was
accepted (1) or rejected (0) in a given iteration of the algorithm. Returned
when tempering is being used.</p>
</td></tr>
<tr><td><code>mhprob_beta</code></td>
<td>
<p>A vector containing the Metropolis-Hastings acceptance
probability for each iteration of the algorithm. Returned when tempering
is being used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander Tarr.
(2016) &quot;A New Automated Redistricting Simulator Using Markov Chain Monte
Carlo.&quot; Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Cannot run on machines without Rmpi
data(fl25)
data(fl25_enum)
data(fl25_adj)

## Code to run the simulations in Figure 4 in Fifield, Higgins, Imai and
## Tarr (2015)

## Get an initial partition
init_plan &lt;- fl25_enum$plans[, 5118]

## Run the algorithm
redist.mcmc.mpi(adj = fl25_adj, total_pop = fl25$pop,
    init_plan = init_plan, nsims = 10000, nloops = 2, savename = "test")
out &lt;- redist.combine.mpi(savename = "test", nloop = 2,
    nthin = 10, tempadj = tempAdjMat)

## End(Not run)
</code></pre>

<hr>
<h2 id='redist.constraint.helper'>Create Constraints for SMC</h2><span id='topic+redist.constraint.helper'></span>

<h3>Description</h3>

<p>Create Constraints for SMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.constraint.helper(
  constraints = "vra",
  tgt_min = 0.55,
  group_pop,
  total_pop,
  ndists,
  nmmd,
  strength_vra = 2500,
  pow_vra = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.constraint.helper_+3A_constraints">constraints</code></td>
<td>
<p>Vector of constraints to include. Currently only 'vra' implemented.</p>
</td></tr>
<tr><td><code id="redist.constraint.helper_+3A_tgt_min">tgt_min</code></td>
<td>
<p>Defaults to 0.55. If 'vra' included, the minority percent to encourage in each district.</p>
</td></tr>
<tr><td><code id="redist.constraint.helper_+3A_group_pop">group_pop</code></td>
<td>
<p>A vector of populations for some subgroup of interest.</p>
</td></tr>
<tr><td><code id="redist.constraint.helper_+3A_total_pop">total_pop</code></td>
<td>
<p>A vector containing the populations of each geographic unit.</p>
</td></tr>
<tr><td><code id="redist.constraint.helper_+3A_ndists">ndists</code></td>
<td>
<p>The total number of districts.</p>
</td></tr>
<tr><td><code id="redist.constraint.helper_+3A_nmmd">nmmd</code></td>
<td>
<p>The number of majority minority districts to target for 'vra' constraint</p>
</td></tr>
<tr><td><code id="redist.constraint.helper_+3A_strength_vra">strength_vra</code></td>
<td>
<p>The strength of the 'vra' constraint. Defaults to 2500.</p>
</td></tr>
<tr><td><code id="redist.constraint.helper_+3A_pow_vra">pow_vra</code></td>
<td>
<p>The exponent for the 'vra' constraint. Defaults to 1.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of lists for each constraint selected
</p>

<hr>
<h2 id='redist.county.id'>Create County IDs</h2><span id='topic+redist.county.id'></span>

<h3>Description</h3>

<p>Create County IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.county.id(counties)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.county.id_+3A_counties">counties</code></td>
<td>
<p>vector of counties, required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with an ID that corresponds from 1:n counties
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
counties &lt;- sample(c(rep("a", 20), rep("b", 5)))
redist.county.id(counties)

</code></pre>

<hr>
<h2 id='redist.county.relabel'>Relabel Discontinuous Counties</h2><span id='topic+redist.county.relabel'></span>

<h3>Description</h3>

<p>Relabel Discontinuous Counties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.county.relabel(adj, counties, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.county.relabel_+3A_adj">adj</code></td>
<td>
<p>adjacency list</p>
</td></tr>
<tr><td><code id="redist.county.relabel_+3A_counties">counties</code></td>
<td>
<p>character vector of county names</p>
</td></tr>
<tr><td><code id="redist.county.relabel_+3A_simplify">simplify</code></td>
<td>
<p>boolean - TRUE returns a numeric vector of ids, while FALSE
appends a number when there are multiple connected components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of county names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
data(fl25)
data(fl25_adj)
counties &lt;- sample(c(rep("a", 20), rep("b", 5)))
redist.county.relabel(fl25_adj, counties)

</code></pre>

<hr>
<h2 id='redist.crsg'>Redistricting via Compact Random Seed and Grow Algorithm</h2><span id='topic+redist.crsg'></span>

<h3>Description</h3>

<p><code>redist.crsg</code> generates redistricting plans using a random seed a grow
algorithm.  This is the compact districting algorithm described in Chen and
Rodden (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.crsg(
  adj,
  total_pop,
  shp,
  ndists,
  pop_tol,
  verbose = TRUE,
  maxiter = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.crsg_+3A_adj">adj</code></td>
<td>
<p>List of length N, where N is the number of precincts.
Each list element is an integer vector indicating which precincts that precinct
is adjacent to.  It is assumed that precinct numbers start at 0.</p>
</td></tr>
<tr><td><code id="redist.crsg_+3A_total_pop">total_pop</code></td>
<td>
<p>numeric vector of length N, where N is the number of precincts.
Each element lists the population total of the corresponding precinct, and is
used to enforce pop_tol constraints.</p>
</td></tr>
<tr><td><code id="redist.crsg_+3A_shp">shp</code></td>
<td>
<p>An sf dataframe to compute area and centroids with.</p>
</td></tr>
<tr><td><code id="redist.crsg_+3A_ndists">ndists</code></td>
<td>
<p>integer, the number of districts we want to partition the
precincts into.</p>
</td></tr>
<tr><td><code id="redist.crsg_+3A_pop_tol">pop_tol</code></td>
<td>
<p>numeric, indicating how close district population targets have
to be to the target population before algorithm converges.  pop_tol=0.05 for
example means that all districts must be between 0.95 and 1.05 times the size
of target.pop in population size.</p>
</td></tr>
<tr><td><code id="redist.crsg_+3A_verbose">verbose</code></td>
<td>
<p>boolean, indicating whether the time to run the algorithm is
printed.</p>
</td></tr>
<tr><td><code id="redist.crsg_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, indicating maximum number of iterations to attempt
before convergence to population constraint fails.  If it fails once, it will
use a different set of start values and try again.  If it fails again,
redist.rsg() returns an object of all NAs, indicating that use of more
iterations may be advised. Default is 5000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, containing three objects containing the completed redistricting
plan.
</p>

<ul>
<li> <p><code>plan</code>:  A vector of length N, indicating the
district membership of each precinct.
</p>
</li>
<li> <p><code>district_list</code>  A list of length Ndistrict.  Each list contains a
vector of the precincts in the respective district.
</p>
</li>
<li> <p><code>district_pop</code>  A vector of length Ndistrict, containing the
population totals of the respective districts.
</p>
</li></ul>



<h3>References</h3>

<p>Jowei Chen and Jonathan Rodden (2013) &ldquo;Unintentional
Gerrymandering: Political Geography and Electoral Bias in Legislatures.&rdquo;
Quarterly Journal of Political Science. 8(3): 239-269.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("fl25")
adj &lt;- redist.adjacency(fl25)
redist.crsg(adj = adj, total_pop = fl25$pop, shp = fl25, ndists = 2, pop_tol = .1)

</code></pre>

<hr>
<h2 id='redist.diagplot'>Diagnostic plotting functionality for MCMC redistricting.</h2><span id='topic+redist.diagplot'></span>

<h3>Description</h3>

<p><code>redist.diagplot</code> generates several common MCMC diagnostic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.diagplot(sumstat,
plot = c("trace", "autocorr", "densplot", "mean", "gelmanrubin"),
logit = FALSE, savename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.diagplot_+3A_sumstat">sumstat</code></td>
<td>
<p>A vector, list, <code>mcmc</code> or <code>mcmc.list</code> object
containing a summary statistic of choice.</p>
</td></tr>
<tr><td><code id="redist.diagplot_+3A_plot">plot</code></td>
<td>
<p>The type of diagnostic plot to generate: one of &quot;trace&quot;,
&quot;autocorr&quot;, &quot;densplot&quot;, &quot;mean&quot;, &quot;gelmanrubin&quot;. If <code>plot = "gelmanrubin"</code>,
the input <code>sumstat</code> must be of class <code>mcmc.list</code> or <code>list</code>.</p>
</td></tr>
<tr><td><code id="redist.diagplot_+3A_logit">logit</code></td>
<td>
<p>Flag for whether to apply the logistic transformation for the
summary statistic. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="redist.diagplot_+3A_savename">savename</code></td>
<td>
<p>Filename to save the plot. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to generate several standard diagnostic
plots from the MCMC literature, as implemented by Plummer et. al (2006).
Diagnostic plots implemented include trace plots, autocorrelation plots,
density plots, running means, and Gelman-Rubin convergence diagnostics
(Gelman &amp; Rubin 1992).
</p>


<h3>Value</h3>

<p>Returns a plot of file type <code>.pdf</code>.
</p>


<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander
Tarr. (2016) &quot;A New Automated Redistricting Simulator Using Markov Chain Monte
Carlo.&quot; Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>
<p>Gelman, Andrew and Donald Rubin. (1992) &quot;Inference from iterative simulations
using multiple sequences (with discussion).&quot; Statistical Science.
</p>
<p>Plummer, Martin, Nicky Best, Kate Cowles and Karen Vines. (2006) &quot;CODA:
Convergence Diagnosis and Output Analysis for MCMC.&quot; R News.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fl25)
data(fl25_enum)
data(fl25_adj)

## Get an initial partition
init_plan &lt;- fl25_enum$plans[, 5118]
fl25$init_plan &lt;- init_plan

## 25 precinct, three districts - no pop constraint ##
fl_map &lt;- redist_map(fl25, existing_plan = 'init_plan', adj = fl25_adj)
alg_253 &lt;- redist_flip(fl_map, nsims = 10000)

## Get Republican Dissimilarity Index from simulations
rep_dmi_253 &lt;- redistmetrics::seg_dissim(alg_253, fl25, mccain, pop) |&gt;
    redistmetrics::by_plan(ndists = 3)

## Generate diagnostic plots
redist.diagplot(rep_dmi_253, plot = "trace")
redist.diagplot(rep_dmi_253, plot = "autocorr")
redist.diagplot(rep_dmi_253, plot = "densplot")
redist.diagplot(rep_dmi_253, plot = "mean")

## Gelman Rubin needs two chains, so we run a second
alg_253_2 &lt;- redist_flip(fl_map, nsims = 10000)

rep_dmi_253_2 &lt;- redistmetrics::seg_dissim(alg_253_2, fl25, mccain, pop) |&gt;
    redistmetrics::by_plan(ndists = 3)

## Make a list out of the objects:
rep_dmi_253_list &lt;- list(rep_dmi_253, rep_dmi_253_2)

## Generate Gelman Rubin diagnostic plot
redist.diagplot(sumstat = rep_dmi_253_list, plot = "gelmanrubin")


</code></pre>

<hr>
<h2 id='redist.dist.pop.overlap'>Compare the Population Overlap Across Plans at the District Level</h2><span id='topic+redist.dist.pop.overlap'></span>

<h3>Description</h3>

<p>This implements Crespin's 2005 measure of district continuity, as applied to
the geographies represented by a plan, typically precincts or voting districts.
This implementation assumes none of the precincts in plan_old or plan_new are
split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.dist.pop.overlap(plan_old, plan_new, total_pop, normalize_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.dist.pop.overlap_+3A_plan_old">plan_old</code></td>
<td>
<p>The reference or original plan to compare against</p>
</td></tr>
<tr><td><code id="redist.dist.pop.overlap_+3A_plan_new">plan_new</code></td>
<td>
<p>The new plan to compare to the reference plan</p>
</td></tr>
<tr><td><code id="redist.dist.pop.overlap_+3A_total_pop">total_pop</code></td>
<td>
<p>The total population by precinct This can also take a redist_map
object and will use the population in that object. If nothing is provided, it weights
all entries in plan equally.</p>
</td></tr>
<tr><td><code id="redist.dist.pop.overlap_+3A_normalize_rows">normalize_rows</code></td>
<td>
<p>Default TRUE. Normalize populations by row. If FALSE,
normalizes by column. If NULL, does not normalize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with length(unique(plan_old)) rows and length(unique(plan_new)) columns
</p>


<h3>References</h3>

<p>&quot;Using Geographic Information Systems to Measure District Change, 2000-02&quot;,
Michael Crespin, Political Analysis (2005) 13(3): 253-260
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
data(iowa)
iowa_map &lt;- redist_map(iowa, total_pop = pop, pop_tol = 0.01, ndists = 4)
plans &lt;- redist_smc(iowa_map, 2)
plans_mat &lt;- get_plans_matrix(plans)
ov &lt;- redist.dist.pop.overlap(plans_mat[, 1], plans_mat[, 2], iowa_map)
round(ov, 2)

ov_col &lt;- redist.dist.pop.overlap(plans_mat[, 1], plans_mat[, 2], iowa_map, normalize_rows = FALSE)
round(ov_col, 2)

ov_un_norm &lt;- redist.dist.pop.overlap(plans_mat[, 1], plans_mat[, 2],
    iowa_map, normalize_rows = NULL)
round(ov_un_norm, 2)

iowa_map_5 &lt;- iowa_map &lt;- redist_map(iowa, total_pop = pop, pop_tol = 0.01, ndists = 5)
plan_5 &lt;- get_plans_matrix(redist_smc(iowa_map_5, 1))
ov4_5 &lt;- redist.dist.pop.overlap(plans_mat[, 1], plan_5, iowa_map)
round(ov4_5, 2)

</code></pre>

<hr>
<h2 id='redist.district.splits'>Counts the Number of Counties within a District</h2><span id='topic+redist.district.splits'></span>

<h3>Description</h3>

<p>Counts the total number of counties that are found within a district.
This does not subtract out the number of counties that are found completely
within a district.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.district.splits(plans, counties)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.district.splits_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
<tr><td><code id="redist.district.splits_+3A_counties">counties</code></td>
<td>
<p>A vector of county names or county ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer matrix where each district is a
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
ia &lt;- redist_map(iowa, existing_plan = cd_2010, total_pop = pop, pop_tol = 0.01)
plans &lt;- redist_smc(ia, 50, silent = TRUE)
#old redist.district.splits(plans, ia$region)
splits_count(plans, ia, region)
</code></pre>

<hr>
<h2 id='redist.enumpart'>Enumerate All Parititions (Fifield et al. 2020)</h2><span id='topic+redist.enumpart'></span>

<h3>Description</h3>

<p>Single function for standard enumeration analysis, using ZDD methodology
(Fifield, Imai, Kawahara, and Kenny 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.enumpart(
  adj,
  unordered_path,
  ordered_path,
  out_path,
  ndists = 2,
  all = TRUE,
  n = NULL,
  weight_path = NULL,
  lower = NULL,
  upper = NULL,
  init = FALSE,
  read = TRUE,
  total_pop = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.enumpart_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list.</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_unordered_path">unordered_path</code></td>
<td>
<p>valid path to output the unordered adjacency map to</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_ordered_path">ordered_path</code></td>
<td>
<p>valid path to output the ordered adjacency map to</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_out_path">out_path</code></td>
<td>
<p>Valid path to output the enumerated districts</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_ndists">ndists</code></td>
<td>
<p>number of districts to enumerate</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_all">all</code></td>
<td>
<p>boolean. TRUE outputs all districts. FALSE samples n districts.</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_n">n</code></td>
<td>
<p>integer. Number of districts to output if all is FALSE. Returns
districts selected from uniform random distribution.</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_weight_path">weight_path</code></td>
<td>
<p>A path (not including &quot;.dat&quot;) to a space-delimited file containing a vector of
vertex weights, to be used along with <code>lower</code> and <code>upper</code>.</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_lower">lower</code></td>
<td>
<p>A lower bound on each partition's total weight, implemented by rejection sampling.</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_upper">upper</code></td>
<td>
<p>An upper bound on each partition's total weight.</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_init">init</code></td>
<td>
<p>Runs redist.init.enumpart. Defaults to false. Should be run on first use.</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_read">read</code></td>
<td>
<p>boolean. Defaults to TRUE. reads</p>
</td></tr>
<tr><td><code id="redist.enumpart_+3A_total_pop">total_pop</code></td>
<td>
<p>the vector of precinct populations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with entries district_membership and parity.
</p>


<h3>References</h3>

<p>Fifield, B., Imai, K., Kawahara, J., &amp; Kenny, C. T. (2020). The essential
role of empirical validation in legislative redistricting simulation.
<em>Statistics and Public Policy</em>, 7(1), 52-68.
</p>

<hr>
<h2 id='redist.find.target'>Find Majority Minority Remainder</h2><span id='topic+redist.find.target'></span>

<h3>Description</h3>

<p>Given a percent goal for majority minority districts, this computes the average
value of minority in non-majority minority districts. This value is &quot;tgt_other&quot;
in <code>redist_flip</code> and <code>redist_smc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.find.target(tgt_min, group_pop, total_pop, ndists, nmmd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.find.target_+3A_tgt_min">tgt_min</code></td>
<td>
<p>target group population for majority minority district</p>
</td></tr>
<tr><td><code id="redist.find.target_+3A_group_pop">group_pop</code></td>
<td>
<p>A vector of populations for some subgroup of interest.</p>
</td></tr>
<tr><td><code id="redist.find.target_+3A_total_pop">total_pop</code></td>
<td>
<p>A vector containing the populations of each geographic unit.</p>
</td></tr>
<tr><td><code id="redist.find.target_+3A_ndists">ndists</code></td>
<td>
<p>The number of congressional districts.</p>
</td></tr>
<tr><td><code id="redist.find.target_+3A_nmmd">nmmd</code></td>
<td>
<p>The number of majority minority districts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value to target
</p>

<hr>
<h2 id='redist.findparams'>Run parameter testing for <code>redist_flip</code></h2><span id='topic+redist.findparams'></span>

<h3>Description</h3>

<p><code>redist.findparams</code> is used to find optimal parameter values of
<code>redist_flip</code> for a given map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.findparams(
  map,
  nsims,
  init_plan = NULL,
  adapt_lambda = FALSE,
  adapt_eprob = FALSE,
  params,
  ssdmat = NULL,
  group_pop = NULL,
  counties = NULL,
  nstartval_store = 1,
  maxdist_startval = 100,
  maxiterrsg = 5000,
  report_all = TRUE,
  parallel = FALSE,
  ncores = NULL,
  log = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.findparams_+3A_map">map</code></td>
<td>
<p>A <code><a href="#topic+redist_map">redist_map</a></code> object.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_nsims">nsims</code></td>
<td>
<p>The number of simulations run before a save point.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_init_plan">init_plan</code></td>
<td>
<p>A vector containing the congressional district labels
of each geographic unit. The default is <code>NULL</code>. If not provided, random
and contiguous congressional district assignments will be generated using <code>redist.rsg</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_adapt_lambda">adapt_lambda</code></td>
<td>
<p>Whether to adaptively tune the lambda parameter so that the Metropolis-Hastings
acceptance probability falls between 20% and 40%. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_adapt_eprob">adapt_eprob</code></td>
<td>
<p>Whether to adaptively tune the edgecut probability parameter so that the
Metropolis-Hastings acceptance probability falls between 20% and 40%. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_params">params</code></td>
<td>
<p>A matrix of parameter values to test, such as the output of
<code>expand.grid</code>. Parameters accepted for <code>params</code> include <code>eprob</code>,
<code>lambda</code>, <code>pop_tol</code>, <code>beta</code>, and <code>constraint</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_ssdmat">ssdmat</code></td>
<td>
<p>A matrix of squared distances between geographic
units. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_group_pop">group_pop</code></td>
<td>
<p>A vector of populations for some sub-group of
interest. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_counties">counties</code></td>
<td>
<p>A vector of county membership assignments. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_nstartval_store">nstartval_store</code></td>
<td>
<p>The number of maps to sample from the preprocessing chain
for use as starting values in future simulations. Default is 1.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_maxdist_startval">maxdist_startval</code></td>
<td>
<p>The maximum distance from the starting map that
sampled maps should be. Default is 100 (no restriction).</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_maxiterrsg">maxiterrsg</code></td>
<td>
<p>Maximum number of iterations for random seed-and-grow
algorithm to generate starting values. Default is 5000.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_report_all">report_all</code></td>
<td>
<p>Whether to report all summary statistics for each set of
parameter values. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_parallel">parallel</code></td>
<td>
<p>Whether to run separate parameter settings in parallel.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_ncores">ncores</code></td>
<td>
<p>Number of parallel tasks to run, declared outside of the
function. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_log">log</code></td>
<td>
<p>Whether to open a log to track progress for each parameter combination
being tested. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redist.findparams_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print additional information about the tests.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to test multiple parameter settings of
<code>redist_flip</code> in preparation for a longer run for analysis.
</p>


<h3>Value</h3>

<p><code>redist.findparams</code> returns a print-out of summary statistics
about each parameter setting.
</p>


<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander
Tarr. (2016) &quot;A New Automated Redistricting Simulator Using Markov Chain Monte
Carlo.&quot; Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fl25)
data(fl25_enum)
data(fl25_adj)

## Get an initial partition
init_plan &lt;- fl25_enum$plans[, 5118]

params &lt;- expand.grid(eprob = c(.01, .05, .1))

# Make map
map_fl &lt;- redist_map(fl25, ndists = 3, pop_tol = 0.2)
## Run the algorithm
redist.findparams(map_fl,
    init_plan = init_plan, nsims = 10000, params = params)

</code></pre>

<hr>
<h2 id='redist.init.enumpart'>Initialize enumpart</h2><span id='topic+redist.init.enumpart'></span>

<h3>Description</h3>

<p>This ensures that the enumerate partitions programs is prepared to run.
This must be run once per install of the redist package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.init.enumpart()
</code></pre>


<h3>Value</h3>

<p>0 on success
</p>


<h3>References</h3>

<p>Benjamin Fifield, Kosuke Imai, Jun Kawahara, and Christopher T Kenny.
&quot;The Essential Role of Empirical Validation in Legislative Redistricting Simulation.&quot;
Forthcoming, Statistics and Public Policy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
redist.init.enumpart()

## End(Not run)
</code></pre>

<hr>
<h2 id='redist.ipw'>Inverse probability reweighting for MCMC Redistricting</h2><span id='topic+redist.ipw'></span>

<h3>Description</h3>

<p><code>redist.ipw</code> properly weights and resamples simulated redistricting plans
so that the set of simulated plans resemble a random sample from the
underlying distribution. <code>redist.ipw</code> is used to correct the sample when
population parity, geographic compactness, or other constraints are
implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.ipw(
  plans,
  resampleconstraint = c("pop_dev", "edges_removed", "segregation", "status_quo"),
  targetbeta,
  targetpop = NULL,
  temper = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.ipw_+3A_plans">plans</code></td>
<td>
<p>An object of class <code>redist_plans</code> from <code>redist_flip()</code>.</p>
</td></tr>
<tr><td><code id="redist.ipw_+3A_resampleconstraint">resampleconstraint</code></td>
<td>
<p>The constraint implemented in the simulations: one
of &quot;pop&quot;, &quot;compact&quot;, &quot;segregation&quot;, or &quot;similar&quot;.</p>
</td></tr>
<tr><td><code id="redist.ipw_+3A_targetbeta">targetbeta</code></td>
<td>
<p>The target value of the constraint.</p>
</td></tr>
<tr><td><code id="redist.ipw_+3A_targetpop">targetpop</code></td>
<td>
<p>The desired level of population parity. <code>targetpop</code> =
0.01 means that the desired distance from population parity is 1%. The
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.ipw_+3A_temper">temper</code></td>
<td>
<p>A flag for whether simulated tempering was used to improve the
mixing of the Markov Chain. The default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to resample redistricting plans using
inverse probability weighting techniques described in Rubin (1987). This
techniques reweights and resamples redistricting plans so that the resulting
sample is representative of a random sample from the uniform distribution.
</p>


<h3>Value</h3>

<p><code>redist.ipw</code> returns an object of class &quot;redist&quot;. The object
<code>redist</code> is a list that contains the following components (the
inclusion of some components is dependent on whether tempering
techniques are used):
</p>
<table>
<tr><td><code>plans</code></td>
<td>
<p>Matrix of congressional district assignments generated by the
algorithm. Each row corresponds to a geographic unit, and each column
corresponds to a simulation.</p>
</td></tr>
<tr><td><code>distance_parity</code></td>
<td>
<p>Vector containing the maximum distance from parity for
a particular simulated redistricting plan.</p>
</td></tr>
<tr><td><code>mhdecisions</code></td>
<td>
<p>A vector specifying whether a proposed redistricting plan
was accepted (1) or rejected (0) in a given iteration.</p>
</td></tr>
<tr><td><code>mhprob</code></td>
<td>
<p>A vector containing the Metropolis-Hastings acceptance
probability for each iteration of the algorithm.</p>
</td></tr>
<tr><td><code>pparam</code></td>
<td>
<p>A vector containing the draw of the <code>p</code> parameter for each
simulation, which dictates the number of swaps attempted.</p>
</td></tr>
<tr><td><code>constraint_pop</code></td>
<td>
<p>A vector containing the value of the population
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_compact</code></td>
<td>
<p>A vector containing the value of the compactness
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_segregation</code></td>
<td>
<p>A vector containing the value of the
segregation constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_similar</code></td>
<td>
<p>A vector containing the value of the similarity
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_vra</code></td>
<td>
<p>A vector containing the value of the
vra constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_partisan</code></td>
<td>
<p>A vector containing the value of the
partisan constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_minority</code></td>
<td>
<p>A vector containing the value of the
minority constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_hinge</code></td>
<td>
<p>A vector containing the value of the
hinge constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_qps</code></td>
<td>
<p>A vector containing the value of the
QPS constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>beta_sequence</code></td>
<td>
<p>A vector containing the value of beta for each iteration
of the algorithm. Returned when tempering is being used.</p>
</td></tr>
<tr><td><code>mhdecisions_beta</code></td>
<td>
<p>A vector specifying whether a proposed beta value was
accepted (1) or rejected (0) in a given iteration of the algorithm. Returned
when tempering is being used.</p>
</td></tr>
<tr><td><code>mhprob_beta</code></td>
<td>
<p>A vector containing the Metropolis-Hastings acceptance
probability for each iteration of the algorithm. Returned when tempering
is being used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander
Tarr. (2016) &quot;A New Automated Redistricting Simulator Using Markov Chain
Monte Carlo.&quot; Working Paper.
Available at <a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>
<p>Rubin, Donald. (1987) &quot;Comment: A Noniterative Sampling/Importance Resampling
Alternative to the Data Augmentation Algorithm for Creating a Few Imputations
when Fractions of Missing Information are Modest: the SIR Algorithm.&quot;
Journal of the American Statistical Association.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iowa)
map_ia &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.01)
cons &lt;- redist_constr(map_ia)
cons &lt;- add_constr_pop_dev(cons, strength = 5.4)
alg &lt;- redist_flip(map_ia, nsims = 500, constraints = cons)

alg_ipw &lt;- redist.ipw(plans = alg,
    resampleconstraint = "pop_dev",
    targetbeta = 1,
    targetpop = 0.05)


</code></pre>

<hr>
<h2 id='redist.mcmc.mpi'>MCMC Redistricting Simulator using MPI</h2><span id='topic+redist.mcmc.mpi'></span>

<h3>Description</h3>

<p><code>redist.mcmc.mpi</code> is used to simulate Congressional redistricting
plans using Markov Chain Monte Carlo methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.mcmc.mpi(
  adj,
  total_pop,
  nsims,
  ndists = NA,
  init_plan = NULL,
  loopscompleted = 0,
  nloop = 1,
  nthin = 1,
  eprob = 0.05,
  lambda = 0,
  pop_tol = NA,
  group_pop = NA,
  areasvec = NA,
  counties = NA,
  borderlength_mat = NA,
  ssdmat = NA,
  compactness_metric = "fryer-holden",
  rngseed = NA,
  constraint = NA,
  constraintweights = NA,
  betaseq = "powerlaw",
  betaseqlength = 10,
  adjswaps = TRUE,
  freq = 100,
  savename = NA,
  maxiterrsg = 5000,
  verbose = FALSE,
  cities = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.mcmc.mpi_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix, list, or object of class
&quot;SpatialPolygonsDataFrame.&quot;</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_total_pop">total_pop</code></td>
<td>
<p>A vector containing the populations of each geographic
unit.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_nsims">nsims</code></td>
<td>
<p>The number of simulations run before a save point.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_ndists">ndists</code></td>
<td>
<p>The number of congressional districts. The default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_init_plan">init_plan</code></td>
<td>
<p>A vector containing the congressional district labels
of each geographic unit. The default is <code>NULL</code>. If not provided, random
and contiguous congressional district assignments will be generated using
<code>redist.rsg</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_loopscompleted">loopscompleted</code></td>
<td>
<p>Number of save points reached by the
algorithm. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_nloop">nloop</code></td>
<td>
<p>The total number of save points for the algorithm. The
default is <code>1</code>. Note that the total number of simulations run
will be <code>nsims</code> * <code>nloop</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_nthin">nthin</code></td>
<td>
<p>The amount by which to thin the Markov Chain. The default
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_eprob">eprob</code></td>
<td>
<p>The probability of keeping an edge connected. The default
is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_lambda">lambda</code></td>
<td>
<p>The parameter determining the number of swaps to attempt
each iteration of the algorithm. The number of swaps each iteration is
equal to Pois(<code>lambda</code>) + 1. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_pop_tol">pop_tol</code></td>
<td>
<p>The strength of the hard population
constraint. <code>pop_tol</code> = 0.05 means that any proposed swap that
brings a district more than 5\
rejected. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_group_pop">group_pop</code></td>
<td>
<p>A vector of populations for some sub-group of
interest. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_areasvec">areasvec</code></td>
<td>
<p>A vector of precinct areas for discrete Polsby-Popper.
The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_counties">counties</code></td>
<td>
<p>A vector of county membership assignments. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_borderlength_mat">borderlength_mat</code></td>
<td>
<p>A matrix of border length distances, where
the first two columns are the indices of precincts sharing a border and
the third column is its distance. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_ssdmat">ssdmat</code></td>
<td>
<p>A matrix of squared distances between geographic
units. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_compactness_metric">compactness_metric</code></td>
<td>
<p>The compactness metric to use when constraining on
compactness. Default is <code>fryer-holden</code>, the other implemented option
is <code>polsby-popper</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_rngseed">rngseed</code></td>
<td>
<p>Allows the user to set the seed for the
simulations. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_constraint">constraint</code></td>
<td>
<p>Which constraint to apply. Accepts any combination of <code>compact</code>,
<code>vra</code>, <code>population</code>, <code>similarity</code>, or <code>none</code>
(no constraint applied). The default is NULL.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_constraintweights">constraintweights</code></td>
<td>
<p>The weights to apply to each constraint. Should be a vector
the same length as constraint. Default is NULL.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_betaseq">betaseq</code></td>
<td>
<p>Sequence of beta values for tempering. The default is
<code>powerlaw</code> (see Fifield et. al (2015) for details).</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_betaseqlength">betaseqlength</code></td>
<td>
<p>Length of beta sequence desired for
tempering. The default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_adjswaps">adjswaps</code></td>
<td>
<p>Flag to restrict swaps of beta so that only
values adjacent to current constraint are proposed. The default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_freq">freq</code></td>
<td>
<p>Frequency of between-chain swaps. Default to once every 100
iterations</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_savename">savename</code></td>
<td>
<p>Filename to save simulations. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_maxiterrsg">maxiterrsg</code></td>
<td>
<p>Maximum number of iterations for random seed-and-grow
algorithm to generate starting values. Default is 5000.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print initialization statement. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist.mcmc.mpi_+3A_cities">cities</code></td>
<td>
<p>integer vector of cities for QPS constraint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to simulate redistricting plans
using Markov Chain Monte Carlo methods. Several constraints
corresponding to substantive requirements in the redistricting process
are implemented, including population parity and geographic
compactness. In addition, the function includes multiple-swap and
parallel tempering functionality in MPI to improve the mixing of the Markov
Chain.
</p>


<h3>Value</h3>

<p><code>redist.mcmc.mpi</code> returns an object of class &quot;redist&quot;. The object
<code>redist</code> is a list that contains the following components (the
inclusion of some components is dependent on whether tempering
techniques are used):
</p>
<table>
<tr><td><code>partitions</code></td>
<td>
<p>Matrix of congressional district assignments generated by the
algorithm. Each row corresponds to a geographic unit, and each column
corresponds to a simulation.</p>
</td></tr>
<tr><td><code>distance_parity</code></td>
<td>
<p>Vector containing the maximum distance from parity for
a particular simulated redistricting plan.</p>
</td></tr>
<tr><td><code>mhdecisions</code></td>
<td>
<p>A vector specifying whether a proposed redistricting plan
was accepted (1) or rejected (0) in a given iteration.</p>
</td></tr>
<tr><td><code>mhprob</code></td>
<td>
<p>A vector containing the Metropolis-Hastings acceptance
probability for each iteration of the algorithm.</p>
</td></tr>
<tr><td><code>pparam</code></td>
<td>
<p>A vector containing the draw of the <code>p</code> parameter for each
simulation, which dictates the number of swaps attempted.</p>
</td></tr>
<tr><td><code>constraint_pop</code></td>
<td>
<p>A vector containing the value of the population
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_compact</code></td>
<td>
<p>A vector containing the value of the compactness
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_vra</code></td>
<td>
<p>A vector containing the value of the
vra constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>constraint_similar</code></td>
<td>
<p>A vector containing the value of the similarity
constraint for each accepted redistricting plan.</p>
</td></tr>
<tr><td><code>beta_sequence</code></td>
<td>
<p>A vector containing the value of beta for each iteration
of the algorithm. Returned when tempering is being used.</p>
</td></tr>
<tr><td><code>mhdecisions_beta</code></td>
<td>
<p>A vector specifying whether a proposed beta value was
accepted (1) or rejected (0) in a given iteration of the algorithm. Returned
when tempering is being used.</p>
</td></tr>
<tr><td><code>mhprob_beta</code></td>
<td>
<p>A vector containing the Metropolis-Hastings acceptance
probability for each iteration of the algorithm. Returned when tempering
is being used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander
Tarr. (2016) &quot;A New Automated Redistricting Simulator Using Markov Chain Monte
Carlo.&quot; Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Cannot run on machines without Rmpi
data(fl25)
data(fl25_enum)
data(fl25_adj)

## Code to run the simulations in Figure 4 in Fifield, Higgins, Imai and
## Tarr (2015)

## Get an initial partition
init_plan &lt;- fl25_enum$plans[, 5118]

## Run the algorithm
redist.mcmc.mpi(adj = fl25_adj, total_pop = fl25$pop,
    init_plan = init_plan, nsims = 10000, savename = "test")

## End(Not run)
</code></pre>

<hr>
<h2 id='redist.multisplits'>Counts the Number of Counties Split Between 3 or More Districts</h2><span id='topic+redist.multisplits'></span>

<h3>Description</h3>

<p>Counts the total number of counties that are split across more than 2 districts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.multisplits(plans, counties)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.multisplits_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or matrix with one row
for each precinct and one column for each map. Required.</p>
</td></tr>
<tr><td><code id="redist.multisplits_+3A_counties">counties</code></td>
<td>
<p>A vector of county names or county ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer matrix where each district is a
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
ia &lt;- redist_map(iowa, existing_plan = cd_2010, total_pop = pop, pop_tol = 0.01)
plans &lt;- redist_smc(ia, 50, silent = TRUE)
#old redist.multisplits(plans, ia$region)
splits_multi(plans, ia, region)
</code></pre>

<hr>
<h2 id='redist.parity'>Calculates Maximum Deviation from Population Parity</h2><span id='topic+redist.parity'></span><span id='topic+plan_parity'></span>

<h3>Description</h3>

<p>Computes the deviation from population parity from a plan.
Higher values indicate that (at least) a single district in the map deviates
from population parity. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.parity(plans, total_pop)

plan_parity(map, .data = pl(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.parity_+3A_plans">plans</code></td>
<td>
<p>A matrix with one row for each precinct and one column for each
map. Required.</p>
</td></tr>
<tr><td><code id="redist.parity_+3A_total_pop">total_pop</code></td>
<td>
<p>A numeric vector with the population for every precinct.</p>
</td></tr>
<tr><td><code id="redist.parity_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="redist.parity_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
<tr><td><code id="redist.parity_+3A_...">...</code></td>
<td>
<p>passed on to <code>redist.parity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a map with <code>pop</code> representing the populations of each district,
the deviation from population parity is given as <code>max(abs(pop - parity) / parity)</code>
where <code>parity = sum(pop)/length(pop)</code> is the population size for the
average district.
Therefore, the metric can be thought of as the maximum percent deviation from
equal population. For example, a value of 0.03 in this metric indicates that
all districts are within 3 percent of population parity.
</p>


<h3>Value</h3>

<p>numeric vector with the population parity for each column
</p>

<hr>
<h2 id='redist.plot.adj'>Creates a Graph Overlay</h2><span id='topic+redist.plot.adj'></span>

<h3>Description</h3>

<p>Creates a Graph Overlay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.adj(
  shp,
  adj = NULL,
  plan = NULL,
  centroids = TRUE,
  drop = FALSE,
  plot_shp = TRUE,
  zoom_to = NULL,
  title = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.adj_+3A_shp">shp</code></td>
<td>
<p>A SpatialPolygonsDataFrame or sf object. Required.</p>
</td></tr>
<tr><td><code id="redist.plot.adj_+3A_adj">adj</code></td>
<td>
<p>A zero-indexed adjacency list. Created with redist.adjacency
if not supplied. Default is NULL.</p>
</td></tr>
<tr><td><code id="redist.plot.adj_+3A_plan">plan</code></td>
<td>
<p>A numeric vector with one entry for each precinct in shp.
Used to remove edges that cross boundaries. Default is <code>NULL</code>.  Optional.</p>
</td></tr>
<tr><td><code id="redist.plot.adj_+3A_centroids">centroids</code></td>
<td>
<p>A logical indicating if centroids should be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.adj_+3A_drop">drop</code></td>
<td>
<p>A logical indicating if edges that cross districts should be dropped. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.adj_+3A_plot_shp">plot_shp</code></td>
<td>
<p>A logical indicating if the shp should be plotted under the
graph. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.adj_+3A_zoom_to">zoom_to</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> An
indexing vector of units to zoom the map to.</p>
</td></tr>
<tr><td><code id="redist.plot.adj_+3A_title">title</code></td>
<td>
<p>A string title of plot. Defaults to empty string. Optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
redist.plot.adj(shp = iowa, plan = iowa$cd_2010)

</code></pre>

<hr>
<h2 id='redist.plot.cores'>Plot Cores</h2><span id='topic+redist.plot.cores'></span>

<h3>Description</h3>

<p>Plot Cores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.cores(shp, plan = NULL, core = NULL, lwd = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.cores_+3A_shp">shp</code></td>
<td>
<p>A SpatialPolygonsDataFrame or sf object. Required.</p>
</td></tr>
<tr><td><code id="redist.plot.cores_+3A_plan">plan</code></td>
<td>
<p>A numeric vector with one entry for each precinct in shp.
Used to color the districts. Required.</p>
</td></tr>
<tr><td><code id="redist.plot.cores_+3A_core">core</code></td>
<td>
<p>Required. integer vector produced by <code>redist.identify.cores()</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.cores_+3A_lwd">lwd</code></td>
<td>
<p>Line width. Defaults to 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>

<hr>
<h2 id='redist.plot.distr_qtys'>Plot quantities by district</h2><span id='topic+redist.plot.distr_qtys'></span>

<h3>Description</h3>

<p>Plots a boxplot of a quantity of interest across districts, with districts
optionally sorted by this quantity. Adds reference points for each reference
plan, if applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.distr_qtys(
  plans,
  qty,
  sort = "asc",
  geom = "jitter",
  color_thresh = NULL,
  size = 0.1,
  ref_geom,
  ref_label,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.distr_qtys_+3A_plans">plans</code></td>
<td>
<p>the <code>redist_plans</code> object.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_qty">qty</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the
quantity of interest.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_sort">sort</code></td>
<td>
<p>set to <code>"asc"</code> to sort districts in ascending order of
<code>qty</code> (the default), <code>"desc"</code> for descending order, or
<code>FALSE</code> or <code>"none"</code> for no sorting.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_geom">geom</code></td>
<td>
<p>the <code>ggplot2</code> geom to use in plotting the simulated districts: either
<code>"jitter"</code> or <code>"boxplot"</code>. Can also take in a function, so long as the
function accepts <code>...</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_color_thresh">color_thresh</code></td>
<td>
<p>if a number, the threshold to use in coloring the points.
Plans with quantities of interest above the threshold will be colored
differently than plans below the threshold.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_size">size</code></td>
<td>
<p>The dot size for <code>geom="jitter"</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_ref_geom">ref_geom</code></td>
<td>
<p>The reference plan geometry type. <code>"line"</code> or <code>"point"</code>
can be passed for reasonable defaults. Can also take in a function, so long as the
function accepts <code>...</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_ref_label">ref_label</code></td>
<td>
<p>A human-readable name for the reference plan. By default
the name in the <code>plan</code> column is used. This can also take in a function which returns
a call to <code>ggplot2::labs()</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.distr_qtys_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Using <code>ggdist</code></h3>

<p>For custom functions in <code>geom</code>, we can also create more complicated things like rainclouds
using the <code>ggdist</code> package. For example:
</p>
<div class="sourceCode r"><pre>raincloud &lt;- function(...) {
list(
    ggdist::stat_slab(aes(thickness = ggplot2::after_stat(pdf*n)), scale = 0.7),
   ggdist::stat_dotsinterval(side = "bottom", scale = 0.7,
                             slab_size = NA, quantiles = 200)
)
}
</pre></div>
<p>These functions can be then passed to <code>geom</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(iowa)

iowa &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05, total_pop = pop)
plans &lt;- redist_smc(iowa, nsims = 100, silent = TRUE)
plans &lt;- plans %&gt;% mutate(pct_dem = group_frac(iowa, dem_08, tot_08))
redist.plot.distr_qtys(plans, pct_dem)

# It also takes custom functions:
redist.plot.distr_qtys(plans, pct_dem, geom = ggplot2::geom_violin)

# With the raincloud example, if you have `ggdist`, you can run:
# redist.plot.distr_qtys(plans, pct_dem, geom = raincloud)

# The reference geom can also be changed via `reg_geom`
r_geom &lt;- function(...) ggplot2::geom_segment(ggplot2::aes(as.integer(.data$.distr_no) - 0.5,
                          xend = as.integer(.data$.distr_no) + 0.5,
                          yend = pct_dem,
                          color = .data$draw),
                      linewidth = 1.2, ...)



# Finally, the `ref_label` argument can also be swapped for a function, like so:
redist.plot.distr_qtys(plans, pct_dem, geom = ggplot2::geom_violin, ref_geom = r_geom,
    ref_label = function() ggplot2::labs(color = 'Ref.'))

</code></pre>

<hr>
<h2 id='redist.plot.hist'>Plot a histogram of a summary statistic</h2><span id='topic+redist.plot.hist'></span><span id='topic+hist.redist_plans'></span>

<h3>Description</h3>

<p>Plots a histogram of a statistic of a <code><a href="#topic+redist_plans">redist_plans</a></code> object,
with a reference line for each reference plan, if applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.hist(plans, qty, bins = NULL, ...)

## S3 method for class 'redist_plans'
hist(x, qty, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.hist_+3A_plans">plans</code></td>
<td>
<p>the <code>redist_plans</code> object.</p>
</td></tr>
<tr><td><code id="redist.plot.hist_+3A_qty">qty</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the statistic.</p>
</td></tr>
<tr><td><code id="redist.plot.hist_+3A_bins">bins</code></td>
<td>
<p>the number of bins to use in the histogram. Defaults to Freedman-Diaconis rule.</p>
</td></tr>
<tr><td><code id="redist.plot.hist_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code></p>
</td></tr>
<tr><td><code id="redist.plot.hist_+3A_x">x</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(iowa)

iowa &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05)
plans &lt;- redist_smc(iowa, nsims = 100, silent = TRUE)
group_by(plans, draw) %&gt;%
    summarize(pop_dev = max(abs(total_pop/mean(total_pop) - 1))) %&gt;%
    redist.plot.hist(pop_dev)

</code></pre>

<hr>
<h2 id='redist.plot.majmin'>Majority Minority Plots</h2><span id='topic+redist.plot.majmin'></span>

<h3>Description</h3>

<p>Majority Minority Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.majmin(grouppercent, type = "hist", title = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.majmin_+3A_grouppercent">grouppercent</code></td>
<td>
<p>output from redist.group.percent</p>
</td></tr>
<tr><td><code id="redist.plot.majmin_+3A_type">type</code></td>
<td>
<p>string in 'hist', 'toptwo', or 'box'</p>
</td></tr>
<tr><td><code id="redist.plot.majmin_+3A_title">title</code></td>
<td>
<p>ggplot title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>

<hr>
<h2 id='redist.plot.map'>Plot a Map</h2><span id='topic+redist.plot.map'></span>

<h3>Description</h3>

<p>Create a ggplot map. It fills by plan or argument fill. If both are supplied,
plan is used as the color and fill as the alpha parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.map(
  shp,
  adj,
  plan = NULL,
  fill = NULL,
  fill_label = "",
  zoom_to = NULL,
  boundaries = is.null(fill),
  title = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.map_+3A_shp">shp</code></td>
<td>
<p>A SpatialPolygonsDataFrame, sf object, or redist_map. Required.</p>
</td></tr>
<tr><td><code id="redist.plot.map_+3A_adj">adj</code></td>
<td>
<p>A zero-indexed adjacency list. Created with redist.adjacency
if not supplied and needed for coloring. Default is NULL.</p>
</td></tr>
<tr><td><code id="redist.plot.map_+3A_plan">plan</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> A numeric
vector with one entry for each precinct in shp. Used to color the
districts. Default is <code>NULL</code>.  Optional.</p>
</td></tr>
<tr><td><code id="redist.plot.map_+3A_fill">fill</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> A
numeric/integer vector with values to color the plot with. Optional.</p>
</td></tr>
<tr><td><code id="redist.plot.map_+3A_fill_label">fill_label</code></td>
<td>
<p>A string title of plot. Defaults to the empty string</p>
</td></tr>
<tr><td><code id="redist.plot.map_+3A_zoom_to">zoom_to</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> An
indexing vector of units to zoom the map to.</p>
</td></tr>
<tr><td><code id="redist.plot.map_+3A_boundaries">boundaries</code></td>
<td>
<p>A logical indicating if precinct boundaries should be plotted.</p>
</td></tr>
<tr><td><code id="redist.plot.map_+3A_title">title</code></td>
<td>
<p>A string title of plot. Defaults to empty string. Optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
redist.plot.map(shp = iowa, plan = iowa$cd_2010)

iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010)
redist.plot.map(iowa_map, fill = dem_08/tot_08, zoom_to = (cd_2010 == 1))

</code></pre>

<hr>
<h2 id='redist.plot.penalty'>(Deprecated) Visualize Group Power Penalty</h2><span id='topic+redist.plot.penalty'></span>

<h3>Description</h3>

<p>Plots the shape of the <code><a href="#topic+add_constr_grp_pow">add_constr_grp_pow()</a></code> penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.penalty(
  tgt_min = 0.55,
  tgt_other = 0.25,
  strength_vra = 2500,
  pow_vra = 1.5,
  limits = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.penalty_+3A_tgt_min">tgt_min</code></td>
<td>
<p>double, defaults to 0.55. The minority target percent.</p>
</td></tr>
<tr><td><code id="redist.plot.penalty_+3A_tgt_other">tgt_other</code></td>
<td>
<p>double, defaults to 0.25. The other group target percent.</p>
</td></tr>
<tr><td><code id="redist.plot.penalty_+3A_strength_vra">strength_vra</code></td>
<td>
<p>double, strength of the VRA constraint.</p>
</td></tr>
<tr><td><code id="redist.plot.penalty_+3A_pow_vra">pow_vra</code></td>
<td>
<p>double, exponent of the VRA constraint.</p>
</td></tr>
<tr><td><code id="redist.plot.penalty_+3A_limits">limits</code></td>
<td>
<p>Whether to limit y axis to 0,500. Default is TRUE for
comparability across values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to plot the un-exponentiated penalty implemented as
<code><a href="#topic+add_constr_grp_pow">add_constr_grp_pow()</a></code>. The function takes two key inputs,
<code>tgt_min</code> and <code>tgt_other</code> which center the minimum penalty spots. A higher y-value
indicates a higher penalty and incentivizes moving towards a spot with a lower y-value.
The x-axis indicates the group population proportion in a given district.
</p>


<h3>Value</h3>

<p>ggplot
</p>

<hr>
<h2 id='redist.plot.plans'>Plot a district assignment</h2><span id='topic+redist.plot.plans'></span>

<h3>Description</h3>

<p>Plot a district assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.plans(
  plans,
  draws,
  shp,
  qty = NULL,
  interactive = FALSE,
  ...,
  geom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.plans_+3A_plans">plans</code></td>
<td>
<p>a <code>redist_plans</code> object.</p>
</td></tr>
<tr><td><code id="redist.plot.plans_+3A_draws">draws</code></td>
<td>
<p>the plan(s) to plot. Will match the <code>draw</code> column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="redist.plot.plans_+3A_qty">qty</code></td>
<td>
<p>the quantity to plot. Defaults to the district assignment.</p>
</td></tr>
<tr><td><code id="redist.plot.plans_+3A_interactive">interactive</code></td>
<td>
<p>if <code>TRUE</code>, show an interactive map in the viewer
rather than a static map. Only uses the first element of <code>draws</code></p>
</td></tr>
<tr><td><code id="redist.plot.plans_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting functions.</p>
</td></tr>
<tr><td><code id="redist.plot.plans_+3A_geom">geom</code>, <code id="redist.plot.plans_+3A_shp">shp</code></td>
<td>
<p>the <code>redist_map</code> geometry to use (<code>geom</code> is deprecated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(iowa)

iowa &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05, total_pop = pop)
plans &lt;- redist_smc(iowa, nsims = 100, silent = TRUE)
redist.plot.plans(plans, c(1, 2, 3, 4), iowa)

</code></pre>

<hr>
<h2 id='redist.plot.scatter'>Scatter plot of plan summary statistics</h2><span id='topic+redist.plot.scatter'></span>

<h3>Description</h3>

<p>Makes a scatterplot of two quantities of interest across districts or plans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.scatter(plans, x, y, ..., bigger = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.scatter_+3A_plans">plans</code></td>
<td>
<p>the <code>redist_plans</code> object.</p>
</td></tr>
<tr><td><code id="redist.plot.scatter_+3A_x">x</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the
quantity to plot on the horizontal axis.</p>
</td></tr>
<tr><td><code id="redist.plot.scatter_+3A_y">y</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the
quantity to plot on the vertical axis.</p>
</td></tr>
<tr><td><code id="redist.plot.scatter_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.</p>
</td></tr>
<tr><td><code id="redist.plot.scatter_+3A_bigger">bigger</code></td>
<td>
<p>if TRUE, make the point corresponding to the reference plan larger.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(iowa)

iowa &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05, total_pop = pop)
plans &lt;- redist_smc(iowa, nsims = 100, silent = TRUE)
plans %&gt;%
    mutate(comp = distr_compactness(iowa)) %&gt;%
    group_by(draw) %&gt;%
    summarize(pop_dev = max(abs(total_pop/mean(total_pop) - 1)),
        comp = comp[1]) %&gt;%
    redist.plot.scatter(pop_dev, comp)

</code></pre>

<hr>
<h2 id='redist.plot.trace'>Make a traceplot for a summary statistic</h2><span id='topic+redist.plot.trace'></span>

<h3>Description</h3>

<p>For a statistic in a <code><a href="#topic+redist_plans">redist_plans</a></code> object,
make a traceplot showing the evolution of the statistic over MCMC iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.trace(plans, qty, district = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.trace_+3A_plans">plans</code></td>
<td>
<p>the <code>redist_plans</code> object.</p>
</td></tr>
<tr><td><code id="redist.plot.trace_+3A_qty">qty</code></td>
<td>
<p><code><a href="dplyr.html#topic+dplyr_data_masking">&lt;data-masking&gt;</a></code> the statistic.</p>
</td></tr>
<tr><td><code id="redist.plot.trace_+3A_district">district</code></td>
<td>
<p>for <code>redist_plans</code> objects with multiple districts,
which <code>district</code> to subset to for plotting. Set to <code>NULL</code> to
perform no subsetting.</p>
</td></tr>
<tr><td><code id="redist.plot.trace_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
data(iowa)

iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05)
plans &lt;- redist_mergesplit_parallel(iowa_map, nsims = 200, chains = 2, silent = TRUE) %&gt;%
    mutate(dem = group_frac(iowa_map, dem_08, dem_08 + rep_08)) %&gt;%
    number_by(dem)
redist.plot.trace(plans, dem, district = 1)

</code></pre>

<hr>
<h2 id='redist.plot.varinfo'>Static Variation of Information Plot</h2><span id='topic+redist.plot.varinfo'></span>

<h3>Description</h3>

<p>Static Variation of Information Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.varinfo(plans, group_pop, total_pop, shp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.varinfo_+3A_plans">plans</code></td>
<td>
<p>matrix of district assignments</p>
</td></tr>
<tr><td><code id="redist.plot.varinfo_+3A_group_pop">group_pop</code></td>
<td>
<p>Required Population of subgroup being studied in each precinct.</p>
</td></tr>
<tr><td><code id="redist.plot.varinfo_+3A_total_pop">total_pop</code></td>
<td>
<p>Required. Population of each precinct.</p>
</td></tr>
<tr><td><code id="redist.plot.varinfo_+3A_shp">shp</code></td>
<td>
<p>sf dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>patchworked ggplot
</p>

<hr>
<h2 id='redist.plot.wted.adj'>Plot Weighted Border Adjacency</h2><span id='topic+redist.plot.wted.adj'></span>

<h3>Description</h3>

<p>Plots the weighted adjacency graph by how often precincts coocur. If an argument
to counties is provided, it subsets the edges to plot to those that cross over the county boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.plot.wted.adj(
  shp,
  plans,
  counties = NULL,
  ref = TRUE,
  adj = NULL,
  plot_shp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.plot.wted.adj_+3A_shp">shp</code></td>
<td>
<p>A SpatialPolygonsDataFrame, sf object, or redist_map. Required.</p>
</td></tr>
<tr><td><code id="redist.plot.wted.adj_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or matrix of redistricting plans, where each
column indicates a plan and each</p>
</td></tr>
<tr><td><code id="redist.plot.wted.adj_+3A_counties">counties</code></td>
<td>
<p>unquoted name of a column in <code>shp</code> or a vector of county assignments. Subsets to
edges which cross this boundary if supplied.</p>
</td></tr>
<tr><td><code id="redist.plot.wted.adj_+3A_ref">ref</code></td>
<td>
<p>Plot reference map? Defaults to TRUE which gets the existing plan from</p>
</td></tr>
<tr><td><code id="redist.plot.wted.adj_+3A_adj">adj</code></td>
<td>
<p>A zero-indexed adjacency list. Extracted from <code>shp</code> if <code>shp</code> is a <code>redist_map</code>.
Otherwise created with redist.adjacency if not supplied. Default is NULL.</p>
</td></tr>
<tr><td><code id="redist.plot.wted.adj_+3A_plot_shp">plot_shp</code></td>
<td>
<p>Should the shapes be plotted? Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
shp &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.01)
plans &lt;- redist_smc(shp, 100)
redist.plot.wted.adj(shp, plans = plans, counties = region)
</code></pre>

<hr>
<h2 id='redist.prec.pop.overlap'>Compare the Population Overlap Across Plans at the Precinct Level</h2><span id='topic+redist.prec.pop.overlap'></span>

<h3>Description</h3>

<p>Compare the Population Overlap Across Plans at the Precinct Level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.prec.pop.overlap(
  plan_old,
  plan_new,
  total_pop,
  weighting = "s",
  normalize = TRUE,
  index_only = FALSE,
  return_mat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.prec.pop.overlap_+3A_plan_old">plan_old</code></td>
<td>
<p>The reference plan to compare against</p>
</td></tr>
<tr><td><code id="redist.prec.pop.overlap_+3A_plan_new">plan_new</code></td>
<td>
<p>The new plan to compare to the reference plan</p>
</td></tr>
<tr><td><code id="redist.prec.pop.overlap_+3A_total_pop">total_pop</code></td>
<td>
<p>The total population by precinct This can also take a redist_map
object and will use the population in that object. If nothing is provided, it weights
all entries in plan equally.</p>
</td></tr>
<tr><td><code id="redist.prec.pop.overlap_+3A_weighting">weighting</code></td>
<td>
<p>Should weighting be done by sum of populations <code>'s'</code>, mean of
populations <code>'m'</code>, geometric mean of populations <code>'g'</code>, or none <code>'n'</code></p>
</td></tr>
<tr><td><code id="redist.prec.pop.overlap_+3A_normalize">normalize</code></td>
<td>
<p>Should entries be normalized by the total population</p>
</td></tr>
<tr><td><code id="redist.prec.pop.overlap_+3A_index_only">index_only</code></td>
<td>
<p>Default is FALSE. TRUE returns only one numeric index, the
mean of the upper triangle of the matrix, under the weighting and normalization
chosen.</p>
</td></tr>
<tr><td><code id="redist.prec.pop.overlap_+3A_return_mat">return_mat</code></td>
<td>
<p>Defaults to FALSE, where it returns the summary by row. If
TRUE returns matrix with length(plan_old) rows and columns. Ignored if
index_only = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with length(plan_old) entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
data(iowa)
iowa_map &lt;- redist_map(iowa, total_pop = pop, pop_tol = 0.01, ndists = 4)
plans &lt;- redist_smc(iowa_map, 2, silent = TRUE)
plans_mat &lt;- get_plans_matrix(plans)
ov_vec &lt;- redist.prec.pop.overlap(plans_mat[, 1], plans_mat[, 2], iowa_map)
redist.prec.pop.overlap(plans_mat[, 1], plans_mat[, 2], iowa_map,  weighting = "s",
    normalize = FALSE, index_only = TRUE)

</code></pre>

<hr>
<h2 id='redist.prep.enumpart'>Prepares a run of the enumpart algorithm by ordering edges</h2><span id='topic+redist.prep.enumpart'></span>

<h3>Description</h3>

<p>Prepares a run of the enumpart algorithm by ordering edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.prep.enumpart(
  adj,
  unordered_path,
  ordered_path,
  weight_path = NULL,
  total_pop = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.prep.enumpart_+3A_adj">adj</code></td>
<td>
<p>zero indexed adjacency list</p>
</td></tr>
<tr><td><code id="redist.prep.enumpart_+3A_unordered_path">unordered_path</code></td>
<td>
<p>valid path to output the unordered adjacency map to</p>
</td></tr>
<tr><td><code id="redist.prep.enumpart_+3A_ordered_path">ordered_path</code></td>
<td>
<p>valid path to output the ordered adjacency map to</p>
</td></tr>
<tr><td><code id="redist.prep.enumpart_+3A_weight_path">weight_path</code></td>
<td>
<p>A path (not including &quot;.dat&quot;) to store a space-delimited
file containing a vector of vertex weights. Only supply with total_pop.</p>
</td></tr>
<tr><td><code id="redist.prep.enumpart_+3A_total_pop">total_pop</code></td>
<td>
<p>the vector of precinct populations. Only supply with weight_path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 on success
</p>


<h3>References</h3>

<p>Benjamin Fifield, Kosuke Imai, Jun Kawahara, and Christopher T Kenny.
&quot;The Essential Role of Empirical Validation in Legislative Redistricting Simulation.&quot;
Forthcoming, Statistics and Public Policy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
temp &lt;- tempdir()
data(fl25)
adj &lt;- redist.adjacency(fl25)
redist.prep.enumpart(adj = adj, unordered_path = paste0(temp, "/unordered"),
    ordered_path = paste0(temp, "/ordered"))

## End(Not run)
</code></pre>

<hr>
<h2 id='redist.random.subgraph'>Return a random subgraph of a shape</h2><span id='topic+redist.random.subgraph'></span>

<h3>Description</h3>

<p><code>random.subgraph</code> returns a random subset of the shp provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.random.subgraph(shp, n, adj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.random.subgraph_+3A_shp">shp</code></td>
<td>
<p>sf object or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="redist.random.subgraph_+3A_n">n</code></td>
<td>
<p>number of edges to sample. n must be a positive integer.</p>
</td></tr>
<tr><td><code id="redist.random.subgraph_+3A_adj">adj</code></td>
<td>
<p>Optional. zero indexed adjacency list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Snowball sampling with backtracking
</p>


<h3>Value</h3>

<p>sf dataframe with n rows
</p>

<hr>
<h2 id='redist.read.enumpart'>Read Results from enumpart</h2><span id='topic+redist.read.enumpart'></span>

<h3>Description</h3>

<p>Read Results from enumpart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.read.enumpart(out_path, skip = 0, n_max = -1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.read.enumpart_+3A_out_path">out_path</code></td>
<td>
<p>out_path specified in redist.run.enumpart</p>
</td></tr>
<tr><td><code id="redist.read.enumpart_+3A_skip">skip</code></td>
<td>
<p>number of lines to skip</p>
</td></tr>
<tr><td><code id="redist.read.enumpart_+3A_n_max">n_max</code></td>
<td>
<p>max number of lines to read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>district_membership matrix
</p>


<h3>References</h3>

<p>Benjamin Fifield, Kosuke Imai, Jun Kawahara, and Christopher T Kenny.
&quot;The Essential Role of Empirical Validation in Legislative Redistricting Simulation.&quot;
Forthcoming, Statistics and Public Policy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
temp &lt;- tempdir()
cds &lt;- redist.read.enumpart(out_path = paste0(temp, "/enumerated"))

## End(Not run)
</code></pre>

<hr>
<h2 id='redist.reduce.adjacency'>Reduce Adjacency List</h2><span id='topic+redist.reduce.adjacency'></span>

<h3>Description</h3>

<p>Tool to help reduce adjacency lists for analyzing subsets of maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.reduce.adjacency(adj, keep_rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.reduce.adjacency_+3A_adj">adj</code></td>
<td>
<p>A zero-indexed adjacency list. Required.</p>
</td></tr>
<tr><td><code id="redist.reduce.adjacency_+3A_keep_rows">keep_rows</code></td>
<td>
<p>row numbers of precincts to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zero indexed adjacency list with max value length(keep_rows) - 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25_adj)
redist.reduce.adjacency(fl25_adj, c(2, 3, 4, 6, 21))

</code></pre>

<hr>
<h2 id='redist.reorder'>Reorders district numbers</h2><span id='topic+redist.reorder'></span>

<h3>Description</h3>

<p>Ensures that for each column in the plans object, the first
district listed is 1, the second is 2, up to n districts. Assumes that all
columns have the same number of districts as the first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.reorder(plans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.reorder_+3A_plans">plans</code></td>
<td>
<p>A numeric vector (if only one map) or
matrix with one row for each precinct and one column for each map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cds &lt;- matrix(c(rep(c(4L, 5L, 2L, 1L, 3L), 5),
    rep(c(5L, 4L, 3L, 2L, 1L), 2), rep(c(4L, 5L, 2L, 1L, 3L), 3)), nrow = 25)
redist.reorder(cds)

</code></pre>

<hr>
<h2 id='redist.rsg'>Redistricting via Random Seed and Grow Algorithm</h2><span id='topic+redist.rsg'></span>

<h3>Description</h3>

<p><code>redist.rsg</code> generates redistricting plans using a random seed a grow
algorithm.  This is the non-compact districting algorithm described in Chen and
Rodden (2013).  The algorithm can provide start values for the other
redistricting routines in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.rsg(adj, total_pop, ndists, pop_tol, verbose = TRUE, maxiter = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.rsg_+3A_adj">adj</code></td>
<td>
<p>List of length N, where N is the number of precincts.
Each list element is an integer vector indicating which precincts that precinct
is adjacent to.  It is assumed that precinct numbers start at 0.</p>
</td></tr>
<tr><td><code id="redist.rsg_+3A_total_pop">total_pop</code></td>
<td>
<p>numeric vector of length N, where N is the number of precincts.
Each element lists the population total of the corresponding precinct, and is
used to enforce population constraints.</p>
</td></tr>
<tr><td><code id="redist.rsg_+3A_ndists">ndists</code></td>
<td>
<p>integer, the number of districts we want to partition the
precincts into.</p>
</td></tr>
<tr><td><code id="redist.rsg_+3A_pop_tol">pop_tol</code></td>
<td>
<p>numeric, indicating how close district population targets have
to be to the target population before algorithm converges.  thresh=0.05 for
example means that all districts must be between 0.95 and 1.05 times the size
of target.pop in population size.</p>
</td></tr>
<tr><td><code id="redist.rsg_+3A_verbose">verbose</code></td>
<td>
<p>boolean, indicating whether the time to run the algorithm is
printed.</p>
</td></tr>
<tr><td><code id="redist.rsg_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, indicating maximum number of iterations to attempt
before convergence to population constraint fails.  If it fails once, it will
use a different set of start values and try again.  If it fails again,
redist.rsg() returns an object of all NAs, indicating that use of more
iterations may be advised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, containing three objects containing the completed redistricting
plan.
</p>

<ul>
<li> <p><code>plan</code>:  A vector of length N, indicating the
district membership of each precinct.
</p>
</li>
<li> <p><code>district_list</code>  A list of length Ndistrict.  Each list contains a
vector of the precincts in the respective district.
</p>
</li>
<li> <p><code>district_pop</code>  A vector of length Ndistrict, containing the
population totals of the respective districts.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Benjamin Fifield, Department of Politics, Princeton University
<a href="mailto:benfifield@gmail.com">benfifield@gmail.com</a>, <a href="https://www.benfifield.com/">https://www.benfifield.com/</a>
</p>
<p>Michael Higgins, Department of Statistics, Kansas State University
<a href="mailto:mikehiggins@k-state.edu">mikehiggins@k-state.edu</a>,
<a href="https://www.k-state.edu/stats/about/people/HigginsMichael.html">https://www.k-state.edu/stats/about/people/HigginsMichael.html</a>
</p>
<p>Kosuke Imai, Department of Politics, Princeton University
<a href="mailto:imai@harvard.edu">imai@harvard.edu</a>, <a href="https://imai.fas.harvard.edu">https://imai.fas.harvard.edu</a>
</p>
<p>James Lo, <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Alexander Tarr, Department of Electrical Engineering, Princeton University
<a href="mailto:atarr@princeton.edu">atarr@princeton.edu</a>
</p>


<h3>References</h3>

<p>Jowei Chen and Jonathan Rodden (2013) &ldquo;Unintentional
Gerrymandering: Political Geography and Electoral Bias in Legislatures.&rdquo;
Quarterly Journal of Political Science. 8(3): 239-269.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Real data example from test set
data(fl25)
data(fl25_adj)

res &lt;- redist.rsg(adj = fl25_adj, total_pop = fl25$pop,
    ndists = 3, pop_tol = 0.05)

</code></pre>

<hr>
<h2 id='redist.run.enumpart'>Runs the enumpart algorithm</h2><span id='topic+redist.run.enumpart'></span>

<h3>Description</h3>

<p>Runs the enumpart algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.run.enumpart(
  ordered_path,
  out_path,
  ndists = 2,
  all = TRUE,
  n = NULL,
  weight_path = NULL,
  lower = NULL,
  upper = NULL,
  options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.run.enumpart_+3A_ordered_path">ordered_path</code></td>
<td>
<p>Path used in redist.prep.enumpart (not including &quot;.dat&quot;)</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_out_path">out_path</code></td>
<td>
<p>Valid path to output the enumerated districts</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_ndists">ndists</code></td>
<td>
<p>number of districts to enumerate</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_all">all</code></td>
<td>
<p>boolean. TRUE outputs all districts. FALSE samples n districts.</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_n">n</code></td>
<td>
<p>integer. Number of districts to output if all is FALSE. Returns
districts selected from uniform random distribution.</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_weight_path">weight_path</code></td>
<td>
<p>A path (not including &quot;.dat&quot;) to a space-delimited file containing a vector of
vertex weights, to be used along with <code>lower</code> and <code>upper</code>.</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_lower">lower</code></td>
<td>
<p>A lower bound on each partition's total weight, implemented by rejection sampling.</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_upper">upper</code></td>
<td>
<p>An upper bound on each partition's total weight.</p>
</td></tr>
<tr><td><code id="redist.run.enumpart_+3A_options">options</code></td>
<td>
<p>Additional enumpart arguments. Not recommended for use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 on success
</p>


<h3>References</h3>

<p>Benjamin Fifield, Kosuke Imai, Jun Kawahara, and Christopher T Kenny.
&quot;The Essential Role of Empirical Validation in Legislative Redistricting Simulation.&quot;
Forthcoming, Statistics and Public Policy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
temp &lt;- tempdir()
redist.run.enumpart(ordered_path = paste0(temp, "/ordered"),
    out_path = paste0(temp, "/enumerated"))

## End(Not run)
</code></pre>

<hr>
<h2 id='redist.sink.plan'>Sink Plans to 1:ndists</h2><span id='topic+redist.sink.plan'></span>

<h3>Description</h3>

<p>Takes a plan and renumbers it to be from 1:ndists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.sink.plan(plan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.sink.plan_+3A_plan">plan</code></td>
<td>
<p>vector of assignments, required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with an ID that corresponds from 1:ndists, and attribute <code>n</code> indicating the number of districts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fl25_enum)
plan &lt;- fl25_enum$plans[, 5118]
# Subset based on something:
plan &lt;- plan[plan != 2]
plan &lt;- vctrs::vec_group_id(plan)
# Now plan can be used with redist_flip()
plan

</code></pre>

<hr>
<h2 id='redist.smc_is_ci'>(Deprecated) Confidence Intervals for Importance Sampling Estimates</h2><span id='topic+redist.smc_is_ci'></span>

<h3>Description</h3>

<p>Builds a confidence interval for a quantity of interest,
given importance sampling weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.smc_is_ci(x, wgt, conf = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.smc_is_ci_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the quantity of interest</p>
</td></tr>
<tr><td><code id="redist.smc_is_ci_+3A_wgt">wgt</code></td>
<td>
<p>A numeric vector containing the nonnegative importance weights.
Will be normalized automatically.</p>
</td></tr>
<tr><td><code id="redist.smc_is_ci_+3A_conf">conf</code></td>
<td>
<p>The confidence level for the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-element vector of the form <code style="white-space: pre;">&#8288;[lower, upper]&#8288;</code> containing
the importance sampling confidence interval.
</p>

<hr>
<h2 id='redist.subset'>Subset a shp</h2><span id='topic+redist.subset'></span>

<h3>Description</h3>

<p>Subsets a shp object along with its adjacency. Useful for running smaller analyses
on pairs of districts. Provide population, ndists, pop_tol, and sub_ndists to get proper
population parity constraints on subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.subset(shp, adj, keep_rows, total_pop, ndists, pop_tol, sub_ndists)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.subset_+3A_shp">shp</code></td>
<td>
<p>An sf object</p>
</td></tr>
<tr><td><code id="redist.subset_+3A_adj">adj</code></td>
<td>
<p>A zero-indexed adjacency list. Created with
<code>redist.adjacency</code> if not supplied.</p>
</td></tr>
<tr><td><code id="redist.subset_+3A_keep_rows">keep_rows</code></td>
<td>
<p>row numbers of precincts to keep. Random submap selected if not supplied.</p>
</td></tr>
<tr><td><code id="redist.subset_+3A_total_pop">total_pop</code></td>
<td>
<p>numeric vector with one entry for the population of each precinct.</p>
</td></tr>
<tr><td><code id="redist.subset_+3A_ndists">ndists</code></td>
<td>
<p>integer, number of districts in whole map</p>
</td></tr>
<tr><td><code id="redist.subset_+3A_pop_tol">pop_tol</code></td>
<td>
<p>The strength of the hard population constraint.</p>
</td></tr>
<tr><td><code id="redist.subset_+3A_sub_ndists">sub_ndists</code></td>
<td>
<p>integer, number of districts in subset map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>shp</code></td>
<td>
<p>The subsetted shp object</p>
</td></tr>
<tr><td><code>adj</code></td>
<td>
<p>The subsetted adjacency list for shp</p>
</td></tr>
<tr><td><code>keep_rows</code></td>
<td>
<p>The indices of the rows kept.</p>
</td></tr>
<tr><td><code>sub_ndists</code></td>
<td>
<p>The number of districts in the subset.</p>
</td></tr>
<tr><td><code>sub_pop_tol</code></td>
<td>
<p>The new parity constraint for a subset.</p>
</td></tr>
</table>

<hr>
<h2 id='redist.uncoarsen'>Uncoarsen a District Matrix</h2><span id='topic+redist.uncoarsen'></span>

<h3>Description</h3>

<p>After a cores analysis or other form of coarsening, sometimes you need
to be at the original geography level to be comparable. This takes in a
coarsened matrix and uncoarsens it to the original level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.uncoarsen(plans, group_index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.uncoarsen_+3A_plans">plans</code></td>
<td>
<p>A coarsened matrix of plans.</p>
</td></tr>
<tr><td><code id="redist.uncoarsen_+3A_group_index">group_index</code></td>
<td>
<p>The index used to coarsen the shape.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='redist.wted.adj'>Create Weighted Adjacency Data</h2><span id='topic+redist.wted.adj'></span>

<h3>Description</h3>

<p>Create Weighted Adjacency Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist.wted.adj(map = NULL, plans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist.wted.adj_+3A_map">map</code></td>
<td>
<p>redist_map</p>
</td></tr>
<tr><td><code id="redist.wted.adj_+3A_plans">plans</code></td>
<td>
<p>redist_plans</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
shp &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.01)
plans &lt;- redist_smc(shp, 100)
redist.wted.adj(shp, plans = plans)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='scorer_group_pct'>Scoring functions for <code>redist_shortburst</code></h2><span id='topic+scorer_group_pct'></span><span id='topic+scorer_pop_dev'></span><span id='topic+scorer_splits'></span><span id='topic+scorer_multisplits'></span><span id='topic+scorer_frac_kept'></span><span id='topic+scorer_polsby_popper'></span><span id='topic+scorer_status_quo'></span><span id='topic+scorers'></span>

<h3>Description</h3>

<p>The output of these functions may be passed into <code>redist_shortburst()</code> as
<code>score_fn</code>.  Scoring functions have type <code>redist_scorer</code> and may be combined
together using basic arithmetic operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scorer_group_pct(map, group_pop, total_pop, k = 1)

scorer_pop_dev(map)

scorer_splits(map, counties)

scorer_multisplits(map, counties)

scorer_frac_kept(map)

scorer_polsby_popper(map, perim_df = NULL, areas = NULL, m = 1)

scorer_status_quo(map, existing_plan = get_existing(map))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorer_group_pct_+3A_map">map</code></td>
<td>
<p>A <code><a href="#topic+redist_map">redist_map</a></code> object.</p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_group_pop">group_pop</code></td>
<td>
<p>A numeric vector with the population of the group for every precinct.</p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_total_pop">total_pop</code></td>
<td>
<p>A numeric vector with the population for every precinct.</p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_k">k</code></td>
<td>
<p>the k-th from the top group fraction to return as the score.</p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_counties">counties</code></td>
<td>
<p>A numeric vector with an integer from 1:n_counties</p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_perim_df">perim_df</code></td>
<td>
<p>perimeter distance dataframe from <code><a href="redistmetrics.html#topic+prep_perims">prep_perims()</a></code></p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_areas">areas</code></td>
<td>
<p>area of each precinct (ie <code>st_area(map)</code>)</p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_m">m</code></td>
<td>
<p>the m-th from the bottom Polsby Popper to return as the score. Defaults to 1,
the minimum Polsby Popper score</p>
</td></tr>
<tr><td><code id="scorer_group_pct_+3A_existing_plan">existing_plan</code></td>
<td>
<p>A vector containing the current plan.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function details:
</p>

<ul>
<li> <p><code>scorer_group_pct</code> returns the <code>k</code>-th top group percentage across districts.
For example, if the group is Democratic voters and <code>k=3</code>, then the function
returns the 3rd-highest fraction of Democratic voters across all districts.
Can be used to target <code>k</code> VRA districts or partisan gerrymanders.
</p>
</li>
<li> <p><code>scorer_pop_dev</code> returns the maximum population deviation within a plan.
Smaller values are closer to population parity, so use <code>maximize=FALSE</code> with
this scorer.
</p>
</li>
<li> <p><code>scorer_splits</code> returns the fraction of counties that are split within a
plan. Higher values have more county splits, so use <code>maximize=FALSE</code> with
this scorer.
</p>
</li>
<li> <p><code>scorer_frac_kept</code> returns the fraction of edges kept in each district.
Higher values mean more compactness.
</p>
</li>
<li> <p><code>scorer_polsby_popper</code> returns the <code>m</code>-th Polsby Popper score within a plan.
Higher scores correspond to more compact districts.  Use <code>m=ndists/2</code> to
target the median compactness, <code>m=1</code> to target the minimum compactness.
</p>
</li>
<li> <p><code>scorer_status_quo</code> returns 1 - the rescaled variation of information
distance between the plan and the <code>existing_plan</code>. Larger values indicate the
plan is closer to the existing plan.
</p>
</li></ul>



<h3>Value</h3>

<p>A scoring function of class <code>redist_scorer</code> which returns a single numeric value per plan.
Larger values are generally better for <code>frac_kept</code>, <code>group_pct</code>, and <code>polsby_popper</code>
and smaller values are better for <code>splits</code> and <code>pop_dev</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iowa)
iowa_map &lt;- redist_map(iowa, existing_plan = cd_2010, pop_tol = 0.05, total_pop = pop)

scorer_frac_kept(iowa_map)
scorer_status_quo(iowa_map)
scorer_group_pct(iowa_map, dem_08, tot_08, k = 2)
1.5*scorer_frac_kept(iowa_map) + 0.4*scorer_status_quo(iowa_map)
1.5*scorer_frac_kept(iowa_map) + scorer_frac_kept(iowa_map)*scorer_status_quo(iowa_map)
cbind(
    comp = scorer_frac_kept(iowa_map),
    sq = scorer_status_quo(iowa_map)
)


</code></pre>

<hr>
<h2 id='scorer-arith'>Scoring function arithmetic</h2><span id='topic+scorer-arith'></span><span id='topic++2A.redist_scorer'></span><span id='topic++2B.redist_scorer'></span><span id='topic+-.redist_scorer'></span>

<h3>Description</h3>

<p><code>redist_scorer</code> functions may be multiplied by constants and/or added
together to form linear combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_scorer'
x * fn2

## S3 method for class 'redist_scorer'
fn1 + fn2

## S3 method for class 'redist_scorer'
fn1 - fn2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorer-arith_+3A_x">x</code></td>
<td>
<p>a numeric or a <code>redist_scorer</code> function, from <code><a href="#topic+scorers">scorers</a></code></p>
</td></tr>
<tr><td><code id="scorer-arith_+3A_fn2">fn2</code></td>
<td>
<p>a <code>redist_scorer</code> function, from <code><a href="#topic+scorers">scorers</a></code></p>
</td></tr>
<tr><td><code id="scorer-arith_+3A_fn1">fn1</code></td>
<td>
<p>a <code>redist_scorer</code> function, from <code><a href="#topic+scorers">scorers</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>function of class redist_scorer
</p>

<hr>
<h2 id='scorer-combine'>Combine scoring functions</h2><span id='topic+scorer-combine'></span><span id='topic+combine_scorers'></span><span id='topic+cbind.redist_scorer'></span>

<h3>Description</h3>

<p><code>redist_scorer</code> functions may be combined together to optimize along multiple
dimensions. Rather than linearly combining multiple scorers to form a single
objective as with <a href="#topic+scorer-arith">scorer-arith</a>, these functions allow analysts to approximate
the Pareto frontier for a set of scorers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_scorers(...)

## S3 method for class 'redist_scorer'
cbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorer-combine_+3A_...">...</code></td>
<td>
<p>a numeric or a <code>redist_scorer</code> function, from <code><a href="#topic+scorers">scorers</a></code></p>
</td></tr>
<tr><td><code id="scorer-combine_+3A_deparse.level">deparse.level</code></td>
<td>
<p>As in <code><a href="base.html#topic+cbind">cbind()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function of class redist_scorer. Will return a matrix with each
column containing every plan's scores for a particular scoring function.
</p>

<hr>
<h2 id='segregation_index'>Segregation index calculation for MCMC redistricting.</h2><span id='topic+segregation_index'></span><span id='topic+redist.segcalc'></span>

<h3>Description</h3>

<p><code>redist.segcalc</code> calculates the dissimilarity index of segregation (see
Massey &amp; Denton 1987 for more details) for a specified subgroup under any
redistricting plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segregation_index(
  map,
  group_pop,
  total_pop = map[[attr(map, "pop_col")]],
  .data = cur_plans()
)

redist.segcalc(plans, group_pop, total_pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segregation_index_+3A_map">map</code></td>
<td>
<p>a <code><a href="#topic+redist_map">redist_map</a></code> object</p>
</td></tr>
<tr><td><code id="segregation_index_+3A_group_pop">group_pop</code></td>
<td>
<p>A vector of populations for some subgroup of interest.</p>
</td></tr>
<tr><td><code id="segregation_index_+3A_total_pop">total_pop</code></td>
<td>
<p>A vector containing the populations of each geographic unit.</p>
</td></tr>
<tr><td><code id="segregation_index_+3A_.data">.data</code></td>
<td>
<p>a <code><a href="#topic+redist_plans">redist_plans</a></code> object</p>
</td></tr>
<tr><td><code id="segregation_index_+3A_plans">plans</code></td>
<td>
<p>A matrix of congressional district assignments or a
redist object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>redist.segcalc</code> returns a vector where each entry is the
dissimilarity index of segregation (Massey &amp; Denton 1987) for each
redistricting plan in <code>algout</code>.
</p>


<h3>References</h3>

<p>Fifield, Benjamin, Michael Higgins, Kosuke Imai and Alexander
Tarr. (2016) &quot;A New Automated Redistricting Simulator Using Markov Chain
Monte Carlo.&quot; Working Paper. Available at
<a href="http://imai.princeton.edu/research/files/redist.pdf">http://imai.princeton.edu/research/files/redist.pdf</a>.
</p>
<p>Massey, Douglas and Nancy Denton. (1987) &quot;The Dimensions of Social
Segregation&quot;. Social Forces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fl25)
data(fl25_enum)
data(fl25_adj)

## Get an initial partition
init_plan &lt;- fl25_enum$plans[, 5118]
fl25$init_plan &lt;- init_plan

## 25 precinct, three districts - no pop constraint ##
fl_map &lt;- redist_map(fl25, existing_plan = 'init_plan', adj = fl25_adj)
alg_253 &lt;- redist_flip(fl_map, nsims = 10000)


## Get Republican Dissimilarity Index from simulations
# old: rep_dmi_253 &lt;- redist.segcalc(alg_253, fl25$mccain, fl25$pop)
rep_dmi_253 &lt;- seg_dissim(alg_253, fl25, mccain, pop)  |&gt;
    redistmetrics::by_plan(ndists = 3)

</code></pre>

<hr>
<h2 id='subset_sampled'>Subset to sampled or reference draws</h2><span id='topic+subset_sampled'></span><span id='topic+subset_ref'></span>

<h3>Description</h3>

<p>Subset to sampled or reference draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_sampled(plans, matrix = TRUE)

subset_ref(plans, matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_sampled_+3A_plans">plans</code></td>
<td>
<p>the <code>redist_plans</code> object</p>
</td></tr>
<tr><td><code id="subset_sampled_+3A_matrix">matrix</code></td>
<td>
<p>if <code>TRUE</code>, the default, also subset the plans matrix. If
the plans matrix is not needed, turning this off may save some time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>redist_plans</code> object, with only rows corresponding to
simulated (or reference) draws remaining.
</p>

<hr>
<h2 id='summary.redist_plans'>Diagnostic information on sampled plans</h2><span id='topic+summary.redist_plans'></span>

<h3>Description</h3>

<p>Prints diagnostic information, which varies by algorithm. All algorithms
compute the <code><a href="#topic+plans_diversity">plans_diversity()</a></code> of the samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'redist_plans'
summary(object, district = 1L, all_runs = TRUE, vi_max = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.redist_plans_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+redist_plans">redist_plans</a> object</p>
</td></tr>
<tr><td><code id="summary.redist_plans_+3A_district">district</code></td>
<td>
<p>For R-hat values, which district to use for district-level
summary statistics. We strongly recommend calling <code>match_numbers()</code> or
<code>number_by()</code> before examining these district-level statistics.</p>
</td></tr>
<tr><td><code id="summary.redist_plans_+3A_all_runs">all_runs</code></td>
<td>
<p>When there are multiple SMC runs, show detailed summary
statistics for all runs (the default), or only the first run?</p>
</td></tr>
<tr><td><code id="summary.redist_plans_+3A_vi_max">vi_max</code></td>
<td>
<p>The maximum number of plans to sample in computing the pairwise
variation of information distance (sample diversity).</p>
</td></tr>
<tr><td><code id="summary.redist_plans_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For SMC and MCMC, if there are multiple runs/chains, R-hat values will be
computed for each summary statistic. These values should be close to 1.
If they are not, then there is too much between-chain variation, indicating
that there are not enough samples. R-hat values are calculated after
rank-normalization and folding.  MCMC chains are split in half before R-hat
is computed. For summary statistics that vary across districts, R-hat is
calculated for the first district only.
</p>
<p>For SMC, diagnostics statistics include:
</p>

<ul>
<li> <p><strong>Effective samples</strong>: the effective sample size at each iteration, computed
using the SMC weights. Larger is better. The percentage in parentheses is the
ratio of the effective samples to the total samples.
</p>
</li>
<li> <p><strong>Acceptance rate</strong>: the fraction of drawn spanning trees which yield a valid
redistricting plan within the population tolerance. Very small values (&lt; 1%)
can indicate a bottleneck and may lead to a lack of diversity.
</p>
</li>
<li> <p><strong>Standard deviation of the log weights</strong>: More variable weights (larger s.d.)
indicate less efficient sampling. Values greater than 3 are likely problematic.
</p>
</li>
<li> <p><strong>Maximum unique plans:</strong> an upper bound on the number of unique redistricting
plans that survive each stage. The percentage in parentheses is the ratio of
this number to the total number of samples. Small values (&lt; 100) indicate a
bottleneck, which leads to a loss of sample diversity and a higher variance.
</p>
</li>
<li> <p><strong>Estimated <code>k</code> parameter</strong>: How many spanning tree edges were considered for
cutting at each split. Mostly informational, though large jumps may indicate
a need to increase <code>adapt_k_thresh</code>.
</p>
</li>
<li> <p><strong>Bottleneck</strong>: An asterisk will appear in the right column if a bottleneck
appears likely, based on the values of the other statistics.
</p>
</li></ul>

<p>In the event of problematic diagnostics, the function will provide
suggestions for improvement.
</p>


<h3>Value</h3>

<p>A data frame containing diagnostic information, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iowa)
iowa_map &lt;- redist_map(iowa, ndists = 4, pop_tol = 0.1)
plans &lt;- redist_smc(iowa_map, 100)
summary(plans)

</code></pre>

<hr>
<h2 id='tally_var'>Tally a variable by district</h2><span id='topic+tally_var'></span>

<h3>Description</h3>

<p>Tally a variable by district
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tally_var(map, x, .data = pl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tally_var_+3A_map">map</code></td>
<td>
<p>a <code>redist_map</code> object</p>
</td></tr>
<tr><td><code id="tally_var_+3A_x">x</code></td>
<td>
<p>a variable to tally. Tidy-evaluated.</p>
</td></tr>
<tr><td><code id="tally_var_+3A_.data">.data</code></td>
<td>
<p>a <code>redist_plans</code> object or matrix of plans</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the tallied values by district and plan (column-major)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
