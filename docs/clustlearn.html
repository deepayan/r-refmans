<!DOCTYPE html><html><head><title>Help for package clustlearn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustlearn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agglomerative_clustering'><p>Agglomerative Hierarchical Clustering</p></a></li>
<li><a href='#db1'><p>Test Database 1</p></a></li>
<li><a href='#db2'><p>Test Database 2</p></a></li>
<li><a href='#db3'><p>Test Database 3</p></a></li>
<li><a href='#db4'><p>Test Database 4</p></a></li>
<li><a href='#db5'><p>Test Database 5</p></a></li>
<li><a href='#db6'><p>Test Database 6</p></a></li>
<li><a href='#dbscan'><p>Density Based Spatial Clustering of Applications with Noise (DBSCAN)</p></a></li>
<li><a href='#divisive_clustering'><p>Divisive Hierarchical Clustering</p></a></li>
<li><a href='#gaussian_mixture'><p>Gaussian mixture model</p></a></li>
<li><a href='#kmeans'><p>K-Means Clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Learn Clustering Techniques Through Examples and Code</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Clustering methods, which (if asked) can provide step-by-step
    explanations of the algorithms used, as described in Ezugwu et. al., (2022)
    &lt;<a href="https://doi.org/10.1016%2Fj.engappai.2022.104743">doi:10.1016/j.engappai.2022.104743</a>&gt;; and datasets to test them on, which
    highlight the strengths and weaknesses of each technique, as presented in
    the clustering section of 'scikit-learn' (Pedregosa et al., 2011)
    <a href="https://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html">https://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Ediu3095/clustlearn">https://github.com/Ediu3095/clustlearn</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Ediu3095/clustlearn/issues">https://github.com/Ediu3095/clustlearn/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>proxy (&ge; 0.4-27), cli (&ge; 3.6.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>deldir (&ge; 1.0-9)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-14 09:28:21 UTC; 3arci</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo Ruiz Sabajanes [aut, cre],
  Juan Jose Cuadrado Gallego
    <a href="https://orcid.org/0000-0001-8178-5556"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Universidad de Alcala [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo Ruiz Sabajanes &lt;eduardo.ruizs@edu.uah.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-14 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agglomerative_clustering'>Agglomerative Hierarchical Clustering</h2><span id='topic+agglomerative_clustering'></span>

<h3>Description</h3>

<p>Perform a hierarchical agglomerative cluster analysis on a set
of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agglomerative_clustering(
  data,
  proximity = "single",
  details = FALSE,
  waiting = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agglomerative_clustering_+3A_data">data</code></td>
<td>
<p>a set of observations, presented as a matrix-like object where
every row is a new observation.</p>
</td></tr>
<tr><td><code id="agglomerative_clustering_+3A_proximity">proximity</code></td>
<td>
<p>the proximity definition to be used. This should be one
of <code>"single"</code> (minimum/single linkage), <code>"complete"</code> (maximum/
complete linkage), <code>"average"</code> (average linkage).</p>
</td></tr>
<tr><td><code id="agglomerative_clustering_+3A_details">details</code></td>
<td>
<p>a Boolean determining whether intermediate logs explaining how
the algorithm works should be printed or not.</p>
</td></tr>
<tr><td><code id="agglomerative_clustering_+3A_waiting">waiting</code></td>
<td>
<p>a Boolean determining whether the intermediate logs should be
printed in chunks waiting for user input before printing the next or not.</p>
</td></tr>
<tr><td><code id="agglomerative_clustering_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a hierarchical cluster analysis for the
<code class="reqn">n</code> objects being clustered. The definition of a set of clusters using
this method follows a <code class="reqn">n</code> step process, which repeats until a single
cluster remains:
</p>

<ol>
<li><p> Initially, each object is assigned to its own cluster. The matrix
of distances between clusters is computed.
</p>
</li>
<li><p> The two clusters with closest proximity will be joined together and
the proximity matrix updated. This is done according to the specified
<code>proximity</code>. This step is repeated until a single cluster remains.
</p>
</li></ol>

<p>The definitions of <code>proximity</code> considered by this function are:
</p>

<dl>
<dt><code>single</code></dt><dd><p><code class="reqn">\min\left\{d(x,y):x\in A,y\in B\right\}</code>. Defines
the proximity between two clusters as the distance between the closest
objects among the two clusters. It produces clusters where each object is
closest to at least one other object in the same cluster. It is known as
<strong>SLINK</strong>, <strong>single-link</strong> and <strong>minimum-link</strong>.</p>
</dd>
<dt><code>complete</code></dt><dd><p><code class="reqn">\max\left\{d(x,y):x\in A,y\in B\right\}</code>.
Defines the proximity between two clusters as the distance between the
furthest objects among the two clusters. It is known as <strong>CLINK</strong>,
<strong>complete-link</strong> and <strong>maximum-link</strong>.</p>
</dd>
<dt><code>average</code></dt><dd><p><code class="reqn">\frac{1}{\left|A\right|\cdot\left|B\right|}
 \sum_{x\in A}\sum_{y\in B} d(x,y)</code>. Defines the proximity between two
clusters as the average distance between every pair of objects, one from
each cluster. It is also known as <strong>UPGMA</strong> or <strong>average-link</strong>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> object which describes the tree produced by the
clustering process.
</p>


<h3>Author(s)</h3>

<p>Eduardo Ruiz Sabajanes, <a href="mailto:eduardo.ruizs@edu.uah.es">eduardo.ruizs@edu.uah.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### !! This algorithm is very slow, so we'll only test it on some datasets !!

### Helper function
test &lt;- function(db, k, prox) {
  print(cl &lt;- clustlearn::agglomerative_clustering(db, prox))
  oldpar &lt;- par(mfrow = c(1, 2))
  plot(db, col = cutree(cl, k), asp = 1, pch = 20)
  h &lt;- rev(cl$height)[50]
  clu &lt;- as.hclust(cut(as.dendrogram(cl), h = h)$upper)
  ctr &lt;- unique(cutree(cl, k)[cl$order])
  plot(clu, labels = FALSE, hang = -1, xlab = "Cluster", sub = "", main = "")
  rect.hclust(clu, k = k, border = ctr)
  par(oldpar)
}

### Example 1
test(clustlearn::db1, 2, "single")

### Example 2
# test(clustlearn::db2, 2, "sing") # same as "single"

### Example 3
test(clustlearn::db3, 4, "a") # same as "average"

### Example 4
test(clustlearn::db4, 6, "s") # same as "single"

### Example 5
test(clustlearn::db5, 3, "complete")

### Example 6
# test(clustlearn::db6, 3, "c") # same as "complete"

### Example 7 (with explanations, no plots)
  cl &lt;- clustlearn::agglomerative_clustering(
  clustlearn::db5[1:6, ],
  'single',
  details = TRUE,
  waiting = FALSE
)

</code></pre>

<hr>
<h2 id='db1'>Test Database 1</h2><span id='topic+db1'></span>

<h3>Description</h3>

<p>Test Database 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db1
</code></pre>


<h3>Format</h3>



<h4><code>db1</code></h4>

<p>A data frame with 500 rows and 2 columns.
</p>
<p>The data points form two concentric circles.
</p>


<hr>
<h2 id='db2'>Test Database 2</h2><span id='topic+db2'></span>

<h3>Description</h3>

<p>Test Database 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db2
</code></pre>


<h3>Format</h3>



<h4><code>db2</code></h4>

<p>A data frame with 500 rows and 2 columns.
</p>
<p>The data points form two moons.
</p>


<hr>
<h2 id='db3'>Test Database 3</h2><span id='topic+db3'></span>

<h3>Description</h3>

<p>Test Database 3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db3
</code></pre>


<h3>Format</h3>



<h4><code>db3</code></h4>

<p>A data frame with 500 rows and 2 columns.
</p>
<p>The data points form three overlapping elliptical clusters of varying
densities.
</p>


<hr>
<h2 id='db4'>Test Database 4</h2><span id='topic+db4'></span>

<h3>Description</h3>

<p>Test Database 4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db4
</code></pre>


<h3>Format</h3>



<h4><code>db4</code></h4>

<p>A data frame with 500 rows and 2 columns.
</p>
<p>The data points form three diagonal parallel segments.
</p>


<hr>
<h2 id='db5'>Test Database 5</h2><span id='topic+db5'></span>

<h3>Description</h3>

<p>Test Database 5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db5
</code></pre>


<h3>Format</h3>



<h4><code>db5</code></h4>

<p>A data frame with 500 rows and 2 columns.
</p>
<p>The data points form three non-overlapping circular clusters of similar
density.
</p>


<hr>
<h2 id='db6'>Test Database 6</h2><span id='topic+db6'></span>

<h3>Description</h3>

<p>Test Database 6
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db6
</code></pre>


<h3>Format</h3>



<h4><code>db6</code></h4>

<p>A data frame with 500 rows and 2 columns.
</p>
<p>The data points are uniformly distributed on the plane.
</p>


<hr>
<h2 id='dbscan'>Density Based Spatial Clustering of Applications with Noise (DBSCAN)</h2><span id='topic+dbscan'></span>

<h3>Description</h3>

<p>Perform DBSCAN clustering on a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbscan(data, eps, min_pts = 4, details = FALSE, waiting = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbscan_+3A_data">data</code></td>
<td>
<p>a set of observations, presented as a matrix-like object where
every row is a new observation.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_eps">eps</code></td>
<td>
<p>how close two observations have to be to be considered neighbors.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_min_pts">min_pts</code></td>
<td>
<p>the minimum amount of neighbors for a region to be considered
dense.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_details">details</code></td>
<td>
<p>a Boolean determining whether intermediate logs explaining how
the algorithm works should be printed or not.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_waiting">waiting</code></td>
<td>
<p>a Boolean determining whether the intermediate logs should be
printed in chunks waiting for user input before printing the next or not.</p>
</td></tr>
<tr><td><code id="dbscan_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given by <code>data</code> is clustered by the DBSCAN method,
which aims to partition the points into clusters such that the points in a
cluster are close to each other and the points in different clusters are far
away from each other. The clusters are defined as dense regions of points
separated by regions of low density.
</p>
<p>The DBSCAN method follows a 2 step process:
</p>

<ol>
<li><p> For each point, the neighborhood of radius <code>eps</code> is computed. If
the neighborhood contains at least <code>min_pts</code> points, then the point is
considered a <strong>core point</strong>. Otherwise, the point is considered an
<strong>outlier</strong>.
</p>
</li>
<li><p> For each core point, if the core point is not already assigned to a
cluster, a new cluster is created and the core point is assigned to it.
Then, the neighborhood of the core point is explored. If a point in the
neighborhood is a core point, then the neighborhood of that point is also
explored. This process is repeated until all points in the neighborhood have
been explored. If a point in the neighborhood is not already assigned to a
cluster, then it is assigned to the cluster of the core point.
</p>
</li></ol>

<p>Whatever points are not assigned to a cluster are considered outliers.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+dbscan">dbscan()</a></code> object. It is a list with the following
components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>cluster</code> </td><td style="text-align: left;"> a vector of integers (from 0 to <code>max(cl$cluster)</code>)
indicating the cluster to which each point belongs. Points in cluster number
0 are considered outliers. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>eps</code> </td><td style="text-align: left;"> the value of <code>eps</code> used. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>min_pts</code> </td><td style="text-align: left;"> the value of <code>min_pts</code> used. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>size</code> </td><td style="text-align: left;"> a vector with the number of data points belonging to each
cluster (where the first element is the number of outliers). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Eduardo Ruiz Sabajanes, <a href="mailto:eduardo.ruizs@edu.uah.es">eduardo.ruizs@edu.uah.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Helper function
test &lt;- function(db, eps) {
  print(cl &lt;- clustlearn::dbscan(db, eps))
  out &lt;- cl$cluster == 0
  plot(db[!out, ], col = cl$cluster[!out], pch = 20, asp = 1)
  points(db[out, ], col = max(cl$cluster) + 1, pch = 4, lwd = 2)
}

### Example 1
test(clustlearn::db1, 0.3)

### Example 2
test(clustlearn::db2, 0.3)

### Example 3
test(clustlearn::db3, 0.25)

### Example 4
test(clustlearn::db4, 0.2)

### Example 5
test(clustlearn::db5, 0.3)

### Example 6
test(clustlearn::db6, 0.3)

### Example 7 (with explanations, no plots)
  cl &lt;- clustlearn::dbscan(
  clustlearn::db5[1:20, ],
  0.3,
  details = TRUE,
  waiting = FALSE
)

</code></pre>

<hr>
<h2 id='divisive_clustering'>Divisive Hierarchical Clustering</h2><span id='topic+divisive_clustering'></span>

<h3>Description</h3>

<p>Perform a hierarchical Divisive cluster analysis on a set of
observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisive_clustering(data, details = FALSE, waiting = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisive_clustering_+3A_data">data</code></td>
<td>
<p>a set of observations, presented as a matrix-like object where
every row is a new observation.</p>
</td></tr>
<tr><td><code id="divisive_clustering_+3A_details">details</code></td>
<td>
<p>a Boolean determining whether intermediate logs explaining how
the algorithm works should be printed or not.</p>
</td></tr>
<tr><td><code id="divisive_clustering_+3A_waiting">waiting</code></td>
<td>
<p>a Boolean determining whether the intermediate logs should be
printed in chunks waiting for user input before printing the next or not.</p>
</td></tr>
<tr><td><code id="divisive_clustering_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+kmeans">kmeans()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a hierarchical cluster analysis for the
<code class="reqn">n</code> objects being clustered. The definition of a set of clusters using
this method follows a <code class="reqn">n</code> step process, which repeats until <code class="reqn">n</code>
clusters remain:
</p>

<ol>
<li><p> Initially, each object is assigned to the same cluster. The sum of
squares of the distances between objects and their cluster center is
computed.
</p>
</li>
<li><p> The cluster with the highest sum of squares is split into two using
the k-means algorithm. This step is repeated until <code class="reqn">n</code> clusters remain.
</p>
</li></ol>



<h3>Value</h3>

<p>An <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> object which describes the tree produced by the
clustering process.
</p>


<h3>Author(s)</h3>

<p>Eduardo Ruiz Sabajanes, <a href="mailto:eduardo.ruizs@edu.uah.es">eduardo.ruizs@edu.uah.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### !! This algorithm is very slow, so we'll only test it on some datasets !!

### Helper function
test &lt;- function(db, k) {
  print(cl &lt;- clustlearn::divisive_clustering(db, max_iterations = 5))
  par(mfrow = c(1, 2))
  plot(db, col = cutree(cl, k), asp = 1, pch = 20)
  h &lt;- rev(cl$height)[50]
  clu &lt;- as.hclust(cut(as.dendrogram(cl), h = h)$upper)
  ctr &lt;- unique(cutree(cl, k)[cl$order])
  plot(clu, labels = FALSE, hang = -1, xlab = "Cluster", sub = "", main = "")
  rect.hclust(clu, k = k, border = ctr)
}

### Example 1
# test(clustlearn::db1, 2)

### Example 2
# test(clustlearn::db2, 2)

### Example 3
# test(clustlearn::db3, 3)

### Example 4
# test(clustlearn::db4, 3)

### Example 5
test(clustlearn::db5, 3)

### Example 6
test(clustlearn::db6, 3)

### Example 7 (with explanations, no plots)
  cl &lt;- clustlearn::divisive_clustering(
  clustlearn::db5[1:6, ],
  details = TRUE,
  waiting = FALSE
)

</code></pre>

<hr>
<h2 id='gaussian_mixture'>Gaussian mixture model</h2><span id='topic+gaussian_mixture'></span>

<h3>Description</h3>

<p>Perform Gaussian mixture model clustering on a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_mixture(data, k, max_iter = 10, details = FALSE, waiting = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_mixture_+3A_data">data</code></td>
<td>
<p>a set of observations, presented as a matrix-like object where
every row is a new observation.</p>
</td></tr>
<tr><td><code id="gaussian_mixture_+3A_k">k</code></td>
<td>
<p>the number of clusters to find.</p>
</td></tr>
<tr><td><code id="gaussian_mixture_+3A_max_iter">max_iter</code></td>
<td>
<p>the maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="gaussian_mixture_+3A_details">details</code></td>
<td>
<p>a Boolean determining whether intermediate logs explaining how
the algorithm works should be printed or not.</p>
</td></tr>
<tr><td><code id="gaussian_mixture_+3A_waiting">waiting</code></td>
<td>
<p>a Boolean determining whether the intermediate logs should be
printed in chunks waiting for user input before printing the next or not.</p>
</td></tr>
<tr><td><code id="gaussian_mixture_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+kmeans">kmeans()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given by <code>data</code> is clustered by the model-based
algorithm that assumes every cluster follows a normal distribution, thus
the name &quot;Gaussian Mixture&quot;.
</p>
<p>The normal distributions are parameterized by their mean vector, covariance
matrix and mixing proportion. Initially, the mean vector is set to the
cluster centers obtained by performing a k-means clustering on the data,
the covariance matrix is set to the covariance matrix of the data points
belonging to each cluster and the mixing proportion is set to the proportion
of data points belonging to each cluster. The algorithm then optimizes the
gaussian models by means of the Expectation Maximization (EM) algorithm.
</p>
<p>The EM algorithm is an iterative algorithm that alternates between two steps:
</p>

<dl>
<dt>Expectation</dt><dd><p>Compute how much is each observation expected to belong
to each component of the GMM.</p>
</dd>
<dt>Maximization</dt><dd><p>Recompute the GMM according to the expectations from
the E-step in order to maximize them.</p>
</dd>
</dl>

<p>The algorithm stops when the changes in the expectations are sufficiently
small or when a maximum number of iterations is reached.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+gaussian_mixture">gaussian_mixture()</a></code> object. It is a list with the
following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>cluster</code> </td><td style="text-align: left;"> a vector of integers (from <code>1:k</code>) indicating the
cluster to which each point belongs. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mu</code> </td><td style="text-align: left;"> the final mean parameters. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sigma</code> </td><td style="text-align: left;"> the final covariance matrices. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lambda</code> </td><td style="text-align: left;"> the final mixing proportions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>loglik</code> </td><td style="text-align: left;"> the final log likelihood. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>all.loglik</code> </td><td style="text-align: left;"> a vector of each iteration's log likelihood. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>iter</code> </td><td style="text-align: left;"> the number of iterations performed. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>size</code> </td><td style="text-align: left;"> a vector with the number of data points belonging to each
cluster. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Eduardo Ruiz Sabajanes, <a href="mailto:eduardo.ruizs@edu.uah.es">eduardo.ruizs@edu.uah.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### !! This algorithm is very slow, so we'll only test it on some datasets !!

### Helper functions
dmnorm &lt;- function(x, mu, sigma) {
  k &lt;- ncol(sigma)

  x  &lt;- as.matrix(x)
  diff &lt;- t(t(x) - mu)

  num &lt;- exp(-1 / 2 * diag(diff %*% solve(sigma) %*% t(diff)))
  den &lt;- sqrt(((2 * pi)^k) * det(sigma))
  num / den
}

test &lt;- function(db, k) {
  print(cl &lt;- clustlearn::gaussian_mixture(db, k, 100))

  x &lt;- seq(min(db[, 1]), max(db[, 1]), length.out = 100)
  y &lt;- seq(min(db[, 2]), max(db[, 2]), length.out = 100)

  plot(db, col = cl$cluster, asp = 1, pch = 20)
  for (i in seq_len(k)) {
    m &lt;- cl$mu[i, ]
    s &lt;- cl$sigma[i, , ]
    f &lt;- function(x, y) cl$lambda[i] * dmnorm(cbind(x, y), m, s)
    z &lt;- outer(x, y, f)
    contour(x, y, z, col = i, add = TRUE)
  }
}

### Example 1
test(clustlearn::db1, 2)

### Example 2
# test(clustlearn::db2, 2)

### Example 3
test(clustlearn::db3, 3)

### Example 4
test(clustlearn::db4, 3)

### Example 5
test(clustlearn::db5, 3)

### Example 6
# test(clustlearn::db6, 3)

### Example 7 (with explanations, no plots)
cl &lt;- clustlearn::gaussian_mixture(
  clustlearn::db5[1:20, ],
  3,
  details = TRUE,
  waiting = FALSE
)

</code></pre>

<hr>
<h2 id='kmeans'>K-Means Clustering</h2><span id='topic+kmeans'></span>

<h3>Description</h3>

<p>Perform K-Means clustering on a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans(
  data,
  centers,
  max_iterations = 10,
  initialization = "kmeans++",
  details = FALSE,
  waiting = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeans_+3A_data">data</code></td>
<td>
<p>a set of observations, presented as a matrix-like object where
every row is a new observation.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_centers">centers</code></td>
<td>
<p>either the number of clusters or a set of initial cluster
centers. If a number, the centers are chosen according to the
<code>initialization</code> parameter.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_max_iterations">max_iterations</code></td>
<td>
<p>the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_initialization">initialization</code></td>
<td>
<p>the initialization method to be used. This should be
one of <code>"random"</code> or <code>"kmeans++"</code>. The latter is the default.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_details">details</code></td>
<td>
<p>a Boolean determining whether intermediate logs explaining how
the algorithm works should be printed or not.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_waiting">waiting</code></td>
<td>
<p>a Boolean determining whether the intermediate logs should be
printed in chunks waiting for user input before printing the next or not.</p>
</td></tr>
<tr><td><code id="kmeans_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data given by <code>data</code> is clustered by the <code class="reqn">k</code>-means
method, which aims to partition the points into <code class="reqn">k</code> groups such that the
sum of squares from points to the assigned cluster centers is minimized. At
the minimum, all cluster centers are at the mean of their Voronoi sets (the
set of data points which are nearest to the cluster center).
</p>
<p>The <code class="reqn">k</code>-means method follows a 2 to <code class="reqn">n</code> step process:
</p>

<ol>
<li><p> The first step can be subdivided into 3 steps: </p>

<ol>
<li><p> Selection of the number <code class="reqn">k</code> of clusters, into which the data is
going to be grouped and of which the centers will be the representatives.
This is determined through the use of the <code>centers</code> parameter.
</p>
</li>
<li><p> Computation of the distance from each data point to each center.
</p>
</li>
<li><p> Assignment of each observation to a cluster. The observation is
assigned to the cluster represented by the nearest center.
</p>
</li></ol>

</li>
<li><p> The next steps are just like the first but for the first sub-step:
</p>

<ol>
<li><p> Computation of the new centers. The center of each cluster is
computed as the mean of the observations assigned to said cluster.
</p>
</li></ol>

</li></ol>

<p>The algorithm stops once the centers in step <code class="reqn">n+1</code> are the same as the
ones in step <code class="reqn">n</code>. However, this convergence does not always take place.
For this reason, the algorithm also stops once a maximum number of iterations
<code>max_iterations</code> is reached.
</p>
<p>The <code>initialization</code> methods provided by this function are:
</p>

<dl>
<dt><code>random</code></dt><dd><p>A set of <code>centers</code> observations is chosen at
random from the data as the initial centers.</p>
</dd>
<dt><code>kmeans++</code></dt><dd><p>The <code>centers</code> observations are chosen using the
<strong>kmeans++</strong> algorithm. This algorithm chooses the first center at
random and then chooses the next center from the remaining observations with
probability proportional to the square distance to the closest center. This
process is repeated until <code>centers</code> centers are chosen.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Eduardo Ruiz Sabajanes, <a href="mailto:eduardo.ruizs@edu.uah.es">eduardo.ruizs@edu.uah.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Voronoi tesselation
voronoi &lt;- suppressMessages(suppressWarnings(require(deldir)))
cols &lt;- c(
  "#00000019",
  "#DF536B19",
  "#61D04F19",
  "#2297E619",
  "#28E2E519",
  "#CD0BBC19",
  "#F5C71019",
  "#9E9E9E19"
)

### Helper function
test &lt;- function(db, k) {
  print(cl &lt;- clustlearn::kmeans(db, k, 100))
  plot(db, col = cl$cluster, asp = 1, pch = 20)
  points(cl$centers, col = seq_len(k), pch = 13, cex = 2, lwd = 2)

  if (voronoi) {
    x &lt;- c(min(db[, 1]), max(db[, 1]))
    dx &lt;- c(x[1] - x[2], x[2] - x[1])
    y &lt;- c(min(db[, 2]), max(db[, 2]))
    dy &lt;- c(y[1] - y[2], y[2] - y[1])
    tesselation &lt;- deldir(
      cl$centers[, 1],
      cl$centers[, 2],
      rw = c(x + dx, y + dy)
    )
    tiles &lt;- tile.list(tesselation)

    plot(
      tiles,
      asp = 1,
      add = TRUE,
      showpoints = FALSE,
      border = "#00000000",
      fillcol = cols
    )
  }
}

### Example 1
test(clustlearn::db1, 2)

### Example 2
test(clustlearn::db2, 2)

### Example 3
test(clustlearn::db3, 3)

### Example 4
test(clustlearn::db4, 3)

### Example 5
test(clustlearn::db5, 3)

### Example 6
test(clustlearn::db6, 3)

### Example 7 (with explanations, no plots)
cl &lt;- clustlearn::kmeans(
  clustlearn::db5[1:20, ],
  3,
  details = TRUE,
  waiting = FALSE
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
