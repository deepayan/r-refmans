<!DOCTYPE html><html lang="en"><head><title>Help for package spFSR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spFSR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#getBestModel'><p>Extracting the wrapped model of the best performing features from a spFSR object</p></a></li>
<li><a href='#getImportance'><p>Extracting feature importance data from a spFSR object</p></a></li>
<li><a href='#plot.spFSR'><p>Ploting a spFSR object</p></a></li>
<li><a href='#plotImportance'><p>Ploting importance ranks of best performing features from a spFSR object</p></a></li>
<li><a href='#spFeatureSelection'><p>SPSA-FSR for Feature Selection and Ranking</p></a></li>
<li><a href='#spFSR.default'><p>Default Function of SP-FSR for Feature Selection and Ranking</p></a></li>
<li><a href='#summary.spFSR'><p>Summarising a spFSR object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Feature Selection and Ranking via Simultaneous Perturbation
Stochastic Approximation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of feature selection, weighting and ranking via simultaneous perturbation
    stochastic approximation (SPSA). The SPSA-FSR algorithm searches for a locally optimal set of
    features that yield the best predictive performance using some error measures such as mean 
    squared error (for regression problems) and accuracy rate (for classification problems).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr3 (&ge; 0.14.0), future (&ge; 1.28.0), tictoc (&ge; 1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mlr3pipelines (&ge; 0.4.2), mlr3learners (&ge; 0.5.4), ranger (&ge;
0.14.1), parallel (&ge; 3.4.2), ggplot2 (&ge; 2.2.1), lgr (&ge;
0.4.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret (&ge; 6.0), MASS (&ge; 7.3)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.featureranking.com/">https://www.featureranking.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yongkai17/spFSR/issues">https://github.com/yongkai17/spFSR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-16 23:19:58 UTC; anders</td>
</tr>
<tr>
<td>Author:</td>
<td>David Akman [aut, cre],
  Babak Abbasi [aut, ctb],
  Yong Kai Wong [aut, ctb],
  Guo Feng Anders Yeo [aut, ctb],
  Zeren D. Yenice [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Akman &lt;david.v.akman@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-17 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='getBestModel'>Extracting the wrapped model of the best performing features from a spFSR object</h2><span id='topic+getBestModel'></span>

<h3>Description</h3>

<p>A fitted model uses the best performing feature subsets. It inherits all methods or functions applied to a <code>WrappedModel</code> objects. For example, the <code>predict</code> function can be used on the fitted model. See <a href="#topic+spFeatureSelection">spFeatureSelection</a> for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBestModel(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBestModel_+3A_x">x</code></td>
<td>
<p>a <code>spFSR</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>WrappedModel</code> object of the best performing features.
</p>


<h3>See Also</h3>

<p><a href="#topic+spFeatureSelection">spFeatureSelection</a>
</p>

<hr>
<h2 id='getImportance'>Extracting feature importance data from a spFSR object</h2><span id='topic+getImportance'></span>

<h3>Description</h3>

<p>This returns importance ranks of best performing features. See <a href="#topic+spFeatureSelection">spFeatureSelection</a> for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getImportance(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getImportance_+3A_x">x</code></td>
<td>
<p>a <code>spFSR</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of features and feature importance
</p>


<h3>See Also</h3>

<p><a href="#topic+plotImportance">plotImportance</a> and <a href="#topic+spFeatureSelection">spFeatureSelection</a>.
</p>

<hr>
<h2 id='plot.spFSR'>Ploting a spFSR object</h2><span id='topic+plot.spFSR'></span>

<h3>Description</h3>

<p>Plot for a spFSR object. It provides a scatterplot of scoring values vs. iteration. The error bar of scoring values at each iteration can be included. It also allows user to identify the iteration which yields the best scoring value. See <a href="#topic+spFeatureSelection">spFeatureSelection</a> for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spFSR'
plot(x, errorBar = FALSE, annotateBest = FALSE, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.spFSR_+3A_x">x</code></td>
<td>
<p>a <code>spFSR</code> object</p>
</td></tr>
<tr><td><code id="plot.spFSR_+3A_errorbar">errorBar</code></td>
<td>
<p>If <code>TRUE</code>, an error bar of +/- 1 standard deviation will be included around the mean error scoring value at each iteration. When it is <code>TRUE</code>, the <code>ylim</code> argument cannot be used. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.spFSR_+3A_annotatebest">annotateBest</code></td>
<td>
<p>If <code>TRUE</code>, the best result will be highlighted and annotated. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.spFSR_+3A_se">se</code></td>
<td>
<p>If <code>TRUE</code>, an error bar of <code class="reqn">\pm</code> standard error will be included around the mean error scoring value at each iteration. When it is <code>TRUE</code>, the <code>ylim</code> argument cannot be used. The <code>se</code> does not produce any error bar if <code>errorBar</code> is set as <code>FALSE</code>. Note that if the standard error is used, the error bar has a narrower range. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.spFSR_+3A_...">...</code></td>
<td>
<p>Additional plot parameters that can be passed into the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot error scoring values vs iterations of a spFSR object with an error bar (if included).
</p>


<h3>See Also</h3>

<p><a href="#topic+plotImportance">plotImportance</a> and <a href="#topic+spFeatureSelection">spFeatureSelection</a>.
</p>

<hr>
<h2 id='plotImportance'>Ploting importance ranks of best performing features from a spFSR object</h2><span id='topic+plotImportance'></span>

<h3>Description</h3>

<p>A vertical bar chart of features vs. feature importance. See <a href="#topic+spFeatureSelection">spFeatureSelection</a> for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImportance(x, low = "darkblue", high = "black")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotImportance_+3A_x">x</code></td>
<td>
<p>a <code>spFSR</code> object</p>
</td></tr>
<tr><td><code id="plotImportance_+3A_low">low</code></td>
<td>
<p>Color for the lowest importance. The default is darkblue.</p>
</td></tr>
<tr><td><code id="plotImportance_+3A_high">high</code></td>
<td>
<p>Color for the highest importance. The default is black.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object: a vertical bar chart of features and feature importance.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotImportance">plotImportance</a>, <a href="#topic+spFSR.default">spFSR.default</a>, and <a href="#topic+spFeatureSelection">spFeatureSelection</a>.
</p>

<hr>
<h2 id='spFeatureSelection'>SPSA-FSR for Feature Selection and Ranking</h2><span id='topic+spFeatureSelection'></span>

<h3>Description</h3>

<p>This function searches for the best performing features and rank the feature importance by implementing simultaneous perturbation stochastic approximation (SPSA) algorithm given a task and a wrapper. The task and wrapper are defined using the <span class="pkg">mlr3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spFeatureSelection(task, wrapper = NULL, scoring = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spFeatureSelection_+3A_task">task</code></td>
<td>
<p>A <code>task</code> object created using <span class="pkg">mlr3</span> package. It must be either a <code>ClassifTask</code> or <code>RegrTask</code> object.</p>
</td></tr>
<tr><td><code id="spFeatureSelection_+3A_wrapper">wrapper</code></td>
<td>
<p>A <code>Learner</code> object created using <span class="pkg">mlr3</span> package. Multiple learners object is not supported.</p>
</td></tr>
<tr><td><code id="spFeatureSelection_+3A_scoring">scoring</code></td>
<td>
<p>A performance measure within the <span class="pkg">mlr3</span> package supported by the <code>task</code>.</p>
</td></tr>
<tr><td><code id="spFeatureSelection_+3A_...">...</code></td>
<td>
<p>Additional arguments. For more details, see <a href="#topic+spFSR.default">spFSR.default</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>spFSR</code> returns an object of class &quot;spFSR&quot;. An object of class &quot;spFSR&quot; consists of the following:
</p>
<table role = "presentation">
<tr><td><code>task.spfs</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>tsk</code> object defined on the best performing features.</p>
</td></tr>
<tr><td><code>wrapper</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>lrn</code> object, default is random forest.</p>
</td></tr>
<tr><td><code>scoring</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>msr</code> object as specified by the user.</p>
</td></tr>
<tr><td><code>param best.model</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>model</code> object trained by the <code>wrapper</code> using <code>task.spfs</code>.</p>
</td></tr>
<tr><td><code>iter.results</code></td>
<td>
<p>A <code>data.frame</code> object containing detailed information on each iteration.</p>
</td></tr>
<tr><td><code>features</code></td>
<td>
<p>Names of the best performing features.</p>
</td></tr>
<tr><td><code>num.features</code></td>
<td>
<p>The number of best performing features.</p>
</td></tr>
<tr><td><code>importance</code></td>
<td>
<p>A vector of importance ranks of the best performing features.</p>
</td></tr>
<tr><td><code>total.iters</code></td>
<td>
<p>The total number of iterations executed.</p>
</td></tr>
<tr><td><code>best.iter</code></td>
<td>
<p>The iteration where the best performing feature subset was encountered.</p>
</td></tr>
<tr><td><code>best.value</code></td>
<td>
<p>The best measure value encountered during execution.</p>
</td></tr>
<tr><td><code>best.std</code></td>
<td>
<p>The standard deviation corresponding to the best measure value encountered.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>Total run time in minutes</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>Dataframe with boolean of selected features, names and measure</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call</p>
</td></tr>
</table>


<h3>References</h3>

<p>David V. Akman et al. (2022) k-best feature selection and ranking via stochastic approximation,  <em>Expert Systems with Applications</em>, <b>Vol. 213</b>. See <a href="https://doi.org/10.1016/j.eswa.2022.118864">doi:10.1016/j.eswa.2022.118864</a>
</p>
<p>G.F.A Yeo and V. Aksakalli (2021) A stochastic approximation approach to simultaneous feature weighting and selection for nearest neighbour learners,  <em>Expert Systems with Applications</em>, <b>Vol. 185</b>. See <a href="https://doi.org/10.1016/j.eswa.2021.115671">doi:10.1016/j.eswa.2021.115671</a>
</p>


<h3>See Also</h3>

<p><a href="mlr3.html#topic+tsk">tsk</a>, <a href="mlr3.html#topic+lrn">lrn</a>, <a href="mlr3.html#topic+msr">msr</a> and <a href="#topic+spFSR.default">spFSR.default</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mlr3)          # load the mlr3 package
library(mlr3learners) # load the mlr3learners package

task    &lt;- tsk('iris') # define task
wrapper &lt;- lrn('classif.rpart')                # define wrapper
measure &lt;- msr('classif.acc')

# run spsa
spsaMod &lt;- spFeatureSelection( task = task,
                               wrapper = wrapper,
                               scoring = measure,
                               num.features.selected = 3,
                               n.jobs = 1,
                               iters.max = 2,
                               num.grad.avg = 1)


# obtain summary
summary(spsaMod)

# plot spsaMod
plot(spsaMod)                                # simplest plot
plot(spsaMod, errorBar = TRUE)               # plot with error bars
plot(spsaMod, errorBar = TRUE, se = TRUE)    # plot with error bars based on se
plot(spsaMod, errorBar = TRUE, annotateBest = TRUE)  # annotate best value
plot(spsaMod, errorBar = TRUE, ylab = 'Acc measure', type = 'o')

# obtain the wrapped model with the best performing features
bestMod &lt;- getBestModel(spsaMod)

# predict using the best mod
pred &lt;- bestMod$predict( task = spsaMod$task.spfs )

# Obtain confusion matrix
pred$confusion

# Get the importance ranks of best performing features
getImportance(spsaMod)
plotImportance(spsaMod)


</code></pre>

<hr>
<h2 id='spFSR.default'>Default Function of SP-FSR for Feature Selection and Ranking</h2><span id='topic+spFSR.default'></span>

<h3>Description</h3>

<p>This is the default function of <a href="#topic+spFeatureSelection">spFeatureSelection</a>. See <a href="#topic+spFeatureSelection">spFeatureSelection</a> for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spFSR.default(
  task,
  wrapper = NULL,
  scoring = NULL,
  perturb.amount = 0.05,
  gain.min = 0.01,
  gain.max = 2,
  change.min = 0,
  change.max = 0.2,
  bb.bottom.threshold = 10^(-8),
  mon.gain.A = 100,
  mon.gain.a = 0.75,
  mon.gain.alpha = 0.6,
  hot.start.num.ft.factor = 15,
  hot.start.max.auto.num.ft = 150,
  use.hot.start = TRUE,
  hot.start.range = 0.2,
  rf.n.estimators = 50,
  gain.type = "bb",
  num.features.selected = 0L,
  iters.max = 100L,
  stall.limit = 35L,
  n.samples.max = 5000,
  ft.weighting = FALSE,
  encoding.type = "encode",
  is.debug = FALSE,
  stall.tolerance = 10^(-8),
  random.state = 1,
  rounding = 3,
  run.parallel = TRUE,
  n.jobs = NULL,
  show.info = TRUE,
  print.freq = 10L,
  num.cv.folds = 5L,
  num.cv.reps.eval = 3L,
  num.cv.reps.grad = 1L,
  num.grad.avg = 4L,
  perf.eval.method = "cv"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spFSR.default_+3A_task">task</code></td>
<td>
<p>A task <code>tsk</code> object created using <span class="pkg">mlr3</span> package. It must be either a <code>ClassifTask</code> or <code>RegrTask</code> object.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_wrapper">wrapper</code></td>
<td>
<p>A Learner <code>lrn</code> object created using <span class="pkg">mlr3</span> package or a <code>GraphLearner</code> object created using <span class="pkg">mlr3pipelines</span> package. Multiple learners object is not supported. If left empty will select random forest by default.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_scoring">scoring</code></td>
<td>
<p>A performance measure <code>msr</code> within the <span class="pkg">mlr3</span> package supported by the <code>task</code>. If left blank will select accuracy for classification and r-squared for regression.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_perturb.amount">perturb.amount</code></td>
<td>
<p>Perturbation amount for feature importances during gradient approximation. It must be a value between 0.01 and 0.1. Default value is 0.05.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_gain.min">gain.min</code></td>
<td>
<p>The minimum gain value. It must be greater than or equal to 0.001. Default value is 0.01.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_gain.max">gain.max</code></td>
<td>
<p>The maximum gain value. It must be greater than or equal to <code>gain.min</code>.  Default value is 1.0.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_change.min">change.min</code></td>
<td>
<p>The minimum change value. It must be non-negative. Default value is 0.0.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_change.max">change.max</code></td>
<td>
<p>The maximum change value. It must be greater than <code>change.min</code>. Default is 0.2.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_bb.bottom.threshold">bb.bottom.threshold</code></td>
<td>
<p>The threshold value of denominator for the Barzilai-Borwein gain sequence. It must be positive. Default is 1/10^8.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_mon.gain.a">mon.gain.A</code></td>
<td>
<p>Parameter for the monetone gain sequence. It must be a positive integer. Default is 100.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_mon.gain.a">mon.gain.a</code></td>
<td>
<p>Parameter for the monetone gain sequence. It must be positive. Default is 0.75.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_mon.gain.alpha">mon.gain.alpha</code></td>
<td>
<p>Parameter for the monetone gain sequence. It must be between (0, 1). Default is 0.6.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_hot.start.num.ft.factor">hot.start.num.ft.factor</code></td>
<td>
<p>The factor of features to select for hot start. Must be an integer greater than 1. Default is 15.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_hot.start.max.auto.num.ft">hot.start.max.auto.num.ft</code></td>
<td>
<p>The maximum initial number of features for automatic hot start. Must be an integer greater than 1. Default is 75.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_use.hot.start">use.hot.start</code></td>
<td>
<p>Logical argument. Whether hot start should be used. Default is True.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_hot.start.range">hot.start.range</code></td>
<td>
<p>Float, the initial range of imputations carried over from hot start. It must be between (0,1). Default is 0.2.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_rf.n.estimators">rf.n.estimators</code></td>
<td>
<p>integer, The number of trees to use in the random forest hot start. The default is 50.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_gain.type">gain.type</code></td>
<td>
<p>The gain sequence to use. Accepted methods are 'bb' for Barzilai-Borwein or 'mon' for a monetonic gain sequence. Default is 'bb'.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_num.features.selected">num.features.selected</code></td>
<td>
<p>Number of features selected. It must be a nonnegative integer and must not exceed the total number of features in the task. A value of 0 results in automatic feature selection. Default value is 0L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_iters.max">iters.max</code></td>
<td>
<p>Maximum number of iterations to execute. The minimum value is 2L. Default value is 300L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_stall.limit">stall.limit</code></td>
<td>
<p>Number of iterations to stall, that is, to continue without at least <code>stall.tolerance</code> improvement to the measure value. The mininum value is 2L. Default value is 100L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_n.samples.max">n.samples.max</code></td>
<td>
<p>The maximum number of samples to select from sampling. It must be a non-negative integer. Default is 2500.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_ft.weighting">ft.weighting</code></td>
<td>
<p>Logical argument. Include simultaneous feature weighting and selection?. Default is FALSE.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_encoding.type">encoding.type</code></td>
<td>
<p>Encoding method for factor features for feature weighting, default is 'encoded'.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_is.debug">is.debug</code></td>
<td>
<p>Logical argument. Print additional debug messages? Default value is FALSE.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_stall.tolerance">stall.tolerance</code></td>
<td>
<p>Value of stall tolerance. It must be strictly positive. Default value is 1/10^8.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_random.state">random.state</code></td>
<td>
<p>random state used. Default is 1.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_rounding">rounding</code></td>
<td>
<p>The number of digits to round results. It must be a positive integer. Default value is 3.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_run.parallel">run.parallel</code></td>
<td>
<p>Logical argument. Perform cross-validations in parallel? Default value is TRUE.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_n.jobs">n.jobs</code></td>
<td>
<p>Number of cores to use in case of a parallel run. It must be less than or equal to the total number of cores on the host machine. If set to <code>NULL</code> when <code>run.parallel</code> is <code>TRUE</code>, it is taken as one less of the total number of cores.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_show.info">show.info</code></td>
<td>
<p>If set to <code>TRUE</code>, iteration information is displayed at print frequency.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_print.freq">print.freq</code></td>
<td>
<p>Iteration information printing frequency. It must be a positive integer. Default value is 10L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_num.cv.folds">num.cv.folds</code></td>
<td>
<p>The number of cross-validation folds when 'cv' is selected as <code>perf.eval.method</code>. The minimum value is 3L. Default value is 5L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_num.cv.reps.eval">num.cv.reps.eval</code></td>
<td>
<p>The number of cross-validation repetitions for feature subset evaluation. It must be a positive integer. Default value is 3L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_num.cv.reps.grad">num.cv.reps.grad</code></td>
<td>
<p>The number of cross-validation repetitions for gradient averaging. It must be a positive integer. Default value is 1L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_num.grad.avg">num.grad.avg</code></td>
<td>
<p>Number of gradients to average for gradient approximation. It must be a positive integer. Default value is 4L.</p>
</td></tr>
<tr><td><code id="spFSR.default_+3A_perf.eval.method">perf.eval.method</code></td>
<td>
<p>Performance evaluation method. It must be either 'cv' for cross-validation or 'resub' for resubstitution. Default is 'cv'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>spFSR</code> returns an object of class &quot;spFSR&quot;. An object of class &quot;spFSR&quot; consists of the following:
</p>
<table role = "presentation">
<tr><td><code>task.spfs</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>tsk</code> object defined on the best performing features.</p>
</td></tr>
<tr><td><code>wrapper</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>lrn</code> object or a <span class="pkg">mlr3pipelines</span> package <code>GraphLearner</code> object as specified by the user.</p>
</td></tr>
<tr><td><code>scoring</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>msr</code> as specified by the user.</p>
</td></tr>
<tr><td><code>param best.model</code></td>
<td>
<p>An <span class="pkg">mlr3</span> package <code>model</code> object trained by the <code>wrapper</code> using <code>task.spfs</code>.</p>
</td></tr>
<tr><td><code>iter.results</code></td>
<td>
<p>A <code>data.frame</code> object containing detailed information on each iteration.</p>
</td></tr>
<tr><td><code>features</code></td>
<td>
<p>Names of the best performing features.</p>
</td></tr>
<tr><td><code>num.features</code></td>
<td>
<p>The number of best performing features.</p>
</td></tr>
<tr><td><code>importance</code></td>
<td>
<p>A vector of importance ranks of the best performing features.</p>
</td></tr>
<tr><td><code>total.iters</code></td>
<td>
<p>The total number of iterations executed.</p>
</td></tr>
<tr><td><code>best.iter</code></td>
<td>
<p>The iteration where the best performing feature subset was encountered.</p>
</td></tr>
<tr><td><code>best.value</code></td>
<td>
<p>The best measure value encountered during execution.</p>
</td></tr>
<tr><td><code>best.std</code></td>
<td>
<p>The standard deviation corresponding to the best measure value encountered.</p>
</td></tr>
<tr><td><code>run.time</code></td>
<td>
<p>Total run time in minutes.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>Dataframe with boolean of selected features, names and measure</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>David V. Akman et al. (2022) k-best feature selection and ranking via stochastic approximation,  <em>Expert Systems with Applications</em>, <b>Vol. 213</b>. See <a href="https://doi.org/10.1016/j.eswa.2022.118864">doi:10.1016/j.eswa.2022.118864</a>
</p>
<p>G.F.A Yeo and V. Aksakalli (2021) A stochastic approximation approach to simultaneous feature weighting and selection for nearest neighbour learners,  <em>Expert Systems with Applications</em>, <b>Vol. 185</b>. See <a href="https://doi.org/10.1016/j.eswa.2021.115671">doi:10.1016/j.eswa.2021.115671</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+spFeatureSelection">spFeatureSelection</a>.
</p>

<hr>
<h2 id='summary.spFSR'>Summarising a spFSR object</h2><span id='topic+summary.spFSR'></span>

<h3>Description</h3>

<p>Summarising a spFSR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spFSR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.spFSR_+3A_object">object</code></td>
<td>
<p>A <code>spFSR</code> object</p>
</td></tr>
<tr><td><code id="summary.spFSR_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of a spFSR object consisting of number of features selected, wrapper type, total number of iterations, the best performing features, and the descriptive statistics of the best iteration result (the iteration where the best performing features are found).
</p>


<h3>See Also</h3>

<p><a href="#topic+getImportance">getImportance</a>, <a href="#topic+spFSR.default">spFSR.default</a>, and <a href="#topic+spFeatureSelection">spFeatureSelection</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
