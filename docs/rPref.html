<!DOCTYPE html><html><head><title>Help for package rPref</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rPref}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base_pref'><p>Base Preferences</p></a></li>
<li><a href='#base_pref_macros'><p>Useful Base Preference Macros</p></a></li>
<li><a href='#complex_pref'><p>Complex Preferences</p></a></li>
<li><a href='#general_pref'><p>Utility Functions for Preferences</p></a></li>
<li><a href='#get_hasse_diag'><p>Adjacency List of Hasse diagram</p></a></li>
<li><a href='#plot_btg'><p>Better-Than-Graphs</p></a></li>
<li><a href='#plot_front'><p>Pareto Front Plot</p></a></li>
<li><a href='#pred_succ'><p>Predecessor and Successor Functions</p></a></li>
<li><a href='#psel'><p>Preference Selection</p></a></li>
<li><a href='#rPref'><p>Summary of the rPref Package</p></a></li>
<li><a href='#show.pref'><p>Partial Evaluation and String Output of Preferences</p></a></li>
<li><a href='#show.query'><p>Show Preferences in Database Query Languages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Database Preferences and Skyline Computation</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Roocks &lt;mail@p-roocks.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Roocks &lt;mail@p-roocks.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines to select and visualize the maxima for a given strict
    partial order. This especially includes the computation of the Pareto
    frontier, also known as (Top-k) Skyline operator (see Börzsönyi, et al. 
    (2001) &lt;<a href="https://doi.org/10.1109%2FICDE.2001.914855">doi:10.1109/ICDE.2001.914855</a>&gt;), and some generalizations 
    known as database preferences (see Kießling (2002) 
    &lt;<a href="https://doi.org/10.1016%2FB978-155860869-6%2F50035-4">doi:10.1016/B978-155860869-6/50035-4</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.p-roocks.de/rpref/">https://www.p-roocks.de/rpref/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), RcppParallel (&ge; 5.1.6), dplyr (&ge; 1.0.0),
igraph (&ge; 1.0.1), lazyeval (&ge; 0.2.1), methods, utils</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11, GNU make, Windows: cmd.exe and cscript.exe</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, graph, Rgraphviz (&ge; 2.16.0), knitr, ggplot2,
rmarkdown</td>
</tr>
<tr>
<td>Collate:</td>
<td>'rPref.r' 'RcppExports.R' 'pref-classes.r' 'base-pref.r'
'base-pref-macros.r' 'complex-pref.r' 'general-pref.r'
'pref-eval.r' 'show-pref.r' 'visualize.r' 'pred-succ.r'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-28 21:27:57 UTC; patrick</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-30 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='base_pref'>Base Preferences</h2><span id='topic+base_pref'></span><span id='topic+low'></span><span id='topic+low_'></span><span id='topic+high'></span><span id='topic+high_'></span><span id='topic+true'></span><span id='topic+true_'></span><span id='topic+is.base_pref'></span>

<h3>Description</h3>

<p>Base preferences are used to describe the different goals (dimensions, in case of a Skyline query)
of a preference query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>low(expr, df = NULL)

low_(expr, df = NULL)

high(expr, df = NULL)

high_(expr, df = NULL)

true(expr, df = NULL)

true_(expr, df = NULL)

is.base_pref(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_pref_+3A_expr">expr</code></td>
<td>
<p>A numerical/logical expression which is the term to evaluate for the current preference. 
The objective is to search for minimal/maximal values of this expression (for <code>low</code>/<code>high</code>) or for 
logical <code>TRUE</code> values (for <code>true</code>).
For <code>low_</code>, <code>high_</code> and <code>true_</code>, the argument must be an expression, a call or a string.</p>
</td></tr>
<tr><td><code id="base_pref_+3A_df">df</code></td>
<td>
<p>(optional) A data frame, having the same structure (i.e., columns)
like that data frame, where this preference is evaluated later on. 
Causes a partial evaluation of the preference and the preference is associated with this data frame.
See below for details.</p>
</td></tr>
<tr><td><code id="base_pref_+3A_x">x</code></td>
<td>
<p>An object to be tested if it is a base preference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mathematically, all base preferences are strict weak orders (irreflexive, transitive and negative transitive).
</p>
<p>The three fundamental base preferences are:
</p>

<dl>
<dt><code>low(a), high(a)</code></dt><dd><p>Search for minimal/maximal values of <code>a</code>, 
i.e., the induced order is the &quot;smaller than&quot; or &quot;greater than&quot; order on the values of <code>a</code>.
The values of <code>a</code> must be numeric values.</p>
</dd>
<dt><code>true(a)</code></dt><dd><p>Search for true values in logical expressions, i.e., <code>TRUE</code> is considered to be better than <code>FALSE</code>.
The values of <code>a</code> must be logical values.
For a tuplewise evaluation of a complex logical expression one has to use the <code>&amp;</code> and <code>|</code> operators for logical AND/OR
(and not the <code>&amp;&amp;</code> and <code>||</code> operators).</p>
</dd>
</dl>

<p>The term <code>expr</code> may be just a single attribute or may contain an arbitrary expression,
depending on more than one attribute, e.g., <code>low(a+2*b+f(c))</code>.
There <code>a</code>, <code>b</code> and <code>c</code> are columns of the addressed data set and <code>f</code> has to be a previously defined function.
</p>
<p>Functions contained in <code>expr</code> are evaluated over the entire data set, i.e., 
it is possible to use aggregate functions (<code>min</code>, <code>mean</code>, etc.). 
Note that all functions (and also variables which are not columns of the data set, where <code>expr</code> will be evaluated on)
must be defined in the same environment (e.g., environment of a function or global environment) as the base preference is defined.
</p>
<p>The function <code>is.base_pref</code> returns <code>TRUE</code> if <code>x</code> is a preference object and <code>FALSE</code> otherwise.
</p>


<h3>Using Expressions in Preferences</h3>

<p>The <code>low_</code>, <code>high_</code> and <code>true_</code> preferences have the same functionality
as <code>low</code>, <code>high</code> and <code>true</code> 
but expect an expression, a call or a string as argument.
For example, <code>low(a)</code> is equivalent to <code>low_(expression(a))</code> or <code>low_("a")</code>. 
Lazy expressions (see the lazyeval package) are also possible.
</p>
<p>This is helpful for developing your own base preferences. Assume you want to define a base Preference <code>false</code>
as the dual of <code>true</code>. A definition like <code>false &lt;- function(x) -true(x)</code> is the wrong approach, as 
<code>psel(data.frame(a = c(1,2)), false(a == 1))</code> will result in the error &quot;object 'a' not found&quot;.
This is because <code>a</code> is considered as a variable and not as an (abstract) symbol to be evaluated later.
By defining
</p>
<p><code>false &lt;- function(x, ...) -true_(substitute(x), ...)</code>
</p>
<p>one gets a preference which behaves like a &quot;built-in&quot; preference.  
Additional optional parameters (like <code>df</code>) are bypassed.
The object <code>false(a == 1)</code> will output 
<code>[Preference] -true(a == 1)</code> on the console and 
<code>psel(data.frame(a = c(1,2)), false(a==1))</code> returns correctly the second tuple with <code>a==2</code>.
</p>
<p>There is a special symbol <code>df__</code> which can be used in preference expression to access the given 
data set <code>df</code>, when <code><a href="#topic+psel">psel</a></code> is called on this data set. 
For example, on a data set where the first column has the name <code>A</code>
the preference <code>low(df__[[1]])</code> is equivalent to <code>low(A)</code>.
</p>


<h3>Partial Evaluation and Associated Data Frames</h3>

<p>If the optional parameter <code>df</code> is given, 
then the expression is evaluated at the time of definition as far as possible.
All variables occurring as columns in <code>df</code> remain untouched. For example, consider
</p>
<p><code>f &lt;- function(x) 2*x</code> <br />
<code>p &lt;- true(cyl == f(1), mtcars)</code>
</p>
<p>Then <code>p</code> is equivalent to the preference <code>true(cyl == 2)</code> as the variable <code>cyl</code> is a column in <code>mtcars</code>.
Additionally the data set <code>mtcars</code> is associated with the preference <code>p</code>, 
implying that the preference selection can be done with <code><a href="#topic+peval">peval</a></code>. 
See <code><a href="#topic+assoc.df">assoc.df</a></code> for details on associated data sets.
</p>
<p>The preference selection, i.e., <code>psel(mtcars, p)</code> can be invoked without the partial evaluation.
But this results in an error, if the function <code>f</code> has meanwhile removed from the current environment.
Hence it is safer to do an early partial evaluation of all preferences, as far as they contain user defined functions.
</p>
<p>The partial evaluation can be done manually by <code><a href="#topic+partial.eval.pref">partial.eval.pref</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+complex_pref">complex_pref</a></code> how to compose complex preferences to retrieve e.g., the Skyline.
See <code><a href="#topic+general_pref">general_pref</a></code> for functions applying to all kind of preferences.
See <code><a href="#topic+base_pref_macros">base_pref_macros</a></code> for more base preferences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defines a preference with a score value combining mpg and hp.
p1 &lt;- high(4 * mpg + hp)
# Perform the preference selection:
psel(mtcars, p1)

# Defines a preference with a given function.
f &lt;- function(x, y) (abs(x - mean(x))/max(x) + abs(y - mean(y))/max(y))
p2 &lt;- low(f(mpg, hp))
psel(mtcars, p2)

# Use partial evaluation for weighted scoring.
p3 &lt;- high(mpg/sum(mtcars$mpg) + hp/sum(mtcars$hp), df = mtcars)
p3
# Select Pareto optima.
peval(p3)
</code></pre>

<hr>
<h2 id='base_pref_macros'>Useful Base Preference Macros</h2><span id='topic+base_pref_macros'></span><span id='topic+around'></span><span id='topic+between'></span><span id='topic+pos'></span><span id='topic+layered'></span>

<h3>Description</h3>

<p>In addition to the base preferences, 
rPref offers some macros to define preferences where a given interval or point is preferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>around(expr, center, df = NULL)

between(expr, left, right, df = NULL)

pos(expr, pos_value, df = NULL)

layered(expr, ..., df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_pref_macros_+3A_expr">expr</code></td>
<td>
<p>A numerical expression (for <code>around</code> and <code>between</code>)
or an arbitrary expression (for <code>pos</code> and <code>layered</code>).
The objective are those tuples where <code>expr</code> evaluates to a value within the preferred interval, layer, etc. 
Regarding attributes, functions and variables, the same requirements as for <code><a href="#topic+base_pref">base_pref</a></code> apply.</p>
</td></tr>
<tr><td><code id="base_pref_macros_+3A_center">center</code></td>
<td>
<p>Preferred numerical value for <code>around</code>.</p>
</td></tr>
<tr><td><code id="base_pref_macros_+3A_df">df</code></td>
<td>
<p>(optional) Data frame for partial evaluation and association of preference and data set.
See <code><a href="#topic+base_pref">base_pref</a></code> for details.</p>
</td></tr>
<tr><td><code id="base_pref_macros_+3A_left">left</code></td>
<td>
<p>Lower limit (numerical) of the preferred interval for <code>between</code>.</p>
</td></tr>
<tr><td><code id="base_pref_macros_+3A_right">right</code></td>
<td>
<p>Upper limit (numerical) of the preferred interval for <code>between</code>.</p>
</td></tr>
<tr><td><code id="base_pref_macros_+3A_pos_value">pos_value</code></td>
<td>
<p>A vector containing the preferred values for a <code>pos</code> preference.
It has to be of the same type (numeric, logical, character, ...) as <code>expr</code>.</p>
</td></tr>
<tr><td><code id="base_pref_macros_+3A_...">...</code></td>
<td>
<p>Layers (sets) for a <code>layered</code> preference. Each parameter corresponds to a layer 
and the first one characterizes the most preferred values.</p>
</td></tr>
</table>


<h3>Definition of the Preference Macros</h3>


<dl>
<dt><code>between(expr, left, right)</code></dt><dd><p>Those tuples are preferred where <code>expr</code> evaluates
to a value between <code>left</code> and <code>right</code>.
For values not in this interval, the values nearest to the interval are preferred.</p>
</dd>
<dt><code>around(expr, center)</code></dt><dd><p>Same as <code>between(expr, center, center)</code>.</p>
</dd>
<dt><code>pos(expr, pos_value)</code></dt><dd><p>Those tuples are preferred, where <code>expr</code> evaluates 
to a value which is contained in <code>pos_value</code>.</p>
</dd>
<dt><code>layered(expr, layer1, layer2, ..., layerN)</code></dt><dd><p>For the most preferred tuples <code>expr</code>
must evaluate to a value in <code>layer1</code>. 
The second-best tuples are those where <code>expr</code> evaluates to a value in <code>layer2</code> and so forth. 
Values occurring in none of the layers are considered worse than those in <code>layerN</code>.
Technically, this is realized by a prioritization chain (lexicographical order)
of <code><a href="#topic+true">true</a></code> preferences.</p>
</dd>
</dl>

<p>Note that only the argument <code>expr</code> may contain columns from the data frame, 
all other variables must evaluate to explicit values. 
For example <code>around(mpg, mean(mpg))</code> is not allowed. In this case, one can use 
<code>around(mpg, mean(mtcars$mpg))</code> instead. Or alternatively, without using the base preference macros, 
<code>low(abs(mpg - mean(mpg)))</code> does the same. There, the actual mean value of <code>mpg</code> is calculated 
just when the preference selection via <code>psel</code> is called.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Search for cars where mpg is near to 25.
psel(mtcars, around(mpg, 25))

# Consider cyl = 2 and cyl = 4 as equally good, while cyl = 6 is worse.
psel(mtcars, layered(cyl, c(2, 4), 6))
</code></pre>

<hr>
<h2 id='complex_pref'>Complex Preferences</h2><span id='topic+complex_pref'></span><span id='topic++2A+2Cpreference+2Cpreference-method'></span><span id='topic++2A+2Cpreference-method'></span><span id='topic++26+2Cpreference+2Cpreference-method'></span><span id='topic++26+2Cpreference-method'></span><span id='topic++7C+2Cpreference+2Cpreference-method'></span><span id='topic++7C+2Cpreference-method'></span><span id='topic++2B+2Cpreference+2Cpreference-method'></span><span id='topic++2B+2Cpreference-method'></span><span id='topic+reverse'></span><span id='topic+is.complex_pref'></span>

<h3>Description</h3>

<p>Complex preferences are used to compose different preference orders. 
For example the Pareto composition (via operator <code>*</code>) is the usual operator
to compose the preference for a Skyline query. The Skyline is also known as Pareto frontier.
All complex preferences are mathematically strict partial orders (irreflexive and transitive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'preference,preference'
e1 * e2

## S4 method for signature 'preference,preference'
e1 &amp; e2

## S4 method for signature 'preference,preference'
e1 | e2

## S4 method for signature 'preference,preference'
e1 + e2

reverse(p)

is.complex_pref(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complex_pref_+3A_p">p</code>, <code id="complex_pref_+3A_e1">e1</code>, <code id="complex_pref_+3A_e2">e2</code></td>
<td>
<p>Preference objects (they can be either base preferences, see <code><a href="#topic+base_pref">base_pref</a></code>, or complex preferences)</p>
</td></tr>
<tr><td><code id="complex_pref_+3A_x">x</code></td>
<td>
<p>An object to be tested if it is a complex preference.</p>
</td></tr>
</table>


<h3>Skylines</h3>

<p>The most important preference composition operator is the Pareto operator (<code>p1 * p2</code>) to formulate a Skyline query. 
A tuple t1 is better than t2 w.r.t. <code>p1 * p2</code> if it is strictly better w.r.t. one of the preferences p1, p2 and is better or equal w.r.t. the other preference.
</p>
<p>The syntactical correspondence to other query languages supporting Skylines/preferences to rPref
is given as follows:
</p>

<ul>
<li><p> A query in the syntax from Börzsönyi et. al (2001) like
</p>
<p>&quot;<code>... SKYLINE OF a MAX, b MIN, c MAX</code>&quot; 
</p>
<p>corresponds in rPref to the preference
</p>
<p><code>high(a) * low(b) * high(c)</code>.
</p>
</li>
<li><p> A query in the syntax from Kiessling (2002) like 
</p>
<p>&quot;<code>... PREFERRING a LOWEST AND (b HIGHEST PRIOR TO c LOWEST)</code>&quot; 
</p>
<p>corresponds in rPref to 
</p>
<p><code>low(a) * (high(b) &amp; low(c))</code>.
</p>
</li>
<li><p> A query in the syntax of the &quot;Skyline&quot; feature of the commercial database &quot;EXASOL EXASolution 5&quot; like 
</p>
<p>&quot;<code>... PREFERRING LOW a PLUS (b = 1 PRIOR TO LOW c))</code>&quot; 
</p>
<p>corresponds in rPref to
</p>
<p><code>low(a) * (true(b == 1) &amp; low(c))</code>.
</p>
</li></ul>

<p>Note that preferences in rPref can be translated to some of this query dialects by <code><a href="#topic+show.query">show.query</a></code>.
</p>


<h3>Definition of Additional Preference Operators</h3>

<p>Additionally, rPref supports the following preference composition operators:
</p>

<dl>
<dt><code>p1 &amp; p2</code></dt><dd><p>Prioritization (lexicographical order): A tuple t1 is better than t2 w.r.t. <code>p1 &amp; p2</code> if it is 
strictly better w.r.t. <code>p1</code> or is equal w.r.t. <code>p1</code> and is better w.r.t. <code>p2</code>.</p>
</dd>
<dt><code>p1 | p2</code></dt><dd><p>Intersection preference: A tuple t1 is better than t2 w.r.t. <code>p1 | p2</code> if it is strictly better w.r.t. both preferences. 
This is a stricter variant of the Pareto operator. The evaluation of <code>psel(df, p1 | p2)</code> is always a subset of <code>psel(df, p1 * p2)</code>.</p>
</dd>
<dt><code>p1 + p2</code></dt><dd><p>Union preference: A tuple t1 is better than t2 w.r.t. <code>p1 + p2</code> if it is strictly better w.r.t. to one of the preferences. 
Note that this can violate the strict partial order property, if the domains (the tuples on which <code>p1</code> and <code>p2</code> define better-than-relationships) 
of the preferences are not disjoint.</p>
</dd>
<dt><code>reverse(p1)</code> or <code>-p1</code></dt><dd><p>Reverse preference (converse relation): 
A tuple t1 is better than t2 w.r.t. <code>-p1</code> if t2 is better than t1 w.r.t. <code>p1</code>. 
The unary minus operator, i.e. <code>-p1</code>, is a short hand notation for <code>reverse(p1)</code>.</p>
</dd>
</dl>

<p>The function <code>is.complex_pref</code> returns <code>TRUE</code> if <code>x</code> is a complex preference object 
(i.e., was constructed by one of these binary operators or the unary operator <code>reverse</code>) 
and <code>FALSE</code> otherwise.
</p>


<h3>Associated Data Sets</h3>

<p>If one of the preferences for a binary operator are associated with a data set (see <code><a href="#topic+base_pref">base_pref</a></code>),
then this association is propagated. For example, the preference
</p>
<p><code>p &lt;- high(mpg, df = mtcars) * high(hp)</code>
</p>
<p>as well as
</p>
<p><code>p &lt;- high(mpg) * high(hp, df = mtcars)</code>
</p>
<p>both result in the same complex preference which is associated with <code>mtcars</code>. 
A partial evaluation is also invoked for all preferences which are added. 
For example, using this <code>p</code>, 
</p>
<p><code>p &lt;- p * true(cyl == max(mtcars$cyl))</code>
</p>
<p>generates the following console output:
</p>
<p><code>[Preference] high(mpg) * high(hp) * true(cyl == 8)</code> <br />
<code>  * associated data source: data.frame "mtcars" [32 x 11]</code>
</p>
<p>We see that the association with the data set is propagated and <code>max(mtcars$cyl)</code> is partially evaluated.
</p>


<h3>References</h3>

<p>S. Borzsonyi, D. Kossmann, K. Stocker (2001): The Skyline Operator. In Data Engineering (ICDE '01), pages 421-430.
</p>
<p>W. Kiessling (2002): Foundations of Preferences in Database Systems. In Very Large Data Bases (VLDB '02), pages 311-322.
</p>
<p>S. Mandl, O. Kozachuk, M. Endres, W. Kiessling (2015): Preference Analytics in EXASolution. 
16th Conference on Database Systems for Business, Technology, and Web.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+base_pref">base_pref</a></code> for the construction of base preferences. 
See <code><a href="#topic+general_pref">general_pref</a></code> for functions applicable to all kind of preferences.
See <code><a href="#topic+psel">psel</a></code> for the evaluation of preferences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defines a preference for cars with low consumption (high mpg-value)
# and simultaneously high horsepower.
p1 &lt;- high(mpg) * high(hp)  

# Performs the preference search.
psel(mtcars, p1)

# Alternative way: create preference with associated data set.
p2 &lt;- high(mpg, df = mtcars) * high(hp)  
peval(p2)
</code></pre>

<hr>
<h2 id='general_pref'>Utility Functions for Preferences</h2><span id='topic+general_pref'></span><span id='topic+empty'></span><span id='topic+is.empty_pref'></span><span id='topic+length+2Cpreference-method'></span><span id='topic+length+2Cbasepref-method'></span><span id='topic+length+2Cemptypref-method'></span><span id='topic+length+2Ccomplexpref-method'></span><span id='topic+length+2Creversepref-method'></span><span id='topic+is.preference'></span><span id='topic+as.expression+2Cpreference-method'></span><span id='topic+as.expression+2Cbasepref-method'></span><span id='topic+as.expression+2Cemptypref-method'></span><span id='topic+as.expression+2Ccomplexpref-method'></span><span id='topic+as.expression+2Creversepref-method'></span><span id='topic+assoc.df'></span><span id='topic+assoc.df+2Cpreference-method'></span><span id='topic+assoc.df+3C-'></span><span id='topic+assoc.df+3C-+2Cpreference-method'></span>

<h3>Description</h3>

<p>Collection of some useful functions which are applicable to all preference objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty()

is.empty_pref(x)

## S4 method for signature 'preference'
length(x)

is.preference(x)

## S4 method for signature 'preference'
as.expression(x, ...)

## S4 method for signature 'preference'
assoc.df(x)

## S4 replacement method for signature 'preference'
assoc.df(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general_pref_+3A_x">x</code></td>
<td>
<p>A preference, or, for <code>is.preference</code>, an object to be tested if it is an (empty) preference.</p>
</td></tr>
<tr><td><code id="general_pref_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>as.expression</code>.</p>
</td></tr>
<tr><td><code id="general_pref_+3A_value">value</code></td>
<td>
<p>A data frame to associate with a preference object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empty preference <code>empty()</code> is a neutral element for the complex preference compositions <code>{*, &amp;, +}</code>. 
It holds that <code>empty() * p</code> and <code>empty() &amp; p</code> is equal to <code>p</code> for all preferences <code>p</code>.
</p>
<p>The function <code>length(p)</code> returns the term length of the preference term <code>p</code>
which is defined as the number of base preferences
in a complex preference term. The empty preference <code>empty()</code> has length 0, 
and all base preferences have length 1.
</p>
<p>With <code>as.expression(p)</code> for a preference <code>p</code> the call to the preference is constructed. 
This means, <code>eval(as.expression(p))</code> returns the preference <code>p</code>, evaluated in the current environment.
</p>
<p>The function <code>is.empty_pref</code> returns <code>TRUE</code> if <code>x</code> is the empty preference object 
<code>empty()</code> and <code>FALSE</code> otherwise.
</p>
<p>With <code>assoc.df</code> the associated data frame of a preference can be retrieved or set.
Setting the associated data frame means that a partial evaluation based on this data frame is done. 
See <code><a href="#topic+show.pref">show.pref</a></code> for details on partial evaluation of preferences.
Next, the preference is linked to that data frame, such that <code><a href="#topic+peval">peval</a>(p)</code> can be used instead of <code>psel(df, p)</code>.
It returns <code>NULL</code> if no data frame is associated.
Use <code>set.assoc.df(NULL)</code> to delete an associated data frame.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+base_pref">base_pref</a></code> for the construction of base preferences,
and <code><a href="#topic+complex_pref">complex_pref</a></code> for the construction of complex preferences. 
See <code><a href="#topic+show.pref">show.pref</a></code> for string output and partial evaluation of preference terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Same as low(a) * low(b).
p &lt;- low(a) * low(b) * empty()

# Returns 2, as empty() does not count.
length(p)

# The preference expression (without empty()).
as.expression(p)

</code></pre>

<hr>
<h2 id='get_hasse_diag'>Adjacency List of Hasse diagram</h2><span id='topic+get_hasse_diag'></span>

<h3>Description</h3>

<p>Returns the adjacency list of the Hasse diagram of a preference as an (n x 2) matrix. 
This is the transitive reduction of the preference relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hasse_diag(df, pref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hasse_diag_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="get_hasse_diag_+3A_pref">pref</code></td>
<td>
<p>A preference on the columns of <code>df</code>, see <code><a href="#topic+psel">psel</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A row (i, j) in the resulting matrix means that <code>df[i,]</code> is better than <code>df[j,]</code> with regard to the preference <code>p</code>.
The matrix is the transitive reduction (Hasse diagram) of the induced relations,
i.e., if (1,2) and (2,3) occur in the result, then (1,3) will not be contained.
The number of rows in the result depends on the number of non-transitive Better-Than-Relationships in <code>df</code> w.r.t. <code>p</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_btg">get_btg</a></code> to plot the Hasse diagram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get_hasse_diag(mtcars, low(mpg))

</code></pre>

<hr>
<h2 id='plot_btg'>Better-Than-Graphs</h2><span id='topic+plot_btg'></span><span id='topic+get_btg'></span><span id='topic+get_btg_dot'></span>

<h3>Description</h3>

<p>Returns or plots a Hasse diagram of a preference order (also called the Better-Than-Graph, short BTG) on a given data set. 
Plotting within R relies on the igraph package or the Rgraphviz package.
Alternatively, a dot file for an external graphviz/dot interpreter can be generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_btg(
  df,
  pref,
  labels = 1:nrow(df),
  flip.edges = FALSE,
  levelwise = TRUE,
  use_dot = "Rgraphviz" %in% rownames(installed.packages())
)

get_btg(
  df,
  pref,
  flip.edges = FALSE,
  use_dot = "Rgraphviz" %in% rownames(installed.packages())
)

get_btg_dot(
  df,
  pref,
  labels = 1:nrow(df),
  flip.edges = FALSE,
  levelwise = TRUE,
  file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_btg_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="plot_btg_+3A_pref">pref</code></td>
<td>
<p>A preference on the columns of <code>df</code>, see <code><a href="#topic+psel">psel</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_btg_+3A_labels">labels</code></td>
<td>
<p>(optional) Labels for the vertices. Default values are the row indices.</p>
</td></tr>
<tr><td><code id="plot_btg_+3A_flip.edges">flip.edges</code></td>
<td>
<p>(optional) Flips the orientation of edges,
if <code>TRUE</code> than arrows point from worse nodes to better nodes.</p>
</td></tr>
<tr><td><code id="plot_btg_+3A_levelwise">levelwise</code></td>
<td>
<p>(optional) Only relevant is the dot layouter is used. 
If <code>TRUE</code>, all tuples from the same level are placed on one row.
If <code>FALSE</code>, the row arrangement is subject to the dot layouter.</p>
</td></tr>
<tr><td><code id="plot_btg_+3A_use_dot">use_dot</code></td>
<td>
<p>(optional) If <code>TRUE</code>, the dot layouter from Rgraphviz is used. 
If <code>FALSE</code>, igraph is used.
By default this is <code>TRUE</code> if and only if Rgraphviz is available.</p>
</td></tr>
<tr><td><code id="plot_btg_+3A_file">file</code></td>
<td>
<p>(optional) If specified, then <code>get_btg_dot</code> writes the graph specification to 
given file path. If not specified, the graph specification is returned as a string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hasse diagram of a preference visualizes all the better-than-relationships on a given data set.
All edges which can be retrieved by transitivity of the order are omitted in the graph.
</p>
<p>The functions <code>get_btg</code> and <code>plot_btg</code> either use the <a href="igraph.html#topic+igraph">igraph</a>
package (if <code>use_dot = FALSE</code>) or the dot layouter from the Rgraphviz package 
(if <code>use_dot = TRUE</code>). 
If Rgraphviz is available it is used by default, otherwise the igraph Package is used.
Note that Rgraphviz is only available on BioConductor and not on CRAN.
</p>
<p>The dot layouter from Rgraphviz is more appropriate for Better-Than-Graphs than the igraph layouter,
as all edges will be directed in the same direction (rank based ordering). 
Using <code>levelwise = TRUE</code> (the default), all tuples of the same level are placed on the same row.
</p>


<h3>BTGs with igraph</h3>

<p>If used with <code>use_dot = FALSE</code>, 
the function <code>get_btg</code> returns a list <code>l</code> with the following list entries:
</p>

<dl>
<dt><code>l$graph</code></dt><dd><p>An igraph object, created with the <code><a href="igraph.html#topic+igraph">igraph</a></code> package.</p>
</dd>
<dt><code>l$layout</code></dt><dd><p>A typical Hasse diagram layout for plotting the graph, also created with igraph.</p>
</dd>
</dl>

<p>To plot the resulting graph returned from <code>get_btg</code>, use the <code>plot</code> function as follows: 
</p>
<p><code>plot(l$graph, layout = l$layout)</code> 
</p>
<p>For more details, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.
</p>


<h3>BTGs with Rgraphviz</h3>

<p>If used with <code>use_dot = FALSE</code>, the function <code>get_btg</code> returns a <code>graphNEL</code> object from 
the graph-package (Rgraphviz is build on top of that package). 
This object can also be plotted using <code>plot(...)</code>.
</p>


<h3>Direct Plotting</h3>

<p>In both cases (whether Rgraphviz is used or not), 
the function <code>plot_btg</code> directly plots the Better-Than-Graph.
There is an additional parameter <code>labels</code>, specifying the node labels. 
The default are the row numbers (not the <code>rownames</code> of the data frame),
ranging from <code>"1"</code> to <code>as.character(nrow(df))</code>.
</p>


<h3>Dot (Graphviz) String Output</h3>

<p>The function <code>get_btg_dot</code> produces the source code of the Better-Than-Graph in the dot language
of the Graphviz software. This is useful for an external dot interpreter. 
Depending on the <code>file</code> parameter the output is either written to a file
(if a file path is given) or returned as a string (if <code>file = NULL</code>).
</p>


<h3>Additional Parameters</h3>

<p>By default, the directed edges in the diagram point from better to worse nodes w.r.t. the preference. 
This means an arrow can be read as &quot;is better than&quot;. If <code>flip.edges = TRUE</code> is set, 
then the arrows point from worse nodes to better nodes (&quot;is worse than&quot;). 
In any case, the better nodes are plotted at the top and the worse nodes at the bottom of the diagram.
</p>
<p>If Rgraphviz is used for <code>plot_btg</code> and for <code>get_btg_dot</code>, 
the option <code>levelwise</code> controls if all nodes of the same level are placed in one row.
If this parameter is <code>FALSE</code>, then the vertical arrangement is subject to the dot layouter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Pick a small data set and create preference and BTG.
df &lt;- mtcars[1:10,]
pref &lt;- high(mpg) * low(wt)

# Directly plot the BTG with row numbers as labels.
# This uses Rgraphviz if available and igraph otherwise.
plot_btg(df, pref) 

# Plot the graph with labels with relevant values.
labels &lt;- paste0(df$mpg, "; ", df$wt)
plot_btg(df, pref, labels)
     
# Show lattice structure of a 3-dimensional Pareto preference.
df &lt;- merge(merge(data.frame(x = 1:3), data.frame(y = 1:3)), data.frame(z = 1:2))
labels &lt;- paste0(df$x, ",", df$y, ",", df$z)
plot_btg(df, low(x) * low(y) * low(z), labels)
     
# Create a graph with external Graphviz (requires installed Graphviz).
## Not run: 
# Vreates tmpgraph.dot in the current working directoy
get_btg_dot(df, pref, labels, file = "tmpgraph.dot")
# Convert to diagram tmpgraph.png using Graphviz
shell(paste0('"C:/Program Files (x86)/Graphviz2.38/bin/dot.exe"',
             ' -Tpng tmpgraph.dot -o tmpgraph.png'))
# Open resulting image
shell("tmpgraph.png")
## End(Not run)

</code></pre>

<hr>
<h2 id='plot_front'>Pareto Front Plot</h2><span id='topic+plot_front'></span>

<h3>Description</h3>

<p>Connects the points of a Pareto front (also known as Pareto frontier) and hence visualizes the dominance region of a Skyline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_front(df, pref, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_front_+3A_df">df</code></td>
<td>
<p>The data frame for which the Pareto front is plotted. This may be already a maximal set w.r.t. the preference <code>pref</code>, 
but anyway the maximal set is recalculated via <code>psel(df, pref)</code>.</p>
</td></tr>
<tr><td><code id="plot_front_+3A_pref">pref</code></td>
<td>
<p>The preference representing the Skyline goals. This must be a Pareto composition (<code>p1 * p2</code>) or
intersection composition (<code>p1 | p2</code>) of 
two <code><a href="#topic+low">low</a></code> or <code><a href="#topic+high">high</a></code> preferences.</p>
</td></tr>
<tr><td><code id="plot_front_+3A_...">...</code></td>
<td>
<p>Additional graphic parameters which are passed to the <code><a href="graphics.html#topic+segments">segments</a></code> function (internally used to plot the front).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_front</code> assumes that there is an existing plot, where the value of the first preference was plotted as x-coordinate
and the value of the second preference as y-coordinate.
</p>
<p>Note that <code>plot_front</code> is only recommended if you want to use the plotting functionality from base R. 
If you prefer to use ggplot2, we recommend using <code>geom_step</code> for plotting the Pareto front.
See <code>vignette("visualization", package = "rPref")</code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# plots Pareto fronts for the hp/mpg values of mtcars
show_front &lt;- function(pref) {
  plot(mtcars$hp, mtcars$mpg)
  sky &lt;- psel(mtcars, pref)
  plot_front(mtcars, pref, col = rgb(0, 0, 1))
  points(sky$hp, sky$mpg, lwd = 3)
}

# do this for all four combinations of Pareto compositions
show_front(low(hp)  * low(mpg))
show_front(low(hp)  * high(mpg))
show_front(high(hp) * low(mpg))
show_front(high(hp) * high(mpg))

# compare this to the front of a intersection preference
show_front(high(hp) | high(mpg))


</code></pre>

<hr>
<h2 id='pred_succ'>Predecessor and Successor Functions</h2><span id='topic+pred_succ'></span><span id='topic+init_pred_succ'></span><span id='topic+hasse_pred'></span><span id='topic+hasse_succ'></span><span id='topic+all_pred'></span><span id='topic+all_succ'></span>

<h3>Description</h3>

<p>Functions for traversing the BTG (Better-Than-Graph or Hasse diagram) of a preference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_pred_succ(p, df = NULL)

hasse_pred(p, v, intersect = FALSE)

hasse_succ(p, v, intersect = FALSE)

all_pred(p, v, intersect = FALSE)

all_succ(p, v, intersect = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_succ_+3A_p">p</code></td>
<td>
<p>A preference. Worse tuples in the induced order are successors and better tuples are predecessors.</p>
</td></tr>
<tr><td><code id="pred_succ_+3A_df">df</code></td>
<td>
<p>(optional) A data frame characterizing the set wherein predecessors/successors are searched. 
If <code>df</code> is <code>NULL</code> then the data frame associated with the preference is used.
Causes an error if <code>df == NULL</code> and no data frame is associated.</p>
</td></tr>
<tr><td><code id="pred_succ_+3A_v">v</code></td>
<td>
<p>A numeric vector of indices in <code>df</code>. This represents the set of tuples for which predecessors/successors are searched.</p>
</td></tr>
<tr><td><code id="pred_succ_+3A_intersect">intersect</code></td>
<td>
<p>(optional) Logical value. 
If it is <code>FALSE</code> (by default) the union of all predecessors/successors of <code>v</code> is returned.
For <code>intersect = TRUE</code> the intersection of those values is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return the predecessors and successors in the Better-Than-Graph of a preference.
Note that the successors/predecessors can can be plotted via <code><a href="#topic+get_btg">get_btg</a></code>. 
Before any of the successor/predecessor functions can be used the initialization has to be called as follows:
</p>
<p><code>init_pred_succ(p, df)</code>
</p>
<p>There <code>p</code> is a preference object and <code>df</code> a data frame. 
When this done, the data frame <code>df</code> is associated with <code>p</code>, i.e.,
implicitly <code><a href="#topic+assoc.df">assoc.df</a></code> is called. 
If the preference has already an associated data frame, <code>df</code> can be omitted. For example
</p>
<p><code>p &lt;- low(mpg, df = mtcars)</code> <br />
<code>init_pred_succ(p)</code>
</p>
<p>does the initialization of the preference <code>low(mpg)</code> on the data set <code>mtcars</code>.
</p>
<p>The <code>init_pred_succ</code> function calculates the Better-Than-Relation on <code>df</code> w.r.t. <code>p</code>. 
Afterwards the predecessor and successor functions, as subsequently described, can be called. 
The value of <code>v</code> is a numeric vector within <code>1:nrow(df)</code> 
and characterizes a subset of tuples in <code>df</code>. 
The return value of these functions is again a numeric vector referring to the row numbers in <code>df</code> 
and it is always ordered ascending, independently of the order of the indices in <code>v</code>.
</p>

<dl>
<dt><code>all_pred(p, v)</code></dt><dd><p>Returns all predecessors of <code>v</code>, i.e., indices of better tuples than <code>v</code>.</p>
</dd>
<dt><code>all_succ(p, v)</code></dt><dd><p>Returns all successors of <code>v</code>, i.e., indices of worse tuples than <code>v</code>.</p>
</dd>
<dt><code>hasse_pred(p, v)</code></dt><dd><p>Returns the direct predecessors of <code>v</code>, 
i.e., indices of better tuples than <code>v</code> where the better-than-relation is contained in the transitive reduction.</p>
</dd>
<dt><code>hasse_succ(p, v)</code></dt><dd><p>Returns the direct successors of <code>v</code>, 
i.e., indices of worse tuples than <code>v</code> where the better-than-relation is contained in the transitive reduction.</p>
</dd>
</dl>

<p>If <code>v</code> has length 1, then the value of <code>intersect</code> does not matter, as there is nothing to intersect or join. 
For scalar values <code>x</code> and <code>y</code> the following identities hold, where <code>f</code> is one of the predecessor/successor functions:
</p>
<p><code>f(p, c(x, y), intersect = FALSE) == union(f(p, x), f(p, y))</code>
</p>
<p><code>f(p, c(x, y), intersect = TRUE) == intersect(f(p, x), f(p, y))</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Preference on mtcars for high mpg and low weight
p &lt;- high(mpg) * low(wt)
init_pred_succ(p, mtcars)

# Helper to show mpg/hp values
show_vals &lt;- function(x) mtcars[x,c('mpg','wt')]

# Pick some tuple "in the middle":
show_vals(10)

# Show (direct) predecessors/successors of tuple 10:
show_vals(hasse_pred(p, 10)) # Next better car
show_vals(hasse_succ(p, 10)) # Next worse car
show_vals(all_pred(p, 10))   # All better cars
show_vals(all_succ(p, 10))   # All worse cars
</code></pre>

<hr>
<h2 id='psel'>Preference Selection</h2><span id='topic+psel'></span><span id='topic+psel.indices'></span><span id='topic+peval'></span>

<h3>Description</h3>

<p>Evaluates a preference on a given data set, i.e., 
returns the maximal elements of a data set for a given preference order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psel(df, pref, ...)

psel.indices(df, pref, ...)

peval(pref, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psel_+3A_df">df</code></td>
<td>
<p>A data frame or, for a grouped preference selection, a grouped data frame. See below for details.</p>
</td></tr>
<tr><td><code id="psel_+3A_pref">pref</code></td>
<td>
<p>The preference order constructed via <code><a href="#topic+complex_pref">complex_pref</a></code> and <code><a href="#topic+base_pref">base_pref</a></code>. 
All variables occurring in the definition of <code>pref</code> must be either columns of the data frame <code>df</code> 
or variables/functions of the environment where <code>pref</code> was defined.</p>
</td></tr>
<tr><td><code id="psel_+3A_...">...</code></td>
<td>
<p>Additional (optional) parameters for top(-level)-k selections:
</p>

<dl>
<dt><code>top</code></dt><dd><p>A <code>top</code> value of k means that the k-best tuples of the data set are returned. 
This may be non-deterministic, see below for details.</p>
</dd>
<dt><code>at_least</code></dt><dd><p>An <code>at_least</code> value of k returns the top-k tuples and additionally all tuples which are 
not dominated by the worst tuple (i.e. the minima) of the Top-k set. 
The number of tuples returned is greater or equal than
<code>at_least</code>. In contrast to top-k, this is deterministic.</p>
</dd>
<dt><code>top_level</code></dt><dd><p>A <code>top_level</code> value of k returns all tuples from the k-best levels. See below for the definition of a level.</p>
</dd>
<dt><code>and_connected</code></dt><dd><p>Logical value, which is only relevant if more than one of the above {<code>top</code>, <code>at_least</code>, <code>top_level</code>} 
values is given, otherwise it will be ignored. 
Then <code>and_connected = TRUE</code> (which is the default) means that all top-conditions 
must hold for the returned tuples: 
Let <code>cond1</code> and <code>cond2</code> be top-conditions like <code>top=2</code> or <code>top_level=3</code>, then
<code>psel([...], cond1, cond2)</code> is equivalent to the intersection of <code>psel([...], cond1)</code> and <code>psel([...], cond2)</code>. If we have
<code>and_connected = FALSE</code>, these conditions are or-connected. 
This corresponds to the union of <code>psel([...], cond1)</code> and <code>psel([...], cond2)</code>.</p>
</dd>
<dt><code>show_level</code></dt><dd><p>Logical value. If <code>TRUE</code>, a column <code>.level</code> 
is added to the returned data frame, containing all level values. 
If at least one of the {<code>top</code>, <code>at_least</code>, <code>top_level</code>} values are given,
then <code>show_level</code> is <code>TRUE</code> by default for the <code>psel</code> function. 
Otherwise, and for <code>psel.indices</code> in all cases, this option is <code>FALSE</code> by default.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between the three variants of the preference selection is:
</p>

<ul>
<li><p> The <code>psel</code> function returns a subset of the data set which contains the maxima according to the given preference. 
</p>
</li>
<li><p> The function <code>psel.indices</code> returns just the row indices of the maxima 
(except top-k queries with <code>show_level = TRUE</code>, see top-k preference selection).
Hence <code>psel(df, pref)</code> is equivalent to <code>df[psel.indices(df, pref),]</code> for non-grouped data frames. 
</p>
</li>
<li><p> Finally, <code>peval</code> does the same like <code>psel</code>, but assumes that <code>p</code> has an associated data frame
which is used for the preference selection.
Consider <code><a href="#topic+base_pref">base_pref</a></code> to see how base preferences are associated with data sets
or use <code><a href="#topic+assoc.df">assoc.df</a></code> to explicitly associate a preference with a data frame.
</p>
</li></ul>



<h3>Top-k Preference Selection</h3>

<p>For a given <code>top</code> value of k the k best elements and their level values are returned. The level values are determined as follows:
</p>

<ul>
<li><p>All the maxima of a data set w.r.t. a preference have level 1.
</p>
</li>
<li><p>The maxima of the remainder, i.e., the data set without the level 1 maxima, have level 2.
</p>
</li>
<li><p>The n-th iteration of &quot;Take the maxima from the remainder&quot; returns tuples of level n.
</p>
</li></ul>

<p>By default, <code>psel.indices</code> does not return the level values. By setting <code>show_level = TRUE</code> this function
returns a data frame with the columns '.indices' and '.level'. 
Note that, if none of the top-k values {<code>top</code>, <code>at_least</code>, <code>top_level</code>} is set,
then all level values are equal to 1. 
</p>
<p>By definition, a top-k preference selection is non-deterministic. 
A top-1 query of two equivalent tuples (equivalence according to <code>pref</code>)
can return both of these tuples. 
For example, a <code>top=1</code> preference selection on the tuples (a=1, b=1), (a=1, b=2)
w.r.t. <code>low(a)</code> preference can return either the 'b=1' or the 'b=2' tuple. 
</p>
<p>On the contrary, a preference selection using <code>at_least</code> is deterministic by adding all tuples having the same level as the worst level 
of the corresponding top-k query. This means, the result is filled with all tuples being not worse than the top-k result. 
A preference selection with top-level-k returns all tuples having level k or better. 
</p>
<p>If the <code>top</code> or <code>at_least</code> value is greater than the number of elements in <code>df</code> 
(i.e., <code>nrow(df)</code>), or <code>top_level</code> is greater than the highest level in <code>df</code>,
then all elements of <code>df</code> will be returned without further warning.
</p>


<h3>Grouped Preference Selection</h3>

<p>Using <code>psel</code> it is also possible to perform a preference selection where the maxima are calculated for every group separately. 
The groups have to be created with <code><a href="dplyr.html#topic+group_by">group_by</a></code> from the dplyr package. The preference selection preserves the grouping, i.e.,
the groups are restored after the preference selection.
</p>
<p>For example, if the <code>summarize</code> function from dplyr is applied to
<code>psel(group_by(...), pref)</code>, the summarizing is done for the set of maxima of each group. 
This can be used to e.g., calculate the number of maxima in each group, see the examples below.
</p>
<p>A {<code>top</code>, <code>at_least</code>, <code>top_level</code>} preference selection
is applied to each group separately.
A <code>top=k</code> selection returns the k best tuples for each group. 
Hence if there are 3 groups in <code>df</code>, each containing at least 2 elements, 
and we have <code>top = 2</code>, then 6 tuples will be returned.
</p>


<h3>Parallel Computation</h3>

<p>On multi-core machines the preference selection can be run in parallel using a divide-and-conquer approach. 
Depending on the data set, this may be faster than a single-threaded computation.
To activate parallel computation within rPref the following option has to be set:
</p>
<p><code>options(rPref.parallel = TRUE)</code>
</p>
<p>If this option is not set, rPref will use single-threaded computation by default. 
With the option <code>rPref.parallel.threads</code> the maximum number of threads can be specified.
The default is the number of cores on your machine. 
To set the number of threads to the value of 4, use:
</p>
<p><code>options(rPref.parallel.threads = 4)</code>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+complex_pref">complex_pref</a></code> on how to construct a Skyline preference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Skyline and top-k/at-least Skyline
psel(mtcars, low(mpg) * low(hp))
psel(mtcars, low(mpg) * low(hp), top = 5)
psel(mtcars, low(mpg) * low(hp), at_least = 5)

# Preference with associated data frame and evaluation
p &lt;- low(mpg, df = mtcars) * (high(cyl) &amp; high(gear))
peval(p)

# Visualizes the Skyline in a plot.
sky1 &lt;- psel(mtcars, high(mpg) * high(hp))
plot(mtcars$mpg, mtcars$hp)
points(sky1$mpg, sky1$hp, lwd=3)

# Grouped preference with dplyr.
library(dplyr)
psel(group_by(mtcars, cyl), low(mpg))

# Returns the size of each maxima group.
summarise(psel(group_by(mtcars, cyl), low(mpg)), n())

</code></pre>

<hr>
<h2 id='rPref'>Summary of the rPref Package</h2><span id='topic+rPref'></span>

<h3>Description</h3>

<p>rPref contains routines to select and visualize the maxima for a given strict
partial order. This especially includes the computation of the Pareto
frontier, also known as (Top-k) Skyline operator, and some
generalizations (database preferences).
</p>


<h3>Preference Composition/Selection</h3>


<ul>
<li><p> Preferences are primarily composed from base preferences (see <code><a href="#topic+base_pref">base_pref</a></code>) 
and complex preferences (see <code><a href="#topic+complex_pref">complex_pref</a></code>),
where especially the Pareto operator for Skylines is such a complex preference. 
</p>
</li>
<li><p> Some utility functions for preferences are collected in <code><a href="#topic+general_pref">general_pref</a></code>.
</p>
</li>
<li><p> Additionally some base preference macros are provided in <code><a href="#topic+base_pref_macros">base_pref_macros</a></code>. 
</p>
</li>
<li><p> The (top(-level)-k) preference selection <code><a href="#topic+psel">psel</a></code> allows to retrieve 
the maxima of a preference (or Pareto frontier, Skyline), 
constructed with the functions above, on a given data set.
</p>
</li></ul>



<h3>Visualization and Analysis of Preferences</h3>


<ul>
<li><p> The visualization of the preference order in a Better-Than-Graph (Hasse diagram) is possible via <code><a href="#topic+plot_btg">plot_btg</a></code>.
</p>
</li>
<li><p> The adjacency list of the Hasse diagram can be accessed via <code><a href="#topic+get_hasse_diag">get_hasse_diag</a></code>.
</p>
</li>
<li><p> Predecessors/successors in the Hasse diagram are calculated with the <code><a href="#topic+pred_succ">pred_succ</a></code> functions.
</p>
</li>
<li><p> The Pareto frontier can be plotted using the <code><a href="#topic+plot_front">plot_front</a></code> function.
</p>
</li></ul>



<h3>String Output of Preferences</h3>


<ul>
<li><p> The preference query for some preference-supporting DBMS can be given by <code><a href="#topic+show.query">show.query</a></code>.
</p>
</li>
<li><p> A preference is partially evaluated and printed with <code><a href="#topic+show.pref">show.pref</a></code>.
</p>
</li></ul>



<h3>Vignettes</h3>

<p>To learn the basics of rPref, start with the vignettes:
</p>

<ul>
<li><p> A general introduction and some examples are given in 
</p>
<p><code>vignette("introduction", package = "rPref")</code>
</p>
</li>
<li><p> The visualization of preferences is explained in 
</p>
<p><code>vignette("visualization", package = "rPref")</code>
</p>
</li></ul>



<h3>Further Information</h3>

<p>The rPref website is <a href="http://www.p-roocks.de/rpref/">http://www.p-roocks.de/rpref/</a>. 
To submit bugs, feature requests or other comments, feel free to write a mail to me.
</p>


<h3>Author(s)</h3>

<p>Patrick Roocks, <a href="mailto:mail@p-roocks.de">mail@p-roocks.de</a>
</p>

<hr>
<h2 id='show.pref'>Partial Evaluation and String Output of Preferences</h2><span id='topic+show.pref'></span><span id='topic+as.character+2Cpreference-method'></span><span id='topic+as.character+2Cbasepref-method'></span><span id='topic+as.character+2Cemptypref-method'></span><span id='topic+as.character+2Ccomplexpref-method'></span><span id='topic+as.character+2Creversepref-method'></span><span id='topic+pref.str'></span><span id='topic+partial.eval.pref'></span>

<h3>Description</h3>

<p>Functions to substitute variables and functions in preferences 
which can be calculated before the preference is evaluated on a data frame
and character output of preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.pref(p, df = NULL)

## S4 method for signature 'preference'
as.character(x, ...)

pref.str(p, df = NULL)

partial.eval.pref(p, df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.pref_+3A_p">p</code>, <code id="show.pref_+3A_x">x</code></td>
<td>
<p>The preference to be shown or partially evaluated.</p>
</td></tr>
<tr><td><code id="show.pref_+3A_df">df</code></td>
<td>
<p>(optional) A data frame on which the preference operates. Used for partial evaluation.</p>
</td></tr>
<tr><td><code id="show.pref_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>as.character</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pref.str</code> (or <code>as.character(p)</code> for a preference <code>p</code>) returns the preference string 
while <code>show.pref</code> outputs it directly to the console, preceded by <code>'[Preference]'</code>.
If <code>df</code> is specified, then a partial evaluation of the preference is done before converting it to a string. 
</p>
<p>The function <code>partial.eval.pref</code> (with given data frame <code>df</code>) partially evaluates the internal preference expression and 
returns again a preference object. All expressions in <code>p</code> are evaluated in the environment
where <code>p</code> was defined, except the the column names in <code>df</code> (which are potential attributes in <code>p</code>) 
and except the special variable <code>df__</code>, which accesses the entire data set (see <code><a href="#topic+psel">psel</a></code>).
The content of the data frame <code>df</code> does not matter; only <code>names(df)</code> is used to get the &quot;free variables&quot; in <code>p</code>.
</p>
<p>If <code>p</code> has already an associated data frame (see <code><a href="#topic+assoc.df">assoc.df</a></code>), 
then a partial evaluation was already done when the data frame was associated.
In this case, the <code>df</code> parameter should not be used.
The association will not be changed if one of these function are called 
with a given data frame on a preference object having an associated data frame.
</p>


<h3>Partial Evaluation Before String Output</h3>

<p>The functions <code>show.pref</code> and <code>pref.str</code> have the optional parameter <code>df</code>.
If this parameter is given, these functions call <code>partial.eval.pref</code> before they output or return the preference string.
The following equalities hold:
</p>

<ul>
<li> <p><code>as.character(partial.eval.pref(p, df)) == pref.str(p, df)</code>
</p>
</li>
<li> <p><code>show(partial.eval.pref(p, df))</code> produces the same console output as <code>show.pref(p, df)</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>See <code><a href="#topic+general_pref">general_pref</a></code> for more utility functions for preferences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(x) 2*x
p &lt;- true(cyl == f(1))

# prints 'true(cyl == f(1))'
p

# prints 'true(cyl == 2)'
show.pref(p, mtcars)
partial.eval.pref(p, mtcars)

</code></pre>

<hr>
<h2 id='show.query'>Show Preferences in Database Query Languages</h2><span id='topic+show.query'></span>

<h3>Description</h3>

<p>For a given preference this shows the <code>PREFERRING</code> clause of a database query in different SQL dialects which support preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.query(p, dialect = "EXASOL", df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.query_+3A_p">p</code></td>
<td>
<p>A preference.</p>
</td></tr>
<tr><td><code id="show.query_+3A_dialect">dialect</code></td>
<td>
<p>The preference query dialect, which determines the syntax of the returned query. 
This has to be one of the following (not case sensitive):
</p>

<dl>
<dt><code>'EXASOL'</code>:</dt><dd><p>Syntax of the &quot;Skyline&quot; feature of the commercial database Exasol EXASolution 5.</p>
</dd>
<dt><code>'Preference SQL'</code> or <code>'PSQL'</code>:</dt><dd><p>Syntax of the Preference SQL system. 
This is a research prototype developed at the Chair of Databases and Information Systems of the University of Augsburg. 
See references for details.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="show.query_+3A_df">df</code></td>
<td>
<p>Optional parameter to specify a data frame on which the preference operates causing a partial evaluation. See <code><a href="#topic+show.pref">show.pref</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are few database systems supporting Skyline queries. 
A Skyline query consists of a usual SQL query followed by a <code>PREFERRING</code>-clause (in some rarely used dialects also <code>SKYLINE OF</code>). 
For example consider a database table r(a,b). The preference selection <code>psel(r, low(a) * high(b))</code> can be expressed by (in the Exasol dialect):
</p>
<p><code>SELECT * FROM r PREFERRING LOW a PLUS HIGH b</code>
</p>
<p>The <code>show.query</code> function generates just the <code>PREFERRING</code>-clause, i.e. <code>show.query(low(a) * high(b))</code> returns 
</p>
<p><code>PREFERRING LOW a PLUS HIGH b</code>
</p>
<p>As usual in SQL queries, all keywords are not case sensitive, i.e., <code>PLUS</code> or <code>plus</code> does not make any difference.
</p>


<h3>References</h3>

<p>W. Kiessling, M. Endres, F. Wenzel (2011): The Preference SQL System - An Overview. IEEE Data Engineering Bulletin, Vol. 34 No. 3, pages 12-19.  
</p>
<p>S. Mandl, O. Kozachuk, M. Endres, W. Kiessling (2015): Preference Analytics in EXASolution. 
16th Conference on Database Systems for Business, Technology, and Web.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
show.query(low(a) * high(b))

show.query(low(a) * high(b), dialect = 'Preference SQL')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
