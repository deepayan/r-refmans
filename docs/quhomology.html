<!DOCTYPE html><html><head><title>Help for package quhomology</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quhomology}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quhomology-package'>
<p>Calculation of Homology groups of a rack/birack</p></a></li>
<li><a href='#all_combinations'>
<p>Calculating all possible permutations</p></a></li>
<li><a href='#boundary_matrix'>
<p>This function calculates a boundary matrix.</p>
</p></a></li>
<li><a href='#boundary_matrix_degenerate'>
<p>Calculation of boundary matrix for degenerate Homology.</p></a></li>
<li><a href='#boundary_names'>
<p>Calculation of boundary elements for quandle and rack boundary matrix</p></a></li>
<li><a href='#boundary_names_degenerate'>
<p>Calculation of degenerate boundary elements for boundary matrix</p></a></li>
<li><a href='#check_f'>
<p>Check if the function is bijective</p></a></li>
<li><a href='#check_more_push'>
<p>Helper function for Smith Normal Form calculation.</p></a></li>
<li><a href='#check_permutations'>
<p>Check if Switch is bijective.</p></a></li>
<li><a href='#check_YB'>
<p>Check Young Baxter Equation</p></a></li>
<li><a href='#degenerate_homology'>
<p>Calculates the degenerate Homology for a rack/birack.</p></a></li>
<li><a href='#down_action'>
<p>The down action for a birack or biquandle.</p></a></li>
<li><a href='#find_S_result'>
<p>Calculate the Switch</p></a></li>
<li><a href='#findX'>
<p>Calculate the left row action matrix to turn a matrix into its Gaussian Form.</p></a></li>
<li><a href='#GaussianElimination'>
<p>Calculation of Gaussian Form of a matrix.</p></a></li>
<li><a href='#homology'>
<p>Calculation of quandle and rack homology groups of a rack / birack.</p></a></li>
<li><a href='#matrix_rank'>
<p>Calculates the rank of a matrix.</p></a></li>
<li><a href='#output_results'>
<p>Function that prints the calculated homology group to the screen</p></a></li>
<li><a href='#push_down'>
<p>Helper Function for Smith Normal Form calculation.</p></a></li>
<li><a href='#row_space'>
<p>Row Space of a Matrix.</p></a></li>
<li><a href='#rref'>
<p>Reduced Row Echelon Form of a matrix</p></a></li>
<li><a href='#S_test'><p>Testing of possible quandle/biquandle actions</p></a></li>
<li><a href='#smith'>
<p>Smith Normal Form of a matrix.</p></a></li>
<li><a href='#up_action'>
<p>The up action for a birack or biquandle.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculation of Homology of Quandles, Racks, Biquandles and
Biracks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates the Quandle, Rack and Degenerate Homology groups of
    Racks and Biracks (as well as Quandles and Biquandles). In addition, a test is
    provided to ascertain if a given set with one or two given functions is indeed a
    biquandle or not.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, numbers</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-10 10:42:24 UTC; ansgarwenzel</td>
</tr>
<tr>
<td>Author:</td>
<td>Ansgar Wenzel [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ansgar Wenzel &lt;ansgar.wenzel+quhomology@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-10 12:16:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='quhomology-package'>
Calculation of Homology groups of a rack/birack
</h2><span id='topic+quhomology-package'></span><span id='topic+quhomology'></span>

<h3>Description</h3>

<p>This package provides the functionality to calculate the rack, quandle and degenerate Homology groups of a given rack or birack.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> quhomology</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-10-10</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL v3+</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>~~ An overview of how to use the package, including the most important functions ~~
</p>


<h3>Author(s)</h3>

<p>Ansgar Wenzel
</p>
<p>Maintainer:  &lt;ansgar.wenzel+quhomology@gmail.com&gt;
</p>


<h3>References</h3>

<p>http://www.maths.sussex.ac.uk/Staff/RAF/Maths/homo.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Using the up and down action as provided for the dihedral quandle, we can then calculate:

#$H_3^R(R_3)$ by 
homology(3,3,FALSE)


#$H_3^Q(R_3)$ by 
homology(3,3,TRUE)

#$H_3^D(R_3)$ by 
degenerate_homology(3,3)

</code></pre>

<hr>
<h2 id='all_combinations'>
Calculating all possible permutations
</h2><span id='topic+all_combinations'></span>

<h3>Description</h3>

<p>This function calculates all possible permutations of order 2 in a set of order k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_combinations(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_combinations_+3A_k">k</code></td>
<td>

<p>Order of set. A positive integer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='boundary_matrix'>
This function calculates a boundary matrix.
</h2><span id='topic+boundary_matrix'></span>

<h3>Description</h3>

<p>This function calculates the boundary matrix for rack/birack for both the quandle and rack homology case. In particular, this is a representation of the boundary function in the simplicial complex of the rack/birack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary_matrix(degree, k, degenerate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_matrix_+3A_degree">degree</code></td>
<td>

<p>This is the degree of the Homology group, that is, if one wants to calculate $H_3$, then degree=3. A positive integer.
</p>
</td></tr>
<tr><td><code id="boundary_matrix_+3A_k">k</code></td>
<td>

<p>This describes the order of the underlying rack or birack. A positive integer.
</p>
</td></tr>
<tr><td><code id="boundary_matrix_+3A_degenerate">degenerate</code></td>
<td>

<p>If degenerate=TRUE, this calculates the boundary matrix for the quandle homology. If FALSE, the boundary matrix for the rack homology case is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions takes all words (or just the non-degenerate ones) of length $degree$ in the rack/biquandle (which are represented by $Z_k$) and then calculates their boundary via the following equation. For this, let $x=(x_i)_0^degree-1$ be an element of the rack/birack and let $n:=degree-1$.
$$partial(x) = Sum_i=0^n (-1)^i ( (x_0...(^x_i)...x_n)-(x_0^x_ix_1^x_i...x_i-1^x_ix_i+1_x_i...x_n_x_i) )$$, where ^x_i means except x_i.
If this is a rack rather than a birack, remember that $f_a()=Id$.
</p>


<h3>Value</h3>

<p>A Matrix.</p>


<h3>References</h3>

<p>http://www.maths.sussex.ac.uk/Staff/RAF/Maths/homo.pdf
</p>


<h3>See Also</h3>

<p><code>link{boundary_matrix_degenerate}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundary_matrix(3,3,TRUE)
</code></pre>

<hr>
<h2 id='boundary_matrix_degenerate'>
Calculation of boundary matrix for degenerate Homology.
</h2><span id='topic+boundary_matrix_degenerate'></span>

<h3>Description</h3>

<p>This function returns the boundary matrix of a rack/birack necessary to calculate the degenerate Homology of the same. In particular, this is a representation of the boundary function in the simplicial complex of the rack/birack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary_matrix_degenerate(degree, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_matrix_degenerate_+3A_degree">degree</code></td>
<td>

<p>This is the degree of the Homology group, that is, if one wants to calculate $H_3$, then degree=3. A positive integer.
</p>
</td></tr>
<tr><td><code id="boundary_matrix_degenerate_+3A_k">k</code></td>
<td>

<p>This describes the order of the underlying rack or birack. A positive integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions takes all degenerate words of length $degree$ in the rack/biquandle (which are represented by $Z_k$) and then calculates their boundary via the followi ng equation. For this, let $x=(x_i)_0^degree-1$ be an element of the rack/birack and let $n:=degree-1$.
$$partial(x) = Sum_i=0^n (-1)^i ( (x_0...(^x_i)...x_n)-(x_0^x_ix_1^x_i...x_i-1^x_ix_i+1_x_i...x_n_x_i) )$$, where ^x_i means except x_i.
If this is a rack rather than a birack, remember that $f_a()=Id$. 
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>References</h3>

<p>http://www.maths.sussex.ac.uk/Staff/RAF/Maths/homo.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boundary_matrix">boundary_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundary_matrix_degenerate(3,3)
</code></pre>

<hr>
<h2 id='boundary_names'>
Calculation of boundary elements for quandle and rack boundary matrix
</h2><span id='topic+boundary_names'></span>

<h3>Description</h3>

<p>This functions calculates the row and column names for both the quandle and the rack boundary matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary_names(degree, k, degenerate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_names_+3A_degree">degree</code></td>
<td>

<p>Length of elements to be calculated. A positive integer.
</p>
</td></tr>
<tr><td><code id="boundary_names_+3A_k">k</code></td>
<td>

<p>Order of underlying rack/birack. This will be passed on to up/down action, if necessary. A positive integer.
</p>
</td></tr>
<tr><td><code id="boundary_names_+3A_degenerate">degenerate</code></td>
<td>

<p>If true, remove degenerate entries (and hence calculate the names for the quandle boundary matrix). TRUE/FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculates all possible permutations of elements in $Z_k$ of length $degree$.  If degenerate is true, it loops through all of them, removing the degenerate ones (that is, those where $x_i=x_i+1$, for an element $x=(x_i)_0^degree)$).
</p>


<h3>Value</h3>

<p>A matrix with $degree$ columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boundary_names_degenerate">boundary_names_degenerate</a></code>, <code><a href="#topic+boundary_matrix">boundary_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundary_names(3,3,TRUE)
</code></pre>

<hr>
<h2 id='boundary_names_degenerate'>
Calculation of degenerate boundary elements for boundary matrix
</h2><span id='topic+boundary_names_degenerate'></span>

<h3>Description</h3>

<p>This functions calculates the row and column names for the degenerate boundary matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary_names_degenerate(degree, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_names_degenerate_+3A_degree">degree</code></td>
<td>

<p>Length of elements to be calculated. A positive integer
</p>
</td></tr>
<tr><td><code id="boundary_names_degenerate_+3A_k">k</code></td>
<td>

<p>Order of underlying rack/birack. This will be passed on to up/down action, if necessary. A positive integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculates all possible permutations of elements in $Z_k$ of length $degree$.  If degenerate is true, it loops through all of them, removing the non-degenerate ones (that is, those where $x_i =/= x_i+1$ for all $i=0,...,degree-1$, for an element $x=(x_i)_0^degree)$).
</p>


<h3>Value</h3>

<p>A matrix, where the rows represent the elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boundary_matrix_degenerate">boundary_matrix_degenerate</a></code>, <code><a href="#topic+boundary_names">boundary_names</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundary_names_degenerate(3,3)
</code></pre>

<hr>
<h2 id='check_f'>
Check if the function is bijective
</h2><span id='topic+check_f'></span>

<h3>Description</h3>

<p>This function checks if a given up or down action is bijective. This is done via checking that the order of the codomain is the same as the order of the domain of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_f(S_X, k, X_squared)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_f_+3A_s_x">S_X</code></td>
<td>

<p>All words of length 2 in a given set after up/down operation.
</p>
</td></tr>
<tr><td><code id="check_f_+3A_k">k</code></td>
<td>

<p>Order of set.
</p>
</td></tr>
<tr><td><code id="check_f_+3A_x_squared">X_squared</code></td>
<td>

<p>All words of length 2 in a given set.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_permutations">check_permutations</a></code>, <code><a href="#topic+check_YB">check_YB</a></code>
</p>

<hr>
<h2 id='check_more_push'>
Helper function for Smith Normal Form calculation.
</h2><span id='topic+check_more_push'></span>

<h3>Description</h3>

<p>Checks if the diagonal entries are ordered properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_more_push(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_more_push_+3A_d">D</code></td>
<td>

<p>Diagonal of a matrix that shall be turned into Smith Normal Form.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smith">smith</a></code>, <code><a href="#topic+push_down">push_down</a></code>
</p>

<hr>
<h2 id='check_permutations'>
Check if Switch is bijective.
</h2><span id='topic+check_permutations'></span>

<h3>Description</h3>

<p>This function checks if a given Switch is bijective. This is done via checking that the order of the codomain is the same as the order of the domain of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_permutations(B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_permutations_+3A_b">B</code></td>
<td>

<p>All elements in set after up/down operation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>checks that the number of unique words of length 2 in the set is the same after up/down operation as before.
</p>


<h3>Value</h3>

<p>TRUE/FALSE
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_f">check_f</a></code>, <code><a href="#topic+check_YB">check_YB</a></code>
</p>

<hr>
<h2 id='check_YB'>
Check Young Baxter Equation
</h2><span id='topic+check_YB'></span>

<h3>Description</h3>

<p>This functions checks if the Young Baxter equation holds. In particular, for up and down actions, let there be a switch $S(a,b_a) = (b,a^b)$ and define $S_1(a,b,c)=(S(a,b),c)$ and $S_2(a,b,c)=(a,S(b,c))$. Then the Young Baxter equations are
$$S_1S_2S_1(a,b,c) = S_2S_1S_2(a,b,c)$$
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_YB(S, k, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_YB_+3A_s">S</code></td>
<td>

<p>All words of length 2 in a given set after up/down operation.
</p>
</td></tr>
<tr><td><code id="check_YB_+3A_k">k</code></td>
<td>

<p>Order of set.
</p>
</td></tr>
<tr><td><code id="check_YB_+3A_x">X</code></td>
<td>

<p>All words of length 2 in a given set.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_f">check_f</a></code>,<code><a href="#topic+check_permutations">check_permutations</a></code>
</p>

<hr>
<h2 id='degenerate_homology'>
Calculates the degenerate Homology for a rack/birack.
</h2><span id='topic+degenerate_homology'></span>

<h3>Description</h3>

<p>This function calculates the degenerate homology group of a given rack or birack. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degenerate_homology(degree, k, return_values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degenerate_homology_+3A_degree">degree</code></td>
<td>

<p>This is the degree of the Homology group, that is, if one wants to calculate $H^D_3$, then degree=3.
</p>
</td></tr>
<tr><td><code id="degenerate_homology_+3A_k">k</code></td>
<td>

<p>This describes the order of the underlying rack or birack.
</p>
</td></tr>
<tr><td><code id="degenerate_homology_+3A_return_values">return_values</code></td>
<td>

<p>If return_values = TRUE, the functions returns the diagonal of the Smith Normal Form. If FALSE (the default), the function calls output_results instead which prints the homology group to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the algorithm described in the references below. It should be sufficient for most users to change the up/down action functions according to their requirements and then run the calculation.
</p>


<h3>Value</h3>

<p>NULL if return_values is FALSE, the diagonal of the Smith Normal Form if return_values is TRUE.
</p>


<h3>References</h3>

<p>http://www.maths.sussex.ac.uk/Staff/RAF/Maths/homo.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homology">homology</a></code>
<code><a href="#topic+output_results">output_results</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degenerate_homology(3,3)
</code></pre>

<hr>
<h2 id='down_action'>
The down action for a birack or biquandle.
</h2><span id='topic+down_action'></span>

<h3>Description</h3>

<p>This functions defines the down action for a birack or biquandle. In the case of a quandle or rack, it is the identity.
The definition of this functions is $f_b(a)$, that is, b acting on a from below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>down_action(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="down_action_+3A_a">a</code></td>
<td>

<p>This is the elements that is acted upon. An integer.
</p>
</td></tr>
<tr><td><code id="down_action_+3A_b">b</code></td>
<td>

<p>This is the element that acts. An integer.
</p>
</td></tr>
<tr><td><code id="down_action_+3A_k">k</code></td>
<td>

<p>This is the order of the biquandle. It is not always required, but passed on nevertheless. An integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can (and should) be changed by the user if s/he requires a different down action. It could be implemented as a matrix lookup, a function or some other way. Examples for the first two options are below.
</p>


<h3>Value</h3>

<p>An integer, representing an element in the birack or rack.
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Biquandle
http://en.wikipedia.org/wiki/Racks_and_quandles
</p>


<h3>See Also</h3>

<p><code><a href="#topic+up_action">up_action</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for version with function (for a dihedral quandle)
down_action &lt;- function (a, b, k){

    result &lt;- (2 * b - a)%%k
    return(as.integer(result))
}


##Example for matrix lookup (for commutative quandle over S_3, in which case k = 6)
down_action &lt;- function (a, b, k){
    #first define the action matrix
    action_matrix &lt;- rbind(c(0,0,0,0,0,0),c(1,1,5,5,2,2),c(2,5,2,1,5,1),
    c(3,4,4,3,4,4),c(4,3,3,3,4,3),c(5,2,1,2,1,5))
    result &lt;-action_matrix[a + 1, b + 1]
    return(as.integer(result))
}

##example for quandles/racks
down_action &lt;- function (a, b, k){

    return(a)
}

</code></pre>

<hr>
<h2 id='find_S_result'>
Calculate the Switch
</h2><span id='topic+find_S_result'></span>

<h3>Description</h3>

<p>This function calculates the result of a switch action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_S_result(x, X, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_S_result_+3A_x">x</code></td>
<td>

</td></tr>
<tr><td><code id="find_S_result_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="find_S_result_+3A_s">S</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>An element in the set, represented by a positive integer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_YB">check_YB</a></code>
</p>

<hr>
<h2 id='findX'>
Calculate the left row action matrix to turn a matrix into its Gaussian Form.
</h2><span id='topic+findX'></span>

<h3>Description</h3>

<p>This function calculates the left, row action matrix X in the equation $$G = X N Y$$, where G is the original matrix and N is the Gaussian Form of the same matrix. This is done via standard Gaussian Elimination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findX(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findX_+3A_a">A</code></td>
<td>

<p>The left row matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussianElimination">GaussianElimination</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_mat &lt;- matrix(c(2,4,4, -6,6,12, 10,-4,-16), nrow=3, ncol=3, byrow=TRUE)
findX(test_mat)
</code></pre>

<hr>
<h2 id='GaussianElimination'>
Calculation of Gaussian Form of a matrix.
</h2><span id='topic+GaussianElimination'></span>

<h3>Description</h3>

<p>This function calculates the Gaussian Form of a Matrix as well as the &quot;row change&quot; multiplication matrix, in short, both $N$ (the Gaussian Form) and $X$ for a matrix G of the form:
$$
N = X G Y
$$
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussianElimination(A, B, tol = sqrt(.Machine$double.eps),
verbose = FALSE, fractions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussianElimination_+3A_a">A</code></td>
<td>

<p>A Matrix to be turned into Gaussian Form.
</p>
</td></tr>
<tr><td><code id="GaussianElimination_+3A_b">B</code></td>
<td>

<p>An identity matrix, which will be returned as the row change multiplication matrix.
</p>
</td></tr>
<tr><td><code id="GaussianElimination_+3A_tol">tol</code></td>
<td>

<p>Tolerance for checking for 0 pivot.
</p>
</td></tr>
<tr><td><code id="GaussianElimination_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, print intermediate steps.
</p>
</td></tr>
<tr><td><code id="GaussianElimination_+3A_fractions">fractions</code></td>
<td>

<p>If true, try to express nonintegers as rational numbers.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>References</h3>

<p>http://socserv.mcmaster.ca/jfox/Courses/R-course-Berkeley/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rref">rref</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_mat &lt;- matrix(c(2,4,4, -6,6,12, 10,-4,-16), nrow=3, ncol=3, byrow=TRUE)
identity_mat &lt;- diag(3)
GaussianElimination(test_mat,identity_mat)
</code></pre>

<hr>
<h2 id='homology'>
Calculation of quandle and rack homology groups of a rack / birack.
</h2><span id='topic+homology'></span>

<h3>Description</h3>

<p>This function calculates the quandle and rack homology groups of a given rack or birack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homology(degree, k, quandle = TRUE, return_values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homology_+3A_degree">degree</code></td>
<td>

<p>This is the degree of the Homology group, that is, if one wants to calculate $H_3$, then degree=3.
</p>
</td></tr>
<tr><td><code id="homology_+3A_k">k</code></td>
<td>

<p>This describes the order of the underlying rack or birack.
</p>
</td></tr>
<tr><td><code id="homology_+3A_quandle">quandle</code></td>
<td>

<p>If quandle=TRUE, this calculates the quandle homology group. If FALSE, the rack homology is calculated.
</p>
</td></tr>
<tr><td><code id="homology_+3A_return_values">return_values</code></td>
<td>

<p>If return_values = TRUE, the functions returns the diagonal of the Smith Normal Form. If FALSE (the default), the function calls output_results instead which prints the homology group to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the algorithm described in the references below. It should be sufficient for most users to change the up/down action functions according to their requirements and then run the calculation.
</p>


<h3>Value</h3>

<p>NULL if return_values is FALSE, the diagonal of the Smith Normal Form if return_values is TRUE.
</p>


<h3>Note</h3>

<p>Note that the rack/birack is determined by not only $k$, but also by the up and down actions in <code><a href="#topic+up_action">up_action</a></code> and <code><a href="#topic+down_action">down_action</a></code>
</p>


<h3>References</h3>

<p>http://www.maths.sussex.ac.uk/Staff/RAF/Maths/homo.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degenerate_homology">degenerate_homology</a></code>
<code><a href="#topic+down_action">down_action</a></code>
<code><a href="#topic+up_action">up_action</a></code>
<code><a href="#topic+output_results">output_results</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>homology(3,3,TRUE)
homology(3,3,FALSE)
</code></pre>

<hr>
<h2 id='matrix_rank'>
Calculates the rank of a matrix.
</h2><span id='topic+matrix_rank'></span>

<h3>Description</h3>

<p>This function calculates the rank of a matrix, using Gaussian elimination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_rank(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_rank_+3A_a">A</code></td>
<td>

<p>A matrix, the rank of which one wants to know.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer, the rank of the matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussianElimination">GaussianElimination</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_mat &lt;- matrix(c(2,4,4, -6,6,12, 10,-4,-16), nrow=3, ncol=3, byrow=TRUE)
matrix_rank(test_mat)
#output:
# 2
</code></pre>

<hr>
<h2 id='output_results'>
Function that prints the calculated homology group to the screen
</h2><span id='topic+output_results'></span>

<h3>Description</h3>

<p>This functions takes the diagonal of the Smith Normal Form of the homology representation and from this prints the homology groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_results(hom_type, Delta, degree, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_results_+3A_hom_type">hom_type</code></td>
<td>

<p>This is the type of homology group, one of degenerate (if called from degenerate_homology), quandle (if called from homology(quandle=TRUE)) and rack (if called from homology(quandle=FALSE)).
</p>
</td></tr>
<tr><td><code id="output_results_+3A_delta">Delta</code></td>
<td>

<p>This is the diagonal of the Smith Normal Form of the homology representation.
</p>
</td></tr>
<tr><td><code id="output_results_+3A_degree">degree</code></td>
<td>

<p>This is the degree of the Homology group, that is, if one wants to calculate $H_3$, then degree=3.
</p>
</td></tr>
<tr><td><code id="output_results_+3A_k">k</code></td>
<td>

<p>This describes the order of the underlying rack or birack.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints the specified homology group of the given biquandle from the diagonal of the Smith Normal Form of the representation.
</p>
<p>In particular, all 1 give nothing, all zeros give a Z each and every other integer n gives a Z_n.
</p>


<h3>Value</h3>

<p>This function does return 0. Otherwise, it is only used for printing output to the screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homology">homology</a></code>
<code><a href="#topic+degenerate_homology">degenerate_homology</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
##H_2^Q(R_3):
output_results("quandle",c(1,1,1,1),2,3)
</code></pre>

<hr>
<h2 id='push_down'>
Helper Function for Smith Normal Form calculation.
</h2><span id='topic+push_down'></span>

<h3>Description</h3>

<p>If diagonal is not properly ordered in Smith Normal Form, this function reorders by gcd/lcm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>push_down(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="push_down_+3A_d">D</code></td>
<td>

<p>Diagonal of matrix to be turned into Smith Normal Form.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, containing the diagonal of a matrix to be turned into Smith Normal Form.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smith">smith</a></code>, <code><a href="#topic+check_more_push">check_more_push</a></code>
</p>

<hr>
<h2 id='row_space'>
Row Space of a Matrix.
</h2><span id='topic+row_space'></span>

<h3>Description</h3>

<p>This calculates the space spanned by the rows of a matrix, or, more precisely, a basis for it. This is done via calculation of the Hermite Normal Form of said matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_space(B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_space_+3A_b">B</code></td>
<td>

<p>The matrix whose row space one wants to know.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates row space of a matrix via its hermite normal form.
</p>


<h3>Value</h3>

<p>A Matrix, consisting of the basis of the space spanned by the rows, plus potentially rows of zeros, so the dimensions of this matrix are the same as of the matrix $B$.
</p>


<h3>See Also</h3>

<p><code><a href="numbers.html#topic+hermiteNF">hermiteNF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_mat &lt;- matrix(c(2,4,4, -6,6,12, 10,-4,-16), nrow=3, ncol=3, byrow=TRUE)
row_space(test_mat)
</code></pre>

<hr>
<h2 id='rref'>
Reduced Row Echelon Form of a matrix
</h2><span id='topic+rref'></span>

<h3>Description</h3>

<p>Function calculates the Reduced Row Echelon Form of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rref(A, tol = sqrt(.Machine$double.eps), verbose = FALSE, fractions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rref_+3A_a">A</code></td>
<td>

<p>Matrix to be turned into Gaussian Form.
</p>
</td></tr>
<tr><td><code id="rref_+3A_tol">tol</code></td>
<td>

<p>Tolerance for checking for 0 pivot. 
</p>
</td></tr>
<tr><td><code id="rref_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, print intermediate steps.
</p>
</td></tr>
<tr><td><code id="rref_+3A_fractions">fractions</code></td>
<td>

<p>If true, try to express nonintegers as rational numbers.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>References</h3>

<p>http://socserv.mcmaster.ca/jfox/Courses/R-course-Berkeley/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussianElimination">GaussianElimination</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_mat &lt;- matrix(c(2,4,4, -6,6,12, 10,-4,-16), nrow=3, ncol=3, byrow=TRUE)
rref(test_mat)
</code></pre>

<hr>
<h2 id='S_test'>Testing of possible quandle/biquandle actions
</h2><span id='topic+S_test'></span>

<h3>Description</h3>

<p>This functions tests if a given set with given operations is a biquandle (or quandle), or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S_test(k, return_result = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_test_+3A_k">k</code></td>
<td>

<p>Order of set, a positive integer.
</p>
</td></tr>
<tr><td><code id="S_test_+3A_return_result">return_result</code></td>
<td>

<p>This variable specifies if the results of the tests should be returned (as a list, if TRUE) or if the result of the tests should be printed to the screen (if FALSE, the default).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test requires the user to define their own up and down actions.
The different tests confirm two facts, namely, the bijectivity of the two functions f, g is considered, as well as the bijectivity of the switch map S, via their permutations. Furthermore, via the Yang-Baxter Check, it confirm whether the Yang-Baxter equation holds for the given up and down functions or not.
</p>


<h3>Value</h3>

<p>A vector with 4 boolean entries for the permutation tests for S, f and g, respectively as well as a check that Yang-Baxter holds.
</p>


<h3>References</h3>

<p>add in thesis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+up_action">up_action</a></code>, <code><a href="#topic+down_action">down_action</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Using the provided up/down action functions.
S_test(3)
##Output:
"The permutation checks hold that S is TRUE, f is TRUE
and g is TRUE and that the Yang-Baxter check holds TRUE."
</code></pre>

<hr>
<h2 id='smith'>
Smith Normal Form of a matrix.
</h2><span id='topic+smith'></span>

<h3>Description</h3>

<p>This calculates the Smith Normal Form of a Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smith(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smith_+3A_s">S</code></td>
<td>

<p>A matrix of which one wants to calculate the Smith Normal Form.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculates the Smith Normal Form of a Matrix based on repeated calculation of the Hermite Normal Form of the matrix and its transpose.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_more_push">check_more_push</a></code>, <code><a href="#topic+push_down">push_down</a></code>, <code><a href="numbers.html#topic+hermiteNF">hermiteNF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_mat &lt;- matrix(c(2,4,4, -6,6,12, 10,-4,-16), nrow=3, ncol=3, byrow=TRUE)
smith(test_mat)
#######
#output:

#  2    0    0
#  0    6    0
#  0    0   12
</code></pre>

<hr>
<h2 id='up_action'>
The up action for a birack or biquandle.
</h2><span id='topic+up_action'></span>

<h3>Description</h3>

<p>This function defines the up action for a birack or biquandle. In the case of a quandle or rack, it is the rack or quandle action.
The definition of this functions is $f^b(a)$, that is, b acting on a from above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>up_action(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="up_action_+3A_a">a</code></td>
<td>

<p>This is the elements that is acted upon. An integer.
</p>
</td></tr>
<tr><td><code id="up_action_+3A_b">b</code></td>
<td>

<p>This is the element that acts. An integer.
</p>
</td></tr>
<tr><td><code id="up_action_+3A_k">k</code></td>
<td>

<p>This is the order of the biquandle. It is not always required, but passed on nevertheless. An integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can (and should) be changed by the user if s/he requires a different up action. It could be implemented as a matrix lookup, a function or some other way. Examples for the first two options are below.
</p>


<h3>Value</h3>

<p>An integer, representing an element in the birack or rack.
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Biquandle
http://en.wikipedia.org/wiki/Racks_and_quandles
</p>


<h3>See Also</h3>

<p><code><a href="#topic+down_action">down_action</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example for version with function (for a dihedral quandle)
up_action &lt;- function (a, b, k){

    result &lt;- (2 * b - a)%%k
    return(as.integer(result))
}


##Example for matrix lookup (for commutative quandle over S_3, in which case k = 6)
up_action &lt;- function (a, b, k){
    #first define the action matrix
    action_matrix &lt;- rbind(c(0,0,0,0,0,0),c(1,1,5,5,2,2),c(2,5,2,1,5,1),
    c(3,4,4,3,4,4),c(4,3,3,3,4,3),c(5,2,1,2,1,5))
    result &lt;-action_matrix[a + 1, b + 1]
    return(as.integer(result))
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
