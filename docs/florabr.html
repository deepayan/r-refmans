<!DOCTYPE html><html><head><title>Help for package florabr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {florabr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Attributes'><p>Available attributes/parameters to filter and select species</p></a></li>
<li><a href='#bf_data'><p>Brazilian Flora 2020 database - Version 393.387</p></a></li>
<li><a href='#biomes'><p>SpatVector of the biomes of Brazil</p></a></li>
<li><a href='#brazil'><p>SpatVector of the Brazil's national borders</p></a></li>
<li><a href='#check_names'><p>Check species names</p></a></li>
<li><a href='#check_version'><p>Check if you have the latest version of Brazilian Flora data available</p></a></li>
<li><a href='#filter_florabr'><p>Identify records outside natural ranges according to Brazilian Flora 2020</p></a></li>
<li><a href='#get_attributes'><p>Get available attributes to filter species</p></a></li>
<li><a href='#get_binomial'><p>Extract the binomial name (Genus + specific epithet) from a Scientific Name</p></a></li>
<li><a href='#get_florabr'><p>Download the latest version of Brazilian Flora 2020 database</p></a></li>
<li><a href='#get_pam'><p>Get a presence-absence matrix</p></a></li>
<li><a href='#get_spat_occ'><p>Get Spatial polygons (SpatVectors) of species based on its distribution</p>
(States and Biomes) according to Brazilian Flora 2020</a></li>
<li><a href='#load_florabr'><p>Load Brazilian Flora database</p></a></li>
<li><a href='#occurrences'><p>Records of plant species</p></a></li>
<li><a href='#select_by_vernacular'><p>Search for taxa using vernacular names</p></a></li>
<li><a href='#select_species'><p>Selection of species based on its characteristics and distribution</p></a></li>
<li><a href='#states'><p>SpatVector of the federal states of Brazil</p></a></li>
<li><a href='#subset_species'><p>Extract a subset of species from Brazilian Flora 2020 database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Explore Brazilian Flora 2020 Database</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions designed to retrieve, filter and spatialize data from the Brazilian Flora 2020 dataset. For more information about the dataset, please visit <a href="https://floradobrasil.jbrj.gov.br/consulta/">https://floradobrasil.jbrj.gov.br/consulta/</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>XML (&ge; 3.99.0.14), data.table (&ge; 1.14.8), httr (&ge; 1.4.6),
terra (&ge; 1.7.39), stats (&ge; 4.2.3), utils(&ge; 4.2.3), grDevices
(&ge; 4.2.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wevertonbio.github.io/florabr/">https://wevertonbio.github.io/florabr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wevertonbio/florabr/issues">https://github.com/wevertonbio/florabr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-14 00:54:07 UTC; wever</td>
</tr>
<tr>
<td>Author:</td>
<td>Weverton Trindade <a href="https://orcid.org/0000-0003-2045-4555"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weverton Trindade &lt;wevertonf1993@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-14 01:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='Attributes'>Available attributes/parameters to filter and select species</h2><span id='topic+Attributes'></span>

<h3>Description</h3>

<p>A list of dataset containing the available attributes to filter and select
species. The dataset is used internally by <code>get_attributes</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Attributes)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with 11 elements: States, Biome, vegetationType,
lifeForm, habitat, nomenclaturalStatus, taxonomicStatus, Endemism, Origin,
Group, and Subgroup
</p>

<hr>
<h2 id='bf_data'>Brazilian Flora 2020 database - Version 393.387</h2><span id='topic+bf_data'></span>

<h3>Description</h3>

<p>A dataset containing a subset of the Brazilian Flora database (version
393.387)
</p>
<p>@usage data(bf_data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bf_data
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 110250 rows and 18 variables:
</p>

<dl>
<dt>species</dt><dd><p>Species names</p>
</dd>
<dt>acceptedName</dt><dd><p>Accepted name of the species (NA when the name in
species is already an accepted name)</p>
</dd>
<dt>kingdom</dt><dd><p>Kingdom to which species belongs (Plantae or Fungi)</p>
</dd>
<dt>Group</dt><dd><p>Major group to which species belongs (Angiosperms,
Gymnosperms, Ferns and Lycophytes, Bryophytes, and Algae)</p>
</dd>
<dt>Subgroup</dt><dd><p>Subgroup to which species belongs. Only available for
Bryophytes (Mosses, Hornworts, and Liverworts)</p>
</dd>
<dt>family</dt><dd><p>Family to which species belongs</p>
</dd>
<dt>genus</dt><dd><p>Genus to which species belongs</p>
</dd>
<dt>lifeForm</dt><dd><p>Life form of the species (e.g: Tree, Herb, Shrub, etc.)</p>
</dd>
<dt>habitat</dt><dd><p>Habitat type of the species (e.g., Terrestrial, Rupicolous,
Epiphytic, etc.)</p>
</dd>
<dt>Biome</dt><dd><p>Biomes with confirmed occurrences of the species</p>
</dd>
<dt>States</dt><dd><p>Federal states with confirmed occurrences of the species</p>
</dd>
<dt>vegetationType</dt><dd><p>Vegetation types with confirmed occurrences of the
species</p>
</dd>
<dt>Origin</dt><dd><p>Indicates whether the species is Native, Naturalized, or
Cultivated in Brazil</p>
</dd>
<dt>Endemism</dt><dd><p>Indicates whether the species is Endemic or Non-endemic to
Brazil</p>
</dd>
<dt>taxonomicStatus</dt><dd><p>Indicates the level of recognition and acceptance
of the species (Accepted or Synonym)</p>
</dd>
<dt>nomenclaturalStatus</dt><dd><p>Indicates the legitimacy and validity of the
species name (Correct, Illegitimate, Uncertain_Application, etc.)</p>
</dd>
<dt>vernacularName</dt><dd><p>Locally or culturally used name for the species</p>
</dd>
<dt>taxonRank</dt><dd><p>Taxonomic rank (Species, Genus, Family, Order, etc). This
data contains only Species</p>
</dd>
</dl>


<hr>
<h2 id='biomes'>SpatVector of the biomes of Brazil</h2><span id='topic+biomes'></span>

<h3>Description</h3>

<p>A simplified and packed SpatVector of the polygons of the biomes present in
Brazilian territory. The spatial data was originally obtained from
<code>geobr::read_biomes</code>. Borders have been simplified by removing vertices
of borders using <code>terra::simplifyGeom</code>. It's necessary unpack the
Spatvectos using <code>terra::unwrap</code>
</p>
<p>@usage data(biomes)
biomes &lt;- terra::unwrap(biomes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biomes
</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> with 6 geometries and 1 attribute:
</p>

<dl>
<dt>name_biome</dt><dd><p>The name of the biome (Amazon, Caatinga, Cerrado,
Atlantic_Forest, Pampa, and Pantanal)</p>
</dd>
</dl>


<hr>
<h2 id='brazil'>SpatVector of the Brazil's national borders</h2><span id='topic+brazil'></span>

<h3>Description</h3>

<p>A simplified and packed SpatVector of the Brazil's national borders. The
spatial data was originally obtained from <code>geobr::read_country</code>.
Borders have been simplified by removing vertices of borders using
<code>terra::simplifyGeom</code>. It's necessary unpack the Spatvectos using
<code>terra::unwrap</code>
</p>
<p>@usage data(brazil)
brazil &lt;- terra::unwrap(brazil)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brazil
</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> with 1 geometry and 0 attribute
</p>

<hr>
<h2 id='check_names'>Check species names</h2><span id='topic+check_names'></span>

<h3>Description</h3>

<p>check_names checks if the species names are correct and searches
for suggestions if the name is misspelled or not found in the Brazilian
Flora 2020 database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_names(data, species, max_distance = 0.1, Kingdom = "Plantae")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_names_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="check_names_+3A_species">species</code></td>
<td>
<p>(character) names of the species to be checked.</p>
</td></tr>
<tr><td><code id="check_names_+3A_max_distance">max_distance</code></td>
<td>
<p>(numeric) Maximum distance (as a fraction) allowed for
searching suggestions when the name is misspelled. It can be any value
between 0 and 1. The higher the value, the more suggestions are returned.
For more details, see <code><a href="base.html#topic+agrep">agrep</a></code>. Default = 0.1.</p>
</td></tr>
<tr><td><code id="check_names_+3A_kingdom">Kingdom</code></td>
<td>
<p>(character) the kingdom to which the species belong. It can
be &quot;Plantae&quot; or &quot;Fungi&quot;. Default = &quot;Plantae&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the following columns:
</p>

<ul>
<li><p> input_name: the species names informed in species argument
</p>
</li>
<li><p> Spelling: indicates if the species name is Correct (a perfect match with a
species name in the Brazilian Flora 2020), Probably_incorrect
(partial match), or Not_found (no match with any species).
</p>
</li>
<li><p> Suggested name: If Spelling is Correct, it is the same as the input_name.
If Spelling is Probably_correct, one or more suggested names are listed,
found according to the maximum distance. If Spelling is &quot;Not_found&quot;, the value
is NA.
</p>
</li>
<li><p> Distance: The integer Levenshtein edit distance. It represents the number
of single-character edits (insertions, deletions, or substitutions) required
to transform the input_name into the Suggested_name.
</p>
</li>
<li><p> taxonomicStatus: the taxonomic status of the species name (&quot;Accepted&quot; or
&quot;Synonym&quot;).
</p>
</li>
<li><p> nomenclaturalStatus: the nomenclatural status of the species name. This
information is not available for all species.
</p>
</li>
<li><p> acceptedName: If the species name is not accepted or incorrect, the
accepted name of the specie. If the species name is accepted and correct,
the same as input_name and Suggested_name.
</p>
</li>
<li><p> family: the family of the specie.
</p>
</li></ul>



<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data", package = "florabr")
spp &lt;- c("Butia cattarinensis", "Araucaria angustifolia")
check_names(data = bf_data, species = spp)
</code></pre>

<hr>
<h2 id='check_version'>Check if you have the latest version of Brazilian Flora data available</h2><span id='topic+check_version'></span>

<h3>Description</h3>

<p>This function checks if you have the latest version of the Brazilian Flora
data available in a specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_version(data_dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_version_+3A_data_dir">data_dir</code></td>
<td>
<p>the directory where the data should be located.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A message informing whether you have the latest version of Brazilian
Flora data available in the data_dir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Check if there is a version of Brazilian Flora data available in the current
#directory
check_version(data_dir = getwd())
</code></pre>

<hr>
<h2 id='filter_florabr'>Identify records outside natural ranges according to Brazilian Flora 2020</h2><span id='topic+filter_florabr'></span>

<h3>Description</h3>

<p>This function removes or flags records outside of the species'
natural ranges according to information provided by the Brazilian Flora 2020
database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_florabr(data, occ, Species = "species", Long = "x", Lat = "y",
                      by_State = TRUE, buffer_State = 20, by_Biome = TRUE,
                      buffer_Biome = 20, by_Endemism = TRUE,
                      Buffer_Brazil = 20, State_vect = NULL,
                      state_column = NULL, Biome_vect = NULL,
                      biome_column = NULL, BR_vect = NULL,
                      value = "flag&amp;clean", keep_columns = TRUE,
                      verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_florabr_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_occ">occ</code></td>
<td>
<p>(data.frame) a data.frame with the records of the species.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_species">Species</code></td>
<td>
<p>(character) column name in occ with species names.
Default = &quot;species&quot;</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_long">Long</code></td>
<td>
<p>(character) column name in occ with longitude data. Default = &quot;x&quot;</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_lat">Lat</code></td>
<td>
<p>(character) column name in occ with latitude data. Default = &quot;y&quot;</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_by_state">by_State</code></td>
<td>
<p>(logical) filter records by state? Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_buffer_state">buffer_State</code></td>
<td>
<p>(numeric) buffer (in km) around the polygons of the
states of occurrence of the specie. Default = 20.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_by_biome">by_Biome</code></td>
<td>
<p>(logical) filter records by Biome? Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_buffer_biome">buffer_Biome</code></td>
<td>
<p>(numeric) buffer (in km) around the polygons of the
biomes of occurrence of the specie. Default = 20.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_by_endemism">by_Endemism</code></td>
<td>
<p>(logical) filter records by endemism? Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_buffer_brazil">Buffer_Brazil</code></td>
<td>
<p>(numeric) buffer (in km) around the polygons of the
Brazil. Default = 20.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_state_vect">State_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian states. By
default, it uses the SpatVector provided by geobr::read_state(). It can be
another Spatvector, but the structure must be identical to
geobr::read_state().</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_state_column">state_column</code></td>
<td>
<p>(character) name of the column in State_vect containing
state abbreviations. Only use if Biome_vect is not null.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_biome_vect">Biome_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian biomes. By
default, it uses the SpatVector provided by geobr::read_biomes(). It can be
another SpatVector, but the structure must be identical to
geobr::read_biomes() with biome names in English.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_biome_column">biome_column</code></td>
<td>
<p>(character) name of the column in Biome_vect containing
names of brazilian biomes (in English: &quot;Amazon&quot;, &quot;Atlantic_Forest&quot;,
&quot;Caatinga&quot;, &quot;Cerrado&quot;, &quot;Pampa&quot; and &quot;Pantanal&quot;. Only use if Biome_vect is not
null.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_br_vect">BR_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of Brazil. By default, it uses the
SpatVector provided by geobr::read_state() after being aggregated/dissolved,</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_value">value</code></td>
<td>
<p>(character) Defines output values. See Value section.
Default = &quot;flag&amp;clean&quot;.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_keep_columns">keep_columns</code></td>
<td>
<p>(logical) if TRUE, keep all the original columns of the
input occ. If False, keep only the columns Species, Long and Lat.
Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display species being filtered during
function execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If by_State = TRUE and/or by_Biome = TRUE, the function takes polygons
representing the states and/or Biomes with confirmed occurrences of the
specie, draws a buffer around the polygons, and tests if the records of the
species fall inside it.
If by_Endemism = TRUE, the function checks if the species is endemic to
Brazil. If it is endemic, the function tests if the records of the specie
fall inside a polygon representing the boundaries of Brazil (with a buffer).
</p>


<h3>Value</h3>

<p>Depending on the 'value' argument. If value = &quot;flag&quot;, it returns the
same data.frame provided in data with additional columns indicating if the
record falls inside the natural range of the specie (TRUE) or outside
(FALSE).
If value = &quot;clean&quot;, it returns a data.frame with only the records that passes
all the tests (TRUE for all the filters). If value = &quot;flag&amp;clean&quot; (Default),
it returns a list with two data.frames: one with the flagged records and one
with the cleaned records.
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Brazilian Flora data
data("occurrences") #Load occurrences
pts &lt;- subset(occurrences, species == "Myrcia hatschbachii")
fd &lt;- filter_florabr(data = bf_data, occ = pts,
                    by_State = TRUE, buffer_State = 20,
                    by_Biome = TRUE, buffer_Biome = 20,
                    by_Endemism = TRUE, Buffer_Brazil = 20,
                    State_vect = NULL,
                    Biome_vect = NULL, BR_vect = NULL,
                    value = "flag&amp;clean", keep_columns = TRUE,
                    verbose = FALSE)
</code></pre>

<hr>
<h2 id='get_attributes'>Get available attributes to filter species</h2><span id='topic+get_attributes'></span>

<h3>Description</h3>

<p>This function displays all the options available to filter species by its
characteristics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attributes(data, attribute, Kingdom = "Plantae")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_attributes_+3A_data">data</code></td>
<td>
<p>(data.frame) a data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function or a data.frame generated with the
<code><a href="#topic+select_species">select_species</a></code> function.</p>
</td></tr>
<tr><td><code id="get_attributes_+3A_attribute">attribute</code></td>
<td>
<p>(character) the type of characteristic. See detail to see
the options.</p>
</td></tr>
<tr><td><code id="get_attributes_+3A_kingdom">Kingdom</code></td>
<td>
<p>(character) the kingdom to which the species belong. It can
be &quot;Plantae&quot; or &quot;Fungi&quot;. Default = &quot;Plantae&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attribute argument accepts the following options: Group, SubGroup,
family, lifeForm, habitat, vegetationType, Origin, Endemism, Biome, States,
taxonomicStatus or nomenclaturalStatus&quot;. These options represent different
characteristics of species that can be used for filtering.
</p>


<h3>Value</h3>

<p>a data.frame with two columns. The first column provides the
available options in English. Use this options in the
<code><a href="#topic+select_species">select_species</a></code> function. The second columns provides the
options in Portuguese.
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Brazilian Flora data
# Get available biomes to filter species
get_attributes(data = bf_data, Kingdom = "Plantae", attribute = "Biome")
# Get available life forms to filter species
get_attributes(data = bf_data, Kingdom = "Plantae", attribute = "lifeForm")
# Get available states to filter species
get_attributes(data = bf_data, Kingdom = "Plantae", attribute = "States")
</code></pre>

<hr>
<h2 id='get_binomial'>Extract the binomial name (Genus + specific epithet) from a Scientific Name</h2><span id='topic+get_binomial'></span>

<h3>Description</h3>

<p>Extract the binomial name (Genus + specific epithet) from a Scientific Name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_binomial(species_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_binomial_+3A_species_names">species_names</code></td>
<td>
<p>(character) Scientific names to be converted to
binomial names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the binomial names (Genus + specific epithet).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spp &lt;- c("Araucaria angustifolia (Bertol.) Kuntze",
"Butia catarinensis Noblick &amp; Lorenzi",
"Adesmia paranensis Burkart")
spp_new &lt;- get_binomial(species_names = spp)
spp_new

</code></pre>

<hr>
<h2 id='get_florabr'>Download the latest version of Brazilian Flora 2020 database</h2><span id='topic+get_florabr'></span>

<h3>Description</h3>

<p>This function downloads the latest or an older version of Brazilian Flora
2020 database, merges the information into a single data.frame, and saves
this data.frame in the specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_florabr(output_dir, data_version = "latest",
                 solve_incongruences = TRUE, overwrite = TRUE,
                 verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_florabr_+3A_output_dir">output_dir</code></td>
<td>
<p>(character) a directory to save the data downloaded from
Brazilian Flora 2020</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_data_version">data_version</code></td>
<td>
<p>(character) Version of the Brazilian Flora database to
download. Use &quot;latest&quot; to get the most recent version, updated weekly.
Alternatively, specify an older version (e.g., data_version = &quot;393.319&quot;).
Default value is &quot;latest&quot;.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_solve_incongruences">solve_incongruences</code></td>
<td>
<p>Resolve inconsistencies between species and
subspecies/varieties  information. When set to TRUE (default), species
information is updated based on unique data from varieties and subspecies.
For example, if a subspecies occurs in a certain biome, it implies that the
species also occurs in that biome.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) If TRUE, data is overwritten. Default = TRUE.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display messages during function
execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function downloads the latest version of the Brazilian Flora 2020
database from the official source. It then merges the information into a
single data.frame, containing details on species, taxonomy, occurrence,
and other relevant data.
The merged data.frame is then saved as a file in the specified output
directory. The data is saved in a format that allows easy loading using the
<code><a href="#topic+load_florabr">load_florabr</a></code> function for further analysis in R.
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Creating a folder in a temporary directory
#Replace 'file.path(tempdir(), "florabr")' by a path folder to be create in
#your computer
my_dir &lt;- file.path(file.path(tempdir(), "florabr"))
dir.create(my_dir)
#Download, merge and save data
get_florabr(output_dir = my_dir, data_version = "latest",
            solve_incongruences = TRUE, overwrite = TRUE, verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_pam'>Get a presence-absence matrix</h2><span id='topic+get_pam'></span>

<h3>Description</h3>

<p>Get a presence-absence matrix of species based on its distribution
(States, Biomes and vegetation types) according to Brazilian Flora 2020
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pam(data, by_Biome = TRUE, by_State = TRUE,
               by_vegetationType = FALSE, remove_empty_sites = TRUE,
               return_richness_summary = TRUE,
               return_spatial_richness = TRUE,
               return_plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pam_+3A_data">data</code></td>
<td>
<p>(data.frame) a data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function or generated by either
<code><a href="#topic+select_species">select_species</a></code> or <code><a href="#topic+subset_species">subset_species</a></code> functions</p>
</td></tr>
<tr><td><code id="get_pam_+3A_by_biome">by_Biome</code></td>
<td>
<p>(logical) get occurrences by Biome. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_by_state">by_State</code></td>
<td>
<p>(logical) get occurrences by State. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_by_vegetationtype">by_vegetationType</code></td>
<td>
<p>(logical) get occurrences by vegetation type.
Default = FALSE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_remove_empty_sites">remove_empty_sites</code></td>
<td>
<p>(logical) remove empty sites (sites without any
species) from final presence-absence matrix. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_return_richness_summary">return_richness_summary</code></td>
<td>
<p>(logical) return a data.frame with the number
of species in each site. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_return_spatial_richness">return_spatial_richness</code></td>
<td>
<p>(logical) return a SpatVector with the number
of species in each site. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_return_plot">return_plot</code></td>
<td>
<p>(logical) plot map with the number of species in each
site.
Only works if return_spatial_richness = TRUE. Default = TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_richness_summary and/or return_spatial_richness is set to
TRUE, return a list with:
</p>

<ul>
<li><p> PAM: the presence-absence matrix (PAM)
</p>
</li>
<li><p> Richness_summary: a data.frame with the number of species in each site
</p>
</li>
<li><p> Spatial_richness: a SpatVector with the number of species in each site
(only by State and Biome)
</p>
</li></ul>

<p>If return_richness_summary and return_spatial_richness is set to FALSE,
return a presence-absence matrix
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Brazilian Flora data
#Select endemic and native species of trees with occurrence only in Amazon
am_trees &lt;- select_species(data = bf_data,
                          include_subspecies = FALSE,
                          include_variety = FALSE,
                          Kingdom = "Plantae",
                          Group = "All", Subgroup = "All",
                          Family = "All", Genus = "All",
                          LifeForm = "Tree", filter_LifeForm = "only",
                          Habitat = "All", filter_Habitat = "in",
                          Biome = "Amazon",
                          filter_Biome = "only",
                          State = "All", filter_State = "and",
                          VegetationType = "All",
                          filter_Vegetation = "in",
                          Endemism = "Endemic", Origin = "Native",
                          TaxonomicStatus = "Accepted",
                          NomenclaturalStatus = "All")
#Get presence-absence matrix
pam_am &lt;- get_pam(data = am_trees, by_Biome = TRUE, by_State = TRUE,
                 by_vegetationType = FALSE, remove_empty_sites = TRUE,
                 return_richness_summary = TRUE,
                 return_spatial_richness = TRUE,
                 return_plot = TRUE)

</code></pre>

<hr>
<h2 id='get_spat_occ'>Get Spatial polygons (SpatVectors) of species based on its distribution
(States and Biomes) according to Brazilian Flora 2020</h2><span id='topic+get_spat_occ'></span>

<h3>Description</h3>

<p>Get Spatial polygons (SpatVectors) of species based on its distribution
(States and Biomes) according to Brazilian Flora 2020
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_spat_occ(
  data,
  species,
  State = TRUE,
  Biome = TRUE,
  intersection = TRUE,
  State_vect = NULL,
  state_column = NULL,
  Biome_vect = NULL,
  biome_column = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_spat_occ_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_species">species</code></td>
<td>
<p>(character) one or more species names (only genus and
specific epithet, eg. &quot;Araucaria angustifolia&quot;)</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_state">State</code></td>
<td>
<p>(logical) get SpatVector of states with occurrence of the
species? Default = TRUE</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_biome">Biome</code></td>
<td>
<p>(logical) get SpatVector of biomes with occurrence of the
species? Default = TRUE</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_intersection">intersection</code></td>
<td>
<p>(character) get a Spatvector representing the
intersection between States and Biomes with occurrence of the specie?
To use intersection = TRUE, you must define State = TRUE and Biome = TRUE&quot;.
Default = TRUE</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_state_vect">State_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian states. By
default, it uses the SpatVector provided by geobr::read_state(). It can be
another Spatvector, but the structure must be identical to
geobr::read_state().</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_state_column">state_column</code></td>
<td>
<p>(character) name of the column in State_vect containing
state abbreviations. Only use if Biome_vect is not null.</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_biome_vect">Biome_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian biomes. By
default, it uses the SpatVector provided by geobr::read_biomes(). It can be
another SpatVector, but the structure must be identical to
geobr::read_biomes().</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_biome_column">biome_column</code></td>
<td>
<p>(character) name of the column in Biome_vect containing
names of brazilian biomes (in English: &quot;Amazon&quot;, &quot;Atlantic_Forest&quot;,
&quot;Caatinga&quot;, &quot;Cerrado&quot;, &quot;Pampa&quot; and &quot;Pantanal&quot;. Only use if Biome_vect is not
null.</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display species being filtered during
function execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with SpatVectors of States and/or Biomes and/or Intersections
for each specie.
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data("bf_data") #Load Brazilian Flora data
spp &lt;- c("Araucaria angustifolia", "Adesmia paranensis") #Example species
#Get states, biomes and intersection states-biomes of species
spp_spt &lt;- get_spat_occ(data = bf_data, species = spp, State = TRUE,
                       Biome = TRUE, intersection = TRUE, State_vect = NULL,
                       Biome_vect = NULL, verbose = TRUE)


#Plot states of occurrence of Araucaria angustifolia
plot(spp_spt[[1]]$States, main = names(spp_spt)[[1]])
#Plot biomes of occurrence of Araucaria angustifolia
plot(spp_spt[[2]]$Biomes, main = names(spp_spt)[[2]])
#Plot intersection between states and biomes of occurrence of
#Araucaria angustifolia
plot(spp_spt[[1]]$States_Biomes)

</code></pre>

<hr>
<h2 id='load_florabr'>Load Brazilian Flora database</h2><span id='topic+load_florabr'></span>

<h3>Description</h3>

<p>Load Brazilian Flora database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_florabr(data_dir, data_version = "Latest_available",
                    type = "short", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_florabr_+3A_data_dir">data_dir</code></td>
<td>
<p>(character) the same directory used to save the data
downloaded from Brazilian Flora 2020 using the <a href="#topic+get_florabr">get_florabr</a> function.</p>
</td></tr>
<tr><td><code id="load_florabr_+3A_data_version">data_version</code></td>
<td>
<p>(character) the version of Brazilian Flora database to
be loaded. It can be &quot;Latest_available&quot;, which will load the latest version
available; or another specified version, for example &quot;393.364&quot;.
Default = &quot;Latest_available&quot;.</p>
</td></tr>
<tr><td><code id="load_florabr_+3A_type">type</code></td>
<td>
<p>(character) it determines the number of columns that will be
loaded. It can be &quot;short&quot; or &quot;complete&quot;. Default = &quot;short&quot;. See details.</p>
</td></tr>
<tr><td><code id="load_florabr_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display messages during function
execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter type accepts two arguments. If type = short, it will load a
data.frame with the 19 columns needed to run the other functions of the
package: species, scientificName, acceptedName, kingdom, Group, Subgroup,
family, genus, lifeForm, habitat, Biome, States, vegetationType, Origin,
Endemism, taxonomicStatus, nomenclaturalStatus, vernacularName, and
taxonRank.
If type = complete, it will load a data.frame with all 39 variables available
in Brazilian Flora database.
</p>


<h3>Value</h3>

<p>A data.frame with the specified version (Default is the latest
available) of the Brazilian Flora database. This data.frame is necessary to
run most of the functions of the package.
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Creating a folder in a temporary directory
#Replace 'file.path(tempdir(), "florabr")' by a path folder to be create in
#your computer
my_dir &lt;- file.path(file.path(tempdir(), "florabr"))
dir.create(my_dir)
#Download, merge and save data
get_florabr(output_dir = my_dir, data_version = "latest", overwrite = TRUE,
            verbose = TRUE)
#Load data
df &lt;- load_florabr(data_dir = my_dir, data_version = "Latest_available",
type = "short")

## End(Not run)
</code></pre>

<hr>
<h2 id='occurrences'>Records of plant species</h2><span id='topic+occurrences'></span>

<h3>Description</h3>

<p>A dataset containing records of 7 plant species downloaded from GBIF. The
records were obtained with <code>plantR::rgbif2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(occurrences)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 1521 rows and 3 variables:
</p>

<dl>
<dt>species</dt><dd><p>Species names (Araucaria angustifolia, Abatia americana,
Passiflora edmundoi, Myrcia hatschbachii, Serjania pernambucensis, Inga
virescens, and Solanum restingae)</p>
</dd>
<dt>x</dt><dd><p>Longitude</p>
</dd>
<dt>y</dt><dd><p>Latitude</p>
</dd>
</dl>


<hr>
<h2 id='select_by_vernacular'>Search for taxa using vernacular names</h2><span id='topic+select_by_vernacular'></span>

<h3>Description</h3>

<p>Search for taxa using vernacular names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_by_vernacular(data, names, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_by_vernacular_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function or generated with the function
<code><a href="#topic+select_species">select_species</a></code>.</p>
</td></tr>
<tr><td><code id="select_by_vernacular_+3A_names">names</code></td>
<td>
<p>(character) vernacular name (&quot;Nome comum&quot;) of the species to be
searched</p>
</td></tr>
<tr><td><code id="select_by_vernacular_+3A_exact">exact</code></td>
<td>
<p>(logic) if TRUE, the function will search only for exact
matches. For example, if names = &quot;pinheiro&quot; and exact = TRUE, the function
will return only the species popularly known as &quot;pinheiro&quot;. On the other
hand, if names = &quot;pinheiro&quot; and exact = FALSE, the function will return
other results as &quot;pinheiro-do-parana&quot;. Default = FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the species with vernacular names that match the
input names
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>
<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Brazilian Flora data
#Search for species whose vernacular name is 'pinheiro'
pinheiro_exact &lt;- select_by_vernacular(data = bf_data,
                                       names = "pinheiro",
                                       exact = TRUE)
pinheiro_exact
#Search for species whose vernacular name is 'pinheiro', allowing non-exact
#matches
pinheiro_not_exact &lt;- select_by_vernacular(data = bf_data,
                                          names = "pinheiro",
                                          exact = FALSE)
head(pinheiro_not_exact)

</code></pre>

<hr>
<h2 id='select_species'>Selection of species based on its characteristics and distribution</h2><span id='topic+select_species'></span>

<h3>Description</h3>

<p>select_species allows filter species based on its
characteristics and distribution available in Brazilian Flora 2020
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_species(data,
                      include_subspecies = FALSE, include_variety = FALSE,
                      Kingdom = "Plantae", Group = "All", Subgroup = "All",
                      Family = "All", Genus = "All",
                      LifeForm = "All", filter_LifeForm = "in",
                      Habitat = "All", filter_Habitat = "in",
                      Biome = "All", filter_Biome = "in",
                      State = "All", filter_State = "in",
                      VegetationType = "All", filter_Vegetation = "in",
                      Endemism = "All", Origin = "All",
                      TaxonomicStatus = "Accepted",
                      NomenclaturalStatus = "All")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_species_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="select_species_+3A_include_subspecies">include_subspecies</code></td>
<td>
<p>(logical) include subspecies?
Default = FALSE</p>
</td></tr>
<tr><td><code id="select_species_+3A_include_variety">include_variety</code></td>
<td>
<p>(logical) include varieties of the species?
Default = FALSE</p>
</td></tr>
<tr><td><code id="select_species_+3A_kingdom">Kingdom</code></td>
<td>
<p>(character) The Kingdom for filtering the dataset. It can be
&quot;Plantae&quot; or &quot;Fungi&quot;. Default = &quot;Plantae&quot;. To include both,
use c(&quot;Plantae&quot;, &quot;Fungi&quot;)</p>
</td></tr>
<tr><td><code id="select_species_+3A_group">Group</code></td>
<td>
<p>(character) The groups for filtering the datasets. It can be
&quot;Fungi&quot;, &quot;Angiosperms&quot;, &quot;Gymnosperms&quot;, &quot;Ferns and Lycophytes&quot;,
&quot;Bryophytes&quot; and &quot;Algae&quot;. To use more than one group, put the available
items in a vector, for example: Group = c(Angiosperms&quot;, &quot;Gymnosperms&quot;).
Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_subgroup">Subgroup</code></td>
<td>
<p>(character) The subgroups for filtering the dataset.
Only available if the Group is &quot;Fungi&quot; or &quot;Bryophytes&quot;. For Fungi, it can be
&quot;stricto sensu&quot; or &quot;lato sensu&quot;. For Bryophytes, it can be &quot;Mosses&quot;,
&quot;Hornworts&quot; and &quot;Liverworts&quot; . To use more than one group, put the available
items in a vector, for example: Subgroup = c(&quot;Mosses&quot;, &quot;Hornworts&quot;).
Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_family">Family</code></td>
<td>
<p>(character) The families for filtering the dataset. It can
be included more than one Family. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_genus">Genus</code></td>
<td>
<p>(character) The genus for filtering the dataset. It can
be included more than one Genus. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_lifeform">LifeForm</code></td>
<td>
<p>(character) The life forms for filtering the dataset. It can
be included more than one LifeForm. Default = &quot;All&quot;</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_lifeform">filter_LifeForm</code></td>
<td>
<p>(character) The type of filtering for life forms. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_habitat">Habitat</code></td>
<td>
<p>(character) The life habitat for filtering the dataset. It can
be included more than one habitat. Default = &quot;All&quot;</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_habitat">filter_Habitat</code></td>
<td>
<p>(character) The type of filtering for habitat. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_biome">Biome</code></td>
<td>
<p>(character) The biomes for filtering the dataset. It can
be included more than one biome. Default = &quot;All&quot;</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_biome">filter_Biome</code></td>
<td>
<p>(character) The type of filtering for biome. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_state">State</code></td>
<td>
<p>(character) The States for filtering the dataset. It can
be included more than one state. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_state">filter_State</code></td>
<td>
<p>(character) The type of filtering for state. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See Details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_vegetationtype">VegetationType</code></td>
<td>
<p>(character) The vegetation types for filtering the
dataset. It can be included more than one vegetation type. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_vegetation">filter_Vegetation</code></td>
<td>
<p>(character) The type of filtering for
vegetation type. It can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for
more about this argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_endemism">Endemism</code></td>
<td>
<p>(character) The endemism (endemic or non-endemic to Brazil)
for filtering the dataset. It can be &quot;All&quot;, &quot;Endemic&quot; or &quot;Non-endemic&quot;.
Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_origin">Origin</code></td>
<td>
<p>(character) The origin for filtering the dataset. It can
be &quot;All&quot;, &quot;Native&quot;, &quot;Cultivated&quot; and &quot;Naturalized&quot;. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_taxonomicstatus">TaxonomicStatus</code></td>
<td>
<p>(character) The taxonomic status for filtering the
dataset. It can be &quot;All&quot;, &quot;Accepted&quot; or &quot;Synonym&quot;. Default = &quot;Accepted&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_nomenclaturalstatus">NomenclaturalStatus</code></td>
<td>
<p>(character) The nomenclatural status for
filtering the dataset. Default = &quot;Accepted&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's possible to choose 4 ways to filter by lifeform, by habitat,
by biome, by state and by vegetation type:
&quot;in&quot;: selects species that have any occurrence of the determined values. It
allows multiple matches. For example, if Biome = c(&quot;Amazon&quot;, Cerrado&quot; and
filter_Biome = &quot;in&quot;, it will select all species that occur in the Amazon and
Cerrado, some of which may also occur in other biomes.
</p>
<p>&quot;only&quot;: selects species that have only occurrence of the determined values.
It allows only single matches. For example, if Biome = c(&quot;Amazon&quot;, &quot;Cerrado&quot;)
and filter_Biome = &quot;only&quot;, it will select all species that occur exclusively
in both the Amazon and Cerrado biomes, without any occurrences in other
biomes.
</p>
<p>&quot;not_in&quot;: selects species that don't have occurrence of the determined
values. It allows single and multiple matches. For example,
if Biome = c(&quot;Amazon&quot;, &quot;Cerrado&quot;) and filter_Biome = &quot;not_in&quot;, it will select
all species without occurrences in the Amazon and Cerrado biomes.
</p>
<p>&quot;and&quot;: selects species that have occurrence in all determined values. It
allows single and multiple matches. For example,
if Biome = c(&quot;Amazon&quot;, &quot;Cerrado&quot;) and filter_Biome = &quot;and&quot;, it will select
all species that occurs only in both the Amazon and Cerrado biomes,
including species that occurs in other biomes too.
</p>
<p>To get the complete list of arguments available for Family, Genus, LifeForm,
Habitat, Biome, State, and NomenclaturalStatus, use the function
<code><a href="#topic+get_attributes">get_attributes</a></code>
</p>


<h3>Value</h3>

<p>A new dataframe with the filtered species.
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Brazilian Flora data
#'Select endemic and native species of trees with disjunct occurrence in
# Atlantic Forest and Amazon
am_af_only &lt;- select_species(data = bf_data,
                             include_subspecies = FALSE,
                             include_variety = FALSE,
                             Kingdom = "Plantae",
                             Group = "All", Subgroup = "All",
                             Family = "All", Genus = "All",
                             LifeForm = "Tree", filter_LifeForm = "only",
                             Habitat = "All", filter_Habitat = "in",
                             Biome = c("Atlantic_Forest","Amazon"),
                             filter_Biome = "only",
                             State = "All", filter_State = "and",
                             VegetationType = "All",
                             filter_Vegetation = "in",
                             Endemism = "Endemic", Origin = "Native",
                             TaxonomicStatus = "All",
                             NomenclaturalStatus = "All")
</code></pre>

<hr>
<h2 id='states'>SpatVector of the federal states of Brazil</h2><span id='topic+states'></span>

<h3>Description</h3>

<p>A simplified and packed SpatVector of the polygons of the federal states of
Brazil. The spatial data was originally obtained from
<code>geobr::read_state</code>. Borders have been simplified by removing vertices
of borders using <code>terra::simplifyGeom</code>. It's necessary unpack the
Spatvectos using <code>terra::unwrap</code>
</p>
<p>@usage data(states)
states &lt;- terra::unwrap(states)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>states
</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> with 27 geometries and 3 attributes:
</p>

<dl>
<dt>abbrev_state</dt><dd><p>State acronym</p>
</dd>
<dt>name_state</dt><dd><p>State's full name</p>
</dd>
<dt>name_region</dt><dd><p>The region to which the state belongs</p>
</dd>
</dl>


<hr>
<h2 id='subset_species'>Extract a subset of species from Brazilian Flora 2020 database</h2><span id='topic+subset_species'></span>

<h3>Description</h3>

<p>Returns a data.frame with a subset of species from Brazilian Flora 2020
database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_species(data, species,
                      include_subspecies = FALSE,
                      include_variety = FALSE,
                      Kingdom = "Plantae")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_species_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="subset_species_+3A_species">species</code></td>
<td>
<p>(character) names of the species to be extracted from
Brazilian Flora database.</p>
</td></tr>
<tr><td><code id="subset_species_+3A_include_subspecies">include_subspecies</code></td>
<td>
<p>(logical) include subspecies?
Default = FALSE</p>
</td></tr>
<tr><td><code id="subset_species_+3A_include_variety">include_variety</code></td>
<td>
<p>(logical) include varieties of the species?
Default = FALSE</p>
</td></tr>
<tr><td><code id="subset_species_+3A_kingdom">Kingdom</code></td>
<td>
<p>(character) The Kingdom for filtering the dataset. It can be
&quot;Plantae&quot; or &quot;Fungi&quot;. Default = &quot;Plantae&quot;. To include both,
use c(&quot;Plantae&quot;, &quot;Fungi&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the selected species.
</p>


<h3>References</h3>

<p>Brazilian Flora 2020. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Brazilian Flora data
#Species to extract from database
spp &lt;- c("Araucaria angustifolia", "Adesmia paranensis")
spp_bf &lt;- subset_species(data = bf_data, species = spp,
                      include_subspecies = FALSE,
                      include_variety = FALSE)
spp_bf
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
