<!DOCTYPE html><html lang="en"><head><title>Help for package florabr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {florabr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bf_data'><p>Flora e Funga do Brasil database - Version 393.401</p></a></li>
<li><a href='#biomes'><p>SpatVector of the biomes of Brazil</p></a></li>
<li><a href='#brazil'><p>SpatVector of the Brazil's national borders</p></a></li>
<li><a href='#check_names'><p>Check species names</p></a></li>
<li><a href='#check_version'><p>Check if you have the latest version of Flora e Funga do Brasil data</p>
available</a></li>
<li><a href='#filter_florabr'><p>Identify records outside natural ranges according to Flora e Funga do Brasil</p></a></li>
<li><a href='#get_attributes'><p>Get available attributes to filter species</p></a></li>
<li><a href='#get_binomial'><p>Extract the binomial name (Genus + specific epithet + infraspecific epithet</p>
(optional)) from a full Scientific Name</a></li>
<li><a href='#get_florabr'><p>Download the latest version of Flora e Funga do Brasil database</p></a></li>
<li><a href='#get_pam'><p>Get a presence-absence matrix</p></a></li>
<li><a href='#get_spat_occ'><p>Get Spatial polygons (SpatVectors) of species based on its distribution</p>
(states and biomes) according to Flora e Funga do Brasil</a></li>
<li><a href='#get_synonym'><p>Retrieve synonyms for species</p></a></li>
<li><a href='#load_florabr'><p>Load Flora e Funga do Brasil database</p></a></li>
<li><a href='#occurrences'><p>Records of plant species</p></a></li>
<li><a href='#select_by_vernacular'><p>Search for taxa using vernacular names</p></a></li>
<li><a href='#select_species'><p>Selection of species based on its characteristics and distribution</p></a></li>
<li><a href='#solve_discrepancies'><p>Resolve discrepancies between species and subspecies/varieties information</p></a></li>
<li><a href='#states'><p>SpatVector of the federal states of Brazil</p></a></li>
<li><a href='#subset_species'><p>Extract a subset of species from Flora e Funga do Brasil database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Explore Flora e Funga do Brasil Database</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions designed to retrieve, filter and spatialize data from the Flora e Funga do Brasil dataset. For more information about the dataset, please visit <a href="https://floradobrasil.jbrj.gov.br/consulta/">https://floradobrasil.jbrj.gov.br/consulta/</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>XML (&ge; 3.99.0.14), data.table (&ge; 1.14.8), httr (&ge; 1.4.6),
terra (&ge; 1.7.39), stats (&ge; 4.2.3), utils(&ge; 4.2.3), grDevices
(&ge; 4.2.3), doSNOW (&ge; 1.0.20), parallel (&ge; 4.3.1), foreach
(&ge; 1.5.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wevertonbio.github.io/florabr/">https://wevertonbio.github.io/florabr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wevertonbio/florabr/issues">https://github.com/wevertonbio/florabr/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-09 16:47:41 UTC; wever</td>
</tr>
<tr>
<td>Author:</td>
<td>Weverton Trindade <a href="https://orcid.org/0000-0003-2045-4555"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weverton Trindade &lt;wevertonf1993@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-09 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bf_data'>Flora e Funga do Brasil database - Version 393.401</h2><span id='topic+bf_data'></span>

<h3>Description</h3>

<p>A dataset containing a subset of the Flora e Funga do Brasil database
(version 393.401)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bf_data)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 50010 rows and 23 variables:
</p>

<dl>
<dt>species</dt><dd><p>Species names</p>
</dd>
<dt>scientificName</dt><dd><p>Complete scientific name of the species</p>
</dd>
<dt>acceptedName</dt><dd><p>Accepted name of the species (NA when the name in
species is already an accepted name)</p>
</dd>
<dt>kingdom</dt><dd><p>Kingdom to which species belongs (Plantae or Fungi)</p>
</dd>
<dt>group</dt><dd><p>Major group to which species belongs (Angiosperms,
Gymnosperms, Ferns and Lycophytes, Bryophytes, and Algae)</p>
</dd>
<dt>subgroup</dt><dd><p>Subgroup to which species belongs. Only available for
Bryophytes (Mosses, Hornworts, and Liverworts)</p>
</dd>
<dt>phylum</dt><dd><p>Phylum to which species belongs</p>
</dd>
<dt>class</dt><dd><p>Class to which species belongs</p>
</dd>
<dt>order</dt><dd><p>Order to which species belongs</p>
</dd>
<dt>family</dt><dd><p>Family to which species belongs</p>
</dd>
<dt>genus</dt><dd><p>Genus to which species belongs</p>
</dd>
<dt>lifeForm</dt><dd><p>Life form of the species (e.g: Tree, Herb, Shrub, etc.)</p>
</dd>
<dt>habitat</dt><dd><p>Habitat type of the species (e.g., Terrestrial, Rupicolous,
Epiphytic, etc.)</p>
</dd>
<dt>biome</dt><dd><p>Biomes with confirmed occurrences of the species</p>
</dd>
<dt>states</dt><dd><p>Federal states with confirmed occurrences of the species</p>
</dd>
<dt>vegetation</dt><dd><p>Vegetation types with confirmed occurrences of the
species</p>
</dd>
<dt>origin</dt><dd><p>Indicates whether the species is Native, Naturalized, or
Cultivated in Brazil</p>
</dd>
<dt>endemism</dt><dd><p>Indicates whether the species is Endemic or Non-endemic to
Brazil</p>
</dd>
<dt>taxonomicStatus</dt><dd><p>Indicates the level of recognition and acceptance
of the species (Accepted or Synonym)</p>
</dd>
<dt>nomenclaturalStatus</dt><dd><p>Indicates the legitimacy and validity of the
species name (Correct, Illegitimate, Uncertain_Application, etc.)</p>
</dd>
<dt>vernacularName</dt><dd><p>Locally or culturally used name for the species</p>
</dd>
<dt>taxonRank</dt><dd><p>Taxonomic rank (Species, Genus, Family, Order, etc). This
data contains only Species</p>
</dd>
<dt>id</dt><dd><p>Unique id for species</p>
</dd>
</dl>



<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>

<hr>
<h2 id='biomes'>SpatVector of the biomes of Brazil</h2><span id='topic+biomes'></span>

<h3>Description</h3>

<p>A simplified and packed SpatVector of the polygons of the biomes present in
Brazilian territory. The spatial data was originally obtained from
<code>geobr::read_biomes</code>. Borders have been simplified by removing vertices
of borders using <code>terra::simplifyGeom</code>. It's necessary unpack the
Spatvectos using <code>terra::unwrap</code>
</p>
<p>@usage data(biomes)
biomes &lt;- terra::unwrap(biomes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biomes
</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> with 6 geometries and 1 attribute:
</p>

<dl>
<dt>name_biome</dt><dd><p>The name of the biome (Amazon, Caatinga, Cerrado,
Atlantic_Forest, Pampa, and Pantanal)</p>
</dd>
</dl>


<hr>
<h2 id='brazil'>SpatVector of the Brazil's national borders</h2><span id='topic+brazil'></span>

<h3>Description</h3>

<p>A simplified and packed SpatVector of the Brazil's national borders. The
spatial data was originally obtained from <code>geobr::read_country</code>.
Borders have been simplified by removing vertices of borders using
<code>terra::simplifyGeom</code>. It's necessary unpack the Spatvectos using
<code>terra::unwrap</code>
</p>
<p>@usage data(brazil)
brazil &lt;- terra::unwrap(brazil)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brazil
</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> with 1 geometry and 0 attribute
</p>

<hr>
<h2 id='check_names'>Check species names</h2><span id='topic+check_names'></span><span id='topic+match_names'></span>

<h3>Description</h3>

<p><code>check_names</code> checks if the species names are correct and searches
for suggestions if the name is misspelled or not found in the Flora e Funga
do Brasil database
</p>
<p><code>match_names</code> finds approximate matches to the specified pattern (species)
within each element of the string <code>x</code> (species_to_match). It is used internally
by <code>check_names</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_names(data, species, max_distance = 0.1,
                   include_subspecies= FALSE, include_variety = FALSE,
                   kingdom = "Plantae", parallel = FALSE, ncores = 1,
                   progress_bar = FALSE)

match_names(
  species,
  species_to_match,
  max_distance = 0.1,
  parallel = FALSE,
  ncores = 1,
  progress_bar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_names_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="check_names_+3A_species">species</code></td>
<td>
<p>(character) names of the species to be checked.</p>
</td></tr>
<tr><td><code id="check_names_+3A_max_distance">max_distance</code></td>
<td>
<p>(numeric) Maximum distance (as a fraction) allowed for
searching suggestions when the name is misspelled. It can be any value
between 0 and 1. The higher the value, the more suggestions are returned.
For more details, see <code><a href="base.html#topic+agrep">agrep</a></code>. Default = 0.1.</p>
</td></tr>
<tr><td><code id="check_names_+3A_include_subspecies">include_subspecies</code></td>
<td>
<p>(logical) whether to include subspecies. Default = FALSE</p>
</td></tr>
<tr><td><code id="check_names_+3A_include_variety">include_variety</code></td>
<td>
<p>(logical) whether to include varieties. Default = FALSE</p>
</td></tr>
<tr><td><code id="check_names_+3A_kingdom">kingdom</code></td>
<td>
<p>(character) the kingdom to which the species belong. It can
be &quot;Plantae&quot; or &quot;Fungi&quot;. Default = &quot;Plantae&quot;.</p>
</td></tr>
<tr><td><code id="check_names_+3A_parallel">parallel</code></td>
<td>
<p>(logical) whether to run in parallel. Setting this to <code>TRUE</code>
is recommended for improved performance when working with 100 or more species.</p>
</td></tr>
<tr><td><code id="check_names_+3A_ncores">ncores</code></td>
<td>
<p>(numeric) number of cores to use for parallel processing.
Default is 1. This is only applicable if <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="check_names_+3A_progress_bar">progress_bar</code></td>
<td>
<p>(logical) whether to display a progress bar during processing.
Default is FALSE</p>
</td></tr>
<tr><td><code id="check_names_+3A_species_to_match">species_to_match</code></td>
<td>
<p>(character) a vector of species names to match against
the <code>species</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the following columns:
</p>

<ul>
<li><p> input_name: the species names informed in species argument
</p>
</li>
<li><p> Spelling: indicates if the species name is Correct (a perfect match with a
species name in the Flora e Funga do Brasil), Probably_incorrect
(partial match), or Not_found (no match with any species).
</p>
</li>
<li><p> Suggested name: If Spelling is Correct, it is the same as the input_name.
If Spelling is Probably_correct, one or more suggested names are listed,
found according to the maximum distance. If Spelling is &quot;Not_found&quot;, the value
is NA.
</p>
</li>
<li><p> Distance: The integer Levenshtein edit distance. It represents the number
of single-character edits (insertions, deletions, or substitutions) required
to transform the input_name into the Suggested_name.
</p>
</li>
<li><p> taxonomicStatus: the taxonomic status of the species name (&quot;Accepted&quot; or
&quot;Synonym&quot;).
</p>
</li>
<li><p> nomenclaturalStatus: the nomenclatural status of the species name. This
information is not available for all species.
</p>
</li>
<li><p> acceptedName: If the species name is not accepted or incorrect, the
accepted name of the specie. If the species name is accepted and correct,
the same as input_name and Suggested_name.
</p>
</li>
<li><p> family: the family of the specie.
</p>
</li></ul>



<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data", package = "florabr")
spp &lt;- c("Butia cattarinensis", "Araucaria angustifolia")
check_names(data = bf_data, species = spp)
</code></pre>

<hr>
<h2 id='check_version'>Check if you have the latest version of Flora e Funga do Brasil data
available</h2><span id='topic+check_version'></span>

<h3>Description</h3>

<p>This function checks if you have the latest version of the Flora e Funga do
Brasil data available in a specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_version(data_dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_version_+3A_data_dir">data_dir</code></td>
<td>
<p>the directory where the data should be located.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A message informing whether you have the latest version of Flora e
Funga do Brasil available in the data_dir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Check if there is a version of Flora e Funga do Brasil data available in the
#current directory
check_version(data_dir = getwd())
</code></pre>

<hr>
<h2 id='filter_florabr'>Identify records outside natural ranges according to Flora e Funga do Brasil</h2><span id='topic+filter_florabr'></span>

<h3>Description</h3>

<p>This function removes or flags records outside of the species'
natural ranges according to information provided by the Flora e Funga do
Brasil database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_florabr(data, occ, species = "species", long = "x", lat = "y",
                      by_state = TRUE, buffer_state = 20, by_biome = TRUE,
                      buffer_biome = 20, by_endemism = TRUE,
                      buffer_brazil = 20, state_vect = NULL,
                      state_column = NULL, biome_vect = NULL,
                      biome_column = NULL, br_vect = NULL,
                      value = "flag&amp;clean", keep_columns = TRUE,
                      verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_florabr_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_occ">occ</code></td>
<td>
<p>(data.frame) a data.frame with the records of the species.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_species">species</code></td>
<td>
<p>(character) column name in occ with species names.
Default = &quot;species&quot;</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_long">long</code></td>
<td>
<p>(character) column name in occ with longitude data. Default = &quot;x&quot;</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_lat">lat</code></td>
<td>
<p>(character) column name in occ with latitude data. Default = &quot;y&quot;</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_by_state">by_state</code></td>
<td>
<p>(logical) filter records by state? Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_buffer_state">buffer_state</code></td>
<td>
<p>(numeric) buffer (in km) around the polygons of the
states of occurrence of the specie. Default = 20.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_by_biome">by_biome</code></td>
<td>
<p>(logical) filter records by biome? Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_buffer_biome">buffer_biome</code></td>
<td>
<p>(numeric) buffer (in km) around the polygons of the
biomes of occurrence of the specie. Default = 20.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_by_endemism">by_endemism</code></td>
<td>
<p>(logical) filter records by endemism? Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_buffer_brazil">buffer_brazil</code></td>
<td>
<p>(numeric) buffer (in km) around the polygons of the
brazil. Default = 20.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_state_vect">state_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian states. By
default, it uses the SpatVector provided by geobr::read_state(). It can be
another Spatvector, but the structure must be identical to
geobr::read_state().</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_state_column">state_column</code></td>
<td>
<p>(character) name of the column in state_vect containing
state abbreviations. Only use if biome_vect is not null.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_biome_vect">biome_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian biomes. By
default, it uses the SpatVector provided by geobr::read_biomes(). It can be
another SpatVector, but the structure must be identical to
geobr::read_biomes() with biome names in English.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_biome_column">biome_column</code></td>
<td>
<p>(character) name of the column in biome_vect containing
names of brazilian biomes (in English: &quot;Amazon&quot;, &quot;Atlantic_Forest&quot;,
&quot;Caatinga&quot;, &quot;Cerrado&quot;, &quot;Pampa&quot; and &quot;Pantanal&quot;. Only use if biome_vect is not
null.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_br_vect">br_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of brazil. By default, it uses the
SpatVector provided by geobr::read_state() after being aggregated/dissolved,</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_value">value</code></td>
<td>
<p>(character) Defines output values. See Value section.
Default = &quot;flag&amp;clean&quot;.</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_keep_columns">keep_columns</code></td>
<td>
<p>(logical) if TRUE, keep all the original columns of the
input occ. If False, keep only the columns species, long and lat.
Default = TRUE</p>
</td></tr>
<tr><td><code id="filter_florabr_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display species being filtered during
function execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If by_state = TRUE and/or by_biome = TRUE, the function takes polygons
representing the states and/or biomes with confirmed occurrences of the
specie, draws a buffer around the polygons, and tests if the records of the
species fall inside it.
If by_endemism = TRUE, the function checks if the species is endemic to
brazil. If it is endemic, the function tests if the records of the specie
fall inside a polygon representing the boundaries of brazil (with a buffer).
</p>


<h3>Value</h3>

<p>Depending on the 'value' argument. If value = &quot;flag&quot;, it returns the
same data.frame provided in data with additional columns indicating if the
record falls inside the natural range of the specie (TRUE) or outside
(FALSE).
If value = &quot;clean&quot;, it returns a data.frame with only the records that passes
all the tests (TRUE for all the filters). If value = &quot;flag&amp;clean&quot; (Default),
it returns a list with two data.frames: one with the flagged records and one
with the cleaned records.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
data("occurrences") #Load occurrences
pts &lt;- subset(occurrences, species == "Myrcia hatschbachii")
fd &lt;- filter_florabr(data = bf_data, occ = pts,
                    by_state = TRUE, buffer_state = 20,
                    by_biome = TRUE, buffer_biome = 20,
                    by_endemism = TRUE, buffer_brazil = 20,
                    state_vect = NULL,
                    biome_vect = NULL, br_vect = NULL,
                    value = "flag&amp;clean", keep_columns = TRUE,
                    verbose = FALSE)
</code></pre>

<hr>
<h2 id='get_attributes'>Get available attributes to filter species</h2><span id='topic+get_attributes'></span>

<h3>Description</h3>

<p>This function displays all the options available to filter species by its
characteristics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attributes(data, attribute)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_attributes_+3A_data">data</code></td>
<td>
<p>(data.frame) a data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function or a data.frame generated with the
<code><a href="#topic+select_species">select_species</a></code> function.</p>
</td></tr>
<tr><td><code id="get_attributes_+3A_attribute">attribute</code></td>
<td>
<p>(character) the type of characteristic. Accept more than one
option. See detail to see the options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attribute argument accepts the following options: kingdom, group,
subgroup, phylum, class, order, family, lifeform, habitat, vegetation,
origin, endemism, biome, states, taxonomicstatus or nomenclaturalstatus.
These options represent different characteristics of species that can be used
for filtering.
</p>


<h3>Value</h3>

<p>a list of data.frames with the available options to use in the
<code><a href="#topic+select_species">select_species</a></code> function.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
# Get available biomes, life forms and states to filter species
d &lt;- get_attributes(data = bf_data,
                    attribute = c("biome", "lifeform", "states"))
</code></pre>

<hr>
<h2 id='get_binomial'>Extract the binomial name (Genus + specific epithet + infraspecific epithet
(optional)) from a full Scientific Name</h2><span id='topic+get_binomial'></span>

<h3>Description</h3>

<p>Extract the binomial name (Genus + specific epithet + infraspecific epithet
(optional)) from a full Scientific Name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_binomial(species_names,
                   include_subspecies = TRUE,
                   include_variety = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_binomial_+3A_species_names">species_names</code></td>
<td>
<p>(character) Scientific names to be converted to
binomial names</p>
</td></tr>
<tr><td><code id="get_binomial_+3A_include_subspecies">include_subspecies</code></td>
<td>
<p>(logical) include subspecies? If TRUE (default),
the function extracts any infraspecific epithet after the pattern &quot;subsp.&quot;</p>
</td></tr>
<tr><td><code id="get_binomial_+3A_include_variety">include_variety</code></td>
<td>
<p>(logical) include subspecies? If TRUE (default),
the function extracts any infraspecific epithet after the pattern &quot;var.&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the binomial names (Genus + specific epithet).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spp &lt;- c("Araucaria angustifolia (Bertol.) Kuntze",
         "Araucaria angustifolia var. alba Reitz",
         "Butia catarinensis Noblick &amp; Lorenzi",
         "Butia eriospatha subsp. punctata",
         "Adesmia paranensis Burkart")
spp_new &lt;- get_binomial(species_names = spp,
                       include_subspecies = TRUE,
                       include_variety = TRUE)
spp_new

</code></pre>

<hr>
<h2 id='get_florabr'>Download the latest version of Flora e Funga do Brasil database</h2><span id='topic+get_florabr'></span>

<h3>Description</h3>

<p>This function downloads the latest or an older version of Flora e Funga do
Brasil database, merges the information into a single data.frame, and saves
this data.frame in the specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_florabr(output_dir, data_version = "latest",
                 solve_discrepancy = FALSE, overwrite = TRUE,
                 verbose = TRUE, remove_files = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_florabr_+3A_output_dir">output_dir</code></td>
<td>
<p>(character) a directory to save the data downloaded from
Flora e Funga do Brasil.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_data_version">data_version</code></td>
<td>
<p>(character) Version of the Flora e Funga do Brasil
database to download. Use &quot;latest&quot; to get the most recent version, updated weekly.
Alternatively, specify an older version (e.g., data_version = &quot;393.319&quot;).
Default value is &quot;latest&quot;.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_solve_discrepancy">solve_discrepancy</code></td>
<td>
<p>Resolve discrepancies between species and
subspecies/varieties  information. When set to TRUE, species
information is updated based on unique data from varieties and subspecies.
For example, if a subspecies occurs in a certain biome, it implies that the
species also occurs in that biome. Default = FALSE.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) If TRUE, data is overwritten. Default = TRUE.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display messages during function
execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
<tr><td><code id="get_florabr_+3A_remove_files">remove_files</code></td>
<td>
<p>(logical) Whether to remove the downloaded files used in
building the final dataset. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function downloads the latest version of the Flora e Funga do Brasil
database from the official source. It then merges the information into a
single data.frame, containing details on species, taxonomy, occurrence,
and other relevant data.
The merged data.frame is then saved as a file in the specified output
directory. The data is saved in a format that allows easy loading using the
<code><a href="#topic+load_florabr">load_florabr</a></code> function for further analysis in R.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Creating a folder in a temporary directory
#Replace 'file.path(tempdir(), "florabr")' by a path folder to be create in
#your computer
my_dir &lt;- file.path(file.path(tempdir(), "florabr"))
dir.create(my_dir)
#Download, merge and save data
get_florabr(output_dir = my_dir, data_version = "latest",
            solve_discrepancy = FALSE, overwrite = TRUE, verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_pam'>Get a presence-absence matrix</h2><span id='topic+get_pam'></span>

<h3>Description</h3>

<p>Get a presence-absence matrix of species based on its distribution
(states, biomes and vegetation types) according to Flora e Funga do Brasil.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pam(data, by_biome = TRUE, by_state = TRUE,
               by_vegetation = FALSE, remove_empty_sites = TRUE,
               return_richness_summary = TRUE,
               return_spatial_richness = TRUE,
               return_plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_pam_+3A_data">data</code></td>
<td>
<p>(data.frame) a data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function or generated by either
<code><a href="#topic+select_species">select_species</a></code> or <code><a href="#topic+subset_species">subset_species</a></code> functions</p>
</td></tr>
<tr><td><code id="get_pam_+3A_by_biome">by_biome</code></td>
<td>
<p>(logical) get occurrences by biome. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_by_state">by_state</code></td>
<td>
<p>(logical) get occurrences by State. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_by_vegetation">by_vegetation</code></td>
<td>
<p>(logical) get occurrences by vegetation type.
Default = FALSE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_remove_empty_sites">remove_empty_sites</code></td>
<td>
<p>(logical) remove empty sites (sites without any
species) from final presence-absence matrix. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_return_richness_summary">return_richness_summary</code></td>
<td>
<p>(logical) return a data.frame with the number
of species in each site. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_return_spatial_richness">return_spatial_richness</code></td>
<td>
<p>(logical) return a SpatVector with the number
of species in each site. Default = TRUE</p>
</td></tr>
<tr><td><code id="get_pam_+3A_return_plot">return_plot</code></td>
<td>
<p>(logical) plot map with the number of species in each
site.
Only works if return_spatial_richness = TRUE. Default = TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_richness_summary and/or return_spatial_richness is set to
TRUE, return a list with:
</p>

<ul>
<li><p> PAM: the presence-absence matrix (PAM)
</p>
</li>
<li><p> Richness_summary: a data.frame with the number of species in each site
</p>
</li>
<li><p> Spatial_richness: a SpatVector with the number of species in each site
(only by State and biome)
</p>
</li></ul>

<p>If return_richness_summary and return_spatial_richness is set to FALSE,
return a presence-absence matrix
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
#Select endemic and native species of trees with occurrence only in Amazon
am_trees &lt;- select_species(data = bf_data,
                          include_subspecies = FALSE,
                          include_variety = FALSE,
                          kingdom = "Plantae",
                          group = "All", subgroup = "All",
                          family = "All", genus = "All",
                          lifeForm = "Tree", filter_lifeForm = "only",
                          habitat = "All", filter_habitat = "in",
                          biome = "Amazon",
                          filter_biome = "only",
                          state = "All", filter_state = "and",
                          vegetation = "All",
                          filter_vegetation = "in",
                          endemism = "Endemic", origin = "Native",
                          taxonomicStatus = "Accepted",
                          nomenclaturalStatus = "All")
#Get presence-absence matrix
pam_am &lt;- get_pam(data = am_trees, by_biome = TRUE, by_state = TRUE,
                 by_vegetation = FALSE, remove_empty_sites = TRUE,
                 return_richness_summary = TRUE,
                 return_spatial_richness = TRUE,
                 return_plot = TRUE)

</code></pre>

<hr>
<h2 id='get_spat_occ'>Get Spatial polygons (SpatVectors) of species based on its distribution
(states and biomes) according to Flora e Funga do Brasil</h2><span id='topic+get_spat_occ'></span>

<h3>Description</h3>

<p>Get Spatial polygons (SpatVectors) of species based on its distribution
(states and biomes) according to Flora e Funga do Brasil
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_spat_occ(
  data,
  species,
  state = TRUE,
  biome = TRUE,
  intersection = TRUE,
  state_vect = NULL,
  state_column = NULL,
  biome_vect = NULL,
  biome_column = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_spat_occ_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_species">species</code></td>
<td>
<p>(character) one or more species names (only genus and
specific epithet, eg. &quot;Araucaria angustifolia&quot;)</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_state">state</code></td>
<td>
<p>(logical) get SpatVector of states with occurrence of the
species? Default = TRUE</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_biome">biome</code></td>
<td>
<p>(logical) get SpatVector of biomes with occurrence of the
species? Default = TRUE</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_intersection">intersection</code></td>
<td>
<p>(character) get a Spatvector representing the
intersection between states and biomes with occurrence of the specie?
To use intersection = TRUE, you must define state = TRUE and biome = TRUE&quot;.
Default = TRUE</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_state_vect">state_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian states. By
default, it uses the SpatVector provided by geobr::read_state(). It can be
another Spatvector, but the structure must be identical to
geobr::read_state().</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_state_column">state_column</code></td>
<td>
<p>(character) name of the column in state_vect containing
state abbreviations. Only use if biome_vect is not null.</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_biome_vect">biome_vect</code></td>
<td>
<p>(SpatVector) a SpatVector of the Brazilian biomes. By
default, it uses the SpatVector provided by geobr::read_biomes(). It can be
another SpatVector, but the structure must be identical to
geobr::read_biomes().</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_biome_column">biome_column</code></td>
<td>
<p>(character) name of the column in biome_vect containing
names of brazilian biomes (in English: &quot;Amazon&quot;, &quot;Atlantic_Forest&quot;,
&quot;Caatinga&quot;, &quot;Cerrado&quot;, &quot;Pampa&quot; and &quot;Pantanal&quot;. Only use if biome_vect is not
null.</p>
</td></tr>
<tr><td><code id="get_spat_occ_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display species being filtered during
function execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with SpatVectors of states and/or biomes and/or Intersections
for each specie.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
data("bf_data") #Load Flora e Funga do Brasil data
spp &lt;- c("Araucaria angustifolia", "Adesmia paranensis") #Example species
#Get states, biomes and intersection states-biomes of species
spp_spt &lt;- get_spat_occ(data = bf_data, species = spp, state = TRUE,
                       biome = TRUE, intersection = TRUE, state_vect = NULL,
                       biome_vect = NULL, verbose = TRUE)


#Plot states of occurrence of Araucaria angustifolia
plot(spp_spt[[1]]$states, main = names(spp_spt)[[1]])
#Plot biomes of occurrence of Araucaria angustifolia
plot(spp_spt[[2]]$biomes, main = names(spp_spt)[[2]])
#Plot intersection between states and biomes of occurrence of
#Araucaria angustifolia
plot(spp_spt[[1]]$states_biomes)

</code></pre>

<hr>
<h2 id='get_synonym'>Retrieve synonyms for species</h2><span id='topic+get_synonym'></span>

<h3>Description</h3>

<p>Retrieve synonyms for species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_synonym(data, species,
                   include_subspecies = TRUE, include_variety = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_synonym_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function</p>
</td></tr>
<tr><td><code id="get_synonym_+3A_species">species</code></td>
<td>
<p>(character) names of the species</p>
</td></tr>
<tr><td><code id="get_synonym_+3A_include_subspecies">include_subspecies</code></td>
<td>
<p>(logical) include subspecies that are synonyms of
the species? Default = TRUE</p>
</td></tr>
<tr><td><code id="get_synonym_+3A_include_variety">include_variety</code></td>
<td>
<p>(logical) include varieties that are synonyms of the
species? Default = TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing unique synonyms of the specified species
along with relevant information on taxonomic and nomenclatural statuses.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
#Species to extract synonyms
spp &lt;- c("Araucaria angustifolia", "Adesmia paranensis")
spp_synonyms &lt;- get_synonym(data = bf_data, species = spp,
                            include_subspecies = TRUE,
                            include_variety = TRUE)
spp_synonyms

</code></pre>

<hr>
<h2 id='load_florabr'>Load Flora e Funga do Brasil database</h2><span id='topic+load_florabr'></span>

<h3>Description</h3>

<p>Load Flora e Funga do Brasil database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_florabr(data_dir, data_version = "Latest_available",
                    type = "short", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_florabr_+3A_data_dir">data_dir</code></td>
<td>
<p>(character) the same directory used to save the data
downloaded from Flora e Funga do Brasil using the <a href="#topic+get_florabr">get_florabr</a> function.</p>
</td></tr>
<tr><td><code id="load_florabr_+3A_data_version">data_version</code></td>
<td>
<p>(character) the version of Flora e Funga do Brasil
database to be loaded. It can be &quot;Latest_available&quot;, which will load the
latest version available; or another specified version, for example &quot;393.364&quot;.
Default = &quot;Latest_available&quot;.</p>
</td></tr>
<tr><td><code id="load_florabr_+3A_type">type</code></td>
<td>
<p>(character) it determines the number of columns that will be
loaded. It can be &quot;short&quot; or &quot;complete&quot;. Default = &quot;short&quot;. See details.</p>
</td></tr>
<tr><td><code id="load_florabr_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether to display messages during function
execution. Set to TRUE to enable display, or FALSE to run silently.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter type accepts two arguments. If type = short, it will load a
data.frame with the 20 columns needed to run the other functions of the
package: species, scientificName, acceptedName, kingdom, Group, Subgroup,
family, genus, lifeForm, habitat, Biome, States, vegetationType, Origin,
Endemism, taxonomicStatus, nomenclaturalStatus, vernacularName, taxonRank,
and id
If type = complete, it will load a data.frame with all 39 variables available
in Flora e Funga do Brasil database.
</p>


<h3>Value</h3>

<p>A data.frame with the specified version (Default is the latest
available) of the Flora e Funga do Brasil database. This data.frame is
necessary to run most of the functions of the package.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Creating a folder in a temporary directory
#Replace 'file.path(tempdir(), "florabr")' by a path folder to be create in
#your computer
my_dir &lt;- file.path(file.path(tempdir(), "florabr"))
dir.create(my_dir)
#Download, merge and save data
get_florabr(output_dir = my_dir, data_version = "latest", overwrite = TRUE,
            verbose = TRUE)
#Load data
df &lt;- load_florabr(data_dir = my_dir, data_version = "Latest_available",
type = "short")

## End(Not run)
</code></pre>

<hr>
<h2 id='occurrences'>Records of plant species</h2><span id='topic+occurrences'></span>

<h3>Description</h3>

<p>A dataset containing records of 7 plant species downloaded from GBIF. The
records were obtained with <code>plantR::rgbif2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(occurrences)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 1521 rows and 3 variables:
</p>

<dl>
<dt>species</dt><dd><p>Species names (Araucaria angustifolia, Abatia americana,
Passiflora edmundoi, Myrcia hatschbachii, Serjania pernambucensis, Inga
virescens, and Solanum restingae)</p>
</dd>
<dt>x</dt><dd><p>Longitude</p>
</dd>
<dt>y</dt><dd><p>Latitude</p>
</dd>
</dl>



<h3>References</h3>

<p>GBIF, 2024. florabr R package: Records of plant species. https://doi.org/10.15468/DD.QPGEB7
</p>

<hr>
<h2 id='select_by_vernacular'>Search for taxa using vernacular names</h2><span id='topic+select_by_vernacular'></span>

<h3>Description</h3>

<p>Search for taxa using vernacular names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_by_vernacular(data, names, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_by_vernacular_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function or generated with the function
<code><a href="#topic+select_species">select_species</a></code>.</p>
</td></tr>
<tr><td><code id="select_by_vernacular_+3A_names">names</code></td>
<td>
<p>(character) vernacular name (&quot;Nome comum&quot;) of the species to be
searched</p>
</td></tr>
<tr><td><code id="select_by_vernacular_+3A_exact">exact</code></td>
<td>
<p>(logic) if TRUE, the function will search only for exact
matches. For example, if names = &quot;pinheiro&quot; and exact = TRUE, the function
will return only the species popularly known as &quot;pinheiro&quot;. On the other
hand, if names = &quot;pinheiro&quot; and exact = FALSE, the function will return
other results as &quot;pinheiro-do-parana&quot;. Default = FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the species with vernacular names that match the
input names
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>
<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
#Search for species whose vernacular name is 'pinheiro'
pinheiro_exact &lt;- select_by_vernacular(data = bf_data,
                                       names = "pinheiro",
                                       exact = TRUE)
pinheiro_exact
#Search for species whose vernacular name is 'pinheiro', allowing non-exact
#matches
pinheiro_not_exact &lt;- select_by_vernacular(data = bf_data,
                                          names = "pinheiro",
                                          exact = FALSE)
head(pinheiro_not_exact)

</code></pre>

<hr>
<h2 id='select_species'>Selection of species based on its characteristics and distribution</h2><span id='topic+select_species'></span>

<h3>Description</h3>

<p>select_species allows filter species based on its
characteristics and distribution available in Flora e Funga do Brasil
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_species(data,
                      include_subspecies = FALSE, include_variety = FALSE,
                      kingdom = "Plantae", group = "All", subgroup = "All",
                      phylum = "All", class ="All", order = "All",
                      family = "All", genus = "All",
                      lifeForm = "All", filter_lifeForm = "in",
                      habitat = "All", filter_habitat = "in",
                      biome = "All", filter_biome = "in",
                      state = "All", filter_state = "in",
                      vegetation = "All", filter_vegetation = "in",
                      endemism = "All", origin = "All",
                      taxonomicStatus = "Accepted",
                      nomenclaturalStatus = "All")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_species_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="select_species_+3A_include_subspecies">include_subspecies</code></td>
<td>
<p>(logical) include subspecies?
Default = FALSE</p>
</td></tr>
<tr><td><code id="select_species_+3A_include_variety">include_variety</code></td>
<td>
<p>(logical) include varieties of the species?
Default = FALSE</p>
</td></tr>
<tr><td><code id="select_species_+3A_kingdom">kingdom</code></td>
<td>
<p>(character) The kingdom for filtering the dataset. It can be
&quot;Plantae&quot; or &quot;Fungi&quot;. Default = &quot;Plantae&quot;. To include both,
use c(&quot;Plantae&quot;, &quot;Fungi&quot;)</p>
</td></tr>
<tr><td><code id="select_species_+3A_group">group</code></td>
<td>
<p>(character) The groups for filtering the datasets. It can be
&quot;Fungi&quot;, &quot;Angiosperms&quot;, &quot;Gymnosperms&quot;, &quot;Ferns and Lycophytes&quot;,
&quot;Bryophytes&quot; and &quot;Algae&quot;. To use more than one group, put the available
items in a vector, for example: group = c(Angiosperms&quot;, &quot;Gymnosperms&quot;).
Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_subgroup">subgroup</code></td>
<td>
<p>(character) The subgroups for filtering the dataset.
Only available if the group is &quot;Fungi&quot; or &quot;Bryophytes&quot;. For Fungi, it can be
&quot;stricto sensu&quot; or &quot;lato sensu&quot;. For Bryophytes, it can be &quot;Mosses&quot;,
&quot;Hornworts&quot; and &quot;Liverworts&quot; . To use more than one group, put the available
items in a vector, for example: subgroup = c(&quot;Mosses&quot;, &quot;Hornworts&quot;).
Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_phylum">phylum</code></td>
<td>
<p>(character) The phyla for filtering the dataset. It can
be included more than one phylum. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_class">class</code></td>
<td>
<p>(character) The classes for filtering the dataset. It can
be included more than one class. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_order">order</code></td>
<td>
<p>(character) The orders for filtering the dataset. It can
be included more than one order. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_family">family</code></td>
<td>
<p>(character) The families for filtering the dataset. It can
be included more than one family. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_genus">genus</code></td>
<td>
<p>(character) The genus for filtering the dataset. It can
be included more than one genus. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_lifeform">lifeForm</code></td>
<td>
<p>(character) The life forms for filtering the dataset. It can
be included more than one lifeForm. Default = &quot;All&quot;</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_lifeform">filter_lifeForm</code></td>
<td>
<p>(character) The type of filtering for life forms. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_habitat">habitat</code></td>
<td>
<p>(character) The life habitat for filtering the dataset. It can
be included more than one habitat. Default = &quot;All&quot;</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_habitat">filter_habitat</code></td>
<td>
<p>(character) The type of filtering for habitat. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_biome">biome</code></td>
<td>
<p>(character) The biomes for filtering the dataset. It can
be included more than one biome. Default = &quot;All&quot;</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_biome">filter_biome</code></td>
<td>
<p>(character) The type of filtering for biome. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_state">state</code></td>
<td>
<p>(character) The states for filtering the dataset. It can
be included more than one state. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_state">filter_state</code></td>
<td>
<p>(character) The type of filtering for state. It
can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See Details for more about this
argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_vegetation">vegetation</code></td>
<td>
<p>(character) The vegetation types for filtering the
dataset. It can be included more than one vegetation type. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_filter_vegetation">filter_vegetation</code></td>
<td>
<p>(character) The type of filtering for
vegetation type. It can be &quot;in&quot;, &quot;only&quot;, &quot;not_in&quot; and &quot;and&quot;. See details for
more about this argument.</p>
</td></tr>
<tr><td><code id="select_species_+3A_endemism">endemism</code></td>
<td>
<p>(character) The endemism (endemic or non-endemic to Brazil)
for filtering the dataset. It can be &quot;All&quot;, &quot;Endemic&quot; or &quot;Non-endemic&quot;.
Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_origin">origin</code></td>
<td>
<p>(character) The origin for filtering the dataset. It can
be &quot;All&quot;, &quot;Native&quot;, &quot;Cultivated&quot; and &quot;Naturalized&quot;. Default = &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_taxonomicstatus">taxonomicStatus</code></td>
<td>
<p>(character) The taxonomic status for filtering the
dataset. It can be &quot;All&quot;, &quot;Accepted&quot; or &quot;Synonym&quot;. Default = &quot;Accepted&quot;.</p>
</td></tr>
<tr><td><code id="select_species_+3A_nomenclaturalstatus">nomenclaturalStatus</code></td>
<td>
<p>(character) The nomenclatural status for
filtering the dataset. Default = &quot;Accepted&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's possible to choose 4 ways to filter by lifeForm, by habitat,
by biome, by state and by vegetation type:
&quot;in&quot;: selects species that have any occurrence of the determined values. It
allows multiple matches. For example, if biome = c(&quot;Amazon&quot;, Cerrado&quot; and
filter_biome = &quot;in&quot;, it will select all species that occur in the Amazon and
Cerrado, some of which may also occur in other biomes.
</p>
<p>&quot;only&quot;: selects species that have only occurrence of the determined values.
It allows only single matches. For example, if biome = c(&quot;Amazon&quot;, &quot;Cerrado&quot;)
and filter_biome = &quot;only&quot;, it will select all species that occur exclusively
in both the Amazon and Cerrado biomes, without any occurrences in other
biomes.
</p>
<p>&quot;not_in&quot;: selects species that don't have occurrence of the determined
values. It allows single and multiple matches. For example,
if biome = c(&quot;Amazon&quot;, &quot;Cerrado&quot;) and filter_biome = &quot;not_in&quot;, it will select
all species without occurrences in the Amazon and Cerrado biomes.
</p>
<p>&quot;and&quot;: selects species that have occurrence in all determined values. It
allows single and multiple matches. For example,
if biome = c(&quot;Amazon&quot;, &quot;Cerrado&quot;) and filter_biome = &quot;and&quot;, it will select
all species that occurs only in both the Amazon and Cerrado biomes,
including species that occurs in other biomes too.
</p>
<p>To get the complete list of arguments available for family, genus, lifeForm,
habitat, biome, state, and nomenclaturalStatus, use the function
<code><a href="#topic+get_attributes">get_attributes</a></code>
</p>


<h3>Value</h3>

<p>A new dataframe with the filtered species.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
#'Select endemic and native species of trees with disjunct occurrence in
# Atlantic Forest and Amazon
am_af_only &lt;- select_species(data = bf_data,
                             include_subspecies = FALSE,
                             include_variety = FALSE,
                             kingdom = "Plantae",
                             group = "All", subgroup = "All",
                             phylum = "All", class ="All", order = "All",
                             family = "All", genus = "All",
                             lifeForm = "Tree", filter_lifeForm = "only",
                             habitat = "All", filter_habitat = "in",
                             biome = c("Atlantic_Forest","Amazon"),
                             filter_biome = "only",
                             state = "All", filter_state = "and",
                             vegetation = "All",
                             filter_vegetation = "in",
                             endemism = "Endemic", origin = "Native",
                             taxonomicStatus = "All",
                             nomenclaturalStatus = "All")
</code></pre>

<hr>
<h2 id='solve_discrepancies'>Resolve discrepancies between species and subspecies/varieties information</h2><span id='topic+solve_discrepancies'></span>

<h3>Description</h3>

<p>Resolve discrepancies between species and subspecies/varieties information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_discrepancies(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solve_discrepancies_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the original dataset, discrepancies may exist between species and
subspecies/varieties information. An example of a discrepancy is when a
species occurs only in one biome (e.g., Amazon), but a subspecies or variety
of the same species occurs in another biome (e.g., Cerrado). This function
rectifies such discrepancies by considering distribution (states, biomes,
and vegetation), life form, and habitat. For instance, if a subspecies is
recorded in a specific biome, it implies that the species also occurs in that
biome.
</p>


<h3>Value</h3>

<p>a data.frame with the discrepancies solved
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
#Check if discrepancies were solved in the dataset
attr(bf_data, "solve_discrepancies")
#Solve discrepancies
bf_solved &lt;- solve_discrepancies(bf_data)
#Check if discrepancies were solved in the dataset
attr(bf_solved, "solve_discrepancies")
</code></pre>

<hr>
<h2 id='states'>SpatVector of the federal states of Brazil</h2><span id='topic+states'></span>

<h3>Description</h3>

<p>A simplified and packed SpatVector of the polygons of the federal states of
Brazil. The spatial data was originally obtained from
<code>geobr::read_state</code>. Borders have been simplified by removing vertices
of borders using <code>terra::simplifyGeom</code>. It's necessary unpack the
Spatvectos using <code>terra::unwrap</code>
</p>
<p>@usage data(states)
states &lt;- terra::unwrap(states)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>states
</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> with 27 geometries and 3 attributes:
</p>

<dl>
<dt>abbrev_state</dt><dd><p>State acronym</p>
</dd>
<dt>name_state</dt><dd><p>State's full name</p>
</dd>
<dt>name_region</dt><dd><p>The region to which the state belongs</p>
</dd>
</dl>


<hr>
<h2 id='subset_species'>Extract a subset of species from Flora e Funga do Brasil database</h2><span id='topic+subset_species'></span>

<h3>Description</h3>

<p>Returns a data.frame with a subset of species from Flora e Funga do Brasil
database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_species(data, species,
                      include_subspecies = FALSE,
                      include_variety = FALSE,
                      kingdom = "Plantae")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_species_+3A_data">data</code></td>
<td>
<p>(data.frame) the data.frame imported with the
<code><a href="#topic+load_florabr">load_florabr</a></code> function.</p>
</td></tr>
<tr><td><code id="subset_species_+3A_species">species</code></td>
<td>
<p>(character) names of the species to be extracted from
Flora e Funga do Brasil database.</p>
</td></tr>
<tr><td><code id="subset_species_+3A_include_subspecies">include_subspecies</code></td>
<td>
<p>(logical) include subspecies?
Default = FALSE</p>
</td></tr>
<tr><td><code id="subset_species_+3A_include_variety">include_variety</code></td>
<td>
<p>(logical) include varieties of the species?
Default = FALSE</p>
</td></tr>
<tr><td><code id="subset_species_+3A_kingdom">kingdom</code></td>
<td>
<p>(character) The kingdom for filtering the dataset. It can be
&quot;Plantae&quot; or &quot;Fungi&quot;. Default = &quot;Plantae&quot;. To include both,
use c(&quot;Plantae&quot;, &quot;Fungi&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the selected species.
</p>


<h3>References</h3>

<p>Flora e Funga do Brasil. Jardim Botânico do Rio de Janeiro. Available at:
http://floradobrasil.jbrj.gov.br/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bf_data") #Load Flora e Funga do Brasil data
#Species to extract from database
spp &lt;- c("Araucaria angustifolia", "Adesmia paranensis")
spp_bf &lt;- subset_species(data = bf_data, species = spp,
                      include_subspecies = FALSE,
                      include_variety = FALSE)
spp_bf
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
