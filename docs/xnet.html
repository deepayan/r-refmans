<!DOCTYPE html><html lang="en"><head><title>Help for package xnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#xnet-package'><p>Two-step kernel ridge regression for network analysis</p></a></li>
<li><a href='#alpha'><p>Getters for linearFilter objects</p></a></li>
<li><a href='#as_tuned'><p>convert tskrr models</p></a></li>
<li><a href='#create_grid'><p>Create a grid of values for tuning tskrr</p></a></li>
<li><a href='#dim+2Ctskrr-method'><p>Get the dimensions of a tskrr object</p></a></li>
<li><a href='#drugTargetInteraction'><p>drug target interactions for neural receptors</p></a></li>
<li><a href='#eigen2hat'><p>Calculate the hat matrix from an eigen decomposition</p></a></li>
<li><a href='#fitted.tskrr'><p>extract the predictions</p></a></li>
<li><a href='#get_loo_fun'><p>Retrieve a loo function</p></a></li>
<li><a href='#has_imputed_values'><p>Getters for tskrrImpute objects</p></a></li>
<li><a href='#hat'><p>Return the hat matrix of a tskrr model</p></a></li>
<li><a href='#impute_tskrr'><p>Impute missing values in a label matrix</p></a></li>
<li><a href='#impute_tskrr.fit'><p>Impute values based on a two-step kernel ridge regression</p></a></li>
<li><a href='#is_symmetric'><p>Test symmetry of a matrix</p></a></li>
<li><a href='#is_tuned'><p>Getters for tskrrTune objects</p></a></li>
<li><a href='#labels.tskrr'><p>Extract labels from a tskrr object</p></a></li>
<li><a href='#linear_filter'><p>Fit a linear filter over a label matrix</p></a></li>
<li><a href='#linearFilter-class'><p>Class linearFilter</p></a></li>
<li><a href='#loo'><p>Leave-one-out cross-validation for tskrr</p></a></li>
<li><a href='#loo_internal'><p>Leave-one-out cross-validation for two-step kernel ridge regression</p></a></li>
<li><a href='#loss'><p>Calculate or extract the loss of a tskrr model</p></a></li>
<li><a href='#loss_functions'><p>loss functions</p></a></li>
<li><a href='#match_labels'><p>Reorder the label matrix</p></a></li>
<li><a href='#permtest'><p>Calculate the relative importance of the edges</p></a></li>
<li><a href='#permtest-class'><p>Class permtest</p></a></li>
<li><a href='#permutations'><p>Getters for permtest objects</p></a></li>
<li><a href='#plot_grid'><p>Plot the grid of a tuned tskrr model</p></a></li>
<li><a href='#plot.tskrr'><p>plot a heatmap of the predictions from a tskrr model</p></a></li>
<li><a href='#predict.tskrr'><p>predict method for tskrr fits</p></a></li>
<li><a href='#proteinInteraction'><p>Protein interaction for yeast</p></a></li>
<li><a href='#residuals'><p>calculate residuals from a tskrr model</p></a></li>
<li><a href='#response+2Ctskrr-method'><p>Getters for tskrr objects</p></a></li>
<li><a href='#test_symmetry'><p>test the symmetry of a matrix</p></a></li>
<li><a href='#tskrr'><p>Fitting a two step kernel ridge regression</p></a></li>
<li><a href='#tskrr-class'><p>Class tskrr</p></a></li>
<li><a href='#tskrr.fit'><p>Carry out a two-step kernel ridge regression</p></a></li>
<li><a href='#tskrrHeterogeneous-class'><p>Class tskrrHeterogeneous</p></a></li>
<li><a href='#tskrrHomogeneous-class'><p>Class tskrrHomogeneous</p></a></li>
<li><a href='#tskrrImpute-class'><p>Class tskrrImpute</p></a></li>
<li><a href='#tskrrImputeHeterogeneous-class'><p>Class tskrrImputeHeterogeneous</p></a></li>
<li><a href='#tskrrImputeHomogeneous-class'><p>Class tskrrImputeHomogeneous</p></a></li>
<li><a href='#tskrrTune-class'><p>Class tskrrTune</p></a></li>
<li><a href='#tskrrTuneHeterogeneous-class'><p>Class tskrrTuneHeterogeneous</p></a></li>
<li><a href='#tskrrTuneHomogeneous-class'><p>Class tskrrTuneHomogeneous</p></a></li>
<li><a href='#tune'><p>tune the lambda parameters for a tskrr</p></a></li>
<li><a href='#update'><p>Update a tskrr object with a new lambda</p></a></li>
<li><a href='#valid_dimensions'><p>Functions to check matrices</p></a></li>
<li><a href='#valid_labels'><p>Test the correctness of the labels.</p></a></li>
<li><a href='#weights+2CtskrrHeterogeneous-method'><p>Extract weights from a tskrr model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Two-Step Kernel Ridge Regression for Network Predictions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit a two-step kernel ridge regression model for
        predicting edges in networks, and carry out cross-validation
        using shortcuts for swift and accurate performance assessment
        (Stock et al, 2018 &lt;<a href="https://doi.org/10.1093%2Fbib%2Fbby095">doi:10.1093/bib/bby095</a>&gt; ).</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-03</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CenterForStatistics-UGent/xnet/issues">https://github.com/CenterForStatistics-UGent/xnet/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CenterForStatistics-UGent/xnet">https://github.com/CenterForStatistics-UGent/xnet</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, graphics, stats, grDevices</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, ChemmineR, covr, fmcsR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Class_linearFilter.R' 'all_generics.R' 'Class_permtest.R'
'Class_tskrr.R' 'Class_tskrrHeterogeneous.R'
'Class_tskrrHomogeneous.R' 'Class_tskrrImpute.R'
'Class_tskrrImputeHeterogeneous.R'
'Class_tskrrImputeHomogeneous.R' 'Class_tskrrTune.R'
'Class_tskrrTuneHeterogeneous.R' 'Class_tskrrTuneHomogeneous.R'
'as_tuned.R' 'create_grid.R' 'data_drugtarget.R'
'data_proteinInteraction.R' 'dim.R' 'eigen2hat.R' 'fitted.R'
'get_loo_fun.R' 'getlooInternal.R' 'getters_linearFilter.R'
'getters_permtest.R' 'getters_tskrr.R' 'getters_tskrrImpute.R'
'getters_tskrrTune.R' 'hat.R' 'impute_tskrr.R'
'impute_tskrr.fit.R' 'internal_helpers.R' 'is_symmetric.R'
'labels.R' 'linear_filter.R' 'loo.R' 'looInternal.R' 'loss.R'
'loss_functions.R' 'match_labels.R' 'permtest.R' 'plot.tskrr.R'
'plot_grid.R' 'predict.R' 'prepare_lambdas.R' 'residuals.R'
'test_input.R' 'test_symmetry.R' 'tskrr.R' 'tskrr.fit.R'
'tune.R' 'update.R' 'valid_dimensions.R' 'valid_labels.R'
'weights.R' 'xnet-package.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-03 16:55:53 UTC; Joris</td>
</tr>
<tr>
<td>Author:</td>
<td>Joris Meys [cre, aut],
  Michiel Stock [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joris Meys &lt;Joris.Meys@UGent.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-03 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='xnet-package'>Two-step kernel ridge regression for network analysis</h2><span id='topic+xnet'></span><span id='topic+xnet-package'></span>

<h3>Description</h3>

<p>This package implements the two-step kernel ridge regression model, a
supervised network prediction method that can be used for all kinds of network
analyses. Examples are protein-protein interaction, foodwebs, ...
</p>


<h3>Author(s)</h3>

<p>Joris Meys and Michiel Stock
</p>


<h3>See Also</h3>

<p>Send your bug reports to:
</p>
<p><a href="https://github.com/CenterForStatistics-UGent/xnet/issues">https://github.com/CenterForStatistics-UGent/xnet/issues</a>
</p>
<p>More background in the paper by Stock et al, 2018:
</p>
<p><a href="http://doi.org/10.1093/bib/bby095">http://doi.org/10.1093/bib/bby095</a>
</p>

<hr>
<h2 id='alpha'>Getters for linearFilter objects</h2><span id='topic+alpha'></span><span id='topic+na_removed'></span><span id='topic+getters_linearFilter'></span><span id='topic+mean.linearFilter'></span><span id='topic+mean+2ClinearFilter-method'></span><span id='topic+colMeans+2ClinearFilter-method'></span><span id='topic+rowMeans+2ClinearFilter-method'></span><span id='topic+alpha+2ClinearFilter-method'></span><span id='topic+na_removed+2ClinearFilter-method'></span>

<h3>Description</h3>

<p>These functions allow you to extract slots from objects of the
class <code><a href="#topic+linearFilter">linearFilter</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha(x)

na_removed(x)

## S3 method for class 'linearFilter'
mean(x, ...)

## S4 method for signature 'linearFilter'
mean(x, ...)

## S4 method for signature 'linearFilter'
colMeans(x)

## S4 method for signature 'linearFilter'
rowMeans(x)

## S4 method for signature 'linearFilter'
alpha(x)

## S4 method for signature 'linearFilter'
na_removed(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha_+3A_x">x</code></td>
<td>
<p>a <code>linearFilter</code> object</p>
</td></tr>
<tr><td><code id="alpha_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>mean</code>: the mean of the original matrix
</p>
<p>for <code>colMeans</code>: a numeric vector with the column means
</p>
<p>for <code>rowMeans</code>: a numeric vector with the row means
</p>
<p>for <code>alpha</code>: a numeric vector of length 4 with the alpha
values.
</p>
<p>for <code>na_removed</code>: a logical value indicating whether
missing values were removed prior to the fitting of the filter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)
lf &lt;- linear_filter(drugTargetInteraction, alpha = 0.25)
alpha(lf)
mean(lf)
colMeans(lf)
na_removed(lf)

</code></pre>

<hr>
<h2 id='as_tuned'>convert tskrr models</h2><span id='topic+as_tuned'></span><span id='topic+as_tskrr'></span><span id='topic+as_tuned+2CtskrrHomogeneous-method'></span><span id='topic+as_tuned+2CtskrrHeterogeneous-method'></span><span id='topic+as_tskrr+2CtskrrTune-method'></span><span id='topic+as_tskrr+2CtskrrImpute-method'></span><span id='topic+as_tskrr+2Ctskrr-method'></span>

<h3>Description</h3>

<p>These functions allow converting models that inherit from the
<code><a href="#topic+tskrr-class">tskrr</a></code> and
<code><a href="#topic+tskrrTune-class">tskrrTune</a></code> class into each other,
keeping track of whether the model is homogeneous or heterogeneous.
The dots argument allows specifying values for possible extra slots
when converting from <code>tskrr</code> to <code>tskrrTune</code>.
More information on these slots can be found
on the help page of <code><a href="#topic+tskrrTune-class">tskrrTune</a></code>.
<strong>These functions are not exported.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tuned(x, ...)

as_tskrr(x, ...)

## S4 method for signature 'tskrrHomogeneous'
as_tuned(x, ...)

## S4 method for signature 'tskrrHeterogeneous'
as_tuned(x, ...)

## S4 method for signature 'tskrrTune'
as_tskrr(x)

## S4 method for signature 'tskrrImpute'
as_tskrr(x)

## S4 method for signature 'tskrr'
as_tskrr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tuned_+3A_x">x</code></td>
<td>
<p>a model of class <code><a href="#topic+tskrr-class">tskrr</a></code></p>
</td></tr>
<tr><td><code id="as_tuned_+3A_...">...</code></td>
<td>
<p>values for the extra slots defined by
the class <code><a href="#topic+tskrrTune-class">tskrrTune</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>as_tuned</code>:
a <code><a href="#topic+tskrrTune-class">tskrrTune</a></code> object of
the proper class (homogeneous or heterogeneous)
</p>
<p>For <code>as_tskrr</code>: an object of class
<code><a href="#topic+tskrrHomogeneous-class">tskrrHomogeneous</a></code> or
<code><a href="#topic+tskrrHeterogeneous-class">tskrrHeterogeneous</a></code> depending
on whether the original object was homogeneous or heterogeneous.
</p>


<h3><b>Warning</b></h3>

<p>This functions do NOT tune a model. they are used internally to
make the connection between both types in the methods.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+tune">tune</a></code> for actually tuning a model.
</p>
</li>
<li> <p><code><a href="#topic+tskrrTune-class">tskrrTune</a></code> for
names and possible values of the slots passed through
...
</p>
</li></ul>


<hr>
<h2 id='create_grid'>Create a grid of values for tuning tskrr</h2><span id='topic+create_grid'></span>

<h3>Description</h3>

<p>This function creates a grid of values for
tuning a <code><a href="#topic+tskrr">tskrr</a></code> model. The grid is equally spaced on
a logarithmic scale. Normally it's not needed to call this method
directly, it's usually called from <code><a href="#topic+tune">tune</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_grid(lim = c(1e-04, 10000), ngrid = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_grid_+3A_lim">lim</code></td>
<td>
<p>a numeric vector with 2 values giving the lower and upper limit
for the grid.</p>
</td></tr>
<tr><td><code id="create_grid_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of values that have to be produced. If this
number is not integer, it is truncated. The value should be 2 or
larger.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lim</code> argument sets the boundaries of the domain in which
the lambdas are sought. The lambda values at which the function is
evaluated, are calculated as:
</p>
<p><code>exp(seq(log(1e-4), log(1e4), length.out = ngrid))</code>
</p>


<h3>Value</h3>

<p>a numeric vector with values evenly spaced on a
logarithmic scale.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tune">tune</a></code> for tuning a tskrr model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_grid(lim = c(1e-4, 1), ngrid = 5)

</code></pre>

<hr>
<h2 id='dim+2Ctskrr-method'>Get the dimensions of a tskrr object</h2><span id='topic+dim+2Ctskrr-method'></span><span id='topic+dim.tskrr'></span>

<h3>Description</h3>

<p>These functions allow you to extract the dimensions of a tskrr
object. These dimensions are essentially the dimensions of the
label matrix y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tskrr'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim+2B2Ctskrr-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+tskrr-class">tskrr</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with two values indicating the number of rows
and the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)
mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)
dim(mod)
nrow(mod)
ncol(mod)

</code></pre>

<hr>
<h2 id='drugTargetInteraction'>drug target interactions for neural receptors</h2><span id='topic+drugTargetInteraction'></span><span id='topic+drugtarget'></span><span id='topic+drugSim'></span><span id='topic+targetSim'></span>

<h3>Description</h3>

<p>A dataset for examining the interaction between 54 drugs and 26
neural receptors. It consists of three different matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drugTargetInteraction
</code></pre>


<h3>Format</h3>


<ul>
<li><p> for drugTargetInteraction: a numeric matrix of 26 rows by
54 columns.
</p>
</li>
<li><p> For drugSim: a numeric square matrix with 54 rows/columns.
</p>
</li>
<li><p> For targetSim: a numeric square matrix with 26 rows/columns.
</p>
</li></ul>


<h3>Details</h3>

<p>The dataset consists of the following objects :
</p>

<ul>
<li><p> drugTargetInteraction: a matrix indicating whether or not a
certain drug compound interacts with a certain neural receptor.
</p>
</li>
<li><p> targetSim: a similarity matrix for the neural receptors.
</p>
</li>
<li><p> drugSim: a similarity matrix for the drugs
</p>
</li></ul>

<p>The data originates from Yamanishi et al (2008) but was partly reworked
to be suitable for two-step kernel ridge regression. This is explained
in detail in  the <a href="../doc/Preparation_example_data.html">Preparation of
the example data</a> vignette.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1093/bioinformatics/btn162">https://doi.org/10.1093/bioinformatics/btn162</a>
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1093/bioinformatics/btn162">Yamanishi et al, 2008</a> : Prediction of drug-target interaction networks from the
integration of chemical and genomic spaces.
</p>

<hr>
<h2 id='eigen2hat'>Calculate the hat matrix from an eigen decomposition</h2><span id='topic+eigen2hat'></span><span id='topic+eigen2map'></span><span id='topic+eigen2matrix'></span>

<h3>Description</h3>

<p>These functions calculate either the hat matrix, the mapping matrix or
the original (kernel) matrix for a two-step kernel ridge regression,
based on the eigendecomposition of the kernel matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen2hat(eigen, val, lambda)

eigen2map(eigen, val, lambda)

eigen2matrix(eigen, val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigen2hat_+3A_eigen">eigen</code></td>
<td>
<p>a matrix with the eigenvectors.</p>
</td></tr>
<tr><td><code id="eigen2hat_+3A_val">val</code></td>
<td>
<p>an numeric vector with the eigenvalues.</p>
</td></tr>
<tr><td><code id="eigen2hat_+3A_lambda">lambda</code></td>
<td>
<p>a single numeric value for the hyperparameter lambda</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the hat matrix, this boils down to:
</p>
<p style="text-align: center;"><code class="reqn">U\Sigma(\Sigma + \lambda I)^{-1} U^{T}</code>
</p>

<p>For the map matrix, this is :
</p>
<p style="text-align: center;"><code class="reqn">U(\Sigma + \lambda I)^{-1} U^{T}</code>
</p>

<p>with <code class="reqn">U</code> the matrix with eigenvectors, <code class="reqn">\Sigma</code> a diagonal matrix
with the eigenvalues on the diagonal, <code class="reqn">I</code> the identity matrix and
<code class="reqn">\lambda</code> the hyperparameter linked to this kernel.
The internal calculation is optimized to avoid having to invert
a matrix. This is done using the fact that <code class="reqn">\Sigma</code> is a
diagonal matrix.
</p>


<h3>Value</h3>

<p>a numeric matrix representing either the hat matrix
(<code>eigen2hat</code>), the map matrix (<code>eigen2map</code>) or
the original matrix (<code>eigen2matrix</code>)
</p>

<hr>
<h2 id='fitted.tskrr'>extract the predictions</h2><span id='topic+fitted.tskrr'></span><span id='topic+fitted.linearFilter'></span><span id='topic+fitted+2Ctskrr-method'></span><span id='topic+fitted+2ClinearFilter-method'></span>

<h3>Description</h3>

<p>This functions extracts the fitted predictions from a
<code><a href="#topic+tskrr-class">tskrr</a></code> object or an object
inheriting from that class. The <code>xnet</code>
package provides an S4 generic for the function
<code><a href="stats.html#topic+fitted">fitted</a></code>  from the package <code>stats</code>,
and a method for <code><a href="#topic+tskrr-class">tskrr</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tskrr'
fitted(object, labels = TRUE, ...)

## S3 method for class 'linearFilter'
fitted(object, ...)

## S4 method for signature 'tskrr'
fitted(object, labels = TRUE, ...)

## S4 method for signature 'linearFilter'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.tskrr_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model fitted values
is meaningful.</p>
</td></tr>
<tr><td><code id="fitted.tskrr_+3A_labels">labels</code></td>
<td>
<p>a logical value indicating whether the labels should
be shown. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="fitted.tskrr_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with the predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)
pred &lt;- fitted(mod)

</code></pre>

<hr>
<h2 id='get_loo_fun'>Retrieve a loo function</h2><span id='topic+get_loo_fun'></span><span id='topic+get_loo_fun+2CtskrrHeterogeneous-method'></span><span id='topic+get_loo_fun+2CtskrrHomogeneous-method'></span><span id='topic+get_loo_fun+2ClinearFilter-method'></span><span id='topic+get_loo_fun+2Ccharacter-method'></span><span id='topic+get_loo_fun+2CtskrrTune-method'></span>

<h3>Description</h3>

<p>This function returns the correct function needed to perform
one of the leave-one-out cross-validations. It's primarily meant
for internal use but can be useful when doing simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_loo_fun(x, ...)

## S4 method for signature 'tskrrHeterogeneous'
get_loo_fun(
  x,
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE
)

## S4 method for signature 'tskrrHomogeneous'
get_loo_fun(
  x,
  exclusion = c("edges", "vertices", "interaction", "both"),
  replaceby0 = FALSE
)

## S4 method for signature 'linearFilter'
get_loo_fun(x, replaceby0 = FALSE)

## S4 method for signature 'character'
get_loo_fun(
  x = c("tskrrHeterogeneous", "tskrrHomogeneous", "linearFilter"),
  ...
)

## S4 method for signature 'tskrrTune'
get_loo_fun(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_loo_fun_+3A_x">x</code></td>
<td>
<p>a character value with the class or a <code><a href="#topic+tskrr">tskrr</a></code>
or <code><a href="#topic+linearFilter">linearFilter</a></code> object.</p>
</td></tr>
<tr><td><code id="get_loo_fun_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="get_loo_fun_+3A_exclusion">exclusion</code></td>
<td>
<p>a character value with possible values &quot;interaction&quot;,
&quot;row&quot;, &quot;column&quot;, &quot;both&quot; for heterogeneous models, and &quot;edges&quot;, &quot;vertices&quot;,
&quot;interaction&quot; or &quot;both&quot; for homogeneous models.
Defaults to &quot;interaction&quot;. See details.</p>
</td></tr>
<tr><td><code id="get_loo_fun_+3A_replaceby0">replaceby0</code></td>
<td>
<p>a logical value indicating whether the interaction
should be simply removed (<code>FALSE</code>) or replaced by 0 (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to select the correct loo function in
a simulation or tuning algorithm, based on the model object you
created. Depending on its class, the returned functions will have
different arguments, so you should only use this if you know
what you're doing and after you checked the actual returned
functions in <code><a href="#topic+loo_internal">loo_internal</a></code>.
</p>
<p>Using <code>replaceby0</code> only makes sense if you only remove the interaction.
In all other cases, this argument is ignored.
</p>
<p>For the class <code>tskrrHomogeneous</code>, it doesn't make sense to
remove rows or columns. If you chose this option, the function will
throw an error. Removing edges corresponds to the setting &quot;edges&quot; or
&quot;interaction&quot;. Removing vertices corresponds to the setting &quot;vertices&quot; or
&quot;both&quot;. These terms can be used interchangeably.
</p>
<p>For the class <code>linearFilter</code> it only makes sense to exclude the
interaction (i.e., a single cell). Therefore you do not have an argument
<code>exclusion</code> for that method.
</p>
<p>For the classes <code>tskrrTune</code> and <code>tskrrImpute</code>,
not specifying <code>exclusion</code> or <code>replaceby0</code> returns the used
loo function. If you specify either of them,
it will use the method for the appropriate model and return
a new loo function.
</p>


<h3>Value</h3>

<p>a function taking the arguments y, and possibly pred
for calculating the leave-one-out cross-validation. For class
<code>tskrrHeterogeneous</code>, the returned function also
has an argument Hk and Hg, representing the hat matrix for the rows
and the columns respectively. For class <code>tskrrHomogeneous</code>,
only the extra argument Hk is available. For class <code>linearFilter</code>,
the extra argument is called <code>alpha</code> and takes the alpha vector
of that model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo">loo</a></code> for carrying out a leave on out crossvalidation,
and <code><a href="#topic+loo_internal">loo_internal</a></code> for more information on the internal
functions one retrieves with this one.
</p>

<hr>
<h2 id='has_imputed_values'>Getters for tskrrImpute objects</h2><span id='topic+has_imputed_values'></span><span id='topic+which_imputed'></span><span id='topic+is_imputed'></span>

<h3>Description</h3>

<p>The functions described here are convenience functions to get
information out of a <code><a href="#topic+tskrrImpute-class">tskrrImpute</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_imputed_values(x)

which_imputed(x)

is_imputed(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_imputed_values_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+tskrrImpute-class">tskrrImpute</a></code> object or
an object inheriting from <code>tskrrImpute</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>has_imputed_values</code>: a logical value indicating whether
the model has imputed values. If <code>x</code> is not some form of a
<code><a href="#topic+tskrr">tskrr</a></code> model, the function will return an error.
</p>
<p>For <code>which_imputed</code>: a integer vector with the positions
for which the values are imputed.
</p>
<p>for <code>is_imputed</code>: a matrix of the same dimensions as the
label matrix. It contains the value <code>FALSE</code> at positions that
were not imputed, and <code>TRUE</code> at positions that were.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)

naid &lt;- sample(length(drugTargetInteraction), 30)
drugTargetInteraction[naid] &lt;- NA

impmod &lt;- impute_tskrr(drugTargetInteraction, targetSim, drugSim)

has_imputed_values(mod)
has_imputed_values(impmod)

# For illustration: extract imputed values
id &lt;- is_imputed(impmod)
fitted(impmod)[id]

</code></pre>

<hr>
<h2 id='hat'>Return the hat matrix of a tskrr model</h2><span id='topic+hat'></span><span id='topic+hat+2CtskrrHeterogeneous-method'></span><span id='topic+hat+2CtskrrHomogeneous-method'></span>

<h3>Description</h3>

<p>This function returns the hat matrix or hat matrices of
a tskrr model. <code>xnet</code> creates an S4 generic for <code>hat</code>
and links the default method to the <code><a href="stats.html#topic+influence.measures">hat</a></code> function
of <code>stats</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hat(x, ...)

## S4 method for signature 'tskrrHeterogeneous'
hat(x, which = c("row", "column"))

## S4 method for signature 'tskrrHomogeneous'
hat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hat_+3A_x">x</code></td>
<td>
<p>a tskrr model</p>
</td></tr>
<tr><td><code id="hat_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="hat_+3A_which">which</code></td>
<td>
<p>a character value with possible values &quot;row&quot; or
&quot;column&quot; to indicate which should be returned. For homogeneous
models, this parameter is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the requested hat matrix of the model.
</p>

<hr>
<h2 id='impute_tskrr'>Impute missing values in a label matrix</h2><span id='topic+impute_tskrr'></span>

<h3>Description</h3>

<p>This function implements an optimization algorithm that allows
imputing missing values in the label matrix while fitting a
<code>tskrr</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_tskrr(
  y,
  k,
  g = NULL,
  lambda = 0.01,
  testdim = TRUE,
  testlabels = TRUE,
  symmetry = c("auto", "symmetric", "skewed"),
  keep = FALSE,
  niter = 10000,
  tol = sqrt(.Machine$double.eps),
  start = mean(y, na.rm = TRUE),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_tskrr_+3A_y">y</code></td>
<td>
<p>a label matrix</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_k">k</code></td>
<td>
<p>a kernel matrix for the rows</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_g">g</code></td>
<td>
<p>an optional kernel matrix for the columns</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_lambda">lambda</code></td>
<td>
<p>a numeric vector with one or two values for the
hyperparameter lambda. If two values are given, the first one is
used for the k matrix and the second for the g matrix.</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_testdim">testdim</code></td>
<td>
<p>a logical value indicating whether symmetry
and the dimensions of the kernel(s) should be tested.
Defaults to <code>TRUE</code>, but for large matrices
putting this to <code>FALSE</code> will speed up the function.</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_testlabels">testlabels</code></td>
<td>
<p>a logical value indicating wether the row- and column
names of the matrices have to be checked for consistency. Defaults to
<code>TRUE</code>, but for large matrices putting this to <code>FALSE</code> will
speed up the function.</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_symmetry">symmetry</code></td>
<td>
<p>a character value with the possibilities
&quot;auto&quot;, &quot;symmetric&quot; or &quot;skewed&quot;. In case of a homogeneous fit, you
can either specify whether the label matrix is symmetric or
skewed, or you can let the function decide (option &quot;auto&quot;).</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_keep">keep</code></td>
<td>
<p>a logical value indicating whether the kernel hat
matrices should be stored in the model object. Doing so makes the
model object quite larger, but can speed up predictions in
some cases. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_niter">niter</code></td>
<td>
<p>an integer giving the maximum number of iterations</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_tol">tol</code></td>
<td>
<p>a numeric value indicating the tolerance for convergence of
the algorithm. It is the maximum sum of squared differences between
to iteration steps.</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_start">start</code></td>
<td>
<p>a numeric value indicating the value with which NA's are
replaced in the first step of the algorithm. Defaults to 0.</p>
</td></tr>
<tr><td><code id="impute_tskrr_+3A_verbose">verbose</code></td>
<td>
<p>either a logical value, 1 or 2. <code>1</code> means &quot;show the number
of iterations and the final deviation&quot;, <code>2</code> means &quot;show the deviation
every 10 iterations&quot;. A value <code>TRUE</code> is read as <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tskrr</code> model of the class <code><a href="#topic+tskrrImputeHeterogeneous">tskrrImputeHeterogeneous</a></code> or <code><a href="#topic+tskrrImputeHomogeneous">tskrrImputeHomogeneous</a></code> depending on whether or
not <code>g</code> has a value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

naid &lt;- sample(length(drugTargetInteraction), 30)
drugTargetInteraction[naid] &lt;- NA

impute_tskrr(drugTargetInteraction, targetSim, drugSim)

</code></pre>

<hr>
<h2 id='impute_tskrr.fit'>Impute values based on a two-step kernel ridge regression</h2><span id='topic+impute_tskrr.fit'></span>

<h3>Description</h3>

<p>This function provides an interface for the imputation of values
based on a <code><a href="#topic+tskrr">tskrr</a></code> model and is the internal function
used by <code><a href="#topic+impute_tskrr">impute_tskrr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_tskrr.fit(y, Hk, Hg, naid = NULL, niter, tol, start, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_tskrr.fit_+3A_y">y</code></td>
<td>
<p>a label matrix</p>
</td></tr>
<tr><td><code id="impute_tskrr.fit_+3A_hk">Hk</code></td>
<td>
<p>a hat matrix for the rows (see also <code><a href="#topic+eigen2hat">eigen2hat</a></code>
on how to calculate them from an eigen decomposition)</p>
</td></tr>
<tr><td><code id="impute_tskrr.fit_+3A_hg">Hg</code></td>
<td>
<p>a hat matrix for the columns. For homogeneous networks, this
should be Hk again.</p>
</td></tr>
<tr><td><code id="impute_tskrr.fit_+3A_naid">naid</code></td>
<td>
<p>an optional index with the values that have to be imputed,
i.e. at which positions you find a <code>NA</code> value. It can be a vector
with integers or a matrix with <code>TRUE</code>/<code>FALSE</code> values.</p>
</td></tr>
<tr><td><code id="impute_tskrr.fit_+3A_niter">niter</code></td>
<td>
<p>an integer giving the maximum number of iterations</p>
</td></tr>
<tr><td><code id="impute_tskrr.fit_+3A_tol">tol</code></td>
<td>
<p>a numeric value indicating the tolerance for convergence of
the algorithm. It is the maximum sum of squared differences between
to iteration steps.</p>
</td></tr>
<tr><td><code id="impute_tskrr.fit_+3A_start">start</code></td>
<td>
<p>a numeric value indicating the value with which NA's are
replaced in the first step of the algorithm. Defaults to 0.</p>
</td></tr>
<tr><td><code id="impute_tskrr.fit_+3A_verbose">verbose</code></td>
<td>
<p>either a logical value, 1 or 2. <code>1</code> means &quot;show the number
of iterations and the final deviation&quot;, <code>2</code> means &quot;show the deviation
every 10 iterations&quot;. A value <code>TRUE</code> is read as <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly available for internal use. In most cases,
it makes much more sense to use <code><a href="#topic+impute_tskrr">impute_tskrr</a></code>, as that
function returns an object one can work with. The function
<code>impute_tskrr.fit</code> could be useful when doing simulations or
creating fitting algorithms.
</p>


<h3>Value</h3>

<p>a list with two elements:
</p>

<ul>
<li><p> a matrix <code>y</code> with the imputed values filled in.
</p>
</li>
<li><p> a numeric value <code>niter</code> with the amount of iterations
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+impute_tskrr">impute_tskrr</a></code> for the user-level function, and
</p>
</li>
<li> <p><code><a href="#topic+eigen2hat">eigen2hat</a></code> for conversion of a eigen decomposition to
a hat matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

K &lt;- eigen(targetSim)
G &lt;- eigen(drugSim)

Hk &lt;- eigen2hat(K$vectors, K$values, lambda = 0.01)
Hg &lt;- eigen2hat(G$vectors, G$values, lambda = 0.05)

drugTargetInteraction[c(3,17,123)] &lt;- NA

res &lt;- impute_tskrr.fit(drugTargetInteraction, Hk, Hg,
                        niter = 1000, tol = 10e-10,
                        start = 0, verbose = FALSE)

</code></pre>

<hr>
<h2 id='is_symmetric'>Test symmetry of a matrix</h2><span id='topic+is_symmetric'></span>

<h3>Description</h3>

<p>The function <code><a href="base.html#topic+isSymmetric">isSymmetric</a></code> tests for symmetry of a matrix but also
takes row and column names into account. This function is a toned-down
(and slightly faster) version that ignores row and column names.
Currently, the function only works for real matrices, not complex ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_symmetric(x, tol = 100 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_symmetric_+3A_x">x</code></td>
<td>
<p>a matrix to be tested.</p>
</td></tr>
<tr><td><code id="is_symmetric_+3A_tol">tol</code></td>
<td>
<p>the tolerance for comparing the numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating whether or not the matrix is
symmetric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:16,ncol = 4)
is_symmetric(x)

x &lt;- x %*% t(x)
is_symmetric(x)

</code></pre>

<hr>
<h2 id='is_tuned'>Getters for tskrrTune objects</h2><span id='topic+is_tuned'></span><span id='topic+get_grid'></span><span id='topic+get_loss_values'></span><span id='topic+has_onedim'></span>

<h3>Description</h3>

<p>The functions described here are convenience functions to get
information out of a <code><a href="#topic+tskrrTune-class">tskrrTune</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_tuned(x)

get_grid(x)

get_loss_values(x)

has_onedim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_tuned_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+tskrrTune-class">tskrrTune</a></code> object or an
object inheriting from <code>tskrrTune</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>is_tuned</code>: a logical value indicating whether the
model is tuned.
</p>
<p>For <code>get_grid</code> a list with the elements <code>k</code> and
possibly <code>g</code>, each containing the different lambdas tried in
the tuning for the row and column kernel matrices respectively.
</p>
<p>For <code>get_loss_values</code> a matrix with the calculated
loss values. Note that each row represents the result for one
lambda value related to the row kernel matrix K. For heterogeneous
models, every column represents the result for one lambda related
to the column kernel matrix G.
</p>
<p>for <code>is_onedim</code> a single logical value telling whether the
grid search in the object was onedimensional.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)
tuned &lt;- tune(mod, ngrid = 10)

is_tuned(mod)
is_tuned(tuned)

# Basic visualization of the grid.

gridvals &lt;- get_grid(tuned)
z &lt;- get_loss_values(tuned)

## Not run: 
image(gridvals$k,gridvals$g,log(z), log = 'xy',
xlab = "lambda k", ylab = "lambda g")

## End(Not run)

</code></pre>

<hr>
<h2 id='labels.tskrr'>Extract labels from a tskrr object</h2><span id='topic+labels.tskrr'></span><span id='topic+labels+2Ctskrr-method'></span><span id='topic+dimnames+2Ctskrr-method'></span><span id='topic+dimnames.tskrr'></span><span id='topic+rownames+2Ctskrr-method'></span><span id='topic+colnames+2Ctskrr-method'></span>

<h3>Description</h3>

<p>These functions allow you to extract the labels from a
<code><a href="#topic+tskrr">tskrr</a></code> object. The function <code>labels</code> and the
function <code>dimnames</code> are aliases and do the exact same
thing. The functions <code>rownames</code> and <code>colnames</code> work like
you would expect. Note that contrary to the latter two, <code>labels</code>
will never return <code>NULL</code>. If no labels are found, it will construct
labels using the prefixes defined in the argument <code>prefix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tskrr'
labels(
  object,
  prefix = if (is_homogeneous(object)) "row" else c("row", "col"),
  ...
)

## S4 method for signature 'tskrr'
labels(
  object,
  prefix = if (is_homogeneous(object)) "row" else c("row", "col"),
  ...
)

## S4 method for signature 'tskrr'
dimnames(x)

## S4 method for signature 'tskrr'
rownames(x, do.NULL = TRUE, prefix = "row")

## S4 method for signature 'tskrr'
colnames(x, do.NULL = TRUE, prefix = "col")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labels.tskrr_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+tskrr">tskrr</a></code> object</p>
</td></tr>
<tr><td><code id="labels.tskrr_+3A_prefix">prefix</code></td>
<td>
<p>a prefix used for construction of the labels in case
none are available. For <code>label</code>, a character vector of length 1 for
homogeneous networks or of length 2 for heterogeneous networks.
In case two values are given, the first is used for the rows and the second
for the columns. Otherwise the only value is used for both. In the case of
<code>rownames</code> and <code>colnames</code>, a single value.
See also <code><a href="base.html#topic+colnames">row+colnames</a></code></p>
</td></tr>
<tr><td><code id="labels.tskrr_+3A_...">...</code></td>
<td>
<p>arguments passed to/from other methods.</p>
</td></tr>
<tr><td><code id="labels.tskrr_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+tskrr">tskrr</a></code> object</p>
</td></tr>
<tr><td><code id="labels.tskrr_+3A_do.null">do.NULL</code></td>
<td>
<p>logical. If <code>FALSE</code> and labels are <code>NULL</code>,
labels are created. If <code>TRUE</code>, the function returns <code>NULL</code> in
the absence of labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>labels</code> and <code>dimnames</code>: a list with two elements <code>k</code> and
<code>g</code>
</p>


<h3>Warning</h3>

<p>If the original data didn't contain row- or column names for the
label matrix, <code>rownames</code> and <code>colnames</code> will return
<code>NULL</code>. Other functions will extract the automatically generated
labels, so don't count on <code>rownames</code> and <code>colnames</code> if you
want to predict output from other functions!
</p>

<hr>
<h2 id='linear_filter'>Fit a linear filter over a label matrix</h2><span id='topic+linear_filter'></span>

<h3>Description</h3>

<p>This function fits a linear filter over a label matrix. It calculates
the row, column and total means, and uses those to construct the linear
filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_filter(y, alpha = 0.25, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_filter_+3A_y">y</code></td>
<td>
<p>a label matrix</p>
</td></tr>
<tr><td><code id="linear_filter_+3A_alpha">alpha</code></td>
<td>
<p>a vector with 4 alpha values, or a single alpha value
which then is used for all 4 alphas.</p>
</td></tr>
<tr><td><code id="linear_filter_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether missing values should
be removed before calculating the row-, column- and total means.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are missing values and they are removed before calculating the
means, a warning is issued. If <code>na.rm = FALSE</code> and there are
missing values present, the outcome is, by definition, a matrix filled
with NA values.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+linearFilter-class">linearFilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)
linear_filter(drugTargetInteraction, alpha = 0.25)
linear_filter(drugTargetInteraction, alpha = c(0.1,0.1,0.4,0.4))

</code></pre>

<hr>
<h2 id='linearFilter-class'>Class linearFilter</h2><span id='topic+linearFilter-class'></span><span id='topic+linearFilter'></span>

<h3>Description</h3>

<p>The class represents the outcome of a linear filter, and is normally
generated by the function <code><a href="#topic+linear_filter">linear_filter</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>y</code></dt><dd><p>the original label matrix with responses.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a numeric vector with the 4 alpha values of the model.</p>
</dd>
<dt><code>pred</code></dt><dd><p>a matrix with the predictions</p>
</dd>
<dt><code>mean</code></dt><dd><p>a numeric vector containing the global mean of <code>y</code></p>
</dd>
<dt><code>colmeans</code></dt><dd><p>a numeric vector containing the column means of <code>y</code></p>
</dd>
<dt><code>rowmeans</code></dt><dd><p>a numeric vector containing the row means of <code>y</code>.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>a logical value indicating whether missing values were
removed prior to the calculation of the means.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+linear_filter">linear_filter</a></code> for creating a linear filter model,
and <code><a href="#topic+getters_linearFilter">getter fuctions for linearFilter</a></code>.
</p>

<hr>
<h2 id='loo'>Leave-one-out cross-validation for tskrr</h2><span id='topic+loo'></span><span id='topic+loo+2CtskrrHeterogeneous-method'></span><span id='topic+loo+2CtskrrHomogeneous-method'></span><span id='topic+loo+2ClinearFilter-method'></span>

<h3>Description</h3>

<p>Perform a leave-one-out cross-validation for two-step kernel
ridge regression based on the shortcuts described in Stock et al, 2018.
(<a href="http://doi.org/10.1093/bib/bby095">http://doi.org/10.1093/bib/bby095</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo(x, ...)

## S4 method for signature 'tskrrHeterogeneous'
loo(
  x,
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE
)

## S4 method for signature 'tskrrHomogeneous'
loo(
  x,
  exclusion = c("edges", "vertices", "interaction", "both"),
  replaceby0 = FALSE
)

## S4 method for signature 'linearFilter'
loo(x, replaceby0 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+tskrr-class">tskrr</a></code> or
<code><a href="#topic+linearFilter">linearFilter</a></code>.</p>
</td></tr>
<tr><td><code id="loo_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.
See Details.</p>
</td></tr>
<tr><td><code id="loo_+3A_exclusion">exclusion</code></td>
<td>
<p>a character value with possible values &quot;interaction&quot;,
&quot;row&quot;, &quot;column&quot;, &quot;both&quot; for heterogeneous models, and &quot;edges&quot;, &quot;vertices&quot;,
&quot;interaction&quot; or &quot;both&quot; for homogeneous models.
Defaults to &quot;interaction&quot;. See details.</p>
</td></tr>
<tr><td><code id="loo_+3A_replaceby0">replaceby0</code></td>
<td>
<p>a logical value indicating whether the interaction
should be simply removed (<code>FALSE</code>) or replaced by 0 (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>exclusion</code> defines what is left out.
The value &quot;interaction&quot; means that a single interaction is removed.
In the case of a homogeneous model, this can be interpreted as the
removal of the interaction between two edges. The values &quot;row&quot; and
&quot;column&quot; mean that all interactions for a row edge resp. a column
edge are removed. The value &quot;both&quot; removes all interactions for
a row and a column edge.
</p>
<p>In the case of a homogeneous model, &quot;row&quot; and &quot;column&quot; don't make sense
and will be replaced by &quot;both&quot; with a warning. This can be interpreted
as removing vertices, i.e. all interactions between one edge and
all other edges. Alternatively one can use &quot;edges&quot; to remove edges and
&quot;vertices&quot; to remove vertices. In the case of a homogeneous model,
the setting &quot;edges&quot; translates to &quot;interaction&quot;, and &quot;vertices&quot;
translates to &quot;both&quot;. For more information, see Stock et al. (2018).
</p>
<p>Replacing by 0 only makes sense when <code>exclusion = "interaction"</code> and the
label matrix contains only 0 and 1 values. The function checks whether
the conditions are fulfilled and if not, returns an error.
</p>


<h3>Value</h3>

<p>a numeric matrix with the leave-one-out predictions for
the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim,
             lambda = c(0.01,0.01))

delta &lt;- loo(mod, exclusion = 'both') - response(mod)
delta0 &lt;- loo(mod, replaceby0 = TRUE) - response(mod)

</code></pre>

<hr>
<h2 id='loo_internal'>Leave-one-out cross-validation for two-step kernel ridge regression</h2><span id='topic+loo_internal'></span><span id='topic+loo.i'></span><span id='topic+loo.i0'></span><span id='topic+loo.r'></span><span id='topic+loo.c'></span><span id='topic+loo.b'></span><span id='topic+loo.e.sym'></span><span id='topic+loo.e.skew'></span><span id='topic+loo.e0.sym'></span><span id='topic+loo.e0.skew'></span><span id='topic+loo.v'></span><span id='topic+loo.i.lf'></span><span id='topic+loo.i0.lf'></span>

<h3>Description</h3>

<p>These functions implement different cross-validation scenarios for
two-step kernel ridge regression. It uses the shortcuts for
leave-one-out cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo.i(Y, Hk, Hg, pred)

loo.i0(Y, Hk, Hg, pred)

loo.r(Y, Hk, Hg, ...)

loo.c(Y, Hk, Hg, ...)

loo.b(Y, Hk, Hg, ...)

loo.e.sym(Y, Hk, pred)

loo.e.skew(Y, Hk, pred)

loo.e0.sym(Y, Hk, pred)

loo.e0.skew(Y, Hk, pred)

loo.v(Y, Hk, ...)

loo.i.lf(Y, alpha, pred)

loo.i0.lf(Y, alpha, pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo_internal_+3A_y">Y</code></td>
<td>
<p>the matrix with responses</p>
</td></tr>
<tr><td><code id="loo_internal_+3A_hk">Hk</code></td>
<td>
<p>the hat matrix for the first kernel (rows of Y)</p>
</td></tr>
<tr><td><code id="loo_internal_+3A_hg">Hg</code></td>
<td>
<p>the hat matrix for the second kernel (columns of Y)</p>
</td></tr>
<tr><td><code id="loo_internal_+3A_pred">pred</code></td>
<td>
<p>the predictions</p>
</td></tr>
<tr><td><code id="loo_internal_+3A_...">...</code></td>
<td>
<p>added to allow for specifying pred even when not needed.</p>
</td></tr>
<tr><td><code id="loo_internal_+3A_alpha">alpha</code></td>
<td>
<p>a vector of length 4 with the alpha values from a
<code><a href="#topic+linearFilter">linearFilter</a></code> model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are primarily for internal use and hence not exported.
Be careful when using them, as they do not perform any sanity check
on the input. It is up to the user to make sure the input makes sense.
</p>


<h3>Value</h3>

<p>a matrix with the leave-one-out predictions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo">loo</a></code> for the user-level function.
</p>

<hr>
<h2 id='loss'>Calculate or extract the loss of a tskrr model</h2><span id='topic+loss'></span><span id='topic+loss+2Ctskrr-method'></span><span id='topic+loss+2CtskrrTune-method'></span><span id='topic+loss+2Cpermtest-method'></span>

<h3>Description</h3>

<p>This function allows calculating the loss of a tskrr model using
either one of the functions defined in <code><a href="#topic+loss_functions">loss_functions</a></code>
or a custom user function. If the model inherits from class
<code><a href="#topic+tskrrTune-class">tskrrTune</a></code> and no additional arguments
are given, the loss is returned for the settings used when tuning.
The function can also be used to extract the original loss from a
<code><a href="#topic+permtest-class">permtest</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss(x, ...)

## S4 method for signature 'tskrr'
loss(
  x,
  fun = loss_mse,
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE,
  predictions = FALSE,
  ...
)

## S4 method for signature 'tskrrTune'
loss(
  x,
  fun = loss_mse,
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE,
  predictions = FALSE,
  ...
)

## S4 method for signature 'permtest'
loss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loss_+3A_x">x</code></td>
<td>
<p>a model that inherits from class
<code><a href="#topic+tskrr-class">tskrr</a></code></p>
</td></tr>
<tr><td><code id="loss_+3A_...">...</code></td>
<td>
<p>extra arguments passed to the loss function in <code>fun</code>.</p>
</td></tr>
<tr><td><code id="loss_+3A_fun">fun</code></td>
<td>
<p>a function to be used for calculating the loss. This
can also be a character value giving the name of one of the loss
functions provided in the package</p>
</td></tr>
<tr><td><code id="loss_+3A_exclusion">exclusion</code></td>
<td>
<p>a character value with possible values &quot;interaction&quot;,
&quot;row&quot;, &quot;column&quot; or &quot;both&quot;.
See also <code><a href="#topic+loo">loo</a></code> for more information.</p>
</td></tr>
<tr><td><code id="loss_+3A_replaceby0">replaceby0</code></td>
<td>
<p>a logical value indicating whether the interaction
should be simply removed (<code>FALSE</code>) or replaced by 0 (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="loss_+3A_predictions">predictions</code></td>
<td>
<p>a logical value to indicate whether the
predictions should be used instead of leave one out crossvalidation.
If set to <code>TRUE</code>, the other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value with the calculated loss
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+loss_functions">loss_functions</a></code> for possible loss functions
</p>
</li>
<li> <p><code><a href="#topic+tune">tune</a></code> for tuning a model based on loss functions
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)

loss(mod, fun = loss_auc)

tuned &lt;- tune(mod, fun = loss_auc)

loss(tuned)
loss(tuned, fun = loss_mse)

</code></pre>

<hr>
<h2 id='loss_functions'>loss functions</h2><span id='topic+loss_functions'></span><span id='topic+loss_mse'></span><span id='topic+loss_auc'></span>

<h3>Description</h3>

<p>These functions can be used as loss functions in <code><a href="#topic+tune">tune</a></code>.
Currently, two functions are provided: a function calculating the
classic mean squared error (<code>loss_mse</code>) and a function
calculating 1 - AUC (<code>loss_auc</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss_mse(Y, LOO, na.rm = FALSE)

loss_auc(Y, LOO)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loss_functions_+3A_y">Y</code></td>
<td>
<p>the label matrix with observed responses</p>
</td></tr>
<tr><td><code id="loss_functions_+3A_loo">LOO</code></td>
<td>
<p>the leave-one-out crossvalidation (or predictions if you
must). This one can be calculated by the function <code>loo</code>.</p>
</td></tr>
<tr><td><code id="loss_functions_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AUC is calculated by sorting the <code>Y</code> matrix based on
the order of the values in the <code>LOO</code> matrix. The false and true
positive rates are calculated solely based on that ordering, which
allows for values in <code>LOO</code> outside the range [0,1]. It's
a naive implementation which is good enough for tuning, but
shouldn't be used as a correct value for 1 - auc in case the
values in <code>LOO</code> are outside the range [0,1].
</p>


<h3>Note</h3>

<p>The function <code>loss_auc</code> should only be used for a <code>Y</code>
matrix that contains solely the values 0 and 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tune">tune</a></code> for application of the loss function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1,0,0,1,0,0,1,0,1)
y &lt;- c(0.8,-0.1,0.2,0.2,0.4,0.01,1.12,0.9,0.9)
loss_mse(x,y)
loss_auc(x,y)

</code></pre>

<hr>
<h2 id='match_labels'>Reorder the label matrix</h2><span id='topic+match_labels'></span>

<h3>Description</h3>

<p>Reorders the label matrix based on the labels of the kernel matrices.
In case there are no labels, the original label matrix is returned,
but with the labels in <code>rows</code> and <code>cols</code> as rownames and
column names respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_labels(y, rows, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_labels_+3A_y">y</code></td>
<td>
<p>a matrix representing the label matrix.</p>
</td></tr>
<tr><td><code id="match_labels_+3A_rows">rows</code></td>
<td>
<p>a character vector with the labels for the rows or a matrix
with rownames that will be used as labels.</p>
</td></tr>
<tr><td><code id="match_labels_+3A_cols">cols</code></td>
<td>
<p>a character vector with the labels for the cols or a matrix
with colnames that will be used as labels. If <code>NULL</code>, <code>rows</code> will be
used for both row and column labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the rows and columns reordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:6, ncol = 2,
              dimnames = list(c("b", "a", "d"),
                              c("ca", "cb"))
             )

match_labels(mat, c("a","b", "d"), c("ca","cb"))

#Using matrices
data(drugtarget)
out &lt;- match_labels(drugTargetInteraction, targetSim, drugSim)

</code></pre>

<hr>
<h2 id='permtest'>Calculate the relative importance of the edges</h2><span id='topic+permtest'></span><span id='topic+print.permtest'></span><span id='topic+permtest+2CtskrrHeterogeneous-method'></span><span id='topic+permtest+2CtskrrHomogeneous-method'></span><span id='topic+permtest+2CtskrrTune-method'></span>

<h3>Description</h3>

<p>This function does a permutation-based evaluation of the impact of
different edges on the final result. It does so by permuting the kernel
matrices, refitting the model and calculating a loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permtest(x, ...)

## S3 method for class 'permtest'
print(x, digits = max(3L, getOption("digits") - 3), ...)

## S4 method for signature 'tskrrHeterogeneous'
permtest(
  x,
  n = 100,
  permutation = c("both", "row", "column"),
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE,
  fun = loss_mse,
  exact = FALSE
)

## S4 method for signature 'tskrrHomogeneous'
permtest(
  x,
  n = 100,
  permutation = c("both"),
  exclusion = c("interaction", "both"),
  replaceby0 = FALSE,
  fun = loss_mse,
  exact = FALSE
)

## S4 method for signature 'tskrrTune'
permtest(x, permutation = c("both", "row", "column"), n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permtest_+3A_x">x</code></td>
<td>
<p>either a <code><a href="#topic+tskrr-class">tskrr-class</a></code> or a
<code><a href="#topic+tskrrTune-class">tskrrTune-class</a></code> object</p>
</td></tr>
<tr><td><code id="permtest_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="permtest_+3A_digits">digits</code></td>
<td>
<p>the number of digits shown in the output</p>
</td></tr>
<tr><td><code id="permtest_+3A_n">n</code></td>
<td>
<p>the number of permutations for every kernel matrix</p>
</td></tr>
<tr><td><code id="permtest_+3A_permutation">permutation</code></td>
<td>
<p>a character string that defines whether the row,
column or both kernel matrices should be permuted. Ignored in case of
a homogeneous network</p>
</td></tr>
<tr><td><code id="permtest_+3A_exclusion">exclusion</code></td>
<td>
<p>the exclusion to be used in the <code><a href="#topic+loo">loo</a></code> function. See also <code><a href="#topic+get_loo_fun">get_loo_fun</a></code></p>
</td></tr>
<tr><td><code id="permtest_+3A_replaceby0">replaceby0</code></td>
<td>
<p>a logical value indicating whether <code><a href="#topic+loo">loo</a></code>
removes a value in the leave-one-out procedure or replaces it by zero.
See also <code><a href="#topic+get_loo_fun">get_loo_fun</a></code>.</p>
</td></tr>
<tr><td><code id="permtest_+3A_fun">fun</code></td>
<td>
<p>a function (or a character string with the name of a
function) that calculates the loss. See also <code><a href="#topic+tune">tune</a></code> and
<code><a href="#topic+loss_functions">loss_functions</a></code></p>
</td></tr>
<tr><td><code id="permtest_+3A_exact">exact</code></td>
<td>
<p>a logical value that indicates whether or not an
exact p-value should be calculated, or be approximated based on
a normal distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test involved uses a normal approximation. It assumes that under the
null hypothesis, the loss values are approximately normally distributed.
The cumulative probability of a loss as small or smaller than
the one found in the original model, is calculated based on a normal
distribution from which the mean and sd are calculated from the permutations.
</p>


<h3>Value</h3>

<p>An object of the class permtest.
</p>


<h3>Warning</h3>

<p>It should be noted that this normal approximation is an ad-hoc approach.
There's no guarantee that the actual distribution of the loss under the
null hypothesis is normal. Depending on the loss function, a significant
deviation from the theoretic distribution can exist. Hence this functions should only
be used as a rough guidance in model evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Heterogeneous network

data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)
permtest(mod, fun = loss_auc)

</code></pre>

<hr>
<h2 id='permtest-class'>Class permtest</h2><span id='topic+permtest-class'></span>

<h3>Description</h3>

<p>This class represents the permutation test outcomes. See also
the function <code><a href="#topic+permtest">permtest</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>orig_loss</code></dt><dd><p>a numeric value with the original loss of
the model.</p>
</dd>
<dt><code>perm_losses</code></dt><dd><p>a numeric vector with the losses of the
different permutations.</p>
</dd>
<dt><code>n</code></dt><dd><p>the number of permutations</p>
</dd>
<dt><code>loss_function</code></dt><dd><p>the function used to calculate the losses.</p>
</dd>
<dt><code>exclusion</code></dt><dd><p>a character value indicating the exclusion
setting used for the test</p>
</dd>
<dt><code>replaceby0</code></dt><dd><p>a locigal value that indicates whether the
exclusion was done by replacing with zero. See also
<code><a href="#topic+loo">loo</a></code>.</p>
</dd>
<dt><code>permutation</code></dt><dd><p>a character value that indicats in which
kernel matrices were permuted.</p>
</dd>
<dt><code>pval</code></dt><dd><p>a p value indicating how likely it is to find a
smaller loss than the one of the model based on a normal
approximation.</p>
</dd>
<dt><code>exact</code></dt><dd><p>a logical value indicating whether the P value was
calculated exactly or approximated by the normal distribution.</p>
</dd>
</dl>


<h3>See Also</h3>


<ul>
<li><p> the function <code><a href="#topic+permtest">permtest</a></code> for the actual test.
</p>
</li>
<li><p> the function <code><a href="#topic+loo">loo</a></code> for the leave one out
procedures
</p>
</li>
<li><p> the function <code><a href="stats.html#topic+t.test">t.test</a></code> for the actual test
</p>
</li></ul>


<hr>
<h2 id='permutations'>Getters for permtest objects</h2><span id='topic+permutations'></span><span id='topic+Extract-permtest'></span><span id='topic++5B+2Cpermtest-method'></span>

<h3>Description</h3>

<p>The functions described here are convenience functions to get
information out of a <code><a href="#topic+permtest-class">permtest</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(x)

## S4 method for signature 'permtest'
x[i]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutations_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+permtest-class">permtest</a></code> object</p>
</td></tr>
<tr><td><code id="permutations_+3A_i">i</code></td>
<td>
<p>either a numeric vector, a logical vector or a character
vector with the elements that need extraction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the requested values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loss">loss</a></code> to extract the original loss value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)
ptest &lt;- permtest(mod, fun = loss_auc)

loss(ptest)
ptest[c(2,3)]
permutations(ptest)

</code></pre>

<hr>
<h2 id='plot_grid'>Plot the grid of a tuned tskrr model</h2><span id='topic+plot_grid'></span>

<h3>Description</h3>

<p>With this function, you can visualize the grid search for optimal
lambdas from a <code><a href="#topic+tskrrTune-class">tskrrTune</a></code> object.
In the case of two-dimensional grid search, this function plots a
contour plot on a grid, based on the functions <code><a href="graphics.html#topic+image">image</a></code>
and <code><a href="graphics.html#topic+contour">contour</a></code>. For one-dimensional grid search, the function
creates a single line plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_grid(
  x,
  addlambda = TRUE,
  lambdapars = list(col = "red"),
  log = TRUE,
  opts.contour = list(nlevels = 10),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_grid_+3A_x">x</code></td>
<td>
<p>an object that inherits from
<code><a href="#topic+tskrrTune-class">tskrrTune</a></code></p>
</td></tr>
<tr><td><code id="plot_grid_+3A_addlambda">addlambda</code></td>
<td>
<p>a logical value indicating whether the
lambda with the minimum loss should be added to the plot.
In case of a one dimensional plot, this adds a colored
vertical line. In the case of a two dimensional plot, this
adds a colored point at the minimum.</p>
</td></tr>
<tr><td><code id="plot_grid_+3A_lambdapars">lambdapars</code></td>
<td>
<p>a list with named <code><a href="graphics.html#topic+par">par</a></code> values
passed to the function <code><a href="graphics.html#topic+abline">abline</a></code> or
<code><a href="graphics.html#topic+points">points</a></code> for plotting the best lambda value when
<code>addmin = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_grid_+3A_log">log</code></td>
<td>
<p>a logical value indicating whether the lambdas should be
plotted at a log scale (the default) or not.</p>
</td></tr>
<tr><td><code id="plot_grid_+3A_opts.contour">opts.contour</code></td>
<td>
<p>options passed to the function
<code><a href="graphics.html#topic+contour">contour</a></code> for 2D grid plots. Ignored for 1D
grid plots.</p>
</td></tr>
<tr><td><code id="plot_grid_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions. For a one
dimensional plot, this will be the function <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

## One dimensional tuning
tuned1d &lt;- tune(drugTargetInteraction, targetSim, drugSim,
                lim = c(1e-4,2), ngrid = 40,
                fun = loss_auc, onedim = TRUE)

plot_grid(tuned1d)
plot_grid(tuned1d, lambdapars = list(col = "green",
                                     lty = 1, lwd = 2),
          log = FALSE, las = 2, main = "1D tuning")

## Two dimensional tuning
tuned2d &lt;- tune(drugTargetInteraction, targetSim, drugSim,
                lim = c(1e-4,10), ngrid = 20,
                fun = loss_auc)

plot_grid(tuned2d)

</code></pre>

<hr>
<h2 id='plot.tskrr'>plot a heatmap of the predictions from a tskrr model</h2><span id='topic+plot.tskrr'></span>

<h3>Description</h3>

<p>This function plots a heatmap of the fitted values in a
<code><a href="#topic+tskrr">tskrr</a></code> model. The function is loosely based on
<code><a href="stats.html#topic+heatmap">heatmap</a></code>, but uses a different mechanism and adds
a legend by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tskrr'
plot(
  x,
  dendro = c("both", "row", "col", "none"),
  which = c("fitted", "loo", "response", "residuals"),
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE,
  nbest = 0,
  rows,
  cols,
  col = rev(heat.colors(20)),
  breaks = NULL,
  legend = TRUE,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  labRow = NULL,
  labCol = NULL,
  margins = c(5, 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tskrr_+3A_x">x</code></td>
<td>
<p>a tskrr model</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_dendro">dendro</code></td>
<td>
<p>a character value indicating whether a dendrogram
should be constructed.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_which">which</code></td>
<td>
<p>a character value indicating whether the fitted values,
the leave-one-out values, the original response values  or the
residuals should be plotted.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_exclusion">exclusion</code></td>
<td>
<p>if <code>which = "loo"</code>, this argument is passed to
<code><a href="#topic+loo">loo</a></code> for the exclusion settings</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_replaceby0">replaceby0</code></td>
<td>
<p>if <code>which = "loo"</code>, this argument is passed to
<code><a href="#topic+loo">loo</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_nbest">nbest</code></td>
<td>
<p>a single integer value indicating the amount of best values
that should be selected. If <code>0</code>, all data is shown.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_rows">rows</code></td>
<td>
<p>a numeric or character vector indicating which rows should be
selected from the model.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_cols">cols</code></td>
<td>
<p>a numeric or character vector indicating which columns should be
selected from the model.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_col">col</code></td>
<td>
<p>a vector with colors to be used for plotting</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_breaks">breaks</code></td>
<td>
<p>a single value specifying the number of
breaks (must be 1 more than number of colors), or a numeric
vector with the breaks used for the color code. If <code>NULL</code>,
the function tries to find evenly spaced breaks.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_legend">legend</code></td>
<td>
<p>a logical value indicating whether or not the legend should
be added to the plot.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_main">main</code></td>
<td>
<p>a character value with a title for the plot</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_xlab">xlab</code></td>
<td>
<p>a character label for the X axis</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_ylab">ylab</code></td>
<td>
<p>a character label for the Y axis</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_labrow">labRow</code></td>
<td>
<p>a character vector with labels to be used on the rows.
Note that these labels are used as is (possibly reordered to match
the dendrogram). They can replace the labels from the model. Set to
<code>NA</code> to remove the row labels.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_labcol">labCol</code></td>
<td>
<p>the same as <code>labRow</code> but then for the columns.</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_margins">margins</code></td>
<td>
<p>a numeric vector with 2 values indicating the margins to
be used for the row and column labels (cfr <code>par("mar")</code>)</p>
</td></tr>
<tr><td><code id="plot.tskrr_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can select a part of the model for plotting. Either you
specify <code>rows</code> and <code>cols</code>, or you specify <code>nbest</code>.
If <code>nbest</code> is specified, <code>rows</code> and <code>cols</code> are ignored.
The n highest values are looked up in the plotted values, and only
the rows and columns related to these values are shown then. This
allows for a quick selection of the highest predictions.
</p>
<p>Dendrograms are created by converting the kernel matrices to
a distance, using
</p>
<p>d(x,y) = K(x,x)^2 + K(y,y)^2 - 2*K(x,y)
</p>
<p>with K being the kernel function. The resulting distances are
clustered using <code><a href="stats.html#topic+hclust">hclust</a></code> and converted to a
dendrogram using <code><a href="stats.html#topic+as.dendrogram">as.dendrogram</a></code>.
</p>


<h3>Value</h3>

<p>an invisible list with the following elements:
</p>

<ul>
<li> <p><code>val</code>: the values plotted
</p>
</li>
<li> <p><code>ddK</code>: if a row dendrogram was requested, the row dendrogram
</p>
</li>
<li> <p><code>ddG</code>: if a column dendrogram was requested,
the column dendrogram
</p>
</li>
<li> <p><code>breaks</code>: the breaks used for the color codes
</p>
</li>
<li> <p><code>col</code>: the colors used
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+tskrr">tskrr</a></code>, <code><a href="#topic+tune">tune</a></code> and
<code>link{impute_tskrr}</code> to construct tskrr models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)
mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)

plot(mod)
plot(mod, dendro = "row", legend = FALSE)
plot(mod, col = rainbow(20), dendro = "none", which = "residuals")
plot(mod, labCol = NA, labRow = NA, margins = c(0.2,0.2))

</code></pre>

<hr>
<h2 id='predict.tskrr'>predict method for tskrr fits</h2><span id='topic+predict.tskrr'></span><span id='topic+predict+2Ctskrr-method'></span>

<h3>Description</h3>

<p>Obtains the predictions from a <code><a href="#topic+tskrr">tskrr</a></code> model for new data.
To get the predictions on the training data,
use the function <code><a href="#topic+fitted">fitted</a></code>
or set both <code>k</code> and <code>g</code> to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tskrr'
predict(object, k = NULL, g = NULL, testdim = TRUE, ...)

## S4 method for signature 'tskrr'
predict(object, k = NULL, g = NULL, testdim = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tskrr_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+tskrr-class">tskrr</a></code>.</p>
</td></tr>
<tr><td><code id="predict.tskrr_+3A_k">k</code></td>
<td>
<p>a new K matrix or <code>NULL</code>. if <code>NULL</code>, the fitted
values on the training data are returned.</p>
</td></tr>
<tr><td><code id="predict.tskrr_+3A_g">g</code></td>
<td>
<p>a new G matrix or <code>NULL</code>. If <code>NULL</code>, K is used
for both.</p>
</td></tr>
<tr><td><code id="predict.tskrr_+3A_testdim">testdim</code></td>
<td>
<p>a logical value indicating whether the dimensions should
be checked prior to the calculation. You can set this to <code>FALSE</code> but
you might get more obscure errors if dimensions don't match.</p>
</td></tr>
<tr><td><code id="predict.tskrr_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions can be calculated between new vertices and the vertices
used to train the model, between new sets of vertices, or both. Which
predictions are given, depends on the kernel matrices passed to the
function.
</p>
<p>In any case, both the K and G matrix need the kernel values for
every combination of the new vertices and the vertices used to
train the model. This is illustrated for both homogeneous and
heterogeneous networks in the examples.
</p>
<p>To predict the links between a new set of vertices and the training
vertices, you need to provide the kernel matrix for either the K
or the G set of vertices. If you want to predict the mutual links
between two new sets of vertices, you have to provide both the
K and the G matrix. This is particularly important for homogeneous
networks: if you only supply the <code>k</code> argument, you will get
predictions for the links between the new vertices and the vertices
on which the model is trained. So in order to get the
mutual links between the new vertices, you need to provide the kernel
matrix as the value for both the <code>k</code> and the <code>g</code> argument.
</p>


<h3>Value</h3>

<p>a matrix with predicted values.
</p>


<h3>Warning</h3>

<p>This function is changed in version 0.1.9 so it's more consistent
in how it expects the K and G matrices to be ordered. Up to version
0.1.8 the new vertices should be on the rows for the K matrix and on
the columns for the G matrix. This lead to confusion.
</p>
<p>If you're using old code, you'll get an error pointing this out.
You need to transpose the G matrix in the old code to make it work
with the new version.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tskrr">tskrr</a></code> and <code><a href="#topic+tskrrTune">tskrrTune</a></code> for
fitting the models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Predictions for homogeneous networks

data(proteinInteraction)

idnew &lt;- sample(nrow(Kmat_y2h_sc), 20)

trainY &lt;- proteinInteraction[-idnew,-idnew]
trainK &lt;- Kmat_y2h_sc[-idnew,-idnew]

testK &lt;- Kmat_y2h_sc[idnew, - idnew]

mod &lt;- tskrr(trainY, trainK, lambda = 0.1)
# Predict interaction between test vertices
predict(mod, testK, testK)

# Predict interaction between test and train vertices
predict(mod, testK)
predict(mod, g = testK)

## Predictions for heterogeneous networks
data("drugtarget")

idnewK &lt;- sample(nrow(targetSim), 10)
idnewG &lt;- sample(ncol(drugSim), 10)

trainY &lt;- drugTargetInteraction[-idnewK, -idnewG]
trainK &lt;- targetSim[-idnewK, -idnewK]
trainG &lt;- drugSim[-idnewG, -idnewG]

testK &lt;- targetSim[idnewK, -idnewK]
testG &lt;- drugSim[idnewG, -idnewG]

mod &lt;- tskrr(trainY, trainK, trainG, lambda = 0.01)

# Predictions for new targets on drugs in model
predict(mod, testK)
# Predictions for new drugs on targets in model
predict(mod, g = testG)
# Predictions for new drugs and targets
predict(mod, testK, testG)

</code></pre>

<hr>
<h2 id='proteinInteraction'>Protein interaction for yeast</h2><span id='topic+proteinInteraction'></span><span id='topic+Kmat_y2h_sc'></span>

<h3>Description</h3>

<p>A dataset for examining the interaction between proteins of
yeast. The dataset consists of the following objects:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proteinInteraction
</code></pre>


<h3>Format</h3>


<ul>
<li><p> proteinInteraction: a numeric square matrix with 150 rows/columns
</p>
</li>
<li><p> Kmat_y2h_sc: a numeric square matrix with 150 rows/columns
</p>
</li></ul>


<h3>Details</h3>


<ul>
<li><p> proteinInteraction: the label matrix based on the protein
network taken from the KEGG/PATHWAY database
</p>
</li>
<li><p> Kmat_y2h_sc: a kernel matrix indicating similarity of proteins.
</p>
</li></ul>

<p>The proteins in the dataset are a subset of the 769 proteins
used in Yamanishi et al (2004). The kernel matrix used is the
combination of 4 kernels: one based on expression data, one
on protein interaction data, one on localization data and one
on phylogenetic profile. These kernels and their combination are
also explained in Yamanishi et al (2004).
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1093/bioinformatics/bth910">https://doi.org/10.1093/bioinformatics/bth910</a>
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1093/bioinformatics/bth910">Yamanishi et al, 2004</a>: Protein network inference from multiple genomic data: a supervised approach.
</p>

<hr>
<h2 id='residuals'>calculate residuals from a tskrr model</h2><span id='topic+residuals'></span><span id='topic+residuals.tskrr'></span><span id='topic+residuals+2Ctskrr-method'></span>

<h3>Description</h3>

<p>This function returns the residuals for
an object inheriting from class <code><a href="#topic+tskrr-class">tskrr</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals(object, ...)

## S3 method for class 'tskrr'
residuals(
  object,
  method = c("predictions", "loo"),
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE,
  ...
)

## S4 method for signature 'tskrr'
residuals(
  object,
  method = c("predictions", "loo"),
  exclusion = c("interaction", "row", "column", "both"),
  replaceby0 = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>a tskrr model</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>arguments passed from/to other methods.</p>
</td></tr>
<tr><td><code id="residuals_+3A_method">method</code></td>
<td>
<p>a character value indicating whether the
residuals should be based on the predictions or on a
leave-one-out crossvalidation.</p>
</td></tr>
<tr><td><code id="residuals_+3A_exclusion">exclusion</code></td>
<td>
<p>a character value with possible values &quot;interaction&quot;,
&quot;row&quot;, &quot;column&quot;, &quot;both&quot; for heterogeneous models, and &quot;edges&quot;, &quot;vertices&quot;,
&quot;interaction&quot; or &quot;both&quot; for homogeneous models.
Defaults to &quot;interaction&quot;. See details.</p>
</td></tr>
<tr><td><code id="residuals_+3A_replaceby0">replaceby0</code></td>
<td>
<p>a logical value indicating whether the interaction
should be simply removed (<code>FALSE</code>) or replaced by 0 (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>exclusion</code> defines what is left out.
The value &quot;interaction&quot; means that a single interaction is removed.
In the case of a homogeneous model, this can be interpreted as the
removal of the interaction between two edges. The values &quot;row&quot; and
&quot;column&quot; mean that all interactions for a row edge resp. a column
edge are removed. The value &quot;both&quot; removes all interactions for
a row and a column edge.
</p>
<p>In the case of a homogeneous model, &quot;row&quot; and &quot;column&quot; don't make sense
and will be replaced by &quot;both&quot; with a warning. This can be interpreted
as removing vertices, i.e. all interactions between one edge and
all other edges. Alternatively one can use &quot;edges&quot; to remove edges and
&quot;vertices&quot; to remove vertices. In the case of a homogeneous model,
the setting &quot;edges&quot; translates to &quot;interaction&quot;, and &quot;vertices&quot;
translates to &quot;both&quot;. For more information, see Stock et al. (2018).
</p>
<p>Replacing by 0 only makes sense when <code>exclusion = "interaction"</code> and the
label matrix contains only 0 and 1 values. The function checks whether
the conditions are fulfilled and if not, returns an error.
</p>


<h3>Value</h3>

<p>a matrix(!) with the requested residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)
mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim,
             lambda = c(0.01,0.01))
delta &lt;- response(mod) - loo(mod, exclusion = "both")
resid &lt;- residuals(mod, method = "loo", exclusion = "both")
all.equal(delta, resid)

</code></pre>

<hr>
<h2 id='response+2Ctskrr-method'>Getters for tskrr objects</h2><span id='topic+response+2Ctskrr-method'></span><span id='topic+response'></span><span id='topic+lambda+2CtskrrHomogeneous-method'></span><span id='topic+lambda+2CtskrrHeterogeneous-method'></span><span id='topic+lambda'></span><span id='topic+is_tskrr'></span><span id='topic+is_homogeneous'></span><span id='topic+is_heterogeneous'></span><span id='topic+symmetry'></span><span id='topic+get_eigen'></span><span id='topic+get_kernelmatrix'></span><span id='topic+has_hat'></span><span id='topic+get_kernel'></span>

<h3>Description</h3>

<p>The functions described here are convenience functions to get
information out of a <code><a href="#topic+tskrr-class">tskrr</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tskrr'
response(x, ...)

## S4 method for signature 'tskrrHomogeneous'
lambda(x)

## S4 method for signature 'tskrrHeterogeneous'
lambda(x)

is_tskrr(x)

is_homogeneous(x)

is_heterogeneous(x)

symmetry(x)

get_eigen(x, which = c("row", "column"))

get_kernelmatrix(x, which = c("row", "column"))

has_hat(x)

get_kernel(x, which = c("row", "column"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="response+2B2Ctskrr-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+tskrr-class">tskrr</a></code> object or an
object inheriting from <code>tskrr</code>.</p>
</td></tr>
<tr><td><code id="response+2B2Ctskrr-method_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="response+2B2Ctskrr-method_+3A_which">which</code></td>
<td>
<p>a character value indicating whether the eigen decomposition
for the row kernel matrix or the column kernel matrix should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>response</code>: the original label matrix
</p>
<p>For <code>lambda</code>: a named numeric vector with one resp both lambda
values used in the model. The names are &quot;k&quot; and &quot;g&quot; respectively.
</p>
<p>For <code>is_tskrr</code> a logical value indicating whether the
object is a <code>tskrr</code> object
</p>
<p>For <code>is_homogeneous</code> a logical value indicating whether the
tskrr model is a homogeneous one.
</p>
<p>For <code>is_heterogeneous</code> a logical value indicating whether the
tskrr model is a heterogeneous one.
</p>
<p>For <code>symmetry</code> a character value indicating the symmetry
for a <code><a href="#topic+tskrrHomogeneous-class">homogeneous model</a></code>. If
the model is not homogeneous, <code>NA</code> is returned.
</p>
<p>For <code>get_eigen</code> the eigen decomposition of the requested
kernel matrix.
</p>
<p>For <code>get_kernelmatrix</code> the original kernel matrix
for the rows or columns.
</p>
<p>For <code>has_hat</code> a logical value indicating whether
the tskrr model contains the kernel hat matrices.
</p>


<h3>Warning</h3>

<p>The function <code>get_kernel</code> is deprecated.
Use <code>get_kernelmatrix</code> instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)
is_homogeneous(mod)

EigR &lt;- get_eigen(mod)
EigC &lt;- get_eigen(mod, which = 'column')
lambda(mod)

</code></pre>

<hr>
<h2 id='test_symmetry'>test the symmetry of a matrix</h2><span id='topic+test_symmetry'></span>

<h3>Description</h3>

<p>This function tells you whether a matrix is symmetric,
skewed symmetric, or not symmetric. It's used by <code><a href="#topic+tskrr">tskrr</a></code>
to determine which kind of homologous network is represented by
the label matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_symmetry(x, tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_symmetry_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="test_symmetry_+3A_tol">tol</code></td>
<td>
<p>a single numeric value with the tolerance for comparison</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character value with the possible values &quot;symmetric&quot;,
&quot;skewed&quot; or &quot;none&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tskrrHomogeneous">tskrrHomogeneous</a></code> for
more information on the values for the slot <code>symmetry</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(c(1,0,0,1),ncol = 2)
test_symmetry(mat1)
mat2 &lt;- matrix(c(1,0,0,-1), ncol = 2)
test_symmetry(mat2)
mat3 &lt;- matrix(1:4, ncol = 2)
test_symmetry(mat3)

</code></pre>

<hr>
<h2 id='tskrr'>Fitting a two step kernel ridge regression</h2><span id='topic+tskrr'></span>

<h3>Description</h3>

<p><code>tskrr</code> is the primary function for fitting a two-step kernel
ridge regression model. It can be used for both homogeneous and heterogeneous
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tskrr(
  y,
  k,
  g = NULL,
  lambda = 1e-04,
  testdim = TRUE,
  testlabels = TRUE,
  symmetry = c("auto", "symmetric", "skewed"),
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tskrr_+3A_y">y</code></td>
<td>
<p>a label matrix</p>
</td></tr>
<tr><td><code id="tskrr_+3A_k">k</code></td>
<td>
<p>a kernel matrix for the rows</p>
</td></tr>
<tr><td><code id="tskrr_+3A_g">g</code></td>
<td>
<p>an optional kernel matrix for the columns</p>
</td></tr>
<tr><td><code id="tskrr_+3A_lambda">lambda</code></td>
<td>
<p>a numeric vector with one or two values for the
hyperparameter lambda. If two values are given, the first one is
used for the k matrix and the second for the g matrix.</p>
</td></tr>
<tr><td><code id="tskrr_+3A_testdim">testdim</code></td>
<td>
<p>a logical value indicating whether symmetry
and the dimensions of the kernel(s) should be tested.
Defaults to <code>TRUE</code>, but for large matrices
putting this to <code>FALSE</code> will speed up the function.</p>
</td></tr>
<tr><td><code id="tskrr_+3A_testlabels">testlabels</code></td>
<td>
<p>a logical value indicating wether the row- and column
names of the matrices have to be checked for consistency. Defaults to
<code>TRUE</code>, but for large matrices putting this to <code>FALSE</code> will
speed up the function.</p>
</td></tr>
<tr><td><code id="tskrr_+3A_symmetry">symmetry</code></td>
<td>
<p>a character value with the possibilities
&quot;auto&quot;, &quot;symmetric&quot; or &quot;skewed&quot;. In case of a homogeneous fit, you
can either specify whether the label matrix is symmetric or
skewed, or you can let the function decide (option &quot;auto&quot;).</p>
</td></tr>
<tr><td><code id="tskrr_+3A_keep">keep</code></td>
<td>
<p>a logical value indicating whether the kernel hat
matrices should be stored in the model object. Doing so makes the
model object quite larger, but can speed up predictions in
some cases. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+tskrr-class">tskrr</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+response">response</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="#topic+get_eigen">get_eigen</a></code>, <code><a href="#topic+eigen2hat">eigen2hat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Heterogeneous network

data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)

Y &lt;- response(mod)
pred &lt;- fitted(mod)

# Homogeneous network

data(proteinInteraction)

modh &lt;- tskrr(proteinInteraction, Kmat_y2h_sc)

Yh &lt;- response(modh)
pred &lt;- fitted(modh)

</code></pre>

<hr>
<h2 id='tskrr-class'>Class tskrr</h2><span id='topic+tskrr-class'></span>

<h3>Description</h3>

<p>The class tskrr represents a two step kernel ridge regression fitting
object, and is normally generated by the function <code><a href="#topic+tskrr">tskrr</a></code>.
This is a superclass so it should not be instantiated directly.
</p>


<h3>Slots</h3>


<dl>
<dt><code>y</code></dt><dd><p>the matrix with responses</p>
</dd>
<dt><code>k</code></dt><dd><p>the eigen decomposition of the kernel matrix for the rows</p>
</dd>
<dt><code>lambda.k</code></dt><dd><p>the lambda value used for k</p>
</dd>
<dt><code>pred</code></dt><dd><p>the matrix with the predictions</p>
</dd>
<dt><code>has.hat</code></dt><dd><p>a logical value indicating whether the kernel hat matrices
are stored in the object.</p>
</dd>
<dt><code>Hk</code></dt><dd><p>the kernel hat matrix for the rows.</p>
</dd>
<dt><code>labels</code></dt><dd><p>a list with two character vectors, <code>k</code> and
<code>g</code>, containing the labels for the rows resp. columns. See
<code><a href="#topic+tskrrHomogeneous">tskrrHomogeneous</a></code> and
<code><a href="#topic+tskrrHeterogeneous">tskrrHeterogeneous</a></code> for more details.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>the classes <code><a href="#topic+tskrrHomogeneous">tskrrHomogeneous</a></code> and
<code><a href="#topic+tskrrHeterogeneous">tskrrHeterogeneous</a></code> for the actual classes.
</p>

<hr>
<h2 id='tskrr.fit'>Carry out a two-step kernel ridge regression</h2><span id='topic+tskrr.fit'></span>

<h3>Description</h3>

<p>This function provides an interface for two-step kernel ridge regression.
To use this function, you need at least one kernel matrix and one
label matrix. It's the internal engine used by the function
<code><a href="#topic+tskrr">tskrr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tskrr.fit(y, k, g = NULL, lambda.k = NULL, lambda.g = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tskrr.fit_+3A_y">y</code></td>
<td>
<p>a matrix representing the links between the nodes of both
networks.</p>
</td></tr>
<tr><td><code id="tskrr.fit_+3A_k">k</code></td>
<td>
<p>an object of class <code><a href="base.html#topic+eigen">eigen</a></code> containing the eigen
decomposition of the first kernel matrix.</p>
</td></tr>
<tr><td><code id="tskrr.fit_+3A_g">g</code></td>
<td>
<p>an optional object of class <code><a href="base.html#topic+eigen">eigen</a></code> containing
the eigen decomposition of the second kernel matrix. If <code>NULL</code>,
the network is considered to be homogeneous.</p>
</td></tr>
<tr><td><code id="tskrr.fit_+3A_lambda.k">lambda.k</code></td>
<td>
<p>a numeric value for the lambda parameter tied
to the first kernel.</p>
</td></tr>
<tr><td><code id="tskrr.fit_+3A_lambda.g">lambda.g</code></td>
<td>
<p>a numeric value for the lambda parameter tied
to the second kernel. If <code>NULL</code>, the model is fit using the same
value for <code>lambda.k</code> and <code>lambda.g</code></p>
</td></tr>
<tr><td><code id="tskrr.fit_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly available for internal use. In most cases, it
makes much more sense to use <code><a href="#topic+tskrr">tskrr</a></code>, as that function
returns an object one can work with. The function
<code>tskrr.fit</code> could be useful when doing simulations or
fitting algorithms, as the information returned from this function
is enough to use the functions returned by <code><a href="#topic+get_loo_fun">get_loo_fun</a></code>.
</p>


<h3>Value</h3>

<p>a list with three elements:
</p>

<ul>
<li><p> k : the hat matrix for the rows
</p>
</li>
<li><p> g : the hat matrix for the columns (or <code>NULL</code>)
for homogeneous networks.
</p>
</li>
<li><p> pred : the predictions
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(drugtarget)

K &lt;- eigen(targetSim)
G &lt;- eigen(drugSim)

res &lt;- tskrr.fit(drugTargetInteraction,K,G,
                 lambda.k = 0.01, lambda.g = 0.05)

</code></pre>

<hr>
<h2 id='tskrrHeterogeneous-class'>Class tskrrHeterogeneous</h2><span id='topic+tskrrHeterogeneous-class'></span><span id='topic+tskrrHeterogeneous'></span>

<h3>Description</h3>

<p>The class tskrrHeterogeneous is a subclass of the superclass
<code><a href="#topic+tskrr-class">tskrr</a></code> specifically for
heterogeneous networks.
</p>


<h3>Slots</h3>


<dl>
<dt><code>y</code></dt><dd><p>the matrix with responses</p>
</dd>
<dt><code>k</code></dt><dd><p>the eigen decomposition of the kernel matrix for the rows</p>
</dd>
<dt><code>lambda.k</code></dt><dd><p>the lambda value used for k</p>
</dd>
<dt><code>pred</code></dt><dd><p>the matrix with the predictions</p>
</dd>
<dt><code>g</code></dt><dd><p>the eigen decomposition of the kernel matrix for the columns</p>
</dd>
<dt><code>lambda.g</code></dt><dd><p>the lambda value used for g</p>
</dd>
<dt><code>has.hat</code></dt><dd><p>a logical value indicating whether the kernel hat matrices
are stored in the object.</p>
</dd>
<dt><code>Hk</code></dt><dd><p>the kernel hat matrix for the rows.</p>
</dd>
<dt><code>Hg</code></dt><dd><p>the kernel hat matrix for the columns.</p>
</dd>
<dt><code>labels</code></dt><dd><p>a list with elements <code>k</code> and <code>g</code> (see
<code><a href="#topic+tskrr-class">tskrr-class</a></code>).
If any element is <code>NA</code>, the labels used
are integers indicating the row resp column number.</p>
</dd>
</dl>

<hr>
<h2 id='tskrrHomogeneous-class'>Class tskrrHomogeneous</h2><span id='topic+tskrrHomogeneous-class'></span><span id='topic+tskrrHomogeneous'></span>

<h3>Description</h3>

<p>The class tskrrHomogeneous is a subclass of the superclass
<code><a href="#topic+tskrr-class">tskrr</a></code> specifically for
homogeneous networks.
</p>


<h3>Slots</h3>


<dl>
<dt><code>y</code></dt><dd><p>the matrix with responses</p>
</dd>
<dt><code>k</code></dt><dd><p>the eigen decomposition of the kernel matrix for the rows</p>
</dd>
<dt><code>lambda.k</code></dt><dd><p>the lambda value used for k</p>
</dd>
<dt><code>pred</code></dt><dd><p>the matrix with the predictions</p>
</dd>
<dt><code>symmetry</code></dt><dd><p>a character value that can have the possible values
<code>"symmetric"</code>, <code>"skewed"</code> or <code>"not"</code>. It indicates
whether the <code>y</code> matrix is symmetric, skewed-symmetric or not
symmetric.</p>
</dd>
<dt><code>has.hat</code></dt><dd><p>a logical value indicating whether the kernel hat matrices
are stored in the object.</p>
</dd>
<dt><code>Hk</code></dt><dd><p>the kernel hat matrix for the rows.</p>
</dd>
<dt><code>labels</code></dt><dd><p>a list with elements <code>k</code> and <code>g</code> (see
<code><a href="#topic+tskrr-class">tskrr-class</a></code>). For homogeneous networks, <code>g</code>
is always <code>NA</code>. If <code>k</code> is <code>NA</code>, the labels used
are integers indicating the row resp column number.</p>
</dd>
</dl>

<hr>
<h2 id='tskrrImpute-class'>Class tskrrImpute</h2><span id='topic+tskrrImpute-class'></span><span id='topic+tskrrImpute'></span>

<h3>Description</h3>

<p>The class <code>tskrrImpute</code> is a virtual class that represents a
<code><a href="#topic+tskrr-class">tskrr</a></code> model with imputed values in
the label matrix Y. Apart from the model, it contains the
following extra information on the imputed values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>imputeid</code></dt><dd><p>a vector with integer values indicating which of
the values in <code>y</code> are imputed</p>
</dd>
<dt><code>niter</code></dt><dd><p>an integer value gving the number of iterations used</p>
</dd>
<dt><code>tol</code></dt><dd><p>a numeric value with the tolerance used</p>
</dd>
</dl>

<hr>
<h2 id='tskrrImputeHeterogeneous-class'>Class tskrrImputeHeterogeneous</h2><span id='topic+tskrrImputeHeterogeneous-class'></span><span id='topic+tskrrImputeHeterogeneous'></span>

<h3>Description</h3>

<p>The class <code>tskrrImputeHeterogeneous</code> is a subclass of the
class <code><a href="#topic+tskrrHeterogeneous-class">tskrrHeterogeneous</a></code> and
<code><a href="#topic+tskrrImpute-class">tskrrImpute</a></code>
specifically for heterogeneous networks with imputed values. It is
the result of the function <code><a href="#topic+impute_tskrr">impute_tskrr</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>y</code></dt><dd><p>the matrix with responses</p>
</dd>
<dt><code>k</code></dt><dd><p>the eigen decomposition of the kernel matrix for the rows</p>
</dd>
<dt><code>lambda.k</code></dt><dd><p>the lambda value used for k</p>
</dd>
<dt><code>pred</code></dt><dd><p>the matrix with the predictions</p>
</dd>
<dt><code>g</code></dt><dd><p>the eigen decomposition of the kernel matrix for the columns</p>
</dd>
<dt><code>lambda.g</code></dt><dd><p>the lambda value used for g</p>
</dd>
<dt><code>has.hat</code></dt><dd><p>a logical value indicating whether the kernel hat matrices
are stored in the object.</p>
</dd>
<dt><code>Hk</code></dt><dd><p>the kernel hat matrix for the rows.</p>
</dd>
<dt><code>Hg</code></dt><dd><p>the kernel hat matrix for the columns.</p>
</dd>
<dt><code>labels</code></dt><dd><p>a list with elements <code>k</code> and <code>g</code> (see
<code><a href="#topic+tskrr-class">tskrr-class</a></code>).
If any element is <code>NA</code>, the labels used
are integers indicating the row resp column number.</p>
</dd>
<dt><code>imputeid</code></dt><dd><p>a vector with integer values indicating which of
the values in <code>y</code> are imputed</p>
</dd>
<dt><code>niter</code></dt><dd><p>an integer value gving the number of iterations used</p>
</dd>
<dt><code>tol</code></dt><dd><p>a numeric value with the tolerance used</p>
</dd>
</dl>

<hr>
<h2 id='tskrrImputeHomogeneous-class'>Class tskrrImputeHomogeneous</h2><span id='topic+tskrrImputeHomogeneous-class'></span><span id='topic+tskrrImputeHomogeneous'></span>

<h3>Description</h3>

<p>The class <code>tskrrImputeHomogeneous</code> is a subclass of the
class <code><a href="#topic+tskrrHomogeneous-class">tskrrHomogeneous</a></code> and
<code><a href="#topic+tskrrImpute-class">tskrrImpute</a></code>
specifically for homogeneous networks with imputed values. It is
the result of the function <code><a href="#topic+impute_tskrr">impute_tskrr</a></code> on a
homogeneous network model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>y</code></dt><dd><p>the matrix with responses</p>
</dd>
<dt><code>k</code></dt><dd><p>the eigen decomposition of the kernel matrix for the rows</p>
</dd>
<dt><code>lambda.k</code></dt><dd><p>the lambda value used for k</p>
</dd>
<dt><code>pred</code></dt><dd><p>the matrix with the predictions</p>
</dd>
<dt><code>symmetry</code></dt><dd><p>a character value that can have the possible values
<code>"symmetric"</code>, <code>"skewed"</code> or <code>"not"</code>. It indicates
whether the <code>y</code> matrix is symmetric, skewed-symmetric or not
symmetric.</p>
</dd>
<dt><code>has.hat</code></dt><dd><p>a logical value indicating whether the kernel hat matrices
are stored in the object.</p>
</dd>
<dt><code>Hk</code></dt><dd><p>the kernel hat matrix for the rows.</p>
</dd>
<dt><code>labels</code></dt><dd><p>a list with elements <code>k</code> and <code>g</code> (see
<code><a href="#topic+tskrr-class">tskrr-class</a></code>). For homogeneous networks, <code>g</code>
is always <code>NA</code>. If <code>k</code> is <code>NA</code>, the labels used
are integers indicating the row resp column number.</p>
</dd>
<dt><code>imputeid</code></dt><dd><p>a vector with integer values indicating which of
the values in <code>y</code> are imputed</p>
</dd>
<dt><code>niter</code></dt><dd><p>an integer value gving the number of iterations used</p>
</dd>
<dt><code>tol</code></dt><dd><p>a numeric value with the tolerance used</p>
</dd>
</dl>

<hr>
<h2 id='tskrrTune-class'>Class tskrrTune</h2><span id='topic+tskrrTune-class'></span><span id='topic+tskrrTune'></span>

<h3>Description</h3>

<p>The class tskrrTune represents a tuned <code><a href="#topic+tskrr-class">tskrr</a></code>
model, and is the output of the function <code><a href="#topic+tune">tune</a></code>. Apart from
the model, it contains extra information on the tuning procedure. This is
a virtual class only.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lambda_grid</code></dt><dd><p>a list object with the elements <code>k</code> and possibly
<code>g</code> indicating the tested lambda values for the row kernel <code>K</code>
and - if applicable - the column kernel <code>G</code>. Both elements have
to be numeric.</p>
</dd>
<dt><code>best_loss</code></dt><dd><p>a numeric value with the loss associated with the
best lambdas</p>
</dd>
<dt><code>loss_values</code></dt><dd><p>a matrix with the loss results from the searched grid.
The rows form the X dimension (related to the first lambda), the columns
form the Y dimension (related to the second lambda if applicable)</p>
</dd>
<dt><code>loss_function</code></dt><dd><p>the used loss function</p>
</dd>
<dt><code>exclusion</code></dt><dd><p>a character value describing the exclusion used</p>
</dd>
<dt><code>replaceby0</code></dt><dd><p>a logical value indicating whether or not the cross
validation replaced the excluded values by zero</p>
</dd>
<dt><code>onedim</code></dt><dd><p>a logical value indicating whether the grid search
was done in one dimension. For homogeneous networks, this is
true by default.</p>
</dd>
</dl>


<h3>See Also</h3>


<ul>
<li><p> the function <code>tune</code> for the tuning itself
</p>
</li>
<li><p> the class <code><a href="#topic+tskrrTuneHomogeneous">tskrrTuneHomogeneous</a></code> and
<code>tskrrTuneHeterogeneous</code> for the actual classes.
</p>
</li></ul>


<hr>
<h2 id='tskrrTuneHeterogeneous-class'>Class tskrrTuneHeterogeneous</h2><span id='topic+tskrrTuneHeterogeneous-class'></span><span id='topic+tskrrTuneHeterogeneous'></span>

<h3>Description</h3>

<p>The class tskrrTuneHeterogeneous represents a tuned Heterogeneous
<code><a href="#topic+tskrr-class">tskrr</a></code> model. It inherits from
the classes <code><a href="#topic+tskrrHeterogeneous-class">tskrrHeterogeneous</a></code>
and <code><a href="#topic+tskrrTune-class">tskrrTune</a></code>.
</p>

<hr>
<h2 id='tskrrTuneHomogeneous-class'>Class tskrrTuneHomogeneous</h2><span id='topic+tskrrTuneHomogeneous-class'></span><span id='topic+tskrrTuneHomogeneous'></span>

<h3>Description</h3>

<p>The class tskrrTuneHomogeneous represents a tuned homogeneous
<code><a href="#topic+tskrr-class">tskrr</a></code> model. It inherits from
the classes <code><a href="#topic+tskrrHomogeneous-class">tskrrHomogeneous</a></code>
and <code><a href="#topic+tskrrTune-class">tskrrTune</a></code>.
</p>

<hr>
<h2 id='tune'>tune the lambda parameters for a tskrr</h2><span id='topic+tune'></span><span id='topic+tune+2CtskrrHomogeneous-method'></span><span id='topic+tune+2CtskrrHeterogeneous-method'></span><span id='topic+tune+2Cmatrix-method'></span>

<h3>Description</h3>

<p>This function lets you tune the lambda parameter(s) of a two-step
kernel ridge regression model for optimal performance. You can either
tune a previously fitted <code><a href="#topic+tskrr">tskrr</a></code> model, or pass the
label matrix and kernel matrices to fit and tune a model in
one go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tskrrHomogeneous'
tune(
  x,
  lim = c(1e-04, 1),
  ngrid = 10,
  lambda = NULL,
  fun = loss_mse,
  exclusion = "edges",
  replaceby0 = FALSE,
  onedim = TRUE,
  ...
)

## S4 method for signature 'tskrrHeterogeneous'
tune(
  x,
  lim = c(1e-04, 1),
  ngrid = 10,
  lambda = NULL,
  fun = loss_mse,
  exclusion = "interaction",
  replaceby0 = FALSE,
  onedim = FALSE,
  ...
)

## S4 method for signature 'matrix'
tune(
  x,
  k,
  g = NULL,
  lim = c(1e-04, 1),
  ngrid = 10,
  lambda = NULL,
  fun = loss_mse,
  exclusion = "interaction",
  replaceby0 = FALSE,
  testdim = TRUE,
  testlabels = TRUE,
  symmetry = c("auto", "symmetric", "skewed"),
  keep = FALSE,
  onedim = is.null(g),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tune_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+tskrr">tskrr</a></code> object representing a two step
kernel ridge regression model.</p>
</td></tr>
<tr><td><code id="tune_+3A_lim">lim</code></td>
<td>
<p>a vector with 2 values that give the boundaries for the domain
in which lambda is searched, or possibly a list with 2 elements. See details</p>
</td></tr>
<tr><td><code id="tune_+3A_ngrid">ngrid</code></td>
<td>
<p>a single numeric value giving the number of points
in a single dimension of the grid, or possibly a list with 2 elements.
See details.</p>
</td></tr>
<tr><td><code id="tune_+3A_lambda">lambda</code></td>
<td>
<p>a vector with the lambdas that need checking for
homogeneous networks, or possibly a list with two elements for
heterogeneous networks. See Details. Defaults to
<code>NULL</code>, which means that the function constructs the search grid
from the other arguments.</p>
</td></tr>
<tr><td><code id="tune_+3A_fun">fun</code></td>
<td>
<p>a loss function that takes the label matrix Y and the
result of the crossvalidation LOO as input. The function name can
be passed as a character string as well.</p>
</td></tr>
<tr><td><code id="tune_+3A_exclusion">exclusion</code></td>
<td>
<p>a character value with possible values &quot;interaction&quot;,
&quot;row&quot;, &quot;column&quot;, &quot;both&quot; for heterogeneous models, and &quot;edges&quot;, &quot;vertices&quot;,
&quot;interaction&quot; or &quot;both&quot; for homogeneous models.
Defaults to &quot;interaction&quot;. See details.</p>
</td></tr>
<tr><td><code id="tune_+3A_replaceby0">replaceby0</code></td>
<td>
<p>a logical value indicating whether the interaction
should be simply removed (<code>FALSE</code>) or replaced by 0 (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="tune_+3A_onedim">onedim</code></td>
<td>
<p>a logical value indicating whether the search should be
done in a single dimension. See details.</p>
</td></tr>
<tr><td><code id="tune_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the loss function</p>
</td></tr>
<tr><td><code id="tune_+3A_k">k</code></td>
<td>
<p>a kernel matrix for the rows</p>
</td></tr>
<tr><td><code id="tune_+3A_g">g</code></td>
<td>
<p>an optional kernel matrix for the columns</p>
</td></tr>
<tr><td><code id="tune_+3A_testdim">testdim</code></td>
<td>
<p>a logical value indicating whether symmetry
and the dimensions of the kernel(s) should be tested.
Defaults to <code>TRUE</code>, but for large matrices
putting this to <code>FALSE</code> will speed up the function.</p>
</td></tr>
<tr><td><code id="tune_+3A_testlabels">testlabels</code></td>
<td>
<p>a logical value indicating wether the row- and column
names of the matrices have to be checked for consistency. Defaults to
<code>TRUE</code>, but for large matrices putting this to <code>FALSE</code> will
speed up the function.</p>
</td></tr>
<tr><td><code id="tune_+3A_symmetry">symmetry</code></td>
<td>
<p>a character value with the possibilities
&quot;auto&quot;, &quot;symmetric&quot; or &quot;skewed&quot;. In case of a homogeneous fit, you
can either specify whether the label matrix is symmetric or
skewed, or you can let the function decide (option &quot;auto&quot;).</p>
</td></tr>
<tr><td><code id="tune_+3A_keep">keep</code></td>
<td>
<p>a logical value indicating whether the kernel hat
matrices should be stored in the model object. Doing so makes the
model object quite larger, but can speed up predictions in
some cases. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function currently only performs a simple grid search for all
(combinations of) lambda values. If no specific lambda values are
provided, then the function uses <code><a href="#topic+create_grid">create_grid</a></code> to
create an evenly spaced (on a logarithmic scale) grid.
</p>
<p>In the case of a heterogeneous network, you can specify different values
for the two parameters that need tuning. To do so, you need to
provide a list with the settings for every parameter to the arguments
<code>lim</code>, <code>ngrid</code> and/or <code>lambda</code>. If you
try this for a homogeneous network, the function will return an error.
</p>
<p>Alternatively, you can speed up the grid search by searching in a
single dimension. When <code>onedim = TRUE</code>, the search for a
heterogeneous network will only consider cases where both lambda values
are equal.
</p>
<p>The arguments <code>exclusion</code> and <code>replaceby0</code> are used by
the function <code><a href="#topic+get_loo_fun">get_loo_fun</a></code> to find the correct
leave-one-out function.
</p>
<p>By default, the function uses standard mean squared error based on
the cross-validation results as a measure for optimization. However, you
can provide a custom function if needed, as long as it takes
two matrices as input: <code>Y</code> being the observed interactions and
<code>LOO</code> being the result of the chosen cross-validation.
</p>


<h3>Value</h3>

<p>a model of class <code><a href="#topic+tskrrTune-class">tskrrTune</a></code>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+loo">loo</a></code>, <code><a href="#topic+loo_internal">loo_internal</a></code> and
<code><a href="#topic+get_loo_fun">get_loo_fun</a></code> for more information on how leave one out
validation works.
</p>
</li>
<li> <p><code><a href="#topic+tskrr">tskrr</a></code> for fitting a twostep kernel ridge regression.
</p>
</li>
<li> <p><code><a href="#topic+loss_functions">loss_functions</a></code> for different loss functions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)
tuned &lt;- tune(mod, lim = c(0.1,1), ngrid = list(5,10),
              fun = loss_auc)

## Not run: 

# This is just some visualization of the matrix
# It can be run safely.
gridvals &lt;- get_grid(tuned)
z &lt;- get_loss_values(tuned)        # loss values

image(gridvals$k,gridvals$g,z, log = 'xy',
      xlab = "lambda k", ylab = "lambda g",
      col = rev(heat.colors(20)))


## End(Not run)
</code></pre>

<hr>
<h2 id='update'>Update a tskrr object with a new lambda</h2><span id='topic+update'></span><span id='topic+update+2CtskrrHomogeneous-method'></span><span id='topic+update+2CtskrrHeterogeneous-method'></span>

<h3>Description</h3>

<p>This function allows you to refit a <code><a href="#topic+tskrr">tskrr</a></code> with a
new lambda. It can be used to do manual tuning/cross-validation.
If the object has the hat matrices stored, these are updated
as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update(object, ...)

## S4 method for signature 'tskrrHomogeneous'
update(object, lambda)

## S4 method for signature 'tskrrHeterogeneous'
update(object, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+tskrr-class">tskrr</a></code> object</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="update_+3A_lambda">lambda</code></td>
<td>
<p>a numeric vector with one or two values for the
hyperparameter lambda. If two values are given, the first one is
used for the k matrix and the second for the g matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated <code><a href="#topic+tskrr-class">tskrr</a></code> object
fitted with the new lambdas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drugtarget)

mod &lt;- tskrr(drugTargetInteraction, targetSim, drugSim)

# Update with the same lambda
mod2 &lt;- update(mod, lambda = 1e-3)

# Use different lambda for rows and columns
mod3 &lt;- update(mod, lambda = c(0.01,0.001))

# A model with the hat matrices stored
lambda &lt;- c(0.001,0.01)
modkeep &lt;- tskrr(drugTargetInteraction, targetSim, drugSim, keep = TRUE)
Hk_1 &lt;- hat(modkeep, which = "row")
modkeep2 &lt;- update(modkeep, lambda = lambda)
Hk_2 &lt;- hat(modkeep2, which = "row")

# Calculate new hat matrix by hand:
decomp &lt;- get_eigen(modkeep, which = "row")
Hk_byhand &lt;- eigen2hat(decomp$vectors,
                       decomp$values,
                       lambda = lambda[1])
identical(Hk_2, Hk_byhand)

</code></pre>

<hr>
<h2 id='valid_dimensions'>Functions to check matrices</h2><span id='topic+valid_dimensions'></span><span id='topic+is_square'></span>

<h3>Description</h3>

<p>These functions allow you to check whether the dimensions of the
label matrix and the kernel matrix (matrices) are compatible.
<code>valid_dimensions</code> checks whether both k and g are square matrices,
whether y has as many rows as k and whether y has as many columns as g.
<code>is_square</code> checks whether both dimensions are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_dimensions(y, k, g = NULL)

is_square(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valid_dimensions_+3A_y">y</code></td>
<td>
<p>a label matrix</p>
</td></tr>
<tr><td><code id="valid_dimensions_+3A_k">k</code></td>
<td>
<p>a kernel matrix</p>
</td></tr>
<tr><td><code id="valid_dimensions_+3A_g">g</code></td>
<td>
<p>an optional second kernel matrix or <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code id="valid_dimensions_+3A_x">x</code></td>
<td>
<p>any matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating whether the dimensions of the
matrices are compatible for a two step kernel ridge regression.
</p>


<h3>Note</h3>

<p>The function <code>is_square</code> is not exported
</p>

<hr>
<h2 id='valid_labels'>Test the correctness of the labels.</h2><span id='topic+valid_labels'></span>

<h3>Description</h3>

<p>This function checks whether the labels between the Y, K, and G
matrices make sense. This means that all the labels found as
rownames for <code>y</code> can be found as rownames <em>and</em> column
names of <code>k</code>, and all the colnames for <code>y</code> can be found
as rownames <em>and</em> colnames of <code>g</code> (if provided).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_labels(y, k, g = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valid_labels_+3A_y">y</code></td>
<td>
<p>the label matrix</p>
</td></tr>
<tr><td><code id="valid_labels_+3A_k">k</code></td>
<td>
<p>the kernel matrix for the rows</p>
</td></tr>
<tr><td><code id="valid_labels_+3A_g">g</code></td>
<td>
<p>the kernel matrix for the columns (optional). If not available,
it takes the value <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compatible labels mean that it is unequivocally clear which
rows and columns can be linked throughout the model. In case none
of the matrices have row- or colnames, the labels are considered
compatible. In all other cases, all matrices should have both row
and column names. They should fulfill the following conditions:
</p>

<ul>
<li><p> the row- and column names of a kernel matrix must contain
the same values in the same order. Otherwise, the matrix can't
be symmetric.
</p>
</li>
<li><p> the rownames of <code>y</code> should correspond to the rownames
of <code>k</code>
</p>
</li>
<li><p> the colnames of <code>y</code> should correspond to the colnames
of <code>g</code> if it is supplied, or the colnames of <code>k</code> in
case <code>g</code> is <code>NULL</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code> if all labels are compatible, an error otherwise.
</p>


<h3>Note</h3>

<p>This is a non-exported convenience function.
</p>

<hr>
<h2 id='weights+2CtskrrHeterogeneous-method'>Extract weights from a tskrr model</h2><span id='topic+weights+2CtskrrHeterogeneous-method'></span><span id='topic+weights'></span><span id='topic+weights+2CtskrrHomogeneous-method'></span>

<h3>Description</h3>

<p>This function calculates the weight matrix for
calculating the predictions of a tskrr model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tskrrHeterogeneous'
weights(object)

## S4 method for signature 'tskrrHomogeneous'
weights(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights+2B2CtskrrHeterogeneous-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+tskrr">tskrr</a></code> object for which the weights
have to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weight matrix is calculated from the map matrices through the
function <code><a href="#topic+eigen2map">eigen2map</a></code>.
</p>


<h3>Value</h3>

<p>a matrix with the weights for the tskrr model.
</p>


<h3>Note</h3>

<p>The package <code>xnet</code> adds a S4 generic function
for <code><a href="stats.html#topic+weights">weights</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
