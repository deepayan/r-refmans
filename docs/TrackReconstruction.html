<!DOCTYPE html><html lang="en"><head><title>Help for package TrackReconstruction</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TrackReconstruction}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TrackReconstruction-package'>
<p>Reconstruct Animal Tracks from Biologger Data.</p></a></li>
<li><a href='#bathymetry'>
<p>Bathymetry data for the Eastern Bering Sea</p></a></li>
<li><a href='#CalcBearing'>
<p>Calculate Bearing</p></a></li>
<li><a href='#CalcDistance'>
<p>Calculate Distance Between Two Points</p></a></li>
<li><a href='#CalcLatitude'>
<p>Calculate Latitude</p></a></li>
<li><a href='#CalcLongitude'>
<p>Calculate Longitude</p></a></li>
<li><a href='#DeadReckoning'>
<p>Calculates Dead Reckoning</p></a></li>
<li><a href='#GapFinder'>
<p>Find gaps in your data file</p></a></li>
<li><a href='#GeoRef'>
<p>Georeference the Dead Reckoning data</p></a></li>
<li><a href='#georef1min01'>
<p>GeoReferenced fur seal track</p></a></li>
<li><a href='#georef1min02'>
<p>GeoReferenced fur seal track</p></a></li>
<li><a href='#georef1min03'>
<p>GeoReferenced fur seal track</p></a></li>
<li><a href='#georef1min26'>
<p>GeoReferenced fur seal track</p></a></li>
<li><a href='#georef1min95'>
<p>GeoReferenced fur seal track</p></a></li>
<li><a href='#GeoReference'>
<p>Georeference the Dead Reckoning data between two GPS points</p></a></li>
<li><a href='#gpsdata01'>
<p>GPS raw data</p></a></li>
<li><a href='#gpsdata02'>
<p>GPS raw data</p></a></li>
<li><a href='#gpsdata03'>
<p>GPS raw data</p></a></li>
<li><a href='#gpsdata26'>
<p>GPS raw data</p></a></li>
<li><a href='#gpsdata95'>
<p>GPS raw data</p></a></li>
<li><a href='#GPStable'>
<p>Format GPS data</p></a></li>
<li><a href='#GraphLimits'>
<p>Determine Latitude and Longitude limits of a graph</p></a></li>
<li><a href='#Mapper'>
<p>Animal track plotting with a color map</p></a></li>
<li><a href='#rawdata'>
<p>Raw triaxial magnetomater and accelerometer data</p></a></li>
<li><a href='#rawdatagap'>
<p>Raw biologger data with a gap</p></a></li>
<li><a href='#Splitter'>
<p>Splits large data files by date and time.</p></a></li>
<li><a href='#square'>
<p>Raw triaxial magnetomater and accelerometer data</p></a></li>
<li><a href='#Standardize'>
<p>Standardize accelerometer and magnetometer data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Reconstruct Animal Tracks from Magnetometer, Accelerometer,
Depth and Optional Speed Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian Battaile</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian Battaile &lt;brian.battaile@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0), fields, RColorBrewer</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, onion, plotrix, rgl, scatterplot3d</td>
</tr>
<tr>
<td>Description:</td>
<td>Reconstructs animal tracks from magnetometer, accelerometer, depth and optional speed data.  Designed primarily using data from Wildlife Computers Daily Diary tags deployed on northern fur seals.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-10 21:17:16 UTC; brianbattaile</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-10 22:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='TrackReconstruction-package'>
Reconstruct Animal Tracks from Biologger Data.  
</h2><span id='topic+TrackReconstruction-package'></span><span id='topic+TrackReconstruction'></span>

<h3>Description</h3>

<p>Given accelerometer, magnetometer, depth and optional speed data, this package will reconstruct animal paths.  Given GPS data, 
pseudotracks can be geolocated.  The package was designed using northern fur seals (<code>Callorhinus ursinus</code>) but is probably suitable as a launching 
pad for other animals.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> TrackReconstruction</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-12-10</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Includes functions to Standardize logger data, format GPS data, find gaps in the raw data, navigation functions to 
calculate distance, bearing, latitude and longitude, functions to calculate pseudotracks, to georeference the tracks
and finally to plot the tracks with color bathymetry.  A vignette includes some additional Perl code to deal with large data files as well
as additional plotting code to make 3D plots and 2D animations.
</p>
<p>DeadReckoning
</p>
<p>GapFinder
</p>
<p>GeoReference
</p>
<p>GeoRef (a wrapper for GeoReference)
</p>
<p>GPStable
</p>
<p>GraphLimits
</p>
<p>Mapper
</p>
<p>Navigation Functions (CalcBearing CalcLatitude CalcLongitude CalcDistance)
</p>
<p>Splitter
</p>
<p>Standardize
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>
<p>Maintainer:Brian Battaile &lt;brian.battaile@gmail.com&gt;
</p>


<h3>References</h3>

<p>Wilson R.P., Liebsch,N., Davies,I.M., Quintana,F., Weimerskirch,H., Storch,S., Lucke,K., Siebert,U., Zankl,S., 
Muller,G., Zimmer,I., Scolaro,A., Campagna,C., Plotz,J., Bornemann,H., Teilmann,J. and Mcmahon,C.R. (2007) 
All at sea with animal tracks; methodological and analytical solutions for the resolution of movement.  
Deep-Sea Research II 54:193-210
</p>
<p>Shepard E.L.C., Wilson, R.P., Halsey, L.G., Quintana, F., Laich, A.G., Gleiss, A.C., Liebsch, N., Myers, A.E., 
Norman, B.  (2008)  Derivation of body motion via appropriate smoothing of acceleration data.  
Aquatic Biology 4:235-241
</p>
<p>Wilson R.P., Wilson M.P. (1988)  Dead reckoning: a new technique for determining penguim movements at sea.
Meeresforschung 32:2 155-158
</p>


<h3>See Also</h3>

<p>R packages diveMove, adehabitat, animalTrack, argosfilter and crawl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>betas&lt;-Standardize(1,1,-1,1,1,1,-57.8,68.76,-61.8,64.2,-70.16,58.08,
	-10.1,9.55,-9.75,9.72, -9.91,9.43)
#get declination and inclination data for study area
decinc&lt;-c(10.228,65.918)
#data set with 6 associated GPS fixes in the "gpsdata" data set
data(rawdata)
DRoutput&lt;-DeadReckoning(rawdata,betas,decinc,Hz=16,RmL=2,DepthHz=1,SpdCalc=3,MaxSpd=3.5)
#prepare GPS data
data(gpsdata02)
gpsformat&lt;-GPStable(gpsdata02)
Georeferenced&lt;-GeoRef(DRoutput,gpsformat)
plot(Georeferenced$Longitude,Georeferenced$Latitude,pch=".")
points(gpsformat$Longitude[2],gpsformat$Latitude[2],pch="S",col="Red") #Start
points(gpsformat$Longitude[7],gpsformat$Latitude[7],pch="F",col="Blue") #Finish
#Intermediate GPS points
points(gpsformat$Longitude[3:6],gpsformat$Latitude[3:6],pch="*",col="Red")

## Not run: 
#plot the data with a bathymetric background, note how the axis dimensions have changed to 
#give a more realistic path relative to that produced in the simple plot call.  See the vignette
#or ?bathymetry for information on how to get bathymetric data for your study area.
data(bathymetry)
#This may take a minute or two
image.xyz=tapply(bathymetry$Depth, list(bathymetry$Long, bathymetry$Lat), unique)
Mapper(Georeferenced, gpsformat[2:7,], image.xyz, ExpFact = 500, minlat = 51, maxlat = 60,
minlong = -177, maxlong = -163, Title = "Fun Graph!!!")
#That entire animals trip plotted
data(georef1min02)
data(gpsdata02)
Mapper(georef1min02, gpsdata02, image.xyz, ExpFact = 500, minlat = 51, maxlat = 60,
minlong = -177, maxlong = -163, Title = "Fun Graph!!!")

## End(Not run)
</code></pre>

<hr>
<h2 id='bathymetry'>
Bathymetry data for the Eastern Bering Sea
</h2><span id='topic+bathymetry'></span>

<h3>Description</h3>

<p>Bathymetry data for the Eastern Bering Sea at a resolution of 30 arc seconds downloaded from http://www.gebco.net
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bathymetry)</code></pre>


<h3>Format</h3>

<p>A data frame with 1814400 observations on the following 3 variables.
</p>

<dl>
<dt><code>Long</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Lat</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>If you want to do color graphing of the tracks within R I have provided a <code>Mapper</code> function to do this but it requires
gridded (raster) bathymetric data to create the background map.  The source for this example data set comes from the General
Bathymetric Chart of the Oceans or GEBCO at <a href="https://www.gebco.net">https://www.gebco.net</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bathymetry)
str(bathymetry)
head(bathymetry);tail(bathymetry)
bathymetryBogs&lt;-subset(bathymetry,Long&lt;=(-166) &amp; Long &gt;=(-169)
	&amp; Lat&lt;= 54.5 &amp; Lat &gt;=53,select=Long:Depth)

image.xyz=tapply(bathymetryBogs$Depth, list(bathymetryBogs$Long, bathymetryBogs$Lat), unique)
#create palette for depth colors
Bathymetry.palette&lt;-colorRampPalette(brewer.pal(9, "Blues"),bias=3)
#Plot the background map image
image.plot(image.xyz,
	col=c(rev(Bathymetry.palette(200)),terrain.colors(100)),#gray(0:20/20),
	breaks=round(c(seq(from=min(image.xyz),to=0,length.out=201),seq(from=max(image.xyz)/101
	,to=max(image.xyz),length.out=100)))
	#,smallplot=2 #plots legend off x axis
	)
## Not run: 
#If you want to map the entire bathymetry file, it takes a while
image.xyz=tapply(bathymetry$Depth, list(bathymetry$Long, bathymetry$Lat), unique)
#create palette for depth colors
Bathymetry.palette&lt;-colorRampPalette(brewer.pal(9, "Blues"),bias=3)
#Plot the background map image
image.plot(image.xyz,
	col=c(rev(Bathymetry.palette(200)),terrain.colors(100)),#gray(0:20/20),
	breaks=round(c(seq(from=min(image.xyz),to=0,length.out=201),seq(from=max(image.xyz)/101
	,to=max(image.xyz),length.out=100)))
	#,smallplot=2 #plots legend off x axis
	)

## End(Not run)
</code></pre>

<hr>
<h2 id='CalcBearing'>
Calculate Bearing
</h2><span id='topic+CalcBearing'></span>

<h3>Description</h3>

<p>Calculates Bearing given initial latitude and longitude and ending latitude and longitude in decimal degrees and returns
bearing in radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcBearing(initialLat, initialLong, finalLat, finalLong)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcBearing_+3A_initiallat">initialLat</code></td>
<td>

<p>initial Latitude
</p>
</td></tr>
<tr><td><code id="CalcBearing_+3A_initiallong">initialLong</code></td>
<td>

<p>initial Longitude
</p>
</td></tr>
<tr><td><code id="CalcBearing_+3A_finallat">finalLat</code></td>
<td>

<p>ending Latitude
</p>
</td></tr>
<tr><td><code id="CalcBearing_+3A_finallong">finalLong</code></td>
<td>

<p>ending Longitude
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data must be provided in decimal degrees (e.g. 162.546).  Longitude values west of the prime meridian are 0 to -180.
Latitude values south of the equator are 0 to -90.  As one travels from point A to point B, the bearing to point B 
changes.  This function calculates the bearing from point A to point B at point A.  This function is primarily used 
internally in the <code>GPStable</code> and <code>GeoReference</code> functions.
</p>


<h3>Value</h3>

<p>Bearing in Radians
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>https://www.movable-type.co.uk/scripts/latlong.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Bearing to Los Angeles from New York
Bearing&lt;-CalcBearing(40.7697,-73.9735,34.0522,-118.2428)
Bearing
Bearing*360/(2*pi) #transform radians to degrees
</code></pre>

<hr>
<h2 id='CalcDistance'>
Calculate Distance Between Two Points
</h2><span id='topic+CalcDistance'></span>

<h3>Description</h3>

<p>Calculates the distance between two points on the globe given latitude and longitude in decimal degrees and returning
distance in kilometers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcDistance(initialLat, initialLong, finalLat, finalLong)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcDistance_+3A_initiallat">initialLat</code></td>
<td>

<p>initial Latitude
</p>
</td></tr>
<tr><td><code id="CalcDistance_+3A_initiallong">initialLong</code></td>
<td>

<p>initial Longitude
</p>
</td></tr>
<tr><td><code id="CalcDistance_+3A_finallat">finalLat</code></td>
<td>

<p>ending Latitude
</p>
</td></tr>
<tr><td><code id="CalcDistance_+3A_finallong">finalLong</code></td>
<td>

<p>ending Longitude
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data must be provided in decimal degrees (e.g. 162.546).  Longitude values west of the prime meridian are 0 to -180.
Latitude values south of the equator are 0 to -90.  This function is primarily used internally in the <code>GPStable</code> and 
<code>GeoReference</code> functions.
</p>


<h3>Value</h3>

<p>Distance in Kilometers
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>https://www.movable-type.co.uk/scripts/latlong.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Distance from New York to Los Angeles given Latitude and Longitude of New York and Los Angeles.
Howfar&lt;-CalcDistance(40.7697,-73.9735,34.0522,-118.2428)
Howfar

</code></pre>

<hr>
<h2 id='CalcLatitude'>
Calculate Latitude
</h2><span id='topic+CalcLatitude'></span>

<h3>Description</h3>

<p>Calculates an unknown latitude given an initial latitude, distance traveled in meters and bearing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcLatitude(initialLat, distance, bearing)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcLatitude_+3A_initiallat">initialLat</code></td>
<td>

<p>initial Latitude
</p>
</td></tr>
<tr><td><code id="CalcLatitude_+3A_distance">distance</code></td>
<td>

<p>distance in meters
</p>
</td></tr>
<tr><td><code id="CalcLatitude_+3A_bearing">bearing</code></td>
<td>

<p>bearing in radians
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data must be provided in decimal degrees (e.g.162.546).  Longitude values west of the prime meridian are 0 to -180.
Latitude values south of the equator are 0 to -90.  Calculates an unknown latutude given an initial latitude, distance traveled in meters and bearing
in radians.  This function is primarily used internally in the <code>gpstable</code> and <code>GeoReference</code> functions.
</p>


<h3>Value</h3>

<p>Latitude in radians
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>https://www.movable-type.co.uk/scripts/latlong.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Calculate the latitude of Los Angeles given a starting point in Manhattan and the distance 
#and bearing to Los Angeles.
Lat&lt;-CalcLatitude (40.7697,3938000,-1.507516)
#transform to degrees
Lat*360/(2*pi)

</code></pre>

<hr>
<h2 id='CalcLongitude'>
Calculate Longitude
</h2><span id='topic+CalcLongitude'></span>

<h3>Description</h3>

<p>Calculate the longitude of a destination given initial latitude and longitude, distance traveled, bearing and final latitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcLongitude(initialLat, destinationLat, initialLong, distance, bearing)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcLongitude_+3A_initiallat">initialLat</code></td>
<td>

<p>initial Latitude
</p>
</td></tr>
<tr><td><code id="CalcLongitude_+3A_destinationlat">destinationLat</code></td>
<td>

<p>final Latitude
</p>
</td></tr>
<tr><td><code id="CalcLongitude_+3A_initiallong">initialLong</code></td>
<td>

<p>initial Longitude
</p>
</td></tr>
<tr><td><code id="CalcLongitude_+3A_distance">distance</code></td>
<td>

<p>distance from initial to final in meters
</p>
</td></tr>
<tr><td><code id="CalcLongitude_+3A_bearing">bearing</code></td>
<td>

<p>bearing from point of departure to final destination
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a destination's longitude given initial latitude and longitude in degrees (e.g.162.546, Longitude values west 
of the prime meridian are 0 to -180.  Latitude values south of the equator are 0 to -90), destination latitude in 
RADIANS (result of <code>CalcLatitude</code> function), distance traveled in meters and bearing in radians.  This function is 
primarily used internally in the <code>GPStable</code> and <code>GeoReference</code> functions.
</p>


<h3>Value</h3>

<p>Longitude of final destination in radians.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>https://www.movable-type.co.uk/scripts/latlong.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Longitude of Los Angeles starting in Manhattan
Long &lt;- CalcLongitude(40.7697,0.5943228,-73.9735,3938000,-1.507516)
#transform to degrees
Long*360/(2*pi)

##Use results of CalcLatitude
Lat&lt;-CalcLatitude (40.7697,3938000,-1.507516)
Long &lt;- CalcLongitude(40.7697,Lat,-73.9735,3938000,-1.507516)
#transform to degrees
Long*360/(2*pi)

</code></pre>

<hr>
<h2 id='DeadReckoning'>
Calculates Dead Reckoning 
</h2><span id='topic+DeadReckoning'></span>

<h3>Description</h3>

<p>This function takes triaxial magnetometer, accelerometer and optional speed data to estimate 
the path traveled (pseudotrack) by a tagged animal based on Wilson et al. (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeadReckoning(rawdata, betas, decinc, Hz = 16, RmL = 2, DepthHz = 1, SpdCalc=1,
MaxSpd=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeadReckoning_+3A_rawdata">rawdata</code></td>
<td>

<p>matrix or data frame of magnetometer and accelerometer with column headings specified in Details.
</p>
</td></tr>
<tr><td><code id="DeadReckoning_+3A_betas">betas</code></td>
<td>

<p>matrix or data frame of coefficients (slope and intercept) that standardizes magnetometer and
accelerometer data between -1 and +1.  This can come from the <code>Standardize</code> function.
</p>
</td></tr>
<tr><td><code id="DeadReckoning_+3A_decinc">decinc</code></td>
<td>

<p>vector of c(Declination, Inclination) values in decimal degrees format in that order.
</p>
</td></tr>
<tr><td><code id="DeadReckoning_+3A_hz">Hz</code></td>
<td>

<p>frequency of data collection in Hz of magnetometers.  The assumption here is that the accelerometer Hz is at least
as high as the magnetometers and that all the magnetometer channels have the same Hz.  See Details.
</p>
</td></tr>
<tr><td><code id="DeadReckoning_+3A_rml">RmL</code></td>
<td>

<p>Running mean length in seconds, required to separate &quot;dynamic&quot; and &quot;static&quot; acceleration.
</p>
</td></tr>
<tr><td><code id="DeadReckoning_+3A_depthhz">DepthHz</code></td>
<td>

<p>Frequency of data collection in Hz of Depth channel.
</p>
</td></tr>
<tr><td><code id="DeadReckoning_+3A_spdcalc">SpdCalc</code></td>
<td>

<p>Integer of value 1,2,3 or 4 (5 and 6 are unsupported) depending on type of speed data supplied, see details. 
</p>
</td></tr>
<tr><td><code id="DeadReckoning_+3A_maxspd">MaxSpd</code></td>
<td>

<p>If <code>SpdCalc</code>=3, the max speed of your animal in m/s.  If <code>SpdCalc</code>=4, the constant speed of your animal in m/s.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rawdata must have columns DateTime or separated as Date and Time, plus Depth, MagSurge, MagHeave, MagSway, AccSurge, 
AccHeave, AccSway and optional Speed in a data frame with those exact column names (Mag=Magnetometer and Acc=
Accelerometer).  It must have an extra number of rows =Hz*RmL*0.5 at beginning and end that will be trimmed on final
output.  Because some users may program tags to collect acceleration data at a higher Hz than magnetometer data (for
example when looking for a Jerk signal), the <code>DeadReckoning</code> function automatically subsets the data set to those samples (rows)
that do NOT have &quot;NA&quot; in the MagSurge column.
</p>
<p>Betas is a [2,6] data frame with intercept in the first row and slope in the second row and can be directly taken from
Standardize function output or user input.  If you do not use the output of the Standardize function, the row names must be 
c(&quot;B0 Intercept&quot;,&quot;B1 Slope&quot;) and the column names must be c(&quot;MagSurge&quot;,&quot;MagHeave&quot;,&quot;MagSway&quot;,&quot;AccSurge&quot;,&quot;AccHeave&quot;,&quot;AccSway&quot;)
though the order is not important.  See the help on the <code>Standardize</code> function for more information.
</p>
<p>Declination and inclination data can be found at various internet sites such as the World Magnetic Model 2010 Calculator
from the British Geological Survey (see references).
</p>
<p>RmL-please read Shepard et al.(2008) and perhaps Wilson et al.(2007) for information on an appropriate Running Mean 
Length for your data and study animal.
</p>
<p>SpdCalc<br />
=1 if Speed is supplied in rawdata at the same Hz as Acc and Mag Hz in m/s.<br />
=2 if Speed is supplied in m/s but at Hz lower than Acc and Mag.<br />  
=3 if no speed is supplied and should be estimated from integrating (a running sum) the dynamic portion of the surge 
channel of acceleration and normalized using a linear model to meters/second from 0 to your max speed (MaxSpd) input.<br />
=4 a constant speed is assumed which is entered as the MaxSpd.<br />
=5 if no speed is supplied and should be estimated from accent and decent rates.  ***Not yet implemented.***<br />
=6 if speed is to be calculated from sound data.  ***Not yet implemented***
</p>


<h3>Value</h3>

<p>data.frame with columns DateTime, Xdim, Ydim, Depth and Speed. DateTime is the data and time columns pasted together using
<code>as.character</code>. Xdim and Ydim are cartesian coordinates from the origin in meters. Depth has been linearly interpolated from 
initial Depth Hz to Magnetometer Hz and Speed is either that supplied by the user or calculated via one of the methods
outlined above.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>One possible source for declination and inclination data <a href="http://www.geomag.bgs.ac.uk/data_service/models_compass/wmm_calc.html">http://www.geomag.bgs.ac.uk/data_service/models_compass/wmm_calc.html</a>
</p>
<p>Wilson R.P., Liebsch,N., Davies,I.M., Quintana,F., Weimerskirch,H., Storch,S., Lucke,K., Siebert,U., Zankl,S., Muller,G., Zimmer,I., Scolaro,A., Campagna,C., Plotz,J., Bornemann,H., Teilmann,J. and Mcmahon,C.R. (2007) All at sea with animal tracks; methodological and analytical solutions for the resolution of movement.  Deep-Sea Research II 54:193-210
</p>
<p>Shepard E.L.C., Wilson, R.P., Halsey, L.G., Quintana, F., Laich, A.G., Gleiss, A.C., Liebsch, N., Myers, A.E., Norman, B.  (2008)  Derivation of body motion via appropriate smoothing of acceleration data.  Aquatic Biology 4:235-241
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A simple square example
betas&lt;-Standardize(1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1)
data(square)
decinc&lt;-c(0,65)
DRoutput&lt;-DeadReckoning(square,betas,decinc,Hz=1,RmL=2,DepthHz=1,SpdCalc=1)
plot(DRoutput$Ydim,DRoutput$Xdim)

#Standardize tag output
betas&lt;-Standardize(1,1,-1,1,1,1,-57.8,68.76,-61.8,64.2,-70.16,58.08,
-10.1,9.55,-9.75,9.72,-9.91,9.43)
#Declination and inclination data for study area
decinc&lt;-c(10.228,65.918)
#data set with 7 associated GPS fixes in the "gpsdata02" data set
data(rawdata)
DRoutput&lt;-DeadReckoning(rawdata,betas,decinc,Hz=16,RmL=2,DepthHz=1,SpdCalc=3,MaxSpd=3.5)
plot(DRoutput$Ydim,DRoutput$Xdim)
</code></pre>

<hr>
<h2 id='GapFinder'>
Find gaps in your data file
</h2><span id='topic+GapFinder'></span>

<h3>Description</h3>

<p>The function looks at the DateTime or Date and Time stamps of your data file and sees if any consecutive 
entries have a difference of greater than the <code>timediff</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GapFinder(rawdata, timediff = 1, timeformat = "%d-%b-%Y %H:%M:%S")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GapFinder_+3A_rawdata">rawdata</code></td>
<td>

<p>Data with a combined DateTime or separate Date and Time stamp columns labeled as such.
</p>
</td></tr>
<tr><td><code id="GapFinder_+3A_timediff">timediff</code></td>
<td>

<p>The amount of time in seconds that is expected between each entry (row).  Typically this would be
your data collection Hz (for Hz=16,<code>timediff</code>=1/16, for Hz=0.5, <code>timediff</code>=2) but results will depend on whether or not you have information on decimal seconds.  
One second is probably small enough for most people and will avoid issues with decimal seconds, but this depends on 
the scale that is important to you.
</p>
</td></tr>
<tr><td><code id="GapFinder_+3A_timeformat">timeformat</code></td>
<td>

<p>Format of the DateTime or separate Date and Time stamp after it is pasted together with a space between. 
See the <code>strptime</code> function for codes.  The default value is the value of the example files.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with 4 columns indicating the row that the gap occurs, the amount of time between the gap, 
and the DateTime stamp on either end of the gap.  The data frame holds a maximum of 1000 entries, so if you have
more gaps, then you can alter the program to create a larger dataframe.  Hopefully you don't have anywhere near that many gaps.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rawdatagap)
gaps&lt;-GapFinder(rawdatagap, timediff = 1, timeformat = "%d-%b-%Y %H:%M:%S")

#how timediff and a lack of decimal seconds information interact given a Hz of 16.
gaps&lt;-GapFinder(rawdatagap, timediff = 1/16, timeformat = "%d-%b-%Y %H:%M:%S")

</code></pre>

<hr>
<h2 id='GeoRef'>
Georeference the Dead Reckoning data
</h2><span id='topic+GeoRef'></span>

<h3>Description</h3>

<p>A wrapper function for the <code>GeoReference</code> function that georeferences a deadreckoning track with multiple GPS relocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoRef(drdata, gpsfdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeoRef_+3A_drdata">drdata</code></td>
<td>

<p>Data frame from, or similar in format as that produced by the <code>DeadReckoning</code> function. 
</p>
</td></tr>
<tr><td><code id="GeoRef_+3A_gpsfdata">gpsfdata</code></td>
<td>

<p>Data frame from, or similar in format as that produced by the <code>GPStable</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data that is not bookended by the DateTime stamp of the GPS relocations will be discarded.  The DateTime stamp of the drdata and gpsfdata
must be in the same format, see the <code>strptime</code> function help file for details.
</p>


<h3>Value</h3>

<p>Returns a data frame with DateTime, Distance, LatRad, LongRad, Latitude, Longitude, Depth, Speed, NewX, NewY, and Bering
of the Georeferenced Deadreckoned tracks.  NewX and NewY are cartesian coordinates in meters.  Distance is the distance 
from the origin to the georeferenced point in 2D.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>Wilson R.P., Liebsch,N., Davies,I.M., Quintana,F., Weimerskirch,H., Storch,S., Lucke,K., Siebert,U., Zankl,S., 
Muller,G., Zimmer,I., Scolaro,A., Campagna,C., Plotz,J., Bornemann,H., Teilmann,J. and Mcmahon,C.R. (2007) 
All at sea with animal tracks; methodological and analytical solutions for the resolution of movement.  
Deep-Sea Research II 54:193-210
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Standardize tag output
betas&lt;-Standardize(1,1,-1,1,1,1,-57.8,68.76,-61.8,64.2,-70.16,58.08,
	-10.1,9.55,-9.75,9.72, -9.91,9.43)
#get declination and inclination data for study area
decinc&lt;-c(10.228,65.918)
#data set with 6 associated GPS fixes in the "gpsdata" data set
data(rawdata)
DRoutput&lt;-DeadReckoning(rawdata,betas,decinc,Hz=16,RmL=2,DepthHz=1,SpdCalc=3,MaxSpd=3.5)
#prepare GPS data
data(gpsdata02)
gpsformat&lt;-GPStable(gpsdata02)
Georeferenced&lt;-GeoRef(DRoutput,gpsformat)
plot(Georeferenced$Longitude,Georeferenced$Latitude,pch=".")
points(gpsformat$Longitude[2],gpsformat$Latitude[2],pch="S",col="Red") #Start
points(gpsformat$Longitude[7],gpsformat$Latitude[7],pch="F",col="Blue") #Finish
#Intermediate GPS points
points(gpsformat$Longitude[3:6],gpsformat$Latitude[3:6],pch="*",col="Red")
</code></pre>

<hr>
<h2 id='georef1min01'>
GeoReferenced fur seal track
</h2><span id='topic+georef1min01'></span>

<h3>Description</h3>

<p>Georeferenced data from a fur seal track in the Bering Sea.  Data has been thinned to relocations
every 1 minute.  This data set is used as an example in the vignette.  <code>gpsdata01</code> is the complementary gps data for this pseudotrack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(georef1min01)</code></pre>


<h3>Format</h3>

<p>A data frame with 6681 observations on the following 6 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>LatRad</code></dt><dd><p>a numeric vector, latitude given in radians</p>
</dd>
<dt><code>LongRad</code></dt><dd><p>a numeric vector, longitude given in radians</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector, latitude given in decimal degrees</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector, longitude given in decimal degrees</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector, in meters</p>
</dd>
</dl>



<h3>Details</h3>

<p>Date files <code>georef1min02</code>, <code>georef1min03</code>, <code>georef1min26</code> and <code>georef1min95</code> have the same structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georef1min01)
head(georef1min01);tail(georef1min01)
str(georef1min01)
plot(georef1min01$Longitude, georef1min01$Latitude,pch=".")
data(gpsdata01)
points(gpsdata01$Longitude,gpsdata01$Latitude,col="red",pch="*")

</code></pre>

<hr>
<h2 id='georef1min02'>
GeoReferenced fur seal track
</h2><span id='topic+georef1min02'></span>

<h3>Description</h3>

<p>Georeferenced data from a fur seal track in the Bering Sea.  Data has been thinned to relocations
every 1 minute.  This data set is used as an example in the vignette and the <code>Mapper</code> function.  
<code>gpsdata02</code> is the complementary gps data for this pseudotrack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(georef1min02)</code></pre>


<h3>Format</h3>

<p>A data frame with 9147 observations on the following 6 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>LatRad</code></dt><dd><p>a numeric vector, latitude given in radians</p>
</dd>
<dt><code>LongRad</code></dt><dd><p>a numeric vector, longitude given in radians</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector, latitude given in decimal degrees</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector, longitude given in decimal degrees</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector, in meters</p>
</dd>
</dl>



<h3>Details</h3>

<p>Date files <code>georef1min01</code>, <code>georef1min03</code>, <code>georef1min26</code> and <code>georef1min95</code> have the same structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georef1min02)
head(georef1min02);tail(georef1min02)
str(georef1min02)
plot(georef1min02$Longitude, georef1min02$Latitude,pch=".")
data(gpsdata02)
points(gpsdata02$Longitude,gpsdata02$Latitude,col="red",pch="*")

</code></pre>

<hr>
<h2 id='georef1min03'>
GeoReferenced fur seal track
</h2><span id='topic+georef1min03'></span>

<h3>Description</h3>

<p>Georeferenced data from a fur seal track in the Bering Sea.  Data has been thinned to relocations
every 1 minute.  This data set is used as an example in the vignette.  <code>gpsdata03</code> is the complementary gps data for this pseudotrack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(georef1min03)</code></pre>


<h3>Format</h3>

<p>A data frame with 6724 observations on the following 6 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>LatRad</code></dt><dd><p>a numeric vector, latitude given in radians</p>
</dd>
<dt><code>LongRad</code></dt><dd><p>a numeric vector, longitude given in radians</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector, latitude given in decimal degrees</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector, longitude given in decimal degrees</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector, in meters</p>
</dd>
</dl>



<h3>Details</h3>

<p>Date files <code>georef1min01</code>, <code>georef1min02</code>, <code>georef1min26</code> and <code>georef1min95</code> have the same structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georef1min03)
head(georef1min03);tail(georef1min03)
str(georef1min03)
plot(georef1min03$Longitude, georef1min03$Latitude,pch=".")
data(gpsdata03)
points(gpsdata03$Longitude,gpsdata03$Latitude,col="red",pch="*")
</code></pre>

<hr>
<h2 id='georef1min26'>
GeoReferenced fur seal track
</h2><span id='topic+georef1min26'></span>

<h3>Description</h3>

<p>Georeferenced data from a fur seal track in the Bering Sea.  Data has been thinned to relocations
every 1 minute.  This data set is used as an example in the <code>Mapper</code> function.  
<code>gpsdata26</code> is the complementary gps data for this pseudotrack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(georef1min26)</code></pre>


<h3>Format</h3>

<p>A data frame with 430 observations on the following 6 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>LatRad</code></dt><dd><p>a numeric vector, latitude given in radians</p>
</dd>
<dt><code>LongRad</code></dt><dd><p>a numeric vector, longitude given in radians</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector, latitude given in decimal degrees</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector, longitude given in decimal degrees</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector, in meters</p>
</dd>
</dl>



<h3>Details</h3>

<p>Date files <code>georef1min01</code>, <code>georef1min02</code>, <code>georef1min03</code> and <code>georef1min95</code> have the same structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georef1min26)
head(georef1min26);tail(georef1min26)
str(georef1min26)
plot(georef1min26$Longitude, georef1min26$Latitude,pch=".")
data(gpsdata26)
points(gpsdata26$Longitude,gpsdata26$Latitude,col="red",pch="*")

</code></pre>

<hr>
<h2 id='georef1min95'>
GeoReferenced fur seal track
</h2><span id='topic+georef1min95'></span>

<h3>Description</h3>

<p>Georeferenced data from a fur seal track in the Bering Sea.  Data has been thinned to relocations
every 1 minute.  This data set is used as an example in the <code>Mapper</code> function.  
<code>gpsdata95</code> is the complementary gps data for this pseudotrack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(georef1min95)</code></pre>


<h3>Format</h3>

<p>A data frame with 6566 observations on the following 6 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>LatRad</code></dt><dd><p>a numeric vector, latitude given in radians</p>
</dd>
<dt><code>LongRad</code></dt><dd><p>a numeric vector, longitude given in radians</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector, latitude given in decimal degrees</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector, longitude given in decimal degrees</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector, in meters</p>
</dd>
</dl>



<h3>Details</h3>

<p>Date files <code>georef1min01</code>, <code>georef1min02</code>, <code>georef1min03</code> and <code>georef1min26</code> have the same structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georef1min95)
head(georef1min95);tail(georef1min95)
str(georef1min95)
plot(georef1min95$Longitude, georef1min95$Latitude,pch=".")
data(gpsdata95)
points(gpsdata95$Longitude,gpsdata95$Latitude,col="red",pch="*")

</code></pre>

<hr>
<h2 id='GeoReference'>
Georeference the Dead Reckoning data between two GPS points
</h2><span id='topic+GeoReference'></span>

<h3>Description</h3>

<p>Takes relocation data and forces it to go through two known points (such as GPS fixes) at the beginning and end by 
rotating the track and either expanding or contracting each section by a constant percentage.  The primary function used
in the wrapper function <code>GeoRef</code>, you should use <code>GeoRef</code> if you have more than two GPS locations for your animal track. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoReference(drdata, gpsdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeoReference_+3A_drdata">drdata</code></td>
<td>

<p>Data frame from, or in a similar format as that produced by the <code>DeadReckoning</code> function
</p>
</td></tr>
<tr><td><code id="GeoReference_+3A_gpsdata">gpsdata</code></td>
<td>

<p>Data frame from, or in a similar format as that produced by the <code>GPStable</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TimeDate stamp of first entry of drdata and gpsdata must be the same.  The <code>GeoRef</code> function does this 
for you my matching the DateTime stamp in the <code>drdata</code> and <code>gpsdata</code>.  The DateTime stamp of the <code>drdata</code> and <code>gpsdata</code>
must be in the same format.
</p>


<h3>Value</h3>

<p>Returns a data frame with DateTime, Distance, LatRad, LongRad, Latitude, Longitude, Depth, Speed, NewX, NewY, and Bearing
of the Georeferenced Deadreckoning tracks.  NewX and NewY are cartesian coordinates in meters.  Distance is the distance 
from the origin to the new point in 2D.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>Wilson R.P., Liebsch,N., Davies,I.M., Quintana,F., Weimerskirch,H., Storch,S., Lucke,K., Siebert,U., Zankl,S., 
Muller,G., Zimmer,I., Scolaro,A., Campagna,C., Plotz,J., Bornemann,H., Teilmann,J. and Mcmahon,C.R. (2007) 
All at sea with animal tracks; methodological and analytical solutions for the resolution of movement.  
Deep-Sea Research II 54:193-210
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Standardize tag output
betas&lt;-Standardize(1,1,-1,1,1,1,-57.8,68.76,-61.8,64.2,-70.16,58.08,
	-10.1,9.55,-9.75,9.72,-9.91,9.43)
#get declination and inclination data for study area
decinc&lt;-c(10.228,65.918)
#data set with 7 associated GPS fixes in the "gpsdata02" data set
data(rawdata)
DRoutput&lt;-DeadReckoning(rawdata,betas,decinc,Hz=16,RmL=2,DepthHz=1,SpdCalc=3,MaxSpd=3.5)
#prepare GPS data
data(gpsdata02)
gpsformat&lt;-GPStable(gpsdata02)
Georeferenced&lt;-GeoReference(DRoutput,gpsformat[c(2,3),])
plot(Georeferenced$Longitude,Georeferenced$Latitude,pch=".")
points(gpsformat$Longitude[2],gpsformat$Latitude[2],pch="S",col="Red")
points(gpsformat$Longitude[3],gpsformat$Latitude[3],pch="F",col="Blue")
</code></pre>

<hr>
<h2 id='gpsdata01'>
GPS raw data
</h2><span id='topic+gpsdata01'></span>

<h3>Description</h3>

<p>Complete gps file for northern fur seal track in the Bering Sea.  Data taken by a wildlife computers mk10-F tag.  
<code>georef1min01</code> is the complementary pseudotrack data for these gps points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gpsdata01)</code></pre>


<h3>Format</h3>

<p>A data frame with 233 observations on the following 3 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(gpsdata01)
head(gpsdata01);tail(gpsdata01)
str(gpsdata01)
plot(gpsdata01$Longitude,gpsdata01$Latitude)
</code></pre>

<hr>
<h2 id='gpsdata02'>
GPS raw data
</h2><span id='topic+gpsdata02'></span>

<h3>Description</h3>

<p>Complete gps file for northern fur seal track in the Bering Sea.  Data taken by a wildlife computers mk10-F tag.  
This data set is used as an example in the <code>Mapper</code>, <code>GraphLimits</code>, <code>GeoRef</code>, <code>Splitter</code> and <code>GeoReference</code>
functions and in the vignette.  <code>georef1min02</code> is the complementary pseudotrack data for these gps points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gpsdata02)</code></pre>


<h3>Format</h3>

<p>A data frame with 276 observations on the following 3 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(gpsdata02)
head(gpsdata02);tail(gpsdata02)
str(gpsdata02)
plot(gpsdata02$Longitude,gpsdata02$Latitude)
</code></pre>

<hr>
<h2 id='gpsdata03'>
GPS raw data
</h2><span id='topic+gpsdata03'></span>

<h3>Description</h3>

<p>Complete gps file for northern fur seal track in the Bering Sea.  Data taken by a wildlife computers mk10-F tag.  
<code>georef1min03</code> is the complementary pseudotrack data for these gps points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gpsdata03)</code></pre>


<h3>Format</h3>

<p>A data frame with 57 observations on the following 3 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(gpsdata03)
head(gpsdata03);tail(gpsdata03)
str(gpsdata03)
plot(gpsdata03$Longitude,gpsdata03$Latitude)
</code></pre>

<hr>
<h2 id='gpsdata26'>
GPS raw data
</h2><span id='topic+gpsdata26'></span>

<h3>Description</h3>

<p>Complete gps file for northern fur seal track in the Bering Sea.  Data taken by a wildlife computers mk10-F tag.  
This data set is used as an example in the <code>Mapper</code> function.  <code>georef1min26</code> is the complementary pseudotrack data for these gps points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gpsdata26)</code></pre>


<h3>Format</h3>

<p>A data frame with 9 observations on the following 3 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(gpsdata26)
head(gpsdata26);tail(gpsdata26)
str(gpsdata26)
plot(gpsdata26$Longitude,gpsdata26$Latitude)
</code></pre>

<hr>
<h2 id='gpsdata95'>
GPS raw data
</h2><span id='topic+gpsdata95'></span>

<h3>Description</h3>

<p>Complete gps file for northern fur seal track in the Bering Sea.  Data taken by a wildlife computers mk10-F tag.  
This data set is used as an example in the <code>Mapper</code> function.  <code>georef1min95</code> is the complementary pseudotrack data for these gps points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gpsdata95)</code></pre>


<h3>Format</h3>

<p>A data frame with 93 observations on the following 3 variables.
</p>

<dl>
<dt><code>DateTime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(gpsdata95)
head(gpsdata95);tail(gpsdata95)
str(gpsdata95)
plot(gpsdata95$Longitude,gpsdata95$Latitude)
</code></pre>

<hr>
<h2 id='GPStable'>
Format GPS data
</h2><span id='topic+GPStable'></span>

<h3>Description</h3>

<p>Takes DateTime, Latitude and Longitude in decimal degrees and converts Latitude and Longitude into radians and calculates bearing
and distance between consecutive locations 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPStable(rawdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GPStable_+3A_rawdata">rawdata</code></td>
<td>

<p>data frame with DateTime, or Date and Time separately, in same format as deadreckoning data, Latitude and Longitude 
in decimal degrees.  Must use those column labels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data must be provided in decimal degrees (e.g. 162.546).  Longitude values west of the prime meridian are 0 to -180.
Latitude values south of the equator are 0 to -90.  DateTime must be in the same format as output of <code>DeadReckoning</code> 
function or separated as Date and Time that can be pasted together to create the same format as output of the <code>Deadreckoning</code> 
function.  Distance is calculated using the Spherical Law of Cosines (see references).
</p>


<h3>Value</h3>

<p>Returns a data frame with columns DateTime, Latitude(Decimal Degrees), Longitude(Decimal Degrees), LatRad(Radians), LongRad(Radians),
BearingRad, BearingDeg, DistanceKm.  BearingRad and BearingDeg are the bearing calculated from point x to point x+1.  
DistanceKm is the distance between point x and point x-1.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>References</h3>

<p>https://www.movable-type.co.uk/scripts/latlong.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gpsdata02)
head(gpsdata02)
gpsformat&lt;-GPStable(gpsdata02)
head(gpsformat)
</code></pre>

<hr>
<h2 id='GraphLimits'>
Determine Latitude and Longitude limits of a graph
</h2><span id='topic+GraphLimits'></span>

<h3>Description</h3>

<p>Finds the minimum and maximum of the longitude and latitude and then adds on 2.5% of the latitude and longitude to create 
boarders in the graph and accounts in a very simple way for projection distortion so long as maps are not to large.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphLimits(infile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GraphLimits_+3A_infile">infile</code></td>
<td>

<p>A file with columns of latitude and longitude labeled as Latitude and Longitude
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function used in the <code>Mapper</code> function.  It attempts to account for the change in distance covered between longitude as latitude changes
by using the cos(latitude) of the center of the latitude of the graph, and adjusting the longitude to cover the same distance.  Hence, the boarders
on the graph are set first by making the distances in latitude and longitude approximately equal in meters, then 2.5% is added on each end.
</p>


<h3>Value</h3>

<p>Returns a list of 4 scalars defining the boarders of the data
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Standardize tag output
betas&lt;-Standardize(1,1,-1,1,1,1,-57.8,68.76,-61.8,64.2,-70.16,58.08,-10.1,9.55,-9.75,9.72,
-9.91,9.43)
#get declination and inclination data for study area
decinc&lt;-c(10.228,65.918)
#data set with 11 associated GPS fixes in the "gpsdata" data set
data(rawdata)
DRoutput&lt;-DeadReckoning(rawdata ,betas, decinc, Hz = 16, RmL = 2, DepthHz = 1, SpdCalc=3,
MaxSpd=3.5)
#prepare GPS data
data(gpsdata02)
gpsformat&lt;-GPStable(gpsdata02)
Georeferenced&lt;-GeoReference(DRoutput,gpsformat[1:2,])
Limits&lt;-GraphLimits(Georeferenced)
Limits
</code></pre>

<hr>
<h2 id='Mapper'>
Animal track plotting with a color map
</h2><span id='topic+Mapper'></span>

<h3>Description</h3>

<p>Makes a color map of your animal track with terrain colors for land and shades of blue for depth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mapper(inFile, gpsFile, bathyFile, ExpFact = 500, minlat = 51, maxlat = 60,
minlong = -177, maxlong = -163, Title = "Main")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mapper_+3A_infile">inFile</code></td>
<td>

<p>Track file of latitude and longitude colums with those names (output of <code>GeoReference</code> function)
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_gpsfile">gpsFile</code></td>
<td>

<p>GPS file of latitude and longitude colums with those names
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_bathyfile">bathyFile</code></td>
<td>

<p>Basemap file made from latitude, longitude and depth data, see <code>?bathymetry</code> for format details
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_expfact">ExpFact</code></td>
<td>

<p>Expansion Factor- a multiplier of how smooth you want your new background graph to be.  Larger numbers make it look
smoother.  Experiment with it.
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_minlat">minlat</code></td>
<td>

<p>minimum latitude of the data from the image.xyz file, MUST BE A WHOLE NUMBER
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_maxlat">maxlat</code></td>
<td>

<p>maximum latitude of the data from the image.xyz file, MUST BE A WHOLE NUMBER
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_minlong">minlong</code></td>
<td>

<p>minimum longitude of the data from the image.xyz file, MUST BE A WHOLE NUMBER
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_maxlong">maxlong</code></td>
<td>

<p>maximum longitude of the data from the image.xyz file, MUST BE A WHOLE NUMBER
</p>
</td></tr>
<tr><td><code id="Mapper_+3A_title">Title</code></td>
<td>

<p>Title of your graph
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://www.gebco.net">https://www.gebco.net</a> do download the raw bathymetric data to create the <code>bathyFile</code>.
</p>


<h3>Value</h3>

<p>Given a bathymetric data file that is much larger than a given track, this function zooms the graph into where the data are
and smooths out the background data if they are pixilated.
The idea is to have a single bathymetry file to make many graphs for many animals no matter where they go so long as the tracks are all
within the area of the bathymetry file limits.  It creates a square graph that should adjust for the differences in actual
distances between latitude and longitude graduals as latitude changes.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A file from GeoRef function that has been thinned to data every 1 minute
data(georef1min26)
data(gpsdata26)
#See the vignette or ?bathymetry for information on how to get 
#bathymetric data for your study area
data(bathymetry)
#This subset is just to save time creating the image.xyz
bathymetryBogs&lt;-subset(bathymetry,Long&lt;=(-168)&amp; Long &gt;=(-169)
	&amp; Lat&lt;= 55 &amp; Lat &gt;=53,select=Long:Depth)
image.xyzBogs=tapply(bathymetryBogs$Depth, list(bathymetryBogs$Long, bathymetryBogs$Lat), unique)
Mapper(georef1min26, gpsdata26, image.xyzBogs, ExpFact = 500, minlat = 53, 
	maxlat = 55, minlong = -169, maxlong = -168, Title = "Fun Graph!!!")

## Not run: 
#Plot the entire bathymetry file (this will take a minute or two)
image.xyz=tapply(bathymetry$Depth, list(bathymetry$Long, bathymetry$Lat), unique)
Bathymetry.palatte&lt;-colorRampPalette(brewer.pal(9, "Blues"),bias=3)
#Plot the background map image
image.plot(image.xyz,
	col=c(rev(Bathymetry.palatte(200)),terrain.colors(100)),#gray(0:20/20),
	breaks=round(c(seq(from=min(image.xyz),to=0,length.out=201),seq(from=max(image.xyz)/101
	,to=max(image.xyz),length.out=100)))
	#,smallplot=2 #plots legend off x axis
	)
#The next examples plot only the part of the background map that contains the relocation data
#Example 1
data(georef1min02)
data(gpsdata02)
Mapper(georef1min02, gpsdata02, image.xyz, ExpFact = 500, minlat = 51, maxlat = 60,
minlong = -177, maxlong = -163, Title = "Fun Graph!!!")

#Example 2
bathymetryBogs2&lt;-subset(bathymetry,Long&lt;=(-168)&amp; Long &gt;=(-169.2)
	&amp; Lat&lt;= 54.3 &amp; Lat &gt;=53.1,select=Long:Depth)
image.xyzBogs2=tapply(bathymetryBogs2$Depth, list(bathymetryBogs2$Long, bathymetryBogs2$Lat),
	unique)
image.plot(image.xyzBogs2,
	col=c(rev(Bathymetry.palatte(200)),terrain.colors(100)),#gray(0:20/20),
	breaks=round(c(seq(from=min(image.xyz),to=0,length.out=201),seq(from=max(image.xyz)/101
	,to=max(image.xyz),length.out=100)))
	#,smallplot=2 #plots legend off x axis
	)
win.graph()
#Note the reduction in pixelation
data(georef1min95)
data(gpsdata95)
Mapper(georef1min95, gpsdata95, image.xyz, ExpFact = 500, minlat = 51, maxlat = 60,
minlong = -177, maxlong = -163, Title = "Fun Graph!!!")

## End(Not run)
</code></pre>

<hr>
<h2 id='rawdata'>
Raw triaxial magnetomater and accelerometer data
</h2><span id='topic+rawdata'></span>

<h3>Description</h3>

<p>Raw data file from a northern fur seal with date, time, internal temp, depth, triaxial magnetometer, accelerometer, and wet/dry fields.  
This data set is bookended by the first 7 gps points in the <code>gpsdata02</code> data set and is used in the examples for the <code>DeadReckoning</code>,
<code>GeoReference</code>, <code>GraphLimits</code>, <code>Splitter</code> and <code>GeoRef</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rawdata)</code></pre>


<h3>Format</h3>

<p>A data frame with 133100 observations on the following 9 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Time</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagSurge</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagSway</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagHeave</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccSurge</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccSway</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccHeave</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(rawdata)
str(rawdata)
head(rawdata);tail(rawdata)
plot(rawdata$AccHeave)
</code></pre>

<hr>
<h2 id='rawdatagap'>
Raw biologger data with a gap
</h2><span id='topic+rawdatagap'></span>

<h3>Description</h3>

<p>Raw data file from a fur seal with a gap in the data file.  Used as an example in the <code>GapFinder</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rawdatagap)</code></pre>


<h3>Format</h3>

<p>A data frame with 13738 observations on the following 9 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Time</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagSurge</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagSway</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagHeave</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccSurge</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccSway</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccHeave</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(rawdatagap)
head(rawdatagap);tail(rawdatagap)
str(rawdatagap)
plot(rawdatagap$AccHeave)
</code></pre>

<hr>
<h2 id='Splitter'>
Splits large data files by date and time. 
</h2><span id='topic+Splitter'></span>

<h3>Description</h3>

<p>This function takes the large data files inherently produced by accelerometer and magnetometer biologgers and splits
them into smaller files so that the <code>TrackReconstruction</code> functions can handle them or it splits the data between trips
or GPS locations or however is needed.  The splitting is done via matching Time and Date as character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Splitter(TagFile,Begin,End,RmL,Hz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Splitter_+3A_tagfile">TagFile</code></td>
<td>

<p>Matrix or data frame of magnetometer and accelerometer and other data collected by biologgers with column headings specified in Details.
</p>
</td></tr>
<tr><td><code id="Splitter_+3A_begin">Begin</code></td>
<td>

<p>A vector of DateTime such as 2009-08-12 05:45:35.0625 indicating the time that the new files should begin.  Format must be the same as the
Date and Time data in the <code>TagFile</code>, though the <code>TagFile</code> Date and Time need not be in the same column.
</p>
</td></tr>
<tr><td><code id="Splitter_+3A_end">End</code></td>
<td>

<p>A vector of DateTime such as 2009-08-12 05:45:35.0625 indicating the time that the new files should end.  Format must be the same as the
Date and Time data in the <code>TagFile</code>, though the <code>TagFile</code> Date and Time need not be in the same column.
</p>
</td></tr>
<tr><td><code id="Splitter_+3A_rml">RmL</code></td>
<td>

<p>Running mean length in seconds, required to calculate the amount of time beyond the <code>Begin</code> and <code>End</code> times that is required for the <code>DeadReckoning</code>
function and is trimmed off by the <code>DeadReckoning</code> function.
</p>
</td></tr>
<tr><td><code id="Splitter_+3A_hz">Hz</code></td>
<td>

<p>Frequency of Accelerometer data collection in Hz, required to calculate the amount of time beyond the Begin and End times that is required for the <code>DeadReckoning</code>
function and is trimmed off by the <code>DeadReckoning</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>TagFile</code> must have columns named DateTime or separated as Date and Time.  <code>Begin</code> and <code>End</code> must be in the same format as the DateTime 
column in <code>TagFile</code> or have the same format as the Date and Time columns when they are pasted together by <code>Splitter</code>.  For example, if
DateTime is 2009-08-21 14:08:06.0625, then <code>Begin</code> and <code>End</code> cannot be Jul/21/2009 14:08:06.0625.  See <code>strptime</code> for formatting
date and time data.  If <code>TagFile</code> has a Date column of 2009-08-21 and a Time column of 14:08:06.0625, <code>Splitter</code> will paste them
together for you to look like 2009-08-21 14:08:06.0625.  You must have enough time on the beginning and end of the <code>TagFile</code>
equivalent to <code>RmL</code>*Hz/2 before the first DateTime in the <code>Begin</code> vector and after the last DateTime in the <code>End</code> vector.  
If your Hz is greater than 1 and you do not have data on fractions of a second, then each time stamp will have copies equal to your 
sampling Hz.  In such a case, the program matches with the first instance of the DateTime and warnings will be given, this may be important
when calculating <code>RmL</code>*Hz/2 tails.
</p>


<h3>Value</h3>

<p>Creates a list of data frames in the format of the <code>TagFile</code>, but with a single DateTime column if the <code>TagFiles</code> had separate Date and Time
columns.
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data set with 6 associated GPS fixes in the "gpsdata" data set
data(rawdata)
data(gpsdata02)
Begin=gpsdata02$DateTime[2:6]
End=gpsdata02$DateTime[3:7]
splits&lt;-Splitter(rawdata,Begin,End,RmL=2,Hz=16)
## Not run: 
#The following is code to write your many new files
setwd() #first fill in the path to the folder where you want the data to be written to
for(i in 1:length(splits))
{
	num&lt;-i
	num=ifelse(num&lt;10 &amp; length(Begin)&gt;10,paste("0",num,sep=""),num)
		num=ifelse(num&lt;100 &amp; length(Begin)&gt;100,paste("0",num,sep=""),num)
		num=ifelse(num&lt;1000 &amp; length(Begin)&gt;1000,paste("0",num,sep=""),num)
		num=ifelse(num&lt;10000 &amp; length(Begin)&gt;10000,paste("0",num,sep=""),num)
	#Create a name for the file
	Nombre&lt;-paste("Animal01Trip03GPS_Section",num,".txt",sep="")
	write.table(splits[[i]],Nombre,sep="\t",row.names=FALSE,quote=FALSE)
	}

## End(Not run)
</code></pre>

<hr>
<h2 id='square'>
Raw triaxial magnetomater and accelerometer data
</h2><span id='topic+square'></span>

<h3>Description</h3>

<p>Fabricated data file 100 observations long to make a square.  Useful for exercises to understand how the 
<code>DeadReckoning</code> algorithm works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rawdata)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 10 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Time</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Depth</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagSurge</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagSway</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MagHeave</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccSurge</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccSway</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>AccHeave</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Speed</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(square)
str(square)
head(square);tail(square)
</code></pre>

<hr>
<h2 id='Standardize'>
Standardize accelerometer and magnetometer data
</h2><span id='topic+Standardize'></span>

<h3>Description</h3>

<p>Calculates intercept and slope values with a linear model to standardize accelerometer and magnetometer data to values between
-1 and +1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Standardize(MagOrSR, MagOrHV, MagOrSW, AccOrSR, AccOrHV, AccOrSW, magSRmin, 
magSRmax, magHVmin, magHVmax, magSWmin, magSWmax, accSRmin, accSRmax, accHVmin,
accHVmax, accSWmin, accSWmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Standardize_+3A_magorsr">MagOrSR</code></td>
<td>

<p>Surge Magnetometer Orientation -1 or 1
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_magorhv">MagOrHV</code></td>
<td>

<p>Heave Magnetometer Orientation -1 or 1
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_magorsw">MagOrSW</code></td>
<td>

<p>Sway Magnetometer Orientation -1 or 1
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_accorsr">AccOrSR</code></td>
<td>

<p>Surge Accelerometer Orientation -1 or 1
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_accorhv">AccOrHV</code></td>
<td>

<p>Heave Accelerometer Orientation -1 or 1
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_accorsw">AccOrSW</code></td>
<td>

<p>Sway Accelerometer Orientation -1 or 1
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_magsrmin">magSRmin</code></td>
<td>

<p>Surge Magnetometer minimum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_magsrmax">magSRmax</code></td>
<td>

<p>Surge Magnetometer maximum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_maghvmin">magHVmin</code></td>
<td>

<p>Heave Magnetometer minimum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_maghvmax">magHVmax</code></td>
<td>

<p>Heave Magnetometer maximum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_magswmin">magSWmin</code></td>
<td>

<p>Sway Magnetometer minimum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_magswmax">magSWmax</code></td>
<td>

<p>Sway Magnetometer maximum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_accsrmin">accSRmin</code></td>
<td>

<p>Surge Accelerometer minimum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_accsrmax">accSRmax</code></td>
<td>

<p>Surge Accelerometer maximum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_acchvmin">accHVmin</code></td>
<td>

<p>Heave Accelerometer minimum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_acchvmax">accHVmax</code></td>
<td>

<p>Heave Accelerometer maximum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_accswmin">accSWmin</code></td>
<td>

<p>Sway Accelerometer minimum
</p>
</td></tr>
<tr><td><code id="Standardize_+3A_accswmax">accSWmax</code></td>
<td>

<p>Sway Accelerometer maximum
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardization/Calibration/normalization/relativizing of accelerometer and magnetometer data.  The right-hand-rule
indicates the orientation (polarity) of the magnetometers and accelerometers required for the pseudotrack reconstruction
algorithm, so that when the front, top or left side of the tag is facing the earth, the accelerometers 
are at the maximal reading (+1) when the tag is not moving.  A similar rule applies for the magnetometers except the
maximal reading for each axis will be when the front, top or left side is facing north and at the angle of 
inclination of the magnetic field (the angle at which the magnetic field enters the earth) at that location on the planet.
If the tag sensors conform to this rule all the orientation parameters should be 1, any sensors that are opposite to this
should have -1 as an orientation value.  Instead of labeling the tag in X,Y and Z dimensions, the directions are labeled
as Surge, Heave and Sway where Surge indicates the front (anterior) to back (posterior) axis, the Heave is the 
top (dorsal) to bottom (ventral) axis and the Sway is the right to left (lateral) axis.
</p>


<h3>Value</h3>

<p>Returns a [2,6] matrix with intercept in the first row and slope in the second row and columns in the order of the 
orientation parameter input.  Row names are c(&quot;B0 Intercept&quot;,&quot;B1 Slope&quot;) and column names are
c(&quot;MagSurge&quot;,&quot;MagHeave&quot;,&quot;MagSway&quot;,&quot;AccSurge&quot;,&quot;AccHeave&quot;,&quot;AccSway&quot;).
</p>


<h3>Author(s)</h3>

<p>Brian Battaile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>betas&lt;-Standardize(1,1,-1,1,1,1,-57.8,68.76,-61.8,64.2,-70.16,58.08,-10.1,9.55,-9.75,9.72,
-9.91,9.43)
betas
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
