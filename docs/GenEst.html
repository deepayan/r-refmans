<!DOCTYPE html><html lang="en"><head><title>Help for package GenEst</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GenEst}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aicc'><p>Generic S3 function for summarizing AICc</p></a></li>
<li><a href='#aicc.cpm'><p>Extract AIC and AICc for a carcass persistence model</p></a></li>
<li><a href='#aicc.cpmSet'><p>Create the AICc tables for a set of carcass persistence models</p></a></li>
<li><a href='#aicc.cpmSetSize'><p>Create the AICc tables for a list of sets of searcher efficiency models</p></a></li>
<li><a href='#aicc.pkm'><p>extract AICc value from pkm object</p></a></li>
<li><a href='#aicc.pkmSet'><p>Create the AICc tables for a set of searcher efficiency models</p></a></li>
<li><a href='#aicc.pkmSetSize'><p>Create the AICc tables for a list of sets of searcher efficiency models</p></a></li>
<li><a href='#aicc.pkmSize'><p>Create the AICc tables for a list of sets of searcher efficiency models</p></a></li>
<li><a href='#app_content'><p>GenEst Information</p></a></li>
<li><a href='#app_download_functions'><p>GenEst app download funtions</p></a></li>
<li><a href='#app_msg_functions'><p>GenEst App Messages</p></a></li>
<li><a href='#app_output_utilities'><p>app utilities for formatting text, tables, figs, etc. for display</p></a></li>
<li><a href='#app_panels'><p>app panel utility functions</p></a></li>
<li><a href='#app_server'><p>The GenEst server definition function</p></a></li>
<li><a href='#app_ui'><p>Create the GenEst User Interface HTML</p></a></li>
<li><a href='#app_ui_utilities'><p>HTML parameters</p></a></li>
<li><a href='#app_utilities'><p>app utilities</p></a></li>
<li><a href='#app_widgets'><p>Create and manage widgets for data input, function execution, data output</p></a></li>
<li><a href='#averageSS'><p>Tabulate an average search schedule from a multi-unit SS data table</p></a></li>
<li><a href='#calcg'><p>Calculate detection probability for given SE and CP parameters and</p>
search schedule.</a></li>
<li><a href='#calcRate'><p>Estimate the number of fatalities in each search interval throughout</p>
the monitoring period.</a></li>
<li><a href='#calcSplits'><p>Estimate the number of fatalities by up to two splitting covariates</p></a></li>
<li><a href='#calcTsplit'><p>Estimate the number of fatalities by time interval</p></a></li>
<li><a href='#checkComponents'><p>Check for model components</p></a></li>
<li><a href='#checkDate'><p>Checks whether a vector of data can be interpreted as dates</p></a></li>
<li><a href='#checkSpecificModelCP'><p>Error check a specific model selection for a CP plot</p></a></li>
<li><a href='#checkSpecificModelSE'><p>Error check a specific model selection for an SE plot</p></a></li>
<li><a href='#CO_DWP'><p>Associate CO carcasses with appropriate DWP values (by unit and carcass class)</p></a></li>
<li><a href='#combinePreds'><p>Combine predictors</p></a></li>
<li><a href='#combinePredsAcrossModels'><p>Combine predictors across models</p></a></li>
<li><a href='#countCarcs'><p>Count the minimum number of carcasses in the cells</p></a></li>
<li><a href='#CPcols'><p>Produce a named vector of standard CP plot colors</p></a></li>
<li><a href='#CPdistOptions'><p>Produce the options for the distributions in the CP model</p></a></li>
<li><a href='#cpLogLik'><p>Calculate the negative log-likelihood of a carcass persistence model</p></a></li>
<li><a href='#cpm'><p>Fit cp carcass persistence models</p></a></li>
<li><a href='#cpmCPCellPlot'><p>Plot cell-specific decay curve for carcass persistence</p></a></li>
<li><a href='#cpmFail'><p>Check if a CP model is well-fit</p></a></li>
<li><a href='#cpmSetFail'><p>Check if cpm models fail</p></a></li>
<li><a href='#cpmSetFailRemove'><p>Remove failed cpm models from a <code>cpmSet</code> object</p></a></li>
<li><a href='#cpmSetSizeFail'><p>Check if all of the cpm models fail</p></a></li>
<li><a href='#cpmSetSizeFailRemove'><p>Remove failed cpm models from a <code>cpmSetSize</code> object</p></a></li>
<li><a href='#cpmSetSpecCPCellPlot'><p>Plot cell-specific decay curve for carcass persistence</p></a></li>
<li><a href='#dateCols'><p>Select the date columns from a data table</p></a></li>
<li><a href='#dateToDay'><p>Calculate day of study from calendar date</p></a></li>
<li><a href='#defineUnitCol'><p>Auto-parsing to find the name of the unit column (<code>unitCol</code>)</p></a></li>
<li><a href='#desc'><p>Descriptive statistics for a fitted CP model</p></a></li>
<li><a href='#dlModTabSE'><p>Create the download version of the Searcher Efficiency model table</p></a></li>
<li><a href='#DWPCols'><p>Select the DWP-ok columns from a data table</p></a></li>
<li><a href='#dwpm'><p>Fit density-weighted proportion (DWP) models.</p></a></li>
<li><a href='#estg'><p>Estimate all carcass-level detection rates and arrival intervals</p></a></li>
<li><a href='#estgGeneric'><p>Estimate generic g</p></a></li>
<li><a href='#estgGenericSize'><p>Estimate generic detection probability for multiple carcass classes</p></a></li>
<li><a href='#estM'><p>Estimate mortality</p></a></li>
<li><a href='#expandModelSetCP'><p>Expand a CP model set for plotting</p></a></li>
<li><a href='#GenEst'><p>Generalized estimation of mortality</p></a></li>
<li><a href='#logit'><p>Compute the logit or anti-logit</p></a></li>
<li><a href='#ltranspose'><p>Transpose a list of arrays</p></a></li>
<li><a href='#mock'><p>A mock example data set</p></a></li>
<li><a href='#model_utility_functions'><p>model utility functions (not exported)</p></a></li>
<li><a href='#obsCols_fta'><p>Select the columns from a data table that could be CP First Time</p>
Absent observations</a></li>
<li><a href='#obsCols_ltp'><p>Select the columns from a data table that could be CP Last Time</p>
Present observations</a></li>
<li><a href='#obsCols_SE'><p>Select the columns from a data table that could be SE observations</p></a></li>
<li><a href='#pkLogLik'><p>Calculate the negative log-likelihood of a searcher efficiency model</p></a></li>
<li><a href='#pkm'><p>Fit pk searcher efficiency models.</p></a></li>
<li><a href='#pkmFail'><p>Check if a pk model is well-fit</p></a></li>
<li><a href='#pkmParamPlot'><p>Plot parameter box plots for each cell for either p or k</p></a></li>
<li><a href='#pkmSECellPlot'><p>Plot cell-specific decay curve for searcher efficiency</p></a></li>
<li><a href='#pkmSetAllFail'><p>Check if all of the pkm models fail within a given set</p></a></li>
<li><a href='#pkmSetFail'><p>Check if pkm models fail</p></a></li>
<li><a href='#pkmSetFailRemove'><p>Remove failed pkm models from a <code>pkmSet</code> object</p></a></li>
<li><a href='#pkmSetSizeFail'><p>Check if all of the pkm models fail</p></a></li>
<li><a href='#pkmSetSizeFailRemove'><p>Remove failed pkm models from a <code>pkmSetSize</code> object</p></a></li>
<li><a href='#pkmSetSpecParamPlot'><p>p or k box plots for an SE model set</p></a></li>
<li><a href='#pkmSetSpecSECellPlot'><p>Plot cell-specific decay curve for searcher efficiency for a specific model</p>
with comparison to the cellwise model</a></li>
<li><a href='#pllogis'><p>The CDF of the loglogistic distribution</p></a></li>
<li><a href='#plot.cpm'><p>Plot results of a single CP model</p></a></li>
<li><a href='#plot.cpmSet'><p>Plot results of a set of CP models</p></a></li>
<li><a href='#plot.estM'><p>Plot total mortality estimation</p></a></li>
<li><a href='#plot.gGeneric'><p>Plot results of a single generic ghat estimation</p></a></li>
<li><a href='#plot.gGenericSize'><p>Plot results of a set of size-based generic ghat estimations</p></a></li>
<li><a href='#plot.pkm'><p>Plot results of a single pk model</p></a></li>
<li><a href='#plot.pkmSet'><p>Plot results of a set of SE models</p></a></li>
<li><a href='#plot.splitFull'><p>Plot summary statistics for splits of mortality estimates</p></a></li>
<li><a href='#plot.splitSummary'><p>Plot summary statistics for splits of mortality estimates</p></a></li>
<li><a href='#plotCPCells'><p>Plot the cellwise results of a single model in a set of CP models</p></a></li>
<li><a href='#plotCPFigure'><p>Plot results of a single CP model in a set</p></a></li>
<li><a href='#plotCPHeader'><p>The CP plot header</p></a></li>
<li><a href='#plotSEBoxPlots'><p>p and k box plots for an SE model set</p></a></li>
<li><a href='#plotSEBoxTemplate'><p>template box plot</p></a></li>
<li><a href='#plotSECells'><p>Plot the cellwise results of a single model in a set of SE models</p></a></li>
<li><a href='#plotSEFigure'><p>Plot results of a single SE model in a set</p></a></li>
<li><a href='#plotSEHeader'><p>The SE plot header</p></a></li>
<li><a href='#ppersist'><p>Calculate the probability of persistence to detection</p></a></li>
<li><a href='#predsCols'><p>Select the predictor-ok columns from a data table</p></a></li>
<li><a href='#prepPredictors'><p>Prepare predictors based on inputs</p></a></li>
<li><a href='#prepSS'><p>Create search schedule data into an prepSS object for convenient</p>
splits analyses</a></li>
<li><a href='#prettyModTabCP'><p>Create the pretty version of the Carcass Persistence model table</p></a></li>
<li><a href='#prettyModTabSE'><p>Create the pretty versions of model and summary tables</p></a></li>
<li><a href='#prettySplitTab'><p>Create the pretty version of the split summary table</p></a></li>
<li><a href='#print.cpm'><p>Print a <code>cpm</code> model object</p></a></li>
<li><a href='#print.pkm'><p>Print a <code>pkm</code> model object</p></a></li>
<li><a href='#qpk'><p>Quantiles of marginal distributions of <code class="reqn">\hat{p}</code> and <code class="reqn">\hat{k}</code></p></a></li>
<li><a href='#rcp'><p>Simulate parameters from a fitted cp model</p></a></li>
<li><a href='#rdwp'><p>Simulate parameters from a fitted dwp model</p></a></li>
<li><a href='#readCSV'><p>Read in csv files in either format</p></a></li>
<li><a href='#refMod'><p>Return the model with the greatest log-likelihood</p></a></li>
<li><a href='#removeCols'><p>Remove selected columns from column names</p></a></li>
<li><a href='#rpk'><p>Simulate parameters from a fitted pk model</p></a></li>
<li><a href='#runGenEst'><p>Launch the GenEst Application</p></a></li>
<li><a href='#SEboxes'><p>Produce boxplots <code>p</code> and/or <code>k</code> for all cells for reference</p>
model and specific model</a></li>
<li><a href='#SEcols'><p>Produce a named vectory with standard SE plot colors</p></a></li>
<li><a href='#SEfig'><p>Plot results of a single SE model in a set</p></a></li>
<li><a href='#SEpanel'><p>Produce a single panel in an SE summary/diagnostic plot</p></a></li>
<li><a href='#SEsi'><p>Calculate decayed searcher efficiency</p></a></li>
<li><a href='#SEsi_left'><p>Calculate conditional probability of observation at a search</p></a></li>
<li><a href='#SEsi_right'><p>Calculate conditional probability of observation after a series of</p>
searches</a></li>
<li><a href='#SEsi0'><p>Calculate decayed searcher efficiency for a single pk</p></a></li>
<li><a href='#simpleMplot'><p>Plot a total mortality estimation for a simple situation</p></a></li>
<li><a href='#sizeCols'><p>Select the potential carcass class columns from a data table</p></a></li>
<li><a href='#solar_powerTower'><p>Power Tower Example Dataset</p></a></li>
<li><a href='#solar_PV'><p>Photovoltaic Example Dataset</p></a></li>
<li><a href='#solar_trough'><p>Trough-based solar thermal power simulated example</p></a></li>
<li><a href='#summary.estM'><p>Summarize total mortality estimation</p></a></li>
<li><a href='#summary.gGeneric'><p>Summarize the gGeneric list to a simple table</p></a></li>
<li><a href='#summary.gGenericSize'><p>Summarize the gGenericSize list to a list of simple tables</p></a></li>
<li><a href='#summary.splitFull'><p>Summarize results of mortality estimate splits</p></a></li>
<li><a href='#tidyModelSetCP'><p>Tidy a CP model set</p></a></li>
<li><a href='#tidyModelSetSE'><p>Tidy an SE model set</p></a></li>
<li><a href='#transposeSplits'><p>Transpose a <code>splitFull</code> array (preserving attributes)</p></a></li>
<li><a href='#trimSetSize'><p>Trim a Model-Set-Size Complex to a Single Model Per Size</p></a></li>
<li><a href='#update_input'><p>Update the inputs when an event occurs</p></a></li>
<li><a href='#update_output'><p>Update the outputs when an event occurs</p></a></li>
<li><a href='#update_rv'><p>Update the reactive value list when an event occurs</p></a></li>
<li><a href='#wind_cleared'><p>Wind cleared plot (60m) Search Example</p></a></li>
<li><a href='#wind_RP'><p>Wind Road and Pad (120m) Example</p></a></li>
<li><a href='#wind_RPbat'><p>Wind Bat-Only Road and Pad (120m) Example</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generalized Mortality Estimator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Command-line and 'shiny' GUI implementation of the GenEst models for estimating bird and bat mortality at wind and solar power facilities, following Dalthorp, et al. (2018) &lt;<a href="https://doi.org/10.3133%2Ftm7A2">doi:10.3133/tm7A2</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>DT, gsl, gtools, hellno, htmltools, lubridate, MASS,
matrixStats, mvtnorm, Rcpp, shiny (&ge; 1.4.0), shinyjs, survival</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-25 13:12:29 UTC; ddalt</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Dalthorp [aut, cre],
  Juniper Simonis [aut],
  Lisa Madsen [aut],
  Manuela Huso [aut],
  Paul Rabie [aut],
  Jeffrey Mintz [aut],
  Robert Wolpert [aut],
  Jared Studyvin [aut],
  Franzi Korner-Nievergelt [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Dalthorp &lt;ddalthorp@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-25 16:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='aicc'>Generic S3 function for summarizing AICc</h2><span id='topic+aicc'></span>

<h3>Description</h3>

<p>Extract AICc values from <code>pkm</code>, <code>pkmSet</code>,
<code>pkmSetSize</code>, <code>cpm</code>, <code>cpmSet</code>, and <code>cpmSetSize</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aicc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc_+3A_x">x</code></td>
<td>
<p>Model or list of models to extract AICc values from.</p>
</td></tr>
<tr><td><code id="aicc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of models sorted by AICc
</p>

<hr>
<h2 id='aicc.cpm'>Extract AIC and AICc for a carcass persistence model</h2><span id='topic+aicc.cpm'></span>

<h3>Description</h3>

<p>S3 function for generating AIC for <code><a href="#topic+cpm">cpm</a></code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpm'
aicc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc.cpm_+3A_x">x</code></td>
<td>
<p>Carcass persistence model (<code>cpm</code> objects)</p>
</td></tr>
<tr><td><code id="aicc.cpm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC, AICc vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- cpm(formula_l = l ~ Season, formula_s = s ~ Season,
           data = wind_RP$CP, left = "LastPresent", right = "FirstAbsent")
 aicc(mod)

</code></pre>

<hr>
<h2 id='aicc.cpmSet'>Create the AICc tables for a set of carcass persistence models</h2><span id='topic+aicc.cpmSet'></span>

<h3>Description</h3>

<p>S3 function to generate model comparison tables based on AICc
values for a set of CP models generated by <code><a href="#topic+cpmSet">cpmSet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpmSet'
aicc(x, ..., quiet = FALSE, app = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc.cpmSet_+3A_x">x</code></td>
<td>
<p>Set of carcass persistence models fit to the same
observations</p>
</td></tr>
<tr><td><code id="aicc.cpmSet_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="aicc.cpmSet_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating if messages should be printed</p>
</td></tr>
<tr><td><code id="aicc.cpmSet_+3A_app">app</code></td>
<td>
<p>Logical indicating if the table should have the app model names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AICc table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- cpmSet(formula_l = l ~ Season * Visibility, formula_s = s ~ Season,
           data = wind_RP$CP, left = "LastPresent", right = "FirstAbsent")
 aicc(mod)

</code></pre>

<hr>
<h2 id='aicc.cpmSetSize'>Create the AICc tables for a list of sets of searcher efficiency models</h2><span id='topic+aicc.cpmSetSize'></span>

<h3>Description</h3>

<p>S3 function to generate model comparison tables for lists of
of sets of CP models of class <code><a href="#topic+cpm">cpmSetSize</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpmSetSize'
aicc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc.cpmSetSize_+3A_x">x</code></td>
<td>
<p>List of sets of CP models fit to the same observations</p>
</td></tr>
<tr><td><code id="aicc.cpmSetSize_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AICc table
</p>


<h3>Examples</h3>

<pre><code class='language-R'> cpmods &lt;- cpm(formula_l = l ~ Visibility, data = wind_RP$CP,
   left = "LastPresent", right = "FirstAbsent", sizeCol = "Size",
   allCombos = TRUE)
 aicc(cpmods)

</code></pre>

<hr>
<h2 id='aicc.pkm'>extract AICc value from pkm object</h2><span id='topic+aicc.pkm'></span>

<h3>Description</h3>

<p>extract AICc value from pkm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkm'
aicc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc.pkm_+3A_x">x</code></td>
<td>
<p>object of class <code>pkm</code></p>
</td></tr>
<tr><td><code id="aicc.pkm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the formulas for p and k and the AICc of the model
</p>

<hr>
<h2 id='aicc.pkmSet'>Create the AICc tables for a set of searcher efficiency models</h2><span id='topic+aicc.pkmSet'></span>

<h3>Description</h3>

<p>Generates model comparison tables based on AICc values for
a set of pk models generated by <code><a href="#topic+pkmSet">pkmSet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkmSet'
aicc(x, ..., quiet = FALSE, app = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc.pkmSet_+3A_x">x</code></td>
<td>
<p>Set of searcher efficiency models fit to the same
observations</p>
</td></tr>
<tr><td><code id="aicc.pkmSet_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="aicc.pkmSet_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating if messages should be printed</p>
</td></tr>
<tr><td><code id="aicc.pkmSet_+3A_app">app</code></td>
<td>
<p>Logical indicating if the table should have the app model names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AICc table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- pkmSet(formula_p = p ~ Season, formula_k = k ~ Season, data = wind_RP$SE)
 aicc(mod)

</code></pre>

<hr>
<h2 id='aicc.pkmSetSize'>Create the AICc tables for a list of sets of searcher efficiency models</h2><span id='topic+aicc.pkmSetSize'></span>

<h3>Description</h3>

<p>Generates model comparison tables based on AICc values for
a set of pk models generated by <code><a href="#topic+pkm">pkm</a></code> with
<code>allCombos = TRUE</code> and a non-<code>NULL</code> <code>sizeCol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkmSetSize'
aicc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc.pkmSetSize_+3A_x">x</code></td>
<td>
<p>List of set of searcher efficiency models fit to the same
observations</p>
</td></tr>
<tr><td><code id="aicc.pkmSetSize_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AICc table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- pkmSet(formula_p = p ~ Season, formula_k = k ~ Season, data = wind_RP$SE)
 aicc(mod)

</code></pre>

<hr>
<h2 id='aicc.pkmSize'>Create the AICc tables for a list of sets of searcher efficiency models</h2><span id='topic+aicc.pkmSize'></span>

<h3>Description</h3>

<p>Generates model comparison tables based on AICc values for
a set of pk models generated by <code><a href="#topic+pkm">pkm</a></code> with
<code>allCombos = FALSE</code> and a non-<code>NULL</code> <code>sizeCol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkmSize'
aicc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicc.pkmSize_+3A_x">x</code></td>
<td>
<p>List of set of searcher efficiency models fit to the same
observations</p>
</td></tr>
<tr><td><code id="aicc.pkmSize_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AICc table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- pkmSet(formula_p = p ~ Season, formula_k = k ~ Season, data = wind_RP$SE)
 aicc(mod)

</code></pre>

<hr>
<h2 id='app_content'>GenEst Information</h2><span id='topic+app_content'></span><span id='topic+createvtext'></span><span id='topic+gettingStartedContent'></span><span id='topic+aboutContent'></span><span id='topic+GenEstAuthors'></span><span id='topic+GenEstGUIauthors'></span><span id='topic+GenEstLicense'></span><span id='topic+GenEstAcknowledgements'></span><span id='topic+GenEstLogos'></span><span id='topic+disclaimersContent'></span><span id='topic+disclaimerUSGS'></span><span id='topic+disclaimerWEST'></span>

<h3>Description</h3>

<p>HTML generators for app information and content
</p>
<p><code>disclaimerUSGS</code> creates the text for the USGS
disclaimer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createvtext(type = "Full")

gettingStartedContent()

aboutContent()

GenEstAuthors()

GenEstGUIauthors()

GenEstLicense()

GenEstAcknowledgements()

GenEstLogos()

disclaimersContent(appType = "base")

disclaimerUSGS()

disclaimerWEST(appType)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_content_+3A_type">type</code></td>
<td>
<p>&quot;Full&quot; or &quot;Short&quot; or &quot;Name&quot; or &quot;NameDate&quot;</p>
</td></tr>
<tr><td><code id="app_content_+3A_apptype">appType</code></td>
<td>
<p>&quot;base&quot; (for local version) or &quot;deploy&quot; (for hosted version)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Panels and text for displaying general information about GenEst
</p>

<hr>
<h2 id='app_download_functions'>GenEst app download funtions</h2><span id='topic+app_download_functions'></span><span id='topic+downloadCPFig'></span><span id='topic+downloadCPmod'></span><span id='topic+downloadSEFig'></span><span id='topic+downloadSEmod'></span><span id='topic+downloadgFig'></span><span id='topic+downloadMres'></span><span id='topic+downloadMFig'></span><span id='topic+downloadTable'></span><span id='topic+downloadgres'></span>

<h3>Description</h3>

<p>Handle downloading of app data and figures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadCPFig(rv)

downloadCPmod(rv, input)

downloadSEFig(rv)

downloadSEmod(rv, input)

downloadgFig(rv, sc)

downloadMres(rv, input)

downloadMFig(rv, split = TRUE)

downloadTable(filename, tablename, csvformat)

downloadgres(rv, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_download_functions_+3A_rv">rv</code></td>
<td>
<p>the reactive values list</p>
</td></tr>
<tr><td><code id="app_download_functions_+3A_input">input</code></td>
<td>
<p>list of shiny input parameters</p>
</td></tr>
<tr><td><code id="app_download_functions_+3A_sc">sc</code></td>
<td>
<p>size class</p>
</td></tr>
<tr><td><code id="app_download_functions_+3A_split">split</code></td>
<td>
<p>logical indicator to use the split or not</p>
</td></tr>
<tr><td><code id="app_download_functions_+3A_filename">filename</code></td>
<td>
<p>the name for the file writing out</p>
</td></tr>
<tr><td><code id="app_download_functions_+3A_tablename">tablename</code></td>
<td>
<p>the name of the table in the rv list</p>
</td></tr>
<tr><td><code id="app_download_functions_+3A_csvformat">csvformat</code></td>
<td>
<p>format for .csv file: &quot;&quot; or NULL for comma-separated, 2
for semi-colon separated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>download handler functions
</p>

<hr>
<h2 id='app_msg_functions'>GenEst App Messages</h2><span id='topic+app_msg_functions'></span><span id='topic+msgList'></span><span id='topic+clearNotifications'></span><span id='topic+msgModRun'></span><span id='topic+msgModDone'></span><span id='topic+msgModPartialFail'></span><span id='topic+msgSampleSize'></span><span id='topic+msgModWarning'></span><span id='topic+msgModSENobs'></span><span id='topic+msgModFail'></span><span id='topic+msgSSavgFail'></span><span id='topic+msgSSinputFail'></span><span id='topic+msgSplitFail'></span><span id='topic+msgFracNote'></span>

<h3>Description</h3>

<p>lists of messages used in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msgList()

clearNotifications(msgs = msgList(), clear = TRUE)

msgModRun(msgs, modelType, clear = TRUE)

msgModDone(msgs, rv, type = "SE", clear = TRUE)

msgModPartialFail(mods, type = "SE")

msgSampleSize(mods)

msgModWarning(mods, type = "SE", rv = NULL)

msgModSENobs(rv)

msgModFail(mods, type = "SE", special = NULL)

msgSSavgFail(msgs, rv, clear = TRUE)

msgSSinputFail(msgs, rv, clear = TRUE)

msgSplitFail(type = NULL)

msgFracNote(fracNote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_msg_functions_+3A_msgs">msgs</code></td>
<td>
<p>message list</p>
</td></tr>
<tr><td><code id="app_msg_functions_+3A_clear">clear</code></td>
<td>
<p>logical indicator if clearing should happen.</p>
</td></tr>
<tr><td><code id="app_msg_functions_+3A_modeltype">modelType</code></td>
<td>
<p>&quot;SE&quot;, &quot;CP&quot;, &quot;g&quot;, or &quot;M&quot;</p>
</td></tr>
<tr><td><code id="app_msg_functions_+3A_rv">rv</code></td>
<td>
<p>reactive values list</p>
</td></tr>
<tr><td><code id="app_msg_functions_+3A_type">type</code></td>
<td>
<p>&quot;SE&quot;, &quot;CP&quot;, &quot;M&quot;, &quot;split&quot;, or &quot;g&quot;</p>
</td></tr>
<tr><td><code id="app_msg_functions_+3A_mods">mods</code></td>
<td>
<p>Set Size list of models</p>
</td></tr>
<tr><td><code id="app_msg_functions_+3A_special">special</code></td>
<td>
<p>indicator of a special type of message</p>
</td></tr>
<tr><td><code id="app_msg_functions_+3A_fracnote">fracNote</code></td>
<td>
<p>the note regarding the input</p>
</td></tr>
</table>

<hr>
<h2 id='app_output_utilities'>app utilities for formatting text, tables, figs, etc. for display</h2><span id='topic+app_output_utilities'></span><span id='topic+classText'></span><span id='topic+estText'></span><span id='topic+setNotSuspending'></span><span id='topic+reNULL'></span><span id='topic+initialOutput'></span><span id='topic+setFigW'></span><span id='topic+setFigH'></span>

<h3>Description</h3>

<p>app utilities for formatting text, tables, figs, etc. for display
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classText(rv, type = "SE")

estText(rv, type = "SE")

setNotSuspending(output, dontSuspend)

reNULL(x, toNULL)

initialOutput(rv, output)

setFigW(modelSet)

setFigH(modelSet, modType = "SE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_output_utilities_+3A_rv">rv</code></td>
<td>
<p>Reactive values list for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="app_output_utilities_+3A_type">type</code></td>
<td>
<p>Model type, either &quot;SE&quot; or &quot;CP&quot; or &quot;g&quot;.</p>
</td></tr>
<tr><td><code id="app_output_utilities_+3A_output">output</code></td>
<td>
<p><code>output</code> list to have elements <code>dontSuspend</code>
(re)set to having <code>suspendWhenHidden = FALSE</code>.</p>
</td></tr>
<tr><td><code id="app_output_utilities_+3A_dontsuspend">dontSuspend</code></td>
<td>
<p>Names of elements in <code>output</code> to (re)set to
having <code>suspendWhenHidden = FALSE</code>.</p>
</td></tr>
<tr><td><code id="app_output_utilities_+3A_x">x</code></td>
<td>
<p><code>list</code> object to have elements <code>toNULL</code> reset to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="app_output_utilities_+3A_tonull">toNULL</code></td>
<td>
<p>Names of elements in <code>x</code> to reset to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="app_output_utilities_+3A_modelset">modelSet</code></td>
<td>
<p>Model set of class <code>cpmSet</code> or <code>pkmSet</code>.</p>
</td></tr>
<tr><td><code id="app_output_utilities_+3A_modtype">modType</code></td>
<td>
<p>&quot;SE&quot; or &quot;CP&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='app_panels'>app panel utility functions</h2><span id='topic+app_panels'></span><span id='topic+dataTabPanel'></span><span id='topic+selectedDataPanel'></span><span id='topic+modelOutputPanel'></span>

<h3>Description</h3>

<p>functions for formatting and displaying app panels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataTabPanel(dataType)

selectedDataPanel(modType)

modelOutputPanel(outType)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_panels_+3A_datatype">dataType</code></td>
<td>
<p>Toggle control for the model type of the panel. One of
&quot;SE&quot;, &quot;CP&quot;, &quot;SS&quot;, &quot;DWP&quot;, or &quot;CO&quot;.</p>
</td></tr>
<tr><td><code id="app_panels_+3A_modtype">modType</code></td>
<td>
<p>Toggle control for the model type of the panel. One of
&quot;SE&quot;, &quot;CP&quot;, or &quot;g&quot;.</p>
</td></tr>
<tr><td><code id="app_panels_+3A_outtype">outType</code></td>
<td>
<p>Toggle control for the model type of the panel. One of
&quot;SEFigures&quot;, &quot;SEEstimates&quot;, &quot;SEModComparison&quot;, &quot;SEModSelection&quot;,
&quot;CPFigures&quot;, &quot;CPEstimates&quot;, &quot;CPModComparison&quot;, &quot;CPModSelection&quot;,
&quot;gFigures&quot;, or &quot;gSummary&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='app_server'>The GenEst server definition function</h2><span id='topic+app_server'></span><span id='topic+GenEstServer'></span><span id='topic+reaction'></span><span id='topic+reactionMessageRun'></span><span id='topic+reactionMessageDone'></span><span id='topic+eventReaction'></span>

<h3>Description</h3>

<p>This suite of functions defines the server-side program for
the GenEst user interface (UI). See the &quot;GenEst Graphic User Interface&quot;
vignette for a more complete detailing of the codebase underlying
the GenEst UI. <br /> <br /> <code>GenEstServer</code>: main server function
expressed within the application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenEstServer(input, output, session)

reaction(eventName)

reactionMessageRun(eventName)

reactionMessageDone(eventName)

eventReaction(eventName, rv, input, output, session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_server_+3A_input">input</code></td>
<td>
<p><code>input</code> list for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="app_server_+3A_output">output</code></td>
<td>
<p><code>output</code> list for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="app_server_+3A_session">session</code></td>
<td>
<p>Environment for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="app_server_+3A_eventname">eventName</code></td>
<td>
<p>Character name of the event. One of &quot;clear_all&quot;,
&quot;file_SE&quot;, &quot;file_SE_clear&quot;, &quot;file_CP&quot;, &quot;file_CP_clear&quot;, &quot;file_SS&quot;,
&quot;file_SS_clear&quot;, &quot;file_DWP&quot;, &quot;file_DWP_clear&quot;, &quot;file_CO&quot;,
&quot;file_CO_clear&quot;, &quot;class&quot;, &quot;obsSE&quot;, &quot;predsSE&quot;, &quot;run_SE&quot;, &quot;run_SE_clear&quot;,
&quot;outSEclass&quot;, &quot;outSEp&quot;, &quot;outSEk&quot;, &quot;ltp&quot;, &quot;fta&quot;, &quot;predsCP&quot;, &quot;run_CP&quot;,
&quot;run_CP_clear&quot;, &quot;outCPclass&quot;, &quot;outCPdist&quot;, &quot;outCPl&quot;, &quot;outCPs&quot;,
&quot;run_M&quot;, &quot;run_M_clear&quot;, &quot;split_M&quot;, &quot;split_M_clear&quot;, &quot;transpose_split&quot;,
&quot;run_g&quot;, &quot;run_g_clear&quot;, or &quot;outgclass&quot;.</p>
</td></tr>
<tr><td><code id="app_server_+3A_rv">rv</code></td>
<td>
<p>reactive variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GenEstServer</code> is used as the main server function, and is
therefore included in the <code>server.R</code> script of the app. This 
function is not used in a standard R function sense, in that it does
not return a value and is not used on its own to have side effects.
The code of the function has two parts: 
</p>

<ol>
<li><p> preamble that defines all the necessary variables and options
</p>
</li>
<li> <p><code><a href="shiny.html#topic+observeEvent">observeEvent</a></code> calls, one for each event in
the application. Each call to <code><a href="shiny.html#topic+observeEvent">observeEvent</a></code> 
includes the <code>eventExpr</code> (event expression) as the first 
argument and the <code>handlerExpr</code> (handler expression) as the 
second argument, which is an evaluated (via <code><a href="base.html#topic+eval">eval</a></code>)
block of code returned from <code>reaction</code> for the specific 
event, as well as any other control switch arguments needed (such as
<code>ignoreNULL</code>). 
</p>
</li></ol>


<hr>
<h2 id='app_ui'>Create the GenEst User Interface HTML</h2><span id='topic+app_ui'></span><span id='topic+GenEstUI'></span><span id='topic+dataInputPanel'></span><span id='topic+dataInputSidebar'></span><span id='topic+loadedDataPanel'></span><span id='topic+analysisPanel'></span><span id='topic+GeneralInputsPanel'></span><span id='topic+GeneralInputSidebar'></span><span id='topic+SEPanel'></span><span id='topic+SESidebar'></span><span id='topic+SEMainPanel'></span><span id='topic+CPPanel'></span><span id='topic+CPSidebar'></span><span id='topic+CPMainPanel'></span><span id='topic+MPanel'></span><span id='topic+MSidebar'></span><span id='topic+MMainPanel'></span><span id='topic+gPanel'></span><span id='topic+gSidebar'></span><span id='topic+gMainPanel'></span><span id='topic+helpPanel'></span><span id='topic+gettingStartedPanel'></span><span id='topic+downloadsPanel'></span><span id='topic+aboutPanel'></span><span id='topic+disclaimersPanel'></span>

<h3>Description</h3>

<p>This suite of functions in <code>app_ui.R</code> create the HTML code
underlying the GenEst user interface (UI). See the &quot;GenEst Graphic User
Interface&quot; vignette for a more complete detailing of the codebase underlying
the GenEst UI. <br /> <br /> <code>GenEstUI</code>: whole application. Calls 
<code>dataInputPanel</code>, <code>analysisPanel</code>, and <code>helpPanel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenEstUI(appType = "base")

dataInputPanel()

dataInputSidebar()

loadedDataPanel()

analysisPanel()

GeneralInputsPanel()

GeneralInputSidebar()

SEPanel()

SESidebar()

SEMainPanel()

CPPanel()

CPSidebar()

CPMainPanel()

MPanel()

MSidebar()

MMainPanel()

gPanel()

gSidebar()

gMainPanel()

helpPanel(appType = "base")

gettingStartedPanel()

downloadsPanel()

aboutPanel()

disclaimersPanel(appType = "base")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_ui_+3A_apptype">appType</code></td>
<td>
<p>Toggle control for the app, <code>"base"</code> for local versions
or <code>"deploy"</code> for hosted version. Currently only differentiates the
disclaimer text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there are few differences between the local and deployed
versions of GenEst, and the <code>appType</code> toggle is only included as an 
argument for functions that can produce different versions of the HTML.
At this point, the only content that is different is the disclaimer text
on the Help panel.
</p>


<h3>Value</h3>

<p>Each function returns a string of HTML code, either as a
<code>"shiny.tag.list"</code> object (in the case of <code>GenEstUI</code>) or a
<code>"shiny.tag"</code> object (in the case of the other functions). <br /> <br /> 
<code>GenEstUI</code>: Full GenEst user interface.
</p>

<hr>
<h2 id='app_ui_utilities'>HTML parameters</h2><span id='topic+app_ui_utilities'></span><span id='topic+navbar'></span><span id='topic+style'></span><span id='topic+ol'></span><span id='topic+ul'></span><span id='topic+li'></span><span id='topic+b'></span><span id='topic+u'></span><span id='topic+small'></span><span id='topic+big'></span><span id='topic+center'></span><span id='topic+GenEstInlineCSS'></span><span id='topic+GenEstShinyJS'></span><span id='topic+cButtonStyle'></span>

<h3>Description</h3>

<p>utility functions for simple HTML tasks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navbar()

style(...)

ol(...)

ul(...)

li(...)

b(...)

u(...)

small(...)

big(text = NULL)

center(text = NULL)

GenEstInlineCSS(...)

GenEstShinyJS(...)

cButtonStyle(buttonType = "single")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_ui_utilities_+3A_...">...</code></td>
<td>
<p>attributes and children of the element</p>
</td></tr>
<tr><td><code id="app_ui_utilities_+3A_text">text</code></td>
<td>
<p>text to wrap in the tag</p>
</td></tr>
<tr><td><code id="app_ui_utilities_+3A_buttontype">buttonType</code></td>
<td>
<p>&quot;single&quot; (for clearing a single component) or &quot;all&quot; (for
clearing everything).</p>
</td></tr>
</table>

<hr>
<h2 id='app_utilities'>app utilities</h2><span id='topic+app_utilities'></span><span id='topic+initialReactiveValues'></span><span id='topic+reVal'></span><span id='topic+setkNeed'></span><span id='topic+updateColNames_size'></span><span id='topic+selectData'></span><span id='topic+modNameSplit'></span><span id='topic+prepSizeclassText'></span><span id='topic+modNamePaste'></span><span id='topic+plotNA'></span><span id='topic+updateSizeclasses'></span><span id='topic+pickSizeclass'></span><span id='topic+updatesizeCol'></span>

<h3>Description</h3>

<p>utility functions for simple app rv management
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialReactiveValues()

reVal(rv, toReVal)

setkNeed(rv)

updateColNames_size(rv)

selectData(data, cols)

modNameSplit(modNames, pos)

prepSizeclassText(sizeclasses)

modNamePaste(parts, type = "SE", tab = FALSE)

plotNA(type = "model")

updateSizeclasses(data, sizeCol)

pickSizeclass(sizeclasses, choice)

updatesizeCol(sizeCol, colNames_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_utilities_+3A_rv">rv</code></td>
<td>
<p>Reactive values list for the GenEst GUI, created by
<code><a href="#topic+initialReactiveValues">initialReactiveValues</a></code>, which calls
<code><a href="shiny.html#topic+reactiveValues">reactiveValues</a></code></p>
</td></tr>
<tr><td><code id="app_utilities_+3A_toreval">toReVal</code></td>
<td>
<p>Names of elements in <code>rv</code> to reset to their factory
setting (as defined by <code><a href="#topic+initialReactiveValues">initialReactiveValues</a></code>).</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_data">data</code></td>
<td>
<p>data table</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_cols">cols</code></td>
<td>
<p>column names to select</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_modnames">modNames</code></td>
<td>
<p>names of the model to be split off</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_pos">pos</code></td>
<td>
<p>position in the name to split off</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_sizeclasses">sizeclasses</code></td>
<td>
<p>names of the carcass classes</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_parts">parts</code></td>
<td>
<p>the component parts of the model's name</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_type">type</code></td>
<td>
<p>&quot;SE&quot; or &quot;CP&quot;</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_tab">tab</code></td>
<td>
<p>logical for if it's the table output for CP</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_sizecol">sizeCol</code></td>
<td>
<p>carcass class column name</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_choice">choice</code></td>
<td>
<p>carcass class chosen</p>
</td></tr>
<tr><td><code id="app_utilities_+3A_colnames_size">colNames_size</code></td>
<td>
<p>updated vector of size column names in all needed
tables</p>
</td></tr>
</table>

<hr>
<h2 id='app_widgets'>Create and manage widgets for data input, function execution, data output</h2><span id='topic+app_widgets'></span><span id='topic+dataInputWidget'></span><span id='topic+dataDownloadWidget'></span><span id='topic+modelInputWidget'></span><span id='topic+widgetMaker'></span><span id='topic+modelRunWidget'></span><span id='topic+preTextMaker'></span><span id='topic+modelOutputWidget'></span><span id='topic+splitButtonWidget'></span><span id='topic+modelSelectionWidget'></span><span id='topic+modelSelectionWidgetHeader'></span><span id='topic+modelSelectionWidgetRow'></span><span id='topic+kFixedWidget'></span><span id='topic+kFixedWidgetHeader'></span><span id='topic+kFixedWidgetRow'></span>

<h3>Description</h3>

<p>This is a generalized function for creating a data input 
widget used in the GenEst GUI, based on the data type (<code>dataType</code>).
Included within the widget is a conditional panel that allows removal of
the specific data file (and clearing of all downstream models) once
it has been loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataInputWidget(dataType)

dataDownloadWidget(set)

modelInputWidget(inType)

widgetMaker(Condition, Name, Fun, Label, Args)

modelRunWidget(modType)

preTextMaker(modType)

modelOutputWidget(modType)

splitButtonWidget()

modelSelectionWidget(mods, modType)

modelSelectionWidgetHeader(mods)

modelSelectionWidgetRow(mods, modType, sci)

kFixedWidget(sizeclasses)

kFixedWidgetHeader(sizeclasses)

kFixedWidgetRow(sizeclasses, sci)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_widgets_+3A_datatype">dataType</code></td>
<td>
<p>Toggle control for the model type of the widget. One of 
&quot;SE&quot;, &quot;CP&quot;, &quot;SS&quot;, &quot;DWP&quot;, or &quot;CO&quot;.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_set">set</code></td>
<td>
<p>Name of data set. One of &quot;RP&quot;, &quot;RPbat&quot;, &quot;cleared&quot;, &quot;powerTower&quot;,
&quot;PV&quot;, &quot;trough&quot;, &quot;mock&quot;</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_intype">inType</code></td>
<td>
<p>Toggle control for the input type of the widget. One of
&quot;nsim&quot;, &quot;CL&quot;, &quot;class&quot;, &quot;obsSE&quot;, &quot;predsSE&quot;, &quot;kFixed&quot;, &quot;ltp&quot;, &quot;fta&quot;,
&quot;predsCP&quot;, &quot;dist&quot;, &quot;xID&quot;, &quot;frac&quot;, &quot;DWPCol&quot;, &quot;COdate&quot;, &quot;gSearchInterval&quot;, or
&quot;gSearchMax&quot;.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_condition">Condition</code></td>
<td>
<p>Condition under which the widget is present to the user.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_name">Name</code></td>
<td>
<p>Name (id) of the widget created.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_fun">Fun</code></td>
<td>
<p>Function name (as character) used to create the widget.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_label">Label</code></td>
<td>
<p>Label presented to the user in the UI for the widget.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_args">Args</code></td>
<td>
<p>List of any additional arguments to be passed to the widget
creating function.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_modtype">modType</code></td>
<td>
<p>Toggle control for the model type of the widget. One of
&quot;SE&quot;, &quot;CP&quot;, &quot;M&quot;, or &quot;g&quot;.</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_mods">mods</code></td>
<td>
<p>Model Set Size object (from the reactive values list).</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_sci">sci</code></td>
<td>
<p>Name of carcass class element</p>
</td></tr>
<tr><td><code id="app_widgets_+3A_sizeclasses">sizeclasses</code></td>
<td>
<p>Vector of carcass class names (from the reactive values
list).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HTML for the data input widget.
</p>

<hr>
<h2 id='averageSS'>Tabulate an average search schedule from a multi-unit SS data table</h2><span id='topic+averageSS'></span>

<h3>Description</h3>

<p>Given a multi-unit Search Schedule data table, produce an 
average search schedule for use in generic detection probability 
estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averageSS(data_SS, SSdate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="averageSS_+3A_data_ss">data_SS</code></td>
<td>
<p>a multi-unit SS data table, for which the average interval 
will be tabulated. It is assumed that <code>data_SS</code> is properly 
formatted, with a column of search dates and a column of 1s and 0s for 
each unit indicating whether the unit was searched on the given date).
Other columns are optional, but optional columns should not all contain
at least on value that is not a 1 or 0.</p>
</td></tr>
<tr><td><code id="averageSS_+3A_ssdate">SSdate</code></td>
<td>
<p>Column name for the date searched data (optional).
if no <code>SSdate</code> is provided, <code>data_SS</code> will be parsed
to extract the dates automatically. If there is more than one column with
dates, then an error will be thrown and the user will be required to
provide the name of the desired dates column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the average search schedule
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mock)
  avgSS &lt;- averageSS(mock$SS)

</code></pre>

<hr>
<h2 id='calcg'>Calculate detection probability for given SE and CP parameters and
search schedule.</h2><span id='topic+calcg'></span>

<h3>Description</h3>

<p>Calculate detection probability (g) given SE and CP parameters
and a search schedule.
</p>
<p>The g given by <code>calcg</code> is a generic aggregate detection
probability and represents the probability of detecting a carcass that
arrives at a (uniform) random time during the time spanned by the search
schedule for the the given SE and CP parameters. This differs from the GenEst
estimation of g when the purpose is to estimate total mortality (M), in
which case the detection probability varies with carcass arrival interval
and is difficult to summarize statistically. <code>calcg</code> provides a 
useful &quot;big picture&quot; summary of detection probability, but would be 
difficult to work with for estimating M with precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcg(days, param_SE, param_CP, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcg_+3A_days">days</code></td>
<td>
<p>Search schedule (vector of days searched)</p>
</td></tr>
<tr><td><code id="calcg_+3A_param_se">param_SE</code></td>
<td>
<p>numeric array of searcher efficiency parameters (p and k);
must have the name number of rows as the <code>param_CP</code>.</p>
</td></tr>
<tr><td><code id="calcg_+3A_param_cp">param_CP</code></td>
<td>
<p>numeric array of carcass persistence parameters (a and b)
must have the name number of rows as the <code>param_SE</code>.</p>
</td></tr>
<tr><td><code id="calcg_+3A_dist">dist</code></td>
<td>
<p>distribution for the CP model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of detection probabilities for each
</p>

<hr>
<h2 id='calcRate'>Estimate the number of fatalities in each search interval throughout
the monitoring period.</h2><span id='topic+calcRate'></span>

<h3>Description</h3>

<p>A carcass that is observed in a given search may have arrived 
at any time prior to that search, so carcass discovery time is often not
a reliable estimate of carcass arrival time. For each observed carcass, 
<code>calcRate</code> takes into account the estimated probability of arrival
in each possible arrival interval, adjusts by detection probability, and 
sums to estimate the estimated number of carcass arrivals in every search
interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcRate(M, Aj, days = NULL, searches_carcass = NULL, data_SS = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcRate_+3A_m">M</code></td>
<td>
<p>Numeric array (ncarc x nsim) of estimated number of fatalities
by observed carcass and simulation rep</p>
</td></tr>
<tr><td><code id="calcRate_+3A_aj">Aj</code></td>
<td>
<p>Integer array (ncarc x nsim) of simulated arrival intervals for
each observed carcass. Arrival intervals are given as integers j, 
indicating that the given carcass (indexed by row) arrived in the jth
search interval in the given simulation rep (indexed by column). Arrival 
interval indices (j) are relative to indexed carcasses' search schedules.</p>
</td></tr>
<tr><td><code id="calcRate_+3A_days">days</code></td>
<td>
<p>Vector of all dates that at least one unit was searched. Format
is the number of days since the first search. For example, days = c(0, 7,
14, 28, 35) for a simple 7-day search schedule in which searches were
conducted every once per week on the same day for 5 weeks. Not all units
need be searched on every search date.</p>
</td></tr>
<tr><td><code id="calcRate_+3A_searches_carcass">searches_carcass</code></td>
<td>
<p>An ncarc x length(days) array of 0s and 1s to 
indicate searches in which the indexed carcass could have been found. 
For example, row i = <code>c(1, 0, 1, 0, 1)</code> indicates that the search 
schedule for the location (unit) where carcass i was found would be 
<code>days[c(1, 3, 5)]</code>.</p>
</td></tr>
<tr><td><code id="calcRate_+3A_data_ss">data_SS</code></td>
<td>
<p><code><a href="#topic+prepSS">prepSS</a></code> object that contains formatted data for
calculating splits. Optional argument. Alternatively, user may provide 
<code>days</code> and <code>searches_carcass</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric array (nsim x nsearch) of estimated fatalities in each
search interval. NOTE: The search at time t = 0 does not correspond to an
interval, and all carcasses found at that time are assumed to have 
arrived prior to the monitoring period and are not included in mortality 
estimates so <code>nsearch = length(days) - 1</code>.
</p>

<hr>
<h2 id='calcSplits'>Estimate the number of fatalities by up to two splitting covariates</h2><span id='topic+calcSplits'></span>

<h3>Description</h3>

<p>Total mortality can be split into sub-categories, according to
various splitting covariates such as species, visibility class, season, 
site, unit, etc. Given the carcass search data, estimated mortalities, 
and splitting covariates, <code>calcSplits()</code> gives the &quot;splits&quot; or 
summaries the estimated mortalities by levels of the splitting 
covariates. For example, user may specify <code>"season"</code> and 
<code>"species"</code> as splitting variables to see estimated mortalities by
season and species. Input would be arrays of estimated mortalities and
arrival intervals when <code>ncarc</code> carcass have been discovered and 
uncertainty in mortality estimates is captured via simulation with 
<code>nsim</code> simulation draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSplits(
  M,
  split_CO = NULL,
  data_CO = NULL,
  split_SS = NULL,
  data_SS = NULL,
  split_time = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcSplits_+3A_m">M</code></td>
<td>
<p><code><a href="#topic+estM">estM</a></code> object, containing numeric array (ncarc x nsim)
of estimated mortalities and other pieces</p>
</td></tr>
<tr><td><code id="calcSplits_+3A_split_co">split_CO</code></td>
<td>
<p>Character vector of names of splitting covariates to be
found in the <code>data_CO</code> data frame. No more than two <code>split_CO</code> 
variables are allowed. Use <code>split_CO = NULL</code> if no CO splits are 
desired.</p>
</td></tr>
<tr><td><code id="calcSplits_+3A_data_co">data_CO</code></td>
<td>
<p>data frame that summarizes the carcass search data and must
include columns specified by the <code>split_CO</code> arg. Each row includes
search and discovery parameters associated with a single observed 
carcass. Columns include carcass ID, carcass discovery date, unit, and 
any number of covariates. <code>data_CO</code> is required if and only if 
<code>split_CO</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="calcSplits_+3A_split_ss">split_SS</code></td>
<td>
<p>Character string giving the name of a splitting covariate 
in the <code>data_SS</code> list, with <code>data_SS[[split_SS]]</code> describing
characteristics of the search intervals (e.g., &quot;season&quot;). Note that
<code>length(data_SS[[split_SS]]</code> must equal 
<code>length(data_SS$days) - 1</code> because no inference is made about
carcass arrivals prior to time t = 0, and the &quot;interval&quot; prior to t = 0 
is not taken as a &quot;search interval.&quot; If no <code>split_SS</code> split is 
desired, use <code>split_SS = NULL</code>.</p>
</td></tr>
<tr><td><code id="calcSplits_+3A_data_ss">data_SS</code></td>
<td>
<p>Search schedule data</p>
</td></tr>
<tr><td><code id="calcSplits_+3A_split_time">split_time</code></td>
<td>
<p>Numeric vector that defines time intervals for splits.
Times must be numeric, strictly increasing, and span the monitoring period
[0, <code>max(data_SS$days)</code>]. If no <code>split_time</code> is desired, use
<code>split_time = NULL</code>. If <code>split_time</code> is NULL and <code>split_SS</code>
is not NULL, <code>data_SS</code> is required.</p>
</td></tr>
<tr><td><code id="calcSplits_+3A_...">...</code></td>
<td>
<p>arguments to be passed down</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arrival intervals (<code>Aj</code>) are given as integers, j, that
indicate which search interval the given carcass (indexed by row) arrived
in the given simulation draw (indexed by column). Arrival interval indices
(j) are relative to indexed carcasses' search schedules.
</p>
<p>No more than two splitting variables (<code>split_CO</code>, <code>split_SS</code>, 
and <code>split_time</code>) in total may be used. <code>split_CO</code> variables
describe qualitative characteristics of the observed carcasses or where
they were found. Some examples include searcher (DHD, JPS, MMH), carcass
size (S, M, L), species, age (fresh/dry or immature/mature), unit,
visibility class (easy, moderate, difficult), etc.
</p>
<p><code>split_SS</code> variables describe characteristics of the search intervals,
such as season (spring, summer, fall, winter) or treatment
(pre- or post-minimization). Each search interval is assigned a level of 
the <code>split_SS</code> variable. For example, for a search schedule with
5 searches (including a search at t = 0), and the <code>split_SS</code> 
variable would have values for each of the 4 search intervals. The
levels of the <code>split_SS</code> must be in contiguous blocks. For example,
<code>season = c("S", "S", "F", "F")</code> would be acceptable, but
<code>season = c("S", "F", "S", "F")</code> would not be.
</p>
<p><code>split_time</code> variables are numeric vectors that split the monitoring
period into distinct time intervals. For example,
<code>split_time = c(0, 30, 60, 90, 120)</code> would split the 120 monitoring
period into 30-day intervals, and <code>calcSplits()</code> would return 
mortality estimates for each of the intervals.
</p>


<h3>Value</h3>

<p>An object of class <code>splitFull</code> is returned. If one splitting
covariate is given, then the output will be an array of estimated
mortality in each level of the splitting covariate, with one row for each
covariate level and one column for each simulation draw. If two splitting
covariates are given, output will be a list of arrays. Each array gives
the estimated mortalities for one level of the second splitting covariate
and all levels of the first splitting covariate.
</p>
<p>Objects of class <code>splitFull</code> have attributes <code>vars</code> (which gives
the name of the splitting covariate(s)) and <code>type</code> (which specifies
whether the covariate(s) are of type <code>split_CO</code>, <code>split_SS</code>, or
<code>split_time</code>). A summary of a resulting <code>splitFull</code> object
is returned from the S3 function <code>summary(splits, CL = 0.90, ...)</code>,
which gives the mean and a 5-number summary for each level of each
covariate. The 5-number summary includes the alpha/2, 0.25, 0.5, 0.75,
and 1 - alpha/2 quantiles, where alpha = 1 - CL. A graph summarizing the
results can be drawn using <code>plot(splits, CL, ...)</code>, which gives
a graphical representation of the <code>summary</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  model_SE &lt;- pkm(p ~ 1, k ~ 1, data = wind_RPbat$SE)
  model_CP &lt;- cpm(l ~ 1, s ~ 1, data = wind_RPbat$CP, dist = "weibull",
    left = "LastPresent", right = "FirstAbsent")
  Mhat &lt;- estM(nsim = 1000, data_CO = wind_RPbat$CO, 
    data_SS = wind_RPbat$SS, data_DWP = wind_RPbat$DWP, 
    model_SE = model_SE, model_CP = model_CP,
    unitCol = "Turbine", COdate = "DateFound")

  M_spp &lt;- calcSplits(M = Mhat, split_CO = "Species",
    data_CO = wind_RPbat$CO)
  summary(M_spp)
  plot(M_spp)
 
</code></pre>

<hr>
<h2 id='calcTsplit'>Estimate the number of fatalities by time interval</h2><span id='topic+calcTsplit'></span>

<h3>Description</h3>

<p><code>calcTsplit()</code> is a lower-level function that requires 
the output of <code>calcRate</code> as input. See <code><a href="#topic+calcSplits">calcSplits</a></code> 
for a more powerful, convenient, and flexible alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcTsplit(rate, days, tsplit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcTsplit_+3A_rate">rate</code></td>
<td>
<p>Array (nsim x nsearch) of arrival rates as number of fatalities
per search interval. Typically, <code>rate</code> will be the return value of 
the <code>calcRate</code> function.</p>
</td></tr>
<tr><td><code id="calcTsplit_+3A_days">days</code></td>
<td>
<p>A vector of times representing search dates when at least one
unit was searched. Times are formatted as number of days since the first
search, e.g., c(0, 7, 14, 28, 35) would indicate a schedule in at least 
one unit was searched every 7 days.</p>
</td></tr>
<tr><td><code id="calcTsplit_+3A_tsplit">tsplit</code></td>
<td>
<p>A vector of times that splits the monitoring period into a
set of time intervals for which <code>calcTsplit</code> will estimate the 
number of fatalities. For example, if <code>tsplit = c(0, 14, 19, 35)</code>, 
then <code>calcTsplit</code> estimates the number of fatalities occuring in 
interval (0, 14], (14, 19], and (19, 35]. Times in <code>tsplit</code> must be 
increasing and between 0 and max(days), inclusive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric array with dimensions
<code>dim = c(length(tsplit) - 1, nsim)</code> giving the estimated number of
fatalities that occured in each time interval.
</p>

<hr>
<h2 id='checkComponents'>Check for model components</h2><span id='topic+checkComponents'></span>

<h3>Description</h3>

<p>Check if all component terms and interactions are
included in a formula. Terms are automatically alphabatized within
interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkComponents(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkComponents_+3A_formula">formula</code></td>
<td>
<p>A formula object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical regarding complete set of terms and interactions
</p>

<hr>
<h2 id='checkDate'>Checks whether a vector of data can be interpreted as dates</h2><span id='topic+checkDate'></span>

<h3>Description</h3>

<p>Checks whether the dates are in a standard format and 
sensible. If so, function returns the dates converted to ISO 8601 
yyyy-mm-dd format. Acceptable formats are yyyy-mm-dd, yyyy/mm/dd, 
mm/dd/yyyy, and dd/mm/yyyy. If format is mm/dd/yyyy or dd/mm/yyyy, the 
dates must be interpretable unambiguously. Also, dates must be later than 
1900-01-01. This additional check provides some protection against common 
data entry errors like entering a year as 0217 or 1017 instead of 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDate(testdate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDate_+3A_testdate">testdate</code></td>
<td>
<p>Date(s) to check and format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dates formatted as yyyy-mm-dd (if possible) or NULL (if some value
is not interpretable as a date after 1900-01-01).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> checkDate("02/20/2018")
 checkDate("10/08/2018")

</code></pre>

<hr>
<h2 id='checkSpecificModelCP'>Error check a specific model selection for a CP plot</h2><span id='topic+checkSpecificModelCP'></span>

<h3>Description</h3>

<p>Make sure it's available and good, update the name for usage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSpecificModelCP(modelSet, specificModel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSpecificModelCP_+3A_modelset">modelSet</code></td>
<td>
<p>cp model set of class cpmSet</p>
</td></tr>
<tr><td><code id="checkSpecificModelCP_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated name of the model to use
</p>

<hr>
<h2 id='checkSpecificModelSE'>Error check a specific model selection for an SE plot</h2><span id='topic+checkSpecificModelSE'></span>

<h3>Description</h3>

<p>Make sure it's available and good, update the name for usage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSpecificModelSE(modelSet, specificModel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSpecificModelSE_+3A_modelset">modelSet</code></td>
<td>
<p>pk model set of class pkmSet</p>
</td></tr>
<tr><td><code id="checkSpecificModelSE_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated name of the model to use
</p>

<hr>
<h2 id='CO_DWP'>Associate CO carcasses with appropriate DWP values (by unit and carcass class)</h2><span id='topic+CO_DWP'></span>

<h3>Description</h3>

<p>Calculate the conditional probability of observing a carcass
at search oi as a function arrival interval (assuming carcass is not
removed by scavengers before the time of the final search)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CO_DWP(dwpsim, data_CO, unitCol, sizeCol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CO_DWP_+3A_dwpsim">dwpsim</code></td>
<td>
<p><code>rdwp</code> object</p>
</td></tr>
<tr><td><code id="CO_DWP_+3A_data_co">data_CO</code></td>
<td>
<p>data frame with results from carcass surveys</p>
</td></tr>
<tr><td><code id="CO_DWP_+3A_unitcol">unitCol</code></td>
<td>
<p>name of the unit column in data_CO (required)</p>
</td></tr>
<tr><td><code id="CO_DWP_+3A_sizecol">sizeCol</code></td>
<td>
<p>name of the carcass class column in data_CO (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric DWP array
</p>

<hr>
<h2 id='combinePreds'>Combine predictors</h2><span id='topic+combinePreds'></span>

<h3>Description</h3>

<p>Create a table of combinations of factor levels for the
the predictors in a searcher efficiency or carcass persistence analysis.
This is a utility function called by <code>pkm0</code> and <code>cpm0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinePreds(preds, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combinePreds_+3A_preds">preds</code></td>
<td>
<p>Vector of character strings with the names of predictor
variables included in the model.</p>
</td></tr>
<tr><td><code id="combinePreds_+3A_data">data</code></td>
<td>
<p>Searcher efficiency or carcass persistence data frame with
columns for each predictor and rows corresponding to carcasses in the field
trials.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns for each predictor in <code>preds</code> and rows
for each factor level combination among the predictors. In addition there is
a column with <code>CellNames</code>, which are the combinations of predictor
levels separated by periods ( . ).
</p>

<hr>
<h2 id='combinePredsAcrossModels'>Combine predictors across models</h2><span id='topic+combinePredsAcrossModels'></span>

<h3>Description</h3>

<p>Create a table of factor combinations of predictors in given
searcher efficiency and carcass persistence models. This is a utility
function called by estgGeneric and governs the cells for which detection
probabilities are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinePredsAcrossModels(preds_CP, preds_SE, data_CP, data_SE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combinePredsAcrossModels_+3A_preds_cp">preds_CP</code></td>
<td>
<p>Character vector with names of carcass persistence predictors.</p>
</td></tr>
<tr><td><code id="combinePredsAcrossModels_+3A_preds_se">preds_SE</code></td>
<td>
<p>Character vector with names of searcher efficiency predictors.</p>
</td></tr>
<tr><td><code id="combinePredsAcrossModels_+3A_data_cp">data_CP</code></td>
<td>
<p>data frame with columns for each predictor and rows
corresponding to carcasses in the field trials.</p>
</td></tr>
<tr><td><code id="combinePredsAcrossModels_+3A_data_se">data_SE</code></td>
<td>
<p>data frame with columns for each predictor and rows
corresponding to carcasses in the field trials.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns for each predictor in <code>preds</code> and rows
for each factor level combination among the predictors. In addition there
are column with <code>CellNames</code>, <code>CellNames_CP</code>, and
<code>CellNames_SE</code>, which are the combinations of predictor levels for all
predictors, CP predictors, and SE predictors (respectively), separated by
periods ( . ).
</p>

<hr>
<h2 id='countCarcs'>Count the minimum number of carcasses in the cells</h2><span id='topic+countCarcs'></span>

<h3>Description</h3>

<p>Count the minimum number of carcasses in all of the cells
within a <code>_SetSize</code> model complex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countCarcs(mods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countCarcs_+3A_mods">mods</code></td>
<td>
<p>model output from the <code>_SetSize</code> version of a function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the minimum number of carcasses in the cells
</p>

<hr>
<h2 id='CPcols'>Produce a named vector of standard CP plot colors</h2><span id='topic+CPcols'></span>

<h3>Description</h3>

<p>Produce a named vector of standard CP plot colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPcols()
</code></pre>

<hr>
<h2 id='CPdistOptions'>Produce the options for the distributions in the CP model</h2><span id='topic+CPdistOptions'></span>

<h3>Description</h3>

<p>Simply make the named list for the disributions in the CP
model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPdistOptions()
</code></pre>


<h3>Value</h3>

<p>list with named elements of the distributions
</p>

<hr>
<h2 id='cpLogLik'>Calculate the negative log-likelihood of a carcass persistence model</h2><span id='topic+cpLogLik'></span>

<h3>Description</h3>

<p>The function used to calculate the negative-loglikelihood of
a given carcass persistence model (<code><a href="#topic+cpm">cpm</a></code>) with a given data
set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpLogLik(t1, t2, beta, nbeta_l, cellByCarc, cellMM, dataMM, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpLogLik_+3A_t1">t1</code></td>
<td>
<p>last times observed present</p>
</td></tr>
<tr><td><code id="cpLogLik_+3A_t2">t2</code></td>
<td>
<p>first times observed absent</p>
</td></tr>
<tr><td><code id="cpLogLik_+3A_beta">beta</code></td>
<td>
<p>Parameters to be optimized.</p>
</td></tr>
<tr><td><code id="cpLogLik_+3A_nbeta_l">nbeta_l</code></td>
<td>
<p>Number of parameters associated with l.</p>
</td></tr>
<tr><td><code id="cpLogLik_+3A_cellbycarc">cellByCarc</code></td>
<td>
<p>Which cell each observation belongs to.</p>
</td></tr>
<tr><td><code id="cpLogLik_+3A_cellmm">cellMM</code></td>
<td>
<p>Combined model matrix.</p>
</td></tr>
<tr><td><code id="cpLogLik_+3A_datamm">dataMM</code></td>
<td>
<p>Combined model matrix expanded to the data.</p>
</td></tr>
<tr><td><code id="cpLogLik_+3A_dist">dist</code></td>
<td>
<p>Name of distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log likelihood of the observations, given the parameters.
</p>

<hr>
<h2 id='cpm'>Fit cp carcass persistence models</h2><span id='topic+cpm'></span><span id='topic+cpm0'></span><span id='topic+cpmSet'></span><span id='topic+cpmSize'></span>

<h3>Description</h3>

<p>Carcass persistence is modeled as survival function where the 
one or both parameter(s) can depend on any number of covariates. Format 
and usage parallel that of common <code>R</code> functions such as <code>lm</code>, 
<code>glm</code>, and <code>gam</code>. However, the input data (<code>data</code>) are 
structured differently to accommodate the survival model approach (see 
&quot;Details&quot;), and model formulas may be entered for both <code>l</code> 
(&quot;location&quot;) and <code>s</code> (&quot;scale&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpm(
  formula_l,
  formula_s = NULL,
  data,
  left,
  right,
  dist = "weibull",
  allCombos = FALSE,
  sizeCol = NULL,
  CL = 0.9,
  quiet = FALSE
)

cpm0(
  formula_l,
  formula_s = NULL,
  data = NULL,
  left = NULL,
  right = NULL,
  dist = "weibull",
  CL = 0.9,
  quiet = FALSE
)

cpmSet(
  formula_l,
  formula_s = NULL,
  data,
  left,
  right,
  dist = c("exponential", "weibull", "lognormal", "loglogistic"),
  CL = 0.9,
  quiet = FALSE
)

cpmSize(
  formula_l,
  formula_s = NULL,
  data,
  left,
  right,
  dist = c("exponential", "weibull", "lognormal", "loglogistic"),
  sizeCol = NULL,
  allCombos = FALSE,
  CL = 0.9,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpm_+3A_formula_l">formula_l</code></td>
<td>
<p>Formula for location; an object of class 
&quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class):
a symbolic description of the model to be fitted. Details of model 
specification are given under &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="cpm_+3A_formula_s">formula_s</code></td>
<td>
<p>Formula for scale; an object of class 
&quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class):
a symbolic description of the model to be fitted. Details of model 
specification are given under &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="cpm_+3A_data">data</code></td>
<td>
<p>Data frame with results from carcass persistence trials and any
covariates included in <code>formula_l</code> or formula_s (required).</p>
</td></tr>
<tr><td><code id="cpm_+3A_left">left</code></td>
<td>
<p>Name of columns in <code>data</code> where the time of last present
observation is stored.</p>
</td></tr>
<tr><td><code id="cpm_+3A_right">right</code></td>
<td>
<p>Name of columns in <code>data</code> where the time of first absent
observation is stored.</p>
</td></tr>
<tr><td><code id="cpm_+3A_dist">dist</code></td>
<td>
<p>Distribution name (&quot;exponential&quot;, &quot;weibull&quot;, &quot;loglogistic&quot;, or 
&quot;lognormal&quot;)</p>
</td></tr>
<tr><td><code id="cpm_+3A_allcombos">allCombos</code></td>
<td>
<p>logical. If <code>allCombos = FALSE</code>, then the single model
expressed by <code>formula_l</code> and <code>formula_s</code> is fit using a call to
<code>cpm0</code>. If <code>allCombos = TRUE</code>, a full set of <code><a href="#topic+cpm">cpm</a></code>
submodels derived from combinations of the given covariates for <code>p</code>
and <code>k</code> is fit. For example, submodels of <code>formula_l = p ~ A * B</code>
would be <code>p ~ A * B</code>, <code>p ~ A + B</code>, <code>p ~ A</code>, <code>p ~ B</code>,
and <code>p ~ 1</code>. Models for each pairing of a <code>p</code> submodel with a
<code>k</code> submodel are fit via <code>cpmSet</code>, which fits each model
combination using successive calls to <code>cpm0</code>, which fits a
single model.</p>
</td></tr>
<tr><td><code id="cpm_+3A_sizecol">sizeCol</code></td>
<td>
<p>character string. The name of the column in <code>data</code> that
gives the size class of the carcasses in the field trials. If
<code>sizeCol = NULL</code>, then models are not segregated by size. If a
<code>sizeCol</code> is provided, then separate models are fit for the <code>data</code>
subsetted by <code>sizeCol</code>.</p>
</td></tr>
<tr><td><code id="cpm_+3A_cl">CL</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="cpm_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicator of whether or not to print messsages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability of a carcass persisting to a particular time is 
dictated by the specific distribution chosen and its underlying location
(l) and  scale (s) parameters (for all models except the exponential,  
which only has a location parameter). Both <code>l</code> and <code>s</code> may 
depend on covariates such as ground cover, season, species, etc., and a 
separate model format (<code>formula_l</code> and <code>formula_s</code>) may be 
entered for each. The models are entered as they would be in the familiar 
<code>lm</code> or <code>glm</code> functions in R. For example, <code>l</code> might vary
with <code>A</code>, <code>B</code>, and <code>C</code>, while <code>k</code> varies only with
<code>A</code>. A user might then enter <code>p ~ A + B + C</code> for <code>formula_l</code>
and <code>k ~ A</code> for <code>formula_s</code>. Other R conventions for defining
formulas may also be used, with <code>A:B</code> for the interaction between
covariates A and B and <code>A * B</code> as short-hand for <code>A + B + A:B</code>.
</p>
<p>Carcass persistence <code>data</code> must be entered in a data frame with data 
in each row giving the fate of a single carcass in the trials. There
must be a column for each of the last time the carcass was observed 
present and the first time the carcass was observed absent (or NA if the
carcass was always present). Additional columns with values for
categorical covariates (e.g., visibility = E, M, or D) may also be 
included.
</p>


<h3>Value</h3>

<p>an object of an object of class <code>cpm</code>, <code>cpmSet</code>,
<code>cpmSize</code>, or <code>cpmSetSize</code>.
</p>

<dl>
<dt><code>cpm0()</code></dt><dd><p>returns a <code>cpm</code> object, which is a description
of a single, fitted pk model. Due to the large number and complexity of
components of a<code>cpm</code> model, only a subset of them is printed
automatically; the rest can be viewed/accessed via the <code>$</code> operator
if desired. These are described in detail in the '<code>cpm</code> Components'
section.</p>
</dd>
<dt><code>cpmSet()</code></dt><dd><p>returns a list of <code>cpm</code> objects, one for each
of the submodels, as described with parameter <code>allCombos = TRUE</code>.</p>
</dd>
<dt><code>cpmSize()</code></dt><dd><p>returns a list of <code>cpmSet</code> objects (one for
each 'size') if <code>allCombos = T</code>, or a list of <code>cpm</code> objects (one
for each 'size') if <code>allCombos = T</code></p>
</dd>
<dt><code>cpm</code></dt><dd><p>returns a <code>cpm</code>, <code>cpmSet</code>, <code>cpmSize</code>, or
<code>cpmSetSize</code> object:
</p>

<ul>
<li> <p><code>cpm</code> object if <code>allCombos = FALSE, sizeCol = NULL</code>
</p>
</li>
<li> <p><code>cpmSet</code> object if <code>allCombos = TRUE, sizeCol = NULL</code>
</p>
</li>
<li> <p><code>cpmSize</code> object if <code>allCombos = FALSE, sizeCol != NULL</code>
</p>
</li>
<li> <p><code>cpmSetSize</code> object if <code>allCombos = TRUE, sizeCol != NULL</code>
</p>
</li></ul>

</dd>
</dl>



<h3><code>cpm</code> Components</h3>

<p>The following components of a <code>cpm</code> object are displayed automatically:
</p>

<dl>
<dt><code>call</code></dt><dd><p>the function call to fit the model</p>
</dd>
<dt><code>formula_l</code></dt><dd><p>the model formula for the <code>p</code> parameter</p>
</dd>
<dt><code>formula_s</code></dt><dd><p>the model formula for the <code>k</code> parameter</p>
</dd>
<dt><code>distribution</code></dt><dd><p>distribution used</p>
</dd>
<dt><code>predictors</code></dt><dd><p>list of covariates of <code>l</code> and/or <code>s</code></p>
</dd>
<dt><code>AICc</code></dt><dd><p>the AIC value as corrected for small sample size</p>
</dd>
<dt><code>convergence</code></dt><dd><p>convergence status of the numerical optimization
to find the maximum likelihood estimates of <code>p</code> and <code>k</code>. A
value of <code>0</code> indicates that the model was fit successfully. For
help in deciphering other values, see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>cell_ls</code></dt><dd><p>summary statistics for estimated cellwise
<code>l</code> and <code>s</code>, including the medians and upper &amp; lower bounds
on CIs for each parameter, indexed by cell (or combination of
covariate levels).</p>
</dd>
<dt><code>cell_ab</code></dt><dd><p>summary statistics for estimated cellwise
<code>pda</code> and <code>pdb</code>, including the medians and upper &amp; lower 
bounds on CIs for each parameter, indexed by cell (or combination of
covariate levels).</p>
</dd>
<dt><code>cell_desc</code></dt><dd><p>Descriptive statistics for estimated
cellwise median persistence time and rI for search intervals of 1, 3, 7
14, and 28 days, where rI is the probability of that carcass that arrives
at a uniform random time in within a search interval of I days persists
until the first search after arrival. </p>
</dd>
</dl>

<p>The following components are not printed automatically but can be accessed
via the <code>$</code> operator:
</p>

<dl>
<dt><code>data</code></dt><dd><p>the data used to fit the model</p>
</dd>
<dt><code>betahat_l</code></dt><dd><p>parameter estimates for the terms in the 
regression model for for <code>l</code></p>
</dd>
<dt><code>betahat_s</code></dt><dd><p>parameter estimates for the terms in the 
regression model for for <code>s</code>. If dist = &quot;exponential&quot;, <code>s</code> 
is set at 1 and not calculated.</p>
</dd>
<dt><code>varbeta</code></dt><dd><p>the variance-covariance matrix of the estimators
for <code>c(betahat_l, betahat_s</code>.</p>
</dd>
<dt><code>cellMM_l</code></dt><dd><p>a cellwise model (design) matrix for covariate 
structure of <code>l_formula</code></p>
</dd>
<dt><code>cellMM_s</code></dt><dd><p>a cellwise model(design) matrix for covariate 
structure of <code>s_formula</code></p>
</dd>
<dt><code>levels_l</code></dt><dd><p>all levels of each covariate of <code>l</code></p>
</dd>
<dt><code>levels_s</code></dt><dd><p>all levels of each covariate of <code>s</code></p>
</dd>
<dt><code>nbeta_l</code></dt><dd><p>number of parameters fit for <code>l</code></p>
</dd>
<dt><code>nbeta_s</code></dt><dd><p>number of parameters fit for <code>s</code></p>
</dd>
<dt><code>cells</code></dt><dd><p>cell structure of the cp-model, i.e., combinations of
all levels for each covariate of <code>p</code> and <code>k</code>. For example, if
<code>covar1</code> has levels <code>"a"</code>, <code>"b"</code>, and <code>"c"</code>, and
<code>covar2</code> has levels <code>"X"</code> and <code>"Y"</code>, then the cells 
would consist of <code>a.X</code>, <code>a.Y</code>, <code>b.X</code>, <code>b.Y</code>, 
<code>c.X</code>, and <code>c.Y</code>.</p>
</dd>
<dt><code>ncell</code></dt><dd><p>total number of cells</p>
</dd>
<dt><code>predictors_l</code></dt><dd><p>list of covariates of <code>l</code></p>
</dd>
<dt><code>predictors_s</code></dt><dd><p>list of covariates of <code>s</code></p>
</dd>
<dt><code>observations</code></dt><dd><p>observations used to fit the model</p>
</dd>
<dt><code>carcCells</code></dt><dd><p>the cell to which each carcass belongs</p>
</dd>
<dt><code>AIC</code></dt><dd><p>the 
<a href="https://en.wikipedia.org/wiki/Akaike_information_criterion">AIC</a>
value for the fitted model</p>
</dd>
<dt><code>CL</code></dt><dd><p>the input <code>CL</code></p>
</dd>
</dl>



<h3>Advanced</h3>

<p><code>cpmSize</code> may also be used to fit a single model for each size class if
<code>allCombos = FALSE</code>. To do so, <code>formula_l</code>, <code>formula_s</code>, and
<code>dist</code> be named lists with names matching the sizes listed in
<code>unique(data[, sizeCol])</code>. The return value is then a list of
<code>cpm</code> objects, one for each size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> head(data(wind_RP))
 mod1 &lt;- cpm(formula_l = l ~ Season, formula_s = s ~ 1, data = wind_RP$CP,
   left = "LastPresent", right = "FirstAbsent")
 class(mod1)
 mod2 &lt;- cpm(formula_l = l ~ Season, formula_s = s ~ 1, data = wind_RP$CP,
   left = "LastPresent", right = "FirstAbsent", allCombos = TRUE)
 class(mod2)
 names(mod2)
 class(mod2[[1]])
 mod3 &lt;- cpm(formula_l = l ~ Season, formula_s = s ~ 1, data = wind_RP$CP,
   left = "LastPresent", right = "FirstAbsent",
   allCombos = TRUE, sizeCol = "Size")
 class(mod3)
 names(mod3)
 class(mod3[[1]])
 class(mod3[[1]][[1]])

</code></pre>

<hr>
<h2 id='cpmCPCellPlot'>Plot cell-specific decay curve for carcass persistence</h2><span id='topic+cpmCPCellPlot'></span>

<h3>Description</h3>

<p>Produce the figure panel for a specific cell (factor
level combination) including the specific fitted decay curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmCPCellPlot(model, specificCell, col, axis_y = TRUE, axis_x = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmCPCellPlot_+3A_model">model</code></td>
<td>
<p>model of class cpm</p>
</td></tr>
<tr><td><code id="cpmCPCellPlot_+3A_specificcell">specificCell</code></td>
<td>
<p>name of the specific cell to plot</p>
</td></tr>
<tr><td><code id="cpmCPCellPlot_+3A_col">col</code></td>
<td>
<p>color to use</p>
</td></tr>
<tr><td><code id="cpmCPCellPlot_+3A_axis_y">axis_y</code></td>
<td>
<p>logical of whether or not to plot the y axis</p>
</td></tr>
<tr><td><code id="cpmCPCellPlot_+3A_axis_x">axis_x</code></td>
<td>
<p>logical of whether or not to plot the x axis</p>
</td></tr>
</table>

<hr>
<h2 id='cpmFail'>Check if a CP model is well-fit</h2><span id='topic+cpmFail'></span>

<h3>Description</h3>

<p>Run a check the arg is a well-fit cpm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmFail(cpmod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmFail_+3A_cpmod">cpmod</code></td>
<td>
<p>A <code><a href="#topic+cpm">cpm</a></code> object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value indicating a failed fit (TRUE) or successful (FALSE)
</p>

<hr>
<h2 id='cpmSetFail'>Check if cpm models fail</h2><span id='topic+cpmSetFail'></span>

<h3>Description</h3>

<p>Run a check on each model within a <code><a href="#topic+cpmSet">cpmSet</a></code> object
to determine if it failed or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmSetFail(cpmSetToCheck)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmSetFail_+3A_cpmsettocheck">cpmSetToCheck</code></td>
<td>
<p>A <code><a href="#topic+cpmSet">cpmSet</a></code> object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of logical values indicating if each of the models failed
</p>

<hr>
<h2 id='cpmSetFailRemove'>Remove failed cpm models from a <code><a href="#topic+cpmSet">cpmSet</a></code> object</h2><span id='topic+cpmSetFailRemove'></span>

<h3>Description</h3>

<p>Remove all failed models within a <code><a href="#topic+cpmSet">cpmSet</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmSetFailRemove(cpmSetToTidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmSetFailRemove_+3A_cpmsettotidy">cpmSetToTidy</code></td>
<td>
<p>A <code><a href="#topic+cpmSet">cpmSet</a></code> object to tidy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+cpmSet">cpmSet</a></code> object with failed models removed
</p>

<hr>
<h2 id='cpmSetSizeFail'>Check if all of the cpm models fail</h2><span id='topic+cpmSetSizeFail'></span>

<h3>Description</h3>

<p>Run a check on each model within a <code><a href="#topic+cpm">cpmSetSize</a></code>
object to determine if they all failed or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmSetSizeFail(cpmSetSizeToCheck)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmSetSizeFail_+3A_cpmsetsizetocheck">cpmSetSizeToCheck</code></td>
<td>
<p>A <code>cpmSetSize</code> object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of logical values indicating if each of the 
models failed
</p>

<hr>
<h2 id='cpmSetSizeFailRemove'>Remove failed cpm models from a <code>cpmSetSize</code> object</h2><span id='topic+cpmSetSizeFailRemove'></span>

<h3>Description</h3>

<p>Remove failed models from a <code><a href="#topic+cpm">cpmSetSize</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmSetSizeFailRemove(cpmSetSizeToTidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmSetSizeFailRemove_+3A_cpmsetsizetotidy">cpmSetSizeToTidy</code></td>
<td>
<p>A list of <code>cpmSetSize</code> objects to tidy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+cpmSet">cpmSet</a></code> objects with failed models removed
</p>

<hr>
<h2 id='cpmSetSpecCPCellPlot'>Plot cell-specific decay curve for carcass persistence</h2><span id='topic+cpmSetSpecCPCellPlot'></span>

<h3>Description</h3>

<p>Produce the figure panel for a specific cell (factor 
level combination) including the specific fitted decay curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpmSetSpecCPCellPlot(modelSet, specificModel, specificCell, cols, axes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpmSetSpecCPCellPlot_+3A_modelset">modelSet</code></td>
<td>
<p>modelSet of class cpmSet</p>
</td></tr>
<tr><td><code id="cpmSetSpecCPCellPlot_+3A_specificmodel">specificModel</code></td>
<td>
<p>name of the specific submodel to plot</p>
</td></tr>
<tr><td><code id="cpmSetSpecCPCellPlot_+3A_specificcell">specificCell</code></td>
<td>
<p>name of the specific cell to plot</p>
</td></tr>
<tr><td><code id="cpmSetSpecCPCellPlot_+3A_cols">cols</code></td>
<td>
<p>named vector of the colors to use for the distributions</p>
</td></tr>
<tr><td><code id="cpmSetSpecCPCellPlot_+3A_axes">axes</code></td>
<td>
<p>named vector of logical values indicating whether or not to 
plot the x axis and the y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a specific cell plot panel
</p>

<hr>
<h2 id='dateCols'>Select the date columns from a data table</h2><span id='topic+dateCols'></span>

<h3>Description</h3>

<p>Simple function to facilitate selection of date columns from
a data table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateCols(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dateCols_+3A_data">data</code></td>
<td>
<p>data table potentially containing columns that could be
coerced (via <code>checkDate()</code>) into a properly formatted date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of columns that can be coerced to dates
</p>

<hr>
<h2 id='dateToDay'>Calculate day of study from calendar date</h2><span id='topic+dateToDay'></span>

<h3>Description</h3>

<p>Convert calendar date to integer day from a reference date
(<code>ref</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateToDay(date, ref = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dateToDay_+3A_date">date</code></td>
<td>
<p>A date or vector of dates to convert to days.</p>
</td></tr>
<tr><td><code id="dateToDay_+3A_ref">ref</code></td>
<td>
<p>Reference date.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value(s) of days from <code>ref</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c("2018-01-01", "2018-02-01")
  dateToDay(x, x[1])

</code></pre>

<hr>
<h2 id='defineUnitCol'>Auto-parsing to find the name of the unit column (<code>unitCol</code>)</h2><span id='topic+defineUnitCol'></span>

<h3>Description</h3>

<p>If a unit column is not explicitly defined by user in the arg list to
<code>estM</code> or <code>estg</code>, then <code>defineUnitCol</code> parses the CO, DWP,
and SS files to extract the unit column if possible.
</p>
<p>Criteria that a column must meet to be a unit column are that it is found
in both <code>data_CO</code> and <code>data_DWP</code>, all units in <code>data_CO</code> must
also be included among units in <code>data_DWP</code>, all units in both
<code>data_CO</code> and <code>data_DWP</code> must be included among the column names
in <code>data_SS</code>. If <code>data_DWP = NULL</code>, then the unit column must be
included in <code>data_CO</code> and all its units must be included among the
column names of <code>data_SS</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineUnitCol(data_CO, data_SS = NULL, data_DWP = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defineUnitCol_+3A_data_co">data_CO</code></td>
<td>
<p>carcass observation data (data frame)</p>
</td></tr>
<tr><td><code id="defineUnitCol_+3A_data_ss">data_SS</code></td>
<td>
<p>search schedule data (data frame)</p>
</td></tr>
<tr><td><code id="defineUnitCol_+3A_data_dwp">data_DWP</code></td>
<td>
<p>density-weighted proportion data (data frame)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>name of unit column (<code>unitCol</code>), if a unique unit column can be
identified. If no unit column is present or there is more than one unit
column, <code>defineUnitCol</code> stops with an error.
</p>

<hr>
<h2 id='desc'>Descriptive statistics for a fitted CP model</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>Given a <code>cpm</code> object, calculate convenient descriptive statistics,
including the median CP, specified <code>rI</code> statistics, and <code>pda</code>
and <code>pdb</code> statistics for the fitted model (EoA parameterization), and
location and scale parameters for the fitted model (<code>survival</code> package
parameterization) along with estimated CIs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(model_CP, Ir = c(1, 3, 7, 14, 28), CL = 0.9, nsim = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="desc_+3A_model_cp">model_CP</code></td>
<td>
<p>A fitted CP model (<code>cpm</code> object)</p>
</td></tr>
<tr><td><code id="desc_+3A_ir">Ir</code></td>
<td>
<p>The intervals for which to calculate the r statistics</p>
</td></tr>
<tr><td><code id="desc_+3A_cl">CL</code></td>
<td>
<p>The confidence level for the CIs.</p>
</td></tr>
<tr><td><code id="desc_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulation draws for estimating CIs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CIs for the r statistics (and the medianCP for the Weibull) ara
based on simulation of the <code>pda</code> and <code>pdb</code> parameters, calculation
of the statistics, and taking the empirical distribution of the simulated
values. Other CIs are based on the assumed bivariate normal distributions of
the appropriately transformed <code>l</code> and <code>s</code> parameters in the fitted
model using <code>beta_hat</code> and <code>varbeta</code>.
</p>
<p>NOTE: <code>rI</code> is the probability that a carcass that arrives at a uniform random
time in an interval of <code>I</code> days will persist until the first search after
arrival.
</p>


<h3>Value</h3>

<p>Matrix of point and interval estimates for the median CP and the r
statistics for the specified intervals. The matrix is assigned to class
<code>descCP</code> that is simply a matrix with dimensions
<code>ncell x (1 + 3*(5 + length(Ir)))</code>, column names that give the number of
observations in each cell, statistic name and upper and lower bounds
(in triplets), and row names giving the names of the cells. <code>CL</code>, <code>nsim</code>,
and the name of the fitted model (<code>model_CP</code>) are included as object
attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpm">cpm</a></code>, <code><a href="#topic+rcp">rcp</a></code>, <code><a href="#topic+ppersist">ppersist</a></code>
</p>

<hr>
<h2 id='dlModTabSE'>Create the download version of the Searcher Efficiency model table</h2><span id='topic+dlModTabSE'></span>

<h3>Description</h3>

<p>Format a user-friendly version of the parameter table from
a Searcher Efficiency model, based on confidence level of interest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlModTabSE(modTab, CL = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlModTabSE_+3A_modtab">modTab</code></td>
<td>
<p>model table</p>
</td></tr>
<tr><td><code id="dlModTabSE_+3A_cl">CL</code></td>
<td>
<p>Confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>download version of the SE model table
</p>

<hr>
<h2 id='DWPCols'>Select the DWP-ok columns from a data table</h2><span id='topic+DWPCols'></span>

<h3>Description</h3>

<p>Simple function to facilitate selection of columns that could
be DWP values from a data table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DWPCols(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DWPCols_+3A_data">data</code></td>
<td>
<p>data table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of columns that can be DWP values
</p>

<hr>
<h2 id='dwpm'>Fit density-weighted proportion (DWP) models.</h2><span id='topic+dwpm'></span>

<h3>Description</h3>

<p>Carcass density is modeled as a function of distance from
turbine. Format and usage parallel that of common <code>R</code> functions
<code>lm</code>, <code>glm</code>, and <code>gam</code> and the GenEst functions <code>pkm</code>
and <code>cpm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwpm(data_DWP, type = "data", unitCol = NULL, dwpCols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dwpm_+3A_data_dwp">data_DWP</code></td>
<td>
<p>data frame with structure depending on model
type. In general, <code>data_DWP</code> would be a data frame if a model is to be
fit or if point estimates only are provided as pre-simulated DWP data, and,
if pre-simulated data with variation are provided, then a 2-d array (if one
carcass class) or a list of 2-d arrays (if more than one carcass class). See
&quot;Details&quot; for details.</p>
</td></tr>
<tr><td><code id="dwpm_+3A_type">type</code></td>
<td>
<p>model type may be <code>rings</code>, <code>glm</code>, <code>TWL</code>, or
<code>data</code>. Currently, only the <code>data</code> type is supported.</p>
</td></tr>
<tr><td><code id="dwpm_+3A_unitcol">unitCol</code></td>
<td>
<p>name of the column with the units, which must be non-numeric</p>
</td></tr>
<tr><td><code id="dwpm_+3A_dwpcols">dwpCols</code></td>
<td>
<p>name(s) of the columns with the DWP data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fraction of carcasses falling in the area searched at a turbine
may be a function of carcass class (e.g., large or small) and/or direction
from the turbine. Data may be provided for fitting a distance model(s) or,
alternatively, simulated turbine-wise DWP data from custom-fitted models may
be provided. If pre-fit, pre-simulated data are used, then <code>glm</code> returns
a <code>dwpm</code> object with <code>type = data</code>.
</p>
<p>To fit a model, <code>data_DWP</code> should be a data frame with a row for each carcass
and columns giving (at a minimum) unique carcass IDs, turbine ID, distance
from turbine, and fraction of area searched at the given distance at the
given turbine. Optional columns may include carcass class, covariates that may
influence detection probability (e.g., visibility class), and direction.
If covariates are to be included in the model, then the fraction of area
column would give the fraction of the area in the given covariate level at
that distance. Alternatively, prefab data may be provided in a dataframe,
with structure depending on data type. The simplest case would be that
point estimates only are provided. In that case, if there are no distinctions
among carcass classes (e.g., size), then <code>data_DWP</code> should be a dataframe
with one column giving the unit (e.g., turbine) and one column with the DWP
at each unit; if distinctions are made among carcass classes, then <code>data_DWP</code> would
be a data frame with a unit column and a DWP column for each carcass class. If
the DWP estimates incorporate uncertainties, then <code>data_DWP</code> should be
an array with <code>n_unit * nsim</code> rows and with colunms for units and DWPs for
each carcass class.
</p>


<h3>Value</h3>

<p>an object of an object of class <code>dwpm</code>, which is a list with
model <code>type</code> (currently only <code>type = data</code> is supported) and
<code>model</code>, which gives the simulated DWP values as an array (if there's
only a single carcass class) or a list of arrays (if there are more than one
carcass classes).
</p>

<hr>
<h2 id='estg'>Estimate all carcass-level detection rates and arrival intervals</h2><span id='topic+estg'></span>

<h3>Description</h3>

<p>Estimate g values and arrival intervals for a set of carcasses
from fitted pk and cp models and search data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estg(
  data_CO,
  COdate,
  data_SS,
  SSdate = NULL,
  model_SE,
  model_CP,
  model_DWP = NULL,
  sizeCol = NULL,
  unitCol = NULL,
  IDcol = NULL,
  nsim = 1000,
  max_intervals = 8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estg_+3A_data_co">data_CO</code></td>
<td>
<p>Carcass Observation data</p>
</td></tr>
<tr><td><code id="estg_+3A_codate">COdate</code></td>
<td>
<p>Column name for the date found data</p>
</td></tr>
<tr><td><code id="estg_+3A_data_ss">data_SS</code></td>
<td>
<p>Search Schedule data</p>
</td></tr>
<tr><td><code id="estg_+3A_ssdate">SSdate</code></td>
<td>
<p>Column name for the date searched data. Optional.
If not provided, <code>estg</code> will try to find the SSdate among
the columns in data_SS. See <code><a href="#topic+prepSS">prepSS</a></code>.</p>
</td></tr>
<tr><td><code id="estg_+3A_model_se">model_SE</code></td>
<td>
<p>Searcher Efficiency model (or list of models if there are
multiple carcass classes)</p>
</td></tr>
<tr><td><code id="estg_+3A_model_cp">model_CP</code></td>
<td>
<p>Carcass Persistence model (or list of models if there are
multiple carcass classes)</p>
</td></tr>
<tr><td><code id="estg_+3A_model_dwp">model_DWP</code></td>
<td>
<p>Density weighted proportion model (or list of models if
there are multiple carcass classes)</p>
</td></tr>
<tr><td><code id="estg_+3A_sizecol">sizeCol</code></td>
<td>
<p>Name of column in <code>data_CO</code> where the carcass classes
are recorded. Optional. If not provided, no distinctions are made among
sizes. <code>sizeCol</code> not only identifies what the name of the size
segregating class</p>
</td></tr>
<tr><td><code id="estg_+3A_unitcol">unitCol</code></td>
<td>
<p>Column name for the unit indicator</p>
</td></tr>
<tr><td><code id="estg_+3A_idcol">IDcol</code></td>
<td>
<p>Column name for unique carcass IDs (required)</p>
</td></tr>
<tr><td><code id="estg_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulation draws</p>
</td></tr>
<tr><td><code id="estg_+3A_max_intervals">max_intervals</code></td>
<td>
<p>maximum number of arrival interval intervals to 
consider for each carcass. Optional. Limiting the number of search 
intervals can greatly increase the speed of calculations with only a 
slight reduction in accuracy in most cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of [1] g estimates (<code>ghat</code>) and [2] arrival interval
estimates (<code>Aj</code>) for each of the carcasses. The row names of the
<code>Aj</code> matrix are the units at which carcasses were found. Row names of
<code>ghat</code> are the carcass IDs (in <code>data_CO</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(mock)
 model_SE &lt;- pkm(formula_p = p ~ HabitatType, formula_k = k ~ 1,
              data = mock$SE)
 model_CP &lt;- cpm(formula_l = l ~ Visibility, formula_s = s ~ Visibility, 
               data = mock$CP, dist = "weibull",
               left = "LastPresentDecimalDays", 
               right = "FirstAbsentDecimalDays"
             )
 ghat &lt;- estg(data_CO = mock$CO, COdate = "DateFound",  data_SS = mock$SS,
      model_SE = model_SE, model_CP = model_CP, unitCol = "Unit", nsim = 100)

</code></pre>

<hr>
<h2 id='estgGeneric'>Estimate generic g</h2><span id='topic+estgGeneric'></span>

<h3>Description</h3>

<p>Generic g estimation by simulation from given SE model and CP 
models under a specific search schedule.
</p>
<p>The g estimated by <code>estgGeneric</code> is a generic aggregate detection 
probability and represents the probability of detecting a carcass that 
arrives at a (uniform) random time during the period monitored, for each
of the possible cell combinations, given the SE and CP models. This 
is somethat different from the GenEst estimation of g when the purpose 
is to estimate total mortality (M), in which case the detection 
probability varies with carcass arrival interval and is difficult to 
summarize statistically. The <code>estgGeneric</code> estimate is a useful 
&quot;big picture&quot; summary of detection probability, but would be difficult
to work with for estimating M with precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estgGeneric(days, model_SE, model_CP, nsim = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estgGeneric_+3A_days">days</code></td>
<td>
<p>Search schedule data as a vector of days searched</p>
</td></tr>
<tr><td><code id="estgGeneric_+3A_model_se">model_SE</code></td>
<td>
<p>Searcher Efficiency model (<code>pkm</code> object)</p>
</td></tr>
<tr><td><code id="estgGeneric_+3A_model_cp">model_CP</code></td>
<td>
<p>Carcass Persistence model (<code>cpm</code> object)</p>
</td></tr>
<tr><td><code id="estgGeneric_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulation draws</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gGeneric</code> object that is a list of [1] a list of g estimates,
with one element in the list corresponding to each of the cells from the
cross-model combination and [2] a table of predictors and cell names 
associated with the gs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mock)
  model_SE &lt;- pkm(formula_p = p ~ HabitatType, formula_k = k ~ 1,
                data = mock$SE)
  model_CP &lt;- cpm(formula_l = l ~ Visibility, formula_s = s ~ Visibility, 
                data = mock$CP, left = "LastPresentDecimalDays", 
                right = "FirstAbsentDecimalDays")
  avgSS &lt;- averageSS(mock$SS)
  ghatsGeneric &lt;- estgGeneric(days = avgSS, model_SE = model_SE,
   model_CP = model_CP)

</code></pre>

<hr>
<h2 id='estgGenericSize'>Estimate generic detection probability for multiple carcass classes</h2><span id='topic+estgGenericSize'></span>

<h3>Description</h3>

<p>Generic g estimation for a combination of SE model and CP
model under a given search schedule
</p>
<p>The g estimated by <code>estgGenericSize</code> is a generic aggregate detection
probability and represents the probability of detecting a carcass that 
arrives at a (uniform) random time during the period monitored, for each
of the possible cell combinations, given the SE and CP models. This 
is somethat different from the GenEst estimation of g when the purpose 
is to estimate total mortality (M), in which case the detection 
probability varies with carcass arrival interval and is difficult to 
summarize statistically. The <code>estgGeneric</code> estimate is a useful 
&quot;big picture&quot; summary of detection probability, but would be difficult
to work with for estimating M with precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estgGenericSize(
  days,
  modelSetSize_SE,
  modelSetSize_CP,
  modelSizeSelections_SE,
  modelSizeSelections_CP,
  nsim = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estgGenericSize_+3A_days">days</code></td>
<td>
<p>Search schedule data as a vector of days searched</p>
</td></tr>
<tr><td><code id="estgGenericSize_+3A_modelsetsize_se">modelSetSize_SE</code></td>
<td>
<p>Searcher Efficiency model set for multiple sizes</p>
</td></tr>
<tr><td><code id="estgGenericSize_+3A_modelsetsize_cp">modelSetSize_CP</code></td>
<td>
<p>Carcass Persistence model set for multiple sizes</p>
</td></tr>
<tr><td><code id="estgGenericSize_+3A_modelsizeselections_se">modelSizeSelections_SE</code></td>
<td>
<p>vector of SE models to use, one for each 
size. Size names are required, and names must match those of
modelSetSize_SE. E.g., 
<code>c(lrg = "p ~ Visibility; k ~ 1", sml = "p ~ 1; k ~ 1")</code>.
Model formulas are read as text and must have exact matches among models
listed in modelSetSize_SE. For example, if one of the
<code>modelSizeSelections_SE</code> elements is
<code>lrg = "p ~ Visibility; k ~ 1"</code>, then <code>"p ~ Visibility; k ~ 1"</code>
must be in <code>names(modelSizeSelections_SE)[["lrg"]]</code>.</p>
</td></tr>
<tr><td><code id="estgGenericSize_+3A_modelsizeselections_cp">modelSizeSelections_CP</code></td>
<td>
<p>vector of CP models to use, one for each size</p>
</td></tr>
<tr><td><code id="estgGenericSize_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulation draws</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of g estimates, with one element in the list corresponding
to each of the cells from the cross-model combination
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mock)
  pkmModsSize &lt;- pkm(formula_p = p ~ HabitatType,
                   formula_k = k ~ HabitatType, data = mock$SE,
                   obsCol = c("Search1", "Search2", "Search3", "Search4"),
                   sizeCol = "Size", allCombos = TRUE)
  cpmModsSize &lt;- cpm(formula_l = l ~ Visibility,
                   formula_s = s ~ Visibility, data = mock$CP,
                   left = "LastPresentDecimalDays",
                   right = "FirstAbsentDecimalDays",
                   dist = c("exponential", "lognormal"),
                   sizeCol = "Size", allCombos = TRUE)

  pkMods &lt;- c("S" = "p ~ 1; k ~ 1", "L" = "p ~ 1; k ~ 1",
             "M" = "p ~ 1; k ~ 1", "XL" = "p ~ 1; k ~ 1"
            )
  cpMods &lt;- c("S" = "dist: exponential; l ~ 1; NULL", 
              "L" = "dist: exponential; l ~ 1; NULL",
              "M" = "dist: exponential; l ~ 1; NULL",
              "XL" = "dist: exponential; l ~ 1; NULL"
            )
  avgSS &lt;- averageSS(mock$SS)
  gsGeneric &lt;- estgGenericSize(nsim = 1000, days = avgSS,
                 modelSetSize_SE = pkmModsSize,
                 modelSetSize_CP = cpmModsSize,
                 modelSizeSelections_SE = pkMods,
                 modelSizeSelections_CP = cpMods
               )

</code></pre>

<hr>
<h2 id='estM'>Estimate mortality</h2><span id='topic+estM'></span>

<h3>Description</h3>

<p>Given given fitted Searcher Efficiency and Carcass 
Persistence models; Search Schedule, Density Weighted Proportion,
and Carcass Observation data; and information about the fraction of the
the facility that was surveyed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estM(
  data_CO,
  data_SS,
  data_DWP = NULL,
  frac = 1,
  COdate = "DateFound",
  model_SE,
  model_CP,
  model_DWP = NULL,
  unitCol = NULL,
  SSdate = NULL,
  sizeCol = NULL,
  IDcol = NULL,
  DWPCol = NULL,
  nsim = 1000,
  max_intervals = 8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estM_+3A_data_co">data_CO</code></td>
<td>
<p>Carcass Observation data</p>
</td></tr>
<tr><td><code id="estM_+3A_data_ss">data_SS</code></td>
<td>
<p>Search Schedule data</p>
</td></tr>
<tr><td><code id="estM_+3A_data_dwp">data_DWP</code></td>
<td>
<p>Survey unit (rows) by carcass class (columns) density weighted
proportion table</p>
</td></tr>
<tr><td><code id="estM_+3A_frac">frac</code></td>
<td>
<p>fraction carcasses on ground that was surveyed but not accounted
for in DWP</p>
</td></tr>
<tr><td><code id="estM_+3A_codate">COdate</code></td>
<td>
<p>Column name for the date found data</p>
</td></tr>
<tr><td><code id="estM_+3A_model_se">model_SE</code></td>
<td>
<p>Searcher Efficiency model (or list of models if there are
multiple carcass classes)</p>
</td></tr>
<tr><td><code id="estM_+3A_model_cp">model_CP</code></td>
<td>
<p>Carcass Persistence model (or list of models if there are
multiple carcass classes)</p>
</td></tr>
<tr><td><code id="estM_+3A_model_dwp">model_DWP</code></td>
<td>
<p>fitted dwp model (optional)</p>
</td></tr>
<tr><td><code id="estM_+3A_unitcol">unitCol</code></td>
<td>
<p>Column name for the unit indicator (optional)</p>
</td></tr>
<tr><td><code id="estM_+3A_ssdate">SSdate</code></td>
<td>
<p>Column name for the date searched data</p>
</td></tr>
<tr><td><code id="estM_+3A_sizecol">sizeCol</code></td>
<td>
<p>Name of colum in <code>data_CO</code> where the carcass classes
are recorded. Optional. If none provided, it is assumed there is no
distinctions among carcass classes.</p>
</td></tr>
<tr><td><code id="estM_+3A_idcol">IDcol</code></td>
<td>
<p>column with unique carcass (CO) identifier</p>
</td></tr>
<tr><td><code id="estM_+3A_dwpcol">DWPCol</code></td>
<td>
<p>Column name for the DWP values in the DWP table when no
carcass class is used and there is more than one column in <code>data_DWP</code>
that could be interpreted as DWP.</p>
</td></tr>
<tr><td><code id="estM_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulation draws</p>
</td></tr>
<tr><td><code id="estM_+3A_max_intervals">max_intervals</code></td>
<td>
<p>maximum number of arrival intervals to consider
for each carcass</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of Mhat, Aj, ghat, DWP (by carcass), and Xtot = total number of
carcasses observe
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(mock)
 model_SE &lt;- pkm(formula_p = p ~ HabitatType, formula_k = k ~ 1,
              data = mock$SE
             )
 model_CP &lt;- cpm(formula_l = l ~ Visibility, formula_s = s ~ Visibility, 
               data = mock$CP, dist = "weibull",
               left = "LastPresentDecimalDays", 
               right = "FirstAbsentDecimalDays"
             )
 eM &lt;- estM(nsim = 1000, data_CO = mock$CO, data_SS = mock$SS, 
         data_DWP = mock$DWP, frac = 1, model_SE = model_SE, 
         model_CP = model_CP, COdate = "DateFound",
         DWPCol = "S", sizeCol = NULL
       )
 
## End(Not run)

</code></pre>

<hr>
<h2 id='expandModelSetCP'>Expand a CP model set for plotting</h2><span id='topic+expandModelSetCP'></span>

<h3>Description</h3>

<p>Expand the exponential models across the other distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandModelSetCP(modelSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandModelSetCP_+3A_modelset">modelSet</code></td>
<td>
<p>cp model set of class cpmSet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated model set
</p>

<hr>
<h2 id='GenEst'>Generalized estimation of mortality</h2><span id='topic+GenEst'></span>

<h3>Description</h3>

<p>This package is designed to analyze searcher efficiency,
carcass persistence, search schedule, and carcass observation data for
the estimation of bird and bat mortality at wind and solar power 
facilities.
</p>


<h3>Information</h3>

<p><code>browseVignettes("GenEst")</code><br />
<code>packageDescription("GenEst")</code><br />
<code>disclaimerUSGS()</code><br />
<code>disclaimerWEST()</code><br />
</p>


<h3>Data sets</h3>

<p><code><a href="#topic+mock">mock</a></code><br />
<code><a href="#topic+wind_cleared">wind_cleared</a></code><br />
<code><a href="#topic+wind_RP">wind_RP</a></code><br />
<code><a href="#topic+wind_RPbat">wind_RPbat</a></code><br />
<code><a href="#topic+solar_powerTower">solar_powerTower</a></code><br />
<code><a href="#topic+solar_PV">solar_PV</a></code><br />
<code><a href="#topic+solar_trough">solar_trough</a></code><br />
</p>


<h3>Main command-line functions</h3>


<dl>
<dt><code><a href="#topic+pkm">pkm</a>, <a href="#topic+cpm">cpm</a>, <a href="#topic+dwpm">dwpm</a></code></dt><dd><p>estimate searcher efficiency
(<code>pk</code>), carcass persistence (<code>cp</code>), and (<code>dwp</code>) parameters</p>
</dd>
<dt><code><a href="#topic+estM">estM</a></code></dt><dd><p>estimate mortality given <code>pkm</code>, <code>cpm</code>
and data</p>
</dd>
<dt><code><a href="#topic+calcSplits">calcSplits</a></code></dt><dd><p>split mortality estimates by subcategories</p>
</dd>
<dt><code>plot</code></dt><dd><p>S3 function for <code><a href="#topic+plot.pkm">pkm</a></code>,
<code><a href="#topic+plot.pkmSet">pkmSet</a></code>, <code><a href="#topic+plot.cpm">cpm</a></code>,
<code><a href="#topic+plot.cpmSet">cpmSet</a></code>, <code><a href="#topic+plot.estM">estM</a></code>,
<code><a href="#topic+plot.splitFull">splitFull</a></code>,
<code><a href="#topic+plot.splitSummary">splitSummary</a></code>,
<code><a href="#topic+plot.gGeneric">gGeneric</a></code>, and
<code><a href="#topic+plot.gGenericSize">gGenericSize</a></code> objects</p>
</dd>
<dt><code><a href="#topic+transposeSplits">transposeSplits</a></code></dt><dd><p>transpose 2-d splits</p>
</dd>
<dt><code>summary</code></dt><dd><p>S3 function for <code><a href="#topic+summary.estM">estM</a></code>,
<code><a href="#topic+summary.splitFull">splitFull</a></code>,
<code><a href="#topic+summary.gGeneric">gGeneric</a></code>,
<code><a href="#topic+summary.gGenericSize">gGenericSize</a></code> objects</p>
</dd>
<dt><code><a href="#topic+aicc">aicc</a></code></dt><dd><p>S3 function for extracting models' AICc values
from <code><a href="#topic+pkm">pkm</a></code>, <code><a href="#topic+pkm">pkmSet</a></code>,
<code><a href="#topic+pkm">pkmSize</a></code>, <code><a href="#topic+pkm">pkmSetSize</a></code>, 
<code><a href="#topic+cpm">cpm</a></code>, <code><a href="#topic+cpm">cpmSet</a></code>,
<code><a href="#topic+cpm">cpmSize</a></code>, and <code><a href="#topic+cpm">cpmSetSize</a></code> objects</p>
</dd>
<dt><code><a href="#topic+desc">desc</a></code></dt><dd><p>Calculate descriptive statistics for a fitted
CP model</p>
</dd>
<dt><code><a href="#topic+estgGeneric">estgGeneric</a></code></dt><dd><p>estimate
detection probability (g) for given searcher efficiency and carcass
persistence model</p>
</dd>
<dt><code>runGenEst()</code></dt><dd><p>start the GUI</p>
</dd>
</dl>



<h3>Potentially useful calculation functions</h3>

<p><code><a href="#topic+rpk">rpk</a></code>, <code><a href="#topic+qpk">qpk</a></code>, <code><a href="#topic+rcp">rcp</a></code>, <code><a href="#topic+rdwp">rdwp</a></code><br />
<code><a href="#topic+estg">estg</a></code>, <code><a href="#topic+calcg">calcg</a></code><br />
<code><a href="#topic+ppersist">ppersist</a></code>, <code><a href="#topic+SEsi">SEsi</a></code><br />
<code><a href="#topic+alogit">alogit</a></code>, <code><a href="#topic+logit">logit</a></code><br />
<code><a href="#topic+pkLogLik">pkLogLik</a></code>, <code><a href="#topic+cpLogLik">cpLogLik</a></code><br />
<code><a href="#topic+calcRate">calcRate</a></code>, <code><a href="#topic+calcTsplit">calcTsplit</a></code>, 
<code><a href="#topic+ltranspose">ltranspose</a></code><br />
<code><a href="#topic+refMod">refMod</a></code><br />
<code><a href="#topic+countCarcs">countCarcs</a></code><br />
<code><a href="#topic+simpleMplot">simpleMplot</a></code><br />
</p>


<h3>Potentially useful editing functions</h3>

<p><code><a href="#topic+estgGenericSize">estgGenericSize</a></code><br />
<code><a href="#topic+prepSS">prepSS</a></code><br />
<code><a href="#topic+averageSS">averageSS</a></code><br />
<code><a href="#topic+tidyModelSetCP">tidyModelSetCP</a></code><br />
<code><a href="#topic+tidyModelSetSE">tidyModelSetSE</a></code><br />
<code><a href="#topic+checkDate">checkDate</a></code><br />
<code><a href="#topic+dateCols">dateCols</a></code><br />
<code><a href="#topic+dateToDay">dateToDay</a></code><br />
<code><a href="#topic+defineUnitCol">defineUnitCol</a></code><br />
<code><a href="#topic+dlModTabSE">dlModTabSE</a></code><br />
<code><a href="#topic+prettyModTabCP">prettyModTabCP</a></code><br />
<code><a href="#topic+prettyModTabSE">prettyModTabSE</a></code><br />
<code><a href="#topic+prettySplitTab">prettySplitTab</a></code><br />
</p>


<h3>Other functions</h3>

<p><code><a href="#topic+trimSetSize">trimSetSize</a></code><br />
<code><a href="#topic+combinePreds">combinePreds</a></code><br />
<code><a href="#topic+combinePredsAcrossModels">combinePredsAcrossModels</a></code><br />
<code><a href="#topic+pkmSetSizeFailRemove">pkmSetSizeFailRemove</a></code><br />
<code><a href="#topic+pkmSetFailRemove">pkmSetFailRemove</a></code><br />
<code><a href="#topic+cpmSetSizeFailRemove">cpmSetSizeFailRemove</a></code><br />
<code><a href="#topic+cpmSetSizeFail">cpmSetSizeFail</a></code><br />
<code><a href="#topic+cpmSetFailRemove">cpmSetFailRemove</a></code><br />
<code><a href="#topic+CO_DWP">CO_DWP</a></code><br />
<code><a href="#topic+CPcols">CPcols</a></code><br />
<code><a href="#topic+cpmCPCellPlot">cpmCPCellPlot</a></code><br />
<code><a href="#topic+cpmFail">cpmFail</a></code><br />
<code><a href="#topic+cpmSetFail">cpmSetFail</a></code><br />
<code><a href="#topic+cpmSetSpecCPCellPlot">cpmSetSpecCPCellPlot</a></code><br />
<code><a href="#topic+DWPCols">DWPCols</a></code><br />
<code><a href="#topic+expandModelSetCP">expandModelSetCP</a></code><br />
<code><a href="#topic+obsCols_SE">obsCols_SE</a></code><br />
<code><a href="#topic+pkmFail">pkmFail</a></code><br />
<code><a href="#topic+pkmSetAllFail">pkmSetAllFail</a></code><br />
<code><a href="#topic+pkmSetFail">pkmSetFail</a></code><br />
<code><a href="#topic+pkmSetSizeFail">pkmSetSizeFail</a></code><br />
<code><a href="#topic+plotCPCells">plotCPCells</a></code><br />
<code><a href="#topic+plotCPFigure">plotCPFigure</a></code><br />
<code><a href="#topic+plotCPHeader">plotCPHeader</a></code><br />
<code><a href="#topic+predsCols">predsCols</a></code><br />
<code><a href="#topic+SEsi_left">SEsi_left</a></code><br />
<code><a href="#topic+SEsi_right">SEsi_right</a></code><br />
<code><a href="#topic+SEsi0">SEsi0</a></code><br />
<code><a href="#topic+sizeCols">sizeCols</a></code><br />
<code><a href="#topic+matchCells">matchCells</a></code><br />
<code>checkComponents</code><br />
<code>checkSpecificModelCP</code><br />
<code>checkSpecificModelSE</code><br />
<code>combinePredsAcrossModels</code><br />
<code>CPdistOptions</code><br />
<code>obsCols_fta</code><br />
<code>obsCols_ltp</code><br />
<code>pkmParamPlot</code><br />
<code>pkmSECellPlot</code><br />
<code>pkmSet</code><br />
<code>pkmSetSpecParamPlot</code><br />
<code>pkmSetSpecSECellPlot</code><br />
<code>plotSEBoxPlots</code><br />
<code>plotSEBoxTemplate</code><br />
<code>plotSECells</code><br />
<code>plotSEFigure</code><br />
<code>plotSEHeader</code><br />
<code>prepPredictors</code><br />
<code>readCSV</code><br />
<code>removeCols</code><br />
</p>


<h3>Internal functions (not exported)</h3>

<p><code>_GenEst_calcRateC</code><br />
<code>_GenEst_calcTsplitC</code><br />
<code>calcRateC</code><br />
<code>calcTsplitC</code><br />
<code>aboutContent</code><br />
<code>aboutPanel</code><br />
<code>analysisPanel</code><br />
<code>b</code><br />
<code>big</code><br />
<code>cButtonStyle</code><br />
<code>center</code><br />
<code>classText</code><br />
<code>clearNotifications</code><br />
<code>CPMainPanel</code><br />
<code>CPPanel</code><br />
<code>downloadCPFig</code><br />
<code>estText</code><br />
<code>CPSidebar</code><br />
<code>initialReactiveValues</code><br />
<code>createvtext</code><br />
<code>dataDownloadWidget</code><br />
<code>dataInputPanel</code><br />
<code>dataInputSidebar</code><br />
<code>dataInputWidget</code><br />
<code>dataTabPanel</code><br />
<code>disclaimersContent</code><br />
<code>disclaimersPanel</code><br />
<code>downloadCPFig</code><br />
<code>downloadCPMod</code><br />
<code>downloadCPMres</code><br />
<code>downloadSEmod</code><br />
<code>downloadgFig</code><br />
<code>downloadMFig</code><br />
<code>downloadSEFig</code><br />
<code>downloadsPanel</code><br />
<code>downloadTable</code><br />
<code>eventReaction</code><br />
<code>GeneralInputSidebar</code><br />
<code>GeneralInputsPanel</code><br />
<code>GenEstAcknowledgements</code><br />
<code>GenEstAuthors</code><br />
<code>GenEstGUIauthors</code><br />
<code>GenEstInlineCSS</code><br />
<code>GenEstLicense</code><br />
<code>GenEstLogos</code><br />
<code>GenEstShinyJS</code><br />
<code>GenEstUI</code><br />
<code>GenEstServer</code><br />
<code>gettingStartedContent</code><br />
<code>gettingStartedPanel</code><br />
<code>gMainPanel</code><br />
<code>gPanel</code><br />
<code>gSidebar</code><br />
<code>helpPanel</code><br />
<code>initialOutput</code><br />
<code>kFixedWidget</code><br />
<code>kFixedWidgetHeader</code><br />
<code>kFixedWidgetRow</code><br />
<code>li</code><br />
<code>loadedDataPanel</code><br />
<code>MMainPanel</code><br />
<code>modelInputWidget</code><br />
<code>modelOutputPanel</code><br />
<code>modelOutputWidget</code><br />
<code>modelRunWidget</code><br />
<code>modelSelectionWidget</code><br />
<code>modelSelectionWidgetHeader</code><br />
<code>modelSelectionWidgetRow</code><br />
<code>modelSetCells</code><br />
<code>modelSetModelCells</code><br />
<code>modelSetModelPredictors</code><br />
<code>modelSetPredictors</code><br />
<code>modNamePaste</code><br />
<code>modNameSplit</code><br />
<code>MPanel</code><br />
<code>msgFracNote</code><br />
<code>msgList</code><br />
<code>msgModDone</code><br />
<code>msgModFail</code><br />
<code>msgModPartialFail</code><br />
<code>msgModRun</code><br />
<code>msgModSENobs</code><br />
<code>msgModWarning</code><br />
<code>msgSampleSize</code><br />
<code>msgSplitFail</code><br />
<code>msgSSavgFail</code><br />
<code>msgSSinputFail</code><br />
<code>MSidebar</code><br />
<code>navbar</code><br />
<code>ol</code><br />
<code>pickSizeclass</code><br />
<code>plotNA</code><br />
<code>prepSizeclassText</code><br />
<code>preTextMaker</code><br />
<code>reaction</code><br />
<code>reactionMessageDone</code><br />
<code>reactionMessageRun</code><br />
<code>reNULL</code><br />
<code>reVal</code><br />
<code>SEboxes</code><br />
<code>SEcols</code><br />
<code>selectData</code><br />
<code>selectedDataPanel</code><br />
<code>SEMainPanel</code><br />
<code>SEPanel</code><br />
<code>SEpanel</code><br />
<code>SESidebar</code><br />
<code>setkNeed</code><br />
<code>setNotSuspending</code><br />
<code>small</code><br />
<code>splitButtonWidget</code><br />
<code>style</code><br />
<code>trimSetSize</code><br />
<code>u</code><br />
<code>ul</code><br />
<code>update_input</code><br />
<code>update_output</code><br />
<code>update_rv</code><br />
<code>updateColNames_size</code><br />
<code>updateSizeclasses</code><br />
<code>updatesizeCol</code><br />
<code>widgetMaker</code><br />
</p>

<hr>
<h2 id='logit'>Compute the logit or anti-logit</h2><span id='topic+logit'></span><span id='topic+alogit'></span>

<h3>Description</h3>

<p>Compute the logit or anti-logit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)

alogit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>A number. For  <code>logit</code>, a probability (between 0 and 1, 
inclusive). For  <code>alogit</code>, any real number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logit</code>: The logit of <code>x</code>.
</p>
<p><code>alogit</code>:  The anti-logit of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  logit(0.5)

  alogit(0)

</code></pre>

<hr>
<h2 id='ltranspose'>Transpose a list of arrays</h2><span id='topic+ltranspose'></span>

<h3>Description</h3>

<p>A list of <code>n</code> arrays, each with dimension <code>m</code> x 
<code>k</code> is redimensioned to a list of <code>m</code> arrays, each with 
dimension <code>m</code> x <code>k</code>. NOTE: Attributes are not preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltranspose(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ltranspose_+3A_m">M</code></td>
<td>
<p>a list of <code>n</code> <code>m</code> x <code>k</code> arrays</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>m</code> <code>n</code> x <code>k</code> arrays
</p>

<hr>
<h2 id='mock'>A mock example data set</h2><span id='topic+mock'></span>

<h3>Description</h3>

<p>A template dataset used for testing purposes.  Dataset containing SE, CP, SS,
DWP, and CO data. Data are mostly random without patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mock
</code></pre>


<h3>Format</h3>

<p>A list with 5 items:
</p>

<dl>
<dt>SE</dt><dd><p>Searcher efficiency trial data</p>
</dd>
<dt>CP</dt><dd><p>Carcass persistence trial data</p>
</dd>
<dt>SS</dt><dd><p>Search schedule data</p>
</dd>
<dt>DWP</dt><dd><p>Density weighted proportion of area searched data</p>
</dd>
<dt>CO</dt><dd><p>Carcass observations</p>
</dd>   
</dl>



<h3>Source</h3>

<p><code>mock</code>
</p>

<hr>
<h2 id='model_utility_functions'>model utility functions (not exported)</h2><span id='topic+model_utility_functions'></span><span id='topic+matchCells'></span><span id='topic+modelSetModelPredictors'></span><span id='topic+modelSetPredictors'></span><span id='topic+modelSetModelCells'></span><span id='topic+modelSetCells'></span>

<h3>Description</h3>

<p>model utility functions that are not exported
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchCells(specific, modelSet)

modelSetModelPredictors(modelSet)

modelSetPredictors(modelSet)

modelSetModelCells(modelSet)

modelSetCells(modelSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_utility_functions_+3A_specific">specific</code></td>
<td>
<p>specific model compared against the full set</p>
</td></tr>
<tr><td><code id="model_utility_functions_+3A_modelset">modelSet</code></td>
<td>
<p>full model set to compare to the specific</p>
</td></tr>
</table>

<hr>
<h2 id='obsCols_fta'>Select the columns from a data table that could be CP First Time
Absent observations</h2><span id='topic+obsCols_fta'></span>

<h3>Description</h3>

<p>Simple function to facilitate selection of columns that could
be First Time Absent observations for a CP model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsCols_fta(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsCols_fta_+3A_data">data</code></td>
<td>
<p>data table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of columns that can be observations
</p>

<hr>
<h2 id='obsCols_ltp'>Select the columns from a data table that could be CP Last Time
Present observations</h2><span id='topic+obsCols_ltp'></span>

<h3>Description</h3>

<p>Simple function to facilitate selection of columns that could
be Last Time Present observations for a CP model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsCols_ltp(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsCols_ltp_+3A_data">data</code></td>
<td>
<p>data table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of columns that can be observations
</p>

<hr>
<h2 id='obsCols_SE'>Select the columns from a data table that could be SE observations</h2><span id='topic+obsCols_SE'></span>

<h3>Description</h3>

<p>Simple function to facilitate selection of columns that could
be observations for an SE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsCols_SE(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsCols_SE_+3A_data">data</code></td>
<td>
<p>data table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of columns that can be observations
</p>

<hr>
<h2 id='pkLogLik'>Calculate the negative log-likelihood of a searcher efficiency model</h2><span id='topic+pkLogLik'></span>

<h3>Description</h3>

<p>The function used to calculate the negative-loglikelihood of
a given searcher efficiency model (<code><a href="#topic+pkm">pkm</a></code>) with a given data
set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkLogLik(
  misses,
  foundOn,
  beta,
  nbeta_p,
  cellByCarc,
  maxmisses,
  cellMM,
  kFixed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkLogLik_+3A_misses">misses</code></td>
<td>
<p>Number of searches when carcass was present but
not found.</p>
</td></tr>
<tr><td><code id="pkLogLik_+3A_foundon">foundOn</code></td>
<td>
<p>Search on which carcass was found.</p>
</td></tr>
<tr><td><code id="pkLogLik_+3A_beta">beta</code></td>
<td>
<p>Parameters to be optimized.</p>
</td></tr>
<tr><td><code id="pkLogLik_+3A_nbeta_p">nbeta_p</code></td>
<td>
<p>Number of parameters associated with p.</p>
</td></tr>
<tr><td><code id="pkLogLik_+3A_cellbycarc">cellByCarc</code></td>
<td>
<p>Which cell each observation belongs to.</p>
</td></tr>
<tr><td><code id="pkLogLik_+3A_maxmisses">maxmisses</code></td>
<td>
<p>Maximum possible number of misses for a carcass.</p>
</td></tr>
<tr><td><code id="pkLogLik_+3A_cellmm">cellMM</code></td>
<td>
<p>Combined pk model matrix.</p>
</td></tr>
<tr><td><code id="pkLogLik_+3A_kfixed">kFixed</code></td>
<td>
<p>Value of k if fixed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log likelihood of the observations, given the parameters.
</p>

<hr>
<h2 id='pkm'>Fit pk searcher efficiency models.</h2><span id='topic+pkm'></span><span id='topic+pkm0'></span><span id='topic+pkmSet'></span><span id='topic+pkmSize'></span>

<h3>Description</h3>

<p>Searcher efficiency is modeled as a function of the number of
times a carcass has been missed in previous searches and any number of
covariates. Format and usage parallel that of common <code>R</code> functions
<code>lm</code>, <code>glm</code>, and <code>gam</code>. However, the input data
(<code>data</code>) is structured differently to accommodate the
multiple-search searcher efficiency trials (see Details), and model
formulas may be entered for both <code>p</code> (akin to an intercept) and
<code>k</code> (akin to a slope).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkm(
  formula_p,
  formula_k = NULL,
  data,
  obsCol = NULL,
  kFixed = NULL,
  allCombos = FALSE,
  sizeCol = NULL,
  CL = 0.9,
  kInit = 0.7,
  quiet = FALSE,
  ...
)

pkm0(
  formula_p,
  formula_k = NULL,
  data,
  obsCol = NULL,
  kFixed = NULL,
  kInit = 0.7,
  CL = 0.9,
  quiet = FALSE
)

pkmSet(
  formula_p,
  formula_k = NULL,
  data,
  obsCol = NULL,
  kFixed = NULL,
  kInit = 0.7,
  CL = 0.9,
  quiet = FALSE
)

pkmSize(
  formula_p,
  formula_k = NULL,
  data,
  kFixed = NULL,
  obsCol = NULL,
  sizeCol = NULL,
  allCombos = FALSE,
  kInit = 0.7,
  CL = 0.9,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkm_+3A_formula_p">formula_p</code></td>
<td>
<p>Formula for p; an object of class <code><a href="stats.html#topic+formula">formula</a></code>
(or one that can be coerced to that class): a symbolic description of
the model to be fitted. Details of model specification are given under
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="pkm_+3A_formula_k">formula_k</code></td>
<td>
<p>Formula for k; an object of class <code><a href="stats.html#topic+formula">formula</a></code>
(or one that can be coerced to that class): a symbolic description of the
model to be fitted. Details of model specification are given under
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="pkm_+3A_data">data</code></td>
<td>
<p>Data frame with results from searcher efficiency trials and any
covariates included in <code>formula_p</code> or <code>formula_k</code> (required).</p>
</td></tr>
<tr><td><code id="pkm_+3A_obscol">obsCol</code></td>
<td>
<p>Vector of names of columns in <code>data</code> where results
for each search occasion are stored (optional). If <code>obsCol</code> is not
provided, <code>pkm</code> uses as <code>obsCol</code> all columns with names that
begin with an <code>"s"</code> or <code>"S"</code> and end with a number, e.g., &quot;s1&quot;,
&quot;s2&quot;, &quot;s3&quot;, etc. This option is included as a convenience for the user,
but care must be taken that other data are not stored in columns with
names matching that pattern. Alternatively, <code>obsCol</code> may be
entered as a vector of names, like <code>c("s1", "s2", "s3")</code>,
<code>paste0("s", 1:3)</code>, or <code>c("initialSearch", "anotherSearch",
"lastSearch")</code>. The columns must be in chronological order, that is, it is
assumed that the first column is for the first search after carcass arrival,
the second column is for the second search, etc.</p>
</td></tr>
<tr><td><code id="pkm_+3A_kfixed">kFixed</code></td>
<td>
<p>Parameter for user-specified <code>k</code> value (optional). If a
value is provided, <code>formula_k</code> is ignored and the model is fit under
the assumption that the <code>k</code> parameter is fixed and known to be
<code>kFixed</code> <code class="reqn">\in [0, 1]</code>. If a <code>sizeCol</code> is provided, <code>kFixed</code>
may either be <code>NULL</code>, a single number in [0, 1], or a vector with
<code>kFixed</code> values for two or more of the carcass size classes. For
example, if there are three sizes (<code>S</code>, <code>M</code>, and <code>L</code>),
<code>kFixed</code> could be <code>c(S = 0.3, M = 0.8, L = 1.0)</code> to assign fixed
<code>k</code> values to each size. To fit <code>k</code> for size <code>S</code> and to assign
values of 0.8 and 1.0 to sizes <code>M</code> and <code>L</code>, resp., use
<code>kFixed = c(S = 0.3, M = 0.8, L = 1.0)</code>. If there are more than one size
classes and <code>kFixed</code> is a scalar, then all size classes are assigned the
same <code>kFixed</code> value (unless <code>kFixed</code> is named, e.g.,
<code>kFixed = c(S = 0.5)</code>, in which case only the named size is assigned the
<code>kFixed</code>).</p>
</td></tr>
<tr><td><code id="pkm_+3A_allcombos">allCombos</code></td>
<td>
<p>logical. If <code>allCombos = FALSE</code>, then the single model
expressed by <code>formula_p</code> and <code>formula_k</code> is fit using a call to
<code>pkm0</code>. If <code>allCombos = TRUE</code>, a full set of <code><a href="#topic+pkm">pkm</a></code>
submodels derived from combinations of the given covariates for <code>p</code>
and <code>k</code> is fit. For example, submodels of <code>formula_p = p ~ A * B</code>
would be <code>p ~ A * B</code>, <code>p ~ A + B</code>, <code>p ~ A</code>, <code>p ~ B</code>,
and <code>p ~ 1</code>. Models for each pairing of a <code>p</code> submodel with a
<code>k</code> submodel are fit via <code>pkmSet</code>, which fits each model
combination using successive calls to <code>pkm0</code>, which fits a
single model.</p>
</td></tr>
<tr><td><code id="pkm_+3A_sizecol">sizeCol</code></td>
<td>
<p>character string. The name of the column in <code>data</code> that
gives the carcass class of the carcasses in the field trials. If
<code>sizeCol = NULL</code>, then models are not segregated by size. If a
<code>sizeCol</code> is provided, then separate models are fit for the <code>data</code>
subsetted by <code>sizeCol</code>.</p>
</td></tr>
<tr><td><code id="pkm_+3A_cl">CL</code></td>
<td>
<p>numeric value in (0, 1). confidence level</p>
</td></tr>
<tr><td><code id="pkm_+3A_kinit">kInit</code></td>
<td>
<p>numeric value in (0, 1). Initial value used for numerical
optimization of <code>k</code>. Default is <code>kInit = 0.7</code>. It is rarely
(if ever) necessary to use an alternative initial value.</p>
</td></tr>
<tr><td><code id="pkm_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicator of whether or not to print messsages</p>
</td></tr>
<tr><td><code id="pkm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to subfunctions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability of finding a carcass that is present at the time of
search is <code>p</code> on the first search after carcass arrival and is
assumed to decrease by a factor of <code>k</code> each time the carcass is
missed in searches. Both <code>p</code> and <code>k</code> may depend on covariates
such as ground cover, season, species, etc., and a separate model format
(<code>formula_p</code> and <code>formula_k</code>) may be entered for each. The
models are entered as they would be in the familiar <code>lm</code> or
<code>glm</code> functions in R. For example, <code>p</code> might vary with
<code>A</code> and <code>B</code>, while <code>k</code> varies
only with <code>A</code>. A user might then enter <code>p ~ A + B</code>
for <code>formula_p</code> and <code>k ~ A</code> for
<code>formula_k</code>. Other R conventions for defining formulas may also be
used, with <code>A:B</code> for the interaction between covariates
A and B and <code>A * B</code> as short-hand for <code>A + B + A:B</code>.
</p>
<p>Search trial <code>data</code> must be entered in a data frame with data in
each row giving the fate of a single carcass in the field trials. There
must be a column for each search occassion, with 0, 1, or NA depending on
whether the carcass was missed, found, or not available (typically
because it was found and removed on a previous search, had been earlier
removed by  scavengers, or was not searched for) on the given search
occasion. Additional columns with values for categorical covariates
(e.g., visibility = E, M, or D) may also be included.
</p>
<p>When all trial carcasses are either found on the first search or
are missed on the first search after carcass placement, pkm effects a
necessary adjustment to the for accuracy; otherwise, the model would not be
able to determine the uncertainty and would substantially over-estimate the
variance of the parameter estimates, giving <code class="reqn">\hat{p}</code> essentially equal
to 0 or 1 with approximately equal probability. The adjustment is to fit the
model on an adjusted data set with duplicated copies of the original data
(<code>2n</code> observations) but with one carcass having the opposite fate of the
others. For example, in field trials with very high searcher efficiency and
<code>n = 10</code> carcasses, all of which are found in the first search after
carcass placement, the original data set would have a carcass observation
column consisting of 1s (<code>rep(1, 10)</code>). The adjusted data set would
have an observation column consisting of <code>2n - 1</code> 1s and one 0. In this
case, the point estimate of <code>p</code> is <code>1/(2n)</code> with distribution that
closely resembling the Bayesian posterior distributions of <code>p</code> with a
uniform or a Jeffreys prior. The adjustment is applied on a cellwise basis
in full cell models (e.g., 1, A, B, A * B). In the additive model with two
predictors (A + B), the adjustment is made only when a full level of
covariate A or B is all 0s or 1s.
</p>


<h3>Value</h3>

<p>an object of an object of class <code>pkm</code>, <code>pkmSet</code>,
<code>pkmSize</code>, or <code>pkmSetSize</code>.
</p>

<dl>
<dt><code>pkm0()</code></dt><dd><p>returns a <code>pkm</code> object, which is a description
of a single, fitted pk model. Due to the large number and complexity of
components of a<code>pkm</code> model, only a subset of them is printed
automatically; the rest can be viewed/accessed via the <code>$</code> operator
if desired. These are described in detail in the '<code>pkm</code> Components'
section.</p>
</dd>
<dt><code>pkmSet()</code></dt><dd><p>returns a list of <code>pkm</code> objects, one for each
of the submodels, as described with parameter <code>allCombos = TRUE</code>.</p>
</dd>
<dt><code>pkmSize()</code></dt><dd><p>returns a list of <code>pkmSet</code> objects (one for
each 'size') if <code>allCombos = T</code>, or a list of <code>pkm</code> objects (one
for each 'size') if <code>allCombos = T</code></p>
</dd>
<dt><code>pkm</code></dt><dd><p>returns a <code>pkm</code>, <code>pkmSet</code>, <code>pkmSize</code>, or
<code>pkmSetSize</code> object:
</p>

<ul>
<li> <p><code>pkm</code> object if <code>allCombos = FALSE, sizeCol = NULL</code>
</p>
</li>
<li> <p><code>pkmSet</code> object if <code>allCombos = TRUE, sizeCol = NULL</code>
</p>
</li>
<li> <p><code>pkmSize</code> object if <code>allCombos = FALSE, sizeCol != NULL</code>
</p>
</li>
<li> <p><code>pkmSetSize</code> object if <code>allCombos = TRUE, sizeCol != NULL</code>
</p>
</li></ul>

</dd>
</dl>



<h3><code>pkm</code> Components</h3>

<p>The following components of a <code>pkm</code> object are displayed automatically:
</p>

<dl>
<dt><code>call</code></dt><dd><p>the function call to fit the model</p>
</dd>
<dt><code>formula_p</code></dt><dd><p>the model formula for the <code>p</code> parameter</p>
</dd>
<dt><code>formula_k</code></dt><dd><p>the model formula for the <code>k</code> parameter</p>
</dd>
<dt><code>predictors</code></dt><dd><p>list of covariates of <code>p</code> and/or <code>k</code></p>
</dd>
<dt><code>AICc</code></dt><dd><p>the AIC value as corrected for small sample size</p>
</dd>
<dt><code>convergence</code></dt><dd><p>convergence status of the numerical optimization
to find the maximum likelihood estimates of <code>p</code> and <code>k</code>. A
value of <code>0</code> indicates that the model was fit successfully. For
help in deciphering other values, see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</dd>
<dt><code>cell_pk</code></dt><dd><p>summary statistics for estimated cellwise estimates
of <code>p</code> and <code>k</code>, including the number of carcasses in each cell,
medians and upper &amp; lower bounds on CIs for each parameter, indexed by
cell (or combination of covariate levels).</p>
</dd>
</dl>

<p>The following components are not printed automatically but can be accessed
via the <code>$</code> operator:
</p>

<dl>
<dt><code>data</code></dt><dd><p>the data used to fit the model</p>
</dd>
<dt><code>data0</code></dt><dd><p><code>$data</code> with NA rows removed</p>
</dd>
<dt><code>betahat_p, betahat_k</code></dt><dd><p>parameter estimates for the terms in the
regression model for for <code>p</code> and <code>k</code> (logit scale). If <code>k</code>
is fixed or not provided, then <code>betahat_k</code> is not calculated.</p>
</dd>
<dt><code>varbeta</code></dt><dd><p>the variance-covariance matrix of the estimators
for <code>c(betahat_p, betahat_k)</code>.</p>
</dd>
<dt><code>cellMM_p, cellMM_k</code></dt><dd><p>cellwise model (design) matrices for
covariate structures of <code>p_formula</code> and <code>k_formula</code></p>
</dd>
<dt><code>levels_p, levels_k</code></dt><dd><p>all levels of each covariate of <code>p</code>
and <code>k</code></p>
</dd>
<dt><code>nbeta_p, nbeta_k</code></dt><dd><p>number of parameters to fit the <code>p</code>
and <code>k</code> models</p>
</dd>
<dt><code>cells</code></dt><dd><p>cell structure of the pk-model, i.e., combinations of
all levels for each covariate of <code>p</code> and <code>k</code>. For example, if
<code>covar1</code> has levels <code>"a"</code>, <code>"b"</code>, and <code>"c"</code>, and
<code>covar2</code> has levels <code>"X"</code> and <code>"Y"</code>, then the cells
would consist of <code>a.X</code>, <code>a.Y</code>, <code>b.X</code>, <code>b.Y</code>,
<code>c.X</code>, and <code>c.Y</code>.</p>
</dd>
<dt><code>ncell</code></dt><dd><p>total number of cells</p>
</dd>
<dt><code>predictors_k, predictors_p</code></dt><dd><p>covariates of <code>p</code> and <code>k</code></p>
</dd>
<dt><code>observations</code></dt><dd><p>observations used to fit the model</p>
</dd>
<dt><code>kFixed</code></dt><dd><p>the input <code>kFixed</code></p>
</dd>
<dt><code>AIC</code></dt><dd><p>the
<a href="https://en.wikipedia.org/wiki/Akaike_information_criterion">AIC</a>
value for the fitted model</p>
</dd>
<dt><code>carcCells</code></dt><dd><p>the cell to which each carcass belongs</p>
</dd>
<dt><code>CL</code></dt><dd><p>the input <code>CL</code></p>
</dd>
<dt><code>loglik</code></dt><dd><p>the log-liklihood for the maximum likelihood estimate</p>
</dd>
<dt><code>pOnly</code></dt><dd><p>a logical value telling whether <code>k</code> is included in
the model. <code>pOnly = TRUE</code> if and only if <code>length(obsCol) == 1)</code>
and <code>kFixed = NULL</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>data_adj</code></dt><dd><p><code>data0</code> as adjusted for the 2n fix to accommodate
scenarios in which all trial carcasses are either found or all are not
found on the first search occasion (uncommon)</p>
</dd>
<dt><code>fixBadCells</code></dt><dd><p>vector giving the names of cells adjusted for the
2n fix</p>
</dd>
</dl>



<h3>Advanced</h3>

<p><code>pkmSize</code> may also be used to fit a single model for each carcass class if
<code>allCombos = FALSE</code>. To do so, <code>formula_p</code> and <code>formula_k</code>
must be a named list of formulas with names matching the sizes listed in
<code>unique(data[, sizeCol])</code>. The return value is then a list of
<code>pkm</code> objects, one for each size.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpk">rpk</a></code>, <code><a href="#topic+qpk">qpk</a></code>, <code><a href="#topic+aicc">aicc</a></code>,
<code><a href="#topic+plot.pkm">plot.pkm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> head(data(wind_RP))
 mod1 &lt;- pkm(formula_p = p ~ Season, formula_k = k ~ 1, data = wind_RP$SE)
 class(mod1)
 mod2 &lt;- pkm(formula_p = p ~ Season, formula_k = k ~ 1, data = wind_RP$SE,
   allCombos = TRUE)
 class(mod2)
 names(mod2)
 class(mod2[[1]])
 mod3 &lt;- pkm(formula_p = p ~ Season, formula_k = k ~ 1, data = wind_RP$SE,
   allCombos = TRUE, sizeCol = "Size")
 class(mod3)
 names(mod3)
 class(mod3[[1]])
 class(mod3[[1]][[1]])

</code></pre>

<hr>
<h2 id='pkmFail'>Check if a pk model is well-fit</h2><span id='topic+pkmFail'></span>

<h3>Description</h3>

<p>Run a check the arg is a well-fit pkm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmFail(pkmod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmFail_+3A_pkmod">pkmod</code></td>
<td>
<p>A <code><a href="#topic+pkm">pkm</a></code> object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value indicating a failed fit (TRUE) or successful (FALSE)
</p>

<hr>
<h2 id='pkmParamPlot'>Plot parameter box plots for each cell for either p or k</h2><span id='topic+pkmParamPlot'></span>

<h3>Description</h3>

<p>Boxplot for pk model cells (soon to be deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmParamPlot(model, pk = "p", col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmParamPlot_+3A_model">model</code></td>
<td>
<p>model of class pkm</p>
</td></tr>
<tr><td><code id="pkmParamPlot_+3A_pk">pk</code></td>
<td>
<p>character of &quot;p&quot; or &quot;k&quot; to delineate between parameter graphed</p>
</td></tr>
<tr><td><code id="pkmParamPlot_+3A_col">col</code></td>
<td>
<p>color to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a parameter plot panel
</p>

<hr>
<h2 id='pkmSECellPlot'>Plot cell-specific decay curve for searcher efficiency</h2><span id='topic+pkmSECellPlot'></span>

<h3>Description</h3>

<p>Plot cell-specific decay curve for searcher efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSECellPlot(model, specificCell, col, axis_y = TRUE, axis_x = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSECellPlot_+3A_model">model</code></td>
<td>
<p>model of class pkm</p>
</td></tr>
<tr><td><code id="pkmSECellPlot_+3A_specificcell">specificCell</code></td>
<td>
<p>name of the specific cell to plot (soon to be deprecated)</p>
</td></tr>
<tr><td><code id="pkmSECellPlot_+3A_col">col</code></td>
<td>
<p>color to use</p>
</td></tr>
<tr><td><code id="pkmSECellPlot_+3A_axis_y">axis_y</code></td>
<td>
<p>logical of whether or not to plot the y axis</p>
</td></tr>
<tr><td><code id="pkmSECellPlot_+3A_axis_x">axis_x</code></td>
<td>
<p>logical of whether or not to plot the x axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cell plot panel
</p>

<hr>
<h2 id='pkmSetAllFail'>Check if all of the pkm models fail within a given set</h2><span id='topic+pkmSetAllFail'></span>

<h3>Description</h3>

<p>Run a check on each model within a <code><a href="#topic+pkmSet">pkmSet</a></code>
object to determine if they all failed or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSetAllFail(pkmSetToCheck)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSetAllFail_+3A_pkmsettocheck">pkmSetToCheck</code></td>
<td>
<p>A <code><a href="#topic+pkmSet">pkmSet</a></code> object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating if all models failed in the set
</p>

<hr>
<h2 id='pkmSetFail'>Check if pkm models fail</h2><span id='topic+pkmSetFail'></span>

<h3>Description</h3>

<p>Run a check on each model within a <code><a href="#topic+pkmSet">pkmSet</a></code> 
object to determine if it failed or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSetFail(pkmSetToCheck)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSetFail_+3A_pkmsettocheck">pkmSetToCheck</code></td>
<td>
<p>A <code><a href="#topic+pkmSet">pkmSet</a></code> object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of logical values indicating if each of the models failed
</p>

<hr>
<h2 id='pkmSetFailRemove'>Remove failed pkm models from a <code>pkmSet</code> object</h2><span id='topic+pkmSetFailRemove'></span>

<h3>Description</h3>

<p>Remove all failed models within a <code><a href="#topic+pkm">pkmSet</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSetFailRemove(pkmSetToTidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSetFailRemove_+3A_pkmsettotidy">pkmSetToTidy</code></td>
<td>
<p>A <code><a href="#topic+pkmSet">pkmSet</a></code> object to tidy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+pkmSet">pkmSet</a></code> object with failed models removed
</p>

<hr>
<h2 id='pkmSetSizeFail'>Check if all of the pkm models fail</h2><span id='topic+pkmSetSizeFail'></span>

<h3>Description</h3>

<p>Run a check on each model within a <code><a href="#topic+pkm">pkmSetSize</a></code>
object to determine if they all failed or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSetSizeFail(pkmSetSizeToCheck)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSetSizeFail_+3A_pkmsetsizetocheck">pkmSetSizeToCheck</code></td>
<td>
<p>A <code>pkmSetSize</code> object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of logical vectors indicating which models failed
</p>

<hr>
<h2 id='pkmSetSizeFailRemove'>Remove failed pkm models from a <code>pkmSetSize</code> object</h2><span id='topic+pkmSetSizeFailRemove'></span>

<h3>Description</h3>

<p>Remove failed models from a <code><a href="#topic+pkm">pkmSetSize</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSetSizeFailRemove(pkmSetSizeToTidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSetSizeFailRemove_+3A_pkmsetsizetotidy">pkmSetSizeToTidy</code></td>
<td>
<p>A list of <code>pkmSetSize</code> objects to tidy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>pkmSet</code> objects with failed models removed
</p>

<hr>
<h2 id='pkmSetSpecParamPlot'>p or k box plots for an SE model set</h2><span id='topic+pkmSetSpecParamPlot'></span>

<h3>Description</h3>

<p>Plot parameter box plots for each cell within a model for
either p or k with comparison to the cellwise model (soor to be deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSetSpecParamPlot(modelSet, specificModel, pk = "p", cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSetSpecParamPlot_+3A_modelset">modelSet</code></td>
<td>
<p>modelSet of class pkmSet</p>
</td></tr>
<tr><td><code id="pkmSetSpecParamPlot_+3A_specificmodel">specificModel</code></td>
<td>
<p>name of the specific submodel to plot</p>
</td></tr>
<tr><td><code id="pkmSetSpecParamPlot_+3A_pk">pk</code></td>
<td>
<p>character of &quot;p&quot; or &quot;k&quot; to delineate between parameter graphed</p>
</td></tr>
<tr><td><code id="pkmSetSpecParamPlot_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a specific parameter plot panel
</p>

<hr>
<h2 id='pkmSetSpecSECellPlot'>Plot cell-specific decay curve for searcher efficiency for a specific model
with comparison to the cellwise model</h2><span id='topic+pkmSetSpecSECellPlot'></span>

<h3>Description</h3>

<p>Plot cell-specific decay curve for searcher efficiency for a specific model
with comparison to the cellwise model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkmSetSpecSECellPlot(modelSet, specificModel, specificCell, cols, axes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkmSetSpecSECellPlot_+3A_modelset">modelSet</code></td>
<td>
<p>modelSet of class pkmSet (soon to be deprecated)</p>
</td></tr>
<tr><td><code id="pkmSetSpecSECellPlot_+3A_specificmodel">specificModel</code></td>
<td>
<p>name of the specific submodel to plot</p>
</td></tr>
<tr><td><code id="pkmSetSpecSECellPlot_+3A_specificcell">specificCell</code></td>
<td>
<p>name of the specific cell to plot</p>
</td></tr>
<tr><td><code id="pkmSetSpecSECellPlot_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
<tr><td><code id="pkmSetSpecSECellPlot_+3A_axes">axes</code></td>
<td>
<p>named vector of logical values indicating whether or not to
plot the x axis and the y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a specific cell plot panel
</p>

<hr>
<h2 id='pllogis'>The CDF of the loglogistic distribution</h2><span id='topic+pllogis'></span>

<h3>Description</h3>

<p>The CDF of the loglogistic distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pllogis(q, pda, pdb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pllogis_+3A_q">q</code></td>
<td>
<p>a numeric vector of quantiles</p>
</td></tr>
<tr><td><code id="pllogis_+3A_pda">pda</code></td>
<td>
<p>the <code class="reqn">\alpha</code> parameter</p>
</td></tr>
<tr><td><code id="pllogis_+3A_pdb">pdb</code></td>
<td>
<p>the <code class="reqn">\beta</code> parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several common parameterizations of the loglogistic
distribution. The one used here gives the following:
</p>

<dl>
<dt>CDF</dt><dd><p><code>Pr(X &lt;= x) = 1/(1 + (x/</code><code class="reqn">\beta</code>)^-<code class="reqn">\alpha</code><code>)</code></p>
</dd>
<dt>PDF</dt><dd><p><code>Pr(X = x) = (</code><code class="reqn">\alpha</code>/<code class="reqn">\beta</code><code>) * (x/</code><code class="reqn">\beta</code>)^(<code class="reqn">\alpha</code><code> - 1)/(1 + (x/</code><code class="reqn">\beta</code>)^<code class="reqn">\alpha</code><code>)^2</code></p>
</dd>
</dl>



<h3>Value</h3>

<p><code>Pr(X &lt;= q | pda, pdb)</code>
</p>

<hr>
<h2 id='plot.cpm'>Plot results of a single CP model</h2><span id='topic+plot.cpm'></span>

<h3>Description</h3>

<p>Plot a single <code><a href="#topic+cpm">cpm</a></code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpm'
plot(x, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpm_+3A_x">x</code></td>
<td>
<p>model of class cpm</p>
</td></tr>
<tr><td><code id="plot.cpm_+3A_col">col</code></td>
<td>
<p>color to use</p>
</td></tr>
<tr><td><code id="plot.cpm_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- cpm(formula_l = l ~ Season, formula_s = s ~ Season,  
           data = wind_RP$CP, left = "LastPresent", right = "FirstAbsent")
 plot(mod)

</code></pre>

<hr>
<h2 id='plot.cpmSet'>Plot results of a set of CP models</h2><span id='topic+plot.cpmSet'></span>

<h3>Description</h3>

<p>Produce a set of figures for a set of CP models, as fit by
<code><a href="#topic+cpmSet">cpmSet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpmSet'
plot(x, specificModel = NULL, cols = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpmSet_+3A_x">x</code></td>
<td>
<p>pk model set of class pkmSet</p>
</td></tr>
<tr><td><code id="plot.cpmSet_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name(s) or index number(s) of specific model(s) to 
restrict the plot</p>
</td></tr>
<tr><td><code id="plot.cpmSet_+3A_cols">cols</code></td>
<td>
<p>named vector of the colors to use for the distributions</p>
</td></tr>
<tr><td><code id="plot.cpmSet_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- cpmSet(formula_l = l ~ Season, formula_s = s ~ Season,  
           data = wind_RP$CP, left = "LastPresent", right = "FirstAbsent")
 plot(mod)

</code></pre>

<hr>
<h2 id='plot.estM'>Plot total mortality estimation</h2><span id='topic+plot.estM'></span>

<h3>Description</h3>

<p><code>plot</code> defined for class <code>estM</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estM'
plot(x, ..., CL = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.estM_+3A_x">x</code></td>
<td>
<p><code>estM</code> object</p>
</td></tr>
<tr><td><code id="plot.estM_+3A_...">...</code></td>
<td>
<p>arguments to pass down</p>
</td></tr>
<tr><td><code id="plot.estM_+3A_cl">CL</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(mock)
 model_SE &lt;- pkm(formula_p = p ~ HabitatType, formula_k = k ~ 1,
              data = mock$SE)
 model_CP &lt;- cpm(formula_l = l ~ Visibility, formula_s = s ~ Visibility, 
               data = mock$CP, dist = "weibull",
               left = "LastPresentDecimalDays", 
               right = "FirstAbsentDecimalDays")
 eM &lt;- estM(nsim = 1000, data_CO = mock$CO, data_SS = mock$SS, 
         data_DWP = mock$DWP, frac = 1, model_SE = model_SE, 
         model_CP = model_CP, COdate = "DateFound",
         DWPCol = "S", sizeCol = NULL)
 plot(eM)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='plot.gGeneric'>Plot results of a single generic ghat estimation</h2><span id='topic+plot.gGeneric'></span>

<h3>Description</h3>

<p>Plot method for a single generic <code>ghat</code> estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gGeneric'
plot(x, CL = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gGeneric_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+estgGeneric">estgGeneric</a></code> output</p>
</td></tr>
<tr><td><code id="plot.gGeneric_+3A_cl">CL</code></td>
<td>
<p>confidence level to use</p>
</td></tr>
<tr><td><code id="plot.gGeneric_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generic detection probability plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mock)
  model_SE &lt;- pkm(formula_p = p ~ HabitatType, formula_k = k ~ 1,
                data = mock$SE)
  model_CP &lt;- cpm(formula_l = l ~ Visibility, formula_s = s ~ Visibility, 
                data = mock$CP, left = "LastPresentDecimalDays", 
                right = "FirstAbsentDecimalDays")
  avgSS &lt;- averageSS(mock$SS)
  ghatsGeneric &lt;- estgGeneric(nsim = 1000, avgSS, model_SE, model_CP)
  plot(ghatsGeneric)

</code></pre>

<hr>
<h2 id='plot.gGenericSize'>Plot results of a set of size-based generic ghat estimations</h2><span id='topic+plot.gGenericSize'></span>

<h3>Description</h3>

<p>Plot method for a size-based generic <code>ghat</code> estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gGenericSize'
plot(x, CL = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gGenericSize_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+estgGenericSize">estgGenericSize</a></code> output</p>
</td></tr>
<tr><td><code id="plot.gGenericSize_+3A_cl">CL</code></td>
<td>
<p>confidence level to use</p>
</td></tr>
<tr><td><code id="plot.gGenericSize_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>


<h3>Value</h3>

<p>size-based detection probability plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mock)
  pkmModsSize &lt;- pkm(formula_p = p ~ HabitatType,
                   formula_k = k ~ HabitatType, data = mock$SE,
                   obsCol = c("Search1", "Search2", "Search3", "Search4"),
                   sizeCol = "Size", allCombos = TRUE)
  cpmModsSize &lt;- cpm(formula_l = l ~ Visibility,
                   formula_s = s ~ Visibility, data = mock$CP,
                   left = "LastPresentDecimalDays",
                   right = "FirstAbsentDecimalDays",
                   dist = c("exponential", "lognormal"),
                   sizeCol = "Size", allCombos = TRUE)
  pkMods &lt;- c("S" = "p ~ 1; k ~ 1", "L" = "p ~ 1; k ~ 1",
             "M" = "p ~ 1; k ~ 1", "XL" = "p ~ 1; k ~ 1"
            )
  cpMods &lt;- c("S" = "dist: exponential; l ~ 1; NULL", 
              "L" = "dist: exponential; l ~ 1; NULL",
              "M" = "dist: exponential; l ~ 1; NULL",
              "XL" = "dist: exponential; l ~ 1; NULL"
            )
  avgSS &lt;- averageSS(mock$SS)
  gsGeneric &lt;- estgGenericSize(nsim = 1000, days = avgSS,
                 modelSetSize_SE = pkmModsSize,
                 modelSetSize_CP = cpmModsSize,
                 modelSizeSelections_SE = pkMods,
                 modelSizeSelections_CP = cpMods
               )
 plot(gsGeneric)

</code></pre>

<hr>
<h2 id='plot.pkm'>Plot results of a single pk model</h2><span id='topic+plot.pkm'></span>

<h3>Description</h3>

<p>Plot a single <code><a href="#topic+pkm">pkm</a></code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkm'
plot(x, col = NULL, CL = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pkm_+3A_x">x</code></td>
<td>
<p>model of class pkm</p>
</td></tr>
<tr><td><code id="plot.pkm_+3A_col">col</code></td>
<td>
<p>color to use</p>
</td></tr>
<tr><td><code id="plot.pkm_+3A_cl">CL</code></td>
<td>
<p>confidence level to show in boxplots and confidence bounds</p>
</td></tr>
<tr><td><code id="plot.pkm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to sub functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- pkm(formula_p = p ~ Season, formula_k = k ~ 1, data = wind_RP$SE)
  plot(mod)

</code></pre>

<hr>
<h2 id='plot.pkmSet'>Plot results of a set of SE models</h2><span id='topic+plot.pkmSet'></span>

<h3>Description</h3>

<p>Produce a set of figures for a set of SE models, as fit by
<code><a href="#topic+pkmSet">pkmSet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkmSet'
plot(x, specificModel = NULL, cols = NULL, CL = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pkmSet_+3A_x">x</code></td>
<td>
<p>pk model set of class pkmSet</p>
</td></tr>
<tr><td><code id="plot.pkmSet_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name(s) or index number(s) of specific model(s)
to restrict the plot</p>
</td></tr>
<tr><td><code id="plot.pkmSet_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
<tr><td><code id="plot.pkmSet_+3A_cl">CL</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="plot.pkmSet_+3A_...">...</code></td>
<td>
<p>to be sent to subfunctions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a set of plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- pkmSet(formula_p = p ~ Season, formula_k = k ~ Season,
           data = wind_RP$SE
         )
  plot(mod)

</code></pre>

<hr>
<h2 id='plot.splitFull'>Plot summary statistics for splits of mortality estimates</h2><span id='topic+plot.splitFull'></span>

<h3>Description</h3>

<p>The S3 <code>plot</code> method for <code>splitFull</code> objects 
constructs boxplots of the mortality estimates for all combinations of 
splitting covariates summarized in the <code>splits</code> variable. This is a
simple wrapper function for creating a <code>splitSummary</code> object by 
calling <code><a href="#topic+summary.splitFull">summary.splitFull</a></code> and plotting the result via
<code><a href="#topic+plot.splitSummary">plot.splitSummary</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splitFull'
plot(x, rate = FALSE, CL = 0.9, commonScale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.splitFull_+3A_x">x</code></td>
<td>
<p>A <code>splitSummary</code> object (result of <code><a href="#topic+calcSplits">calcSplits</a></code>)
that includes summary statistics for simulated mortality estimates for
all combinations of levels of 1 or 2 splitting covariates.</p>
</td></tr>
<tr><td><code id="plot.splitFull_+3A_rate">rate</code></td>
<td>
<p><code>logical</code> scalar indicating whether the figures should be
plotted as number of fatalities per split category (<code>rate = TRUE</code>)
or fatality rates per unit time (<code>rate = TRUE</code>). If the splits do
not include either a <code>split_SS</code> or <code>split_time</code> variable, the
<code>rate</code> arg is ignored.</p>
</td></tr>
<tr><td><code id="plot.splitFull_+3A_cl">CL</code></td>
<td>
<p>desired confidence level to show in box plots</p>
</td></tr>
<tr><td><code id="plot.splitFull_+3A_commonscale">commonScale</code></td>
<td>
<p>Boolean: Should panels share a common y-axis scale?
Relevant only when there are two splitting variables.</p>
</td></tr>
<tr><td><code id="plot.splitFull_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>

<hr>
<h2 id='plot.splitSummary'>Plot summary statistics for splits of mortality estimates</h2><span id='topic+plot.splitSummary'></span>

<h3>Description</h3>

<p>The S3 <code>plot</code> method for <code>splitSummary</code> objects 
constructs boxplots of the mortality estimates for all combinations of 
splitting covariates summarized in the <code>splits</code> variable.
</p>
<p>For 1-covariate splits, box plots showing median, IQR, and confidence
intervals (for the <code>CL</code> attribute for the splits object). For
2-covariate splits, the box plots are in an array with levels of
the temporal split (<code>split_SS</code> or <code>split_time</code>) arranged
horizontally (if present) and the levels of the <code>split_CO</code> variable
arranged vertically. If no temporal splits are present, then the box 
plots along the levels of the first <code>split_CO</code> variable are arranged
horizontally and the levels of the second variable are are arranged
vertically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splitSummary'
plot(x, rate = FALSE, commonScale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.splitSummary_+3A_x">x</code></td>
<td>
<p>A <code>splitSummary</code> object (result of <code><a href="#topic+calcSplits">calcSplits</a></code>)
that includes summary statistics for simulated mortality estimates for all
combinations of levels of 1 or 2 splitting covariates.</p>
</td></tr>
<tr><td><code id="plot.splitSummary_+3A_rate">rate</code></td>
<td>
<p><code>logical</code> scalar indicating whether the figures should be
plotted as number of fatalities per split category (<code>rate = TRUE</code>) or
fatality rates per unit time (<code>rate = TRUE</code>). If the splits do not
include either a <code>split_SS</code> or <code>split_time</code> variable, the
<code>rate</code> arg is ignored.</p>
</td></tr>
<tr><td><code id="plot.splitSummary_+3A_commonscale">commonScale</code></td>
<td>
<p>boolean to indicate whether to plot separate splits panels
with a common scale on their y-axes (or have y-axes scaled to fit each graph
separately)</p>
</td></tr>
<tr><td><code id="plot.splitSummary_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down</p>
</td></tr>
</table>

<hr>
<h2 id='plotCPCells'>Plot the cellwise results of a single model in a set of CP models</h2><span id='topic+plotCPCells'></span>

<h3>Description</h3>

<p>Produce a set of cellwise figures for a specific CP model, as 
fit by <code><a href="#topic+cpmSet">cpmSet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCPCells(modelSet, specificModel, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCPCells_+3A_modelset">modelSet</code></td>
<td>
<p>cp model set of class cpmSet</p>
</td></tr>
<tr><td><code id="plotCPCells_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
<tr><td><code id="plotCPCells_+3A_cols">cols</code></td>
<td>
<p>named vector of the colors to use for the distributions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>

<hr>
<h2 id='plotCPFigure'>Plot results of a single CP model in a set</h2><span id='topic+plotCPFigure'></span>

<h3>Description</h3>

<p>Produce a figures for a specific CP model, as fit by
<code><a href="#topic+cpmSet">cpmSet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCPFigure(modelSet, specificModel, cols = CPcols())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCPFigure_+3A_modelset">modelSet</code></td>
<td>
<p>cp model set of class <code>cpmSet</code></p>
</td></tr>
<tr><td><code id="plotCPFigure_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
<tr><td><code id="plotCPFigure_+3A_cols">cols</code></td>
<td>
<p>named vector of the colors to use for the distributions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>

<hr>
<h2 id='plotCPHeader'>The CP plot header</h2><span id='topic+plotCPHeader'></span>

<h3>Description</h3>

<p>Produce the header for a CP plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCPHeader(modelSet, specificModel, cols = CPcols())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCPHeader_+3A_modelset">modelSet</code></td>
<td>
<p>cp model set of class cpmSet</p>
</td></tr>
<tr><td><code id="plotCPHeader_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
<tr><td><code id="plotCPHeader_+3A_cols">cols</code></td>
<td>
<p>named vector of the colors to use for the distributions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>

<hr>
<h2 id='plotSEBoxPlots'>p and k box plots for an SE model set</h2><span id='topic+plotSEBoxPlots'></span>

<h3>Description</h3>

<p>Plot parameter box plots for each cell within a model for
both p and k with comparison to the cellwise model (soon to be deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSEBoxPlots(modelSet, specificModel, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSEBoxPlots_+3A_modelset">modelSet</code></td>
<td>
<p>modelSet of class pkmSet</p>
</td></tr>
<tr><td><code id="plotSEBoxPlots_+3A_specificmodel">specificModel</code></td>
<td>
<p>name of the specific submodel to plot</p>
</td></tr>
<tr><td><code id="plotSEBoxPlots_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a set of parameter plot panels
</p>

<hr>
<h2 id='plotSEBoxTemplate'>template box plot</h2><span id='topic+plotSEBoxTemplate'></span>

<h3>Description</h3>

<p>Plot template box plot (soon to be deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSEBoxTemplate(modelSet, specificModel, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSEBoxTemplate_+3A_modelset">modelSet</code></td>
<td>
<p>modelSet of class pkmSet</p>
</td></tr>
<tr><td><code id="plotSEBoxTemplate_+3A_specificmodel">specificModel</code></td>
<td>
<p>name of the specific submodel to plot</p>
</td></tr>
<tr><td><code id="plotSEBoxTemplate_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a template box plot
</p>

<hr>
<h2 id='plotSECells'>Plot the cellwise results of a single model in a set of SE models</h2><span id='topic+plotSECells'></span>

<h3>Description</h3>

<p>Produce a set of cellwise figures for a specific SE model, as
fit by <code><a href="#topic+pkmSet">pkmSet</a></code> (soon to be deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSECells(modelSet, specificModel, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSECells_+3A_modelset">modelSet</code></td>
<td>
<p>pk model set of class pkmSet</p>
</td></tr>
<tr><td><code id="plotSECells_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
<tr><td><code id="plotSECells_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>

<hr>
<h2 id='plotSEFigure'>Plot results of a single SE model in a set</h2><span id='topic+plotSEFigure'></span>

<h3>Description</h3>

<p>Produce a figures for a specific SE model, as fit by
<code><a href="#topic+pkmSet">pkmSet</a></code> (soon to be deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSEFigure(modelSet, specificModel, app, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSEFigure_+3A_modelset">modelSet</code></td>
<td>
<p>pk model set of class <code>pkmSet</code></p>
</td></tr>
<tr><td><code id="plotSEFigure_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
<tr><td><code id="plotSEFigure_+3A_app">app</code></td>
<td>
<p>logical indicating if the plot is for the app</p>
</td></tr>
<tr><td><code id="plotSEFigure_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>

<hr>
<h2 id='plotSEHeader'>The SE plot header</h2><span id='topic+plotSEHeader'></span>

<h3>Description</h3>

<p>Produce the header for an SE plot (soon to be deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSEHeader(modelSet, specificModel, app = FALSE, cols = SEcols())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSEHeader_+3A_modelset">modelSet</code></td>
<td>
<p>pk model set of class pkmSet</p>
</td></tr>
<tr><td><code id="plotSEHeader_+3A_specificmodel">specificModel</code></td>
<td>
<p>the name of the specific model for the plot</p>
</td></tr>
<tr><td><code id="plotSEHeader_+3A_app">app</code></td>
<td>
<p>logical indicating if the plot is for the app</p>
</td></tr>
<tr><td><code id="plotSEHeader_+3A_cols">cols</code></td>
<td>
<p>named vector of colors to use for the specific and reference
models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>

<hr>
<h2 id='ppersist'>Calculate the probability of persistence to detection</h2><span id='topic+ppersist'></span>

<h3>Description</h3>

<p>Given a set of CP parameters (of <code>"ppersist"</code> type), 
calculate the probability of persistence to detection for a carcass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppersist(pda, pdb, dist, t_arrive0, t_arrive1, t_search)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppersist_+3A_pda">pda</code></td>
<td>
<p>parameter a.</p>
</td></tr>
<tr><td><code id="ppersist_+3A_pdb">pdb</code></td>
<td>
<p>parameter b.</p>
</td></tr>
<tr><td><code id="ppersist_+3A_dist">dist</code></td>
<td>
<p>Distribution used.</p>
</td></tr>
<tr><td><code id="ppersist_+3A_t_arrive0">t_arrive0</code></td>
<td>
<p>Beginning of arrival window.</p>
</td></tr>
<tr><td><code id="ppersist_+3A_t_arrive1">t_arrive1</code></td>
<td>
<p>End of arrival window.</p>
</td></tr>
<tr><td><code id="ppersist_+3A_t_search">t_search</code></td>
<td>
<p>Search time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability of persistence of detection to at t_search, 
given arrival between t_arrive0 and t_arrive1
</p>

<hr>
<h2 id='predsCols'>Select the predictor-ok columns from a data table</h2><span id='topic+predsCols'></span>

<h3>Description</h3>

<p>Simple function to facilitate selection of columns that could
be predictors for SE or CP models from a data table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predsCols(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predsCols_+3A_data">data</code></td>
<td>
<p>data table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of columns that can be predictors
</p>

<hr>
<h2 id='prepPredictors'>Prepare predictors based on inputs</h2><span id='topic+prepPredictors'></span>

<h3>Description</h3>

<p>Prepare predictor inputs from the app for use in the model
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepPredictors(preds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepPredictors_+3A_preds">preds</code></td>
<td>
<p>predictors, as input to the app</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prepared predictors (or 1 if no predictors)
</p>

<hr>
<h2 id='prepSS'>Create search schedule data into an prepSS object for convenient 
splits analyses</h2><span id='topic+prepSS'></span>

<h3>Description</h3>

<p>Since data_SS columns largely have a specific, required
format, the <code>prepSS</code> function can often automatically decipher the
data, but the user may specify explicit instructions for parsing the data
for safety if desired. If the data are formatted properly, the automatic
parsing is reliable in most cases. There are two exceptions. (1) If
there is more than one column with possible dates (formatted as formal
dates (as class <code>Date</code>, <code>POSIXlt</code> or <code>POSIXct</code>) or
character strings or factors that can be unambiguously interpreted as
dates (with assumed format &quot;2018-05-15&quot; or &quot;2018/5/15&quot;). In that case,
the user must specify the desired dates as <code>dateColumn</code>. (2) If
there is a covariate column consisting entirely of 0s and 1s. In that
case, the user must specify the column(s) in <code>covars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepSS(data_SS, SSdate = NULL, preds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepSS_+3A_data_ss">data_SS</code></td>
<td>
<p>data frame or matrix with search schedule parameters,
including columns for search dates, covariates (describing characteristics
of the search intervals), and each unit (with 1s and 0s to indicate 
whether the given unit was searched (= 1) or not (= 0) on the given date)</p>
</td></tr>
<tr><td><code id="prepSS_+3A_ssdate">SSdate</code></td>
<td>
<p>name of the column with the search dates in it
(optional). If no <code>SSdate</code> is given, <code>prepSS</code> will
try to find the date column based on data formats. If there is exactly one
column that can be interpreted as dates, that column will be taken as the
dates searched. If more than one date column is found, <code>prepSS</code> exits
with an error message.</p>
</td></tr>
<tr><td><code id="prepSS_+3A_preds">preds</code></td>
<td>
<p>vector of character strings giving the names of columns to be
interpreted as potential covariates (optional). Typically, it is not
necessary for a user to provide a value for <code>preds</code>. It is used only
to identify specific columns of 1s and 0s as covariates rather than as
search schedules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>prepSS</code> object that can be conveniently used in the splitting
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(mock)
 prepSS(mock$SS)

</code></pre>

<hr>
<h2 id='prettyModTabCP'>Create the pretty version of the Carcass Persistence model table</h2><span id='topic+prettyModTabCP'></span>

<h3>Description</h3>

<p>Format a reader-friendly version of the parameter table from
a carcass persistence model showing CIs for medianCP and for rI's for
intervals of Ir
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettyModTabCP(modTab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prettyModTabCP_+3A_modtab">modTab</code></td>
<td>
<p><code>descCP</code> object or NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pretty version of the CP model table in a data frame with point
and interval estimates for medianCP and rI statistics. Output table is
ready for rendering in shiny and posting in the GUI
</p>

<hr>
<h2 id='prettyModTabSE'>Create the pretty versions of model and summary tables</h2><span id='topic+prettyModTabSE'></span>

<h3>Description</h3>

<p>Format reader-friendly versions of results summary tables for
searcher efficiency (GUI display and download), carcass persistence, and
splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettyModTabSE(modTab, CL = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prettyModTabSE_+3A_modtab">modTab</code></td>
<td>
<p>model table</p>
</td></tr>
<tr><td><code id="prettyModTabSE_+3A_cl">CL</code></td>
<td>
<p>Confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pretty version of the SE model table
</p>

<hr>
<h2 id='prettySplitTab'>Create the pretty version of the split summary table</h2><span id='topic+prettySplitTab'></span>

<h3>Description</h3>

<p>Format a reader-friendly version of the split summary table
a mortality estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettySplitTab(splitSummary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prettySplitTab_+3A_splitsummary">splitSummary</code></td>
<td>
<p>a split summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>split pretty table
</p>

<hr>
<h2 id='print.cpm'>Print a <code><a href="#topic+cpm">cpm</a></code> model object</h2><span id='topic+print.cpm'></span>

<h3>Description</h3>

<p>Print a <code><a href="#topic+cpm">cpm</a></code> model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cpm_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+cpm">cpm</a></code> model object</p>
</td></tr>
<tr><td><code id="print.cpm_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>

<hr>
<h2 id='print.pkm'>Print a <code><a href="#topic+pkm">pkm</a></code> model object</h2><span id='topic+print.pkm'></span>

<h3>Description</h3>

<p>Print a <code><a href="#topic+pkm">pkm</a></code> model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pkm_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+pkm">pkm</a></code> model object</p>
</td></tr>
<tr><td><code id="print.pkm_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>

<hr>
<h2 id='qpk'>Quantiles of marginal distributions of <code class="reqn">\hat{p}</code> and <code class="reqn">\hat{k}</code></h2><span id='topic+qpk'></span>

<h3>Description</h3>

<p>Calculate quantiles of marginal distributions of <code class="reqn">\hat{p}</code>
and <code class="reqn">\hat{k}</code> for a <code><a href="#topic+pkm">pkm</a></code> model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpk(p, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qpk_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="qpk_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+pkm">pkm</a></code> object (which is returned from
<code>pkm()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a list of <code>ncell</code> <code class="reqn">\times</code> <code>length(p)</code> matrices
of quantiles for <code>$p</code> and <code>$k</code> for cells defined by the
<code>model</code> object (if <code>model$pOnly == FALSE</code>) or a <code>ncell</code>
<code class="reqn">\times</code> <code>length(p)</code> matrix of quantiles for <code>p</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpk">rpk</a></code>, <code><a href="#topic+pkm">pkm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # 90% confidence intervals for \code{p} and \code{k}
  mod &lt;- pkm(formula_p = p ~ Visibility * Season, formula_k = k ~ Season,
   data = wind_cleared$SE)
  qpk(p = c(0.05, 0.95), model = mod)

</code></pre>

<hr>
<h2 id='rcp'>Simulate parameters from a fitted cp model</h2><span id='topic+rcp'></span>

<h3>Description</h3>

<p>Simulate parameters from a <code><a href="#topic+cpm">cpm</a></code> model object, and 
format them as either type <code>"survreg"</code> or <code>"ppersist"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcp(n, model, type = "survreg")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcp_+3A_n">n</code></td>
<td>
<p>the number of simulation draws</p>
</td></tr>
<tr><td><code id="rcp_+3A_model">model</code></td>
<td>
<p>A <code>cpm</code> object (which is returned from 
<code><a href="#topic+cpm">cpm</a></code>)</p>
</td></tr>
<tr><td><code id="rcp_+3A_type">type</code></td>
<td>
<p>The type of parameters requested. <code>"survreg"</code> or 
<code>"ppersist"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two matrices of <code>n</code> simulated <code>l</code> and <code>s</code>
(if <code>type = "survreg"</code>) or <code>a</code> and <code>b</code> (if <code>type = 
  "ppersist"</code>)for cells defined by the <code>model</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- cpm(formula_l = l ~ 1, data = wind_RP$CP, left = "LastPresent",
           right = "FirstAbsent"
         )
  rcp(n = 10, model = mod, type = "survreg")
  rcp(n = 10, model = mod, type = "ppersist")

</code></pre>

<hr>
<h2 id='rdwp'>Simulate parameters from a fitted dwp model</h2><span id='topic+rdwp'></span>

<h3>Description</h3>

<p>Simulate parameters from a <code><a href="#topic+dwpm">dwpm</a></code> model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdwp(n, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdwp_+3A_n">n</code></td>
<td>
<p>the number of simulation draws</p>
</td></tr>
<tr><td><code id="rdwp_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+dwpm">dwpm</a></code> object (which is returned from
<code>dwpm()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model type = <code>data</code>, then the number of simulated columns
must be either <code>&gt;=n</code> (in which case the first n colunms are taken as the
simulated DWP) or 1 (in which case, DWP is assumed constant).
</p>


<h3>Value</h3>

<p>array of <code>n</code> simulated <code>dwp</code> values for each unit.
Dimensions = c(n, number of units).
</p>

<hr>
<h2 id='readCSV'>Read in csv files in either format</h2><span id='topic+readCSV'></span>

<h3>Description</h3>

<p>Handle reading in of a csv that is either comma-decimal or
semicolon-comma separation style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCSV(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readCSV_+3A_path">path</code></td>
<td>
<p>file path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>read in data table
</p>

<hr>
<h2 id='refMod'>Return the model with the greatest log-likelihood</h2><span id='topic+refMod'></span>

<h3>Description</h3>

<p>Compares all fitted models in a list and returns the model
with the greatest log-likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refMod(modelSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refMod_+3A_modelset">modelSet</code></td>
<td>
<p>a list of fitted models with a <code>loglik</code> element.
Models may be <code>pkm</code>, <code>cpm</code>, <code>survreg</code> objects or any
objects with a <code>loglik</code> component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model object with the greatest log-likelihood among
the models in <code>modelSet</code>
</p>

<hr>
<h2 id='removeCols'>Remove selected columns from column names</h2><span id='topic+removeCols'></span>

<h3>Description</h3>

<p>Simple function to facilitate removal of columns selected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeCols(colNames, selCols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeCols_+3A_colnames">colNames</code></td>
<td>
<p>column names from which some could be removed</p>
</td></tr>
<tr><td><code id="removeCols_+3A_selcols">selCols</code></td>
<td>
<p>selected columns to be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names without selected columns
</p>

<hr>
<h2 id='rpk'>Simulate parameters from a fitted pk model</h2><span id='topic+rpk'></span>

<h3>Description</h3>

<p>Simulate parameters from a <code><a href="#topic+pkm">pkm</a></code> model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpk(n, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpk_+3A_n">n</code></td>
<td>
<p>the number of simulation draws</p>
</td></tr>
<tr><td><code id="rpk_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+pkm">pkm</a></code> object (which is returned from 
<code>pkm()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of pairs of matrices of <code>n</code> simulated <code>p</code> and
<code>k</code> for cells defined by the <code>model</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpk">rpk</a></code>, <code><a href="#topic+pkm">pkm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind_RP)
  mod &lt;- pkm(formula_p = p ~ 1, formula_k = k ~ Season, data = wind_RP$SE)
  rpk(n = 10, model = mod)

</code></pre>

<hr>
<h2 id='runGenEst'>Launch the GenEst Application</h2><span id='topic+runGenEst'></span>

<h3>Description</h3>

<p>Launches a local version of the GenEst application by running
<code><a href="shiny.html#topic+runApp">runApp</a></code> pointed to the <code>app</code> subdirectory in the 
local <code>GenEst</code> package folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGenEst()
</code></pre>

<hr>
<h2 id='SEboxes'>Produce boxplots <code>p</code> and/or <code>k</code> for all cells for reference
model and specific model</h2><span id='topic+SEboxes'></span>

<h3>Description</h3>

<p>Each call to <code>SEboxes</code> produces a series of boxplots for
either <code>p</code> or <code>k</code>. For interal use only, for producing figs for
<code>plot.pkmSet</code>. Function requires that ncell, preds_set, lev1, lev2,
boxW, bsep, gdat_spc, and gdat_ref are defined prior to the function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEboxes(pk, cells_set, gdat_spc, gdat_ref, cols_SE = cols_SE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEboxes_+3A_pk">pk</code></td>
<td>
<p>either <code>p</code> or <code>k</code>, depending on which type of boxplots
need to be inserted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL inserts a boxplot panel into pkmSet plot
</p>

<hr>
<h2 id='SEcols'>Produce a named vectory with standard SE plot colors</h2><span id='topic+SEcols'></span>

<h3>Description</h3>

<p>Produce a named vectory with standard SE plot colors. soon to be
deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEcols()
</code></pre>

<hr>
<h2 id='SEfig'>Plot results of a single SE model in a set</h2><span id='topic+SEfig'></span>

<h3>Description</h3>

<p>Produce a figures for a specific SE model, as fit by
<code><a href="#topic+pkmSet">pkmSet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEfig(
  referenceModel,
  specificModel,
  gdat_spc,
  gdat_ref,
  found,
  available,
  cells_set,
  cols_SE,
  p,
  CL
)
</code></pre>

<hr>
<h2 id='SEpanel'>Produce a single panel in an SE summary/diagnostic plot</h2><span id='topic+SEpanel'></span>

<h3>Description</h3>

<p>Each call to <code>SEpanel</code> produces a single panel showing
searcher efficiency as a function of number of searches. Includes raw data
(<code>found</code> and <code>available</code>) and model fits for a specific model
(<code>y_spc</code>) and for the reference model (<code>y_ref</code>) for the
<code>pkmSet</code> object from the reference model was extracted. For interal use
only, for producing figs for <code>plot.pkmSet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEpanel(found, available, y_spc, y_ref, xends, cols_SE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEpanel_+3A_found">found</code></td>
<td>
<p>vector of number carcasses found on the ith attempt</p>
</td></tr>
<tr><td><code id="SEpanel_+3A_available">available</code></td>
<td>
<p>vector of number carcasses found on the ith attempt</p>
</td></tr>
<tr><td><code id="SEpanel_+3A_y_spc">y_spc</code></td>
<td>
<p>vector of model fits for the specific model</p>
</td></tr>
<tr><td><code id="SEpanel_+3A_y_ref">y_ref</code></td>
<td>
<p>vector of model fits for the reference model</p>
</td></tr>
<tr><td><code id="SEpanel_+3A_xends">xends</code></td>
<td>
<p>x-axis buffer (numeric scalar) on sides of figs</p>
</td></tr>
<tr><td><code id="SEpanel_+3A_cols_se">cols_SE</code></td>
<td>
<p>named vector of colors (character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL inserts a panel with no labels into a preformatted figure
</p>

<hr>
<h2 id='SEsi'>Calculate decayed searcher efficiency</h2><span id='topic+SEsi'></span>

<h3>Description</h3>

<p>Calculate searcher efficiency after some searches under 
pk values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEsi(days, pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEsi_+3A_days">days</code></td>
<td>
<p>search days</p>
</td></tr>
<tr><td><code id="SEsi_+3A_pk">pk</code></td>
<td>
<p><code>p</code> and <code>k</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>searcher efficiency that matches the output of ppersist
</p>

<hr>
<h2 id='SEsi_left'>Calculate conditional probability of observation at a search</h2><span id='topic+SEsi_left'></span>

<h3>Description</h3>

<p>Calculate the conditional probability of observing a carcass 
at search oi as a function arrival interval (assuming carcass is not
removed by scavengers before the time of the final search)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEsi_left(oi, pk, rng = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEsi_left_+3A_oi">oi</code></td>
<td>
<p>number of searches after arrival</p>
</td></tr>
<tr><td><code id="SEsi_left_+3A_pk">pk</code></td>
<td>
<p>numeric array of searcher efficiency p and k parameters
(p = pk[ , 1] and k = pk[ , 2])</p>
</td></tr>
<tr><td><code id="SEsi_left_+3A_rng">rng</code></td>
<td>
<p>optional parameter giving the range of intervals to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric array of probability of observing a carcass at oi for
given that it arrived in intervals 1:oi if rng = NULL (or in intervals
<code>rng</code>), assuming the carcass had not been previously discovered or
removed by scavengers
</p>

<hr>
<h2 id='SEsi_right'>Calculate conditional probability of observation after a series of 
searches</h2><span id='topic+SEsi_right'></span>

<h3>Description</h3>

<p>Calculate the conditional probability of observing a carcass 
after i = 1:nsi searches (assuming carcass is not previous discovered by 
searchers or removed by scavengers)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEsi_right(nsi, pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEsi_right_+3A_nsi">nsi</code></td>
<td>
<p>number of searches after arrival</p>
</td></tr>
<tr><td><code id="SEsi_right_+3A_pk">pk</code></td>
<td>
<p>numeric array of searcher efficiency p and k parameters
(p = pk[ , 1] and k = pk[ , 2])</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric nsi x dim(pk)[1] array of probabilities of observing a
carcass after 1:nsi searches (assuming that the carcass had not been
previously discovered or removed by scavengers
</p>

<hr>
<h2 id='SEsi0'>Calculate decayed searcher efficiency for a single pk</h2><span id='topic+SEsi0'></span>

<h3>Description</h3>

<p>Calculate searcher efficiency after some searches for a 
single pk combination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEsi0(days, pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEsi0_+3A_days">days</code></td>
<td>
<p>search days</p>
</td></tr>
<tr><td><code id="SEsi0_+3A_pk">pk</code></td>
<td>
<p>pk combination</p>
</td></tr>
</table>


<h3>Value</h3>

<p>searcher efficiency that matches the output of ppersist
</p>

<hr>
<h2 id='simpleMplot'>Plot a total mortality estimation for a simple situation</h2><span id='topic+simpleMplot'></span>

<h3>Description</h3>

<p>Function underneath <code><a href="#topic+plot.estM">plot.estM</a></code>, which 
defines the plot method for a mortality object, composed of a hisogram 
with the empirical PDF and summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleMplot(M, ..., Xmin = 0, CL = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleMplot_+3A_m">M</code></td>
<td>
<p>Mortality object</p>
</td></tr>
<tr><td><code id="simpleMplot_+3A_...">...</code></td>
<td>
<p>arguments to pass down</p>
</td></tr>
<tr><td><code id="simpleMplot_+3A_xmin">Xmin</code></td>
<td>
<p>minimum number of observable carcasses</p>
</td></tr>
<tr><td><code id="simpleMplot_+3A_cl">CL</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>

<hr>
<h2 id='sizeCols'>Select the potential carcass class columns from a data table</h2><span id='topic+sizeCols'></span>

<h3>Description</h3>

<p>Simple function to facilitate selection of columns that could
be carcass class values from a data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeCols(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sizeCols_+3A_data">data</code></td>
<td>
<p>data table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of columns that can be carcass class values
</p>

<hr>
<h2 id='solar_powerTower'>Power Tower Example Dataset</h2><span id='topic+solar_powerTower'></span>

<h3>Description</h3>

<p>An example data set for estimating fatalities from a concentrating
solar-thermal (power tower) generation facility.  
</p>
<p>The simulated site consists of a single tower generating approximately 130 
MW.  The tower is surrounded by a 250 meter radius circular inner field of 
heliostats, searched on a weekly schedule.  From the inner circle, 18 
concentric rings of heliostats 50 meters deep extend to the boundaries of the
simulated site.  Rings are subdivided into 8 arcs each, with arcs 1-8 
immediately adjacent to the central circle.  Arcs are search using distance 
sampling techniques on a weekly schedule, with 29 arcs searched per weekday.
</p>
<p>There are two sources of mortality simulated: flux and non-flux (collision or
unknown cause).Flux carcasses are generated (weibull) about the tower, with 
5% to be found in the outer field. Non-flux mortality is assumed uniform 
across the site.
</p>
<p>The dataset consists of five parts: Data on carcass observations (CO) from 
inner and outer heliostat searches, field trials for estimating carcass 
persistence (CP) and searcher efficiency (SE), search schedule (SS), and 
density weighted proportion (DWP) of area searched at each turbine (which is 
an area adjustment factor to account for incomplete search coverage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar_powerTower
</code></pre>


<h3>Format</h3>

<p><code>solar_powerTower</code> is a list with 5 elements:
</p>

<dl>
<dt><code>SE</code></dt><dd><p>Searcher efficiency trial data</p>
</dd>
<dt><code>CP</code></dt><dd><p>Carcass persistence trial data</p>
</dd>
<dt><code>SS</code></dt><dd><p>Search schedule parameters</p>
</dd>
<dt><code>DWP</code></dt><dd><p>Density weighted proportion of area searched</p>
</dd>
<dt><code>CO</code></dt><dd><p>Carcass observations</p>
</dd>
</dl>



<h3>Searcher Efficiency (<code>SE</code>)</h3>

<p><code>$SE</code> is a data frame with each row representing the fate of a single
carcass in the searcher efficiency trials. There are columns for:
</p>

<dl>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or
<code>"sml"</code> bird</p>
</dd>
<dt><code>Field</code></dt><dd><p>indicates carcass placed in inner or outer heliostat 
field, with levels <code>"inner"</code> or <code>outer</code>.</p>
</dd>
<dt><code>"Search1",...,"Search5"</code></dt><dd><p>fate of carcass on the 1st, 2nd, 3rd,
4th, and 5th search after placement. A value of 1 implies that a carcass 
was discovered by searchers, 0 implies the carcass was present but not
discovered, and any other value is interpreted as &quot;no search&quot; or
&quot;carcass not present&quot; and ignored in the model. In this data set,
<code>NA</code> indicates that a carcass had been previously discovered and
removed from the field. A user may use a variety of values to
differentiate different reasons no search was conducted or the carcass
was not present. For example, &quot;NS&quot; to indicate the search
was not scheduled in that location at that time, or &quot;SC&quot; to indicate the
carcass had been removed by scavengers prior to the search.</p>
</dd>
</dl>



<h3>Carcass Persistence (<code>CP</code>)</h3>

<p><code>$CP</code> is a data frame with each row representing the fate of a single
carcass in the carcass persistence trials. There are columns for:
</p>

<dl>
<dt><code>cpID</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or
<code>"sml"</code> bird</p>
</dd>
<dt><code>LastPresent</code>, <code>FirstAbsent</code></dt><dd><p>endpoints of the interval bracketing
the time the carcass was scavenged or otherwise removed from the field.
For example, <code>LastPresent = 2.04</code>, <code>FirstAbsent = 3.21</code> indicates that the
carcass was last observed 2.04 days after being placed in the field and
was noted missing 3.21 days after being placed. If the precise time of
carcass removal is known (e.g., recorded by camera), then <code>LastPresent</code> and
<code>FirstAbsent</code> should be set equal to each other. If a carcass persists
beyond the last day of the field trial, <code>LastPresent</code> is the last time it
was observed and <code>FirstAbsent</code> is entered as <code>Inf</code> or <code>NA</code>.</p>
</dd>
</dl>



<h3>Search Schedule (<code>SS</code>)</h3>

<p><code>$SS</code> is a data frame with a row for each date an arc at the site
was searched, a column of <code>SearchDate</code>s, and a column for each arc, and
one column at the end for the inner heliostat field, labeled <code>center</code>.
In addition, there is a column to indicate the <code>Season</code>. A column with 
search dates and columns for each distinct area (arcs and center) searched 
are required. Other columns are optional.
</p>

<dl>
<dt><code>SearchDate</code></dt><dd><p>columns of dates on which an arc was searched. 
Format in this data is <code>"%Y-%m-%d CDT"</code>, but time zone (<code>CDT</code>)
is optional. A time stamp may be included if desired (e.g., 
<code>2018-03-20 02:15:41</code>). Alternatively, <code>\</code> can be used in place
of <code>-</code>.</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code> to indicate which season the search was conducted in. 
<code>Season</code> is optional but may be used as a temporal covariate for 
fatality estimates.</p>
</dd>
</dl>



<h3>Density Weighted Proportion (<code>DWP</code>)</h3>

<p><code>$DWP</code> is a data frame with a row for each arc and columns for each
carcass size class (labels must match those of the class factors in the
carcass observation file). Values represent the density-weighted proportion
of the searched area for each size (or the fraction of carcasses that fall
in the searched area).  In this example, within the inner field (center)
observers are unobstructed in ability to discover carcasses, for a DWP of 1.
In the outer heliostat field observers walk along transects separated by 50 
meters, but the entire area is surveyed, so DWP = 1.
</p>

<dl>
<dt><code>Unit</code></dt><dd><p>unique ID for each arc, plus one labeled <code>center</code> 
for the inner heliostat field.  IDs match those used in the <code>$CO</code> data
frame and the column names in the <code>$SS</code> data.</p>
</dd>
<dt><code>bat</code></dt><dd><p>DWP associated with size class Bat</p>
</dd>
<dt><code>sml</code></dt><dd><p>DWP associated with size  class Small</p>
</dd>
<dt><code>med</code></dt><dd><p>DWP associated with size  class Medium</p>
</dd>
<dt><code>lrg</code></dt><dd><p>DWP associated with size  class Large</p>
</dd>
</dl>



<h3>Carcass Observations (<code>CO</code>)</h3>

<p><code>$CO</code> is a data frame with a row for carcass observed in the carcass
searches and a number of columns giving information about the given
carcass (date found, size, species, etc.)
</p>

<dl>
<dt><code>carcID</code></dt><dd><p>unique identifier for each carcass.</p>
</dd>
<dt><code>Unit</code></dt><dd><p>identifier for which unit the given carcass was found 
at: <code>"arc19"</code>, <code>"arc65"</code>, etc, for arcs in the outer heliostat 
field, or <code>"center"</code>, indicating the inner heliostat field.</p>
</dd>
<dt><code>Species</code></dt><dd><p>species of the carcass: <code>"BA"</code>, <code>"BB"</code>,
<code>"BC"</code>, <code>"BD"</code>, <code>"BE"</code>, <code>"LA"</code>, <code>"LB"</code>,
<code>"LD"</code>, <code>"LE"</code>, <code>"MA"</code>, <code>"MB"</code>, <code>"SA"</code>,
<code>"SB"</code>, <code>"SC"</code>, <code>"SD"</code>, <code>"SE"</code>, <code>"SF"</code>,
<code>"SG"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p>size: <code>"bat"</code>, <code>"lrg"</code>, <code>"med"</code>,
<code>"sml"</code></p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code></p>
</dd>
<dt><code>Flux</code></dt><dd><p>An optional field indicating whether there Was evidence 
the animal was killed by flux. <code>"TRUE"</code>, or <code>"False"</code>.</p>
</dd>
<dt><code>Field</code></dt><dd><p>Optional indicator of whether the animal found in the 
<code>"inner"</code> or <code>"outer"</code> heliostat field?</p>
</dd>
<dt><code>Ring</code></dt><dd><p>Optional note animals found in the outer heliostat field
indicating which concentric ring the carcass was found in.</p>
</dd>
<dt><code>Distance</code></dt><dd><p>Optional note animals found in the outer heliostat 
field representing the perpendicular distance from the searcher the carcass
was discovered at.</p>
</dd>
<dt><code>DateFound</code></dt><dd><p>dates entered in the same format as in 
<code>$SS$SearchDate</code>. Every date entered here is (and must be) included
in the search schedule (<code>$SS$SearchDate</code></p>
</dd>
<dt><code>X</code></dt><dd><p>Distance in meters from the Western edge of the facility.</p>
</dd>
<dt><code>Y</code></dt><dd><p>Distance in meters from the Southern edge of the facility.</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>solar_powerTower</code>
</p>

<hr>
<h2 id='solar_PV'>Photovoltaic Example Dataset</h2><span id='topic+solar_PV'></span>

<h3>Description</h3>

<p>An example data set for estimating fatalities from a large photovoltaic solar
generation facility.
</p>
<p>The simulated site is organized into 300 arrays of panels.  As observers walk
north-south along paths between arrays, they look east or west down rows 
between solar panels 150 meters long, with 38 searchable rows per array.  
Observers consistently look for animals down one cardinal direction, making 
this a one-sided distance sample.  Searches are scheduled on a seven day
rotation, with 60 arrays searched per weekday.  A sitewide clearout search 
is implemented before the first scheduled winter search.
</p>
<p>The dataset consists of five parts: Data on carcass observations (CO) from 
array searches, field trials for estimating carcass persistence (CP) and 
searcher efficiency (SE), search schedule (SS), and density weighted 
proportion (DWP) of area searched at each array (which is an area adjustment 
factor to account for incomplete search coverage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar_PV
</code></pre>


<h3>Format</h3>

<p><code>solar_PV</code> is a list with 5 elements:
</p>

<dl>
<dt><code>SE</code></dt><dd><p>Searcher efficiency trial data</p>
</dd>
<dt><code>CP</code></dt><dd><p>Carcass persistence trial data</p>
</dd>
<dt><code>SS</code></dt><dd><p>Search schedule parameters</p>
</dd>
<dt><code>DWP</code></dt><dd><p>Density weighted proportion of area searched</p>
</dd>
<dt><code>CO</code></dt><dd><p>Carcass observations</p>
</dd>
</dl>



<h3>Searcher Efficiency (<code>SE</code>)</h3>

<p><code>$SE</code> is a data frame with each row representing the fate of a single
carcass in the searcher efficiency trials. There are columns for:
</p>

<dl>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or
<code>"sml"</code> bird</p>
</dd>
<dt><code>"Search1",...,"Search5"</code></dt><dd><p>fate of carcass on the 1st, 2nd, 3rd,
4th, and 5th search after placement. A value of 1 implies that a carcass 
was discovered by searchers, 0 implies the carcass was present but not
discovered, and any other value is interpreted as &quot;no search&quot; or
&quot;carcass not present&quot; and ignored in the model. In this data set,
<code>NA</code> indicates that a carcass had been previously discovered and
removed from the field. A user may use a variety of values to
differentiate different reasons no search was conducted or the carcass
was not present. For example, &quot;NS&quot; to indicate the search
was not scheduled in that location at that time, or &quot;SC&quot; to indicate the
carcass had been removed by scavengers prior to the search.</p>
</dd>
<dt><code>Distance</code></dt><dd><p>the distance a carcass was placed from the 
observer's transect. Used in determining probability to detect with 
distance sampling.</p>
</dd>
</dl>



<h3>Carcass Persistence (<code>CP</code>)</h3>

<p><code>$CP</code> is a data frame with each row representing the fate of a single
carcass in the carcass persistence trials. There are columns for:
</p>

<dl>
<dt><code>Index</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or
<code>"sml"</code> bird</p>
</dd>
<dt><code>LastPresent</code>, <code>FirstAbsent</code></dt><dd><p>endpoints of the interval bracketing
the time the carcass was scavenged or otherwise removed from the field.
For example, <code>LastPresent = 2.04</code>, <code>FirstAbsent = 3.21</code> indicates that the
carcass was last observed 2.04 days after being placed in the field and
was noted missing 3.21 days after being placed. If the precise time of
carcass removal is known (e.g., recorded by camera), then <code>LastPresent</code> and
<code>FirstAbsent</code> should be set equal to each other. If a carcass persists
beyond the last day of the field trial, <code>LastPresent</code> is the last time it
was observed and <code>FirstAbsent</code> is entered as <code>Inf</code> or <code>NA</code>.</p>
</dd>
</dl>



<h3>Search Schedule (<code>SS</code>)</h3>

<p><code>$SS</code> is a data frame with a row for each date an array at the site was
searched, a column of <code>SearchDate</code>s, and a column for each array. In 
addition, there is an optional column to indicate the <code>Season</code>. The 
columns for distinct area (array) and the date column are required, and the
names of the columns for search areas must match the names of areas used in 
the DWP and CO files.
</p>

<dl>
<dt><code>SearchDate</code></dt><dd><p>columns of dates when arrays were searched. Format
in this data is <code>"%Y-%m-%d CDT"</code>, but time zone (<code>CDT</code>) is 
optional. A time stamp may be included if desired (e.g., 
<code>2018-03-20 02:15:41</code>). Alternatively, <code>\</code> can be used in
place of <code>-</code>.</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>,
or <code>"fall"</code> to indicate which season the search was conducted in. 
<code>Season</code> is optional but may be used as a temporal covariate for 
fatality estimates.</p>
</dd>
</dl>



<h3>Density Weighted Proportion (<code>DWP</code>)</h3>

<p><code>$DWP</code> is a data frame with a row for each array and columns for each 
carcass size class (labels must match those of the class factors in the 
carcass observation file). Values represent the density-weighted proportion 
of the searched area for each size (or the fraction of carcasses that fall 
in the searched area).  In this example, observers walk along transects 
separated by 150 meters, and search coverage is assumed to be 100
DWP = 1 for each unit. This requires that carcasses be placed at random
locations in the field, even at distances from the transects that would make
it unlikely to observe small carcasses.
</p>

<dl>
<dt><code>Unit</code></dt><dd><p>unique ID for each array.  IDs match those used in the 
<code>$CO</code> data frame and the column names in the <code>$SS</code> data.</p>
</dd>
<dt><code>bat</code></dt><dd><p>DWP associated with size class Bat</p>
</dd>
<dt><code>sml</code></dt><dd><p>DWP associated with size class Small</p>
</dd>
<dt><code>med</code></dt><dd><p>DWP associated with size class Medium</p>
</dd>
<dt><code>lrg</code></dt><dd><p>DWP associated with size class Large</p>
</dd>
</dl>



<h3>Carcass Observations (<code>CO</code>)</h3>

<p><code>$CO</code> is a data frame with a row for carcass observed in the carcass
searches and a number of columns giving information about the given
carcass (date found, size, species, etc.)
</p>

<dl>
<dt><code>Index</code></dt><dd><p>unique identifier for each carcass.</p>
</dd>
<dt><code>Unit</code></dt><dd><p>identifier for which unit the given carcass was found 
at: <code>"arc19"</code>, <code>"arc65"</code>, etc, for arcs in the outer heliostat 
field, or <code>"center"</code>, indicating the inner heliostat field.</p>
</dd>
<dt><code>Species</code></dt><dd><p>species of the carcass: <code>"BA"</code>, <code>"BB"</code>,
<code>"BC"</code>, <code>"BD"</code>, <code>"BE"</code>, <code>"LA"</code>, <code>"LB"</code>,
<code>"LD"</code>, <code>"LE"</code>, <code>"MA"</code>, <code>"MB"</code>, <code>"SA"</code>,
<code>"SB"</code>, <code>"SC"</code>, <code>"SD"</code>, <code>"SE"</code>, <code>"SF"</code>,
<code>"SG"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p>size: <code>"bat"</code>, <code>"lrg"</code>, <code>"med"</code>,
<code>"sml"</code></p>
</dd>
<dt><code>Row</code></dt><dd><p>Optional indicator of which row within an array a carcass
was found at.</p>
</dd>
<dt><code>Distance</code></dt><dd><p>The perpendicular distance from the searcher's 
transect at which the carcass was discovered at.</p>
</dd>
<dt><code>DateFound</code></dt><dd><p>dates entered in the same format as in 
<code>$SS$SearchDate</code>. Every date entered here is (and must be) included in
the search schedule 
(<code>$SS$SearchDate</code></p>
</dd>
<dt><code>X</code></dt><dd><p>UTM Easting of carcass.</p>
</dd>
<dt><code>Y</code></dt><dd><p>UTM Northing of carcass.</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>solar_PV</code>
</p>

<hr>
<h2 id='solar_trough'>Trough-based solar thermal power simulated example</h2><span id='topic+solar_trough'></span>

<h3>Description</h3>

<p>An example data set for estimating fatalities from a trough-based solar 
thermal electric power generation facility.  The simulated site is inspected 
daily along ten 2000 meter long transects,  which run  north-south. Observers
look up to 150 meters away down the rows created by troughs  (east-west).  
One sided distance sampling will be used, with observers looking consistently
in  one cardinal direction as they travel through the facility. A sitewide 
clearout search is implemented before the first scheduled winter search.
</p>
<p>The dataset consists of five parts: Data on carcass observations (CO) from 
daily searches, field trials for estimating carcass persistence (CP) and 
searcher efficiency (SE), search schedule (SS), and density weighted 
proportion (DWP) of area searched for the rows within each transect (which is
an area adjustment factor to account for incomplete search coverage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar_trough
</code></pre>


<h3>Format</h3>

<p><code>solar_trough</code> is a list with 5 elements:
</p>

<dl>
<dt><code>SE</code></dt><dd><p>Searcher efficiency trial data</p>
</dd>
<dt><code>CP</code></dt><dd><p>Carcass persistence trial data</p>
</dd>
<dt><code>SS</code></dt><dd><p>Search schedule parameters</p>
</dd>
<dt><code>DWP</code></dt><dd><p>Density weighted proportion of area searched</p>
</dd>
<dt><code>CO</code></dt><dd><p>Carcass observations</p>
</dd>
</dl>



<h3>Searcher Efficiency (<code>SE</code>)</h3>

<p><code>$SE</code> is a data frame with each row representing the fate of a single
carcass in the searcher efficiency trials. There are columns for:
</p>

<dl>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or 
<code>"sml"</code> bird</p>
</dd>
<dt><code>"Search1",...,"Search5"</code></dt><dd><p>fate of carcass on the 1st, 2nd, 3rd,
4th, and 5th search after placement. A value of 1 implies that a carcass 
was discovered by searchers, 0 implies the carcass was present but not
discovered, and any other value is interpreted as &quot;no search&quot; or
&quot;carcass not present&quot; and ignored in the model. In this data set,
<code>NA</code> indicates that a carcass had been previously discovered and
removed from the field. A user may use a variety of values to
differentiate different reasons no search was conducted or the carcass
was not present. For example, &quot;NS&quot; to indicate the search
was not scheduled in that location at that time, or &quot;SC&quot; to indicate the
carcass had been removed by scavengers prior to the search.</p>
</dd>
<dt><code>Distance</code></dt><dd><p>the distance a carcass was placed from the 
observer's transect.</p>
</dd>
</dl>



<h3>Carcass Persistence (<code>CP</code>)</h3>

<p><code>$CP</code> is a data frame with each row representing the fate of a single
carcass in the carcass persistence trials. There are columns for:
</p>

<dl>
<dt><code>Index</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or 
<code>"sml"</code> bird</p>
</dd>
<dt><code>LastPresent</code>, <code>FirstAbsent</code></dt><dd><p>endpoints of the interval bracketing the
time the carcass was scavenged or otherwise removed from the field. For 
example, <code>LastPresent = 2.04</code>, <code>FirstAbsent = 3.21</code> indicates that the carcass
was last observed 2.04 days after being placed in the field and was noted 
missing 3.21 days after being placed. If the precise time of carcass 
removal is known (e.g., recorded by camera), then <code>LastPresent</code> and
<code>FirstAbsent</code> should be set equal to each other. If a carcass persists
beyond the last day of the field trial, <code>LastPresent</code> is the last time it was
observed and <code>FirstAbsent</code> is entered as <code>Inf</code> or <code>NA</code>.</p>
</dd>
</dl>



<h3>Search Schedule (<code>SS</code>)</h3>

<p><code>$SS</code> is a data frame with a row for each date a transect at the site 
was searched, a column of <code>SearchDate</code>s, and a column for each 
transect. In addition, there is an optional column to indicate the 
<code>Season</code>. The columns for distinct area (array) and the date column
are required, and the names of the columns for search areas must match the 
names of areas used in the DWP and CO files.
</p>

<dl>
<dt><code>SearchDate</code></dt><dd><p>columns of dates when a transect was searched. 
Format in this data is <code>"%Y-%m-%d CDT"</code>, but time zone (<code>CDT</code>)
is optional. A time stamp may be included if desired (e.g., 
<code>2018-03-20 02:15:41</code>). Alternatively, <code>\</code> can be used in
place of <code>-</code>.</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"winter"</code>, <code>"spring"</code>, <code>"summer"</code>, or 
<code>"fall"</code> to indicate which season the search was conducted in. 
<code>Season</code> is optional but may be used as a temporal covariate for 
fatality estimates.</p>
</dd>
</dl>



<h3>Density Weighted Proportion (<code>DWP</code>)</h3>

<p><code>$DWP</code> is a data frame with a row for each transect and columns for 
each carcass size class (labels must match those of the class factors in the
carcass observation file). Values represent the density-weighted proportion
of the searched area for each size (or the fractionof carcasses that fall
in the searched area). Since the whole site was searched, DWP is uniformly
set equal to 1.
</p>

<dl>
<dt><code>Unit</code></dt><dd><p>unique ID for each transect.  IDs match those used in 
the <code>$CO</code> data frame and the column names in the <code>$SS</code> data.</p>
</dd>
<dt><code>bat</code></dt><dd><p>DWP associated with size class Bat</p>
</dd>
<dt><code>sml</code></dt><dd><p>DWP associated with size class Small</p>
</dd>
<dt><code>med</code></dt><dd><p>DWP associated with size class Medium</p>
</dd>
<dt><code>lrg</code></dt><dd><p>DWP associated with size class Large</p>
</dd>
</dl>



<h3>Carcass Observations (<code>CO</code>)</h3>

<p><code>$CO</code> is a data frame with a row for carcass observed in the carcass 
searches and a number of columns giving information about the given carcass 
(date found, size, species, etc.)
</p>

<dl>
<dt><code>Index</code></dt><dd><p>unique identifier for each carcass.</p>
</dd>
<dt><code>Unit</code></dt><dd><p>identifier for which transect the given carcass was 
found at.  Values must match with DWP Transect values Search Schedule 
column names.</p>
</dd>
<dt><code>Species</code></dt><dd><p>species of the carcass: <code>"BA"</code>, <code>"BB"</code>,
<code>"BC"</code>, <code>"BD"</code>, <code>"BE"</code>, <code>"LA"</code>, <code>"LB"</code>,
<code>"LD"</code>, <code>"LE"</code>, <code>"MA"</code>, <code>"MB"</code>, <code>"SA"</code>,
<code>"SB"</code>, <code>"SC"</code>, <code>"SD"</code>, <code>"SE"</code>, <code>"SF"</code>,
<code>"SG"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p>size: <code>"bat"</code>, <code>"lrg"</code>, <code>"med"</code>,
<code>"sml"</code></p>
</dd>
<dt><code>Row</code></dt><dd><p>Optional indicator of which row within an array a carcass
was found at.</p>
</dd>
<dt><code>Distance</code></dt><dd><p>The perpendicular distance from the searcher's 
transect at which the carcass was discovered at.</p>
</dd>
<dt><code>DateFound</code></dt><dd><p>dates entered in the same format as in 
<code>$SS$SearchDate</code>. 
Every date entered here is (and must be) included in the search schedule 
(<code>$SS$SearchDate</code>)</p>
</dd>
<dt><code>X</code></dt><dd><p>UTM Easting of carcass.</p>
</dd>
<dt><code>Y</code></dt><dd><p>UTM Northing of carcass.</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>solar_trough</code>
</p>

<hr>
<h2 id='summary.estM'>Summarize total mortality estimation</h2><span id='topic+summary.estM'></span>

<h3>Description</h3>

<p><code>summary</code> defined for class <code>estM</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estM'
summary(object, ..., CL = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.estM_+3A_object">object</code></td>
<td>
<p><code>estM</code> object</p>
</td></tr>
<tr><td><code id="summary.estM_+3A_...">...</code></td>
<td>
<p>arguments to pass down</p>
</td></tr>
<tr><td><code id="summary.estM_+3A_cl">CL</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>

<hr>
<h2 id='summary.gGeneric'>Summarize the gGeneric list to a simple table</h2><span id='topic+summary.gGeneric'></span>

<h3>Description</h3>

<p>methods for <code>summary</code> applied to a <code>gGeneric</code> list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gGeneric'
summary(object, ..., CL = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gGeneric_+3A_object">object</code></td>
<td>
<p>gGeneric output list (each element is a named vector of 
gGeneric values for a cell in the model combinations)</p>
</td></tr>
<tr><td><code id="summary.gGeneric_+3A_...">...</code></td>
<td>
<p>arguments to be passed down</p>
</td></tr>
<tr><td><code id="summary.gGeneric_+3A_cl">CL</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary table of g values (medians and confidence bounds) for 
each cell combination within the gGeneric list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mock)
  model_SE &lt;- pkm(formula_p = p ~ HabitatType, formula_k = k ~ 1,
                data = mock$SE)
  model_CP &lt;- cpm(formula_l = l ~ Visibility, formula_s = s ~ Visibility, 
                data = mock$CP, left = "LastPresentDecimalDays", 
                right = "FirstAbsentDecimalDays")
  avgSS &lt;- averageSS(mock$SS)
  ghatsGeneric &lt;- estgGeneric(nsim = 1000, avgSS, model_SE, model_CP)
  summary(ghatsGeneric)

</code></pre>

<hr>
<h2 id='summary.gGenericSize'>Summarize the gGenericSize list to a list of simple tables</h2><span id='topic+summary.gGenericSize'></span>

<h3>Description</h3>

<p>methods for <code>summary</code> applied to a <code>gGenericSize</code>
list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gGenericSize'
summary(object, ..., CL = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gGenericSize_+3A_object">object</code></td>
<td>
<p>gGenericSize output list (each element is a size-named 
list of named vectors of gGeneric values for a cell in the model 
combinations)</p>
</td></tr>
<tr><td><code id="summary.gGenericSize_+3A_...">...</code></td>
<td>
<p>arguments to be passed down</p>
</td></tr>
<tr><td><code id="summary.gGenericSize_+3A_cl">CL</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of summary tables of g values (medians and confidence 
bounds) for each cell combination within the gGeneric list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(mock)
  pkmModsSize &lt;- pkm(formula_p = p ~ HabitatType,
                   formula_k = k ~ HabitatType, data = mock$SE,
                   obsCol = c("Search1", "Search2", "Search3", "Search4"),
                   sizeCol = "Size", allCombos = TRUE)
  cpmModsSize &lt;- cpm(formula_l = l ~ Visibility,
                   formula_s = s ~ Visibility, data = mock$CP,
                   left = "LastPresentDecimalDays",
                   right = "FirstAbsentDecimalDays",
                   dist = c("exponential", "lognormal"),
                   sizeCol = "Size", allCombos = TRUE)
  pkMods &lt;- c("S" = "p ~ 1; k ~ 1", "L" = "p ~ 1; k ~ 1",
             "M" = "p ~ 1; k ~ 1", "XL" = "p ~ 1; k ~ 1"
            )
  cpMods &lt;- c("S" = "dist: exponential; l ~ 1; NULL", 
              "L" = "dist: exponential; l ~ 1; NULL",
              "M" = "dist: exponential; l ~ 1; NULL",
              "XL" = "dist: exponential; l ~ 1; NULL"
            )
  avgSS &lt;- averageSS(mock$SS)
  gsGeneric &lt;- estgGenericSize(nsim = 1000, days = avgSS,
                 modelSetSize_SE = pkmModsSize,
                 modelSetSize_CP = cpmModsSize,
                 modelSizeSelections_SE = pkMods,
                 modelSizeSelections_CP = cpMods
               )
 summary(gsGeneric)

</code></pre>

<hr>
<h2 id='summary.splitFull'>Summarize results of mortality estimate splits</h2><span id='topic+summary.splitFull'></span>

<h3>Description</h3>

<p>Mortality estimates can be calculated for the various levels 
of splitting covariates such as season, species, or visibility class
using <code><a href="#topic+calcSplits">calcSplits</a></code>, which gives full arrays of simulated M 
estimates (i.e., for each level of each splitting covariate, each 
discovered carcass, and each simulation draw). summary(splits, CL = 0.90,
...) gives summary statistics of the estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splitFull'
summary(object, CL = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.splitFull_+3A_object">object</code></td>
<td>
<p>A <code>splitFull</code> object (<code><a href="#topic+calcSplits">calcSplits</a></code>) that 
gives simulated mortality estimates for all combinations of levels of 1 
or 2 splitting covariates.</p>
</td></tr>
<tr><td><code id="summary.splitFull_+3A_cl">CL</code></td>
<td>
<p>desired confidence level for summary CIs (numeric scalar in 
(0, 1))</p>
</td></tr>
<tr><td><code id="summary.splitFull_+3A_...">...</code></td>
<td>
<p>to be passed down</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>splitSummary</code>, which gives 5-number
summaries for all combinations of levels among the splitting covariates 
in the <code>splits</code>. The 5-number summaries include the mean and 
alpha/2, 0.25, 0.5, 0.75, and 1 - alpha/2 quantiles of mortality 
estimates, where alpha = 1 - CL. A graphical representation of the 
results can be produced using <code>plot(splits, CL, ...)</code>. For splits
along CO covariates, the levels are organized alphabetically (but with 
numeric suffixes appearing in numeric order, e.g., &quot;t1&quot;, &quot;t2&quot;, &quot;t10&quot; 
rather than &quot;t1&quot;, &quot;t10&quot;, &quot;t2&quot;).
</p>

<hr>
<h2 id='tidyModelSetCP'>Tidy a CP model set</h2><span id='topic+tidyModelSetCP'></span>

<h3>Description</h3>

<p>Remove bad fit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyModelSetCP(modelSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidyModelSetCP_+3A_modelset">modelSet</code></td>
<td>
<p>cp model set of class cpmSet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trimmed model set
</p>

<hr>
<h2 id='tidyModelSetSE'>Tidy an SE model set</h2><span id='topic+tidyModelSetSE'></span>

<h3>Description</h3>

<p>Remove bad fit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyModelSetSE(modelSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidyModelSetSE_+3A_modelset">modelSet</code></td>
<td>
<p>pk model set of class pkmSet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trimmed model set
</p>

<hr>
<h2 id='transposeSplits'>Transpose a <code>splitFull</code> array (preserving attributes)</h2><span id='topic+transposeSplits'></span>

<h3>Description</h3>

<p>Transpose a <code>splitFull</code> array (preserving attributes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transposeSplits(splits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transposeSplits_+3A_splits">splits</code></td>
<td>
<p>a <code>splitFull</code> object, which is a list of <code>n</code>
<code>m</code> x <code>k</code> arrays with attributes describing characteristics of 
the splits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>m</code> <code>n</code> x <code>k</code> arrays as a <code>splitFull</code>
object
</p>

<hr>
<h2 id='trimSetSize'>Trim a Model-Set-Size Complex to a Single Model Per Size</h2><span id='topic+trimSetSize'></span>

<h3>Description</h3>

<p>Select a single model from each carcass class (based on the model
names).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimSetSize(modSetSize, mods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimSetSize_+3A_modsetsize">modSetSize</code></td>
<td>
<p>modSetSize complex (cpm or pkm)</p>
</td></tr>
<tr><td><code id="trimSetSize_+3A_mods">mods</code></td>
<td>
<p>named (according to carcass classes) vector of model names to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modSetSize reduced to a single model per carcass class
</p>

<hr>
<h2 id='update_input'>Update the inputs when an event occurs</h2><span id='topic+update_input'></span>

<h3>Description</h3>

<p>When an event occurs in the GenEst GUI, the input values may
need to be updated. This function contains all of the possible updates
based on the event options (or lacks any updates if the event doesn't
require any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_input(eventName, rv, input, session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_input_+3A_eventname">eventName</code></td>
<td>
<p>Character name of the event. One of &quot;clear_all&quot;,
&quot;file_SE&quot;, &quot;file_SE_clear&quot;, &quot;file_CP&quot;, &quot;file_CP_clear&quot;, &quot;file_SS&quot;,
&quot;file_SS_clear&quot;, &quot;file_DWP&quot;, &quot;file_DWP_clear&quot;, &quot;file_CO&quot;,
&quot;file_CO_clear&quot;, &quot;class&quot;, &quot;obsSE&quot;, &quot;predsSE&quot;, &quot;run_SE&quot;, &quot;run_SE_clear&quot;,
&quot;outSEclass&quot;, &quot;outSEp&quot;, &quot;outSEk&quot;, &quot;ltp&quot;, &quot;fta&quot;, &quot;predsCP&quot;, &quot;run_CP&quot;,
&quot;run_CP_clear&quot;, &quot;outCPclass&quot;, &quot;outCPdist&quot;, &quot;outCPl&quot;, &quot;outCPs&quot;,
&quot;run_M&quot;, &quot;run_M_clear&quot;, &quot;split_M&quot;, &quot;split_M_clear&quot;, &quot;transpose_split&quot;,
&quot;run_g&quot;, &quot;run_g_clear&quot;, or &quot;outgclass&quot;.</p>
</td></tr>
<tr><td><code id="update_input_+3A_rv">rv</code></td>
<td>
<p>Reactive values list for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="update_input_+3A_input">input</code></td>
<td>
<p><code>input</code> list for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="update_input_+3A_session">session</code></td>
<td>
<p>Environment for the GenEst GUI.</p>
</td></tr>
</table>

<hr>
<h2 id='update_output'>Update the outputs when an event occurs</h2><span id='topic+update_output'></span>

<h3>Description</h3>

<p>When an event occurs in the GenEst GUI, the output values may
need to be updated. This function contains all of the possible updates
based on the event options (or lacks any updates if the event doesn't
require any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_output(eventName, rv, output, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_output_+3A_eventname">eventName</code></td>
<td>
<p>Character name of the event. One of &quot;clear_all&quot;,
&quot;file_SE&quot;, &quot;file_SE_clear&quot;, &quot;file_CP&quot;, &quot;file_CP_clear&quot;, &quot;file_SS&quot;,
&quot;file_SS_clear&quot;, &quot;file_DWP&quot;, &quot;file_DWP_clear&quot;, &quot;file_CO&quot;, 
&quot;file_CO_clear&quot;, &quot;class&quot;, &quot;obsSE&quot;, &quot;predsSE&quot;, &quot;run_SE&quot;, &quot;run_SE_clear&quot;,
&quot;outSEclass&quot;, &quot;outSEp&quot;, &quot;outSEk&quot;, &quot;ltp&quot;, &quot;fta&quot;, &quot;predsCP&quot;, &quot;run_CP&quot;,
&quot;run_CP_clear&quot;, &quot;outCPclass&quot;, &quot;outCPdist&quot;, &quot;outCPl&quot;, &quot;outCPs&quot;,
&quot;run_M&quot;, &quot;run_M_clear&quot;, &quot;split_M&quot;, &quot;split_M_clear&quot;, &quot;transpose_split&quot;,
&quot;run_g&quot;, &quot;run_g_clear&quot;, or &quot;outgclass&quot;.</p>
</td></tr>
<tr><td><code id="update_output_+3A_rv">rv</code></td>
<td>
<p>Reactive values list for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="update_output_+3A_output">output</code></td>
<td>
<p><code>output</code> list for the GenEst GUI.</p>
</td></tr>
<tr><td><code id="update_output_+3A_input">input</code></td>
<td>
<p><code>input</code> lisst for the GenEst GUI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>output</code> list.
</p>

<hr>
<h2 id='update_rv'>Update the reactive value list when an event occurs</h2><span id='topic+update_rv'></span>

<h3>Description</h3>

<p>When an event occurs in the GenEst GUI, the reactive values 
need to be updated. This function contains all of the possible updates
based on the event options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_rv(eventName, rv, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_rv_+3A_eventname">eventName</code></td>
<td>
<p>Character name of the event. One of &quot;clear_all&quot;,
&quot;file_SE&quot;, &quot;file_SE_clear&quot;, &quot;file_CP&quot;, &quot;file_CP_clear&quot;, &quot;file_SS&quot;,
&quot;file_SS_clear&quot;, &quot;file_DWP&quot;, &quot;file_DWP_clear&quot;, &quot;file_CO&quot;, 
&quot;file_CO_clear&quot;, &quot;class&quot;, &quot;obsSE&quot;, &quot;predsSE&quot;, &quot;run_SE&quot;, &quot;run_SE_clear&quot;,
&quot;outSEclass&quot;, &quot;outSEp&quot;, &quot;outSEk&quot;, &quot;ltp&quot;, &quot;fta&quot;, &quot;predsCP&quot;, &quot;run_CP&quot;,
&quot;run_CP_clear&quot;, &quot;outCPclass&quot;, &quot;outCPdist&quot;, &quot;outCPl&quot;, &quot;outCPs&quot;,
&quot;run_M&quot;, &quot;run_M_clear&quot;, &quot;split_M&quot;, &quot;split_M_clear&quot;, &quot;transpose_split&quot;,
&quot;run_g&quot;, &quot;run_g_clear&quot;, &quot;outgclass&quot;, &quot;load_RP&quot;, &quot;load_RPbat&quot;,
&quot;load_cleared&quot;, &quot;load_PV&quot;, &quot;load_trough&quot;, &quot;load_powerTower&quot;, or &quot;load_mock&quot;</p>
</td></tr>
<tr><td><code id="update_rv_+3A_rv">rv</code></td>
<td>
<p>Reactive values list for the GenEst GUI, created by 
<code><a href="#topic+initialReactiveValues">initialReactiveValues</a></code>, which calls 
<code><a href="shiny.html#topic+reactiveValues">reactiveValues</a></code></p>
</td></tr>
<tr><td><code id="update_rv_+3A_input">input</code></td>
<td>
<p><code>input</code> list for the GenEst GUI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>rv</code> list.
</p>

<hr>
<h2 id='wind_cleared'>Wind cleared plot (60m) Search Example</h2><span id='topic+wind_cleared'></span>

<h3>Description</h3>

<p>A complete example data set for estimating fatalities from 60 m cleared plots
at 23 out of 100 searches at a wind power facility.  Data on carcass 
observations (CO) from a search of all terrain out to 60m from each of 100 
turbines at a theoretical site, field trials for estimating carcass 
persistence (CP) and searcher efficiency (SE), search schedule (SS) 
parameters (for example, which turbines were searched on which days), and 
density weighted proportion (DWP) of area searched at each turbine (which is 
an area adjustment factor to account for incomplete  search coverage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind_cleared
</code></pre>


<h3>Format</h3>

<p><code>wind_cleared</code> is a list with 5 elements:
</p>

<dl>
<dt><code>SE</code></dt><dd><p>Searcher efficiency trial data</p>
</dd>
<dt><code>CP</code></dt><dd><p>Carcass persistence trial data</p>
</dd>
<dt><code>SS</code></dt><dd><p>Search schedule parameters</p>
</dd>
<dt><code>DWP</code></dt><dd><p>Density weighted proportion of area searched</p>
</dd>
<dt><code>CO</code></dt><dd><p>Carcass observations</p>
</dd>
</dl>



<h3>Searcher Efficiency (<code>SE</code>)</h3>

<p><code>$SE</code> is a data frame with each row representing the fate of a single
carcass in the searcher efficiency trials. There are columns for:
</p>

<dl>
<dt><code>pkID</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or
<code>"sml"</code> bird</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code></p>
</dd>
<dt><code>Visibility</code></dt><dd><p>indicator for visibility class of the ground, with
<code>"RP"</code> for carcasses placed on a road or turbine pad, <code>"M"</code>
for moderate visibility (e.g., plowed field; short, sparse vegetation),
or <code>"D"</code> for difficult visibility</p>
</dd>
<dt><code>"s1",...,"s5"</code></dt><dd><p>fate of carcass on the 1st, 2nd, 3rd, 4th, and
5th search after placement. A value of 1 implies that a carcass was
discovered by searchers, 0 implies the carcass was present but not
discovered, and any other value is interpreted as &quot;no search&quot; or
&quot;carcass not present&quot; and ignored in the model. In this data set,
<code>NA</code> indicates that a carcass had been previously discovered and
removed from the field. A user may use a variety of values to
differentiate different reasons no search was conducted or the carcass
was not present. For example, &quot;SN&quot; could be used to indicate that the
turbine was not searched because of snow, or &quot;NS&quot; to indicate the search
was not scheduled in that location at that time, or &quot;SC&quot; to indicate the
carcass had been removed by scavengers prior to the search.</p>
</dd>
</dl>



<h3>Carcass Persistence (<code>CP</code>)</h3>

<p><code>$CP</code> is a data frame with each row representing the fate of a single
carcass in the carcass persistence trials. There are columns for:
</p>

<dl>
<dt><code>cpID</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or 
<code>"sml"</code> bird</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code></p>
</dd>
<dt><code>Visibility</code></dt><dd><p>indicator for visibility class of the ground, with
<code>"RP"</code> for carcasses placed on a road or turbine pad, <code>"M"</code> for 
moderate visibility (e.g., plowed field; short, sparse vegetation), or 
<code>"D"</code> for difficult visibility.</p>
</dd> <dt><code>LastPresent</code>,
<code>FirstAbsent</code></dt><dd><p>endpoints of the interval bracketing the time the carcass
was scavenged or otherwise removed from the field. For example, 
<code>LastPresent = 2.04</code>, <code>FirstAbsent = 3.21</code> indicates that the carcass was
last observed 2.04 days after being placed in the field and was noted 
missing 3.21 days after being placed. If the precise time of carcass 
removal is known (e.g., recorded by camera), then <code>LastPresent</code> and
<code>FirstAbsent</code> should be set equal to each other. If a carcass persists
beyond the last day of the field trial, <code>LastPresent</code> is the last time it
was observed and <code>FirstAbsent</code> is entered as <code>Inf</code> or <code>NA</code>.</p>
</dd>
</dl>



<h3>Search Schedule (<code>SS</code>)</h3>

<p><code>$SS</code> is a data frame with a row for each date a turbine at the site
was searched, a column of <code>SearchDate</code>s, and a column for each turbine.
In addition, there is a column to indicate the <code>Season</code>. A column with
search dates and columns for each turbine searched are required. Other
columns are optional.
</p>

<dl>
<dt><code>SearchDate</code></dt><dd><p>columns of dates on which at least one turbine was
searched. Format in this data is <code>"%Y-%m-%d CDT"</code>, but time zone 
(<code>CDT</code>) is optional. A time stamp may be included if desired (e.g., 
<code>2018-03-20 02:15:41</code>). Alternatively, <code>\</code> can be used in place
of <code>-</code>.</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code> to
indicate which season the search was conducted in. <code>Season</code> is
optional but may be used as a temporal covariate for fatality estimates.</p>
</dd>
<dt><code>t1</code>, etc.</dt><dd><p>unique ID for all turbines that were searched on at
least one search date. Values are either 1 or 0, indicating whether the
given turbine (column) was searched or not on the given date (row).</p>
</dd>
</dl>



<h3>Density Weighted Proportion (<code>DWP</code>)</h3>

<p><code>$DWP</code> is a data frame with a row for each turbine and columns for
each carcass size class. Values represent the density-weighted proportion
of the searched area for each size (or the fraction of carcasses that fall
in the searched area).
</p>

<dl>
<dt><code>Turbine</code></dt><dd><p>unique ID for each turbine. IDs match those used in 
the <code>$CO</code> data frame and the column names in the <code>$SS</code> data.</p>
</dd>
<dt><code>Size</code></dt><dd><p><code>bat</code>, <code>sml</code>, <code>med</code>, <code>lrg</code></p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code> to 
indicate which season the search was conducted in. <code>Season</code> is 
optional but may be used as a temporal covariate for fatality estimates.</p>
</dd></dl>



<h3>Carcass Observations (<code>CO</code>)</h3>

<p><code>$CO</code> is a data frame with a row for carcass observed in the carcass
searches and a number of columns giving information about the given carcass
(date found, size, species, etc.)
</p>

<dl>
<dt><code>carcID</code></dt><dd><p>unique identifier for each carcass: <code>"x30"</code>,
<code>"x46"</code>, etc.</p>
</dd>
<dt><code>Turbine</code></dt><dd><p>identifier for which turbine the given carcass was
found at: <code>"t19"</code>, <code>"t65"</code>, <code>"t49"</code>, etc.</p>
</dd>
<dt><code>TurbineType</code></dt><dd><p>the type of turbine: <code>"X"</code>, <code>"Y"</code> or
<code>"Z"</code>. </p>
</dd>
<dt><code>DateFound</code></dt><dd><p>dates entered in the same format as in
<code>$SS$SearchDate</code>. Every date entered here is (and must be) included
in the search schedule (<code>$SS$SearchDate</code>)</p>
</dd>
<dt><code>Visibility</code></dt><dd><p>visibility class: <code>"RP"</code>, <code>"M"</code>, or
<code>"D"</code>, as described in <code>$CP</code> and <code>$SE</code></p>
</dd>
<dt><code>Species</code></dt><dd><p>species of the carcass: <code>"BA"</code>, <code>"BB"</code>,
<code>"BC"</code>, <code>"BD"</code>, <code>"BE"</code>, <code>"LA"</code>, <code>"LB"</code>,
<code>"LD"</code>, <code>"LE"</code>, <code>"MA"</code>, <code>"MB"</code>, <code>"SA"</code>,
<code>"SB"</code>, <code>"SC"</code>, <code>"SD"</code>, <code>"SE"</code>, <code>"SF"</code>,
<code>"SG"</code></p>
</dd>
<dt><code>SpeciesGroup</code></dt><dd><p>species group: <code>"bat0"</code>, <code>"bat1"</code>,
<code>"brd1"</code>, <code>"brd2"</code>, <code>"brd3"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p>size: <code>"bat"</code>, <code>"lrg"</code>, <code>"med"</code>,
<code>"sml"</code></p>
</dd>
<dt><code>Distance</code></dt><dd><p>distance from the turbine</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>wind_cleared</code>
</p>

<hr>
<h2 id='wind_RP'>Wind Road and Pad (120m) Example</h2><span id='topic+wind_RP'></span>

<h3>Description</h3>

<p>This example dataset is based on 120 m radius road and pad searches of all 
100 turbines at a theoretical site.  The simulated site consists of 100 
turbines, searched on roads and pads only, out to 120 meters.  Search 
schedule differs by turbine and season, with more frequent searches in the 
fall, and a subset of twenty turbines searched at every scheduled search.
</p>
<p>Data on carcass observations (CO) from searches, field trials for estimating 
carcass persistence (CP) and searcher efficiency (SE), search schedule (SS) 
parameters (for example, which turbines were searched on which days), and 
density weighted proportion (DWP) of area searched at each turbine (which is 
an area adjustment factor to account for incomplete search coverage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind_RP
</code></pre>


<h3>Format</h3>

<p><code>wind_RP</code> is a list with 5 elements:
</p>

<dl>
<dt><code>SE</code></dt><dd><p>Searcher efficiency trial data</p>
</dd>
<dt><code>CP</code></dt><dd><p>Carcass persistence trial data</p>
</dd>
<dt><code>SS</code></dt><dd><p>Search schedule parameters</p>
</dd>
<dt><code>DWP</code></dt><dd><p>Density weighted proportion of area searched</p>
</dd>
<dt><code>CO</code></dt><dd><p>Carcass observations</p>
</dd>
</dl>



<h3>Searcher Efficiency (<code>SE</code>)</h3>

<p><code>$SE</code> is a data frame with each row representing the fate of a single
carcass in the searcher efficiency trials. There are columns for:
</p>

<dl>
<dt><code>pkID</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or
<code>"sml"</code> bird</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code></p>
</dd>
<dt><code>"s1",...,"s5"</code></dt><dd><p>fate of carcass on the 1st, 2nd, 3rd, 4th, and
5th search after placement. A value of 1 implies that a carcass was
discovered by searchers, 0 implies the carcass was present but not
discovered, and any other value is interpreted as &quot;no search&quot; or
&quot;carcass not present&quot; and ignored in the model. In this data set,
<code>NA</code> indicates that a carcass had been previously discovered and
removed from the field. A user may use a variety of values to
differentiate different reasons no search was conducted or the carcass
was not present. For example, &quot;SN&quot; could be used to indicate that the
turbine was not searched because of snow, or &quot;NS&quot; to indicate the search
was not scheduled in that location at that time, or &quot;SC&quot; to indicate the
carcass had been removed by scavengers prior to the search.</p>
</dd>
</dl>



<h3>Carcass Persistence (<code>CP</code>)</h3>

<p><code>$CP</code> is a data frame with each row representing the fate of a single
carcass in the carcass persistence trials. There are columns for:
</p>

<dl>
<dt><code>cpID</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Size</code></dt><dd><p><code>"bat"</code>; or <code>"lrg"</code>, <code>"med"</code>, or 
<code>"sml"</code> bird.</p>
</dd> 
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code></p>
</dd>
<dt><code>LastPresent</code>, <code>FirstAbsent</code></dt><dd><p>endpoints of the interval bracketing the
time the carcass was scavenged or otherwise removed from the field. For 
example, <code>LastPresent = 2.04</code>, <code>FirstAbsent = 3.21</code> indicates that the carcass
was last observed 2.04 days after being placed in the field and was noted 
missing 3.21 days after being placed. If the precise time of carcass
removal is known (e.g., recorded by camera), then <code>LastPresent</code> and
<code>FirstAbsent</code> should be set equal to each other. If a carcass persists
beyond the last day of the field trial, <code>LastPresent</code> is the last time it
was observed and <code>FirstAbsent</code> is entered as <code>Inf</code> or <code>NA</code>.</p>
</dd>
</dl>



<h3>Search Schedule (<code>SS</code>)</h3>

<p><code>$SS</code> is a data frame with a row for each date a turbine at the site
was searched, a column of <code>SearchDate</code>s, and a column for each turbine.
In addition, there is a column to indicate the <code>Season</code>. A column with
search dates and columns for each turbine searched are required. Other
columns are optional.
</p>

<dl>
<dt><code>SearchDate</code></dt><dd><p>columns of dates on which at least one turbine was
searched. Format in this data is <code>"%Y-%m-%d CDT"</code>, but time zone
(<code>CDT</code>) is optional. A time stamp may be included if desired
(e.g., <code>2018-03-20 02:15:41</code>). Alternatively, <code>\</code> can be used 
in place of <code>-</code>.</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code> to
indicate which season the search was conducted in. <code>Season</code> is
optional but may be used as a temporal covariate for fatality estimates.</p>
</dd>
<dt><code>t1</code>, etc.</dt><dd><p>unique ID for all turbines that were searched on at
least one search date. Values are either 1 or 0, indicating whether the
given turbine (column) was searched or not on the given date (row).</p>
</dd>
</dl>



<h3>Density Weighted Proportion (<code>DWP</code>)</h3>

<p><code>$DWP</code> is a data frame with a row for each turbine and columns for
each carcass size class. Values represent the density-weighted proportion
of the searched area for each size (or the fraction of carcasses that fall
in the searched area).
</p>

<dl>
<dt><code>Turbine</code></dt><dd><p>unique ID for each turbine. IDs match those used in
the <code>$CO</code> data frame and the column names in the <code>$SS</code> data.</p>
</dd>
<dt><code>bat</code></dt><dd><p>DWP associated with size class Bat.</p>
</dd>
<dt><code>sml</code></dt><dd><p>DWP associated with size class Small.</p>
</dd>
<dt><code>med</code></dt><dd><p>DWP associated with size class Medium.</p>
</dd>
<dt><code>lrg</code></dt><dd><p>DWP associated with size class Large.</p>
</dd>
</dl>



<h3>Carcass Observations (<code>CO</code>)</h3>

<p><code>$CO</code> is a data frame with a row for carcass observed in the carcass
searches and a number of columns giving information about the given
carcass (date found, size, species, etc.)
</p>

<dl>
<dt><code>carcID</code></dt><dd><p>unique identifier for each carcass: <code>"x30"</code>,
<code>"x46"</code>, etc.</p>
</dd>
<dt><code>Turbine</code></dt><dd><p>identifier for which turbine the given carcass was
found at: <code>"t19"</code>, <code>"t65"</code>, <code>"t49"</code>, etc.</p>
</dd>
<dt><code>TurbineType</code></dt><dd><p>the type of turbine: <code>"X"</code>, <code>"Y"</code> or
<code>"Z"</code>. </p>
</dd>
<dt><code>DateFound</code></dt><dd><p>dates entered in the same format as in
<code>$SS$SearchDate</code>. Every date entered here is (and must be) included
in the search schedule (<code>$SS$SearchDate</code></p>
</dd>
<dt><code>Species</code></dt><dd><p>species of the carcass: <code>"BA"</code>, <code>"BB"</code>,
<code>"BC"</code>, <code>"BD"</code>, <code>"BE"</code>, <code>"LA"</code>, <code>"LB"</code>,
<code>"LD"</code>, <code>"LE"</code>, <code>"MA"</code>, <code>"MB"</code>, <code>"SA"</code>,
<code>"SB"</code>, <code>"SC"</code>, <code>"SD"</code>, <code>"SE"</code>, <code>"SF"</code>,
<code>"SG"</code></p>
</dd>
<dt><code>SpeciesGroup</code></dt><dd><p>species group: <code>"bat0"</code>, <code>"bat1"</code>,
<code>"brd1"</code>, <code>"brd2"</code>, <code>"brd3"</code></p>
</dd>
<dt><code>Size</code></dt><dd><p>size: <code>"bat"</code>, <code>"lrg"</code>, <code>"med"</code>,
<code>"sml"</code></p>
</dd>
<dt><code>Distance</code></dt><dd><p>distance from the turbine</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>wind_RP</code>
</p>

<hr>
<h2 id='wind_RPbat'>Wind Bat-Only Road and Pad (120m) Example</h2><span id='topic+wind_RPbat'></span>

<h3>Description</h3>

<p>This example dataset considers only bats found on 120 m radius road and pad 
searches of all 100 turbines at a theoretical site.  The simulated site 
consists of 100 turbines, searched on roads and pads only, out to 120 
meters.  Search schedule differs by turbine and season, with more frequent 
searches in the fall, and a subset of twenty turbines searched at every 
scheduled search.
</p>
<p>Data on carcass observations (CO) from searches, field trials for estimating 
carcass persistence (CP) and searcher efficiency (SE), search schedule (SS) 
parameters (for example, which turbines  were searched on which days), and 
density weighted proportion (DWP) of area searched at each  turbine (which is
an area adjustment factor to account for incomplete search coverage).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind_RPbat
</code></pre>


<h3>Format</h3>

<p><code>wind_RPbat</code> is a list with 5 elements:
</p>

<dl>
<dt><code>SE</code></dt><dd><p>Searcher efficiency trial data</p>
</dd>
<dt><code>CP</code></dt><dd><p>Carcass persistence trial data</p>
</dd>
<dt><code>SS</code></dt><dd><p>Search schedule parameters</p>
</dd>
<dt><code>DWP</code></dt><dd><p>Density weighted proportion of area searched</p>
</dd>
<dt><code>CO</code></dt><dd><p>Carcass observations</p>
</dd>
</dl>



<h3>Searcher Efficiency (<code>SE</code>)</h3>

<p><code>$SE</code> is a data frame with each row representing the fate of a single
carcass in the searcher efficiency trials. There are columns for:
</p>

<dl>
<dt><code>pkID</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code></p>
</dd>
<dt><code>"s1",...,"s5"</code></dt><dd><p>fate of carcass on the 1st, 2nd, 3rd, 4th, and
5th search after placement. A value of 1 implies that a carcass was
discovered by searchers, 0 implies the carcass was present but not
discovered, and any other value is interpreted as &quot;no search&quot; or
&quot;carcass not present&quot; and ignored in the model. In this data set,
<code>NA</code> indicates that a carcass had been previously discovered and
removed from the field. A user may use a variety of values to
differentiate different reasons no search was conducted or the carcass
was not present. For example, &quot;SN&quot; could be used to indicate that the
turbine was not searched because of snow, or &quot;NS&quot; to indicate the search
was not scheduled in that location at that time, or &quot;SC&quot; to indicate the
carcass had been removed by scavengers prior to the search.</p>
</dd>
</dl>



<h3>Carcass Persistence (<code>CP</code>)</h3>

<p><code>$CP</code> is a data frame with each row representing the fate of a single
carcass in the carcass persistence trials. There are columns for:
</p>

<dl>
<dt><code>cpID</code></dt><dd><p>unique ID for each carcass</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code></p>
</dd>
<dt><code>LastPresent</code>, <code>FirstAbsent</code></dt><dd><p>endpoints of the interval bracketing
the time the carcass was scavenged or otherwise removed from the field.
For example, <code>LastPresent = 2.04</code>, <code>FirstAbsent = 3.21</code> indicates that the
carcass was last observed 2.04 days after being placed in the field and
was noted missing 3.21 days after being placed. If the precise time of
carcass removal is known (e.g., recorded by camera), then <code>LastPresent</code> and
<code>FirstAbsent</code> should be set equal to each other. If a carcass persists
beyond the last day of the field trial, <code>LastPresent</code> is the last time it
was observed and <code>FirstAbsent</code> is entered as <code>Inf</code> or <code>NA</code>.</p>
</dd>
</dl>



<h3>Search Schedule (<code>SS</code>)</h3>

<p><code>$SS</code> is a data frame with a row for each date a turbine at the site
was searched, a column of <code>SearchDate</code>s, and a column for each turbine.
In addition, there is a column to indicate the <code>Season</code>. A column with
search dates and columns for each turbine searched are required. Other
columns are optional.
</p>

<dl>
<dt><code>SearchDate</code></dt><dd><p>columns of dates on which at least one turbine was
searched. Format in this data is <code>"%Y-%m-%d CDT"</code>, but time zone
(<code>CDT</code>) is optional. A time stamp may be included if desired
(e.g., <code>2018-03-20 02:15:41</code>). Alternatively, <code>\</code> can be used 
in place of <code>-</code>.</p>
</dd>
<dt><code>Season</code></dt><dd><p><code>"spring"</code>, <code>"summer"</code>, or <code>"fall"</code> to
indicate which season the search was conducted in. <code>Season</code> is
optional but may be used as a temporal covariate for fatality estimates.</p>
</dd>
<dt><code>t1</code>, etc.</dt><dd><p>unique ID for all turbines that were searched on at
least one search date. Values are either 1 or 0, indicating whether the
given turbine (column) was searched or not on the given date (row).</p>
</dd>
</dl>



<h3>Density Weighted Proportion (<code>DWP</code>)</h3>

<p><code>$DWP</code> is a data frame with a row for each turbine and columns for
each carcass size class. Values represent the density-weighted proportion
of the searched area for each size (or the fraction of carcasses that fall
in the searched area).
</p>

<dl>
<dt><code>Turbine</code></dt><dd><p>unique ID for each turbine. IDs match those used in
the <code>$CO</code> data frame and the column names in the <code>$SS</code> data.</p>
</dd>
<dt><code>bat</code></dt><dd><p>Contains the DWP for each turbine, with respect to size 
class (in this case, bats only.</p>
</dd>
</dl>



<h3>Carcass Observations (<code>CO</code>)</h3>

<p><code>$CO</code> is a data frame with a row for carcass observed in the carcass
searches and a number of columns giving information about the given
carcass (date found, size, species, etc.)
</p>

<dl>
<dt><code>carcID</code></dt><dd><p>unique identifier for each carcass: <code>"x30"</code>,
<code>"x46"</code>, etc.</p>
</dd>
<dt><code>Turbine</code></dt><dd><p>identifier for which turbine the given carcass was
found at: <code>"t19"</code>, <code>"t65"</code>, <code>"t49"</code>, etc.</p>
</dd>
<dt><code>TurbineType</code></dt><dd><p>the type of turbine: <code>"X"</code>, <code>"Y"</code> or
<code>"Z"</code>. </p>
</dd>
<dt><code>DateFound</code></dt><dd><p>dates entered in the same format as in
<code>$SS$SearchDate</code>. Every date entered here is (and must be) included
in the search schedule (<code>$SS$SearchDate</code></p>
</dd>
<dt><code>Species</code></dt><dd><p>species of the carcass: <code>"BA"</code>, <code>"BB"</code>,
<code>"BC"</code>, <code>"BD"</code>, <code>"BE"</code>, <code>"LA"</code>, <code>"LB"</code>,
<code>"LD"</code>, <code>"LE"</code>, <code>"MA"</code>, <code>"MB"</code>, <code>"SA"</code>,
<code>"SB"</code>, <code>"SC"</code>, <code>"SD"</code>, <code>"SE"</code>, <code>"SF"</code>,
<code>"SG"</code></p>
</dd>
<dt><code>SpeciesGroup</code></dt><dd><p>species group: <code>"bat0"</code>, <code>"bat1"</code>,
<code>"brd1"</code>, <code>"brd2"</code>, <code>"brd3"</code></p>
</dd>
<dt><code>Distance</code></dt><dd><p>Distance from the turbine.</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>wind_RPbat</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
