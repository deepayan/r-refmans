<!DOCTYPE html><html lang="en"><head><title>Help for package coreCollection</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coreCollection}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coreCollection-package'><p>The coreCollection package</p></a></li>
<li><a href='#.CoreCollectionClass'><p>The CoreCollection Class</p></a></li>
<li><a href='#computeAdjustedSelectionUsingRecomputeMethod'><p>Compute selection - recompute method</p></a></li>
<li><a href='#computeAdjustedSelectionUsingSplitMethod'><p>Compute selection - split method</p></a></li>
<li><a href='#computeCore'><p>Compute the core</p></a></li>
<li><a href='#computeRandomSelection'><p>Compute a random selection</p></a></li>
<li><a href='#CoreCollection'><p>The CoreCollection class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Core Collection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.5</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Create a custom sized Core Collection based on a distance matrix and applying
  the A-NE (accession nearest entry), E-NE (entry nearest entry) or E-E (entry entry) method
  as introduced in Jansen and van Hintum (2007) &lt;<a href="https://doi.org/10.1007%2Fs00122-006-0433-9">doi:10.1007/s00122-006-0433-9</a>&gt; and
  further elaborated on in Odong, T.L. (2012) <a href="https://edepot.wur.nl/212422">https://edepot.wur.nl/212422</a>.
  Optionally a list of preselected accessions to be included into the core can be set.
  For each accession in the computed core, if available nearby accessions are retrievable
  that can be used as an alternative.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), R6 (&ge; 2.4.0), methods</td>
</tr>
<tr>
<td>Collate:</td>
<td>coreCollection.package.R coreCollection.R coreSelection.R
RcppExports.R</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), vcfR, adegenet, ggfortify</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-20 08:37:25 UTC; matthijs</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthijs Brouwer <a href="https://orcid.org/0000-0001-8183-0484"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Reinhoud Blok, de [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthijs Brouwer &lt;matthijs.brouwer@wur.nl&gt;</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-20 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coreCollection-package'>The coreCollection package</h2><span id='topic+coreCollection-package'></span><span id='topic+coreCollection'></span>

<h3>Description</h3>

<p>This package can be used to create a <a href="#topic+CoreCollection">CoreCollection</a> object.
</p>


<h3>Author(s)</h3>

<p>Matthijs Brouwer &lt;matthijs.brouwer@wur.nl&gt;
</p>


<h3>References</h3>

<p>Odong, T.L. (2012) Quantative methods for sampling of germplasm collections -
Getting the best out of molecular markers when creating core collections. PhD diss., Wageningen
University and Research, Wageningen, The Netherlands. <a href="http://edepot.wur.nl/212422">http://edepot.wur.nl/212422</a><br />
</p>
<p>Jansen, J &amp; Hintum, Theo. (2007) Genetic distance sampling: A novel
sampling method for obtaining core collections using genetic distances with an
application to cultivated lettuce. TAG. Theoretical and applied genetics.
Theoretische und angewandte Genetik. 114. 421-8. 10.1007/s00122-006-0433-9<br />
</p>


<h3>See Also</h3>

<p>- <span class="pkg">vcfR</span> provides a suite of tools for input and output of variant call format (VCF) files, manipulation of their content and visualization.<br />
- <span class="pkg">adegenet</span> provides the <code>genlight</code> class for genome-wide SNP data, and includes a method to create a distance matrix.
</p>
<p>Other core collection: 
<code><a href="#topic+CoreCollection">CoreCollection</a>()</code>
</p>

<hr>
<h2 id='.CoreCollectionClass'>The CoreCollection Class</h2><span id='topic+.CoreCollectionClass'></span>

<h3>Description</h3>

<p>The CoreCollection Class
</p>
<p>The CoreCollection Class
</p>


<h3>Format</h3>

<p>A <code>R6Class</code> generator object
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-coreCollection-recompute"><code>.CoreCollectionClass$recompute()</code></a>
</p>
</li>
<li> <p><a href="#method-coreCollection-alternativeCore"><code>.CoreCollectionClass$alternativeCore()</code></a>
</p>
</li>
<li> <p><a href="#method-coreCollection-new"><code>.CoreCollectionClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-coreCollection-print"><code>.CoreCollectionClass$print()</code></a>
</p>
</li>
<li> <p><a href="#method-coreCollection-summary"><code>.CoreCollectionClass$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-coreCollection-measure"><code>.CoreCollectionClass$measure()</code></a>
</p>
</li>
<li> <p><a href="#method-coreCollection-measures"><code>.CoreCollectionClass$measures()</code></a>
</p>
</li>
<li> <p><a href="#method-coreCollection-clone"><code>.CoreCollectionClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-coreCollection-recompute"></a>



<h4>Method <code>recompute()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$recompute()</pre></div>


<hr>
<a id="method-coreCollection-alternativeCore"></a>



<h4>Method <code>alternativeCore()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$alternativeCore(n)</pre></div>


<hr>
<a id="method-coreCollection-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$new(
  distanceMatrix,
  n,
  preselected,
  coreSelectMethod,
  adjustedGroupMethod,
  algorithm,
  seed
)</pre></div>


<hr>
<a id="method-coreCollection-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$print(...)</pre></div>


<hr>
<a id="method-coreCollection-summary"></a>



<h4>Method <code>summary()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$summary(...)</pre></div>


<hr>
<a id="method-coreCollection-measure"></a>



<h4>Method <code>measure()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$measure(coreSelectMethod)</pre></div>


<hr>
<a id="method-coreCollection-measures"></a>



<h4>Method <code>measures()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$measures(...)</pre></div>


<hr>
<a id="method-coreCollection-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>.CoreCollectionClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='computeAdjustedSelectionUsingRecomputeMethod'>Compute selection - recompute method</h2><span id='topic+computeAdjustedSelectionUsingRecomputeMethod'></span>

<h3>Description</h3>

<p>The function <code>computeAdjustedSelectionUsingRecomputeMethod</code> is used internally by
the <code><a href="#topic+CoreCollection">CoreCollection</a></code> object to compute an adjusted selection using the recompute
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAdjustedSelectionUsingRecomputeMethod(dist, adjustedSelected)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeAdjustedSelectionUsingRecomputeMethod_+3A_dist">dist</code></td>
<td>
<p>distance matrix, used for distances and implicitly defining the set of entries</p>
</td></tr>
<tr><td><code id="computeAdjustedSelectionUsingRecomputeMethod_+3A_adjustedselected">adjustedSelected</code></td>
<td>
<p>the selected entries defined as a list of zero-based integers referring to the row/columns of <code>dist</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list describing for each of the row/columns entries of <code>dist</code> the
closest selected entry. The entries are implicetly defined by the row/columns of
<code>dist</code> and referred to by a zero-based integer describing the position.
</p>

<hr>
<h2 id='computeAdjustedSelectionUsingSplitMethod'>Compute selection - split method</h2><span id='topic+computeAdjustedSelectionUsingSplitMethod'></span>

<h3>Description</h3>

<p>The function <code>computeAdjustedSelectionUsingSplitMethod</code> is used internally by
the <code><a href="#topic+CoreCollection">CoreCollection</a></code> object to compute an adjusted selection using the split
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAdjustedSelectionUsingSplitMethod(dist, groups, preselected)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeAdjustedSelectionUsingSplitMethod_+3A_dist">dist</code></td>
<td>
<p>distance matrix, used for distances and implicitly defining the set of entries</p>
</td></tr>
<tr><td><code id="computeAdjustedSelectionUsingSplitMethod_+3A_groups">groups</code></td>
<td>
<p>the initial division into group defined as a list of zero-based integers referring to the row/columns of <code>dist</code></p>
</td></tr>
<tr><td><code id="computeAdjustedSelectionUsingSplitMethod_+3A_preselected">preselected</code></td>
<td>
<p>the set of preselected entries</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list describing for each of the row/columns entries of <code>dist</code> the
corresponding entry referred to in <code>groups</code>. However, groups with one or multiple
<code>preselected</code> entries are divided, and the returned list wil contain references to
the closest preselected entry within this group, implying a split if multiple preselected
entries occur within one group. The entries are implicetly defined by the row/columns of
<code>dist</code> and referred to by a zero-based integer describing the position.
</p>

<hr>
<h2 id='computeCore'>Compute the core</h2><span id='topic+computeCore'></span>

<h3>Description</h3>

<p>The function <code>computeCore</code> is used internally by
the <code><a href="#topic+CoreCollection">CoreCollection</a></code> object to compute the core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCore(algorithm, method, dist, groups)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeCore_+3A_algorithm">algorithm</code></td>
<td>
<p>applied algorithm to find solution with method: currently, only <code>randomDescent</code> is available</p>
</td></tr>
<tr><td><code id="computeCore_+3A_method">method</code></td>
<td>
<p>required method for choosing the entries within the groups: <code>A-NE</code> (accession nearest entry), <code>E-NE</code> (entry nearest entry) or <code>E-E</code> (entry entry)</p>
</td></tr>
<tr><td><code id="computeCore_+3A_dist">dist</code></td>
<td>
<p>distance matrix, used for distances and implicitly defining the set of entries</p>
</td></tr>
<tr><td><code id="computeCore_+3A_groups">groups</code></td>
<td>
<p>the initially created subdivision into groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>A-NE</code> method requires the core to minimize the average distance between each accession and
the nearest entry within the core. The <code>E-NE</code> method requires the core to maximize the
average distance between each core entry and its nearest neighbouring entry within the core.
The <code>E-E</code> method requires the core to maximize the average distance between all core entries.
</p>

<hr>
<h2 id='computeRandomSelection'>Compute a random selection</h2><span id='topic+computeRandomSelection'></span>

<h3>Description</h3>

<p>The function <code>computeRandomSelection</code> is used internally by
the <code><a href="#topic+CoreCollection">CoreCollection</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeRandomSelection(dist, requiredN, preselected, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeRandomSelection_+3A_dist">dist</code></td>
<td>
<p>distance matrix, used for distances and implicitly defining the set of entries</p>
</td></tr>
<tr><td><code id="computeRandomSelection_+3A_requiredn">requiredN</code></td>
<td>
<p>the required size of the random selection</p>
</td></tr>
<tr><td><code id="computeRandomSelection_+3A_preselected">preselected</code></td>
<td>
<p>a list of preselected entries, referring to the row/column of <code>dist</code></p>
</td></tr>
<tr><td><code id="computeRandomSelection_+3A_seed">seed</code></td>
<td>
<p>the applied seed for the randomizer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a random selection of approximately size
<code>requiredN</code> by choosing entries sequentually and randomly, while excluding all entries
within a certain radius of an entry chosen before, and by finding iteratively the most
appropiate radius to end up with a number close to <code>requiredN</code> of selected entries.
</p>

<hr>
<h2 id='CoreCollection'>The CoreCollection class</h2><span id='topic+CoreCollection'></span>

<h3>Description</h3>

<p>R6 class for creating a core collection based on the provided <code>distanceMatrix</code>,
required size of the core <code>n</code> and optionally a set of <code>preselected</code> accessions to be included
into the core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoreCollection(
  distanceMatrix,
  n,
  preselected = c(),
  coreSelectMethod = "A-NE",
  adjustedGroupMethod = "split",
  algorithm = "randomDescent",
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CoreCollection_+3A_distancematrix">distanceMatrix</code></td>
<td>
<p>A distance matrix; can be either a <a href="base.html#topic+matrix">matrix</a> or a <a href="stats.html#topic+dist">dist</a></p>
</td></tr>
<tr><td><code id="CoreCollection_+3A_n">n</code></td>
<td>
<p>The number of items in the core</p>
</td></tr>
<tr><td><code id="CoreCollection_+3A_preselected">preselected</code></td>
<td>
<p>An optional list of preselected accessions to be included in the core collection;
the provided accessions should occur in the labels or rownames of the provided distanceMatrix</p>
</td></tr>
<tr><td><code id="CoreCollection_+3A_coreselectmethod">coreSelectMethod</code></td>
<td>
<p>The method for <a href="#topic+computeCore">computing</a> core accessions within the groups:
<code>A-NE</code> (accession nearest entry), <code>E-NE</code> (entry nearest entry) or <code>E-E</code> (entry entry)</p>
</td></tr>
<tr><td><code id="CoreCollection_+3A_adjustedgroupmethod">adjustedGroupMethod</code></td>
<td>
<p>The method to handle adjusting groups when multiple preselected accessions occur within a single group:
<code>split</code> to just split the initial groups with multiple accessions or <code>recompute</code> to recompute the division of
accessions over the groups.</p>
</td></tr>
<tr><td><code id="CoreCollection_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm applied to <a href="#topic+computeCore">compute</a> a solution: currently, only <code>randomDescent</code> is available</p>
</td></tr>
<tr><td><code id="CoreCollection_+3A_seed">seed</code></td>
<td>
<p>The seed used when generating the core collection. If no seed is provided, a random
seed is chosen and each time the <code>recompute()</code> method is called on the object, a new seed will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a provided <code>distanceMatrix</code> and required number <code>n</code> of accessions
within the core, a random set of accessions is created, implicitly dividing the full
population into initial groups based on the nearest randomly chosen random accession. If a
set of <code>preselected</code> accessions is provided, this initial division is adjusted using the
<code>adjustedGroupMethod</code>. Then, using the <code>coreSelectMethod</code> in the <code>algorithm</code>, the
core accessions within these groups are calculated, resulting in the final core collection.
</p>


<h3>Fields</h3>


<dl>
<dt><code>adjustedBasedGroups</code></dt><dd><p>A list describing the initial random division of all accessions into groups, adjusted for the
set of <code>preselected</code> accessions by using the defined <code>adjustedGroupMethod</code>.</p>
</dd>
<dt><code>adjustedGroupMethod</code></dt><dd><p>The method to handle adjusting groups when multiple preselected accessions occur within a single group.</p>
</dd>
<dt><code>adjustedSelected</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> representing the intial random selection of accesions, adjusted for the
set of <code>preselected</code> accessions by using the defined <code>adjustedGroupMethod</code>, with the accession names as labels and the following columns: </p>

<ul>
<li> <p><code>contains</code>: the (positive) number of accessions that have this accessions as the closest random selected accession
</p>
</li>
<li> <p><code>preselects</code>: the number of these closest accessions that were preselected
</p>
</li>
<li> <p><code>preselected</code>: a boolean indicating if the random selected accession was preselected
</p>
</li>
<li> <p><code>random</code>: a boolean indiciating if the selected accesion was initially randomly chosen or introduced later by the applied <code>adjustedGroupMethod</code>.
</p>
</li></ul>
</dd>
<dt><code>algorithm</code></dt><dd><p>The applied algorithm to compute the solution.</p>
</dd>
<dt><code>core</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> representing the core collection with the accession names as labels and in the first and only column a boolean value indicating whether or not the accession was preselected.</p>
</dd>
<dt><code>coreSelectMethod</code></dt><dd><p>The applied method to select the core accessions based on the computed <code>adjustedBasedGroups</code>.</p>
</dd>
<dt><code>distanceMatrix</code></dt><dd><p>The distance matrix; this will allways be a <a href="stats.html#topic+dist">dist</a> object.</p>
</dd>
<dt><code>n</code></dt><dd><p>The required core size</p>
</dd>
<dt><code>pop</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> representing the whole collection with the accession names as labels and in the first and only column:</p>

<ul>
<li> <p><code>result</code>: a string describing if the accession is marked as <code>other</code> or as included in the <code>core</code>, and if in the <code>core</code> because it was <code>preselected</code> or because of the applied <code>coreSelectMethod</code>.
</p>
</li></ul>
</dd>
<dt><code>preselected</code></dt><dd><p>The list of preselected accessions.</p>
</dd>
<dt><code>randomBasedGroups</code></dt><dd><p>A list with the initial division into groups based on the initial random selection of accessions described by <code>randomSelected</code>. Each item describes all accessions that have the random selected accesion from the label as the nearest neighbour, including the random selected accession.</p>
</dd>
<dt><code>randomSelected</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> representing the intial random selection of accesions with the accession names as labels and the following columns: </p>

<ul>
<li> <p><code>contains</code>: the (positive) number of accessions that have this accessions as the closest random selected accession
</p>
</li>
<li> <p><code>preselects</code>: the number of these closest accessions that were preselected
</p>
</li>
<li> <p><code>preselected</code>: a boolean indicating if the random selected accession was preselected
</p>
</li>
<li> <p><code>random</code>: a boolean indiciating if the random selected accesion was randomly chosen. This will always be TRUE for this field, but including this column makes the output comparable with <code>adjustedSelected</code>.
</p>
</li></ul>
</dd>
<dt><code>seed</code></dt><dd><p>The last applied seed for the randomizer. This will only change when the <code>recompute()</code> method
is called and no initial <code>seed</code> is defined.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>alternativeCore(n)</code></dt><dd><p>The <code>n</code>th alternative core with <code>n</code> a positive integer. Provides for each accession in the core, if available, the <code>n</code>th nearest accession from within the same group as an alternative.</p>
</dd>
<dt><code>clone(deep = FALSE)</code></dt><dd><p>The default R6Class clone method.</p>
</dd>
<dt><code>initialize(distanceMatrix, n, preselected, coreSelectMethod, adjustedGroupMethod, algorithm, seed)</code></dt><dd><p>Initialisation of the object, is called automatically on creation or recomputing.</p>
</dd>
<dt><code>measure(coreSelectMethod)</code></dt><dd><p>The measure for the provided <code>coreSelectMethod</code>. If no value is provided, the current selected <code>coreSelectMethod</code> is used. The measure is used by the algorithm to compute the core collection.</p>
</dd>
<dt><code>measures()</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> with the available <code>coreSelectMethods</code> as labels and in the first and only column the measures for these methods.</p>
</dd>
<dt><code>recompute()</code></dt><dd><p>Recompute the core collection: If on initialisation of the object a seed was provided, this same seed will be applied and therefore the same core collection will be created. Otherwise, a new seed is generated, resulting in a new core.</p>
</dd>
<dt><code>print()</code></dt><dd><p>Create a summary of the core collection object, same as <code>summary()</code>.</p>
</dd>
<dt><code>summary()</code></dt><dd><p>Create a summary of the core collection object, same as <code>print()</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other core collection: 
<code><a href="#topic+coreCollection-package">coreCollection-package</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
