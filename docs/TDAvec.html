<!DOCTYPE html><html lang="en"><head><title>Help for package TDAvec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDAvec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computeAlgebraicFunctions'><p>Compute Algebraic Functions from a Persistence Diagram</p></a></li>
<li><a href='#computeBettiCurve'><p>A Vector Summary of the Betti Curve</p></a></li>
<li><a href='#computeComplexPolynomial'><p>Compute Complex Polynomial Coefficients from a Persistence Diagram</p></a></li>
<li><a href='#computeEulerCharacteristic'><p>A Vector Summary of the Euler Characteristic Curve</p></a></li>
<li><a href='#computeLimits'><p>Compute the Extreme Values of Birth, Death, and Persistence Across Multiple Persistence Diagrams</p></a></li>
<li><a href='#computeNormalizedLife'><p>A Vector Summary of the Normalized Life Curve</p></a></li>
<li><a href='#computePersistenceBlock'><p>A Vector Summary of the Persistence Block</p></a></li>
<li><a href='#computePersistenceImage'><p>A Vector Summary of the Persistence Surface</p></a></li>
<li><a href='#computePersistenceLandscape'><p>Vector Summaries of the Persistence Landscape Functions</p></a></li>
<li><a href='#computePersistenceSilhouette'><p>A Vector Summary of the Persistence Silhouette Function</p></a></li>
<li><a href='#computePersistentEntropy'><p>A Vector Summary of the Persistent Entropy Summary Function</p></a></li>
<li><a href='#computeStats'><p>Compute Descriptive Statistics for Births, Deaths, Midpoints, and Lifespans in a Persistence Diagram</p></a></li>
<li><a href='#computeTemplateFunction'><p>Compute a Vectorization of a Persistence Diagram based on Tent Template Functions</p></a></li>
<li><a href='#computeTropicalCoordinates'><p>Compute Tropical Coordinates from a Persistence Diagram</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vector Summaries of Persistence Diagrams</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aleksei Luchinsky &lt;aluchi@bgsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for computing various vector summaries of persistence diagrams studied in Topological Data Analysis. For improved computational efficiency, 
    all code for the vector summaries is written in 'C++' using the 'Rcpp' and 'RcppArmadillo' packages.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, TDAstats</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/uislambekov/TDAvec">https://github.com/uislambekov/TDAvec</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/uislambekov/TDAvec/issues">https://github.com/uislambekov/TDAvec/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-15 15:27:53 UTC; alekseiluchinsky</td>
</tr>
<tr>
<td>Author:</td>
<td>Umar Islambekov [aut],
  Aleksei Luchinsky [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-15 16:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='computeAlgebraicFunctions'>Compute Algebraic Functions from a Persistence Diagram</h2><span id='topic+computeAlgebraicFunctions'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computeAlgebraicFunctions()</code> computes the following four algebraic functions based on the birth and death values:
</p>

<ul>
<li> <p><code class="reqn">f_1=\sum_i b_i (d_i - b_i).</code>
</p>
</li>
<li>  <p><code class="reqn">f_2=\sum_i (d_{\max} - d_i) (d_i - b_i)</code>, where <code class="reqn">d_{\max} = \max(d_i)</code>.
</p>
</li>
<li> <p><code class="reqn">f_3=\sum_i b_i^2 (d_i - b_i)^4</code>.
</p>
</li>
<li> <p><code class="reqn">f_4=\sum_i (d_{\max} - d_i)^2 (d_i - b_i)^4</code>.
</p>
</li></ul>

<p>Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAlgebraicFunctions(D, homDim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeAlgebraicFunctions_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeAlgebraicFunctions_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes the four algebraic functions based on the filtered data. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A (named) numeric vector <code class="reqn">(f_1,f_2,f_3,f_4)</code>.
</p>


<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Adcock, A., Carlsson, E. and Carlsson, G., 2013. The ring of algebraic functions on persistence bar codes. Homology, Homotopy Appl., 18:381â€“402, 2016.
</p>
<p>2. Ali, D., Asaad, A., Jimenez, M.J., Nanda, V., Paluzo-Hidalgo, E. and Soriano-Trigueros, M., (2023). A survey of vectorization methods in topological data analysis. IEEE Transactions on Pattern Analysis and Machine Intelligence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

# Compute algebraic functions for homological dimension H_0
computeAlgebraicFunctions(D, homDim = 0)

# Compute algebraic functions for homological dimension H_1
computeAlgebraicFunctions(D, homDim = 1)
</code></pre>

<hr>
<h2 id='computeBettiCurve'>A Vector Summary of the Betti Curve</h2><span id='topic+computeBettiCurve'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D={(b_i,d_i)}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computeBettiCurve()</code> vectorizes the Betti curve </p>
<p style="text-align: center;"><code class="reqn">\beta(t)=\sum_{i=1}^N\bold 1_{[b_i,d_i)}(t)</code>
</p>
<p> based on a scale sequence <code>scaleSeq</code>. The evaluation method depends on the argument <code>evaluate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeBettiCurve(D, homDim, scaleSeq, evaluate = "intervals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeBettiCurve_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeBettiCurve_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computeBettiCurve_+3A_scaleseq">scaleSeq</code></td>
<td>
<p>a numeric vector of increasing scale values used for vectorization.</p>
</td></tr>
<tr><td><code id="computeBettiCurve_+3A_evaluate">evaluate</code></td>
<td>
<p>a character string indicating the evaluation method. Must be either <code>"intervals"</code> (default) or <code>"points"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data and <code>scaleSeq</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A numeric vector containing elements computed using <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code> according to the method specified by <code>evaluate</code>.
</p>

<ul>
<li> <p><code>"intervals"</code>: Computes average values of the Betti curve over intervals defined by consecutive elements in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta t_1}\int_{t_1}^{t_2}\beta(t)dt,\frac{1}{\Delta t_2}\int_{t_2}^{t_3}\beta(t)dt,\ldots,\frac{1}{\Delta t_{n-1}}\int_{t_{n-1}}^{t_n}\beta(t)dt\Big)\in\mathbb{R}^{n-1},</code>
</p>

<p>where <code class="reqn">\Delta t_k=t_{k+1}-t_k</code>.
</p>
</li>
<li> <p><code>"points"</code>: Computes values of the Betti curve at each point in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">(\beta(t_1),\beta(t_2),\ldots,\beta(t_n))\in\mathbb{R}^n.</code>
</p>

</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov, Hasani Pathirana</p>


<h3>References</h3>

<p>1. Chazal, F., &amp; Michel, B. (2021). An Introduction to Topological Data Analysis: Fundamental and Practical Aspects for Data Scientists. Frontiers in Artificial Intelligence, 108.
</p>
<p>2. Chung, Y. M., &amp; Lawson, A. (2022). Persistence curves: A canonical framework for summarizing persistence diagrams. Advances in Computational Mathematics, 48(1), 1-42.
</p>
<p>3. Islambekov, U., &amp; Pathirana. H. (2024). Vector Summaries of Persistence Diagrams for Permutation-based Hypothesis Testing. Foundations of Data Science 6 (1), 41-61.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

scaleSeq = seq(0, 2, length.out = 11) # A sequence of scale values

# Compute a vector summary of the Betti curve for homological dimension H_0
computeBettiCurve(D, homDim = 0, scaleSeq)

# Compute a vector summary of the Betti curve for homological dimension H_1
computeBettiCurve(D, homDim = 1, scaleSeq)
</code></pre>

<hr>
<h2 id='computeComplexPolynomial'>Compute Complex Polynomial Coefficients from a Persistence Diagram</h2><span id='topic+computeComplexPolynomial'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computeComplexPolynomial()</code>
computes the coefficients of a complex polynomial
</p>
<p style="text-align: center;"><code class="reqn">C_X(z) = \prod_{i=1}^N [z - X(b_i,d_i)],</code>
</p>

<p>where <code class="reqn">X:\mathbb{R}^2\rightarrow\mathbb{C}</code> is any one of the following three functions:
</p>

<ul>
<li> <p><code class="reqn">R(x,y)=x+iy.</code>
</p>
</li>
<li>  <p><code class="reqn">S(x, y) =
\begin{cases}
\frac{y - x}{\alpha \sqrt{2}}(x+iy) &amp; \text{if } (x, y) \neq (0, 0) \\
0 &amp; \text{otherwise.}
\end{cases}</code>
</p>
</li>
<li> <p><code class="reqn">T(x, y) = \frac{y - x}{2} [(\cos\alpha - \sin\alpha)+i(\cos\alpha + \sin\alpha)]</code>,
</p>
</li></ul>

<p>where <code class="reqn">\alpha=\sqrt{x^2+y^2}</code>. Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeComplexPolynomial(D, homDim, m = 1, polyType = "R")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeComplexPolynomial_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeComplexPolynomial_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computeComplexPolynomial_+3A_m">m</code></td>
<td>
<p>the number of coefficients to return (default is 1). Must be less than or equal to the number of points in the diagram.</p>
</td></tr>
<tr><td><code id="computeComplexPolynomial_+3A_polytype">polyType</code></td>
<td>
<p>a string specifying the polynomial type to use. Options are &quot;R&quot; (default), &quot;S&quot;, or &quot;T&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data and <code>polyType</code>. 
If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a matrix of zeros is returned.
</p>


<h3>Value</h3>

<p>A numeric matrix of dimension <code class="reqn">m \times 2</code>. Each row corresponds to a coefficient of the polynomial <code class="reqn">C_X(z)</code>:
</p>

<ul>
<li><p> Column 1: Real part of the coefficient.
</p>
</li>
<li><p> Column 2: Imaginary part of the coefficient.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov
</p>


<h3>References</h3>

<p>1. Ferri, M. and Landi, C., (1999). Representing size functions by complex polynomials. Proc. Math. Met. in Pattern Recognition, 9, pp.16-19.
</p>
<p>2. Di Fabio, B. and Ferri, M., (2015). Comparing persistence diagrams through complex vectors. In Image Analysis and Processingâ€”ICIAP 2015:
18th International Conference, Genoa, Italy, September 7-11, 2015, Proceedings, Part I 18 (pp. 294-305). Springer International Publishing.
</p>
<p>3. Ali, D., Asaad, A., Jimenez, M.J., Nanda, V., Paluzo-Hidalgo, E. and Soriano-Trigueros, M., (2023). A survey of vectorization methods
in topological data analysis. IEEE Transactions on Pattern Analysis and Machine Intelligence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

# Compute first 5 coefficients of the complex polynomial of type "R" for dimension H_0
computeComplexPolynomial(D, homDim = 0, m = 5, polyType = "R")

# Compute the first 5 coefficients of the complex polynomial of type "S"
#  for homological dimension H_0
computeComplexPolynomial(D, homDim = 0, m = 5, polyType = "S")
</code></pre>

<hr>
<h2 id='computeEulerCharacteristic'>A Vector Summary of the Euler Characteristic Curve</h2><span id='topic+computeEulerCharacteristic'></span>

<h3>Description</h3>

<p>Vectorizes the Euler characteristic curve </p>
<p style="text-align: center;"><code class="reqn">\chi(t)=\sum_{k=0}^d (-1)^k\beta_k(t),</code>
</p>
<p> where <code class="reqn">\beta_0,\beta_1,\ldots,\beta_d</code> are the Betti curves corresponding to persistence diagrams <code class="reqn">D_0,D_1,\ldots,D_d</code> of dimensions <code class="reqn">0,1,\ldots,d</code> respectively, all computed from the same filtration. The evaluation method depends on the argument <code>evaluate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeEulerCharacteristic(D, scaleSeq, maxhomDim = -1, evaluate = "intervals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeEulerCharacteristic_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeEulerCharacteristic_+3A_scaleseq">scaleSeq</code></td>
<td>
<p>a numeric vector of increasing scale values used for vectorization.</p>
</td></tr>
<tr><td><code id="computeEulerCharacteristic_+3A_maxhomdim">maxhomDim</code></td>
<td>
<p>the maximum homological dimension considered (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). If set to -1 (default), it uses the maximum dimension found in <code>D</code>.</p>
</td></tr>
<tr><td><code id="computeEulerCharacteristic_+3A_evaluate">evaluate</code></td>
<td>
<p>a character string indicating the evaluation method. Must be either <code>"intervals"</code> (default) or <code>"points"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing elements computed using <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code> according to the method specified by <code>evaluate</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>

<ul>
<li> <p><code>"intervals"</code>: Computes average values of the Euler characteristic curve over intervals defined by consecutive elements in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta t_1}\int_{t_1}^{t_2}\chi(t)dt,\frac{1}{\Delta t_2}\int_{t_2}^{t_3}\chi(t)dt,\ldots,\frac{1}{\Delta t_{n-1}}\int_{t_{n-1}}^{t_n}\chi(t)dt\Big)\in\mathbb{R}^{n-1},</code>
</p>

<p>where <code class="reqn">\Delta t_k=t_{k+1}-t_k</code>.
</p>
</li>
<li> <p><code>"points"</code>: Computes values of the Euler characteristic curve at each point in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">(\chi(t_1),\chi(t_2),\ldots,\chi(t_n))\in\mathbb{R}^n.</code>
</p>

</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Richardson, E., &amp; Werman, M. (2014). Efficient classification using the Euler characteristic. Pattern Recognition Letters, 49, 99-106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

scaleSeq = seq(0, 2, length.out = 11) # A sequence of scale values

# Compute a vector summary of the Euler characteristic curve
computeEulerCharacteristic(D, scaleSeq)
</code></pre>

<hr>
<h2 id='computeLimits'>Compute the Extreme Values of Birth, Death, and Persistence Across Multiple Persistence Diagrams</h2><span id='topic+computeLimits'></span>

<h3>Description</h3>

<p>Given a list of persistence diagrams, <code>computeLimits()</code> computes the extreme values of birth, death, and persistence across all diagrams for a specified homological dimension. Points with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeLimits(Dlist, homDim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeLimits_+3A_dlist">Dlist</code></td>
<td>
<p>a list of persistence diagrams, where each diagram is a matrix containing three columns representing homological dimension, birth, and death values.</p>
</td></tr>
<tr><td><code id="computeLimits_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows of the diagrams are filtered based on this value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (named) numeric vector containing:
</p>

<ul>
<li> <p><code>minB</code>: the minimum birth value across all diagrams.
</p>
</li>
<li> <p><code>maxB</code>: the maximum birth value across all diagrams.
</p>
</li>
<li> <p><code>maxD</code>: the maximum death value across all diagrams.
</p>
</li>
<li> <p><code>minP</code>: the minimum persistence value across all diagrams.
</p>
</li>
<li> <p><code>maxP</code>: the maximum persistence value across all diagrams.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
N &lt;- 100 # The size of point clouds
nD &lt;- 50 # The number of persistence diagrams
Dlist &lt;- list()
for (i in 1:nD){
  # sample N points uniformly from the unit circle and add Gaussian noise
  theta &lt;- runif(N, min = 0, max = 2 * pi)
  X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

  # Compute the persistence diagram using the Rips filtration built on top of X
  # The 'threshold' parameter specifies the maximum distance for building simplices
  Dlist[[i]] &lt;- TDAstats::calculate_homology(X, threshold = 2)
}

# Compute the extreme values of birth, death, and persistence across 
# all 50 diagrams for homological dimension H_0
computeLimits(Dlist, homDim = 0)

# Compute the extreme values of birth, death, and persistence across 
# all 50 diagrams for homological dimension H_1
computeLimits(Dlist, homDim = 1)
</code></pre>

<hr>
<h2 id='computeNormalizedLife'>A Vector Summary of the Normalized Life Curve</h2><span id='topic+computeNormalizedLife'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computeNormalizedLife()</code> vectorizes the normalized life curve
</p>
<p style="text-align: center;"><code class="reqn">sl(t)=\sum_{i=1}^N \frac{d_i-b_i}{L}\bold{1}_{[b_i,d_i)}(t),</code>
</p>

<p>where <code class="reqn">L=\sum_{i=1}^N (d_i-b_i)</code>, based on a scale sequence <code>scaleSeq</code>. The evaluation method depends on the argument <code>evaluate</code>. Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeNormalizedLife(D, homDim, scaleSeq, evaluate = "intervals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeNormalizedLife_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeNormalizedLife_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computeNormalizedLife_+3A_scaleseq">scaleSeq</code></td>
<td>
<p>a numeric vector of increasing scale values used for vectorization.</p>
</td></tr>
<tr><td><code id="computeNormalizedLife_+3A_evaluate">evaluate</code></td>
<td>
<p>a character string indicating the evaluation method. Must be either <code>"intervals"</code> (default) or <code>"points"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data and <code>scaleSeq</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A numeric vector containing elements computed using <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code> according to the method specified by <code>evaluate</code>.
</p>

<ul>
<li> <p><code>"intervals"</code>: Computes average values of the normalized life curve over intervals defined by consecutive elements in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta t_1}\int_{t_1}^{t_2}sl(t)dt,\frac{1}{\Delta t_2}\int_{t_2}^{t_3}sl(t)dt,\ldots,\frac{1}{\Delta t_{n-1}}\int_{t_{n-1}}^{t_n}sl(t)dt\Big)\in\mathbb{R}^{n-1},</code>
</p>

<p>where <code class="reqn">\Delta t_k=t_{k+1}-t_k</code>.
</p>
</li>
<li> <p><code>"points"</code>: Computes values of the normalized life curve at each point in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">(sl(t_1),sl(t_2),\ldots,sl(t_n))\in\mathbb{R}^n.</code>
</p>

</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>Chung, Y. M., &amp; Lawson, A. (2022). Persistence curves: A canonical framework for summarizing persistence diagrams. Advances in Computational Mathematics, 48(1), 1-42.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

scaleSeq = seq(0, 2, length.out = 11) # A sequence of scale values

# Compute a vector summary of the normalized life curve for homological dimension H_0
computeNormalizedLife(D, homDim = 0, scaleSeq)

# Compute a vector summary of the normalized life curve for homological dimension H_1
computeNormalizedLife(D, homDim = 1, scaleSeq)
</code></pre>

<hr>
<h2 id='computePersistenceBlock'>A Vector Summary of the Persistence Block</h2><span id='topic+computePersistenceBlock'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,p_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computePersistenceBlock()</code> vectorizes the persistence block </p>
<p style="text-align: center;"><code class="reqn">f(x,y)=\sum_{i=1}^N \bold 1_{E(b_i,p_i)}(x,y),</code>
</p>
<p> where <code class="reqn">E(b_i,p_i)=[b_i-\frac{\lambda_i}{2},b_i+\frac{\lambda_i}{2}]\times [p_i-\frac{\lambda_i}{2},p_i+\frac{\lambda_i}{2}]</code> and <code class="reqn">\lambda_i=2\tau p_i</code> with <code class="reqn">\tau\in (0,1]</code>. Points in <code class="reqn">D</code> with infinite persistence values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePersistenceBlock(D, homDim, xSeq, ySeq, tau=0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePersistenceBlock_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, <em>birth</em> and <em>persistence</em> values respectively.</p>
</td></tr>
<tr><td><code id="computePersistenceBlock_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computePersistenceBlock_+3A_xseq">xSeq</code></td>
<td>
<p>a numeric vector of increasing x (birth) values used for vectorization.</p>
</td></tr>
<tr><td><code id="computePersistenceBlock_+3A_yseq">ySeq</code></td>
<td>
<p>a numeric vector of increasing y (persistence) values used for vectorization.</p>
</td></tr>
<tr><td><code id="computePersistenceBlock_+3A_tau">tau</code></td>
<td>
<p>a parameter (between 0 and 1) controlling block sizes. Default is <code>tau=0.3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data, <code>xSeq</code> and <code>ySeq</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A numeric vector whose elements are the weighted averages of the persistence block computed over each cell of the two-dimensional grid constructred from <code>xSeq</code>=<code class="reqn">\{x_1,x_2,\ldots,x_n\}</code> and <code>ySeq</code>=<code class="reqn">\{y_1,y_2,\ldots,y_m\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta x_1\Delta y_1}\int_{[x_1,x_2]\times [y_1,y_2]}f(x,y)wdA,\ldots,\frac{1}{\Delta x_{n-1}\Delta y_{m-1}}\int_{[x_{n-1},x_n]\times [y_{m-1},y_m]}f(x,y)wdA\Big)\in\mathbb{R}^{d},</code>
</p>

<p>where <code class="reqn">d=(n-1)(m-1)</code>, <code class="reqn">wdA=(x+y)dxdy</code>, <code class="reqn">\Delta x_k=x_{k+1}-x_k</code> and <code class="reqn">\Delta y_j=y_{j+1}-y_j.</code>
</p>
<p>If <code>homDim=0</code> and all the birth values are equal (e.g., zero), univariate persistence block functions are used instead for vectorization:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta y_1}\int_{y_1}^{y_2}f(y)ydy,\ldots,\frac{1}{\Delta y_{m-1}}\int_{y_{m-1}}^{y_m}f(y)ydy\Big)\in\mathbb{R}^{m-1},</code>
</p>

<p>where <code class="reqn">f(y)=\sum_{i=1}^N \bold 1_{[p_i-\frac{\lambda_i}{2},p_i+\frac{\lambda_i}{2}]}(y)</code> and <code class="reqn">\Delta y_j=y_{j+1}-y_j.</code>
</p>


<h3>Author(s)</h3>

<p>Umar Islambekov, Aleksei Luchinsky</p>


<h3>References</h3>

<p>1. Chan, K. C., Islambekov, U., Luchinsky, A., &amp; Sanders, R. (2022). A computationally efficient framework for vector representation of persistence diagrams. Journal of Machine Learning Research 23, 1-33.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample
set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

# Switch from the birth-death to the birth-persistence coordinates
D[,3] &lt;- D[,3] - D[,2]
colnames(D)[3] &lt;- "Persistence"

# Construct one-dimensional grid of scale values
ySeqH0 &lt;- unique(quantile(D[D[,1] == 0, 3], probs = seq(0, 1, by = 0.2)))
tau &lt;- 0.3 # Parameter in [0,1] which controls the size of blocks around each point of the diagram

# Compute a vector summary of the persistence block for homological dimension H_0
computePersistenceBlock(D, homDim = 0, xSeq = NA, ySeq = ySeqH0, tau = tau)

xSeqH1 &lt;- unique(quantile(D[D[,1] == 1, 2], probs = seq(0, 1, by = 0.2)))
ySeqH1 &lt;- unique(quantile(D[D[,1] == 1, 3], probs = seq(0, 1, by = 0.2)))

# Compute a vector summary of the persistence block for homological dimension H_1
computePersistenceBlock(D, homDim = 1, xSeq = xSeqH1, ySeq = ySeqH1, tau = tau)

</code></pre>

<hr>
<h2 id='computePersistenceImage'>A Vector Summary of the Persistence Surface</h2><span id='topic+computePersistenceImage'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,p_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computePersistenceImage()</code> computes the persistence image - a vector summary of the persistence surface: </p>
<p style="text-align: center;"><code class="reqn">\rho(x,y)=\sum_{i=1}^N f(b_i,p_i)\phi_{(b_i,p_i)}(x,y),</code>
</p>
<p> where <code class="reqn">\phi_{(b_i,p_i)}(x,y)</code> is
the Gaussian distribution with mean <code class="reqn">(b_i,p_i)</code> and
covariance matrix <code class="reqn">\sigma^2 I_{2\times 2}</code> and
</p>
<p style="text-align: center;"><code class="reqn">f(b,p) = w(p)=\left\{
        \begin{array}{ll}
            0 &amp; \quad p\leq 0 \\
            p/p_{max} &amp; \quad 0&lt;p&lt;p_{max}\\
            1&amp; \quad p\geq p_{max}
        \end{array}
    \right.</code>
</p>

<p>is the weighting function with <code class="reqn">p_{max}</code> being the maximum persistence value among all persistence diagrams considered in the experiment. Points in <code class="reqn">D</code> with infinite persistence values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePersistenceImage(D, homDim, xSeq, ySeq, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePersistenceImage_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, <em>birth</em> and <em>persistence</em> values respectively.</p>
</td></tr>
<tr><td><code id="computePersistenceImage_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computePersistenceImage_+3A_xseq">xSeq</code></td>
<td>
<p>a numeric vector of increasing x (birth) values used for vectorization.</p>
</td></tr>
<tr><td><code id="computePersistenceImage_+3A_yseq">ySeq</code></td>
<td>
<p>a numeric vector of increasing y (persistence) values used for vectorization.</p>
</td></tr>
<tr><td><code id="computePersistenceImage_+3A_sigma">sigma</code></td>
<td>
<p>a standard deviation (<code class="reqn">\sigma</code>) of the Gaussian.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data, <code>xSeq</code> and <code>ySeq</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A numeric vector whose elements are the average values of the persistence surface computed over each cell of the two-dimensional grid constructred from <code>xSeq</code>=<code class="reqn">\{x_1,x_2,\ldots,x_n\}</code> and <code>ySeq</code>=<code class="reqn">\{y_1,y_2,\ldots,y_m\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta x_1\Delta y_1}\int_{[x_1,x_2]\times [y_1,y_2]}\rho(x,y)dA,\ldots,\frac{1}{\Delta x_{n-1}\Delta y_{m-1}}\int_{[x_{n-1},x_n]\times [y_{m-1},y_m]}\rho(x,y)dA\Big)\in\mathbb{R}^{d},</code>
</p>

<p>where <code class="reqn">d=(n-1)(m-1)</code>, <code class="reqn">dA=dxdy</code>, <code class="reqn">\Delta x_k=x_{k+1}-x_k</code> and <code class="reqn">\Delta y_j=y_{j+1}-y_j.</code>
</p>
<p>If <code>homDim=0</code> and all the birth values are equal (e.g., zero), univariate Gaussians are used instead for vectorization:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta y_1}\int_{y_1}^{y_2}\rho(y)dy,\ldots,\frac{1}{\Delta y_{m-1}}\int_{y_{m-1}}^{y_m}\rho(y)dy\Big)\in\mathbb{R}^{m-1},</code>
</p>

<p>where <code class="reqn">\rho(y)=\sum_{i=1}^N f(p_i)\phi_{p_i}(y)</code> and <code class="reqn">\Delta y_j=y_{j+1}-y_j.</code>
</p>


<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Adams, H., Emerson, T., Kirby, M., Neville, R., Peterson, C., Shipman, P., ... &amp; Ziegelmeier, L. (2017). Persistence images: A stable vector representation of persistent homology. Journal of Machine Learning Research, 18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample
set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

# Switch from the birth-death to the birth-persistence coordinates
D[,3] &lt;- D[,3] - D[,2]
colnames(D)[3] &lt;- "Persistence"

resB &lt;- 5 # Resolution (or grid size) along the birth axis
resP &lt;- 5 # Resolution (or grid size) along the persistence axis

# Compute persistence image for homological dimension H_0
minPH0 &lt;- min(D[D[,1]==0,3]); maxPH0 &lt;- max(D[D[,1]==0,3])
ySeqH0 &lt;- seq(minPH0, maxPH0, length.out = resP + 1)
sigma &lt;- 0.5 * (maxPH0 - minPH0) / resP
computePersistenceImage(D, homDim = 0, xSeq = NA, ySeq = ySeqH0, sigma = sigma)

# Compute persistence image for homological dimension H_1
minBH1 &lt;- min(D[D[,1]==1,2]); maxBH1 &lt;- max(D[D[,1]==1,2])
minPH1 &lt;- min(D[D[,1]==1,3]); maxPH1 &lt;- max(D[D[,1]==1,3])
xSeqH1 &lt;- seq(minBH1, maxBH1, length.out = resB + 1)
ySeqH1 &lt;- seq(minPH1, maxPH1, length.out = resP + 1)
sigma &lt;- 0.5 * (maxPH1 - minPH1) / resP
computePersistenceImage(D, homDim = 1, xSeq = xSeqH1, ySeq = ySeqH1, sigma = sigma)

</code></pre>

<hr>
<h2 id='computePersistenceLandscape'>Vector Summaries of the Persistence Landscape Functions</h2><span id='topic+computePersistenceLandscape'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension),
<code>computePersistenceLandscape()</code> vectorizes the first <code class="reqn">k</code> persistence landscape functions
</p>
<p style="text-align: center;"><code class="reqn">\lambda_j(t) = j\hbox{max}_{1\leq i \leq N} \Lambda_i(t), \quad j=1,\dots,k,</code>
</p>

<p>where <code class="reqn">j\hbox{max}</code> returns the <code class="reqn">j</code>th largest value and
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_i(t) = \left\{
        \begin{array}{ll}
            t-b_i &amp; \quad t\in [b_i,\frac{b_i+d_i}{2}] \\
            d_i-t &amp; \quad t\in (\frac{b_i+d_i}{2},d_i]\\
            0 &amp; \quad \hbox{otherwise}
        \end{array}
    \right.</code>
</p>

<p>based on a scale sequence <code>scaleSeq</code>. For <em>generalized</em> persistence landscape functions, we instead take
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_i(t) = \left\{
        \begin{array}{ll}
            \frac{d_i-b_i}{2K_h(0)}K_h(t-\frac{b_i+d_i}{2}) &amp; \hbox{for } |\frac{t-\frac{b_i+d_i}{2}}{h}| \leq 1 \\
            0 &amp; \hbox{otherwise}
        \end{array}
    \right.</code>
</p>

<p>where <code class="reqn">K_h(\cdot)</code> is a kernel function with the bandwidth parameter <code class="reqn">h.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePersistenceLandscape(D, homDim, scaleSeq, k = 1, generalized = FALSE, 
  kernel = "triangle", h = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePersistenceLandscape_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computePersistenceLandscape_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computePersistenceLandscape_+3A_scaleseq">scaleSeq</code></td>
<td>
<p>a numeric vector of increasing scale values used for vectorization.</p>
</td></tr>
<tr><td><code id="computePersistenceLandscape_+3A_k">k</code></td>
<td>
<p>an integer specifying the number of persistence landscape functions to consider (default is 1).  Must be less than or equal to the number of points in the diagram.</p>
</td></tr>
<tr><td><code id="computePersistenceLandscape_+3A_generalized">generalized</code></td>
<td>
<p>a logical value indicating whether to use a generalized persistence landscape or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="computePersistenceLandscape_+3A_kernel">kernel</code></td>
<td>
<p>a string specifying the kernel type to use if <code>generalized = TRUE</code>. Options are &quot;triangle&quot;, &quot;epanechnikov&quot;, or &quot;tricubic&quot;. Default is &quot;triangle&quot;.</p>
</td></tr>
<tr><td><code id="computePersistenceLandscape_+3A_h">h</code></td>
<td>
<p>a positive numeric value specifying the bandwidth for the kernel. Must be provided if  <code>generalized = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data and <code>scaleSeq</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned. If <code>generalized = TRUE</code>, three different kernel functions are currently supported:
</p>

<ul>
<li><p> Triangle kernel: <code class="reqn">K_h(t) = \frac{1}{h} \max(0, 1 - \frac{|t|}{h})</code>
</p>
</li>
<li><p> Epanechnikov kernel: <code class="reqn">K_h(t) = \frac{3}{4h} \max(0, 1 - \frac{t^2}{h^2})</code>
</p>
</li>
<li><p> Tricubic kernel: <code class="reqn">K_h(t) = \frac{70}{81h} \max(0, (1 - \frac{|t|^3}{h^3})^3)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix where the <code class="reqn">j</code>th column contains the values of the <code class="reqn">j</code>th order persistence landscape function evaluated at each point of <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\begin{bmatrix}
\lambda_1(t_1) &amp; \lambda_2(t_1) &amp;  \cdots &amp; \lambda_k(t_1) \\
\lambda_1(t_2) &amp; \lambda_2(t_2) &amp; \cdots &amp; \lambda_k(t_2)\\
\vdots &amp; \vdots&amp; \ddots &amp; \vdots \\
\lambda_1(t_n) &amp; \lambda_2(t_n) &amp; \cdots &amp; \lambda_k(t_n)
\end{bmatrix}
</code>
</p>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Bubenik, P. (2015). Statistical topological data analysis using persistence landscapes. Journal of Machine Learning Research, 16(1), 77-102.
</p>
<p>2. Chazal, F., Fasy, B. T., Lecci, F., Rinaldo, A., &amp; Wasserman, L. (2014, June). Stochastic convergence of persistence landscapes and silhouettes. In Proceedings of the thirtieth annual symposium on Computational geometry (pp. 474-483).
</p>
<p>3. Berry, E., Chen, Y. C., Cisewski-Kehe, J., &amp; Fasy, B. T. (2020). Functional summaries of persistence diagrams. Journal of Applied and Computational Topology, 4(2):211â€“262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

scaleSeq = seq(0, 2, length.out = 11) # A sequence of scale values

# Compute vector summaries of the first three persistence landscape functions 
#  for homological dimension H_1
computePersistenceLandscape(D, homDim = 1, scaleSeq, k = 3)

# Compute vector summaries of the first three generalized persistence landscape 
#  functions (with triangle kernel and bandwidth h=0.2) for homological dimension H_1
computePersistenceLandscape(D, homDim = 1, scaleSeq, generalized = TRUE, k = 3, h = 0.2)

</code></pre>

<hr>
<h2 id='computePersistenceSilhouette'>A Vector Summary of the Persistence Silhouette Function</h2><span id='topic+computePersistenceSilhouette'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computePersistenceSilhouette()</code> vectorizes the <code class="reqn">p</code>th power persistence silhouette function
</p>
<p style="text-align: center;"><code class="reqn">\phi_p(t) = \frac{\sum_{i=1}^N |d_i-b_i|^p\Lambda_i(t)}{\sum_{i=1}^N |d_i-b_i|^p},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_i(t) = \left\{
        \begin{array}{ll}
            t-b_i &amp; \quad t\in [b_i,\frac{b_i+d_i}{2}] \\
            d_i-t &amp; \quad t\in (\frac{b_i+d_i}{2},d_i]\\
            0 &amp; \quad \hbox{otherwise}
        \end{array}
    \right.</code>
</p>

<p>based on a scale sequence <code>scaleSeq</code>. The evaluation method depends on the argument <code>evaluate</code>. Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePersistenceSilhouette(D, homDim, scaleSeq, p = 1.0, evaluate = "intervals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePersistenceSilhouette_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computePersistenceSilhouette_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computePersistenceSilhouette_+3A_scaleseq">scaleSeq</code></td>
<td>
<p>a numeric vector of increasing scale values used for vectorization.</p>
</td></tr>
<tr><td><code id="computePersistenceSilhouette_+3A_p">p</code></td>
<td>
<p>power of the weights for the silhouette function. By default, <code>p=1.</code></p>
</td></tr>
<tr><td><code id="computePersistenceSilhouette_+3A_evaluate">evaluate</code></td>
<td>
<p>a character string indicating the evaluation method. Must be either <code>"intervals"</code> (default) or <code>"points"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data and <code>scaleSeq</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A numeric vector containing elements computed using <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code> according to the method specified by <code>evaluate</code>.
</p>

<ul>
<li> <p><code>"intervals"</code>: Computes average values of the persistence silhouette function over intervals defined by consecutive elements in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta t_1}\int_{t_1}^{t_2}\phi_p(t)dt,\frac{1}{\Delta t_2}\int_{t_2}^{t_3}\phi_p(t)dt,\ldots,\frac{1}{\Delta t_{n-1}}\int_{t_{n-1}}^{t_n}\phi_p(t)dt\Big)\in\mathbb{R}^{n-1},</code>
</p>

<p>where <code class="reqn">\Delta t_k=t_{k+1}-t_k</code>.
</p>
</li>
<li> <p><code>"points"</code>: Computes values of the persistence silhouette function at each point in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">(\phi_p(t_1),\phi_p(t_2),\ldots,\phi_p(t_n))\in\mathbb{R}^n.</code>
</p>

</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Chazal, F., Fasy, B. T., Lecci, F., Rinaldo, A., &amp; Wasserman, L. (2014). Stochastic convergence of persistence landscapes and silhouettes. In Proceedings of the thirtieth annual symposium on Computational geometry (pp. 474-483).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

scaleSeq = seq(0, 2, length.out = 11) # A sequence of scale values

# Compute a vector summary of the persistence silhouette (with p=1) for homological dimension H_0
computePersistenceSilhouette(D, homDim = 0, scaleSeq)

# Compute a vector summary of the persistence silhouette (with p=1) for homological dimension H_1
computePersistenceSilhouette(D, homDim = 1, scaleSeq)
</code></pre>

<hr>
<h2 id='computePersistentEntropy'>A Vector Summary of the Persistent Entropy Summary Function</h2><span id='topic+computePersistentEntropy'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D={(b_i,d_i)}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computePersistentEntropy()</code> vectorizes the persistent entropy summary function </p>
<p style="text-align: center;"><code class="reqn">S(t)=-\sum_{i=1}^N \frac{l_i}{L}\log_2{(\frac{l_i}{L}})\bold 1_{[b_i,d_i]}(t),</code>
</p>
<p> where <code class="reqn">l_i=d_i-b_i</code> and <code class="reqn">L=\sum_{i=1}^Nl_i</code>, based on a scale sequence <code>scaleSeq</code>. If <code class="reqn">N=1</code>, <code class="reqn">L</code> is set to 1. The evaluation method depends on the argument <code>evaluate</code>. Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePersistentEntropy(D, homDim, scaleSeq, evaluate = "intervals")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePersistentEntropy_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computePersistentEntropy_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computePersistentEntropy_+3A_scaleseq">scaleSeq</code></td>
<td>
<p>a numeric vector of increasing scale values used for vectorization.</p>
</td></tr>
<tr><td><code id="computePersistentEntropy_+3A_evaluate">evaluate</code></td>
<td>
<p>a character string indicating the evaluation method. Must be either <code>"intervals"</code> (default) or <code>"points"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes values based on the filtered data and <code>scaleSeq</code>. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A numeric vector containing elements computed using <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code> according to the method specified by <code>evaluate</code>.
</p>

<ul>
<li> <p><code>"intervals"</code>: Computes average values of the persistent entropy summary function over intervals defined by consecutive elements in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta t_1}\int_{t_1}^{t_2}S(t)dt,\frac{1}{\Delta t_2}\int_{t_2}^{t_3}S(t)dt,\ldots,\frac{1}{\Delta t_{n-1}}\int_{t_{n-1}}^{t_n}S(t)dt\Big)\in\mathbb{R}^{n-1},</code>
</p>

<p>where <code class="reqn">\Delta t_k=t_{k+1}-t_k</code>.
</p>
</li>
<li> <p><code>"points"</code>: Computes values of the persistent entropy summary function at each point in <code>scaleSeq</code>:
</p>
<p style="text-align: center;"><code class="reqn">(S(t_1),S(t_2),\ldots,S(t_n))\in\mathbb{R}^n.</code>
</p>

</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Atienza, N., Gonzalez-DÃ­az, R., &amp; Soriano-Trigueros, M. (2020). On the stability of persistent entropy and new summary functions for topological data analysis. Pattern Recognition, 107, 107509.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

scaleSeq = seq(0, 2, length.out = 11) # A sequence of scale values

# Compute a vector summary of the persistent entropy summary function for homological dimension H_0
computePersistentEntropy(D, homDim = 0, scaleSeq)

# Compute a vector summary of the persistent entropy summary function for homological dimension H_1
computePersistentEntropy(D, homDim = 1, scaleSeq)
</code></pre>

<hr>
<h2 id='computeStats'>Compute Descriptive Statistics for Births, Deaths, Midpoints, and Lifespans in a Persistence Diagram</h2><span id='topic+computeStats'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computeStats()</code> calculates descriptive statistics of the birth, death, midpoint (the average of birth and death), and lifespan (death minus birth) values. Additionally, it computes the total number of points and entropy of the lifespan values. Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeStats(D, homDim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeStats_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeStats_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes the mean, standard deviation, median, IQR (interquartile range), range, 10th, 25th, 75th and 90th percentiles of the birth, death, midpoint, lifespan (or persistence) values; the total number of bars (or points in the diagram) and the entropy of the lifespan values (-<code class="reqn">\sum_{i=1}^N\frac{l_i}{L}\log_2(\frac{l_i}{L})</code>, where <code class="reqn">l_i=d_i-b_i</code> (lifespan) and <code class="reqn">L=\sum_{i=1}^N l_i</code>). If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A (named) 38-dimensional numeric vector containing:
</p>

<ul>
<li> <p><code>mean_births</code>, <code>stddev_births</code>, <code>median_births</code>, <code>iqr_births</code>, <code>range_births</code>, <code>p10_births</code>, <code>p25_births</code>, <code>p75_births</code>, <code>p90_births</code>: Descriptive statistics for birth values.
</p>
</li>
<li> <p><code>mean_deaths</code>, <code>stddev_deaths</code>, <code>median_deaths</code>, <code>iqr_deaths</code>, <code>range_deaths</code>, <code>p10_deaths</code>, <code>p25_deaths</code>, <code>p75_deaths</code>, <code>p90_deaths</code>: Descriptive statistics for death values.
</p>
</li>
<li> <p><code>mean_midpoints</code>, <code>stddev_midpoints</code>, <code>median_midpoints</code>, <code>iqr_midpoints</code>, <code>range_midpoints</code>, <code>p10_midpoints</code>, <code>p25_midpoints</code>, <code>p75_midpoints</code>, <code>p90_midpoints</code>: Descriptive statistics for midpoint values (mean of birth and death values).
</p>
</li>
<li> <p><code>mean_lifespans</code>, <code>stddev_lifespans</code>, <code>median_lifespans</code>, <code>iqr_lifespans</code>, <code>range_lifespans</code>, <code>p10_lifespans</code>, <code>p25_lifespans</code>, <code>p75_lifespans</code>, <code>p90_lifespans</code>: Descriptive statistics for lifespan (or persistence) values (difference between death and birth values).
</p>
</li>
<li> <p><code>total_bars</code>: The total number of points in the specified homological dimension.
</p>
</li>
<li> <p><code>entropy</code>: The entropy of the lifespan values.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Umar Islambekov
</p>


<h3>References</h3>

<p>1. Ali, D., Asaad, A., Jimenez, M.J., Nanda, V., Paluzo-Hidalgo, E. and Soriano-Trigueros, M., (2023). A survey of vectorization methods in topological data analysis. IEEE Transactions on Pattern Analysis and Machine Intelligence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

# Compute statistics for homological dimension H_0
computeStats(D, homDim = 0)

# Compute statistics for homological dimension H_1
computeStats(D, homDim = 1)
</code></pre>

<hr>
<h2 id='computeTemplateFunction'>Compute a Vectorization of a Persistence Diagram based on Tent Template Functions</h2><span id='topic+computeTemplateFunction'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computeTemplateFunction()</code> computes a vectorization using a collection of tent template functions defined by
</p>
<p style="text-align: center;"><code class="reqn">G_{(b,p),\delta}(D) = \sum_{i=1}^N\max \left\{ 0, 1 - \frac{1}{\delta} \max \left( |b_i - b|, |p_i - p| \right) \right\},</code>
</p>

<p>where <code class="reqn">p_i=d_i-b_i</code> (persistence), <code class="reqn">b\geq 0</code>, <code class="reqn">p&gt;0</code> and  <code class="reqn">0&lt;\delta&lt;p</code>. The point <code class="reqn">(b,p)</code> is referred to as the center. Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeTemplateFunction(D, homDim, delta, d, epsilon)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeTemplateFunction_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeTemplateFunction_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computeTemplateFunction_+3A_delta">delta</code></td>
<td>
<p>a positive scalar representing the increment size used in the computation of the template function.</p>
</td></tr>
<tr><td><code id="computeTemplateFunction_+3A_d">d</code></td>
<td>
<p>a positive integer specifying the number of bins along each axis in the grid.</p>
</td></tr>
<tr><td><code id="computeTemplateFunction_+3A_epsilon">epsilon</code></td>
<td>
<p>a positive scalar indicating the vertical shift applied to the grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes the tent template function on a discretized grid determined by <code>delta</code>, <code>d</code>, and <code>epsilon</code>. The number of tent functions is controlled by <code>d</code>. The value of <code class="reqn">\delta</code> is chosen such that the box <code class="reqn">[0, \delta d] \times [\epsilon,\delta d + \epsilon]</code> contains all the points of the diagrams considered in the birth-persistence plane. <code class="reqn">\epsilon</code> should be smaller than the minimum persistence value across all the diagrams under consideration. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>
<p>If <code>homDim=0</code> and all the birth values are equal (e.g., zero), one-dimensional tent template functions are used instead for vectorization:
</p>
<p style="text-align: center;"><code class="reqn">G_{p,\delta}(D) = \sum_{i=1}^N\max (0, 1 - \frac{|p_i - p|}{\delta}).</code>
</p>



<h3>Value</h3>

<p>A numeric vector of dimension <code class="reqn">(d+1)d</code>, containing the values of the tent template functions centered at the grid points <code class="reqn">\{(\delta i, \delta j + \epsilon)\}_{i=0,j=1}^{d,d}</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\{ G_{(\delta i, \delta j + \epsilon), \delta}(D) \mid 0 \leq i \leq d, \, 1 \leq j \leq d \}.
</code>
</p>

<p>When one-dimensional tent template functions are used, the returned vector has a dimension of <code class="reqn">d</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\{ G_{\delta j + \epsilon, \delta}(D) \mid 1 \leq j \leq d \}.
</code>
</p>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Perea, J.A., Munch, E. and Khasawneh, F.A., (2023). Approximating continuous functions on persistence diagrams using template functions. Foundations of Computational Mathematics, 23(4), pp.1215-1272.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

# Compute a vectorizaton based on tent template functions for homological dimension H_0
computeTemplateFunction(D, homDim = 0, delta = 0.1, d = 20, epsilon = 0.01)

# Compute a vectorizaton based on tent template functions for homological dimension H_1
computeTemplateFunction(D, homDim = 1, delta = 0.1, d = 9, epsilon = 0.01)
</code></pre>

<hr>
<h2 id='computeTropicalCoordinates'>Compute Tropical Coordinates from a Persistence Diagram</h2><span id='topic+computeTropicalCoordinates'></span>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> (corresponding to a specified homological dimension), <code>computeTropicalCoordinates()</code> computes the following seven tropical coordinates based on the lifespans (or persistence) <code class="reqn">\lambda_i = d_i - b_i</code>:
</p>

<ul>
<li> <p><code class="reqn">F_1 = \max_i \lambda_i</code>.
</p>
</li>
<li> <p><code class="reqn">F_2 = \max_{i&lt;j} (\lambda_i+\lambda_j)</code>.
</p>
</li>
<li> <p><code class="reqn">F_3 = \max_{i&lt;j&lt;k} (\lambda_i+\lambda_j+\lambda_k)</code>.
</p>
</li>
<li> <p><code class="reqn">F_4 = \max_{i&lt;j&lt;k&lt;l} (\lambda_i+\lambda_j+\lambda_k+\lambda_l)</code>.
</p>
</li>
<li> <p><code class="reqn">F_5 = \sum_i \lambda_i</code>.
</p>
</li>
<li> <p><code class="reqn">F_6 = \sum_i \min(r \lambda_i, b_i)</code>, where <code class="reqn">r</code> is a positive integer.
</p>
</li>
<li> <p><code class="reqn">F_7 = \sum_j \big(\max_i(\min(r \lambda_i, b_i)+\lambda_i)  - (\min(r \lambda_j, b_j)+\lambda_j)\big)</code>.
</p>
</li></ul>

<p>Points in <code class="reqn">D</code> with infinite death values are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeTropicalCoordinates(D, homDim, r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeTropicalCoordinates_+3A_d">D</code></td>
<td>
<p>a persistence diagram: a matrix with three columns containing the homological dimension, birth and death values respectively.</p>
</td></tr>
<tr><td><code id="computeTropicalCoordinates_+3A_homdim">homDim</code></td>
<td>
<p>the homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.). Rows in <code>D</code> are filtered based on this value.</p>
</td></tr>
<tr><td><code id="computeTropicalCoordinates_+3A_r">r</code></td>
<td>
<p>a positive integer used to compute <code class="reqn">F_6</code> and <code class="reqn">F_7</code>. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts rows from <code>D</code> where the first column equals <code>homDim</code>, and computes the seven tropical coordinates based on the filtered data. If <code>D</code> does not contain any points corresponding to <code>homDim</code>, a vector of zeros is returned.
</p>


<h3>Value</h3>

<p>A (named) numeric vector <code class="reqn">(F_1, F_2, F_3, F_4, F_5, F_6, F_7)</code>.
</p>


<h3>Author(s)</h3>

<p>Umar Islambekov
</p>


<h3>References</h3>

<p>1. KaliÅ¡nik, S., (2019). Tropical coordinates on the space of persistence barcodes. Foundations of Computational Mathematics, 19(1), pp.101-129.
</p>
<p>2. Ali, D., Asaad, A., Jimenez, M.J., Nanda, V., Paluzo-Hidalgo, E. and Soriano-Trigueros, M., (2023). A survey of vectorization methods in topological data analysis. IEEE Transactions on Pattern Analysis and Machine Intelligence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100 # The number of points to sample

set.seed(123) # Set a random seed for reproducibility

# Sample N points uniformly from the unit circle and add Gaussian noise
theta &lt;- runif(N, min = 0, max = 2 * pi)
X &lt;- cbind(cos(theta), sin(theta)) + rnorm(2 * N, mean = 0, sd = 0.2)

# Compute the persistence diagram using the Rips filtration built on top of X
# The 'threshold' parameter specifies the maximum distance for building simplices
D &lt;- TDAstats::calculate_homology(X, threshold = 2)

# Compute tropical coordinates for homological dimension H_0
computeTropicalCoordinates(D, homDim = 0)

# Compute tropical coordinates for homological dimension H_1
computeTropicalCoordinates(D, homDim = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
