<!DOCTYPE html><html><head><title>Help for package fbati</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fbati}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fbatc'><p>fbatc</p></a></li>
<li><a href='#fbatcStrategyStep'><p>FBAT-C Stepwise Strategy</p></a></li>
<li><a href='#fbatge'><p>fbatge</p></a></li>
<li><a href='#fbati'><p>fbati</p></a></li>
<li><a href='#fbatj'><p>fbatj</p></a></li>
<li><a href='#fbatme'><p>FBAT Main effects Test</p></a></li>
<li><a href='#launchpad'><p>Launchpad</p></a></li>
<li><a href='#nuclify'><p>Nuclify and Merge</p></a></li>
<li><a href='#strataReduce'><p>Strata Reduction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Gene by Environment Interaction and Conditional Gene Tests for
Nuclear Families</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Hoffmann &lt;tjhoffm@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Hoffmann &lt;tjhoffm@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>pbatR(&ge; 2.2-17)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tcltk, fgui, rootSolve</td>
</tr>
<tr>
<td>Description:</td>
<td>Does family-based gene by environment interaction tests, joint gene, gene-environment interaction test, and a test of a set of genes conditional on another set of genes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3120904/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3120904/</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-28 00:54:34 UTC; tom</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fbatc'>fbatc</h2><span id='topic+fbatc'></span>

<h3>Description</h3>

<p>Family based test for a group of markers conditional on another group of markers (typically conditional on a single marker). To start the graphical interface, provide no options, i.e. type <code>fbatc()</code> and press return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbatc( ped=NULL, phe=NULL, data=mergePhePed( ped, phe),
       trait="AffectionStatus", traitType="auto",
       markerAnalyze=NULL, markerCondition=NULL,
       offset=NULL,
       tempPrefix="temp",
       MAXITER=1000, TOL=sqrt(.Machine$double.eps),
       verbose=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbatc_+3A_ped">ped</code></td>
<td>
<p>Object from <code>(f)read.ped</code> or <code>as.ped</code> (non-symbolic). See <code>write.ped</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_phe">phe</code></td>
<td>
<p>Object from <code>(f)read.phe</code> or <code>as.phe</code> (non-symbolic). See <code>write.phe</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_data">data</code></td>
<td>
<p>a data.frame object containing required data, or formed from merging a pedigree and phenotype object together. The first columns of it must be as in a &lsquo;ped&rsquo; object, while the next can be in any order representing marker or phenotype information.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_trait">trait</code></td>
<td>
<p>Trait to be analyzed. Defaults to AffectionStatus.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_traittype">traitType</code></td>
<td>
<p>&ldquo;auto&rdquo;,&ldquo;binary&rdquo;, or &ldquo;continuous&rdquo;: if set to &ldquo;auto&rdquo;, then &ldquo;binary&rdquo; will be chosen if there is only two levels of outcome, otherwise &ldquo;continuous&rdquo;.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_markeranalyze">markerAnalyze</code></td>
<td>
<p>Names of markers to analyze (without .a, e.g.).</p>
</td></tr>
<tr><td><code id="fbatc_+3A_markercondition">markerCondition</code></td>
<td>
<p>Names of markers to condition on. If none are specified, then each marker will be conditioned on in turn.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_offset">offset</code></td>
<td>
<p>If set to NULL (i.e. left unset, the default) then for a continuous trait this is estimated by the trait mean.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_tempprefix">tempPrefix</code></td>
<td>
<p>Temporary prefix to use for output files. These are safe to delete later.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_maxiter">MAXITER</code></td>
<td>
<p>Maximum iterations before giving up on convergence for the nuisance parameters.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_tol">TOL</code></td>
<td>
<p>Relative tolerance for convergence for the nuisance parameters.</p>
</td></tr>
<tr><td><code id="fbatc_+3A_verbose">verbose</code></td>
<td>
<p>For debug.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the test as described in Hoffmann et. al. (please see References).
</p>
<p>The results returned are a data.frame object. The column &lsquo;pvalue&rsquo; and &lsquo;rank&rsquo; are the pvalue and rank of the empirical covariance matrix of the model-based test (dichotomous or normal). The column &lsquo;pvalueR&rsquo; and &lsquo;rankR&rsquo; are the pvalue and rank of the robust test. The model-based test has considerable more power over the robust test, but must assume a disease model. Please see Hoffmann et. al. for more details.
</p>
<p>This requires that FBAT be installed. If it is not, then the routine will attempt to automatically install it when given permission to do so by the user.
</p>


<h3>References</h3>

<p>Hoffmann, Thomas J. and Laird, Nan M. Parsing the Effects of Individual SNPs in Candidate Genes in Families. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  set.seed(13)

  ## We simulate NO LD HERE, and a completely random trait!
  ## Data here is only to show how to use the function

  ###################
  ## IGNORE START: ##
  ###################

  ##  You can safely ignore how the data is generated,
  ##  and just see how to use it afterward.
  NUM_FAMILIES &lt;- 500
  AFREQ &lt;- c(0.2,0.2)
  ped &lt;- as.ped( data.frame( pid = kronecker(1:NUM_FAMILIES,c(1,1,1)),
                            id = kronecker( rep(1,NUM_FAMILIES), c(1,2,3) ),
                            idfath = kronecker( rep(1,NUM_FAMILIES), c(0,0,1) ),
                            idmoth = kronecker( rep(1,NUM_FAMILIES), c(0,0,2) ),
                            sex = rep(0,NUM_FAMILIES*3),
                            AffectionStatus = kronecker( rep(1,NUM_FAMILIES), c(0,0,2) ),
                            m0.a = rep(0,NUM_FAMILIES*3),      ## missing for now
                            m0.b = rep(0,NUM_FAMILIES*3),
                            m1.a = rep(0,NUM_FAMILIES*3),
                            m1.b = rep(0,NUM_FAMILIES*3) ) )
  CUR_FAMILY &lt;- 1
  while( CUR_FAMILY&lt;=NUM_FAMILIES ) {
    ## Indexing: start=father, (start+1)=mother, (start+2)=child
    start &lt;- CUR_FAMILY*3-2

    ## Draw the parental genotypes from the population
    ped$m0.a[start:(start+1)] &lt;- rbinom( 1, 1, AFREQ[1] ) + 1
    ped$m0.b[start:(start+1)] &lt;- rbinom( 1, 1, AFREQ[1] ) + 1
    ped$m1.a[start:(start+1)] &lt;- rbinom( 1, 1, AFREQ[2] ) + 1
    ped$m1.b[start:(start+1)] &lt;- rbinom( 1, 1, AFREQ[2] ) + 1

    ## Draw the children's genotype from the parents
    ma &lt;- rbinom( 1, 1, 0.5 )
    mb &lt;- rbinom( 1, 1, 0.5 )
    if( rbinom( 1, 1, 0.5 ) == 0 ) {
      ped$m0.a[start+2] &lt;- ped$m0.a[start]
      ped$m1.a[start+2] &lt;- ped$m1.a[start]
    }else{
      ped$m0.a[start+2] &lt;- ped$m0.b[start]
      ped$m1.a[start+2] &lt;- ped$m1.b[start]
    }
    if( rbinom( 1, 1, 0.5 ) == 0 ) {
      ped$m0.b[start+2] &lt;- ped$m0.a[start+1]
      ped$m1.b[start+2] &lt;- ped$m1.a[start+1]
    }else{
      ped$m0.b[start+2] &lt;- ped$m0.b[start+1]
      ped$m1.b[start+2] &lt;- ped$m1.b[start+1]
    }

    CUR_FAMILY &lt;- CUR_FAMILY + 1
  }

  ## Create a completely random phenotype as well
  phe &lt;- as.phe( data.frame( pid=ped$pid, id=ped$id, qtl=rnorm(nrow(ped)) ) )

  ################
  ## IGNORE END ##
  ################

  ## Look at the first part of the pedigree
  print( head( ped ) )
  ## Look at the first part of the phenotype
  print( head( phe ) )

  ## Binary trait
  ## -- fbatc default trait is AffectionStatus
  ## -- fbatc default trait type is 'auto'
  ## - Test marker m1 conditional on m0
  print(  fbatc( ped=ped, markerAnalyze="m1", markerCondition="m0" )  )
  ## - Do the test the other way around, m0 conditional on m1
  print(  fbatc( ped=ped, markerAnalyze="m0", markerCondition="m1" )  )
  ## - Otherwise, we could have done this in one step;
  ##    if markerCondition is not specified, each member
  ##     of markerAnalyze is used.
  print(  fbatc( ped=ped, markerAnalyze=c("m0","m1") )  )

  ## QTL
  print(  fbatc( ped=ped, phe=phe, trait="qtl", markerAnalyze="m1", markerCondition="m0" )  )
  print(  fbatc( ped=ped, phe=phe, trait="qtl", markerAnalyze="m0", markerCondition="m1" )  )

  ## Additionally, we could write out the data that we
  ##  generated to disk so that we can then use it.
  write.ped( "simulated", ped ) ## to simulated.ped
  write.phe( "simulated", phe ) ## to simulated.phe

## End(Not run)
</code></pre>

<hr>
<h2 id='fbatcStrategyStep'>FBAT-C Stepwise Strategy</h2><span id='topic+fbatcStrategyStep'></span><span id='topic+fbatcStrategyStepUp'></span><span id='topic+fbatcStrategyStepDown'></span><span id='topic+fbatcStrategyStepLatex'></span><span id='topic+print.fbatcSStep'></span>

<h3>Description</h3>

<p>Apply the FBAT-C test in a stepwise fashion using <code>fbatcStrategyStep</code> (which does forward selection with <code>fbatcStrategyStepUp</code>, followed by backwards selection with <code>fbatcStrategyStepDown</code>) and get the results ready for publication with <code>fbatcStrategyStepLatex</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbatcStrategyStepUp(ped, phe, markers=pedMarkerNames(ped), trait="trait",
  traitType="auto", alphaMMarker=0.05, alphaStep=alphaMMarker, sortByCorrelation=TRUE,
  tempPrefix="temp_", sim=FALSE, debug=FALSE )
fbatcStrategyStepDown(ped, phe,  markers=pedMarkerNames(ped),
  markersChosen=pedMarkerNames(ped), markersChosenR=markersChosen, trait="trait",
  traitType="auto", alphaMMarker=0.05, alphaStep=alphaMMarker, sortByCorrelation=TRUE,
  tempPrefix="temp_", sim=FALSE, debug=FALSE )
fbatcStrategyStep(ped, phe, markers=pedMarkerNames(ped), trait="trait",
  traitType="auto", alphaMMarker=0.05, alphaStep=alphaMMarker, sortByCorrelation=TRUE,
  tempPrefix="temp_", sim=FALSE, debug=FALSE )
fbatcStrategyStepLatex(res, digits=4, ffile="", preamble=FALSE, build=preamble, pdf="")
## S3 method for class 'fbatcSStep'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbatcStrategyStep_+3A_ped">ped</code></td>
<td>
<p>Object from <code>(f)read.ped</code> or <code>as.ped</code>. See <code>write.ped</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_phe">phe</code></td>
<td>
<p>Object from <code>(f)read.phe</code> or <code>as.phe</code>. See <code>write.phe</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_markers">markers</code></td>
<td>
<p>Names of the markers to analyze.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_trait">trait</code></td>
<td>
<p>Name of the trait to analyze. Can be dichotomous or continuous.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_traittype">traitType</code></td>
<td>
<p>&quot;auto&quot;,&quot;dichotomous&quot;, or &quot;continuous&quot;. If &quot;auto&quot; (the default), then &quot;dichotomous&quot; will be set if there are only two levels of the phenotype.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_alphammarker">alphaMMarker</code></td>
<td>
<p>Alpha value for the multimarker test.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_alphastep">alphaStep</code></td>
<td>
<p>Alpha value used in the stepwise procedure.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_sortbycorrelation">sortByCorrelation</code></td>
<td>
<p>Whether to sort the markers by putting those in highest correlation closest to each other.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_tempprefix">tempPrefix</code></td>
<td>
<p>The prefix to use for some intermittent files. Changing this is only necessary when you want to run this routine in parallel when each process shares the same disk.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_sim">sim</code></td>
<td>
<p>Developer use only.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_res">res</code></td>
<td>
<p>Result of 'fbatcStrategyStep' routine.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to display.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_ffile">ffile</code></td>
<td>
<p>If set to a filename, then the output is redirected to that file instead of the standard output.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_preamble">preamble</code></td>
<td>
<p>Whether to produce a latex file that can be compiled, or only the code for the chart.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_build">build</code></td>
<td>
<p>Whether to run pdflatex on the file (requires <code>preamble=TRUE</code>), pdflatex must be in your path (generally true in linux, but not in Windows).</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_pdf">pdf</code></td>
<td>
<p>Name of the pdf viewer executable, if you also want to open the compiled file immediately. Note that in this case, you may not be able to return to the R session until you close this window.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_markerschosen">markersChosen</code></td>
<td>
<p>In the step-down approach, the markers to start with for the model-based approach.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_markerschosenr">markersChosenR</code></td>
<td>
<p>In the step-down approach, the markers to start with for the model-free approach.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_debug">debug</code></td>
<td>
<p>Developer use only.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_x">x</code></td>
<td>
<p>Result of fbatcStrategyStep, fbatcStrategyStepUp, fbatcStrategyStepDown.</p>
</td></tr>
<tr><td><code id="fbatcStrategyStep_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fbatcStrategy returns a list with the following components.
</p>
<p><code>mmarkerPvalue</code>: p-value of the multi-marker test on those markers (Rakovski et. al 2008).
</p>
<p><code>correlation</code>: correlation matrix of the markers
</p>
<p><code>univariate</code>: univariate results
</p>
<p><code>step</code>: (model-based test) list of components <code>pvalue</code> (ith pvalue of the conditional test of markersAnalyze[i] on all markersCondition), <code>numInf</code> (number of informative families in the ith test), <code>markersAnalyze</code>, and <code>markersCondition</code>
</p>
<p><code>markersChosen</code>: (model-based test) results from applying step-up strategy
</p>
<p><code>stepR</code>, <code>markersChosenR</code>: (model-free test) results similar to <code>step</code> and <code>markersChosen</code>.
</p>

<hr>
<h2 id='fbatge'>fbatge</h2><span id='topic+fbatge'></span><span id='topic+fbatgeAll'></span>

<h3>Description</h3>

<p>Family based test for gene-environment interaction utilizing arbitrary family structures and multiple affected offspring. This method is recommended over the <code>fbati</code> routine in most scenarios.
</p>
<p>If no arguments are passed, then a friendly graphical interface is presented to the user.
</p>
<p>fbatge [GxE test], fbatj (see fbatj help) [G,GxE test], fbatme (see fbatme help) [G test] generally have more options than fbatgeAll. fbatgeAll runs all three tests, and gives results of all of them, and so uses only the options that are common to all three functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbatge( ped=NULL, phe=NULL,
        env=NULL, cov=NULL,
        trait="AffectionStatus", geno=NULL,
        strategy="hybrid", model="additive" )
fbatgeAll( ped=NULL, phe=NULL, env=NULL, trait="AffectionStatus" )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbatge_+3A_ped">ped</code></td>
<td>
<p>Object from <code>(f)read.ped</code> or <code>as.ped</code> (non-symbolic). See <code>write.ped</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatge_+3A_phe">phe</code></td>
<td>
<p>Object from <code>(f)read.phe</code> or <code>as.phe</code> (non-symbolic). See <code>write.phe</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatge_+3A_env">env</code></td>
<td>
<p>Environmental Exposure. Should be a string, corresponding to the name in the 'phe' object.</p>
</td></tr>
<tr><td><code id="fbatge_+3A_cov">cov</code></td>
<td>
<p>Any covariates to adjust for (does not apply to RR method). Should be a vector of strings, corresponding to names in the 'phe' object.</p>
</td></tr>
<tr><td><code id="fbatge_+3A_trait">trait</code></td>
<td>
<p>Dichotomous trait name. Should be either &quot;AffectionStatus&quot;, corresponding to the affection status in the pedigree object, or a string in the phenotype object.</p>
</td></tr>
<tr><td><code id="fbatge_+3A_geno">geno</code></td>
<td>
<p>Names of the genetic markers, from the 'ped' object. If NULL (default), then all genetic markers are tested.</p>
</td></tr>
<tr><td><code id="fbatge_+3A_strategy">strategy</code></td>
<td>
<p>One of 'hybrid' (recommended, most efficient, requires rare disease), 'RR' (relative risk model, generally for a rare disease), or 'CLR' (conditional logistic regression).</p>
</td></tr>
<tr><td><code id="fbatge_+3A_model">model</code></td>
<td>
<p>Either 'additive' for the additive genetic model, or 'codominant' for the codominant genetic model (indicator variables for the genotypes).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the test as described in Hoffmann et. al. (please see References).
</p>
<p>NOTE: The allele frequency is simply based on the allele frequency in all genotyped individuals, and is not the best choice.
</p>


<h3>References</h3>

<p>Hoffmann, Thomas J., and Laird, Nan M. Combining Multiple Disease Models for a More Powerful Gene-Environment Interaction Test in Nuclear Families.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  example( fbati ) ## See fbati, creates a dataset for us in 'phe' and 'ped'
  print( fbatge( ped=ped, phe=phe, env="env" ) )
  ## The results are very close to the FBAT-I function, which
  ##  we would expect for trios.
</code></pre>

<hr>
<h2 id='fbati'>fbati</h2><span id='topic+fbati'></span>

<h3>Description</h3>

<p>Family based test for gene-environment interaction for bi-allelic snps, command/line or GUI (provide no options to start the graphical interface, i.e. just type <code>fbati()</code> and press return).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbati( ped=NULL, phe=NULL,
       data=mergePhePed(ped,phe),
       marker=NULL, ## pairs...
       env,
       method="fbati",
       model="additive",
       iter=10000,
       seed=7,
       maxSib=3,
       fixNames=TRUE,
       debug=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbati_+3A_ped">ped</code></td>
<td>
<p>Object from <code>(f)read.ped</code> or <code>as.ped</code>. See <code>write.ped</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbati_+3A_phe">phe</code></td>
<td>
<p>Object from <code>(f)read.phe</code> or <code>as.phe</code>. See <code>write.phe</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbati_+3A_data">data</code></td>
<td>
<p>a data.frame object containing required data, or formed from merging a pedigree and phenotype object together. The first columns of it must be as in a &lsquo;ped&rsquo; object, while the next can be in any order representing marker or phenotype information.</p>
</td></tr>
<tr><td><code id="fbati_+3A_marker">marker</code></td>
<td>
<p>Default is NULL for all markers. Otherwise, it can be the names of the marker (if you load in with read.ped, this should be without the '.a'/'.b' added to differentiate the two markers). If you are using more specialized loading routines, this represents the numbers of the columns where the markers are at. For example, 7:10 would mean that columns 7 and 8 represent one locus, and columns 9 and 10 represent another locus.</p>
</td></tr>
<tr><td><code id="fbati_+3A_env">env</code></td>
<td>
<p>Character string representing the name of the environmental variable to use (a column header name of the 'data' parameter).</p>
</td></tr>
<tr><td><code id="fbati_+3A_method">method</code></td>
<td>
<p>Currently only &lsquo;fbati&rsquo; is supported.</p>
</td></tr>
<tr><td><code id="fbati_+3A_model">model</code></td>
<td>
<p>one of <code>"additive"</code>, <code>"dominant"</code>, or <code>"recessive".</code></p>
</td></tr>
<tr><td><code id="fbati_+3A_iter">iter</code></td>
<td>
<p>The number of Monte-Carlo iterations to perform.</p>
</td></tr>
<tr><td><code id="fbati_+3A_seed">seed</code></td>
<td>
<p>The random seed, so consistent answers are maintained. See NOTE 1 for more details. NA/NULL disables this, but is not recommended.</p>
</td></tr>
<tr><td><code id="fbati_+3A_maxsib">maxSib</code></td>
<td>
<p>When nonzero, employs the following rules to minimize the number of strata, to improve the number of informative transmissions. When there are parents, a random affected child is chosen. When parents are missing, a random affected child with environmental exposure is chosen, and random genotyped siblings are chosen to maxSib total offspring (so 2 indicates a sibpair, 3 a sibtrio, etc.), and parents are treated as missing (even if there is one). See the 'strataReduce' routine for more details and examples.</p>
</td></tr>
<tr><td><code id="fbati_+3A_fixnames">fixNames</code></td>
<td>
<p>Just leave this to TRUE if creating from ped/phe objects (pops off the '.a' and '.b' added on to the names of the two markers that are added on when read in via the (f)read.ped(...) routine).</p>
</td></tr>
<tr><td><code id="fbati_+3A_debug">debug</code></td>
<td>
<p>Developer use only (extended output).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data.frame object with the results.  The columns entitled GX...X indicate the number of informative families in each strata for the given marker. If these columns do not show up, it indicates there was only one type of strata.
</p>
<p>The parents need not be in the dataset if they have completely missing genotypes (they will be inserted), but the snps must currently be bi-allelic (or you will get error messages).
</p>
<p><code>fread.ped</code> and <code>fread.phe</code> are suggested to enforce loading the whole dataset.
</p>
<p>NOTE 1: The fbati test was developed for families with at least one affected, so if there is more than one affected individual per family, only a random affected one will be used, and a random unaffected to reduce strata, unless <code>strataFix</code> is disabled. This is done on a per marker basis, thus the seed is set before every marker to obtain reproducible results.
</p>
<p>NOTE 2: The data is converted into nuclear families. This is done by a
call to &lsquo;nuclifyMerged&rsquo; to the passed in dataset to enforce this
consistency.
</p>


<h3>References</h3>

<p>Hoffmann, Thomas J.,  Lange, Christoph,  Vansteelandt, Stijn,  and Laird, Nan M.  Gene-Environment Interaction Test for Dichotomous Traits in Trios and Sibships. Submitted.
</p>
<p>S. L. Lake and N. M. Laird. Tests of gene-environment interaction for case-parent triads with general environmental exposures. Ann Hum Genet, 68(Pt 1):55-64, Jan 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbatj">fbatj</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data is simulated according to the formula in the
##  paper (you can see it from the code).

## Set the seed so you get the same results
set.seed(13)

## Constants (you can vary these)
NUM_FAMILIES &lt;- 500
AFREQ &lt;- 0.1  ## Allele frequency
BG &lt;- -0.25   ## main effect of gene
BE &lt;- 0       ## main effect of environment
BGE &lt;- 0.75   ## main gene-environment effect
ENV &lt;- 0.2    ## environmental exposure frequency

## (but don't modify this one)
MAX_PROB &lt;- exp( BG*2 + BE*1 + BGE*2*1 )

#####################################
## Create a random dataset (trios) ##
#####################################

## -- genotypes are set to missing for now,
##    everyone will be affected
ped &lt;- as.ped( data.frame( pid = kronecker(1:NUM_FAMILIES,c(1,1,1)),
                           id = kronecker( rep(1,NUM_FAMILIES), c(1,2,3) ),
                           idfath = kronecker( rep(1,NUM_FAMILIES), c(0,0,1) ),
                           idmoth = kronecker( rep(1,NUM_FAMILIES), c(0,0,2) ),
                           sex = rep(0,NUM_FAMILIES*3),
                           AffectionStatus = kronecker( rep(1,NUM_FAMILIES), c(0,0,2) ),
                           m0.a = rep(0,NUM_FAMILIES*3),      ## missing for now
                           m0.b = rep(0,NUM_FAMILIES*3) ) )   ## missing for now
## -- envioronment not generated yet
phe &lt;- as.phe( data.frame( pid = ped$pid,
                           id = ped$id,
                           env = rep(NA,NUM_FAMILIES*3) ) )   ## missing for now

## 50/50 chance of each parents alleles
mendelTransmission &lt;- function( a, b ) {
  r &lt;- rbinom( length(a), 1, 0.75 )
  return( a*r + b*(1-r) )
}

## Not the most efficient code, but it gets it done;
##  takes &lt; 5 sec on pentium M 1.8Ghz
CUR_FAMILY &lt;- 1
while( CUR_FAMILY&lt;=NUM_FAMILIES ) {
  ## Indexing: start=father, (start+1)=mother, (start+2)=child
  start &lt;- CUR_FAMILY*3-2

  ## Draw the parental genotypes from the population
  ped$m0.a[start:(start+1)] &lt;- rbinom( 1, 1, AFREQ ) + 1
  ped$m0.b[start:(start+1)] &lt;- rbinom( 1, 1, AFREQ ) + 1

  ## Draw the children's genotype from the parents
  ped$m0.a[start+2] &lt;- mendelTransmission( ped$m0.a[start], ped$m0.b[start] )
  ped$m0.b[start+2] &lt;- mendelTransmission( ped$m0.a[start+1], ped$m0.b[start+1] )

  ## Generate the environment
  phe$env[start+2] &lt;- rbinom( 1, 1, ENV )

  ## and the affection status
  Xg &lt;- as.integer(ped$m0.a[start+2]==2) + as.integer(ped$m0.b[start+2]==2)
  if( rbinom( 1, 1, exp( BG*Xg + BE*phe$env[start+2] + BGE*Xg*phe$env[start+2] ) / MAX_PROB ) == 1 )
    CUR_FAMILY &lt;- CUR_FAMILY + 1
  ## otherwise it wasn't a valid drawn individual
}


##############
## Analysis ##
##############

## Print the first 4 families
print( head( ped, n=12 ) )
print( head( phe, n=12 ) )

## NOTE: We could have just put all of this info into a single dataframe otherwise,
##  that would look like just the results of this
data &lt;- mergePhePed( ped, phe )
print( head( data, n=12 ) )

## And run the analysis on all the markers
fbati( ped=ped, phe=phe, env="env" )

## Or do it via the merged data.frame object
##  7 and 8 correspond to the marker columns
fbati( data=data, env="env", marker=c(7,8) )

## You may also want to up the number of Monte-Carlo
##  iterations from the default

## And we could also run a joint test instead
##  (see fbatj)
fbatj( ped=ped, phe=phe, env="env" )
fbatj( data=data, env="env", marker=c(7,8) )

## Not run: 
## This won't be run, but we could do this with the gui.
## It requires the data to be written to disk, so we do so:
write.ped( ped, "simulated" )
write.phe( phe, "simulated" )
## Then start the GUI -- specify the options as before,
##  but for the first two, navigate to the 'simulated.ped' and 'simulated.phe' files.
fbati()

## End(Not run)
</code></pre>

<hr>
<h2 id='fbatj'>fbatj</h2><span id='topic+fbatj'></span>

<h3>Description</h3>

<p>Family based joint test for both the main effect of the gene and gene-environment interaction, command/line or GUI (provide no options to start gui, i.e. just type <code>fbatj()</code> and press return). Null hypothesis is no linkage and no association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbatj( ped=NULL, phe=NULL,
       data=mergePhePed(ped,phe),
       marker = NULL,
       trait = "AffectionStatus",
       env = "env",
       model = "additive",
       mode = "univariate",
       fixNames = TRUE,
       verbose = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbatj_+3A_ped">ped</code></td>
<td>
<p>Object from <code>(f)read.ped</code> or <code>as.ped</code>. See <code>write.ped</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatj_+3A_phe">phe</code></td>
<td>
<p>Object from <code>(f)read.phe</code> or <code>as.phe</code>. See <code>write.phe</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatj_+3A_data">data</code></td>
<td>
<p>a data.frame object containing required data, or formed from merging a pedigree and phenotype object together. The first columns of it must be as in a &lsquo;ped&rsquo; object, while the next can be in any order representing marker or phenotype information.</p>
</td></tr>
<tr><td><code id="fbatj_+3A_marker">marker</code></td>
<td>
<p>Default is NULL for all markers. Otherwise, it can be the names of the marker (if you load in with read.ped, this should be without the '.a'/'.b' added to differentiate the two markers). If you are using more specialized loading routines, this represents the numbers of the columns where the markers are at. For example, 7:10 would mean that columns 7 and 8 represent one locus, and columns 9 and 10 represent another locus.</p>
</td></tr>
<tr><td><code id="fbatj_+3A_trait">trait</code></td>
<td>
<p>Character string representing the name of the trait variable to use (a column header name of the 'data' parameter).</p>
</td></tr>
<tr><td><code id="fbatj_+3A_env">env</code></td>
<td>
<p>Character string representing the name of the environmental variable to use (a column header name of the 'data' parameter).</p>
</td></tr>
<tr><td><code id="fbatj_+3A_model">model</code></td>
<td>
<p>one of <code>"additive"</code>, <code>"dominant"</code>, or <code>"recessive".</code></p>
</td></tr>
<tr><td><code id="fbatj_+3A_mode">mode</code></td>
<td>
<p>&quot;univariate&quot; is the only one supported.</p>
</td></tr>
<tr><td><code id="fbatj_+3A_fixnames">fixNames</code></td>
<td>
<p>Just leave this to TRUE if creating from ped/phe objects (pops off the '.a' and '.b' added on to the names of the two markers that are added on when read in via the (f)read.ped(...) routine).</p>
</td></tr>
<tr><td><code id="fbatj_+3A_verbose">verbose</code></td>
<td>
<p>Developer use only (extended output).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data.frame object with the results. Uses variance based on Mendelian transmissions (no longer uses the empirical variance).
</p>
<p>For an example, see the fbati function.
</p>


<h3>References</h3>

<p>K Lunetta, S V Faraone, J Biederman, and N M Laird. Family-based tests of association and linkage that use unaffected sibs, covariates, and interactions. Am J Hum Genet, 2000, 66, 605-614.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbatj">fbatj</a></code>
</p>

<hr>
<h2 id='fbatme'>FBAT Main effects Test</h2><span id='topic+fbatme'></span>

<h3>Description</h3>

<p>Family based test for the main genetic effect, using the variance based on Mendelian transmissions. The null hypothesis is that there is no linkage and no association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbatme( ped=NULL, phe=NULL,
        data=mergePhePed(ped,phe),
        marker=NULL,
        trait="AffectionStatus",
        model="additive",
        fixNames=TRUE,
        verbose = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbatme_+3A_ped">ped</code></td>
<td>
<p>Object from <code>(f)read.ped</code> or <code>as.ped</code>. See <code>write.ped</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatme_+3A_phe">phe</code></td>
<td>
<p>Object from <code>(f)read.phe</code> or <code>as.phe</code>. See <code>write.phe</code> in the pbatR R package for more details on the file format.</p>
</td></tr>
<tr><td><code id="fbatme_+3A_data">data</code></td>
<td>
<p>a data.frame object containing required data, or formed from merging a pedigree and phenotype object together. The first columns of it must be as in a &lsquo;ped&rsquo; object, while the next can be in any order representing marker or phenotype information.</p>
</td></tr>
<tr><td><code id="fbatme_+3A_marker">marker</code></td>
<td>
<p>Default is NULL for all markers. Otherwise, it can be the names of the marker (if you load in with read.ped, this should be without the '.a'/'.b' added to differentiate the two markers). If you are using more specialized loading routines, this represents the numbers of the columns where the markers are at. For example, 7:10 would mean that columns 7 and 8 represent one locus, and columns 9 and 10 represent another locus.</p>
</td></tr>
<tr><td><code id="fbatme_+3A_trait">trait</code></td>
<td>
<p>Character string representing the name of the trait variable to use (a column header name of the 'data' parameter).</p>
</td></tr>
<tr><td><code id="fbatme_+3A_model">model</code></td>
<td>
<p>one of <code>"additive"</code>, <code>"dominant"</code>, or <code>"recessive".</code></p>
</td></tr>
<tr><td><code id="fbatme_+3A_fixnames">fixNames</code></td>
<td>
<p>Just leave this to TRUE if creating from ped/phe objects (pops off the '.a' and '.b' added on to the names of the two markers that are added on when read in via the (f)read.ped(...) routine).</p>
</td></tr>
<tr><td><code id="fbatme_+3A_verbose">verbose</code></td>
<td>
<p>Developer use only (extended output).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data.frame object with the results. Uses the variance based on Mendelian transmissions.
</p>
<p>NOTE: The allele frequency is simply based on the allele frequency in all genotyped individuals, and is not the best choice.
</p>

<hr>
<h2 id='launchpad'>Launchpad</h2><span id='topic+launchpad'></span>

<h3>Description</h3>

<p>Provides a GUI launchpad for routines in the fbati (i.e. this package) and pbatR (a dependency of this package) R packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launchpad()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+fbati">fbati</a></code>
<code><a href="#topic+fbatj">fbatj</a></code>
</p>

<hr>
<h2 id='nuclify'>Nuclify and Merge</h2><span id='topic+nuclify'></span><span id='topic+nuclifyMerged'></span><span id='topic+mergePhePed'></span>

<h3>Description</h3>

<p><code>mergePhePed</code> merges a phenotype and pedigree object into a single data.frame object.
</p>
<p><code>nuclifyMerged</code> chops a merged object into nuclear families of a dataset, generally a necessary preprocessing option for tests.
</p>
<p><code>nuclify</code> chops instead a &lsquo;ped&rsquo; and &lsquo;phe&rsquo; object separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePhePed(ped, phe)
nuclifyMerged(data, OUT_MULT=2)
nuclify(ped, phe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nuclify_+3A_ped">ped</code></td>
<td>
<p>Object from <code>(f)read.ped</code> or <code>as.ped</code>.</p>
</td></tr>
<tr><td><code id="nuclify_+3A_phe">phe</code></td>
<td>
<p>Object from <code>(f)read.phe</code> or <code>as.phe</code>.</p>
</td></tr>
<tr><td><code id="nuclify_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing required data, or formed from merging a pedigree and phenotype object together. The first columns of it must be as in a &lsquo;ped&rsquo; object, while the next can be in any order representing marker or phenotype information.</p>
</td></tr>
<tr><td><code id="nuclify_+3A_out_mult">OUT_MULT</code></td>
<td>
<p>Hint for size of output, doesn't matter if wrong.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mergePhePed</code> and <code>nuclifyMerged</code> both return data.frame objects. <code>nuclify</code> returns a list that contains the &lsquo;phe&rsquo; object and the &lsquo;ped&rsquo; object with those respective names (see pbatR documentation, both objects extend data.frame objects, and can be used for the most part as if data.frame objects). When the data is nuclified, the parents of the nuclified families parents are lost.
</p>
<p>NOTE: nuclifyMerged will modify the pedigree id (pid) to be [100*(previous pid) + (nuclear family index)]. This should make it easy to observe the results of this call to your dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some pedigree structure
##
##   100 --- 101
##        |
##       201---202
##           |
##     -------------
##     |   |   |   |
##    301 302 303 304
ped &lt;- as.ped( data.frame( pid    = rep(1,8),
                           id     = c(100,101, 201,202, 301,302,303,304),
                           idfath = c(0,0,     100,0,   201,201,201,201),
                           idmoth = c(0,0,     101,0,   202,202,202,202),
                           sex    = c(1,2,     1,2,     2,2,2,2),
                           AffectionStatus = rep(0,8),
                           m0.a = rep(2,8),
                           m0.b = rep(2,8) ) )

## Which should chop up into
##   100 --- 101    201---202
##        |             |
##       201      -------------
##                |   |   |   |
##               301 302 303 304
nuclifyMerged( ped )

## NOTE: We could have merged the ped with a phe object,
##        via the 'mergePhePed' routine before running.
</code></pre>

<hr>
<h2 id='strataReduce'>Strata Reduction</h2><span id='topic+strataReduce'></span>

<h3>Description</h3>

<p>Reduces the number of strata in nuclear pedigrees for testing (for use with FBAT-I). For nuclear families with both parents, a random affected child is drawn. For nuclear families with at least one parent missing, a random affected and another random sib is used (parents ignored).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strataReduce( data, envCol, m0, m1=m0+1, maxSib=3 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strataReduce_+3A_data">data</code></td>
<td>
<p>data.frame of a merged pedigree/phenotype (see mergePhePed(...)).</p>
</td></tr>
<tr><td><code id="strataReduce_+3A_envcol">envCol</code></td>
<td>
<p>Integer representing environment column.</p>
</td></tr>
<tr><td><code id="strataReduce_+3A_m0">m0</code></td>
<td>
<p>Integer representing column of first marker.</p>
</td></tr>
<tr><td><code id="strataReduce_+3A_m1">m1</code></td>
<td>
<p>Integer representing column of second marker.</p>
</td></tr>
<tr><td><code id="strataReduce_+3A_maxsib">maxSib</code></td>
<td>
<p>Maximum number of sibs to use per family to reduce the number of strata.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Function creates a family with the specified markers and statuses
## NOTE: affection is false/true, whereas it is coded 1/2 in the ped file
createFam &lt;- function( pa=c(0,0), pb=c(0,0),
                       ca, cb,
                       caffected=rep(TRUE,length(ca)),
                       env=1:length(ca) ) {
  ## pid, id, idfath, idmoth, sex, affection, m0a, m0b
  numC &lt;- length(ca)
  return( data.frame( pid=rep(1,2+numC),
                      id=1:(2+numC),
                      idfath=c(0,0,rep(1,numC)),
                      idmoth=c(0,0,rep(2,numC)),
                      sex=c(2,1,rep(0,numC)),
                      affection=c(0,0,as.integer(caffected)+1),
                      m0.a=c(pa,ca), m0.b=c(pb,cb),
                      env=c(NA,NA,env) ) )
}
## Function tests/exemplifies the strataReduce(...) routine
srFam &lt;- function( ... ) {
  data &lt;- createFam( ... )
  data2 &lt;- strataReduce( data=data, envCol=9, m0=7, maxSib=2 )
  cat( "Original data:\n" )
  print( data )
  cat( "Reduced stratification data:\n" )
  print( data2 )
}

## Basic sib test
srFam( ca=c(1,1,2), cb=c(1,2,2) )

## Basic trio test
srFam( ca=c(1,1,2), cb=c(1,2,2), pa=c(1,1), pb=c(2,2) )

## a fairly comprehensive test here
## The affected should always be one of the first three,
##  the unaffected could be one the first eight
for( i in 1:10 )
  srFam( ca=c(1:8,0,0), cb=c(1:8,0,0),
         pa=c(1,1),
         caffected=c(rep(TRUE,6),rep(FALSE,4)),
         env=c(1:3,rep(NA,7)) )

## Now just to make sure, a full pedigree, rather than just one family
data &lt;- createFam( ca=1:2, cb=1:2 )
for( i in 2:10 )
  data &lt;- rbind( data, createFam( ca=1:2, cb=1:2 ) )
  cat( "Original data (full pedigree):\n" )
  print( data )
  cat( "Reduced stratification data (full pedigree), maxSib=3\n" )
  print( strataReduce( data=data, envCol=9, m0=7 ) )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
