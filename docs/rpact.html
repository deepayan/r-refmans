<!DOCTYPE html><html lang="en-US"><head><title>Help for package rpact</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rpact}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rpact'><p>rpact - Confirmatory Adaptive Clinical Trial Design and Analysis</p></a></li>
<li><a href='#AccrualTime'><p>Accrual Time</p></a></li>
<li><a href='#AnalysisResults'><p>Basic Class for Analysis Results</p></a></li>
<li><a href='#AnalysisResultsConditionalDunnett'><p>Analysis Results Multi-Arm Conditional Dunnett</p></a></li>
<li><a href='#AnalysisResultsEnrichment'><p>Basic Class for Analysis Results Enrichment</p></a></li>
<li><a href='#AnalysisResultsEnrichmentFisher'><p>Analysis Results Enrichment Fisher</p></a></li>
<li><a href='#AnalysisResultsEnrichmentInverseNormal'><p>Analysis Results Enrichment Inverse Normal</p></a></li>
<li><a href='#AnalysisResultsFisher'><p>Analysis Results Fisher</p></a></li>
<li><a href='#AnalysisResultsGroupSequential'><p>Analysis Results Group Sequential</p></a></li>
<li><a href='#AnalysisResultsInverseNormal'><p>Analysis Results Inverse Normal</p></a></li>
<li><a href='#AnalysisResultsMultiArm'><p>Basic Class for Analysis Results Multi-Arm</p></a></li>
<li><a href='#AnalysisResultsMultiArmFisher'><p>Analysis Results Multi-Arm Fisher</p></a></li>
<li><a href='#AnalysisResultsMultiArmInverseNormal'><p>Analysis Results Multi-Arm Inverse Normal</p></a></li>
<li><a href='#AnalysisResultsMultiHypotheses'><p>Basic Class for Analysis Results Multi-Hypotheses</p></a></li>
<li><a href='#as.data.frame.AnalysisResults'><p>Coerce AnalysisResults to a Data Frame</p></a></li>
<li><a href='#as.data.frame.ParameterSet'><p>Coerce Parameter Set to a Data Frame</p></a></li>
<li><a href='#as.data.frame.PowerAndAverageSampleNumberResult'><p>Coerce Power And Average Sample Number Result to a Data Frame</p></a></li>
<li><a href='#as.data.frame.StageResults'><p>Coerce Stage Results to a Data Frame</p></a></li>
<li><a href='#as.data.frame.TrialDesign'><p>Coerce TrialDesign to a Data Frame</p></a></li>
<li><a href='#as.data.frame.TrialDesignCharacteristics'><p>Coerce TrialDesignCharacteristics to a Data Frame</p></a></li>
<li><a href='#as.data.frame.TrialDesignPlan'><p>Coerce Trial Design Plan to a Data Frame</p></a></li>
<li><a href='#as.data.frame.TrialDesignSet'><p>Coerce Trial Design Set to a Data Frame</p></a></li>
<li><a href='#as.matrix.FieldSet'><p>Coerce Field Set to a Matrix</p></a></li>
<li><a href='#as251Normal'><p>Algorithm AS 251: Normal Distribution</p></a></li>
<li><a href='#as251StudentT'><p>Algorithm AS 251: Student T Distribution</p></a></li>
<li><a href='#ClosedCombinationTestResults'><p>Analysis Results Closed Combination Test</p></a></li>
<li><a href='#ConditionalPowerResults'><p>Conditional Power Results</p></a></li>
<li><a href='#ConditionalPowerResultsEnrichmentMeans'><p>Conditional Power Results Enrichment Means</p></a></li>
<li><a href='#ConditionalPowerResultsEnrichmentRates'><p>Conditional Power Results Enrichment Rates</p></a></li>
<li><a href='#ConditionalPowerResultsMeans'><p>Conditional Power Results Means</p></a></li>
<li><a href='#ConditionalPowerResultsRates'><p>Conditional Power Results Rates</p></a></li>
<li><a href='#ConditionalPowerResultsSurvival'><p>Conditional Power Results Survival</p></a></li>
<li><a href='#dataEnrichmentMeans'><p>Enrichment Dataset of Means</p></a></li>
<li><a href='#dataEnrichmentMeansStratified'><p>Stratified Enrichment Dataset of Means</p></a></li>
<li><a href='#dataEnrichmentRates'><p>Enrichment Dataset of Rates</p></a></li>
<li><a href='#dataEnrichmentRatesStratified'><p>Stratified Enrichment Dataset of Rates</p></a></li>
<li><a href='#dataEnrichmentSurvival'><p>Enrichment Dataset of Survival Data</p></a></li>
<li><a href='#dataEnrichmentSurvivalStratified'><p>Stratified Enrichment Dataset of Survival Data</p></a></li>
<li><a href='#dataMeans'><p>One-Arm Dataset of Means</p></a></li>
<li><a href='#dataMultiArmMeans'><p>Multi-Arm Dataset of Means</p></a></li>
<li><a href='#dataMultiArmRates'><p>Multi-Arm Dataset of Rates</p></a></li>
<li><a href='#dataMultiArmSurvival'><p>Multi-Arm Dataset of Survival Data</p></a></li>
<li><a href='#dataRates'><p>One-Arm Dataset of Rates</p></a></li>
<li><a href='#Dataset'><p>Dataset</p></a></li>
<li><a href='#DatasetMeans'><p>Dataset of Means</p></a></li>
<li><a href='#DatasetRates'><p>Dataset of Rates</p></a></li>
<li><a href='#DatasetSurvival'><p>Dataset of Survival Data</p></a></li>
<li><a href='#dataSurvival'><p>One-Arm Dataset of Survival Data</p></a></li>
<li><a href='#EventProbabilities'><p>Event Probabilities</p></a></li>
<li><a href='#FieldSet'><p>Field Set</p></a></li>
<li><a href='#getAccrualTime'><p>Get Accrual Time</p></a></li>
<li><a href='#getAnalysisResults'><p>Get Analysis Results</p></a></li>
<li><a href='#getClosedCombinationTestResults'><p>Get Closed Combination Test Results</p></a></li>
<li><a href='#getClosedConditionalDunnettTestResults'><p>Get Closed Conditional Dunnett Test Results</p></a></li>
<li><a href='#getConditionalPower'><p>Get Conditional Power</p></a></li>
<li><a href='#getConditionalRejectionProbabilities'><p>Get Conditional Rejection Probabilities</p></a></li>
<li><a href='#getData'><p>Get Simulation Data</p></a></li>
<li><a href='#getDataset'><p>Get Dataset</p></a></li>
<li><a href='#getDesignCharacteristics'><p>Get Design Characteristics</p></a></li>
<li><a href='#getDesignConditionalDunnett'><p>Get Design Conditional Dunnett Test</p></a></li>
<li><a href='#getDesignFisher'><p>Get Design Fisher</p></a></li>
<li><a href='#getDesignGroupSequential'><p>Get Design Group Sequential</p></a></li>
<li><a href='#getDesignInverseNormal'><p>Get Design Inverse Normal</p></a></li>
<li><a href='#getDesignSet'><p>Get Design Set</p></a></li>
<li><a href='#getEventProbabilities'><p>Get Event Probabilities</p></a></li>
<li><a href='#getFinalConfidenceInterval'><p>Get Final Confidence Interval</p></a></li>
<li><a href='#getFinalPValue'><p>Get Final P Value</p></a></li>
<li><a href='#getGroupSequentialProbabilities'><p>Get Group Sequential Probabilities</p></a></li>
<li><a href='#getLambdaStepFunction'><p>Get Lambda Step Function</p></a></li>
<li><a href='#getLogLevel'><p>Get Log Level</p></a></li>
<li><a href='#getLongFormat'><p>Get Long Format</p></a></li>
<li><a href='#getNumberOfSubjects'><p>Get Number Of Subjects</p></a></li>
<li><a href='#getObservedInformationRates'><p>Get Observed Information Rates</p></a></li>
<li><a href='#getOutputFormat'><p>Get Output Format</p></a></li>
<li><a href='#getParameterCaption'><p>Get Parameter Caption</p></a></li>
<li><a href='#getParameterName'><p>Get Parameter Name</p></a></li>
<li><a href='#getParameterType'><p>Get Parameter Type</p></a></li>
<li><a href='#getPerformanceScore'><p>Get Performance Score</p></a></li>
<li><a href='#getPiecewiseSurvivalTime'><p>Get Piecewise Survival Time</p></a></li>
<li><a href='#getPlotSettings'><p>Get Plot Settings</p></a></li>
<li><a href='#getPowerAndAverageSampleNumber'><p>Get Power And Average Sample Number</p></a></li>
<li><a href='#getPowerCounts'><p>Get Power Counts</p></a></li>
<li><a href='#getPowerMeans'><p>Get Power Means</p></a></li>
<li><a href='#getPowerRates'><p>Get Power Rates</p></a></li>
<li><a href='#getPowerSurvival'><p>Get Power Survival</p></a></li>
<li><a href='#getRawData'><p>Get Simulation Raw Data for Survival</p></a></li>
<li><a href='#getRepeatedConfidenceIntervals'><p>Get Repeated Confidence Intervals</p></a></li>
<li><a href='#getRepeatedPValues'><p>Get Repeated P Values</p></a></li>
<li><a href='#getSampleSizeCounts'><p>Get Sample Size Counts</p></a></li>
<li><a href='#getSampleSizeMeans'><p>Get Sample Size Means</p></a></li>
<li><a href='#getSampleSizeRates'><p>Get Sample Size Rates</p></a></li>
<li><a href='#getSampleSizeSurvival'><p>Get Sample Size Survival</p></a></li>
<li><a href='#getSimulationCounts'><p>Get Simulation Counts</p></a></li>
<li><a href='#getSimulationEnrichmentMeans'><p>Get Simulation Enrichment Means</p></a></li>
<li><a href='#getSimulationEnrichmentRates'><p>Get Simulation Enrichment Rates</p></a></li>
<li><a href='#getSimulationEnrichmentSurvival'><p>Get Simulation Enrichment Survival</p></a></li>
<li><a href='#getSimulationMeans'><p>Get Simulation Means</p></a></li>
<li><a href='#getSimulationMultiArmMeans'><p>Get Simulation Multi-Arm Means</p></a></li>
<li><a href='#getSimulationMultiArmRates'><p>Get Simulation Multi-Arm Rates</p></a></li>
<li><a href='#getSimulationMultiArmSurvival'><p>Get Simulation Multi-Arm Survival</p></a></li>
<li><a href='#getSimulationRates'><p>Get Simulation Rates</p></a></li>
<li><a href='#getSimulationSurvival'><p>Get Simulation Survival</p></a></li>
<li><a href='#getStageResults'><p>Get Stage Results</p></a></li>
<li><a href='#getTestActions'><p>Get Test Actions</p></a></li>
<li><a href='#getWideFormat'><p>Get Wide Format</p></a></li>
<li><a href='#kableParameterSet'><p>Create output in Markdown</p></a></li>
<li><a href='#knit_print.FieldSet'><p>Print Field Set in Markdown Code Chunks</p></a></li>
<li><a href='#knit_print.ParameterSet'><p>Print Parameter Set in Markdown Code Chunks</p></a></li>
<li><a href='#knit_print.SummaryFactory'><p>Print Summary Factory in Markdown Code Chunks</p></a></li>
<li><a href='#length.TrialDesignSet'><p>Length of Trial Design Set</p></a></li>
<li><a href='#mvnprd'><p>Original Algorithm AS 251: Normal Distribution</p></a></li>
<li><a href='#mvstud'><p>Original Algorithm AS 251: Student T Distribution</p></a></li>
<li><a href='#names.AnalysisResults'><p>Names of a Analysis Results Object</p></a></li>
<li><a href='#names.FieldSet'><p>Names of a Field Set Object</p></a></li>
<li><a href='#names.SimulationResults'><p>Names of a Simulation Results Object</p></a></li>
<li><a href='#names.StageResults'><p>Names of a Stage Results Object</p></a></li>
<li><a href='#names.TrialDesignSet'><p>Names of a Trial Design Set Object</p></a></li>
<li><a href='#NumberOfSubjects'><p>Number Of Subjects</p></a></li>
<li><a href='#obtain'><p>Extract a single parameter</p></a></li>
<li><a href='#param_accrualIntensity'><p>Parameter Description: Accrual Intensity</p></a></li>
<li><a href='#param_accrualIntensity_counts'><p>Parameter Description: accrualIntensity for Counts</p></a></li>
<li><a href='#param_accrualIntensityType'><p>Parameter Description: Accrual Intensity Type</p></a></li>
<li><a href='#param_accrualTime'><p>Parameter Description: Accrual Time</p></a></li>
<li><a href='#param_accrualTime_counts'><p>Parameter Description: accrualTime for Counts</p></a></li>
<li><a href='#param_activeArms'><p>Parameter Description: Active Arms</p></a></li>
<li><a href='#param_adaptations'><p>Parameter Description: Adaptations</p></a></li>
<li><a href='#param_allocationRatioPlanned'><p>Parameter Description: Allocation Ratio Planned</p></a></li>
<li><a href='#param_allocationRatioPlanned_sampleSize'><p>Parameter Description: Allocation Ratio Planned With Optimum Option</p></a></li>
<li><a href='#param_alpha'><p>Parameter Description: Alpha</p></a></li>
<li><a href='#param_alternative'><p>Parameter Description: Alternative</p></a></li>
<li><a href='#param_alternative_simulation'><p>Parameter Description: Alternative for Simulation</p></a></li>
<li><a href='#param_beta'><p>Parameter Description: Beta</p></a></li>
<li><a href='#param_bindingFutility'><p>Parameter Description: Binding Futility</p></a></li>
<li><a href='#param_calcEventsFunction'><p>Parameter Description: Calculate Events Function</p></a></li>
<li><a href='#param_calcSubjectsFunction'><p>Parameter Description: Calculate Subjects Function</p></a></li>
<li><a href='#param_conditionalPower'><p>Parameter Description: Conditional Power</p></a></li>
<li><a href='#param_conditionalPowerSimulation'><p>Parameter Description: Conditional Power</p></a></li>
<li><a href='#param_dataInput'><p>Parameter Description: Data Input</p></a></li>
<li><a href='#param_design'><p>Parameter Description: Design</p></a></li>
<li><a href='#param_design_with_default'><p>Parameter Description: Design with Default</p></a></li>
<li><a href='#param_digits'><p>Parameter Description: Digits</p></a></li>
<li><a href='#param_directionUpper'><p>Parameter Description: Direction Upper</p></a></li>
<li><a href='#param_dropoutRate1'><p>Parameter Description: Dropout Rate (1)</p></a></li>
<li><a href='#param_dropoutRate2'><p>Parameter Description: Dropout Rate (2)</p></a></li>
<li><a href='#param_dropoutTime'><p>Parameter Description: Dropout Time</p></a></li>
<li><a href='#param_effectList'><p>Parameter Description: Effect List</p></a></li>
<li><a href='#param_effectMatrix'><p>Parameter Description: Effect Matrix</p></a></li>
<li><a href='#param_effectMeasure'><p>Parameter Description: Effect Measure</p></a></li>
<li><a href='#param_epsilonValue'><p>Parameter Description: Epsilon Value</p></a></li>
<li><a href='#param_eventTime'><p>Parameter Description: Event Time</p></a></li>
<li><a href='#param_fixedExposureTime_counts'><p>Parameter Description: fixedExposureTime for Counts</p></a></li>
<li><a href='#param_followUpTime_counts'><p>Parameter Description: followUpTime for Counts</p></a></li>
<li><a href='#param_gED50'><p>Parameter Description: G ED50</p></a></li>
<li><a href='#param_grid'><p>Parameter Description: Grid (Output Specification Of Multiple Plots)</p></a></li>
<li><a href='#param_groups'><p>Parameter Description: Number Of Treatment Groups</p></a></li>
<li><a href='#param_hazardRatio'><p>Parameter Description: Hazard Ratio</p></a></li>
<li><a href='#param_includeAllParameters'><p>Parameter Description: Include All Parameters</p></a></li>
<li><a href='#param_informationEpsilon'><p>Parameter Description: Information Epsilon</p></a></li>
<li><a href='#param_informationRates'><p>Parameter Description: Information Rates</p></a></li>
<li><a href='#param_intersectionTest_Enrichment'><p>Parameter Description: Intersection Test</p></a></li>
<li><a href='#param_intersectionTest_MultiArm'><p>Parameter Description: Intersection Test</p></a></li>
<li><a href='#param_kappa'><p>Parameter Description: Kappa</p></a></li>
<li><a href='#param_kMax'><p>Parameter Description: Maximum Number of Stages</p></a></li>
<li><a href='#param_lambda_counts'><p>Parameter Description: lambda for Counts</p></a></li>
<li><a href='#param_lambda1'><p>Parameter Description: Lambda (1)</p></a></li>
<li><a href='#param_lambda1_counts'><p>Parameter Description: lambda (1) for Counts</p></a></li>
<li><a href='#param_lambda2'><p>Parameter Description: Lambda (2)</p></a></li>
<li><a href='#param_lambda2_counts'><p>Parameter Description: lambda (2) for Counts</p></a></li>
<li><a href='#param_legendPosition'><p>Parameter Description: Legend Position On Plots</p></a></li>
<li><a href='#param_maxInformation'><p>Parameter Description: Maximum Information</p></a></li>
<li><a href='#param_maxNumberOfEventsPerStage'><p>Parameter Description: Max Number Of Events Per Stage</p></a></li>
<li><a href='#param_maxNumberOfIterations'><p>Parameter Description: Maximum Number Of Iterations</p></a></li>
<li><a href='#param_maxNumberOfSubjects'><p>Parameter Description: Maximum Number Of Subjects</p></a></li>
<li><a href='#param_maxNumberOfSubjects_survival'><p>Parameter Description: Maximum Number Of Subjects For Survival Endpoint</p></a></li>
<li><a href='#param_maxNumberOfSubjectsPerStage'><p>Parameter Description: Maximum Number Of Subjects Per Stage</p></a></li>
<li><a href='#param_median1'><p>Parameter Description: Median (1)</p></a></li>
<li><a href='#param_median2'><p>Parameter Description: Median (2)</p></a></li>
<li><a href='#param_minNumberOfEventsPerStage'><p>Parameter Description: Min Number Of Events Per Stage</p></a></li>
<li><a href='#param_minNumberOfSubjectsPerStage'><p>Parameter Description: Minimum Number Of Subjects Per Stage</p></a></li>
<li><a href='#param_niceColumnNamesEnabled'><p>Parameter Description: Nice Column Names Enabled</p></a></li>
<li><a href='#param_nMax'><p>Parameter Description: N_max</p></a></li>
<li><a href='#param_normalApproximation'><p>Parameter Description: Normal Approximation</p></a></li>
<li><a href='#param_nPlanned'><p>Parameter Description: N Planned</p></a></li>
<li><a href='#param_overdispersion_counts'><p>Parameter Description: overdispersion for Counts</p></a></li>
<li><a href='#param_palette'><p>Parameter Description: Palette</p></a></li>
<li><a href='#param_pi1_rates'><p>Parameter Description: Pi (1) for Rates</p></a></li>
<li><a href='#param_pi1_survival'><p>Parameter Description: Pi (1) for Survival Data</p></a></li>
<li><a href='#param_pi2_rates'><p>Parameter Description: Pi (2) for Rates</p></a></li>
<li><a href='#param_pi2_survival'><p>Parameter Description: Pi (2) for Survival Data</p></a></li>
<li><a href='#param_piecewiseSurvivalTime'><p>Parameter Description: Piecewise Survival Time</p></a></li>
<li><a href='#param_plannedCalendarTime'><p>Parameter Description: Planned Calendar Time</p></a></li>
<li><a href='#param_plannedEvents'><p>Parameter Description: Planned Events</p></a></li>
<li><a href='#param_plannedSubjects'><p>Parameter Description: Planned Subjects</p></a></li>
<li><a href='#param_plotPointsEnabled'><p>Parameter Description: Plot Points Enabled</p></a></li>
<li><a href='#param_plotSettings'><p>Parameter Description: Plot Settings</p></a></li>
<li><a href='#param_populations'><p>Parameter Description: Populations</p></a></li>
<li><a href='#param_rValue'><p>Parameter Description: R Value</p></a></li>
<li><a href='#param_seed'><p>Parameter Description: Seed</p></a></li>
<li><a href='#param_selectArmsFunction'><p>Parameter Description: Select Arms Function</p></a></li>
<li><a href='#param_selectPopulationsFunction'><p>Parameter Description: Select Populations Function</p></a></li>
<li><a href='#param_showSource'><p>Parameter Description: Show Source</p></a></li>
<li><a href='#param_showStatistics'><p>Parameter Description: Show Statistics</p></a></li>
<li><a href='#param_sided'><p>Parameter Description: Sided</p></a></li>
<li><a href='#param_slope'><p>Parameter Description: Slope</p></a></li>
<li><a href='#param_stage'><p>Parameter Description: Stage</p></a></li>
<li><a href='#param_stageResults'><p>Parameter Description: Stage Results</p></a></li>
<li><a href='#param_stDev'><p>Parameter Description: Standard Deviation</p></a></li>
<li><a href='#param_stDevH1'><p>Parameter Description: Standard Deviation Under Alternative</p></a></li>
<li><a href='#param_stDevSimulation'><p>Parameter Description: Standard Deviation for Simulation</p></a></li>
<li><a href='#param_stratifiedAnalysis'><p>Parameter Description: Stratified Analysis</p></a></li>
<li><a href='#param_successCriterion'><p>Parameter Description: Success Criterion</p></a></li>
<li><a href='#param_theta'><p>Parameter Description: Theta</p></a></li>
<li><a href='#param_theta_counts'><p>Parameter Description: theta for Counts</p></a></li>
<li><a href='#param_thetaH0'><p>Parameter Description: Theta H0</p></a></li>
<li><a href='#param_thetaH1'><p>Parameter Description: Effect Under Alternative</p></a></li>
<li><a href='#param_three_dots'><p>Parameter Description: &quot;...&quot;</p></a></li>
<li><a href='#param_three_dots_plot'><p>Parameter Description: &quot;...&quot; (optional plot arguments)</p></a></li>
<li><a href='#param_threshold'><p>Parameter Description: Threshold</p></a></li>
<li><a href='#param_tolerance'><p>Parameter Description: Tolerance</p></a></li>
<li><a href='#param_typeOfComputation'><p>Parameter Description: Type Of Computation</p></a></li>
<li><a href='#param_typeOfDesign'><p>Parameter Description: Type of Design</p></a></li>
<li><a href='#param_typeOfSelection'><p>Parameter Description: Type of Selection</p></a></li>
<li><a href='#param_typeOfShape'><p>Parameter Description: Type Of Shape</p></a></li>
<li><a href='#param_userAlphaSpending'><p>Parameter Description: User Alpha Spending</p></a></li>
<li><a href='#param_varianceOption'><p>Parameter Description: Variance Option</p></a></li>
<li><a href='#ParameterSet'><p>Parameter Set</p></a></li>
<li><a href='#PerformanceScore'><p>Performance Score</p></a></li>
<li><a href='#PiecewiseSurvivalTime'><p>Piecewise Exponential Survival Time</p></a></li>
<li><a href='#plot.AnalysisResults'><p>Analysis Results Plotting</p></a></li>
<li><a href='#plot.Dataset'><p>Dataset Plotting</p></a></li>
<li><a href='#plot.EventProbabilities'><p>Event Probabilities Plotting</p></a></li>
<li><a href='#plot.NumberOfSubjects'><p>Number Of Subjects Plotting</p></a></li>
<li><a href='#plot.ParameterSet'><p>Parameter Set Plotting</p></a></li>
<li><a href='#plot.SimulationResults'><p>Simulation Results Plotting</p></a></li>
<li><a href='#plot.StageResults'><p>Stage Results Plotting</p></a></li>
<li><a href='#plot.SummaryFactory'><p>Summary Factory Plotting</p></a></li>
<li><a href='#plot.TrialDesign'><p>Trial Design Plotting</p></a></li>
<li><a href='#plot.TrialDesignPlan'><p>Trial Design Plan Plotting</p></a></li>
<li><a href='#plot.TrialDesignSet'><p>Trial Design Set Plotting</p></a></li>
<li><a href='#plot.TrialDesignSummaries'><p>Plot Trial Design Summaries</p></a></li>
<li><a href='#PlotSettings'><p>Plot Settings</p></a></li>
<li><a href='#plotTypes'><p>Get Available Plot Types</p></a></li>
<li><a href='#PowerAndAverageSampleNumberResult'><p>Power and Average Sample Number Result</p></a></li>
<li><a href='#print.Dataset'><p>Print Dataset Values</p></a></li>
<li><a href='#print.FieldSet'><p>Print Field Set Values</p></a></li>
<li><a href='#print.ParameterSet'><p>Print Parameter Set Values</p></a></li>
<li><a href='#print.SimulationResults'><p>Print Simulation Results</p></a></li>
<li><a href='#print.SummaryFactory'><p>Summary Factory Printing</p></a></li>
<li><a href='#print.TrialDesignCharacteristics'><p>Trial Design Characteristics Printing</p></a></li>
<li><a href='#print.TrialDesignSummaries'><p>Print Trial Design Summaries</p></a></li>
<li><a href='#printCitation'><p>Print Citation</p></a></li>
<li><a href='#rawDataTwoArmNormal'><p>Raw Dataset Of A Two Arm Continuous Outcome With Covariates</p></a></li>
<li><a href='#rcmd'><p>Get Object R Code</p></a></li>
<li><a href='#readDataset'><p>Read Dataset</p></a></li>
<li><a href='#readDatasets'><p>Read Multiple Datasets</p></a></li>
<li><a href='#resetLogLevel'><p>Reset Log Level</p></a></li>
<li><a href='#setLogLevel'><p>Set Log Level</p></a></li>
<li><a href='#setOutputFormat'><p>Set Output Format</p></a></li>
<li><a href='#SimulationResults'><p>Class for Simulation Results</p></a></li>
<li><a href='#SimulationResultsCountData'><p>Class for Simulation Results Count Data</p></a></li>
<li><a href='#SimulationResultsEnrichmentMeans'><p>Class for Simulation Results Enrichment Means</p></a></li>
<li><a href='#SimulationResultsEnrichmentRates'><p>Class for Simulation Results Enrichment Rates</p></a></li>
<li><a href='#SimulationResultsEnrichmentSurvival'><p>Class for Simulation Results Enrichment Survival</p></a></li>
<li><a href='#SimulationResultsMeans'><p>Class for Simulation Results Means</p></a></li>
<li><a href='#SimulationResultsMultiArmMeans'><p>Class for Simulation Results Multi-Arm Means</p></a></li>
<li><a href='#SimulationResultsMultiArmRates'><p>Class for Simulation Results Multi-Arm Rates</p></a></li>
<li><a href='#SimulationResultsMultiArmSurvival'><p>Class for Simulation Results Multi-Arm Survival</p></a></li>
<li><a href='#SimulationResultsRates'><p>Class for Simulation Results Rates</p></a></li>
<li><a href='#SimulationResultsSurvival'><p>Class for Simulation Results Survival</p></a></li>
<li><a href='#StageResults'><p>Basic Stage Results</p></a></li>
<li><a href='#StageResultsEnrichmentMeans'><p>Stage Results Enrichment Means</p></a></li>
<li><a href='#StageResultsEnrichmentRates'><p>Stage Results Enrichment Rates</p></a></li>
<li><a href='#StageResultsEnrichmentSurvival'><p>Stage Results Enrichment Survival</p></a></li>
<li><a href='#StageResultsMeans'><p>Stage Results of Means</p></a></li>
<li><a href='#StageResultsMultiArmMeans'><p>Stage Results Multi Arm Means</p></a></li>
<li><a href='#StageResultsMultiArmRates'><p>Stage Results Multi Arm Rates</p></a></li>
<li><a href='#StageResultsMultiArmSurvival'><p>Stage Results Multi Arm Survival</p></a></li>
<li><a href='#StageResultsRates'><p>Stage Results of Rates</p></a></li>
<li><a href='#StageResultsSurvival'><p>Stage Results of Survival Data</p></a></li>
<li><a href='#summary.AnalysisResults'><p>Analysis Results Summary</p></a></li>
<li><a href='#summary.Dataset'><p>Dataset Summary</p></a></li>
<li><a href='#summary.ParameterSet'><p>Parameter Set Summary</p></a></li>
<li><a href='#summary.TrialDesignSet'><p>Trial Design Set Summary</p></a></li>
<li><a href='#SummaryFactory'><p>Summary Factory</p></a></li>
<li><a href='#test_plan_section'><p>Test Plan Section</p></a></li>
<li><a href='#testPackage'><p>Test Package</p></a></li>
<li><a href='#TrialDesign'><p>Basic Trial Design</p></a></li>
<li><a href='#TrialDesignCharacteristics'><p>Trial Design Characteristics</p></a></li>
<li><a href='#TrialDesignConditionalDunnett'><p>Conditional Dunnett Design</p></a></li>
<li><a href='#TrialDesignFisher'><p>Fisher Design</p></a></li>
<li><a href='#TrialDesignGroupSequential'><p>Group Sequential Design</p></a></li>
<li><a href='#TrialDesignInverseNormal'><p>Inverse Normal Design</p></a></li>
<li><a href='#TrialDesignPlan'><p>Basic Trial Design Plan</p></a></li>
<li><a href='#TrialDesignPlanCountData'><p>Trial Design Plan Count Data</p></a></li>
<li><a href='#TrialDesignPlanMeans'><p>Trial Design Plan Means</p></a></li>
<li><a href='#TrialDesignPlanRates'><p>Trial Design Plan Rates</p></a></li>
<li><a href='#TrialDesignPlanSurvival'><p>Trial Design Plan Survival</p></a></li>
<li><a href='#TrialDesignSet'><p>Class for trial design sets.</p></a></li>
<li><a href='#utilitiesForPiecewiseExponentialDistribution'><p>The Piecewise Exponential Distribution</p></a></li>
<li><a href='#utilitiesForSurvivalTrials'><p>Survival Helper Functions for Conversion of Pi, Lambda, Median</p></a></li>
<li><a href='#writeDataset'><p>Write Dataset</p></a></li>
<li><a href='#writeDatasets'><p>Write Multiple Datasets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Confirmatory Adaptive Clinical Trial Design and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>4.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Design and analysis of confirmatory adaptive clinical trials with continuous, binary, and survival endpoints according to the methods described in the monograph by Wassmer and Brannath (2016) &lt;<a href="https://doi.org/10.1007%2F978-3-319-32562-0">doi:10.1007/978-3-319-32562-0</a>&gt;. This includes classical group sequential as well as multi-stage adaptive hypotheses tests that are based on the combination testing principle.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rpact.org">https://www.rpact.org</a>, <a href="https://www.rpact.com">https://www.rpact.com</a>,
<a href="https://github.com/rpact-com/rpact">https://github.com/rpact-com/rpact</a>,
<a href="https://rpact-com.github.io/rpact/">https://rpact-com.github.io/rpact/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rpact-com/rpact/issues">https://github.com/rpact-com/rpact/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, graphics, tools, rlang, R6 (&ge; 2.5.1),
knitr (&ge; 1.19), Rcpp (&ge; 1.0.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2 (&ge; 3.2.0), testthat (&ge; 3.0.0), rmarkdown (&ge; 1.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>*analysis*</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'f_logger.R' 'class_dictionary.R'
'f_core_constants.R' 'f_core_utilities.R' 'f_core_assertions.R'
'f_analysis_utilities.R' 'f_parameter_set_utilities.R'
'class_core_parameter_set.R' 'class_core_plot_settings.R'
'f_core_plot.R' 'class_design.R' 'f_object_r_code.R'
'f_analysis_base.R' 'class_analysis_dataset.R'
'class_analysis_stage_results.R' 'class_analysis_results.R'
'f_design_general_utilities.R' 'class_time.R'
'class_design_set.R' 'class_design_plan.R'
'class_design_power_and_asn.R' 'class_event_probabilities.R'
'f_simulation_base_count_data.R' 'f_simulation_utilities.R'
'f_simulation_base_survival.R' 'class_simulation_results.R'
'class_performance_score.R' 'class_summary.R' 'data.R'
'f_analysis_base_means.R' 'f_analysis_base_rates.R'
'f_analysis_base_survival.R' 'f_analysis_enrichment.R'
'f_analysis_enrichment_means.R' 'f_analysis_enrichment_rates.R'
'f_analysis_enrichment_survival.R' 'f_analysis_multiarm.R'
'f_analysis_multiarm_means.R' 'f_analysis_multiarm_rates.R'
'f_analysis_multiarm_survival.R' 'f_as251.R'
'f_core_output_formats.R' 'f_design_fisher_combination_test.R'
'f_design_group_sequential.R' 'f_design_plan_count_data.R'
'f_design_plan_means.R' 'f_design_plan_plot.R'
'f_design_plan_rates.R' 'f_design_plan_survival.R'
'f_design_plan_utilities.R' 'f_quality_assurance.R'
'f_simulation_base_means.R' 'f_simulation_base_rates.R'
'f_simulation_calc_subjects_function.R'
'f_simulation_enrichment.R' 'f_simulation_enrichment_means.R'
'f_simulation_enrichment_rates.R'
'f_simulation_enrichment_survival.R' 'f_simulation_multiarm.R'
'f_simulation_multiarm_means.R' 'f_simulation_multiarm_rates.R'
'f_simulation_multiarm_survival.R'
'f_simulation_performance_score.R' 'f_simulation_plot.R'
'parameter_descriptions.R' 'pkgname.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-27 10:02:02 UTC; fried</td>
</tr>
<tr>
<td>Author:</td>
<td>Gernot Wassmer <a href="https://orcid.org/0000-0001-9397-1794"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Friedrich Pahlke <a href="https://orcid.org/0000-0003-2105-2582"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Till Jensen [ctb],
  Stephen Schueuerhuis [ctb],
  Tobias Muetze <a href="https://orcid.org/0000-0002-4111-1941"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Friedrich Pahlke &lt;friedrich.pahlke@rpact.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-27 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rpact'>rpact - Confirmatory Adaptive Clinical Trial Design and Analysis</h2><span id='topic+rpact-package'></span><span id='topic+rpact'></span>

<h3>Description</h3>

<p>rpact (R Package for Adaptive Clinical Trials) is a comprehensive package that enables
the design, simulation, and analysis of confirmatory adaptive group sequential designs.
Particularly, the methods described in the recent monograph by Wassmer and Brannath
(published by Springer, 2016) are implemented. It also comprises advanced methods for sample
size calculations for fixed sample size designs incl., e.g., sample size calculation for survival
trials with piecewise exponentially distributed survival times and staggered patients entry.
</p>


<h3>Details</h3>

<p>rpact includes the classical group sequential designs (incl. user spending function approaches)
where the sample sizes per stage (or the time points of interim analysis) cannot be changed
in a data-driven way.
Confirmatory adaptive designs explicitly allow for this under control of the Type I error rate.
They are either based on the combination testing or the conditional rejection
probability (CRP) principle.
Both are available, for the former the inverse normal combination test and
Fisher's combination test can be used.
</p>
<p>Specific techniques of the adaptive methodology are also available, e.g.,
overall confidence intervals, overall p-values, and conditional and predictive power assessments.
Simulations can be performed to assess the design characteristics of a (user-defined) sample size
recalculation strategy. Designs are available for trials with continuous, binary, and survival endpoint.
</p>
<p>For more information please visit <a href="https://www.rpact.org">www.rpact.org</a>.
If you are interested in professional services round about the package or need
a comprehensive validation documentation to fulfill regulatory requirements
please visit <a href="https://www.rpact.com">www.rpact.com</a>.
</p>
<p>rpact is developed by
</p>

<ul>
<li><p> Gernot Wassmer (<a href="mailto:gernot.wassmer@rpact.com">gernot.wassmer@rpact.com</a>) and
</p>
</li>
<li><p> Friedrich Pahlke (<a href="mailto:friedrich.pahlke@rpact.com">friedrich.pahlke@rpact.com</a>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gernot Wassmer, Friedrich Pahlke
</p>


<h3>References</h3>

<p>Wassmer, G., Brannath, W. (2016) Group Sequential and Confirmatory Adaptive Designs
in Clinical Trials (Springer Series in Pharmaceutical Statistics; <a href="https://doi.org/10.1007/978-3-319-32562-0">doi:10.1007/978-3-319-32562-0</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.rpact.org">https://www.rpact.org</a>
</p>
</li>
<li> <p><a href="https://www.rpact.com">https://www.rpact.com</a>
</p>
</li>
<li> <p><a href="https://github.com/rpact-com/rpact">https://github.com/rpact-com/rpact</a>
</p>
</li>
<li> <p><a href="https://rpact-com.github.io/rpact/">https://rpact-com.github.io/rpact/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rpact-com/rpact/issues">https://github.com/rpact-com/rpact/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AccrualTime'>Accrual Time</h2><span id='topic+AccrualTime'></span>

<h3>Description</h3>

<p>Class for the definition of accrual time and accrual intensity.
</p>


<h3>Details</h3>

<p><code>AccrualTime</code> is a class for the definition of accrual time and accrual intensity.
</p>


<h3>Fields</h3>


<dl>
<dt><code>endOfAccrualIsUserDefined</code></dt><dd><p>If <code>TRUE</code>, the end of accrual has to be defined by the user (i.e., the length of <code>accrualTime</code> is equal to the length of <code>accrualIntensity -1</code>). Is a logical vector of length 1.</p>
</dd>
<dt><code>followUpTimeMustBeUserDefined</code></dt><dd><p>Specifies whether follow up time needs to be defined or not. Is a logical vector of length 1.</p>
</dd>
<dt><code>maxNumberOfSubjectsIsUserDefined</code></dt><dd><p>If <code>TRUE</code>, the maximum number of subjects has been specified by the user, if <code>FALSE</code>, it was calculated.</p>
</dd>
<dt><code>maxNumberOfSubjectsCanBeCalculatedDirectly</code></dt><dd><p>If <code>TRUE</code>, the maximum number of subjects can directly be calculated. Is a logical vector of length 1.</p>
</dd>
<dt><code>absoluteAccrualIntensityEnabled</code></dt><dd><p>If <code>TRUE</code>, absolute accrual intensity is enabled. Is a logical vector of length 1.</p>
</dd>
<dt><code>accrualTime</code></dt><dd><p>The assumed accrual time intervals for the study. Is a numeric vector.</p>
</dd>
<dt><code>accrualIntensity</code></dt><dd><p>The absolute accrual intensities. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>accrualIntensityRelative</code></dt><dd><p>The relative accrual intensities.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>remainingTime</code></dt><dd><p>In survival designs, the remaining time for observation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>piecewiseAccrualEnabled</code></dt><dd><p>Indicates whether piecewise accrual is selected. Is a logical vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResults'>Basic Class for Analysis Results</h2><span id='topic+AnalysisResults'></span>

<h3>Description</h3>

<p>A basic class for analysis results.
</p>


<h3>Details</h3>

<p><code>AnalysisResults</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+AnalysisResultsFisher">AnalysisResultsFisher</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsGroupSequential">AnalysisResultsGroupSequential</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsInverseNormal">AnalysisResultsInverseNormal</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsMultiArmFisher">AnalysisResultsMultiArmFisher</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsMultiArmInverseNormal">AnalysisResultsMultiArmInverseNormal</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsConditionalDunnett">AnalysisResultsConditionalDunnett</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsEnrichmentFisher">AnalysisResultsEnrichmentFisher</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsEnrichmentInverseNormal">AnalysisResultsEnrichmentInverseNormal</a></code>.
</p>
</li></ul>


<hr>
<h2 id='AnalysisResultsConditionalDunnett'>Analysis Results Multi-Arm Conditional Dunnett</h2><span id='topic+AnalysisResultsConditionalDunnett'></span>

<h3>Description</h3>

<p>Class for multi-arm analysis results based on a conditional Dunnett test design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the multi-arm analysis results of a conditional Dunnett test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDevs</code></dt><dd><p>Assumed standard deviations to calculate conditional power in multi-arm trials or enrichment designs. Is a numeric vector.</p>
</dd>
<dt><code>piTreatments</code></dt><dd><p>The assumed rates in the treatment groups for multi-arm and enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple (i.e., &gt;2) treatment arms or population enrichment designs when testing means. Available options for multiple arms: <code>"overallPooled", "pairwisePooled", "notPooled"</code>. Available options for enrichment designs: <code>"pooled", "pooledFromFull", "notPooled"</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>piControl</code></dt><dd><p>The assumed probability in the control arm for simulation and under which the sample size recalculation is performed. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsEnrichment'>Basic Class for Analysis Results Enrichment</h2><span id='topic+AnalysisResultsEnrichment'></span>

<h3>Description</h3>

<p>A basic class for enrichment analysis results.
</p>


<h3>Details</h3>

<p><code>AnalysisResultsEnrichment</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+AnalysisResultsEnrichmentFisher">AnalysisResultsEnrichmentFisher</a></code> and
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsEnrichmentInverseNormal">AnalysisResultsEnrichmentInverseNormal</a></code>.
</p>
</li></ul>


<hr>
<h2 id='AnalysisResultsEnrichmentFisher'>Analysis Results Enrichment Fisher</h2><span id='topic+AnalysisResultsEnrichmentFisher'></span>

<h3>Description</h3>

<p>Class for enrichment analysis results based on a Fisher combination test design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the multi-arm analysis results of a Fisher combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDevs</code></dt><dd><p>Assumed standard deviations to calculate conditional power in multi-arm trials or enrichment designs. Is a numeric vector.</p>
</dd>
<dt><code>piTreatments</code></dt><dd><p>The assumed rates in the treatment groups for multi-arm and enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple (i.e., &gt;2) treatment arms or population enrichment designs when testing means. Available options for multiple arms: <code>"overallPooled", "pairwisePooled", "notPooled"</code>. Available options for enrichment designs: <code>"pooled", "pooledFromFull", "notPooled"</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>piControls</code></dt><dd><p>The assumed rates in the control group for enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>conditionalPowerSimulated</code></dt><dd><p>The simulated conditional power, under the assumption of observed or assumed effect sizes.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen. When testing means and rates, a non-stratified analysis can be performed on overall data. For survival data, only a stratified analysis is possible. Is a logical vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsEnrichmentInverseNormal'>Analysis Results Enrichment Inverse Normal</h2><span id='topic+AnalysisResultsEnrichmentInverseNormal'></span>

<h3>Description</h3>

<p>Class for enrichment analysis results based on a inverse normal design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the enrichment analysis results of an inverse normal design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDevs</code></dt><dd><p>Assumed standard deviations to calculate conditional power in multi-arm trials or enrichment designs. Is a numeric vector.</p>
</dd>
<dt><code>piTreatments</code></dt><dd><p>The assumed rates in the treatment groups for multi-arm and enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple (i.e., &gt;2) treatment arms or population enrichment designs when testing means. Available options for multiple arms: <code>"overallPooled", "pairwisePooled", "notPooled"</code>. Available options for enrichment designs: <code>"pooled", "pooledFromFull", "notPooled"</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>piControls</code></dt><dd><p>The assumed rates in the control group for enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen. When testing means and rates, a non-stratified analysis can be performed on overall data. For survival data, only a stratified analysis is possible. Is a logical vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsFisher'>Analysis Results Fisher</h2><span id='topic+AnalysisResultsFisher'></span>

<h3>Description</h3>

<p>Class for analysis results based on a Fisher combination test design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the analysis results of a Fisher combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDev</code></dt><dd><p>The assumed standard deviation(s) for means analysis. Is a numeric vector.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>Describes if the variances in two treatment groups are assumed to be the same. Is a logical vector of length 1.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>finalStage</code></dt><dd><p>The stage at which the trial ends, either with acceptance or rejection of the null hypothesis. Is a numeric vector of length 1.</p>
</dd>
<dt><code>finalPValues</code></dt><dd><p>The final p-value that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>finalConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence interval that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>finalConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>medianUnbiasedEstimates</code></dt><dd><p>The calculated median unbiased estimates that are based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>conditionalPowerSimulated</code></dt><dd><p>The simulated conditional power, under the assumption of observed or assumed effect sizes.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsGroupSequential'>Analysis Results Group Sequential</h2><span id='topic+AnalysisResultsGroupSequential'></span>

<h3>Description</h3>

<p>Class for analysis results results based on a group sequential design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the analysis results of a group sequential design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDev</code></dt><dd><p>The assumed standard deviation(s) for means analysis. Is a numeric vector.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>Describes if the variances in two treatment groups are assumed to be the same. Is a logical vector of length 1.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>finalStage</code></dt><dd><p>The stage at which the trial ends, either with acceptance or rejection of the null hypothesis. Is a numeric vector of length 1.</p>
</dd>
<dt><code>finalPValues</code></dt><dd><p>The final p-value that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>finalConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence interval that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>finalConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>medianUnbiasedEstimates</code></dt><dd><p>The calculated median unbiased estimates that are based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>maxInformation</code></dt><dd><p>The maximum information. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>informationEpsilon</code></dt><dd><p>The absolute information epsilon, which defines the maximum distance from the observed information to the maximum information that causes the final analysis. Updates at the final analysis if the observed information at the final analysis is smaller (&quot;under-running&quot;) than the planned maximum information. Is either a positive integer value specifying the absolute information epsilon or a floating point number &gt;0 and &lt;1 to define a relative information epsilon.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsInverseNormal'>Analysis Results Inverse Normal</h2><span id='topic+AnalysisResultsInverseNormal'></span>

<h3>Description</h3>

<p>Class for analysis results results based on an inverse normal design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the analysis results of a inverse normal design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDev</code></dt><dd><p>The assumed standard deviation(s) for means analysis. Is a numeric vector.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>Describes if the variances in two treatment groups are assumed to be the same. Is a logical vector of length 1.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>finalStage</code></dt><dd><p>The stage at which the trial ends, either with acceptance or rejection of the null hypothesis. Is a numeric vector of length 1.</p>
</dd>
<dt><code>finalPValues</code></dt><dd><p>The final p-value that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>finalConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence interval that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>finalConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that is based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>medianUnbiasedEstimates</code></dt><dd><p>The calculated median unbiased estimates that are based on the stage-wise ordering. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsMultiArm'>Basic Class for Analysis Results Multi-Arm</h2><span id='topic+AnalysisResultsMultiArm'></span>

<h3>Description</h3>

<p>A basic class for multi-arm analysis results.
</p>


<h3>Details</h3>

<p><code>AnalysisResultsMultiArm</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+AnalysisResultsMultiArmFisher">AnalysisResultsMultiArmFisher</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsMultiArmInverseNormal">AnalysisResultsMultiArmInverseNormal</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsConditionalDunnett">AnalysisResultsConditionalDunnett</a></code>.
</p>
</li></ul>


<hr>
<h2 id='AnalysisResultsMultiArmFisher'>Analysis Results Multi-Arm Fisher</h2><span id='topic+AnalysisResultsMultiArmFisher'></span>

<h3>Description</h3>

<p>Class for multi-arm analysis results based on a Fisher combination test design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the multi-arm analysis results of a Fisher combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDevs</code></dt><dd><p>Assumed standard deviations to calculate conditional power in multi-arm trials or enrichment designs. Is a numeric vector.</p>
</dd>
<dt><code>piTreatments</code></dt><dd><p>The assumed rates in the treatment groups for multi-arm and enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple (i.e., &gt;2) treatment arms or population enrichment designs when testing means. Available options for multiple arms: <code>"overallPooled", "pairwisePooled", "notPooled"</code>. Available options for enrichment designs: <code>"pooled", "pooledFromFull", "notPooled"</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>piControl</code></dt><dd><p>The assumed probability in the control arm for simulation and under which the sample size recalculation is performed. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>conditionalPowerSimulated</code></dt><dd><p>The simulated conditional power, under the assumption of observed or assumed effect sizes.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsMultiArmInverseNormal'>Analysis Results Multi-Arm Inverse Normal</h2><span id='topic+AnalysisResultsMultiArmInverseNormal'></span>

<h3>Description</h3>

<p>Class for multi-arm analysis results based on a inverse normal design.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the multi-arm analysis results of an inverse normal design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDevs</code></dt><dd><p>Assumed standard deviations to calculate conditional power in multi-arm trials or enrichment designs. Is a numeric vector.</p>
</dd>
<dt><code>piTreatments</code></dt><dd><p>The assumed rates in the treatment groups for multi-arm and enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple (i.e., &gt;2) treatment arms or population enrichment designs when testing means. Available options for multiple arms: <code>"overallPooled", "pairwisePooled", "notPooled"</code>. Available options for enrichment designs: <code>"pooled", "pooledFromFull", "notPooled"</code>.</p>
</dd>
<dt><code>conditionalRejectionProbabilities</code></dt><dd><p>The probabilities of rejecting the null hypothesis at each stage, given the stage has been reached. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>repeatedConfidenceIntervalLowerBounds</code></dt><dd><p>The lower bound of the confidence intervals that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedConfidenceIntervalUpperBounds</code></dt><dd><p>The upper bound of the confidence interval that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>repeatedPValues</code></dt><dd><p>The p-values that are calculated at any stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>piControl</code></dt><dd><p>The assumed probability in the control arm for simulation and under which the sample size recalculation is performed. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
</dl>

<hr>
<h2 id='AnalysisResultsMultiHypotheses'>Basic Class for Analysis Results Multi-Hypotheses</h2><span id='topic+AnalysisResultsMultiHypotheses'></span>

<h3>Description</h3>

<p>A basic class for multi-hypotheses analysis results.
</p>


<h3>Details</h3>

<p><code>AnalysisResultsMultiHypotheses</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+AnalysisResultsMultiArm">AnalysisResultsMultiArm</a></code> and
</p>
</li>
<li> <p><code><a href="#topic+AnalysisResultsEnrichment">AnalysisResultsEnrichment</a></code>.
</p>
</li></ul>


<hr>
<h2 id='as.data.frame.AnalysisResults'>Coerce AnalysisResults to a Data Frame</h2><span id='topic+as.data.frame.AnalysisResults'></span>

<h3>Description</h3>

<p>Returns the <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnalysisResults'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  ...,
  niceColumnNamesEnabled = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.AnalysisResults_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object created by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.AnalysisResults_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="as.data.frame.AnalysisResults_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces the analysis results to a data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>

<hr>
<h2 id='as.data.frame.ParameterSet'>Coerce Parameter Set to a Data Frame</h2><span id='topic+as.data.frame.ParameterSet'></span>

<h3>Description</h3>

<p>Returns the <code>ParameterSet</code> as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ParameterSet'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  niceColumnNamesEnabled = FALSE,
  includeAllParameters = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.ParameterSet_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+FieldSet">FieldSet</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.ParameterSet_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.ParameterSet_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.ParameterSet_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces the parameter set to a data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>

<hr>
<h2 id='as.data.frame.PowerAndAverageSampleNumberResult'>Coerce Power And Average Sample Number Result to a Data Frame</h2><span id='topic+as.data.frame.PowerAndAverageSampleNumberResult'></span>

<h3>Description</h3>

<p>Returns the <code><a href="#topic+PowerAndAverageSampleNumberResult">PowerAndAverageSampleNumberResult</a></code> as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PowerAndAverageSampleNumberResult'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  niceColumnNamesEnabled = FALSE,
  includeAllParameters = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.PowerAndAverageSampleNumberResult_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PowerAndAverageSampleNumberResult">PowerAndAverageSampleNumberResult</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.PowerAndAverageSampleNumberResult_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.PowerAndAverageSampleNumberResult_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.PowerAndAverageSampleNumberResult_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces the <code><a href="#topic+PowerAndAverageSampleNumberResult">PowerAndAverageSampleNumberResult</a></code> object to a data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- as.data.frame(getPowerAndAverageSampleNumber(getDesignGroupSequential()))
head(data)
dim(data)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.data.frame.StageResults'>Coerce Stage Results to a Data Frame</h2><span id='topic+as.data.frame.StageResults'></span>

<h3>Description</h3>

<p>Returns the <code>StageResults</code> as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StageResults'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  niceColumnNamesEnabled = FALSE,
  includeAllParameters = FALSE,
  type = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.StageResults_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+StageResults">StageResults</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.StageResults_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.StageResults_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.StageResults_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces the stage results to a data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>

<hr>
<h2 id='as.data.frame.TrialDesign'>Coerce TrialDesign to a Data Frame</h2><span id='topic+as.data.frame.TrialDesign'></span>

<h3>Description</h3>

<p>Returns the <code>TrialDesign</code> as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesign'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  niceColumnNamesEnabled = FALSE,
  includeAllParameters = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.TrialDesign_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TrialDesign">TrialDesign</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesign_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesign_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesign_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the <code><a href="#topic+TrialDesign">TrialDesign</a></code> is
converted to a column in the data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
as.data.frame(getDesignGroupSequential())

## End(Not run)

</code></pre>

<hr>
<h2 id='as.data.frame.TrialDesignCharacteristics'>Coerce TrialDesignCharacteristics to a Data Frame</h2><span id='topic+as.data.frame.TrialDesignCharacteristics'></span>

<h3>Description</h3>

<p>Returns the <code>TrialDesignCharacteristics</code> as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignCharacteristics'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  niceColumnNamesEnabled = FALSE,
  includeAllParameters = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.TrialDesignCharacteristics_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TrialDesignCharacteristics">TrialDesignCharacteristics</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignCharacteristics_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignCharacteristics_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignCharacteristics_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the <code><a href="#topic+TrialDesignCharacteristics">TrialDesignCharacteristics</a></code> is converted to a column in the data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
as.data.frame(getDesignCharacteristics(getDesignGroupSequential()))

## End(Not run)

</code></pre>

<hr>
<h2 id='as.data.frame.TrialDesignPlan'>Coerce Trial Design Plan to a Data Frame</h2><span id='topic+as.data.frame.TrialDesignPlan'></span>

<h3>Description</h3>

<p>Returns the <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignPlan'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  niceColumnNamesEnabled = FALSE,
  includeAllParameters = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.TrialDesignPlan_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignPlan_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignPlan_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignPlan_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces the design plan to a data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
as.data.frame(getSampleSizeMeans())

## End(Not run)

</code></pre>

<hr>
<h2 id='as.data.frame.TrialDesignSet'>Coerce Trial Design Set to a Data Frame</h2><span id='topic+as.data.frame.TrialDesignSet'></span>

<h3>Description</h3>

<p>Returns the <code>TrialDesignSet</code> as data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignSet'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  niceColumnNamesEnabled = FALSE,
  includeAllParameters = FALSE,
  addPowerAndAverageSampleNumber = FALSE,
  theta = seq(-1, 1, 0.02),
  nMax = NA_integer_,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.TrialDesignSet_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TrialDesignSet">TrialDesignSet</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignSet_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignSet_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignSet_+3A_addpowerandaveragesamplenumber">addPowerAndAverageSampleNumber</code></td>
<td>
<p>If <code>TRUE</code>, power and average sample size will
be added to data frame, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignSet_+3A_theta">theta</code></td>
<td>
<p>A vector of standardized effect sizes (theta values), default is a sequence from -1 to 1.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignSet_+3A_nmax">nMax</code></td>
<td>
<p>The maximum sample size. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="as.data.frame.TrialDesignSet_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces the design set to a data frame.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
designSet &lt;- getDesignSet(design = getDesignGroupSequential(), alpha = c(0.01, 0.05))
as.data.frame(designSet)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.matrix.FieldSet'>Coerce Field Set to a Matrix</h2><span id='topic+as.matrix.FieldSet'></span>

<h3>Description</h3>

<p>Returns the <code>FrameSet</code> as matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FieldSet'
as.matrix(x, ..., enforceRowNames = TRUE, niceColumnNamesEnabled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.FieldSet_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+FieldSet">FieldSet</a></code> object.</p>
</td></tr>
<tr><td><code id="as.matrix.FieldSet_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="as.matrix.FieldSet_+3A_enforcerownames">enforceRowNames</code></td>
<td>
<p>If <code>TRUE</code>, row names will be created
depending on the object type, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.matrix.FieldSet_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coerces the frame set to a matrix.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>

<hr>
<h2 id='as251Normal'>Algorithm AS 251: Normal Distribution</h2><span id='topic+as251Normal'></span>

<h3>Description</h3>

<p>Calculates the Multivariate Normal Distribution with Product Correlation Structure published
by Charles Dunnett, Algorithm AS 251.1 Appl.Statist. (1989), Vol.38, No.3, <a href="https://doi.org/10.2307/2347754">doi:10.2307/2347754</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as251Normal(
  lower,
  upper,
  sigma,
  ...,
  eps = 1e-06,
  errorControl = c("strict", "halvingIntervals"),
  intervalSimpsonsRule = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as251Normal_+3A_lower">lower</code></td>
<td>
<p>Lower limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="as251Normal_+3A_upper">upper</code></td>
<td>
<p>Upper limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="as251Normal_+3A_sigma">sigma</code></td>
<td>
<p>Values defining correlation structure. Array of N dimensions</p>
</td></tr>
<tr><td><code id="as251Normal_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="as251Normal_+3A_eps">eps</code></td>
<td>
<p>desired accuracy. Defaults to 1e-06</p>
</td></tr>
<tr><td><code id="as251Normal_+3A_errorcontrol">errorControl</code></td>
<td>
<p>error control. If set to 1, strict error control based on
fourth derivative is used. If set to zero, error control based on halving intervals is used</p>
</td></tr>
<tr><td><code id="as251Normal_+3A_intervalsimpsonsrule">intervalSimpsonsRule</code></td>
<td>
<p>Interval width for Simpson's rule. Value of zero caused a default .24 to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a multivariate normal vector with correlation structure
defined by rho(i,j) = bpd(i) * bpd(j), computes the probability
that the vector falls in a rectangle in n-space with error
less than eps.
</p>
<p>This function calculates the <code>bdp</code> value from <code>sigma</code>, determines the right <code>inf</code> value and calls <code><a href="#topic+mvnprd">mvnprd</a></code>.
</p>

<hr>
<h2 id='as251StudentT'>Algorithm AS 251: Student T Distribution</h2><span id='topic+as251StudentT'></span>

<h3>Description</h3>

<p>Calculates the Multivariate Normal Distribution with Product Correlation Structure published
by Charles Dunnett, Algorithm AS 251.1 Appl.Statist. (1989), Vol.38, No.3, <a href="https://doi.org/10.2307/2347754">doi:10.2307/2347754</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as251StudentT(
  lower,
  upper,
  sigma,
  ...,
  df,
  eps = 1e-06,
  errorControl = c("strict", "halvingIntervals"),
  intervalSimpsonsRule = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as251StudentT_+3A_lower">lower</code></td>
<td>
<p>Lower limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="as251StudentT_+3A_upper">upper</code></td>
<td>
<p>Upper limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="as251StudentT_+3A_sigma">sigma</code></td>
<td>
<p>Values defining correlation structure. Array of N dimensions</p>
</td></tr>
<tr><td><code id="as251StudentT_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="as251StudentT_+3A_df">df</code></td>
<td>
<p>Degrees of Freedom. Use 0 for infinite D.F.</p>
</td></tr>
<tr><td><code id="as251StudentT_+3A_eps">eps</code></td>
<td>
<p>desired accuracy. Defaults to 1e-06</p>
</td></tr>
<tr><td><code id="as251StudentT_+3A_errorcontrol">errorControl</code></td>
<td>
<p>error control. If set to 1, strict error control based on
fourth derivative is used. If set to zero, error control based on halving intervals is used</p>
</td></tr>
<tr><td><code id="as251StudentT_+3A_intervalsimpsonsrule">intervalSimpsonsRule</code></td>
<td>
<p>Interval width for Simpson's rule. Value of zero caused a default .24 to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a multivariate normal vector with correlation structure
defined by rho(i,j) = bpd(i) * bpd(j), computes the probability
that the vector falls in a rectangle in n-space with error
less than eps.
</p>
<p>This function calculates the <code>bdp</code> value from <code>sigma</code>, determines the right <code>inf</code> value and calls <code><a href="#topic+mvstud">mvstud</a></code>.
</p>

<hr>
<h2 id='ClosedCombinationTestResults'>Analysis Results Closed Combination Test</h2><span id='topic+ClosedCombinationTestResults'></span>

<h3>Description</h3>

<p>Class for multi-arm analysis results based on a closed combination test.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getAnalysisResults">getAnalysisResults</a></code>
with suitable arguments to create the multi-arm analysis results of a closed combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>indices</code></dt><dd><p>Indicates which stages are available for analysis.</p>
</dd>
<dt><code>adjustedStageWisePValues</code></dt><dd><p>The multiplicity adjusted p-values from the separate stages. Is a numeric matrix.</p>
</dd>
<dt><code>overallAdjustedTestStatistics</code></dt><dd><p>The overall adjusted test statistics.</p>
</dd>
<dt><code>separatePValues</code></dt><dd><p>The p-values from the separate stages. Is a numeric matrix.</p>
</dd>
<dt><code>conditionalErrorRate</code></dt><dd><p>The calculated conditional error rate.</p>
</dd>
<dt><code>secondStagePValues</code></dt><dd><p>For conditional Dunnett test, the conditional or unconditional p-value calculated for the second stage.</p>
</dd>
<dt><code>rejected</code></dt><dd><p>Indicates whether a hypothesis is rejected or not.</p>
</dd>
<dt><code>rejectedIntersections</code></dt><dd><p>The simulated number of rejected arms in the closed testing procedure.. Is a logical matrix.</p>
</dd>
</dl>

<hr>
<h2 id='ConditionalPowerResults'>Conditional Power Results</h2><span id='topic+ConditionalPowerResults'></span>

<h3>Description</h3>

<p>Class for conditional power calculations
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getConditionalPower">getConditionalPower()</a></code>
with suitable arguments to create the results of a group sequential or a combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>simulated</code></dt><dd><p>Describes if the power for Fisher's combination test has been simulated. Only applicable when using Fisher designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDev</code></dt><dd><p>The assumed standard deviation(s) for means analysis. Is a numeric vector.</p>
</dd>
</dl>

<hr>
<h2 id='ConditionalPowerResultsEnrichmentMeans'>Conditional Power Results Enrichment Means</h2><span id='topic+ConditionalPowerResultsEnrichmentMeans'></span>

<h3>Description</h3>

<p>Class for conditional power calculations of enrichment means data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getConditionalPower">getConditionalPower</a></code>
with suitable arguments to create the results of a group sequential or a combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>simulated</code></dt><dd><p>Describes if the power for Fisher's combination test has been simulated. Only applicable when using Fisher designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDevs</code></dt><dd><p>Assumed standard deviations to calculate conditional power in multi-arm trials or enrichment designs. Is a numeric vector.</p>
</dd>
</dl>

<hr>
<h2 id='ConditionalPowerResultsEnrichmentRates'>Conditional Power Results Enrichment Rates</h2><span id='topic+ConditionalPowerResultsEnrichmentRates'></span>

<h3>Description</h3>

<p>Class for conditional power calculations of enrichment rates data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getConditionalPower">getConditionalPower</a></code>
with suitable arguments to create the results of a group sequential or a combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>simulated</code></dt><dd><p>Describes if the power for Fisher's combination test has been simulated. Only applicable when using Fisher designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>piTreatments</code></dt><dd><p>The assumed rates in the treatment groups for multi-arm and enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
<dt><code>piControls</code></dt><dd><p>The assumed rates in the control group for enrichment designs, i.e., designs with multiple subsets.</p>
</dd>
</dl>

<hr>
<h2 id='ConditionalPowerResultsMeans'>Conditional Power Results Means</h2><span id='topic+ConditionalPowerResultsMeans'></span>

<h3>Description</h3>

<p>Class for conditional power calculations of means data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getConditionalPower">getConditionalPower</a></code>
with suitable arguments to create the results of a group sequential or a combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>simulated</code></dt><dd><p>Describes if the power for Fisher's combination test has been simulated. Only applicable when using Fisher designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>assumedStDev</code></dt><dd><p>The assumed standard deviation(s) for means analysis. Is a numeric vector.</p>
</dd>
</dl>

<hr>
<h2 id='ConditionalPowerResultsRates'>Conditional Power Results Rates</h2><span id='topic+ConditionalPowerResultsRates'></span>

<h3>Description</h3>

<p>Class for conditional power calculations of rates data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getConditionalPower">getConditionalPower</a></code>
with suitable arguments to create the results of a group sequential or a combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>simulated</code></dt><dd><p>Describes if the power for Fisher's combination test has been simulated. Only applicable when using Fisher designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
</dl>

<hr>
<h2 id='ConditionalPowerResultsSurvival'>Conditional Power Results Survival</h2><span id='topic+ConditionalPowerResultsSurvival'></span>

<h3>Description</h3>

<p>Class for conditional power calculations of survival data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getConditionalPower">getConditionalPower</a></code>
with suitable arguments to create the results of a group sequential or a combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nPlanned</code></dt><dd><p>The sample size planned for each of the subsequent stages. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>simulated</code></dt><dd><p>Describes if the power for Fisher's combination test has been simulated. Only applicable when using Fisher designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
</dl>

<hr>
<h2 id='dataEnrichmentMeans'>Enrichment Dataset of Means</h2><span id='topic+dataEnrichmentMeans'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes, means, and standard deviations of two groups.
Use <code>getDataset(dataEnrichmentMeans)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataEnrichmentMeans
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataEnrichmentMeansStratified'>Stratified Enrichment Dataset of Means</h2><span id='topic+dataEnrichmentMeansStratified'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes, means, and standard deviations of two groups.
Use <code>getDataset(dataEnrichmentMeansStratified)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataEnrichmentMeansStratified
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataEnrichmentRates'>Enrichment Dataset of Rates</h2><span id='topic+dataEnrichmentRates'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes and events of two groups.
Use <code>getDataset(dataEnrichmentRates)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataEnrichmentRates
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataEnrichmentRatesStratified'>Stratified Enrichment Dataset of Rates</h2><span id='topic+dataEnrichmentRatesStratified'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes and events of two groups.
Use <code>getDataset(dataEnrichmentRatesStratified)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataEnrichmentRatesStratified
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataEnrichmentSurvival'>Enrichment Dataset of Survival Data</h2><span id='topic+dataEnrichmentSurvival'></span>

<h3>Description</h3>

<p>A dataset containing the log-rank statistics, events, and allocation ratios of two groups.
Use <code>getDataset(dataEnrichmentSurvival)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataEnrichmentSurvival
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataEnrichmentSurvivalStratified'>Stratified Enrichment Dataset of Survival Data</h2><span id='topic+dataEnrichmentSurvivalStratified'></span>

<h3>Description</h3>

<p>A dataset containing the log-rank statistics, events, and allocation ratios of two groups.
Use <code>getDataset(dataEnrichmentSurvivalStratified)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataEnrichmentSurvivalStratified
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataMeans'>One-Arm Dataset of Means</h2><span id='topic+dataMeans'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes, means, and standard deviations of one group.
Use <code>getDataset(dataMeans)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataMeans
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataMultiArmMeans'>Multi-Arm Dataset of Means</h2><span id='topic+dataMultiArmMeans'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes, means, and standard deviations of four groups.
Use <code>getDataset(dataMultiArmMeans)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataMultiArmMeans
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataMultiArmRates'>Multi-Arm Dataset of Rates</h2><span id='topic+dataMultiArmRates'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes and events of three groups.
Use <code>getDataset(dataMultiArmRates)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataMultiArmRates
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataMultiArmSurvival'>Multi-Arm Dataset of Survival Data</h2><span id='topic+dataMultiArmSurvival'></span>

<h3>Description</h3>

<p>A dataset containing the log-rank statistics, events, and allocation ratios of three groups.
Use <code>getDataset(dataMultiArmSurvival)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataMultiArmSurvival
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='dataRates'>One-Arm Dataset of Rates</h2><span id='topic+dataRates'></span>

<h3>Description</h3>

<p>A dataset containing the sample sizes and events of one group.
Use <code>getDataset(dataRates)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataRates
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='Dataset'>Dataset</h2><span id='topic+Dataset'></span>

<h3>Description</h3>

<p>Basic class for datasets.
</p>


<h3>Details</h3>

<p><code>Dataset</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+DatasetMeans">DatasetMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+DatasetRates">DatasetRates</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+DatasetSurvival">DatasetSurvival</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+DatasetEnrichmentSurvival">DatasetEnrichmentSurvival</a></code>.
</p>
</li></ul>

<p>This basic class contains the fields <code>stages</code> and <code>groups</code> and several commonly used
functions.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
</dl>

<hr>
<h2 id='DatasetMeans'>Dataset of Means</h2><span id='topic+DatasetMeans'></span>

<h3>Description</h3>

<p>Class for a dataset of means.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; better use <code><a href="#topic+getDataset">getDataset</a></code>
with suitable arguments to create a dataset of means.
</p>


<h3>Fields</h3>


<dl>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>means</code></dt><dd><p>The means. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>stDevs</code></dt><dd><p>The standard deviations. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallSampleSizes</code></dt><dd><p>The overall, i.e., cumulative sample sizes. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallMeans</code></dt><dd><p>The overall, i.e., cumulative means. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallStDevs</code></dt><dd><p>The overall, i.e., cumulative standard deviations. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
</dl>

<hr>
<h2 id='DatasetRates'>Dataset of Rates</h2><span id='topic+DatasetRates'></span>

<h3>Description</h3>

<p>Class for a dataset of rates.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; better use <code><a href="#topic+getDataset">getDataset</a></code>
with suitable arguments to create a dataset of rates.
</p>


<h3>Fields</h3>


<dl>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>overallSampleSizes</code></dt><dd><p>The overall, i.e., cumulative sample sizes. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>events</code></dt><dd><p>The number of events in each group at each stage. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallEvents</code></dt><dd><p>The overall, i.e., cumulative events. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
</dl>

<hr>
<h2 id='DatasetSurvival'>Dataset of Survival Data</h2><span id='topic+DatasetSurvival'></span><span id='topic+DatasetEnrichmentSurvival'></span>

<h3>Description</h3>

<p>Class for a dataset of survival data.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; better use <code><a href="#topic+getDataset">getDataset</a></code>
with suitable arguments to create a dataset of survival data.
</p>


<h3>Fields</h3>


<dl>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>events</code></dt><dd><p>The number of events in each group at each stage. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallEvents</code></dt><dd><p>The overall, i.e., cumulative events. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>allocationRatios</code></dt><dd><p>The observed allocation ratios. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallAllocationRatios</code></dt><dd><p>The cumulative allocation ratios. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>logRanks</code></dt><dd><p>The logrank test statistics at each stage of the trial. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallLogRanks</code></dt><dd><p>The overall, i.e., cumulative logrank test statistics. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
</dl>

<hr>
<h2 id='dataSurvival'>One-Arm Dataset of Survival Data</h2><span id='topic+dataSurvival'></span>

<h3>Description</h3>

<p>A dataset containing the log-rank statistics, events, and allocation ratios of one group.
Use <code>getDataset(dataSurvival)</code> to create a dataset object that can be processed by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataSurvival
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>

<hr>
<h2 id='EventProbabilities'>Event Probabilities</h2><span id='topic+EventProbabilities'></span>

<h3>Description</h3>

<p>Class for the definition of event probabilities.
</p>


<h3>Details</h3>

<p><code>EventProbabilities</code> is a class for the definition of event probabilities.
</p>


<h3>Fields</h3>


<dl>
<dt><code>time</code></dt><dd><p>The time values. Is a numeric vector.</p>
</dd>
<dt><code>accrualTime</code></dt><dd><p>The assumed accrual time intervals for the study. Is a numeric vector.</p>
</dd>
<dt><code>accrualIntensity</code></dt><dd><p>The absolute accrual intensities. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>kappa</code></dt><dd><p>The shape of the Weibull distribution if <code>kappa!=1</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>piecewiseSurvivalTime</code></dt><dd><p>The time intervals for the piecewise definition of the exponential survival time cumulative distribution function. Is a numeric vector.</p>
</dd>
<dt><code>lambda1</code></dt><dd><p>The assumed hazard rate in the treatment group. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>lambda2</code></dt><dd><p>The assumed hazard rate in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>hazardRatio</code></dt><dd><p>The hazard ratios under consideration. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>dropoutRate1</code></dt><dd><p>The assumed drop-out rate in the treatment group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>dropoutRate2</code></dt><dd><p>The assumed drop-out rate in the control group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>dropoutTime</code></dt><dd><p>The assumed time for drop-out rates in the control and treatment group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>overallEventProbabilities</code></dt><dd><p>Deprecated field which will be removed in one of the next releases. Use <code>cumulativeEventProbabilities</code> instead.</p>
</dd>
<dt><code>cumulativeEventProbabilities</code></dt><dd><p>The cumulative event probabilities in survival designs. Is a numeric vector.</p>
</dd>
<dt><code>eventProbabilities1</code></dt><dd><p>The event probabilities in treatment group 1. Is a numeric vector.</p>
</dd>
<dt><code>eventProbabilities2</code></dt><dd><p>The event probabilities in treatment group 2. Is a numeric vector.</p>
</dd>
</dl>

<hr>
<h2 id='FieldSet'>Field Set</h2><span id='topic+FieldSet'></span>

<h3>Description</h3>

<p>Basic class for field sets.
</p>


<h3>Details</h3>

<p>The field set implements basic functions for a set of fields.
</p>

<hr>
<h2 id='getAccrualTime'>Get Accrual Time</h2><span id='topic+getAccrualTime'></span>

<h3>Description</h3>

<p>Returns an <code>AccrualTime</code> object that contains the accrual time and the accrual intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAccrualTime(
  accrualTime = NA_real_,
  ...,
  accrualIntensity = NA_real_,
  accrualIntensityType = c("auto", "absolute", "relative"),
  maxNumberOfSubjects = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAccrualTime_+3A_accrualtime">accrualTime</code></td>
<td>
<p>The assumed accrual time intervals for the study, default is
<code>c(0, 12)</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getAccrualTime_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getAccrualTime_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>A numeric vector of accrual intensities, default is the relative
intensity <code>0.1</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getAccrualTime_+3A_accrualintensitytype">accrualIntensityType</code></td>
<td>
<p>A character value specifying the accrual intensity input type.
Must be one of <code>"auto"</code>, <code>"absolute"</code>, or <code>"relative"</code>; default is <code>"auto"</code>,
i.e., if all values are &lt; 1 the type is <code>"relative"</code>, otherwise it is <code>"absolute"</code>.</p>
</td></tr>
<tr><td><code id="getAccrualTime_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p>The maximum number of subjects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AccrualTime">AccrualTime</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.ParameterSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Staggered patient entry</h3>

<p><code>accrualTime</code> is the time period of subjects' accrual in a study.
It can be a value that defines the end of accrual or a vector.
In this case, <code>accrualTime</code> can be used to define a non-constant accrual over time.
For this, <code>accrualTime</code> is a vector that defines the accrual intervals.
The first element of <code>accrualTime</code> must be equal to <code>0</code> and, additionally,
<code>accrualIntensity</code> needs to be specified.
<code>accrualIntensity</code> itself is a value or a vector (depending on the
length of <code>accrualTime</code>) that defines the intensity how subjects
enter the trial in the intervals defined through <code>accrualTime</code>.
</p>
<p><code>accrualTime</code> can also be a list that combines the definition of the accrual time and
accrual intensity (see below and examples for details).
</p>
<p>If the length of <code>accrualTime</code> and the length of <code>accrualIntensity</code> are the same
(i.e., the end of accrual is undefined), <code>maxNumberOfSubjects &gt; 0</code> needs to be specified
and the end of accrual is calculated.
In that case, <code>accrualIntensity</code> is the number of subjects per time unit, i.e., the absolute accrual intensity.
</p>
<p>If the length of <code>accrualTime</code> equals the length of <code>accrualIntensity - 1</code>
(i.e., the end of accrual is defined), <code>maxNumberOfSubjects</code> is calculated if the absolute accrual intensity is given.
If all elements in <code>accrualIntensity</code> are smaller than 1, <code>accrualIntensity</code> defines
the <em>relative</em> intensity how subjects enter the trial.
For example, <code>accrualIntensity = c(0.1, 0.2)</code> specifies that in the second accrual interval
the intensity is doubled as compared to the first accrual interval. The actual (absolute) accrual intensity
is calculated for the calculated or given <code>maxNumberOfSubjects</code>.
Note that the default is <code>accrualIntensity = 0.1</code> meaning that the <em>absolute</em> accrual intensity
will be calculated.
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getNumberOfSubjects">getNumberOfSubjects()</a></code> for calculating the number of subjects at given time points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assume that in a trial the accrual after the first 6 months is doubled
# and the total accrual time is 30 months.
# Further assume that a total of 1000 subjects are entered in the trial.
# The number of subjects to be accrued in the first 6 months and afterwards
# is achieved through
getAccrualTime(
    accrualTime = c(0, 6, 30),
    accrualIntensity = c(0.1, 0.2), maxNumberOfSubjects = 1000
)

# The same result is obtained via the list based definition
getAccrualTime(
    list(
        "0 - &lt;6"   = 0.1,
        "6 - &lt;=30" = 0.2
    ),
    maxNumberOfSubjects = 1000
)

# Calculate the end of accrual at given absolute intensity:
getAccrualTime(
    accrualTime = c(0, 6),
    accrualIntensity = c(18, 36), maxNumberOfSubjects = 1000
)

# Via the list based definition this is
getAccrualTime(
    list(
        "0 - &lt;6" = 18,
        "&gt;=6" = 36
    ),
    maxNumberOfSubjects = 1000
)

# You can use an accrual time object in getSampleSizeSurvival() or
# getPowerSurvival().
# For example, if the maximum number of subjects and the follow up
# time needs to be calculated for a given effect size:
accrualTime &lt;- getAccrualTime(
    accrualTime = c(0, 6, 30),
    accrualIntensity = c(0.1, 0.2)
)
getSampleSizeSurvival(accrualTime = accrualTime, pi1 = 0.4, pi2 = 0.2)

# Or if the power and follow up time needs to be calculated for given
# number of events and subjects:
accrualTime &lt;- getAccrualTime(
    accrualTime = c(0, 6, 30),
    accrualIntensity = c(0.1, 0.2), maxNumberOfSubjects = 110
)
getPowerSurvival(
    accrualTime = accrualTime, pi1 = 0.4, pi2 = 0.2,
    maxNumberOfEvents = 46
)

# How to show accrual time details

# You can use a sample size or power object as argument for the function
# getAccrualTime():
sampleSize &lt;- getSampleSizeSurvival(
    accrualTime = c(0, 6), accrualIntensity = c(22, 53),
    lambda2 = 0.05, hazardRatio = 0.8, followUpTime = 6
)
sampleSize
accrualTime &lt;- getAccrualTime(sampleSize)
accrualTime

## End(Not run)

</code></pre>

<hr>
<h2 id='getAnalysisResults'>Get Analysis Results</h2><span id='topic+getAnalysisResults'></span>

<h3>Description</h3>

<p>Calculates and returns the analysis results for the specified design and data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnalysisResults(
  design,
  dataInput,
  ...,
  directionUpper = NA,
  thetaH0 = NA_real_,
  nPlanned = NA_real_,
  allocationRatioPlanned = 1,
  stage = NA_integer_,
  maxInformation = NULL,
  informationEpsilon = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAnalysisResults_+3A_design">design</code></td>
<td>
<p>The trial design.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_datainput">dataInput</code></td>
<td>
<p>The summary data used for calculating the test results.
This is either an element of <code>DatasetMeans</code>, of <code>DatasetRates</code>, or of <code>DatasetSurvival</code>
and should be created with the function <code><a href="#topic+getDataset">getDataset()</a></code>.
For more information see <code><a href="#topic+getDataset">getDataset()</a></code>.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods (cf., separate functions in &quot;See Also&quot; below), e.g.,
</p>

<dl>
<dt><code>thetaH1</code> and <code>stDevH1</code> (or <code>assumedStDev</code> / <code>assumedStDevs</code>),
<code>pi1</code>, <code>pi2</code>, or <code>piTreatments</code>, <code>piControl(s)</code></dt><dd>
<p>The assumed effect size, standard deviation or rates to calculate the conditional power if <code>nPlanned</code>
is specified. For survival designs, <code>thetaH1</code> refers to the hazard ratio.
For one-armed trials with binary outcome, only <code>pi1</code> can be specified, for two-armed trials with binary outcome,
<code>pi1</code> and <code>pi2</code> can be specified referring to the assumed treatment and control rate, respectively.
In multi-armed or enrichment designs, you can
specify a value or a vector with elements referring to the treatment arms or the sub-populations,
respectively. For testing rates, the parameters to be specified are <code>piTreatments</code> and <code>piControl</code>
(multi-arm designs) and <code>piTreatments</code> and <code>piControls</code> (enrichment designs).<br />
If not specified, the conditional power is calculated under the assumption of observed effect sizes,
standard deviations, rates, or hazard ratios.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>Iterations for simulating the power for Fisher's combination test.
If the power for more than one remaining stages is to be determined for
Fisher's combination test, it is estimated via simulation with specified <br />
<code>iterations</code>, the default is <code>1000</code>.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed for simulating the conditional power for Fisher's combination test.
See above, default is a random seed.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>The type of computation of the p-values. Default is <code>FALSE</code> for
testing means (i.e., the t test is used) and <code>TRUE</code> for testing rates and the hazard ratio.
For testing rates, if <code>normalApproximation = FALSE</code> is specified, the binomial test
(one sample) or the exact test of Fisher (two samples) is used for calculating the p-values.
In the survival setting, <code>normalApproximation = FALSE</code> has no effect.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>The type of t test. For testing means in two treatment groups, either
the t test assuming that the variances are equal or the t test without assuming this,
i.e., the test of Welch-Satterthwaite is calculated, default is <code>TRUE</code>.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses when testing multiple hypotheses.
Five options are available in multi-arm designs: <code>"Dunnett"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
<code>"Sidak"</code>, and <code>"Hierarchical"</code>, default is <code>"Dunnett"</code>.
Four options are available in population enrichment designs: <code>"SpiessensDebois"</code> (one subset only),
<code>"Bonferroni"</code>, <code>"Simes"</code>, and <code>"Sidak"</code>, default is <code>"Simes"</code>.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple treatment arms (&gt; 2)
or population enrichment designs for testing means. For multiple arms, three options are available:
<code>"overallPooled"</code>, <code>"pairwisePooled"</code>, and <code>"notPooled"</code>, default is <code>"overallPooled"</code>.
For enrichment designs, the options are: <code>"pooled"</code>, <code>"pooledFromFull"</code> (one subset only),
and <code>"notPooled"</code>, default is <code>"pooled"</code>.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen.
For testing means and rates, also a non-stratified analysis based on overall data can be performed.
For survival data, only a stratified analysis is possible (see Brannath et al., 2009), default is <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_nplanned">nPlanned</code></td>
<td>
<p>The additional (i.e., &quot;new&quot; and not cumulative) sample size planned for each of the subsequent stages.
The argument must be a vector with length equal to the number of remaining stages and contain
the combined sample size from both treatment groups if two groups are considered. For survival outcomes,
it should contain the planned number of additional events.
For multi-arm designs, it is the per-comparison (combined) sample size.
For enrichment designs, it is the (combined) sample size for the considered sub-population.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_stage">stage</code></td>
<td>
<p>The stage number (optional). Default: total number of existing stages in the data input.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_maxinformation">maxInformation</code></td>
<td>
<p>Positive integer value specifying the maximum information.</p>
</td></tr>
<tr><td><code id="getAnalysisResults_+3A_informationepsilon">informationEpsilon</code></td>
<td>
<p>Positive integer value specifying the absolute information epsilon, which
defines the maximum distance from the observed information to the maximum information that causes the final analysis.
Updates at the final analysis in case the observed information at the final
analysis is smaller (&quot;under-running&quot;) than the planned maximum information <code>maxInformation</code>, default is 0.
Alternatively, a floating-point number &gt; 0 and &lt; 1 can be specified to define a relative information epsilon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a design and a dataset, at given stage the function calculates the test results
(effect sizes, stage-wise test statistics and p-values, overall p-values and test statistics,
conditional rejection probability (CRP), conditional power, Repeated Confidence Intervals (RCIs),
repeated overall p-values, and final stage p-values, median unbiased effect estimates,
and final confidence intervals.
</p>
<p>For designs with more than two treatments arms (multi-arm designs) or enrichment designs
a closed combination test is performed.
That is, additionally the statistics to be used in a closed testing procedure are provided.
</p>
<p>The conditional power is calculated if the planned sample size for the subsequent stages (<code>nPlanned</code>)
is specified. The conditional power is calculated either under the assumption of the observed effect or
under the assumption of an assumed effect, that has to be specified (see above).<br />
For testing rates in a two-armed trial, pi1 and pi2 typically refer to the rates in the treatment
and the control group, respectively. This is not mandatory, however, and so pi1 and pi2 can be interchanged.
In many-to-one multi-armed trials, piTreatments and piControl refer to the rates in the treatment arms and
the one control arm, and so they cannot be interchanged. piTreatments and piControls in enrichment designs
can principally be interchanged, but we use the plural form to indicate that the rates can be differently
specified for the sub-populations.
</p>
<p>Median unbiased effect estimates and confidence intervals are calculated if
a group sequential design or an inverse normal combination test design was chosen, i.e., it is not applicable
for Fisher's p-value combination test design.
For the inverse normal combination test design with more than two stages, a warning informs that the validity
of the confidence interval is theoretically shown only if no sample size change was performed.
</p>
<p>A final stage p-value for Fisher's combination test is calculated only if a two-stage design was chosen.
For Fisher's combination test, the conditional power for more than one remaining stages is estimated via simulation.
</p>
<p>Final stage p-values, median unbiased effect estimates, and final confidence intervals are not calculated
for multi-arm and enrichment designs.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.AnalysisResults">names</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.ParameterSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.AnalysisResults">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.AnalysisResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.AnalysisResults">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getObservedInformationRates">getObservedInformationRates()</a></code>
</p>
<p>Other analysis functions: 
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1 One-Sample t Test
# Perform an analysis within a three-stage group sequential design with
# O'Brien &amp; Fleming boundaries and one-sample data with a continuous outcome
# where H0: mu = 1.2 is to be tested
dsnGS &lt;- getDesignGroupSequential()
dataMeans &lt;- getDataset(
    n = c(30, 30),
    means = c(1.96, 1.76),
    stDevs = c(1.92, 2.01)
)
getAnalysisResults(design = dsnGS, dataInput = dataMeans, thetaH0 = 1.2)

# You can obtain the results when performing an inverse normal combination test
# with these data by using the commands
dsnIN &lt;- getDesignInverseNormal()
getAnalysisResults(design = dsnIN, dataInput = dataMeans, thetaH0 = 1.2)

# Example 2 Use Function Approach with Time to Event Data
# Perform an analysis within a use function approach according to an
# O'Brien &amp; Fleming type use function and survival data where
# where H0: hazard ratio = 1 is to be tested. The events were observed
# over time and maxInformation = 120, informationEpsilon = 5 specifies
# that 116 &gt; 120 - 5 observed events defines the final analysis.
design &lt;- getDesignGroupSequential(typeOfDesign = "asOF")
dataSurvival &lt;- getDataset(
    cumulativeEvents = c(33, 72, 116),
    cumulativeLogRanks = c(1.33, 1.88, 1.902)
)
getAnalysisResults(design,
    dataInput = dataSurvival,
    maxInformation = 120, informationEpsilon = 5
)

# Example 3 Multi-Arm Design
# In a four-stage combination test design with O'Brien &amp; Fleming boundaries
# at the first stage the second treatment arm was dropped. With the Bonferroni
# intersection test, the results together with the CRP, conditional power
# (assuming a total of 40 subjects for each comparison and effect sizes 0.5
# and 0.8 for treatment arm 1 and 3, respectively, and standard deviation 1.2),
# RCIs and p-values of a closed adaptive test procedure are
# obtained as follows with the given data (treatment arm 4 refers to the
# reference group; displayed with summary and plot commands):
data &lt;- getDataset(
    n1 = c(22, 23),
    n2 = c(21, NA),
    n3 = c(20, 25),
    n4 = c(25, 27),
    means1 = c(1.63, 1.51),
    means2 = c(1.4, NA),
    means3 = c(0.91, 0.95),
    means4 = c(0.83, 0.75),
    stds1 = c(1.2, 1.4),
    stds2 = c(1.3, NA),
    stds3 = c(1.1, 1.14),
    stds4 = c(1.02, 1.18)
)
design &lt;- getDesignInverseNormal(kMax = 4)
x &lt;- getAnalysisResults(design,
    dataInput = data, intersectionTest = "Bonferroni",
    nPlanned = c(40, 40), thetaH1 = c(0.5, NA, 0.8), assumedStDevs = 1.2
)
summary(x)
if (require(ggplot2)) plot(x, thetaRange = c(0, 0.8))
design &lt;- getDesignConditionalDunnett(secondStageConditioning = FALSE)
y &lt;- getAnalysisResults(design,
    dataInput = data,
    nPlanned = 40, thetaH1 = c(0.5, NA, 0.8), assumedStDevs = 1.2, stage = 1
)
summary(y)
if (require(ggplot2)) plot(y, thetaRange = c(0, 0.4))

# Example 4 Enrichment Design
# Perform an two-stage enrichment design analysis with O'Brien &amp; Fleming boundaries
# where one sub-population (S1) and a full population (F) are considered as primary
# analysis sets. At interim, S1 is selected for further analysis and the sample
# size is increased accordingly. With the Spiessens &amp; Debois intersection test,
# the results of a closed adaptive test procedure together with the CRP, repeated
# RCIs and p-values are obtained as follows with the given data (displayed with
# summary and plot commands):
design &lt;- getDesignInverseNormal(kMax = 2, typeOfDesign = "OF")
dataS1 &lt;- getDataset(
    means1 = c(13.2, 12.8),
    means2 = c(11.1, 10.8),
    stDev1 = c(3.4, 3.3),
    stDev2 = c(2.9, 3.5),
    n1 = c(21, 42),
    n2 = c(19, 39)
)
dataNotS1 &lt;- getDataset(
    means1 = c(11.8, NA),
    means2 = c(10.5, NA),
    stDev1 = c(3.6, NA),
    stDev2 = c(2.7, NA),
    n1 = c(15, NA),
    n2 = c(13, NA)
)
dataBoth &lt;- getDataset(S1 = dataS1, R = dataNotS1)
x &lt;- getAnalysisResults(design,
    dataInput = dataBoth,
    intersectionTest = "SpiessensDebois",
    varianceOption = "pooledFromFull",
    stratifiedAnalysis = TRUE
)
summary(x)
if (require(ggplot2)) plot(x, type = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='getClosedCombinationTestResults'>Get Closed Combination Test Results</h2><span id='topic+getClosedCombinationTestResults'></span>

<h3>Description</h3>

<p>Calculates and returns the results from the closed combination test in multi-arm
and population enrichment designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClosedCombinationTestResults(stageResults)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getClosedCombinationTestResults_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+ClosedCombinationTestResults">ClosedCombinationTestResults</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.ParameterSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# In a four-stage combination test design with O'Brien &amp; Fleming boundaries
# at the first stage the second treatment arm was dropped. With the Bonferroni
# intersection test, the results of a closed adaptive test procedure are
# obtained as follows with the given data (treatment arm 4 refers to the
# reference group):
data &lt;- getDataset(
    n1 = c(22, 23),
    n2 = c(21, NA),
    n3 = c(20, 25),
    n4 = c(25, 27),
    means1 = c(1.63, 1.51),
    means2 = c(1.4, NA),
    means3 = c(0.91, 0.95),
    means4 = c(0.83, 0.75),
    stds1 = c(1.2, 1.4),
    stds2 = c(1.3, NA),
    stds3 = c(1.1, 1.14),
    stds4 = c(1.02, 1.18)
)

design &lt;- getDesignInverseNormal(kMax = 4)
stageResults &lt;- getStageResults(design,
    dataInput = data,
    intersectionTest = "Bonferroni"
)
getClosedCombinationTestResults(stageResults)

## End(Not run)

</code></pre>

<hr>
<h2 id='getClosedConditionalDunnettTestResults'>Get Closed Conditional Dunnett Test Results</h2><span id='topic+getClosedConditionalDunnettTestResults'></span>

<h3>Description</h3>

<p>Calculates and returns the results from the closed conditional Dunnett test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClosedConditionalDunnettTestResults(
  stageResults,
  ...,
  stage = stageResults$stage
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getClosedConditionalDunnettTestResults_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
<tr><td><code id="getClosedConditionalDunnettTestResults_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getClosedConditionalDunnettTestResults_+3A_stage">stage</code></td>
<td>
<p>The stage number (optional). Default: total number of existing stages in the data input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For performing the conditional Dunnett test the design must be defined through the function
<code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett()</a></code>.<br />
See Koenig et al. (2008) and Wassmer &amp; Brannath (2016), chapter 11 for details of the test procedure.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+ClosedCombinationTestResults">ClosedCombinationTestResults</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.ParameterSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# In a two-stage design a conditional Dunnett test should be performed
# where the  unconditional second stage p-values should be used for the
# test decision.
# At the first stage the second treatment arm was dropped. The results of
# a closed conditionsal Dunnett test are obtained as follows with the given
# data (treatment arm 4 refers to the reference group):
data &lt;- getDataset(
    n1 = c(22, 23),
    n2 = c(21, NA),
    n3 = c(20, 25),
    n4 = c(25, 27),
    means1 = c(1.63, 1.51),
    means2 = c(1.4, NA),
    means3 = c(0.91, 0.95),
    means4 = c(0.83, 0.75),
    stds1 = c(1.2, 1.4),
    stds2 = c(1.3, NA),
    stds3 = c(1.1, 1.14),
    stds4 = c(1.02, 1.18)
)

# For getting the results of the closed test procedure, use the following commands:
design &lt;- getDesignConditionalDunnett(secondStageConditioning = FALSE)
stageResults &lt;- getStageResults(design, dataInput = data)
getClosedConditionalDunnettTestResults(stageResults)

## End(Not run)

</code></pre>

<hr>
<h2 id='getConditionalPower'>Get Conditional Power</h2><span id='topic+getConditionalPower'></span>

<h3>Description</h3>

<p>Calculates and returns the conditional power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConditionalPower(stageResults, ..., nPlanned, allocationRatioPlanned = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getConditionalPower_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
<tr><td><code id="getConditionalPower_+3A_...">...</code></td>
<td>
<p>Further (optional) arguments to be passed:
</p>

<dl>
<dt><code>thetaH1</code> and <code>stDevH1</code> (or <code>assumedStDev</code> / <code>assumedStDevs</code>),
<code>pi1</code>, <code>pi2</code>, or <code>piTreatments</code>, <code>piControl(s)</code></dt><dd>
<p>The assumed effect size, standard deviation or rates to calculate the conditional power if <code>nPlanned</code>
is specified. For survival designs, <code>thetaH1</code> refers to the hazard ratio.
For one-armed trials with binary outcome, only <code>pi1</code> can be specified, for two-armed trials with binary outcome,
<code>pi1</code> and <code>pi2</code> can be specified referring to the assumed treatment and control rate, respectively.
In multi-armed or enrichment designs, you can
specify a value or a vector with elements referring to the treatment arms or the sub-populations,
respectively. For testing rates, the parameters to be specified are <code>piTreatments</code> and <code>piControl</code> (multi-arm
designs) and <code>piTreatments</code> and <code>piControls</code> (enrichment designs).<br />
If not specified, the conditional power is calculated under the assumption of observed effect sizes,
standard deviations, rates, or hazard ratios.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>Iterations for simulating the power for Fisher's combination test.
If the power for more than one remaining stages is to be determined for
Fisher's combination test, it is estimated via simulation with specified <br />
<code>iterations</code>, the default is <code>1000</code>.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed for simulating the conditional power for Fisher's combination test.
See above, default is a random seed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getConditionalPower_+3A_nplanned">nPlanned</code></td>
<td>
<p>The additional (i.e., &quot;new&quot; and not cumulative) sample size planned for each of the subsequent stages.
The argument must be a vector with length equal to the number of remaining stages and contain
the combined sample size from both treatment groups if two groups are considered. For survival outcomes,
it should contain the planned number of additional events.
For multi-arm designs, it is the per-comparison (combined) sample size.
For enrichment designs, it is the (combined) sample size for the considered sub-population.</p>
</td></tr>
<tr><td><code id="getConditionalPower_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional power is calculated if the planned sample size for the subsequent stages is specified.<br />
For testing rates in a two-armed trial, pi1 and pi2 typically refer to the rates in the treatment
and the control group, respectively. This is not mandatory, however, and so pi1 and pi2 can be interchanged.
In many-to-one multi-armed trials, piTreatments and piControl refer to the rates in the treatment arms and
the one control arm, and so they cannot be interchanged. piTreatments and piControls in enrichment designs
can principally be interchanged, but we use the plural form to indicate that the rates can be differently
specified for the sub-populations.
</p>
<p>For Fisher's combination test, the conditional power for more than one remaining stages is
estimated via simulation.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+ConditionalPowerResults">ConditionalPowerResults</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.ParameterSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.StageResults">plot.StageResults()</a></code> or <code><a href="#topic+plot.AnalysisResults">plot.AnalysisResults()</a></code>
for plotting the conditional power.
</p>
<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- getDataset(
    n1     = c(22, 13, 22, 13),
    n2     = c(22, 11, 22, 11),
    means1 = c(1, 1.1, 1, 1),
    means2 = c(1.4, 1.5, 1, 2.5),
    stds1  = c(1, 2, 2, 1.3),
    stds2  = c(1, 2, 2, 1.3)
)
stageResults &lt;- getStageResults(
    getDesignGroupSequential(kMax = 4),
    dataInput = data, stage = 2, directionUpper = FALSE
)
getConditionalPower(stageResults, thetaH1 = -0.4,
    nPlanned = c(64, 64), assumedStDev = 1.5, 
    allocationRatioPlanned = 3
)

## End(Not run)

</code></pre>

<hr>
<h2 id='getConditionalRejectionProbabilities'>Get Conditional Rejection Probabilities</h2><span id='topic+getConditionalRejectionProbabilities'></span>

<h3>Description</h3>

<p>Calculates the conditional rejection probabilities (CRP) for given test results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConditionalRejectionProbabilities(stageResults, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getConditionalRejectionProbabilities_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
<tr><td><code id="getConditionalRejectionProbabilities_+3A_...">...</code></td>
<td>
<p>Further (optional) arguments to be passed:
</p>

<dl>
<dt><code>iterations</code></dt><dd><p>Iterations for simulating the conditional
rejection probabilities for Fisher's combination test.
For checking purposes, it can be estimated via simulation with
specified <code>iterations</code>.</p>
</dd>
<dt><code>seed</code></dt><dd><p>Seed for simulating the conditional rejection probabilities
for Fisher's combination test. See above, default is a random seed.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional rejection probability is the probability, under H0, to reject H0
in one of the subsequent (remaining) stages.
The probability is calculated using the specified design. For testing rates and the
survival design, the normal approximation is used, i.e., it is calculated with the
use of the prototype case testing a mean for normally distributed data with known variance.
</p>
<p>The conditional rejection probabilities are provided up to the specified stage.
</p>
<p>For Fisher's combination test, you can check the validity of the CRP calculation via simulation.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code>kMax</code> or in case of multi-arm stage results
a <code><a href="base.html#topic+matrix">matrix</a></code> (each column represents a stage, each row a comparison)
containing the conditional rejection probabilities.
</p>


<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate CRP for a Fisher's combination test design with
# two remaining stages and check the results by simulation.
design &lt;- getDesignFisher(
    kMax = 4, alpha = 0.01,
    informationRates = c(0.1, 0.3, 0.8, 1)
)
data &lt;- getDataset(n = c(40, 40), events = c(20, 22))
sr &lt;- getStageResults(design, data, thetaH0 = 0.4)
getConditionalRejectionProbabilities(sr)
getConditionalRejectionProbabilities(sr,
    simulateCRP = TRUE,
    seed = 12345, iterations = 10000
)

## End(Not run)

</code></pre>

<hr>
<h2 id='getData'>Get Simulation Data</h2><span id='topic+getData'></span><span id='topic+getData.SimulationResults'></span>

<h3>Description</h3>

<p>Returns the aggregated simulation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getData(x)

getData.SimulationResults(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getData_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+SimulationResults">SimulationResults</a></code> object created by <code><a href="#topic+getSimulationMeans">getSimulationMeans()</a></code>,<br />
<code><a href="#topic+getSimulationRates">getSimulationRates()</a></code>, <code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code>, <code><a href="#topic+getSimulationMultiArmMeans">getSimulationMultiArmMeans()</a></code>,<br />
<code><a href="#topic+getSimulationMultiArmRates">getSimulationMultiArmRates()</a></code>, or <code><a href="#topic+getSimulationMultiArmSurvival">getSimulationMultiArmSurvival()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to get the aggregated simulated data from an simulation results
object, for example, obtained by <code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code>.
In this case, the data frame contains the following columns:
</p>

<ol>
<li> <p><code>iterationNumber</code>: The number of the simulation iteration.
</p>
</li>
<li> <p><code>stageNumber</code>: The stage.
</p>
</li>
<li> <p><code>pi1</code>: The assumed or derived event rate in the treatment group.
</p>
</li>
<li> <p><code>pi2</code>: The assumed or derived event rate in the control group.
</p>
</li>
<li> <p><code>hazardRatio</code>: The hazard ratio under consideration (if available).
</p>
</li>
<li> <p><code>analysisTime</code>: The analysis time.
</p>
</li>
<li> <p><code>numberOfSubjects</code>: The number of subjects under consideration when the
(interim) analysis takes place.
</p>
</li>
<li> <p><code>eventsPerStage1</code>: The observed number of events per stage
in treatment group 1.
</p>
</li>
<li> <p><code>eventsPerStage2</code>: The observed number of events per stage
in treatment group 2.
</p>
</li>
<li> <p><code>eventsPerStage</code>: The observed number of events per stage
in both treatment groups.
</p>
</li>
<li> <p><code>rejectPerStage</code>: 1 if null hypothesis can be rejected, 0 otherwise.
</p>
</li>
<li> <p><code>eventsNotAchieved</code>: 1 if number of events could not be reached with
observed number of subjects, 0 otherwise.
</p>
</li>
<li> <p><code>futilityPerStage</code>: 1 if study should be stopped for futility, 0 otherwise.
</p>
</li>
<li> <p><code>testStatistic</code>: The test statistic that is used for the test decision,
depends on which design was chosen (group sequential, inverse normal,
or Fisher combination test)'
</p>
</li>
<li> <p><code>logRankStatistic</code>: Z-score statistic which corresponds to a one-sided
log-rank test at considered stage.
</p>
</li>
<li> <p><code>conditionalPowerAchieved</code>: The conditional power for the subsequent stage of the trial for
selected sample size and effect. The effect is either estimated from the data or can be
user defined with <code>thetaH1</code> or <code>pi1H1</code> and <code>pi2H1</code>.
</p>
</li>
<li> <p><code>trialStop</code>: <code>TRUE</code> if study should be stopped for efficacy or futility or final stage, <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>hazardRatioEstimateLR</code>: The estimated hazard ratio, derived from the
log-rank statistic.
</p>
</li></ol>

<p>A subset of variables is provided for <code><a href="#topic+getSimulationMeans">getSimulationMeans()</a></code>, <code><a href="#topic+getSimulationRates">getSimulationRates()</a></code>, <code><a href="#topic+getSimulationMultiArmMeans">getSimulationMultiArmMeans()</a></code>,<br />
<code><a href="#topic+getSimulationMultiArmRates">getSimulationMultiArmRates()</a></code>, or <code><a href="#topic+getSimulationMultiArmSurvival">getSimulationMultiArmSurvival()</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
results &lt;- getSimulationSurvival(
    pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, eventTime = 12,
    accrualTime = 24, plannedEvents = 40, maxNumberOfSubjects = 200,
    maxNumberOfIterations = 50
)
data &lt;- getData(results)
head(data)
dim(data)

## End(Not run)

</code></pre>

<hr>
<h2 id='getDataset'>Get Dataset</h2><span id='topic+getDataset'></span><span id='topic+getDataSet'></span>

<h3>Description</h3>

<p>Creates a dataset object and returns it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDataset(..., floatingPointNumbersEnabled = FALSE)

getDataSet(..., floatingPointNumbersEnabled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDataset_+3A_...">...</code></td>
<td>
<p>A <code>data.frame</code> or some data vectors defining the dataset.</p>
</td></tr>
<tr><td><code id="getDataset_+3A_floatingpointnumbersenabled">floatingPointNumbersEnabled</code></td>
<td>
<p>If <code>TRUE</code>,
sample sizes and event numbers can be specified as floating-point numbers
(this make sense, e.g., for theoretical comparisons); <br />
by default <code>floatingPointNumbersEnabled = FALSE</code>, i.e.,
samples sizes and event numbers defined as floating-point numbers will be truncated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different dataset types <code>DatasetMeans</code>, of <code>DatasetRates</code>, or
<code>DatasetSurvival</code> can be created as follows:
</p>

<ul>
<li><p> An element of <code><a href="#topic+DatasetMeans">DatasetMeans</a></code> for one sample is created by <br />
<code>getDataset(sampleSizes =, means =, stDevs =)</code> where <br />
<code>sampleSizes</code>, <code>means</code>, <code>stDevs</code> are vectors with stage-wise sample sizes,
means and standard deviations of length given by the number of available stages.
</p>
</li>
<li><p> An element of <code><a href="#topic+DatasetMeans">DatasetMeans</a></code> for two samples is created by <br />
<code>getDataset(sampleSizes1 =, sampleSizes2 =, means1 =, means2 =, </code> <br />
<code>stDevs1 =, stDevs2 =)</code> where
<code>sampleSizes1</code>, <code>sampleSizes2</code>, <code>means1</code>, <code>means2</code>,
<code>stDevs1</code>, <code>stDevs2</code> are vectors with
stage-wise sample sizes, means and standard deviations for the two treatment groups
of length given by the number of available stages.
</p>
</li>
<li><p> An element of <code><a href="#topic+DatasetRates">DatasetRates</a></code> for one sample is created by <br />
<code>getDataset(sampleSizes =, events =)</code> where <code>sampleSizes</code>, <code>events</code> are vectors
with stage-wise sample sizes and events of length given by the number of available stages.
</p>
</li>
<li><p> An element of <code><a href="#topic+DatasetRates">DatasetRates</a></code> for two samples is created by <br />
<code>getDataset(sampleSizes1 =, sampleSizes2 =, events1 =, events2 =)</code> where
<code>sampleSizes1</code>, <code>sampleSizes2</code>, <code>events1</code>, <code>events2</code>
are vectors with stage-wise sample sizes
and events  for the two treatment groups of length given by the number of available stages.
</p>
</li>
<li><p> An element of <code><a href="#topic+DatasetSurvival">DatasetSurvival</a></code> is created by <br />
<code>getDataset(events =, logRanks =, allocationRatios =)</code> where
<code>events</code>, <code>logRanks</code>, and <code>allocation ratios</code> are the stage-wise events,
(one-sided) logrank statistics, and allocation ratios.
</p>
</li>
<li><p> An element of <code><a href="#topic+DatasetMeans">DatasetMeans</a></code>, <code><a href="#topic+DatasetRates">DatasetRates</a></code>, and <code><a href="#topic+DatasetSurvival">DatasetSurvival</a></code>
for more than one comparison is created by adding subsequent digits to the variable names.
The system can analyze these data in a multi-arm many-to-one comparison setting where the
group with the highest index represents the control group.
</p>
</li></ul>

<p>Prefix <code>overall[Capital case of first letter of variable name]...</code> for the variable
names enables entering the overall (cumulative) results and calculates stage-wise statistics.
Since rpact version 3.2, the prefix <code>cumulative[Capital case of first letter of variable name]...</code> or
<code>cum[Capital case of first letter of variable name]...</code> can alternatively be used for this.
</p>
<p><code>n</code> can be used in place of <code>samplesizes</code>.
</p>
<p>Note that in survival design usually the overall (cumulative) events and logrank test statistics are provided
in the output, so <br />
<code>getDataset(cumulativeEvents=, cumulativeLogRanks =, cumulativeAllocationRatios =)</code> <br />
is the usual command for entering survival data. Note also that for <code>cumulativeLogranks</code> also the
z scores from a Cox regression can be used.
</p>
<p>For multi-arm designs, the index refers to the considered comparison. For example,<br />
<code>
  getDataset(events1=c(13, 33), logRanks1 = c(1.23, 1.55), events2 = c(16, NA), logRanks2 = c(1.55, NA))
</code> <br />
refers to the case where one active arm (1) is considered at both stages whereas active arm 2
was dropped at interim. Number of events and logrank statistics are entered for the corresponding
comparison to control (see Examples).
</p>
<p>For enrichment designs, the comparison of two samples is provided for an unstratified
(sub-population wise) or stratified data input.<br />
For non-stratified (sub-population wise) data input the data sets are defined for the sub-populations
S1, S2, ..., F, where F refers to the full populations. Use of <code>getDataset(S1 = , S2, ..., F = )</code>
defines the data set to be used in <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code> (see examples)<br />
For stratified data input the data sets are defined for the strata S1, S12, S2, ..., R, where R
refers to the remainder of the strata such that the union of all sets is the full population.
Use of <code>getDataset(S1 = , S12 = , S2, ..., R = )</code> defines the data set to be used in
<code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code> (see examples)<br />
For survival data, for enrichment designs the log-rank statistics can only be entered as stratified
log-rank statistics in order to provide strong control of Type I error rate. For stratified data input,
the variables to be specified in <code>getDataset()</code> are <code>cumEvents</code>, <code>cumExpectedEvents</code>,
<code>cumVarianceEvents</code>, and <code>cumAllocationRatios</code> or <code>overallEvents</code>, <code>overallExpectedEvents</code>,
<code>overallVarianceEvents</code>, and <code>overallAllocationRatios</code>. From this, (stratified) log-rank tests and
and the independent increments are calculated.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+Dataset">Dataset</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.Dataset">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a Dataset of Means (one group):
datasetOfMeans &lt;- getDataset(
    n      = c(22, 11, 22, 11),
    means  = c(1, 1.1, 1, 1),
    stDevs = c(1, 2, 2, 1.3)
)
datasetOfMeans
datasetOfMeans$show(showType = 2)

datasetOfMeans2 &lt;- getDataset(
    cumulativeSampleSizes = c(22, 33, 55, 66),
    cumulativeMeans = c(1.000, 1.033, 1.020, 1.017),
    cumulativeStDevs = c(1.00, 1.38, 1.64, 1.58)
)
datasetOfMeans2
datasetOfMeans2$show(showType = 2)
as.data.frame(datasetOfMeans2)

# Create a Dataset of Means (two groups):
datasetOfMeans3 &lt;- getDataset(
    n1 = c(22, 11, 22, 11),
    n2 = c(22, 13, 22, 13),
    means1  = c(1, 1.1, 1, 1),
    means2  = c(1.4, 1.5, 3, 2.5),
    stDevs1 = c(1, 2, 2, 1.3),
    stDevs2 = c(1, 2, 2, 1.3)
)
datasetOfMeans3

datasetOfMeans4 &lt;- getDataset(
    cumulativeSampleSizes1 = c(22, 33, 55, 66),
    cumulativeSampleSizes2 = c(22, 35, 57, 70),
    cumulativeMeans1  = c(1, 1.033, 1.020, 1.017),
    cumulativeMeans2  = c(1.4, 1.437, 2.040, 2.126),
    cumulativeStDevs1 = c(1, 1.38, 1.64, 1.58),
    cumulativeStDevs2 = c(1, 1.43, 1.82, 1.74)
)
datasetOfMeans4

df &lt;- data.frame(
    stages = 1:4,
    n1      = c(22, 11, 22, 11),
    n2      = c(22, 13, 22, 13),
    means1  = c(1, 1.1, 1, 1),
    means2  = c(1.4, 1.5, 3, 2.5),
    stDevs1 = c(1, 2, 2, 1.3),
    stDevs2 = c(1, 2, 2, 1.3)
)
datasetOfMeans5 &lt;- getDataset(df)
datasetOfMeans5

# Create a Dataset of Means (three groups) where the comparison of 
# treatment arm 1 to control is dropped at the second interim stage:
datasetOfMeans6 &lt;- getDataset(
   cumN1      = c(22, 33, NA),
   cumN2      = c(20, 34, 56),
   cumN3      = c(22, 31, 52),
   cumMeans1  = c(1.64, 1.54, NA),
   cumMeans2  = c(1.7, 1.5, 1.77),
   cumMeans3  = c(2.5, 2.06, 2.99),
   cumStDevs1 = c(1.5, 1.9, NA),
   cumStDevs2 = c(1.3, 1.3, 1.1),
   cumStDevs3 = c(1, 1.3, 1.8))
datasetOfMeans6

# Create a Dataset of Rates (one group):
datasetOfRates &lt;- getDataset(
    n = c(8, 10, 9, 11), 
    events = c(4, 5, 5, 6)
)
datasetOfRates

# Create a Dataset of Rates (two groups):
datasetOfRates2 &lt;- getDataset(
    n2      = c(8, 10, 9, 11),
    n1      = c(11, 13, 12, 13),
    events2 = c(3, 5, 5, 6),
    events1 = c(10, 10, 12, 12)
)
datasetOfRates2

# Create a Dataset of Rates (three groups) where the comparison of 
# treatment arm 2 to control is dropped at the first interim stage:
datasetOfRates3 &lt;- getDataset(
    cumN1      = c(22, 33, 44),
    cumN2      = c(20, NA, NA),
    cumN3      = c(20, 34, 44),
    cumEvents1 = c(11, 14, 22),
    cumEvents2 = c(17, NA, NA),
    cumEvents3 = c(17, 19, 33))
datasetOfRates3

# Create a Survival Dataset
datasetSurvival &lt;- getDataset(
    cumEvents = c(8, 15, 19, 31),
    cumAllocationRatios = c(1, 1, 1, 2),
    cumLogRanks = c(1.52, 1.98, 1.99, 2.11)
)
datasetSurvival
 
# Create a Survival Dataset with four comparisons where treatment
# arm 2 was dropped at the first interim stage, and treatment arm 4
# at the second.
datasetSurvival2 &lt;- getDataset(
    cumEvents1   = c(18, 45, 56),
    cumEvents2   = c(22, NA, NA),
    cumEvents3   = c(12, 41, 56),
    cumEvents4   = c(27, 56, NA),
    cumLogRanks1 = c(1.52, 1.98, 1.99),
    cumLogRanks2 = c(3.43, NA, NA),
    cumLogRanks3 = c(1.45, 1.67, 1.87),
    cumLogRanks4 = c(1.12, 1.33, NA)
)
datasetSurvival2

# Enrichment: Stratified and unstratified data input
# The following data are from one study. Only the first 
# (stratified) data input enables a stratified analysis. 

# Stratified data input
S1 &lt;- getDataset(
    sampleSize1 = c(18, 17), 
    sampleSize2 = c(12, 33), 
    mean1       = c(125.6, 111.1), 
    mean2       = c(107.7, 77.7), 
    stDev1      = c(120.1, 145.6),
    stDev2      = c(128.5, 133.3)) 
S2 &lt;- getDataset(
    sampleSize1 = c(11, NA), 
    sampleSize2 = c(14, NA), 
    mean1       = c(100.1, NA), 
    mean2      = c( 68.3, NA), 
    stDev1      = c(116.8, NA),
    stDev2      = c(124.0, NA)) 
S12 &lt;- getDataset(           
    sampleSize1 = c(21, 17), 
    sampleSize2 = c(21, 12), 
    mean1       = c(135.9, 117.7), 
    mean2       = c(84.9, 107.7), 
    stDev1      = c(185.0, 92.3),
    stDev2      = c(139.5, 107.7)) 
R &lt;- getDataset(
    sampleSize1 = c(19, NA), 
    sampleSize2 = c(33, NA), 
    mean1       = c(142.4, NA), 
    mean2       = c(77.1, NA), 
    stDev1      = c(120.6, NA),
    stDev2      = c(163.5, NA)) 
dataEnrichment &lt;- getDataset(S1 = S1, S2 = S2, S12 = S12, R = R)
dataEnrichment

# Unstratified data input
S1N &lt;- getDataset(
    sampleSize1 = c(39, 34), 
    sampleSize2 = c(33, 45), 
    stDev1      = c(156.503, 120.084), 
    stDev2      = c(134.025, 126.502), 
    mean1       = c(131.146, 114.4), 
    mean2       = c(93.191, 85.7))
S2N &lt;- getDataset(
    sampleSize1 = c(32, NA), 
    sampleSize2 = c(35, NA), 
    stDev1      = c(163.645, NA), 
    stDev2      = c(131.888, NA),
    mean1       = c(123.594, NA), 
    mean2       = c(78.26, NA))
F &lt;- getDataset(
    sampleSize1 = c(69, NA), 
    sampleSize2 = c(80, NA), 
    stDev1      = c(165.468, NA), 
    stDev2      = c(143.979, NA), 
    mean1       = c(129.296, NA), 
    mean2       = c(82.187, NA))
dataEnrichmentN &lt;- getDataset(S1 = S1N, S2 = S2N, F = F)
dataEnrichmentN

## End(Not run)

</code></pre>

<hr>
<h2 id='getDesignCharacteristics'>Get Design Characteristics</h2><span id='topic+getDesignCharacteristics'></span>

<h3>Description</h3>

<p>Calculates the characteristics of a design and returns it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignCharacteristics(design = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDesignCharacteristics_+3A_design">design</code></td>
<td>
<p>The trial design.</p>
</td></tr>
<tr><td><code id="getDesignCharacteristics_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the inflation factor (IF),
the expected reduction in sample size under H1, under H0, and under a value in between H0 and H1.
Furthermore, absolute information values are calculated
under the prototype case testing H0: mu = 0 against H1: mu = 1.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignCharacteristics">TrialDesignCharacteristics</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.ParameterSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignCharacteristics">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other design functions: 
<code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a>()</code>,
<code><a href="#topic+getDesignFisher">getDesignFisher</a>()</code>,
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential</a>()</code>,
<code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal</a>()</code>,
<code><a href="#topic+getGroupSequentialProbabilities">getGroupSequentialProbabilities</a>()</code>,
<code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate design characteristics for a three-stage O'Brien &amp; Fleming 
# design at power 90% and compare it with Pocock's design.  
getDesignCharacteristics(getDesignGroupSequential(beta = 0.1))
getDesignCharacteristics(getDesignGroupSequential(beta = 0.1, typeOfDesign = "P")) 

## End(Not run)

</code></pre>

<hr>
<h2 id='getDesignConditionalDunnett'>Get Design Conditional Dunnett Test</h2><span id='topic+getDesignConditionalDunnett'></span>

<h3>Description</h3>

<p>Defines the design to perform an analysis with the conditional Dunnett test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignConditionalDunnett(
  alpha = 0.025,
  informationAtInterim = 0.5,
  secondStageConditioning = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDesignConditionalDunnett_+3A_alpha">alpha</code></td>
<td>
<p>The significance level alpha, default is <code>0.025</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getDesignConditionalDunnett_+3A_informationatinterim">informationAtInterim</code></td>
<td>
<p>The information to be expected at interim, default is <code>informationAtInterim = 0.5</code>.</p>
</td></tr>
<tr><td><code id="getDesignConditionalDunnett_+3A_secondstageconditioning">secondStageConditioning</code></td>
<td>
<p>The way the second stage p-values are calculated within the closed system of hypotheses.
If <code>secondStageConditioning = FALSE</code> is specified, the unconditional adjusted p-values are used, otherwise
conditional adjusted p-values are calculated, default is <code>secondStageConditioning = TRUE</code>
(for details, see Koenig et al., 2008).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For performing the conditional Dunnett test the design must be defined through this function.
You can define the information fraction and the way of how to compute the second stage
p-values only in the design definition, and not in the analysis call.<br />
See <code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults()</a></code>
for an example and Koenig et al. (2008) and
Wassmer &amp; Brannath (2016), chapter 11 for details of the test procedure.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesign">TrialDesign</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesign">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesign">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other design functions: 
<code><a href="#topic+getDesignCharacteristics">getDesignCharacteristics</a>()</code>,
<code><a href="#topic+getDesignFisher">getDesignFisher</a>()</code>,
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential</a>()</code>,
<code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal</a>()</code>,
<code><a href="#topic+getGroupSequentialProbabilities">getGroupSequentialProbabilities</a>()</code>,
<code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber</a>()</code>
</p>

<hr>
<h2 id='getDesignFisher'>Get Design Fisher</h2><span id='topic+getDesignFisher'></span>

<h3>Description</h3>

<p>Performs Fisher's combination test and returns critical values for this design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignFisher(
  ...,
  kMax = NA_integer_,
  alpha = NA_real_,
  method = c("equalAlpha", "fullAlpha", "noInteraction", "userDefinedAlpha"),
  userAlphaSpending = NA_real_,
  alpha0Vec = NA_real_,
  informationRates = NA_real_,
  sided = 1,
  bindingFutility = NA,
  directionUpper = NA,
  tolerance = 1e-14,
  iterations = 0,
  seed = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDesignFisher_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_kmax">kMax</code></td>
<td>
<p>The maximum number of stages <code>K</code>.
Must be a positive integer of length 1 (default value is <code>3</code>).
The maximum selectable <code>kMax</code> is <code>20</code> for group sequential or inverse normal and
<code>6</code> for Fisher combination test designs.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_alpha">alpha</code></td>
<td>
<p>The significance level alpha, default is <code>0.025</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_method">method</code></td>
<td>
<p><code>"equalAlpha"</code>, <code>"fullAlpha"</code>, <code>"noInteraction"</code>, or <code>"userDefinedAlpha"</code>,
default is <code>"equalAlpha"</code> (for details, see Wassmer, 1999).</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_useralphaspending">userAlphaSpending</code></td>
<td>
<p>The user defined alpha spending.
Numeric vector of length <code>kMax</code> containing the cumulative
alpha-spending (Type I error rate) up to each interim stage: <code>0 &lt;= alpha_1 &lt;= ... &lt;= alpha_K &lt;= alpha</code>.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_alpha0vec">alpha0Vec</code></td>
<td>
<p>Stopping for futility bounds for stage-wise p-values.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_informationrates">informationRates</code></td>
<td>
<p>The information rates t_1, ..., t_kMax (that must be fixed prior to the trial),
default is <code>(1:kMax) / kMax</code>. For the weighted inverse normal design, the weights are derived
through w_1 = sqrt(t_1), and w_k = sqrt(t_k - t_(k-1)). For the weighted Fisher's combination test, the
weights (scales) are w_k = sqrt((t_k - t_(k-1)) / t_1) (see the documentation).</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_sided">sided</code></td>
<td>
<p>Is the alternative one-sided (<code>1</code>) or two-sided (<code>2</code>), default is <code>1</code>.
Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_bindingfutility">bindingFutility</code></td>
<td>
<p>If <code>bindingFutility = TRUE</code> is specified the calculation of
the critical values is affected by the futility bounds (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_tolerance">tolerance</code></td>
<td>
<p>The numerical tolerance, default is <code>1e-14</code>.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_iterations">iterations</code></td>
<td>
<p>The number of simulation iterations, e.g.,
<code>getDesignFisher(iterations = 100000)</code> checks the validity of the critical values for the design.
The default value of <code>iterations</code> is 0, i.e., no simulation will be executed.</p>
</td></tr>
<tr><td><code id="getDesignFisher_+3A_seed">seed</code></td>
<td>
<p>Seed for simulating the power for Fisher's combination test. See above, default is a random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getDesignFisher()</code> calculates the critical values and stage levels for
Fisher's combination test as described in Bauer (1989), Bauer and Koehne (1994),
Bauer and Roehmel (1995), and Wassmer (1999) for equally and unequally sized stages.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesign">TrialDesign</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesign">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesign">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignSet">getDesignSet()</a></code> for creating a set of designs to compare.
</p>
<p>Other design functions: 
<code><a href="#topic+getDesignCharacteristics">getDesignCharacteristics</a>()</code>,
<code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a>()</code>,
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential</a>()</code>,
<code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal</a>()</code>,
<code><a href="#topic+getGroupSequentialProbabilities">getGroupSequentialProbabilities</a>()</code>,
<code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate critical values for a two-stage Fisher's combination test 
# with full level alpha = 0.05 at the final stage and stopping for 
# futility bound alpha0 = 0.50, as described in Bauer and Koehne (1994). 
getDesignFisher(kMax = 2, method = "fullAlpha", alpha = 0.05, alpha0Vec = 0.50) 

## End(Not run)

</code></pre>

<hr>
<h2 id='getDesignGroupSequential'>Get Design Group Sequential</h2><span id='topic+getDesignGroupSequential'></span>

<h3>Description</h3>

<p>Provides adjusted boundaries and defines a group sequential design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignGroupSequential(
  ...,
  kMax = NA_integer_,
  alpha = NA_real_,
  beta = NA_real_,
  sided = 1L,
  informationRates = NA_real_,
  futilityBounds = NA_real_,
  typeOfDesign = c("OF", "P", "WT", "PT", "HP", "WToptimum", "asP", "asOF", "asKD",
    "asHSD", "asUser", "noEarlyEfficacy"),
  deltaWT = NA_real_,
  deltaPT1 = NA_real_,
  deltaPT0 = NA_real_,
  optimizationCriterion = c("ASNH1", "ASNIFH1", "ASNsum"),
  gammaA = NA_real_,
  typeBetaSpending = c("none", "bsP", "bsOF", "bsKD", "bsHSD", "bsUser"),
  userAlphaSpending = NA_real_,
  userBetaSpending = NA_real_,
  gammaB = NA_real_,
  bindingFutility = NA,
  directionUpper = NA,
  betaAdjustment = NA,
  constantBoundsHP = 3,
  twoSidedPower = NA,
  delayedInformation = NA_real_,
  tolerance = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDesignGroupSequential_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_kmax">kMax</code></td>
<td>
<p>The maximum number of stages <code>K</code>.
Must be a positive integer of length 1 (default value is <code>3</code>).
The maximum selectable <code>kMax</code> is <code>20</code> for group sequential or inverse normal and
<code>6</code> for Fisher combination test designs.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_alpha">alpha</code></td>
<td>
<p>The significance level alpha, default is <code>0.025</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_beta">beta</code></td>
<td>
<p>Type II error rate, necessary for providing sample size calculations
(e.g., <code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans()</a></code>), beta spending function designs,
or optimum designs, default is <code>0.20</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_sided">sided</code></td>
<td>
<p>Is the alternative one-sided (<code>1</code>) or two-sided (<code>2</code>), default is <code>1</code>.
Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_informationrates">informationRates</code></td>
<td>
<p>The information rates t_1, ..., t_kMax (that must be fixed prior to the trial),
default is <code>(1:kMax) / kMax</code>. For the weighted inverse normal design, the weights are derived
through w_1 = sqrt(t_1), and w_k = sqrt(t_k - t_(k-1)). For the weighted Fisher's combination test, the
weights (scales) are w_k = sqrt((t_k - t_(k-1)) / t_1) (see the documentation).</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_futilitybounds">futilityBounds</code></td>
<td>
<p>The futility bounds, defined on the test statistic z scale
(numeric vector of length <code>kMax - 1</code>).</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_typeofdesign">typeOfDesign</code></td>
<td>
<p>The type of design. Type of design is one of the following:
O'Brien &amp; Fleming (<code>"OF"</code>), Pocock (<code>"P"</code>), Wang &amp; Tsiatis Delta class (<code>"WT"</code>),
Pampallona &amp; Tsiatis (<code>"PT"</code>), Haybittle &amp; Peto (&quot;HP&quot;),
Optimum design within Wang &amp; Tsiatis class (<code>"WToptimum"</code>),
O'Brien &amp; Fleming type alpha spending (<code>"asOF"</code>), Pocock type alpha spending (<code>"asP"</code>),
Kim &amp; DeMets alpha spending (<code>"asKD"</code>), Hwang, Shi &amp; DeCani alpha spending (<code>"asHSD"</code>),
user defined alpha spending (<code>"asUser"</code>), no early efficacy stop (<code>"noEarlyEfficacy"</code>),
default is <code>"OF"</code>.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_deltawt">deltaWT</code></td>
<td>
<p>Delta for Wang &amp; Tsiatis Delta class.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_deltapt1">deltaPT1</code></td>
<td>
<p>Delta1 for Pampallona &amp; Tsiatis class rejecting H0 boundaries.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_deltapt0">deltaPT0</code></td>
<td>
<p>Delta0 for Pampallona &amp; Tsiatis class rejecting H1 boundaries.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_optimizationcriterion">optimizationCriterion</code></td>
<td>
<p>Optimization criterion for optimum design within
Wang &amp; Tsiatis class (<code>"ASNH1"</code>, <code>"ASNIFH1"</code>,
<code>"ASNsum"</code>), default is <code>"ASNH1"</code>, see details.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_gammaa">gammaA</code></td>
<td>
<p>Parameter for alpha spending function.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_typebetaspending">typeBetaSpending</code></td>
<td>
<p>Type of beta spending. Type of of beta spending is one of the following:
O'Brien &amp; Fleming type beta spending, Pocock type beta spending,
Kim &amp; DeMets beta spending, Hwang, Shi &amp; DeCani beta spending, user defined
beta spending (<code>"bsOF"</code>, <code>"bsP"</code>, <code>"bsKD"</code>,
<code>"bsHSD"</code>, <code>"bsUser"</code>, default is <code>"none"</code>).</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_useralphaspending">userAlphaSpending</code></td>
<td>
<p>The user defined alpha spending.
Numeric vector of length <code>kMax</code> containing the cumulative
alpha-spending (Type I error rate) up to each interim stage: <code>0 &lt;= alpha_1 &lt;= ... &lt;= alpha_K &lt;= alpha</code>.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_userbetaspending">userBetaSpending</code></td>
<td>
<p>The user defined beta spending. Vector of length <code>kMax</code> containing the cumulative
beta-spending up to each interim stage.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_gammab">gammaB</code></td>
<td>
<p>Parameter for beta spending function.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_bindingfutility">bindingFutility</code></td>
<td>
<p>Logical. If <code>bindingFutility = TRUE</code> is specified the calculation of
the critical values is affected by the futility bounds and the futility threshold is binding in the
sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_betaadjustment">betaAdjustment</code></td>
<td>
<p>For two-sided beta spending designs, if <code>betaAdjustement = TRUE</code> a linear
adjustment of the beta spending values is performed if an overlapping of decision regions for futility
stopping at earlier stages occurs, otherwise no adjustment is performed (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_constantboundshp">constantBoundsHP</code></td>
<td>
<p>The constant bounds up to stage <code>kMax - 1</code> for the
Haybittle &amp; Peto design (default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_twosidedpower">twoSidedPower</code></td>
<td>
<p>For two-sided testing, if <code>twoSidedPower = TRUE</code> is specified
the sample size calculation is performed by considering both tails of the distribution.
Default is <code>FALSE</code>, i.e., it is assumed that one tail probability is equal to 0 or the power
should be directed to one part.</p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_delayedinformation">delayedInformation</code></td>
<td>
<p>Delay of information for delayed response designs. Can be a numeric value or a
numeric vector of length <code>kMax - 1</code></p>
</td></tr>
<tr><td><code id="getDesignGroupSequential_+3A_tolerance">tolerance</code></td>
<td>
<p>The numerical tolerance, default is <code>1e-08</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>typeOfDesign</code> some parameters are specified, others not.
For example, only if <code>typeOfDesign</code> <code>"asHSD"</code> is selected, <code>gammaA</code> needs to be specified.
</p>
<p>If an alpha spending approach was specified (<code>"asOF"</code>, <code>"asP"</code>, <code>"asKD"</code>, <code>"asHSD"</code>, or <code>"asUser"</code>)
additionally a beta spending function can be specified to produce futility bounds.
</p>
<p>For optimum designs, <code>"ASNH1"</code> minimizes the expected sample size under H1,
<code>"ASNIFH1"</code> minimizes the sum of the maximum sample and the expected sample size under H1,
and <code>"ASNsum"</code>  minimizes the sum of the maximum sample size, the expected sample size under a value midway H0 and H1,
and the expected sample size under H1.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesign">TrialDesign</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesign">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesign">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignSet">getDesignSet()</a></code> for creating a set of designs to compare different designs.
</p>
<p>Other design functions: 
<code><a href="#topic+getDesignCharacteristics">getDesignCharacteristics</a>()</code>,
<code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a>()</code>,
<code><a href="#topic+getDesignFisher">getDesignFisher</a>()</code>,
<code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal</a>()</code>,
<code><a href="#topic+getGroupSequentialProbabilities">getGroupSequentialProbabilities</a>()</code>,
<code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate two-sided critical values for a four-stage 
# Wang &amp; Tsiatis design with Delta = 0.25 at level alpha = 0.05
getDesignGroupSequential(kMax = 4, alpha = 0.05, sided = 2, 
    typeOfDesign = "WT", deltaWT = 0.25) 

# Calculate one-sided critical values and binding futility bounds for a three-stage 
# design with alpha- and beta-spending functions according to Kim &amp; DeMets with gamma = 2.5
# (planned informationRates as specified, default alpha = 0.025 and beta = 0.2)
getDesignGroupSequential(kMax = 3, informationRates = c(0.3, 0.75, 1), 
    typeOfDesign = "asKD", gammaA = 2.5, typeBetaSpending = "bsKD", 
    gammaB = 2.5, bindingFutility = TRUE)

# Calculate the Pocock type alpha spending critical values if the first 
# interim analysis was performed after 40% of the maximum information was observed
# and the second after 70% of the maximum information was observed (default alpha = 0.025)
getDesignGroupSequential(informationRates = c(0.4, 0.7), typeOfDesign = "asP") 

## End(Not run)

</code></pre>

<hr>
<h2 id='getDesignInverseNormal'>Get Design Inverse Normal</h2><span id='topic+getDesignInverseNormal'></span>

<h3>Description</h3>

<p>Provides adjusted boundaries and defines a group sequential design for its use in
the inverse normal combination test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignInverseNormal(
  ...,
  kMax = NA_integer_,
  alpha = NA_real_,
  beta = NA_real_,
  sided = 1L,
  informationRates = NA_real_,
  futilityBounds = NA_real_,
  typeOfDesign = c("OF", "P", "WT", "PT", "HP", "WToptimum", "asP", "asOF", "asKD",
    "asHSD", "asUser", "noEarlyEfficacy"),
  deltaWT = NA_real_,
  deltaPT1 = NA_real_,
  deltaPT0 = NA_real_,
  optimizationCriterion = c("ASNH1", "ASNIFH1", "ASNsum"),
  gammaA = NA_real_,
  typeBetaSpending = c("none", "bsP", "bsOF", "bsKD", "bsHSD", "bsUser"),
  userAlphaSpending = NA_real_,
  userBetaSpending = NA_real_,
  gammaB = NA_real_,
  bindingFutility = NA,
  directionUpper = NA,
  betaAdjustment = NA,
  constantBoundsHP = 3,
  twoSidedPower = NA,
  tolerance = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDesignInverseNormal_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_kmax">kMax</code></td>
<td>
<p>The maximum number of stages <code>K</code>.
Must be a positive integer of length 1 (default value is <code>3</code>).
The maximum selectable <code>kMax</code> is <code>20</code> for group sequential or inverse normal and
<code>6</code> for Fisher combination test designs.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_alpha">alpha</code></td>
<td>
<p>The significance level alpha, default is <code>0.025</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_beta">beta</code></td>
<td>
<p>Type II error rate, necessary for providing sample size calculations
(e.g., <code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans()</a></code>), beta spending function designs,
or optimum designs, default is <code>0.20</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_sided">sided</code></td>
<td>
<p>Is the alternative one-sided (<code>1</code>) or two-sided (<code>2</code>), default is <code>1</code>.
Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_informationrates">informationRates</code></td>
<td>
<p>The information rates t_1, ..., t_kMax (that must be fixed prior to the trial),
default is <code>(1:kMax) / kMax</code>. For the weighted inverse normal design, the weights are derived
through w_1 = sqrt(t_1), and w_k = sqrt(t_k - t_(k-1)). For the weighted Fisher's combination test, the
weights (scales) are w_k = sqrt((t_k - t_(k-1)) / t_1) (see the documentation).</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_futilitybounds">futilityBounds</code></td>
<td>
<p>The futility bounds, defined on the test statistic z scale
(numeric vector of length <code>kMax - 1</code>).</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_typeofdesign">typeOfDesign</code></td>
<td>
<p>The type of design. Type of design is one of the following:
O'Brien &amp; Fleming (<code>"OF"</code>), Pocock (<code>"P"</code>), Wang &amp; Tsiatis Delta class (<code>"WT"</code>),
Pampallona &amp; Tsiatis (<code>"PT"</code>), Haybittle &amp; Peto (&quot;HP&quot;),
Optimum design within Wang &amp; Tsiatis class (<code>"WToptimum"</code>),
O'Brien &amp; Fleming type alpha spending (<code>"asOF"</code>), Pocock type alpha spending (<code>"asP"</code>),
Kim &amp; DeMets alpha spending (<code>"asKD"</code>), Hwang, Shi &amp; DeCani alpha spending (<code>"asHSD"</code>),
user defined alpha spending (<code>"asUser"</code>), no early efficacy stop (<code>"noEarlyEfficacy"</code>),
default is <code>"OF"</code>.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_deltawt">deltaWT</code></td>
<td>
<p>Delta for Wang &amp; Tsiatis Delta class.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_deltapt1">deltaPT1</code></td>
<td>
<p>Delta1 for Pampallona &amp; Tsiatis class rejecting H0 boundaries.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_deltapt0">deltaPT0</code></td>
<td>
<p>Delta0 for Pampallona &amp; Tsiatis class rejecting H1 boundaries.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_optimizationcriterion">optimizationCriterion</code></td>
<td>
<p>Optimization criterion for optimum design within
Wang &amp; Tsiatis class (<code>"ASNH1"</code>, <code>"ASNIFH1"</code>,
<code>"ASNsum"</code>), default is <code>"ASNH1"</code>, see details.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_gammaa">gammaA</code></td>
<td>
<p>Parameter for alpha spending function.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_typebetaspending">typeBetaSpending</code></td>
<td>
<p>Type of beta spending. Type of of beta spending is one of the following:
O'Brien &amp; Fleming type beta spending, Pocock type beta spending,
Kim &amp; DeMets beta spending, Hwang, Shi &amp; DeCani beta spending, user defined
beta spending (<code>"bsOF"</code>, <code>"bsP"</code>, <code>"bsKD"</code>,
<code>"bsHSD"</code>, <code>"bsUser"</code>, default is <code>"none"</code>).</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_useralphaspending">userAlphaSpending</code></td>
<td>
<p>The user defined alpha spending.
Numeric vector of length <code>kMax</code> containing the cumulative
alpha-spending (Type I error rate) up to each interim stage: <code>0 &lt;= alpha_1 &lt;= ... &lt;= alpha_K &lt;= alpha</code>.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_userbetaspending">userBetaSpending</code></td>
<td>
<p>The user defined beta spending. Vector of length <code>kMax</code> containing the cumulative
beta-spending up to each interim stage.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_gammab">gammaB</code></td>
<td>
<p>Parameter for beta spending function.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_bindingfutility">bindingFutility</code></td>
<td>
<p>Logical. If <code>bindingFutility = TRUE</code> is specified the calculation of
the critical values is affected by the futility bounds and the futility threshold is binding in the
sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_betaadjustment">betaAdjustment</code></td>
<td>
<p>For two-sided beta spending designs, if <code>betaAdjustement = TRUE</code> a linear
adjustment of the beta spending values is performed if an overlapping of decision regions for futility
stopping at earlier stages occurs, otherwise no adjustment is performed (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_constantboundshp">constantBoundsHP</code></td>
<td>
<p>The constant bounds up to stage <code>kMax - 1</code> for the
Haybittle &amp; Peto design (default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_twosidedpower">twoSidedPower</code></td>
<td>
<p>For two-sided testing, if <code>twoSidedPower = TRUE</code> is specified
the sample size calculation is performed by considering both tails of the distribution.
Default is <code>FALSE</code>, i.e., it is assumed that one tail probability is equal to 0 or the power
should be directed to one part.</p>
</td></tr>
<tr><td><code id="getDesignInverseNormal_+3A_tolerance">tolerance</code></td>
<td>
<p>The numerical tolerance, default is <code>1e-08</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>typeOfDesign</code> some parameters are specified, others not.
For example, only if <code>typeOfDesign</code> <code>"asHSD"</code> is selected, <code>gammaA</code> needs to be specified.
</p>
<p>If an alpha spending approach was specified (<code>"asOF"</code>, <code>"asP"</code>, <code>"asKD"</code>, <code>"asHSD"</code>, or <code>"asUser"</code>)
additionally a beta spending function can be specified to produce futility bounds.
</p>
<p>For optimum designs, <code>"ASNH1"</code> minimizes the expected sample size under H1,
<code>"ASNIFH1"</code> minimizes the sum of the maximum sample and the expected sample size under H1,
and <code>"ASNsum"</code>  minimizes the sum of the maximum sample size, the expected sample size under a value midway H0 and H1,
and the expected sample size under H1.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesign">TrialDesign</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesign">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesign">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignSet">getDesignSet()</a></code> for creating a set of designs to compare different designs.
</p>
<p>Other design functions: 
<code><a href="#topic+getDesignCharacteristics">getDesignCharacteristics</a>()</code>,
<code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a>()</code>,
<code><a href="#topic+getDesignFisher">getDesignFisher</a>()</code>,
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential</a>()</code>,
<code><a href="#topic+getGroupSequentialProbabilities">getGroupSequentialProbabilities</a>()</code>,
<code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate two-sided critical values for a four-stage 
# Wang &amp; Tsiatis design with Delta = 0.25 at level alpha = 0.05
getDesignInverseNormal(kMax = 4, alpha = 0.05, sided = 2, 
    typeOfDesign = "WT", deltaWT = 0.25) 

# Defines a two-stage design at one-sided alpha = 0.025 with provision of early stopping  
# if the one-sided p-value exceeds 0.5 at interim and no early stopping for efficacy. 
# The futility bound is non-binding.
getDesignInverseNormal(kMax = 2, typeOfDesign = "noEarlyEfficacy", futilityBounds = 0)  

# Calculate one-sided critical values and binding futility bounds for a three-stage 
# design with alpha- and beta-spending functions according to Kim &amp; DeMets with gamma = 2.5
# (planned informationRates as specified, default alpha = 0.025 and beta = 0.2)
getDesignInverseNormal(kMax = 3, informationRates = c(0.3, 0.75, 1), 
    typeOfDesign = "asKD", gammaA = 2.5, typeBetaSpending = "bsKD", 
    gammaB = 2.5, bindingFutility = TRUE)

## End(Not run) 

</code></pre>

<hr>
<h2 id='getDesignSet'>Get Design Set</h2><span id='topic+getDesignSet'></span>

<h3>Description</h3>

<p>Creates a trial design set object and returns it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDesignSet(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDesignSet_+3A_...">...</code></td>
<td>
<p><code>designs</code> or <code>design</code> and one or more design parameters, e.g., <code>deltaWT = c(0.1, 0.3, 0.4)</code>.
</p>

<ul>
<li> <p><code>design</code> The master design (optional, you need to specify an
additional parameter that shall be varied).
</p>
</li>
<li> <p><code>designs</code> The designs to compare (optional, you need to specify the variable <code>variedParameters</code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Specify a master design and one or more design parameters or a list of designs.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignSet">TrialDesignSet</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.TrialDesignSet">names</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+length.TrialDesignSet">length</a></code> to obtain the number of design,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignSet">as.data.frame()</a></code>
to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code>
to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example 1
design &lt;- getDesignGroupSequential(
    alpha = 0.05, kMax = 6,
    sided = 2, typeOfDesign = "WT", deltaWT = 0.1
)
designSet &lt;- getDesignSet()
designSet$add(design = design, deltaWT = c(0.3, 0.4))
if (require(ggplot2)) plot(designSet, type = 1)

# Example 2 (shorter script)
design &lt;- getDesignGroupSequential(
    alpha = 0.05, kMax = 6,
    sided = 2, typeOfDesign = "WT", deltaWT = 0.1
)
designSet &lt;- getDesignSet(design = design, deltaWT = c(0.3, 0.4))
if (require(ggplot2)) plot(designSet, type = 1)

# Example 3 (use of designs instead of design)
d1 &lt;- getDesignGroupSequential(
    alpha = 0.05, kMax = 2,
    sided = 1, beta = 0.2, typeOfDesign = "asHSD",
    gammaA = 0.5, typeBetaSpending = "bsHSD", gammaB = 0.5
)
d2 &lt;- getDesignGroupSequential(
    alpha = 0.05, kMax = 4,
    sided = 1, beta = 0.2, typeOfDesign = "asP",
    typeBetaSpending = "bsP"
)
designSet &lt;- getDesignSet(
    designs = c(d1, d2),
    variedParameters = c("typeOfDesign", "kMax")
)
if (require(ggplot2)) plot(designSet, type = 8, nMax = 20)

## End(Not run)

</code></pre>

<hr>
<h2 id='getEventProbabilities'>Get Event Probabilities</h2><span id='topic+getEventProbabilities'></span>

<h3>Description</h3>

<p>Returns the event probabilities for specified parameters at given time vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEventProbabilities(
  time,
  ...,
  accrualTime = c(0, 12),
  accrualIntensity = 0.1,
  accrualIntensityType = c("auto", "absolute", "relative"),
  kappa = 1,
  piecewiseSurvivalTime = NA_real_,
  lambda2 = NA_real_,
  lambda1 = NA_real_,
  allocationRatioPlanned = 1,
  hazardRatio = NA_real_,
  dropoutRate1 = 0,
  dropoutRate2 = 0,
  dropoutTime = 12,
  maxNumberOfSubjects = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEventProbabilities_+3A_time">time</code></td>
<td>
<p>A numeric vector with time values.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_accrualtime">accrualTime</code></td>
<td>
<p>The assumed accrual time intervals for the study, default is
<code>c(0, 12)</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>A numeric vector of accrual intensities, default is the relative
intensity <code>0.1</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_accrualintensitytype">accrualIntensityType</code></td>
<td>
<p>A character value specifying the accrual intensity input type.
Must be one of <code>"auto"</code>, <code>"absolute"</code>, or <code>"relative"</code>; default is <code>"auto"</code>,
i.e., if all values are &lt; 1 the type is <code>"relative"</code>, otherwise it is <code>"absolute"</code>.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>A vector that specifies the time intervals for the piecewise
definition of the exponential survival time cumulative distribution function <br />
(for details see <code><a href="#topic+getPiecewiseSurvivalTime">getPiecewiseSurvivalTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_lambda2">lambda2</code></td>
<td>
<p>The assumed hazard rate in the reference group, there is no default.
<code>lambda2</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_lambda1">lambda1</code></td>
<td>
<p>The assumed hazard rate in the treatment group, there is no default.
<code>lambda1</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. If <code>allocationRatioPlanned = 0</code> is entered,
the optimal allocation ratio yielding the smallest overall sample size is determined.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_hazardratio">hazardRatio</code></td>
<td>
<p>The vector of hazard ratios under consideration.
If the event or hazard rates in both treatment groups are defined, the hazard ratio needs
not to be specified as it is calculated, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_dropoutrate1">dropoutRate1</code></td>
<td>
<p>The assumed drop-out rate in the treatment group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_dropoutrate2">dropoutRate2</code></td>
<td>
<p>The assumed drop-out rate in the control group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_dropouttime">dropoutTime</code></td>
<td>
<p>The assumed time for drop-out rates in the control and the
treatment group, default is <code>12</code>.</p>
</td></tr>
<tr><td><code id="getEventProbabilities_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p>If <code>maxNumberOfSubjects &gt; 0</code> is specified,
the end of accrual at specified <code>accrualIntensity</code> for the specified
number of subjects is determined or <code>accrualIntensity</code> is calculated
at fixed end of accrual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the overall event probabilities in a two treatment groups design.
For details of the parameters see <code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival()</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+EventProbabilities">EventProbabilities</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.EventProbabilities">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate event probabilities for staggered subjects' entry, piecewisely defined
# survival time and hazards, and plot it.
timeVector &lt;- seq(0, 100, 1)
y &lt;- getEventProbabilities(timeVector, accrualTime = c(0, 20, 60), 
    accrualIntensity = c(5, 20), 
    piecewiseSurvivalTime = c(0, 20, 80),
    lambda2 = c(0.02, 0.06, 0.1), 
    hazardRatio = 2
)
plot(timeVector, y$cumulativeEventProbabilities, type = 'l')

## End(Not run)
</code></pre>

<hr>
<h2 id='getFinalConfidenceInterval'>Get Final Confidence Interval</h2><span id='topic+getFinalConfidenceInterval'></span>

<h3>Description</h3>

<p>Returns the final confidence interval for the parameter of interest.
It is based on the prototype case, i.e., the test for testing a mean for
normally distributed variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFinalConfidenceInterval(
  design,
  dataInput,
  ...,
  directionUpper = NA,
  thetaH0 = NA_real_,
  tolerance = 1e-06,
  stage = NA_integer_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFinalConfidenceInterval_+3A_design">design</code></td>
<td>
<p>The trial design.</p>
</td></tr>
<tr><td><code id="getFinalConfidenceInterval_+3A_datainput">dataInput</code></td>
<td>
<p>The summary data used for calculating the test results.
This is either an element of <code>DatasetMeans</code>, of <code>DatasetRates</code>, or of <code>DatasetSurvival</code>
and should be created with the function <code><a href="#topic+getDataset">getDataset()</a></code>.
For more information see <code><a href="#topic+getDataset">getDataset()</a></code>.</p>
</td></tr>
<tr><td><code id="getFinalConfidenceInterval_+3A_...">...</code></td>
<td>
<p>Further (optional) arguments to be passed:
</p>

<dl>
<dt><code>normalApproximation</code></dt><dd>
<p>The type of computation of the p-values. Default is <code>FALSE</code> for
testing means (i.e., the t test is used) and TRUE for testing rates and the hazard ratio.
For testing rates, if <code>normalApproximation = FALSE</code> is specified, the binomial test
(one sample) or the exact test of Fisher (two samples) is used for calculating the p-values.
In the survival setting, <code>normalApproximation = FALSE</code> has no effect.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>The type of t test. For testing means in two treatment groups, either
the t test assuming that the variances are equal or the t test without assuming this,
i.e., the test of Welch-Satterthwaite is calculated, default is <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getFinalConfidenceInterval_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getFinalConfidenceInterval_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getFinalConfidenceInterval_+3A_tolerance">tolerance</code></td>
<td>
<p>The numerical tolerance, default is <code>1e-06</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getFinalConfidenceInterval_+3A_stage">stage</code></td>
<td>
<p>The stage number (optional). Default: total number of existing stages in the data input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>design</code> and <code>dataInput</code> the final confidence interval and median unbiased estimate
that is based on the stage-wise ordering of the sample space will be calculated and returned.
Additionally, a non-standardized (&quot;general&quot;) version is provided,
the estimated standard deviation must be used to obtain
the confidence interval for the parameter of interest.
</p>
<p>For the inverse normal combination test design with more than two
stages, a warning informs that the validity of the confidence interval is theoretically shown only if
no sample size change was performed.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> containing
</p>

<ul>
<li> <p><code>finalStage</code>,
</p>
</li>
<li> <p><code>medianUnbiased</code>,
</p>
</li>
<li> <p><code>finalConfidenceInterval</code>,
</p>
</li>
<li> <p><code>medianUnbiasedGeneral</code>, and
</p>
</li>
<li> <p><code>finalConfidenceIntervalGeneral</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(kMax = 2)
data &lt;- getDataset(
    n = c(20, 30),
    means = c(50, 51),
    stDevs = c(130, 140)
)
getFinalConfidenceInterval(design, dataInput = data)

## End(Not run)

</code></pre>

<hr>
<h2 id='getFinalPValue'>Get Final P Value</h2><span id='topic+getFinalPValue'></span>

<h3>Description</h3>

<p>Returns the final p-value for given stage results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFinalPValue(stageResults, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFinalPValue_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
<tr><td><code id="getFinalPValue_+3A_...">...</code></td>
<td>
<p>Only available for backward compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the final p-value is based on the stage-wise ordering of the sample space.
This enables the calculation for both the non-adaptive and the adaptive case.
For Fisher's combination test, it is available for <code>kMax = 2</code> only.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> containing
</p>

<ul>
<li> <p><code>finalStage</code>,
</p>
</li>
<li> <p><code>pFinal</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(kMax = 2)
data &lt;- getDataset(
    n      = c( 20,  30),
    means  = c( 50,  51),
    stDevs = c(130, 140)
)
getFinalPValue(getStageResults(design, dataInput = data))

## End(Not run)

</code></pre>

<hr>
<h2 id='getGroupSequentialProbabilities'>Get Group Sequential Probabilities</h2><span id='topic+getGroupSequentialProbabilities'></span>

<h3>Description</h3>

<p>Calculates probabilities in the group sequential setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGroupSequentialProbabilities(decisionMatrix, informationRates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGroupSequentialProbabilities_+3A_decisionmatrix">decisionMatrix</code></td>
<td>
<p>A matrix with either 2 or 4 rows and kMax = length(informationRates) columns, see details.</p>
</td></tr>
<tr><td><code id="getGroupSequentialProbabilities_+3A_informationrates">informationRates</code></td>
<td>
<p>The information rates t_1, ..., t_kMax (that must be fixed prior to the trial),
default is <code>(1:kMax) / kMax</code>. For the weighted inverse normal design, the weights are derived
through w_1 = sqrt(t_1), and w_k = sqrt(t_k - t_(k-1)). For the weighted Fisher's combination test, the
weights (scales) are w_k = sqrt((t_k - t_(k-1)) / t_1) (see the documentation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a sequence of information rates (fixing the correlation structure), and
decisionMatrix with either 2 or 4 rows and kMax = length(informationRates) columns,
this function calculates a probability matrix containing, for two rows, the probabilities:<br />
P(Z_1 &lt; l_1), P(l_1 &lt; Z_1 &lt; u_1, Z_2 &lt; l_2),..., P(l_kMax-1 &lt; Z_kMax-1 &lt; u_kMax-1, Z_kMax &lt; l_l_kMax)<br />
P(Z_1 &lt; u_1), P(l_1 &lt; Z_1 &lt; u_1, Z_2 &lt; u_2),..., P(l_kMax-1 &lt; Z_kMax-1 &lt; u_kMax-1, Z_kMax &lt; u_l_kMax)<br />
P(Z_1 &lt; Inf), P(l_1 &lt; Z_1 &lt; u_1, Z_2 &lt; Inf),..., P(l_kMax-1 &lt; Z_kMax-1 &lt; u_kMax-1, Z_kMax &lt; Inf)<br />
with continuation matrix<br />
l_1,...,l_kMax<br />
u_1,...,u_kMax<br />
That is, the output matrix of the function provides per stage (column) the cumulative probabilities
for values specified in decisionMatrix and Inf, and reaching the stage, i.e., the test
statistics is in the continuation region for the preceding stages.
For 4 rows, the continuation region contains of two regions and the probability matrix is
obtained analogously (cf., Wassmer and Brannath, 2016).
</p>


<h3>Value</h3>

<p>Returns a numeric matrix containing the probabilities described in the details section.
</p>


<h3>See Also</h3>

<p>Other design functions: 
<code><a href="#topic+getDesignCharacteristics">getDesignCharacteristics</a>()</code>,
<code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a>()</code>,
<code><a href="#topic+getDesignFisher">getDesignFisher</a>()</code>,
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential</a>()</code>,
<code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal</a>()</code>,
<code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate Type I error rates in the two-sided group sequential setting when
# performing kMax stages with constant critical boundaries at level alpha:
alpha &lt;- 0.05
kMax &lt;- 10
decisionMatrix &lt;- matrix(c(
    rep(-qnorm(1 - alpha / 2), kMax),
    rep(qnorm(1 - alpha / 2), kMax)
), nrow = 2, byrow = TRUE)
informationRates &lt;- (1:kMax) / kMax
probs &lt;- getGroupSequentialProbabilities(decisionMatrix, informationRates)
cumsum(probs[3, ] - probs[2, ] + probs[1, ])

# Do the same for a one-sided design without futility boundaries:
decisionMatrix &lt;- matrix(c(
    rep(-Inf, kMax),
    rep(qnorm(1 - alpha), kMax)
), nrow = 2, byrow = TRUE)
informationRates &lt;- (1:kMax) / kMax
probs &lt;- getGroupSequentialProbabilities(decisionMatrix, informationRates)
cumsum(probs[3, ] - probs[2, ])

# Check that two-sided Pampallona and Tsiatis boundaries with binding 
# futility bounds obtain Type I error probabilities equal to alpha:
x &lt;- getDesignGroupSequential(
    alpha = 0.05, beta = 0.1, kMax = 3, typeOfDesign = "PT",
    deltaPT0 = 0, deltaPT1 = 0.4, sided = 2, bindingFutility = TRUE
)
dm &lt;- matrix(c(
    -x$criticalValues, -x$futilityBounds, 0,
    x$futilityBounds, 0, x$criticalValues
), nrow = 4, byrow = TRUE)
dm[is.na(dm)] &lt;- 0
probs &lt;- getGroupSequentialProbabilities(
    decisionMatrix = dm, informationRates = (1:3) / 3
)
sum(probs[5, ] - probs[4, ] + probs[1, ])

# Check the Type I error rate decrease when using non-binding futility bounds:
x &lt;- getDesignGroupSequential(
    alpha = 0.05, beta = 0.1, kMax = 3, typeOfDesign = "PT",
    deltaPT0 = 0, deltaPT1 = 0.4, sided = 2, bindingFutility = FALSE
)
dm &lt;- matrix(c(
    -x$criticalValues, -x$futilityBounds, 0,
    x$futilityBounds, 0, x$criticalValues
), nrow = 4, byrow = TRUE)
dm[is.na(dm)] &lt;- 0
probs &lt;- getGroupSequentialProbabilities(
    decisionMatrix = dm, informationRates = (1:3) / 3
)
sum(probs[5, ] - probs[4, ] + probs[1, ])

## End(Not run)

</code></pre>

<hr>
<h2 id='getLambdaStepFunction'>Get Lambda Step Function</h2><span id='topic+getLambdaStepFunction'></span>

<h3>Description</h3>

<p>Calculates the lambda step values for a given time vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLambdaStepFunction(timeValues, ..., piecewiseSurvivalTime, piecewiseLambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLambdaStepFunction_+3A_timevalues">timeValues</code></td>
<td>
<p>A numeric vector that specifies the time values for which the lambda step values shall be calculated.</p>
</td></tr>
<tr><td><code id="getLambdaStepFunction_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getLambdaStepFunction_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>A numeric vector that specifies the time intervals for the piecewise
definition of the exponential survival time cumulative distribution function (see details).</p>
</td></tr>
<tr><td><code id="getLambdaStepFunction_+3A_piecewiselambda">piecewiseLambda</code></td>
<td>
<p>A numeric vector that specifies the assumed hazard rate in the treatment group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first element of the vector <code>piecewiseSurvivalTime</code> must be equal to <code>0</code>.
This function is used for plotting of sample size survival results
(cf., <code><a href="#topic+plot.TrialDesignPlan">plot</a></code>, <code>type = 13</code> and <code>type = 14</code>).
</p>


<h3>Value</h3>

<p>A numeric vector containing the lambda step values that corresponds to the specified time values.
</p>

<hr>
<h2 id='getLogLevel'>Get Log Level</h2><span id='topic+getLogLevel'></span>

<h3>Description</h3>

<p>Returns the current <code>rpact</code> log level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLogLevel()
</code></pre>


<h3>Details</h3>

<p>This function gets the log level of the <code>rpact</code> internal log message system.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> of length 1 specifying the current log level.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+setLogLevel">setLogLevel()</a></code> for setting the log level,
</p>
</li>
<li> <p><code><a href="#topic+resetLogLevel">resetLogLevel()</a></code> for resetting the log level to default.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># show current log level
getLogLevel()

</code></pre>

<hr>
<h2 id='getLongFormat'>Get Long Format</h2><span id='topic+getLongFormat'></span>

<h3>Description</h3>

<p>Returns the specified dataset as a <code><a href="base.html#topic+data.frame">data.frame</a></code> in so-called long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLongFormat(dataInput)
</code></pre>


<h3>Details</h3>

<p>In the long format (narrow, stacked), the data are presented with one column containing
all the values and another column listing the context of the value, i.e.,
the data for the different groups are in one column and the dataset contains an additional &quot;group&quot; column.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getWideFormat">getWideFormat()</a></code> for returning the dataset as a <code><a href="base.html#topic+data.frame">data.frame</a></code> in wide format.
</p>

<hr>
<h2 id='getNumberOfSubjects'>Get Number Of Subjects</h2><span id='topic+getNumberOfSubjects'></span>

<h3>Description</h3>

<p>Returns the number of recruited subjects at given time vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfSubjects(
  time,
  ...,
  accrualTime = c(0, 12),
  accrualIntensity = 0.1,
  accrualIntensityType = c("auto", "absolute", "relative"),
  maxNumberOfSubjects = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNumberOfSubjects_+3A_time">time</code></td>
<td>
<p>A numeric vector with time values.</p>
</td></tr>
<tr><td><code id="getNumberOfSubjects_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getNumberOfSubjects_+3A_accrualtime">accrualTime</code></td>
<td>
<p>The assumed accrual time intervals for the study, default is
<code>c(0, 12)</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getNumberOfSubjects_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>A numeric vector of accrual intensities, default is the relative
intensity <code>0.1</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getNumberOfSubjects_+3A_accrualintensitytype">accrualIntensityType</code></td>
<td>
<p>A character value specifying the accrual intensity input type.
Must be one of <code>"auto"</code>, <code>"absolute"</code>, or <code>"relative"</code>; default is <code>"auto"</code>,
i.e., if all values are &lt; 1 the type is <code>"relative"</code>, otherwise it is <code>"absolute"</code>.</p>
</td></tr>
<tr><td><code id="getNumberOfSubjects_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p>If <code>maxNumberOfSubjects &gt; 0</code> is specified,
the end of accrual at specified <code>accrualIntensity</code> for the specified number of
subjects is determined or <code>accrualIntensity</code> is calculated at fixed end of accrual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate number of subjects over time range at given accrual time vector
and accrual intensity. Intensity can either be defined in absolute or
relative terms (for the latter, <code>maxNumberOfSubjects</code> needs to be defined)<br />
The function is used by <code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival()</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+NumberOfSubjects">NumberOfSubjects</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.NumberOfSubjects">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AccrualTime">AccrualTime</a></code> for defining the accrual time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getNumberOfSubjects(time = seq(10, 70, 10), accrualTime = c(0, 20, 60), 
    accrualIntensity = c(5, 20))

getNumberOfSubjects(time = seq(10, 70, 10), accrualTime = c(0, 20, 60), 
    accrualIntensity = c(0.1, 0.4), maxNumberOfSubjects = 900)

## End(Not run)

</code></pre>

<hr>
<h2 id='getObservedInformationRates'>Get Observed Information Rates</h2><span id='topic+getObservedInformationRates'></span>

<h3>Description</h3>

<p>Recalculates the observed information rates from the specified dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObservedInformationRates(
  dataInput,
  ...,
  maxInformation = NULL,
  informationEpsilon = NULL,
  stage = NA_integer_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getObservedInformationRates_+3A_datainput">dataInput</code></td>
<td>
<p>The dataset for which the information rates shall be recalculated.</p>
</td></tr>
<tr><td><code id="getObservedInformationRates_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getObservedInformationRates_+3A_maxinformation">maxInformation</code></td>
<td>
<p>Positive integer value specifying the maximum information.</p>
</td></tr>
<tr><td><code id="getObservedInformationRates_+3A_informationepsilon">informationEpsilon</code></td>
<td>
<p>Positive integer value specifying the absolute information epsilon, which
defines the maximum distance from the observed information to the maximum information that causes the final analysis.
Updates at the final analysis in case the observed information at the final
analysis is smaller (&quot;under-running&quot;) than the planned maximum information <code>maxInformation</code>, default is 0.
Alternatively, a floating-point number &gt; 0 and &lt; 1 can be specified to define a relative information epsilon.</p>
</td></tr>
<tr><td><code id="getObservedInformationRates_+3A_stage">stage</code></td>
<td>
<p>The stage number (optional). Default: total number of existing stages in the data input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For means and rates the maximum information is the maximum number of subjects
or the relative proportion if <code>informationEpsilon</code> &lt; 1;
for survival data it is the maximum number of events
or the relative proportion if <code>informationEpsilon</code> &lt; 1.
</p>


<h3>Value</h3>

<p>Returns a list that summarizes the observed information rates.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code> for using
<code>getObservedInformationRates()</code> implicit,
</p>
</li>
<li> <p><a href="https://www.rpact.org/vignettes/planning/rpact_boundary_update_example/">www.rpact.org/vignettes/planning/rpact_boundary_update_example</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Absolute information epsilon:
# decision rule 45 &gt;= 46 - 1, i.e., under-running
data &lt;- getDataset(
    overallN = c(22, 45),
    overallEvents = c(11, 28)
)
getObservedInformationRates(data,
    maxInformation = 46, informationEpsilon = 1
)

# Relative information epsilon:
# last information rate = 45/46 = 0.9783,
# is &gt; 1 - 0.03 = 0.97, i.e., under-running
data &lt;- getDataset(
    overallN = c(22, 45),
    overallEvents = c(11, 28)
)
getObservedInformationRates(data,
    maxInformation = 46, informationEpsilon = 0.03
)

## End(Not run)

</code></pre>

<hr>
<h2 id='getOutputFormat'>Get Output Format</h2><span id='topic+getOutputFormat'></span>

<h3>Description</h3>

<p>With this function the format of the standard outputs of all <code>rpact</code>
objects can be shown and written to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOutputFormat(
  parameterName = NA_character_,
  ...,
  file = NA_character_,
  default = FALSE,
  fields = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getOutputFormat_+3A_parametername">parameterName</code></td>
<td>
<p>The name of the parameter whose output format shall be returned.
Leave the default <code>NA_character_</code> if
the output format of all parameters shall be returned.</p>
</td></tr>
<tr><td><code id="getOutputFormat_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getOutputFormat_+3A_file">file</code></td>
<td>
<p>An optional file name where to write the output formats
(see Details for more information).</p>
</td></tr>
<tr><td><code id="getOutputFormat_+3A_default">default</code></td>
<td>
<p>If <code>TRUE</code> the default output format of the specified parameter(s)
will be returned, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getOutputFormat_+3A_fields">fields</code></td>
<td>
<p>If <code>TRUE</code> the names of all affected object fields will be displayed, default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output formats can be written to a text file by specifying a <code>file</code>.
See <code><a href="#topic+setOutputFormat">setOutputFormat()</a></code>() to learn how to read a formerly saved file.
</p>
<p>Note that the <code>parameterName</code> must not match exactly, e.g., for p-values the
following parameter names will be recognized amongst others:
</p>

<ol>
<li> <p><code>p value</code>
</p>
</li>
<li> <p><code>p.values</code>
</p>
</li>
<li> <p><code>p-value</code>
</p>
</li>
<li> <p><code>pValue</code>
</p>
</li>
<li> <p><code>rpact.output.format.p.value</code>
</p>
</li></ol>



<h3>Value</h3>

<p>A named list of output formats.
</p>


<h3>See Also</h3>

<p>Other output formats: 
<code><a href="#topic+setOutputFormat">setOutputFormat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# show output format of p values
getOutputFormat("p.value")

# set new p value output format
setOutputFormat("p.value", digits = 5, nsmall = 5)

# show sample sizes as smallest integers not less than the not rounded values
setOutputFormat("sample size", digits = 0, nsmall = 0, roundFunction = "ceiling")
getSampleSizeMeans()

# show sample sizes as smallest integers not greater than the not rounded values
setOutputFormat("sample size", digits = 0, nsmall = 0, roundFunction = "floor")
getSampleSizeMeans()

# set new sample size output format without round function
setOutputFormat("sample size", digits = 2, nsmall = 2)
getSampleSizeMeans()

# reset sample size output format to default
setOutputFormat("sample size")
getSampleSizeMeans()
getOutputFormat("sample size")

## End(Not run)
</code></pre>

<hr>
<h2 id='getParameterCaption'>Get Parameter Caption</h2><span id='topic+getParameterCaption'></span>

<h3>Description</h3>

<p>Returns the parameter caption for a given object and parameter name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParameterCaption(obj, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getParameterCaption_+3A_obj">obj</code></td>
<td>
<p>The rpact result object.</p>
</td></tr>
<tr><td><code id="getParameterCaption_+3A_var">var</code></td>
<td>
<p>The variable/parameter name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies and returns the caption that will be used in print outputs of an rpact result object.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> of specifying the corresponding caption of a given parameter name.
Returns <code>NULL</code> if the specified <code>parameterName</code> does not exist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParameterName">getParameterName()</a></code> for getting the parameter name for a given caption.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getParameterCaption(getDesignInverseNormal(), "kMax")

## End(Not run)

</code></pre>

<hr>
<h2 id='getParameterName'>Get Parameter Name</h2><span id='topic+getParameterName'></span>

<h3>Description</h3>

<p>Returns the parameter name for a given object and parameter caption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParameterName(obj, parameterCaption)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getParameterName_+3A_obj">obj</code></td>
<td>
<p>The rpact result object.</p>
</td></tr>
<tr><td><code id="getParameterName_+3A_parametercaption">parameterCaption</code></td>
<td>
<p>The parameter caption.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies and returns the parameter name for a given caption
that will be used in print outputs of an rpact result object.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> of specifying the corresponding name of a given parameter caption.
Returns <code>NULL</code> if the specified <code>parameterCaption</code> does not exist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParameterCaption">getParameterCaption()</a></code> for getting the parameter caption for a given name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getParameterName(getDesignInverseNormal(), "Maximum number of stages")

## End(Not run)

</code></pre>

<hr>
<h2 id='getParameterType'>Get Parameter Type</h2><span id='topic+getParameterType'></span>

<h3>Description</h3>

<p>Returns the parameter type for a given object and parameter name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParameterType(obj, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getParameterType_+3A_obj">obj</code></td>
<td>
<p>The rpact result object.</p>
</td></tr>
<tr><td><code id="getParameterType_+3A_var">var</code></td>
<td>
<p>The variable/parameter name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies and returns the type that will be used in print outputs of an rpact result object.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> of specifying the corresponding type of a given parameter name.
Returns <code>NULL</code> if the specified <code>parameterName</code> does not exist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParameterName">getParameterName()</a></code> for getting the parameter name for a given caption.
<code><a href="#topic+getParameterCaption">getParameterCaption()</a></code> for getting the parameter caption for a given name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getParameterType(getDesignInverseNormal(), "kMax")

## End(Not run)

</code></pre>

<hr>
<h2 id='getPerformanceScore'>Get Performance Score</h2><span id='topic+getPerformanceScore'></span>

<h3>Description</h3>

<p>Calculates the conditional performance score, its sub-scores and components according to
(Herrmann et al. (2020), <a href="https://doi.org/10.1002/sim.8534">doi:10.1002/sim.8534</a>) and
(Bokelmann et al. (2024), <a href="https://doi.org/10.1186/s12874-024-02150-4">doi:10.1186/s12874-024-02150-4</a>) for a given
simulation result from a two-stage design with continuous or binary endpoint.
Larger (sub-)score and component values refer to a better performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPerformanceScore(simulationResult)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPerformanceScore_+3A_simulationresult">simulationResult</code></td>
<td>
<p>A simulation result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional performance score consists of two sub-scores, one for the sample size
(subscoreSampleSize) and one for the conditional power (subscoreConditionalPower).
Each of those are composed of a location (locationSampleSize, locationConditionalPower)
and variation component (variationSampleSize, variationConditionalPower).
The term conditional refers to an evaluation perspective where the interim results
suggest a trial continuation with a second stage.
The score can take values between 0 and 1. More details on the performance score
can be found in Herrmann et al. (2020), <a href="https://doi.org/10.1002/sim.8534">doi:10.1002/sim.8534</a> and
Bokelmann et al. (2024) <a href="https://doi.org/10.1186/s12874-024-02150-4">doi:10.1186/s12874-024-02150-4</a>.
</p>


<h3>Author(s)</h3>

<p>Stephen Schueuerhuis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example from Table 3 in "A new conditional performance score for 
# the evaluation of adaptive group sequential designs with samplesize 
# recalculation from Herrmann et al 2023", p. 2097 for 
# Observed Conditional Power approach and Delta = 0.5

# Create two-stage Pocock design with binding futility boundary at 0
design &lt;- getDesignGroupSequential(
    kMax = 2, typeOfDesign = "P", 
    futilityBounds = 0, bindingFutility = TRUE)

# Initialize sample sizes and effect; 
# Sample sizes are referring to overall stage-wise sample sizes
n1 &lt;- 100
n2 &lt;- 100
nMax &lt;- n1 + n2
alternative &lt;- 0.5

# Perform Simulation; nMax * 1.5 defines the maximum 
# sample size for the additional stage
simulationResult &lt;- getSimulationMeans(
    design = design,
    normalApproximation = TRUE,
    thetaH0 = 0,
    alternative = alternative,
    plannedSubjects = c(n1, nMax),
    minNumberOfSubjectsPerStage = c(NA_real_, 1),
    maxNumberOfSubjectsPerStage = c(NA_real_, nMax * 1.5),
    conditionalPower = 0.8,
    directionUpper = TRUE,
    maxNumberOfIterations = 1e05,
    seed = 140
)

# Calculate performance score
getPerformanceScore(simulationResult)

## End(Not run)

</code></pre>

<hr>
<h2 id='getPiecewiseSurvivalTime'>Get Piecewise Survival Time</h2><span id='topic+getPiecewiseSurvivalTime'></span>

<h3>Description</h3>

<p>Returns a <code>PiecewiseSurvivalTime</code> object that contains the all relevant parameters
of an exponential survival time cumulative distribution function.
Use <code><a href="base.html#topic+names">names</a></code> to obtain the field names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPiecewiseSurvivalTime(
  piecewiseSurvivalTime = NA_real_,
  ...,
  lambda1 = NA_real_,
  lambda2 = NA_real_,
  hazardRatio = NA_real_,
  pi1 = NA_real_,
  pi2 = NA_real_,
  median1 = NA_real_,
  median2 = NA_real_,
  eventTime = 12,
  kappa = 1,
  delayedResponseAllowed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPiecewiseSurvivalTime_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>A vector that specifies the time intervals for the piecewise
definition of the exponential survival time cumulative distribution function (see details).</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_lambda1">lambda1</code></td>
<td>
<p>The assumed hazard rate in the treatment group, there is no default.
<code>lambda1</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_lambda2">lambda2</code></td>
<td>
<p>The assumed hazard rate in the reference group, there is no default.
<code>lambda2</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_hazardratio">hazardRatio</code></td>
<td>
<p>The vector of hazard ratios under consideration.
If the event or hazard rates in both treatment groups are defined, the hazard ratio needs
not to be specified as it is calculated, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed event rate in the treatment group,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed event rate in the control group, default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_median1">median1</code></td>
<td>
<p>The assumed median survival time in the treatment group, there is no default.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_median2">median2</code></td>
<td>
<p>The assumed median survival time in the reference group, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_eventtime">eventTime</code></td>
<td>
<p>The assumed time under which the event rates are calculated, default is <code>12</code>.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
<tr><td><code id="getPiecewiseSurvivalTime_+3A_delayedresponseallowed">delayedResponseAllowed</code></td>
<td>
<p>If <code>TRUE</code>, delayed response is allowed;
otherwise it will be validated that the response is not delayed, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PiecewiseSurvivalTime">PiecewiseSurvivalTime</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.ParameterSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Piecewise survival time</h3>

<p>The first element of the vector <code>piecewiseSurvivalTime</code> must be equal to <code>0</code>.
<code>piecewiseSurvivalTime</code> can also be a list that combines the definition of the
time intervals and hazard rates in the reference group.
The definition of the survival time in the treatment group is obtained by the specification
of the hazard ratio (see examples for details).
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getPiecewiseSurvivalTime(lambda2 = 0.5, hazardRatio = 0.8)

getPiecewiseSurvivalTime(lambda2 = 0.5, lambda1 = 0.4)

getPiecewiseSurvivalTime(pi2 = 0.5, hazardRatio = 0.8)

getPiecewiseSurvivalTime(pi2 = 0.5, pi1 = 0.4)

getPiecewiseSurvivalTime(pi1 = 0.3)

getPiecewiseSurvivalTime(hazardRatio = c(0.6, 0.8), lambda2 = 0.4)

getPiecewiseSurvivalTime(piecewiseSurvivalTime = c(0, 6, 9), 
    lambda2 = c(0.025, 0.04, 0.015), hazardRatio = 0.8)

getPiecewiseSurvivalTime(piecewiseSurvivalTime = c(0, 6, 9), 
    lambda2 = c(0.025, 0.04, 0.015), 
    lambda1 = c(0.025, 0.04, 0.015) * 0.8)

pwst &lt;- getPiecewiseSurvivalTime(list(
    "0 - &lt;6"   = 0.025, 
    "6 - &lt;9"   = 0.04, 
    "9 - &lt;15"  = 0.015, 
    "15 - &lt;21" = 0.01, 
    "&gt;=21"     = 0.007), hazardRatio = 0.75)
pwst

# The object created by getPiecewiseSurvivalTime() can be used directly in 
# getSampleSizeSurvival():
getSampleSizeSurvival(piecewiseSurvivalTime = pwst)

# The object created by getPiecewiseSurvivalTime() can be used directly in 
# getPowerSurvival():
getPowerSurvival(piecewiseSurvivalTime = pwst, 
    maxNumberOfEvents = 40, maxNumberOfSubjects = 100)

## End(Not run)
 
</code></pre>

<hr>
<h2 id='getPlotSettings'>Get Plot Settings</h2><span id='topic+getPlotSettings'></span>

<h3>Description</h3>

<p>Returns a plot settings object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPlotSettings(
  lineSize = 0.8,
  pointSize = 3,
  pointColor = NA_character_,
  mainTitleFontSize = 14,
  axesTextFontSize = 10,
  legendFontSize = 11,
  scalingFactor = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPlotSettings_+3A_linesize">lineSize</code></td>
<td>
<p>The line size, default is <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="getPlotSettings_+3A_pointsize">pointSize</code></td>
<td>
<p>The point size, default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="getPlotSettings_+3A_pointcolor">pointColor</code></td>
<td>
<p>The point color (character), default is <code>NA_character_</code>.</p>
</td></tr>
<tr><td><code id="getPlotSettings_+3A_maintitlefontsize">mainTitleFontSize</code></td>
<td>
<p>The main title font size, default is <code>14</code>.</p>
</td></tr>
<tr><td><code id="getPlotSettings_+3A_axestextfontsize">axesTextFontSize</code></td>
<td>
<p>The axes text font size, default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="getPlotSettings_+3A_legendfontsize">legendFontSize</code></td>
<td>
<p>The legend font size, default is <code>11</code>.</p>
</td></tr>
<tr><td><code id="getPlotSettings_+3A_scalingfactor">scalingFactor</code></td>
<td>
<p>The scaling factor, default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an object of class <code>PlotSettings</code> that collects typical plot settings.
</p>

<hr>
<h2 id='getPowerAndAverageSampleNumber'>Get Power And Average Sample Number</h2><span id='topic+getPowerAndAverageSampleNumber'></span>

<h3>Description</h3>

<p>Returns the power and average sample number of the specified design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerAndAverageSampleNumber(design, theta = seq(-1, 1, 0.02), nMax = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPowerAndAverageSampleNumber_+3A_design">design</code></td>
<td>
<p>The trial design.</p>
</td></tr>
<tr><td><code id="getPowerAndAverageSampleNumber_+3A_theta">theta</code></td>
<td>
<p>A vector of standardized effect sizes (theta values), default is a sequence from -1 to 1.</p>
</td></tr>
<tr><td><code id="getPowerAndAverageSampleNumber_+3A_nmax">nMax</code></td>
<td>
<p>The maximum sample size. Must be a positive integer of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the power and average sample number (ASN) of the specified
design for the prototype case which is testing H0: mu = mu0 in a one-sample design.
<code>theta</code> represents the standardized effect <code>(mu - mu0) / sigma</code> and power and ASN
is calculated for maximum sample size <code>nMax</code>.
For other designs than the one-sample test of a mean the standardized effect needs to be adjusted accordingly.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PowerAndAverageSampleNumberResult">PowerAndAverageSampleNumberResult</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.ParameterSet">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.PowerAndAverageSampleNumberResult">as.data.frame()</a></code>
to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other design functions: 
<code><a href="#topic+getDesignCharacteristics">getDesignCharacteristics</a>()</code>,
<code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a>()</code>,
<code><a href="#topic+getDesignFisher">getDesignFisher</a>()</code>,
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential</a>()</code>,
<code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal</a>()</code>,
<code><a href="#topic+getGroupSequentialProbabilities">getGroupSequentialProbabilities</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate power, stopping probabilities, and expected sample 
# size for the default design with specified theta and nMax  
getPowerAndAverageSampleNumber(
    getDesignGroupSequential(), 
    theta = seq(-1, 1, 0.5), nMax = 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='getPowerCounts'>Get Power Counts</h2><span id='topic+getPowerCounts'></span>

<h3>Description</h3>

<p>Returns the power, stopping probabilities, and expected sample size for testing mean rates
for negative binomial distributed event numbers in two samples at given sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerCounts(
  design = NULL,
  ...,
  directionUpper = NA,
  maxNumberOfSubjects = NA_real_,
  lambda1 = NA_real_,
  lambda2 = NA_real_,
  lambda = NA_real_,
  theta = NA_real_,
  thetaH0 = 1,
  overdispersion = 0,
  fixedExposureTime = NA_real_,
  accrualTime = NA_real_,
  accrualIntensity = NA_real_,
  followUpTime = NA_real_,
  allocationRatioPlanned = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPowerCounts_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified for power calculations or calculation
of necessary follow-up (count data). For two treatment arms, it is the maximum number of subjects for both treatment arms.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_lambda1">lambda1</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the active treatment group, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_lambda2">lambda2</code></td>
<td>
<p>A numeric value that represents the assumed rate of a homogeneous Poisson process in
the control group, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the pooled treatment groups, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_theta">theta</code></td>
<td>
<p>A numeric value or vector that represents the assumed mean ratios lambda1/lambda2 of a homogeneous
Poisson process, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_overdispersion">overdispersion</code></td>
<td>
<p>A numeric value that represents the assumed overdispersion of the negative binomial distribution,
default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_fixedexposuretime">fixedExposureTime</code></td>
<td>
<p>If specified, the fixed time of exposure per subject for count data, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_accrualtime">accrualTime</code></td>
<td>
<p>If specified, the assumed accrual time interval(s) for the study, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>If specified, the assumed accrual intensities for the study, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_followuptime">followUpTime</code></td>
<td>
<p>If specified, the assumed (additional) follow-up time for the study, there is no default.
The total study duration is <code>accrualTime + followUpTime</code>.</p>
</td></tr>
<tr><td><code id="getPowerCounts_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the power, stopping probabilities, and expected sample size
for testing the ratio of two mean rates of negative binomial distributed event numbers in two samples
at given maximum sample size and effect.
The power calculation is performed either for a fixed exposure time or a variable exposure time with fixed follow-up
where the information over the stages is calculated according to the specified information rate in the design.
Additionally, an allocation ratio = <code>n1 / n2</code> can be specified where <code>n1</code> and <code>n2</code> are the number
of subjects in the two treatment groups. A null hypothesis value <code>thetaH0</code> can also be specified.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other power functions: 
<code><a href="#topic+getPowerMeans">getPowerMeans</a>()</code>,
<code><a href="#topic+getPowerRates">getPowerRates</a>()</code>,
<code><a href="#topic+getPowerSurvival">getPowerSurvival</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size trial where a therapy is assumed to decrease the 
# exacerbation rate from 1.4 to 1.05 (25% decrease) within an 
# observation period of 1 year, i.e., each subject has a equal 
# follow-up of 1 year.
# Calculate power at significance level 0.025 at given sample size = 180 
# for a range of lambda1 values if the overdispersion is assumed to be 
# equal to 0.5, is obtained by
getPowerCounts(alpha = 0.025, lambda1 = seq(1, 1.4, 0.05), lambda2 = 1.4, 
    maxNumberOfSubjects = 180, overdispersion = 0.5, fixedExposureTime = 1)

# Group sequential alpha and beta spending function design with O'Brien and 
# Fleming type boundaries: Power and test characteristics for N = 286, 
# under the assumption of a fixed exposure time, and for a range of 
# lambda1 values: 
getPowerCounts(design = getDesignGroupSequential(
        kMax = 3, alpha = 0.025, beta = 0.2, 
        typeOfDesign = "asOF", typeBetaSpending = "bsOF"), 
    lambda1 = seq(0.17, 0.23, 0.01), lambda2 = 0.3, 
    directionUpper = FALSE, overdispersion = 1, maxNumberOfSubjects = 286, 
    fixedExposureTime = 12, accrualTime = 6)

# Group sequential design alpha spending function design with O'Brien and 
# Fleming type boundaries: Power and test characteristics for N = 1976, 
# under variable exposure time with uniform recruitment over 1.25 months,
# study time (accrual + followup) = 4 (lambda1, lambda2, and overdispersion 
# as specified, no futility stopping):
getPowerCounts(design = getDesignGroupSequential(
        kMax = 3, alpha = 0.025, beta = 0.2, typeOfDesign = "asOF"),
    lambda1 = seq(0.08, 0.09, 0.0025), lambda2 = 0.125, 
    overdispersion = 5, directionUpper = FALSE, maxNumberOfSubjects = 1976, 
    followUpTime = 2.75, accrualTime = 1.25)

## End(Not run)

</code></pre>

<hr>
<h2 id='getPowerMeans'>Get Power Means</h2><span id='topic+getPowerMeans'></span>

<h3>Description</h3>

<p>Returns the power, stopping probabilities, and expected sample size for
testing means in one or two samples at given maximum sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerMeans(
  design = NULL,
  ...,
  groups = 2L,
  normalApproximation = FALSE,
  meanRatio = FALSE,
  thetaH0 = ifelse(meanRatio, 1, 0),
  alternative = seq(0, 1, 0.2),
  stDev = 1,
  directionUpper = NA,
  maxNumberOfSubjects = NA_real_,
  allocationRatioPlanned = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPowerMeans_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_groups">groups</code></td>
<td>
<p>The number of treatment groups (1 or 2), default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_normalapproximation">normalApproximation</code></td>
<td>
<p>The type of computation of the p-values. If <code>TRUE</code>, the variance is
assumed to be known, default is <code>FALSE</code>, i.e., the calculations are performed
with the t distribution.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_meanratio">meanRatio</code></td>
<td>
<p>If <code>TRUE</code>, the sample size for
one-sided testing of H0: <code>mu1 / mu2 = thetaH0</code> is calculated, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_alternative">alternative</code></td>
<td>
<p>The alternative hypothesis value for testing means. This can be a vector of assumed
alternatives, default is <code>seq(0, 1, 0.2)</code> (power calculations) or <code>seq(0.2, 1, 0.2)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_stdev">stDev</code></td>
<td>
<p>The standard deviation under which the sample size or power
calculation is performed, default is <code>1</code>.
If <code>meanRatio = TRUE</code> is specified, <code>stDev</code> defines
the coefficient of variation <code>sigma / mu2</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified for power calculations or calculation
of necessary follow-up (count data). For two treatment arms, it is the maximum number of subjects for both treatment arms.</p>
</td></tr>
<tr><td><code id="getPowerMeans_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the power, stopping probabilities,
and expected sample size for testing means at given sample size.
In a two treatment groups design, additionally, an allocation ratio = <code>n1 / n2</code>
can be specified where <code>n1</code> and <code>n2</code> are the number
of subjects in the two treatment groups.
A null hypothesis value thetaH0 != 0 for testing the difference of two means
or <code>thetaH0 != 1</code> for testing the ratio of two means can be specified.
For the specified sample size, critical bounds and stopping for futility
bounds are provided at the effect scale (mean, mean difference, or
mean ratio, respectively)
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other power functions: 
<code><a href="#topic+getPowerCounts">getPowerCounts</a>()</code>,
<code><a href="#topic+getPowerRates">getPowerRates</a>()</code>,
<code><a href="#topic+getPowerSurvival">getPowerSurvival</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate the power, stopping probabilities, and expected sample size 
# for testing H0: mu1 - mu2 = 0 in a two-armed design against a range of 
# alternatives H1: mu1 - m2 = delta, delta = (0, 1, 2, 3, 4, 5), 
# standard deviation sigma = 8, maximum sample size N = 80 (both treatment 
# arms), and an allocation ratio n1/n2 = 2. The design is a three stage 
# O'Brien &amp; Fleming design with non-binding futility bounds (-0.5, 0.5) 
# for the two interims. The computation takes into account that the t test 
# is used (normalApproximation = FALSE). 
getPowerMeans(getDesignGroupSequential(alpha = 0.025, 
    sided = 1, futilityBounds = c(-0.5, 0.5)), 
    groups = 2, alternative = c(0:5), stDev = 8,
    normalApproximation = FALSE, maxNumberOfSubjects = 80, 
    allocationRatioPlanned = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='getPowerRates'>Get Power Rates</h2><span id='topic+getPowerRates'></span>

<h3>Description</h3>

<p>Returns the power, stopping probabilities, and expected sample size for testing rates
in one or two samples at given maximum sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerRates(
  design = NULL,
  ...,
  groups = 2L,
  riskRatio = FALSE,
  thetaH0 = ifelse(riskRatio, 1, 0),
  pi1 = seq(0.2, 0.5, 0.1),
  pi2 = 0.2,
  directionUpper = NA,
  maxNumberOfSubjects = NA_real_,
  allocationRatioPlanned = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPowerRates_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_groups">groups</code></td>
<td>
<p>The number of treatment groups (1 or 2), default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_riskratio">riskRatio</code></td>
<td>
<p>If <code>TRUE</code>, the power for one-sided
testing of H0: <code>pi1 / pi2 = thetaH0</code> is calculated, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed probability in
the active treatment group if two treatment groups
are considered, or the alternative probability for a one treatment group design,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed probability in the reference group if two treatment
groups are considered, default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified for power calculations or calculation
of necessary follow-up (count data). For two treatment arms, it is the maximum number of subjects for both treatment arms.</p>
</td></tr>
<tr><td><code id="getPowerRates_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the power, stopping probabilities, and expected sample size
for testing rates at given maximum sample size.
The sample sizes over the stages are calculated according to the specified information rate in the design.
In a two treatment groups design, additionally, an allocation ratio = <code>n1 / n2</code> can be specified
where <code>n1</code> and <code>n2</code> are the number of subjects in the two treatment groups.
If a null hypothesis value thetaH0 != 0 for testing the difference of two rates
or <code>thetaH0 != 1</code> for testing the risk ratio is specified, the
formulas according to Farrington &amp; Manning (Statistics in Medicine, 1990) are used (only one-sided testing).
Critical bounds and stopping for futility bounds are provided at the effect scale
(rate, rate difference, or rate ratio, respectively).
For the two-sample case, the calculation here is performed at fixed pi2 as given as argument in the function.
Note that the power calculation for rates is always based on the normal approximation.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other power functions: 
<code><a href="#topic+getPowerCounts">getPowerCounts</a>()</code>,
<code><a href="#topic+getPowerMeans">getPowerMeans</a>()</code>,
<code><a href="#topic+getPowerSurvival">getPowerSurvival</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate the power, stopping probabilities, and expected sample size in a
# two-armed design at given maximum sample size N = 200 in a three-stage 
# O'Brien &amp; Fleming design with information rate vector (0.2,0.5,1), 
# non-binding futility boundaries (0,0), i.e., the study stops for futility 
# if the p-value exceeds 0.5 at interm, and allocation ratio = 2 for a range 
# of pi1 values when testing H0: pi1 - pi2 = -0.1:
getPowerRates(getDesignGroupSequential(informationRates = c(0.2, 0.5, 1), 
    futilityBounds = c(0, 0)), groups = 2, thetaH0 = -0.1, 
    pi1 = seq(0.3, 0.6, 0.1), directionUpper = FALSE, 
    pi2 = 0.7, allocationRatioPlanned = 2, maxNumberOfSubjects = 200)

# Calculate the power, stopping probabilities, and expected sample size in a single 
# arm design at given maximum sample size N = 60 in a three-stage two-sided 
# O'Brien &amp; Fleming design with information rate vector (0.2, 0.5,1) 
# for a range of pi1 values when testing H0: pi = 0.3:
getPowerRates(getDesignGroupSequential(informationRates = c(0.2, 0.5,1), 
    sided = 2), groups = 1, thetaH0 = 0.3, pi1 = seq(0.3, 0.5, 0.05),  
    maxNumberOfSubjects = 60)

## End(Not run)

</code></pre>

<hr>
<h2 id='getPowerSurvival'>Get Power Survival</h2><span id='topic+getPowerSurvival'></span>

<h3>Description</h3>

<p>Returns the power, stopping probabilities, and expected sample size for testing
the hazard ratio in a two treatment groups survival design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerSurvival(
  design = NULL,
  ...,
  typeOfComputation = c("Schoenfeld", "Freedman", "HsiehFreedman"),
  thetaH0 = 1,
  directionUpper = NA,
  pi1 = NA_real_,
  pi2 = NA_real_,
  lambda1 = NA_real_,
  lambda2 = NA_real_,
  median1 = NA_real_,
  median2 = NA_real_,
  kappa = 1,
  hazardRatio = NA_real_,
  piecewiseSurvivalTime = NA_real_,
  allocationRatioPlanned = 1,
  eventTime = 12,
  accrualTime = c(0, 12),
  accrualIntensity = 0.1,
  accrualIntensityType = c("auto", "absolute", "relative"),
  maxNumberOfSubjects = NA_real_,
  maxNumberOfEvents = NA_real_,
  dropoutRate1 = 0,
  dropoutRate2 = 0,
  dropoutTime = 12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPowerSurvival_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_typeofcomputation">typeOfComputation</code></td>
<td>
<p>Three options are available: <code>"Schoenfeld"</code>, <code>"Freedman"</code>, <code>"HsiehFreedman"</code>,
the default is <code>"Schoenfeld"</code>. For details, see Hsieh (Statistics in Medicine, 1992).
For non-inferiority testing (i.e., <code>thetaH0 != 1</code>), only Schoenfeld's formula can be used.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed event rate in the treatment group,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed event rate in the control group, default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_lambda1">lambda1</code></td>
<td>
<p>The assumed hazard rate in the treatment group, there is no default.
<code>lambda1</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_lambda2">lambda2</code></td>
<td>
<p>The assumed hazard rate in the reference group, there is no default.
<code>lambda2</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_median1">median1</code></td>
<td>
<p>The assumed median survival time in the treatment group, there is no default.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_median2">median2</code></td>
<td>
<p>The assumed median survival time in the reference group, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_hazardratio">hazardRatio</code></td>
<td>
<p>The vector of hazard ratios under consideration.
If the event or hazard rates in both treatment groups are defined, the hazard ratio needs
not to be specified as it is calculated, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>A vector that specifies the time intervals for the piecewise
definition of the exponential survival time cumulative distribution function <br />
(for details see <code><a href="#topic+getPiecewiseSurvivalTime">getPiecewiseSurvivalTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_eventtime">eventTime</code></td>
<td>
<p>The assumed time under which the event rates are calculated, default is <code>12</code>.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_accrualtime">accrualTime</code></td>
<td>
<p>The assumed accrual time intervals for the study, default is
<code>c(0, 12)</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>A numeric vector of accrual intensities, default is the relative
intensity <code>0.1</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_accrualintensitytype">accrualIntensityType</code></td>
<td>
<p>A character value specifying the accrual intensity input type.
Must be one of <code>"auto"</code>, <code>"absolute"</code>, or <code>"relative"</code>; default is <code>"auto"</code>,
i.e., if all values are &lt; 1 the type is <code>"relative"</code>, otherwise it is <code>"absolute"</code>.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified.
If accrual time and accrual intensity are specified, this will be calculated. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_maxnumberofevents">maxNumberOfEvents</code></td>
<td>
<p><code>maxNumberOfEvents &gt; 0</code> is the maximum number of events, it determines
the power of the test and needs to be specified.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_dropoutrate1">dropoutRate1</code></td>
<td>
<p>The assumed drop-out rate in the treatment group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_dropoutrate2">dropoutRate2</code></td>
<td>
<p>The assumed drop-out rate in the control group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getPowerSurvival_+3A_dropouttime">dropoutTime</code></td>
<td>
<p>The assumed time for drop-out rates in the control and the
treatment group, default is <code>12</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the power, stopping probabilities, and expected
sample size at given number of events and number of subjects.
It also calculates the time when the required events are expected under the given
assumptions (exponentially, piecewise exponentially, or Weibull distributed survival times
and constant or non-constant piecewise accrual).
Additionally, an allocation ratio = <code>n1 / n2</code> can be specified where <code>n1</code> and <code>n2</code> are the number
of subjects in the two treatment groups.
</p>
<p>The formula of Kim &amp; Tsiatis (Biometrics, 1990)
is used to calculate the expected number of events under the alternative
(see also Lakatos &amp; Lan, Statistics in Medicine, 1992). These formulas are generalized to piecewise survival times and
non-constant piecewise accrual over time.<br />
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Piecewise survival time</h3>

<p>The first element of the vector <code>piecewiseSurvivalTime</code> must be equal to <code>0</code>.
<code>piecewiseSurvivalTime</code> can also be a list that combines the definition of the
time intervals and hazard rates in the reference group.
The definition of the survival time in the treatment group is obtained by the specification
of the hazard ratio (see examples for details).
</p>


<h3>Staggered patient entry</h3>

<p><code>accrualTime</code> is the time period of subjects' accrual in a study.
It can be a value that defines the end of accrual or a vector.
In this case, <code>accrualTime</code> can be used to define a non-constant accrual over time.
For this, <code>accrualTime</code> is a vector that defines the accrual intervals.
The first element of <code>accrualTime</code> must be equal to <code>0</code> and, additionally,
<code>accrualIntensity</code> needs to be specified.
<code>accrualIntensity</code> itself is a value or a vector (depending on the
length of <code>accrualTime</code>) that defines the intensity how subjects
enter the trial in the intervals defined through <code>accrualTime</code>.
</p>
<p><code>accrualTime</code> can also be a list that combines the definition of the accrual time and
accrual intensity (see below and examples for details).
</p>
<p>If the length of <code>accrualTime</code> and the length of <code>accrualIntensity</code> are the same
(i.e., the end of accrual is undefined), <code>maxNumberOfSubjects &gt; 0</code> needs to be specified
and the end of accrual is calculated.
In that case, <code>accrualIntensity</code> is the number of subjects per time unit, i.e., the absolute accrual intensity.
</p>
<p>If the length of <code>accrualTime</code> equals the length of <code>accrualIntensity - 1</code>
(i.e., the end of accrual is defined), <code>maxNumberOfSubjects</code> is calculated if the absolute accrual intensity is given.
If all elements in <code>accrualIntensity</code> are smaller than 1, <code>accrualIntensity</code> defines
the <em>relative</em> intensity how subjects enter the trial.
For example, <code>accrualIntensity = c(0.1, 0.2)</code> specifies that in the second accrual interval
the intensity is doubled as compared to the first accrual interval. The actual (absolute) accrual intensity
is calculated for the calculated or given <code>maxNumberOfSubjects</code>.
Note that the default is <code>accrualIntensity = 0.1</code> meaning that the <em>absolute</em> accrual intensity
will be calculated.
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other power functions: 
<code><a href="#topic+getPowerCounts">getPowerCounts</a>()</code>,
<code><a href="#topic+getPowerMeans">getPowerMeans</a>()</code>,
<code><a href="#topic+getPowerRates">getPowerRates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size with minimum required definitions, pi1 = c(0.2, 0.3, 0.4, 0.5) and 
# pi2 = 0.2 at event time 12, accrual time 12 and follow-up time 6 as default 
getPowerSurvival(maxNumberOfEvents = 40, maxNumberOfSubjects = 200)

# Four stage O'Brien &amp; Fleming group sequential design with minimum required 
# definitions, pi1 = c(0.2, 0.3, 0.4, 0.5) and pi2 = 0.2 at event time 12, 
# accrual time 12 and follow-up time 6 as default  
getPowerSurvival(design = getDesignGroupSequential(kMax = 4), 
    maxNumberOfEvents = 40, maxNumberOfSubjects = 200)

# For fixed sample design, determine necessary accrual time if 200 subjects and 
# 30 subjects per time unit can be recruited 
getPowerSurvival(maxNumberOfEvents = 40, accrualTime = c(0), 
    accrualIntensity = 30, maxNumberOfSubjects = 200)

# Determine necessary accrual time if 200 subjects and if the first 6 time units 
# 20 subjects per time unit can be recruited, then 30 subjects per time unit 
getPowerSurvival(maxNumberOfEvents = 40, accrualTime = c(0, 6), 
    accrualIntensity = c(20, 30), maxNumberOfSubjects = 200)

# Determine maximum number of Subjects if the first 6 time units 20 subjects per 
# time unit can be recruited, and after 10 time units 30 subjects per time unit
getPowerSurvival(maxNumberOfEvents = 40, accrualTime = c(0, 6, 10), 
    accrualIntensity = c(20, 30))

# Specify accrual time as a list
at &lt;- list(
    "0 - &lt;6"  = 20,
    "6 - Inf" = 30)
getPowerSurvival(maxNumberOfEvents = 40, accrualTime = at, maxNumberOfSubjects = 200)

# Specify accrual time as a list, if maximum number of subjects need to be calculated
at &lt;- list(
    "0 - &lt;6"   = 20,
    "6 - &lt;=10" = 30) 
getPowerSurvival(maxNumberOfEvents = 40, accrualTime = at)

# Specify effect size for a two-stage group design with O'Brien &amp; Fleming boundaries
# Effect size is based on event rates at specified event time, directionUpper = FALSE 
# needs to be specified because it should be shown that hazard ratio &lt; 1
getPowerSurvival(design = getDesignGroupSequential(kMax = 2), pi1 = 0.2, pi2 = 0.3, 
    eventTime = 24, maxNumberOfEvents = 40, maxNumberOfSubjects = 200, 
    directionUpper = FALSE)

# Effect size is based on event rate at specified event time for the reference group 
# and hazard ratio, directionUpper = FALSE needs to be specified 
# because it should be shown that hazard ratio &lt; 1
getPowerSurvival(design = getDesignGroupSequential(kMax = 2), hazardRatio = 0.5, 
    pi2 = 0.3, eventTime = 24, maxNumberOfEvents = 40, maxNumberOfSubjects = 200, 
    directionUpper = FALSE)

# Effect size is based on hazard rate for the reference group and hazard ratio, 
# directionUpper = FALSE needs to be specified because it should be shown that 
# hazard ratio &lt; 1
getPowerSurvival(design = getDesignGroupSequential(kMax = 2), hazardRatio = 0.5, 
    lambda2 = 0.02, maxNumberOfEvents = 40, maxNumberOfSubjects = 200, 
    directionUpper = FALSE) 

# Specification of piecewise exponential survival time and hazard ratios  
getPowerSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = c(0, 5, 10), lambda2 = c(0.01, 0.02, 0.04), 
    hazardRatio = c(1.5, 1.8, 2),  maxNumberOfEvents = 40, maxNumberOfSubjects = 200)

# Specification of piecewise exponential survival time as list and hazard ratios 
pws &lt;- list(
    "0 - &lt;5"  = 0.01,
    "5 - &lt;10" = 0.02,
    "&gt;=10"    = 0.04)
getPowerSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = pws, hazardRatio = c(1.5, 1.8, 2), 
    maxNumberOfEvents = 40, maxNumberOfSubjects = 200)

# Specification of piecewise exponential survival time for both treatment arms  
getPowerSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = c(0, 5, 10), lambda2 = c(0.01, 0.02, 0.04), 
    lambda1 = c(0.015,0.03,0.06),  maxNumberOfEvents = 40, maxNumberOfSubjects = 200)

# Specification of piecewise exponential survival time as a list
pws &lt;- list(
    "0 - &lt;5"  = 0.01,
    "5 - &lt;10" = 0.02,
    "&gt;=10"    = 0.04)
getPowerSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = pws, hazardRatio = c(1.5, 1.8, 2), 
    maxNumberOfEvents = 40, maxNumberOfSubjects = 200)

# Specify effect size based on median survival times
getPowerSurvival(median1 = 5, median2 = 3, 
    maxNumberOfEvents = 40, maxNumberOfSubjects = 200, directionUpper = FALSE)

# Specify effect size based on median survival times of 
# Weibull distribtion with kappa = 2
getPowerSurvival(median1 = 5, median2 = 3, kappa = 2, 
    maxNumberOfEvents = 40, maxNumberOfSubjects = 200, directionUpper = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='getRawData'>Get Simulation Raw Data for Survival</h2><span id='topic+getRawData'></span>

<h3>Description</h3>

<p>Returns the raw survival data which was generated for simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRawData(x, aggregate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRawData_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+SimulationResults">SimulationResults</a></code> object created by <code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code>.</p>
</td></tr>
<tr><td><code id="getRawData_+3A_aggregate">aggregate</code></td>
<td>
<p>Logical. If <code>TRUE</code> the raw data will be aggregated similar to
the result of <code><a href="#topic+getData">getData()</a></code>, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works only if <code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code> was called with a <br />
<code>maxNumberOfRawDatasetsPerStage</code> &gt; 0 (default is <code>0</code>).
</p>
<p>This function can be used to get the simulated raw data from a simulation results
object obtained by <code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code>.
Note that <code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code>
must called before with <code>maxNumberOfRawDatasetsPerStage</code> &gt; 0.
The data frame contains the following columns:
</p>

<ol>
<li> <p><code>iterationNumber</code>: The number of the simulation iteration.
</p>
</li>
<li> <p><code>stopStage</code>: The stage of stopping.
</p>
</li>
<li> <p><code>subjectId</code>: The subject id (increasing number 1, 2, 3, ...)
</p>
</li>
<li> <p><code>accrualTime</code>: The accrual time, i.e., the time when the subject entered the trial.
</p>
</li>
<li> <p><code>treatmentGroup</code>: The treatment group number (1 or 2).
</p>
</li>
<li> <p><code>survivalTime</code>: The survival time of the subject.
</p>
</li>
<li> <p><code>dropoutTime</code>: The dropout time of the subject (may be <code>NA</code>).
</p>
</li>
<li> <p><code>lastObservationTime</code>: The specific observation time.
</p>
</li>
<li> <p><code>timeUnderObservation</code>: The time under observation is defined as follows:
</p>
<div class="sourceCode"><pre>if (event == TRUE) {
    timeUnderObservation &lt;- survivalTime
} else if (dropoutEvent == TRUE) {
    timeUnderObservation &lt;- dropoutTime
} else {
    timeUnderObservation &lt;- lastObservationTime - accrualTime
}
</pre></div>
</li>
<li> <p><code>event</code>: <code>TRUE</code> if an event occurred; <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>dropoutEvent</code>: <code>TRUE</code> if an dropout event occurred; <code>FALSE</code> otherwise.
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
results &lt;- getSimulationSurvival(
    pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, eventTime = 12,
    accrualTime = 24, plannedEvents = 40, maxNumberOfSubjects = 200,
    maxNumberOfIterations = 50, maxNumberOfRawDatasetsPerStage = 5
)
rawData &lt;- getRawData(results)
head(rawData)
dim(rawData)

## End(Not run)

</code></pre>

<hr>
<h2 id='getRepeatedConfidenceIntervals'>Get Repeated Confidence Intervals</h2><span id='topic+getRepeatedConfidenceIntervals'></span>

<h3>Description</h3>

<p>Calculates and returns the lower and upper limit of the repeated confidence intervals of the trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRepeatedConfidenceIntervals(
  design,
  dataInput,
  ...,
  directionUpper = NA,
  tolerance = 1e-06,
  stage = NA_integer_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRepeatedConfidenceIntervals_+3A_design">design</code></td>
<td>
<p>The trial design.</p>
</td></tr>
<tr><td><code id="getRepeatedConfidenceIntervals_+3A_datainput">dataInput</code></td>
<td>
<p>The summary data used for calculating the test results.
This is either an element of <code>DatasetMeans</code>, of <code>DatasetRates</code>, or of <code>DatasetSurvival</code>
and should be created with the function <code><a href="#topic+getDataset">getDataset()</a></code>.
For more information see <code><a href="#topic+getDataset">getDataset()</a></code>.</p>
</td></tr>
<tr><td><code id="getRepeatedConfidenceIntervals_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods (cf., separate functions in &quot;See Also&quot; below), e.g.,
</p>

<dl>
<dt><code>normalApproximation</code></dt><dd><p>The type of computation of the p-values. Default is <code>FALSE</code> for
testing means (i.e., the t test is used) and <code>TRUE</code> for testing rates and the hazard ratio.
For testing rates, if <code>normalApproximation = FALSE</code> is specified, the binomial test
(one sample) or the exact test of Fisher (two samples) is used for calculating the p-values.
In the survival setting, <code>normalApproximation = FALSE</code> has no effect.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>The type of t test. For testing means in two treatment groups, either
the t test assuming that the variances are equal or the t test without assuming this,
i.e., the test of Welch-Satterthwaite is calculated, default is <code>TRUE</code>.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses when testing multiple hypotheses.
Five options are available in multi-arm designs: <code>"Dunnett"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
<code>"Sidak"</code>, and <code>"Hierarchical"</code>, default is <code>"Dunnett"</code>.
Four options are available in population enrichment designs: <code>"SpiessensDebois"</code> (one subset only),
<code>"Bonferroni"</code>, <code>"Simes"</code>, and <code>"Sidak"</code>, default is <code>"Simes"</code>.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple treatment arms (&gt; 2)
or population enrichment designs for testing means. For multiple arms, three options are available:
<code>"overallPooled"</code>, <code>"pairwisePooled"</code>, and <code>"notPooled"</code>, default is <code>"overallPooled"</code>.
For enrichment designs, the options are: <code>"pooled"</code>, <code>"pooledFromFull"</code> (one subset only),
and <code>"notPooled"</code>, default is <code>"pooled"</code>.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen.
For testing means and rates, also a non-stratified analysis based on overall data can be performed.
For survival data, only a stratified analysis is possible (see Brannath et al., 2009), default is <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getRepeatedConfidenceIntervals_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getRepeatedConfidenceIntervals_+3A_tolerance">tolerance</code></td>
<td>
<p>The numerical tolerance, default is <code>1e-06</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getRepeatedConfidenceIntervals_+3A_stage">stage</code></td>
<td>
<p>The stage number (optional). Default: total number of existing stages in the data input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The repeated confidence interval at a given stage of the trial contains the
parameter values that are not rejected using the specified sequential design.
It can be calculated at each stage of the trial and can thus be used as a monitoring tool.
</p>
<p>The repeated confidence intervals are provided up to the specified stage.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+matrix">matrix</a></code> with <code>2</code> rows
and <code>kMax</code> columns containing the lower RCI limits in the first row and
the upper RCI limits in the second row, where each column represents a stage.
</p>


<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(kMax = 2)
data &lt;- getDataset(
    n      = c( 20,  30),
    means  = c( 50,  51),
    stDevs = c(130, 140)
)
getRepeatedConfidenceIntervals(design, dataInput = data)

## End(Not run)

</code></pre>

<hr>
<h2 id='getRepeatedPValues'>Get Repeated P Values</h2><span id='topic+getRepeatedPValues'></span>

<h3>Description</h3>

<p>Calculates the repeated p-values for a given test results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRepeatedPValues(stageResults, ..., tolerance = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRepeatedPValues_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
<tr><td><code id="getRepeatedPValues_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getRepeatedPValues_+3A_tolerance">tolerance</code></td>
<td>
<p>The numerical tolerance, default is <code>1e-06</code>. Must be a positive numeric of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The repeated p-value at a given stage of the trial is defined as the smallest
significance level under which at given test design the test results
obtain rejection of the null hypothesis. It can be calculated at each
stage of the trial and can thus be used as a monitoring tool.
</p>
<p>The repeated p-values are provided up to the specified stage.
</p>
<p>In multi-arm trials, the repeated p-values are defined separately for each
treatment comparison within the closed testing procedure.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code>kMax</code> or in case of multi-arm stage results
a <code><a href="base.html#topic+matrix">matrix</a></code> (each column represents a stage, each row a comparison)
containing the repeated p values.
</p>


<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(kMax = 2)
data &lt;- getDataset(
    n      = c( 20,  30),
    means  = c( 50,  51),
    stDevs = c(130, 140)
)
getRepeatedPValues(getStageResults(design, dataInput = data))

## End(Not run)

</code></pre>

<hr>
<h2 id='getSampleSizeCounts'>Get Sample Size Counts</h2><span id='topic+getSampleSizeCounts'></span>

<h3>Description</h3>

<p>Returns the sample size for testing the ratio of mean rates
of negative binomial distributed event numbers in two samples at given effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleSizeCounts(
  design = NULL,
  ...,
  lambda1 = NA_real_,
  lambda2 = NA_real_,
  lambda = NA_real_,
  theta = NA_real_,
  thetaH0 = 1,
  overdispersion = 0,
  fixedExposureTime = NA_real_,
  accrualTime = NA_real_,
  accrualIntensity = NA_real_,
  followUpTime = NA_real_,
  maxNumberOfSubjects = NA_integer_,
  allocationRatioPlanned = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSampleSizeCounts_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_lambda1">lambda1</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the active treatment group, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_lambda2">lambda2</code></td>
<td>
<p>A numeric value that represents the assumed rate of a homogeneous Poisson process in
the control group, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the pooled treatment groups, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_theta">theta</code></td>
<td>
<p>A numeric value or vector that represents the assumed mean ratios lambda1/lambda2 of a homogeneous
Poisson process, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_overdispersion">overdispersion</code></td>
<td>
<p>A numeric value that represents the assumed overdispersion of the negative binomial distribution,
default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_fixedexposuretime">fixedExposureTime</code></td>
<td>
<p>If specified, the fixed time of exposure per subject for count data, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_accrualtime">accrualTime</code></td>
<td>
<p>If specified, the assumed accrual time interval(s) for the study, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>If specified, the assumed accrual intensities for the study, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_followuptime">followUpTime</code></td>
<td>
<p>If specified, the assumed (additional) follow-up time for the study, there is no default.
The total study duration is <code>accrualTime + followUpTime</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified for power calculations or calculation
of necessary follow-up (count data). For two treatment arms, it is the maximum number of subjects for both treatment arms.</p>
</td></tr>
<tr><td><code id="getSampleSizeCounts_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. If <code>allocationRatioPlanned = 0</code> is entered,
the optimal allocation ratio yielding the smallest overall sample size is determined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the information, and stage-wise and maximum sample size for testing mean rates
of negative binomial distributed event numbers in two samples at given effect.
The sample size calculation is performed either for a fixed exposure time or a variable exposure time with fixed follow-up.
For the variable exposure time case, at given maximum sample size the necessary follow-up time is calculated.
The planned calendar time of interim stages is calculated if an accrual time is defined.
Additionally, an allocation ratio = <code>n1 / n2</code> can be specified where <code>n1</code> and <code>n2</code> are the number
of subjects in the two treatment groups. A null hypothesis value <code>thetaH0</code> can also be specified.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other sample size functions: 
<code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans</a>()</code>,
<code><a href="#topic+getSampleSizeRates">getSampleSizeRates</a>()</code>,
<code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size trial where a therapy is assumed to decrease the 
# exacerbation rate from 1.4 to 1.05 (25% decrease) within an observation 
# period of 1 year, i.e., each subject has an equal follow-up of 1 year.
# The sample size that yields 90% power at significance level 0.025 for 
# detecting such a difference, if the overdispersion is assumed to be 
# equal to 0.5, is obtained by
getSampleSizeCounts(alpha = 0.025, beta = 0.1, lambda2 = 1.4, 
    theta = 0.75, overdispersion = 0.5, fixedExposureTime = 1)

# Noninferiority test with blinded sample size reassessment to reproduce 
# Table 2 from Friede and Schmidli (2010):
getSampleSizeCounts(alpha = 0.025, beta = 0.2, lambda = 1, theta = 1,
    thetaH0 = 1.15, overdispersion = 0.4, fixedExposureTime = 1)

# Group sequential alpha and beta spending function design with O'Brien and 
# Fleming type boundaries: Estimate observation time under uniform 
# recruitment of patients over 6 months and a fixed exposure time of 12 
# months (lambda1, lambda2, and overdispersion as specified):
getSampleSizeCounts(design = getDesignGroupSequential(
        kMax = 3, alpha = 0.025, beta = 0.2, 
        typeOfDesign = "asOF", typeBetaSpending = "bsOF"), 
    lambda1 = 0.2, lambda2 = 0.3, overdispersion = 1, 
    fixedExposureTime = 12, accrualTime = 6)

# Group sequential alpha spending function design with O'Brien and Fleming 
# type boundaries: Sample size for variable exposure time with uniform 
# recruitment over 1.25 months and study time (accrual + followup) = 4 
# (lambda1, lambda2, and overdispersion as specified, no futility stopping):
getSampleSizeCounts(design = getDesignGroupSequential(
        kMax = 3, alpha = 0.025, beta = 0.2, typeOfDesign = "asOF"),
    lambda1 = 0.0875, lambda2 = 0.125, overdispersion = 5, 
    followUpTime = 2.75, accrualTime = 1.25)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSampleSizeMeans'>Get Sample Size Means</h2><span id='topic+getSampleSizeMeans'></span>

<h3>Description</h3>

<p>Returns the sample size for testing means in one or two samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleSizeMeans(
  design = NULL,
  ...,
  groups = 2L,
  normalApproximation = FALSE,
  meanRatio = FALSE,
  thetaH0 = ifelse(meanRatio, 1, 0),
  alternative = seq(0.2, 1, 0.2),
  stDev = 1,
  allocationRatioPlanned = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSampleSizeMeans_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_groups">groups</code></td>
<td>
<p>The number of treatment groups (1 or 2), default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_normalapproximation">normalApproximation</code></td>
<td>
<p>The type of computation of the p-values. If <code>TRUE</code>, the variance is
assumed to be known, default is <code>FALSE</code>, i.e., the calculations are performed
with the t distribution.</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_meanratio">meanRatio</code></td>
<td>
<p>If <code>TRUE</code>, the sample size for
one-sided testing of H0: <code>mu1 / mu2 = thetaH0</code> is calculated, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_alternative">alternative</code></td>
<td>
<p>The alternative hypothesis value for testing means. This can be a vector of assumed
alternatives, default is <code>seq(0, 1, 0.2)</code> (power calculations) or <code>seq(0.2, 1, 0.2)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_stdev">stDev</code></td>
<td>
<p>The standard deviation under which the sample size or power
calculation is performed, default is <code>1</code>.
If <code>meanRatio = TRUE</code> is specified, <code>stDev</code> defines
the coefficient of variation <code>sigma / mu2</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSampleSizeMeans_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. If <code>allocationRatioPlanned = 0</code> is entered,
the optimal allocation ratio yielding the smallest overall sample size is determined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the stage-wise and maximum sample size for testing means.
In a two treatment groups design, additionally, an allocation ratio = <code>n1 / n2</code>
can be specified where <code>n1</code> and <code>n2</code> are the number of subjects in the two treatment groups.
A null hypothesis value thetaH0 != 0 for testing the difference of two means or
thetaH0 != 1 for testing the ratio of two means can be specified.
Critical bounds and stopping for futility bounds are provided at the effect scale
(mean, mean difference, or mean ratio, respectively) for each sample size calculation separately.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other sample size functions: 
<code><a href="#topic+getSampleSizeCounts">getSampleSizeCounts</a>()</code>,
<code><a href="#topic+getSampleSizeRates">getSampleSizeRates</a>()</code>,
<code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate sample sizes in a fixed sample size parallel group design 
# with allocation ratio \code{n1 / n2 = 2} for a range of 
# alternative values 1, ..., 5 with assumed standard deviation = 3.5; 
# two-sided alpha = 0.05, power 1 - beta = 90%:
getSampleSizeMeans(alpha = 0.05, beta = 0.1, sided = 2, groups = 2, 
    alternative = seq(1, 5, 1), stDev = 3.5, allocationRatioPlanned = 2)

# Calculate sample sizes in a three-stage Pocock paired comparison design testing 
# H0: mu = 2 for a range of alternative values 3,4,5 with assumed standard 
# deviation = 3.5; one-sided alpha = 0.05, power 1 - beta = 90%:
getSampleSizeMeans(getDesignGroupSequential(typeOfDesign = "P", alpha = 0.05, 
    sided = 1, beta = 0.1), groups = 1, thetaH0 = 2, 
    alternative = seq(3, 5, 1), stDev = 3.5)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSampleSizeRates'>Get Sample Size Rates</h2><span id='topic+getSampleSizeRates'></span>

<h3>Description</h3>

<p>Returns the sample size for testing rates in one or two samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleSizeRates(
  design = NULL,
  ...,
  groups = 2L,
  normalApproximation = TRUE,
  riskRatio = FALSE,
  thetaH0 = ifelse(riskRatio, 1, 0),
  pi1 = c(0.4, 0.5, 0.6),
  pi2 = 0.2,
  allocationRatioPlanned = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSampleSizeRates_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_groups">groups</code></td>
<td>
<p>The number of treatment groups (1 or 2), default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_normalapproximation">normalApproximation</code></td>
<td>
<p>If <code>FALSE</code>, the sample size
for the case of one treatment group is calculated exactly using the binomial distribution,
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_riskratio">riskRatio</code></td>
<td>
<p>If <code>TRUE</code>, the sample size for one-sided
testing of H0: <code>pi1 / pi2 = thetaH0</code> is calculated, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed probability in
the active treatment group if two treatment groups
are considered, or the alternative probability for a one treatment group design,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed probability in the reference group if two treatment
groups are considered, default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeRates_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. If <code>allocationRatioPlanned = 0</code> is entered,
the optimal allocation ratio yielding the smallest overall sample size is determined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the stage-wise and maximum sample size for testing rates.
In a two treatment groups design, additionally, an allocation ratio = <code>n1 / n2</code> can be specified
where <code>n1</code> and <code>n2</code> are the number of subjects in the two treatment groups.
If a null hypothesis value thetaH0 != 0 for testing the difference of two rates or
thetaH0 != 1 for testing the risk ratio is specified, the sample size
formula according to Farrington &amp; Manning (Statistics in Medicine, 1990) is used.
Critical bounds and stopping for futility bounds are provided at the effect scale
(rate, rate difference, or rate ratio, respectively) for each sample size calculation separately.
For the two-sample case, the calculation here is performed at fixed pi2 as given as argument
in the function.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other sample size functions: 
<code><a href="#topic+getSampleSizeCounts">getSampleSizeCounts</a>()</code>,
<code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans</a>()</code>,
<code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate the stage-wise sample sizes, maximum sample sizes, and the optimum 
# allocation ratios for a range of pi1 values when testing 
# H0: pi1 - pi2 = -0.1 within a two-stage O'Brien &amp; Fleming design;
# alpha = 0.05 one-sided, power 1 - beta = 90%:
getSampleSizeRates(getDesignGroupSequential(kMax = 2, alpha = 0.05,  
    beta = 0.1), groups = 2, thetaH0 = -0.1, pi1 = seq(0.4, 0.55, 0.025), 
    pi2 = 0.4, allocationRatioPlanned = 0)

# Calculate the stage-wise sample sizes, maximum sample sizes, and the optimum 
# allocation ratios for a range of pi1 values when testing 
# H0: pi1 / pi2 = 0.80 within a three-stage O'Brien &amp; Fleming design;
# alpha = 0.025 one-sided, power 1 - beta = 90%:
getSampleSizeRates(getDesignGroupSequential(kMax = 3, alpha = 0.025, 
    beta = 0.1), groups = 2, riskRatio = TRUE, thetaH0 = 0.80, 
    pi1 = seq(0.3, 0.5, 0.025), pi2 = 0.3, allocationRatioPlanned = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSampleSizeSurvival'>Get Sample Size Survival</h2><span id='topic+getSampleSizeSurvival'></span>

<h3>Description</h3>

<p>Returns the sample size for testing the hazard ratio in a two treatment groups survival design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleSizeSurvival(
  design = NULL,
  ...,
  typeOfComputation = c("Schoenfeld", "Freedman", "HsiehFreedman"),
  thetaH0 = 1,
  pi1 = NA_real_,
  pi2 = NA_real_,
  lambda1 = NA_real_,
  lambda2 = NA_real_,
  median1 = NA_real_,
  median2 = NA_real_,
  kappa = 1,
  hazardRatio = NA_real_,
  piecewiseSurvivalTime = NA_real_,
  allocationRatioPlanned = NA_real_,
  eventTime = 12,
  accrualTime = c(0, 12),
  accrualIntensity = 0.1,
  accrualIntensityType = c("auto", "absolute", "relative"),
  followUpTime = NA_real_,
  maxNumberOfSubjects = NA_real_,
  dropoutRate1 = 0,
  dropoutRate2 = 0,
  dropoutTime = 12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSampleSizeSurvival_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_typeofcomputation">typeOfComputation</code></td>
<td>
<p>Three options are available: <code>"Schoenfeld"</code>, <code>"Freedman"</code>, <code>"HsiehFreedman"</code>,
the default is <code>"Schoenfeld"</code>. For details, see Hsieh (Statistics in Medicine, 1992).
For non-inferiority testing (i.e., <code>thetaH0 != 1</code>), only Schoenfeld's formula can be used.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed event rate in the treatment group,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed event rate in the control group, default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_lambda1">lambda1</code></td>
<td>
<p>The assumed hazard rate in the treatment group, there is no default.
<code>lambda1</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_lambda2">lambda2</code></td>
<td>
<p>The assumed hazard rate in the reference group, there is no default.
<code>lambda2</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_median1">median1</code></td>
<td>
<p>The assumed median survival time in the treatment group, there is no default.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_median2">median2</code></td>
<td>
<p>The assumed median survival time in the reference group, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_hazardratio">hazardRatio</code></td>
<td>
<p>The vector of hazard ratios under consideration.
If the event or hazard rates in both treatment groups are defined, the hazard ratio needs
not to be specified as it is calculated, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>A vector that specifies the time intervals for the piecewise
definition of the exponential survival time cumulative distribution function <br />
(for details see <code><a href="#topic+getPiecewiseSurvivalTime">getPiecewiseSurvivalTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. If <code>allocationRatioPlanned = 0</code> is entered,
the optimal allocation ratio yielding the smallest overall sample size is determined.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_eventtime">eventTime</code></td>
<td>
<p>The assumed time under which the event rates are calculated, default is <code>12</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_accrualtime">accrualTime</code></td>
<td>
<p>The assumed accrual time intervals for the study, default is
<code>c(0, 12)</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>A numeric vector of accrual intensities, default is the relative
intensity <code>0.1</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_accrualintensitytype">accrualIntensityType</code></td>
<td>
<p>A character value specifying the accrual intensity input type.
Must be one of <code>"auto"</code>, <code>"absolute"</code>, or <code>"relative"</code>; default is <code>"auto"</code>,
i.e., if all values are &lt; 1 the type is <code>"relative"</code>, otherwise it is <code>"absolute"</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_followuptime">followUpTime</code></td>
<td>
<p>The assumed (additional) follow-up time for the study, default is <code>6</code>.
The total study duration is <code>accrualTime + followUpTime</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p>If <code>maxNumberOfSubjects &gt; 0</code> is specified,
the follow-up time for the required number of events is determined.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_dropoutrate1">dropoutRate1</code></td>
<td>
<p>The assumed drop-out rate in the treatment group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_dropoutrate2">dropoutRate2</code></td>
<td>
<p>The assumed drop-out rate in the control group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getSampleSizeSurvival_+3A_dropouttime">dropoutTime</code></td>
<td>
<p>The assumed time for drop-out rates in the control and the
treatment group, default is <code>12</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function calculates the number of events and an estimate for the
necessary number of subjects for testing the hazard ratio in a survival design.
It also calculates the time when the required events are expected under the given
assumptions (exponentially, piecewise exponentially, or Weibull distributed survival times
and constant or non-constant piecewise accrual).
Additionally, an allocation ratio = <code>n1 / n2</code> can be specified where <code>n1</code> and <code>n2</code> are the number
of subjects in the two treatment groups.
</p>
<p>Optional argument <code>accountForObservationTimes</code>: if <code>accountForObservationTimes = TRUE</code>, the number of
subjects is calculated assuming specific accrual and follow-up time, default is <code>TRUE</code>.
</p>
<p>The formula of Kim &amp; Tsiatis (Biometrics, 1990)
is used to calculate the expected number of events under the alternative
(see also Lakatos &amp; Lan, Statistics in Medicine, 1992). These formulas are generalized
to piecewise survival times and non-constant piecewise accrual over time.<br />
</p>
<p>Optional argument <code>accountForObservationTimes</code>: if <code>accountForObservationTimes = FALSE</code>,
only the event rates are used for the calculation of the maximum number of subjects.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+TrialDesignPlan">TrialDesignPlan</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.TrialDesignSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.TrialDesignPlan">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.TrialDesignPlan">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Piecewise survival time</h3>

<p>The first element of the vector <code>piecewiseSurvivalTime</code> must be equal to <code>0</code>.
<code>piecewiseSurvivalTime</code> can also be a list that combines the definition of the
time intervals and hazard rates in the reference group.
The definition of the survival time in the treatment group is obtained by the specification
of the hazard ratio (see examples for details).
</p>


<h3>Staggered patient entry</h3>

<p><code>accrualTime</code> is the time period of subjects' accrual in a study.
It can be a value that defines the end of accrual or a vector.
In this case, <code>accrualTime</code> can be used to define a non-constant accrual over time.
For this, <code>accrualTime</code> is a vector that defines the accrual intervals.
The first element of <code>accrualTime</code> must be equal to <code>0</code> and, additionally,
<code>accrualIntensity</code> needs to be specified.
<code>accrualIntensity</code> itself is a value or a vector (depending on the
length of <code>accrualTime</code>) that defines the intensity how subjects
enter the trial in the intervals defined through <code>accrualTime</code>.
</p>
<p><code>accrualTime</code> can also be a list that combines the definition of the accrual time and
accrual intensity (see below and examples for details).
</p>
<p>If the length of <code>accrualTime</code> and the length of <code>accrualIntensity</code> are the same
(i.e., the end of accrual is undefined), <code>maxNumberOfSubjects &gt; 0</code> needs to be specified
and the end of accrual is calculated.
In that case, <code>accrualIntensity</code> is the number of subjects per time unit, i.e., the absolute accrual intensity.
</p>
<p>If the length of <code>accrualTime</code> equals the length of <code>accrualIntensity - 1</code>
(i.e., the end of accrual is defined), <code>maxNumberOfSubjects</code> is calculated if the absolute accrual intensity is given.
If all elements in <code>accrualIntensity</code> are smaller than 1, <code>accrualIntensity</code> defines
the <em>relative</em> intensity how subjects enter the trial.
For example, <code>accrualIntensity = c(0.1, 0.2)</code> specifies that in the second accrual interval
the intensity is doubled as compared to the first accrual interval. The actual (absolute) accrual intensity
is calculated for the calculated or given <code>maxNumberOfSubjects</code>.
Note that the default is <code>accrualIntensity = 0.1</code> meaning that the <em>absolute</em> accrual intensity
will be calculated.
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other sample size functions: 
<code><a href="#topic+getSampleSizeCounts">getSampleSizeCounts</a>()</code>,
<code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans</a>()</code>,
<code><a href="#topic+getSampleSizeRates">getSampleSizeRates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size trial with median survival 20 vs. 30 months in treatment and 
# reference group, respectively, alpha = 0.05 (two-sided), and power 1 - beta = 90%.
# 20 subjects will be recruited per month up to 400 subjects, i.e., accrual time 
# is 20 months.  
getSampleSizeSurvival(alpha = 0.05, sided = 2, beta = 0.1, lambda1 = log(2) / 20, 
    lambda2 = log(2) / 30, accrualTime = c(0,20), accrualIntensity = 20)

# Fixed sample size with minimum required definitions, pi1 = c(0.4,0.5,0.6) and 
# pi2 = 0.2 at event time 12, accrual time 12 and follow-up time 6 as default, 
# only alpha = 0.01 is specified  
getSampleSizeSurvival(alpha = 0.01)

# Four stage O'Brien &amp; Fleming group sequential design with minimum required 
# definitions, pi1 = c(0.4,0.5,0.6) and pi2 = 0.2 at event time 12, 
# accrual time 12 and follow-up time 6 as default  
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 4))

# For fixed sample design, determine necessary accrual time if 200 subjects and 
# 30 subjects per time unit can be recruited 
getSampleSizeSurvival(accrualTime = c(0), accrualIntensity = c(30), 
    maxNumberOfSubjects = 200)

# Determine necessary accrual time if 200 subjects and if the first 6 time units 
# 20 subjects per time unit can be recruited, then 30 subjects per time unit 
getSampleSizeSurvival(accrualTime = c(0, 6), accrualIntensity = c(20, 30), 
    maxNumberOfSubjects = 200)

# Determine maximum number of Subjects if the first 6 time units 20 subjects 
# per time unit can be recruited, and after 10 time units 30 subjects per time unit
getSampleSizeSurvival(accrualTime = c(0, 6, 10), accrualIntensity = c(20, 30))

# Specify accrual time as a list
at &lt;- list(
    "0 - &lt;6"  = 20,
    "6 - Inf" = 30)
getSampleSizeSurvival(accrualTime = at, maxNumberOfSubjects = 200)

# Specify accrual time as a list, if maximum number of subjects need to be calculated
at &lt;- list(
    "0 - &lt;6"   = 20,
    "6 - &lt;=10" = 30)
getSampleSizeSurvival(accrualTime = at)

# Specify effect size for a two-stage group design with O'Brien &amp; Fleming boundaries
# Effect size is based on event rates at specified event time 
# needs to be specified because it should be shown that hazard ratio &lt; 1
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 2), 
    pi1 = 0.2, pi2 = 0.3, eventTime = 24)

# Effect size is based on event rate at specified event 
# time for the reference group and hazard ratio 
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 2), 
    hazardRatio = 0.5, pi2 = 0.3, eventTime = 24)

# Effect size is based on hazard rate for the reference group and hazard ratio
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 2), 
    hazardRatio = 0.5, lambda2 = 0.02) 

# Specification of piecewise exponential survival time and hazard ratios  
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = c(0, 5, 10), lambda2 = c(0.01, 0.02, 0.04), 
    hazardRatio = c(1.5, 1.8, 2))

# Specification of piecewise exponential survival time as a list and hazard ratios 
pws &lt;- list(
    "0 - &lt;5"  = 0.01,
    "5 - &lt;10" = 0.02,
    "&gt;=10"    = 0.04)
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = pws, hazardRatio = c(1.5, 1.8, 2))

# Specification of piecewise exponential survival time for both treatment arms
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = c(0, 5, 10), lambda2 = c(0.01, 0.02, 0.04), 
    lambda1 = c(0.015, 0.03, 0.06))

# Specification of piecewise exponential survival time as a list
pws &lt;- list(
    "0 - &lt;5"  = 0.01,
    "5 - &lt;10" = 0.02,
    "&gt;=10"    = 0.04)
getSampleSizeSurvival(design = getDesignGroupSequential(kMax = 2), 
    piecewiseSurvivalTime = pws, hazardRatio = c(1.5, 1.8, 2))

# Specify effect size based on median survival times
getSampleSizeSurvival(median1 = 5, median2 = 3)

# Specify effect size based on median survival times of Weibull distribtion with 
# kappa = 2
getSampleSizeSurvival(median1 = 5, median2 = 3, kappa = 2)

# Identify minimal and maximal required subjects to 
# reach the required events in spite of dropouts
getSampleSizeSurvival(accrualTime = c(0, 18), accrualIntensity = c(20, 30), 
    lambda2 = 0.4, lambda1 = 0.3, followUpTime = Inf, dropoutRate1 = 0.001, 
    dropoutRate2 = 0.005)
getSampleSizeSurvival(accrualTime = c(0, 18), accrualIntensity = c(20, 30), 
    lambda2 = 0.4, lambda1 = 0.3, followUpTime = 0, dropoutRate1 = 0.001, 
    dropoutRate2 = 0.005)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationCounts'>Get Simulation Counts</h2><span id='topic+getSimulationCounts'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping probabilities, conditional power, and expected sample size for
testing mean rates for negative binomial distributed event numbers in the two treatment groups testing situation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationCounts(
  design = NULL,
  ...,
  plannedCalendarTime,
  maxNumberOfSubjects = NA_real_,
  lambda1 = NA_real_,
  lambda2 = NA_real_,
  lambda = NA_real_,
  theta = NA_real_,
  directionUpper = NA,
  thetaH0 = 1,
  overdispersion = 0,
  fixedExposureTime = NA_real_,
  accrualTime = NA_real_,
  accrualIntensity = NA_real_,
  followUpTime = NA_real_,
  allocationRatioPlanned = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationCounts_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_plannedcalendartime">plannedCalendarTime</code></td>
<td>
<p>For simulating count data, the time points where an analysis is planned to be performed.
Should be a vector of length <code>kMax</code></p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified for power calculations or calculation
of necessary follow-up (count data). For two treatment arms, it is the maximum number of subjects for both treatment arms.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_lambda1">lambda1</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the active treatment group, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_lambda2">lambda2</code></td>
<td>
<p>A numeric value that represents the assumed rate of a homogeneous Poisson process in
the control group, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the pooled treatment groups, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_theta">theta</code></td>
<td>
<p>A numeric value or vector that represents the assumed mean ratios lambda1/lambda2 of a homogeneous
Poisson process, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_overdispersion">overdispersion</code></td>
<td>
<p>A numeric value that represents the assumed overdispersion of the negative binomial distribution,
default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_fixedexposuretime">fixedExposureTime</code></td>
<td>
<p>If specified, the fixed time of exposure per subject for count data, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_accrualtime">accrualTime</code></td>
<td>
<p>If specified, the assumed accrual time interval(s) for the study, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>If specified, the assumed accrual intensities for the study, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_followuptime">followUpTime</code></td>
<td>
<p>If specified, the assumed (additional) follow-up time for the study, there is no default.
The total study duration is <code>accrualTime + followUpTime</code>.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationCounts_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities, conditional power, and expected
sample size at given number of subjects and parameter configuration.
Additionally, an allocation <code>ratio = n1/n2</code> and a null hypothesis value <code>thetaH0</code> can be specified.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Simulation Data</h3>

<p>The summary statistics &quot;Simulated data&quot; contains the following parameters: median <a href="base.html#topic+range">range</a>; mean +/-sd<br />
</p>
<p><code>$show(showStatistics = FALSE)</code> or <code>$setShowStatistics(FALSE)</code> can be used to disable
the output of the aggregated simulated data.<br />
</p>
<p><code><a href="#topic+getData">getData()</a></code> can be used to get the aggregated simulated data from the
object as <code><a href="base.html#topic+data.frame">data.frame</a></code>. The data frame contains the following columns:
</p>

<ol>
<li> <p><code>iterationNumber</code>: The number of the simulation iteration.
</p>
</li>
<li> <p><code>stageNumber</code>: The stage.
</p>
</li>
<li> <p><code>lambda1</code>: The assumed or derived event rate in the treatment group.
</p>
</li>
<li> <p><code>lambda2</code>: The assumed or derived event rate in the control group.
</p>
</li>
<li> <p><code>accrualTime</code>: The assumed accrualTime.
</p>
</li>
<li> <p><code>followUpTime</code>: The  assumed followUpTime.
</p>
</li>
<li> <p><code>overdispersion</code>: The  assumed overdispersion.
</p>
</li>
<li> <p><code>fixedFollowUp</code>: The  assumed fixedFollowUp.
</p>
</li>
<li> <p><code>numberOfSubjects</code>: The number of subjects under consideration when the (interim) analysis takes place.
</p>
</li>
<li> <p><code>rejectPerStage</code>: 1 if null hypothesis can be rejected, 0 otherwise.
</p>
</li>
<li> <p><code>futilityPerStage</code>: 1 if study should be stopped for futility, 0 otherwise.
</p>
</li>
<li> <p><code>testStatistic</code>: The test statistic that is used for the test decision
</p>
</li>
<li> <p><code>estimatedLambda1</code>: The estimated rate in treatment group 1.
</p>
</li>
<li> <p><code>estimatedLambda2</code>: The estimated rate in treatment group 2.
</p>
</li>
<li> <p><code>estimatedOverdispersion</code>: The estimated overdispersion.
</p>
</li>
<li> <p><code>infoAnalysis</code>: The Fisher information at interim stage.
</p>
</li>
<li> <p><code>trialStop</code>: <code>TRUE</code> if study should be stopped for efficacy or futility or final stage, <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>conditionalPowerAchieved</code>: Not yet available
</p>
</li></ol>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size design with two groups, fixed exposure time
getSimulationCounts(
    theta = 1.8,
    lambda2 = 0.2,
    maxNumberOfSubjects = 200,
    plannedCalendarTime = 8,
    maxNumberOfIterations = 1000,
    fixedExposureTime = 6,
    accrualTime = 3,
    overdispersion = 2)

# Group sequential design alpha spending function design with O'Brien and 
# Fleming type boundaries: Power and test characteristics for N = 264, 
# under variable exposure time with uniform recruitment over 1.25 months,
# study time (accrual + followup) = 4, interim analysis take place after
# equidistant time points (lambda1, lambda2, and overdispersion as specified,
# no futility stopping):
dOF &lt;- getDesignGroupSequential(
    kMax = 3,
    alpha = 0.025,
    beta = 0.2,
    typeOfDesign = "asOF")

getSimulationCounts(design = dOF,
    lambda1 = seq(0.04, 0.12, 0.02),
    lambda2 = 0.12,
    directionUpper = FALSE,
    overdispersion = 5,
    plannedCalendarTime = (1:3)/3*4,
    maxNumberOfSubjects = 264,
    followUpTime = 2.75,
    accrualTime = 1.25,
    maxNumberOfIterations = 1000)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationEnrichmentMeans'>Get Simulation Enrichment Means</h2><span id='topic+getSimulationEnrichmentMeans'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping and selection probabilities, conditional power,
and expected sample size or testing means in an enrichment design testing situation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationEnrichmentMeans(
  design = NULL,
  ...,
  effectList = NULL,
  intersectionTest = c("Simes", "SpiessensDebois", "Bonferroni", "Sidak"),
  stratifiedAnalysis = TRUE,
  adaptations = NA,
  typeOfSelection = c("best", "rBest", "epsilon", "all", "userDefined"),
  effectMeasure = c("effectEstimate", "testStatistic"),
  successCriterion = c("all", "atLeastOne"),
  epsilonValue = NA_real_,
  rValue = NA_real_,
  threshold = -Inf,
  plannedSubjects = NA_integer_,
  allocationRatioPlanned = NA_real_,
  minNumberOfSubjectsPerStage = NA_real_,
  maxNumberOfSubjectsPerStage = NA_real_,
  conditionalPower = NA_real_,
  thetaH1 = NA_real_,
  stDevH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcSubjectsFunction = NULL,
  selectPopulationsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationEnrichmentMeans_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_effectlist">effectList</code></td>
<td>
<p>List of subsets, prevalences, and effect sizes with columns and number of rows
reflecting the different situations to consider (see examples).</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Four options are available in enrichment designs: <code>"SpiessensDebois"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
and <code>"Sidak"</code>, default is <code>"Simes"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_stratifiedanalysis">stratifiedAnalysis</code></td>
<td>
<p>Logical. For enrichment designs, typically a stratified analysis should be chosen.
For testing rates, also a non-stratified analysis based on overall data can be performed.
For survival data, only a stratified analysis is possible (see Brannath et al., 2009),
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_adaptations">adaptations</code></td>
<td>
<p>A logical vector of length <code>kMax - 1</code> indicating whether or not an adaptation takes
place at interim k, default is <code>rep(TRUE, kMax - 1)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_typeofselection">typeOfSelection</code></td>
<td>
<p>The way the treatment arms or populations are selected at interim.
Five options are available: <code>"best"</code>, <code>"rbest"</code>, <code>"epsilon"</code>, <code>"all"</code>, and <code>"userDefined"</code>,
default is <code>"best"</code>.<br />
For <code>"rbest"</code> (select the <code>rValue</code> best treatment arms/populations), the parameter <code>rValue</code> has to be specified,
for <code>"epsilon"</code> (select treatment arm/population not worse than epsilon compared to the best), the parameter
<code>epsilonValue</code> has to be specified.
If <code>"userDefined"</code> is selected, <code>"selectArmsFunction"</code> or <code>"selectPopulationsFunction"</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_effectmeasure">effectMeasure</code></td>
<td>
<p>Criterion for treatment arm/population selection, either based on test statistic
(<code>"testStatistic"</code>) or effect estimate (difference for means and rates or ratio for survival) (<code>"effectEstimate"</code>),
default is <code>"effectEstimate"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_successcriterion">successCriterion</code></td>
<td>
<p>Defines when the study is stopped for efficacy at interim.
Two options are available: <code>"all"</code> stops the trial
if the efficacy criterion is fulfilled for all selected treatment arms/populations,
<code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be
superior to control at interim, default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_epsilonvalue">epsilonValue</code></td>
<td>
<p>For <code>typeOfSelection = "epsilon"</code> (select treatment arm / population not worse than
epsilon compared to the best), the parameter <code>epsilonValue</code> has to be specified. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_rvalue">rValue</code></td>
<td>
<p>For <code>typeOfSelection = "rbest"</code> (select the <code>rValue</code> best treatment arms / populations),
the parameter <code>rValue</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_threshold">threshold</code></td>
<td>
<p>Selection criterion: treatment arm / population is selected only if <code>effectMeasure</code>
exceeds <code>threshold</code>, default is <code>-Inf</code>.
<code>threshold</code> can also be a vector of length <code>activeArms</code> referring to
a separate threshold condition over the treatment arms.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_plannedsubjects">plannedSubjects</code></td>
<td>
<p><code>plannedSubjects</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) subjects when the interim stages are planned.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs, <code>plannedSubjects</code> refers to the number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_minnumberofsubjectsperstage">minNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the
minimum number of subjects per stage (i.e., not cumulated), the first element
is not taken into account. For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>minNumberOfSubjectsPerStage</code> refers
to the minimum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_maxnumberofsubjectsperstage">maxNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the maximum number
of subjects per stage (i.e., not cumulated), the first element is not taken into account.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>maxNumberOfSubjectsPerStage</code> refers
to the maximum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_thetah1">thetaH1</code></td>
<td>
<p>If specified, the value of the alternative under which
the conditional power or sample size recalculation calculation is performed. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_stdevh1">stDevH1</code></td>
<td>
<p>If specified, the value of the standard deviation under which
the conditional power or sample size recalculation calculation is performed,
default is the value of <code>stDev</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_calcsubjectsfunction">calcSubjectsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, sample size recalculation is performed with conditional power and specified
<code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_selectpopulationsfunction">selectPopulationsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how populations
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>populations</code>
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedPopulations"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentMeans_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities, selection probabilities,
and expected sample size at given number of subjects, parameter configuration, and population
selection rule in the enrichment situation.
An allocation ratio can be specified referring to the ratio of number of subjects in the active
treatment groups as compared to the control group.
</p>
<p>The definition of <code>thetaH1</code> and/or <code>stDevH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfSubjectsPerStage</code>, and
<code>maxNumberOfSubjectsPerStage</code> (or <code>calcSubjectsFunction</code>) are defined.
</p>
<p><code>calcSubjectsFunction</code><br />
This function returns the number of subjects at given conditional power and conditional
critical value for specified testing situation. The function might depend on the variables
<code>stage</code>,
<code>selectedPopulations</code>,
<code>plannedSubjects</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfSubjectsPerStage</code>,
<code>maxNumberOfSubjectsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>,
<code>overallEffects</code>, and
<code>stDevH1</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assess a population selection strategy with one subset population.
# If the subset is better than the full population, then the subset
# is selected for the second stage, otherwise the full. Print and plot
# design characteristics.

# Define design
designIN &lt;- getDesignInverseNormal(kMax = 2)

# Define subgroups and their prevalences
subGroups &lt;- c("S", "R") # fixed names!
prevalences &lt;- c(0.2, 0.8)

# Define effect matrix and variability
effectR &lt;- 0.2
m &lt;- c()
for (effectS in seq(0, 0.5, 0.25)) {
    m &lt;- c(m, effectS, effectR)
}
effects &lt;- matrix(m, byrow = TRUE, ncol = 2)
stDev &lt;- c(0.4, 0.8)

# Define effect list
effectList &lt;- list(subGroups=subGroups, prevalences=prevalences, stDevs = stDev, effects = effects)

# Perform simulation
simResultsPE &lt;- getSimulationEnrichmentMeans(design = designIN,
    effectList = effectList, plannedSubjects = c(50, 100),
    maxNumberOfIterations = 100)
print(simResultsPE)

# Assess the design characteristics of a user defined selection
# strategy in a three-stage design with no interim efficacy stop
# using the inverse normal method for combining the stages.
# Only the second interim is used for a selecting of a study
# population. There is a small probability for stopping the trial
# at the first interim.

# Define design
designIN2 &lt;- getDesignInverseNormal(typeOfDesign = "noEarlyEfficacy", kMax = 3)

# Define selection function
mySelection &lt;- function(effectVector, stage) {
    selectedPopulations &lt;- rep(TRUE, 3)
    if (stage == 2) {
        selectedPopulations &lt;- (effectVector &gt;= c(1, 2, 3))
    }
    return(selectedPopulations)
}

# Define subgroups and their prevalences
subGroups &lt;- c("S1", "S12", "S2", "R")   # fixed names!
prevalences &lt;- c(0.2, 0.3, 0.4, 0.1)

effectR &lt;- 1.5
effectS12 = 5
m &lt;- c()
for (effectS1 in seq(0, 5, 1)) {
    for (effectS2 in seq(0, 5, 1)) {
        m &lt;- c(m, effectS1, effectS12, effectS2, effectR)
    }
}
effects &lt;- matrix(m, byrow = TRUE, ncol = 4)
stDev &lt;- 10

# Define effect list
effectList &lt;- list(subGroups=subGroups, prevalences=prevalences, stDevs = stDev, effects = effects)

# Perform simulation
simResultsPE &lt;- getSimulationEnrichmentMeans(
    design = designIN2,
    effectList = effectList,
    typeOfSelection = "userDefined",
    selectPopulationsFunction = mySelection,
    intersectionTest = "Simes",
    plannedSubjects = c(50, 100, 150),
    maxNumberOfIterations = 100)
print(simResultsPE)
if (require(ggplot2)) plot(simResultsPE, type = 3)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationEnrichmentRates'>Get Simulation Enrichment Rates</h2><span id='topic+getSimulationEnrichmentRates'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping and selection probabilities, conditional power,
and expected sample size for testing rates in an enrichment design testing situation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationEnrichmentRates(
  design = NULL,
  ...,
  effectList = NULL,
  intersectionTest = c("Simes", "SpiessensDebois", "Bonferroni", "Sidak"),
  stratifiedAnalysis = TRUE,
  directionUpper = NA,
  adaptations = NA,
  typeOfSelection = c("best", "rBest", "epsilon", "all", "userDefined"),
  effectMeasure = c("effectEstimate", "testStatistic"),
  successCriterion = c("all", "atLeastOne"),
  epsilonValue = NA_real_,
  rValue = NA_real_,
  threshold = -Inf,
  plannedSubjects = NA_real_,
  allocationRatioPlanned = NA_real_,
  minNumberOfSubjectsPerStage = NA_real_,
  maxNumberOfSubjectsPerStage = NA_real_,
  conditionalPower = NA_real_,
  piTreatmentH1 = NA_real_,
  piControlH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcSubjectsFunction = NULL,
  selectPopulationsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationEnrichmentRates_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_effectlist">effectList</code></td>
<td>
<p>List of subsets, prevalences, and effect sizes with columns and number of rows
reflecting the different situations to consider (see examples).</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Four options are available in enrichment designs: <code>"SpiessensDebois"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
and <code>"Sidak"</code>, default is <code>"Simes"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_stratifiedanalysis">stratifiedAnalysis</code></td>
<td>
<p>Logical. For enrichment designs, typically a stratified analysis should be chosen.
For testing rates, also a non-stratified analysis based on overall data can be performed.
For survival data, only a stratified analysis is possible (see Brannath et al., 2009),
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_adaptations">adaptations</code></td>
<td>
<p>A logical vector of length <code>kMax - 1</code> indicating whether or not an adaptation takes
place at interim k, default is <code>rep(TRUE, kMax - 1)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_typeofselection">typeOfSelection</code></td>
<td>
<p>The way the treatment arms or populations are selected at interim.
Five options are available: <code>"best"</code>, <code>"rbest"</code>, <code>"epsilon"</code>, <code>"all"</code>, and <code>"userDefined"</code>,
default is <code>"best"</code>.<br />
For <code>"rbest"</code> (select the <code>rValue</code> best treatment arms/populations), the parameter <code>rValue</code> has to be specified,
for <code>"epsilon"</code> (select treatment arm/population not worse than epsilon compared to the best), the parameter
<code>epsilonValue</code> has to be specified.
If <code>"userDefined"</code> is selected, <code>"selectArmsFunction"</code> or <code>"selectPopulationsFunction"</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_effectmeasure">effectMeasure</code></td>
<td>
<p>Criterion for treatment arm/population selection, either based on test statistic
(<code>"testStatistic"</code>) or effect estimate (difference for means and rates or ratio for survival) (<code>"effectEstimate"</code>),
default is <code>"effectEstimate"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_successcriterion">successCriterion</code></td>
<td>
<p>Defines when the study is stopped for efficacy at interim.
Two options are available: <code>"all"</code> stops the trial
if the efficacy criterion is fulfilled for all selected treatment arms/populations,
<code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be
superior to control at interim, default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_epsilonvalue">epsilonValue</code></td>
<td>
<p>For <code>typeOfSelection = "epsilon"</code> (select treatment arm / population not worse than
epsilon compared to the best), the parameter <code>epsilonValue</code> has to be specified. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_rvalue">rValue</code></td>
<td>
<p>For <code>typeOfSelection = "rbest"</code> (select the <code>rValue</code> best treatment arms / populations),
the parameter <code>rValue</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_threshold">threshold</code></td>
<td>
<p>Selection criterion: treatment arm / population is selected only if <code>effectMeasure</code>
exceeds <code>threshold</code>, default is <code>-Inf</code>.
<code>threshold</code> can also be a vector of length <code>activeArms</code> referring to
a separate threshold condition over the treatment arms.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_plannedsubjects">plannedSubjects</code></td>
<td>
<p><code>plannedSubjects</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) subjects when the interim stages are planned.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs, <code>plannedSubjects</code> refers to the number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_minnumberofsubjectsperstage">minNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the
minimum number of subjects per stage (i.e., not cumulated), the first element
is not taken into account. For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>minNumberOfSubjectsPerStage</code> refers
to the minimum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_maxnumberofsubjectsperstage">maxNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the maximum number
of subjects per stage (i.e., not cumulated), the first element is not taken into account.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>maxNumberOfSubjectsPerStage</code> refers
to the maximum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_pitreatmenth1">piTreatmentH1</code></td>
<td>
<p>If specified, the assumed probabilities in the active arm
under which the sample size recalculation was performed
and the conditional power was calculated.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_picontrolh1">piControlH1</code></td>
<td>
<p>If specified, the assumed probabilities in the control arm
under which the sample size recalculation was performed
and the conditional power was calculated.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_calcsubjectsfunction">calcSubjectsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, sample size recalculation is performed with conditional power and specified
<code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_selectpopulationsfunction">selectPopulationsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how populations
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>populations</code>
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedPopulations"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentRates_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities,
selection probabilities, and expected sample size at given number of subjects,
parameter configuration, and treatment arm selection rule in the enrichment situation.
An allocation ratio can be specified referring to the ratio of number of
subjects in the active treatment groups as compared to the control group.
</p>
<p>The definition of <code>piTreatmentH1</code> and/or <code>piControlH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfSubjectsPerStage</code>, and
<code>maxNumberOfSubjectsPerStage</code> (or <code>calcSubjectsFunction</code>) are defined.
</p>
<p><code>calcSubjectsFunction</code><br />
This function returns the number of subjects at given conditional power and
conditional critical value for specified testing situation.
The function might depend on the variables
<code>stage</code>,
<code>selectedPopulations</code>,
<code>directionUpper</code>,
<code>plannedSubjects</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfSubjectsPerStage</code>,
<code>maxNumberOfSubjectsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>,
<code>overallRatesTreatment</code>,
<code>overallRatesControl</code>,
<code>piTreatmentH1</code>, and
<code>piControlH1</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assess a population selection strategy with two subset populations and
# a binary endpoint using a stratified analysis. No early efficacy stop,
# weighted inverse normal method with weight sqrt(0.4).
pi2 &lt;- c(0.3, 0.4, 0.3, 0.55)
pi1Seq &lt;- seq(0.0, 0.2, 0.2)
pi1 &lt;- matrix(rep(pi1Seq, length(pi2)), ncol = length(pi1Seq), byrow = TRUE) + pi2
effectList &lt;- list(
    subGroups = c("S1", "S2", "S12", "R"), 
    prevalences = c(0.1, 0.4, 0.2, 0.3),
    piControl = pi2, 
    piTreatments = expand.grid(pi1[1, ], pi1[2, ], pi1[3, ], pi1[4, ])
)
design &lt;- getDesignInverseNormal(informationRates = c(0.4, 1),
    typeOfDesign = "noEarlyEfficacy")
simResultsPE &lt;- getSimulationEnrichmentRates(design, 
    plannedSubjects = c(150, 300),
    allocationRatioPlanned = 1.5, directionUpper = TRUE,
    effectList = effectList, stratifiedAnalysis = TRUE,
    intersectionTest = "Sidak",
    typeOfSelection = "epsilon", epsilonValue = 0.025,
    maxNumberOfIterations = 100)
print(simResultsPE)	

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationEnrichmentSurvival'>Get Simulation Enrichment Survival</h2><span id='topic+getSimulationEnrichmentSurvival'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping and selection probabilities, conditional power,
and expected sample size for testing hazard ratios in an enrichment design testing situation.
In contrast to <code>getSimulationSurvival()</code> (where survival times are simulated), normally
distributed logrank test statistics are simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationEnrichmentSurvival(
  design = NULL,
  ...,
  effectList = NULL,
  intersectionTest = c("Simes", "SpiessensDebois", "Bonferroni", "Sidak"),
  stratifiedAnalysis = TRUE,
  directionUpper = NA,
  adaptations = NA,
  typeOfSelection = c("best", "rBest", "epsilon", "all", "userDefined"),
  effectMeasure = c("effectEstimate", "testStatistic"),
  successCriterion = c("all", "atLeastOne"),
  epsilonValue = NA_real_,
  rValue = NA_real_,
  threshold = -Inf,
  plannedEvents = NA_real_,
  allocationRatioPlanned = NA_real_,
  minNumberOfEventsPerStage = NA_real_,
  maxNumberOfEventsPerStage = NA_real_,
  conditionalPower = NA_real_,
  thetaH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcEventsFunction = NULL,
  selectPopulationsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_effectlist">effectList</code></td>
<td>
<p>List of subsets, prevalences, and effect sizes with columns and number of rows
reflecting the different situations to consider (see examples).</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Four options are available in enrichment designs: <code>"SpiessensDebois"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
and <code>"Sidak"</code>, default is <code>"Simes"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_stratifiedanalysis">stratifiedAnalysis</code></td>
<td>
<p>Logical. For enrichment designs, typically a stratified analysis should be chosen.
For testing rates, also a non-stratified analysis based on overall data can be performed.
For survival data, only a stratified analysis is possible (see Brannath et al., 2009),
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_adaptations">adaptations</code></td>
<td>
<p>A logical vector of length <code>kMax - 1</code> indicating whether or not an adaptation takes
place at interim k, default is <code>rep(TRUE, kMax - 1)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_typeofselection">typeOfSelection</code></td>
<td>
<p>The way the treatment arms or populations are selected at interim.
Five options are available: <code>"best"</code>, <code>"rbest"</code>, <code>"epsilon"</code>, <code>"all"</code>, and <code>"userDefined"</code>,
default is <code>"best"</code>.<br />
For <code>"rbest"</code> (select the <code>rValue</code> best treatment arms/populations), the parameter <code>rValue</code> has to be specified,
for <code>"epsilon"</code> (select treatment arm/population not worse than epsilon compared to the best), the parameter
<code>epsilonValue</code> has to be specified.
If <code>"userDefined"</code> is selected, <code>"selectArmsFunction"</code> or <code>"selectPopulationsFunction"</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_effectmeasure">effectMeasure</code></td>
<td>
<p>Criterion for treatment arm/population selection, either based on test statistic
(<code>"testStatistic"</code>) or effect estimate (difference for means and rates or ratio for survival) (<code>"effectEstimate"</code>),
default is <code>"effectEstimate"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_successcriterion">successCriterion</code></td>
<td>
<p>Defines when the study is stopped for efficacy at interim.
Two options are available: <code>"all"</code> stops the trial
if the efficacy criterion is fulfilled for all selected treatment arms/populations,
<code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be
superior to control at interim, default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_epsilonvalue">epsilonValue</code></td>
<td>
<p>For <code>typeOfSelection = "epsilon"</code> (select treatment arm / population not worse than
epsilon compared to the best), the parameter <code>epsilonValue</code> has to be specified. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_rvalue">rValue</code></td>
<td>
<p>For <code>typeOfSelection = "rbest"</code> (select the <code>rValue</code> best treatment arms / populations),
the parameter <code>rValue</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_threshold">threshold</code></td>
<td>
<p>Selection criterion: treatment arm / population is selected only if <code>effectMeasure</code>
exceeds <code>threshold</code>, default is <code>-Inf</code>.
<code>threshold</code> can also be a vector of length <code>activeArms</code> referring to
a separate threshold condition over the treatment arms.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_plannedevents">plannedEvents</code></td>
<td>
<p><code>plannedEvents</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) events in survival designs when the interim stages are planned.
For two treatment arms, it is the number of events for both treatment arms.
For multi-arm designs, <code>plannedEvents</code> refers to the overall number of events for the selected arms plus control.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_minnumberofeventsperstage">minNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfEventsPerStage</code> with length kMax determines the
minimum number of events per stage (i.e., not cumulated), the first element
is not taken into account.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_maxnumberofeventsperstage">maxNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfEventsPerStage</code> with length kMax determines the maximum number
of events per stage (i.e., not cumulated), the first element is not taken into account.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_thetah1">thetaH1</code></td>
<td>
<p>If specified, the value of the alternative under which
the conditional power or sample size recalculation calculation is performed. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_calceventsfunction">calcEventsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, event number recalculation is performed with conditional power and specified
<code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_selectpopulationsfunction">selectPopulationsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how populations
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>populations</code>
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedPopulations"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationEnrichmentSurvival_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities,
selection probabilities, and expected event number at given number of events,
parameter configuration, and population selection rule in the enrichment situation.
An allocation ratio can be specified referring to the ratio of number of subjects
in the active treatment group as compared to the control group.
</p>
<p>The definition of <code>thetaH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfEventsPerStage</code>, and
<code>maxNumberOfEventsPerStage</code> (or <code>calcEventsFunction</code>) are defined.
</p>
<p><code>calcEventsFunction</code><br />
This function returns the number of events at given conditional power
and conditional critical value for specified testing situation.
The function might depend on the variables
<code>stage</code>,
<code>selectedPopulations</code>,
<code>plannedEvents</code>,
<code>directionUpper</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfEventsPerStage</code>,
<code>maxNumberOfEventsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>, and
<code>overallEffects</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assess a population selection strategy with one subset population and
# a survival endpoint. The considered situations are defined through the 
# event rates yielding a range of hazard ratios in the subsets. Design 
# with O'Brien and Fleming alpha spending and a reassessment of event 
# number in the first interim based on conditional power and assumed 
# hazard ratio using weighted inverse normal combination test.  
    
subGroups &lt;- c("S", "R")
prevalences &lt;- c(0.40, 0.60)
 
p2 &lt;- c(0.3, 0.4)
range1 &lt;- p2[1] + seq(0, 0.3, 0.05)

p1 &lt;- c()
for (x1 in range1) {
    p1 &lt;- c(p1, x1, p2[2] + 0.1)
}		
hazardRatios &lt;- log(matrix(1 - p1, byrow = TRUE, ncol = 2)) /
    matrix(log(1 - p2), byrow = TRUE, ncol = 2,
    nrow = length(range1))

effectList &lt;- list(subGroups=subGroups, prevalences=prevalences,
    hazardRatios = hazardRatios)

design &lt;- getDesignInverseNormal(informationRates = c(0.3, 0.7, 1),
    typeOfDesign = "asOF")

simResultsPE &lt;- getSimulationEnrichmentSurvival(design, 
    plannedEvents = c(40, 90, 120),
    effectList = effectList,
    typeOfSelection = "rbest", rValue = 2,
    conditionalPower = 0.8, minNumberOfEventsPerStage = c(NA, 50, 30),
    maxNumberOfEventsPerStage = c(NA, 150, 30), thetaH1 = 4 / 3,
    maxNumberOfIterations = 100)
print(simResultsPE)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationMeans'>Get Simulation Means</h2><span id='topic+getSimulationMeans'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping probabilities, conditional power, and expected sample size
for testing means in a one or two treatment groups testing situation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationMeans(
  design = NULL,
  ...,
  groups = 2L,
  normalApproximation = TRUE,
  meanRatio = FALSE,
  thetaH0 = ifelse(meanRatio, 1, 0),
  alternative = seq(0, 1, 0.2),
  stDev = 1,
  plannedSubjects = NA_real_,
  directionUpper = NA,
  allocationRatioPlanned = NA_real_,
  minNumberOfSubjectsPerStage = NA_real_,
  maxNumberOfSubjectsPerStage = NA_real_,
  conditionalPower = NA_real_,
  thetaH1 = NA_real_,
  stDevH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcSubjectsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationMeans_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_groups">groups</code></td>
<td>
<p>The number of treatment groups (1 or 2), default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_normalapproximation">normalApproximation</code></td>
<td>
<p>The type of computation of the p-values. Default is <code>TRUE</code>,
i.e., normally distributed test statistics are generated.
If <code>FALSE</code>, the t test is used for calculating the p-values,
i.e., t distributed test statistics are generated.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_meanratio">meanRatio</code></td>
<td>
<p>If <code>TRUE</code>, the design characteristics for
one-sided testing of H0: <code>mu1 / mu2 = thetaH0</code> are simulated, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_alternative">alternative</code></td>
<td>
<p>The alternative hypothesis value for testing means under which the data is simulated.
This can be a vector of assumed alternatives, default is <code>seq(0, 1, 0.2)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_stdev">stDev</code></td>
<td>
<p>The standard deviation under which the data is simulated,
default is <code>1</code>.
If <code>meanRatio = TRUE</code> is specified, <code>stDev</code> defines
the coefficient of variation <code>sigma / mu2</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_plannedsubjects">plannedSubjects</code></td>
<td>
<p><code>plannedSubjects</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) subjects when the interim stages are planned.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs, <code>plannedSubjects</code> refers to the number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_minnumberofsubjectsperstage">minNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the
minimum number of subjects per stage (i.e., not cumulated), the first element
is not taken into account. For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>minNumberOfSubjectsPerStage</code> refers
to the minimum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_maxnumberofsubjectsperstage">maxNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the maximum number
of subjects per stage (i.e., not cumulated), the first element is not taken into account.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>maxNumberOfSubjectsPerStage</code> refers
to the maximum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_thetah1">thetaH1</code></td>
<td>
<p>If specified, the value of the alternative under which
the conditional power or sample size recalculation calculation is performed. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_stdevh1">stDevH1</code></td>
<td>
<p>If specified, the value of the standard deviation under which
the conditional power or sample size recalculation calculation is performed,
default is the value of <code>stDev</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_calcsubjectsfunction">calcSubjectsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, sample size recalculation is performed with conditional power and specified
<code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationMeans_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities, conditional power, and expected
sample size at given number of subjects and parameter configuration.
Additionally, an allocation ratio = n1/n2 can be specified where n1 and n2 are the number
of subjects in the two treatment groups.
</p>
<p>The definition of <code>thetaH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfSubjectsPerStage</code>, and
<code>maxNumberOfSubjectsPerStage</code> (or <code>calcSubjectsFunction</code>) are defined.
</p>
<p><code>calcSubjectsFunction</code><br />
This function returns the number of subjects at given conditional power and conditional critical value for specified
testing situation. The function might depend on variables
<code>stage</code>,
<code>meanRatio</code>,
<code>thetaH0</code>,
<code>groups</code>,
<code>plannedSubjects</code>,
<code>sampleSizesPerStage</code>,
<code>directionUpper</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfSubjectsPerStage</code>,
<code>maxNumberOfSubjectsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>,
<code>thetaH1</code>, and
<code>stDevH1</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Simulation Data</h3>

<p>The summary statistics &quot;Simulated data&quot; contains the following parameters: median <a href="base.html#topic+range">range</a>; mean +/-sd<br />
</p>
<p><code>$show(showStatistics = FALSE)</code> or <code>$setShowStatistics(FALSE)</code> can be used to disable
the output of the aggregated simulated data.<br />
</p>
<p>Example 1: <br />
<code>simulationResults &lt;- getSimulationMeans(plannedSubjects = 40)</code> <br />
<code>simulationResults$show(showStatistics = FALSE)</code><br />
</p>
<p>Example 2: <br />
<code>simulationResults &lt;- getSimulationMeans(plannedSubjects = 40)</code> <br />
<code>simulationResults$setShowStatistics(FALSE)</code><br />
<code>simulationResults</code><br />
</p>
<p><code><a href="#topic+getData">getData()</a></code> can be used to get the aggregated simulated data from the
object as <code><a href="base.html#topic+data.frame">data.frame</a></code>. The data frame contains the following columns:
</p>

<ol>
<li> <p><code>iterationNumber</code>: The number of the simulation iteration.
</p>
</li>
<li> <p><code>stageNumber</code>: The stage.
</p>
</li>
<li> <p><code>alternative</code>: The alternative hypothesis value.
</p>
</li>
<li> <p><code>numberOfSubjects</code>: The number of subjects under consideration when the
(interim) analysis takes place.
</p>
</li>
<li> <p><code>rejectPerStage</code>: 1 if null hypothesis can be rejected, 0 otherwise.
</p>
</li>
<li> <p><code>futilityPerStage</code>: 1 if study should be stopped for futility, 0 otherwise.
</p>
</li>
<li> <p><code>testStatistic</code>: The test statistic that is used for the test decision,
depends on which design was chosen (group sequential, inverse normal, or Fisher's combination test).
</p>
</li>
<li> <p><code>testStatisticsPerStage</code>: The test statistic for each stage if only data from
the considered stage is taken into account.
</p>
</li>
<li> <p><code>effectEstimate</code>: Overall simulated standardized effect estimate.
</p>
</li>
<li> <p><code>trialStop</code>: <code>TRUE</code> if study should be stopped for efficacy or futility or final stage, <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>conditionalPowerAchieved</code>: The conditional power for the subsequent stage of the trial for
selected sample size and effect. The effect is either estimated from the data or can be
user defined with <code>thetaH1</code>.
</p>
</li></ol>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size design with two groups, total sample size 40,
# alternative = c(0, 0.2, 0.4, 0.8, 1), and standard deviation = 1 (the default)
getSimulationMeans(plannedSubjects = 40, maxNumberOfIterations = 10)

# Increase number of simulation iterations and compare results
# with power calculator using normal approximation
getSimulationMeans(
    alternative = 0:4, stDev = 5,
    plannedSubjects = 40, maxNumberOfIterations = 1000
)
getPowerMeans(
    alternative = 0:4, stDev = 5,
    maxNumberOfSubjects = 40, normalApproximation = TRUE
)

# Do the same for a three-stage O'Brien&amp;Fleming inverse
# normal group sequential design with non-binding futility stops
designIN &lt;- getDesignInverseNormal(typeOfDesign = "OF", futilityBounds = c(0, 0))
x &lt;- getSimulationMeans(designIN,
    alternative = c(0:4), stDev = 5,
    plannedSubjects = c(20, 40, 60), maxNumberOfIterations = 1000
)
getPowerMeans(designIN,
    alternative = 0:4, stDev = 5,
    maxNumberOfSubjects = 60, normalApproximation = TRUE
)

# Assess power and average sample size if a sample size increase is foreseen
# at conditional power 80% for each subsequent stage based on observed overall
# effect and specified minNumberOfSubjectsPerStage and
# maxNumberOfSubjectsPerStage
getSimulationMeans(designIN,
    alternative = 0:4, stDev = 5,
    plannedSubjects = c(20, 40, 60),
    minNumberOfSubjectsPerStage = c(NA, 20, 20),
    maxNumberOfSubjectsPerStage = c(NA, 80, 80),
    conditionalPower = 0.8,
    maxNumberOfIterations = 50
)

# Do the same under the assumption that a sample size increase only takes
# place at the first interim. The sample size for the third stage is set equal
# to the second stage sample size.
mySampleSizeCalculationFunction &lt;- function(..., stage,
        minNumberOfSubjectsPerStage,
        maxNumberOfSubjectsPerStage,
        sampleSizesPerStage,
        conditionalPower,
        conditionalCriticalValue,
        allocationRatioPlanned,
        thetaH1,
        stDevH1) {
    if (stage &lt;= 2) {
        # Note that allocationRatioPlanned is as a vector of length kMax
        stageSubjects &lt;- (1 + allocationRatioPlanned[stage])^2 / 
            allocationRatioPlanned[stage] *
            (max(0, conditionalCriticalValue + stats::qnorm(conditionalPower)))^2 /
            (max(1e-12, thetaH1 / stDevH1))^2
        stageSubjects &lt;- min(max(
            minNumberOfSubjectsPerStage[stage],
            stageSubjects
        ), maxNumberOfSubjectsPerStage[stage])
    } else {
        stageSubjects &lt;- sampleSizesPerStage[stage - 1]
    }
    return(stageSubjects)
}
getSimulationMeans(designIN,
    alternative = 0:4, stDev = 5,
    plannedSubjects = c(20, 40, 60),
    minNumberOfSubjectsPerStage = c(NA, 20, 20),
    maxNumberOfSubjectsPerStage = c(NA, 80, 80),
    conditionalPower = 0.8,
    calcSubjectsFunction = mySampleSizeCalculationFunction,
    maxNumberOfIterations = 50
)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationMultiArmMeans'>Get Simulation Multi-Arm Means</h2><span id='topic+getSimulationMultiArmMeans'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping and selection probabilities, conditional power,
and expected sample size for testing means in a multi-arm treatment groups testing situation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationMultiArmMeans(
  design = NULL,
  ...,
  activeArms = 3L,
  effectMatrix = NULL,
  typeOfShape = c("linear", "sigmoidEmax", "userDefined"),
  muMaxVector = seq(0, 1, 0.2),
  gED50 = NA_real_,
  slope = 1,
  intersectionTest = c("Dunnett", "Bonferroni", "Simes", "Sidak", "Hierarchical"),
  stDev = 1,
  adaptations = NA,
  typeOfSelection = c("best", "rBest", "epsilon", "all", "userDefined"),
  effectMeasure = c("effectEstimate", "testStatistic"),
  successCriterion = c("all", "atLeastOne"),
  epsilonValue = NA_real_,
  rValue = NA_real_,
  threshold = -Inf,
  plannedSubjects = NA_integer_,
  allocationRatioPlanned = NA_real_,
  minNumberOfSubjectsPerStage = NA_real_,
  maxNumberOfSubjectsPerStage = NA_real_,
  conditionalPower = NA_real_,
  thetaH1 = NA_real_,
  stDevH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcSubjectsFunction = NULL,
  selectArmsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationMultiArmMeans_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_activearms">activeArms</code></td>
<td>
<p>The number of active treatment arms to be compared with control, default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_effectmatrix">effectMatrix</code></td>
<td>
<p>Matrix of effect sizes with <code>activeArms</code> columns and number of rows
reflecting the different situations to consider.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_typeofshape">typeOfShape</code></td>
<td>
<p>The shape of the dose-response relationship over the treatment groups.
This can be either <code>"linear"</code>, <code>"sigmoidEmax"</code>, or <code>"userDefined"</code>,
default is <code>"linear"</code>.<br />
For <code>"linear"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with highest response.
If <code>"sigmoidEmax"</code> is selected, <code>"gED50"</code> and <code>"slope"</code> has to be entered
to specify the ED50 and the slope of the sigmoid Emax model.
For <code>"sigmoidEmax"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with response according to infinite dose.
If <code>"userDefined"</code> is selected, <code>"effectMatrix"</code> has to be entered.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_mumaxvector">muMaxVector</code></td>
<td>
<p>Range of effect sizes for the treatment group with highest response
for <code>"linear"</code> and <code>"sigmoidEmax"</code> model, default is <code>seq(0, 1, 0.2)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_ged50">gED50</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"gED50"</code> has to be entered
to specify the ED50 of the sigmoid Emax model.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_slope">slope</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"slope"</code> can be entered
to specify the slope of the sigmoid Emax model, default is 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Five options are available in multi-arm designs: <code>"Dunnett"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
<code>"Sidak"</code>, and <code>"Hierarchical"</code>, default is <code>"Dunnett"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_stdev">stDev</code></td>
<td>
<p>The standard deviation under which the data is simulated,
default is <code>1</code>.
If <code>meanRatio = TRUE</code> is specified, <code>stDev</code> defines
the coefficient of variation <code>sigma / mu2</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_adaptations">adaptations</code></td>
<td>
<p>A logical vector of length <code>kMax - 1</code> indicating whether or not an adaptation takes
place at interim k, default is <code>rep(TRUE, kMax - 1)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_typeofselection">typeOfSelection</code></td>
<td>
<p>The way the treatment arms or populations are selected at interim.
Five options are available: <code>"best"</code>, <code>"rbest"</code>, <code>"epsilon"</code>, <code>"all"</code>, and <code>"userDefined"</code>,
default is <code>"best"</code>.<br />
For <code>"rbest"</code> (select the <code>rValue</code> best treatment arms/populations), the parameter <code>rValue</code> has to be specified,
for <code>"epsilon"</code> (select treatment arm/population not worse than epsilon compared to the best), the parameter
<code>epsilonValue</code> has to be specified.
If <code>"userDefined"</code> is selected, <code>"selectArmsFunction"</code> or <code>"selectPopulationsFunction"</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_effectmeasure">effectMeasure</code></td>
<td>
<p>Criterion for treatment arm/population selection, either based on test statistic
(<code>"testStatistic"</code>) or effect estimate (difference for means and rates or ratio for survival) (<code>"effectEstimate"</code>),
default is <code>"effectEstimate"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_successcriterion">successCriterion</code></td>
<td>
<p>Defines when the study is stopped for efficacy at interim.
Two options are available: <code>"all"</code> stops the trial
if the efficacy criterion is fulfilled for all selected treatment arms/populations,
<code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be
superior to control at interim, default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_epsilonvalue">epsilonValue</code></td>
<td>
<p>For <code>typeOfSelection = "epsilon"</code> (select treatment arm / population not worse than
epsilon compared to the best), the parameter <code>epsilonValue</code> has to be specified. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_rvalue">rValue</code></td>
<td>
<p>For <code>typeOfSelection = "rbest"</code> (select the <code>rValue</code> best treatment arms / populations),
the parameter <code>rValue</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_threshold">threshold</code></td>
<td>
<p>Selection criterion: treatment arm / population is selected only if <code>effectMeasure</code>
exceeds <code>threshold</code>, default is <code>-Inf</code>.
<code>threshold</code> can also be a vector of length <code>activeArms</code> referring to
a separate threshold condition over the treatment arms.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_plannedsubjects">plannedSubjects</code></td>
<td>
<p><code>plannedSubjects</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) subjects when the interim stages are planned.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs, <code>plannedSubjects</code> refers to the number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_minnumberofsubjectsperstage">minNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the
minimum number of subjects per stage (i.e., not cumulated), the first element
is not taken into account. For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>minNumberOfSubjectsPerStage</code> refers
to the minimum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_maxnumberofsubjectsperstage">maxNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the maximum number
of subjects per stage (i.e., not cumulated), the first element is not taken into account.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>maxNumberOfSubjectsPerStage</code> refers
to the maximum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_thetah1">thetaH1</code></td>
<td>
<p>If specified, the value of the alternative under which
the conditional power or sample size recalculation calculation is performed. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_stdevh1">stDevH1</code></td>
<td>
<p>If specified, the value of the standard deviation under which
the conditional power or sample size recalculation calculation is performed,
default is the value of <code>stDev</code>. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_calcsubjectsfunction">calcSubjectsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, sample size recalculation is performed with conditional power and specified
<code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_selectarmsfunction">selectArmsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how treatment arms
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>activeArms</code>,
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedArms"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmMeans_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities, selection probabilities,
and expected sample size at given number of subjects, parameter configuration, and treatment arm
selection rule in the multi-arm situation.
An allocation ratio can be specified referring to the ratio of number of subjects in the active
treatment groups as compared to the control group.
</p>
<p>The definition of <code>thetaH1</code> and/or <code>stDevH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfSubjectsPerStage</code>, and
<code>maxNumberOfSubjectsPerStage</code> (or <code>calcSubjectsFunction</code>) are defined.
</p>
<p><code>calcSubjectsFunction</code><br />
This function returns the number of subjects at given conditional power and conditional
critical value for specified testing situation. The function might depend on the variables
<code>stage</code>,
<code>selectedArms</code>,
<code>plannedSubjects</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfSubjectsPerStage</code>,
<code>maxNumberOfSubjectsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>,
<code>overallEffects</code>, and
<code>stDevH1</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assess a treatment-arm selection strategy with three active arms, 
# if the better of the arms is selected for the second stage, and 
# compare it with the no-selection case. 
# Assume a linear dose-response relationship 
maxNumberOfIterations &lt;- 100
designIN &lt;- getDesignInverseNormal(typeOfDesign = "OF", kMax = 2)
sim &lt;- getSimulationMultiArmMeans(design = designIN,
    activeArms = 3, typeOfShape = "linear",
    muMaxVector = seq(0,0.8,0.2),
    intersectionTest = "Simes",
    typeOfSelection = "best",
    plannedSubjects = c(30,60),
    maxNumberOfIterations = maxNumberOfIterations)

sim0 &lt;- getSimulationMultiArmMeans(design = designIN,
    activeArms = 3, typeOfShape = "linear",
    muMaxVector = seq(0,0.8,0.2),
    intersectionTest = "Simes",
    typeOfSelection = "all",
    plannedSubjects = c(30,60),
    maxNumberOfIterations = maxNumberOfIterations)

sim$rejectAtLeastOne
sim$expectedNumberOfSubjects

sim0$rejectAtLeastOne
sim0$expectedNumberOfSubjects

# Compare the power of the conditional Dunnett test with the power of the 
# combination test using Dunnett's intersection tests if no treatment arm 
# selection takes place. Asseume a linear dose-response relationship.
maxNumberOfIterations &lt;- 100
designIN &lt;- getDesignInverseNormal(typeOfDesign = "asUser", 
    userAlphaSpending = c(0, 0.025))
designCD &lt;- getDesignConditionalDunnett(secondStageConditioning = TRUE)

index &lt;- 1
for (design in c(designIN, designCD)) {
    results &lt;- getSimulationMultiArmMeans(design, activeArms = 3, 
        muMaxVector = seq(0, 1, 0.2), typeOfShape = "linear", 
        plannedSubjects = cumsum(rep(20, 2)), 
        intersectionTest = "Dunnett", 
        typeOfSelection = "all", maxNumberOfIterations = maxNumberOfIterations)
    if (index == 1) {
        drift &lt;- results$effectMatrix[nrow(results$effectMatrix), ]
        plot(drift, results$rejectAtLeastOne, type = "l", lty = 1, 
            lwd = 3, col = "black", ylab = "Power")
    } else {
        lines(drift,results$rejectAtLeastOne, type = "l", 
            lty = index, lwd = 3, col = "red")
    }
    index &lt;- index + 1
}
legend("topleft", legend=c("Combination Dunnett", "Conditional Dunnett"),
    col=c("black", "red"), lty = (1:2), cex = 0.8)

# Assess the design characteristics of a user defined selection
# strategy in a two-stage design using the inverse normal method
# with constant bounds. Stopping for futility due to
# de-selection of all treatment arms.
designIN &lt;- getDesignInverseNormal(typeOfDesign = "P", kMax = 2)

mySelection &lt;- function(effectVector) {
    selectedArms &lt;- (effectVector &gt;= c(0, 0.1, 0.3))
    return(selectedArms)
}

results &lt;- getSimulationMultiArmMeans(designIN, activeArms = 3, 
    muMaxVector = seq(0, 1, 0.2), 
    typeOfShape = "linear", 
    plannedSubjects = c(30,60), 
    intersectionTest = "Dunnett", 
    typeOfSelection = "userDefined",
    selectArmsFunction = mySelection,
    maxNumberOfIterations = 100)

options(rpact.summary.output.size = "medium")         
summary(results)
if (require(ggplot2)) plot(results, type = c(5,3,9), grid = 4)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationMultiArmRates'>Get Simulation Multi-Arm Rates</h2><span id='topic+getSimulationMultiArmRates'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping and selection probabilities, conditional power,
and expected sample size for testing rates in a multi-arm treatment groups testing situation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationMultiArmRates(
  design = NULL,
  ...,
  activeArms = 3L,
  effectMatrix = NULL,
  typeOfShape = c("linear", "sigmoidEmax", "userDefined"),
  piMaxVector = seq(0.2, 0.5, 0.1),
  piControl = 0.2,
  gED50 = NA_real_,
  slope = 1,
  intersectionTest = c("Dunnett", "Bonferroni", "Simes", "Sidak", "Hierarchical"),
  directionUpper = NA,
  adaptations = NA,
  typeOfSelection = c("best", "rBest", "epsilon", "all", "userDefined"),
  effectMeasure = c("effectEstimate", "testStatistic"),
  successCriterion = c("all", "atLeastOne"),
  epsilonValue = NA_real_,
  rValue = NA_real_,
  threshold = -Inf,
  plannedSubjects = NA_real_,
  allocationRatioPlanned = NA_real_,
  minNumberOfSubjectsPerStage = NA_real_,
  maxNumberOfSubjectsPerStage = NA_real_,
  conditionalPower = NA_real_,
  piTreatmentsH1 = NA_real_,
  piControlH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcSubjectsFunction = NULL,
  selectArmsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationMultiArmRates_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_activearms">activeArms</code></td>
<td>
<p>The number of active treatment arms to be compared with control, default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_effectmatrix">effectMatrix</code></td>
<td>
<p>Matrix of effect sizes with <code>activeArms</code> columns and number of rows
reflecting the different situations to consider.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_typeofshape">typeOfShape</code></td>
<td>
<p>The shape of the dose-response relationship over the treatment groups.
This can be either <code>"linear"</code>, <code>"sigmoidEmax"</code>, or <code>"userDefined"</code>,
default is <code>"linear"</code>.<br />
For <code>"linear"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with highest response.
If <code>"sigmoidEmax"</code> is selected, <code>"gED50"</code> and <code>"slope"</code> has to be entered
to specify the ED50 and the slope of the sigmoid Emax model.
For <code>"sigmoidEmax"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with response according to infinite dose.
If <code>"userDefined"</code> is selected, <code>"effectMatrix"</code> has to be entered.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_pimaxvector">piMaxVector</code></td>
<td>
<p>Range of assumed probabilities for the treatment group with
highest response for <code>"linear"</code> and <code>"sigmoidEmax"</code> model,
default is <code>seq(0, 1, 0.2)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_picontrol">piControl</code></td>
<td>
<p>If specified, the assumed probability in the control arm
for simulation and under which the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_ged50">gED50</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"gED50"</code> has to be entered
to specify the ED50 of the sigmoid Emax model.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_slope">slope</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"slope"</code> can be entered
to specify the slope of the sigmoid Emax model, default is 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Five options are available in multi-arm designs: <code>"Dunnett"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
<code>"Sidak"</code>, and <code>"Hierarchical"</code>, default is <code>"Dunnett"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_adaptations">adaptations</code></td>
<td>
<p>A logical vector of length <code>kMax - 1</code> indicating whether or not an adaptation takes
place at interim k, default is <code>rep(TRUE, kMax - 1)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_typeofselection">typeOfSelection</code></td>
<td>
<p>The way the treatment arms or populations are selected at interim.
Five options are available: <code>"best"</code>, <code>"rbest"</code>, <code>"epsilon"</code>, <code>"all"</code>, and <code>"userDefined"</code>,
default is <code>"best"</code>.<br />
For <code>"rbest"</code> (select the <code>rValue</code> best treatment arms/populations), the parameter <code>rValue</code> has to be specified,
for <code>"epsilon"</code> (select treatment arm/population not worse than epsilon compared to the best), the parameter
<code>epsilonValue</code> has to be specified.
If <code>"userDefined"</code> is selected, <code>"selectArmsFunction"</code> or <code>"selectPopulationsFunction"</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_effectmeasure">effectMeasure</code></td>
<td>
<p>Criterion for treatment arm/population selection, either based on test statistic
(<code>"testStatistic"</code>) or effect estimate (difference for means and rates or ratio for survival) (<code>"effectEstimate"</code>),
default is <code>"effectEstimate"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_successcriterion">successCriterion</code></td>
<td>
<p>Defines when the study is stopped for efficacy at interim.
Two options are available: <code>"all"</code> stops the trial
if the efficacy criterion is fulfilled for all selected treatment arms/populations,
<code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be
superior to control at interim, default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_epsilonvalue">epsilonValue</code></td>
<td>
<p>For <code>typeOfSelection = "epsilon"</code> (select treatment arm / population not worse than
epsilon compared to the best), the parameter <code>epsilonValue</code> has to be specified. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_rvalue">rValue</code></td>
<td>
<p>For <code>typeOfSelection = "rbest"</code> (select the <code>rValue</code> best treatment arms / populations),
the parameter <code>rValue</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_threshold">threshold</code></td>
<td>
<p>Selection criterion: treatment arm / population is selected only if <code>effectMeasure</code>
exceeds <code>threshold</code>, default is <code>-Inf</code>.
<code>threshold</code> can also be a vector of length <code>activeArms</code> referring to
a separate threshold condition over the treatment arms.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_plannedsubjects">plannedSubjects</code></td>
<td>
<p><code>plannedSubjects</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) subjects when the interim stages are planned.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs, <code>plannedSubjects</code> refers to the number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_minnumberofsubjectsperstage">minNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the
minimum number of subjects per stage (i.e., not cumulated), the first element
is not taken into account. For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>minNumberOfSubjectsPerStage</code> refers
to the minimum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_maxnumberofsubjectsperstage">maxNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the maximum number
of subjects per stage (i.e., not cumulated), the first element is not taken into account.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>maxNumberOfSubjectsPerStage</code> refers
to the maximum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_pitreatmentsh1">piTreatmentsH1</code></td>
<td>
<p>If specified, the assumed probability in the active treatment arm(s)
under which the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_picontrolh1">piControlH1</code></td>
<td>
<p>If specified, the assumed probability in the reference group
(if different from <code>piControl</code>) for which the conditional power was calculated.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_calcsubjectsfunction">calcSubjectsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, sample size recalculation is performed with conditional power and specified
<code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_selectarmsfunction">selectArmsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how treatment arms
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>activeArms</code>,
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedArms"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmRates_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities,
selection probabilities, and expected sample size at given number of subjects,
parameter configuration, and treatment arm selection rule in the multi-arm situation.
An allocation ratio can be specified referring to the ratio of number of
subjects in the active treatment groups as compared to the control group.
</p>
<p>The definition of <code>piTreatmentsH1</code> and/or <code>piControlH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfSubjectsPerStage</code>, and
<code>maxNumberOfSubjectsPerStage</code> (or <code>calcSubjectsFunction</code>) are defined.
</p>
<p><code>calcSubjectsFunction</code><br />
This function returns the number of subjects at given conditional power and
conditional critical value for specified testing situation.
The function might depend on the variables
<code>stage</code>,
<code>selectedArms</code>,
<code>directionUpper</code>,
<code>plannedSubjects</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfSubjectsPerStage</code>,
<code>maxNumberOfSubjectsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>,
<code>overallRates</code>,
<code>overallRatesControl</code>,
<code>piTreatmentsH1</code>, and
<code>piControlH1</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate the power of the combination test with two interim stages and 
# O'Brien &amp; Fleming boundaries using Dunnett's intersection tests if the 
# best treatment arm is selected at first interim. Selection only take 
# place if a non-negative treatment effect is observed (threshold = 0); 
# 20 subjects per stage and treatment arm, simulation is performed for 
# four parameter configurations.
design &lt;- getDesignInverseNormal(typeOfDesign = "OF")
effectMatrix &lt;- matrix(c(0.2,0.2,0.2,
    0.4,0.4,0.4,
    0.4,0.5,0.5,
    0.4,0.5,0.6),
    byrow = TRUE, nrow = 4, ncol = 3)
x &lt;- getSimulationMultiArmRates(design = design, typeOfShape = "userDefined", 
    effectMatrix = effectMatrix , piControl = 0.2, 
    typeOfSelection = "best", threshold = 0, intersectionTest = "Dunnett", 
    plannedSubjects = c(20, 40, 60), 
    maxNumberOfIterations = 50)
summary(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationMultiArmSurvival'>Get Simulation Multi-Arm Survival</h2><span id='topic+getSimulationMultiArmSurvival'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping and selection probabilities, conditional power, and
expected sample size for testing hazard ratios in a multi-arm treatment groups testing situation.
In contrast to <code>getSimulationSurvival()</code> (where survival times are simulated), normally
distributed logrank test statistics are simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationMultiArmSurvival(
  design = NULL,
  ...,
  activeArms = 3L,
  effectMatrix = NULL,
  typeOfShape = c("linear", "sigmoidEmax", "userDefined"),
  omegaMaxVector = seq(1, 2.6, 0.4),
  gED50 = NA_real_,
  slope = 1,
  intersectionTest = c("Dunnett", "Bonferroni", "Simes", "Sidak", "Hierarchical"),
  directionUpper = NA,
  adaptations = NA,
  typeOfSelection = c("best", "rBest", "epsilon", "all", "userDefined"),
  effectMeasure = c("effectEstimate", "testStatistic"),
  successCriterion = c("all", "atLeastOne"),
  correlationComputation = c("alternative", "null"),
  epsilonValue = NA_real_,
  rValue = NA_real_,
  threshold = -Inf,
  plannedEvents = NA_real_,
  allocationRatioPlanned = NA_real_,
  minNumberOfEventsPerStage = NA_real_,
  maxNumberOfEventsPerStage = NA_real_,
  conditionalPower = NA_real_,
  thetaH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcEventsFunction = NULL,
  selectArmsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationMultiArmSurvival_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_activearms">activeArms</code></td>
<td>
<p>The number of active treatment arms to be compared with control, default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_effectmatrix">effectMatrix</code></td>
<td>
<p>Matrix of effect sizes with <code>activeArms</code> columns and number of rows
reflecting the different situations to consider.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_typeofshape">typeOfShape</code></td>
<td>
<p>The shape of the dose-response relationship over the treatment groups.
This can be either <code>"linear"</code>, <code>"sigmoidEmax"</code>, or <code>"userDefined"</code>,
default is <code>"linear"</code>.<br />
For <code>"linear"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with highest response.
If <code>"sigmoidEmax"</code> is selected, <code>"gED50"</code> and <code>"slope"</code> has to be entered
to specify the ED50 and the slope of the sigmoid Emax model.
For <code>"sigmoidEmax"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with response according to infinite dose.
If <code>"userDefined"</code> is selected, <code>"effectMatrix"</code> has to be entered.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_omegamaxvector">omegaMaxVector</code></td>
<td>
<p>Range of hazard ratios with highest response for <code>"linear"</code> and
<code>"sigmoidEmax"</code> model, default is <code>seq(1, 2.6, 0.4)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_ged50">gED50</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"gED50"</code> has to be entered
to specify the ED50 of the sigmoid Emax model.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_slope">slope</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"slope"</code> can be entered
to specify the slope of the sigmoid Emax model, default is 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Five options are available in multi-arm designs: <code>"Dunnett"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
<code>"Sidak"</code>, and <code>"Hierarchical"</code>, default is <code>"Dunnett"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_adaptations">adaptations</code></td>
<td>
<p>A logical vector of length <code>kMax - 1</code> indicating whether or not an adaptation takes
place at interim k, default is <code>rep(TRUE, kMax - 1)</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_typeofselection">typeOfSelection</code></td>
<td>
<p>The way the treatment arms or populations are selected at interim.
Five options are available: <code>"best"</code>, <code>"rbest"</code>, <code>"epsilon"</code>, <code>"all"</code>, and <code>"userDefined"</code>,
default is <code>"best"</code>.<br />
For <code>"rbest"</code> (select the <code>rValue</code> best treatment arms/populations), the parameter <code>rValue</code> has to be specified,
for <code>"epsilon"</code> (select treatment arm/population not worse than epsilon compared to the best), the parameter
<code>epsilonValue</code> has to be specified.
If <code>"userDefined"</code> is selected, <code>"selectArmsFunction"</code> or <code>"selectPopulationsFunction"</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_effectmeasure">effectMeasure</code></td>
<td>
<p>Criterion for treatment arm/population selection, either based on test statistic
(<code>"testStatistic"</code>) or effect estimate (difference for means and rates or ratio for survival) (<code>"effectEstimate"</code>),
default is <code>"effectEstimate"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_successcriterion">successCriterion</code></td>
<td>
<p>Defines when the study is stopped for efficacy at interim.
Two options are available: <code>"all"</code> stops the trial
if the efficacy criterion is fulfilled for all selected treatment arms/populations,
<code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be
superior to control at interim, default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_correlationcomputation">correlationComputation</code></td>
<td>
<p>If <code>correlationComputation = "alternative"</code>,
for simulating log-rank statistics in the many-to-one design, a correlation
matrix according to Deng et al. (Biometrics, 2019) accounting for the
respective alternative is used;
if <code>correlationComputation = "null"</code>, a constant correlation matrix valid
under the null, i.e., not accounting for the alternative is used,
default is <code>"alternative"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_epsilonvalue">epsilonValue</code></td>
<td>
<p>For <code>typeOfSelection = "epsilon"</code> (select treatment arm / population not worse than
epsilon compared to the best), the parameter <code>epsilonValue</code> has to be specified. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_rvalue">rValue</code></td>
<td>
<p>For <code>typeOfSelection = "rbest"</code> (select the <code>rValue</code> best treatment arms / populations),
the parameter <code>rValue</code> has to be specified.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_threshold">threshold</code></td>
<td>
<p>Selection criterion: treatment arm / population is selected only if <code>effectMeasure</code>
exceeds <code>threshold</code>, default is <code>-Inf</code>.
<code>threshold</code> can also be a vector of length <code>activeArms</code> referring to
a separate threshold condition over the treatment arms.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_plannedevents">plannedEvents</code></td>
<td>
<p><code>plannedEvents</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) events in survival designs when the interim stages are planned.
For two treatment arms, it is the number of events for both treatment arms.
For multi-arm designs, <code>plannedEvents</code> refers to the overall number of events for the selected arms plus control.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_minnumberofeventsperstage">minNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfEventsPerStage</code> with length kMax determines the
minimum number of events per stage (i.e., not cumulated), the first element
is not taken into account.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_maxnumberofeventsperstage">maxNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfEventsPerStage</code> with length kMax determines the maximum number
of events per stage (i.e., not cumulated), the first element is not taken into account.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_thetah1">thetaH1</code></td>
<td>
<p>If specified, the value of the alternative under which
the conditional power or sample size recalculation calculation is performed. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_calceventsfunction">calcEventsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, event number recalculation is performed with conditional power and specified
<code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_selectarmsfunction">selectArmsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how treatment arms
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>activeArms</code>,
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedArms"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationMultiArmSurvival_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities,
selection probabilities, and expected sample size at given number of subjects,
parameter configuration, and treatment arm selection rule in the multi-arm situation.
An allocation ratio can be specified referring to the ratio of number of subjects
in the active treatment groups as compared to the control group.
</p>
<p>The definition of <code>thetaH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfEventsPerStage</code>, and
<code>maxNumberOfEventsPerStage</code> (or <code>calcEventsFunction</code>) are defined.
</p>
<p><code>calcEventsFunction</code><br />
This function returns the number of events at given conditional power
and conditional critical value for specified testing situation.
The function might depend on the variables
<code>stage</code>,
<code>selectedArms</code>,
<code>plannedEvents</code>,
<code>directionUpper</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfEventsPerStage</code>,
<code>maxNumberOfEventsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>, and
<code>overallEffects</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assess different selection rules for a two-stage survival design with 
# O'Brien &amp; Fleming alpha spending boundaries and (non-binding) stopping 
# for futility if the test statistic is negative. 
# Number of events at the second stage is adjusted based on conditional 
# power 80% and specified minimum and maximum number of Events.
design &lt;- getDesignInverseNormal(typeOfDesign = "asOF", futilityBounds = 0)

y1 &lt;- getSimulationMultiArmSurvival(design = design, activeArms = 4, 
    intersectionTest = "Simes", typeOfShape = "sigmoidEmax", 
    omegaMaxVector = seq(1, 2, 0.5), gED50 = 2, slope = 4, 
    typeOfSelection = "best", conditionalPower = 0.8, 
    minNumberOfEventsPerStage = c(NA_real_, 30), 
    maxNumberOfEventsPerStage = c(NA_real_, 90),
    maxNumberOfIterations = 50, 
    plannedEvents = c(75, 120))

y2 &lt;- getSimulationMultiArmSurvival(design = design, activeArms = 4, 
    intersectionTest = "Simes", typeOfShape = "sigmoidEmax", 
    omegaMaxVector = seq(1,2,0.5), gED50 = 2, slope = 4,
    typeOfSelection = "epsilon", epsilonValue = 0.2, 
    effectMeasure = "effectEstimate",
    conditionalPower = 0.8, minNumberOfEventsPerStage = c(NA_real_, 30), 
    maxNumberOfEventsPerStage = c(NA_real_, 90),
    maxNumberOfIterations = 50, 
	   plannedEvents = c(75, 120))

y1$effectMatrix

y1$rejectAtLeastOne
y2$rejectAtLeastOne

y1$selectedArms
y2$selectedArms

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationRates'>Get Simulation Rates</h2><span id='topic+getSimulationRates'></span>

<h3>Description</h3>

<p>Returns the simulated power, stopping probabilities, conditional power, and expected sample size for
testing rates in a one or two treatment groups testing situation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationRates(
  design = NULL,
  ...,
  groups = 2L,
  normalApproximation = TRUE,
  riskRatio = FALSE,
  thetaH0 = ifelse(riskRatio, 1, 0),
  pi1 = seq(0.2, 0.5, 0.1),
  pi2 = NA_real_,
  plannedSubjects = NA_real_,
  directionUpper = NA,
  allocationRatioPlanned = NA_real_,
  minNumberOfSubjectsPerStage = NA_real_,
  maxNumberOfSubjectsPerStage = NA_real_,
  conditionalPower = NA_real_,
  pi1H1 = NA_real_,
  pi2H1 = NA_real_,
  maxNumberOfIterations = 1000L,
  seed = NA_real_,
  calcSubjectsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationRates_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_groups">groups</code></td>
<td>
<p>The number of treatment groups (1 or 2), default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_normalapproximation">normalApproximation</code></td>
<td>
<p>The type of computation of the p-values. Default is <code>FALSE</code> for
testing means (i.e., the t test is used) and <code>TRUE</code> for testing rates and the hazard ratio.
For testing rates, if <code>normalApproximation = FALSE</code> is specified, the binomial test
(one sample) or the exact test of Fisher (two samples) is used for calculating the p-values.
In the survival setting <code>normalApproximation = FALSE</code> has no effect.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_riskratio">riskRatio</code></td>
<td>
<p>If <code>TRUE</code>, the design characteristics for
one-sided testing of H0: <code>pi1 / pi2 = thetaH0</code> are simulated, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed probability in
the active treatment group if two treatment groups
are considered, or the alternative probability for a one treatment group design,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed probability in the reference group if two treatment
groups are considered, default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_plannedsubjects">plannedSubjects</code></td>
<td>
<p><code>plannedSubjects</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) subjects when the interim stages are planned.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs, <code>plannedSubjects</code> refers to the number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_minnumberofsubjectsperstage">minNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the
minimum number of subjects per stage (i.e., not cumulated), the first element
is not taken into account. For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>minNumberOfSubjectsPerStage</code> refers
to the minimum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_maxnumberofsubjectsperstage">maxNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the maximum number
of subjects per stage (i.e., not cumulated), the first element is not taken into account.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>maxNumberOfSubjectsPerStage</code> refers
to the maximum number of subjects per selected active arm.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_pi1h1">pi1H1</code></td>
<td>
<p>If specified, the assumed probability in the active treatment group if two treatment groups
are considered, or the assumed probability for a one treatment group design, for which the conditional
power was calculated.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_pi2h1">pi2H1</code></td>
<td>
<p>If specified, the assumed probability in the reference group if two treatment groups
are considered, for which the conditional power was calculated.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_calcsubjectsfunction">calcSubjectsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, sample size recalculation is performed with conditional power and specified
<code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationRates_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities, conditional power, and expected
sample size at given number of subjects and parameter configuration.
Additionally, an allocation ratio = n1/n2 can be specified where n1 and n2 are the number
of subjects in the two treatment groups.
</p>
<p>The definition of <code>pi1H1</code> and/or <code>pi2H1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfSubjectsPerStage</code>, and
<code>maxNumberOfSubjectsPerStage</code> (or <code>calcSubjectsFunction</code>) are defined.
</p>
<p><code>calcSubjectsFunction</code><br />
This function returns the number of subjects at given conditional power and conditional critical value for specified
testing situation. The function might depend on variables
<code>stage</code>,
<code>riskRatio</code>,
<code>thetaH0</code>,
<code>groups</code>,
<code>plannedSubjects</code>,
<code>sampleSizesPerStage</code>,
<code>directionUpper</code>,
<code>allocationRatioPlanned</code>,
<code>minNumberOfSubjectsPerStage</code>,
<code>maxNumberOfSubjectsPerStage</code>,
<code>conditionalPower</code>,
<code>conditionalCriticalValue</code>,
<code>overallRate</code>,
<code>farringtonManningValue1</code>, and <code>farringtonManningValue2</code>.
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Simulation Data</h3>

<p>The summary statistics &quot;Simulated data&quot; contains the following parameters: median <a href="base.html#topic+range">range</a>; mean +/-sd<br />
</p>
<p><code>$show(showStatistics = FALSE)</code> or <code>$setShowStatistics(FALSE)</code> can be used to disable
the output of the aggregated simulated data.<br />
</p>
<p>Example 1: <br />
<code>simulationResults &lt;- getSimulationRates(plannedSubjects = 40)</code> <br />
<code>simulationResults$show(showStatistics = FALSE)</code><br />
</p>
<p>Example 2: <br />
<code>simulationResults &lt;- getSimulationRates(plannedSubjects = 40)</code> <br />
<code>simulationResults$setShowStatistics(FALSE)</code><br />
<code>simulationResults</code><br />
</p>
<p><code><a href="#topic+getData">getData()</a></code> can be used to get the aggregated simulated data from the
object as <code><a href="base.html#topic+data.frame">data.frame</a></code>. The data frame contains the following columns:
</p>

<ol>
<li> <p><code>iterationNumber</code>: The number of the simulation iteration.
</p>
</li>
<li> <p><code>stageNumber</code>: The stage.
</p>
</li>
<li> <p><code>pi1</code>: The assumed or derived event rate in the treatment group (if available).
</p>
</li>
<li> <p><code>pi2</code>: The assumed or derived event rate in the control group (if available).
</p>
</li>
<li> <p><code>numberOfSubjects</code>: The number of subjects under consideration when the
(interim) analysis takes place.
</p>
</li>
<li> <p><code>rejectPerStage</code>: 1 if null hypothesis can be rejected, 0 otherwise.
</p>
</li>
<li> <p><code>futilityPerStage</code>: 1 if study should be stopped for futility, 0 otherwise.
</p>
</li>
<li> <p><code>testStatistic</code>: The test statistic that is used for the test decision,
depends on which design was chosen (group sequential, inverse normal,
or Fisher combination test)'
</p>
</li>
<li> <p><code>testStatisticsPerStage</code>: The test statistic for each stage if only data from
the considered stage is taken into account.
</p>
</li>
<li> <p><code>overallRate1</code>: The cumulative rate in treatment group 1.
</p>
</li>
<li> <p><code>overallRate2</code>: The cumulative rate in treatment group 2.
</p>
</li>
<li> <p><code>stagewiseRates1</code>: The stage-wise rate in treatment group 1.
</p>
</li>
<li> <p><code>stagewiseRates2</code>: The stage-wise rate in treatment group 2.
</p>
</li>
<li> <p><code>sampleSizesPerStage1</code>: The stage-wise sample size in treatment group 1.
</p>
</li>
<li> <p><code>sampleSizesPerStage2</code>: The stage-wise sample size in treatment group 2.
</p>
</li>
<li> <p><code>trialStop</code>: <code>TRUE</code> if study should be stopped for efficacy or futility or final stage, <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>conditionalPowerAchieved</code>: The conditional power for the subsequent stage of the trial for
selected sample size and effect. The effect is either estimated from the data or can be
user defined with <code>pi1H1</code> and <code>pi2H1</code>.
</p>
</li></ol>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size design (two groups) with total sample 
# size 120, pi1 = (0.3,0.4,0.5,0.6) and pi2 = 0.3
getSimulationRates(pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, 
    plannedSubjects = 120, maxNumberOfIterations = 10)

# Increase number of simulation iterations and compare results with power calculator
getSimulationRates(pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, 
    plannedSubjects = 120, maxNumberOfIterations = 50)
getPowerRates(pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, maxNumberOfSubjects = 120)

# Do the same for a two-stage Pocock inverse normal group sequential 
# design with non-binding futility stops
designIN &lt;- getDesignInverseNormal(typeOfDesign = "P", futilityBounds = c(0))
getSimulationRates(designIN, pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, 
    plannedSubjects = c(40, 80), maxNumberOfIterations = 50)
getPowerRates(designIN, pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, maxNumberOfSubjects = 80)

# Assess power and average sample size if a sample size reassessment is 
# foreseen at conditional power 80% for the subsequent stage (decrease and increase) 
# based on observed overall (cumulative) rates and specified minNumberOfSubjectsPerStage 
# and maxNumberOfSubjectsPerStage

# Do the same under the assumption that a sample size increase only takes place 
# if the rate difference exceeds the value 0.1 at interim. For this, the sample 
# size recalculation method needs to be redefined:  
mySampleSizeCalculationFunction &lt;- function(..., stage,
        plannedSubjects,
        minNumberOfSubjectsPerStage,
        maxNumberOfSubjectsPerStage,
        conditionalPower,
        conditionalCriticalValue,
        overallRate) {
    if (overallRate[1] - overallRate[2] &lt; 0.1) {
        return(plannedSubjects[stage] - plannedSubjects[stage - 1]) 
    } else {
        rateUnderH0 &lt;- (overallRate[1] + overallRate[2]) / 2 
        stageSubjects &lt;- 2 * (max(0, conditionalCriticalValue * 
            sqrt(2 * rateUnderH0 * (1 - rateUnderH0)) + 
            stats::qnorm(conditionalPower) * sqrt(overallRate[1] * 
            (1 - overallRate[1]) + overallRate[2] * (1 - overallRate[2]))))^2 /
            (max(1e-12, (overallRate[1] - overallRate[2])))^2
        stageSubjects &lt;- ceiling(min(max(
            minNumberOfSubjectsPerStage[stage], 
            stageSubjects), maxNumberOfSubjectsPerStage[stage]))
        return(stageSubjects)
    }
}
getSimulationRates(designIN, pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, 
    plannedSubjects = c(40, 80), minNumberOfSubjectsPerStage = c(40, 20), 
    maxNumberOfSubjectsPerStage = c(40, 160), conditionalPower = 0.8, 
    calcSubjectsFunction = mySampleSizeCalculationFunction, maxNumberOfIterations = 50)

## End(Not run)

</code></pre>

<hr>
<h2 id='getSimulationSurvival'>Get Simulation Survival</h2><span id='topic+getSimulationSurvival'></span>

<h3>Description</h3>

<p>Returns the analysis times, power, stopping probabilities, conditional power, and expected sample size
for testing the hazard ratio in a two treatment groups survival design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulationSurvival(
  design = NULL,
  ...,
  thetaH0 = 1,
  directionUpper = NA,
  pi1 = NA_real_,
  pi2 = NA_real_,
  lambda1 = NA_real_,
  lambda2 = NA_real_,
  median1 = NA_real_,
  median2 = NA_real_,
  hazardRatio = NA_real_,
  kappa = 1,
  piecewiseSurvivalTime = NA_real_,
  allocation1 = 1,
  allocation2 = 1,
  eventTime = 12,
  accrualTime = c(0, 12),
  accrualIntensity = 0.1,
  accrualIntensityType = c("auto", "absolute", "relative"),
  dropoutRate1 = 0,
  dropoutRate2 = 0,
  dropoutTime = 12,
  maxNumberOfSubjects = NA_real_,
  plannedEvents = NA_real_,
  minNumberOfEventsPerStage = NA_real_,
  maxNumberOfEventsPerStage = NA_real_,
  conditionalPower = NA_real_,
  thetaH1 = NA_real_,
  maxNumberOfIterations = 1000L,
  maxNumberOfRawDatasetsPerStage = 0,
  longTimeSimulationAllowed = FALSE,
  seed = NA_real_,
  calcEventsFunction = NULL,
  showStatistics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulationSurvival_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed event rate in the treatment group,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed event rate in the control group, default is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_lambda1">lambda1</code></td>
<td>
<p>The assumed hazard rate in the treatment group, there is no default.
<code>lambda1</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_lambda2">lambda2</code></td>
<td>
<p>The assumed hazard rate in the reference group, there is no default.
<code>lambda2</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_median1">median1</code></td>
<td>
<p>The assumed median survival time in the treatment group, there is no default.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_median2">median2</code></td>
<td>
<p>The assumed median survival time in the reference group, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_hazardratio">hazardRatio</code></td>
<td>
<p>The vector of hazard ratios under consideration.
If the event or hazard rates in both treatment groups are defined, the hazard ratio needs
not to be specified as it is calculated, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>A vector that specifies the time intervals for the piecewise
definition of the exponential survival time cumulative distribution function <br />
(for details see <code><a href="#topic+getPiecewiseSurvivalTime">getPiecewiseSurvivalTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_allocation1">allocation1</code></td>
<td>
<p>The number how many subjects are assigned to treatment 1 in a
subsequent order, default is <code>1</code></p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_allocation2">allocation2</code></td>
<td>
<p>The number how many subjects are assigned to treatment 2 in a
subsequent order, default is <code>1</code></p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_eventtime">eventTime</code></td>
<td>
<p>The assumed time under which the event rates are calculated, default is <code>12</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_accrualtime">accrualTime</code></td>
<td>
<p>The assumed accrual time intervals for the study, default is
<code>c(0, 12)</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>A numeric vector of accrual intensities, default is the relative
intensity <code>0.1</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_accrualintensitytype">accrualIntensityType</code></td>
<td>
<p>A character value specifying the accrual intensity input type.
Must be one of <code>"auto"</code>, <code>"absolute"</code>, or <code>"relative"</code>; default is <code>"auto"</code>,
i.e., if all values are &lt; 1 the type is <code>"relative"</code>, otherwise it is <code>"absolute"</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_dropoutrate1">dropoutRate1</code></td>
<td>
<p>The assumed drop-out rate in the treatment group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_dropoutrate2">dropoutRate2</code></td>
<td>
<p>The assumed drop-out rate in the control group, default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_dropouttime">dropoutTime</code></td>
<td>
<p>The assumed time for drop-out rates in the control and the
treatment group, default is <code>12</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified.
If accrual time and accrual intensity are specified, this will be calculated. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_plannedevents">plannedEvents</code></td>
<td>
<p><code>plannedEvents</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) events in survival designs when the interim stages are planned.
For two treatment arms, it is the number of events for both treatment arms.
For multi-arm designs, <code>plannedEvents</code> refers to the overall number of events for the selected arms plus control.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_minnumberofeventsperstage">minNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfEventsPerStage</code> with length kMax determines the
minimum number of events per stage (i.e., not cumulated), the first element
is not taken into account.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_maxnumberofeventsperstage">maxNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfEventsPerStage</code> with length kMax determines the maximum number
of events per stage (i.e., not cumulated), the first element is not taken into account.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_thetah1">thetaH1</code></td>
<td>
<p>If specified, the value of the alternative under which
the conditional power or sample size recalculation calculation is performed. Must be a numeric of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_maxnumberofrawdatasetsperstage">maxNumberOfRawDatasetsPerStage</code></td>
<td>
<p>The number of raw datasets per stage that shall
be extracted and saved as <code><a href="base.html#topic+data.frame">data.frame</a></code>, default is <code>0</code>.
<code><a href="#topic+getRawData">getRawData()</a></code> can be used to get the extracted raw data from the object.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_longtimesimulationallowed">longTimeSimulationAllowed</code></td>
<td>
<p>Logical that indicates whether long time simulations
that consumes more than 30 seconds are allowed or not, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_calceventsfunction">calcEventsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, event number recalculation is performed with conditional power and specified
<code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code> (see details and examples).</p>
</td></tr>
<tr><td><code id="getSimulationSurvival_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At given design the function simulates the power, stopping probabilities, conditional power, and expected
sample size at given number of events, number of subjects, and parameter configuration.
It also simulates the time when the required events are expected under the given
assumptions (exponentially, piecewise exponentially, or Weibull distributed survival times
and constant or non-constant piecewise accrual).
Additionally, integers <code>allocation1</code> and <code>allocation2</code> can be specified that determine the number allocated
to treatment group 1 and treatment group 2, respectively.
More precisely, unequal randomization ratios must be specified via the two integer arguments <code>allocation1</code> and
<code>allocation2</code> which describe how many subjects are consecutively enrolled in each group, respectively, before a
subject is assigned to the other group. For example, the arguments <code>allocation1 = 2</code>, <code>allocation2 = 1</code>,
<code>maxNumberOfSubjects = 300</code> specify 2:1 randomization with 200 subjects randomized to intervention and 100 to
control. (Caveat: Do not use <code>allocation1 = 200</code>, <code>allocation2 = 100</code>, <code>maxNumberOfSubjects = 300</code>
as this would imply that the 200 intervention subjects are enrolled prior to enrollment of any control subjects.)
</p>
<p><code>conditionalPower</code><br />
The definition of <code>thetaH1</code> makes only sense if <code>kMax</code> &gt; 1
and if <code>conditionalPower</code>, <code>minNumberOfEventsPerStage</code>, and
<code>maxNumberOfEventsPerStage</code> are defined.
</p>
<p>Note that <code>numberOfSubjects</code>, <code>numberOfSubjects1</code>, and <code>numberOfSubjects2</code> in the output
are the expected number of subjects.
</p>
<p><code>calcEventsFunction</code><br />
This function returns the number of events at given conditional power and conditional critical value for specified
testing situation. The function might depend on variables
<code>stage</code>,
<code>conditionalPower</code>,
<code>thetaH0</code>,
<code>plannedEvents</code>,
<code>singleEventsPerStage</code>,
<code>minNumberOfEventsPerStage</code>,
<code>maxNumberOfEventsPerStage</code>,
<code>allocationRatioPlanned</code>,
<code>conditionalCriticalValue</code>,
The function has to contain the three-dots argument '...' (see examples).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
The following generics (R generic functions) are available for this object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.SimulationResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>Piecewise survival time</h3>

<p>The first element of the vector <code>piecewiseSurvivalTime</code> must be equal to <code>0</code>.
<code>piecewiseSurvivalTime</code> can also be a list that combines the definition of the
time intervals and hazard rates in the reference group.
The definition of the survival time in the treatment group is obtained by the specification
of the hazard ratio (see examples for details).
</p>


<h3>Staggered patient entry</h3>

<p><code>accrualTime</code> is the time period of subjects' accrual in a study.
It can be a value that defines the end of accrual or a vector.
In this case, <code>accrualTime</code> can be used to define a non-constant accrual over time.
For this, <code>accrualTime</code> is a vector that defines the accrual intervals.
The first element of <code>accrualTime</code> must be equal to <code>0</code> and, additionally,
<code>accrualIntensity</code> needs to be specified.
<code>accrualIntensity</code> itself is a value or a vector (depending on the
length of <code>accrualTime</code>) that defines the intensity how subjects
enter the trial in the intervals defined through <code>accrualTime</code>.
</p>
<p><code>accrualTime</code> can also be a list that combines the definition of the accrual time and
accrual intensity (see below and examples for details).
</p>
<p>If the length of <code>accrualTime</code> and the length of <code>accrualIntensity</code> are the same
(i.e., the end of accrual is undefined), <code>maxNumberOfSubjects &gt; 0</code> needs to be specified
and the end of accrual is calculated.
In that case, <code>accrualIntensity</code> is the number of subjects per time unit, i.e., the absolute accrual intensity.
</p>
<p>If the length of <code>accrualTime</code> equals the length of <code>accrualIntensity - 1</code>
(i.e., the end of accrual is defined), <code>maxNumberOfSubjects</code> is calculated if the absolute accrual intensity is given.
If all elements in <code>accrualIntensity</code> are smaller than 1, <code>accrualIntensity</code> defines
the <em>relative</em> intensity how subjects enter the trial.
For example, <code>accrualIntensity = c(0.1, 0.2)</code> specifies that in the second accrual interval
the intensity is doubled as compared to the first accrual interval. The actual (absolute) accrual intensity
is calculated for the calculated or given <code>maxNumberOfSubjects</code>.
Note that the default is <code>accrualIntensity = 0.1</code> meaning that the <em>absolute</em> accrual intensity
will be calculated.
</p>


<h3>Simulation Data</h3>

<p>The summary statistics &quot;Simulated data&quot; contains the following parameters: median <a href="base.html#topic+range">range</a>; mean +/-sd<br />
</p>
<p><code>$show(showStatistics = FALSE)</code> or <code>$setShowStatistics(FALSE)</code> can be used to disable
the output of the aggregated simulated data.<br />
</p>
<p>Example 1: <br />
<code>simulationResults &lt;- getSimulationSurvival(maxNumberOfSubjects = 100, plannedEvents = 30)</code> <br />
<code>simulationResults$show(showStatistics = FALSE)</code><br />
</p>
<p>Example 2: <br />
<code>simulationResults &lt;- getSimulationSurvival(maxNumberOfSubjects = 100, plannedEvents = 30)</code> <br />
<code>simulationResults$setShowStatistics(FALSE)</code><br />
<code>simulationResults</code><br />
</p>
<p><code><a href="#topic+getData">getData()</a></code> can be used to get the aggregated simulated data from the
object as <code><a href="base.html#topic+data.frame">data.frame</a></code>. The data frame contains the following columns:
</p>

<ol>
<li> <p><code>iterationNumber</code>: The number of the simulation iteration.
</p>
</li>
<li> <p><code>stageNumber</code>: The stage.
</p>
</li>
<li> <p><code>pi1</code>: The assumed or derived event rate in the treatment group.
</p>
</li>
<li> <p><code>pi2</code>: The assumed or derived event rate in the control group.
</p>
</li>
<li> <p><code>hazardRatio</code>: The hazard ratio under consideration (if available).
</p>
</li>
<li> <p><code>analysisTime</code>: The analysis time.
</p>
</li>
<li> <p><code>numberOfSubjects</code>: The number of subjects under consideration when the
(interim) analysis takes place.
</p>
</li>
<li> <p><code>eventsPerStage1</code>: The observed number of events per stage
in treatment group 1.
</p>
</li>
<li> <p><code>eventsPerStage2</code>: The observed number of events per stage
in treatment group 2.
</p>
</li>
<li> <p><code>singleEventsPerStage</code>: The observed number of events per stage
in both treatment groups.
</p>
</li>
<li> <p><code>rejectPerStage</code>: 1 if null hypothesis can be rejected, 0 otherwise.
</p>
</li>
<li> <p><code>futilityPerStage</code>: 1 if study should be stopped for futility, 0 otherwise.
</p>
</li>
<li> <p><code>eventsNotAchieved</code>: 1 if number of events could not be reached with
observed number of subjects, 0 otherwise.
</p>
</li>
<li> <p><code>testStatistic</code>: The test statistic that is used for the test decision,
depends on which design was chosen (group sequential, inverse normal,
or Fisher combination test)'
</p>
</li>
<li> <p><code>logRankStatistic</code>: Z-score statistic which corresponds to a one-sided
log-rank test at considered stage.
</p>
</li>
<li> <p><code>hazardRatioEstimateLR</code>: The estimated hazard ratio, derived from the
log-rank statistic.
</p>
</li>
<li> <p><code>trialStop</code>: <code>TRUE</code> if study should be stopped for efficacy or futility or final stage, <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>conditionalPowerAchieved</code>: The conditional power for the subsequent stage of the trial for
selected sample size and effect. The effect is either estimated from the data or can be
user defined with <code>thetaH1</code>.
</p>
</li></ol>



<h3>Raw Data</h3>

<p><code><a href="#topic+getRawData">getRawData()</a></code> can be used to get the simulated raw data from the
object as <code><a href="base.html#topic+data.frame">data.frame</a></code>. Note that <code>getSimulationSurvival()</code>
must called before with <code>maxNumberOfRawDatasetsPerStage</code> &gt; 0.
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fixed sample size with minimum required definitions, pi1 = (0.3,0.4,0.5,0.6) and
# pi2 = 0.3 at event time 12, and accrual time 24
getSimulationSurvival(
    pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, eventTime = 12,
    accrualTime = 24, plannedEvents = 40, maxNumberOfSubjects = 200,
    maxNumberOfIterations = 10
)

# Increase number of simulation iterations
getSimulationSurvival(
    pi1 = seq(0.3, 0.6, 0.1), pi2 = 0.3, eventTime = 12,
    accrualTime = 24, plannedEvents = 40, maxNumberOfSubjects = 200,
    maxNumberOfIterations = 50
)

# Determine necessary accrual time with default settings if 200 subjects and
# 30 subjects per time unit can be recruited
getSimulationSurvival(
    plannedEvents = 40, accrualTime = 0,
    accrualIntensity = 30, maxNumberOfSubjects = 200, maxNumberOfIterations = 50
)

# Determine necessary accrual time with default settings if 200 subjects and
# if the first 6 time units 20 subjects per time unit can be recruited,
# then 30 subjects per time unit
getSimulationSurvival(
    plannedEvents = 40, accrualTime = c(0, 6),
    accrualIntensity = c(20, 30), maxNumberOfSubjects = 200,
    maxNumberOfIterations = 50
)

# Determine maximum number of Subjects with default settings if the first
# 6 time units 20 subjects per time unit can be recruited, and after
# 10 time units 30 subjects per time unit
getSimulationSurvival(
    plannedEvents = 40, accrualTime = c(0, 6, 10),
    accrualIntensity = c(20, 30), maxNumberOfIterations = 50
)

# Specify accrual time as a list
at &lt;- list(
    "0 - &lt;6"  = 20,
    "6 - Inf" = 30
)
getSimulationSurvival(
    plannedEvents = 40, accrualTime = at,
    maxNumberOfSubjects = 200, maxNumberOfIterations = 50
)

# Specify accrual time as a list, if maximum number of subjects need to be calculated
at &lt;- list(
    "0 - &lt;6"   = 20,
    "6 - &lt;=10" = 30
)
getSimulationSurvival(plannedEvents = 40, accrualTime = at, maxNumberOfIterations = 50)

# Specify effect size for a two-stage group sequential design with
# O'Brien &amp; Fleming boundaries. Effect size is based on event rates
# at specified event time, directionUpper = FALSE needs to be specified
# because it should be shown that hazard ratio &lt; 1
designGS &lt;- getDesignGroupSequential(kMax = 2)
getSimulationSurvival(
    design = designGS,
    pi1 = 0.2, pi2 = 0.3, eventTime = 24, plannedEvents = c(20, 40),
    maxNumberOfSubjects = 200, directionUpper = FALSE, maxNumberOfIterations = 50
)

# As above, but with a three-stage O'Brien and Fleming design with
# specified information rates, note that planned events consists of integer values
designGS2 &lt;- getDesignGroupSequential(informationRates = c(0.4, 0.7, 1))
getSimulationSurvival(
    design = designGS2, 
    pi1 = 0.2, pi2 = 0.3, eventTime = 24,
    plannedEvents = round(designGS2$informationRates * 40),
    maxNumberOfSubjects = 200, directionUpper = FALSE,
    maxNumberOfIterations = 50
)

# Effect size is based on event rate at specified event time for the reference
# group and hazard ratio, directionUpper = FALSE needs to be specified because
# it should be shown that hazard ratio &lt; 1
getSimulationSurvival(
    design = designGS, hazardRatio = 0.5,
    pi2 = 0.3, eventTime = 24, plannedEvents = c(20, 40), maxNumberOfSubjects = 200,
    directionUpper = FALSE, maxNumberOfIterations = 50
)

# Effect size is based on hazard rate for the reference group and
# hazard ratio, directionUpper = FALSE needs to be specified because
# it should be shown that hazard ratio &lt; 1
getSimulationSurvival(
    design = designGS,
    hazardRatio = 0.5, lambda2 = 0.02, plannedEvents = c(20, 40),
    maxNumberOfSubjects = 200, directionUpper = FALSE,
    maxNumberOfIterations = 50
)

# Specification of piecewise exponential survival time and hazard ratios,
# note that in getSimulationSurvival only on hazard ratio is used
# in the case that the survival time is piecewise expoential
getSimulationSurvival(
    design = designGS,
    piecewiseSurvivalTime = c(0, 5, 10), lambda2 = c(0.01, 0.02, 0.04),
    hazardRatio = 1.5, plannedEvents = c(20, 40), maxNumberOfSubjects = 200,
    maxNumberOfIterations = 50
)

pws &lt;- list(
    "0 - &lt;5"  = 0.01,
    "5 - &lt;10" = 0.02,
    "&gt;=10"    = 0.04
)
getSimulationSurvival(
    design = designGS,
    piecewiseSurvivalTime = pws, hazardRatio = c(1.5),
    plannedEvents = c(20, 40), maxNumberOfSubjects = 200,
    maxNumberOfIterations = 50
)

# Specification of piecewise exponential survival time for both treatment arms
getSimulationSurvival(
    design = designGS,
    piecewiseSurvivalTime = c(0, 5, 10), lambda2 = c(0.01, 0.02, 0.04),
    lambda1 = c(0.015, 0.03, 0.06), plannedEvents = c(20, 40),
    maxNumberOfSubjects = 200, maxNumberOfIterations = 50
)

# Specification of piecewise exponential survival time as a list,
# note that in getSimulationSurvival only on hazard ratio
# (not a vector) can be used
pws &lt;- list(
    "0 - &lt;5"  = 0.01,
    "5 - &lt;10" = 0.02,
    "&gt;=10"    = 0.04
)
getSimulationSurvival(
    design = designGS,
    piecewiseSurvivalTime = pws, hazardRatio = 1.5,
    plannedEvents = c(20, 40), maxNumberOfSubjects = 200,
    maxNumberOfIterations = 50
)

# Specification of piecewise exponential survival time and delayed effect
# (response after 5 time units)
getSimulationSurvival(
    design = designGS,
    piecewiseSurvivalTime = c(0, 5, 10), lambda2 = c(0.01, 0.02, 0.04),
    lambda1 = c(0.01, 0.02, 0.06), plannedEvents = c(20, 40),
    maxNumberOfSubjects = 200, maxNumberOfIterations = 50
)

# Specify effect size based on median survival times
getSimulationSurvival(
    median1 = 5, median2 = 3, plannedEvents = 40,
    maxNumberOfSubjects = 200, directionUpper = FALSE,
    maxNumberOfIterations = 50
)

# Specify effect size based on median survival
# times of Weibull distribtion with kappa = 2
getSimulationSurvival(
    median1 = 5, median2 = 3, kappa = 2,
    plannedEvents = 40, maxNumberOfSubjects = 200,
    directionUpper = FALSE, maxNumberOfIterations = 50
)

# Perform recalculation of number of events based on conditional power for a
# three-stage design with inverse normal combination test, where the conditional power
# is calculated under the specified effect size thetaH1 = 1.3 and up to a four-fold
# increase in originally planned sample size (number of events) is allowed.
# Note that the first value in minNumberOfEventsPerStage and
# maxNumberOfEventsPerStage is arbitrary, i.e., it has no effect.
designIN &lt;- getDesignInverseNormal(informationRates = c(0.4, 0.7, 1))

resultsWithSSR1 &lt;- getSimulationSurvival(
    design = designIN,
    hazardRatio = seq(1, 1.6, 0.1),
    pi2 = 0.3, conditionalPower = 0.8, thetaH1 = 1.3,
    plannedEvents = c(58, 102, 146),
    minNumberOfEventsPerStage = c(NA, 44, 44),
    maxNumberOfEventsPerStage = 4 * c(NA, 44, 44),
    maxNumberOfSubjects = 800, maxNumberOfIterations = 50
)
resultsWithSSR1

# If thetaH1 is unspecified, the observed hazard ratio estimate
# (calculated from the log-rank statistic) is used for performing the
# recalculation of the number of events
resultsWithSSR2 &lt;- getSimulationSurvival(
    design = designIN,
    hazardRatio = seq(1, 1.6, 0.1),
    pi2 = 0.3, conditionalPower = 0.8, plannedEvents = c(58, 102, 146),
    minNumberOfEventsPerStage = c(NA, 44, 44),
    maxNumberOfEventsPerStage = 4 * c(NA, 44, 44),
    maxNumberOfSubjects = 800, maxNumberOfIterations = 50
)
resultsWithSSR2

# Compare it with design without event size recalculation
resultsWithoutSSR &lt;- getSimulationSurvival(
    design = designIN,
    hazardRatio = seq(1, 1.6, 0.1), pi2 = 0.3,
    plannedEvents = c(58, 102, 145), maxNumberOfSubjects = 800,
    maxNumberOfIterations = 50
)
resultsWithoutSSR$overallReject
resultsWithSSR1$overallReject
resultsWithSSR2$overallReject

# Confirm that event size racalcuation increases the Type I error rate,
# i.e., you have to use the combination test
resultsWithSSRGS &lt;- getSimulationSurvival(
    design = designGS2, 
    hazardRatio = seq(1),
    pi2 = 0.3, conditionalPower = 0.8, plannedEvents = c(58, 102, 145),
    minNumberOfEventsPerStage = c(NA, 44, 44),
    maxNumberOfEventsPerStage = 4 * c(NA, 44, 44),
    maxNumberOfSubjects = 800, maxNumberOfIterations = 50
)
resultsWithSSRGS$overallReject

# Set seed to get reproducable results
identical(
    getSimulationSurvival(
        plannedEvents = 40, maxNumberOfSubjects = 200,
        seed = 99
    )$analysisTime,
    getSimulationSurvival(
        plannedEvents = 40, maxNumberOfSubjects = 200,
        seed = 99
    )$analysisTime
)

# Perform recalculation of number of events based on conditional power as above.
# The number of events is recalculated only in the first interim, the recalculated number
# is also used for the final stage. Here, we use the user defind calcEventsFunction as
# follows (note that the last stage value in minNumberOfEventsPerStage and maxNumberOfEventsPerStage
# has no effect):
myCalcEventsFunction &lt;- function(...,
        stage, conditionalPower, estimatedTheta,
        plannedEvents, eventsOverStages,
        minNumberOfEventsPerStage, maxNumberOfEventsPerStage,
        conditionalCriticalValue) {
    theta &lt;- max(1 + 1e-12, estimatedTheta)
    if (stage == 2) {
        requiredStageEvents &lt;-
            max(0, conditionalCriticalValue + qnorm(conditionalPower))^2 * 4 / log(theta)^2
        requiredOverallStageEvents &lt;- min(
            max(minNumberOfEventsPerStage[stage], requiredStageEvents),
            maxNumberOfEventsPerStage[stage]
        ) + eventsOverStages[stage - 1]
    } else {
        requiredOverallStageEvents &lt;- 2 * eventsOverStages[stage - 1] - eventsOverStages[1]
    }
    return(requiredOverallStageEvents)
}
resultsWithSSR &lt;- getSimulationSurvival(
    design = designIN,
    hazardRatio = seq(1, 2.6, 0.5),
    pi2 = 0.3,
    conditionalPower = 0.8,
    plannedEvents = c(58, 102, 146),
    minNumberOfEventsPerStage = c(NA, 44, 4),
    maxNumberOfEventsPerStage = 4 * c(NA, 44, 4),
    maxNumberOfSubjects = 800,
    calcEventsFunction = myCalcEventsFunction,
    seed = 1234,
    maxNumberOfIterations = 50
)

## End(Not run)

</code></pre>

<hr>
<h2 id='getStageResults'>Get Stage Results</h2><span id='topic+getStageResults'></span>

<h3>Description</h3>

<p>Returns summary statistics and p-values for a given data set and a given design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStageResults(
  design,
  dataInput,
  ...,
  stage = NA_integer_,
  directionUpper = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getStageResults_+3A_design">design</code></td>
<td>
<p>The trial design.</p>
</td></tr>
<tr><td><code id="getStageResults_+3A_datainput">dataInput</code></td>
<td>
<p>The summary data used for calculating the test results.
This is either an element of <code>DatasetMeans</code>, of <code>DatasetRates</code>, or of <code>DatasetSurvival</code>
and should be created with the function <code><a href="#topic+getDataset">getDataset()</a></code>.
For more information see <code><a href="#topic+getDataset">getDataset()</a></code>.</p>
</td></tr>
<tr><td><code id="getStageResults_+3A_...">...</code></td>
<td>
<p>Further (optional) arguments to be passed:
</p>

<dl>
<dt><code>thetaH0</code></dt><dd><p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0:
<code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>The
type of computation of the p-values. Default is <code>FALSE</code> for
testing means (i.e., the t test is used) and <code>TRUE</code> for testing rates and the hazard ratio.
For testing rates, if <code>normalApproximation = FALSE</code> is specified, the binomial test
(one sample) or the exact test of Fisher (two samples) is used for calculating the p-values.
In the survival setting, <code>normalApproximation = FALSE</code> has no effect.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>The type of t test. For testing means in two treatment groups, either
the t test assuming that the variances are equal or the t test without assuming this,
i.e., the test of Welch-Satterthwaite is calculated, default is <code>TRUE</code>.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses when testing multiple hypotheses.
Five options are available in multi-arm designs: <code>"Dunnett"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
<code>"Sidak"</code>, and <code>"Hierarchical"</code>, default is <code>"Dunnett"</code>.
Four options are available in population enrichment designs: <code>"SpiessensDebois"</code> (one subset only),
<code>"Bonferroni"</code>, <code>"Simes"</code>, and <code>"Sidak"</code>, default is <code>"Simes"</code>.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple treatment arms (&gt; 2)
or population enrichment designs for testing means. For multiple arms, three options are available:
<code>"overallPooled"</code>, <code>"pairwisePooled"</code>, and <code>"notPooled"</code>, default is <code>"overallPooled"</code>.
For enrichment designs, the options are: <code>"pooled"</code>, <code>"pooledFromFull"</code> (one subset only),
and <code>"notPooled"</code>, default is <code>"pooled"</code>.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen.
For testing means and rates, also a non-stratified analysis based on overall data can be performed.
For survival data, only a stratified analysis is possible (see Brannath et al., 2009), default is <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getStageResults_+3A_stage">stage</code></td>
<td>
<p>The stage number (optional). Default: total number of existing stages in the data input.</p>
</td></tr>
<tr><td><code id="getStageResults_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates and returns the stage results of the specified design and data input at the specified stage.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+StageResults">StageResults</a></code> object.
</p>

<ul>
<li> <p><code><a href="#topic+names.StageResults">names</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.StageResults">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.StageResults">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>


<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getTestActions">getTestActions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal()
dataRates &lt;- getDataset(
    n1      = c(10, 10),
    n2      = c(20, 20),
    events1 = c( 8, 10),
    events2 = c(10, 16))
getStageResults(design, dataRates)

## End(Not run)

</code></pre>

<hr>
<h2 id='getTestActions'>Get Test Actions</h2><span id='topic+getTestActions'></span>

<h3>Description</h3>

<p>Returns test actions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTestActions(stageResults, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTestActions_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
<tr><td><code id="getTestActions_+3A_...">...</code></td>
<td>
<p>Only available for backward compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the test actions of the specified design and
stage results at the specified stage.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> vector of length <code>kMax</code>
Returns a <code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code>kMax</code>
containing the test actions of each stage.
</p>


<h3>See Also</h3>

<p>Other analysis functions: 
<code><a href="#topic+getAnalysisResults">getAnalysisResults</a>()</code>,
<code><a href="#topic+getClosedCombinationTestResults">getClosedCombinationTestResults</a>()</code>,
<code><a href="#topic+getClosedConditionalDunnettTestResults">getClosedConditionalDunnettTestResults</a>()</code>,
<code><a href="#topic+getConditionalPower">getConditionalPower</a>()</code>,
<code><a href="#topic+getConditionalRejectionProbabilities">getConditionalRejectionProbabilities</a>()</code>,
<code><a href="#topic+getFinalConfidenceInterval">getFinalConfidenceInterval</a>()</code>,
<code><a href="#topic+getFinalPValue">getFinalPValue</a>()</code>,
<code><a href="#topic+getRepeatedConfidenceIntervals">getRepeatedConfidenceIntervals</a>()</code>,
<code><a href="#topic+getRepeatedPValues">getRepeatedPValues</a>()</code>,
<code><a href="#topic+getStageResults">getStageResults</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(kMax = 2)
data &lt;- getDataset(
    n      = c( 20,  30),
    means  = c( 50,  51),
    stDevs = c(130, 140)
)
getTestActions(getStageResults(design, dataInput = data))

## End(Not run)

</code></pre>

<hr>
<h2 id='getWideFormat'>Get Wide Format</h2><span id='topic+getWideFormat'></span>

<h3>Description</h3>

<p>Returns the specified dataset as a <code><a href="base.html#topic+data.frame">data.frame</a></code> in so-called wide format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWideFormat(dataInput)
</code></pre>


<h3>Details</h3>

<p>In the wide format (unstacked), the data are presented with each different data variable in a separate column, i.e.,
the different groups are in separate columns.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLongFormat">getLongFormat()</a></code> for returning the dataset as a <code><a href="base.html#topic+data.frame">data.frame</a></code> in long format.
</p>

<hr>
<h2 id='kableParameterSet'>Create output in Markdown</h2><span id='topic+kableParameterSet'></span><span id='topic+kable.ParameterSet'></span><span id='topic+kable.FieldSet'></span><span id='topic+kable.data.frame'></span><span id='topic+kable.table'></span><span id='topic+kable.matrix'></span><span id='topic+kable.array'></span><span id='topic+kable.numeric'></span><span id='topic+kable.character'></span><span id='topic+kable.logical'></span><span id='topic+kable'></span>

<h3>Description</h3>

<p>The <code>kable()</code> function returns the output of the specified object formatted in Markdown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ParameterSet'
kable(x, ...)

## S3 method for class 'FieldSet'
kable(x, ..., enforceRowNames = TRUE, niceColumnNamesEnabled = TRUE)

## S3 method for class 'data.frame'
kable(x, ...)

## S3 method for class 'table'
kable(x, ...)

## S3 method for class 'matrix'
kable(x, ...)

## S3 method for class 'array'
kable(x, ...)

## S3 method for class 'numeric'
kable(x, ...)

## S3 method for class 'character'
kable(x, ...)

## S3 method for class 'logical'
kable(x, ...)

kable(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kableParameterSet_+3A_x">x</code></td>
<td>
<p>A <code>ParameterSet</code>. If x does not inherit from class <code><a href="#topic+ParameterSet">ParameterSet</a></code>,
<code>knitr::kable(x)</code> will be returned.</p>
</td></tr>
<tr><td><code id="kableParameterSet_+3A_...">...</code></td>
<td>
<p>Other arguments (see <code><a href="knitr.html#topic+kable">kable</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is deprecated and should no longer be used.
Manual use of kable() for rpact result objects is no longer needed,
as the formatting and display will be handled automatically by the rpact package.
Please remove any manual kable() calls from your code to avoid redundancy and potential issues.
The results will be displayed in a consistent format automatically.
</p>

<hr>
<h2 id='knit_print.FieldSet'>Print Field Set in Markdown Code Chunks</h2><span id='topic+knit_print.FieldSet'></span>

<h3>Description</h3>

<p>The function <code>knit_print.FieldSet</code> is the default printing function for rpact result objects in knitr.
The chunk option <code>render</code> uses this function by default.
To fall back to the normal printing behavior set the chunk option <code>render = normal_print</code>.
For more information see <code><a href="knitr.html#topic+knit_print">knit_print</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FieldSet'
knit_print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knit_print.FieldSet_+3A_x">x</code></td>
<td>
<p>A <code>FieldSet</code>.</p>
</td></tr>
<tr><td><code id="knit_print.FieldSet_+3A_...">...</code></td>
<td>
<p>Other arguments (see <code><a href="knitr.html#topic+knit_print">knit_print</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to print a field set in Markdown.
</p>


<h3>Markdown options</h3>

<p>Use <code>options("rpact.print.heading.base.number" = NUMBER)</code>
(where <code>NUMBER</code> is an integer value &gt;= -2) to
specify the heading level.
</p>
<p>NUMBER = 1 results in the heading prefix <code>#</code>, NUMBER = 2 results in <code>##</code>, ...
</p>
<p>The default is
<code>options("rpact.print.heading.base.number" = -2)</code>, i.e., the
top headings will be written italic but are not
explicit defined as header.
<code>options("rpact.print.heading.base.number" = -1)</code> means
that all headings will be written bold but are not
explicit defined as header.
</p>
<p>Furthermore the following options can be set globally:
</p>

<ul>
<li> <p><code>rpact.auto.markdown.all</code>: if <code>TRUE</code>, all output types will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.print</code>: if <code>TRUE</code>, all print outputs will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.summary</code>: if <code>TRUE</code>, all summary outputs will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.plot</code>: if <code>TRUE</code>, all plot outputs will be rendered in Markdown format automatically.
</p>
</li></ul>

<p>Example: <code>options("rpact.auto.markdown.plot" = FALSE)</code> disables the automatic knitting of plots inside Markdown documents.
</p>

<hr>
<h2 id='knit_print.ParameterSet'>Print Parameter Set in Markdown Code Chunks</h2><span id='topic+knit_print.ParameterSet'></span>

<h3>Description</h3>

<p>The function <code>knit_print.ParameterSet</code> is the default printing function for rpact result objects in knitr.
The chunk option <code>render</code> uses this function by default.
To fall back to the normal printing behavior set the chunk option <code>render = normal_print</code>.
For more information see <code><a href="knitr.html#topic+knit_print">knit_print</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ParameterSet'
knit_print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knit_print.ParameterSet_+3A_x">x</code></td>
<td>
<p>A <code>ParameterSet</code>.</p>
</td></tr>
<tr><td><code id="knit_print.ParameterSet_+3A_...">...</code></td>
<td>
<p>Other arguments (see <code><a href="knitr.html#topic+knit_print">knit_print</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to print a parameter set in Markdown.
</p>


<h3>Markdown options</h3>

<p>Use <code>options("rpact.print.heading.base.number" = NUMBER)</code>
(where <code>NUMBER</code> is an integer value &gt;= -2) to
specify the heading level.
</p>
<p>NUMBER = 1 results in the heading prefix <code>#</code>, NUMBER = 2 results in <code>##</code>, ...
</p>
<p>The default is
<code>options("rpact.print.heading.base.number" = -2)</code>, i.e., the
top headings will be written italic but are not
explicit defined as header.
<code>options("rpact.print.heading.base.number" = -1)</code> means
that all headings will be written bold but are not
explicit defined as header.
</p>
<p>Furthermore the following options can be set globally:
</p>

<ul>
<li> <p><code>rpact.auto.markdown.all</code>: if <code>TRUE</code>, all output types will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.print</code>: if <code>TRUE</code>, all print outputs will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.summary</code>: if <code>TRUE</code>, all summary outputs will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.plot</code>: if <code>TRUE</code>, all plot outputs will be rendered in Markdown format automatically.
</p>
</li></ul>

<p>Example: <code>options("rpact.auto.markdown.plot" = FALSE)</code> disables the automatic knitting of plots inside Markdown documents.
</p>

<hr>
<h2 id='knit_print.SummaryFactory'>Print Summary Factory in Markdown Code Chunks</h2><span id='topic+knit_print.SummaryFactory'></span>

<h3>Description</h3>

<p>The function <code>knit_print.SummaryFactory</code> is the default
printing function for rpact summary objects in knitr.
The chunk option <code>render</code> uses this function by default.
To fall back to the normal printing behavior set the
chunk option <code>render = normal_print</code>.
For more information see <code><a href="knitr.html#topic+knit_print">knit_print</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SummaryFactory'
knit_print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knit_print.SummaryFactory_+3A_x">x</code></td>
<td>
<p>A <code>SummaryFactory</code>.</p>
</td></tr>
<tr><td><code id="knit_print.SummaryFactory_+3A_...">...</code></td>
<td>
<p>Other arguments (see <code><a href="knitr.html#topic+knit_print">knit_print</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to print a summary object in Markdown.
</p>


<h3>Markdown options</h3>

<p>Use <code>options("rpact.print.heading.base.number" = NUMBER)</code>
(where <code>NUMBER</code> is an integer value &gt;= -2) to
specify the heading level.
</p>
<p>NUMBER = 1 results in the heading prefix <code>#</code>, NUMBER = 2 results in <code>##</code>, ...
</p>
<p>The default is
<code>options("rpact.print.heading.base.number" = -2)</code>, i.e., the
top headings will be written italic but are not
explicit defined as header.
<code>options("rpact.print.heading.base.number" = -1)</code> means
that all headings will be written bold but are not
explicit defined as header.
</p>
<p>Furthermore the following options can be set globally:
</p>

<ul>
<li> <p><code>rpact.auto.markdown.all</code>: if <code>TRUE</code>, all output types will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.print</code>: if <code>TRUE</code>, all print outputs will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.summary</code>: if <code>TRUE</code>, all summary outputs will be rendered in Markdown format automatically.
</p>
</li>
<li> <p><code>rpact.auto.markdown.plot</code>: if <code>TRUE</code>, all plot outputs will be rendered in Markdown format automatically.
</p>
</li></ul>

<p>Example: <code>options("rpact.auto.markdown.plot" = FALSE)</code> disables the automatic knitting of plots inside Markdown documents.
</p>

<hr>
<h2 id='length.TrialDesignSet'>Length of Trial Design Set</h2><span id='topic+length.TrialDesignSet'></span>

<h3>Description</h3>

<p>Returns the number of designs in a <code>TrialDesignSet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignSet'
length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="length.TrialDesignSet_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TrialDesignSet">TrialDesignSet</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is helpful for iteration over all designs in a design set.
</p>


<h3>Value</h3>

<p>Returns a non-negative <code><a href="base.html#topic+integer">integer</a></code> of length 1
representing the number of design in the <code>TrialDesignSet</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
designSet &lt;- getDesignSet(design = getDesignGroupSequential(), alpha = c(0.01, 0.05))
length(designSet)

## End(Not run)

</code></pre>

<hr>
<h2 id='mvnprd'>Original Algorithm AS 251: Normal Distribution</h2><span id='topic+mvnprd'></span>

<h3>Description</h3>

<p>Calculates the Multivariate Normal Distribution with Product Correlation Structure published
by Charles Dunnett, Algorithm AS 251.1 Appl.Statist. (1989), Vol.38, No.3, <a href="https://doi.org/10.2307/2347754">doi:10.2307/2347754</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnprd(..., A, B, BPD, EPS = 1e-06, INF, IERC = 1, HINC = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvnprd_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="mvnprd_+3A_a">A</code></td>
<td>
<p>Upper limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="mvnprd_+3A_b">B</code></td>
<td>
<p>Lower limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="mvnprd_+3A_bpd">BPD</code></td>
<td>
<p>Values defining correlation structure. Array of N dimensions</p>
</td></tr>
<tr><td><code id="mvnprd_+3A_eps">EPS</code></td>
<td>
<p>desired accuracy.  Defaults to 1e-06</p>
</td></tr>
<tr><td><code id="mvnprd_+3A_inf">INF</code></td>
<td>
<p>Determines where integration is done to infinity. Array of N dimensions.
Valid values for INF(I):
0 = c(B(I), Inf),
1 = c(-Inf, A(I)),
2 = c(B(I), A(I))</p>
</td></tr>
<tr><td><code id="mvnprd_+3A_ierc">IERC</code></td>
<td>
<p>error control. If set to 1, strict error control based on
fourth derivative is used.  If set to zero, error control based on halving intervals is used</p>
</td></tr>
<tr><td><code id="mvnprd_+3A_hinc">HINC</code></td>
<td>
<p>Interval width for Simpson's rule. Value of zero caused a default .24 to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for the original Fortran 77 code.
For a multivariate normal vector with correlation structure
defined by RHO(I,J) = BPD(I) * BPD(J), computes the probability
that the vector falls in a rectangle in n-space with error
less than eps.
</p>

<hr>
<h2 id='mvstud'>Original Algorithm AS 251: Student T Distribution</h2><span id='topic+mvstud'></span>

<h3>Description</h3>

<p>Calculates the Multivariate Normal Distribution with Product Correlation Structure published
by Charles Dunnett, Algorithm AS 251.1 Appl.Statist. (1989), Vol.38, No.3, <a href="https://doi.org/10.2307/2347754">doi:10.2307/2347754</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvstud(..., NDF, A, B, BPD, D, EPS = 1e-06, INF, IERC = 1, HINC = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvstud_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="mvstud_+3A_ndf">NDF</code></td>
<td>
<p>Degrees of Freedom. Use 0 for infinite D.F.</p>
</td></tr>
<tr><td><code id="mvstud_+3A_a">A</code></td>
<td>
<p>Upper limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="mvstud_+3A_b">B</code></td>
<td>
<p>Lower limits of integration. Array of N dimensions</p>
</td></tr>
<tr><td><code id="mvstud_+3A_bpd">BPD</code></td>
<td>
<p>Values defining correlation structure. Array of N dimensions</p>
</td></tr>
<tr><td><code id="mvstud_+3A_d">D</code></td>
<td>
<p>Non-Centrality Vector</p>
</td></tr>
<tr><td><code id="mvstud_+3A_eps">EPS</code></td>
<td>
<p>desired accuracy.  Defaults to 1e-06</p>
</td></tr>
<tr><td><code id="mvstud_+3A_inf">INF</code></td>
<td>
<p>Determines where integration is done to infinity. Array of N dimensions.
Valid values for INF(I):
0 = c(B(I), Inf),
1 = c(-Inf, A(I)),
2 = c(B(I), A(I))</p>
</td></tr>
<tr><td><code id="mvstud_+3A_ierc">IERC</code></td>
<td>
<p>error control. If set to 1, strict error control based on
fourth derivative is used.  If set to zero, error control based on halving intervals is used</p>
</td></tr>
<tr><td><code id="mvstud_+3A_hinc">HINC</code></td>
<td>
<p>Interval width for Simpson's rule. Value of zero caused a default .24 to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for the original Fortran 77 code.
For a multivariate normal vector with correlation structure
defined by RHO(I,J) = BPD(I) * BPD(J), computes the probability
that the vector falls in a rectangle in n-space with error
less than eps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N &lt;- 3
RHO &lt;- 0.5
B &lt;- rep(-5.0, length = N)
A &lt;- rep(5.0, length = N)
INF &lt;- rep(2, length = N)
BPD &lt;- rep(sqrt(RHO), length = N)
D &lt;- rep(0.0, length = N)
result &lt;- mvstud(NDF = 0, A = A, B = B, BPD = BPD, INF = INF, D = D)
result

## End(Not run)

</code></pre>

<hr>
<h2 id='names.AnalysisResults'>Names of a Analysis Results Object</h2><span id='topic+names.AnalysisResults'></span>

<h3>Description</h3>

<p>Function to get the names of an <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnalysisResults'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.AnalysisResults_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object created by <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the names of an analysis results that can be accessed by the user.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> vector containing the names of the <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
</p>

<hr>
<h2 id='names.FieldSet'>Names of a Field Set Object</h2><span id='topic+names.FieldSet'></span>

<h3>Description</h3>

<p>Function to get the names of a <code><a href="#topic+FieldSet">FieldSet</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FieldSet'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.FieldSet_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+FieldSet">FieldSet</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the names of a field set that can be accessed by the user.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> vector containing the names of the <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
</p>

<hr>
<h2 id='names.SimulationResults'>Names of a Simulation Results Object</h2><span id='topic+names.SimulationResults'></span>

<h3>Description</h3>

<p>Function to get the names of a <code><a href="#topic+SimulationResults">SimulationResults</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimulationResults'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.SimulationResults_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+SimulationResults">SimulationResults</a></code> object created by
<code>getSimulationResults[MultiArm/Enrichment][Means/Rates/Survival]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the names of a simulation results that can be accessed by the user.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> vector containing the names of the <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
</p>

<hr>
<h2 id='names.StageResults'>Names of a Stage Results Object</h2><span id='topic+names.StageResults'></span>

<h3>Description</h3>

<p>Function to get the names of a <code><a href="#topic+StageResults">StageResults</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StageResults'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.StageResults_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+StageResults">StageResults</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the names of stage results that can be accessed by the user.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> vector containing the names of the <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
</p>

<hr>
<h2 id='names.TrialDesignSet'>Names of a Trial Design Set Object</h2><span id='topic+names.TrialDesignSet'></span>

<h3>Description</h3>

<p>Function to get the names of a <code><a href="#topic+TrialDesignSet">TrialDesignSet</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignSet'
names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.TrialDesignSet_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+TrialDesignSet">TrialDesignSet</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the names of a design set that can be accessed by the user.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> vector containing the names of the <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
designSet &lt;- getDesignSet(design = getDesignGroupSequential(), alpha = c(0.01, 0.05))
names(designSet)

## End(Not run)

</code></pre>

<hr>
<h2 id='NumberOfSubjects'>Number Of Subjects</h2><span id='topic+NumberOfSubjects'></span>

<h3>Description</h3>

<p>Class for the definition of number of subjects results.
</p>


<h3>Details</h3>

<p><code>NumberOfSubjects</code> is a class for the definition of number of subjects results.
</p>


<h3>Fields</h3>


<dl>
<dt><code>time</code></dt><dd><p>The time values. Is a numeric vector.</p>
</dd>
<dt><code>accrualTime</code></dt><dd><p>The assumed accrual time intervals for the study. Is a numeric vector.</p>
</dd>
<dt><code>accrualIntensity</code></dt><dd><p>The absolute accrual intensities. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>numberOfSubjects</code></dt><dd><p>In simulation results data set: The number of subjects under consideration when the interim analysis takes place.</p>
</dd>
</dl>

<hr>
<h2 id='obtain'>Extract a single parameter</h2><span id='topic+obtain'></span><span id='topic+obtain.ParameterSet'></span><span id='topic+fetch'></span><span id='topic+fetch.ParameterSet'></span>

<h3>Description</h3>

<p>Fetch a parameter from a parameter set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain(x, ..., output)

## S3 method for class 'ParameterSet'
obtain(x, ..., output = c("named", "labeled", "value", "list"))

fetch(x, ..., output)

## S3 method for class 'ParameterSet'
fetch(x, ..., output = c("named", "labeled", "value", "list"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obtain_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+ParameterSet">ParameterSet</a></code> object to fetch from.</p>
</td></tr>
<tr><td><code id="obtain_+3A_...">...</code></td>
<td>
<p>One or more variables specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
The default returns the last parameter.
This argument is taken by expression and supports quasiquotation (you can unquote column names and column locations).
</p>
</li></ul>
</td></tr>
<tr><td><code id="obtain_+3A_output">output</code></td>
<td>
<p>A character defining the output type as follows:
</p>

<ul>
<li><p> &quot;named&quot; (default) returns the named value if the value is a single value, the value inside a named list otherwise
</p>
</li>
<li><p> &quot;value&quot; returns only the value itself
</p>
</li>
<li><p> &quot;list&quot; returns the value inside a named list
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getDesignInverseNormal() |&gt; fetch(kMax)
getDesignInverseNormal() |&gt; fetch(kMax, output = "list")

## End(Not run)

</code></pre>

<hr>
<h2 id='param_accrualIntensity'>Parameter Description: Accrual Intensity</h2><span id='topic+param_accrualIntensity'></span>

<h3>Description</h3>

<p>Parameter Description: Accrual Intensity
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_accrualIntensity_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>A numeric vector of accrual intensities, default is the relative
intensity <code>0.1</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
</table>

<hr>
<h2 id='param_accrualIntensity_counts'>Parameter Description: accrualIntensity for Counts</h2><span id='topic+param_accrualIntensity_counts'></span>

<h3>Description</h3>

<p>Parameter Description: accrualIntensity for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_accrualIntensity_counts_+3A_accrualintensity">accrualIntensity</code></td>
<td>
<p>If specified, the assumed accrual intensities for the study, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_accrualIntensityType'>Parameter Description: Accrual Intensity Type</h2><span id='topic+param_accrualIntensityType'></span>

<h3>Description</h3>

<p>Parameter Description: Accrual Intensity Type
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_accrualIntensityType_+3A_accrualintensitytype">accrualIntensityType</code></td>
<td>
<p>A character value specifying the accrual intensity input type.
Must be one of <code>"auto"</code>, <code>"absolute"</code>, or <code>"relative"</code>; default is <code>"auto"</code>,
i.e., if all values are &lt; 1 the type is <code>"relative"</code>, otherwise it is <code>"absolute"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_accrualTime'>Parameter Description: Accrual Time</h2><span id='topic+param_accrualTime'></span>

<h3>Description</h3>

<p>Parameter Description: Accrual Time
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_accrualTime_+3A_accrualtime">accrualTime</code></td>
<td>
<p>The assumed accrual time intervals for the study, default is
<code>c(0, 12)</code> (for details see <code><a href="#topic+getAccrualTime">getAccrualTime()</a></code>).</p>
</td></tr>
</table>

<hr>
<h2 id='param_accrualTime_counts'>Parameter Description: accrualTime for Counts</h2><span id='topic+param_accrualTime_counts'></span>

<h3>Description</h3>

<p>Parameter Description: accrualTime for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_accrualTime_counts_+3A_accrualtime">accrualTime</code></td>
<td>
<p>If specified, the assumed accrual time interval(s) for the study, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_activeArms'>Parameter Description: Active Arms</h2><span id='topic+param_activeArms'></span>

<h3>Description</h3>

<p>Parameter Description: Active Arms
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_activeArms_+3A_activearms">activeArms</code></td>
<td>
<p>The number of active treatment arms to be compared with control, default is <code>3</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_adaptations'>Parameter Description: Adaptations</h2><span id='topic+param_adaptations'></span>

<h3>Description</h3>

<p>Parameter Description: Adaptations
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_adaptations_+3A_adaptations">adaptations</code></td>
<td>
<p>A logical vector of length <code>kMax - 1</code> indicating whether or not an adaptation takes
place at interim k, default is <code>rep(TRUE, kMax - 1)</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_allocationRatioPlanned'>Parameter Description: Allocation Ratio Planned</h2><span id='topic+param_allocationRatioPlanned'></span>

<h3>Description</h3>

<p>Parameter Description: Allocation Ratio Planned
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_allocationRatioPlanned_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
</table>

<hr>
<h2 id='param_allocationRatioPlanned_sampleSize'>Parameter Description: Allocation Ratio Planned With Optimum Option</h2><span id='topic+param_allocationRatioPlanned_sampleSize'></span>

<h3>Description</h3>

<p>Parameter Description: Allocation Ratio Planned With Optimum Option
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_allocationRatioPlanned_sampleSize_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. If <code>allocationRatioPlanned = 0</code> is entered,
the optimal allocation ratio yielding the smallest overall sample size is determined.</p>
</td></tr>
</table>

<hr>
<h2 id='param_alpha'>Parameter Description: Alpha</h2><span id='topic+param_alpha'></span>

<h3>Description</h3>

<p>Parameter Description: Alpha
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_alpha_+3A_alpha">alpha</code></td>
<td>
<p>The significance level alpha, default is <code>0.025</code>. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_alternative'>Parameter Description: Alternative</h2><span id='topic+param_alternative'></span>

<h3>Description</h3>

<p>Parameter Description: Alternative
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_alternative_+3A_alternative">alternative</code></td>
<td>
<p>The alternative hypothesis value for testing means. This can be a vector of assumed
alternatives, default is <code>seq(0, 1, 0.2)</code> (power calculations) or <code>seq(0.2, 1, 0.2)</code> (sample size calculations).</p>
</td></tr>
</table>

<hr>
<h2 id='param_alternative_simulation'>Parameter Description: Alternative for Simulation</h2><span id='topic+param_alternative_simulation'></span>

<h3>Description</h3>

<p>Parameter Description: Alternative for Simulation
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_alternative_simulation_+3A_alternative">alternative</code></td>
<td>
<p>The alternative hypothesis value for testing means under which the data is simulated.
This can be a vector of assumed alternatives, default is <code>seq(0, 1, 0.2)</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_beta'>Parameter Description: Beta</h2><span id='topic+param_beta'></span>

<h3>Description</h3>

<p>Parameter Description: Beta
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_beta_+3A_beta">beta</code></td>
<td>
<p>Type II error rate, necessary for providing sample size calculations
(e.g., <code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans()</a></code>), beta spending function designs,
or optimum designs, default is <code>0.20</code>. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_bindingFutility'>Parameter Description: Binding Futility</h2><span id='topic+param_bindingFutility'></span>

<h3>Description</h3>

<p>Parameter Description: Binding Futility
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_bindingFutility_+3A_bindingfutility">bindingFutility</code></td>
<td>
<p>Logical. If <code>bindingFutility = TRUE</code> is specified the calculation of
the critical values is affected by the futility bounds and the futility threshold is binding in the
sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='param_calcEventsFunction'>Parameter Description: Calculate Events Function</h2><span id='topic+param_calcEventsFunction'></span>

<h3>Description</h3>

<p>Parameter Description: Calculate Events Function
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_calcEventsFunction_+3A_calceventsfunction">calcEventsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, event number recalculation is performed with conditional power and specified
<code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code> (see details and examples).</p>
</td></tr>
</table>

<hr>
<h2 id='param_calcSubjectsFunction'>Parameter Description: Calculate Subjects Function</h2><span id='topic+param_calcSubjectsFunction'></span>

<h3>Description</h3>

<p>Parameter Description: Calculate Subjects Function
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_calcSubjectsFunction_+3A_calcsubjectsfunction">calcSubjectsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of performing the sample size
recalculation. By default, sample size recalculation is performed with conditional power and specified
<code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code> (see details and examples).</p>
</td></tr>
</table>

<hr>
<h2 id='param_conditionalPower'>Parameter Description: Conditional Power</h2><span id='topic+param_conditionalPower'></span>

<h3>Description</h3>

<p>Parameter Description: Conditional Power
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_conditionalPower_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>The conditional power for the subsequent stage
under which the sample size recalculation is performed. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_conditionalPowerSimulation'>Parameter Description: Conditional Power</h2><span id='topic+param_conditionalPowerSimulation'></span>

<h3>Description</h3>

<p>Parameter Description: Conditional Power
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_conditionalPowerSimulation_+3A_conditionalpower">conditionalPower</code></td>
<td>
<p>If <code>conditionalPower</code> together with <code>minNumberOfSubjectsPerStage</code> and
<code>maxNumberOfSubjectsPerStage</code> (or <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>
for survival designs) is specified, a sample size recalculation based on the specified conditional power is performed.
It is defined as the power for the subsequent stage given the current data. By default,
the conditional power will be calculated under the observed effect size. Optionally, you can also specify <code>thetaH1</code> and
<code>stDevH1</code> (for simulating means), <code>pi1H1</code> and <code>pi2H1</code> (for simulating rates), or <code>thetaH1</code> (for simulating
hazard ratios) as parameters under which it is calculated and the sample size recalculation is performed.</p>
</td></tr>
</table>

<hr>
<h2 id='param_dataInput'>Parameter Description: Data Input</h2><span id='topic+param_dataInput'></span>

<h3>Description</h3>

<p>Parameter Description: Data Input
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_dataInput_+3A_datainput">dataInput</code></td>
<td>
<p>The summary data used for calculating the test results.
This is either an element of <code>DatasetMeans</code>, of <code>DatasetRates</code>, or of <code>DatasetSurvival</code>
and should be created with the function <code><a href="#topic+getDataset">getDataset()</a></code>.
For more information see <code><a href="#topic+getDataset">getDataset()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_design'>Parameter Description: Design</h2><span id='topic+param_design'></span>

<h3>Description</h3>

<p>Parameter Description: Design
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_design_+3A_design">design</code></td>
<td>
<p>The trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='param_design_with_default'>Parameter Description: Design with Default</h2><span id='topic+param_design_with_default'></span>

<h3>Description</h3>

<p>Parameter Description: Design with Default
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_design_with_default_+3A_design">design</code></td>
<td>
<p>The trial design. If no trial design is specified, a fixed sample size design is used.
In this case, Type I error rate <code>alpha</code>, Type II error rate <code>beta</code>, <code>twoSidedPower</code>,
and <code>sided</code> can be directly entered as argument where necessary.</p>
</td></tr>
</table>

<hr>
<h2 id='param_digits'>Parameter Description: Digits</h2><span id='topic+param_digits'></span>

<h3>Description</h3>

<p>Parameter Description: Digits
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_digits_+3A_digits">digits</code></td>
<td>
<p>Defines how many digits are to be used for numeric values. Must be a positive integer of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_directionUpper'>Parameter Description: Direction Upper</h2><span id='topic+param_directionUpper'></span>

<h3>Description</h3>

<p>Parameter Description: Direction Upper
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_directionUpper_+3A_directionupper">directionUpper</code></td>
<td>
<p>Logical. Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.</p>
</td></tr>
</table>

<hr>
<h2 id='param_dropoutRate1'>Parameter Description: Dropout Rate (1)</h2><span id='topic+param_dropoutRate1'></span>

<h3>Description</h3>

<p>Parameter Description: Dropout Rate (1)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_dropoutRate1_+3A_dropoutrate1">dropoutRate1</code></td>
<td>
<p>The assumed drop-out rate in the treatment group, default is <code>0</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_dropoutRate2'>Parameter Description: Dropout Rate (2)</h2><span id='topic+param_dropoutRate2'></span>

<h3>Description</h3>

<p>Parameter Description: Dropout Rate (2)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_dropoutRate2_+3A_dropoutrate2">dropoutRate2</code></td>
<td>
<p>The assumed drop-out rate in the control group, default is <code>0</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_dropoutTime'>Parameter Description: Dropout Time</h2><span id='topic+param_dropoutTime'></span>

<h3>Description</h3>

<p>Parameter Description: Dropout Time
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_dropoutTime_+3A_dropouttime">dropoutTime</code></td>
<td>
<p>The assumed time for drop-out rates in the control and the
treatment group, default is <code>12</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_effectList'>Parameter Description: Effect List</h2><span id='topic+param_effectList'></span>

<h3>Description</h3>

<p>Parameter Description: Effect List
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_effectList_+3A_effectlist">effectList</code></td>
<td>
<p>List of subsets, prevalences, and effect sizes with columns and number of rows
reflecting the different situations to consider (see examples).</p>
</td></tr>
</table>

<hr>
<h2 id='param_effectMatrix'>Parameter Description: Effect Matrix</h2><span id='topic+param_effectMatrix'></span>

<h3>Description</h3>

<p>Parameter Description: Effect Matrix
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_effectMatrix_+3A_effectmatrix">effectMatrix</code></td>
<td>
<p>Matrix of effect sizes with <code>activeArms</code> columns and number of rows
reflecting the different situations to consider.</p>
</td></tr>
</table>

<hr>
<h2 id='param_effectMeasure'>Parameter Description: Effect Measure</h2><span id='topic+param_effectMeasure'></span>

<h3>Description</h3>

<p>Parameter Description: Effect Measure
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_effectMeasure_+3A_effectmeasure">effectMeasure</code></td>
<td>
<p>Criterion for treatment arm/population selection, either based on test statistic
(<code>"testStatistic"</code>) or effect estimate (difference for means and rates or ratio for survival) (<code>"effectEstimate"</code>),
default is <code>"effectEstimate"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_epsilonValue'>Parameter Description: Epsilon Value</h2><span id='topic+param_epsilonValue'></span>

<h3>Description</h3>

<p>Parameter Description: Epsilon Value
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_epsilonValue_+3A_epsilonvalue">epsilonValue</code></td>
<td>
<p>For <code>typeOfSelection = "epsilon"</code> (select treatment arm / population not worse than
epsilon compared to the best), the parameter <code>epsilonValue</code> has to be specified. Must be a numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_eventTime'>Parameter Description: Event Time</h2><span id='topic+param_eventTime'></span>

<h3>Description</h3>

<p>Parameter Description: Event Time
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_eventTime_+3A_eventtime">eventTime</code></td>
<td>
<p>The assumed time under which the event rates are calculated, default is <code>12</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_fixedExposureTime_counts'>Parameter Description: fixedExposureTime for Counts</h2><span id='topic+param_fixedExposureTime_counts'></span>

<h3>Description</h3>

<p>Parameter Description: fixedExposureTime for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_fixedExposureTime_counts_+3A_fixedexposuretime">fixedExposureTime</code></td>
<td>
<p>If specified, the fixed time of exposure per subject for count data, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_followUpTime_counts'>Parameter Description: followUpTime for Counts</h2><span id='topic+param_followUpTime_counts'></span>

<h3>Description</h3>

<p>Parameter Description: followUpTime for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_followUpTime_counts_+3A_followuptime">followUpTime</code></td>
<td>
<p>If specified, the assumed (additional) follow-up time for the study, there is no default.
The total study duration is <code>accrualTime + followUpTime</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_gED50'>Parameter Description: G ED50</h2><span id='topic+param_gED50'></span>

<h3>Description</h3>

<p>Parameter Description: G ED50
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_gED50_+3A_ged50">gED50</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"gED50"</code> has to be entered
to specify the ED50 of the sigmoid Emax model.</p>
</td></tr>
</table>

<hr>
<h2 id='param_grid'>Parameter Description: Grid (Output Specification Of Multiple Plots)</h2><span id='topic+param_grid'></span>

<h3>Description</h3>

<p>Parameter Description: Grid (Output Specification Of Multiple Plots)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_grid_+3A_grid">grid</code></td>
<td>
<p>An integer value specifying the output of multiple plots.
By default (<code>1</code>) a list of <code>ggplot</code> objects will be returned.
If a <code>grid</code> value &gt; 1 was specified, a grid plot will be returned
if the number of plots is &lt;= specified <code>grid</code> value;
a list of <code>ggplot</code> objects will be returned otherwise.
If <code>grid = 0</code> is specified, all plots will be created using <code><a href="base.html#topic+print">print</a></code> command
and a list of <code>ggplot</code> objects will be returned invisible.
Note that one of the following packages must be installed to create a grid plot:
'ggpubr', 'gridExtra', or 'cowplot'.</p>
</td></tr>
</table>

<hr>
<h2 id='param_groups'>Parameter Description: Number Of Treatment Groups</h2><span id='topic+param_groups'></span>

<h3>Description</h3>

<p>Parameter Description: Number Of Treatment Groups
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_groups_+3A_groups">groups</code></td>
<td>
<p>The number of treatment groups (1 or 2), default is <code>2</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_hazardRatio'>Parameter Description: Hazard Ratio</h2><span id='topic+param_hazardRatio'></span>

<h3>Description</h3>

<p>Parameter Description: Hazard Ratio
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_hazardRatio_+3A_hazardratio">hazardRatio</code></td>
<td>
<p>The vector of hazard ratios under consideration.
If the event or hazard rates in both treatment groups are defined, the hazard ratio needs
not to be specified as it is calculated, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_includeAllParameters'>Parameter Description: Include All Parameters</h2><span id='topic+param_includeAllParameters'></span>

<h3>Description</h3>

<p>Parameter Description: Include All Parameters
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_includeAllParameters_+3A_includeallparameters">includeAllParameters</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all available
parameters will be included in the data frame;
a meaningful parameter selection otherwise, default is <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_informationEpsilon'>Parameter Description: Information Epsilon</h2><span id='topic+param_informationEpsilon'></span>

<h3>Description</h3>

<p>Parameter Description: Information Epsilon
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_informationEpsilon_+3A_informationepsilon">informationEpsilon</code></td>
<td>
<p>Positive integer value specifying the absolute information epsilon, which
defines the maximum distance from the observed information to the maximum information that causes the final analysis.
Updates at the final analysis in case the observed information at the final
analysis is smaller (&quot;under-running&quot;) than the planned maximum information <code>maxInformation</code>, default is 0.
Alternatively, a floating-point number &gt; 0 and &lt; 1 can be specified to define a relative information epsilon.</p>
</td></tr>
</table>

<hr>
<h2 id='param_informationRates'>Parameter Description: Information Rates</h2><span id='topic+param_informationRates'></span>

<h3>Description</h3>

<p>Parameter Description: Information Rates
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_informationRates_+3A_informationrates">informationRates</code></td>
<td>
<p>The information rates t_1, ..., t_kMax (that must be fixed prior to the trial),
default is <code>(1:kMax) / kMax</code>. For the weighted inverse normal design, the weights are derived
through w_1 = sqrt(t_1), and w_k = sqrt(t_k - t_(k-1)). For the weighted Fisher's combination test, the
weights (scales) are w_k = sqrt((t_k - t_(k-1)) / t_1) (see the documentation).</p>
</td></tr>
</table>

<hr>
<h2 id='param_intersectionTest_Enrichment'>Parameter Description: Intersection Test</h2><span id='topic+param_intersectionTest_Enrichment'></span>

<h3>Description</h3>

<p>Parameter Description: Intersection Test
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_intersectionTest_Enrichment_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Four options are available in enrichment designs: <code>"SpiessensDebois"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
and <code>"Sidak"</code>, default is <code>"Simes"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_intersectionTest_MultiArm'>Parameter Description: Intersection Test</h2><span id='topic+param_intersectionTest_MultiArm'></span>

<h3>Description</h3>

<p>Parameter Description: Intersection Test
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_intersectionTest_MultiArm_+3A_intersectiontest">intersectionTest</code></td>
<td>
<p>Defines the multiple test for the intersection
hypotheses in the closed system of hypotheses.
Five options are available in multi-arm designs: <code>"Dunnett"</code>, <code>"Bonferroni"</code>, <code>"Simes"</code>,
<code>"Sidak"</code>, and <code>"Hierarchical"</code>, default is <code>"Dunnett"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_kappa'>Parameter Description: Kappa</h2><span id='topic+param_kappa'></span>

<h3>Description</h3>

<p>Parameter Description: Kappa
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_kappa_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
</table>

<hr>
<h2 id='param_kMax'>Parameter Description: Maximum Number of Stages</h2><span id='topic+param_kMax'></span>

<h3>Description</h3>

<p>Parameter Description: Maximum Number of Stages
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_kMax_+3A_kmax">kMax</code></td>
<td>
<p>The maximum number of stages <code>K</code>.
Must be a positive integer of length 1 (default value is <code>3</code>).
The maximum selectable <code>kMax</code> is <code>20</code> for group sequential or inverse normal and
<code>6</code> for Fisher combination test designs.</p>
</td></tr>
</table>

<hr>
<h2 id='param_lambda_counts'>Parameter Description: lambda for Counts</h2><span id='topic+param_lambda_counts'></span>

<h3>Description</h3>

<p>Parameter Description: lambda for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_lambda_counts_+3A_lambda">lambda</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the pooled treatment groups, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_lambda1'>Parameter Description: Lambda (1)</h2><span id='topic+param_lambda1'></span>

<h3>Description</h3>

<p>Parameter Description: Lambda (1)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_lambda1_+3A_lambda1">lambda1</code></td>
<td>
<p>The assumed hazard rate in the treatment group, there is no default.
<code>lambda1</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_lambda1_counts'>Parameter Description: lambda (1) for Counts</h2><span id='topic+param_lambda1_counts'></span>

<h3>Description</h3>

<p>Parameter Description: lambda (1) for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_lambda1_counts_+3A_lambda1">lambda1</code></td>
<td>
<p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in
the active treatment group, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_lambda2'>Parameter Description: Lambda (2)</h2><span id='topic+param_lambda2'></span>

<h3>Description</h3>

<p>Parameter Description: Lambda (2)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_lambda2_+3A_lambda2">lambda2</code></td>
<td>
<p>The assumed hazard rate in the reference group, there is no default.
<code>lambda2</code> can also be used to define piecewise exponentially distributed survival times (see details). Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_lambda2_counts'>Parameter Description: lambda (2) for Counts</h2><span id='topic+param_lambda2_counts'></span>

<h3>Description</h3>

<p>Parameter Description: lambda (2) for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_lambda2_counts_+3A_lambda2">lambda2</code></td>
<td>
<p>A numeric value that represents the assumed rate of a homogeneous Poisson process in
the control group, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_legendPosition'>Parameter Description: Legend Position On Plots</h2><span id='topic+param_legendPosition'></span>

<h3>Description</h3>

<p>Parameter Description: Legend Position On Plots
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_legendPosition_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='param_maxInformation'>Parameter Description: Maximum Information</h2><span id='topic+param_maxInformation'></span>

<h3>Description</h3>

<p>Parameter Description: Maximum Information
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_maxInformation_+3A_maxinformation">maxInformation</code></td>
<td>
<p>Positive integer value specifying the maximum information.</p>
</td></tr>
</table>

<hr>
<h2 id='param_maxNumberOfEventsPerStage'>Parameter Description: Max Number Of Events Per Stage</h2><span id='topic+param_maxNumberOfEventsPerStage'></span>

<h3>Description</h3>

<p>Parameter Description: Max Number Of Events Per Stage
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_maxNumberOfEventsPerStage_+3A_maxnumberofeventsperstage">maxNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfEventsPerStage</code> with length kMax determines the maximum number
of events per stage (i.e., not cumulated), the first element is not taken into account.</p>
</td></tr>
</table>

<hr>
<h2 id='param_maxNumberOfIterations'>Parameter Description: Maximum Number Of Iterations</h2><span id='topic+param_maxNumberOfIterations'></span>

<h3>Description</h3>

<p>Parameter Description: Maximum Number Of Iterations
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_maxNumberOfIterations_+3A_maxnumberofiterations">maxNumberOfIterations</code></td>
<td>
<p>The number of simulation iterations, default is <code>1000</code>. Must be a positive integer of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_maxNumberOfSubjects'>Parameter Description: Maximum Number Of Subjects</h2><span id='topic+param_maxNumberOfSubjects'></span>

<h3>Description</h3>

<p>Parameter Description: Maximum Number Of Subjects
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_maxNumberOfSubjects_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified for power calculations or calculation
of necessary follow-up (count data). For two treatment arms, it is the maximum number of subjects for both treatment arms.</p>
</td></tr>
</table>

<hr>
<h2 id='param_maxNumberOfSubjects_survival'>Parameter Description: Maximum Number Of Subjects For Survival Endpoint</h2><span id='topic+param_maxNumberOfSubjects_survival'></span>

<h3>Description</h3>

<p>Parameter Description: Maximum Number Of Subjects For Survival Endpoint
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_maxNumberOfSubjects_survival_+3A_maxnumberofsubjects">maxNumberOfSubjects</code></td>
<td>
<p><code>maxNumberOfSubjects &gt; 0</code> needs to be specified.
If accrual time and accrual intensity are specified, this will be calculated. Must be a positive integer of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_maxNumberOfSubjectsPerStage'>Parameter Description: Maximum Number Of Subjects Per Stage</h2><span id='topic+param_maxNumberOfSubjectsPerStage'></span>

<h3>Description</h3>

<p>Parameter Description: Maximum Number Of Subjects Per Stage
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_maxNumberOfSubjectsPerStage_+3A_maxnumberofsubjectsperstage">maxNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>maxNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the maximum number
of subjects per stage (i.e., not cumulated), the first element is not taken into account.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>maxNumberOfSubjectsPerStage</code> refers
to the maximum number of subjects per selected active arm.</p>
</td></tr>
</table>

<hr>
<h2 id='param_median1'>Parameter Description: Median (1)</h2><span id='topic+param_median1'></span>

<h3>Description</h3>

<p>Parameter Description: Median (1)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_median1_+3A_median1">median1</code></td>
<td>
<p>The assumed median survival time in the treatment group, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_median2'>Parameter Description: Median (2)</h2><span id='topic+param_median2'></span>

<h3>Description</h3>

<p>Parameter Description: Median (2)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_median2_+3A_median2">median2</code></td>
<td>
<p>The assumed median survival time in the reference group, there is no default. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_minNumberOfEventsPerStage'>Parameter Description: Min Number Of Events Per Stage</h2><span id='topic+param_minNumberOfEventsPerStage'></span>

<h3>Description</h3>

<p>Parameter Description: Min Number Of Events Per Stage
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_minNumberOfEventsPerStage_+3A_minnumberofeventsperstage">minNumberOfEventsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfEventsPerStage</code> with length kMax determines the
minimum number of events per stage (i.e., not cumulated), the first element
is not taken into account.</p>
</td></tr>
</table>

<hr>
<h2 id='param_minNumberOfSubjectsPerStage'>Parameter Description: Minimum Number Of Subjects Per Stage</h2><span id='topic+param_minNumberOfSubjectsPerStage'></span>

<h3>Description</h3>

<p>Parameter Description: Minimum Number Of Subjects Per Stage
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_minNumberOfSubjectsPerStage_+3A_minnumberofsubjectsperstage">minNumberOfSubjectsPerStage</code></td>
<td>
<p>When performing a data driven sample size recalculation,
the numeric vector <code>minNumberOfSubjectsPerStage</code> with length <code>kMax</code> determines the
minimum number of subjects per stage (i.e., not cumulated), the first element
is not taken into account. For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs <code>minNumberOfSubjectsPerStage</code> refers
to the minimum number of subjects per selected active arm.</p>
</td></tr>
</table>

<hr>
<h2 id='param_niceColumnNamesEnabled'>Parameter Description: Nice Column Names Enabled</h2><span id='topic+param_niceColumnNamesEnabled'></span>

<h3>Description</h3>

<p>Parameter Description: Nice Column Names Enabled
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_niceColumnNamesEnabled_+3A_nicecolumnnamesenabled">niceColumnNamesEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, nice looking column
names will be used; syntactic names (variable names) otherwise
(see <code><a href="base.html#topic+make.names">make.names</a></code>).</p>
</td></tr>
</table>

<hr>
<h2 id='param_nMax'>Parameter Description: N_max</h2><span id='topic+param_nMax'></span>

<h3>Description</h3>

<p>Parameter Description: N_max
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_nMax_+3A_nmax">nMax</code></td>
<td>
<p>The maximum sample size. Must be a positive integer of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_normalApproximation'>Parameter Description: Normal Approximation</h2><span id='topic+param_normalApproximation'></span>

<h3>Description</h3>

<p>Parameter Description: Normal Approximation
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_normalApproximation_+3A_normalapproximation">normalApproximation</code></td>
<td>
<p>The type of computation of the p-values. Default is <code>FALSE</code> for
testing means (i.e., the t test is used) and <code>TRUE</code> for testing rates and the hazard ratio.
For testing rates, if <code>normalApproximation = FALSE</code> is specified, the binomial test
(one sample) or the exact test of Fisher (two samples) is used for calculating the p-values.
In the survival setting <code>normalApproximation = FALSE</code> has no effect.</p>
</td></tr>
</table>

<hr>
<h2 id='param_nPlanned'>Parameter Description: N Planned</h2><span id='topic+param_nPlanned'></span>

<h3>Description</h3>

<p>Parameter Description: N Planned
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_nPlanned_+3A_nplanned">nPlanned</code></td>
<td>
<p>The additional (i.e., &quot;new&quot; and not cumulative) sample size planned for each of the subsequent stages.
The argument must be a vector with length equal to the number of remaining stages and contain
the combined sample size from both treatment groups if two groups are considered. For survival outcomes,
it should contain the planned number of additional events.
For multi-arm designs, it is the per-comparison (combined) sample size.
For enrichment designs, it is the (combined) sample size for the considered sub-population.</p>
</td></tr>
</table>

<hr>
<h2 id='param_overdispersion_counts'>Parameter Description: overdispersion for Counts</h2><span id='topic+param_overdispersion_counts'></span>

<h3>Description</h3>

<p>Parameter Description: overdispersion for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_overdispersion_counts_+3A_overdispersion">overdispersion</code></td>
<td>
<p>A numeric value that represents the assumed overdispersion of the negative binomial distribution,
default is <code>0</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_palette'>Parameter Description: Palette</h2><span id='topic+param_palette'></span>

<h3>Description</h3>

<p>Parameter Description: Palette
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_palette_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_pi1_rates'>Parameter Description: Pi (1) for Rates</h2><span id='topic+param_pi1_rates'></span>

<h3>Description</h3>

<p>Parameter Description: Pi (1) for Rates
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_pi1_rates_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed probability in
the active treatment group if two treatment groups
are considered, or the alternative probability for a one treatment group design,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
</table>

<hr>
<h2 id='param_pi1_survival'>Parameter Description: Pi (1) for Survival Data</h2><span id='topic+param_pi1_survival'></span>

<h3>Description</h3>

<p>Parameter Description: Pi (1) for Survival Data
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_pi1_survival_+3A_pi1">pi1</code></td>
<td>
<p>A numeric value or vector that represents the assumed event rate in the treatment group,
default is <code>seq(0.2, 0.5, 0.1)</code> (power calculations and simulations) or
<code>seq(0.4, 0.6, 0.1)</code> (sample size calculations).</p>
</td></tr>
</table>

<hr>
<h2 id='param_pi2_rates'>Parameter Description: Pi (2) for Rates</h2><span id='topic+param_pi2_rates'></span>

<h3>Description</h3>

<p>Parameter Description: Pi (2) for Rates
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_pi2_rates_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed probability in the reference group if two treatment
groups are considered, default is <code>0.2</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_pi2_survival'>Parameter Description: Pi (2) for Survival Data</h2><span id='topic+param_pi2_survival'></span>

<h3>Description</h3>

<p>Parameter Description: Pi (2) for Survival Data
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_pi2_survival_+3A_pi2">pi2</code></td>
<td>
<p>A numeric value that represents the assumed event rate in the control group, default is <code>0.2</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_piecewiseSurvivalTime'>Parameter Description: Piecewise Survival Time</h2><span id='topic+param_piecewiseSurvivalTime'></span>

<h3>Description</h3>

<p>Parameter Description: Piecewise Survival Time
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_piecewiseSurvivalTime_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>A vector that specifies the time intervals for the piecewise
definition of the exponential survival time cumulative distribution function <br />
(for details see <code><a href="#topic+getPiecewiseSurvivalTime">getPiecewiseSurvivalTime()</a></code>).</p>
</td></tr>
</table>

<hr>
<h2 id='param_plannedCalendarTime'>Parameter Description: Planned Calendar Time</h2><span id='topic+param_plannedCalendarTime'></span>

<h3>Description</h3>

<p>Parameter Description: Planned Calendar Time
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_plannedCalendarTime_+3A_plannedcalendartime">plannedCalendarTime</code></td>
<td>
<p>For simulating count data, the time points where an analysis is planned to be performed.
Should be a vector of length <code>kMax</code></p>
</td></tr>
</table>

<hr>
<h2 id='param_plannedEvents'>Parameter Description: Planned Events</h2><span id='topic+param_plannedEvents'></span>

<h3>Description</h3>

<p>Parameter Description: Planned Events
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_plannedEvents_+3A_plannedevents">plannedEvents</code></td>
<td>
<p><code>plannedEvents</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) events in survival designs when the interim stages are planned.
For two treatment arms, it is the number of events for both treatment arms.
For multi-arm designs, <code>plannedEvents</code> refers to the overall number of events for the selected arms plus control.</p>
</td></tr>
</table>

<hr>
<h2 id='param_plannedSubjects'>Parameter Description: Planned Subjects</h2><span id='topic+param_plannedSubjects'></span>

<h3>Description</h3>

<p>Parameter Description: Planned Subjects
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_plannedSubjects_+3A_plannedsubjects">plannedSubjects</code></td>
<td>
<p><code>plannedSubjects</code> is a numeric vector of length <code>kMax</code> (the number of stages of the design)
that determines the number of cumulated (overall) subjects when the interim stages are planned.
For two treatment arms, it is the number of subjects for both treatment arms.
For multi-arm designs, <code>plannedSubjects</code> refers to the number of subjects per selected active arm.</p>
</td></tr>
</table>

<hr>
<h2 id='param_plotPointsEnabled'>Parameter Description: Plot Points Enabled</h2><span id='topic+param_plotPointsEnabled'></span>

<h3>Description</h3>

<p>Parameter Description: Plot Points Enabled
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_plotPointsEnabled_+3A_plotpointsenabled">plotPointsEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional points will be plotted.</p>
</td></tr>
</table>

<hr>
<h2 id='param_plotSettings'>Parameter Description: Plot Settings</h2><span id='topic+param_plotSettings'></span>

<h3>Description</h3>

<p>Parameter Description: Plot Settings
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_plotSettings_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_populations'>Parameter Description: Populations</h2><span id='topic+param_populations'></span>

<h3>Description</h3>

<p>Parameter Description: Populations
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_populations_+3A_populations">populations</code></td>
<td>
<p>The number of populations in a two-sample comparison, default is <code>3</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_rValue'>Parameter Description: R Value</h2><span id='topic+param_rValue'></span>

<h3>Description</h3>

<p>Parameter Description: R Value
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_rValue_+3A_rvalue">rValue</code></td>
<td>
<p>For <code>typeOfSelection = "rbest"</code> (select the <code>rValue</code> best treatment arms / populations),
the parameter <code>rValue</code> has to be specified.</p>
</td></tr>
</table>

<hr>
<h2 id='param_seed'>Parameter Description: Seed</h2><span id='topic+param_seed'></span>

<h3>Description</h3>

<p>Parameter Description: Seed
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_seed_+3A_seed">seed</code></td>
<td>
<p>The seed to reproduce the simulation, default is a random seed.</p>
</td></tr>
</table>

<hr>
<h2 id='param_selectArmsFunction'>Parameter Description: Select Arms Function</h2><span id='topic+param_selectArmsFunction'></span>

<h3>Description</h3>

<p>Parameter Description: Select Arms Function
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_selectArmsFunction_+3A_selectarmsfunction">selectArmsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how treatment arms
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>activeArms</code>,
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedArms"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_selectPopulationsFunction'>Parameter Description: Select Populations Function</h2><span id='topic+param_selectPopulationsFunction'></span>

<h3>Description</h3>

<p>Parameter Description: Select Populations Function
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_selectPopulationsFunction_+3A_selectpopulationsfunction">selectPopulationsFunction</code></td>
<td>
<p>Optionally, a function can be entered that defines the way of how populations
are selected. This function is allowed to depend on <code>effectVector</code> with length <code>populations</code>
<code>stage</code>, <code>"conditionalPower"</code>, <code>"conditionalCriticalValue"</code>, <code>"plannedSubjects/plannedEvents"</code>,
<code>"allocationRatioPlanned"</code>, <code>"selectedPopulations"</code>, <code>"thetaH1"</code> (for means and survival), <code>"stDevH1"</code> (for means),
<code>"overallEffects"</code>, and for rates additionally: <code>"piTreatmentsH1"</code>, <code>"piControlH1"</code>, <code>"overallRates"</code>, and
<code>"overallRatesControl"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_showSource'>Parameter Description: Show Source</h2><span id='topic+param_showSource'></span>

<h3>Description</h3>

<p>Parameter Description: Show Source
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_showSource_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
</table>

<hr>
<h2 id='param_showStatistics'>Parameter Description: Show Statistics</h2><span id='topic+param_showStatistics'></span>

<h3>Description</h3>

<p>Parameter Description: Show Statistics
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_showStatistics_+3A_showstatistics">showStatistics</code></td>
<td>
<p>Logical. If <code>TRUE</code>, summary statistics of the simulated data
are displayed for the <code>print</code> command, otherwise the output is suppressed, default
is <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_sided'>Parameter Description: Sided</h2><span id='topic+param_sided'></span>

<h3>Description</h3>

<p>Parameter Description: Sided
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_sided_+3A_sided">sided</code></td>
<td>
<p>Is the alternative one-sided (<code>1</code>) or two-sided (<code>2</code>), default is <code>1</code>.
Must be a positive integer of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_slope'>Parameter Description: Slope</h2><span id='topic+param_slope'></span>

<h3>Description</h3>

<p>Parameter Description: Slope
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_slope_+3A_slope">slope</code></td>
<td>
<p>If <code>typeOfShape = "sigmoidEmax"</code> is selected, <code>"slope"</code> can be entered
to specify the slope of the sigmoid Emax model, default is 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_stage'>Parameter Description: Stage</h2><span id='topic+param_stage'></span>

<h3>Description</h3>

<p>Parameter Description: Stage
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_stage_+3A_stage">stage</code></td>
<td>
<p>The stage number (optional). Default: total number of existing stages in the data input.</p>
</td></tr>
</table>

<hr>
<h2 id='param_stageResults'>Parameter Description: Stage Results</h2><span id='topic+param_stageResults'></span>

<h3>Description</h3>

<p>Parameter Description: Stage Results
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_stageResults_+3A_stageresults">stageResults</code></td>
<td>
<p>The results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_stDev'>Parameter Description: Standard Deviation</h2><span id='topic+param_stDev'></span>

<h3>Description</h3>

<p>Parameter Description: Standard Deviation
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_stDev_+3A_stdev">stDev</code></td>
<td>
<p>The standard deviation under which the sample size or power
calculation is performed, default is <code>1</code>.
If <code>meanRatio = TRUE</code> is specified, <code>stDev</code> defines
the coefficient of variation <code>sigma / mu2</code>. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_stDevH1'>Parameter Description: Standard Deviation Under Alternative</h2><span id='topic+param_stDevH1'></span>

<h3>Description</h3>

<p>Parameter Description: Standard Deviation Under Alternative
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_stDevH1_+3A_stdevh1">stDevH1</code></td>
<td>
<p>If specified, the value of the standard deviation under which
the conditional power or sample size recalculation calculation is performed,
default is the value of <code>stDev</code>. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_stDevSimulation'>Parameter Description: Standard Deviation for Simulation</h2><span id='topic+param_stDevSimulation'></span>

<h3>Description</h3>

<p>Parameter Description: Standard Deviation for Simulation
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_stDevSimulation_+3A_stdev">stDev</code></td>
<td>
<p>The standard deviation under which the data is simulated,
default is <code>1</code>.
If <code>meanRatio = TRUE</code> is specified, <code>stDev</code> defines
the coefficient of variation <code>sigma / mu2</code>. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_stratifiedAnalysis'>Parameter Description: Stratified Analysis</h2><span id='topic+param_stratifiedAnalysis'></span>

<h3>Description</h3>

<p>Parameter Description: Stratified Analysis
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_stratifiedAnalysis_+3A_stratifiedanalysis">stratifiedAnalysis</code></td>
<td>
<p>Logical. For enrichment designs, typically a stratified analysis should be chosen.
For testing rates, also a non-stratified analysis based on overall data can be performed.
For survival data, only a stratified analysis is possible (see Brannath et al., 2009),
default is <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_successCriterion'>Parameter Description: Success Criterion</h2><span id='topic+param_successCriterion'></span>

<h3>Description</h3>

<p>Parameter Description: Success Criterion
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_successCriterion_+3A_successcriterion">successCriterion</code></td>
<td>
<p>Defines when the study is stopped for efficacy at interim.
Two options are available: <code>"all"</code> stops the trial
if the efficacy criterion is fulfilled for all selected treatment arms/populations,
<code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be
superior to control at interim, default is <code>"all"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_theta'>Parameter Description: Theta</h2><span id='topic+param_theta'></span>

<h3>Description</h3>

<p>Parameter Description: Theta
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_theta_+3A_theta">theta</code></td>
<td>
<p>A vector of standardized effect sizes (theta values), default is a sequence from -1 to 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_theta_counts'>Parameter Description: theta for Counts</h2><span id='topic+param_theta_counts'></span>

<h3>Description</h3>

<p>Parameter Description: theta for Counts
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_theta_counts_+3A_theta">theta</code></td>
<td>
<p>A numeric value or vector that represents the assumed mean ratios lambda1/lambda2 of a homogeneous
Poisson process, there is no default.</p>
</td></tr>
</table>

<hr>
<h2 id='param_thetaH0'>Parameter Description: Theta H0</h2><span id='topic+param_thetaH0'></span>

<h3>Description</h3>

<p>Parameter Description: Theta H0
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_thetaH0_+3A_thetah0">thetaH0</code></td>
<td>
<p>The null hypothesis value,
default is <code>0</code> for the normal and the binary case (testing means and rates, respectively),
it is <code>1</code> for the survival case (testing the hazard ratio).<br /><br />
For non-inferiority designs, <code>thetaH0</code> is the non-inferiority bound.
That is, in case of (one-sided) testing of
</p>

<ul>
<li> <p><em>means</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the mean ratio) can be specified.
</p>
</li>
<li> <p><em>rates</em>: a value <code>!= 0</code>
(or a value <code>!= 1</code> for testing the risk ratio <code>pi1 / pi2</code>) can be specified.
</p>
</li>
<li> <p><em>survival data</em>: a bound for testing H0: <code>hazard ratio = thetaH0 != 1</code> can be specified.
</p>
</li>
<li> <p><em>count data</em>: a bound for testing H0: <code>lambda1 / lambda2 = thetaH0 != 1</code> can be specified.
</p>
</li></ul>

<p>For testing a rate in one sample, a value <code>thetaH0</code> in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_thetaH1'>Parameter Description: Effect Under Alternative</h2><span id='topic+param_thetaH1'></span>

<h3>Description</h3>

<p>Parameter Description: Effect Under Alternative
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_thetaH1_+3A_thetah1">thetaH1</code></td>
<td>
<p>If specified, the value of the alternative under which
the conditional power or sample size recalculation calculation is performed. Must be a numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_three_dots'>Parameter Description: &quot;...&quot;</h2><span id='topic+param_three_dots'></span>

<h3>Description</h3>

<p>Parameter Description: &quot;...&quot;
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_three_dots_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
</table>

<hr>
<h2 id='param_three_dots_plot'>Parameter Description: &quot;...&quot; (optional plot arguments)</h2><span id='topic+param_three_dots_plot'></span>

<h3>Description</h3>

<p>Parameter Description: &quot;...&quot; (optional plot arguments)
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_three_dots_plot_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
</table>

<hr>
<h2 id='param_threshold'>Parameter Description: Threshold</h2><span id='topic+param_threshold'></span>

<h3>Description</h3>

<p>Parameter Description: Threshold
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_threshold_+3A_threshold">threshold</code></td>
<td>
<p>Selection criterion: treatment arm / population is selected only if <code>effectMeasure</code>
exceeds <code>threshold</code>, default is <code>-Inf</code>.
<code>threshold</code> can also be a vector of length <code>activeArms</code> referring to
a separate threshold condition over the treatment arms.</p>
</td></tr>
</table>

<hr>
<h2 id='param_tolerance'>Parameter Description: Tolerance</h2><span id='topic+param_tolerance'></span>

<h3>Description</h3>

<p>Parameter Description: Tolerance
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_tolerance_+3A_tolerance">tolerance</code></td>
<td>
<p>The numerical tolerance, default is <code>1e-06</code>. Must be a positive numeric of length 1.</p>
</td></tr>
</table>

<hr>
<h2 id='param_typeOfComputation'>Parameter Description: Type Of Computation</h2><span id='topic+param_typeOfComputation'></span>

<h3>Description</h3>

<p>Parameter Description: Type Of Computation
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_typeOfComputation_+3A_typeofcomputation">typeOfComputation</code></td>
<td>
<p>Three options are available: <code>"Schoenfeld"</code>, <code>"Freedman"</code>, <code>"HsiehFreedman"</code>,
the default is <code>"Schoenfeld"</code>. For details, see Hsieh (Statistics in Medicine, 1992).
For non-inferiority testing (i.e., <code>thetaH0 != 1</code>), only Schoenfeld's formula can be used.</p>
</td></tr>
</table>

<hr>
<h2 id='param_typeOfDesign'>Parameter Description: Type of Design</h2><span id='topic+param_typeOfDesign'></span>

<h3>Description</h3>

<p>Parameter Description: Type of Design
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_typeOfDesign_+3A_typeofdesign">typeOfDesign</code></td>
<td>
<p>The type of design. Type of design is one of the following:
O'Brien &amp; Fleming (<code>"OF"</code>), Pocock (<code>"P"</code>), Wang &amp; Tsiatis Delta class (<code>"WT"</code>),
Pampallona &amp; Tsiatis (<code>"PT"</code>), Haybittle &amp; Peto (&quot;HP&quot;),
Optimum design within Wang &amp; Tsiatis class (<code>"WToptimum"</code>),
O'Brien &amp; Fleming type alpha spending (<code>"asOF"</code>), Pocock type alpha spending (<code>"asP"</code>),
Kim &amp; DeMets alpha spending (<code>"asKD"</code>), Hwang, Shi &amp; DeCani alpha spending (<code>"asHSD"</code>),
user defined alpha spending (<code>"asUser"</code>), no early efficacy stop (<code>"noEarlyEfficacy"</code>),
default is <code>"OF"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_typeOfSelection'>Parameter Description: Type of Selection</h2><span id='topic+param_typeOfSelection'></span>

<h3>Description</h3>

<p>Parameter Description: Type of Selection
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_typeOfSelection_+3A_typeofselection">typeOfSelection</code></td>
<td>
<p>The way the treatment arms or populations are selected at interim.
Five options are available: <code>"best"</code>, <code>"rbest"</code>, <code>"epsilon"</code>, <code>"all"</code>, and <code>"userDefined"</code>,
default is <code>"best"</code>.<br />
For <code>"rbest"</code> (select the <code>rValue</code> best treatment arms/populations), the parameter <code>rValue</code> has to be specified,
for <code>"epsilon"</code> (select treatment arm/population not worse than epsilon compared to the best), the parameter
<code>epsilonValue</code> has to be specified.
If <code>"userDefined"</code> is selected, <code>"selectArmsFunction"</code> or <code>"selectPopulationsFunction"</code> has to be specified.</p>
</td></tr>
</table>

<hr>
<h2 id='param_typeOfShape'>Parameter Description: Type Of Shape</h2><span id='topic+param_typeOfShape'></span>

<h3>Description</h3>

<p>Parameter Description: Type Of Shape
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_typeOfShape_+3A_typeofshape">typeOfShape</code></td>
<td>
<p>The shape of the dose-response relationship over the treatment groups.
This can be either <code>"linear"</code>, <code>"sigmoidEmax"</code>, or <code>"userDefined"</code>,
default is <code>"linear"</code>.<br />
For <code>"linear"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with highest response.
If <code>"sigmoidEmax"</code> is selected, <code>"gED50"</code> and <code>"slope"</code> has to be entered
to specify the ED50 and the slope of the sigmoid Emax model.
For <code>"sigmoidEmax"</code>, <code>"muMaxVector"</code> specifies the range
of effect sizes for the treatment group with response according to infinite dose.
If <code>"userDefined"</code> is selected, <code>"effectMatrix"</code> has to be entered.</p>
</td></tr>
</table>

<hr>
<h2 id='param_userAlphaSpending'>Parameter Description: User Alpha Spending</h2><span id='topic+param_userAlphaSpending'></span>

<h3>Description</h3>

<p>Parameter Description: User Alpha Spending
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_userAlphaSpending_+3A_useralphaspending">userAlphaSpending</code></td>
<td>
<p>The user defined alpha spending.
Numeric vector of length <code>kMax</code> containing the cumulative
alpha-spending (Type I error rate) up to each interim stage: <code>0 &lt;= alpha_1 &lt;= ... &lt;= alpha_K &lt;= alpha</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='param_varianceOption'>Parameter Description: Variance Option</h2><span id='topic+param_varianceOption'></span>

<h3>Description</h3>

<p>Parameter Description: Variance Option
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="param_varianceOption_+3A_varianceoption">varianceOption</code></td>
<td>
<p>Defines the way to calculate the variance in multiple treatment arms (&gt; 2)
or population enrichment designs for testing means. For multiple arms, three options are available:
<code>"overallPooled"</code>, <code>"pairwisePooled"</code>, and <code>"notPooled"</code>, default is <code>"overallPooled"</code>.
For enrichment designs, the options are: <code>"pooled"</code>, <code>"pooledFromFull"</code> (one subset only),
and <code>"notPooled"</code>, default is <code>"pooled"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='ParameterSet'>Parameter Set</h2><span id='topic+ParameterSet'></span>

<h3>Description</h3>

<p>Basic class for parameter sets.
</p>


<h3>Details</h3>

<p>The parameter set implements basic functions for a set of parameters.
</p>

<hr>
<h2 id='PerformanceScore'>Performance Score</h2><span id='topic+PerformanceScore'></span>

<h3>Description</h3>

<p>Contains the conditional performance score, its sub-scores and components according to
Herrmann et al. (2020) for a given simulation result.
</p>


<h3>Details</h3>

<p>Use <a href="#topic+getPerformanceScore">getPerformanceScore</a> to calculate the performance score.
</p>

<hr>
<h2 id='PiecewiseSurvivalTime'>Piecewise Exponential Survival Time</h2><span id='topic+PiecewiseSurvivalTime'></span>

<h3>Description</h3>

<p>Class for the definition of piecewise survival times.
</p>


<h3>Details</h3>

<p><code>PiecewiseSurvivalTime</code> is a class for the definition of piecewise survival times.
</p>


<h3>Fields</h3>


<dl>
<dt><code>piecewiseSurvivalTime</code></dt><dd><p>The time intervals for the piecewise definition of the exponential survival time cumulative distribution function. Is a numeric vector.</p>
</dd>
<dt><code>lambda1</code></dt><dd><p>The assumed hazard rate in the treatment group. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>lambda2</code></dt><dd><p>The assumed hazard rate in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>hazardRatio</code></dt><dd><p>The hazard ratios under consideration. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed event rate in the treatment group. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed event rate in the control group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>median1</code></dt><dd><p>The assumed median survival time in the treatment group. Is a numeric vector.</p>
</dd>
<dt><code>median2</code></dt><dd><p>The assumed median survival time in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>eventTime</code></dt><dd><p>The assumed time under which the event rates are calculated. Is a numeric vector of length 1.</p>
</dd>
<dt><code>kappa</code></dt><dd><p>The shape of the Weibull distribution if <code>kappa!=1</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>piecewiseSurvivalEnabled</code></dt><dd><p>Indicates whether specification of piecewise definition of survival time is selected. Is a logical vector of length 1.</p>
</dd>
<dt><code>delayedResponseAllowed</code></dt><dd><p>If <code>TRUE</code>, delayed response is allowed, if <code>FALSE</code> the response is not delayed.</p>
</dd>
<dt><code>delayedResponseEnabled</code></dt><dd><p>If <code>TRUE</code>, delayed response is enabled, if <code>FALSE</code> delayed response is not enabled.</p>
</dd>
</dl>

<hr>
<h2 id='plot.AnalysisResults'>Analysis Results Plotting</h2><span id='topic+plot.AnalysisResults'></span>

<h3>Description</h3>

<p>Plots the conditional power together with the likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnalysisResults'
plot(
  x,
  y,
  ...,
  type = 1L,
  nPlanned = NA_real_,
  allocationRatioPlanned = NA_real_,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  legendTitle = NA_character_,
  palette = "Set1",
  legendPosition = NA_integer_,
  showSource = FALSE,
  grid = 1,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.AnalysisResults_+3A_x">x</code></td>
<td>
<p>The analysis results at given stage, obtained from <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_...">...</code></td>
<td>
<p>Optional <a href="#topic+param_three_dots_plot">plot arguments</a>. Furthermore the following arguments can be defined:
</p>

<ul>
<li> <p><code>thetaRange</code>: A range of assumed effect sizes if testing means or a survival design was specified.
Additionally, if testing means was selected, <code>assumedStDev</code> (assumed standard deviation)
can be specified (default is <code>1</code>).
</p>
</li>
<li> <p><code>piTreatmentRange</code>: A range of assumed rates pi1 to calculate the conditional power.
Additionally, if a two-sample comparison was selected, <code>pi2</code> can be specified (default is the value from
<code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>).
</p>
</li>
<li> <p><code>directionUpper</code>: Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.
</p>
</li>
<li> <p><code><a href="#topic+param_thetaH0">thetaH0</a></code>: The null hypothesis value, default is <code>0</code> for
the normal and the binary case, it is <code>1</code> for the survival case.
For testing a rate in one sample, a value thetaH0 in (0, 1) has to be specified for
defining the null hypothesis H0: <code>pi = thetaH0</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_type">type</code></td>
<td>
<p>The plot type (default = 1). Note that at the moment only one type (the conditional power plot) is available.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_nplanned">nPlanned</code></td>
<td>
<p>The additional (i.e., &quot;new&quot; and not cumulative) sample size planned for each of the subsequent stages.
The argument must be a vector with length equal to the number of remaining stages and contain
the combined sample size from both treatment groups if two groups are considered. For survival outcomes,
it should contain the planned number of additional events.
For multi-arm designs, it is the per-comparison (combined) sample size.
For enrichment designs, it is the (combined) sample size for the considered sub-population.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_main">main</code></td>
<td>
<p>The main title, default is <code>"Dataset"</code>.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label, default is <code>"Stage"</code>.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_legendtitle">legendTitle</code></td>
<td>
<p>The legend title, default is <code>""</code>.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_grid">grid</code></td>
<td>
<p>An integer value specifying the output of multiple plots.
By default (<code>1</code>) a list of <code>ggplot</code> objects will be returned.
If a <code>grid</code> value &gt; 1 was specified, a grid plot will be returned
if the number of plots is &lt;= specified <code>grid</code> value;
a list of <code>ggplot</code> objects will be returned otherwise.
If <code>grid = 0</code> is specified, all plots will be created using <code><a href="base.html#topic+print">print</a></code> command
and a list of <code>ggplot</code> objects will be returned invisible.
Note that one of the following packages must be installed to create a grid plot:
'ggpubr', 'gridExtra', or 'cowplot'.</p>
</td></tr>
<tr><td><code id="plot.AnalysisResults_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional power is calculated only if effect size and sample size is specified.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignGroupSequential(kMax = 2)

dataExample &lt;- getDataset(
    n = c(20, 30),
    means = c(50, 51),
    stDevs = c(130, 140)
)

result &lt;- getAnalysisResults(design = design, 
    dataInput = dataExample, thetaH0 = 20, 
    nPlanned = c(30), thetaH1 = 1.5, stage = 1) 

if (require(ggplot2)) plot(result, thetaRange = c(0, 100))

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.Dataset'>Dataset Plotting</h2><span id='topic+plot.Dataset'></span>

<h3>Description</h3>

<p>Plots a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Dataset'
plot(
  x,
  y,
  ...,
  main = "Dataset",
  xlab = "Stage",
  ylab = NA_character_,
  legendTitle = "Group",
  palette = "Set1",
  showSource = FALSE,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Dataset_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+Dataset">Dataset</a></code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible
to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_main">main</code></td>
<td>
<p>The main title, default is <code>"Dataset"</code>.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label, default is <code>"Stage"</code>.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_legendtitle">legendTitle</code></td>
<td>
<p>The legend title, default is <code>"Group"</code>.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.Dataset_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot all kinds of datasets.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plot a dataset of means
dataExample &lt;- getDataset(
    n1 = c(22, 11, 22, 11),
    n2 = c(22, 13, 22, 13),
    means1 = c(1, 1.1, 1, 1),
    means2 = c(1.4, 1.5, 3, 2.5),
    stDevs1 = c(1, 2, 2, 1.3),
    stDevs2 = c(1, 2, 2, 1.3)
)
if (require(ggplot2)) plot(dataExample, main = "Comparison of Means")

# Plot a dataset of rates
dataExample &lt;- getDataset(
    n1 = c(8, 10, 9, 11),
    n2 = c(11, 13, 12, 13),
    events1 = c(3, 5, 5, 6),
    events2 = c(8, 10, 12, 12)
)
if (require(ggplot2)) plot(dataExample, main = "Comparison of Rates")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.EventProbabilities'>Event Probabilities Plotting</h2><span id='topic+plot.EventProbabilities'></span>

<h3>Description</h3>

<p>Plots an object that inherits from class <code><a href="#topic+EventProbabilities">EventProbabilities</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EventProbabilities'
plot(
  x,
  y,
  ...,
  allocationRatioPlanned = x$allocationRatioPlanned,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  type = 1L,
  legendTitle = NA_character_,
  palette = "Set1",
  plotPointsEnabled = NA,
  legendPosition = NA_integer_,
  showSource = FALSE,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.EventProbabilities_+3A_x">x</code></td>
<td>
<p>The object that inherits from <code><a href="#topic+EventProbabilities">EventProbabilities</a></code>.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_y">y</code></td>
<td>
<p>An optional object that inherits from <code><a href="#topic+NumberOfSubjects">NumberOfSubjects</a></code>.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_type">type</code></td>
<td>
<p>The plot type (default = 1). Note that at the moment only one type is available.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_legendtitle">legendTitle</code></td>
<td>
<p>The legend title, default is <code>""</code>.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_plotpointsenabled">plotPointsEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional points will be plotted.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.EventProbabilities_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot an event probabilities object.
</p>
<p>Generic function to plot an event probabilities object.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>

<hr>
<h2 id='plot.NumberOfSubjects'>Number Of Subjects Plotting</h2><span id='topic+plot.NumberOfSubjects'></span>

<h3>Description</h3>

<p>Plots an object that inherits from class <code><a href="#topic+NumberOfSubjects">NumberOfSubjects</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NumberOfSubjects'
plot(
  x,
  y,
  ...,
  allocationRatioPlanned = NA_real_,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  type = 1L,
  legendTitle = NA_character_,
  palette = "Set1",
  plotPointsEnabled = NA,
  legendPosition = NA_integer_,
  showSource = FALSE,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.NumberOfSubjects_+3A_x">x</code></td>
<td>
<p>The object that inherits from <code><a href="#topic+NumberOfSubjects">NumberOfSubjects</a></code>.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_y">y</code></td>
<td>
<p>An optional object that inherits from <code><a href="#topic+EventProbabilities">EventProbabilities</a></code>.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. Will be ignored if <code>y</code> is undefined.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_type">type</code></td>
<td>
<p>The plot type (default = 1). Note that at the moment only one type is available.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_legendtitle">legendTitle</code></td>
<td>
<p>The legend title, default is <code>""</code>.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_plotpointsenabled">plotPointsEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional points will be plotted.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.NumberOfSubjects_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot an &quot;number of subjects&quot; object.
</p>
<p>Generic function to plot a &quot;number of subjects&quot; object.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>

<hr>
<h2 id='plot.ParameterSet'>Parameter Set Plotting</h2><span id='topic+plot.ParameterSet'></span>

<h3>Description</h3>

<p>Plots an object that inherits from class <code><a href="#topic+ParameterSet">ParameterSet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ParameterSet'
plot(
  x,
  y,
  ...,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  type = 1L,
  palette = "Set1",
  legendPosition = NA_integer_,
  showSource = FALSE,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ParameterSet_+3A_x">x</code></td>
<td>
<p>The object that inherits from <code><a href="#topic+ParameterSet">ParameterSet</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_type">type</code></td>
<td>
<p>The plot type (default = 1).</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.ParameterSet_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot a parameter set.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>

<hr>
<h2 id='plot.SimulationResults'>Simulation Results Plotting</h2><span id='topic+plot.SimulationResults'></span>

<h3>Description</h3>

<p>Plots simulation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimulationResults'
plot(
  x,
  y,
  ...,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  type = NA_integer_,
  palette = "Set1",
  theta = seq(-1, 1, 0.01),
  plotPointsEnabled = NA,
  legendPosition = NA_integer_,
  showSource = FALSE,
  grid = 1,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.SimulationResults_+3A_x">x</code></td>
<td>
<p>The simulation results, obtained from <br />
<code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_type">type</code></td>
<td>
<p>The plot type (default = <code>1</code>). The following plot types are available:
</p>

<ul>
<li> <p><code>1</code>: creates a 'Overall Success' plot (multi-arm and enrichment only)
</p>
</li>
<li> <p><code>2</code>: creates a 'Success per Stage' plot (multi-arm and enrichment  only)
</p>
</li>
<li> <p><code>3</code>: creates a 'Selected Arms per Stage' plot (multi-arm and enrichment  only)
</p>
</li>
<li> <p><code>4</code>: creates a 'Reject per Stage' or 'Rejected Arms per Stage' plot
</p>
</li>
<li> <p><code>5</code>: creates a 'Overall Power and Early Stopping' plot
</p>
</li>
<li> <p><code>6</code>: creates a 'Expected Number of Subjects and Power / Early Stop' or
'Expected Number of Events and Power / Early Stop' plot
</p>
</li>
<li> <p><code>7</code>: creates an 'Overall Power' plot
</p>
</li>
<li> <p><code>8</code>: creates an 'Overall Early Stopping' plot
</p>
</li>
<li> <p><code>9</code>: creates an 'Expected Sample Size' or 'Expected Number of Events' plot
</p>
</li>
<li> <p><code>10</code>: creates a 'Study Duration' plot (non-multi-arm and non-enrichment survival only)
</p>
</li>
<li> <p><code>11</code>: creates an 'Expected Number of Subjects' plot (non-multi-arm and non-enrichment survival only)
</p>
</li>
<li> <p><code>12</code>: creates an 'Analysis Times' plot (non-multi-arm and non-enrichment survival only)
</p>
</li>
<li> <p><code>13</code>: creates a 'Cumulative Distribution Function' plot (non-multi-arm and non-enrichment survival only)
</p>
</li>
<li> <p><code>14</code>: creates a 'Survival Function' plot (non-multi-arm and non-enrichment survival only)
</p>
</li>
<li> <p><code>"all"</code>: creates all available plots and returns it as a grid plot or list
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_theta">theta</code></td>
<td>
<p>A vector of standardized effect sizes (theta values), default is a sequence from -1 to 1.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_plotpointsenabled">plotPointsEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional points will be plotted.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_grid">grid</code></td>
<td>
<p>An integer value specifying the output of multiple plots.
By default (<code>1</code>) a list of <code>ggplot</code> objects will be returned.
If a <code>grid</code> value &gt; 1 was specified, a grid plot will be returned
if the number of plots is &lt;= specified <code>grid</code> value;
a list of <code>ggplot</code> objects will be returned otherwise.
If <code>grid = 0</code> is specified, all plots will be created using <code><a href="base.html#topic+print">print</a></code> command
and a list of <code>ggplot</code> objects will be returned invisible.
Note that one of the following packages must be installed to create a grid plot:
'ggpubr', 'gridExtra', or 'cowplot'.</p>
</td></tr>
<tr><td><code id="plot.SimulationResults_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot all kinds of simulation results.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
results &lt;- getSimulationMeans(
    alternative = 0:4, stDev = 5,
    plannedSubjects = 40, maxNumberOfIterations = 1000
)
plot(results, type = 5)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.StageResults'>Stage Results Plotting</h2><span id='topic+plot.StageResults'></span>

<h3>Description</h3>

<p>Plots the conditional power together with the likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StageResults'
plot(
  x,
  y,
  ...,
  type = 1L,
  nPlanned,
  allocationRatioPlanned = 1,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  legendTitle = NA_character_,
  palette = "Set1",
  legendPosition = NA_integer_,
  showSource = FALSE,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.StageResults_+3A_x">x</code></td>
<td>
<p>The stage results at given stage, obtained from <code><a href="#topic+getStageResults">getStageResults()</a></code> or
<code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_...">...</code></td>
<td>
<p>Optional <a href="#topic+param_three_dots_plot">plot arguments</a>. Furthermore the following arguments can be defined:
</p>

<ul>
<li> <p><code>thetaRange</code>: A range of assumed effect sizes if testing means or a survival design was specified.
Additionally, if testing means was selected, an assumed standard deviation can be specified (default is 1).
</p>
</li>
<li> <p><code>piTreatmentRange</code>: A range of assumed rates pi1 to calculate the conditional power.
Additionally, if a two-sample comparison was selected, pi2 can be specified (default is the value from
<code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code>).
</p>
</li>
<li> <p><code>directionUpper</code>: Specifies the direction of the alternative,
only applicable for one-sided testing; default is <code>TRUE</code>
which means that larger values of the test statistics yield smaller p-values.
</p>
</li>
<li> <p><code><a href="#topic+param_thetaH0">thetaH0</a></code>: The null hypothesis value, default is 0 for the normal and the binary case,
it is 1 for the survival case.
For testing a rate in one sample, a value thetaH0 in (0,1) has to be specified for
defining the null hypothesis H0: pi = thetaH0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_type">type</code></td>
<td>
<p>The plot type (default = 1). Note that at the moment only one type
(the conditional power plot) is available.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_nplanned">nPlanned</code></td>
<td>
<p>The additional (i.e., &quot;new&quot; and not cumulative) sample size planned for each of the subsequent stages.
The argument must be a vector with length equal to the number of remaining stages and contain
the combined sample size from both treatment groups if two groups are considered. For survival outcomes,
it should contain the planned number of additional events.
For multi-arm designs, it is the per-comparison (combined) sample size.
For enrichment designs, it is the (combined) sample size for the considered sub-population.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_allocationratioplanned">allocationRatioPlanned</code></td>
<td>
<p>The planned allocation ratio <code>n1 / n2</code> for a two treatment groups
design, default is <code>1</code>. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control.
For simulating means and rates for a two treatment groups design, it can be a vector of length <code>kMax</code>, the number of stages.
It can be a vector of length kMax, too, for multi-arm and enrichment designs.
In these cases, a change of allocating subjects to treatment groups over the stages can be assessed.
Note that internally <code>allocationRatioPlanned</code> is treated as a vector of length <code>kMax</code>, not a scalar.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_legendtitle">legendTitle</code></td>
<td>
<p>The legend title.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.StageResults_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot all kinds of stage results.
The conditional power is calculated only if effect size and sample size is specified.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignGroupSequential(
    kMax = 4, alpha = 0.025,
    informationRates = c(0.2, 0.5, 0.8, 1),
    typeOfDesign = "WT", deltaWT = 0.25
)
dataExample &lt;- getDataset(
    n = c(20, 30, 30),
    means = c(50, 51, 55),
    stDevs = c(130, 140, 120)
)
stageResults &lt;- getStageResults(design, dataExample, thetaH0 = 20)
if (require(ggplot2)) plot(stageResults, nPlanned = c(30), thetaRange = c(0, 100))

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.SummaryFactory'>Summary Factory Plotting</h2><span id='topic+plot.SummaryFactory'></span>

<h3>Description</h3>

<p>Plots a summary factory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SummaryFactory'
plot(x, y, ..., showSummary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.SummaryFactory_+3A_x">x</code></td>
<td>
<p>The summary factory object.</p>
</td></tr>
<tr><td><code id="plot.SummaryFactory_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined
to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.SummaryFactory_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.SummaryFactory_+3A_showsummary">showSummary</code></td>
<td>
<p>Show the summary before creating the
plot output, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot all kinds of summary factories.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>

<hr>
<h2 id='plot.TrialDesign'>Trial Design Plotting</h2><span id='topic+plot.TrialDesign'></span><span id='topic+plot.TrialDesignCharacteristics'></span>

<h3>Description</h3>

<p>Plots a trial design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesign'
plot(
  x,
  y,
  ...,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  type = 1L,
  palette = "Set1",
  theta = seq(-1, 1, 0.01),
  nMax = NA_integer_,
  plotPointsEnabled = NA,
  legendPosition = NA_integer_,
  showSource = FALSE,
  grid = 1,
  plotSettings = NULL
)

## S3 method for class 'TrialDesignCharacteristics'
plot(x, y, ..., type = 1L, grid = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.TrialDesign_+3A_x">x</code></td>
<td>
<p>The trial design, obtained from <br />
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential()</a></code>, <br />
<code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal()</a></code> or <br />
<code><a href="#topic+getDesignFisher">getDesignFisher()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_type">type</code></td>
<td>
<p>The plot type (default = <code>1</code>). The following plot types are available:
</p>

<ul>
<li> <p><code>1</code>: creates a 'Boundaries' plot
</p>
</li>
<li> <p><code>3</code>: creates a 'Stage Levels' plot
</p>
</li>
<li> <p><code>4</code>: creates a 'Error Spending' plot
</p>
</li>
<li> <p><code>5</code>: creates a 'Power and Early Stopping' plot
</p>
</li>
<li> <p><code>6</code>: creates an 'Average Sample Size and Power / Early Stop' plot
</p>
</li>
<li> <p><code>7</code>: creates an 'Power' plot
</p>
</li>
<li> <p><code>8</code>: creates an 'Early Stopping' plot
</p>
</li>
<li> <p><code>9</code>: creates an 'Average Sample Size' plot
</p>
</li>
<li> <p><code>"all"</code>: creates all available plots and returns it as a grid plot or list
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_theta">theta</code></td>
<td>
<p>A vector of standardized effect sizes (theta values), default is a sequence from -1 to 1.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_nmax">nMax</code></td>
<td>
<p>The maximum sample size. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_plotpointsenabled">plotPointsEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional points will be plotted.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_grid">grid</code></td>
<td>
<p>An integer value specifying the output of multiple plots.
By default (<code>1</code>) a list of <code>ggplot</code> objects will be returned.
If a <code>grid</code> value &gt; 1 was specified, a grid plot will be returned
if the number of plots is &lt;= specified <code>grid</code> value;
a list of <code>ggplot</code> objects will be returned otherwise.
If <code>grid = 0</code> is specified, all plots will be created using <code><a href="base.html#topic+print">print</a></code> command
and a list of <code>ggplot</code> objects will be returned invisible.
Note that one of the following packages must be installed to create a grid plot:
'ggpubr', 'gridExtra', or 'cowplot'.</p>
</td></tr>
<tr><td><code id="plot.TrialDesign_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot a trial design.
</p>
<p>Generic function to plot a trial design.
</p>
<p>Note that <code><a href="#topic+param_nMax">nMax</a></code> is not an argument that it passed to <code>ggplot2</code>.
Rather, the underlying calculations (e.g. power for different theta's or average sample size) are based
on calls to function <code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber()</a></code>
which has argument <code><a href="#topic+param_nMax">nMax</a></code>.
I.e., <code><a href="#topic+param_nMax">nMax</a></code> is not an argument to ggplot2 but to
<code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber()</a></code>
which is called prior to plotting.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.TrialDesignSet">plot()</a></code> to compare different designs or design parameters visual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(
    kMax = 3, alpha = 0.025,
    typeOfDesign = "asKD", gammaA = 2,
    informationRates = c(0.2, 0.7, 1),
    typeBetaSpending = "bsOF"
)
if (require(ggplot2)) {
    plot(design) # default: type = 1
}

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.TrialDesignPlan'>Trial Design Plan Plotting</h2><span id='topic+plot.TrialDesignPlan'></span>

<h3>Description</h3>

<p>Plots a trial design plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignPlan'
plot(
  x,
  y,
  ...,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  type = NA_integer_,
  palette = "Set1",
  theta = NA_real_,
  plotPointsEnabled = NA,
  legendPosition = NA_integer_,
  showSource = FALSE,
  grid = 1,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.TrialDesignPlan_+3A_x">x</code></td>
<td>
<p>The trial design plan, obtained from <br />
<code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans()</a></code>, <br />
<code><a href="#topic+getSampleSizeRates">getSampleSizeRates()</a></code>, <br />
<code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival()</a></code>, <br />
<code><a href="#topic+getSampleSizeCounts">getSampleSizeCounts()</a></code>, <br />
<code><a href="#topic+getPowerMeans">getPowerMeans()</a></code>, <br />
<code><a href="#topic+getPowerRates">getPowerRates()</a></code> or <br />
<code><a href="#topic+getPowerSurvival">getPowerSurvival()</a></code> or <br />
<code><a href="#topic+getPowerCounts">getPowerCounts()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_type">type</code></td>
<td>
<p>The plot type (default = <code>1</code>). The following plot types are available:
</p>

<ul>
<li> <p><code>1</code>: creates a 'Boundaries' plot
</p>
</li>
<li> <p><code>2</code>: creates a 'Boundaries Effect Scale' plot
</p>
</li>
<li> <p><code>3</code>: creates a 'Boundaries p Values Scale' plot
</p>
</li>
<li> <p><code>4</code>: creates a 'Error Spending' plot
</p>
</li>
<li> <p><code>5</code>: creates a 'Sample Size' or 'Overall Power and Early Stopping' plot
</p>
</li>
<li> <p><code>6</code>: creates a 'Number of Events' or 'Sample Size' plot
</p>
</li>
<li> <p><code>7</code>: creates an 'Overall Power' plot
</p>
</li>
<li> <p><code>8</code>: creates an 'Overall Early Stopping' plot
</p>
</li>
<li> <p><code>9</code>: creates an 'Expected Number of Events' or 'Expected Sample Size' plot
</p>
</li>
<li> <p><code>10</code>: creates a 'Study Duration' plot
</p>
</li>
<li> <p><code>11</code>: creates an 'Expected Number of Subjects' plot
</p>
</li>
<li> <p><code>12</code>: creates an 'Analysis Times' plot
</p>
</li>
<li> <p><code>13</code>: creates a 'Cumulative Distribution Function' plot
</p>
</li>
<li> <p><code>14</code>: creates a 'Survival Function' plot
</p>
</li>
<li> <p><code>"all"</code>: creates all available plots and returns it as a grid plot or list
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_theta">theta</code></td>
<td>
<p>A vector of standardized effect sizes (theta values), default is a sequence from -1 to 1.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_plotpointsenabled">plotPointsEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional points will be plotted.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_grid">grid</code></td>
<td>
<p>An integer value specifying the output of multiple plots.
By default (<code>1</code>) a list of <code>ggplot</code> objects will be returned.
If a <code>grid</code> value &gt; 1 was specified, a grid plot will be returned
if the number of plots is &lt;= specified <code>grid</code> value;
a list of <code>ggplot</code> objects will be returned otherwise.
If <code>grid = 0</code> is specified, all plots will be created using <code><a href="base.html#topic+print">print</a></code> command
and a list of <code>ggplot</code> objects will be returned invisible.
Note that one of the following packages must be installed to create a grid plot:
'ggpubr', 'gridExtra', or 'cowplot'.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignPlan_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot all kinds of trial design plans.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(ggplot2)) plot(getSampleSizeMeans())

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.TrialDesignSet'>Trial Design Set Plotting</h2><span id='topic+plot.TrialDesignSet'></span>

<h3>Description</h3>

<p>Plots a trial design set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignSet'
plot(
  x,
  y,
  ...,
  type = 1L,
  main = NA_character_,
  xlab = NA_character_,
  ylab = NA_character_,
  palette = "Set1",
  theta = seq(-1, 1, 0.02),
  nMax = NA_integer_,
  plotPointsEnabled = NA,
  legendPosition = NA_integer_,
  showSource = FALSE,
  grid = 1,
  plotSettings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.TrialDesignSet_+3A_x">x</code></td>
<td>
<p>The trial design set, obtained from <code><a href="#topic+getDesignSet">getDesignSet()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_y">y</code></td>
<td>
<p>Not available for this kind of plot (is only defined to be compatible to the generic plot function).</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_type">type</code></td>
<td>
<p>The plot type (default = <code>1</code>). The following plot types are available:
</p>

<ul>
<li> <p><code>1</code>: creates a 'Boundaries' plot
</p>
</li>
<li> <p><code>3</code>: creates a 'Stage Levels' plot
</p>
</li>
<li> <p><code>4</code>: creates a 'Error Spending' plot
</p>
</li>
<li> <p><code>5</code>: creates a 'Power and Early Stopping' plot
</p>
</li>
<li> <p><code>6</code>: creates an 'Average Sample Size and Power / Early Stop' plot
</p>
</li>
<li> <p><code>7</code>: creates an 'Power' plot
</p>
</li>
<li> <p><code>8</code>: creates an 'Early Stopping' plot
</p>
</li>
<li> <p><code>9</code>: creates an 'Average Sample Size' plot
</p>
</li>
<li> <p><code>"all"</code>: creates all available plots and returns it as a grid plot or list
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_palette">palette</code></td>
<td>
<p>The palette, default is <code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_theta">theta</code></td>
<td>
<p>A vector of standardized effect sizes (theta values), default is a sequence from -1 to 1.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_nmax">nMax</code></td>
<td>
<p>The maximum sample size. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_plotpointsenabled">plotPointsEnabled</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional points will be plotted.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_legendposition">legendPosition</code></td>
<td>
<p>The position of the legend.
By default (<code>NA_integer_</code>) the algorithm tries to find a suitable position.
Choose one of the following values to specify the position manually:
</p>

<ul>
<li> <p><code>-1</code>: no legend will be shown
</p>
</li>
<li> <p><code>NA</code>: the algorithm tries to find a suitable position
</p>
</li>
<li> <p><code>0</code>: legend position outside plot
</p>
</li>
<li> <p><code>1</code>: legend position left top
</p>
</li>
<li> <p><code>2</code>: legend position left center
</p>
</li>
<li> <p><code>3</code>: legend position left bottom
</p>
</li>
<li> <p><code>4</code>: legend position right top
</p>
</li>
<li> <p><code>5</code>: legend position right center
</p>
</li>
<li> <p><code>6</code>: legend position right bottom
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_showsource">showSource</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the parameter names of the object will
be printed which were used to create the plot; that may be, e.g.,
useful to check the values or to create own plots with the base R <code>plot</code> function.
Alternatively <code>showSource</code> can be defined as one of the following character values:
</p>

<ul>
<li> <p><code>"commands"</code>: returns a character vector with plot commands
</p>
</li>
<li> <p><code>"axes"</code>: returns a list with the axes definitions
</p>
</li>
<li> <p><code>"test"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function does not stop if an error occurs)
</p>
</li>
<li> <p><code>"validate"</code>: all plot commands will be validated with <code>eval(parse())</code> and
returned as character vector (function stops if an error occurs)
</p>
</li></ul>

<p>Note: no plot object will be returned if <code>showSource</code> is a character.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_grid">grid</code></td>
<td>
<p>An integer value specifying the output of multiple plots.
By default (<code>1</code>) a list of <code>ggplot</code> objects will be returned.
If a <code>grid</code> value &gt; 1 was specified, a grid plot will be returned
if the number of plots is &lt;= specified <code>grid</code> value;
a list of <code>ggplot</code> objects will be returned otherwise.
If <code>grid = 0</code> is specified, all plots will be created using <code><a href="base.html#topic+print">print</a></code> command
and a list of <code>ggplot</code> objects will be returned invisible.
Note that one of the following packages must be installed to create a grid plot:
'ggpubr', 'gridExtra', or 'cowplot'.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSet_+3A_plotsettings">plotSettings</code></td>
<td>
<p>An object of class <code>PlotSettings</code> created by <code><a href="#topic+getPlotSettings">getPlotSettings()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to plot a trial design set.
Is, e.g., useful to compare different designs or design parameters visual.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(
    kMax = 3, alpha = 0.025,
    typeOfDesign = "asKD", gammaA = 2,
    informationRates = c(0.2, 0.7, 1), typeBetaSpending = "bsOF"
)

# Create a set of designs based on the master design defined above
# and varied parameter 'gammaA'
designSet &lt;- getDesignSet(design = design, gammaA = 4)

if (require(ggplot2)) plot(designSet, type = 1, legendPosition = 6)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.TrialDesignSummaries'>Plot Trial Design Summaries</h2><span id='topic+plot.TrialDesignSummaries'></span>

<h3>Description</h3>

<p>Generic function to plot a <code>TrialDesignSummaries</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignSummaries'
plot(x, ..., type = 1L, grid = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.TrialDesignSummaries_+3A_x">x</code></td>
<td>
<p>a <code>TrialDesignSummaries</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSummaries_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="plot.TrialDesignSummaries_+3A_type">type</code></td>
<td>
<p>The plot type (default = <code>1</code>). The following plot types are available:
</p>

<ul>
<li> <p><code>1</code>: creates a 'Boundaries' plot
</p>
</li>
<li> <p><code>3</code>: creates a 'Stage Levels' plot
</p>
</li>
<li> <p><code>4</code>: creates a 'Error Spending' plot
</p>
</li>
<li> <p><code>5</code>: creates a 'Power and Early Stopping' plot
</p>
</li>
<li> <p><code>6</code>: creates an 'Average Sample Size and Power / Early Stop' plot
</p>
</li>
<li> <p><code>7</code>: creates an 'Power' plot
</p>
</li>
<li> <p><code>8</code>: creates an 'Early Stopping' plot
</p>
</li>
<li> <p><code>9</code>: creates an 'Average Sample Size' plot
</p>
</li>
<li> <p><code>"all"</code>: creates all available plots and returns it as a grid plot or list
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.TrialDesignSummaries_+3A_grid">grid</code></td>
<td>
<p>An integer value specifying the output of multiple plots.
By default (<code>1</code>) a list of <code>ggplot</code> objects will be returned.
If a <code>grid</code> value &gt; 1 was specified, a grid plot will be returned
if the number of plots is &lt;= specified <code>grid</code> value;
a list of <code>ggplot</code> objects will be returned otherwise.
If <code>grid = 0</code> is specified, all plots will be created using <code><a href="base.html#topic+print">print</a></code> command
and a list of <code>ggplot</code> objects will be returned invisible.
Note that one of the following packages must be installed to create a grid plot:
'ggpubr', 'gridExtra', or 'cowplot'.</p>
</td></tr>
</table>

<hr>
<h2 id='PlotSettings'>Plot Settings</h2><span id='topic+PlotSettings'></span>

<h3>Description</h3>

<p>Class for plot settings.
</p>


<h3>Details</h3>

<p>Collects typical plot settings in an object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>lineSize</code></dt><dd><p>The line size.</p>
</dd>
<dt><code>pointSize</code></dt><dd><p>The point size.</p>
</dd>
<dt><code>pointColor</code></dt><dd><p>The point color, e.g., &quot;red&quot; or &quot;blue&quot;.</p>
</dd>
<dt><code>mainTitleFontSize</code></dt><dd><p>The main tile font size.</p>
</dd>
<dt><code>axesTextFontSize</code></dt><dd><p>The text font size.</p>
</dd>
<dt><code>legendFontSize</code></dt><dd><p>The legend font size.</p>
</dd>
<dt><code>scalingFactor</code></dt><dd><p>The scaling factor.</p>
</dd>
</dl>

<hr>
<h2 id='plotTypes'>Get Available Plot Types</h2><span id='topic+plotTypes'></span><span id='topic+getAvailablePlotTypes'></span>

<h3>Description</h3>

<p>Function to identify the available plot types of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTypes(
  obj,
  output = c("numeric", "caption", "numcap", "capnum"),
  numberInCaptionEnabled = FALSE
)

getAvailablePlotTypes(
  obj,
  output = c("numeric", "caption", "numcap", "capnum"),
  numberInCaptionEnabled = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTypes_+3A_obj">obj</code></td>
<td>
<p>The object for which the plot types shall be identified, e.g. produced by
<code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential()</a></code> or <code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans()</a></code>.</p>
</td></tr>
<tr><td><code id="plotTypes_+3A_output">output</code></td>
<td>
<p>The output type. Can be one of <code>c("numeric", "caption", "numcap", "capnum")</code>.</p>
</td></tr>
<tr><td><code id="plotTypes_+3A_numberincaptionenabled">numberInCaptionEnabled</code></td>
<td>
<p>If <code>TRUE</code>, the number will be added to the
caption, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotTypes</code> and <code>getAvailablePlotTypes()</code> are equivalent, i.e.,
<code>plotTypes</code> is a short form of <code>getAvailablePlotTypes()</code>.
</p>
<p><code>output</code>:
</p>

<ol>
<li> <p><code>numeric</code>: numeric output
</p>
</li>
<li> <p><code>caption</code>: caption as character output
</p>
</li>
<li> <p><code>numcap</code>:  list with number and caption
</p>
</li>
<li> <p><code>capnum</code>:  list with caption and number
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a list if <code>option</code> is either <code>capnum</code> or <code>numcap</code>
or returns a vector that is of  character type for <code>option=caption</code> or
of numeric type for <code>option=numeric</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
design &lt;- getDesignInverseNormal(kMax = 2)
getAvailablePlotTypes(design, "numeric")
plotTypes(design, "caption")
getAvailablePlotTypes(design, "numcap")
plotTypes(design, "capnum")

## End(Not run)

</code></pre>

<hr>
<h2 id='PowerAndAverageSampleNumberResult'>Power and Average Sample Number Result</h2><span id='topic+PowerAndAverageSampleNumberResult'></span>

<h3>Description</h3>

<p>Class for power and average sample number (ASN) results.
</p>


<h3>Details</h3>

<p>This object cannot be created directly;
use <code><a href="#topic+getPowerAndAverageSampleNumber">getPowerAndAverageSampleNumber()</a></code>
with suitable arguments to create it.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nMax</code></dt><dd><p>The maximum sample size. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>theta</code></dt><dd><p>A vector of standardized effect sizes (theta values). Is a numeric vector.</p>
</dd>
<dt><code>averageSampleNumber</code></dt><dd><p>The average sample number calculated for each value of <code>theta</code> or <code>nMax</code>, if the specified maximum sample size would be exceeded. Is a numeric vector.</p>
</dd>
<dt><code>calculatedPower</code></dt><dd><p>The calculated power for the given scenario.</p>
</dd>
<dt><code>overallEarlyStop</code></dt><dd><p>The overall early stopping probability. Is a numeric vector.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>overallFutility</code></dt><dd><p>The overall stopping for futility probability. Is a numeric vector.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='print.Dataset'>Print Dataset Values</h2><span id='topic+print.Dataset'></span>

<h3>Description</h3>

<p><code>print</code> prints its <code><a href="#topic+Dataset">Dataset</a></code> argument and returns it invisibly (via <code>invisible(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Dataset'
print(
  x,
  ...,
  markdown = NA,
  output = c("list", "long", "wide", "r", "rComplete")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Dataset_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+Dataset">Dataset</a></code> object.</p>
</td></tr>
<tr><td><code id="print.Dataset_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="print.Dataset_+3A_markdown">markdown</code></td>
<td>
<p>If <code>TRUE</code>, the output will be created in Markdown.</p>
</td></tr>
<tr><td><code id="print.Dataset_+3A_output">output</code></td>
<td>
<p>A character defining the output type, default is &quot;list&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the dataset.
</p>

<hr>
<h2 id='print.FieldSet'>Print Field Set Values</h2><span id='topic+print.FieldSet'></span>

<h3>Description</h3>

<p><code>print</code> prints its <code><a href="#topic+FieldSet">FieldSet</a></code> argument and returns it invisibly (via <code>invisible(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FieldSet'
print(x, ..., markdown = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.FieldSet_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+FieldSet">FieldSet</a></code> object to print.</p>
</td></tr>
<tr><td><code id="print.FieldSet_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="print.FieldSet_+3A_markdown">markdown</code></td>
<td>
<p>If <code>TRUE</code>, the object <code>x</code> will be printed using markdown syntax;
normal representation will be used otherwise (default is <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the parameters and results of a field set.
</p>

<hr>
<h2 id='print.ParameterSet'>Print Parameter Set Values</h2><span id='topic+print.ParameterSet'></span>

<h3>Description</h3>

<p><code>print</code> prints its <code>ParameterSet</code> argument and returns it invisibly (via <code>invisible(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ParameterSet'
print(x, ..., markdown = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ParameterSet_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+ParameterSet">ParameterSet</a></code> object to print.</p>
</td></tr>
<tr><td><code id="print.ParameterSet_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="print.ParameterSet_+3A_markdown">markdown</code></td>
<td>
<p>If <code>TRUE</code>, the object <code>x</code> will be printed using markdown syntax;
normal representation will be used otherwise (default is <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the parameters and results of a parameter set.
</p>

<hr>
<h2 id='print.SimulationResults'>Print Simulation Results</h2><span id='topic+print.SimulationResults'></span>

<h3>Description</h3>

<p><code>print</code> prints its <code>SimulationResults</code> argument and
returns it invisibly (via <code>invisible(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimulationResults'
print(x, ..., showStatistics = FALSE, markdown = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.SimulationResults_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+SimulationResults">SimulationResults</a></code> object to print.</p>
</td></tr>
<tr><td><code id="print.SimulationResults_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="print.SimulationResults_+3A_markdown">markdown</code></td>
<td>
<p>If <code>TRUE</code>, the object <code>x</code>
will be printed using markdown syntax;
normal representation will be used otherwise (default is <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the parameters and results of an <code>SimulationResults</code> object.
</p>

<hr>
<h2 id='print.SummaryFactory'>Summary Factory Printing</h2><span id='topic+print.SummaryFactory'></span>

<h3>Description</h3>

<p>Prints the result object stored inside a summary factory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SummaryFactory'
print(x, ..., markdown = NA, sep = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.SummaryFactory_+3A_x">x</code></td>
<td>
<p>The summary factory object.</p>
</td></tr>
<tr><td><code id="print.SummaryFactory_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="print.SummaryFactory_+3A_markdown">markdown</code></td>
<td>
<p>If <code>TRUE</code>, the object <code>x</code>
will be printed using markdown syntax;
normal representation will be used otherwise (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="print.SummaryFactory_+3A_sep">sep</code></td>
<td>
<p>The separator line between the summary and the print output, default is <code>"\n\n-----\n\n"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to print all kinds of summary factories.
</p>

<hr>
<h2 id='print.TrialDesignCharacteristics'>Trial Design Characteristics Printing</h2><span id='topic+print.TrialDesignCharacteristics'></span>

<h3>Description</h3>

<p>Prints the design characteristics object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignCharacteristics'
print(x, ..., markdown = NA, showDesign = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.TrialDesignCharacteristics_+3A_x">x</code></td>
<td>
<p>The trial design characteristics object.</p>
</td></tr>
<tr><td><code id="print.TrialDesignCharacteristics_+3A_...">...</code></td>
<td>
<p>Optional plot arguments. At the moment <code>xlim</code> and <code>ylim</code> are implemented
for changing x or y axis limits without dropping data observations.</p>
</td></tr>
<tr><td><code id="print.TrialDesignCharacteristics_+3A_markdown">markdown</code></td>
<td>
<p>If <code>TRUE</code>, the object <code>x</code> will be printed using markdown syntax;
normal representation will be used otherwise (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="print.TrialDesignCharacteristics_+3A_showdesign">showDesign</code></td>
<td>
<p>Show the design print output above the design characteristics, default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to print all kinds of design characteristics.
</p>

<hr>
<h2 id='print.TrialDesignSummaries'>Print Trial Design Summaries</h2><span id='topic+print.TrialDesignSummaries'></span>

<h3>Description</h3>

<p>Generic function to print a <code>TrialDesignSummaries</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignSummaries'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.TrialDesignSummaries_+3A_x">x</code></td>
<td>
<p>a <code>TrialDesignSummaries</code> object to print.</p>
</td></tr>
<tr><td><code id="print.TrialDesignSummaries_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='printCitation'>Print Citation</h2><span id='topic+printCitation'></span>

<h3>Description</h3>

<p>How to cite <code>rpact</code> and <code>R</code> in publications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printCitation(inclusiveR = TRUE, language = "en", markdown = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printCitation_+3A_inclusiver">inclusiveR</code></td>
<td>
<p>If <code>TRUE</code> (default) the information on how to cite the base R system in publications will be added.</p>
</td></tr>
<tr><td><code id="printCitation_+3A_language">language</code></td>
<td>
<p>Language code to use for the output, default is &quot;en&quot;.</p>
</td></tr>
<tr><td><code id="printCitation_+3A_markdown">markdown</code></td>
<td>
<p>If <code>TRUE</code>, the output will be created in Markdown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function shows how to cite <code>rpact</code> and <code>R</code> (<code>inclusiveR = TRUE</code>) in publications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>printCitation()

</code></pre>

<hr>
<h2 id='rawDataTwoArmNormal'>Raw Dataset Of A Two Arm Continuous Outcome With Covariates</h2><span id='topic+rawDataTwoArmNormal'></span>

<h3>Description</h3>

<p>An artificial dataset that was randomly generated
with simulated normal data. The data set has six variables:
</p>

<ol>
<li><p> Subject id
</p>
</li>
<li><p> Stage number
</p>
</li>
<li><p> Group name
</p>
</li>
<li><p> An example outcome in that we are interested in
</p>
</li>
<li><p> The first covariate <em>gender</em>
</p>
</li>
<li><p> The second covariate <em>covariate</em>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>rawDataTwoArmNormal
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>


<h3>Details</h3>

<p>See the vignette &quot;Two-arm analysis for continuous data with covariates from raw data&quot;
to learn how to
</p>

<ul>
<li><p> import raw data from a csv file,
</p>
</li>
<li><p> calculate estimated adjusted (marginal) means (EMMs, least-squares means) for a linear model, and
</p>
</li>
<li><p> perform two-arm interim analyses with these data.
</p>
</li></ul>

<p>You can use <code>rawDataTwoArmNormal</code> to reproduce the examples in the vignette.
</p>

<hr>
<h2 id='rcmd'>Get Object R Code</h2><span id='topic+rcmd'></span><span id='topic+getObjectRCode'></span>

<h3>Description</h3>

<p>Returns the R source command of a result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcmd(
  obj,
  ...,
  leadingArguments = NULL,
  includeDefaultParameters = FALSE,
  stringWrapParagraphWidth = 90,
  prefix = "",
  postfix = "",
  stringWrapPrefix = "",
  newArgumentValues = list(),
  tolerance = 1e-07,
  pipeOperator = c("auto", "none", "magrittr", "R"),
  output = c("vector", "cat", "test", "markdown", "internal"),
  explicitPrint = FALSE
)

getObjectRCode(
  obj,
  ...,
  leadingArguments = NULL,
  includeDefaultParameters = FALSE,
  stringWrapParagraphWidth = 90,
  prefix = "",
  postfix = "",
  stringWrapPrefix = "",
  newArgumentValues = list(),
  tolerance = 1e-07,
  pipeOperator = c("auto", "none", "magrittr", "R"),
  output = c("vector", "cat", "test", "markdown", "internal"),
  explicitPrint = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcmd_+3A_obj">obj</code></td>
<td>
<p>The result object.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_leadingarguments">leadingArguments</code></td>
<td>
<p>A character vector with arguments that shall be inserted at the beginning of the function command,
e.g., <code>design = x</code>. Be careful with this option because the created R command may no longer be valid if used.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_includedefaultparameters">includeDefaultParameters</code></td>
<td>
<p>If <code>TRUE</code>, default parameters will be included in all <code>rpact</code> commands;
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_stringwrapparagraphwidth">stringWrapParagraphWidth</code></td>
<td>
<p>An integer value defining the number of characters after which a line break shall be inserted;
set to <code>NULL</code> to insert no line breaks.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_prefix">prefix</code></td>
<td>
<p>A character string that shall be added to the beginning of the R command.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_postfix">postfix</code></td>
<td>
<p>A character string that shall be added to the end of the R command.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_stringwrapprefix">stringWrapPrefix</code></td>
<td>
<p>A prefix character string that shall be added to each new line, typically some spaces.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_newargumentvalues">newArgumentValues</code></td>
<td>
<p>A named list with arguments that shall be renewed in the R command, e.g.,
<code>newArgumentValues = list(informationRates = c(0.5, 1))</code>.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance for defining a value as default.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_pipeoperator">pipeOperator</code></td>
<td>
<p>The pipe operator to use in the R code, default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_output">output</code></td>
<td>
<p>The output format, default is a character &quot;vector&quot;.</p>
</td></tr>
<tr><td><code id="rcmd_+3A_explicitprint">explicitPrint</code></td>
<td>
<p>Show an explicit <code>print</code> command, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+getObjectRCode">getObjectRCode()</a></code> (short: <code><a href="#topic+rcmd">rcmd()</a></code>) recreates
the R commands that result in the specified object <code>obj</code>.
<code>obj</code> must be an instance of class <code>ParameterSet</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+character">character</a></code> value or vector will be returned.
</p>

<hr>
<h2 id='readDataset'>Read Dataset</h2><span id='topic+readDataset'></span>

<h3>Description</h3>

<p>Reads a data file and returns it as dataset object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDataset(
  file,
  ...,
  header = TRUE,
  sep = ",",
  quote = "\"",
  dec = ".",
  fill = TRUE,
  comment.char = "",
  fileEncoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readDataset_+3A_file">file</code></td>
<td>
<p>A CSV file (see <code><a href="utils.html#topic+read.table">read.table</a></code>).</p>
</td></tr>
<tr><td><code id="readDataset_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="readDataset_+3A_header">header</code></td>
<td>
<p>A logical value indicating whether the file contains the names of
the variables as its first line.</p>
</td></tr>
<tr><td><code id="readDataset_+3A_sep">sep</code></td>
<td>
<p>The field separator character. Values on each line of the file are separated
by this character. If sep = &quot;,&quot; (the default for <code>readDataset</code>) the separator is a comma.</p>
</td></tr>
<tr><td><code id="readDataset_+3A_quote">quote</code></td>
<td>
<p>The set of quoting characters. To disable quoting altogether, use
quote = &quot;&quot;. See scan for the behavior on quotes embedded in quotes. Quoting is only
considered for columns read as character, which is all of them unless <code>colClasses</code> is specified.</p>
</td></tr>
<tr><td><code id="readDataset_+3A_dec">dec</code></td>
<td>
<p>The character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="readDataset_+3A_fill">fill</code></td>
<td>
<p>logical. If <code>TRUE</code> then in case the rows have unequal length, blank fields
are implicitly added.</p>
</td></tr>
<tr><td><code id="readDataset_+3A_comment.char">comment.char</code></td>
<td>
<p>character: a character vector of length one containing a single character
or an empty string. Use &quot;&quot; to turn off the interpretation of comments altogether.</p>
</td></tr>
<tr><td><code id="readDataset_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: if non-empty declares the encoding used on a file
(not a connection) so the character data can be re-encoded.
See the 'Encoding' section of the help for file, the 'R Data Import/Export Manual' and 'Note'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readDataset</code> is a wrapper function that uses <code><a href="utils.html#topic+read.table">read.table</a></code> to read the
CSV file into a data frame, transfers it from long to wide format with <code><a href="stats.html#topic+reshape">reshape</a></code>
and puts the data to <code><a href="#topic+getDataset">getDataset()</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+Dataset">Dataset</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object,
</p>
</li>
<li> <p><code><a href="#topic+summary.ParameterSet">summary()</a></code> to display a summary of the object,
</p>
</li>
<li> <p><code><a href="#topic+plot.Dataset">plot()</a></code> to plot the object,
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.ParameterSet">as.data.frame()</a></code> to coerce the object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.FieldSet">as.matrix()</a></code> to coerce the object to a <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+readDatasets">readDatasets()</a></code> for reading multiple datasets,
</p>
</li>
<li> <p><code><a href="#topic+writeDataset">writeDataset()</a></code> for writing a single dataset,
</p>
</li>
<li> <p><code><a href="#topic+writeDatasets">writeDatasets()</a></code> for writing multiple datasets.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataFileRates &lt;- system.file("extdata",
    "dataset_rates.csv",
    package = "rpact"
)
if (dataFileRates != "") {
    datasetRates &lt;- readDataset(dataFileRates)
    datasetRates
}

dataFileMeansMultiArm &lt;- system.file("extdata",
    "dataset_means_multi-arm.csv",
    package = "rpact"
)
if (dataFileMeansMultiArm != "") {
    datasetMeansMultiArm &lt;- readDataset(dataFileMeansMultiArm)
    datasetMeansMultiArm
}

dataFileRatesMultiArm &lt;- system.file("extdata",
    "dataset_rates_multi-arm.csv",
    package = "rpact"
)
if (dataFileRatesMultiArm != "") {
    datasetRatesMultiArm &lt;- readDataset(dataFileRatesMultiArm)
    datasetRatesMultiArm
}

dataFileSurvivalMultiArm &lt;- system.file("extdata",
    "dataset_survival_multi-arm.csv",
    package = "rpact"
)
if (dataFileSurvivalMultiArm != "") {
    datasetSurvivalMultiArm &lt;- readDataset(dataFileSurvivalMultiArm)
    datasetSurvivalMultiArm
}

## End(Not run)

</code></pre>

<hr>
<h2 id='readDatasets'>Read Multiple Datasets</h2><span id='topic+readDatasets'></span>

<h3>Description</h3>

<p>Reads a data file and returns it as a list of dataset objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDatasets(
  file,
  ...,
  header = TRUE,
  sep = ",",
  quote = "\"",
  dec = ".",
  fill = TRUE,
  comment.char = "",
  fileEncoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readDatasets_+3A_file">file</code></td>
<td>
<p>A CSV file (see <code><a href="utils.html#topic+read.table">read.table</a></code>).</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_header">header</code></td>
<td>
<p>A logical value indicating whether the file contains the names of
the variables as its first line.</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_sep">sep</code></td>
<td>
<p>The field separator character. Values on each line of the file are separated
by this character. If sep = &quot;,&quot; (the default for <code>readDatasets</code>) the separator is a comma.</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_quote">quote</code></td>
<td>
<p>The set of quoting characters. To disable quoting altogether, use
quote = &quot;&quot;. See scan for the behavior on quotes embedded in quotes. Quoting is only
considered for columns read as character, which is all of them unless <code>colClasses</code> is specified.</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_dec">dec</code></td>
<td>
<p>The character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_fill">fill</code></td>
<td>
<p>logical. If <code>TRUE</code> then in case the rows have unequal length, blank fields
are implicitly added.</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_comment.char">comment.char</code></td>
<td>
<p>character: a character vector of length one containing a single character
or an empty string. Use &quot;&quot; to turn off the interpretation of comments altogether.</p>
</td></tr>
<tr><td><code id="readDatasets_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: if non-empty declares the encoding used on a file
(not a connection) so the character data can be re-encoded.
See the 'Encoding' section of the help for file, the 'R Data Import/Export Manual' and 'Note'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads a file that was written by <code><a href="#topic+writeDatasets">writeDatasets()</a></code> before.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code> of <code><a href="#topic+Dataset">Dataset</a></code> objects.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+readDataset">readDataset()</a></code> for reading a single dataset,
</p>
</li>
<li> <p><code><a href="#topic+writeDatasets">writeDatasets()</a></code> for writing multiple datasets,
</p>
</li>
<li> <p><code><a href="#topic+writeDataset">writeDataset()</a></code> for writing a single dataset.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataFile &lt;- system.file("extdata", "datasets_rates.csv", package = "rpact")
if (dataFile != "") {
    datasets &lt;- readDatasets(dataFile)
    datasets
}

## End(Not run)
</code></pre>

<hr>
<h2 id='resetLogLevel'>Reset Log Level</h2><span id='topic+resetLogLevel'></span>

<h3>Description</h3>

<p>Resets the <code>rpact</code> log level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetLogLevel()
</code></pre>


<h3>Details</h3>

<p>This function resets the log level of the <code>rpact</code> internal log message
system to the default value <code>"PROGRESS"</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getLogLevel">getLogLevel()</a></code> for getting the current log level,
</p>
</li>
<li> <p><code><a href="#topic+setLogLevel">setLogLevel()</a></code> for setting the log level.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# reset log level to default value
resetLogLevel()

## End(Not run)

</code></pre>

<hr>
<h2 id='setLogLevel'>Set Log Level</h2><span id='topic+setLogLevel'></span>

<h3>Description</h3>

<p>Sets the <code>rpact</code> log level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLogLevel(
  logLevel = c("PROGRESS", "ERROR", "WARN", "INFO", "DEBUG", "TRACE", "DISABLED")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setLogLevel_+3A_loglevel">logLevel</code></td>
<td>
<p>The new log level to set. Can be one of
&quot;PROGRESS&quot;, &quot;ERROR&quot;, &quot;WARN&quot;, &quot;INFO&quot;, &quot;DEBUG&quot;, &quot;TRACE&quot;, &quot;DISABLED&quot;.
Default is &quot;PROGRESS&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets the log level of the <code>rpact</code> internal log message system.
By default only calculation progress messages will be shown on the output console,
particularly <code><a href="#topic+getAnalysisResults">getAnalysisResults()</a></code> shows this kind of messages.
The output of these messages can be disabled by setting the log level to <code>"DISABLED"</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+getLogLevel">getLogLevel()</a></code> for getting the current log level,
</p>
</li>
<li> <p><code><a href="#topic+resetLogLevel">resetLogLevel()</a></code> for resetting the log level to default.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# show debug messages
setLogLevel("DEBUG")

# disable all log messages
setLogLevel("DISABLED")

## End(Not run)

</code></pre>

<hr>
<h2 id='setOutputFormat'>Set Output Format</h2><span id='topic+setOutputFormat'></span>

<h3>Description</h3>

<p>With this function the format of the standard outputs of all <code>rpact</code>
objects can be changed and set user defined respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setOutputFormat(
  parameterName = NA_character_,
  ...,
  digits = NA_integer_,
  nsmall = NA_integer_,
  trimSingleZeros = NA,
  futilityProbabilityEnabled = NA,
  file = NA_character_,
  resetToDefault = FALSE,
  roundFunction = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setOutputFormat_+3A_parametername">parameterName</code></td>
<td>
<p>The name of the parameter whose output format shall be edited.
Leave the default <code>NA_character_</code> if
the output format of all parameters shall be edited.</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_digits">digits</code></td>
<td>
<p>How many significant digits are to be used for a numeric value.
The default, <code>NULL</code>, uses getOption(&quot;digits&quot;).
Allowed values are <code>0 &lt;= digits &lt;= 20</code>.</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_nsmall">nsmall</code></td>
<td>
<p>The minimum number of digits to the right of the decimal point in
formatting real numbers in non-scientific formats.
Allowed values are <code>0 &lt;= nsmall &lt;= 20</code>.</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_trimsinglezeros">trimSingleZeros</code></td>
<td>
<p>If <code>TRUE</code> zero values will be trimmed in the output, e.g.,
&quot;0.00&quot; will displayed as &quot;0&quot;</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_futilityprobabilityenabled">futilityProbabilityEnabled</code></td>
<td>
<p>If <code>TRUE</code> very small value (&lt; 1e-09) will
be displayed as &quot;0&quot;, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_file">file</code></td>
<td>
<p>An optional file name of an existing text file that contains output format definitions
(see Details for more information).</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_resettodefault">resetToDefault</code></td>
<td>
<p>If <code>TRUE</code> all output formats will be reset to default value.
Note that other settings will be executed afterwards if specified, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="setOutputFormat_+3A_roundfunction">roundFunction</code></td>
<td>
<p>A character value that specifies the R base round function
to use, default is <code>NA_character_</code>.
Allowed values are &quot;ceiling&quot;, &quot;floor&quot;, &quot;trunc&quot;, &quot;round&quot;, &quot;signif&quot;, and <code>NA_character_</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output formats can be written to a text file (see <code><a href="#topic+getOutputFormat">getOutputFormat()</a></code>).
To load your personal output formats read a formerly saved file at the beginning of your
work with <code>rpact</code>, e.g. execute <code>setOutputFormat(file = "my_rpact_output_formats.txt")</code>.
</p>
<p>Note that the <code>parameterName</code> must not match exactly, e.g., for p-values the
following parameter names will be recognized amongst others:
</p>

<ol>
<li> <p><code>p value</code>
</p>
</li>
<li> <p><code>p.values</code>
</p>
</li>
<li> <p><code>p-value</code>
</p>
</li>
<li> <p><code>pValue</code>
</p>
</li>
<li> <p><code>rpact.output.format.p.value</code>
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="base.html#topic+format">format</a></code> for details on the
function used internally to format the values.
</p>
<p>Other output formats: 
<code><a href="#topic+getOutputFormat">getOutputFormat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# show output format of p values
getOutputFormat("p.value")

# set new p value output format
setOutputFormat("p.value", digits = 5, nsmall = 5)

# show sample sizes as smallest integers not less than the not rounded values
setOutputFormat("sample size", digits = 0, nsmall = 0, roundFunction = "ceiling")
getSampleSizeMeans()

# show sample sizes as smallest integers not greater than the not rounded values
setOutputFormat("sample size", digits = 0, nsmall = 0, roundFunction = "floor")
getSampleSizeMeans()

# set new sample size output format without round function
setOutputFormat("sample size", digits = 2, nsmall = 2)
getSampleSizeMeans()

# reset sample size output format to default
setOutputFormat("sample size")
getSampleSizeMeans()
getOutputFormat("sample size")

## End(Not run)
</code></pre>

<hr>
<h2 id='SimulationResults'>Class for Simulation Results</h2><span id='topic+SimulationResults'></span>

<h3>Description</h3>

<p>A class for simulation results.
</p>


<h3>Details</h3>

<p><code>SimulationResults</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+SimulationResultsMeans">SimulationResultsMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsRates">SimulationResultsRates</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsSurvival">SimulationResultsSurvival</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsCountData">SimulationResultsCountData</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsMultiArmMeans">SimulationResultsMultiArmMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsMultiArmRates">SimulationResultsMultiArmRates</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsMultiArmSurvival">SimulationResultsMultiArmSurvival</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsEnrichmentMeans">SimulationResultsEnrichmentMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsEnrichmentRates">SimulationResultsEnrichmentRates</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsEnrichmentSurvival">SimulationResultsEnrichmentSurvival</a></code>.
</p>
</li></ul>



<h3>Fields</h3>


<dl>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsCountData'>Class for Simulation Results Count Data</h2><span id='topic+SimulationResultsCountData'></span>

<h3>Description</h3>

<p>A class for simulation results count data.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationCounts">getSimulationCounts()</a></code>
to create an object of this type.
</p>


<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>accrualTime</code></dt><dd><p>The assumed accrual time intervals for the study. Is a numeric vector.</p>
</dd>
<dt><code>accrualIntensity</code></dt><dd><p>The absolute accrual intensities. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsEnrichmentMeans'>Class for Simulation Results Enrichment Means</h2><span id='topic+SimulationResultsEnrichmentMeans'></span>

<h3>Description</h3>

<p>A class for simulation results means in enrichment designs.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationEnrichmentMeans">getSimulationEnrichmentMeans()</a></code>
to create an object of this type.
</p>


<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>stDev</code></dt><dd><p>The standard deviation used for sample size and power calculation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>plannedSubjects</code></dt><dd><p>Determines the number of cumulated (overall) subjects when the interim stages are planned. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, refers to the number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>minNumberOfSubjectsPerStage</code></dt><dd><p>Determines the minimum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfSubjectsPerStage</code></dt><dd><p>Determines the maximum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>stDevH1</code></dt><dd><p>The standard deviation under which the conditional power or sample size recalculation is performed. Is a numeric vector of length 1.</p>
</dd>
<dt><code>calcSubjectsFunction</code></dt><dd><p>An optional function that can be entered to define how sample size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>populations</code></dt><dd><p>The number of populations in an enrichment design. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>effectList</code></dt><dd><p>The list of subsets, prevalences and effect sizes with columns and number of rows reflecting the different situations to be considered.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen. When testing means and rates, a non-stratified analysis can be performed on overall data. For survival data, only a stratified analysis is possible. Is a logical vector of length 1.</p>
</dd>
<dt><code>adaptations</code></dt><dd><p>Indicates whether or not an adaptation takes place at interim k. Is a logical vector of length <code>kMax</code> minus 1.</p>
</dd>
<dt><code>typeOfSelection</code></dt><dd><p>The way the treatment arms or populations are selected at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>effectMeasure</code></dt><dd><p>Criterion for treatment arm/population selection, either based on test statistic (<code>"testStatistic"</code>) or effect estimate (<code>"effectEstimate"</code>). Is a character vector of length 1.</p>
</dd>
<dt><code>successCriterion</code></dt><dd><p>Defines when the study is stopped for efficacy at interim. <code>"all"</code> stops the trial if the efficacy criterion has been fulfilled for all selected treatment arms/populations, <code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be superior to control at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>epsilonValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "epsilon"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>rValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "rBest"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>The selection criterion: treatment arm/population is only selected if <code>effectMeasure</code> exceeds <code>threshold</code>. Either a single numeric value or a numeric vector of length <code>activeArms</code> referring to a separate threshold condition for each treatment arm.</p>
</dd>
<dt><code>selectPopulationsFunction</code></dt><dd><p>An optional function that can be entered to define the way of how populations are selected.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>selectedPopulations</code></dt><dd><p>The selected populations in enrichment designs.</p>
</dd>
<dt><code>numberOfPopulations</code></dt><dd><p>The number of populations in an enrichment design. Is a numeric matrix.</p>
</dd>
<dt><code>rejectAtLeastOne</code></dt><dd><p>The probability to reject at least one of the (multiple) hypotheses. Is a numeric vector.</p>
</dd>
<dt><code>rejectedPopulationsPerStage</code></dt><dd><p>The simulated number of rejected populations per stage.</p>
</dd>
<dt><code>successPerStage</code></dt><dd><p>The simulated success probabilities per stage where success is defined by user. Is a numeric matrix.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsEnrichmentRates'>Class for Simulation Results Enrichment Rates</h2><span id='topic+SimulationResultsEnrichmentRates'></span>

<h3>Description</h3>

<p>A class for simulation results rates in enrichment designs.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationEnrichmentRates">getSimulationEnrichmentRates()</a></code>
to create an object of this type.
</p>


<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>plannedSubjects</code></dt><dd><p>Determines the number of cumulated (overall) subjects when the interim stages are planned. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, refers to the number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>minNumberOfSubjectsPerStage</code></dt><dd><p>Determines the minimum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfSubjectsPerStage</code></dt><dd><p>Determines the maximum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>calcSubjectsFunction</code></dt><dd><p>An optional function that can be entered to define how sample size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>populations</code></dt><dd><p>The number of populations in an enrichment design. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>effectList</code></dt><dd><p>The list of subsets, prevalences and effect sizes with columns and number of rows reflecting the different situations to be considered.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen. When testing means and rates, a non-stratified analysis can be performed on overall data. For survival data, only a stratified analysis is possible. Is a logical vector of length 1.</p>
</dd>
<dt><code>adaptations</code></dt><dd><p>Indicates whether or not an adaptation takes place at interim k. Is a logical vector of length <code>kMax</code> minus 1.</p>
</dd>
<dt><code>piTreatmentH1</code></dt><dd><p>The assumed probabilities in the active arm under which the sample size recalculation was performed and the conditional power was calculated.</p>
</dd>
<dt><code>piControlH1</code></dt><dd><p>The assumed probability in the reference group, for which the conditional power was calculated. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>typeOfSelection</code></dt><dd><p>The way the treatment arms or populations are selected at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>effectMeasure</code></dt><dd><p>Criterion for treatment arm/population selection, either based on test statistic (<code>"testStatistic"</code>) or effect estimate (<code>"effectEstimate"</code>). Is a character vector of length 1.</p>
</dd>
<dt><code>successCriterion</code></dt><dd><p>Defines when the study is stopped for efficacy at interim. <code>"all"</code> stops the trial if the efficacy criterion has been fulfilled for all selected treatment arms/populations, <code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be superior to control at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>epsilonValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "epsilon"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>rValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "rBest"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>The selection criterion: treatment arm/population is only selected if <code>effectMeasure</code> exceeds <code>threshold</code>. Either a single numeric value or a numeric vector of length <code>activeArms</code> referring to a separate threshold condition for each treatment arm.</p>
</dd>
<dt><code>selectPopulationsFunction</code></dt><dd><p>An optional function that can be entered to define the way of how populations are selected.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>selectedPopulations</code></dt><dd><p>The selected populations in enrichment designs.</p>
</dd>
<dt><code>numberOfPopulations</code></dt><dd><p>The number of populations in an enrichment design. Is a numeric matrix.</p>
</dd>
<dt><code>rejectAtLeastOne</code></dt><dd><p>The probability to reject at least one of the (multiple) hypotheses. Is a numeric vector.</p>
</dd>
<dt><code>rejectedPopulationsPerStage</code></dt><dd><p>The simulated number of rejected populations per stage.</p>
</dd>
<dt><code>successPerStage</code></dt><dd><p>The simulated success probabilities per stage where success is defined by user. Is a numeric matrix.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsEnrichmentSurvival'>Class for Simulation Results Enrichment Survival</h2><span id='topic+SimulationResultsEnrichmentSurvival'></span>

<h3>Description</h3>

<p>A class for simulation results survival in enrichment designs.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationEnrichmentSurvival">getSimulationEnrichmentSurvival()</a></code>
to create an object of this type.
</p>


<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>plannedSubjects</code></dt><dd><p>Determines the number of cumulated (overall) subjects when the interim stages are planned. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, refers to the number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>minNumberOfSubjectsPerStage</code></dt><dd><p>Determines the minimum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfSubjectsPerStage</code></dt><dd><p>Determines the maximum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>calcEventsFunction</code></dt><dd><p>An optional function that can be entered to define how event size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfEvents</code></dt><dd><p>The expected number of events under specified alternative. Is a numeric vector.</p>
</dd>
<dt><code>populations</code></dt><dd><p>The number of populations in an enrichment design. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>effectList</code></dt><dd><p>The list of subsets, prevalences and effect sizes with columns and number of rows reflecting the different situations to be considered.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen. When testing means and rates, a non-stratified analysis can be performed on overall data. For survival data, only a stratified analysis is possible. Is a logical vector of length 1.</p>
</dd>
<dt><code>adaptations</code></dt><dd><p>Indicates whether or not an adaptation takes place at interim k. Is a logical vector of length <code>kMax</code> minus 1.</p>
</dd>
<dt><code>typeOfSelection</code></dt><dd><p>The way the treatment arms or populations are selected at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>effectMeasure</code></dt><dd><p>Criterion for treatment arm/population selection, either based on test statistic (<code>"testStatistic"</code>) or effect estimate (<code>"effectEstimate"</code>). Is a character vector of length 1.</p>
</dd>
<dt><code>successCriterion</code></dt><dd><p>Defines when the study is stopped for efficacy at interim. <code>"all"</code> stops the trial if the efficacy criterion has been fulfilled for all selected treatment arms/populations, <code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be superior to control at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>epsilonValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "epsilon"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>rValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "rBest"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>The selection criterion: treatment arm/population is only selected if <code>effectMeasure</code> exceeds <code>threshold</code>. Either a single numeric value or a numeric vector of length <code>activeArms</code> referring to a separate threshold condition for each treatment arm.</p>
</dd>
<dt><code>selectPopulationsFunction</code></dt><dd><p>An optional function that can be entered to define the way of how populations are selected.</p>
</dd>
<dt><code>correlationComputation</code></dt><dd><p>If <code>"alternative"</code>, a correlation matrix according to Deng et al. (Biometrics, 2019) accounting for the respective alternative is used for simulating log-rank statistics in the many-to-one design. If <code>"null"</code>, a constant correlation matrix valid under the null hypothesis is used.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>selectedPopulations</code></dt><dd><p>The selected populations in enrichment designs.</p>
</dd>
<dt><code>numberOfPopulations</code></dt><dd><p>The number of populations in an enrichment design. Is a numeric matrix.</p>
</dd>
<dt><code>rejectAtLeastOne</code></dt><dd><p>The probability to reject at least one of the (multiple) hypotheses. Is a numeric vector.</p>
</dd>
<dt><code>rejectedPopulationsPerStage</code></dt><dd><p>The simulated number of rejected populations per stage.</p>
</dd>
<dt><code>successPerStage</code></dt><dd><p>The simulated success probabilities per stage where success is defined by user. Is a numeric matrix.</p>
</dd>
<dt><code>eventsPerStage</code></dt><dd><p>Deprecated: use <code>singleEventsPerStage</code> or <code>cumulativeEventsPerStage</code> instead Is a numeric matrix.</p>
</dd>
<dt><code>singleNumberOfEventsPerStage</code></dt><dd><p>Deprecated: use <code>singleEventsPerArmAndStage</code> or <code>singleEventsPerSubsetAndStage</code> instead</p>
</dd>
<dt><code>singleEventsPerSubsetAndStage</code></dt><dd><p>The number of events per subset and stage that is used for the analysis.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsMeans'>Class for Simulation Results Means</h2><span id='topic+SimulationResultsMeans'></span>

<h3>Description</h3>

<p>A class for simulation results means.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationMeans">getSimulationMeans()</a></code> to create an object of this type.
</p>
<p><code>SimulationResultsMeans</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+SimulationResultsMeans">SimulationResultsMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsMultiArmMeans">SimulationResultsMultiArmMeans</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsEnrichmentMeans">SimulationResultsEnrichmentMeans</a></code>.
</p>
</li></ul>



<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>stDev</code></dt><dd><p>The standard deviation used for sample size and power calculation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>plannedSubjects</code></dt><dd><p>Determines the number of cumulated (overall) subjects when the interim stages are planned. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, refers to the number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>minNumberOfSubjectsPerStage</code></dt><dd><p>Determines the minimum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfSubjectsPerStage</code></dt><dd><p>Determines the maximum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>stDevH1</code></dt><dd><p>The standard deviation under which the conditional power or sample size recalculation is performed. Is a numeric vector of length 1.</p>
</dd>
<dt><code>calcSubjectsFunction</code></dt><dd><p>An optional function that can be entered to define how sample size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>meanRatio</code></dt><dd><p>Specifies if the sample size for one-sided testing of H0: <code>mu1/mu2 = thetaH0</code> has been calculated. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>alternative</code></dt><dd><p>The alternative hypothesis value(s) for testing means. Is a numeric vector.</p>
</dd>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>effect</code></dt><dd><p>The effect for randomly creating normally distributed responses. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsMultiArmMeans'>Class for Simulation Results Multi-Arm Means</h2><span id='topic+SimulationResultsMultiArmMeans'></span>

<h3>Description</h3>

<p>A class for simulation results means in multi-arm designs.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationMultiArmMeans">getSimulationMultiArmMeans()</a></code> to create an object of this type.
</p>


<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>stDev</code></dt><dd><p>The standard deviation used for sample size and power calculation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>plannedSubjects</code></dt><dd><p>Determines the number of cumulated (overall) subjects when the interim stages are planned. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, refers to the number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>minNumberOfSubjectsPerStage</code></dt><dd><p>Determines the minimum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfSubjectsPerStage</code></dt><dd><p>Determines the maximum number of subjects per stage for data-driven sample size recalculation. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, is the minimum number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>stDevH1</code></dt><dd><p>The standard deviation under which the conditional power or sample size recalculation is performed. Is a numeric vector of length 1.</p>
</dd>
<dt><code>calcSubjectsFunction</code></dt><dd><p>An optional function that can be entered to define how sample size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>activeArms</code></dt><dd><p>The number of active treatment arms to be compared with control. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>effectMatrix</code></dt><dd><p>The matrix of effect sizes with <code>activeArms</code> columns and number of rows reflecting the different situations to consider.</p>
</dd>
<dt><code>typeOfShape</code></dt><dd><p>The shape of the dose-response relationship over the treatment groups. Is a character vector of length 1.</p>
</dd>
<dt><code>muMaxVector</code></dt><dd><p>The range of effect sizes for the treatment group with highest response for <code>"linear"</code> and <code>"sigmoidEmax"</code> model. Is a numeric vector.</p>
</dd>
<dt><code>gED50</code></dt><dd><p>The ED50 of the sigmoid Emax model. Only necessary if <code>typeOfShape = "sigmoidEmax"</code> has been specified. Is a numeric vector of length 1.</p>
</dd>
<dt><code>slope</code></dt><dd><p>The slope of the sigmoid Emax model, if <code>typeOfShape = "sigmoidEmax"</code> Is a numeric vector of length 1.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>adaptations</code></dt><dd><p>Indicates whether or not an adaptation takes place at interim k. Is a logical vector of length <code>kMax</code> minus 1.</p>
</dd>
<dt><code>typeOfSelection</code></dt><dd><p>The way the treatment arms or populations are selected at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>effectMeasure</code></dt><dd><p>Criterion for treatment arm/population selection, either based on test statistic (<code>"testStatistic"</code>) or effect estimate (<code>"effectEstimate"</code>). Is a character vector of length 1.</p>
</dd>
<dt><code>successCriterion</code></dt><dd><p>Defines when the study is stopped for efficacy at interim. <code>"all"</code> stops the trial if the efficacy criterion has been fulfilled for all selected treatment arms/populations, <code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be superior to control at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>epsilonValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "epsilon"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>rValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "rBest"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>The selection criterion: treatment arm/population is only selected if <code>effectMeasure</code> exceeds <code>threshold</code>. Either a single numeric value or a numeric vector of length <code>activeArms</code> referring to a separate threshold condition for each treatment arm.</p>
</dd>
<dt><code>selectArmsFunction</code></dt><dd><p>An optional function that can be entered to define how treatment arms are selected.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>selectedArms</code></dt><dd><p>The selected arms in multi-armed designs.</p>
</dd>
<dt><code>numberOfActiveArms</code></dt><dd><p>The number of active arms in a multi-armed design. Is a numeric matrix.</p>
</dd>
<dt><code>rejectAtLeastOne</code></dt><dd><p>The probability to reject at least one of the (multiple) hypotheses. Is a numeric vector.</p>
</dd>
<dt><code>rejectedArmsPerStage</code></dt><dd><p>The simulated number of rejected arms per stage.</p>
</dd>
<dt><code>successPerStage</code></dt><dd><p>The simulated success probabilities per stage where success is defined by user. Is a numeric matrix.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsMultiArmRates'>Class for Simulation Results Multi-Arm Rates</h2><span id='topic+SimulationResultsMultiArmRates'></span>

<h3>Description</h3>

<p>A class for simulation results rates in multi-arm designs.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationMultiArmRates">getSimulationMultiArmRates()</a></code>
to create an object of this type.
</p>


<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>plannedSubjects</code></dt><dd><p>Determines the number of cumulated (overall) subjects when the interim stages are planned. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, refers to the number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>calcSubjectsFunction</code></dt><dd><p>An optional function that can be entered to define how sample size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>activeArms</code></dt><dd><p>The number of active treatment arms to be compared with control. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>effectMatrix</code></dt><dd><p>The matrix of effect sizes with <code>activeArms</code> columns and number of rows reflecting the different situations to consider.</p>
</dd>
<dt><code>typeOfShape</code></dt><dd><p>The shape of the dose-response relationship over the treatment groups. Is a character vector of length 1.</p>
</dd>
<dt><code>piMaxVector</code></dt><dd><p>The range of assumed probabilities for the treatment group with highest response for <code>"linear"</code> and <code>"sigmoidEmax"</code> model.</p>
</dd>
<dt><code>piControl</code></dt><dd><p>The assumed probability in the control arm for simulation and under which the sample size recalculation is performed. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>piH1</code></dt><dd><p>The assumed probability in the active treatment arm(s) under which the sample size recalculation is performed. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>piControlH1</code></dt><dd><p>The assumed probability in the reference group, for which the conditional power was calculated. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>gED50</code></dt><dd><p>The ED50 of the sigmoid Emax model. Only necessary if <code>typeOfShape = "sigmoidEmax"</code> has been specified. Is a numeric vector of length 1.</p>
</dd>
<dt><code>slope</code></dt><dd><p>The slope of the sigmoid Emax model, if <code>typeOfShape = "sigmoidEmax"</code> Is a numeric vector of length 1.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>adaptations</code></dt><dd><p>Indicates whether or not an adaptation takes place at interim k. Is a logical vector of length <code>kMax</code> minus 1.</p>
</dd>
<dt><code>typeOfSelection</code></dt><dd><p>The way the treatment arms or populations are selected at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>effectMeasure</code></dt><dd><p>Criterion for treatment arm/population selection, either based on test statistic (<code>"testStatistic"</code>) or effect estimate (<code>"effectEstimate"</code>). Is a character vector of length 1.</p>
</dd>
<dt><code>successCriterion</code></dt><dd><p>Defines when the study is stopped for efficacy at interim. <code>"all"</code> stops the trial if the efficacy criterion has been fulfilled for all selected treatment arms/populations, <code>"atLeastOne"</code> stops if at least one of the selected treatment arms/populations is shown to be superior to control at interim. Is a character vector of length 1.</p>
</dd>
<dt><code>epsilonValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "epsilon"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>rValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "rBest"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>The selection criterion: treatment arm/population is only selected if <code>effectMeasure</code> exceeds <code>threshold</code>. Either a single numeric value or a numeric vector of length <code>activeArms</code> referring to a separate threshold condition for each treatment arm.</p>
</dd>
<dt><code>selectArmsFunction</code></dt><dd><p>An optional function that can be entered to define how treatment arms are selected.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>selectedArms</code></dt><dd><p>The selected arms in multi-armed designs.</p>
</dd>
<dt><code>numberOfActiveArms</code></dt><dd><p>The number of active arms in a multi-armed design. Is a numeric matrix.</p>
</dd>
<dt><code>rejectAtLeastOne</code></dt><dd><p>The probability to reject at least one of the (multiple) hypotheses. Is a numeric vector.</p>
</dd>
<dt><code>rejectedArmsPerStage</code></dt><dd><p>The simulated number of rejected arms per stage.</p>
</dd>
<dt><code>successPerStage</code></dt><dd><p>The simulated success probabilities per stage where success is defined by user. Is a numeric matrix.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsMultiArmSurvival'>Class for Simulation Results Multi-Arm Survival</h2><span id='topic+SimulationResultsMultiArmSurvival'></span>

<h3>Description</h3>

<p>A class for simulation results survival in multi-arm designs.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationMultiArmSurvival">getSimulationMultiArmSurvival()</a></code>
to create an object of this type.
</p>


<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>plannedEvents</code></dt><dd><p>Determines the number of cumulated (overall) events in survival designs when the interim stages are planned. For two treatment arms, is the number of events for both treatment arms. For multi-arm designs, refers to the overall number of events for the selected arms plus control. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>minNumberOfEventsPerStage</code></dt><dd><p>Determines the minimum number of events per stage for data-driven sample size recalculation. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfEventsPerStage</code></dt><dd><p>Determines the maximum number of events per stage for data-driven sample size recalculation. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>expectedNumberOfEvents</code></dt><dd><p>The expected number of events under specified alternative. Is a numeric vector.</p>
</dd>
<dt><code>activeArms</code></dt><dd><p>The number of active treatment arms to be compared with control. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>effectMatrix</code></dt><dd><p>The matrix of effect sizes with <code>activeArms</code> columns and number of rows reflecting the different situations to consider.</p>
</dd>
<dt><code>typeOfShape</code></dt><dd><p>The shape of the dose-response relationship over the treatment groups. Is a character vector of length 1.</p>
</dd>
<dt><code>omegaMaxVector</code></dt><dd><p>The range of hazard ratios with highest response for <code>"linear"</code> and <code>"sigmoidEmax"</code> model. Is a numeric vector.</p>
</dd>
<dt><code>gED50</code></dt><dd><p>The ED50 of the sigmoid Emax model. Only necessary if <code>typeOfShape = "sigmoidEmax"</code> has been specified. Is a numeric vector of length 1.</p>
</dd>
<dt><code>slope</code></dt><dd><p>The slope of the sigmoid Emax model, if <code>typeOfShape = "sigmoidEmax"</code> Is a numeric vector of length 1.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>adaptations</code></dt><dd><p>Indicates whether or not an adaptation takes place at interim k. Is a logical vector of length <code>kMax</code> minus 1.</p>
</dd>
<dt><code>epsilonValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "epsilon"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>rValue</code></dt><dd><p>Needs to be specified if <code>typeOfSelection = "rBest"</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>The selection criterion: treatment arm/population is only selected if <code>effectMeasure</code> exceeds <code>threshold</code>. Either a single numeric value or a numeric vector of length <code>activeArms</code> referring to a separate threshold condition for each treatment arm.</p>
</dd>
<dt><code>selectArmsFunction</code></dt><dd><p>An optional function that can be entered to define how treatment arms are selected.</p>
</dd>
<dt><code>correlationComputation</code></dt><dd><p>If <code>"alternative"</code>, a correlation matrix according to Deng et al. (Biometrics, 2019) accounting for the respective alternative is used for simulating log-rank statistics in the many-to-one design. If <code>"null"</code>, a constant correlation matrix valid under the null hypothesis is used.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>selectedArms</code></dt><dd><p>The selected arms in multi-armed designs.</p>
</dd>
<dt><code>numberOfActiveArms</code></dt><dd><p>The number of active arms in a multi-armed design. Is a numeric matrix.</p>
</dd>
<dt><code>rejectAtLeastOne</code></dt><dd><p>The probability to reject at least one of the (multiple) hypotheses. Is a numeric vector.</p>
</dd>
<dt><code>rejectedArmsPerStage</code></dt><dd><p>The simulated number of rejected arms per stage.</p>
</dd>
<dt><code>successPerStage</code></dt><dd><p>The simulated success probabilities per stage where success is defined by user. Is a numeric matrix.</p>
</dd>
<dt><code>eventsPerStage</code></dt><dd><p>Deprecated: use <code>singleEventsPerStage</code> or <code>cumulativeEventsPerStage</code> instead Is a numeric matrix.</p>
</dd>
<dt><code>singleNumberOfEventsPerStage</code></dt><dd><p>Deprecated: use <code>singleEventsPerArmAndStage</code> or <code>singleEventsPerSubsetAndStage</code> instead</p>
</dd>
<dt><code>singleEventsPerArmAndStage</code></dt><dd><p>The number of events per arm and stage that is used for the analysis.</p>
</dd>
<dt><code>singleEventsPerStage</code></dt><dd><p>The single number of events per stage. Is a numeric matrix.</p>
</dd>
<dt><code>cumulativeEventsPerStage</code></dt><dd><p>The cumulative number of events per stage. Is a numeric matrix.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsRates'>Class for Simulation Results Rates</h2><span id='topic+SimulationResultsRates'></span>

<h3>Description</h3>

<p>A class for simulation results rates.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationRates">getSimulationRates()</a></code>
to create an object of this type.
</p>
<p><code>SimulationResultsRates</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+SimulationResultsRates">SimulationResultsRates</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsMultiArmRates">SimulationResultsMultiArmRates</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsEnrichmentRates">SimulationResultsEnrichmentRates</a></code>.
</p>
</li></ul>



<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>plannedSubjects</code></dt><dd><p>Determines the number of cumulated (overall) subjects when the interim stages are planned. For two treatment arms, is the number of subjects for both treatment arms. For multi-arm designs, refers to the number of subjects per selected active arm. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>calcSubjectsFunction</code></dt><dd><p>An optional function that can be entered to define how sample size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfSubjectsPerStage</code> and <code>maxNumberOfSubjectsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>riskRatio</code></dt><dd><p>Specifies if the sample size for one-sided testing of H0: <code>pi1 / pi2 = thetaH0</code> has been calculated. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>pi1H1</code></dt><dd><p>The assumed probability in the active treatment group for two-group designs, or the assumed probability for a one treatment group design, for which the conditional power was calculated. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>pi2H1</code></dt><dd><p>The assumed probability in the reference group for two-group designs, for which the conditional power was calculated. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>effect</code></dt><dd><p>The effect for randomly creating normally distributed responses. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>sampleSizes</code></dt><dd><p>The sample sizes for each group and stage. Is a numeric vector of length number of stages times number of groups containing whole numbers.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='SimulationResultsSurvival'>Class for Simulation Results Survival</h2><span id='topic+SimulationResultsSurvival'></span>

<h3>Description</h3>

<p>A class for simulation results survival.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+getSimulationSurvival">getSimulationSurvival()</a></code>
to create an object of this type.
</p>
<p><code>SimulationResultsSurvival</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+SimulationResultsSurvival">SimulationResultsSurvival</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsMultiArmSurvival">SimulationResultsMultiArmSurvival</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+SimulationResultsEnrichmentSurvival">SimulationResultsEnrichmentSurvival</a></code>.
</p>
</li></ul>



<h3>Fields</h3>


<dl>
<dt><code>maxNumberOfIterations</code></dt><dd><p>The number of simulation iterations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>conditionalPower</code></dt><dd><p>The conditional power at each stage of the trial. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>plannedEvents</code></dt><dd><p>Determines the number of cumulated (overall) events in survival designs when the interim stages are planned. For two treatment arms, is the number of events for both treatment arms. For multi-arm designs, refers to the overall number of events for the selected arms plus control. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>minNumberOfEventsPerStage</code></dt><dd><p>Determines the minimum number of events per stage for data-driven sample size recalculation. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>maxNumberOfEventsPerStage</code></dt><dd><p>Determines the maximum number of events per stage for data-driven sample size recalculation. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>thetaH1</code></dt><dd><p>The assumed effect under the alternative hypothesis. For survival designs, refers to the hazard ratio. Is a numeric vector.</p>
</dd>
<dt><code>calcEventsFunction</code></dt><dd><p>An optional function that can be entered to define how event size is recalculated. By default, recalculation is performed with conditional power with specified <code>minNumberOfEventsPerStage</code> and <code>maxNumberOfEventsPerStage</code>.</p>
</dd>
<dt><code>expectedNumberOfEvents</code></dt><dd><p>The expected number of events under specified alternative. Is a numeric vector.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed event rate in the treatment group. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed event rate in the control group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>median1</code></dt><dd><p>The assumed median survival time in the treatment group. Is a numeric vector.</p>
</dd>
<dt><code>median2</code></dt><dd><p>The assumed median survival time in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>accrualTime</code></dt><dd><p>The assumed accrual time intervals for the study. Is a numeric vector.</p>
</dd>
<dt><code>accrualIntensity</code></dt><dd><p>The absolute accrual intensities. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>dropoutRate1</code></dt><dd><p>The assumed drop-out rate in the treatment group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>dropoutRate2</code></dt><dd><p>The assumed drop-out rate in the control group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>dropoutTime</code></dt><dd><p>The assumed time for drop-out rates in the control and treatment group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>eventTime</code></dt><dd><p>The assumed time under which the event rates are calculated. Is a numeric vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>allocation1</code></dt><dd><p>The number of subjects to be assigned to treatment 1 in subsequent order. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>allocation2</code></dt><dd><p>The number of subjects to be assigned to treatment 2 in subsequent order. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>kappa</code></dt><dd><p>The shape of the Weibull distribution if <code>kappa!=1</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>piecewiseSurvivalTime</code></dt><dd><p>The time intervals for the piecewise definition of the exponential survival time cumulative distribution function. Is a numeric vector.</p>
</dd>
<dt><code>lambda1</code></dt><dd><p>The assumed hazard rate in the treatment group. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>lambda2</code></dt><dd><p>The assumed hazard rate in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>hazardRatio</code></dt><dd><p>The hazard ratios under consideration. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>studyDuration</code></dt><dd><p>The study duration for specified effect size. Is a positive numeric vector.</p>
</dd>
<dt><code>eventsNotAchieved</code></dt><dd><p>The simulated number of cases how often the number of events was not reached. Is a numeric matrix.</p>
</dd>
<dt><code>numberOfSubjects</code></dt><dd><p>In simulation results data set: The number of subjects under consideration when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects1</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 1 when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects2</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 2 when the interim analysis takes place.</p>
</dd>
<dt><code>singleEventsPerStage</code></dt><dd><p>The single number of events per stage. Is a numeric matrix.</p>
</dd>
<dt><code>cumulativeEventsPerStage</code></dt><dd><p>The cumulative number of events per stage. Is a numeric matrix.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>conditionalPowerAchieved</code></dt><dd><p>The calculated conditional power, under the assumption of observed or assumed effect sizes. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='StageResults'>Basic Stage Results</h2><span id='topic+StageResults'></span>

<h3>Description</h3>

<p>Basic class for stage results.
</p>


<h3>Details</h3>

<p><code>StageResults</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+StageResultsMeans">StageResultsMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+StageResultsRates">StageResultsRates</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+StageResultsSurvival">StageResultsSurvival</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+StageResultsMultiArmMeans">StageResultsMultiArmMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+StageResultsMultiArmRates">StageResultsMultiArmRates</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+StageResultsMultiArmSurvival">StageResultsMultiArmSurvival</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+StageResultsEnrichmentMeans">StageResultsEnrichmentMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+StageResultsEnrichmentRates">StageResultsEnrichmentRates</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+StageResultsEnrichmentSurvival">StageResultsEnrichmentSurvival</a></code>.
</p>
</li></ul>



<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsEnrichmentMeans'>Stage Results Enrichment Means</h2><span id='topic+StageResultsEnrichmentMeans'></span>

<h3>Description</h3>

<p>Class for stage results of enrichment means data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of enrichment means.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>direction</code></dt><dd><p>Specifies the direction of the alternative, is either &quot;upper&quot; or &quot;lower&quot;. Only applicable for one-sided testing.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple (i.e., &gt;2) treatment arms or population enrichment designs when testing means. Available options for multiple arms: <code>"overallPooled", "pairwisePooled", "notPooled"</code>. Available options for enrichment designs: <code>"pooled", "pooledFromFull", "notPooled"</code>.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallTestStatistics</code></dt><dd><p>The overall, i.e., cumulated test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>overallPValues</code></dt><dd><p>The overall, i.e., cumulated p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>overallStDevs</code></dt><dd><p>The overall, i.e., cumulative standard deviations. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallPooledStDevs</code></dt><dd><p>The overall pooled standard deviations. Is a numeric matrix.</p>
</dd>
<dt><code>separatePValues</code></dt><dd><p>The p-values from the separate stages. Is a numeric matrix.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>singleStepAdjustedPValues</code></dt><dd><p>The adjusted p-value for testing multiple hypotheses per stage of the trial.</p>
</dd>
<dt><code>stratifiedAnalysis</code></dt><dd><p>For enrichment designs, typically a stratified analysis should be chosen. When testing means and rates, a non-stratified analysis can be performed on overall data. For survival data, only a stratified analysis is possible. Is a logical vector of length 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsEnrichmentRates'>Stage Results Enrichment Rates</h2><span id='topic+StageResultsEnrichmentRates'></span>

<h3>Description</h3>

<p>Class for stage results of enrichment rates data.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of enrichment rates.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsEnrichmentSurvival'>Stage Results Enrichment Survival</h2><span id='topic+StageResultsEnrichmentSurvival'></span>

<h3>Description</h3>

<p>Class for stage results of enrichment survival data.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of enrichment survival.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsMeans'>Stage Results of Means</h2><span id='topic+StageResultsMeans'></span>

<h3>Description</h3>

<p>Class for stage results of means.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of means.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallTestStatistics</code></dt><dd><p>The overall, i.e., cumulated test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>overallPValues</code></dt><dd><p>The overall, i.e., cumulated p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>direction</code></dt><dd><p>Specifies the direction of the alternative, is either &quot;upper&quot; or &quot;lower&quot;. Only applicable for one-sided testing.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>equalVariances</code></dt><dd><p>Describes if the variances in two treatment groups are assumed to be the same. Is a logical vector of length 1.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Names of <code>dataInput</code>.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsMultiArmMeans'>Stage Results Multi Arm Means</h2><span id='topic+StageResultsMultiArmMeans'></span>

<h3>Description</h3>

<p>Class for stage results of multi arm means data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of multi arm means.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>overallTestStatistics</code></dt><dd><p>The overall, i.e., cumulated test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallStDevs</code></dt><dd><p>The overall, i.e., cumulative standard deviations. Is a numeric vector of length number of stages times number of groups.</p>
</dd>
<dt><code>overallPooledStDevs</code></dt><dd><p>The overall pooled standard deviations. Is a numeric matrix.</p>
</dd>
<dt><code>overallPValues</code></dt><dd><p>The overall, i.e., cumulated p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>separatePValues</code></dt><dd><p>The p-values from the separate stages. Is a numeric matrix.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>singleStepAdjustedPValues</code></dt><dd><p>The adjusted p-value for testing multiple hypotheses per stage of the trial.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>varianceOption</code></dt><dd><p>Defines the way to calculate the variance in multiple (i.e., &gt;2) treatment arms or population enrichment designs when testing means. Available options for multiple arms: <code>"overallPooled", "pairwisePooled", "notPooled"</code>. Available options for enrichment designs: <code>"pooled", "pooledFromFull", "notPooled"</code>.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsMultiArmRates'>Stage Results Multi Arm Rates</h2><span id='topic+StageResultsMultiArmRates'></span>

<h3>Description</h3>

<p>Class for stage results of multi arm rates data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of multi arm rates.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>overallTestStatistics</code></dt><dd><p>The overall, i.e., cumulated test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallPValues</code></dt><dd><p>The overall, i.e., cumulated p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>separatePValues</code></dt><dd><p>The p-values from the separate stages. Is a numeric matrix.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>singleStepAdjustedPValues</code></dt><dd><p>The adjusted p-value for testing multiple hypotheses per stage of the trial.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsMultiArmSurvival'>Stage Results Multi Arm Survival</h2><span id='topic+StageResultsMultiArmSurvival'></span>

<h3>Description</h3>

<p>Class for stage results of multi arm survival data
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of multi arm survival.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>overallTestStatistics</code></dt><dd><p>The overall, i.e., cumulated test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallPValues</code></dt><dd><p>The overall, i.e., cumulated p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>separatePValues</code></dt><dd><p>The p-values from the separate stages. Is a numeric matrix.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>singleStepAdjustedPValues</code></dt><dd><p>The adjusted p-value for testing multiple hypotheses per stage of the trial.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsRates'>Stage Results of Rates</h2><span id='topic+StageResultsRates'></span>

<h3>Description</h3>

<p>Class for stage results of rates.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of rates.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallTestStatistics</code></dt><dd><p>The overall, i.e., cumulated test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>pValues</code></dt><dd><p>The stage-wise p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>overallPValues</code></dt><dd><p>The overall, i.e., cumulated p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>direction</code></dt><dd><p>Specifies the direction of the alternative, is either &quot;upper&quot; or &quot;lower&quot;. Only applicable for one-sided testing.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>...</code></dt><dd><p>Names of <code>dataInput</code>.</p>
</dd>
</dl>

<hr>
<h2 id='StageResultsSurvival'>Stage Results of Survival Data</h2><span id='topic+StageResultsSurvival'></span>

<h3>Description</h3>

<p>Class for stage results survival data.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code>getStageResults</code>
with suitable arguments to create the stage results of a dataset of survival data.
</p>


<h3>Fields</h3>


<dl>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>testStatistics</code></dt><dd><p>The stage-wise test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallTestStatistics</code></dt><dd><p>The overall, i.e., cumulated test statistics. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>separatePValues</code></dt><dd><p>The p-values from the separate stages. Is a numeric matrix.</p>
</dd>
<dt><code>singleStepAdjustedPValues</code></dt><dd><p>The adjusted p-value for testing multiple hypotheses per stage of the trial.</p>
</dd>
<dt><code>overallPValues</code></dt><dd><p>The overall, i.e., cumulated p-values. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>direction</code></dt><dd><p>Specifies the direction of the alternative, is either &quot;upper&quot; or &quot;lower&quot;. Only applicable for one-sided testing.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>intersectionTest</code></dt><dd><p>The multiple test used for intersection hypotheses in closed systems of hypotheses. Is a character vector of length 1.</p>
</dd>
<dt><code>combInverseNormal</code></dt><dd><p>The test statistics over stages for the inverse normal test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>combFisher</code></dt><dd><p>The test statistics over stages for Fisher's combination test. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>effectSizes</code></dt><dd><p>The stage-wise effect sizes. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>testActions</code></dt><dd><p>The test decisions at each stage of the trial. Is a character vector of length <code>kMax</code>.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>weightsFisher</code></dt><dd><p>The weights for Fisher's combination test. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>weightsInverseNormal</code></dt><dd><p>The weights for the inverse normal statistic. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>...</code></dt><dd><p>Names of <code>dataInput</code>.</p>
</dd>
</dl>

<hr>
<h2 id='summary.AnalysisResults'>Analysis Results Summary</h2><span id='topic+summary.AnalysisResults'></span>

<h3>Description</h3>

<p>Displays a summary of <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnalysisResults'
summary(object, ..., type = 1, digits = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.AnalysisResults_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+AnalysisResults">AnalysisResults</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.AnalysisResults_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="summary.AnalysisResults_+3A_digits">digits</code></td>
<td>
<p>Defines how many digits are to be used for numeric values. Must be a positive integer of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the parameters and results of an analysis results object.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SummaryFactory">SummaryFactory</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object
</p>
</li></ul>



<h3>Summary options</h3>

<p>The following options can be set globally:
</p>

<ol>
<li> <p><code>rpact.summary.output.size</code>: one of <code>c("small", "medium", "large")</code>;
defines how many details will be included into the summary;
default is <code>"large"</code>, i.e., all available details are displayed.
</p>
</li>
<li> <p><code>rpact.summary.justify</code>: one of <code>c("right", "left", "centre")</code>;
shall the values be right-justified (the default), left-justified or centered.
</p>
</li>
<li> <p><code>rpact.summary.width</code>: defines the maximum number of characters to be used per line (default is <code>83</code>).
</p>
</li>
<li> <p><code>rpact.summary.intervalFormat</code>: defines how intervals will be displayed in the summary,
default is <code>"[%s; %s]"</code>.
</p>
</li>
<li> <p><code>rpact.summary.digits</code>: defines how many digits are to be used for numeric values (default is <code>3</code>).
</p>
</li>
<li> <p><code>rpact.summary.digits.probs</code>: defines how many digits are to be used for numeric values
(default is one more than value of <code>rpact.summary.digits</code>, i.e., <code>4</code>).
</p>
</li>
<li> <p><code>rpact.summary.trim.zeroes</code>: if <code>TRUE</code> (default) zeroes will always displayed as &quot;0&quot;,
e.g. &quot;0.000&quot; will become &quot;0&quot;.
</p>
</li></ol>

<p>Example: <code>options("rpact.summary.intervalFormat" = "%s - %s")</code>
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>

<hr>
<h2 id='summary.Dataset'>Dataset Summary</h2><span id='topic+summary.Dataset'></span>

<h3>Description</h3>

<p>Displays a summary of <code><a href="#topic+Dataset">Dataset</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Dataset'
summary(object, ..., type = 1, digits = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Dataset_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+Dataset">Dataset</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.Dataset_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="summary.Dataset_+3A_digits">digits</code></td>
<td>
<p>Defines how many digits are to be used for numeric values. Must be a positive integer of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the parameters and results of a dataset.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SummaryFactory">SummaryFactory</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object
</p>
</li></ul>



<h3>Summary options</h3>

<p>The following options can be set globally:
</p>

<ol>
<li> <p><code>rpact.summary.output.size</code>: one of <code>c("small", "medium", "large")</code>;
defines how many details will be included into the summary;
default is <code>"large"</code>, i.e., all available details are displayed.
</p>
</li>
<li> <p><code>rpact.summary.justify</code>: one of <code>c("right", "left", "centre")</code>;
shall the values be right-justified (the default), left-justified or centered.
</p>
</li>
<li> <p><code>rpact.summary.width</code>: defines the maximum number of characters to be used per line (default is <code>83</code>).
</p>
</li>
<li> <p><code>rpact.summary.intervalFormat</code>: defines how intervals will be displayed in the summary,
default is <code>"[%s; %s]"</code>.
</p>
</li>
<li> <p><code>rpact.summary.digits</code>: defines how many digits are to be used for numeric values (default is <code>3</code>).
</p>
</li>
<li> <p><code>rpact.summary.digits.probs</code>: defines how many digits are to be used for numeric values
(default is one more than value of <code>rpact.summary.digits</code>, i.e., <code>4</code>).
</p>
</li>
<li> <p><code>rpact.summary.trim.zeroes</code>: if <code>TRUE</code> (default) zeroes will always displayed as &quot;0&quot;,
e.g. &quot;0.000&quot; will become &quot;0&quot;.
</p>
</li></ol>

<p>Example: <code>options("rpact.summary.intervalFormat" = "%s - %s")</code>
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>

<hr>
<h2 id='summary.ParameterSet'>Parameter Set Summary</h2><span id='topic+summary.ParameterSet'></span>

<h3>Description</h3>

<p>Displays a summary of <code><a href="#topic+ParameterSet">ParameterSet</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ParameterSet'
summary(
  object,
  ...,
  type = 1,
  digits = NA_integer_,
  output = c("all", "title", "overview", "body"),
  printObject = FALSE,
  sep = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ParameterSet_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+ParameterSet">ParameterSet</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.ParameterSet_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="summary.ParameterSet_+3A_digits">digits</code></td>
<td>
<p>Defines how many digits are to be used for numeric values. Must be a positive integer of length 1.</p>
</td></tr>
<tr><td><code id="summary.ParameterSet_+3A_output">output</code></td>
<td>
<p>The output parts, default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="summary.ParameterSet_+3A_printobject">printObject</code></td>
<td>
<p>Show also the print output after the summary, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.ParameterSet_+3A_sep">sep</code></td>
<td>
<p>The separator line between the summary and the optional print output, default is <code>"\n\n-----\n\n"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the parameters and results of a parameter set.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SummaryFactory">SummaryFactory</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object
</p>
</li></ul>



<h3>Summary options</h3>

<p>The following options can be set globally:
</p>

<ol>
<li> <p><code>rpact.summary.output.size</code>: one of <code>c("small", "medium", "large")</code>;
defines how many details will be included into the summary;
default is <code>"large"</code>, i.e., all available details are displayed.
</p>
</li>
<li> <p><code>rpact.summary.justify</code>: one of <code>c("right", "left", "centre")</code>;
shall the values be right-justified (the default), left-justified or centered.
</p>
</li>
<li> <p><code>rpact.summary.width</code>: defines the maximum number of characters to be used per line (default is <code>83</code>).
</p>
</li>
<li> <p><code>rpact.summary.intervalFormat</code>: defines how intervals will be displayed in the summary,
default is <code>"[%s; %s]"</code>.
</p>
</li>
<li> <p><code>rpact.summary.digits</code>: defines how many digits are to be used for numeric values (default is <code>3</code>).
</p>
</li>
<li> <p><code>rpact.summary.digits.probs</code>: defines how many digits are to be used for numeric values
(default is one more than value of <code>rpact.summary.digits</code>, i.e., <code>4</code>).
</p>
</li>
<li> <p><code>rpact.summary.trim.zeroes</code>: if <code>TRUE</code> (default) zeroes will always displayed as &quot;0&quot;,
e.g. &quot;0.000&quot; will become &quot;0&quot;.
</p>
</li></ol>

<p>Example: <code>options("rpact.summary.intervalFormat" = "%s - %s")</code>
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>

<hr>
<h2 id='summary.TrialDesignSet'>Trial Design Set Summary</h2><span id='topic+summary.TrialDesignSet'></span>

<h3>Description</h3>

<p>Displays a summary of <code><a href="#topic+ParameterSet">ParameterSet</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TrialDesignSet'
summary(object, ..., type = 1, digits = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.TrialDesignSet_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+ParameterSet">ParameterSet</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.TrialDesignSet_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="summary.TrialDesignSet_+3A_digits">digits</code></td>
<td>
<p>Defines how many digits are to be used for numeric values. Must be a positive integer of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the trial designs.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+SummaryFactory">SummaryFactory</a></code> object.
The following generics (R generic functions) are available for this result object:
</p>

<ul>
<li> <p><code><a href="#topic+names.FieldSet">names()</a></code> to obtain the field names,
</p>
</li>
<li> <p><code><a href="#topic+print.FieldSet">print()</a></code> to print the object
</p>
</li></ul>



<h3>Summary options</h3>

<p>The following options can be set globally:
</p>

<ol>
<li> <p><code>rpact.summary.output.size</code>: one of <code>c("small", "medium", "large")</code>;
defines how many details will be included into the summary;
default is <code>"large"</code>, i.e., all available details are displayed.
</p>
</li>
<li> <p><code>rpact.summary.justify</code>: one of <code>c("right", "left", "centre")</code>;
shall the values be right-justified (the default), left-justified or centered.
</p>
</li>
<li> <p><code>rpact.summary.width</code>: defines the maximum number of characters to be used per line (default is <code>83</code>).
</p>
</li>
<li> <p><code>rpact.summary.intervalFormat</code>: defines how intervals will be displayed in the summary,
default is <code>"[%s; %s]"</code>.
</p>
</li>
<li> <p><code>rpact.summary.digits</code>: defines how many digits are to be used for numeric values (default is <code>3</code>).
</p>
</li>
<li> <p><code>rpact.summary.digits.probs</code>: defines how many digits are to be used for numeric values
(default is one more than value of <code>rpact.summary.digits</code>, i.e., <code>4</code>).
</p>
</li>
<li> <p><code>rpact.summary.trim.zeroes</code>: if <code>TRUE</code> (default) zeroes will always displayed as &quot;0&quot;,
e.g. &quot;0.000&quot; will become &quot;0&quot;.
</p>
</li></ol>

<p>Example: <code>options("rpact.summary.intervalFormat" = "%s - %s")</code>
</p>


<h3>How to get help for generic functions</h3>

<p>Click on the link of a generic in the list above to go directly to the help documentation of
the <code>rpact</code> specific implementation of the generic.
Note that you can use the R function <code><a href="utils.html#topic+methods">methods</a></code> to get all the methods of a generic and
to identify the object specific name of it, e.g.,
use <code>methods("plot")</code> to get all the methods for the <code>plot</code> generic.
There you can find, e.g., <code>plot.AnalysisResults</code> and
obtain the specific help documentation linked above by typing <code>?plot.AnalysisResults</code>.
</p>

<hr>
<h2 id='SummaryFactory'>Summary Factory</h2><span id='topic+SummaryFactory'></span>

<h3>Description</h3>

<p>Basic class for summaries
</p>

<hr>
<h2 id='test_plan_section'>Test Plan Section</h2><span id='topic+test_plan_section'></span>

<h3>Description</h3>

<p>The section title or description will be used in the formal validation documentation.
For more information visit <a href="https://www.rpact.com">https://www.rpact.com</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_plan_section(section)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_plan_section_+3A_section">section</code></td>
<td>
<p>The section title or description.</p>
</td></tr>
</table>

<hr>
<h2 id='testPackage'>Test Package</h2><span id='topic+testPackage'></span>

<h3>Description</h3>

<p>This function allows the installed package <code>rpact</code> to be tested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPackage(
  outDir = ".",
  ...,
  completeUnitTestSetEnabled = TRUE,
  types = "tests",
  connection = list(token = NULL, secret = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testPackage_+3A_outdir">outDir</code></td>
<td>
<p>The output directory where all test results shall be saved.
By default the current working directory is used.</p>
</td></tr>
<tr><td><code id="testPackage_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="testPackage_+3A_completeunittestsetenabled">completeUnitTestSetEnabled</code></td>
<td>
<p>If <code>TRUE</code> (default) all existing unit tests will
be executed; a subset of all unit tests will be used otherwise.</p>
</td></tr>
<tr><td><code id="testPackage_+3A_types">types</code></td>
<td>
<p>The type(s) of tests to be done. Can be one or more of
<code>c("tests", "examples", "vignettes")</code>, default is &quot;tests&quot; only.</p>
</td></tr>
<tr><td><code id="testPackage_+3A_connection">connection</code></td>
<td>
<p>A <code>list</code> where owners of the rpact validation documentation
can enter a <code>token</code> and a <code>secret</code> to get full access to all unit tests, e.g.,
to fulfill regulatory requirements (see <a href="https://www.rpact.com">www.rpact.com</a> for more information).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates the subdirectory <code>rpact-tests</code> in the specified output directory
and copies all unit test files of the package to this newly created directory.
Then the function runs all tests (or a subset of all tests if
<code>completeUnitTestSetEnabled</code> is <code>FALSE</code>) using
<code><a href="tools.html#topic+testInstalledPackage">testInstalledPackage</a></code>.
The test results will be saved to the text file <code>testthat.Rout</code> that can be found
in the subdirectory <code>rpact-tests</code>.
</p>


<h3>Value</h3>

<p>The value of <code>completeUnitTestSetEnabled</code> will be returned invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
testPackage()

## End(Not run)

</code></pre>

<hr>
<h2 id='TrialDesign'>Basic Trial Design</h2><span id='topic+TrialDesign'></span>

<h3>Description</h3>

<p>Basic class for trial designs.
</p>


<h3>Details</h3>

<p><code>TrialDesign</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+TrialDesignFisher">TrialDesignFisher</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+TrialDesignGroupSequential">TrialDesignGroupSequential</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+TrialDesignInverseNormal">TrialDesignInverseNormal</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+TrialDesignConditionalDunnett">TrialDesignConditionalDunnett</a></code>.
</p>
</li></ul>



<h3>Fields</h3>


<dl>
<dt><code>kMax</code></dt><dd><p>The maximum number of stages <code>K</code>. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level alpha, default is 0.025. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>userAlphaSpending</code></dt><dd><p>The user defined alpha spending. Contains the cumulative alpha-spending (type I error rate) up to each interim stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>criticalValues</code></dt><dd><p>The critical values for each stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>stageLevels</code></dt><dd><p>The adjusted significance levels to reach significance in a group sequential design. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>alphaSpent</code></dt><dd><p>The cumulative alpha spent at each stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>bindingFutility</code></dt><dd><p>If <code>TRUE</code>, the calculation of the critical values is affected by the futility bounds and the futility threshold is binding in the sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>) Is a logical vector of length 1.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The numerical tolerance, default is <code>1e-06</code>. Is a numeric vector of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='TrialDesignCharacteristics'>Trial Design Characteristics</h2><span id='topic+TrialDesignCharacteristics'></span>

<h3>Description</h3>

<p>Class for trial design characteristics.
</p>


<h3>Details</h3>

<p><code>TrialDesignCharacteristics</code> contains all fields required
to collect the characteristics of a design.
This object should not be created directly; use <code>getDesignCharacteristics</code>
with suitable arguments to create it.
</p>


<h3>Fields</h3>


<dl>
<dt><code>nFixed</code></dt><dd><p>The sample size in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>shift</code></dt><dd><p>The shift value for group sequential test characteristics. Is a numeric vector of length 1.</p>
</dd>
<dt><code>inflationFactor</code></dt><dd><p>The relative increase of maximum sample size in a group sequential design as compared to the fixed sample size case. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>information</code></dt><dd><p>The information over stages needed to achieve power of the specified design. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>power</code></dt><dd><p>The one-sided power at each stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>rejectionProbabilities</code></dt><dd><p>The rejection probabilities over treatments arms or populations and stages. Is a numeric vector.</p>
</dd>
<dt><code>futilityProbabilities</code></dt><dd><p>The overall probabilities of stopping the trial for futility. Is a numeric vector of length <code>kMax</code> minus 1 containing values between 0 and 1.</p>
</dd>
<dt><code>averageSampleNumber1</code></dt><dd><p>The expected sample size under H1. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>averageSampleNumber01</code></dt><dd><p>The expected sample size for a value between H0 and H1. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>averageSampleNumber0</code></dt><dd><p>The expected sample size under H0. Is a positive numeric vector of length 1.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignCharacteristics">getDesignCharacteristics</a></code> for getting the design characteristics.
</p>

<hr>
<h2 id='TrialDesignConditionalDunnett'>Conditional Dunnett Design</h2><span id='topic+TrialDesignConditionalDunnett'></span>

<h3>Description</h3>

<p>Trial design for conditional Dunnett tests.
</p>


<h3>Details</h3>

<p>This object should not be created directly; use <code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a></code>
with suitable arguments to create a conditional Dunnett test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>kMax</code></dt><dd><p>The maximum number of stages <code>K</code>. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level alpha, default is 0.025. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>userAlphaSpending</code></dt><dd><p>The user defined alpha spending. Contains the cumulative alpha-spending (type I error rate) up to each interim stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>criticalValues</code></dt><dd><p>The critical values for each stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>stageLevels</code></dt><dd><p>The adjusted significance levels to reach significance in a group sequential design. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>alphaSpent</code></dt><dd><p>The cumulative alpha spent at each stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>bindingFutility</code></dt><dd><p>If <code>TRUE</code>, the calculation of the critical values is affected by the futility bounds and the futility threshold is binding in the sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>) Is a logical vector of length 1.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The numerical tolerance, default is <code>1e-06</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>informationAtInterim</code></dt><dd><p>The information to be expected at interim, default is informationAtInterim = 0.5. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>secondStageConditioning</code></dt><dd><p>The way the second stage p-values are calculated within the closed system of hypotheses. If <code>FALSE</code>, the unconditional adjusted p-values are used, otherwise conditional adjusted p-values are calculated. Is a logical vector of length 1.</p>
</dd>
<dt><code>sided</code></dt><dd><p>Describes if the alternative is one-sided (<code>1</code>) or two-sided (<code>2</code>). Is a numeric vector of length 1 containing a whole number.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignConditionalDunnett">getDesignConditionalDunnett</a></code> for creating a conditional Dunnett test design.
</p>

<hr>
<h2 id='TrialDesignFisher'>Fisher Design</h2><span id='topic+TrialDesignFisher'></span>

<h3>Description</h3>

<p>Trial design for Fisher's combination test.
</p>


<h3>Details</h3>

<p>This object should not be created directly; use <code><a href="#topic+getDesignFisher">getDesignFisher</a></code>
with suitable arguments to create a Fisher combination test design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>kMax</code></dt><dd><p>The maximum number of stages <code>K</code>. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level alpha, default is 0.025. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>userAlphaSpending</code></dt><dd><p>The user defined alpha spending. Contains the cumulative alpha-spending (type I error rate) up to each interim stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>criticalValues</code></dt><dd><p>The critical values for each stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>stageLevels</code></dt><dd><p>The adjusted significance levels to reach significance in a group sequential design. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>alphaSpent</code></dt><dd><p>The cumulative alpha spent at each stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>bindingFutility</code></dt><dd><p>If <code>TRUE</code>, the calculation of the critical values is affected by the futility bounds and the futility threshold is binding in the sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>) Is a logical vector of length 1.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The numerical tolerance, default is <code>1e-06</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>method</code></dt><dd><p>&quot;equalAlpha&quot;, &quot;fullAlpha&quot;, &quot;noInteraction&quot;, or &quot;userDefinedAlpha&quot;, default is &quot;equalAlpha&quot;. For details, see Wassmer, 1999, doi: 10.1002/(SICI)1521-4036(199906)41:3%3C279::AID-BIMJ279%3E3.0.CO;2-V.</p>
</dd>
<dt><code>alpha0Vec</code></dt><dd><p>The stopping for futility bounds for stage-wise p-values in Fisher's combination test. Is a numeric vector of length <code>kMax</code> minus 1 containing values between 0 and 1.</p>
</dd>
<dt><code>scale</code></dt><dd><p>The scale for Fisher's combination test. Numeric vector of length <code>kMax-1</code> that applies to Fisher's design with unequally spaced information rates. Is a numeric vector of length <code>kMax</code> minus 1 containing values between 0 and 1.</p>
</dd>
<dt><code>nonStochasticCurtailment</code></dt><dd><p>If <code>TRUE</code>, the stopping rule is based on the phenomenon of non-stochastic curtailment rather than stochastic reasoning. Is a logical vector of length 1.</p>
</dd>
<dt><code>sided</code></dt><dd><p>Describes if the alternative is one-sided (<code>1</code>) or two-sided (<code>2</code>). Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>simAlpha</code></dt><dd><p>The observed alpha error if simulations have been performed. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations used for simulations. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed used for random number generation. Is a numeric vector of length 1.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignFisher">getDesignFisher</a></code> for creating a Fisher combination test design.
</p>

<hr>
<h2 id='TrialDesignGroupSequential'>Group Sequential Design</h2><span id='topic+TrialDesignGroupSequential'></span>

<h3>Description</h3>

<p>Trial design for group sequential design.
</p>


<h3>Details</h3>

<p>This object should not be created directly;
use <code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential()</a></code>
with suitable arguments to create a group sequential design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>kMax</code></dt><dd><p>The maximum number of stages <code>K</code>. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level alpha, default is 0.025. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>userAlphaSpending</code></dt><dd><p>The user defined alpha spending. Contains the cumulative alpha-spending (type I error rate) up to each interim stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>criticalValues</code></dt><dd><p>The critical values for each stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>stageLevels</code></dt><dd><p>The adjusted significance levels to reach significance in a group sequential design. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>alphaSpent</code></dt><dd><p>The cumulative alpha spent at each stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>bindingFutility</code></dt><dd><p>If <code>TRUE</code>, the calculation of the critical values is affected by the futility bounds and the futility threshold is binding in the sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>) Is a logical vector of length 1.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The numerical tolerance, default is <code>1e-06</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>typeOfDesign</code></dt><dd><p>The type of design. Is a character vector of length 1.</p>
</dd>
<dt><code>beta</code></dt><dd><p>The Type II error rate necessary for providing sample size calculations  (e.g., in <code>getSampleSizeMeans</code>), beta spending function designs, or optimum designs, default is <code>0.20</code>. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>deltaWT</code></dt><dd><p>Delta for Wang &amp; Tsiatis Delta class. Is a numeric vector of length 1.</p>
</dd>
<dt><code>deltaPT1</code></dt><dd><p>Delta1 for Pampallona &amp; Tsiatis class rejecting H0 boundaries. Is a numeric vector of length 1.</p>
</dd>
<dt><code>deltaPT0</code></dt><dd><p>Delta0 for Pampallona &amp; Tsiatis class rejecting H1 (accepting H0) boundaries. Is a numeric vector of length 1.</p>
</dd>
<dt><code>futilityBounds</code></dt><dd><p>The futility bounds for each stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>gammaA</code></dt><dd><p>The parameter for the alpha spending function. Is a numeric vector of length 1.</p>
</dd>
<dt><code>gammaB</code></dt><dd><p>The parameter for the beta spending function. Is a numeric vector of length 1.</p>
</dd>
<dt><code>optimizationCriterion</code></dt><dd><p>The optimization criterion for optimum design within the Wang &amp; Tsiatis class (<code>"ASNH1"</code>, <code>"ASNIFH1"</code>, <code>"ASNsum"</code>), default is <code>"ASNH1"</code>.</p>
</dd>
<dt><code>sided</code></dt><dd><p>Describes if the alternative is one-sided (<code>1</code>) or two-sided (<code>2</code>). Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>betaSpent</code></dt><dd><p>The cumulative beta level spent at each stage of the trial. Only applicable for beta-spending designs. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>typeBetaSpending</code></dt><dd><p>The type of beta spending. Is a character vector of length 1.</p>
</dd>
<dt><code>userBetaSpending</code></dt><dd><p>The user defined beta spending. Contains the cumulative beta-spending up to each interim stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>power</code></dt><dd><p>The one-sided power at each stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>twoSidedPower</code></dt><dd><p>Specifies if power is defined two-sided at each stage of the trial. Is a logical vector of length 1.</p>
</dd>
<dt><code>constantBoundsHP</code></dt><dd><p>The constant bounds up to stage kMax - 1 for the Haybittle &amp; Peto design (default is 3). Is a numeric vector of length 1.</p>
</dd>
<dt><code>betaAdjustment</code></dt><dd><p>If <code>TRUE</code>, beta spending values are linearly adjusted if an overlapping of decision regions for futility stopping at earlier stages occurs. Only applicable for two-sided beta-spending designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>delayedInformation</code></dt><dd><p>Delay of information for delayed response designs. Is a numeric vector of length <code>kMax</code> minus 1 containing values between 0 and 1.</p>
</dd>
<dt><code>decisionCriticalValues</code></dt><dd><p>The decision critical values for each stage of the trial in a delayed response design. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>reversalProbabilities</code></dt><dd><p>The probability to switch from stopping the trial for success (or futility) and reaching non-rejection (or rejection) in a delayed response design. Is a numeric vector of length <code>kMax</code> minus 1 containing values between 0 and 1.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignGroupSequential">getDesignGroupSequential()</a></code> for creating a group sequential design.
</p>

<hr>
<h2 id='TrialDesignInverseNormal'>Inverse Normal Design</h2><span id='topic+TrialDesignInverseNormal'></span>

<h3>Description</h3>

<p>Trial design for inverse normal method.
</p>


<h3>Details</h3>

<p>This object should not be created directly; use <code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal()</a></code>
with suitable arguments to create a inverse normal design.
</p>


<h3>Fields</h3>


<dl>
<dt><code>kMax</code></dt><dd><p>The maximum number of stages <code>K</code>. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level alpha, default is 0.025. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>stages</code></dt><dd><p>The stage numbers of the trial. Is a numeric vector of length <code>kMax</code> containing whole numbers.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>userAlphaSpending</code></dt><dd><p>The user defined alpha spending. Contains the cumulative alpha-spending (type I error rate) up to each interim stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>criticalValues</code></dt><dd><p>The critical values for each stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>stageLevels</code></dt><dd><p>The adjusted significance levels to reach significance in a group sequential design. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>alphaSpent</code></dt><dd><p>The cumulative alpha spent at each stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>bindingFutility</code></dt><dd><p>If <code>TRUE</code>, the calculation of the critical values is affected by the futility bounds and the futility threshold is binding in the sense that the study must be stopped if the futility condition was reached (default is <code>FALSE</code>) Is a logical vector of length 1.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The numerical tolerance, default is <code>1e-06</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>typeOfDesign</code></dt><dd><p>The type of design. Is a character vector of length 1.</p>
</dd>
<dt><code>beta</code></dt><dd><p>The Type II error rate necessary for providing sample size calculations  (e.g., in <code>getSampleSizeMeans</code>), beta spending function designs, or optimum designs, default is <code>0.20</code>. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>deltaWT</code></dt><dd><p>Delta for Wang &amp; Tsiatis Delta class. Is a numeric vector of length 1.</p>
</dd>
<dt><code>deltaPT1</code></dt><dd><p>Delta1 for Pampallona &amp; Tsiatis class rejecting H0 boundaries. Is a numeric vector of length 1.</p>
</dd>
<dt><code>deltaPT0</code></dt><dd><p>Delta0 for Pampallona &amp; Tsiatis class rejecting H1 (accepting H0) boundaries. Is a numeric vector of length 1.</p>
</dd>
<dt><code>futilityBounds</code></dt><dd><p>The futility bounds for each stage of the trial. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>gammaA</code></dt><dd><p>The parameter for the alpha spending function. Is a numeric vector of length 1.</p>
</dd>
<dt><code>gammaB</code></dt><dd><p>The parameter for the beta spending function. Is a numeric vector of length 1.</p>
</dd>
<dt><code>optimizationCriterion</code></dt><dd><p>The optimization criterion for optimum design within the Wang &amp; Tsiatis class (<code>"ASNH1"</code>, <code>"ASNIFH1"</code>, <code>"ASNsum"</code>), default is <code>"ASNH1"</code>.</p>
</dd>
<dt><code>sided</code></dt><dd><p>Describes if the alternative is one-sided (<code>1</code>) or two-sided (<code>2</code>). Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>betaSpent</code></dt><dd><p>The cumulative beta level spent at each stage of the trial. Only applicable for beta-spending designs. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>typeBetaSpending</code></dt><dd><p>The type of beta spending. Is a character vector of length 1.</p>
</dd>
<dt><code>userBetaSpending</code></dt><dd><p>The user defined beta spending. Contains the cumulative beta-spending up to each interim stage. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>power</code></dt><dd><p>The one-sided power at each stage of the trial. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>twoSidedPower</code></dt><dd><p>Specifies if power is defined two-sided at each stage of the trial. Is a logical vector of length 1.</p>
</dd>
<dt><code>constantBoundsHP</code></dt><dd><p>The constant bounds up to stage kMax - 1 for the Haybittle &amp; Peto design (default is 3). Is a numeric vector of length 1.</p>
</dd>
<dt><code>betaAdjustment</code></dt><dd><p>If <code>TRUE</code>, beta spending values are linearly adjusted if an overlapping of decision regions for futility stopping at earlier stages occurs. Only applicable for two-sided beta-spending designs. Is a logical vector of length 1.</p>
</dd>
<dt><code>delayedInformation</code></dt><dd><p>Delay of information for delayed response designs. Is a numeric vector of length <code>kMax</code> minus 1 containing values between 0 and 1.</p>
</dd>
<dt><code>decisionCriticalValues</code></dt><dd><p>The decision critical values for each stage of the trial in a delayed response design. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>reversalProbabilities</code></dt><dd><p>The probability to switch from stopping the trial for success (or futility) and reaching non-rejection (or rejection) in a delayed response design. Is a numeric vector of length <code>kMax</code> minus 1 containing values between 0 and 1.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignInverseNormal">getDesignInverseNormal()</a></code> for creating a inverse normal design.
</p>

<hr>
<h2 id='TrialDesignPlan'>Basic Trial Design Plan</h2><span id='topic+TrialDesignPlan'></span>

<h3>Description</h3>

<p>Basic class for trial design plans.
</p>


<h3>Details</h3>

<p><code>TrialDesignPlan</code> is the basic class for
</p>

<ul>
<li> <p><code><a href="#topic+TrialDesignPlanMeans">TrialDesignPlanMeans</a></code>,
</p>
</li>
<li> <p><code><a href="#topic+TrialDesignPlanRates">TrialDesignPlanRates</a></code>, and
</p>
</li>
<li> <p><code><a href="#topic+TrialDesignPlanSurvival">TrialDesignPlanSurvival</a></code>.
</p>
</li></ul>


<hr>
<h2 id='TrialDesignPlanCountData'>Trial Design Plan Count Data</h2><span id='topic+TrialDesignPlanCountData'></span>

<h3>Description</h3>

<p>Trial design plan for count data.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getSampleSizeCounts">getSampleSizeCounts()</a></code>
with suitable arguments to create a design plan for a dataset of rates.
</p>


<h3>Fields</h3>


<dl>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>optimumAllocationRatio</code></dt><dd><p>The allocation ratio that is optimum with respect to the overall sample size at given power. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>lambda1</code></dt><dd><p>The assumed hazard rate in the treatment group. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>lambda2</code></dt><dd><p>The assumed hazard rate in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>A numeric value or vector that represents the assumed rate of a homogeneous Poisson process in the pooled treatment groups Is a numeric vector.</p>
</dd>
<dt><code>theta</code></dt><dd><p>A vector of standardized effect sizes (theta values). Is a numeric vector.</p>
</dd>
<dt><code>nFixed</code></dt><dd><p>The sample size in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed1</code></dt><dd><p>The sample size in treatment arm 1 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed2</code></dt><dd><p>The sample size in treatment arm 2 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects1</code></dt><dd><p>The maximum number of subjects in treatment arm 1. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects2</code></dt><dd><p>The maximum number of subjects in treatment arm 2. Is a numeric vector.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>overdispersion</code></dt><dd><p>A numeric value that represents the assumed overdispersion of the negative binomial distribution Is a numeric vector.</p>
</dd>
<dt><code>fixedExposureTime</code></dt><dd><p>If specified, the fixed time of exposure per subject for count data Is a numeric vector.</p>
</dd>
<dt><code>accrualTime</code></dt><dd><p>The assumed accrual time intervals for the study. Is a numeric vector.</p>
</dd>
<dt><code>accrualIntensity</code></dt><dd><p>The absolute accrual intensities. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>followUpTime</code></dt><dd><p>The assumed follow-up time for the study. Is a numeric vector of length 1.</p>
</dd>
<dt><code>calendarTime</code></dt><dd><p>The calendar time Is a numeric vector.</p>
</dd>
<dt><code>expectedStudyDurationH1</code></dt><dd><p>The expected study duration under H1 Is a numeric vector.</p>
</dd>
<dt><code>studyTime</code></dt><dd><p>The study time Is a numeric vector.</p>
</dd>
<dt><code>numberOfSubjects</code></dt><dd><p>In simulation results data set: The number of subjects under consideration when the interim analysis takes place.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH1</code></dt><dd><p>The expected number of subjects under H1. Is a numeric vector.</p>
</dd>
<dt><code>informationOverStages</code></dt><dd><p>The information over stages Is a numeric vector.</p>
</dd>
<dt><code>expectedInformationH0</code></dt><dd><p>The expected information under H0 Is a numeric vector.</p>
</dd>
<dt><code>expectedInformationH01</code></dt><dd><p>The expected information under H0/H1 Is a numeric vector.</p>
</dd>
<dt><code>expectedInformationH1</code></dt><dd><p>The expected information under H1 Is a numeric vector.</p>
</dd>
<dt><code>maxInformation</code></dt><dd><p>The maximum information. Is a numeric vector of length 1 containing a whole number.</p>
</dd>
<dt><code>futilityBoundsPValueScale</code></dt><dd><p>The futility bounds for each stage of the trial on the p-value scale. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='TrialDesignPlanMeans'>Trial Design Plan Means</h2><span id='topic+TrialDesignPlanMeans'></span>

<h3>Description</h3>

<p>Trial design plan for means.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getSampleSizeMeans">getSampleSizeMeans()</a></code>
with suitable arguments to create a design plan for a dataset of means.
</p>


<h3>Fields</h3>


<dl>
<dt><code>meanRatio</code></dt><dd><p>Specifies if the sample size for one-sided testing of H0: <code>mu1/mu2 = thetaH0</code> has been calculated. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>alternative</code></dt><dd><p>The alternative hypothesis value(s) for testing means. Is a numeric vector.</p>
</dd>
<dt><code>stDev</code></dt><dd><p>The standard deviation used for sample size and power calculation. Is a numeric vector of length 1.</p>
</dd>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>optimumAllocationRatio</code></dt><dd><p>The allocation ratio that is optimum with respect to the overall sample size at given power. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>effect</code></dt><dd><p>The effect for randomly creating normally distributed responses. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>nFixed</code></dt><dd><p>The sample size in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed1</code></dt><dd><p>The sample size in treatment arm 1 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed2</code></dt><dd><p>The sample size in treatment arm 2 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects1</code></dt><dd><p>The maximum number of subjects in treatment arm 1. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects2</code></dt><dd><p>The maximum number of subjects in treatment arm 2. Is a numeric vector.</p>
</dd>
<dt><code>numberOfSubjects</code></dt><dd><p>In simulation results data set: The number of subjects under consideration when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects1</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 1 when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects2</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 2 when the interim analysis takes place.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH0</code></dt><dd><p>The expected number of subjects under H0. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH01</code></dt><dd><p>The expected number of subjects under a value between H0 and H1. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH1</code></dt><dd><p>The expected number of subjects under H1. Is a numeric vector.</p>
</dd>
<dt><code>criticalValuesEffectScale</code></dt><dd><p>The critical values for each stage of the trial on the effect size scale.</p>
</dd>
<dt><code>criticalValuesEffectScaleLower</code></dt><dd><p>The lower critical values for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>criticalValuesEffectScaleUpper</code></dt><dd><p>The upper critical values for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>criticalValuesPValueScale</code></dt><dd><p>The critical values for each stage of the trial on the p-value scale.</p>
</dd>
<dt><code>futilityBoundsEffectScale</code></dt><dd><p>The futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsEffectScaleLower</code></dt><dd><p>The lower futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsEffectScaleUpper</code></dt><dd><p>The upper futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsPValueScale</code></dt><dd><p>The futility bounds for each stage of the trial on the p-value scale. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='TrialDesignPlanRates'>Trial Design Plan Rates</h2><span id='topic+TrialDesignPlanRates'></span>

<h3>Description</h3>

<p>Trial design plan for rates.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getSampleSizeRates">getSampleSizeRates()</a></code>
with suitable arguments to create a design plan for a dataset of rates.
</p>


<h3>Fields</h3>


<dl>
<dt><code>riskRatio</code></dt><dd><p>Specifies if the sample size for one-sided testing of H0: <code>pi1 / pi2 = thetaH0</code> has been calculated. Is a logical vector of length 1.</p>
</dd>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>normalApproximation</code></dt><dd><p>Describes if a normal approximation was used when calculating p-values. Default for means is <code>FALSE</code> and <code>TRUE</code> for rates and hazard ratio. Is a logical vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed probability or probabilities in the active treatment group in two-group designs, or the alternative probability for a one-group design.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed probability in the reference group for two-group designs. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>groups</code></dt><dd><p>The group numbers. Is a numeric vector.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>optimumAllocationRatio</code></dt><dd><p>The allocation ratio that is optimum with respect to the overall sample size at given power. Is a logical vector of length 1.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>effect</code></dt><dd><p>The effect for randomly creating normally distributed responses. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>nFixed</code></dt><dd><p>The sample size in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed1</code></dt><dd><p>The sample size in treatment arm 1 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed2</code></dt><dd><p>The sample size in treatment arm 2 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects1</code></dt><dd><p>The maximum number of subjects in treatment arm 1. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects2</code></dt><dd><p>The maximum number of subjects in treatment arm 2. Is a numeric vector.</p>
</dd>
<dt><code>numberOfSubjects</code></dt><dd><p>In simulation results data set: The number of subjects under consideration when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects1</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 1 when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects2</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 2 when the interim analysis takes place.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH0</code></dt><dd><p>The expected number of subjects under H0. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH01</code></dt><dd><p>The expected number of subjects under a value between H0 and H1. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH1</code></dt><dd><p>The expected number of subjects under H1. Is a numeric vector.</p>
</dd>
<dt><code>criticalValuesEffectScale</code></dt><dd><p>The critical values for each stage of the trial on the effect size scale.</p>
</dd>
<dt><code>criticalValuesEffectScaleLower</code></dt><dd><p>The lower critical values for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>criticalValuesEffectScaleUpper</code></dt><dd><p>The upper critical values for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>criticalValuesPValueScale</code></dt><dd><p>The critical values for each stage of the trial on the p-value scale.</p>
</dd>
<dt><code>futilityBoundsEffectScale</code></dt><dd><p>The futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsEffectScaleLower</code></dt><dd><p>The lower futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsEffectScaleUpper</code></dt><dd><p>The upper futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsPValueScale</code></dt><dd><p>The futility bounds for each stage of the trial on the p-value scale. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='TrialDesignPlanSurvival'>Trial Design Plan Survival</h2><span id='topic+TrialDesignPlanSurvival'></span>

<h3>Description</h3>

<p>Trial design plan for survival data.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; use <code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival()</a></code>
with suitable arguments to create a design plan for a dataset of survival data.
</p>


<h3>Fields</h3>


<dl>
<dt><code>thetaH0</code></dt><dd><p>The difference or assumed effect under H0. Is a numeric vector of length 1.</p>
</dd>
<dt><code>typeOfComputation</code></dt><dd><p>The type of computation used, either <code>"Schoenfeld", "Freedman"</code>, or <code>"HsiehFreedman"</code>.</p>
</dd>
<dt><code>directionUpper</code></dt><dd><p>Specifies the direction of the alternative, only applicable for one-sided testing. Default is <code>TRUE</code> which means that larger values of the test statistics yield smaller p-values. Is a logical vector of length 1.</p>
</dd>
<dt><code>pi1</code></dt><dd><p>The assumed event rate in the treatment group. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>pi2</code></dt><dd><p>The assumed event rate in the control group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>median1</code></dt><dd><p>The assumed median survival time in the treatment group. Is a numeric vector.</p>
</dd>
<dt><code>median2</code></dt><dd><p>The assumed median survival time in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>lambda1</code></dt><dd><p>The assumed hazard rate in the treatment group. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>lambda2</code></dt><dd><p>The assumed hazard rate in the reference group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>hazardRatio</code></dt><dd><p>The hazard ratios under consideration. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>maxNumberOfSubjects</code></dt><dd><p>The maximum number of subjects for power calculations. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects1</code></dt><dd><p>The maximum number of subjects in treatment arm 1. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfSubjects2</code></dt><dd><p>The maximum number of subjects in treatment arm 2. Is a numeric vector.</p>
</dd>
<dt><code>maxNumberOfEvents</code></dt><dd><p>The maximum number of events for power calculations. Is a positive numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>allocationRatioPlanned</code></dt><dd><p>The planned allocation ratio (<code>n1 / n2</code>) for the groups. For multi-arm designs, it is the allocation ratio relating the active arm(s) to the control. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>optimumAllocationRatio</code></dt><dd><p>The allocation ratio that is optimum with respect to the overall sample size at given power. Is a logical vector of length 1.</p>
</dd>
<dt><code>accountForObservationTimes</code></dt><dd><p>If <code>FALSE</code>, only the event rates are used for the calculation of the maximum number of subjects. Is a logical vector of length 1.</p>
</dd>
<dt><code>eventTime</code></dt><dd><p>The assumed time under which the event rates are calculated. Is a numeric vector of length 1.</p>
</dd>
<dt><code>accrualTime</code></dt><dd><p>The assumed accrual time intervals for the study. Is a numeric vector.</p>
</dd>
<dt><code>totalAccrualTime</code></dt><dd><p>The total accrual time, i.e., the maximum of <code>accrualTime</code>. Is a positive numeric vector of length 1.</p>
</dd>
<dt><code>accrualIntensity</code></dt><dd><p>The absolute accrual intensities. Is a numeric vector of length <code>kMax</code>.</p>
</dd>
<dt><code>accrualIntensityRelative</code></dt><dd><p>The relative accrual intensities.</p>
</dd>
<dt><code>kappa</code></dt><dd><p>The shape of the Weibull distribution if <code>kappa!=1</code>. Is a numeric vector of length 1.</p>
</dd>
<dt><code>piecewiseSurvivalTime</code></dt><dd><p>The time intervals for the piecewise definition of the exponential survival time cumulative distribution function. Is a numeric vector.</p>
</dd>
<dt><code>followUpTime</code></dt><dd><p>The assumed follow-up time for the study. Is a numeric vector of length 1.</p>
</dd>
<dt><code>dropoutRate1</code></dt><dd><p>The assumed drop-out rate in the treatment group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>dropoutRate2</code></dt><dd><p>The assumed drop-out rate in the control group. Is a numeric vector of length 1 containing a value between 0 and 1.</p>
</dd>
<dt><code>dropoutTime</code></dt><dd><p>The assumed time for drop-out rates in the control and treatment group. Is a numeric vector of length 1.</p>
</dd>
<dt><code>chi</code></dt><dd><p>The calculated event probability at end of trial. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfEvents</code></dt><dd><p>The expected number of events under specified alternative. Is a numeric vector.</p>
</dd>
<dt><code>eventsFixed</code></dt><dd><p>The number of events in a fixed sample size design. Is a numeric vector.</p>
</dd>
<dt><code>nFixed</code></dt><dd><p>The sample size in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed1</code></dt><dd><p>The sample size in treatment arm 1 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>nFixed2</code></dt><dd><p>The sample size in treatment arm 2 in a fixed (one-stage) design. Is a positive numeric vector.</p>
</dd>
<dt><code>overallReject</code></dt><dd><p>The overall rejection probability. Is a numeric vector.</p>
</dd>
<dt><code>rejectPerStage</code></dt><dd><p>The probability to reject a hypothesis per stage of the trial. Is a numeric matrix.</p>
</dd>
<dt><code>futilityStop</code></dt><dd><p>In simulation results data set: indicates whether trial is stopped for futility or not.</p>
</dd>
<dt><code>futilityPerStage</code></dt><dd><p>The per-stage probabilities of stopping the trial for futility. Is a numeric matrix.</p>
</dd>
<dt><code>earlyStop</code></dt><dd><p>The probability to stopping the trial either for efficacy or futility. Is a numeric vector.</p>
</dd>
<dt><code>informationRates</code></dt><dd><p>The information rates (that must be fixed prior to the trial), default is <code>(1:kMax) / kMax</code>. Is a numeric vector of length <code>kMax</code> containing values between 0 and 1.</p>
</dd>
<dt><code>analysisTime</code></dt><dd><p>The estimated time of analysis. Is a numeric matrix.</p>
</dd>
<dt><code>studyDurationH1</code></dt><dd><p>The study duration under the alternative hypothesis. Is a positive numeric vector.</p>
</dd>
<dt><code>studyDuration</code></dt><dd><p>The study duration for specified effect size. Is a positive numeric vector.</p>
</dd>
<dt><code>maxStudyDuration</code></dt><dd><p>The maximum study duration in survival designs. Is a numeric vector.</p>
</dd>
<dt><code>eventsPerStage</code></dt><dd><p>Deprecated: use <code>singleEventsPerStage</code> or <code>cumulativeEventsPerStage</code> instead Is a numeric matrix.</p>
</dd>
<dt><code>singleEventsPerStage</code></dt><dd><p>The single number of events per stage. Is a numeric matrix.</p>
</dd>
<dt><code>cumulativeEventsPerStage</code></dt><dd><p>The cumulative number of events per stage. Is a numeric matrix.</p>
</dd>
<dt><code>expectedEventsH0</code></dt><dd><p>The expected number of events under H0. Is a numeric vector.</p>
</dd>
<dt><code>expectedEventsH01</code></dt><dd><p>The expected number of events under a value between H0 and H1. Is a numeric vector.</p>
</dd>
<dt><code>expectedEventsH1</code></dt><dd><p>The expected number of events under H1. Is a numeric vector.</p>
</dd>
<dt><code>numberOfSubjects</code></dt><dd><p>In simulation results data set: The number of subjects under consideration when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects1</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 1 when the interim analysis takes place.</p>
</dd>
<dt><code>numberOfSubjects2</code></dt><dd><p>In simulation results data set: The number of subjects under consideration in treatment arm 2 when the interim analysis takes place.</p>
</dd>
<dt><code>expectedNumberOfSubjectsH1</code></dt><dd><p>The expected number of subjects under H1. Is a numeric vector.</p>
</dd>
<dt><code>expectedNumberOfSubjects</code></dt><dd><p>The expected number of subjects under specified alternative.</p>
</dd>
<dt><code>criticalValuesEffectScale</code></dt><dd><p>The critical values for each stage of the trial on the effect size scale.</p>
</dd>
<dt><code>criticalValuesEffectScaleLower</code></dt><dd><p>The lower critical values for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>criticalValuesEffectScaleUpper</code></dt><dd><p>The upper critical values for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>criticalValuesPValueScale</code></dt><dd><p>The critical values for each stage of the trial on the p-value scale.</p>
</dd>
<dt><code>futilityBoundsEffectScale</code></dt><dd><p>The futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsEffectScaleLower</code></dt><dd><p>The lower futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsEffectScaleUpper</code></dt><dd><p>The upper futility bounds for each stage of the trial on the effect size scale. Is a numeric matrix.</p>
</dd>
<dt><code>futilityBoundsPValueScale</code></dt><dd><p>The futility bounds for each stage of the trial on the p-value scale. Is a numeric matrix.</p>
</dd>
</dl>

<hr>
<h2 id='TrialDesignSet'>Class for trial design sets.</h2><span id='topic+TrialDesignSet'></span>

<h3>Description</h3>

<p><code>TrialDesignSet</code> is a class for creating a collection of different trial designs.
</p>


<h3>Details</h3>

<p>This object cannot be created directly; better use <code><a href="#topic+getDesignSet">getDesignSet()</a></code>
with suitable arguments to create a set of designs.
</p>


<h3>Fields</h3>


<dl>
<dt><code>designs</code></dt><dd><p>The trial designs to be compared.</p>
</dd>
<dt><code>design</code></dt><dd><p>The trial design.</p>
</dd>
<dt><code>variedParameters</code></dt><dd><p>A character vector containing the names of the parameters that vary between designs.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+getDesignSet">getDesignSet()</a></code>
</p>

<hr>
<h2 id='utilitiesForPiecewiseExponentialDistribution'>The Piecewise Exponential Distribution</h2><span id='topic+utilitiesForPiecewiseExponentialDistribution'></span><span id='topic+getPiecewiseExponentialDistribution'></span><span id='topic+ppwexp'></span><span id='topic+getPiecewiseExponentialQuantile'></span><span id='topic+qpwexp'></span><span id='topic+getPiecewiseExponentialRandomNumbers'></span><span id='topic+rpwexp'></span>

<h3>Description</h3>

<p>Distribution function, quantile function and random number generation for the
piecewise exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPiecewiseExponentialDistribution(
  time,
  ...,
  piecewiseSurvivalTime = NA_real_,
  piecewiseLambda = NA_real_,
  kappa = 1
)

ppwexp(t, ..., s = NA_real_, lambda = NA_real_, kappa = 1)

getPiecewiseExponentialQuantile(
  quantile,
  ...,
  piecewiseSurvivalTime = NA_real_,
  piecewiseLambda = NA_real_,
  kappa = 1
)

qpwexp(q, ..., s = NA_real_, lambda = NA_real_, kappa = 1)

getPiecewiseExponentialRandomNumbers(
  n,
  ...,
  piecewiseSurvivalTime = NA_real_,
  piecewiseLambda = NA_real_,
  kappa = 1
)

rpwexp(n, ..., s = NA_real_, lambda = NA_real_, kappa = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utilitiesForPiecewiseExponentialDistribution_+3A_...">...</code></td>
<td>
<p>Ensures that all arguments (starting from the &quot;...&quot;) are to be named and
that a warning will be displayed if unknown arguments are passed.</p>
</td></tr>
<tr><td><code id="utilitiesForPiecewiseExponentialDistribution_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
<tr><td><code id="utilitiesForPiecewiseExponentialDistribution_+3A_t">t</code>, <code id="utilitiesForPiecewiseExponentialDistribution_+3A_time">time</code></td>
<td>
<p>Vector of time values.</p>
</td></tr>
<tr><td><code id="utilitiesForPiecewiseExponentialDistribution_+3A_s">s</code>, <code id="utilitiesForPiecewiseExponentialDistribution_+3A_piecewisesurvivaltime">piecewiseSurvivalTime</code></td>
<td>
<p>Vector of start times defining the &quot;time pieces&quot;.</p>
</td></tr>
<tr><td><code id="utilitiesForPiecewiseExponentialDistribution_+3A_lambda">lambda</code>, <code id="utilitiesForPiecewiseExponentialDistribution_+3A_piecewiselambda">piecewiseLambda</code></td>
<td>
<p>Vector of lambda values (hazard rates) corresponding to the start times.</p>
</td></tr>
<tr><td><code id="utilitiesForPiecewiseExponentialDistribution_+3A_q">q</code>, <code id="utilitiesForPiecewiseExponentialDistribution_+3A_quantile">quantile</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="utilitiesForPiecewiseExponentialDistribution_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getPiecewiseExponentialDistribution()</code> (short: <code>ppwexp()</code>),
<code>getPiecewiseExponentialQuantile()</code> (short: <code>qpwexp()</code>), and
<code>getPiecewiseExponentialRandomNumbers()</code> (short: <code>rpwexp()</code>) provide
probabilities, quantiles, and random numbers according to a piecewise
exponential or a Weibull distribution.
The piecewise definition is performed through a vector of
starting times (<code>piecewiseSurvivalTime</code>) and a vector of hazard rates (<code>piecewiseLambda</code>).
You can also use a list that defines the starting times and piecewise
lambdas together and define piecewiseSurvivalTime as this list.
The list needs to have the form, e.g.,
piecewiseSurvivalTime &lt;- list(
&quot;0 - &lt;6&quot;   = 0.025,
&quot;6 - &lt;9&quot;   = 0.04,
&quot;9 - &lt;15&quot;  = 0.015,
&quot;&gt;=15&quot;      = 0.007) .
For the Weibull case, you can also specify a shape parameter kappa in order to
calculate probabilities, quantiles, or random numbers.
In this case, no piecewise definition is possible, i.e., only piecewiseLambda
(as a single value) and kappa need to be specified.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value or vector will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate probabilties for a range of time values for a
# piecewise exponential distribution with hazard rates
# 0.025, 0.04, 0.015, and 0.007 in the intervals
# [0, 6), [6, 9), [9, 15), [15, Inf), respectively,
# and re-return the time values:
piecewiseSurvivalTime &lt;- list(
    "0 - &lt;6"   = 0.025,
    "6 - &lt;9"   = 0.04,
    "9 - &lt;15"  = 0.015,
    "&gt;=15"     = 0.01
)
y &lt;- getPiecewiseExponentialDistribution(seq(0, 150, 15),
    piecewiseSurvivalTime = piecewiseSurvivalTime
)
getPiecewiseExponentialQuantile(y,
    piecewiseSurvivalTime = piecewiseSurvivalTime
)

## End(Not run)

</code></pre>

<hr>
<h2 id='utilitiesForSurvivalTrials'>Survival Helper Functions for Conversion of Pi, Lambda, Median</h2><span id='topic+utilitiesForSurvivalTrials'></span><span id='topic+getLambdaByPi'></span><span id='topic+getLambdaByMedian'></span><span id='topic+getHazardRatioByPi'></span><span id='topic+getPiByLambda'></span><span id='topic+getPiByMedian'></span><span id='topic+getMedianByLambda'></span><span id='topic+getMedianByPi'></span>

<h3>Description</h3>

<p>Functions to convert pi, lambda and median values into each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLambdaByPi(piValue, eventTime = 12, kappa = 1)

getLambdaByMedian(median, kappa = 1)

getHazardRatioByPi(pi1, pi2, eventTime = 12, kappa = 1)

getPiByLambda(lambda, eventTime = 12, kappa = 1)

getPiByMedian(median, eventTime = 12, kappa = 1)

getMedianByLambda(lambda, kappa = 1)

getMedianByPi(piValue, eventTime = 12, kappa = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utilitiesForSurvivalTrials_+3A_pivalue">piValue</code>, <code id="utilitiesForSurvivalTrials_+3A_pi1">pi1</code>, <code id="utilitiesForSurvivalTrials_+3A_pi2">pi2</code>, <code id="utilitiesForSurvivalTrials_+3A_lambda">lambda</code>, <code id="utilitiesForSurvivalTrials_+3A_median">median</code></td>
<td>
<p>Value that shall be converted.</p>
</td></tr>
<tr><td><code id="utilitiesForSurvivalTrials_+3A_eventtime">eventTime</code></td>
<td>
<p>The assumed time under which the event rates are calculated, default is <code>12</code>.</p>
</td></tr>
<tr><td><code id="utilitiesForSurvivalTrials_+3A_kappa">kappa</code></td>
<td>
<p>A numeric value &gt; 0. A <code>kappa != 1</code> will be used for the specification
of the shape of the Weibull distribution.
Default is <code>1</code>, i.e., the exponential survival distribution is used instead of the Weibull distribution.
Note that the Weibull distribution cannot be used for the piecewise definition of
the survival time distribution, i.e., only <code>piecewiselambda</code> (as a single value) and <code>kappa</code>
can be specified.
This function is equivalent to <code>pweibull(t, shape = kappa, scale = 1 / lambda)</code>
of the <code>stats</code> package, i.e., the scale parameter is <code>1 / 'hazard rate'</code>.<br />
For example,
<code>getPiecewiseExponentialDistribution(time = 130, piecewiseLambda = 0.01, kappa = 4.2)</code>
and <code>pweibull(q = 130, shape = 4.2, scale = 1 / 0.01)</code> provide the sample result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be used, e.g., to convert median values into pi or lambda values for usage in
<code><a href="#topic+getSampleSizeSurvival">getSampleSizeSurvival()</a></code> or <code><a href="#topic+getPowerSurvival">getPowerSurvival()</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> value or vector will be returned.
</p>

<hr>
<h2 id='writeDataset'>Write Dataset</h2><span id='topic+writeDataset'></span>

<h3>Description</h3>

<p>Writes a dataset to a CSV file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeDataset(
  dataset,
  file,
  ...,
  append = FALSE,
  quote = TRUE,
  sep = ",",
  eol = "\n",
  na = "NA",
  dec = ".",
  row.names = TRUE,
  col.names = NA,
  qmethod = "double",
  fileEncoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeDataset_+3A_dataset">dataset</code></td>
<td>
<p>A dataset.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_file">file</code></td>
<td>
<p>The target CSV file.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_append">append</code></td>
<td>
<p>Logical. Only relevant if file is a character string.
If <code>TRUE</code>, the output is appended to the file. If <code>FALSE</code>, any existing file of the name is destroyed.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_quote">quote</code></td>
<td>
<p>The set of quoting characters. To disable quoting altogether, use
quote = &quot;&quot;. See scan for the behavior on quotes embedded in quotes. Quoting is only
considered for columns read as character, which is all of them unless <code>colClasses</code> is specified.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_sep">sep</code></td>
<td>
<p>The field separator character. Values on each line of the file are separated
by this character. If sep = &quot;,&quot; (the default for <code>writeDataset</code>) the separator is a comma.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_eol">eol</code></td>
<td>
<p>The character(s) to print at the end of each line (row).</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_na">na</code></td>
<td>
<p>The string to use for missing values in the data.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_dec">dec</code></td>
<td>
<p>The character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_row.names">row.names</code></td>
<td>
<p>Either a logical value indicating whether the row names of <code>dataset</code> are
to be written along with  <code>dataset</code>, or a character vector of row names to be written.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_col.names">col.names</code></td>
<td>
<p>Either a logical value indicating whether the column names of  <code>dataset</code> are
to be written along with  <code>dataset</code>, or a character vector of column names to be written.
See the section on 'CSV files' for the meaning of <code>col.names = NA</code>.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_qmethod">qmethod</code></td>
<td>
<p>A character string specifying how to deal with embedded double quote characters
when quoting strings. Must be one of &quot;double&quot; (default in <code>writeDataset</code>) or &quot;escape&quot;.</p>
</td></tr>
<tr><td><code id="writeDataset_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>Character string: if non-empty declares the encoding used on a file
(not a connection) so the character data can be re-encoded.
See the 'Encoding' section of the help for file, the 'R Data Import/Export Manual' and 'Note'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+writeDataset">writeDataset()</a></code> is a wrapper function that coerces the dataset to a data frame and uses <br />
<code><a href="utils.html#topic+write.table">write.table</a></code> to write it to a CSV file.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+writeDatasets">writeDatasets()</a></code> for writing multiple datasets,
</p>
</li>
<li> <p><code><a href="#topic+readDataset">readDataset()</a></code> for reading a single dataset,
</p>
</li>
<li> <p><code><a href="#topic+readDatasets">readDatasets()</a></code> for reading multiple datasets.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
datasetOfRates &lt;- getDataset(
    n1 = c(11, 13, 12, 13),
    n2 = c(8, 10, 9, 11),
    events1 = c(10, 10, 12, 12),
    events2 = c(3, 5, 5, 6)
)
writeDataset(datasetOfRates, "dataset_rates.csv")

## End(Not run)

</code></pre>

<hr>
<h2 id='writeDatasets'>Write Multiple Datasets</h2><span id='topic+writeDatasets'></span>

<h3>Description</h3>

<p>Writes a list of datasets to a CSV file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeDatasets(
  datasets,
  file,
  ...,
  append = FALSE,
  quote = TRUE,
  sep = ",",
  eol = "\n",
  na = "NA",
  dec = ".",
  row.names = TRUE,
  col.names = NA,
  qmethod = "double",
  fileEncoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeDatasets_+3A_datasets">datasets</code></td>
<td>
<p>A list of datasets.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_file">file</code></td>
<td>
<p>The target CSV file.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_append">append</code></td>
<td>
<p>Logical. Only relevant if file is a character string.
If <code>TRUE</code>, the output is appended to the file. If FALSE, any existing file of the name is destroyed.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_quote">quote</code></td>
<td>
<p>The set of quoting characters. To disable quoting altogether, use
quote = &quot;&quot;. See scan for the behavior on quotes embedded in quotes. Quoting is only
considered for columns read as character, which is all of them unless <code>colClasses</code> is specified.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_sep">sep</code></td>
<td>
<p>The field separator character. Values on each line of the file are separated
by this character. If sep = &quot;,&quot; (the default for <code>writeDatasets</code>) the separator is a comma.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_eol">eol</code></td>
<td>
<p>The character(s) to print at the end of each line (row).</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_na">na</code></td>
<td>
<p>The string to use for missing values in the data.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_dec">dec</code></td>
<td>
<p>The character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_row.names">row.names</code></td>
<td>
<p>Either a logical value indicating whether the row names of <code>dataset</code> are
to be written along with  <code>dataset</code>, or a character vector of row names to be written.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_col.names">col.names</code></td>
<td>
<p>Either a logical value indicating whether the column names of  <code>dataset</code> are
to be written along with  <code>dataset</code>, or a character vector of column names to be written.
See the section on 'CSV files' for the meaning of <code>col.names = NA</code>.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_qmethod">qmethod</code></td>
<td>
<p>A character string specifying how to deal with embedded double quote characters
when quoting strings. Must be one of &quot;double&quot; (default in <code>writeDatasets</code>) or &quot;escape&quot;.</p>
</td></tr>
<tr><td><code id="writeDatasets_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>Character string: if non-empty declares the encoding used on a file
(not a connection) so the character data can be re-encoded.
See the 'Encoding' section of the help for file, the 'R Data Import/Export Manual' and 'Note'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of the CSV file is optimized for usage of <code><a href="#topic+readDatasets">readDatasets()</a></code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+writeDataset">writeDataset()</a></code> for writing a single dataset,
</p>
</li>
<li> <p><code><a href="#topic+readDatasets">readDatasets()</a></code> for reading multiple datasets,
</p>
</li>
<li> <p><code><a href="#topic+readDataset">readDataset()</a></code> for reading a single dataset.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d1 &lt;- getDataset(
    n1 = c(11, 13, 12, 13),
    n2 = c(8, 10, 9, 11),
    events1 = c(10, 10, 12, 12),
    events2 = c(3, 5, 5, 6)
)
d2 &lt;- getDataset(
    n1 = c(9, 13, 12, 13),
    n2 = c(6, 10, 9, 11),
    events1 = c(10, 10, 12, 12),
    events2 = c(4, 5, 5, 6)
)
datasets &lt;- list(d1, d2)
writeDatasets(datasets, "datasets_rates.csv")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
