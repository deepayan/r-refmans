<!DOCTYPE html><html><head><title>Help for package plink</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plink}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plink-package'><p>IRT Separate Calibration Linking Methods</p></a></li>
<li><a href='#act.mcm'><p>ACT Mathematics Test 1997-1998 Multiple-Choice Model</p></a></li>
<li><a href='#act.nrm'><p>ACT Mathematics Test 1997-1998 Nominal Response Model</p></a></li>
<li><a href='#as.irt.pars'><p>irt.pars objects</p></a></li>
<li><a href='#as.poly.mod'><p>poly.mod objects</p></a></li>
<li><a href='#as.weight'><p>Calibration Weights</p></a></li>
<li><a href='#combine.pars'><p>Combine Item Parameters for Multiple Groups</p></a></li>
<li><a href='#dgn'><p>Unidimensional Mixed-Format Item Parameters</p></a></li>
<li><a href='#drm-methods'><p>Dichotomous Response Model Probabilities</p></a></li>
<li><a href='#equate-methods'><p>IRT True Score and Observed Score Equating</p></a></li>
<li><a href='#gpcm-methods'><p>Generalized Partial Credit Model Response Probabilities</p></a></li>
<li><a href='#grm-methods'><p>Graded Response Model Probabilities</p></a></li>
<li><a href='#irt.pars-class'><p>Class &quot;irt.pars&quot;</p></a></li>
<li><a href='#irt.prob-class'><p>Class &quot;irt.prob&quot;</p></a></li>
<li><a href='#is.irt.pars'><p>Identify Class</p></a></li>
<li><a href='#KB04'><p>Kolen - Brennan (2004)</p></a></li>
<li><a href='#link-class'><p>Class &quot;link&quot;</p></a></li>
<li><a href='#link.con'><p>Extract Output Information</p></a></li>
<li><a href='#list.poly-class'><p>Class Combinations</p></a></li>
<li><a href='#mcm-methods'><p>Multiple-Choice Model Response Probabilities</p></a></li>
<li><a href='#md.mixed'><p>Multidimensional Mixed-Format Tests</p></a></li>
<li><a href='#mixed-methods'><p>Mixed-Format Response Probabilities</p></a></li>
<li><a href='#nrm-methods'><p>Nominal Response Model Probabilities</p></a></li>
<li><a href='#plink-methods'><p>Separate Calibration</p></a></li>
<li><a href='#plot.irt.prob'><p>Plot Item Stuff</p></a></li>
<li><a href='#poly.mod-class'><p>Class &quot;poly.mod&quot;</p></a></li>
<li><a href='#read.bilog'><p>Import Parameters from IRT Software</p></a></li>
<li><a href='#reading'><p>Multi-Group Mixed-Format Reading Assessment</p></a></li>
<li><a href='#reckase9'><p>Reckase MIRT Multidimensional Item Parameters</p></a></li>
<li><a href='#sep.pars-class'><p>Class &quot;sep.pars&quot;</p></a></li>
<li><a href='#sep.pars-methods'><p>Separate Item Parameters</p></a></li>
<li><a href='#summary.irt.pars'><p>Summarize Item Parameters/plink Output</p></a></li>
<li><a href='#TK07'><p>Tong - Kolen (2007)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-04-26</td>
</tr>
<tr>
<td>Title:</td>
<td>IRT Separate Calibration Linking Methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.3), methods, lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, statmod</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan P. Weeks &lt;weeksjp@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan P. Weeks &lt;weeksjp@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Item response theory based methods are used to compute
        linking constants and conduct chain linking of unidimensional
        or multidimensional tests for multiple groups under a common
        item design.  The unidimensional methods include the Mean/Mean,
        Mean/Sigma, Haebara, and Stocking-Lord methods for dichotomous
        (1PL, 2PL and 3PL) and/or polytomous (graded response, partial
        credit/generalized partial credit, nominal, and multiple-choice
        model) items.  The multidimensional methods include the least
        squares method and extensions of the Haebara and Stocking-Lord
        method using single or multiple dilation parameters for
        multidimensional extensions of all the unidimensional
        dichotomous and polytomous item response models.  The package
        also includes functions for importing item and/or ability
        parameters from common IRT software, conducting IRT true score
        and observed score equating, and plotting item response
        curves/surfaces, vector plots, information plots, and comparison 
        plots for examining parameter drift.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-04-26 11:36:15 UTC; Jonathan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-04-26 16:36:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='plink-package'>IRT Separate Calibration Linking Methods</h2><span id='topic+plink-package'></span>

<h3>Description</h3>

<p>This package uses unidimensional and multidimensional item response theory methods 
to compute linking constants and conduct chain linking of tests for multiple groups under a 
nonequivalent groups common item design.</p>


<h3>Details</h3>

<p>The package consists of three types of functions: 
</p>

<ul>
<li><p>Response Probability Functions: These functions compute response probabilities for specified 
theta values (for as many dimensions and theta values as allowed by your computer's memory). The package 
can estimate probabilities for the item response models listed below. For all of these models, I have 
tried to include examples from the corresponding journal articles as a way to show that the equations are correct.
</p>

<ul>
<li><p>1PL
</p>
</li>
<li><p>2PL
</p>
</li>
<li><p>3PL
</p>
</li>
<li><p>Graded Response Model* (cumulative or category probabilities)
</p>
</li>
<li><p>Partial Credit Model*
</p>
</li>
<li><p>Generalized Partial Credit Model*
</p>
</li>
<li><p>Nominal Response Model
</p>
</li>
<li><p>Multiple-Choice Model
</p>
</li>
<li><p>M1PL
</p>
</li>
<li><p>M2PL
</p>
</li>
<li><p>M3PL
</p>
</li>
<li><p>MD Graded Response Model* (cumulative or category probabilities)
</p>
</li>
<li><p>MD Partial Credit Model*
</p>
</li>
<li><p>MD Generalized Partial Credit Model*
</p>
</li>
<li><p>MD Nominal Response Model
</p>
</li>
<li><p>MD Multiple-Choice Model (this model has not formally been presented in the literature)
</p>
</li></ul>

<p>* These models can be specified using a location parameter

</p>
</li>
<li><p>Linking Function: There is only one linking function, but it includes a variety of linking methods. 
The most notable feature of this function (as compared to other software) is that it allows you to input 
parameters for more than two groups and then chain link all of the tests together in a single run. 
Below are several options.
</p>

<ul>
<li><p>Symmetric or Non-Symmetric linking (as originally presented by Haebara)
</p>
</li>
<li><p>Specification of weights (can include uniform, quadrature, and normal density 
weights for default or specified theta points)
</p>
</li>
<li><p>Choice of base group
</p>
</li>
<li><p>Choice of method to rescale item parameters and/or ability estimates (if included)
</p>
</li></ul>

<p>When the item parameters correspond to a unidimensional model, linking constants can be estimated 
using the following methods
</p>

<ul>
<li><p>Mean/Mean
</p>
</li>
<li><p>Mean/Sigma
</p>
</li>
<li><p>Haebara
</p>
</li>
<li><p>Stocking-Lord
</p>
</li></ul>

<p>When the item parameters correspond to a multidimensional model, linking constants can be estimated 
using the following methods (with different options for the first two)
</p>

<ul>
<li><p>Multidimensional extension of Haebara
</p>
</li>
<li><p>Multidimensional extension of Stocking-Lord
</p>
</li>
<li><p>Reckase-Martineau (based on the oblique procrustes rotation and least squares method 
for estimating the translation vector <code>m</code>.
</p>
</li></ul>

<p>For the first two approaches there is a &quot;dilation&quot; argument where
</p>

<ul>
<li><p>all of the elements of the rotation/scaling matrix <code>A</code> and the translation vector <code>m</code> 
are estimated via the optimization routine (see Oshima, Davey, &amp; Lee, 2000)
</p>
</li>
<li><p>an orthongonal procrustes rotation to resolve the rotational indeterminacy and 
a single dilation parameter is estimated (see Li &amp; Lissitz, 2000)
</p>
</li>
<li><p>an orthongonal procrustes rotation to resolve the rotational indeterminacy and different 
parameters are estimated to adjust the scale of each dimension (see Min, 2003). 
</p>
</li></ul>

<p>For all of these approaches an optional matrix can be specified to identify the ordering of dimensions. 
It allows you to specify an overall factor structure that can take into account construct shift or 
different orderings of the factor loadings.
</p>
</li>
<li><p>Utility Functions:
</p>

<ul>
<li><p>Import item parameters and/or ability estimates from BILOG-MG 3, PARSCALE 4, MULTILOG 7, TESTFACT 4,
ICL, BMIRT, and the <code>eRm</code> and <code>ltm</code> packages.
</p>
</li>
<li><p>Separate item parameters from matrices or lists into the slope, difficulty, category, 
etc. values for use in computing response probabilities, descriptive statistics, etc.
</p>
</li>
<li><p>Combine multiple sets of parameters into a single object for use in the linking function 
(this essentially creates a blueprint of all the items including the IRT model used for each item, 
the number of response categories, and the mapping of common items between groups)
</p>
</li>
<li><p>Plot item characteristic/category curves (for unidimensional items), item response/category 
surfaces, contour plots, level plots, and three types of vector plots (for multidimensional items).
The first three types of multidimensional plots include functionality for creating &quot;conditional&quot; 
surfaces when there are more than two dimensions).
</p>
</li>
<li><p>Summarize the item parameters (unique and/or common) for each item response model separately, and overall
</p>
</li></ul>

</li></ul>

<p>Running the separate calibration is typically a two-step process.  The first step is to format the
item parameters and the second step is to run the function <code><a href="#topic+plink-methods">plink</a></code>. In the
simplest scenario, the parameters should be formatted as a single <code><a href="#topic+irt.pars-class">irt.pars</a></code> 
object with multiple groups. Refer to the function <code><a href="#topic+as.irt.pars">as.irt.pars</a></code> for specific details. Once 
in this format, the linking constants can be computed using <code>plink</code>.  The 
<code><a href="#topic+summary.irt.pars">summary</a></code> function can be used to summarize the common item parameters 
(including descriptive statistics) and the linking constants.
</p>
<p>To compute response probabilities for a given model, the following functions can be used: 
<code><a href="#topic+drm-methods">drm</a></code>, <code><a href="#topic+gpcm-methods">gpcm</a></code>, <code><a href="#topic+grm-methods">grm</a></code>,
<code><a href="#topic+mcm-methods">mcm</a></code>, or <code><a href="#topic+nrm-methods">nrm</a></code>. The <code><a href="#topic+plot.irt.prob">plot</a></code> 
function can be used to create item/category characteristic curves, item/category response surfaces, 
and vector plots.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a></p>


<h3>References</h3>

<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>

<hr>
<h2 id='act.mcm'>ACT Mathematics Test 1997-1998 Multiple-Choice Model</h2><span id='topic+act.mcm'></span>

<h3>Description</h3>

<p>This (unidimensional) dataset includes multiple-choice model item parameter estimates 
for two groups.  There are 60 items, all of which are common items.  The estimates
are from the 1997 and 1998 ACT mathematics test.  The item parameters were
obtained from the examples for the software <code>mceq</code> written by Bradley
Hanson.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>act.mcm</code></pre>


<h3>Format</h3>

<p>A list of length two. The matrices in the two list elements contain
multiple-choice model item parameters for 1997 and 1998 respectively.  The first
six columns in each matrix are the slope parameters, the next six columns are
the category difficulty parameters, and the last five columns are the lower
asymptote parameters.
</p>


<h3>Source</h3>

<p>Kim, J.-S. &amp; Hanson, B. A. (2002). 
Test Equating Under the Multiple-Choice Model.
<em>Applied Psychological Measurement</em>, <em>26</em>(3), 255-270.
</p>
<p>The item parameters can be found here
<a href="http://www.b-a-h.com/software/mcmequate/index.html">http://www.b-a-h.com/software/mcmequate/index.html</a>
</p>

<hr>
<h2 id='act.nrm'>ACT Mathematics Test 1997-1998 Nominal Response Model</h2><span id='topic+act.nrm'></span>

<h3>Description</h3>

<p>This (unidimensional )dataset includes nominal response model item parameter estimates 
for two groups.  There are 60 items, all of which are common items.  The estimates
are from the 1997 and 1998 ACT mathematics test.  The item parameters were
obtained from the examples for the software <code>nreq</code> written by Bradley
Hanson.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>act.nrm</code></pre>


<h3>Format</h3>

<p>A list of length two. The matrices in the two list elements contain
nominal response model item parameters for 1997 and 1998 respectively. The first
six columns in each matrix are the slope parameters and the next six columns are
the category difficulty parameters.
</p>


<h3>Source</h3>

<p>Kim, J.-S. &amp; Hanson, B. A. (2002). 
Test Equating Under the Multiple-Choice Model.
<em>Applied Psychological Measurement</em>, <em>26</em>(3), 255-270.
</p>
<p>The item parameters can be found here
<a href="http://www.b-a-h.com/software/mcmequate/index.html">http://www.b-a-h.com/software/mcmequate/index.html</a>
</p>

<hr>
<h2 id='as.irt.pars'>irt.pars objects</h2><span id='topic+as.irt.pars'></span><span id='topic+as.irt.pars-methods'></span><span id='topic+as.irt.pars+2Cnumeric+2Cmissing-method'></span><span id='topic+as.irt.pars+2Cdata.frame+2Cmissing-method'></span><span id='topic+as.irt.pars+2Cmatrix+2Cmissing-method'></span><span id='topic+as.irt.pars+2Clist+2Cmissing-method'></span><span id='topic+as.irt.pars+2Csep.pars+2Cmissing-method'></span><span id='topic+as.irt.pars+2Clist+2Cmatrix-method'></span><span id='topic+as.irt.pars+2Clist+2Clist-method'></span>

<h3>Description</h3>

<p>This function attempts to turn the given values into an <code><a href="#topic+irt.pars-class">irt.pars</a></code> object
that is used primarily with the <code><a href="#topic+plink-methods">plink</a></code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.irt.pars(x, common, cat, poly.mod, dimensions = 1, 
  location = FALSE, grp.names, ...)

## S4 method for signature 'numeric', 'missing'
as.irt.pars(x, common, cat, poly.mod, dimensions, location, 
  grp.names, ...)

## S4 method for signature 'matrix', 'missing'
as.irt.pars(x, common, cat, poly.mod, dimensions, location, 
  grp.names, ...)

## S4 method for signature 'data.frame', 'missing'
as.irt.pars(x, common, cat, poly.mod, dimensions, location, 
  grp.names, ...)

## S4 method for signature 'list', 'missing'
as.irt.pars(x, common, cat, poly.mod, dimensions, location, 
  grp.names, ...)

## S4 method for signature 'sep.pars', 'missing'
as.irt.pars(x, common, cat, poly.mod, dimensions, location, 
  grp.names, ...)

## S4 method for signature 'list', 'matrix'
as.irt.pars(x, common, cat, poly.mod, dimensions, location, 
  grp.names, ...)

## S4 method for signature 'list', 'list'
as.irt.pars(x, common, cat, poly.mod, dimensions, location, 
  grp.names, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.irt.pars_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object containing item parameters. For details on the 
formatting of parameters for specific item response models see the corresponding
methods (i.e., <code><a href="#topic+drm-methods">drm</a></code>, <code><a href="#topic+gpcm-methods">gpcm</a></code>, 
<code><a href="#topic+grm-methods">grm</a></code>, <code><a href="#topic+mcm-methods">mcm</a></code>, and 
<code><a href="#topic+nrm-methods">nrm</a></code> ). See below for details on combining parameters 
from multiple models. </p>
</td></tr>
<tr><td><code id="as.irt.pars_+3A_common">common</code></td>
<td>
<p>j x 2 matrix or list of matrices identifying the common items between
adjacent groups in <code>x</code>. This argument is only applicable when <code>x</code>
includes two or more groups</p>
</td></tr>
<tr><td><code id="as.irt.pars_+3A_cat">cat</code></td>
<td>
<p>vector or list of the number of response categories for each item in <code>x</code>.
if <code>x</code> is a list, <code>cat</code> should be a list as well. For multiple-choice
model items, <code>cat</code> is the number of response categories plus one (the 
additional category is for 'do not know')</p>
</td></tr>
<tr><td><code id="as.irt.pars_+3A_poly.mod">poly.mod</code></td>
<td>
<p>a <code><a href="#topic+poly.mod-class">poly.mod</a></code> object or a list of <code>poly.mod</code>
objects (one for each group in <code>x</code>)</p>
</td></tr>
<tr><td><code id="as.irt.pars_+3A_dimensions">dimensions</code></td>
<td>
<p>numeric vector identifying the number of modeled dimensions in each group. </p>
</td></tr>
<tr><td><code id="as.irt.pars_+3A_location">location</code></td>
<td>
<p>logical vector identifying whether the parameters in <code>x</code>
include a location parameter (i.e., for polytomous items)</p>
</td></tr>
<tr><td><code id="as.irt.pars_+3A_grp.names">grp.names</code></td>
<td>
<p>character vector of group names</p>
</td></tr>
<tr><td><code id="as.irt.pars_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.pars-class">irt.pars</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;numeric&quot;, common = &quot;missing&quot;</dt><dd><p>This method should only be used for the Rasch model 
where <code>x</code> is a vector of difficulty parameters (or parameters related to item difficulty 
in the multidimensional case).  Under this method the slopes and lower asymptote values for 
all items will default to one and zero respectively.  This is true for both the unidimensional 
and multidimensional case.</p>
</dd>
<dt>x = &quot;matrix&quot;, common = &quot;missing&quot;</dt><dd><p><code>x</code> can include item parameters from
multiple models.  The general format for structuring <code>x</code> is an additive column 
approach.  That is, the left-most columns are typically for discrimination/slope parameters,
the next column, if applicable, is for location parameters, the next set of columns
is for difficulty/threshold/step/category parameters, and the final set of columns
is for lower asymptote (guessing) parameters.  When multiple models are included, or models 
with differing numbers of response categories, not all cells in <code>x</code> may have data.
In these instances, cells with no data should be <code>NA</code>.  The resulting matrix will be an
n x k matrix for n items and k equal to the maximum number of columns (across all item
response models).  In essence, the combination of multiple models is equivalent to formatting
the item parameters for each response model separately, stacking the matrices on top of one
another and then filling in any missing cells with <code>NA</code>s.
</p>
</dd>
<dt>x = &quot;data.frame&quot;, common = &quot;missing&quot;</dt><dd><p>See the method for x = &quot;matrix&quot; </p>
</dd>
<dt>x = &quot;list&quot;, common = &quot;missing&quot;</dt><dd><p>This method can include a list with one, two, or three 
elements.  In general, these elements correspond to discrimination/slope parameters, 
difficulty/threshold/ step/category parameters, and lower asymptote (guessing) parameters, although 
this may not be the case depending on the supplied parameters.  If a combination of models are used, 
the number of list elements should correspond with the maximum number of elements across models.  
For example, if the 3PL model (3 list elements) and nominal response model (2 list elements) are 
used, the list should include three elements.  Within each list element, the parameters should be
formatted as vectors or matrices (depending on the specific item response models).  For the format
of the matrices, see the method for x = &quot;matrix&quot; above and/or the methods corresponding to the specific
response models.  When location parameters are included, these values should be placed in the first 
column of the matrix of difficulty/threshold/step/category parameters (in the corresponding list 
element). 
</p>
</dd>
<dt>x = &quot;sep.pars&quot;, common = &quot;missing&quot;</dt><dd><p><code>x</code> is an object of class <code><a href="#topic+sep.pars-class">sep.pars</a></code>.
The arguments <code>cat</code>, <code>poly.mod</code>, and <code>location</code> do not need to be included.</p>
</dd>
<dt>x = &quot;list&quot;, common = &quot;matrix&quot;</dt><dd><p>This method is intended for the creation of an 
object with only two groups.  Each list element should conform to one of the formats 
listed above (i.e. a numeric vector, matrix/data.frame, list, or sep.pars object)
or be an <code><a href="#topic+irt.pars-class">irt.pars</a></code> object.  The format of each list element does
not need to be the same.  That is, the first list element might be a <code>"sep.pars"</code> 
object while the second element is a list of item parameters. If an object of class
<code>irt.pars</code> is included, the object can contain information for a single group
or for multiple groups.  If the <code>irt.pars</code> object includes multiple groups,
<code>common</code> should identify the common items between the last group in <code>x[[1]]</code>
and the first group in <code>x[[2]]</code>.
</p>
<p>For this method <code>common</code> is a j x 2 matrix where the first column identifies the 
common items for the first group (<code>x[[1]]</code>).  The second column in <code>common</code> 
identifies the corresponding set of common items from the next list element.  For example, 
if item 4 in group one (row 4 in <code>x[[1]]</code>) is the same as item 6 in group two, the 
first row of <code>common</code> would be <code>"4,6"</code>.
</p>
<p>If the objects in <code>x</code> are of class <code>sep.pars</code> or <code>irt.pars</code>, <code>cat</code>, 
<code>poly.mod</code>, and <code>location</code> do not need to be included.</p>
</dd>
<dt>x = &quot;list&quot;, common = &quot;list&quot;</dt><dd><p>This method is intended for the creation of an object 
with more than two groups; however, if there are two groups <code>common</code> can be 
defined as a list with length one.  Each list element should conform to one of the formats 
listed above (i.e. a numeric vector, matrix/data.frame, list, or sep.pars object)
or be an <code><a href="#topic+irt.pars-class">irt.pars</a></code> object.  The format of each list element does
not need to be the same.  That is, the first list element might be a <code>"sep.pars"</code> 
object while the second element is a list of item parameters.  If an object of class
<code>irt.pars</code> is included, the object can contain information for a single group
or for multiple groups.  The list elements in <code>x</code> should be ordered such that 
adjacent elements correspond to adjacent groups.  If an <code>"irt.pars"</code> object is 
included with multiple groups, the list element following this object should contain 
information for a  group that is adjacent to the last group in the <code>"irt.pars"</code> object
</p>
<p>For this method <code>common</code> is a list of j x 2 matrices where the first column identifies 
the identifies the common items for the first group of two adjacent list elements in
The second column in <code>common</code> identifies the corresponding set of common items from the 
next list element in <code>x</code>.  For example, if <code>x</code> contains only two list elements, a 
single set of common items links them together.  If item 4 in group one (row 4 in slot <code>pars</code>) 
is the same as item 6 in group two, the first row of <code>common</code> would be <code>"4,6"</code>.
</p>
<p>If all the objects in <code>x</code> are of class <code>sep.pars</code> or <code>irt.pars</code>, the arguments
<code>cat</code>, <code>poly.mod</code>, and <code>location</code> do not need to be included.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+as.poly.mod">as.poly.mod</a></code>, <code><a href="#topic+poly.mod-class">poly.mod</a></code>, 
<code><a href="#topic+sep.pars-class">sep.pars</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Create object for three dichotomous (1PL) items with difficulties 
# equal to -1, 0, 1
x &lt;- as.irt.pars(c(-1,0,1))


# Create object for three dichotomous (3PL) items and two polytomous 
# (gpcm) items without a location parameter 
# (use signature matrix, missing)
dichot &lt;- matrix(c(1.2, .8, .9, 2.3, -1.1, -.2, .24, .19, .13),3,3)
poly &lt;- matrix(c(.64, -1.8, -.73, .45, NA, .88, .06, 1.4, 1.9, 2.6),
  2,5,byrow=TRUE)
pars &lt;- rbind(cbind(dichot,matrix(NA,3,2)),poly)
cat &lt;- c(2,2,2,4,5)
pm &lt;- as.poly.mod(5, c("drm","gpcm"), list(1:3,4:5))
x &lt;- as.irt.pars(pars, cat=cat, poly.mod=pm)
summary(x)


# Create object for three dichotomous (3PL) items and two polytomous 
# (gpcm) items without a location parameter 
# (use signature list, missing)
a &lt;- c(1.2, .8, .9, .64, .88)
b &lt;- matrix(c(
  2.3, rep(NA,3),
  -1.1, rep(NA,3),
  -.2, rep(NA,3),
  -1.8, -.73, .45, NA,
  .06, 1.4, 1.9, 2.6),5,4,byrow=TRUE)
c &lt;- c(1.4, 1.9, 2.6, NA, NA)
pars &lt;- list(a,b,c)
cat &lt;- c(2,2,2,4,5)
pm &lt;- as.poly.mod(5, c("drm","gpcm"), list(1:3,4:5))
x &lt;- as.irt.pars(pars, cat=cat, poly.mod=pm)
summary(x)


# Create object for three dichotomous (3PL) items, four polytomous items,
# two gpcm items and two nrm items. Include a location parameter for the 
# gpcm items (use signature list, missing)
a &lt;- matrix(c(
  1.2, rep(NA,4),
  .8, rep(NA,4),
  .9, rep(NA,4),
  .64, rep(NA,4),
  .88, rep(NA,4),
  .905, .522, -.469, -.959, NA, 
  .828, .375, -.357, -.079, -.817),7,5,byrow=TRUE)
b &lt;- matrix(c(
  2.3, rep(NA,4),
  -1.1, rep(NA,4),
  -.2, rep(NA,4),
  -.69, -1.11, -.04, 1.14, NA,
  1.49, -1.43, -.09, .41, 1.11,
  .126, -.206, -.257, .336, NA, 
  .565, .865, -1.186, -1.199, .993),7,5,byrow=TRUE)
c &lt;- c(.14, .19, .26, rep(NA,4))
pars &lt;- list(a,b,c)
cat &lt;- c(2,2,2,4,5,4,5)
pm &lt;- as.poly.mod(7, c("drm","gpcm","nrm"), list(1:3,4:5,6:7))
x &lt;- as.irt.pars(pars, cat=cat, poly.mod=pm, location=TRUE)
summary(x, TRUE)


# Create object with two groups (all dichotomous items)
pm &lt;- as.poly.mod(36)
x &lt;- as.irt.pars(KB04$pars, KB04$common, cat=list(rep(2,36),rep(2,36)), 
  list(pm,pm), grp.names=c("form.x","form.y"))
summary(x, TRUE)


# Create object with six groups (all dichotomous items)
pars &lt;- TK07$pars
common &lt;- TK07$common
cat &lt;- list(rep(2,26),rep(2,34),rep(2,37),rep(2,40),rep(2,41),rep(2,43))
pm1 &lt;- as.poly.mod(26)
pm2 &lt;- as.poly.mod(34)
pm3 &lt;- as.poly.mod(37)
pm4 &lt;- as.poly.mod(40)
pm5 &lt;- as.poly.mod(41)
pm6 &lt;- as.poly.mod(43)
pm &lt;- list(pm1, pm2, pm3, pm4, pm5, pm6)
x &lt;- as.irt.pars(pars, common, cat, pm, 
  grp.names=paste("grade",3:8,sep=""))

# Create an object with two groups using mixed-format items and 
# a mixed placement of common items. This example uses the dgn dataset.
pm1=as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group1)
pm2=as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group2)
x=as.irt.pars(dgn$pars,dgn$common,dgn$cat,list(pm1,pm2))
summary(x, TRUE)
</code></pre>

<hr>
<h2 id='as.poly.mod'>poly.mod objects</h2><span id='topic+as.poly.mod'></span>

<h3>Description</h3>

<p>This function attempts to turn the given values into a <code><a href="#topic+poly.mod-class">poly.mod</a></code> object that
associates each item with a specific unidimensional or multidimensional item response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.poly.mod(n, model = "drm", items = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.poly.mod_+3A_n">n</code></td>
<td>
<p>total number of items</p>
</td></tr>
<tr><td><code id="as.poly.mod_+3A_model">model</code></td>
<td>
<p>character vector identifying the IRT models used to estimate
the item parameters.  The only acceptable models are 
<code>drm, gpcm, grm, mcm, and nrm</code>.  See below for an explanation of
the codes. </p>
</td></tr>
<tr><td><code id="as.poly.mod_+3A_items">items</code></td>
<td>
<p>list identifying the item numbers from a set of parameters
that correspond to the given model in <code>model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When creating a <code>poly.mod</code> object, there is no difference in the specification for
unidimensional versus multidimensional item response models.  If all the items are dichotomous, 
it is only necessary to specify a value for <code>n</code>.  If all the items correspond to a 
single model (other than <code>drm</code>), only <code>n</code> and <code>model</code> need to be specified.
</p>
<p>The IRT models associated with the codes:
</p>

<dl>
<dt><code>drm</code>:</dt><dd><p>dichotomous response models (includes the 1PL, 2PL, 3PL, M1PL, 
M2PL, and M3PL)</p>
</dd>
<dt><code>gpcm</code>:</dt><dd><p>partial credit model, generalized partial credit model,
multidimensional partial credit model, and multidimensional generalized partial credit model</p>
</dd>
<dt><code>grm</code>:</dt><dd><p>graded response model and multidimensional graded response model</p>
</dd>
<dt><code>mcm</code>:</dt><dd><p>multiple-choice model and multidimensional multiple-choice model</p>
</dd>
<dt><code>nrm</code>:</dt><dd><p>nominal response model and multidimensional nominal response model</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+poly.mod-class">poly.mod</a></code>
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+poly.mod-class">poly.mod</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Ten dichotomous items
as.poly.mod(10)

# The first ten items in the set of associated (not present here) item 
# parameters are dichotomous and the last five were estimated using the 
# generalized partial credit model
as.poly.mod(15, c("drm", "gpcm"), list(1:10,11:15) )

# Ten multidimensional graded response model items
# Note: This same specification would be used for a unidimensional
# graded response model
as.poly.mod(10, "grm")
</code></pre>

<hr>
<h2 id='as.weight'>Calibration Weights</h2><span id='topic+as.weight'></span>

<h3>Description</h3>

<p>This function facilitates the creation of either a set of quadrature weights or
weights based on a set of theta values for use in the function 
<code><a href="#topic+plink-methods">plink</a> </code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.weight(n, theta, weight, quadrature = FALSE, normal.wt = FALSE, 
  dimensions = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.weight_+3A_n">n</code></td>
<td>
<p>numeric value or vector identifying the number of theta values
to use for each dimension. If only one value is supplied but <code>dimensions</code> is
greater than one, <code>n</code> will be the same for all dimensions.</p>
</td></tr>
<tr><td><code id="as.weight_+3A_theta">theta</code></td>
<td>
<p>vector or list of theta values. If <code>dimensions</code> is greater than
one, list elements should correspond to each dimension, otherwise the single vector
will be repeated for all dimensions.</p>
</td></tr>
<tr><td><code id="as.weight_+3A_weight">weight</code></td>
<td>
<p>vector or list of weights. If <code>dimensions</code> is greater than
one, list elements should correspond to each dimension, otherwise the single vector
will be repeated for all dimensions.</p>
</td></tr>
<tr><td><code id="as.weight_+3A_quadrature">quadrature</code></td>
<td>
<p>if <code>TRUE</code>, quadrature points and weights will be 
computed for the corresponding number of points <code>n</code> for each dimension
respectively. See <code><a href="statmod.html#topic+gauss.quad.prob">gauss.quad.prob</a></code> 
for more information on creating quadrature points and weights.</p>
</td></tr>
<tr><td><code id="as.weight_+3A_normal.wt">normal.wt</code></td>
<td>
<p>if <code>TRUE</code> and <code>weight</code> is <code>missing</code>, the weights 
for <code>theta</code> will be computed to correspond to the densities from a 
normal distribution. </p>
</td></tr>
<tr><td><code id="as.weight_+3A_dimensions">dimensions</code></td>
<td>
<p>number of dimensions for which the weights should be created</p>
</td></tr>
<tr><td><code id="as.weight_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When weighting expected response probabilities at different theta values using
characteristic curve linking methods, there are a variety of approaches one can take.
These range from uniform weights to normal weights, to quadrature weights corresponding
to some a priori specified distribution. The purpose of this function is to facilitate 
the creation of these weights for use in <code><a href="#topic+plink-methods">plink</a> </code>. 
</p>
<p>For all approaches, when more than one dimension is specified, the weights for each combined 
set of theta values will be a multiplicative weight. For example, if there are two dimensions 
and the specified weights corresponding to two specific theta values on each dimension
respectively are 0.8 and 1.2, the final weight for this pair of theta values will be 0.96.
</p>

<dl>
<dt>Uniform Weights</dt><dd><p>Five general approaches can be used to create uniform weights.</p>
</dd>
</dl>

<ul>
<li><p>If no arguments are supplied, a set of weights (all equal to one) will be 
returned for a single dimension, for 40 equal interval theta values ranging from 
-4 to 4. If <code>dimensions</code> is greater than one, seven equal interval theta values
ranging from -4 to 4 will be specified for each dimension. For instance, for two
dimensions, there will be weights for 7 x 7 (49) points.
</p>
</li>
<li><p>If only a value for <code>n</code> is supplied, uniform weights (all equal to one)
will be created for <code>n</code> points ranging from -4 to 4 for each dimension specified.
</p>
</li>
<li><p>If values are only specified for <code>theta</code>, uniform weights (all equal to one) 
will be created for each of these values for each dimension specified.
</p>
</li>
<li><p>If values are only specified for <code>weight</code> where the values are all equal. In 
this case, equal interval theta values will be selected from -4 to 4 to correspond to
the number of specified weights.
</p>
</li>
<li><p>If values are specified for <code>theta</code> and uniform values are specified for 
<code>weight</code>.
</p>
</li></ul>

<dl>
<dt>Non-Uniform Weights</dt><dd><p>Four general approaches can be used to create non-uniform weights.
</p>

<ul>
<li><p>If values are only specified for <code>weight</code> where the values are not equal. In 
this case, equal interval theta values will be selected from -4 to 4 to correspond to
the number of specified weights.  
</p>
</li>
<li><p>If values are specified for <code>theta</code> and varying values are specified for 
<code>weight</code>. 
</p>
</li>
<li><p>If <code>quadrature</code> is equal to <code>TRUE</code>, and no other arguments are specified
<code>n</code> will default to 40. if <code>dimensions</code> is greater than one, <code>n</code> will default
to seven for each dimension. In either case <code>n</code> quadrature points and weights will be 
selected from a standard normal distribution. To change the mean and/or standard deviation of 
this distribution, values for <code>mu</code> and <code>sigma</code> respectively should be specified. See
<code><a href="statmod.html#topic+gauss.quad.prob">gauss.quad.prob</a></code> for more information. Different means
and/or SDs can be supplied for each dimension. If values are specified for <code>theta</code> or 
<code>weight</code>, the quadrature approach will not be used. 
</p>
</li>
<li><p>If <code>quadrature</code> equals <code>TRUE</code> other distributions can be specified for
<code>n</code> points. See <code><a href="statmod.html#topic+gauss.quad.prob">gauss.quad.prob</a></code> for more 
information.
</p>
</li>
<li><p>If <code>normal.wt</code> equals <code>TRUE</code>, normal densities will be created for the 
specified <code>theta</code> values (if supplied) or equal interval values. The default distribution 
will be standard normal, but different means and/or standard deviations can be specified by
passing arguments for <code>mean</code> and <code>sd</code> respectively. Different means and/or SDs can be 
supplied for each dimension. If no values are included for <code>theta</code>, equal interval theta 
values will be created for the range of three SDs above and below the mean. If values are 
specified for <code>weight</code>, the <code>normal.wt</code> argument will be ignored. 
</p>
</li></ul>

</dd>
</dl>

<p>See Kolen &amp; Brennan (2004) for more information on calibration weights.
</p>


<h3>Value</h3>

<p>Returns a list of length two.  The first list element is an n x m matrix of theta values 
for m dimensions.  The second list element is a vector of weights corresponding to the 
theta values in the first list element.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Kolen, M. J., &amp; Brennan, R. L. (2004)
<em>Test Equating, Scaling, and Linking.</em>
New York: Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plink-methods">plink</a></code>, <code><a href="statmod.html#topic+gauss.quad.prob">gauss.quad.prob</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
# Create a set of 40 (default) theta values and uniform weights
wt &lt;- as.weight()

# Create a set of 40 quadrature points and weights using a standard 
# normal distribution
wt &lt;- as.weight(quadrature=TRUE)

# Create a set of 30 quadrature points and weights using a normal 
# distribution with a mean of 0.5
wt &lt;- as.weight(n=30, quadrature=TRUE, mu=0.5)

# Create weights for a set of random normal theta values
wt &lt;- as.weight(theta=rnorm(100))

# Create an object with equal interval theta values and standard 
# normal density weights
wt &lt;- as.weight(theta=seq(-4,4,0.05), normal.wt=TRUE)

# Create an object with equal interval theta values and normal 
# density weights with a mean of 0.5 and SD equal to .92
wt &lt;- as.weight(theta=seq(-4,4,0.05), normal.wt=TRUE, mean=0.5, sd=0.92)

###### Multidimensional Examples ######
# Create a set of 49 theta values and uniform weights 
# (based on seven points for each dimension)
wt &lt;- as.weight(dimensions=2)

# Create a set of 100 quadrature points and weights using a normal 
# distribution with a means of 0 and 0.5 for the two dimensions respectively
wt &lt;- as.weight(n=10, quadrature=TRUE, mu=c(0,0.5), dimensions=2)

# Create an object with equal interval theta values and standard 
# normal density weights for three dimensions
wt &lt;- as.weight(theta=seq(-3,3), normal.wt=TRUE, dimensions=3)

# Create an object with two sets of equal interval theta values for 
# two dimensions
wt &lt;- as.weight(theta=list(seq(-4,4),seq(-3,3)), dimensions=2)

# Create an object with two sets of random normal theta values and 
# standard normal density weights for two dimensions
wt &lt;- as.weight(theta=list(rnorm(10),rnorm(10)), normal.wt=TRUE, dimensions=2)
</code></pre>

<hr>
<h2 id='combine.pars'>Combine Item Parameters for Multiple Groups</h2><span id='topic+combine.pars'></span>

<h3>Description</h3>

<p>This function combines objects of class <code><a href="#topic+irt.pars-class">irt.pars</a></code> and/or 
<code><a href="#topic+sep.pars">sep.pars</a></code> into a single <code>irt.pars</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.pars(x, common, grp.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.pars_+3A_x">x</code></td>
<td>
<p>an ordered list containing two or more <code>irt.pars</code> objects, two or more 
<code>sep.pars</code> objects, or a combination of <code>irt.pars</code> and <code>sep.pars</code> 
objects.</p>
</td></tr>
<tr><td><code id="combine.pars_+3A_common">common</code></td>
<td>
<p>an n x 2 matrix or list of matrices identifying the common items between 
adjacent pairs of objects in <code>x</code>. See below for more details. </p>
</td></tr>
<tr><td><code id="combine.pars_+3A_grp.names">grp.names</code></td>
<td>
<p>character vector of names for all the groups in the returned object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although many of the methods in this package allow for lists containing <code>irt.pars</code> 
and <code>sep.pars</code> objects, it may be helpful to combine the item parameters for multiple 
groups into a single object.  <code>x</code> can include a combination of <code>irt.pars</code> and 
<code>sep.pars</code> objects.  The <code>irt.pars</code> objects can contain information for a 
single group or multiple groups.  The list elements in <code>x</code> should be ordered such that 
adjacent elements correspond to adjacent groups.  If an <code>irt.pars</code> object is included 
with multiple groups, the list element following this object should contain information for a 
group that is adjacent to the last group in the <code>irt.pars</code> object.
</p>
<p>If <code>x</code> contains only two elements, <code>common</code> should be a matrix.  If <code>x</code> contains
more than two elements, <code>common</code> should be a list.  In any of the <code>common</code> matrices
the first column identifies the common items for the first group of two adjacent list elements
in <code>x</code>.  The second column in <code>common</code> identifies the corresponding set of common 
items from the next list element in <code>x</code>. For example, if <code>x</code> contains only two list 
elements, a single set of common items links them together.  If item 4 in group one (row 4 in 
slot <code>pars</code>) is the same as item 6 in group two, the first row of <code>common</code> would be <code>"4,6"</code>.
</p>
<p>If an <code>irt.pars</code> object is included with multiple groups, <code>common</code> should correspond
to the set of common items between the last group in the <code>irt.pars</code> object and the
group in the adjacent element in <code>x</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.pars-class">irt.pars</a></code>
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+as.irt.pars">as.irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a></code>,
<code><a href="#topic+sep.pars-methods">sep.pars</a></code> </p>

<hr>
<h2 id='dgn'>Unidimensional Mixed-Format Item Parameters</h2><span id='topic+dgn'></span>

<h3>Description</h3>

<p>This (unidimensional) dataset includes item parameters for two groups estimated under 
the three parameter logistic model, the generalized partial credit model, and 
the nominal response model. There are 15 common items (7 drm, 3 gpcm, 5 nrm).
This dataset is for illustrative purposes to show how items from different
response models can be mixed together and common items can be in different
positions across groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgn</code></pre>


<h3>Format</h3>

<p>A list of length four.  The first element is a list of length two with item
parameter estimates for groups 1 and 2 respectively.  The gpcm items do not
include a location parameter.  The second list element is a list identifying 
the number of response categories for the two groups.  The third element, 
specifies which items correspond to the different item response models for each 
group respectively.  The last element is a matrix of common items between the two 
groups.
</p>


<h3>References</h3>

<p>The item parameters are loosely based on parameters listed in the following articles
</p>
<p>Kim, J.-S. (2006). 
Using the Distractor Categories of Multiple-Choice Items to Improve IRT Linking. 
<em>Journal of Educational Measurement</em>, <em>43</em>(3), 193-213.
</p>
<p>Kim, S. &amp; Lee, W.-C. (2006). 
An Extension of Four IRT Linking Methods for Mixed-Format Tests. 
<em>Journal of Educational Measurement</em>, <em>43</em>(1), 53-76.
</p>

<hr>
<h2 id='drm-methods'>Dichotomous Response Model Probabilities</h2><span id='topic+drm'></span><span id='topic+drm-methods'></span><span id='topic+drm+2Cnumeric-method'></span><span id='topic+drm+2Cmatrix-method'></span><span id='topic+drm+2Cdata.frame-method'></span><span id='topic+drm+2Clist-method'></span><span id='topic+drm+2Cirt.pars-method'></span><span id='topic+drm+2Csep.pars-method'></span>

<h3>Description</h3>

<p>This function computes the probability of correct responses (and optionally, incorrect 
responses) for one or more items for a given set of theta values using the 1PL, 2PL, 3PL,
M1PL, M2PL or M3PL model, depending on the included item parameters and the specified
number of dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drm(x, theta, dimensions = 1, D = 1, incorrect = FALSE, 
  print.mod = FALSE, items, information = FALSE, angle, ...)

## S4 method for signature 'numeric'
drm(x, theta, dimensions, D, incorrect, print.mod, items, information, angle, ...)

## S4 method for signature 'matrix'
drm(x, theta, dimensions, D, incorrect, print.mod, items, information, angle, ...)

## S4 method for signature 'data.frame'
drm(x, theta, dimensions, D, incorrect, print.mod, items, information, angle, ...)

## S4 method for signature 'list'
drm(x, theta, dimensions, D, incorrect, print.mod, items, information, angle, ...)

## S4 method for signature 'irt.pars'
drm(x, theta, dimensions, D, incorrect, print.mod, items, information, angle, ...)

## S4 method for signature 'sep.pars'
drm(x, theta, dimensions, D, incorrect, print.mod, items, information, angle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drm-methods_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object containing item parameters</p>
</td></tr>
<tr><td><code id="drm-methods_+3A_theta">theta</code></td>
<td>
<p>vector, matrix, or list of theta values for which probabilities will be computed. 
If <code>theta</code> is not specified, an equal interval range of values from -4 to 4 is used 
with an increment of 0.5. See details below for more information. </p>
</td></tr>
<tr><td><code id="drm-methods_+3A_dimensions">dimensions</code></td>
<td>
<p>number of modeled dimensions </p>
</td></tr>
<tr><td><code id="drm-methods_+3A_d">D</code></td>
<td>
<p>scaling constant. The default value assumes that the parameters are already in the 
desired metric. If the parameters are in the logistic metric, they can be transformed to a 
normal metric by setting D = 1.7</p>
</td></tr>
<tr><td><code id="drm-methods_+3A_incorrect">incorrect</code></td>
<td>
<p>if <code>TRUE</code>, compute probabilities for the incorrect response category) </p>
</td></tr>
<tr><td><code id="drm-methods_+3A_print.mod">print.mod</code></td>
<td>
<p>if <code>TRUE</code>, print the model that was used (i.e., 1PL, 2PL, 3PL, M1PL, M2PL, or M3PL) </p>
</td></tr>
<tr><td><code id="drm-methods_+3A_items">items</code></td>
<td>
<p>numeric vector identifying the items for which probabilities should be computed</p>
</td></tr>
<tr><td><code id="drm-methods_+3A_information">information</code></td>
<td>
<p>logical value. If <code>TRUE</code> compute item information. In the multidimensional
case, information will be computed in the directions specified by <code>angle</code> or default angles
of 0 - 90 in increments of 10 degrees.</p>
</td></tr>
<tr><td><code id="drm-methods_+3A_angle">angle</code></td>
<td>
<p>vector or matrix of angles between the dimension 1 axis and the corresponding axes for each 
of the other dimensions for which information will be computed. When there are more than two dimensions 
and <code>angle</code> is a vector, the same set of angles will be used relative to each of the corresponding axes.</p>
</td></tr>
<tr><td><code id="drm-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> can be specified as a vector, matrix, or list.  For the unidimensional case, <code>theta</code>
should be a vector. If a matrix or list of values is supplied, they will be converted to a single vector
of theta values.  For the multidimensional case, if a vector of values is supplied it will be assumed
that this same set of values should be used for each dimension.  Probabilities will be computed for each
combination of theta values.  Similarly, if a list is supplied, probabilities will be computed for each
combination of theta values.  In instances where probabilities are desired for specific combinations of 
theta values, a j x m matrix should be specified for j ability points and m dimensions where the columns 
are ordered from dimension 1 to m.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.prob-class">irt.prob</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;numeric&quot;</dt><dd><p>This method should only be used for the Rasch model where <code>x</code> is a vector of 
difficulty parameters (or parameters related to item difficulty in the multidimensional case).  Under 
this method the slopes and lower asymptote values for all items will default to one and zero respectively.  
This is true for both the unidimensional and multidimensional case.</p>
</dd>
<dt>x = &quot;matrix&quot;</dt><dd><p>This method allows one to specify an n x k matrix for n items, for m
dimensions, and k equal to m, m+1, or m+2.  The first m columns generally correspond to the 
discrimination/slope parameters, and the last two columns correspond to the difficulty, and
lower asymptote parameters, although this may not be the case depending on the supplied
parameters.
</p>

<dl>
<dt>1PL/M1PL:</dt><dd><p>For the 1PL and M1PL model with discriminations equal to 1 (Rasch Model), 
an n x 1 matrix of item difficulties can be supplied.  An n x (m+1) matrix can also be used with
all the values in the first m columns equal to 1 and difficulty parameters in the last
column.  For discrimination values other than 1, <code>x</code> should include at least m+1
columns where the first m columns contain the item discriminations (identical for all items) 
and the last column is for the item difficulties.  The lower asymptote defaults to zero for 
all items; however, m+2 columns can be specified where the values in the last column all 
equal zero.</p>
</dd>
<dt>2PL/M2PL:</dt><dd><p><code>x</code> should include at least m+1 columns where the first m columns contain 
the item discriminations and the last column is for the item difficulties.  The lower asymptote 
defaults to zero for all items; however, m+2 columns can be specified where the values in the 
last column all equal zero.</p>
</dd>
<dt>3PL/M3PL:</dt><dd><p><code>x</code> should include m+2 columns where the first m columns contain the item 
discriminations, the m+1 column is for item difficulties, and the last column is for lower 
asymptote values.</p>
</dd>
</dl>

</dd>
<dt>x = &quot;data.frame&quot;</dt><dd><p>See the method for x = &quot;matrix&quot; </p>
</dd>
<dt>x = &quot;list&quot;</dt><dd><p>This method can include a list with 1, 2, or 3 elements.  In general, these 
elements correspond to discrimination, difficulty, and lower asymptote parameters, although 
this may not be the case depending on the supplied parameters.  For the unidimensional case,
each list element can be a vector of length n or an n x 1 matrix for n items.  For the 
multidimensional case, the list element for the discrimination parameters should be an n x m
matrix for m dimensions.  The other list elements can be vectors of length n or an n x 1 matrix 
for n items.
</p>

<dl>
<dt>1PL/M1PL:</dt><dd><p>For the 1PL and M1PL model with discriminations equal to 1 (Rasch Model), 
one element with item difficulties can be supplied.  Alternatively, two elements can be used 
with the first list element containing a matrix/vector of ones and difficulty parameters in 
the second list element.  For discrimination values other than 1, <code>x</code> should contain 
at  least two list elements where the first contains the item discriminations (identical 
for all items) and the second is for item difficulties.  The lower asymptote defaults to 
zero for all items; however, a third element with a vector/matrix of zeros can be included.</p>
</dd>
<dt>2PL/M2PL:</dt><dd><p><code>x</code> should contain at least two list elements where the first element 
contains the item discriminations and the second element includes the item difficulties.  
The lower asymptote defaults to zero for all items; however, a third element with a 
vector/matrix of zeros can be included.</p>
</dd>
<dt>3PL/M3PL:</dt><dd><p><code>x</code> should include three list elements where the first element contains the 
item discriminations, the second element includes the item difficulties, and the third element
contains the lower asymptote values.</p>
</dd>
</dl>

</dd>
<dt>x = &quot;irt.pars&quot;</dt><dd><p>This method can be used to compute probabilities for the dichotomous
items in an object of class <code>"irt.pars"</code>.  If <code>x</code> contains polytomous items, a
warning will be displayed stating that probabilities will be computed for the 
dichotomous items only.  If <code>x</code> contains parameters for multiple groups, a list of 
<code>"irt.prob"</code> objects will be returned.  The argument <code>dimensions</code> does not need
to be included for this method.</p>
</dd>
<dt>x = &quot;sep.pars&quot;</dt><dd><p>This method can be used to compute probabilities for the dichotomous
items in an object of class <code>sep.pars</code>.  If <code>x</code> contains polytomous items, a
warning will be displayed stating that probabilities will be computed for the 
dichotomous items only.  The argument <code>dimensions</code> does not need to be included for 
this method.</p>
</dd>
</dl>



<h3>Note</h3>

 
<p>The indices 0 and 1 are used in the column labels for incorrect and correct responses 
respectively (e.g. the label d1.0 indicates the incorrect response column for item 1, d1.1 
indicates the correct response column for the same item).  If <code>incorrect</code> = <code>FALSE</code>, 
all column labels will end with .1
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Adams, R. J., Wilson, M., &amp; Wang, W. (1997).
The multidimensional random coefficients multinomial logit model.
<em>Applied Psychological Measurement</em>, <em>21</em>(1), 1-23.
</p>
<p>Birnbaum, A. (1968).
Some latent trait models and their use in inferring an examinee's ability
In F. M. Lord &amp; M. R. Novick (Eds.)
<em>Statistical Theories of Mental Test Scores.</em>
Reading, MA: Addison-Wesley.
</p>
<p>Rasch, G. (1960).
<em>Probabilistic Models for Some Intelligence and Attainment Tests</em>
Copenhagen, Denmark: Danish Institute for Educational Research.
</p>
<p>Reckase, M. D. (1985). 
The difficulty of items that measure more than one ability.
<em>Applied Psychological Measurement</em>, <em>9</em>(4), 401-412. 
</p>
<p>Reckase, M. D. (1997). 
A linear logistic multidimensional model for dichotomous item response data. 
In W. J. van der Linden &amp; R. K. Hambleton (Eds.)
<em>Handbook of Modern Item Response Theory</em> (pp. 271-286). 
New York: Springer-Verlag.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+mixed-methods">mixed</a>:</code> compute probabilities for mixed-format items<br />
<code><a href="#topic+plot.irt.prob">plot</a>:</code> plot item characteristic/category curves<br />
<code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a>:</code> classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
## 1PL
# A single item with a difficulty at 1 logit
x &lt;- drm(1) 
plot(x)

# Three items with a difficulties at -2.2, -1.7, and 0.54 logits 
# respectively. Assume a constant discrimination of 1 for each item
b &lt;- c(-2.2,-.7,1.54)
x &lt;- drm(b) 
# Plot the expected probabilites
plot(x)

# Five items with a constant discrimination equal to 1.2
# Use the scaling constant for the normal metric
a &lt;- rep(1.2,5)
b &lt;- c(-2,-1,0,1,2)
pars &lt;- list(a,b)
x &lt;- drm(pars,D=1.7)
# Extract the expected probabilities
get.prob(x)
# Plot the expected probabilities
plot(x,combine=5,item.names="Items 1-5")


## 2PL
# Compute probabilities for five items at a theta value of 1.5 logits
# Print the model
a &lt;- c(1,.8,.6,1.2,.9)
b &lt;- c(-1.7,2.2,.4,-1,-.4)
pars &lt;- cbind(a,b)
drm(pars,theta=1.5,print.mod=TRUE)


# Include a vector of zeros for the lower asymptote
# Compute probabilities for incorrect responses
a &lt;- c(.63,1.14,.89,1.01,1.51,.58)
b &lt;- c(-1.9,.08,1.6,-1.4,.5,-2.3)
c &lt;- rep(0,6)
pars &lt;- cbind(a,b,c)
x &lt;- drm(pars,incorrect=TRUE)
plot(x)


## 3PL
a &lt;- c(1,.8,.4,1.5,.9)
b &lt;- c(-2,-1,0,1,2)
c &lt;- c(.2,.25,.18,.2,.22)
pars &lt;- list(a,b,c)
x &lt;- drm(pars)
plot(x)

# Use theta values from -3 to 3 with an increment of 0.2
a &lt;- c(.71,.96,.36,1.05,1.76,.64)
b &lt;- c(-.16,1.18,2.03,1.09,.82,-1.56)
c &lt;- c(.22,.17,.24,.08,.20,.13)
theta &lt;- seq(-3,3,.2)
pars &lt;- cbind(a,b,c)
x &lt;- drm(pars,theta)
plot(x,combine=6,item.names="Items 1-6",auto.key=list(space="right"))

###### Multidimensional Examples ######
## M1PL
# A single item with a parameter related to item difficulty at 1 logit
x &lt;- drm(1, dimensions=2) 
plot(x)

# Three items with a difficulties at -2.2, -1.7, and 0.54 logits 
# respectively. Assume a constant discrimination of 1 for each item
d &lt;- c(-2.2,-.7,1.54)
x &lt;- drm(d, dimensions=2) 
plot(x, drape=TRUE)


## M2PL
# Items 27-30 from Reckase (1985)
a &lt;- matrix(c(1.66,1.72,.69,.19,.88,1.12,.68,1.21),4,2,byrow=TRUE)
d &lt;- c(-.38,-.68,-.91,-1.08)
pars &lt;- list(a,d)
x &lt;- drm(pars,dimensions=2)
plot(x, drape=TRUE, item.names=paste("Item",27:30))

# Create contourplots for these items
plot(x,type="contourplot",cuts=10)


## M3PL
# Single item from Reckase (1997, p. 274)
pars &lt;- t(c(.8,1.4,-2,.2))
x &lt;- drm(pars, dimensions=2)
plot(x, default.scales=list(arrows=FALSE),drape=TRUE)

# Compute the probabilities of an incorrect response
# for the Reckase (1997) item
x &lt;- drm(pars, dimensions=2, incorrect=TRUE)
plot(x, screen=list(z=-40,x=-60), auto.key=list(space="right"))

# Four items from the included example for BMIRT (Yao, 2003)
# modeled using four dimensions
pars &lt;- matrix(c(0.5038,2.1910,1.1317,0.2493,0.5240,0.1763, 
0.2252,1.1999,0.5997,0.2087, 2.1730,0.4576,
0.2167,0.2487,1.4009,0.3865,-1.5270,0.3507, 
2.3428,1.1530,0.3577,0.4240,-1.4971,0.3641),4,6,byrow=TRUE)
colnames(pars) &lt;- c("a1","a2","a3","a4","d","c")
x &lt;- drm(pars, dimensions=4, print.mod=TRUE)


## Not run: 
# Plot the item response surfaces for item 4
plot(x,items=4,item.names="Item 4",drape=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='equate-methods'>IRT True Score and Observed Score Equating</h2><span id='topic+equate'></span><span id='topic+equate-methods'></span><span id='topic+equate+2Clist-method'></span><span id='topic+equate+2Cirt.pars-method'></span>

<h3>Description</h3>

<p>This function conducts IRT true score and observed score equating for unidimensional 
single-format or mixed-format item parameters for two or more groups.  This function
supports all item response models available in <code>plink</code> with the exception of 
the multiple-choice model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equate(x, method=c("TSE", "OSE"), true.scores, ts.low, base.grp=1, score=1, 
  startval, weights1, weights2, syn.weights, exclude, max.tse.iter, ...) 

## S4 method for signature 'list'
equate(x, method, true.scores, ts.low, base.grp, score, startval, 
  weights1, weights2, syn.weights, exclude, max.tse.iter, ...)

## S4 method for signature 'irt.pars', 'ANY'
equate(x, method, true.scores, ts.low, base.grp, score, startval, 
  weights1, weights2, syn.weights, exclude, max.tse.iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equate-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+irt.pars-class">irt.pars</a></code> with one or more groups,
a list containing two or more <code><a href="#topic+irt.pars-class">irt.pars</a></code> objects (e.g., when there
are no common items), or the output from <code>plink</code> containing rescaled item parameters. </p>
</td></tr>
<tr><td><code id="equate-methods_+3A_method">method</code></td>
<td>
<p>character vector identifying the equating method(s) to use. 
Values can include <code>"TSE"</code> and <code>"OSE"</code>.</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_true.scores">true.scores</code></td>
<td>
<p>numeric vector of true score values to be equated</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_ts.low">ts.low</code></td>
<td>
<p>logical value. If TRUE, interpolate values for the equated 
true scores in the range of observed scores from one to the value below 
the lowest estimated true score (a rounded sum of guessing parameters)</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_base.grp">base.grp</code></td>
<td>
<p>integer identifying the group for the base scale</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_score">score</code></td>
<td>
<p>if <code>score</code> = 1, score responses for the true-score equating
method with zero for the lowest category and k-1 for the highest, k, category
for each item.  If <code>score</code> = 2, score responses with one for the
lowest category and k for the highest, k, category for each item.  A vector or
list of scoring weights for each response category can be supplied, but this is 
only recommended for advanced users.</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_startval">startval</code></td>
<td>
<p>integer starting value for the first value of <code>true.score</code></p>
</td></tr>
<tr><td><code id="equate-methods_+3A_weights1">weights1</code></td>
<td>
<p>list containing information about the theta values and weights
to be used in the observed score equating for population 1. See below for more 
details. </p>
</td></tr>
<tr><td><code id="equate-methods_+3A_weights2">weights2</code></td>
<td>
<p>list containing information about the theta values and weights
to be used in the observed score equating for population 2. See below for more 
details. </p>
</td></tr>
<tr><td><code id="equate-methods_+3A_syn.weights">syn.weights</code></td>
<td>
<p>vector of length two or a list containing vectors of length two
with synthetic population weights to be used for each pair of tests for populations 
1 and 2 respectively. If missing, weights of 0.5 will be used for both populations
for all groups.  If <code>syn.weights</code> is a list, there should be k-1 elements for
k groups.</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_exclude">exclude</code></td>
<td>
<p>character vector or list identifying common items that should be
excluded when estimating the linking constants. See below for more details.</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_max.tse.iter">max.tse.iter</code></td>
<td>
<p>maximum number of iterations to identify the theta value associated
with each true score. The default is 50.</p>
</td></tr>
<tr><td><code id="equate-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weights1</code> can be a list or a list of lists.  The purpose of this object is to specify
the theta values for population 1 to integrate over in the observed score equating as well as 
any weights associated with the theta values.  The function <code><a href="#topic+as.weight">as.weight</a></code> 
can be used to facilitate the creation of this object.  If <code>weights1</code> is missing, the 
default is to use equally spaced theta values ranging from -4 to 4 with an increment of 0.05 
and normal density weights for all groups.
</p>
<p>To better understand the elements of <code>weights1</code>, let us assume for a moment that <code>x</code>
has parameters for only two groups.  In this instance, <code>weights1</code> would be a single list 
with length two.  The first element should be a vector of theta values corresponding to points 
on the base scale.  The second list element should be a vector of weights corresponding the 
theta values.  If <code>x</code> contains more than two groups, a single <code>weights1</code> object can 
be supplied, and the same set of thetas and weights will be used for all adjacent groups.  
However, a separate list of theta values and weights for each adjacent group in <code>x</code> can be 
supplied.
</p>
<p>The specification of <code>weights2</code> is the same as that for <code>weights1</code>, although the 
theta values and weights for this object correspond to theta values for population 2.
This argument is only used when the synthetic weight associated with population 2 is greater
than zero. If <code>weights2</code> is missing, the same theta values and weights used for 
<code>weights1</code> will be used for <code>weights2</code>.
</p>
<p>For both equating methods, response probabilities are computed using the functions <code>drm</code>, 
<code>grm</code>, <code>gpcm</code>, and <code>nrm</code> for the associated models respectively. Various 
arguments from these functions can be passed to <code>equate</code>. Specifically, the argument 
<code>incorrect</code> can be passed to <code>drm</code> and <code>catprob</code> can be passed to <code>grm</code>. 
In the functions <code>drm</code>, <code>grm</code>, and <code>gpcm</code> there is an argument <code>D</code>
for the value of a scaling constant. In <code>plink</code>, a single argument <code>D</code> can be passed
that will be applied to all applicable models, or arguments <code>D.drm</code>, <code>D.grm</code>, and 
<code>D.gpcm</code> can be specified for each model respectively. If an argument is specified for <code>D</code>
and, say <code>D.drm</code>, the values for <code>D.grm</code> and <code>D.gpcm</code> (if applicable) will be
set equal to <code>D</code>. If only <code>D.drm</code> is specified, the values for <code>D.grm</code> and 
<code>D.gpcm</code> (if applicable) will be set to 1.
</p>
<p>There are instances where certain items should not be included in the computation of total scores
(e.g., when the common items correspond to an external anchor test or when using field test items)
The <code>exclude</code> argument can be used to remove these items prior to conducting the equationg. 
<code>exclude</code> can be specified as a character vector or a list. In the former case, a single value
&quot;all.common&quot; can be used to remove all common items or a vector of model names (i.e., &quot;drm&quot;, &quot;grm&quot;, 
&quot;gpcm&quot;, &quot;nrm&quot;, &quot;mcm&quot;) can be supplied, indicating that any item on any test associated with the given 
model(s) would be excluded. If the argument is specified as a list, <code>exclude</code> should have as 
any elements as groups in <code>x</code>. Each list element can include model names and/or item numbers 
corresponding to the items on each test that should be excluded. If no items need to be excluded for 
a given group, the list element should be equal NA. For example, say we have two groups and we would 
like to exclude the GRM items and item 23 from the first group, we would specify <code>exclude</code> as 
<code>exclude &lt;- list(c("grm",23),NA)</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of equated true scores and/or a list of equated observed scores with associated
marginal distributions or a list combining these two objects. The output for the observed-score
equating also includes EAP scores and SDs for each of the observed scores (Thissen &amp; Orlando, 2001).
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Kolen, M. J. (1981). 
Comparison of traditional and item response theory methods for equating tests. 
<em>Journal of Educational Measurement</em>, <em>18</em>(1), 1-11.
</p>
<p>Kolen, M. J. &amp; Brennan, R. L. (2004)
<em>Test Equating, Scaling, and Linking</em> (2nd ed.).
New York: Springer
</p>
<p>Thissen, D. &amp; Orlando, M. (2001)
Item response theory for items scored in two categories.
In D. Thissen &amp; H. Wainer (Eds.)
<em>Test Scoring</em> (p. 23 - 72).
Hillsdale, NJ: Lawrence Erlbaum Associates.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># IRT true score and observed score examples from 
# Kolen &amp; Brennan (2004, ch. 6)
pm &lt;- as.poly.mod(36)
x &lt;- as.irt.pars(KB04$pars, KB04$common,
  cat=list(rep(2,36),rep(2,36)), poly.mod=list(pm,pm))
out &lt;- plink(x, rescale="MS", base.grp=2, D=1.7, exclude=list(27,NA))

# Create the quadrature points and weights
wt &lt;- as.weight(
  theta=c(-5.2086,-4.163,-3.1175,-2.072,-1.0269,0.0184,
    1.0635,2.109,3.1546,4.2001),
  weight=c(0.000101,0.00276,0.03021,0.142,0.3149,0.3158,
    0.1542,0.03596,0.003925,0.000186))

# Conduct the equating
equate(out,weights1=wt, synth.weights=c(1,0),D=1.7)

# Conduct true score equating for specific true scores
equate(out, true.scores=7:15, ts.low=FALSE, D=1.7)

# Exclude all common items (assume they correspond to an external anchor)
equate(out, D=1.7, exclude="all.common")


# Observed score equating for mixed-format tests
pm1 &lt;- as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group1)
pm2 &lt;- as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group2)
x &lt;- as.irt.pars(dgn$pars,dgn$common,dgn$cat,list(pm1,pm2))
out &lt;- plink(x, rescale="HB") 
OSE &lt;- equate(out, method="OSE", score=2)

# Display the equated scores
OSE[[1]]

# Multiple group equating
pars &lt;- TK07$pars
common &lt;- TK07$common
cat &lt;- list(rep(2,26),rep(2,34),rep(2,37),rep(2,40),rep(2,41),rep(2,43))
pm1 &lt;- as.poly.mod(26)
pm2 &lt;- as.poly.mod(34)
pm3 &lt;- as.poly.mod(37)
pm4 &lt;- as.poly.mod(40)
pm5 &lt;- as.poly.mod(41)
pm6 &lt;- as.poly.mod(43)
pm &lt;- list(pm1, pm2, pm3, pm4, pm5, pm6)
x &lt;- as.irt.pars(pars, common, cat, pm, grp.names=paste("grade",3:8,sep=""))
out &lt;- plink(x, rescale="SL")


# True score equating
equate(out, method="TSE")

# True score equating with the base group changed to 3
equate(out, method="TSE", base.grp=3)

# Observed score equating (These data are for non-equivalent groups, but
# this example is included to illustrate the multigroup capabilities)
OSE &lt;- equate(out, method="OSE", base.grp=3)

# Display the equated scores for each group
OSE[[1]]

</code></pre>

<hr>
<h2 id='gpcm-methods'>Generalized Partial Credit Model Response Probabilities</h2><span id='topic+gpcm'></span><span id='topic+gpcm-methods'></span><span id='topic+gpcm+2Cmatrix+2Cnumeric-method'></span><span id='topic+gpcm+2Cdata.frame+2Cnumeric-method'></span><span id='topic+gpcm+2Clist+2Cnumeric-method'></span><span id='topic+gpcm+2Cirt.pars+2CANY-method'></span><span id='topic+gpcm+2Csep.pars+2CANY-method'></span>

<h3>Description</h3>

<p>This function computes the probability of responding in a specific category for one or 
more items for a given set of theta values using the partial credit model, generalized 
partial credit model, or multidimensional extension of these models, depending 
on the included item parameters and the specified number of dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpcm(x, cat, theta, dimensions = 1, D = 1, location = FALSE, 
  print.mod = FALSE, items, information = FALSE, angle, ...)

## S4 method for signature 'matrix', 'numeric'
gpcm(x, cat, theta, dimensions, D, location, print.mod, items, information, angle, ...)

## S4 method for signature 'data.frame', 'numeric'
gpcm(x, cat, theta, dimensions, D, location, print.mod, items, information, angle, ...)

## S4 method for signature 'list', 'numeric'
gpcm(x, cat, theta, dimensions, D, location, print.mod, items, information, angle, ...)

## S4 method for signature 'irt.pars', 'ANY'
gpcm(x, cat, theta, dimensions, D, location, print.mod, items, information, angle, ...)

## S4 method for signature 'sep.pars', 'ANY'
gpcm(x, cat, theta, dimensions, D, location, print.mod, items, information, angle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpcm-methods_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object containing item parameters </p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_cat">cat</code></td>
<td>
<p>vector identifying the number of response categories (not the number of step
parameters) for each item. </p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_theta">theta</code></td>
<td>
<p>vector, matrix, or list of theta values for which probabilities will be computed. 
If <code>theta</code> is not specified, an equal interval range of values from -4 to 4 is used 
with an increment of 0.5. See details below for more information. </p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_dimensions">dimensions</code></td>
<td>
<p>number of modeled dimensions </p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_d">D</code></td>
<td>
<p>scaling constant. The default value assumes that the parameters are already in the 
desired metric. If the parameters are in the logistic metric, they can be transformed to a 
normal metric by setting D = 1.7</p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_location">location</code></td>
<td>
<p>if <code>TRUE</code>, the step parameters are deviations from a difficulty
parameter </p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_print.mod">print.mod</code></td>
<td>
<p>if <code>TRUE</code>, print the model that was used (i.e., Partial Credit
Model, Generalized Partial Credit Model, Multidimensional Partial Credit
Model or Multidimensional Generalized Partial Credit Model) </p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_items">items</code></td>
<td>
<p>numeric vector identifying the items for which probabilities should be computed</p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_information">information</code></td>
<td>
<p>logical value. If <code>TRUE</code> compute item information. In the multidimensional
case, information will be computed in the directions specified by <code>angle</code> or default angles
of 0 - 90 in increments of 10 degrees.</p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_angle">angle</code></td>
<td>
<p>vector or matrix of angles between the dimension 1 axis and the corresponding axes for each 
of the other dimensions for which information will be computed. When there are more than two dimensions 
and <code>angle</code> is a vector, the same set of angles will be used relative to each of the corresponding axes.</p>
</td></tr>
<tr><td><code id="gpcm-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> can be specified as a vector, matrix, or list.  For the unidimensional case, <code>theta</code>
should be a vector. If a matrix or list of values is supplied, they will be converted to a single vector
of theta values.  For the multidimensional case, if a vector of values is supplied it will be assumed
that this same set of values should be used for each dimension.  Probabilities will be computed for each
combination of theta values.  Similarly, if a list is supplied, probabilities will be computed for each
combination of theta values.  In instances where probabilities are desired for specific combinations of 
theta values, a j x m matrix should be specified for j ability points and m dimensions where the columns 
are ordered from dimension 1 to m.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.prob-class">irt.prob</a></code>
</p>


<h3>Methods</h3>

<p>In the following description, references to the partial credit model and generalized
partial credit model should be thought of as encompassing both the unidimensional and 
multidimensional models.
</p>

<dl>
<dt>x = &quot;matrix&quot;, cat = &quot;numeric&quot;</dt><dd><p>This method allows one to specify an n x k 
matrix for n items.  The number of columns can vary depending on the model 
(partial credit or generalized partial credit model), number of dimensions, and 
whether a location parameter is included.  Generally, the first m columns, for m
dimensions, are for item slopes and the remaining columns are for step parameters.
</p>

<dl>
<dt>Slope Parameters:</dt><dd><p>The partial credit model is typically specified with 
all slopes equal to 1.  For this model it is unnecessary (although optional) to 
include ones in the first m columns.  For slope values other than one (equal for 
all items) or for the generalized partial credit model, slope parameters should 
be included in the first m columns.</p>
</dd>
<dt>Step/Step Deviation Parameters:</dt><dd><p>Step parameters can be characterized in
two ways: as the actual steps or deviations from an overall item difficulty
(location).  In the deviation scenario the <code>location</code> argument should be 
equal to <code>TRUE</code>.  If column(s) are included for the slope parameters, 
the location parameters should be in the m+1 column; otherwise, they should be 
in the first column.  The columns for the step/step deviation parameters will always
follow the slope and/or location columns (or they may potentially 
start in the first column for the partial credit model with no location parameter).
</p>
<p>The number of step/step deviation parameters can vary for each item.  In these
instances, all cells with missing values should be filled with <code>NA</code>s.  For
example, for a unidimensional generalized partial credit model with no location 
parameter, if one item has five categories (four step parameters) and another item 
has three categories (two step parameters), there should be five columns.  The first 
column includes the slope parameters and columns 2-5 include the step parameters.
The values in the last two columns for the item with three categories should be <code>NA</code>.</p>
</dd>
</dl>

</dd>
<dt>x = &quot;data.frame&quot;, cat = &quot;numeric&quot;</dt><dd><p>See the method for x = &quot;matrix&quot; </p>
</dd>
<dt>x = &quot;list&quot;, cat = &quot;numeric&quot;</dt><dd><p>This method can include a list with one or two
elements. Generally, the first element is for item slopes and the second is
for step/step deviation parameters. 
</p>

<dl>
<dt>Slope Parameters:</dt><dd><p>For the partial credit model with all slopes equal to 1 it is 
unnecessary (although optional) to include a list element for the item slopes.  If no 
slope values are included, the first element would contain the step/deviation step 
parameters.  For slopes other than 1 (equal for all items) or for the generalized partial 
credit model, slope values should be included in the first list element.  For the 
unidimensional case, these values should be a vector of length n or an n x 1 matrix for 
n items. For the multidimensional case, an n x m matrix of values for m dimensions 
should be supplied</p>
</dd>
<dt>Step/Step Deviation Parameters:</dt><dd><p>The step/step deviation parameters should be 
formatted as an n x k matrix for n items.  If the steps are deviations from a location 
parameter, the argument <code>location</code> should equal <code>TRUE</code> and the location 
parameters should be in the first column.  The number of step/step deviation parameters 
can vary for each item.  In these instances, all cells with missing values should be 
filled with <code>NA</code>s (See the example in the method for x = &quot;matrix&quot;). </p>
</dd>
</dl>

</dd>
<dt>x = &quot;irt.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the gpcm items in an object of class <code>"irt.pars"</code>.  If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning 
will be displayed stating that probabilities will be computed for the gpcm items only. 
If <code>x</code> contains parameters for multiple groups, a list of <code>"irt.prob"</code> objects 
will be returned. The argument <code>dimensions</code> does not need to be included for this method.</p>
</dd>
<dt>x = &quot;sep.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the gpcm items in an object of class <code>sep.pars</code>.  If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning will be 
displayed stating that probabilities will be computed for the gpcm items only. The argument 
<code>dimensions</code> does not need to be included for this method.</p>
</dd>
</dl>



<h3>Note</h3>

 
<p>The determination of the model (partial credit or generalized partial credit) is based on
the number of non-NA columns for each item in <code>x</code> and the corresponding values in
<code>cat</code>.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Adams, R. J., Wilson, M., &amp; Wang, W. (1997).
The multidimensional random coefficients multinomial logit model.
<em>Applied Psychological Measurement</em>, <em>21</em>(1), 1-23.
</p>
<p>Embretson, S. E., &amp; Reise, S. P. (2000).
<em>Item Response Theory for Psychologists.</em>
Mahwah, New Jersey: Lawrence Erlbaum Associates.
</p>
<p>Masters, G. N. (1982).
A rasch model for partial credit scoring.
<em>Psychometrika</em>, <em>47</em>(2), 149-174.
</p>
<p>Masters, G. N. &amp; Wright, B. D. (1996)
The partial credit model.
In W. J. van der Linden &amp; Hambleton, R. K. (Eds.) 
<em>Handbook of Modern Item Response Theory</em> (pp. 101-121). 
New York: Springer-Verlag.
</p>
<p>Muraki, E. (1992)
A generalized partial credit model: Application of an EM algorithm.
<em>Applied Psychological Measurement</em>, <em>16</em>(2), 159-176.
</p>
<p>Muraki, E. (1996)
A generalized partial credit model.
In W. J. van der Linden &amp; Hambleton, R. K. (Eds.) 
<em>Handbook of Modern Item Response Theory</em> (pp. 153-164). 
New York: Springer-Verlag.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>
<p>Yao, L. (2003). 
BMIRT: Bayesian multivariate item response theory [Computer Program]. 
Monterey, CA: CTB/McGraw-Hill.	
</p>
<p>Yao, L., &amp; Schwarz, R. D. (2006). 
A multidimensional partial credit model with associated item and test statistics: 
An application to mixed-format tests. 
<em>Applied Psychological Measurement</em>, <em>30</em>(6), 469-492.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+mixed-methods">mixed</a>:</code> compute probabilities for mixed-format items<br />
<code><a href="#topic+plot.irt.prob">plot</a>:</code> plot item characteristic/category curves<br />
<code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a>:</code> classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
## Partial Credit Model
## Item parameters from Embretson &amp; Reise (2000, p. 108) item 5
b &lt;- t(c(-2.519,-.063,.17,2.055))
x &lt;- gpcm(b,5)
plot(x) 

## Generalized Partial Credit Model
## Item parameters from Embretson &amp; Reise (2000, p. 112) items 5-7
a &lt;- c(.683,1.073,.583)
b &lt;- matrix(c(-3.513,-.041,.182,NA,-.873,.358,-.226,
  1.547,-4.493,-.004,NA,NA),3,4,byrow=TRUE)
pars &lt;- cbind(a,b) # Does not include a location parameter
rownames(pars) &lt;- paste("Item",5:7,sep="") 
colnames(pars) &lt;- c("a",paste("b",1:4,sep=""))
cat &lt;- c(4,5,3)
x &lt;- gpcm(pars,cat,seq(-3,3,.05))
plot(x)

## Item parameters from Muraki (1996, p. 154)
a &lt;- c(1,.5)
b &lt;- matrix(c(.25,-1.75,1.75,.75,-1.25,1.25),2,3,byrow=TRUE)
pars &lt;- cbind(a,b) # Include a location parameter
rownames(pars) &lt;- paste("Item",1:2,sep="")
colnames(pars) &lt;- c("a","b",paste("d",1:2,sep=""))
cat &lt;- c(3,3)
x &lt;- gpcm(pars,cat,location=TRUE,print.mod=TRUE, D=1.7)
# Plot category curves for two items
matplot(x@prob$theta,x@prob[,2:4],xlab="Theta",ylab="Probability",
  ylim=c(0,1),lty=1,type="l",col="black") 
par(new=TRUE)
matplot(x@prob$theta,x@prob[,5:7],xlab="Theta",ylab="Probability",
  ylim=c(0,1),lty=3,type="l",col="black") 


###### Multidimensional Examples ######
## Multidimensional Partial Credit Model
pars &lt;- matrix(c(2.4207,0.245,-1.1041,NA,
2.173,-0.4576,NA,NA,
2.1103,-0.8227,.4504,NA,
3.2023,1.0251,-.7837,-1.3062),4,4,byrow=TRUE)
cat &lt;- c(4,3,4,5)
x &lt;- gpcm(pars,cat,dimensions=2,print.mod=TRUE)
# plot combined item category surfaces
# The screen argument adjusts the orientation of the axes
plot(x,screen=list(z=-60,x=-70))

## Multidimensional Generalized Partial Credit Model
a &lt;- matrix(c(.873, .226, .516, .380, .613, .286 ),3,2,byrow=TRUE)
b &lt;- matrix(c(2.255, 1.334, -.503, -2.051, -3.082,
1.917, 1.074, -.497, -1.521, -2.589,
1.624, .994, -.656, -1.978, NA),3,5,byrow=TRUE)
pars &lt;- cbind(a,b)
cat &lt;- c(6,6,5)
x &lt;- gpcm(pars,cat,dimensions=2,print.mod=TRUE)

# plot combined item category surfaces
plot(x,screen=list(z=-40,x=-60), auto.key=list(space="right"))

# plot separated item category surfaces for item two
plot(x,items=2,separate=TRUE,drape=TRUE,panels=1)

# Compute response probabilities for a single three-category item with
# three dimensions. Plot the response surfaces for the first two 
# dimensions conditional on each theta value on the third dimension
pars &lt;- matrix(c(1.1999,0.5997,0.8087,2.1730,-1.4576),1,5)
x &lt;- gpcm(pars,3,dimensions=3,theta=-4:4)
plot(x, screen=list(z=-30,x=-60))
</code></pre>

<hr>
<h2 id='grm-methods'>Graded Response Model Probabilities</h2><span id='topic+grm'></span><span id='topic+grm-methods'></span><span id='topic+grm+2Cmatrix+2Cnumeric-method'></span><span id='topic+grm+2Cdata.frame+2Cnumeric-method'></span><span id='topic+grm+2Clist+2Cnumeric-method'></span><span id='topic+grm+2Cirt.pars+2CANY-method'></span><span id='topic+grm+2Csep.pars+2CANY-method'></span>

<h3>Description</h3>

<p>This function computes the cumulative probability of responding within or above a certain 
category or the probability of responding in a specific category for one or more items for 
a given set of theta values using the graded response model or multidimensional graded
response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grm(x, cat, theta, dimensions = 1, catprob = FALSE, D = 1, 
  location = FALSE, items, information = FALSE, angle, ...)

## S4 method for signature 'matrix', 'numeric'
grm(x, cat, theta, dimensions, catprob, D, location, items, information, angle, ...)

## S4 method for signature 'data.frame', 'numeric'
grm(x, cat, theta, dimensions, catprob, D, location, items, information, angle, ...)

## S4 method for signature 'list', 'numeric'
grm(x, cat, theta, dimensions, catprob, D, location, items, information, angle, ...)

## S4 method for signature 'irt.pars', 'ANY'
grm(x, cat, theta, dimensions, catprob, D, location, items, information, angle, ...)

## S4 method for signature 'sep.pars', 'ANY'
grm(x, cat, theta, dimensions, catprob, D, location, items, information, angle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grm-methods_+3A_x">x</code></td>
<td>
<p>ans <code>R</code> object containing item parameters.</p>
</td></tr>
<tr><td><code id="grm-methods_+3A_cat">cat</code></td>
<td>
<p>vector identifying the number of response categories (not the number of threshold
parameters) for each item.</p>
</td></tr>
<tr><td><code id="grm-methods_+3A_theta">theta</code></td>
<td>
<p>vector, matrix, or list of theta values for which probabilities will be computed. 
If <code>theta</code> is not specified, an equal interval range of values from -4 to 4 is used 
with an increment of 0.5. See details below for more information. </p>
</td></tr>
<tr><td><code id="grm-methods_+3A_dimensions">dimensions</code></td>
<td>
<p>number of modeled dimensions </p>
</td></tr>
<tr><td><code id="grm-methods_+3A_catprob">catprob</code></td>
<td>
<p>if <code>TRUE</code>, compute category probabilities instead of cumulative
probabilities </p>
</td></tr>
<tr><td><code id="grm-methods_+3A_d">D</code></td>
<td>
<p>scaling constant. The default value assumes that the parameters are already in the 
desired metric. If the parameters are in the logistic metric, they can be transformed to a 
normal metric by setting D = 1.7</p>
</td></tr>
<tr><td><code id="grm-methods_+3A_location">location</code></td>
<td>
<p>if <code>TRUE</code>, the step parameters are deviations from a difficulty
parameter </p>
</td></tr>
<tr><td><code id="grm-methods_+3A_items">items</code></td>
<td>
<p>numeric vector identifying the items for which probabilities should be computed</p>
</td></tr>
<tr><td><code id="grm-methods_+3A_information">information</code></td>
<td>
<p>logical value. If <code>TRUE</code> compute item information. In the multidimensional
case, information will be computed in the directions specified by <code>angle</code> or default angles
of 0 - 90 in increments of 10 degrees.</p>
</td></tr>
<tr><td><code id="grm-methods_+3A_angle">angle</code></td>
<td>
<p>vector or matrix of angles between the dimension 1 axis and the corresponding axes for each 
of the other dimensions for which information will be computed. When there are more than two dimensions 
and <code>angle</code> is a vector, the same set of angles will be used relative to each of the corresponding axes.</p>
</td></tr>
<tr><td><code id="grm-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> can be specified as a vector, matrix, or list.  For the unidimensional case, <code>theta</code>
should be a vector. If a matrix or list of values is supplied, they will be converted to a single vector
of theta values.  For the multidimensional case, if a vector of values is supplied it will be assumed
that this same set of values should be used for each dimension.  Probabilities will be computed for each
combination of theta values.  Similarly, if a list is supplied, probabilities will be computed for each
combination of theta values.  In instances where probabilities are desired for specific combinations of 
theta values, a j x m matrix should be specified for j ability points and m dimensions where the columns 
are ordered from dimension 1 to m.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.prob-class">irt.prob</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;matrix&quot;, cat = &quot;numeric&quot;</dt><dd><p> This method allows one to specify an n x k 
matrix for n items.  The number of columns can vary depending on the number of dimensions
and whether a location parameter is included.  The first m columns, for m dimensions, are
for item slopes and the remaining columns are for the threshold/threshold deviation 
parameters.
</p>
<p>Threshold parameters can be characterized in two ways: the actual thresholds or 
deviations from an overall item difficulty (location).  In the deviation scenario the 
<code>location</code> argument should be <code>TRUE</code> and the location parameters should be 
in the m+1 column.  The columns for the threshold/threshold deviation parameters 
will always follow the slope column(s) and, if applicable, the location column.  The number 
of threshold/threshold deviation parameters can vary for each item.  In these instances, 
all cells with missing values should be filled with <code>NA</code>s.  For example, for a 
unidimensional model with no location parameter, if one item has five categories (four 
threshold parameters) and another item has three categories (two threshold parameters), 
there should be five columns.  The first column includes the slope parameters and columns 
2-5 include the threshold parameters.  The values in the last two columns for the item with 
three categories should be <code>NA</code>.</p>
</dd>
<dt>x = &quot;data.frame&quot;, cat = &quot;numeric&quot;</dt><dd><p>See the method for x = &quot;matrix&quot; </p>
</dd>
<dt>x = &quot;list&quot;, cat = &quot;numeric&quot;</dt><dd><p>This method is for a list with two elements.  The first 
list element is for item slopes and the second for the threshold/threshold deviation 
parameters.  For the unidimensional case, the slope values should be a vector of length n 
or an n x 1 matrix for n items.  For the multidimensional case, the slopes should be
specified in an n x m matrix.  For both the unidimensional and multidimensional cases, 
the threshold/threshold deviation parameters should be formatted as an n x k matrix.  If 
the thresholds are deviations from a location parameter, the argument <code>location</code> 
should be <code>TRUE</code> and the location parameters should be in the first column.  The 
number of threshold/threshold deviation parameters can vary for each item.  In these 
instances, all cells with missing values should be filled with <code>NA</code>s (See the 
example in the method for x = &quot;matrix&quot;). </p>
</dd>
<dt>x = &quot;irt.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the grm items in an object of class <code>"irt.pars"</code>.  If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning will be 
displayed stating that probabilities will be computed for the grm items only. If <code>x</code> 
contains parameters for multiple groups, a list of <code>"irt.prob"</code> objects will be 
returned.  The argument <code>dimensions</code> does not need to be included for this method.</p>
</dd>
<dt>x = &quot;sep.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the grm items in an object of class <code>sep.pars</code>. If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning will be 
displayed stating that probabilities will be computed for the grm items only.  The 
argument <code>dimensions</code> does not need to be included for this method.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Embretson, S. E., &amp; Reise, S. P. (2000)
<em>Item Response Theory for Psychologists.</em>
Mahwah, New Jersey: Lawrence Erlbaum Associates.
</p>
<p>Kolen, M. J. &amp; Brennan, R. L. (2004)
<em>Test Equating, Scaling, and Linking (2nd ed.).</em>
New York: Springer.
</p>
<p>Muraki, E., &amp; Carlson, J. E. (1995). 
Full-information factor analysis for polytomous item responses. 
<em>Applied Psychological Measurement</em>, <em>19</em>(1), 73-90.
</p>
<p>Samejima, F. (1969)
Estimation of latent ability using a response pattern of graded scores.
<em>Psychometrika Monograph</em>, No. 17.
</p>
<p>Samejima, F. (1996)
The graded response model.
In W. J. van der Linden &amp; Hambleton, R. K. (Eds.) 
<em>Handbook of Modern Item Response Theory</em> (pp. 85-100). 
New York: Springer-Verlag.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+mixed-methods">mixed</a>:</code> compute probabilities for mixed-format items<br />
<code><a href="#topic+plot.irt.prob">plot</a>:</code> plot item characteristic/category curves<br />
<code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a>:</code> classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
## Cumulative probabilities 
## Item parameters from Embretson &amp; Reise (2000, p. 101) items 9-11
# Includes a location parameter
a &lt;- c(2.09,1.18,1.69)
b &lt;- matrix(c(-1.07,-1.03,.39,.86,1.78,1.85,-.87,-.39,.31,NA,
  -1.4,-.42,NA,NA,-1.74),3,5) 
pars &lt;- cbind(a,b)
rownames(pars) &lt;- paste("Item",9:11,sep=" ")
colnames(pars) &lt;- c("a","b",paste("c",1:4,sep=""))
cat &lt;- c(3,4,5)
x &lt;- grm(pars,cat,location=TRUE)
plot(x)

## Item parameters from Kolen &amp; Brennan (2004, p. 210)
# Use theta values from -3 to 3 with an increment of 0.5
pars &lt;- t(c(1.2,-.5,.6,1.1,1.3))
x &lt;- grm(pars,5,theta=seq(-3,3,.05))
plot(x,item.lab=FALSE)


## Category probabilities
## Single item
pars &lt;- t(c(1.2,-.5,.6,1.1,1.3))
x &lt;- grm(pars,5,seq(-3,3,.05),catprob=TRUE)
plot(x,item.lab=FALSE)

# Items without location parameter
a &lt;- c(2.09,1.18,1.69)
b &lt;- matrix(c(-1.93,-2.81,-1.46,-.2,-.64,.08,NA,.37,.81,NA,NA,2.13),3,4) 
pars &lt;- cbind(a,b)
rownames(pars) &lt;- paste("Item",9:11,sep=" ")
colnames(pars) &lt;- c("a",paste("b",1:4,sep=""))
cat &lt;- c(3,4,5)
x &lt;- grm(pars,cat,catprob=TRUE)
plot(x)

## Create sep.pars object then compute category probabilities
a &lt;- c(2.09,1.18,1.69)
b &lt;- matrix(c(-1.93,-2.81,-1.46,-.2,-.64,.08,NA,.37,.81,NA,NA,2.13),3,4) 
pars &lt;- cbind(a,b)
cat &lt;- c(3,4,5)
pm &lt;- as.poly.mod(3,"grm")
out &lt;- sep.pars(pars,cat,pm)
x &lt;- grm(out,catprob=TRUE)
plot(x)


###### Multidimensional Examples ######
## Cumulative probabilities
a &lt;- matrix(c(.873, .226, .516, .380, .613, .286 ),3,2,byrow=TRUE)
d &lt;- matrix(c(2.255, 1.334, -.503, -2.051, -3.082,
1.917, 1.074, -.497, -1.521, -2.589,
1.624, .994, -.656, -1.978, NA),3,5,byrow=TRUE)
pars &lt;- cbind(a,d)
cat &lt;- c(6,6,5)
x &lt;- grm(pars,cat,dimensions=2)
plot(x)

# Plot separated response surfaces
plot(x, separate=TRUE, drape=TRUE)

## Category Probabilities
## Use {pars} an {cat} from the example above
x &lt;- grm(pars,cat,dimensions=2, catprob=TRUE)

# plot combined item category surfaces
# The screen argument adjusts the orientation of the axes
plot(x,screen=list(z=-40,x=-60), auto.key=list(space="right"))
</code></pre>

<hr>
<h2 id='irt.pars-class'>Class &quot;irt.pars&quot;</h2><span id='topic+irt.pars-class'></span><span id='topic+initialize+2Cirt.pars-method'></span>

<h3>Description</h3>

<p>The formal S4 class for irt.pars. This class contains the item parameters
and characteristics of the item parameters for one or more groups.  When parameters
are included for two or more groups, the common items between the different groups are also
included.</p>


<h3>Details</h3>

<p>Objects of class <code>irt.pars</code> contain all the information necessary to produce
expected response probabilities, linking constants (when data for two or more groups are 
included), and to plot item response curves/surfaces, vector plots, and parameter 
comparison plots.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("irt.pars", ...)</code>, but this is 
not encouraged.  Use the function <code><a href="#topic+as.irt.pars">as.irt.pars</a></code> instead. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>pars</code>:</dt><dd><p>matrix of item parameters for a single group or a list of matrices 
containing item parameters for two or more groups</p>
</dd>
<dt><code>cat</code>:</dt><dd><p>vector with length equal to the number of items, identifying the number 
of response categories for each item for a single group or a list of response category 
vectors for two or more groups</p>
</dd>
<dt><code>poly.mod</code>:</dt><dd><p>a <code><a href="#topic+poly.mod-class">poly.mod</a></code> object for one group or a list of 
<code>poly.mod</code> objects identifying the items associated with each IRT model (see class 
<code><a href="#topic+poly.mod-class">poly.mod</a></code> for more information)</p>
</dd>
<dt><code>common</code>:</dt><dd><p>a j x 2 matrix for j common items or a list of matrices identifying the 
common items between pairs of item parameters</p>
</dd>
<dt><code>location</code>:</dt><dd><p>logical vector identifying whether a given set of item parameters 
(i.e., for a given group) includes a location parameter </p>
</dd>
<dt><code>groups</code>:</dt><dd><p>the number of groups (i.e. sets of item parameters)</p>
</dd>
<dt><code>dimensions</code>:</dt><dd><p>numeric vector identifying the number of modeled dimensions</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+poly.mod-class">poly.mod</a></code>, directly.
Class <code><a href="#topic+list.poly-class">list.poly</a></code>, by class <code>poly.mod</code>, distance 2.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+as.irt.pars">as.irt.pars</a></code>, <code><a href="#topic+as.poly.mod">as.poly.mod</a></code>
</p>

<hr>
<h2 id='irt.prob-class'>Class &quot;irt.prob&quot;</h2><span id='topic+irt.prob-class'></span>

<h3>Description</h3>

<p>The formal S4 class for irt.prob.  This class contains the expected 
probabilities of responding in a given category for a set of items and theta values 
under the specified IRT models.  The class also includes characteristics of the items.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("irt.prob", ...)</code>, but this is
not encouraged.  Use one of the functions <code>drm</code>, <code>gpcm</code>, <code>grm</code>, <code>mcm</code>, 
<code>nrm</code>, or <code>mixed</code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob</code>:</dt><dd><p>data.frame of item probabilities with n rows and j+m columns for n theta 
values and j items (the first m column contains theta values for m dimensions)</p>
</dd>
<dt><code>info</code>:</dt><dd><p>data.frame of item information</p>
</dd>
<dt><code>p.cat</code>:</dt><dd><p>vector identifying the number of categories for each item for which 
probabilities were computed</p>
</dd>
<dt><code>mod.lab</code>:</dt><dd><p>character vector of labels for the model(s).</p>
</dd>
<dt><code>dimensions</code>:</dt><dd><p>numeric value identifying the number of modeled dimensions</p>
</dd>
<dt><code>D</code>:</dt><dd><p>numeric vector identifying scaling constants for <code>drm</code>, <code>grm</code>, 
and <code>gpcm</code></p>
</dd>
<dt><code>pars</code>:</dt><dd><p>list of the item parameters used to compute the probabilities</p>
</dd>
<dt><code>model</code>:</dt><dd><p>character vector identifying all the models used to compute the 
probabilities in <code>prob</code>.  The only acceptable models are <code>drm</code>, <code>gpcm</code>, 
<code>grm</code>, <code>mcm</code>, and <code>nrm</code> (see class <code><a href="#topic+poly.mod-class">poly.mod</a></code> for more 
information).</p>
</dd>
<dt><code>items</code>:</dt><dd><p>list with the same length as <code>model</code>, where each element 
identifies the items associated with the model(s) specified in <code>model</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+poly.mod-class">poly.mod</a></code>, directly.<br />
Class <code><a href="#topic+list.poly-class">list.poly</a></code>, by class <code>poly.mod</code>, distance 2.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

<p>These models provide information on both unidimensional and multidimensional formulations<br />
<code><a href="#topic+drm-methods">drm</a>:</code> for dichotomous response models (1PL, 2PL, and 3PL)<br />
<code><a href="#topic+gpcm-methods">gpcm</a>:</code> for the partial credit/generalized partial credit model<br />
<code><a href="#topic+grm-methods">grm</a>:</code> for the graded response model<br />
<code><a href="#topic+mcm-methods">mcm</a>:</code> for the multiple-choice model<br />
<code><a href="#topic+nrm-methods">nrm</a>:</code> for the nominal response model<br />
<code><a href="#topic+mixed-methods">mixed</a>:</code> for mixed-format items<br />
<code><a href="#topic+irt.pars-class">irt.pars</a></code>
</p>

<hr>
<h2 id='is.irt.pars'>Identify Class</h2><span id='topic+is.irt.pars'></span><span id='topic+is.sep.pars'></span><span id='topic+is.poly.mod'></span><span id='topic+is.irt.prob'></span><span id='topic+is.link'></span>

<h3>Description</h3>

<p>These functions test whether a given object is of a specified class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.irt.pars(x)
is.sep.pars(x)
is.poly.mod(x)
is.irt.prob(x)
is.link(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.irt.pars_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical value
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a></code>, <code><a href="#topic+poly.mod-class">poly.mod</a></code>,
<code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+link-class">link</a></code> </p>

<hr>
<h2 id='KB04'>Kolen - Brennan (2004)</h2><span id='topic+KB04'></span>

<h3>Description</h3>

<p>This (unidimensional) dataset includes three parameter logistic model (3PL) item parameter 
estimates for two groups.  The Form X items are from a &quot;new&quot; form and the Form Y items are 
from an &quot;old&quot; form.  The data are listed in Table 6.5 in <em>Test Equating, Scaling, and 
Linking</em> (2nd ed.).  There are 12 common items between the two forms.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KB04</code></pre>


<h3>Format</h3>

<p>A list of length two.  The first element <code>pars</code> is a list of length two. 
Each of the list elements in <code>pars</code> is a 36 x 3 matrix of item parameters.
Element one is for <code>Form X</code>, and element two is for <code>Form Y</code>.
</p>
<p>The second list element in <code>KB04</code> is a matrix identifying the common items
between the two sets of parameters in <code>pars</code>.  That is, the first column in
<code>common</code> identifies the rows in <code>pars$form.x</code> that are common items.
The second column identifies the corresponding set of common items in <code>pars$form.y</code>.
</p>


<h3>Note</h3>

<p>In the book, the authors transform the Form X parameters to the Form Y scale.</p>


<h3>Source</h3>

<p>Kolen, M. J., &amp; Brennan, R. L. (2004)
<em>Test Equating, Scaling, and Linking.</em> (2nd ed.), p. 192
New York: Springer
</p>

<hr>
<h2 id='link-class'>Class &quot;link&quot;</h2><span id='topic+link-class'></span>

<h3>Description</h3>

<p>The formal S4 class for link.  This class compiles the linking constants,
item parameter descriptive statistics, and iteration/objective/convergence information
for the moment methods and characteristic curve methods from a separate calibration linking
procedure. It is also able to store rescaled item and ability parameters.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("link", ...)</code>, but this is 
not encouraged.  Use the function <code><a href="#topic+plink-methods">plink</a></code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt><code>constants</code>:</dt><dd><p>list of linking methods where the list elements include
the linking constants.  For unidimensional models, each element is a vector of
length two containing a slope and intercept to adjust the SD and mean respectively. 
For multidimensional models, each element is a list with a matrix (or set of 
matrices) to resolve rotational indeterminacy and scale, and a vector of 
translation constants to adjust the mean of each dimension. </p>
</dd>
<dt><code>descriptives</code>:</dt><dd><p>data.frame or list containing the item parameter
descriptive statistics</p>
</dd>
<dt><code>iterations</code>:</dt><dd><p>vector of the number of optimization iterations for
the Haebara and Stocking-Lord methods</p>
</dd>
<dt><code>objective</code>:</dt><dd><p>vector of criterion values for HBcrit and SLcrit at the point
of convergence for the Haebara and Stocking-Lord methods</p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>character vector identifying the type of convergence
reached under the Haebara or Stocking-Lord optimizations.</p>
</dd>
<dt><code>base.grp</code>:</dt><dd><p>numeric value indicating the base group for the calibration</p>
</dd>
<dt><code>n</code>:</dt><dd><p>vector identifying the total number of common items, the number of
dichotomous common items, and the number of polytomous common items</p>
</dd>
<dt><code>grp.names</code>:</dt><dd><p>character vector of group names</p>
</dd>
<dt><code>mod.lab</code>:</dt><dd><p>character vector identifying the dichotomous and/or polytomous
models used to model the item responses</p>
</dd>
<dt><code>dilation</code>:</dt><dd><p>character value identifying the dilation approach used when
estimating multidimensional linking constants</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+plink-methods">plink</a></code>
</p>

<hr>
<h2 id='link.con'>Extract Output Information</h2><span id='topic+link.con'></span><span id='topic+link.pars'></span><span id='topic+link.ability'></span><span id='topic+get.prob'></span>

<h3>Description</h3>

<p>These functions extract information from an object of class <code><a href="#topic+irt.pars-class">irt.pars</a></code>,
typically created using <code><a href="#topic+plink-methods">plink</a></code>, or an object of 
class <code><a href="#topic+irt.prob-class">irt.prob</a></code> containing expected probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link.con(x, method = "ALL")
link.pars(x)
link.ability(x)
get.prob(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link.con_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object</p>
</td></tr>
<tr><td><code id="link.con_+3A_method">method</code></td>
<td>
<p>character vector identifying the linking methods for which
constants should be returned. The only acceptable values are 
<code>ALL, MM, MS, HB, SL, and RM</code>. See below for details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>link.con</code> extracts the linking constants,
<code>link.pars</code> extracts the rescaled item parameters (if present), and 
<code>link.ability</code> extracts the rescaled ability estimates (if present)
<code>get.prob</code> extracts expected probabilities for an <code>irt.prob</code> object
</p>
<p>For <code>link.con</code>, the following values can be included for <code>method</code>.
For multidimensional constants, although matrices <code>A</code>, <code>K</code>, and <code>T</code> are
included in the object of class &quot;<code>link</code>&quot; for the Haebara and Stocking-Lord
methods, only the matrix <code>A</code> will be returned for these methods.
</p>

<dl>
<dt>ALL</dt><dd><p>Returns the constants for all linking methods</p>
</dd>
<dt><code>MM</code>:</dt><dd><p>Mean/Mean</p>
</dd>
<dt><code>MS</code>:</dt><dd><p>Mean/Sigma</p>
</dd>
<dt><code>HB</code>:</dt><dd><p>Haebara</p>
</dd>
<dt><code>SL</code>:</dt><dd><p>Stocking-Lord</p>
</dd>
<dt><code>RM</code>:</dt><dd><p>Reckase-Martineau (for multidimensional constants only)</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns a matrix or list of linking constants
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+link-class">link</a></code>, <code><a href="#topic+plink-methods">plink</a></code> </p>

<hr>
<h2 id='list.poly-class'>Class Combinations</h2><span id='topic+list.poly-class'></span><span id='topic+list.dat-class'></span><span id='topic+list.mat-class'></span><span id='topic+list.num-class'></span><span id='topic+num.null-class'></span><span id='topic+list.null-class'></span><span id='topic+pars.null-class'></span><span id='topic+dat.null-class'></span>

<h3>Description</h3>

<p>These classes are combinations of classes</p>


<h3>Details</h3>


<dl>
<dt>list.poly:</dt><dd><p>combines class <code>list</code> and class <code><a href="#topic+poly.mod-class">poly.mod</a></code> </p>
</dd>
<dt>list.dat:</dt><dd><p>combines class <code>list</code> and class <code>data.frame</code> </p>
</dd>
<dt>list.mat:</dt><dd><p>combines class <code>list</code> and class <code>matrix</code> </p>
</dd>
<dt>list.num:</dt><dd><p>combines class <code>list</code> and class <code>numeric</code> </p>
</dd>
<dt>num.null:</dt><dd><p>combines class <code>numeric</code> and class <code>NULL</code> </p>
</dd>
<dt>list.null:</dt><dd><p>combines class <code>list</code> and class <code>NULL</code> </p>
</dd>
<dt>pars.null:</dt><dd><p>combines class <code>irt.pars</code> and class <code>NULL</code> </p>
</dd>
<dt>dat.null:</dt><dd><p>combines class <code>data.frame</code> and class <code>NULL</code> </p>
</dd>
</dl>



<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>

<hr>
<h2 id='mcm-methods'>Multiple-Choice Model Response Probabilities</h2><span id='topic+mcm'></span><span id='topic+mcm-methods'></span><span id='topic+mcm+2Cmatrix+2Cnumeric-method'></span><span id='topic+mcm+2Cdata.frame+2Cnumeric-method'></span><span id='topic+mcm+2Clist+2Cnumeric-method'></span><span id='topic+mcm+2Cirt.pars+2CANY-method'></span><span id='topic+mcm+2Csep.pars+2CANY-method'></span>

<h3>Description</h3>

<p>This function computes the probability of responding in a specific category for one or more 
items for a given set of theta values using the multiple-choice model or multidimensional
multiple-choice model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcm(x, cat, theta, dimensions = 1, items, information = FALSE, angle, ...)

## S4 method for signature 'matrix', 'numeric'
mcm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'data.frame', 'numeric'
mcm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'list', 'numeric'
mcm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'irt.pars', 'ANY'
mcm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'sep.pars', 'ANY'
mcm(x, cat, theta, dimensions, items, information, angle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcm-methods_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object containing item parameters</p>
</td></tr>
<tr><td><code id="mcm-methods_+3A_cat">cat</code></td>
<td>
<p>vector identifying the number of response categories plus one for each item 
(the additional category is for 'do not know') </p>
</td></tr>
<tr><td><code id="mcm-methods_+3A_theta">theta</code></td>
<td>
<p>vector, matrix, or list of theta values for which probabilities will be computed. 
If <code>theta</code> is not specified, an equal interval range of values from -4 to 4 is used 
with an increment of 0.5. See details below for more information. </p>
</td></tr>
<tr><td><code id="mcm-methods_+3A_dimensions">dimensions</code></td>
<td>
<p>number of modeled dimensions </p>
</td></tr>
<tr><td><code id="mcm-methods_+3A_items">items</code></td>
<td>
<p>numeric vector identifying the items for which probabilities should be computed</p>
</td></tr>
<tr><td><code id="mcm-methods_+3A_information">information</code></td>
<td>
<p>logical value. If <code>TRUE</code> compute item information. In the multidimensional
case, information will be computed in the directions specified by <code>angle</code> or default angles
of 0 - 90 in increments of 10 degrees.</p>
</td></tr>
<tr><td><code id="mcm-methods_+3A_angle">angle</code></td>
<td>
<p>vector or matrix of angles between the dimension 1 axis and the corresponding axes for each 
of the other dimensions for which information will be computed. When there are more than two dimensions 
and <code>angle</code> is a vector, the same set of angles will be used relative to each of the corresponding axes.</p>
</td></tr>
<tr><td><code id="mcm-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> can be specified as a vector, matrix, or list.  For the unidimensional case, <code>theta</code>
should be a vector. If a matrix or list of values is supplied, they will be converted to a single vector
of theta values.  For the multidimensional case, if a vector of values is supplied it will be assumed
that this same set of values should be used for each dimension.  Probabilities will be computed for each
combination of theta values.  Similarly, if a list is supplied, probabilities will be computed for each
combination of theta values.  In instances where probabilities are desired for specific combinations of 
theta values, a j x m matrix should be specified for j ability points and m dimensions where the columns 
are ordered from dimension 1 to m.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.prob-class">irt.prob</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;matrix&quot;, cat = &quot;numeric&quot;</dt><dd><p>This method allows one to specify an n x h matrix
for n items and h equal to [m x 2k + (k-1)] where m is the number of modeled dimensions
and k is equal to the maximum number of response categories (including the 'do not know' 
category) across items.  The first (m x k) columns are for category slope parameters,
the next block of (m x k) columns are for category difficulty parameters, and the 
remaining columns are for the lower asymptote (guessing) parameters.  For any items 
with fewer categories than the maximum, the remaining cells in each block of (m x k) 
columns or the last k columns should be <code>NA</code>.  
</p>

<dl>
<dt>Unidimensional Specification:</dt><dd><p>Say we have one item with four actual response
categories and one item with five response categories.  There will be 17 columns.  
The first six columns are for the category slope parameters.  The first column should 
contain the parameters for the 'do not know' category.  Column six for the four category 
item should be <code>NA</code>.  The next six columns (7-12) are for category difficulty 
parameters.  The first column of this subset of columns (column 7) should contain the 
category difficulties for the 'do not know' category.  Similar to the block of columns 
containing the slopes, the last column in this subset of columns (column 12) for the 
four category item should be <code>NA</code>.  The remaining five columns are for the lower
asymptote (guessing) parameters.  The last column for the four category item would 
be <code>NA</code>. </p>
</dd>
<dt>Multidimensional Specification:</dt><dd><p>In the multidimensional case, the columns for 
the slope and difficulty parameters should be grouped first by dimension and then by 
category.  Using the same example for the two items with two dimensions there will be 
29 columns.  The first five columns for the four category item would include the slope 
parameters associated with the first dimension for the 'do not know' category and each 
of the four actual categories respectively.  Columns 11-12 would be <code>NA</code>.  Columns 
13-17 would include the category difficulties associated with the first dimension (again
the parameters for the 'do not know' category should be in the first column of this 
block of columns) and columns 23-24 would be <code>NA</code>.  The remaining five columns are 
for the lower asymptote (guessing) parameters.  The last column for the four category 
item would be <code>NA</code>. </p>
</dd>
</dl>
</dd>
<dt>x = &quot;data.frame&quot;, cat = &quot;numeric&quot;</dt><dd><p>See the method for x = &quot;matrix&quot; </p>
</dd>
<dt>x = &quot;list&quot;, cat = &quot;numeric&quot;</dt><dd><p>This method is for a list with three elements. The 
first element is an n x (m x k) matrix of category slope values for n items, m 
dimensions, and k equal to the maximum number of response categories across items
(including the 'do not know' category).  The second list element is an n x (m x k) 
matrix of category difficulty parameters and the last element is an n x (k-1) matrix
of lower asymptote (guessing) parameters.  For any list element, for items with fewer 
categories than the maximum, the remaining cells in the rows should be <code>NA</code> (see 
the examples for method x = &quot;matrix&quot; for specification details). </p>
</dd>
<dt>x = &quot;irt.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the mcm items in an object of class <code>"irt.pars"</code>.  If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning will be 
displayed stating that probabilities will be computed for the mcm items only.  If <code>x</code> 
contains parameters for multiple groups, a list of <code>"irt.prob"</code> objects will be 
returned.  The argument <code>dimensions</code> does not need to be included for this method.</p>
</dd>
<dt>x = &quot;sep.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the mcm items in an object of class <code>sep.pars</code>.  If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning will be 
displayed stating that probabilities will be computed for the mcm items only.  The argument 
<code>dimensions</code> does not need to be included for this method.</p>
</dd>
</dl>



<h3>Note</h3>

<p>No multidimensional extension of the multiple-choice model has officially been presented in
the literature; however, this model is consistent with how the 3PL and nominal response model
were extended to the multidimensional context. Additionally, item information is not currently
available for the multiple-choice model even though the arguments are included in the function. 
Information will be available in a later release.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Bolt, D. M. &amp; Johnson, T. J. (in press) 
Applications of a MIRT model to self-report measures: 
Addressing score bias and DIF due to individual differences in response style. 
<em>Applied Psychological Measurement</em>.
</p>
<p>Thissen, D., &amp; Steinberg, L. (1984). 
A response model for multiple choice items.
<em>Psychometrika</em>, <em>49</em>(4), 501-519.
</p>
<p>Thissen, D., &amp; Steinberg, L. (1996)
A response model for multiple choice items.
In W.J. van der Linden &amp; Hambleton, R. K. (Eds.) 
<em>Handbook of Modern Item Response Theory</em>. New York: Springer-Verlag
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+mixed-methods">mixed</a>:</code> compute probabilities for mixed-format items<br />
<code><a href="#topic+plot.irt.prob">plot</a>:</code> plot item characteristic/category curves<br />
<code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a>:</code> classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
## Item parameters from Thissen &amp; Steinberg (1984, p. 510)
## Items R,S,T,U for the whole test
a &lt;- matrix(c(-1.7, -1, 1.1, .3, 1.9, 
  -2.1, -.6, 1.2, 2.3, -.8, 
  -1.3, -.9, -.2, 1.9, .5, 
  -1.9, -.5, 0, -.6, 1.9),4,5,byrow=TRUE)
c &lt;- matrix(c(.3, -2.3, 2.4, -2.5, 2.1, 
  2.1, .05, -3, -.6, 1, 
  -.9, -2.5, -.1, 1.8, 1.6, 
  -.1, -2, .5, .8, .8),4,5,byrow=TRUE)
d &lt;- matrix(c(.25, .25, .25, .25, 
  .2, .2, .4, .2, 
  .2, .2, .4, .2, 
  .25, .25, .25, .25),
  4,4,byrow=TRUE)
pars &lt;- cbind(a,c,d)
x &lt;- mcm(pars, rep(5,4))
plot(x,item.names=paste("Item",c("R","S","T","U")), 
  auto.key=list(space="right"))

## Item parameters from Thissen &amp; Steinberg (1984, p. 511)
## Items W,X,Y,Z for the 
pars &lt;- vector("list",3)
pars[[1]] &lt;- matrix(c(-2.3, -.2, 2, .9, -.3, 
  -.8, .6, -.5, 1.1, -.4, 
  -.5, -.2, 2, -1.2, 0, 
  -1.5, -.7, -.2, .1, 2.3),4,5,byrow=TRUE)
pars[[2]] &lt;- matrix(c(.5, .7, -.5, -1.9, 1.1, 
  1.6, -2.8, 1.5, 0, -.3, 
  -.3, .7, -1, .7, 0, 
  .4, .4, -.5, .5, -.8),4,5,byrow=TRUE)
pars[[3]] &lt;- matrix(c(.2, .4, .2, .2, 
  .2, .2, .4, .2, 
  .2, .4, .2, .2, 
  .2, .2, .2, .4), 4,4,byrow=TRUE)
x &lt;- mcm(pars, rep(5,4))
plot(x,item.names=paste("Item",c("W","X","Y","Z")), 
  auto.key=list(space="right"))


###### Multidimensional Example ######
## Discrimination and category parameters from Bolt &amp; Johnson (in press)
pars &lt;- matrix(c(-1.28, -1.029, -0.537, 0.015, 0.519, 0.969, 1.343,
1.473, -0.585, -0.561, -0.445, -0.741, -0.584, 1.444,
0.29, 0.01, 0.04, 0.34, 0, -0.04, -0.63,
0.01, 0.09, 0.09, 0.28, 0.22, 0.31),1,27)
x &lt;- mcm(pars, cat=7, dimensions=2)
# Plot separated surfaces
plot(x,separate=TRUE,drape=TRUE)
</code></pre>

<hr>
<h2 id='md.mixed'>Multidimensional Mixed-Format Tests</h2><span id='topic+md.mixed'></span>

<h3>Description</h3>

<p>This dataset includes multidimensional 3PL and multidimensional generalized partial
credit model item parameters for two groups modeled with four dimensions.  The item
parameters were estimated based on item responses provided with BMIRT (Yao, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md.mixed</code></pre>


<h3>Format</h3>

<p>A list of length two. There are two matrices in the first list element that correspond
to form.x and form.y tests respectively.  The second list element identifies the 
number of response categories for each item.  All of the items are common items.  There
is no location parameter for the polytomous items.
</p>


<h3>Source</h3>

<p>Yao, L. (2008). 
BMIRT: Bayesian multivariate item response theory [Computer Program]. 
Monterey, CA: CTB/McGraw-Hill.
</p>

<hr>
<h2 id='mixed-methods'>Mixed-Format Response Probabilities</h2><span id='topic+mixed'></span><span id='topic+mixed-methods'></span><span id='topic+mixed+2Cnumeric+2Cnumeric-method'></span><span id='topic+mixed+2Cmatrix+2Cnumeric-method'></span><span id='topic+mixed+2Cdata.frame+2Cnumeric-method'></span><span id='topic+mixed+2Clist+2Cnumeric-method'></span><span id='topic+mixed+2Cirt.pars+2CANY-method'></span><span id='topic+mixed+2Csep.pars+2CANY-method'></span>

<h3>Description</h3>

<p>This function computes the probability of responding in a specific category for one or more 
items for a given set of theta values when the items are from a mixed-format test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed(x, cat, poly.mod, theta, dimensions = 1, items, information = FALSE, angle, ...)

## S4 method for signature 'numeric', 'numeric'
mixed(x, cat, poly.mod, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'matrix', 'numeric'
mixed(x, cat, poly.mod, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'data.frame', 'numeric'
mixed(x, cat, poly.mod, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'list', 'numeric'
mixed(x, cat, poly.mod, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'irt.pars', 'ANY'
mixed(x, cat, poly.mod, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'sep.pars', 'ANY'
mixed(x, cat, poly.mod, theta, dimensions, items, information, angle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixed-methods_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object containing item parameters</p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_cat">cat</code></td>
<td>
<p>vector identifying the number of response categories for each item.  If 
multiple-choice model items are included, <code>cat</code> for these items should equal 
the number of response categories plus one (the additional category is for 
'do not know')</p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_poly.mod">poly.mod</code></td>
<td>
<p>object of class <code><a href="#topic+poly.mod-class">poly.mod</a></code> identifying 
the items associated with each IRT model</p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_theta">theta</code></td>
<td>
<p>vector, matrix, or list of theta values for which probabilities will be computed. 
If <code>theta</code> is not specified, an equal interval range of values from -4 to 4 is used 
with an increment of 0.5. See details below for more information. </p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_dimensions">dimensions</code></td>
<td>
<p>number of modeled dimensions </p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_items">items</code></td>
<td>
<p>numeric vector identifying the items for which probabilities should be computed</p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_information">information</code></td>
<td>
<p>logical value. If <code>TRUE</code> compute item information. In the multidimensional
case, information will be computed in the directions specified by <code>angle</code> or default angles
of 0 - 90 in increments of 10 degrees.</p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_angle">angle</code></td>
<td>
<p>vector or matrix of angles between the dimension 1 axis and the corresponding axes for each 
of the other dimensions for which information will be computed. When there are more than two dimensions 
and <code>angle</code> is a vector, the same set of angles will be used relative to each of the corresponding axes.</p>
</td></tr>
<tr><td><code id="mixed-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. See details below. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The item parameters supplied to this method can be associated with a single IRT model or
multiple models.  When the parameters are tied to only one model, the format of <code>x</code>
(for either unidimensional or multidimensional models) should follow the conventions in 
<code><a href="#topic+drm">drm</a></code> for dichotomous response models (i.e. 1PL, 2PL, 3PL), <code><a href="#topic+gpcm">gpcm</a></code> 
for the partial credit model and generalized partial credit model, <code><a href="#topic+grm">grm</a></code> for 
the graded response model, <code><a href="#topic+mcm">mcm</a></code> for the multiple-choice model, and 
<code><a href="#topic+nrm">nrm</a></code> for the nominal response model.  When the parameters are associated with 
two or more models, the parameters should be combined. See <code><a href="#topic+as.irt.pars">as.irt.pars</a></code> or 
for more details on how the parameters from different models can be combined.  Additional 
arguments for the above models can be passed to this method as well.
</p>
<p><code>theta</code> can be specified as a vector, matrix, or list.  For the unidimensional case, <code>theta</code>
should be a vector. If a matrix or list of values is supplied, they will be converted to a single vector
of theta values.  For the multidimensional case, if a vector of values is supplied it will be assumed
that this same set of values should be used for each dimension.  Probabilities will be computed for each
combination of theta values.  Similarly, if a list is supplied, probabilities will be computed for each
combination of theta values.  In instances where probabilities are desired for specific combinations of 
theta values, a j x m matrix should be specified for j ability points and m dimensions where the columns 
are ordered from dimension 1 to m.
</p>
<p>The <code>mixed</code> function essentially compiles response probabilities computed using the functions
<code>drm</code>, <code>grm</code>, <code>gpcm</code>, <code>nrm</code>, and <code>mcm</code> for the associated models
respectively. All of the arguments specified in any one of these functions can be passed to 
<code>mixed</code> as an additional argument. For example, the argument <code>incorrect</code> can be passed 
to <code>drm</code> and <code>catprob</code> can be passed to <code>grm</code>. In the functions <code>drm</code>, <code>grm</code>, 
and <code>gpcm</code> there is an argument <code>D</code> for the value of a scaling constant. In <code>mixed</code>, 
a single argument <code>D</code> can be passed that will be applied to all applicable models, or arguments 
<code>D.drm</code>, <code>D.grm</code>, and <code>D.gpcm</code> can be specified for each model respectively. If an 
argument is specified for <code>D</code> and, say <code>D.drm</code>, the values for <code>D.grm</code> and <code>D.gpcm</code> 
(if applicable) will be set equal to <code>D</code>. If only <code>D.drm</code> is specified, the values for 
<code>D.grm</code> and <code>D.gpcm</code> (if applicable) will be set to 1.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.prob-class">irt.prob</a></code>
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+plot.irt.prob">plot</a>:</code> plot item characteristic/category curves<br />
<code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a>:</code> classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
# Compute probabilities for three dichotomous (3PL) items and two 
# polytomous (gpcm) items without a location parameter
dichot &lt;- matrix(c(1.2, .8, .9, 2.3, -1.1, -.2, .24, .19, .13),3,3)
poly &lt;- matrix(c(.64, -1.8, -.73, .45, NA, .88, .06, 1.4, 1.9, 2.6),
  2,5,byrow=TRUE)
pars &lt;- rbind(cbind(dichot,matrix(NA,3,2)),poly)
cat &lt;- c(2,2,2,4,5)
pm &lt;- as.poly.mod(5, c("drm","gpcm"), list(1:3,4:5))
x &lt;- mixed(pars, cat, pm) 
plot(x)

# Specify a different scaling constant for the GPCM items in the
# above example
x &lt;- mixed(pars, cat, pm, D.gpcm=1.7) 
plot(x)


# Compute probabilities for three dichotomous (3PL) items, four 
# polytomous items, two gpcm items and two nrm items. Include a 
# location parameter for the gpcm items
a &lt;- matrix(c(
  1.2, rep(NA,4),
  .8, rep(NA,4),
  .9, rep(NA,4),
  .64, rep(NA,4),
  .88, rep(NA,4),
  .905, .522, -.469, -.959, NA, 
  .828, .375, -.357, -.079, -.817),7,5,byrow=TRUE)
b &lt;- matrix(c(
  2.3, rep(NA,4),
  -1.1, rep(NA,4),
  -.2, rep(NA,4),
  -.69, -1.11, -.04, 1.14, NA,
  1.49, -1.43, -.09, .41, 1.11,
  .126, -.206, -.257, .336, NA, 
  .565, .865, -1.186, -1.199, .993),7,5,byrow=TRUE)
c &lt;- c(.14, .19, .26, rep(NA,4))
pars &lt;- list(a,b,c)
cat &lt;- c(2,2,2,4,5,4,5)
pm &lt;- as.poly.mod(7, c("drm","gpcm","nrm"), list(1:3,4:5,6:7))
x &lt;- mixed(pars, cat, pm, location=TRUE)
plot(x)

###### Multidimensional Example ######
# Compute response probabilities for four dichotomous items
# modeled using the M2PL and three polytomous items modeled
# using the multidimensional graded response model. For the 
# later items, cumulative probabilities are computed.
a &lt;- matrix(c(1.66,1.72,.69,.19,.88,1.12,.68,1.21,
     .873, .226, .516, .380, .613, .286 ),7,2,byrow=TRUE)
d &lt;- matrix(c(-.38,NA,NA,NA,NA,
     -.68,NA,NA,NA,NA,
     -.91,NA,NA,NA,NA,
     -1.08,NA,NA,NA,NA,
     2.255, 1.334, -.503, -2.051, -3.082,
     1.917, 1.074, -.497, -1.521, -2.589,
     1.624, .994, -.656, -1.978, NA),7,5,byrow=TRUE)
cat &lt;- c(2,2,2,2,6,6,5)
pars &lt;- cbind(a,d)
pm &lt;- as.poly.mod(7,c("drm","grm"),list(1:4,5:7))
x &lt;- mixed(pars, cat, pm, dimensions=2, catprob=TRUE)
plot(x)
</code></pre>

<hr>
<h2 id='nrm-methods'>Nominal Response Model Probabilities</h2><span id='topic+nrm'></span><span id='topic+nrm-methods'></span><span id='topic+nrm+2Cmatrix+2Cnumeric-method'></span><span id='topic+nrm+2Cdata.frame+2Cnumeric-method'></span><span id='topic+nrm+2Clist+2Cnumeric-method'></span><span id='topic+nrm+2Cirt.pars+2CANY-method'></span><span id='topic+nrm+2Csep.pars+2CANY-method'></span>

<h3>Description</h3>

<p>This function computes the probability of responding in a specific category for one or more 
items for a given set of theta values using the nominal response model or multidimensional
nominal response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrm(x, cat, theta, dimensions = 1, items, information = FALSE, angle, ...)

## S4 method for signature 'matrix', 'numeric'
nrm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'data.frame', 'numeric'
nrm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'list', 'numeric'
nrm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'irt.pars', 'ANY'
nrm(x, cat, theta, dimensions, items, information, angle, ...)

## S4 method for signature 'sep.pars', 'ANY'
nrm(x, cat, theta, dimensions, items, information, angle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrm-methods_+3A_x">x</code></td>
<td>
<p>Object containing item parameters. See below for more details. </p>
</td></tr>
<tr><td><code id="nrm-methods_+3A_cat">cat</code></td>
<td>
<p>vector identifying the number of response categories for each item </p>
</td></tr> 
<tr><td><code id="nrm-methods_+3A_theta">theta</code></td>
<td>
<p>vector, matrix, or list of theta values for which probabilities will be computed. 
If <code>theta</code> is not specified, an equal interval range of values from -4 to 4 is used 
with an increment of 0.5. See details below for more information. </p>
</td></tr>
<tr><td><code id="nrm-methods_+3A_dimensions">dimensions</code></td>
<td>
<p>number of modeled dimensions </p>
</td></tr>
<tr><td><code id="nrm-methods_+3A_items">items</code></td>
<td>
<p>numeric vector identifying the items for which probabilities should be computed</p>
</td></tr>
<tr><td><code id="nrm-methods_+3A_information">information</code></td>
<td>
<p>logical value. If <code>TRUE</code> compute item information. In the multidimensional
case, information will be computed in the directions specified by <code>angle</code> or default angles
of 0 - 90 in increments of 10 degrees.</p>
</td></tr>
<tr><td><code id="nrm-methods_+3A_angle">angle</code></td>
<td>
<p>vector or matrix of angles between the dimension 1 axis and the corresponding axes for each 
of the other dimensions for which information will be computed. When there are more than two dimensions 
and <code>angle</code> is a vector, the same set of angles will be used relative to each of the corresponding axes.</p>
</td></tr>
<tr><td><code id="nrm-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theta</code> can be specified as a vector, matrix, or list.  For the unidimensional case, <code>theta</code>
should be a vector. If a matrix or list of values is supplied, they will be converted to a single vector
of theta values.  For the multidimensional case, if a vector of values is supplied it will be assumed
that this same set of values should be used for each dimension.  Probabilities will be computed for each
combination of theta values.  Similarly, if a list is supplied, probabilities will be computed for each
combination of theta values.  In instances where probabilities are desired for specific combinations of 
theta values, a j x m matrix should be specified for j ability points and m dimensions where the columns 
are ordered from dimension 1 to m.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+irt.prob-class">irt.prob</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;matrix&quot;, cat = &quot;numeric&quot;</dt><dd><p>This method allows one to specify an n x (m x 2k) 
matrix for n items, m dimensions, and k equal to the maximum number of response 
categories across items.  The first (m x k) columns are for category slope parameters
and the remaining columns are for the category difficulty parameters.  For any items 
with fewer categories than the maximum, the remaining cells in each block of (m x k) 
columns should be <code>NA</code>.  
</p>

<dl>
<dt>Unidimensional Specification:</dt><dd><p>Say we have one four category item and one 
five category item, the first four columns of the four response item would include 
the slope parameters. The fifth column for this item would be <code>NA</code>.  The next 
four columns would include the category difficulty values, and the last column would 
be <code>NA</code>. </p>
</dd>
<dt>Multidimensional Specification:</dt><dd><p>In the multidimensional case, the columns for 
the slope and difficulty parameters should be grouped first by dimension and then by 
category.  Using the same example for the two items with two dimensions there will be 
20 columns.  The first four columns for the four category item would include the slope 
parameters associated with the first dimension for each of the four categories 
respectively.  Columns 9-10 would be <code>NA</code>.  Columns 11-14 would include the 
category difficulties associated with the first dimension and columns 19-20 would 
be <code>NA</code>. </p>
</dd>
</dl>

</dd>
<dt>x = &quot;data.frame&quot;, cat = &quot;numeric&quot;</dt><dd><p>See the method for x = &quot;matrix&quot; </p>
</dd>
<dt>x = &quot;list&quot;, cat = &quot;numeric&quot;</dt><dd><p>This method is for a list with two elements. The 
first element is an n x (m x k) matrix of category slope values for n items, m 
dimensions, and k equal to the maximum number of response categories across items.
The second list element is an n x (m x k) matrix of category difficulty parameters. 
For either element, for items with fewer categories than the maximum, the remaining 
cells in the rows should be <code>NA</code> (see the examples for method x = &quot;matrix&quot; for
specification details). </p>
</dd>
<dt>x = &quot;irt.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the nrm items in an object of class <code>"irt.pars"</code>. If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning 
will be displayed stating that probabilities will be computed for the nrm
items only. If <code>x</code> contains parameters for multiple groups, a list of 
<code>"irt.prob"</code> objects will be returned.</p>
</dd>
<dt>x = &quot;sep.pars&quot;, cat = &quot;ANY&quot;</dt><dd><p>This method can be used to compute probabilities 
for the mcm items in an object of class <code>sep.pars</code>. If <code>x</code> contains 
dichotomous items or items associated with another polytomous model, a warning 
will be displayed stating that probabilities will be computed for the nrm
items only.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Bock, R.D. (1972)
Estimating item parameters and latent ability when responses are scored in two or more 
nominal categories.
<em>Psychometrika</em>, <em>37</em>(1), 29-51.
</p>
<p>Bock, R.D. (1996)
The nominal categories model.
In W.J. van der Linden &amp; Hambleton, R. K. (Eds.) 
<em>Handbook of Modern Item Response Theory</em>. New York: Springer-Verlag
</p>
<p>Bolt, D. M. &amp; Johnson, T. J. (in press)
Applications of a MIRT model to self-report measures: 
Addressing score bias and DIF due to individual differences in response style. 
<em>Applied Psychological Measurement</em>.
</p>
<p>Kolen, M. J., &amp; Brennan, R. L. (2004)
<em>Test Equating, Scaling, and Linking.</em>
New York: Springer
</p>
<p>Takane, Y., &amp; De Leeuw, J. (1987)
On the relationship between item response theory and factor analysis of discretized variables. 
<em>Psychometrika</em>, <em>52</em>(3), 393-408.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+mixed-methods">mixed</a>:</code> compute probabilities for mixed-format items<br />
<code><a href="#topic+plot.irt.prob">plot</a>:</code> plot item characteristic/category curves<br />
<code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a>:</code> classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Example ######
## Item parameters from Bock (1972, p. 46,47)
a &lt;- matrix(c(.905, .522, -.469, -.959, NA, 
  .828, .375, -.357, -.079, -.817), 2,5,byrow=TRUE)
c &lt;- matrix(c(.126, -.206, -.257, .336, NA, 
  .565, .865, -1.186, -1.199, .993), 2,5,byrow=TRUE)
pars &lt;- cbind(a,c)
x &lt;- nrm(pars, c(4,5))
plot(x,auto.key=list(space="right"))

###### Multidimensional Example ######
# From Bolt &amp; Johnson (in press)
pars &lt;- matrix(c(-1.28, -1.029, -0.537, 0.015, 0.519, 0.969, 1.343,
1.473, -0.585, -0.561, -0.445, -0.741, -0.584, 1.444,
0.29, 0.01, 0.04, 0.34, 0, -0.04, -0.63), 1,21)
x &lt;- nrm(pars, cat=7, dimensions=2)
# Plot separated surfaces
plot(x,separate=TRUE,drape=TRUE)
</code></pre>

<hr>
<h2 id='plink-methods'>Separate Calibration</h2><span id='topic+plink'></span><span id='topic+plink-methods'></span><span id='topic+plink+2Clist+2Cmatrix-method'></span><span id='topic+plink+2Clist+2Cdata.frame-method'></span><span id='topic+plink+2Clist+2Clist-method'></span><span id='topic+plink+2Cirt.pars+2CANY-method'></span>

<h3>Description</h3>

<p>This function conducts separate calibration of unidimensional or multidimensional
IRT single-format or mixed-format item parameters for multiple groups.  The  
unidimensional methods include the Mean/Mean, Mean/Sigma, Haebara, and Stocking-Lord 
methods.  The multidimensional methods include a least squares approach (Li &amp; Lissitz,
2000; Min, 2003; Reckase &amp; Martineau, 2004) and extensions of the Haebara and 
Stocking-Lord method using a single dilation parameter (Li &amp; Lissitz, 2000), multiple 
dilation parameters (Min, 2003), or an oblique Procrustes approach (Oshima, Davey, &amp; 
Lee, 2000; Reckase, 2009). The methods allow for symmetric and non-symmetric 
optimization and chain-linked rescaling of item and ability parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plink(x, common, rescale, ability, method, weights.t, weights.f, 
  startvals, exclude, score = 1, base.grp = 1, symmetric = FALSE, 
  rescale.com = TRUE, grp.names = NULL, dilation = "oblique", 
  md.center = FALSE, dim.order = NULL, ...)

## S4 method for signature 'list', 'matrix'
plink(x, common, rescale, ability, method, weights.t, weights.f, 
  startvals, exclude, score, base.grp, symmetric, rescale.com, 
  grp.names, dilation, md.center, dim.order, ...)

## S4 method for signature 'list', 'data.frame'
plink(x, common, rescale, ability, method, weights.t, weights.f, 
  startvals, exclude, score, base.grp, symmetric, rescale.com, 
  grp.names, dilation, md.center, dim.order, ...)

## S4 method for signature 'list', 'list'
plink(x, common, rescale, ability, method, weights.t, weights.f, 
  startvals, exclude, score, base.grp, symmetric, rescale.com, 
  grp.names, dilation, md.center, dim.order, ...)

## S4 method for signature 'irt.pars', 'ANY'
plink(x, common, rescale, ability, method, weights.t, weights.f, 
  startvals, exclude, score, base.grp, symmetric, rescale.com, 
  grp.names, dilation, md.center, dim.order, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plink-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+irt.pars-class">irt.pars</a></code> with multiple groups or
a list of <code>irt.pars</code> and/or <code><a href="#topic+sep.pars-class">sep.pars</a></code> objects. </p>
</td></tr>
<tr><td><code id="plink-methods_+3A_common">common</code></td>
<td>
<p>matrix or list of common items. See below for more details. </p>
</td></tr>
<tr><td><code id="plink-methods_+3A_rescale">rescale</code></td>
<td>
<p>if missing (default), the parameters in <code>x</code> will not be 
transformed to the base scale. To transform the parameters use 
<code>"MM","MS","HB","SL","LS"</code> for the Mean/Mean, Mean/Sigma, Haebara, 
Stocking-Lord, and least squares linking constants respectively.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_ability">ability</code></td>
<td>
<p>list of theta values with length equal to the number of groups. 
If supplied, these values will be transformed to the base scale using the
constants identified in <code>rescale</code> or the Haebara constants if <code>rescale</code>
is missing.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_method">method</code></td>
<td>
<p>character vector identifying the linking methods to use. Values can
include <code>"MM","MS","HB","SL","LS"</code> for the Mean/Mean, Mean/Sigma, Haebara, 
Stocking-Lord, and least squares linking constants respectively, or if
missing, constants will be estimated for all methods.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_weights.t">weights.t</code></td>
<td>
<p>list containing information about the theta values and weights
on the <em>To</em> scale for use with the characteristic curve methods. 
See below for more details. </p>
</td></tr>
<tr><td><code id="plink-methods_+3A_weights.f">weights.f</code></td>
<td>
<p>list containing information about the theta values and weights
on the <em>From</em> scale for use with the characteristic curve methods. This
argument will be ignored if <code>symmetric</code>=FALSE. See below for more details. </p>
</td></tr>
<tr><td><code id="plink-methods_+3A_startvals">startvals</code></td>
<td>
<p>vector or list of slope and intercept starting values for the 
characteristic curve methods or character value(s) of &quot;MM&quot;, &quot;MS&quot;, or &quot;LS&quot; to identify 
that values from the Mean/Mean, Mean/Sigma, or least squares method should be used
for the starting values. See below for more details.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_exclude">exclude</code></td>
<td>
<p>character vector or list identifying common items that should be
excluded when estimating the linking constants. See below for more details.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_score">score</code></td>
<td>
<p>if <code>score</code> = 1, score responses for the Stocking-Lord
method with zero for the lowest category and k-1 for the highest, k, category
for each item.  If <code>score</code> = 2, score responses with one for the
lowest category and k for the highest, k, category for each item.  A vector or 
list of scoring weights for each response category can be supplied, but this is 
only recommended for advanced users.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_base.grp">base.grp</code></td>
<td>
<p>integer identifying the group for the base scale</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_symmetric">symmetric</code></td>
<td>
<p>if <code>TRUE</code> use symmetric minimization for the characteristic 
curve methods.  See Kim and Lee (2006) for more information</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_rescale.com">rescale.com</code></td>
<td>
<p>if <code>TRUE</code> rescale the common item parameters using the 
estimated linking constants; otherwise, insert the non-transformed common item
parameters into the set of unique transformed item parameters</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_grp.names">grp.names</code></td>
<td>
<p>character vector of group names </p>
</td></tr>
<tr><td><code id="plink-methods_+3A_dilation">dilation</code></td>
<td>
<p>character value identifying whether an oblique Procrustes approach
(Oshima, Davey, &amp; Lee, 2000; Reckase 2009) <code>"oblique"</code>, an orthogonal Procrustes 
approach with a fixed dilation parameter (Li &amp; Lissitz, 2000) <code>"orth.fd"</code>, or an
orthogonal Procrustes approach with variable dilations (Min, 2003) <code>"orth.vd"</code> 
should be used to estimate the linking constants for the multidimensional methods. Both
orthogonal approaches can be constrained to exclude reflections by using <code>"orth.fdc"</code>
or <code>"orth.vdc"</code>.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_md.center">md.center</code></td>
<td>
<p>if <code>TRUE</code> mean center the slope matrices prior to estimating the 
rotation matrix and dilation constants</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_dim.order">dim.order</code></td>
<td>
<p>matrix for identifying the ordering of factors across groups.  See 
below for details.</p>
</td></tr>
<tr><td><code id="plink-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> contains only two elements, <code>common</code> should be a matrix.  If <code>x</code> 
contains more than two elements, <code>common</code> should be a list.  In any of the <code>common</code> 
matrices the first column identifies the common items for the first group of two adjacent 
list elements in <code>x</code>.  The second column in <code>common</code> identifies the corresponding 
set of common items from the next list element in <code>x</code>. For example, if <code>x</code> 
contains only two list elements, a single set of common items links them together.  If 
item 4 in group one (row 4 in slot <code>pars</code>) is the same as item 6 in group two, the 
first row of <code>common</code> would be <code>(4,6)</code>.
</p>
<p><code>startvals</code> can be a vector or list of starting values for the slope(s) and intercept(s). 
For unidimensional methods, when there are only two groups, this argument should be a vector of 
length of two with the first value for the slope and the second value for the intercept or a
character value equal to &quot;MM&quot; or&quot;MS&quot;. When there are more than two groups a vector of starting 
values or a character value can be supplied (the same numeric values, if a vector is supplied,
will be used for all pairs, or the corresponding MM/MS values for each pair of tests will be 
used) or a list of vectors/character values can be supplied with the number of list elements
equal to the number of groups minus one. For the multidimensional methods, the same general 
structure applies (a vector or character value for a single group or a vector, character value 
or list for multiple groups); however, the length of the vector will vary depending on the 
dilation approach used. If <code>dilation</code> is &quot;obliquw&quot;, the first m*m values in <code>startvals</code>, 
for m dimensions, should correspond to the values in the transformation matrix (starting with 
the value in the upper-left corner, then the next value in the column, ..., then the first value 
in the next column, etc.). The remaining m values should be for the translation vector. If 
<code>dilation</code> is &quot;orth.fd&quot;, the first value will be the slope parameter and the remaining m values 
will be for the translation vector. If <code>dilation</code> is &quot;orth.vd&quot;, the first m values are the 
slopes for each dimension and the remaining m values are for the translation vector. 
</p>
<p><code>weights.t</code> can be a list or a list of lists.  The purpose of this object is to specify
the theta values on the <em>To</em> scale to integrate over in the characteristic curve methods 
as well as any weights associated with the theta values.  See Kim and Lee (2006) or Kolen 
and Brennan (2004) for more information of these weights.  The function <code><a href="#topic+as.weight">as.weight</a></code> 
can be used to facilitate the creation of this object.  If <code>weights.t</code> is missing, the 
default&ndash;in the unidimensional case&ndash;is to use equally spaced theta values ranging from -4 to 4 
with an increment of 0.05 and theta weights equal to one for all theta values. In the
multidimensional case, the default is to use 1000 randomly sampled values from a multivariate
normal distribution with correlations equal to 0.6 for all dimensions.  The theta weights are
equal to the normal distribution weights at these points. 
</p>
<p>To better understand the elements of <code>weights.t</code>, let us assume for a moment that <code>x</code>
has parameters for only two groups and that we are using non-symmetric linking.  In this instance, 
<code>weights.t</code> would be a single list with length two.  The first element should be a vector
of theta values corresponding to points on the <em>To</em> scale.  The second list element should 
be a vector of weights corresponding the theta values.  If <code>x</code> contains multiple 
groups, a single <code>weights.t</code> object can be supplied, and the same set of thetas and weights
will be used for all adjacent groups.  However, a separate list of theta values and theta weights 
for each adjacent group in <code>x</code> can be supplied.
</p>
<p>The specification of <code>weights.f</code> is the same as that for <code>weights.t</code>, although the 
theta values and weights for this object correspond to theta values on the <em>From</em> scale.
This argument is only used when <code>symmetric</code>=TRUE. If <code>weights.f</code> is missing and 
<code>symmetric</code>=TRUE, the same theta values and weights used for <code>weights.t</code> will be
used for <code>weights.f</code>.
</p>
<p>In general, all of the common items identified in <code>x</code> or <code>common</code> will be used
in estimating linking constants; however, there are instances where there is a need to exclude
certain common items (e.g., NRM or MCM items or items exhibiting parameter drift). Instead of
creating a new matrix or list of matrices for <code>common</code>, the <code>exclude</code> argument can
be used. <code>exclude</code> can be specified as a character vector or a list. In the former case,
a vector of model names (i.e., &quot;drm&quot;, &quot;grm&quot;, &quot;gpcm&quot;, &quot;nrm&quot;, &quot;mcm&quot;) would be supplied, indicating
that any common item on any test associated with the given model(s) would be excluded from the
set of items used to estimate the linking constants. If the argument is specified as a list, 
<code>exclude</code> should have as many elements as groups in <code>x</code>. Each list element can include
model names and/or item numbers corresponding to the common items that should be excluded for
the given group. If no items need to be excluded for a given group, the list element should be
NULL or NA. For example, say we have two groups and we would like to exclude the NRM items and
item 23 from the first group, we would specify <code>exclude</code> as <code>exclude &lt;- list(c("nrm",23),NA)</code>.
Notice that the item number corresponding item 23 in group 2 does not need to be specified.
</p>
<p>The argument <code>dim.order</code> is a k x r matrix for k groups and r unique dimensions across
groups. This object identifies the common dimensions across groups. The elements in the 
matrix should correspond to the dimension (i.e., the column in the matrix of slope parameters)
for a given group. For example, say there are four unique dimensions across two groups,
each group only measures three dimensions, and there are only two common dimensions. We might
specify a matrix as follows dim.order &lt;- matrix(c(1:3,NA,NA,1:3),2,4). In words, this means
that dimensions 2 and 3 in the first group correspond to dimensions 1 and 2 in the second
group respectively. If no <code>dim.order</code> is specified, it is assumed that all of the 
dimensions are common, or in instances with different numbers of factors, that the first
m dimensions for each group are common and the remaining r-m dimensions for a given group
are unique.
</p>
<p>For the characteristic curve methods, response probabilities are computed using the functions
<code>drm</code>, <code>grm</code>, <code>gpcm</code>, <code>nrm</code>, and <code>mcm</code> for the associated models
respectively. Various arguments from these functions can be passed to <code>plink</code>. Specifically,
the argument <code>incorrect</code> can be passed to <code>drm</code> and <code>catprob</code> can be passed to
<code>grm</code>. In the functions <code>drm</code>, <code>grm</code>, and <code>gpcm</code> there is an argument <code>D</code>
for the value of a scaling constant. In <code>plink</code>, a single argument <code>D</code> can be passed
that will be applied to all applicable models, or arguments <code>D.drm</code>, <code>D.grm</code>, and 
<code>D.gpcm</code> can be specified for each model respectively. If an argument is specified for <code>D</code>
and, say <code>D.drm</code>, the values for <code>D.grm</code> and <code>D.gpcm</code> (if applicable) will be
set equal to <code>D</code>. If only <code>D.drm</code> is specified, the values for <code>D.grm</code> and 
<code>D.gpcm</code> (if applicable) will be set to 1.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+link-class">link</a></code>. The labels for the linking constants are 
specified in the following manner &quot;group1/group2&quot;, meaning the group1 parameters were transformed 
to the group2 test. The base group is indicated by an asterisk.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;list&quot;, common = &quot;matrix&quot;</dt><dd><p>This method is used when <code>x</code> contains only
two list elements. If either of the list elements is of class <code>irt.pars</code>, they
can include multiple groups. <code>common</code> is the matrix of common items between
the two groups in <code>x</code>.  See details for more information on <code>common</code>.</p>
</dd>
<dt>x = &quot;list&quot;, common = &quot;data.frame&quot;</dt><dd><p>See the method for signature <code>x</code>=&quot;list&quot;, 
<code>common</code>=&quot;matrix&quot;.</p>
</dd>
<dt>x = &quot;list&quot;, common = &quot;list&quot;</dt><dd><p>This method is used when <code>x</code> includes two or
more list elements. When <code>x</code> has length two, <code>common</code> (although a single
matrix) should be a list with length one. If <code>x</code> has more than two list elements
<code>common</code> identifies the common items between adjacent list elements.  If objects
of class <code>irt.pars</code> are included with multiple groups, <code>common</code> should
identify the common items between the first or last group in the <code>irt.pars</code> object,
depending on its location in <code>x</code>, and the adjacent list element(s) in <code>x</code>.
For example, if <code>x</code> has three elements: an <code>irt.pars</code> object with one group,
an <code>irt.pars</code> object with four groups, and a <code>sep.pars</code> object, <code>common</code>
will be a list with length two. The first element in <code>common</code> is a matrix 
identifying the common items between the items in the first <code>irt.pars</code> object
and the first group in the second <code>irt.pars</code> object. The second element in 
<code>common</code> should identify the common items between the fourth group in the 
second <code>irt.pars</code> object and the items in the <code>sep.pars</code> object.
</p>
</dd>
<dt>x = &quot;irt.pars&quot;, common = &quot;ANY&quot;</dt><dd><p>This method is intended for an <code>irt.pars</code>
object with multiple groups.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The translation vector for the multidimensional Stocking-Lord
method may converge to odd values. The least squares method has been
shown to produce more accurate constants than the characteristic curve
methods (in less time); however, if use of a characteristic curve 
approach is desired, it is recommended that the Haebara method be used 
and/or the relative tolerance for the optimization be lowered to 0.001 
using the argument <code>control=list(rel.tol=0.001)</code>.</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Haebara, T. (1980). 
Equating logistic ability scales by a weighted least squares method. 
<em>Japanese Psychological Research</em>, <em>22</em>(3), 144-149.
</p>
<p>Kim, S. &amp; Lee, W.-C. (2006). 
An Extension of Four IRT Linking Methods for Mixed-Format Tests. 
<em>Journal of Educational Measurement</em>, <em>43</em>(1), 53-76.
</p>
<p>Kolen, M. J. &amp; Brennan, R. L. (2004)
<em>Test Equating, Scaling, and Linking</em> (2nd ed.).
New York: Springer
</p>
<p>Li, Y. H., &amp; Lissitz, R. W. (2000). 
An evaluation of the accuracy of multidimensional IRT linking. 
<em>Applied Psychological Measurement</em>, <em>24</em>(2), 115-138.
</p>
<p>Loyd, B. H. &amp; Hoover, H. D. (1980). 
Vertical Equating Using the Rasch Model. 
<em>Journal of Educational Measurement</em>, <em>17</em>(3), 179-193.
</p>
<p>Marco, G. L. (1977). 
Item Characteristic Curve Solutions to Three Intractable Testing Problems.
<em>Journal of Educational Measurement</em>, <em>14</em>(2), 139-160.
</p>
<p>Min, K. -S. (2007). 
Evaluation of linking methods for multidimensional IRT calibrations. 
<em>Asia Pacific Education Review</em>, <em>8</em>(1), 41-55. 
</p>
<p>Oshima, T. C., Davey, T., &amp; Lee, K. (2000). 
Multidimensional linking: Four practical approaches. 
<em>Journal of Educational Measurement</em>, <em>37</em>(4), 357-373.
</p>
<p>Reckase, M. D. (2009).
<em>Multidimensional item response theory</em>
New York, Springer
</p>
<p>Reckase, M. D., &amp; Martineau, J. A. (2004). 
<em>The vertical scaling of science achievement tests</em>.
Research report for the Center for Education and National Research Council.
</p>
<p>Stocking, M. L. &amp; Lord, F. M. (1983). 
Developing a common metric in item response theory. 
<em>Applied Psychological Measurement</em>, <em>7</em>(2), 201-210.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
# Create irt.pars object with two groups (all dichotomous items),
# rescale the item parameters using the Mean/Sigma linking constants,
# and exclude item 27 from the common item set
pm &lt;- as.poly.mod(36)
x &lt;- as.irt.pars(KB04$pars, KB04$common, cat=list(rep(2,36),rep(2,36)), 
  poly.mod=list(pm,pm))
out &lt;- plink(x, rescale="MS", base.grp=2, D=1.7, exclude=list(27,NA))
summary(out, descrip=TRUE)
pars.out &lt;- link.pars(out)


# Create object with six groups (all dichotomous items)
pars &lt;- TK07$pars
common &lt;- TK07$common
cat &lt;- list(rep(2,26),rep(2,34),rep(2,37),rep(2,40),rep(2,41),rep(2,43))
pm1 &lt;- as.poly.mod(26)
pm2 &lt;- as.poly.mod(34)
pm3 &lt;- as.poly.mod(37)
pm4 &lt;- as.poly.mod(40)
pm5 &lt;- as.poly.mod(41)
pm6 &lt;- as.poly.mod(43)
pm &lt;- list(pm1, pm2, pm3, pm4, pm5, pm6)
x &lt;- as.irt.pars(pars, common, cat, pm, 
  grp.names=paste("grade",3:8,sep=""))
out &lt;- plink(x)
summary(out)
constants &lt;- link.con(out) # Extract linking constants

# Create an irt.pars object and a sep.pars object for two groups of
# nominal response model items. Compare non-symmetric and symmetric 
# minimization. Note: This example may take a minute or two to run
## Not run: 
pm &lt;- as.poly.mod(60, "nrm", 1:60)
pars1 &lt;- as.irt.pars(act.nrm$yr97, cat=rep(5,60), poly.mod=pm)
pars2 &lt;- sep.pars(act.nrm$yr98, cat=rep(5,60), poly.mod=pm)
out &lt;- plink(list(pars1, pars2), matrix(1:60,60,2))
out1 &lt;- plink(list(pars1, pars2), matrix(1:60,60,2), symmetric=TRUE)
summary(out, descrip=TRUE)
summary(out1, descrip=TRUE)

## End(Not run)

# Compute linking constants for two groups with multiple-choice model
# item parameters. Rescale theta values and item parameters using
# the Haebara linking constants
# Note: This example may take a minute or two to run
## Not run: 
theta &lt;- rnorm(100) # In practice, estimated theta values would be used
pm &lt;- as.poly.mod(60, "mcm", 1:60)
x &lt;- as.irt.pars(act.mcm, common=matrix(1:60,60,2), cat=list(rep(6,60),
  rep(6,60)), poly.mod=list(pm,pm))
out &lt;- plink(x, ability=list(theta,theta), rescale="HB")
pars.out &lt;- link.pars(out)
ability.out &lt;- link.ability(out)
summary(out, descrip=TRUE)

## End(Not run)

# Compute linking constants for two groups using mixed-format items and 
# a mixed placement of common items. Compare calibrations with the
# inclusion or exclusion of NRM items. This example uses the dgn dataset.
pm1 &lt;- as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group1)
pm2 &lt;- as.poly.mod(55,c("drm","gpcm","nrm"),dgn$items$group2)
x &lt;- as.irt.pars(dgn$pars,dgn$common,dgn$cat,list(pm1,pm2))
# Run with the NRM common items included
out &lt;- plink(x) 
# Run with the NRM common items excluded
out1 &lt;- plink(x,exclude="nrm") 
summary(out)
summary(out1)


# Compute linking constants for six groups using mixed-format items and 
# a mixed placement of common items. This example uses the reading dataset.
# See the information on the dataset for an interpretation of the output.
pm1 &lt;- as.poly.mod(41, c("drm", "gpcm"), reading$items[[1]])
pm2 &lt;- as.poly.mod(70, c("drm", "gpcm"), reading$items[[2]])
pm3 &lt;- as.poly.mod(70, c("drm", "gpcm"), reading$items[[3]])
pm4 &lt;- as.poly.mod(70, c("drm", "gpcm"), reading$items[[4]])
pm5 &lt;- as.poly.mod(72, c("drm", "gpcm"), reading$items[[5]])
pm6 &lt;- as.poly.mod(71, c("drm", "gpcm"), reading$items[[6]])
pm &lt;- list(pm1, pm2, pm3, pm4, pm5, pm6)
x &lt;- as.irt.pars(reading$pars, reading$common, reading$cat, pm, base.grp=4)
out &lt;- plink(x)
summary(out)


###### Multidimensional Examples ######
# Reckase Chapter 9
pm &lt;- as.poly.mod(80, "drm", list(1:80))
x &lt;- as.irt.pars(reckase9$pars, reckase9$common, 
  list(rep(2,80),rep(2,80)), list(pm,pm), dimensions=2)
# Compute constants using the least squares method and 
# the orthongal rotation with variable dilation. 
# Rescale the item parameters using the LS method
out &lt;- plink(x, dilation="orth.vd", rescale="LS")
summary(out, descrip=TRUE)
# Extract the rescaled item parameters
pars.out &lt;- link.pars(out)

# Compute constants using an oblique Procrustes method
# Display output and descriptives
out &lt;- plink(x, dilation="oblique")
summary(out, descrip=TRUE)

# Compute constants using and orthogonal rotation with
# a fixed dilation parameter 
# Rescale the item parameters and ability estimates 
# using the "HB" and "LS" methods.
# Display the optimization iterations
ability &lt;- matrix(rnorm(40),20,2)
out &lt;- plink(x, method=c("HB","LS"), dilation="orth.fd", 
   rescale="HB", ability=list(ability,ability),
   control=list(trace=1,rel.tol=0.001))
summary(out)
# Extract rescaled ability estimates
ability.out &lt;- out$ability


# Compute linking constants for two groups using mixed-format items 
# modeled with the M3PL and MGPCM. Only compute constants using the 
# orth.vd dilation.
pm &lt;- as.poly.mod(60,c("drm","gpcm"), list(c(1:60)[md.mixed$cat==2],
  c(1:60)[md.mixed$cat&gt;2]))
x &lt;- as.irt.pars(md.mixed$pars, matrix(1:60,60,2), 
  list(md.mixed$cat, md.mixed$cat), 
  list(pm, pm), dimensions=4, grp.names=c("Form.X","Form.Y"))
out &lt;- plink(x,dilation="orth.vd")
summary(out, descrip=TRUE)


# Illustration of construct shift and how to specify common dimensions
pm &lt;- as.poly.mod(80, "drm", list(1:80))
pars &lt;- cbind(round(runif(80),2),reckase9$pars[[1]])
x &lt;- as.irt.pars(list(pars,reckase9$pars[[2]]), reckase9$common, 
list(rep(2,80),rep(2,80)), list(pm,pm), dimensions=c(3,2))
dim.order &lt;- matrix(c(1,2,3,NA,1,2),2,3,byrow=TRUE)
out &lt;- plink(x, dilation="oblique", dim.order=dim.order, rescale="LS")
summary(out)
pars.out &lt;- link.pars(out)

</code></pre>

<hr>
<h2 id='plot.irt.prob'>Plot Item Stuff</h2><span id='topic+plot.irt.prob'></span><span id='topic+plot.sep.pars'></span><span id='topic+plot.irt.pars'></span><span id='topic+plot.list'></span>

<h3>Description</h3>

<p>This function plots item response curves/surfaces using the <code>lattice</code> 
package in addition to vector plots, contour plots, and level plots for 
multidimensional items, and comparison plots for examining parameter drift. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for signature 'irt.pars'
## S3 method for class 'irt.pars'
plot(x, y, ..., type, separate, combine, items, item.names, 
    item.nums, panels, drift, groups, grp.names, sep.mod, 
    drift.sd, save.hist)

## S3 method for signature 'irt.prob'
## S3 method for class 'irt.prob'
plot(x, y, ..., type, separate, combine, items, item.names, 
    item.nums, panels, save.hist)

## S3 method for signature 'sep.pars'
## S3 method for class 'sep.pars'
plot(x, y, ..., type, separate, combine, items, item.names, 
    item.nums, panels, save.hist) 

## S3 method for signature 'list'
## S3 method for class 'irt.pars'
plot(x, y, ..., type, separate, combine, items, item.names, 
    item.nums, panels, drift, groups, grp.names, sep.mod, 
    drift.sd, save.hist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.irt.prob_+3A_x">x</code></td>
<td>
<p>object of class <code>irt.prob</code>, <code>irt.pars</code>, or <code>sep.pars</code>.  For the
later two classes, probabilities are computed using the function <code>mixed</code> before
plotting the curves.</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_y">y</code></td>
<td>
<p>this is an argument in the generic plot function, but is not used for these methods</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_type">type</code></td>
<td>
<p>type of plot to produce (for multidimensional models). Values can include
&quot;wireframe&quot;, &quot;contourplot&quot;, &quot;levelplot&quot;, &quot;vectorplot1&quot;, &quot;vectorplot2&quot;, &quot;vectorplot3&quot;. 
The default if <code>type</code> is missing is &quot;wireframe&quot;.  The first three types of plots 
are based on the correspondingly named lattice plots; properties can be controlled 
using arguments associated with the respective methods. See the details below for
more information on multidimensional plots.</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_separate">separate</code></td>
<td>
<p>logical value.  If <code>TRUE</code>, plot the item category curves or 
surfaces for polytomous items in separate panels</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_combine">combine</code></td>
<td>
<p>vector identifying the number of response categories to plot in each
panel.  If <code>NULL</code>, the curves will be grouped by item. <code>combine</code> is 
typically used to plot curves for more than one item in a panel. </p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_items">items</code></td>
<td>
<p>numeric vector identifying the items to plot</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_item.names">item.names</code></td>
<td>
<p>vector of item names for use in labeling the panels </p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_item.nums">item.nums</code></td>
<td>
<p>logical value.  If <code>TRUE</code>, include item numbers on the vector plots. </p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_panels">panels</code></td>
<td>
<p>number of panels to display in the output window. If the number of items 
is greater than <code>panels</code>, the plots will be created on multiple pages.  If 
<code>NULL</code>, all panels will be plotted on a single page.</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_drift">drift</code></td>
<td>
<p>character vector identifying the plots to create to examine item
parameter drift. Acceptable values are &quot;a&quot;, &quot;b&quot;, &quot;c&quot; for the various parameters
respectively, &quot;pars&quot; to compare all of these parameters, &quot;TCC&quot; to compare test
characteristic curves, &quot;ICC&quot; to compare item characteristic curves, or &quot;all&quot; to
produce all of these plots.</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_groups">groups</code></td>
<td>
<p>numeric vector identifying the groups in <code>x</code> that should be included
for comparing parameter drift. The values should correspond to the group number of 
the lowest group of each pair of adjacent groups in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_grp.names">grp.names</code></td>
<td>
<p>character vector of group names to use when creating the drift plots</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_sep.mod">sep.mod</code></td>
<td>
<p>logical value. If <code>TRUE</code> use different markers in the drift plots
to identify parameters related to different item response models</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_drift.sd">drift.sd</code></td>
<td>
<p>numeric value identifying the number of standard deviations to use when
creating the perpendicular confidence region for the drift comparison plots. If 
missing, <code>drift.sd</code> will default to 3.</p>
</td></tr>
<tr><td><code id="plot.irt.prob_+3A_save.hist">save.hist</code></td>
<td>
<p>logical value. If <code>FALSE</code>, the plot history should be deleted
(only applies to Windows); otherwise, any previously saved plots will be retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of the plots, with the exception of the vector plots, are based on the <code>lattice</code> package.
For the unidimensional plots, any arguments associated with the <code>xyplot</code> function can be
included.  For the multidimensional plots, any arguments associated with the <code>wireframe</code>,
<code>contourplot</code>, or <code>levelplot</code> functions (corresponding to the argument specified in 
<code>type</code>) can be passed as well. 
</p>
<p>For the multidimensional plots, vector plots are limited to two dimensions.  The other three
types of plots can be used with multiple dimensions by plotting the results for the first
two dimensions conditional on each combination of theta values for the other dimensions.  The 
function can handle up to ten dimensions; however, the usefulness of the plots will likely
diminish if more than four dimensions are modeled.<br />
</p>
<p>There are three types of vector plots.  The first two types create a set of vectors that
originate at the location of the multidimensional difficulty and characterize the length
of the vectors at the appropriate angles, relative to the axes, based on the multidimensional 
discrimination. Setting <code>type</code> equal to &quot;vectorplot2&quot; will also include the reference
composite based on an eigenvalue decomposition of the slope parameters. The third type of 
vector plot is similar to the first with the key distinction that the lines are drawn from 
the origin to the points of multidimensional difficulty. When there are more than two dimensions,
a panel of vectorplots is created for each pair of dimensions.
</p>


<h3>Note</h3>

<p>When multiple pages are created, the PgUp and PgDn buttons can be used to view the 
plots on different pages on a Windows machine. For other operating systems, it is suggested
that the multipage plot be sent to an external graphics file.</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a>, Adam Wyse (Contributing Author)</p>


<h3>References</h3>

<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irt.prob-class">irt.prob</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
# Compute probabilites for three dichotomous (3PL) items and two polytomous
# (gpcm) items then plot the item characteristic/category curves
dichot &lt;- matrix(c(1.2, .8, .9, 2.3, -1.1, -.2, .24, .19, .13),3,3)
poly &lt;- matrix(c(.64, -1.8, -.73, .45, NA, .88, .06, 1.4, 1.9, 2.6),
  2,5,byrow=TRUE)
pars &lt;- rbind(cbind(dichot,matrix(NA,3,2)),poly)
cat &lt;- c(2,2,2,4,5)
pm &lt;- as.poly.mod(5, c("drm","gpcm"), list(1:3,4:5))
x &lt;- mixed(pars, cat, pm) 
plot(x)

# Compute probabilites for six items using the 3PL and plot all of the item
# characteristic curves on a single panel using the combine argument
a &lt;- c(.71,.96,.36,1.05,1.76,.64)
b &lt;- c(-.16,1.18,2.03,1.09,.82,-1.56)
c &lt;- c(.22,.17,.24,.08,.20,.13)
theta &lt;- seq(-3,3,.2)
pars &lt;- cbind(a,b,c)
x &lt;- drm(pars,theta)
plot(x,combine=6,item.names="Items 1-6",auto.key=list(space="right"))

# Compute probabilties for the nominal response model using the ACT
# mathematics data. Plot the item category curves for a subset of 9 items.
x &lt;- nrm(act.nrm[[1]], rep(5,60))
plot(x, items=c(2,7,12,20,35,41,48,57,60),auto.key=list(space="right"))

# Create irt.pars object with two groups (all dichotomous items)
# rescale the item parameters using the Stocking-Lord linking constants
# Create drift plots 
pm &lt;- as.poly.mod(36)
x &lt;- as.irt.pars(KB04$pars, KB04$common, cat=list(rep(2,36),rep(2,36)), 
  poly.mod=list(pm,pm))
out &lt;- plink(x, rescale="SL", base.grp=2, D=1.7)
plot(out$pars, drift="all", grp.names=c("Form X","Form Y"), 
item.nums=TRUE)

## Not run: 
# Compute linking constants for six groups using mixed-format items 
# Create drift plots with distinct markers for the two response models
pm1 &lt;- as.poly.mod(41, c("drm", "gpcm"), reading$items[[1]])
pm2 &lt;- as.poly.mod(70, c("drm", "gpcm"), reading$items[[2]])
pm3 &lt;- as.poly.mod(70, c("drm", "gpcm"), reading$items[[3]])
pm4 &lt;- as.poly.mod(70, c("drm", "gpcm"), reading$items[[4]])
pm5 &lt;- as.poly.mod(72, c("drm", "gpcm"), reading$items[[5]])
pm6 &lt;- as.poly.mod(71, c("drm", "gpcm"), reading$items[[6]])
pm &lt;- list(pm1, pm2, pm3, pm4, pm5, pm6)
x &lt;- as.irt.pars(reading$pars, reading$common, reading$cat, pm, base.grp=4)
out &lt;- plink(x, rescale="HB")
plot(out$pars, drift=c("a","b"), sep.mod=TRUE)

## End(Not run)

###### Multidimensional Examples ######
# Compute response probabilities for 20 items from the 
# reckase9 data. Probabilites are modeled using the M2PL. 
# Each of the six plot types will be created.
x &lt;- drm(reckase9[[1]][[1]][31:50,],dimensions=2)

# Wireframe plot
plot(x, drape=TRUE, item.names=paste("Item",31:50))
# Contour Plot
plot(x, type="contourplot",labels=FALSE,cuts=20)
# Level Plot
plot(x, type="levelplot",cuts=20)

# Use all the items for the vector plots
x &lt;- drm(reckase9[[1]][[1]],dimensions=2)
# Vector Plot 1
plot(x, type="vectorplot1",item.nums=FALSE)
# Vector Plot 2
plot(x, type="vectorplot2",item.nums=FALSE)
# Vector Plot 3
plot(x, type="vectorplot3",xlim=c(-1.5,1.5),ylim=c(-1.5,1.5))


# Compute response probabilities for a single three-category item using 
# the multidimensional generalized partial credit model for three 
# dimensions. Plot the conditional item category surfaces in a single 
# panel and then the separated item category surfaces in separate panels
pars &lt;- matrix(c(1.1999,0.5997,0.8087,2.1730,-1.4576),1,5)
x &lt;- gpcm(pars,3,dimensions=3,theta=-4:4)

# plot combined item category surfaces. Rotate the plots using the
# screen argument
plot(x, screen=list(z=-30,x=-60))

## Not run: 
# plot separated item category surfaces
x &lt;- gpcm(pars,3,dimensions=3)
plot(x,separate=TRUE,drape=TRUE,panels=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='poly.mod-class'>Class &quot;poly.mod&quot;</h2><span id='topic+poly.mod-class'></span>

<h3>Description</h3>

<p>The formal S4 class for poly.mod.  This class characterizes the models and 
associated items for a set of item parameters.</p>


<h3>Details</h3>

 
<p>The IRT models associated with the codes:
</p>

<dl>
<dt><code>drm</code>:</dt><dd><p>dichotomous response models (includes 1PL, 2PL, and 3PL)</p>
</dd>
<dt><code>gpcm</code>:</dt><dd><p>generalized partial credit model (includes the
partial credit model)</p>
</dd>
<dt><code>grm</code>:</dt><dd><p>graded response model</p>
</dd>
<dt><code>mcm</code>:</dt><dd><p>multiple-choice model</p>
</dd>
<dt><code>nrm</code>:</dt><dd><p>nominal response model</p>
</dd>
</dl>



<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("poly.mod", ...)</code>, but this is 
not encouraged. Use the function <code><a href="#topic+as.poly.mod">as.poly.mod</a></code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>character vector identifying all the models associated with the 
corresponding set of item parameters.  The only acceptable models are 
<code>drm</code>, <code>gpcm</code>, <code>grm</code>, <code>mcm</code>, and <code>nrm</code>.  See below for more 
details.</p>
</dd>
<dt><code>items</code>:</dt><dd><p>list with the same length as <code>model</code>, where each element 
identifies the items(rows) in the corresponding set of item parameters associated 
with the model(s) identified in <code>model</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The names of the list elements for <code>items</code> must correspond to the elements in <code>model</code>. 
For example, if the poly.mod object is <code>pm</code> and the first element in <code>pm@model</code> is 
<code>drm</code>,one should be able to reference the associated items by <code>pm@items$drm</code>. If 
the list elements are unnamed, some functions may not work properly.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+as.poly.mod">as.poly.mod</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-class">sep.pars</a></code>,
<code><a href="#topic+irt.prob-class">irt.prob</a></code>
</p>

<hr>
<h2 id='read.bilog'>Import Parameters from IRT Software</h2><span id='topic+read.bilog'></span><span id='topic+read.parscale'></span><span id='topic+read.multilog'></span><span id='topic+read.testfact'></span><span id='topic+read.icl'></span><span id='topic+read.bmirt'></span><span id='topic+read.erm'></span><span id='topic+read.ltm'></span>

<h3>Description</h3>

<p>This function imports item and/or ability parameters from BILOG-MG 3, PARSCALE 4, 
MULTILOG 7, TESTFACT 4, ICL, BMIRT, and ltm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bilog(file, ability = FALSE, pars.only = TRUE, as.irt.pars = TRUE)

read.parscale(file, ability = FALSE, loc.out = FALSE, pars.only = TRUE, 
  as.irt.pars = TRUE)

read.multilog(file, cat, poly.mod, ability = FALSE, contrast = "dev", 
  drm.3PL = TRUE, loc.out = FALSE, as.irt.pars = TRUE)

read.testfact(file, ability = FALSE, guessing = FALSE, bifactor = FALSE, 
  as.irt.pars = TRUE)

read.icl(file, poly.mod, ability = FALSE, loc.out = FALSE, 
  as.irt.pars = TRUE)

read.bmirt(file, ability = FALSE, sign.adjust = TRUE, loc.out = FALSE, 
  pars.only = TRUE, as.irt.pars = TRUE)

read.erm(x, loc.out = FALSE, as.irt.pars = TRUE)

read.ltm(x, loc.out = FALSE, as.irt.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.bilog_+3A_file">file</code></td>
<td>
<p>filename of file containing the item or ability parameters</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_ability">ability</code></td>
<td>
<p>if <code>TRUE</code>, <code>file</code> contains ability parameters</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_pars.only">pars.only</code></td>
<td>
<p>if <code>TRUE</code>, only the item/ability parameters will be imported 
(i.e., any other information like standard errors will be dropped). </p>
</td></tr>
<tr><td><code id="read.bilog_+3A_loc.out">loc.out</code></td>
<td>
<p>if <code>TRUE</code>, the step/threshold parameters will be reformated to 
be deviations from a location parameter </p>
</td></tr>
<tr><td><code id="read.bilog_+3A_as.irt.pars">as.irt.pars</code></td>
<td>
<p>if <code>TRUE</code>, the parameters will be output as an 
<code><a href="#topic+irt.pars-class">irt.pars</a></code> object (this is only applicable to item
parameters)</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_cat">cat</code></td>
<td>
<p>vector with the number of response categories for each item. For 
multiple-choice model items, <code>cat</code> is the number of response categories 
plus one (the additional category is for 'do not know')</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_poly.mod">poly.mod</code></td>
<td>
<p>a <code><a href="#topic+poly.mod-class">poly.mod</a></code> object.  See the documentation for
the function <code><a href="#topic+as.irt.pars">as.irt.pars</a></code> for more information on creating this 
object.</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_contrast">contrast</code></td>
<td>
<p>an object identifying the type of contrast(s) used to estimate the
various parameters for each item.  See below for more details.</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_drm.3pl">drm.3PL</code></td>
<td>
<p>logical value indicating whether the dichotomous items (if applicable)
were modeled using the three parameter logistic model (3PL)</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_guessing">guessing</code></td>
<td>
<p>logical value indicating whether a guessing parameter was modeled</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_bifactor">bifactor</code></td>
<td>
<p>logical value indicating whether the bifactor model was used to
estimate the item/ability parameters</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_sign.adjust">sign.adjust</code></td>
<td>
<p>logical value indicating whether the difficulty/step parameters 
should be multiplied by -1 to make them consistent with common formulations of 
multidimensional response models</p>
</td></tr>
<tr><td><code id="read.bilog_+3A_x">x</code></td>
<td>
<p>output object from one of the following functions in the <code>eRm</code> package:
<code>LLTM</code>, <code>LPCM</code>, <code>LRSM</code>,<code>PCM</code>, <code>RM</code>, or <code>RSM</code> or one
of the following functions in the <code>ltm</code> package: <code>rasch</code>, <code>ltm</code>, 
<code>tpm</code>, <code>grm</code>, or <code>gpcm</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file extensions for the item parameter and ability files respectively are as follows:
.par and .sco for BILOG-MG, PARSCALE, and MULTILOG, .par and .fsc for TESTFACT, and 
.par and .ss for BMIRT. For <code>ICL</code>, the file extensions are specified by the user, 
and for <code>ltm</code>, the name of the output object is specified by the user.
</p>
<p>When item parameters are estimated in MULTILOG for models other than the 1PL, 2PL, and GRM,
the program estimates (and returns) contrast parameters.  MULTILOG implements three types
of contrasts: deviation, polynomial, and triangle (see Thissen &amp; Steinberg, 1986 for more
information). A single type of contrast can be used for all parameters (a, b, and c) for all
items or different contrasts can be specified for individual parameters and individual items.
If a single type of contrast is used for all parameters for all items, a character value 
can be specified for the <code>contrast</code> argument: &quot;dev&quot;, &quot;poly&quot;, or &quot;tri&quot; for the three
types of contrasts respectively. When different contrasts are used, <code>contrast</code> should
be a list of length nine. The list elements should be ordered as follows &quot;dev.a&quot;,&quot;poly.a&quot;,
&quot;tri.a&quot;,&quot;dev.c&quot;,&quot;poly.c&quot;,&quot;tri.c&quot;,&quot;dev.d&quot;, &quot;poly.d&quot;,&quot;tri.d&quot; where the first three elements 
correspond to the various contrasts for the slope parameters, the next three elements 
correspond to the contrasts for the category parameters, and the last three elements 
correspond to the contrasts for the lower asymptote (guessing parameters). There are two
approaches that can be implemented using this list 1) character vectors with the model
names &quot;drm&quot;, &quot;grm&quot;, &quot;gpcm&quot;, &quot;nrm&quot;, and &quot;mcm&quot; indicating that the given parameters for
all items associated with the given model should be transformed using the specified contrast.
In instances where a model is not included for a given parameter (for any of the contrasts)
the parameters will be transformed using deviation contrasts.  2) numeric vectors 
identifying the contrasts used for given parameters for given items can be specified.  
It is only necessary to include item numbers for the various parameter/contrast combinations 
when deviation contrasts are not used. See below for examples of how to formulate this argument.
</p>


<h3>Value</h3>

<p>Returns a data.frame or an object of class <code><a href="#topic+irt.pars-class">irt.pars</a></code> if 
<code>as.irt.pars</code> = <code>TRUE</code>.
</p>


<h3>Note</h3>

<p>These functions are currently unable to handle output generated when subtests are used.</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

 
<p>Hanson, B. A. (2002). 
IRT command language [Computer Program].
URL <a href="http://www.b-a-h.com/software/irt/icl/">http://www.b-a-h.com/software/irt/icl/</a>
</p>
<p>Mair, P &amp; Hatzinger, R. (2007).
Extended Rasch modeling: The eRm package for the application of IRT models in R.
URL <a href="http://www.jstatsoft.org/v20/i09">http://www.jstatsoft.org/v20/i09</a>
</p>
<p>Muraki, E. &amp; Bock, R. D. (2003). 
PARSCALE 4: IRT item analysis and test scoring for rating scale data [Computer Program].
Chicago, IL: Scientific Software International. URL <a href="http://www.ssicentral.com">http://www.ssicentral.com</a>
</p>
<p>Rizopoulos, D. (2006). 
ltm: An R package for latent variable modeling and item response theory analyses. 
<em>Journal of Statistical Software</em>, <em>17</em>(5), 1-25. 
URL <a href="http://www.jstatsoft.org/v17/i05/">http://www.jstatsoft.org/v17/i05/</a>
</p>
<p>Thissen, D. (2003). 
MULTILOG 7: Multiple, categorical item analysis and test scoring using item response theory [Computer Program].
Chicago, IL: Scientific Software International. URL <a href="http://www.ssicentral.com">http://www.ssicentral.com</a>
</p>
<p>Thissen, D. &amp; Steinberg, L. (1986).
A taxonomy of item response models.
<em>Psychometrika</em>, <em>51</em>(4), 567-577.
</p>
<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>
<p>Wood, R., Wilson, D. T., Muraki, E., Schilling, S. G., Gibbons, R., &amp; Bock, R. D. (2003).
TESTFACT 4: Test scoring, item statistics, and item factor analysis [Computer Program].
Chicago, IL: Scientific Software International. URL <a href="http://www.ssicentral.com">http://www.ssicentral.com</a>
</p>
<p>Yao, L. (2008). 
BMIRT: Bayesian multivariate item response theory [Computer Program]. 
Monterey, CA: CTB/McGraw-Hill.
</p>
<p>Zimowski, M. F., Muraki, E., Mislevy, R. J., &amp; Bock, R. D. (2003). 
BILOG-MG 3: Multiple-group IRT analysis and test maintenance for binary items [Computer Program].
Chicago, IL: Scientific Software International. URL <a href="http://www.ssicentral.com">http://www.ssicentral.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Illustration of how to formulate the contrast argument. Say that we 
# have 20 items where the first 15 are modeled using the 3PL and the 
# last five are modeled using the GPCM.  For the 3PL items, deviation 
# contrasts are commonly used for all of the parameters, whereas with 
# the GPCM items, polynomial contrasts are typically used for the slope 
# parameters and triangle contrasts are used for the category parameters. 
# The contrast argument could be specified as follows

contrast &lt;- vector("list",9)
# Note: the list elements do not need to be named for read.multilog
names(contrast) &lt;- c("dev.a","poly.a","tri.a","dev.c","poly.c","tri.c",
  "dev.d", "poly.d","tri.d") 
contrast$poly.a &lt;- 16:20
contrast$tri.c &lt;- 16:20

# The object could alternatively be formatted as follows
contrast &lt;- vector("list",9)
names(contrast) &lt;- c("dev.a","poly.a","tri.a","dev.c","poly.c","tri.c",
  "dev.d","poly.d","tri.d") 
contrast$dev.a &lt;- 1:15
contrast$poly.a &lt;- 16:20
contrast$dev.c &lt;- 1:15
contrast$tri.c &lt;- 16:20
contrast$dev.d &lt;- 1:15
</code></pre>

<hr>
<h2 id='reading'>Multi-Group Mixed-Format Reading Assessment</h2><span id='topic+reading'></span>

<h3>Description</h3>

<p>This (unidimensional) dataset includes item parameters from a large-scale reading 
assessment.  The parameters were estimated using a combination of the three parameter 
logistic model (3PL) and the generalized partial credit model (GPCM).  There are 
six sets of parameters which are based on tests administered in four grades over 
three years.  In particular, the data include a grade 3 and grade 4 test in year 0, 
a grade 4 and grade 5 test in year 1, and a grade 5 and grade 6 test in year 2. The 
label for the information related to the grade 3 test is grade3.0 where the value 
after the decimal indicates the year.  Similar labels are used for the other grade/year
combinations.  This dataset is used for illustrative purposes to show in a multi-group
scenario how items from different response models can be mixed together and common 
items can be in different positions across groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reading</code></pre>


<h3>Format</h3>

<p>A list of length four.  The first element is a list of length six with item
parameter estimates for each grade/year.  There is no location parameter for the GPCM
items.  The second list element is a list identifying the number of response categories 
for the six grade/year combinations.  The third element specifies which items correspond 
to the different item response models for each grade/year respectively.  The last element 
is a list of common item matrices for each adjacent grade/year group.
</p>


<h3>Source</h3>

<p>Briggs, D. C. &amp; Weeks, J. P. (In Press)
The Impact of Vertical Scaling Decisions on Growth Interpretations.
<em>Educational Measurement: Issues and Practices</em>.
</p>

<hr>
<h2 id='reckase9'>Reckase MIRT Multidimensional Item Parameters</h2><span id='topic+reckase9'></span>

<h3>Description</h3>

<p>This dataset includes multidimensional two parameter logistic model (M2PL) item parameter 
estimates for two dimensions and two groups.  The Form 1 items are from a &quot;new&quot; form and 
the Form 2 items are from an &quot;old&quot; form.  There are 16 common items between the two forms.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reckase9</code></pre>


<h3>Format</h3>

<p>A list of length two.  The first element <code>pars</code> is a list of length two. 
Each of the list elements in <code>pars</code> is a 80 x 3 matrix of item parameters.  Element 
one is for <code>Form 1</code>, and element two is for <code>Form 2</code>.  The first two columns 
in each matrix are for the slope parameters and the third column is for the parameter 
related to item difficulty.  
</p>
<p>The second list element in <code>reckase9</code> is a matrix identifying the common items
between the two sets of parameters in <code>pars</code>.  That is, the first column in
<code>common</code> identifies the rows in <code>pars$form1</code> that are common items.
The second column identifies the corresponding set of common items in <code>pars$form2</code>.
</p>


<h3>Source</h3>

<p>Reckase, M. D. (2009).  Multidimensional item response theory.  New York: Springer.
</p>

<hr>
<h2 id='sep.pars-class'>Class &quot;sep.pars&quot;</h2><span id='topic+sep.pars-class'></span>

<h3>Description</h3>

<p>The formal S4 class for sep.pars. This class stores a set of separated item
parameters and characteristics of these parameters.</p>


<h3>Details</h3>

<p><code>a</code> will be an n x m matrix for n items and m dimensions if there are no nominal response model 
or multiple-choice model items.  Otherwise, if nrm or mcm items are included, <code>a</code> will be an 
n x (k x m) matrix with k equal to the maximum number of response categories across items. If nrm or 
mcm items are included, the discrimination/slope parameters for the dichotomous response models, the 
graded response model, partial credit model and generalized partial credit model (and the multidimensional
extensions of these models) are listed in the first m columns with all other columns filled with <code>NA</code>s.
</p>
<p><code>b</code> is an n x (k x m) matrix of difficulty, threshold, step, or category parameters (depending on 
the corresponding model) for n items and m dimensions with k equal to the maximum number of <code>b</code> 
parameters across all items. For items with <code>b</code> less than k x m, the row is right-filled with <code>NA</code>s.
</p>
<p><code>c</code> will be an n x 1 matrix for n items if there are no multiple-choice model items. Otherwise, 
if mcm items are included, <code>c</code> will be an n x k matrix with k equal to the maximum number of 
response categories across items minus one. If mcm items are included, the lower asymptote parameters 
for the dichotomous response models, are listed in the first column with all other columns filled with 
<code>NA</code>s. The <code>c</code> values for the 1PL, 2PL, M1PL, and M2PL equal zero.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("sep.pars", ...)</code>, but this is 
not encouraged. Use the function <code><a href="#topic+sep.pars">sep.pars</a></code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt><code>a</code>:</dt><dd><p>matrix of discrimination/slope parameters</p>
</dd>
<dt><code>b</code>:</dt><dd><p>matrix of difficulty, threshold, step, and category parameters 
(depending on the associated IRT model)</p>
</dd>
<dt><code>c</code>:</dt><dd><p>matrix of lower asymptote parameters and category proportions for the 
dichotomous response models and multiple-choice model respectively. <code>c</code> is equal to 
<code>NA</code> for each item for all other models.</p>
</dd>
<dt><code>cat</code>:</dt><dd><p>vector identifying the number of categories associated with each item. 
All dichotomous items will have <code>cat</code> values equal to 2. Graded response model and 
partial credit/generalized partial credit model items will have <code>cat</code> values equal 
to the number of step/threshold parameters plus one. Nominal response model items will 
have <code>cat</code> values equal to the number of categories, and multiple-choice model items 
will have <code>cat</code> values equal to the number of categories plus one (the 'do not know' 
category). </p>
</dd>
<dt><code>n</code>:</dt><dd><p>vector identifying the total number of items, the total number of dichotomous 
and polytomous items, and the number of items associated with each polytomous model.</p>
</dd>
<dt><code>mod.lab</code>:</dt><dd><p>character vector of labels for the model(s).</p>
</dd> 
<dt><code>location</code>:</dt><dd><p>logical value. If <code>TRUE</code>, the step and/or threshold parameters in 
slot <code>b</code> for the graded response model and generalized partial credit model include a 
location parameter. </p>
</dd>
<dt><code>dimensions</code>:</dt><dd><p>numeric value identifying the number of modeled dimensions.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>character vector identifying all the models associated with the 
corresponding set of item parameters. The only acceptable models are 
<code>drm</code>, <code>gpcm</code>, <code>grm</code>, <code>mcm</code>, and <code>nrm</code> (see class <code>poly.mod</code> 
for more information).</p>
</dd>
<dt><code>items</code>:</dt><dd><p>list with the same length as <code>model</code>, where each element identifies
the items(rows) in the corresponding set of item parameters associated with the model(s) 
identified in <code>model</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+poly.mod-class">poly.mod</a></code>, directly.<br />
Class <code><a href="#topic+list.poly-class">list.poly</a></code>, by class <code>poly.mod</code>, distance 2.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+sep.pars">sep.pars</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>
</p>

<hr>
<h2 id='sep.pars-methods'>Separate Item Parameters</h2><span id='topic+sep.pars'></span><span id='topic+sep.pars-methods'></span><span id='topic+sep.pars+2Cnumeric-method'></span><span id='topic+sep.pars+2Cdata.frame-method'></span><span id='topic+sep.pars+2Cirt.pars-method'></span><span id='topic+sep.pars+2Cmatrix-method'></span><span id='topic+sep.pars+2Clist-method'></span>

<h3>Description</h3>

<p>This function splits the item parameters in the specified object into
discrimination/slope parameters, difficulty/step/threshold/category 
parameters, and lower asymptote/category probability parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.pars(x, cat, poly.mod, dimensions = 1, location = FALSE, 
  loc.out = FALSE, ...)

## S4 method for signature 'numeric'
sep.pars(x, cat, poly.mod, dimensions, location, loc.out, ...)

## S4 method for signature 'matrix'
sep.pars(x, cat, poly.mod, dimensions, location, loc.out, ...)

## S4 method for signature 'data.frame'
sep.pars(x, cat, poly.mod, dimensions, location, loc.out, ...)

## S4 method for signature 'irt.pars'
sep.pars(x, cat, poly.mod, dimensions, location, loc.out, ...)

## S4 method for signature 'list'
sep.pars(x, cat, poly.mod, dimensions, location, loc.out, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.pars-methods_+3A_x">x</code></td>
<td>
<p>Object containing item parameters. For details on the formatting of parameters 
for specific item response models see the corresponding methods (i.e., 
<code><a href="#topic+drm-methods">drm</a></code>, <code><a href="#topic+gpcm-methods">gpcm</a></code>, 
<code><a href="#topic+grm-methods">grm</a></code>, <code><a href="#topic+mcm-methods">mcm</a></code>, and 
<code><a href="#topic+nrm-methods">nrm</a></code> ). See the <code>Methods</code> section for 
<code><a href="#topic+as.irt.pars">as.irt.pars</a></code> for details on how to format the item parameters when
combining parameters from multiple models. </p>
</td></tr>
<tr><td><code id="sep.pars-methods_+3A_cat">cat</code></td>
<td>
<p>vector identifying the number of response categories for each item.  If 
multiple-choice model items are included, <code>cat</code> for these items should equal 
the number of response categories plus one (the additional category is for 
'do not know') </p>
</td></tr>
<tr><td><code id="sep.pars-methods_+3A_poly.mod">poly.mod</code></td>
<td>
<p>object of class <code><a href="#topic+poly.mod-class">poly.mod</a></code> identifying 
the items associated with each IRT model</p>
</td></tr>
<tr><td><code id="sep.pars-methods_+3A_dimensions">dimensions</code></td>
<td>
<p>number of modeled dimensions </p>
</td></tr>
<tr><td><code id="sep.pars-methods_+3A_location">location</code></td>
<td>
<p>if <code>TRUE</code>, the step parameters are deviations from a location
parameter </p>
</td></tr>
<tr><td><code id="sep.pars-methods_+3A_loc.out">loc.out</code></td>
<td>
<p>if <code>TRUE</code>, the step/threshold parameters will be reformated to 
be deviations from a location parameter</p>
</td></tr>
<tr><td><code id="sep.pars-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+sep.pars-class">sep.pars</a></code>
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Unidimensional Examples ######
# Create object for three dichotomous (1PL) items with difficulties -1, 0, 1
x &lt;- sep.pars(c(-1,0,1))


# Create object for three dichotomous (3PL) items and two polytomous 
# (gpcm) items without a location parameter (the parameters are 
# formatted as a matrix)
dichot &lt;- matrix(c(1.2, .8, .9, 2.3, -1.1, -.2, .24, .19, .13),3,3)
poly &lt;- matrix(c(.64, -1.8, -.73, .45, NA, .88, .06, 1.4, 1.9, 2.6),
  2,5,byrow=TRUE)
pars &lt;- rbind(cbind(dichot,matrix(NA,3,2)),poly)
cat &lt;- c(2,2,2,4,5)
pm &lt;- as.poly.mod(5, c("drm","gpcm"), list(1:3,4:5))
x &lt;- sep.pars(pars, cat, pm)
summary(x)


# Create object for three dichotomous (3PL) items and two polytomous 
# (gpcm) items without a location parameter (the parameters are 
# included in a list)
a &lt;- c(1.2, .8, .9, .64, .88)
b &lt;- matrix(c(
  2.3, rep(NA,3),
  -1.1, rep(NA,3),
  -.2, rep(NA,3),
  -1.8, -.73, .45, NA,
  .06, 1.4, 1.9, 2.6),5,4,byrow=TRUE)
c &lt;- c(1.4, 1.9, 2.6, NA, NA)
pars &lt;- list(a,b,c)
cat &lt;- c(2,2,2,4,5)
pm &lt;- as.poly.mod(5, c("drm","gpcm"), list(1:3,4:5))
x &lt;- sep.pars(pars, cat, pm)
summary(x)


# Create object for three dichotomous (3PL) items, four polytomous 
# items, two gpcm items and two nrm items. Include a location parameter 
# for the gpcm items. Maintain the location parameter in the output.
a &lt;- matrix(c(
  1.2, rep(NA,4),
  .8, rep(NA,4),
  .9, rep(NA,4),
  .64, rep(NA,4),
  .88, rep(NA,4),
  .905, .522, -.469, -.959, NA, 
  .828, .375, -.357, -.079, -.817),7,5,byrow=TRUE)
b &lt;- matrix(c(
  2.3, rep(NA,4),
  -1.1, rep(NA,4),
  -.2, rep(NA,4),
  -.69, -1.11, -.04, 1.14, NA,
  1.49, -1.43, -.09, .41, 1.11,
  .126, -.206, -.257, .336, NA, 
  .565, .865, -1.186, -1.199, .993),7,5,byrow=TRUE)
c &lt;- c(.14, .19, .26, rep(NA,4))
pars &lt;- list(a,b,c)
cat &lt;- c(2,2,2,4,5,4,5)
pm &lt;- as.poly.mod(7, c("drm","gpcm","nrm"), list(1:3,4:5,6:7))
x &lt;- sep.pars(pars, cat, pm, location=TRUE, loc.out=TRUE)
summary(x, descrip=TRUE)


# Create irt.pars object with two groups then run sep.pars
pm &lt;- as.poly.mod(36)
x &lt;- as.irt.pars(KB04$pars, KB04$common, cat=list(rep(2,36),rep(2,36)), 
  list(pm,pm), grp.names=c("form.x","form.y"))
out &lt;- sep.pars(x)
summary(out, descrip=TRUE)


###### Multidimensional Examples ######
# Create object for three dichotomous (M1PL) items for two dimensions 
# with parameters related to item difficulties of -1, 0, 1
x &lt;- sep.pars(c(-1,0,1), dimensions=2)

# Create object for three dichotomous (M3PL) items and two polytomous 
# (MGPCM) items without a location parameter for four dimensions 
# (the parameters are included in a list)
a &lt;- matrix(c(0.5038, 2.1910, 1.1317, 0.2493,
  2.9831, 0.4811, 0.3566, 0.4306,
  0.2397, 0.2663, 1.5588, 0.5295,
  0.2020, 0.2410, 1.2061, 0.5552,
  0.2054, 0.6302, 0.3152, 0.2037),5,4,byrow=TRUE)
b &lt;- matrix(c(0.5240, rep(NA,3),
  -1.8841, rep(NA,3),
  0.2570, rep(NA,3),
  -1.4207, 0.3041, -0.5450, NA,
  -2.1720, 0.0954, 0.6531, 0.9114),5,4,byrow=TRUE)
c &lt;- c(0.1022, 0.3528, 0.2498, NA, NA)
pars &lt;- list(a,b,c)
cat &lt;- c(2,2,2,4,5)
pm &lt;- as.poly.mod(5, c("drm","gpcm"), list(1:3,4:5))
x &lt;- sep.pars(pars, cat, pm, dimensions=4)
summary(x, descrip=TRUE)
</code></pre>

<hr>
<h2 id='summary.irt.pars'>Summarize Item Parameters/plink Output </h2><span id='topic+summary.irt.pars'></span><span id='topic+summary.sep.pars'></span><span id='topic+summary.list'></span><span id='topic+summary.link'></span>

<h3>Description</h3>

<p>This function summarizes the item parameters for a given object.  If the object is
of class <code><a href="#topic+link-class">link</a></code>, the function prints the linking constants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'irt.pars'
summary(object, ..., descrip = FALSE)

## S3 method for class 'sep.pars'
summary(object, ..., descrip = FALSE)

## S3 method for class 'list'
summary(object, ..., descrip = FALSE)

## S3 method for class 'link'
summary(object, ..., descrip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.irt.pars_+3A_object">object</code></td>
<td>
<p>an <code>R</code> object. See details below</p>
</td></tr>
<tr><td><code id="summary.irt.pars_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="summary.irt.pars_+3A_descrip">descrip</code></td>
<td>
<p>if <code>TRUE</code>,print descriptive statistics for the item parameters in 
<code>object</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for objects of class <code>irt.pars</code> summarizes the parameters for a single 
group or multiple groups.  If multiple groups are included in the object, parameters will 
be summarized for each group separately.
</p>
<p>The method for objects of class <code>sep.pars</code> summarizes the parameters for a single
<code>sep.pars</code> object.
</p>
<p>Objects of class <code>list</code> can include any combination of <code>irt.pars</code> or
<code>sep.pars</code> objects.  The parameters will be summarized for each group separately.
</p>
<p>The method for objects of class <code>link</code> prints the linking constants for n-1 groups.
If <code>descrip</code> = <code>TRUE</code>, the method summarizes the parameters for all groups 
separately.  The labels are specified in the following manner &quot;group1/group2&quot;, meaning
the group1 parameters were transformed to the group2 test using the associated constants.
The base group is indicated by an asterisk.
</p>


<h3>Author(s)</h3>

<p> Jonathan P. Weeks <a href="mailto:weeksjp@gmail.com">weeksjp@gmail.com</a> </p>


<h3>References</h3>

<p>Weeks, J. P. (2010) 
<b>plink</b>: An R package for linking mixed-format tests using IRT-based methods. 
<em>Journal of Statistical Software</em>, <b>35(12)</b>, 1&ndash;33. 
URL <a href="http://www.jstatsoft.org/v35/i12/">http://www.jstatsoft.org/v35/i12/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.irt.pars">as.irt.pars</a></code>, <code><a href="#topic+irt.pars-class">irt.pars</a></code>, <code><a href="#topic+sep.pars-methods">sep.pars</a></code>,
<code><a href="#topic+sep.pars-class">sep.pars</a></code>, <code><a href="#topic+link-class">link</a></code>
</p>

<hr>
<h2 id='TK07'>Tong - Kolen (2007)</h2><span id='topic+TK07'></span>

<h3>Description</h3>

<p>This (unidimensional) dataset includes three parameter logistic model (3PL) item parameter 
estimates from simulated dataset based on items from the 1992 Iowa Test of Basic 
Skills vocabulary test.  The data are for six groups (grades 3-8) with varying 
numbers of common items between adjacent grades. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TK07</code></pre>


<h3>Format</h3>

<p>A list of length two.  The first element <code>pars</code> is a list of length six.  Each
of the list elements in <code>pars</code> is a n x 3 matrix of item parameters where n
differs for each grade.  The second list element in <code>TK07</code> is a list of length
five identifying the common items between adjacent groups in <code>pars</code>.  Each list
element in <code>common</code> is a j x 2 matrix for j common items.  For example, there
are 13 common items between grades 3 and 4. The first list element in <code>common</code> 
is for the common items between these grades.  The first column in the matrix show that
items 14-26 in grade 3 are the same as items 1-13 in grade 4.  Similar matrices are 
identified for all other grade pairs.
</p>


<h3>Source</h3>

<p>The parameters were obtained from Dr. Ye Tong at Pearson Educational Measurement
and were used in the following article:
</p>
<p>Tong, Y. &amp; Kolen, M. J. (2007)
Comparisons of methodologies and results in vertical scaling for educational 
achievement tests. <em>Applied Measurement in Education</em>, <em>20</em>(2), 227-253.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
