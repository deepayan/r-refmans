<!DOCTYPE html><html><head><title>Help for package secr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {secr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#secr-package'><p>Spatially Explicit Capture&ndash;Recapture Models</p></a></li>
<li><a href='#addCovariates'>
<p>Add Covariates to Mask or Traps</p></a></li>
<li><a href='#addSightings'><p>Mark-resight Data</p></a></li>
<li><a href='#addTelemetry'><p>Combine Telemetry and Detection Data</p></a></li>
<li><a href='#AIC.secr'><p> Compare SECR Models</p></a></li>
<li><a href='#AICcompatible'><p>Model Compatibility</p></a></li>
<li><a href='#as.data.frame'><p> Coerce capthist to Data Frame</p></a></li>
<li><a href='#as.mask'><p>Coerce traps object to mask</p></a></li>
<li><a href='#as.popn'><p>Coerce ppp object to popn</p></a></li>
<li><a href='#autoini'><p> Initial Parameter Values for SECR</p></a></li>
<li><a href='#binCovariate'><p>Add Binned Covariate</p></a></li>
<li><a href='#BUGS'>
<p>Convert Data To Or From BUGS Format</p></a></li>
<li><a href='#capthist'><p> Spatial Capture History Object</p></a></li>
<li><a href='#capthist.parts'><p> Dissect Spatial Capture History Object</p></a></li>
<li><a href='#chat'><p> Overdispersion of Activity Centres</p></a></li>
<li><a href='#circular'>
<p>Circular Probability</p></a></li>
<li><a href='#clone'>
<p>Replicate Rows</p></a></li>
<li><a href='#closedN'>
<p>Closed population estimates</p></a></li>
<li><a href='#closure.test'>
<p>Closure tests</p></a></li>
<li><a href='#cluster'><p> Detector Clustering</p></a></li>
<li><a href='#coef.secr'><p> Coefficients of secr Object</p></a></li>
<li><a href='#collate'><p> Array of Parameter Estimates</p></a></li>
<li><a href='#confint.secr'><p> Profile Likelihood Confidence Intervals</p></a></li>
<li><a href='#contour'>
<p>Contour Detection Probability</p></a></li>
<li><a href='#covariates'><p> Covariates Attribute</p></a></li>
<li><a href='#CV'><p> Coefficient of Variation</p></a></li>
<li><a href='#D.designdata'><p> Construct Density Design Data</p></a></li>
<li><a href='#deermouse'><p> Deermouse Live-trapping Datasets</p></a></li>
<li><a href='#deleteMaskPoints'><p>Edit Mask Points</p></a></li>
<li><a href='#derived'><p> Derived Parameters of Fitted SECR Model</p></a></li>
<li><a href='#details'><p> Detail Specification for secr.fit</p></a></li>
<li><a href='#detectfn'><p> Detection Functions</p></a></li>
<li><a href='#detector'><p> Detector Type</p></a></li>
<li><a href='#deviance'>
<p>Deviance of fitted secr model and residual degrees of freedom</p></a></li>
<li><a href='#discretize'><p>Rasterize Area Search or Transect Data</p></a></li>
<li><a href='#distancetotrap'><p> Distance To Nearest Detector</p></a></li>
<li><a href='#Dsurface'><p> Density Surfaces</p></a></li>
<li><a href='#ellipse.secr'><p> Confidence Ellipses</p></a></li>
<li><a href='#empirical.varD'>
<p>Empirical Variance of H-T Density Estimate</p>
</p></a></li>
<li><a href='#esa.plot'>
<p>Mask Buffer Diagnostic Plot</p></a></li>
<li><a href='#esa.plot.secr'>
<p>Mask Buffer Diagnostic Plot (internal)</p>
</p></a></li>
<li><a href='#expected.n'>
<p>Expected Number of Individuals</p></a></li>
<li><a href='#extractMoves'><p>Simulated Movements</p></a></li>
<li><a href='#FAQ'><p> Frequently Asked Questions, And Others</p></a></li>
<li><a href='#Fletcher.chat'><p>Estimate overdispersion</p></a></li>
<li><a href='#fx.total'><p>Activity Centres of Detected and</p>
Undetected Animals</a></li>
<li><a href='#fxi'><p> Probability Density of Home Range Centre</p></a></li>
<li><a href='#gridCells'><p>Construct Grid Cells</p></a></li>
<li><a href='#hcov'><p> Hybrid Mixture Model</p></a></li>
<li><a href='#head'><p> First or Last Part of an Object</p></a></li>
<li><a href='#homerange'><p> Home Range Statistics</p></a></li>
<li><a href='#hornedlizard'><p> Flat-tailed Horned Lizard Dataset</p></a></li>
<li><a href='#housemouse'><p> House mouse live trapping data</p></a></li>
<li><a href='#Internal'><p>Internal Functions</p></a></li>
<li><a href='#intervals'><p> Work with Open Population data</p></a></li>
<li><a href='#join'><p> Combine or Split Sessions of capthist Object</p></a></li>
<li><a href='#kfn'><p>Overlap Index</p></a></li>
<li><a href='#list.secr.fit'><p>Fit Multiple SECR Models</p></a></li>
<li><a href='#LLsurface'><p>Plot Likelihood Surface</p></a></li>
<li><a href='#logit'><p> Logit Transformation</p></a></li>
<li><a href='#logmultinom'>
<p>Multinomial Coefficient of SECR Likelihood</p></a></li>
<li><a href='#LR.test'><p> Likelihood Ratio Test</p></a></li>
<li><a href='#make.capthist'><p> Construct capthist Object</p></a></li>
<li><a href='#make.lacework'><p>Construct Lacework Detector Design</p></a></li>
<li><a href='#make.mask'><p> Build Habitat Mask</p></a></li>
<li><a href='#make.systematic'><p> Construct Systematic Detector Design</p></a></li>
<li><a href='#make.traps'><p> Build Detector Array</p></a></li>
<li><a href='#make.tri'><p> Build Detector Array on Triangular or Hexagonal Grid</p></a></li>
<li><a href='#makeStart'>
<p>Initial Parameter Values</p>
</p></a></li>
<li><a href='#mask'><p> Mask Object</p></a></li>
<li><a href='#mask.check'>
<p>Mask Diagnostics</p></a></li>
<li><a href='#modelAverage'><p> Averaging of SECR Models Using Akaike's Information Criterion</p></a></li>
<li><a href='#ms'>
<p>Multi-session Objects</p></a></li>
<li><a href='#newdata'>
<p>Create Default Design Data</p></a></li>
<li><a href='#nontarget'><p> Non-target Data</p></a></li>
<li><a href='#occasionKey'><p>Key to Petal Plot</p></a></li>
<li><a href='#ovenbird'><p> Ovenbird Mist-netting Dataset</p></a></li>
<li><a href='#ovensong'><p> Ovenbird Acoustic Dataset</p></a></li>
<li><a href='#OVpossum'><p>Orongorongo Valley Brushtail Possums</p></a></li>
<li><a href='#Parallel'><p> Multi-core Processing</p></a></li>
<li><a href='#pdot'><p> Net Detection Probability</p></a></li>
<li><a href='#PG'><p>Telemetry Fixes in Polygons</p></a></li>
<li><a href='#plot.capthist'><p> Plot Detection Histories</p></a></li>
<li><a href='#plot.mask'><p> Plot Habitat Mask, Density or Resource Surface</p></a></li>
<li><a href='#plot.popn'><p> Plot Population Object</p></a></li>
<li><a href='#plot.secr'><p> Plot Detection Functions</p></a></li>
<li><a href='#plot.traps'><p> Plot traps Object</p></a></li>
<li><a href='#plotMaskEdge'><p>Outline Around Mask Cells</p></a></li>
<li><a href='#pmixProfileLL'><p>Mixture Model Check</p></a></li>
<li><a href='#pointsInPolygon'><p>Points Inside Polygon</p></a></li>
<li><a href='#polyarea'>
<p>Area of Polygon(s)</p></a></li>
<li><a href='#popn'><p> Population Object</p></a></li>
<li><a href='#possum'><p> Brushtail Possum Trapping Dataset</p></a></li>
<li><a href='#predict.secr'><p> SECR Model Predictions</p></a></li>
<li><a href='#predictDsurface'><p> Predict Density Surface</p></a></li>
<li><a href='#print.capthist'><p> Print Detections</p></a></li>
<li><a href='#print.secr'><p> Print or Summarise secr Object</p></a></li>
<li><a href='#print.traps'><p> Print Detectors</p></a></li>
<li><a href='#randomHabitat'><p>Random Landscape</p></a></li>
<li><a href='#raster'><p>Create a RasterLayer Object from Mask or Dsurface</p></a></li>
<li><a href='#rbind.capthist'><p> Combine capthist Objects</p></a></li>
<li><a href='#rbind.popn'><p> Combine popn Objects</p></a></li>
<li><a href='#rbind.traps'><p> Combine traps Objects</p></a></li>
<li><a href='#read.capthist'><p> Import or export data</p></a></li>
<li><a href='#read.mask'><p> Read Habitat Mask From File</p></a></li>
<li><a href='#read.telemetry'><p> Import Telemetry Fixes</p></a></li>
<li><a href='#read.traps'><p> Read Detector Data From File</p></a></li>
<li><a href='#rectangularMask'><p>Rectangular Mask</p></a></li>
<li><a href='#reduce'><p> Combine Columns</p></a></li>
<li><a href='#reduce.capthist'><p> Combine Occasions Or Detectors</p></a></li>
<li><a href='#region.N'><p>Population Size</p></a></li>
<li><a href='#RMarkInput'><p> Convert Data to RMark Input Format</p></a></li>
<li><a href='#RSE'><p>RSE from Fitted Model</p></a></li>
<li><a href='#Rsurface'><p> Smoothed Resource Surface</p></a></li>
<li><a href='#score.test'><p> Score Test for SECR Models</p></a></li>
<li><a href='#secr-defunct'><p>Defunct Functions in Package <span class="pkg">secr</span></p></a></li>
<li><a href='#secr-deprecated'><p>Deprecated Functions in Package <span class="pkg">secr</span></p></a></li>
<li><a href='#secr.design.MS'><p> Construct Detection Model Design Matrices and Lookups</p></a></li>
<li><a href='#secr.fit'><p> Spatially Explicit Capture&ndash;Recapture</p></a></li>
<li><a href='#secr.test'><p>Goodness-of-Fit Test</p></a></li>
<li><a href='#secrdemo'><p> SECR Models Fitted to Demonstration Data</p></a></li>
<li><a href='#secrRNG'><p> Random Number Seed</p></a></li>
<li><a href='#secrtest'><p> Goodness-of-fit Test Results</p></a></li>
<li><a href='#session'><p> Session Vector</p></a></li>
<li><a href='#setNumThreads'><p>Number of Threads</p></a></li>
<li><a href='#shareFactorLevels'><p>Fix Inconsistent Covariates</p></a></li>
<li><a href='#sighting'><p> Sighting Attributes</p></a></li>
<li><a href='#signal'><p> Signal Fields</p></a></li>
<li><a href='#signalmatrix'>
<p>Reformat Signal Data</p></a></li>
<li><a href='#sim.capthist'><p> Simulate Detection Histories</p></a></li>
<li><a href='#sim.popn'><p> Simulate 2-D Population</p></a></li>
<li><a href='#sim.secr'>
<p>Simulate From Fitted secr Model</p></a></li>
<li><a href='#skink'><p> Skink Pitfall Data</p></a></li>
<li><a href='#smooths'><p> Smooth Terms in SECR Models</p></a></li>
<li><a href='#snip'><p>Slice Transect Into Shorter Sections</p></a></li>
<li><a href='#sort.capthist'>
<p>Sort Rows of capthist or mask Object</p></a></li>
<li><a href='#spacing'><p> Detector or Mask Spacing</p></a></li>
<li><a href='#speed'><p> Speed Tips</p></a></li>
<li><a href='#stoatDNA'><p> Stoat DNA Data</p></a></li>
<li><a href='#strip.legend'><p>Colour Strip Legend</p></a></li>
<li><a href='#subset.capthist'><p> Subset or Split capthist Object</p></a></li>
<li><a href='#subset.mask'><p> Subset, Split or Combine Mask Objects</p></a></li>
<li><a href='#subset.popn'><p> Subset popn Object</p></a></li>
<li><a href='#subset.traps'><p> Subset traps Object</p></a></li>
<li><a href='#suggest.buffer'>
<p>Mask Buffer Width</p></a></li>
<li><a href='#summary.capthist'><p> Summarise Detections</p></a></li>
<li><a href='#summary.mask'><p> Summarise Habitat Mask</p></a></li>
<li><a href='#summary.popn'><p> Summarise Simulated Population</p></a></li>
<li><a href='#summary.traps'><p> Summarise Detector Array</p></a></li>
<li><a href='#timevaryingcov'><p> Time-varying Covariates</p></a></li>
<li><a href='#transformations'><p> Transform Point Array</p></a></li>
<li><a href='#trap.builder'>
<p>Complex Detector Layouts</p></a></li>
<li><a href='#traps'><p> Detector Array</p></a></li>
<li><a href='#traps.info'><p> Detector Attributes</p></a></li>
<li><a href='#Trend'><p> Density Trend</p></a></li>
<li><a href='#trim'>
<p>Drop Unwanted List Components</p></a></li>
<li><a href='#Troubleshooting'><p> Problems in Fitting SECR Models</p></a></li>
<li><a href='#turnover'><p> Specifying a Dynamic Population</p></a></li>
<li><a href='#updateCH'><p>Update Old capthist Format</p></a></li>
<li><a href='#usage'><p> Detector Usage</p></a></li>
<li><a href='#usagePlot'>
<p>Plot usage, detections or sightings.</p></a></li>
<li><a href='#userdist'><p> Non-Euclidean Distances</p></a></li>
<li><a href='#utility'><p>Utility Functions</p></a></li>
<li><a href='#vcov.secr'><p> Variance - Covariance Matrix of SECR Parameters</p></a></li>
<li><a href='#verify'>
<p>Check SECR Data</p></a></li>
<li><a href='#write.captures'><p> Write Data to Text File</p></a></li>
<li><a href='#writeGPS'>
<p>Upload to GPS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatially Explicit Capture-Recapture</td>
</tr>
<tr>
<td>Version:</td>
<td>4.6.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to estimate the density and size of a spatially 
  distributed animal population sampled with an array of passive detectors, 
  such as traps, or by searching polygons or transects. Models incorporating 
  distance-dependent detection are fitted by maximizing the likelihood. 
  Tools are included for data manipulation and model selection.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, graphics, grDevices, MASS, mgcv, nlme, parallel, raster
(&ge; 3.5-15), Rcpp (&ge; 0.12.14), RcppNumerical, RcppParallel (&ge;
5.1.1), sf, stats, stringr, terra (&ge; 1.5-12), tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gdistance, igraph, knitr, readxl, rmarkdown, sp, spatstat (&ge;
3.0-2), spatstat.geom, spatstat.random, spsurvey (&ge; 5.3.0),
testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp, RcppEigen, RcppNumerical, RcppParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>,
<a href="https://github.com/MurrayEfford/secr/">https://github.com/MurrayEfford/secr/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 18:39:25 UTC; murra</td>
</tr>
<tr>
<td>Author:</td>
<td>Murray Efford <a href="https://orcid.org/0000-0001-5231-5184"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Philipp Jund [ctb] ((faster transect search and spacing)),
  David Fletcher [ctb] ((overdispersion))</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Murray Efford &lt;murray.efford@otago.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='secr-package'>Spatially Explicit Capture&ndash;Recapture Models </h2><span id='topic+secr-package'></span><span id='topic+secr'></span>

<h3>Description</h3>

<p>Functions to estimate the density and size of a spatially
distributed animal population sampled with an array of passive
detectors, such as traps, or by searching polygons or transects.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> secr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 4.6.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-01</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GNU General Public License Version 2 or later</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Spatially explicit capture&ndash;recapture is a set of methods for studying
marked animals distributed in space. Data comprise the locations of
detectors (traps, searched areas, etc. described in an object of class
&lsquo;traps&rsquo;), and the detection histories of individually marked
animals. Individual histories are stored in an object of class
&lsquo;capthist&rsquo; that includes the relevant &lsquo;traps&rsquo; object.
</p>
<p>Models for population density (animals per hectare) and detection are
defined in <span class="pkg">secr</span> using symbolic formula notation. Density models
may include spatial or temporal trend. Possible predictors for detection
probability include both pre-defined variables (t, b, etc.)
corresponding to &lsquo;time&rsquo;, &lsquo;behaviour&rsquo; and other effects), and
user-defined covariates of several kinds. Habitat is distinguished from
nonhabitat with an object of class &lsquo;mask&rsquo;.
</p>
<p>Models are fitted in <span class="pkg">secr</span> by maximizing either the full likelihood
or the likelihood conditional on the number of individuals observed
(<code class="reqn">n</code>). Conditional likelihood models are limited to homogeneous
Poisson density, but allow continuous individual covariates for
detection. A model fitted with <code><a href="#topic+secr.fit">secr.fit</a></code> is an object
of class <code>secr</code>. Generic methods (plot, print, summary, etc.) are
provided for each object class.
</p>
<p>A link at the bottom of each help page takes you to the
help index. Several vignettes complement the help pages:
</p>

<table>
<tr>
 <td style="text-align: left;">
General interest </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-overview.pdf">secr-overview.pdf</a> </td><td style="text-align: left;"> general introduction </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf">secr-datainput.pdf</a> </td><td style="text-align: left;"> data formats and input functions </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-version4.pdf">secr-version4.pdf</a> </td><td style="text-align: left;"> changes in secr 4.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-manual.pdf">secr-manual.pdf</a> </td><td style="text-align: left;"> consolidated help pages </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-tutorial.pdf">secr-tutorial.pdf</a> </td><td style="text-align: left;"> introductory tutorial </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-habitatmasks.pdf">secr-habitatmasks.pdf</a> </td><td style="text-align: left;"> buffers and habitat masks </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-spatialdata.pdf">secr-spatialdata.pdf</a> </td><td style="text-align: left;"> using spatial data </td>
</tr>
<tr>
 <td style="text-align: left;">   
  <a href="https://www.otago.ac.nz/density/pdfs/secr-models.pdf">secr-models.pdf</a> </td><td style="text-align: left;"> linear models in <span class="pkg">secr</span> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-troubleshooting.pdf">secr-troubleshooting.pdf</a>  </td><td style="text-align: left;"> problems with secr.fit, including speed issues </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
More specialised topics </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-densitysurfaces.pdf">secr-densitysurfaces.pdf</a> </td><td style="text-align: left;"> modelling density surfaces </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-finitemixtures.pdf">secr-finitemixtures.pdf</a> </td><td style="text-align: left;"> mixture models for individual heterogeneity </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-markresight.pdf">secr-markresight.pdf</a> </td><td style="text-align: left;"> mark-resight data and models </td>
</tr>
<tr>
 <td style="text-align: left;">
    <a href="https://www.otago.ac.nz/density/pdfs/secr-multisession.pdf">secr-multisession.pdf</a> </td><td style="text-align: left;"> multi-session capthist objects and models </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-noneuclidean.pdf">secr-noneuclidean.pdf</a> </td><td style="text-align: left;"> non-Euclidean distances </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-parameterisations.pdf">secr-parameterisations.pdf</a> </td><td style="text-align: left;"> alternative parameterisations sigmak, a0 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-polygondetectors.pdf">secr-polygondetectors.pdf</a> </td><td style="text-align: left;"> using polygon and transect detector types </td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-sound.pdf">secr-sound.pdf</a> </td><td style="text-align: left;"> analysing data from microphone arrays</td>
</tr>
<tr>
 <td style="text-align: left;">
  <a href="https://www.otago.ac.nz/density/pdfs/secr-varyingeffort.pdf">secr-varyingeffort.pdf</a> </td><td style="text-align: left;"> variable effort in SECR models</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The datasets <code><a href="#topic+captdata">captdata</a></code> and <code><a href="#topic+ovenbird">ovenbird</a></code> include examples of fitted
models. For models fitted to other datasets see <a href="https://www.otago.ac.nz/density/pdfs/secr-version4.pdf">secr-version4.pdf</a> Appendix 2.
</p>
<p>Add-on packages extend the capability of <span class="pkg">secr</span> and are
documented separately. 
<span class="pkg">secrlinear</span> enables the estimation of linear
density (e.g., animals per km) for populations in linear habitats such
as stream networks
(<a href="https://cran.r-project.org/package=secrlinear/vignettes/secrlinear-vignette.pdf">secrlinear-vignette.pdf</a>). 
<span class="pkg">secrdesign</span>
enables the assessment of alternative study designs by Monte Carlo
simulation; scenarios may differ in detector (trap) layout, sampling
intensity, and other characteristics
(<a href="https://www.otago.ac.nz/density/pdfs/secrdesign-vignette.pdf">secrdesign-vignette.pdf</a>).
<span class="pkg">ipsecr</span> fits some awkward models (e.g., for single-catch traps) by simulation and inverse prediction 
(<a href="https://CRAN.R-project.org/package=ipsecr/vignettes/ipsecr-vignette.pdf">ipsecr-vignette.pdf</a>).
<span class="pkg">openCR</span> fits open population models, both non-spatial and spatial
(<a href="https://CRAN.R-project.org/package=openCR/vignettes/openCR-vignette.pdf">openCR-vignette.pdf</a>).
</p>
<p>The analyses in <span class="pkg">secr</span> extend those available in the software
Density (see
<a href="https://www.otago.ac.nz/density/">www.otago.ac.nz/density/</a>
for the most recent version of Density).  Help is available on the
&lsquo;DENSITY | secr&rsquo; forum at
<a href="http://www.phidot.org/forum/">www.phidot.org</a> and
the Google group <a href="https://groups.google.com/forum/#!forum/secrgroup">secrgroup</a>. Feedback
on the software is also welcome, including suggestions for additional
documentation or new features consistent with the overall design.
</p>


<h3>Author(s)</h3>

<p> Murray Efford <a href="mailto:murray.efford@otago.ac.nz">murray.efford@otago.ac.nz</a> </p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Borchers, D. L. and Fewster, R. M. (2016)  Spatial capture&ndash;recapture models.  
<em>Statistical Science</em> <b>31</b>, 219&ndash;232.
</p>
<p>Efford, M. G. (2004) Density estimation in live-trapping studies.
<em>Oikos</em> <b>106</b>, 598&ndash;610.
</p>
<p>Efford, M. G. (2011) Estimation of population density by spatially
explicit capture&ndash;recapture with area searches. <em>Ecology</em>
<b>92</b>, 2202&ndash;2207.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>
<p>Efford, M. G., Borchers D. L. and Mowat, G. (2013) Varying effort in
capture&ndash;recapture studies. <em>Methods in Ecology and Evolution</em>
<b>4</b>, 629&ndash;636.
</p>
<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009) Population
density estimated from locations of individuals on a passive detector
array. <em>Ecology</em> <b>90</b>, 2676&ndash;2682.
</p>
<p>Efford, M. G., Dawson, D. K. and Robbins C. S. (2004) DENSITY: software
for analysing capture-recapture data from passive detector arrays.
<em>Animal Biodiversity and Conservation</em> <b>27</b>,
217&ndash;228.
</p>
<p>Efford, M. G. and Fewster, R. M. (2013) Estimating population
size by spatially explicit capture&ndash;recapture. <em>Oikos</em>
<b>122</b>, 918&ndash;928.
</p>
<p>Efford, M. G. and Hunter, C. M. (2017) Spatial capture&ndash;mark&ndash;resight
estimation of animal population density. <em>Biometrics</em> <b>74</b>, 411&ndash;420.
</p>
<p>Efford, M. G. and Mowat, G. (2014) Compensatory heterogeneity in
capture&ndash;recapture data.<em>Ecology</em> <b>95</b>, 1341&ndash;1348.
</p>
<p>Royle, J. A., Chandler, R. B., Sollmann, R. and Gardner, B. (2014)
<em>Spatial capture&ndash;recapture.</em> Academic Press.
</p>
<p>Royle, J. A. and Gardner, B. (2011) Hierarchical spatial
capture&ndash;recapture models for estimating density from trapping
arrays. In: A.F. O'Connell, J.D. Nichols and K.U. Karanth (eds)
<em>Camera Traps in Animal Ecology: Methods and Analyses</em>. Springer,
Tokyo.  Pp. 163&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.capthist">read.capthist</a></code>,
<code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+traps">traps</a></code>,
<code><a href="#topic+capthist">capthist</a></code>,
<code><a href="#topic+mask">mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## generate some data &amp; plot
detectors  &lt;- make.grid (nx = 10, ny = 10, spacing = 20,
    detector = "multi")
plot(detectors, label = TRUE, border = 0, gridspace = 20)
detections &lt;- sim.capthist (detectors, noccasions = 5,
    popn = list(D = 5, buffer = 100),
    detectpar = list(g0 = 0.2, sigma = 25))
session(detections) &lt;- "Simulated data"
plot(detections, border = 20, tracks = TRUE, varycol = TRUE)

## generate habitat mask
mask &lt;- make.mask (detectors, buffer = 100, nx = 48)

## fit model and display results
secr.model &lt;- secr.fit (detections, model = g0~b, mask = mask)
secr.model


## End(Not run)

</code></pre>

<hr>
<h2 id='addCovariates'>
Add Covariates to Mask or Traps
</h2><span id='topic+addCovariates'></span>

<h3>Description</h3>

<p>Tools to construct spatial covariates for existing mask or traps objects
from a spatial data source.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
addCovariates(object, spatialdata, columns = NULL, strict = FALSE, replace = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCovariates_+3A_object">object</code></td>
<td>
<p>mask, traps or popn object</p>
</td></tr>
<tr><td><code id="addCovariates_+3A_spatialdata">spatialdata</code></td>
<td>
<p>spatial data source (see Details)</p>
</td></tr>
<tr><td><code id="addCovariates_+3A_columns">columns</code></td>
<td>
<p>character vector naming columns to include (all by default)</p>
</td></tr>
<tr><td><code id="addCovariates_+3A_strict">strict</code></td>
<td>
<p>logical; if TRUE a check is performed for points in <code>object</code> that
lie outside <code>spatialdata</code> (mask data sources only)</p>
</td></tr>
<tr><td><code id="addCovariates_+3A_replace">replace</code></td>
<td>
<p>logical; if TRUE then covariates with duplicate names are replaced; otherwise a new column is added</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal is to obtain the value(s) of one or more spatial covariates
for each point (i.e. row) in <code>object</code>. The procedure depends on
the data source <code>spatialdata</code>, which may be either a spatial
coverage (raster or polygon) or an object with covariate values at
points (another mask or traps object). In the first case, an
overlay operation is performed to find the pixel or
polygon matching each point. In the second case, a search is conducted
for the closest point in <code>spatialdata</code>.
</p>
<p>If <code>spatialdata</code> is a character value then it is interpreted as
the name of a polygon shape file (excluding &lsquo;.shp&rsquo;).
</p>
<p>If <code>spatialdata</code> is a SpatialPolygonsDataFrame, 
SpatialGridDataFrame or 'sf' object from <span class="pkg">sf</span> then it will be used 
in an overlay operation as described. 
</p>
<p>If package <span class="pkg">terra</span> has been installed then <code>spatialdata</code> may also be a RasterLayer from package <span class="pkg">raster</span> or SpatRaster from <span class="pkg">terra</span>. If provided <code>counts</code> should be a single name that will be used for the values (otherwise 'raster' will be used).
</p>
<p>If <code>spatialdata</code> is a <code>mask</code> or <code>traps</code> object then it
is searched for the closest point to each point in <code>object</code>, and
covariates are drawn from the corresponding rows in
<code>covariates(spatialdata)</code>. By default (<code>strict = FALSE</code>),
values are returned even when the points lie outside any cell of the mask.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>object</code> with new or augmented
<code>covariates</code> attribute. Column names and types are derived from the input.
</p>


<h3>Warning</h3>

<p>Use of a SpatialGridDataFrame for <code>spatialdata</code> is untested.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+read.mask">read.mask</a></code>, <code><a href="#topic+read.traps">read.traps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## In the Lake Station skink study (see ?skink), habitat covariates were
## measured only at trap sites. Here we extrapolate to a mask, taking
## values for each mask point from the nearest trap.

LSmask &lt;- make.mask(LStraps, buffer = 30, type = "trapbuffer")
tempmask &lt;- addCovariates(LSmask, LStraps)
## show first few lines
head(covariates(tempmask))

</code></pre>

<hr>
<h2 id='addSightings'>Mark-resight Data</h2><span id='topic+addSightings'></span>

<h3>Description</h3>

<p>Add sighting data on unmarked individuals and/or unidentified marked
individuals to an existing capthist object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
addSightings(capthist, unmarked = NULL, nonID = NULL, uncertain = NULL, verify = TRUE,
    ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSightings_+3A_capthist">capthist</code></td>
<td>
<p>secr capthist object</p>
</td></tr>
<tr><td><code id="addSightings_+3A_unmarked">unmarked</code></td>
<td>
<p>matrix or list of matrices of sightings of unmarked animals, Tu, or file name (see Details)</p>
</td></tr>
<tr><td><code id="addSightings_+3A_nonid">nonID</code></td>
<td>
<p>matrix or list of matrices of unidentified sightings of marked animals, Tm, or file name (see Details)</p>
</td></tr>
<tr><td><code id="addSightings_+3A_uncertain">uncertain</code></td>
<td>
<p>matrix or list of matrices of uncertain sightings, Tn, or file name (see Details)</p>
</td></tr>
<tr><td><code id="addSightings_+3A_verify">verify</code></td>
<td>
<p> logical; if TRUE then the resulting capthist object is
checked with <code><a href="#topic+verify">verify</a></code></p>
</td></tr>
<tr><td><code id="addSightings_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="utils.html#topic+read.table">read.table</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The capthist object for mark-resight analysis comprises distinct marking and sighting occasions, defined in the markocc attribute of <code>traps(capthist)</code>. Add this attribute to <code>traps(capthist)</code> with <code><a href="#topic+markocc">markocc</a></code> before using 'addSightings'. See also <code><a href="#topic+read.traps">read.traps</a></code> and <code><a href="#topic+read.capthist">read.capthist</a></code>.
</p>
<p>Mark-resight data may be binary (detector type &lsquo;proximity&rsquo;) or counts (detector types &lsquo;count&rsquo;, 'polygon' or 'transect'). The detector type is an attribute of <code>traps(capthist)</code>. Values in <code>unmarked</code> and <code>nonID</code> should be whole numbers, and may be greater than 1 even for binary proximity detectors because multiple animals may be detected simultaneously at one place.
</p>
<p>Arguments <code>unmarked</code>, <code>nonID</code>, <code>uncertain</code> provide data for attributes
&lsquo;Tu&rsquo;, &lsquo;Tm&rsquo;, &lsquo;Tn&rsquo; respectively. They may take several forms
</p>

<ul>
<li><p> a single integer, the sum of all counts*
</p>
</li>
<li><p> a matrix of the count on each occasion at each detector (dimensions K x S, where K is the number of detectors and S is the total number of occasions). Columns corresponding to marking occasions should be all-zero.
</p>
</li>
<li><p> for multi-session data, a list with components as above
</p>
</li>
<li><p> a character value with the name of a text file containing the data; the file will be read with <code><a href="utils.html#topic+read.table">read.table</a></code>. The ... argument allows some control over how the file is read. The data format comprises at least S+1 columns. The first is a session identifier used to split the file when the data span multiple sessions; it should be constant for a single-session capthist. The remaining S columns contain the counts for occasions 1:S, one row per detector. Further columns may be present; they are ignored at present.    
</p>
</li></ul>

<p>* although this is convenient, the full matrix of counts provides more flexibility (e.g., when you wish to subset by occasion), and enables modelling of variation across detectors and occasions.
</p>


<h3>Value</h3>

<p>A capthist object with the same structure as the input, but with new sighting-related attributes Tu (sightings of unmarked animals) and/or Tm (unidentified sightings of marked animals). Input values, including NULL, overwrite existing values.
</p>


<h3>Warning</h3>

<p>** Mark-resight data formats and models are experimental and subject to change **</p>


<h3>See Also</h3>

<p><code><a href="#topic+markocc">markocc</a></code>, 
<code><a href="#topic+read.capthist">read.capthist</a></code>, 
<code><a href="#topic+read.traps">read.traps</a></code>, 
<code><a href="#topic+sim.resight">sim.resight</a></code>,
<code><a href="#topic+Tm">Tm</a></code>,
<code><a href="#topic+Tu">Tu</a></code>,
<code><a href="#topic+Tn">Tn</a></code>,
<a href="https://www.otago.ac.nz/density/pdfs/secr-markresight.pdf">secr-markresight.pdf</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## construct capthist object MRCH from text files provided in 
## 'extdata' folder, assigning attribute 'markocc' and add unmarked
## and marked sightings from respective textfiles

datadir &lt;- system.file("extdata", package = "secr")
captfile &lt;- paste0(datadir, '/MRCHcapt.txt')
trapfile &lt;- paste0(datadir, '/MRCHtrap.txt')
Tufile &lt;- paste0(datadir, '/Tu.txt')
Tmfile &lt;- paste0(datadir, '/Tm.txt')

MRCH &lt;- read.capthist(captfile, trapfile, detector = c("multi", 
    rep("proximity",4)), markocc = c(1,0,0,0,0))
MRCH1 &lt;- addSightings(MRCH, Tufile, Tmfile)

## alternatively (ignoring marked, not ID sightings)

MRCH &lt;- read.capthist(captfile, trapfile, detector = c("multi", 
    rep("proximity",4)), markocc = c(1,0,0,0,0))
Tu &lt;- read.table(Tufile)[,-1]  # drop session column
MRCH2 &lt;- addSightings(MRCH, unmarked = Tu)
summary(MRCH2)

</code></pre>

<hr>
<h2 id='addTelemetry'>Combine Telemetry and Detection Data</h2><span id='topic+addTelemetry'></span><span id='topic+xy2CH'></span><span id='topic+telemetrytype'></span><span id='topic+telemetrytype+3C-'></span>

<h3>Description</h3>

<p>Animal locations determined by radiotelemetry can be used to augment
capture&ndash;recapture data.  The procedure in <span class="pkg">secr</span> is first to form a
capthist object containing the telemetry data and then to combine this
with true capture&ndash;recapture data (e.g. detections from hair-snag DNA)
in another capthist object.  <code>secr.fit</code> automatically detects the
telemetry data in the new object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
addTelemetry (detectionCH, telemetryCH, type = c('concurrent','dependent','independent'), 
   collapsetelemetry = TRUE, verify = TRUE) 

xy2CH (CH, inflation = 1e-08)

telemetrytype (object) &lt;- value

telemetrytype (object, ...)       

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addTelemetry_+3A_detectionch">detectionCH</code></td>
<td>
<p>single-session capthist object, detector type &lsquo;single&rsquo;, &lsquo;multi&rsquo;, &lsquo;proximity&rsquo; or &lsquo;count&rsquo;</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_telemetrych">telemetryCH</code></td>
<td>
<p>single-session capthist object, detector type &lsquo;telemetryonly&rsquo;</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_type">type</code></td>
<td>
<p>character (see Details)</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_collapsetelemetry">collapsetelemetry</code></td>
<td>
<p>logical; if TRUE then telemetry occasions are collapsed to one</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_verify">verify</code></td>
<td>
<p>logical; if TRUE then <code><a href="#topic+verify.capthist">verify.capthist</a></code> is called on the output</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_ch">CH</code></td>
<td>
<p>capthist object with telemetryxy attribute</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_inflation">inflation</code></td>
<td>
<p>numeric tolerance for polygon</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_object">object</code></td>
<td>
<p>secr traps object</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_value">value</code></td>
<td>
<p>character telemetry type replacement value</p>
</td></tr>
<tr><td><code id="addTelemetry_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that a number of animals have been radiotagged, and their telemetry data
(xy-coordinates) have been input to <code>telemetryCH</code>, perhaps using
<code><a href="#topic+read.capthist">read.capthist</a></code> with <code>detector = "telemetryonly"</code> and <code>fmt =
  "XY"</code>, or with <code><a href="#topic+read.telemetry">read.telemetry</a></code>.
</p>
<p>A new capthist object is built comprising all the detection
histories in <code>detectionCH</code>, plus empty (all-zero) histories for
every telemetered animal not in <code>detectionCH</code>.  Telemetry is associated with new sampling occasions and a new detector (nominally at the same point as the first in <code>detectionCH</code>).  The number of telemetry fixes of each animal is recorded in the relevant cell of the new capthist object (CH[i, s, K+1] for animal i and occasion s if there were K detectors in detectionCH).
</p>
<p>The new sampling occasion(s) are assigned the detector type &lsquo;telemetry&rsquo; in the traps attribute of the output capthist object, and the traps attribute <code>telemetrytype</code> is set to the value provided.  The telemetry type may be &ldquo;independent&rdquo; (no matching of individuals in captured and telemetered samples), &ldquo;dependent&rdquo; (telemetered animals are a subset of captured animals) or &ldquo;concurrent&rdquo; (histories may be capture-only, telemetry-only or both capture and telemetry).
</p>
<p>The telemetry locations are carried over from telemetryCH as attribute &lsquo;xylist&rsquo; (each
component of xylist holds the coordinates of one animal; use
<code><a href="#topic+telemetryxy">telemetryxy</a></code> to extract).
</p>
<p>The default behaviour of 'addTelemetry' is to automatically collapse all telemetry occasions into one.  This is computationally more efficient than the alternative, but closes off some possible models.
</p>
<p><code>xy2CH</code> partly reverses <code>addTelemetry</code>: the location
information in the telemetryxy attribute is converted back to a capthist with
detector type &lsquo;telemetry&rsquo;.
</p>


<h3>Value</h3>

<p>A single-session capthist object with the same detector type as
<code>detectionCH</code>, but possibly with empty rows and an &lsquo;telemetryxy&rsquo; attribute.
</p>


<h3>Note</h3>

<p>Telemetry provides independent data on the location and presence of a
sample of animals. These animals may be missed in the main sampling that
gives rise to detectionCH i.e., they may have all-zero detection
histories.
</p>
<p>The &lsquo;telemetry&rsquo; detector type is used for telemetry occasions in a combined dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>,
<code><a href="#topic+make.telemetry">make.telemetry</a></code>,
<code><a href="#topic+read.telemetry">read.telemetry</a></code>,
<code><a href="#topic+telemetryxy">telemetryxy</a></code>
<code><a href="#topic+telemetered">telemetered</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Generate some detection and telemetry data, combine them using
# addTelemetry, and perform analyses

# detectors
te &lt;- make.telemetry()
tr &lt;- make.grid(detector = "proximity")

# simulated population and 50% telemetry sample
totalpop &lt;- sim.popn(tr, D = 20, buffer = 100)
tepop &lt;- subset(totalpop, runif(nrow(totalpop)) &lt; 0.5)

# simulated detection histories and telemetry
# the original animalID (renumber = FALSE) are needed for matching
trCH &lt;- sim.capthist(tr,  popn = totalpop, renumber = FALSE, detectfn = "HHN")
teCH &lt;- sim.capthist(te, popn = tepop, renumber=FALSE, detectfn = "HHN",
    detectpar = list(lambda0 = 3, sigma = 25))

combinedCH &lt;- addTelemetry(trCH, teCH)

# summarise and display
summary(combinedCH)
plot(combinedCH, border = 150)
ncapt &lt;- apply(combinedCH,1,sum)
points(totalpop[row.names(combinedCH)[ncapt==0],], pch = 1)
points(totalpop[row.names(combinedCH)[ncapt&gt;0],], pch = 16)

# for later comparison of precision we must fix the habitat mask
mask &lt;- make.mask(tr, buffer = 100)
fit.tr &lt;- secr.fit(trCH, mask = mask, CL = TRUE, detectfn = "HHN")  ## trapping alone
fit.te &lt;- secr.fit(teCH, mask = mask, CL = TRUE, start = log(20),   ## telemetry alone
    detectfn = "HHN") 
fit2   &lt;- secr.fit(combinedCH, mask = mask, CL = TRUE,              ## combined
    detectfn = "HHN")                                 

# improved precision when focus on realised population
# (compare CVD)
derived(fit.tr, distribution = "binomial")
derived(fit2, distribution = "binomial")


# may also use CL = FALSE
secr.fit(combinedCH, CL = FALSE, detectfn = "HHN", trace = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='AIC.secr'> Compare SECR Models </h2><span id='topic+AIC.secr'></span><span id='topic+logLik.secr'></span><span id='topic+AIC.secrlist'></span><span id='topic+secrlist'></span><span id='topic++5B.secrlist'></span>

<h3>Description</h3>

<p>Terse report on the fit of one or more spatially explicit
capture&ndash;recapture models.  Models with smaller values of AIC (Akaike's
Information Criterion) are preferred.  Extraction ([) and logLik methods
are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'secr'
AIC(object, ..., sort = TRUE, k = 2, dmax = 10, criterion = c("AICc","AIC"), chat = NULL)
## S3 method for class 'secrlist'
AIC(object, ..., sort = TRUE, k = 2, dmax = 10, criterion = c("AICc","AIC"), chat = NULL)
## S3 method for class 'secr'
logLik(object, ...)
secrlist(..., names = NULL)
## S3 method for class 'secrlist'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.secr_+3A_object">object</code></td>
<td>
 <p><code>secr</code> object output from the function
<code><a href="#topic+secr.fit">secr.fit</a></code>, or a list of such objects with class c(&quot;secrlist&quot;, &quot;list&quot;) </p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_...">...</code></td>
<td>
<p> other <code>secr</code> objects </p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_sort">sort</code></td>
<td>
<p> logical for whether rows should be sorted by ascending AICc </p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_k">k</code></td>
<td>
<p> numeric, penalty per parameter to be used; always k = 2 in this method</p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_dmax">dmax</code></td>
<td>
<p> numeric, maximum AIC difference for inclusion in confidence set</p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_criterion">criterion</code></td>
<td>
<p> character, criterion to use for model comparison and
weights</p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_chat">chat</code></td>
<td>
<p>numeric optional variance inflation factor for quasi-AIC</p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_names">names</code></td>
<td>
<p>character vector of names (optional)</p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_x">x</code></td>
<td>
<p>secrlist</p>
</td></tr>
<tr><td><code id="AIC.secr_+3A_i">i</code></td>
<td>
<p>indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models to be compared must have been fitted to the same data and use the
same likelihood method (full vs conditional).  From version 4.1 a warning is 
issued if <code><a href="#topic+AICcompatible">AICcompatible</a></code> reveals a problem.
</p>
<p>AIC is given by
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{AIC} = -2\log(L(\hat{\theta})) + 2K</code>
</p>

<p>where <code class="reqn">K</code> is the number of &quot;beta&quot; parameters estimated. 
</p>
<p>AIC with small sample adjustment is given by
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{AIC}_c = -2\log(L(\hat{\theta})) + 2K +
\frac{2K(K+1)}{n-K-1}.</code>
</p>

<p>The sample size <code class="reqn">n</code> is the number of individuals observed at least once (i.e. the
number of rows in <code>capthist</code>).
</p>
<p>Model weights are calculated as </p>
<p style="text-align: center;"><code class="reqn">w_i = \frac{\exp(-\Delta_i / 2),}{
\sum{\exp(-\Delta_i / 2)}}</code>
</p>
<p> where <code class="reqn">\Delta</code> refers to differences in AIC or AICc depending on the
argument &lsquo;criterion&rsquo;. AICc is widely used, but AIC may be better (Fletcher 2018, p. 60).
</p>
<p>Models for which delta &gt; <code>dmax</code> are given a weight of zero and are
excluded from the summation. Model weights may be used to form
model-averaged estimates of real or beta parameters with
<code><a href="#topic+modelAverage">modelAverage</a></code> (see also Buckland et al. 1997, Burnham and
Anderson 2002).
</p>
<p>The argument <code>k</code> is included for consistency with the generic method <code>AIC</code>.
</p>
<p><code>secrlist</code> forms a list of fitted models (an object of class
&lsquo;secrlist&rsquo;) from the fitted models in ....  Arguments may include
secrlists. If secr components are named the model names will be retained unless &lsquo;names&rsquo; is specified.
(see Examples).
</p>
<p>If chat (<code class="reqn">\hat c</code>) is provided then quasi-AIC values are computed (<span class="pkg">secr</span> &gt;= 4.6.0):
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{QAIC} = -2\log(L(\hat{\theta}))/ \hat c + 2K.</code>
</p>



<h3>Value</h3>

<p>A data frame with one row per model.  By default, rows are sorted by ascending 
'criterion' (default AICc).
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>character string describing the fitted model</p>
</td></tr>
<tr><td><code>detectfn</code></td>
<td>
<p>shape of detection function fitted (halfnormal vs hazard-rate) </p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>number of parameters estimated</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>maximized log likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with small-sample adjustment of Hurvich &amp; Tsai
(1989)</p>
</td></tr>
</table>
<p>And depending on <code>criterion</code>:
</p>
<table>
<tr><td><code>dAICc</code></td>
<td>
<p>difference between AICc of this model and the one with smallest AICc</p>
</td></tr>
<tr><td><code>AICcwt</code></td>
<td>
<p>AICc model weight</p>
</td></tr>
</table>
<p>or
</p>
<table>
<tr><td><code>dAIC</code></td>
<td>
<p>difference between AIC of this model and the one with smallest AIC</p>
</td></tr>
<tr><td><code>AICwt</code></td>
<td>
<p>AIC model weight</p>
</td></tr>
</table>
<p><code>logLik.secr</code> returns an object of class &lsquo;logLik&rsquo; that has
attribute <code>df</code> (degrees of freedom = number of estimated
parameters).
</p>
<p>If the variance inflation factor 'chat' is provided then outputs AIC, AICc 
etc. are replaced by the corresponding quasi-AIC values labelled QAIC, QAICc etc.
</p>


<h3>Note</h3>

<p>It is not be meaningful to compare models by AIC if they relate to
different data (see <code><a href="#topic+AICcompatible">AICcompatible</a></code>).
</p>
<p>Specifically:
</p>

<ul>
<li><p> an &lsquo;secrlist&rsquo; generated and saved to file by <code>mask.check</code>
may be supplied as the object argument of <code>AIC.secrlist</code>, but the
results are not informative
</p>
</li>
<li><p> models fitted by the conditional likelihood (<code>CL = TRUE</code>) and
full likelihood (<code>CL = FALSE</code>) methods cannot be compared
</p>
</li>
<li><p> hybrid mixture models (using hcov argument of secr.fit) should not
be compared with other models
</p>
</li>
<li><p> grouped models (using groups argument of secr.fit) should not be
compared with other models
</p>
</li>
<li><p> multi-session models should not be compared with single-session
models based on the same data.
</p>
</li></ul>

<p>A likelihood-ratio test (<code><a href="#topic+LR.test">LR.test</a></code>) is a more direct way to
compare two models.
</p>
<p>The issue of goodness-of-fit and possible adjustment of AIC for
overdispersion has yet to be addressed (cf QAIC in MARK).
</p>
<p>From version 2.6.0 the user may select between AIC and AICc for
comparing models, whereas previously only AICc was used and AICc weights
were reported as &lsquo;AICwt&rsquo;). There is evidence that AIC may be better for
model averaging even when samples are small sizes - Turek and Fletcher
(2012).
</p>


<h3>References</h3>

 
<p>Buckland S. T., Burnham K. P. and Augustin, N. H. (1997) Model selection: an integral part of inference. <em>Biometrics</em> <b>53</b>, 603&ndash;618.
</p>
<p>Burnham, K. P. and Anderson, D. R. (2002) <em>Model Selection and Multimodel Inference: A Practical Information-Theoretic Approach</em>. Second edition. New York: Springer-Verlag.
</p>
<p>Fletcher, D. (2019) Model averaging. SpringerBriefs in Statistics. Berlin: Springer-Verlag.
</p>
<p>Hurvich, C. M. and Tsai, C. L. (1989) Regression and time series model selection in small samples. <em>Biometrika</em> <b>76</b>, 297&ndash;307.
</p>
<p>Turek, D. and Fletcher, D. (2012) Model-averaged Wald confidence
intervals. <em>Computational statistics and data analysis</em> <b>56</b>,
2809&ndash;2815.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+AICcompatible">AICcompatible</a></code>, 
<code><a href="#topic+modelAverage">modelAverage</a></code>, 
<code><a href="stats.html#topic+AIC">AIC</a></code>, 
<code><a href="#topic+secr.fit">secr.fit</a></code>, 
<code><a href="#topic+print.secr">print.secr</a></code>, 
<code><a href="#topic+score.test">score.test</a></code>, 
<code><a href="#topic+LR.test">LR.test</a></code>, 
<code><a href="#topic+deviance.secr">deviance.secr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare two models fitted previously
## secrdemo.0 is a null model
## secrdemo.b has a learned trap response

AIC(secrdemo.0, secrdemo.b)

## Form secrlist and pass to AIC.secr
temp &lt;- secrlist(null = secrdemo.0, learnedresponse = secrdemo.b)
AIC(temp)

</code></pre>

<hr>
<h2 id='AICcompatible'>Model Compatibility</h2><span id='topic+AICcompatible.secr'></span><span id='topic+AICcompatible.secrlist'></span><span id='topic+AICcompatible'></span>

<h3>Description</h3>

<p>Determine whether models can be compared by AIC. Incompatibility may be due to difference in the data or the specifications of the groups, hcov or binomN arguments to <code><a href="#topic+secr.fit">secr.fit</a></code>, 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secr'
AICcompatible(object, ...)
## S3 method for class 'secrlist'
AICcompatible(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICcompatible_+3A_object">object</code></td>
<td>
<p><code>secr</code> object output from the function
<code><a href="#topic+secr.fit">secr.fit</a></code>, or a list of such objects with class c(&quot;secrlist&quot;, &quot;list&quot;)</p>
</td></tr>
<tr><td><code id="AICcompatible_+3A_...">...</code></td>
<td>
<p>other <code>secr</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The capthist objects are checked for strict identity with the function <code><a href="base.html#topic+identical">identical</a></code>.
</p>
<p>All elements in the output must be TRUE for valid AIC comparison or model averaging using AIC or AICc.
</p>


<h3>Value</h3>

<p>Named logical vector with elements &lsquo;data&rsquo;, &lsquo;CL&rsquo;, &lsquo;groups&rsquo;, &lsquo;hcov&rsquo; and &lsquo;binomN&rsquo;. 
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+AIC.secr">AIC.secr</a></code>, <code><a href="#topic+modelAverage">modelAverage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
AICcompatible(secrdemo.0, secrdemo.CL)

## Not run: 

## A common application of AICcompatible() is to determine 
## the compatibility of models fitted with and without the 
## fastproximity option.

ovenCHp1 &lt;- reduce(ovenCHp, by = 'all', outputdetector = 'count')
ob1 &lt;- secr.fit(ovenCHp, buffer = 300, details = list(fastproximity = TRUE))
ob2 &lt;- secr.fit(ovenCHp1, buffer = 300, details = list(fastproximity = FALSE))
ob3 &lt;- secr.fit(ovenCHp1, buffer = 300, details = list(fastproximity = FALSE), binomN = 1)
AICcompatible(ob1,ob2)
AICcompatible(ob1,ob3)


## End(Not run)

</code></pre>

<hr>
<h2 id='as.data.frame'> Coerce capthist to Data Frame </h2><span id='topic+as.data.frame'></span><span id='topic+as.data.frame.capthist'></span><span id='topic+as.data.frame.traps'></span>

<h3>Description</h3>

<p>Method for generic <code>as.data.frame</code> function that partially reverses <code>make.capthist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'capthist'
as.data.frame(x, row.names = NULL, optional = FALSE, covariates = FALSE, 
                                    fmt = c("trapID", "XY"), ...)
## S3 method for class 'traps'
as.data.frame(x, row.names = NULL, optional = FALSE, usage = FALSE, 
                              covariates = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
 <p><code>capthist</code>  object </p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_row.names">row.names</code></td>
<td>
<p>unused argument of generic function</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_optional">optional</code></td>
<td>
<p>unused argument of generic function</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_covariates">covariates</code></td>
<td>
<p> logical or a character vector of covariates to export </p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_fmt">fmt</code></td>
<td>
<p> character string for capture format </p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_usage">usage</code></td>
<td>
<p> logical; if TRUE then usage columns are appended if present </p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default individual covariates are not exported. When exported they
are repeated for each detection of an individual.
</p>


<h3>Value</h3>

<p>A data frame or list of data frames (in the case of a multisession input). 
</p>
<p>For capthist objects &ndash;
</p>
<p>The core columns are (Session, ID, Occasion, TrapID) or (Session, ID, Occasion, x, y), 
depending on the value of <code>fmt</code>.  Additional columns for covariates and signal 
strength (detector &lsquo;signal&rsquo;) are appended to the right. 
</p>
<p>For traps objects &ndash;
</p>
<p>The core columns are (x, y). Usage columns are named u1, u2, ..., uS where S is the number of occasions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  as.data.frame (captdata)
  as.data.frame (traps(captdata))
  
</code></pre>

<hr>
<h2 id='as.mask'>Coerce traps object to mask</h2><span id='topic+as.mask'></span>

<h3>Description</h3>

<p>This function is used primarily for plotting covariates, for which the plot.mask function has greater functionality than <code>plot.traps</code>.  It also generates pretty maps of grid cells. </p>


<h3>Usage</h3>

<pre><code class='language-R'>
as.mask(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mask_+3A_x">x</code></td>
<td>
<p>an object of class 'traps'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A mask derived by coercion with <code>as.mask</code> may behave
unpredictably e.g., in <code>secr.fit</code>.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a single-session traps object &ndash;
</p>
<p>an object of class c(&quot;mask&quot;, &quot;data.frame&quot;)
</p>
<p>If <code>x</code> is a multi-session traps object &ndash;
</p>
<p>an object of class c(&quot;mask&quot;, &quot;list&quot;), for which each component is a
single-session mask.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.mask">make.mask</a></code>,  <code><a href="#topic+plot.mask">plot.mask</a></code>,  
<a href="#topic+mask">mask</a>, <a href="#topic+traps">traps</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(as.mask(traps(captdata)), dots = FALSE, meshcol = "black")
plot(traps(captdata), add = TRUE)

</code></pre>

<hr>
<h2 id='as.popn'>Coerce ppp object to popn</h2><span id='topic+as.popn'></span>

<h3>Description</h3>

<p>This function converts a <span class="pkg">spatstat</span> &quot;ppp&quot; object (Baddeley et al. 2015), making it easier to use the simulation capability of <span class="pkg">spatstat</span> in <span class="pkg">secr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
as.popn(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.popn_+3A_x">x</code></td>
<td>
<p>an object of class 'ppp'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all attributes are carried over.
</p>


<h3>Value</h3>

<p>An object of class c(&quot;popn&quot;, &quot;data.frame&quot;) with attribute &quot;boundingbox&quot;. The attribute &quot;Lambda&quot;  (<span class="pkg">spatstat</span> class &quot;im&quot;) is also carried over if present (used for the intensity surface of LGCP simulations).
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., and Turner, R. 2015. Spatial Point Patterns: Methodology and Applications with R. Chapman and Hall/CRC Press, London. ISBN 9781482210200, https://www.routledge.com/Spatial-Point-Patterns-Methodology-and-Applications-with-R/Baddeley-Rubak-Turner/p/book/9781482210200/. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.popn">sim.popn</a></code>, <code><a href="#topic+popn">popn</a></code>
</p>

<hr>
<h2 id='autoini'> Initial Parameter Values for SECR </h2><span id='topic+autoini'></span>

<h3>Description</h3>

<p>Find plausible initial parameter values for <code><a href="#topic+secr.fit">secr.fit</a></code>.  A
simple SECR model is fitted by a fast ad hoc method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoini(capthist, mask, detectfn = 0, thin = 0.2, tol = 0.001, 
    binomN = 1, adjustg0 = TRUE, adjustsigma = 1.2, ignoreusage = FALSE, 
    ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoini_+3A_capthist">capthist</code></td>
<td>
<p><code>capthist</code> object</p>
</td></tr>
<tr><td><code id="autoini_+3A_mask">mask</code></td>
<td>
<p><code>mask</code> object compatible with the detector layout in
<code>capthist</code></p>
</td></tr>
<tr><td><code id="autoini_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of
detection function 0 = halfnormal</p>
</td></tr>
<tr><td><code id="autoini_+3A_thin">thin</code></td>
<td>
<p>proportion of points to retain in mask </p>
</td></tr>
<tr><td><code id="autoini_+3A_tol">tol</code></td>
<td>
<p>numeric absolute tolerance for numerical root finding </p>
</td></tr>
<tr><td><code id="autoini_+3A_binomn">binomN</code></td>
<td>
<p>integer code for distribution of counts (see <code><a href="#topic+secr.fit">secr.fit</a></code>) </p>
</td></tr>
<tr><td><code id="autoini_+3A_adjustg0">adjustg0</code></td>
<td>
<p>logical for whether to adjust g0 for usage (effort) and
binomN </p>
</td></tr>
<tr><td><code id="autoini_+3A_adjustsigma">adjustsigma</code></td>
<td>
<p>numeric scalar applied to RPSV(capthist, CC = TRUE) </p>
</td></tr>
<tr><td><code id="autoini_+3A_ignoreusage">ignoreusage</code></td>
<td>
<p>logical for whether to discard usage information from
<code>traps(capthist)</code></p>
</td></tr>
<tr><td><code id="autoini_+3A_ncores">ncores</code></td>
<td>
<p> integer number of threads to be used for parallel processing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plausible starting values are needed to avoid numerical
problems when fitting SECR models.  Actual models
to be fitted will usually have more than the three basic parameters
output by <code>autoini</code>; other initial values can usually be set to
zero for <code>secr.fit</code>.  If the algorithm encounters problems obtaining
a value for g0, the default value of 0.1 is returned.
</p>
<p>Only the halfnormal detection function is currently available in <code>autoini</code> (cf
other options in e.g. <a href="#topic+detectfn">detectfn</a> and <code><a href="#topic+sim.capthist">sim.capthist</a></code>).
</p>
<p><code>autoini</code> implements a modified version of the algorithm proposed
by Efford et al. (2004).  In outline, the algorithm is
</p>

<ol>
<li><p> Find value of sigma that predicts the 2-D dispersion of individual locations (see <code><a href="#topic+RPSV">RPSV</a></code>). 
</p>
</li>
<li><p> Find value of g0 that, with sigma, predicts the observed mean number of captures per individual (by algorithm of Efford et al. (2009, Appendix 2))
</p>
</li>
<li><p> Compute the effective sampling area from g0, sigma, using thinned mask (see <code><a href="#topic+esa">esa</a></code>)
</p>
</li>
<li><p> Compute D = <code class="reqn">n</code>/esa(g0, sigma), where <code class="reqn">n</code> is the number of individuals detected
</p>
</li></ol>

<p>Here &lsquo;find&rsquo; means solve numerically for zero difference between the observed and predicted values, using <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>
<p>Halfnormal sigma is estimated with <code>RPSV(capthist, CC = TRUE)</code>.  The factor <code>adjustsigma</code> is applied as a crude correction for truncation of movements at the edge of the detector array.
</p>
<p>If <code>RPSV</code> cannot be computed the algorithm tries to use observed
mean recapture distance <code class="reqn">\bar{d}</code>.  Computation of
<code class="reqn">\bar{d}</code> fails if there no recaptures, and all returned
values are NA.
</p>
<p>If the mask has more than 100 points then a proportion 1&ndash;<code>thin</code> of
points are discarded at random to speed execution.
</p>
<p>The argument <code>tol</code> is passed to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.  It may be a
vector of two values, the first for g0 and the second for sigma.
</p>
<p>If <code>traps(capthist)</code> has a <a href="#topic+usage">usage</a> attribute (defining effort
on each occasion at each detector) then the value of g0 is divided by
the mean of the non-zero elements of usage.  This adjustment is not
precise.
</p>
<p>If <code>adjustg0</code> is TRUE then an adjustment is made to g0 depending
on the value of <code>binomN</code>.  For Poisson counts (<code>binomN = 0</code>)
the adjustment is linear on effort (adjusted.g0 = g0 /
usage).  Otherwise, the adjustment is on the hazard scale (adjusted.g0 =
1 &ndash; (1 &ndash; g0) ^ (1 / (usage x binomN))).  An arithmetic average is taken
over all non-zero usage values (i.e. over used detectors and times). If
usage is not specified it is taken to be 1.0.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>


<h3>Value</h3>

<p>A list of parameter values :
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>Density (animals per hectare)</p>
</td></tr>
<tr><td><code>g0</code></td>
<td>
<p>Magnitude (intercept) of detection function </p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Spatial scale of detection function (m) </p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>autoini</code> always uses the Euclidean distance between detectors and
mask points.
</p>
<p>You may get this message from secr.fit: &ldquo;'autoini' failed to find g0;
setting initial g0 = 0.1&rdquo;.  If the fitted model looks OK (reasonable
estimates, non-missing SE) there is no reason to worry about the
starting values.  If you get this message and model fitting fails then
supply your own values in the start argument of secr.fit.
</p>


<h3>References</h3>

<p>Efford, M. G., Dawson, D. K. and Robbins C. S. (2004) DENSITY: software for analysing capture&ndash;recapture data from passive detector arrays. <em>Animal Biodiversity and Conservation</em> <b>27</b>,
217&ndash;228.
</p>
<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009) Population
density estimated from locations of individuals on a passive detector
array. <em>Ecology</em> <b>90</b>, 2676&ndash;2682.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+dbar">dbar</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

demotraps &lt;- make.grid()
demomask &lt;- make.mask(demotraps)
demoCH &lt;- sim.capthist (demotraps, popn = list(D = 5, buffer = 100), seed = 321)
autoini (demoCH, demomask)


## End(Not run)

</code></pre>

<hr>
<h2 id='binCovariate'>Add Binned Covariate</h2><span id='topic+binCovariate'></span>

<h3>Description</h3>

<p>Forms a new covariate, replacing values of an old covariate by the central value of equal-width bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
binCovariate(object, covname, width)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binCovariate_+3A_object">object</code></td>
<td>
<p>secr object with covariates attribute (capthist, traps, mask)</p>
</td></tr>
<tr><td><code id="binCovariate_+3A_covname">covname</code></td>
<td>
<p>character name of covariate</p>
</td></tr>
<tr><td><code id="binCovariate_+3A_width">width</code></td>
<td>
<p>numeric bin width</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the new covariate is <code>paste0(covname, width)</code>.
</p>
<p>Fails if covariate not found or is not numeric or there is already a covariate with the new name.
</p>
<p>Multi-session objects are handled appropriately. 
</p>


<h3>Value</h3>

<p>Object of the same class as the input with new covariate.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covariates">covariates</a></code>, <a href="#topic+skink">skink</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# bin values of skink snout-vent length (mm)
infraCH &lt;- binCovariate (infraCH, 'SVL', 5)
table(covariates(infraCH[[1]])$SVL5)

# bin values of trap covariate 'HtBrack' (height of bracken, cm)
traps(infraCH) &lt;- binCovariate(traps(infraCH), "HtBrack", 20)
table(covariates(traps(infraCH)[[1]])$HtBrack20)

</code></pre>

<hr>
<h2 id='BUGS'>
Convert Data To Or From BUGS Format
</h2><span id='topic+read.DA'></span><span id='topic+write.DA'></span>

<h3>Description</h3>

<p>Convert data between &lsquo;capthist&rsquo; and BUGS input format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
read.DA(DAlist, detector = "polygonX", units = 1, session = 1,
    Y = "Y", xcoord = "U1", ycoord = "U2", xmin = "Xl",
    xmax = "Xu", ymin = "Yl", ymax = "Yu", buffer = "delta",
    verify = TRUE)

write.DA(capthist, buffer, nzeros = 200, units = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BUGS_+3A_dalist">DAlist</code></td>
<td>
<p> list containing data in BUGS format </p>
</td></tr>
<tr><td><code id="BUGS_+3A_detector">detector</code></td>
<td>
<p> character value for detector type: &lsquo;polygon&rsquo; or &lsquo;polygonX&rsquo; </p>
</td></tr>
<tr><td><code id="BUGS_+3A_units">units</code></td>
<td>
<p> numeric for scaling output coordinates</p>
</td></tr>
<tr><td><code id="BUGS_+3A_session">session</code></td>
<td>
<p>numeric or character label used in output</p>
</td></tr>
<tr><td><code id="BUGS_+3A_y">Y</code></td>
<td>
<p>character, name of binary detection history matrix (animals x occasions)</p>
</td></tr>
<tr><td><code id="BUGS_+3A_xcoord">xcoord</code></td>
<td>
<p>character, name of matrix of x-coordinates for each detection in <code>Y</code></p>
</td></tr>
<tr><td><code id="BUGS_+3A_ycoord">ycoord</code></td>
<td>
<p>character, name of matrix of y-coordinates for each detection in <code>Y</code></p>
</td></tr>
<tr><td><code id="BUGS_+3A_xmin">xmin</code></td>
<td>
<p> character, name of coordinate of state space boundary</p>
</td></tr>
<tr><td><code id="BUGS_+3A_xmax">xmax</code></td>
<td>
<p> character, name of coordinate of state space boundary</p>
</td></tr>
<tr><td><code id="BUGS_+3A_ymin">ymin</code></td>
<td>
<p> character, name of coordinate of state space boundary</p>
</td></tr>
<tr><td><code id="BUGS_+3A_ymax">ymax</code></td>
<td>
<p> character, name of coordinate of state space boundary</p>
</td></tr>
<tr><td><code id="BUGS_+3A_buffer">buffer</code></td>
<td>
<p> see Details</p>
</td></tr>
<tr><td><code id="BUGS_+3A_verify">verify</code></td>
<td>
<p> logical if TRUE then the resulting capthist object is
checked with <code><a href="#topic+verify">verify</a></code></p>
</td></tr>
<tr><td><code id="BUGS_+3A_capthist">capthist</code></td>
<td>
<p><code><a href="#topic+capthist">capthist</a></code> object </p>
</td></tr>
<tr><td><code id="BUGS_+3A_nzeros">nzeros</code></td>
<td>
<p>level of data augmentation (all-zero detection histories)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data for OpenBUGS or WinBUGS called from R using the package
<span class="pkg">R2WinBUGS</span> (Sturtz et al. 2005) take the form of an <span class="rlang"><b>R</b></span> list.
</p>
<p>These functions are limited at present to binary data from a square
quadrat such as used by Royle and Young (2008). Marques et al. (2011)
provide an <span class="rlang"><b>R</b></span> function <code>create.data()</code> for generating simulated
datasets of this sort (see <code><a href="#topic+sim.capthist">sim.capthist</a></code> for equivalent
functionality).
</p>
<p>When reading BUGS data &ndash;
</p>
<p>The character values <code>Y</code>, <code>xcoord</code>, <code>ycoord</code>,
<code>xmin</code> etc. are used to locate the data within <code>DAlist</code>,
allowing for variation in the input names.
</p>
<p>The number of sampling occasions is taken from the number of columns
in <code>Y</code>. Each value in <code>Y</code> should be 0 or 1. Coordinates may
be missing
</p>
<p>A numeric value for <code>buffer</code> is the distance (in the original
units) by which the limits Xl, Xu etc. should be shrunk to give the
actual plot limits.  If <code>buffer</code> is character then a component of
<code>DAlist</code> contains the required numeric value.
</p>
<p>Coordinates in the output will be <em>multiplied by</em> the scalar
<code>units</code>.
</p>
<p>Augmentation rows corresponding to &lsquo;all-zero&rsquo; detection histories in
<code>Y</code>, <code>xcoord</code>, and <code>ycoord</code> are discarded.
</p>
<p>When writing BUGS data &ndash;
</p>
<p>Null (all-zero) detection histories are added to the matrix of
detection histories <code>Y</code>, and missing (NA) rows are added to the
coordinate matrices <code>xcoord</code> and <code>ycoord</code>.
</p>
<p>Coordinates in the output will be <em>divided by</em> the scalar
<code>units</code>.
</p>


<h3>Value</h3>

<p>For <code>read.DA</code>, an object of class &lsquo;capthist&rsquo;.
</p>
<p>For <code>write.DA</code>, a list with the components
</p>

<table>
<tr>
 <td style="text-align: left;">
Xl </td><td style="text-align: left;"> left edge of state space </td>
</tr>
<tr>
 <td style="text-align: left;">
Xu </td><td style="text-align: left;"> right edge of state space </td>
</tr>
<tr>
 <td style="text-align: left;">
Yl </td><td style="text-align: left;"> bottom edge of state space </td>
</tr>
<tr>
 <td style="text-align: left;">
Yu </td><td style="text-align: left;"> top edge of state space </td>
</tr>
<tr>
 <td style="text-align: left;">
delta </td><td style="text-align: left;"> buffer between edge of state space and quadrat </td>
</tr>
<tr>
 <td style="text-align: left;">
nind </td><td style="text-align: left;"> number of animals observed </td>
</tr>
<tr>
 <td style="text-align: left;">
nzeros </td><td style="text-align: left;"> number of added all-zero detection histories </td>
</tr>
<tr>
 <td style="text-align: left;">
T </td><td style="text-align: left;"> number of sampling occasions </td>
</tr>
<tr>
 <td style="text-align: left;">
Y </td><td style="text-align: left;"> binary matrix of detection histories (dim = c(nind+nzeros, T)) </td>
</tr>
<tr>
 <td style="text-align: left;">
U1 </td><td style="text-align: left;"> matrix of x-coordinates, dimensioned as Y </td>
</tr>
<tr>
 <td style="text-align: left;">
U2 </td><td style="text-align: left;"> matrix of y-coordinates, dimensioned as Y </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>U1 and U2 are &lsquo;NA&rsquo; where animal was not detected.
</p>


<h3>References</h3>

<p>Marques, T. A., Thomas, L. and Royle, J. A. (2011) A hierarchical model
for spatial capture&ndash;recapture data: Comment. <em>Ecology</em> <b>92</b>,
526&ndash;528.
</p>
<p>Royle, J. A. and Young, K. V. (2008) A hierarchical model for spatial
capture&ndash;recapture data. <em>Ecology</em> <b>89</b>, 2281&ndash;2289.
</p>
<p>Sturtz, S., Ligges, U. and Gelman, A. (2005) R2WinBUGS: a package for
running WinBUGS from R. <em>Journal of Statistical Software</em>
<b>12</b>, 1&ndash;16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hornedlizardCH">hornedlizardCH</a></code>, <code><a href="#topic+verify">verify</a></code>, <code><a href="#topic+capthist">capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
write.DA (hornedlizardCH, buffer = 100, units = 100)

## In this example, the input uses Xl, Xu etc.
## for the limits of the plot itself, so buffer = 0.
## Input is in hundreds of metres.
## First, obtain the list lzdata
olddir &lt;- setwd (system.file("extdata", package="secr"))
source ("lizarddata.R")
setwd(olddir)
str(lzdata)
## Now convert to capthist
tempcapt &lt;- read.DA(lzdata, Y = "H", xcoord = "X",
    ycoord = "Y", buffer = 0, units = 100)

## Not run: 

plot(tempcapt)
secr.fit(tempcapt, trace = FALSE)
## etc.


## End(Not run)

</code></pre>

<hr>
<h2 id='capthist'> Spatial Capture History Object </h2><span id='topic+capthist'></span>

<h3>Description</h3>

<p>A <code>capthist</code> object encapsulates all data needed by
<code>secr.fit</code>, except for the optional habitat mask.
</p>


<h3>Details</h3>

<p>An object of class <code>capthist</code> holds spatial capture histories,
detector (trap) locations, individual covariates and other data needed
for a spatially explicit capture-recapture analysis with
<code>secr.fit</code>. 
</p>
<p>A <code>capthist</code> is primarily an array of values with dim(capthist) = c(nc,
noccasions, ntraps) where nc is the number of detected individuals. 
Values maybe binary ({&ndash;1, 0, 1}) or integer depending on the detector type.
</p>
<p>Deaths during the experiment are represented as negative values. 
</p>
<p>Ancillary data are retained as attributes of a <code>capthist</code> object as follows:
</p>

<ul>
<li><p>traps &mdash; object of class <code>traps</code> (required)
</p>
</li>
<li><p>session &mdash; session identifier (required)
</p>
</li>
<li><p>covariates &mdash; dataframe of individual covariates (optional)
</p>
</li>
<li><p>cutval &mdash; threshold of signal strength for detection (&lsquo;signal&rsquo; only)
</p>
</li>
<li><p>signalframe &mdash; signal strength values etc., one row per detection (&lsquo;signal&rsquo; only)
</p>
</li>
<li><p>detectedXY &mdash; dataframe of coordinates for location within
polygon (&lsquo;polygon&rsquo;-like detectors only)
</p>
</li>
<li><p>xylist &mdash; coordinates of telemetered animals
</p>
</li>
<li><p>Tu &mdash; detectors x occasions matrix of sightings of unmarked animals
</p>
</li>
<li><p>Tm &mdash; detectors x occasions matrix of sightings of marked but unidentified animals 
</p>
</li>
<li><p>Tn &mdash; detectors x occasions matrix of sightings with unknown mark status 
</p>
</li></ul>

<p><code>read.capthist</code> is adequate for most data input. Alternatively, the parts of a 
capthist object can be assembled with the function <code>make.capthist</code>.  
Use <code>sim.capthist</code> for Monte Carlo simulation
(simple models only). Methods are provided to display and manipulate
<code>capthist</code> objects (print, summary, plot, rbind, subset, reduce)
and to extract and replace attributes (covariates, traps, xy).
</p>
<p>A multi-session <code>capthist</code> object is a list in which each component
is a <code>capthist</code> for a single session.  The list maybe derived
directly from multi-session input in Density format, or by combining
existing <code>capthist</code> objects with <code><a href="#topic+MS.capthist">MS.capthist</a></code>.
</p>


<h3>Note</h3>

<p>Early versions of <span class="pkg">secr</span> (before 3.0) used an individual x occasion matrix 
for data from single-catch and multi-catch traps, instead of a 3-D array. 
Entries in the matrix corresponded to trap numbers. The function 
<code><a href="#topic+updateCH">updateCH</a></code> converts the old format.
</p>


<h3>References</h3>

 
<p>Borchers, D. L. and Efford, M. G. (2008) Spatially
explicit maximum likelihood methods for capture&ndash;recapture studies.
<em>Biometrics</em> <b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+traps">traps</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+read.capthist">read.capthist</a></code>, <code><a href="#topic+make.capthist">make.capthist</a></code>,
<code><a href="#topic+sim.capthist">sim.capthist</a></code>,
<code><a href="#topic+subset.capthist">subset.capthist</a></code>, <code><a href="#topic+rbind.capthist">rbind.capthist</a></code>,
<code><a href="#topic+MS.capthist">MS.capthist</a></code>,
<code><a href="#topic+reduce.capthist">reduce.capthist</a></code>, <code><a href="#topic+mask">mask</a></code> </p>

<hr>
<h2 id='capthist.parts'> Dissect Spatial Capture History Object </h2><span id='topic+animalID'></span><span id='topic+occasion'></span><span id='topic+trap'></span><span id='topic+alive'></span><span id='topic+xy'></span><span id='topic+alongtransect'></span><span id='topic+xy+3C-'></span><span id='topic+telemetryxy'></span><span id='topic+telemetryxy+3C-'></span><span id='topic+telemetered'></span>

<h3>Description</h3>

<p>Extract parts of an object of class &lsquo;capthist&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
animalID(object, names = TRUE, sortorder = c("snk", "ksn"))
occasion(object, sortorder = c("snk", "ksn"))
trap(object, names = TRUE, sortorder = c("snk", "ksn"))
alive(object, sortorder = c("snk", "ksn"))
alongtransect(object, tol = 0.01)
xy(object)
xy(object) &lt;- value
telemetryxy(object, includeNULL = FALSE)
telemetryxy(object) &lt;- value
telemetered(object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capthist.parts_+3A_object">object</code></td>
<td>
<p> a &lsquo;capthist&rsquo; object </p>
</td></tr>
<tr><td><code id="capthist.parts_+3A_names">names</code></td>
<td>
<p> if FALSE the values returned are numeric indices rather
than names </p>
</td></tr>
<tr><td><code id="capthist.parts_+3A_sortorder">sortorder</code></td>
<td>
<p>character code for sort order (see Details)</p>
</td></tr>
<tr><td><code id="capthist.parts_+3A_tol">tol</code></td>
<td>
<p> tolerance for snapping to transect line (m) </p>
</td></tr>
<tr><td><code id="capthist.parts_+3A_value">value</code></td>
<td>
<p> replacement value (see Details) </p>
</td></tr>
<tr><td><code id="capthist.parts_+3A_includenull">includeNULL</code></td>
<td>
<p>logical; if TRUE a NULL component is included for
untelemetered animals </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>These functions extract data on detections, ignoring occasions when an
animal was not detected. By default, detections are ordered by occasion, animalID
and trap (<code>sortorder = "snk"</code>). The alternative is to order by 
trap, occasion and animalID (<code>sortorder = "ksn"</code>). (&lsquo;n&rsquo;, &lsquo;s&rsquo; and &lsquo;k&rsquo; are the 
indices used internally for animals, occasions and traps respectively).
</p>
<p>For historical reasons, &quot;ksn&quot; is used for locations within polygons and similar 
(<code>xy</code>). 
</p>
<p><code>trap</code> returns polygon or transect numbers if <code>traps(object)</code>
has detector type &lsquo;polygon&rsquo; or &lsquo;transect&rsquo;.
</p>
<p><code>alongtransect</code> returns the distance of each detection from the
start of the transect with which it is associated.
</p>
<p>Replacement values must precisely match <code>object</code> in number of
detections and in their order. <code>xy&lt;-</code> expects a dataframe of x and y
coordinates for points of detection within a &lsquo;polygon&rsquo; or &lsquo;transect&rsquo;
detector. <code>telemetryxy&lt;-</code> expects a list of dataframes, one per telemetered animal.
</p>


<h3>Value</h3>

<p>For <code>animalID</code> and <code>trap</code> a vector of numeric or character values, one per detection.
</p>
<p>For <code>alive</code> a vector of logical values, one per detection.
</p>
<p>For <code>occasion</code>, a vector of numeric values, one per detection.
</p>
<p>For <code>xy</code>, a dataframe with one row per detection and columns &lsquo;x&rsquo; and &lsquo;y&rsquo;.
</p>
<p>If <code>object</code> has multiple sessions, the result is a list with one
component per session.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+polyID">polyID</a></code>, <code><a href="#topic+signalmatrix">signalmatrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## `captdata' is a demonstration dataset
animalID(captdata)

temp &lt;- sim.capthist(popn = list(D = 1), make.grid(detector
    = "count"))
cbind(ID = as.numeric(animalID(temp)), occ = occasion(temp),
    trap = trap(temp))

</code></pre>

<hr>
<h2 id='chat'> Overdispersion of Activity Centres</h2><span id='topic+nk'></span><span id='topic+Enk'></span><span id='topic+chat.nk'></span><span id='topic+adjustVarD'></span>

<h3>Description</h3>

<p>Activity centres may be clumped (overdispersed) relative to a Poisson distribution,
the model used in <code><a href="#topic+secr.fit">secr.fit</a></code> (Borchers and Efford 2008). This can cause 
the sampling variance of density estimates to be understated. One solution currently under investigation is to apply a variance inflation factor, a measure of overdispersion, based on the number of individuals detected at each detector (Bischof et al. 2020).
</p>
<p>Functions described here compute the observed (nk) or expected (Enk) number of individuals detected at each detector and use that to compute Fletcher's <code class="reqn">\hat c</code> estimate of overdispersion 
for use as a variance inflation factor. 
</p>
<p><code>Enk</code> uses exact formulae for 'multi', 'proximity' and 'count' detector types. Other types may be simulated by setting a positive value for 'nrepl', which should be large (e.g., nrepl = 10000).
</p>
<p><code>adjustVarD</code> adjusts the SE and confidence limits of density estimates 
using Fletcher's <code class="reqn">\hat c</code>. The implementation is limited to simple detection models 
(see Warnings).
</p>
<p>See Cooch and White (2022) for an introduction to measurement of overdispersion 
in capture&ndash;recapture. The focus here is on overdispersion of activity centres 
relative to a Poisson distribution, rather than on non-independence in the 
spatial detection process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
nk(capthist)

Enk(D, mask, traps, detectfn = 0, detectpar = list(g0 = 0.2,
    sigma = 25, z = 1), noccasions = NULL, binomN = NULL,
    userdist = NULL, ncores = NULL, nrepl = NULL) 

chat.nk(object, nsim = NULL, ...)

adjustVarD(object, chatmin = 1, alpha = 0.05, chat = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chat_+3A_capthist">capthist</code></td>
<td>
<p>secr <code>capthist</code> object</p>
</td></tr>
<tr><td><code id="chat_+3A_d">D</code></td>
<td>
<p>numeric density, either scalar or vector of length nrow(mask)</p>
</td></tr>
<tr><td><code id="chat_+3A_mask">mask</code></td>
<td>
<p>single-session habitat mask</p>
</td></tr>
<tr><td><code id="chat_+3A_traps">traps</code></td>
<td>
 <p><code>traps</code> object </p>
</td></tr>
<tr><td><code id="chat_+3A_detectfn">detectfn</code></td>
<td>
<p> integer code for detection function q.v. </p>
</td></tr>
<tr><td><code id="chat_+3A_detectpar">detectpar</code></td>
<td>
<p> a named list giving a value for each parameter of detection function </p>
</td></tr>
<tr><td><code id="chat_+3A_noccasions">noccasions</code></td>
<td>
<p> number of sampling intervals (occasions) </p>
</td></tr>
<tr><td><code id="chat_+3A_binomn">binomN</code></td>
<td>
<p> integer code for discrete distribution (see
<code><a href="#topic+secr.fit">secr.fit</a></code>) </p>
</td></tr>
<tr><td><code id="chat_+3A_userdist">userdist</code></td>
<td>
<p>user-defined distance function or matrix (see <a href="#topic+userdist">userdist</a>)</p>
</td></tr>
<tr><td><code id="chat_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads</p>
</td></tr>
<tr><td><code id="chat_+3A_nrepl">nrepl</code></td>
<td>
<p>integer number of replicates for E(nk) by simulation (optional)</p>
</td></tr>
<tr><td><code id="chat_+3A_object">object</code></td>
<td>
<p>fitted secr model or dataframe (see Warnings for restrictions)</p>
</td></tr>
<tr><td><code id="chat_+3A_nsim">nsim</code></td>
<td>
<p>integer number of c-hat values to simulate (optional) </p>
</td></tr>
<tr><td><code id="chat_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+Fletcher.chat">Fletcher.chat</a></code> (verbose, type)</p>
</td></tr>
<tr><td><code id="chat_+3A_chatmin">chatmin</code></td>
<td>
<p>minimum value of Fletcher's <code class="reqn">\hat c</code></p>
</td></tr>
<tr><td><code id="chat_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="chat_+3A_chat">chat</code></td>
<td>
<p>numeric chat (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>traps</code> has a <a href="#topic+usage">usage</a> attribute then <code>noccasions</code> is
set accordingly; otherwise it must be provided.
</p>
<p>The environment variable RCPP_PARALLEL_NUM_THREADS determines the number of 
parallel threads. It is set to the value of <code>ncores</code>, unless that is NULL 
(see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>A conventional variance inflation factor due to Wedderburn (1974) is
<code class="reqn">\hat c_X = X^2/(K-p)</code> where <code class="reqn">K</code> is the number of detectors,  <code class="reqn">p</code> is the number of estimated parameters, and 
</p>
<p style="text-align: center;"><code class="reqn">X^2 = \sum_k (n_k - E (n_k))^2/  E(n_k).</code>
</p>
 
<p>Fletcher's <code class="reqn">\hat c</code> is an improvement on <code class="reqn">\hat c_X</code> that is less affected 
by small expected counts. It is defined by
</p>
<p style="text-align: center;"><code class="reqn">\hat c = c_X / (1+ \bar s),</code>
</p>
 
<p>where <code class="reqn">\bar s = \sum_k s_k / K</code> and <code class="reqn">s_k = (n_k - E(n_k)) / E(n_k)</code>.
</p>
<p><code>chat.nk</code> may be used to simulate <code class="reqn">\hat c</code> values under the given model (set nsim &gt; 0). The ... argument may include 'ncores = x' (x&gt;1) to specify parallel processing of simulations - the speed up is large on unix-like machines for which the cluster type of <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> is &quot;FORK&quot; rather than &quot;PSOCK&quot;. If 'ncores' is not provided then the value returned by <code>setNumThreads()</code> is used.
</p>
<p>No adjustment is made by <code>adjustVarD</code> when <code class="reqn">\hat c</code> is less than the 
minimum. <code>adjustVarD</code> by default computes Fletcher's &lsquo;chat&rsquo; using <code>chat.nk</code>, 
but a value may be provided.
</p>
<p>If chat has been computed separately and provided in the argument of that name, <code>adjustVarD</code> also accepts a single dataframe as the argument &lsquo;object&rsquo;; the dataframe should have row &lsquo;D&rsquo; and columns &lsquo;link&rsquo;, &lsquo;estimate&rsquo;, &lsquo;SE.estimate&rsquo; as in the output from <code><a href="#topic+predict.secr">predict.secr</a></code>.
</p>


<h3>Value</h3>

<p>For <code>nk</code>, a vector of observed counts, one for each detector in <code>traps(capthist)</code>.
</p>
<p>For <code>Enk</code>, a vector of expected counts, one for each detector in <code>traps</code>.
</p>
<p>For <code>chat.nk</code>, usually a list comprising &ndash;
</p>
<table>
<tr><td><code>expected.nk</code></td>
<td>
<p>expected number at each detector</p>
</td></tr> 
<tr><td><code>nk</code></td>
<td>
<p>observed number at each detector</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>vector of summary statistics: mean(expected.nk), var(expected.nk), mean(nk), var(nk), nu (=df), X2/nu</p>
</td></tr>
<tr><td><code>chat</code></td>
<td>
<p><code class="reqn">\hat c</code> (Fletcher or Wedderburn depending on &lsquo;type&rsquo;)</p>
</td></tr>
</table>
<p>There are two variations &ndash;
</p>
<p>If &lsquo;verbose = FALSE&rsquo; then only the numeric value of <code class="reqn">\hat c</code> is returned (a vector of 2 values if &lsquo;type = &quot;both&quot;&rsquo;).
</p>
<p>If <code>chat.nk</code> is called with &lsquo;nsim &gt; 0&rsquo; then the output is a list comprising &ndash;
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>sim.chat</code></td>
<td>
<p>vector of simulated <code class="reqn">\hat c</code></p>
</td></tr> 
<tr><td><code>chat</code></td>
<td>
<p><code class="reqn">\hat c</code> (Fletcher or Wedderburn depending on &lsquo;type&rsquo;)</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>probability of observing <code class="reqn">\hat c</code> as large as this (from rank of chat among sim.chat)</p>
</td></tr>
</table>
<p>For <code>adjustVarD</code>, a dataframe with one row for each session, based on <code><a href="#topic+predict.secr">predict.secr</a></code> or <code><a href="#topic+derived.secr">derived.secr</a></code>, with extra column &lsquo;c-hat&rsquo;.
</p>


<h3>Warning</h3>

<p>These functions are experimental in secr 4.6, and do not work with 
polygon-like and single-catch detectors. No allowance is made for modelled variation in 
detection parameters with respect to occasion, detector or animal; 
this includes mixture models (e.g., g0~h2).
</p>
<p>Versions before 4.5.11 did not correctly compute expected counts for multi-catch detectors. 
</p>
<p>Furthermore, we doubt that the adjustment actually solves the problem of 
overdispersion (Efford and Fletcher unpubl.).
</p>


<h3>References</h3>

<p>Bischof, R., P. Dupont, C. Milleret, J. Chipperfield, and J. A. Royle. 2020. Consequences of ignoring group association in spatial capture&ndash;recapture analysis. <em>Wildlife Biology</em> wlb.00649. DOI 10.2981/wlb.00649
</p>
<p>Cooch, E. and White, G. (eds) (2022) <em>Program MARK: A Gentle Introduction</em>. 
22nd edition. Available online at http://www.phidot.org/software/mark/docs/book/.
</p>
<p>Fletcher, D. (2012) Estimating overdispersion when fitting a generalized linear model to sparse data.
<em>Biometrika</em> <b>99</b>, 230&ndash;237.
</p>
<p>Wedderburn, R. W. M. (1974) Quasi-likelihood functions, generalized linear models, and the Gauss-Newton
method. <em>Biometrika</em> <b>61</b>, 439&ndash;47.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+secr">secr</a></code>, 
<code><a href="#topic+make.mask">make.mask</a></code>,
<code><a href="#topic+Detection+20functions">Detection functions</a></code>, 
<code><a href="#topic+Fletcher.chat">Fletcher.chat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  temptrap &lt;- make.grid()
  msk &lt;- make.mask(temptrap)
  ## expected number of individuals per detector (multi-catch) 
  Enk (D = 5, msk, temptrap, detectpar = list(g0 = 0.2, sigma = 25),
    noccasions = 5)



# useful plotting function for simulated chat (nsim&gt;0)
plotchat &lt;- function(chat, head = '', breaks = seq(0.5,2.5,0.05)) {
    hist(chat$sim.chat, xlim = range(breaks), main = head, xlab = 'c-hat',
        breaks = breaks, cex.main = 1, yaxs = 'i')
    abline(v = chat$chat, lwd = 1.5, col = 'blue')
}

</code></pre>

<hr>
<h2 id='circular'>
Circular Probability
</h2><span id='topic+circular.r'></span><span id='topic+circular.p'></span>

<h3>Description</h3>

<p>Functions to answer the question &quot;what radius is expected to include
proportion p of points from a circular bivariate distribution
corresponding to a given detection function&quot;, and the reverse. These
functions may be used to relate the scale parameter(s) of a detection
function (e.g., <code class="reqn">\sigma</code>) to home-range area (specifically, the area
within an activity contour for the corresponding simple home-range
model) (see Note).
</p>
<p>WARNING: the default behaviour of these functions changed in version
2.6.0. Integration is now performed on the cumulative hazard (exposure)
scale for all functions unless <code>hazard = FALSE</code>. Results will
differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
circular.r (p = 0.95, detectfn = 0, sigma = 1, detectpar = NULL, hazard
= TRUE, upper = Inf, ...) 

circular.p (r = 1, detectfn = 0, sigma = 1, detectpar = NULL, hazard
= TRUE, upper = Inf, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circular_+3A_p">p</code></td>
<td>
<p>vector of probability levels for which radius is required</p>
</td></tr>
<tr><td><code id="circular_+3A_r">r</code></td>
<td>
<p>vector of radii for which probability level is required</p>
</td></tr>
<tr><td><code id="circular_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of
detection function 0 = halfnormal, 2 = exponential etc. &ndash; see
<a href="#topic+detectfn">detectfn</a> for other codes</p>
</td></tr>
<tr><td><code id="circular_+3A_sigma">sigma</code></td>
<td>
<p>spatial scale parameter of detection function </p>
</td></tr>
<tr><td><code id="circular_+3A_detectpar">detectpar</code></td>
<td>
<p>named list of detection function parameters </p>
</td></tr>
<tr><td><code id="circular_+3A_hazard">hazard</code></td>
<td>
<p>logical; if TRUE the transformation <code class="reqn">-log(1-g(d))</code>
is applied before integration</p>
</td></tr>
<tr><td><code id="circular_+3A_upper">upper</code></td>
<td>
<p>numeric upper limit of integration</p>
</td></tr>
<tr><td><code id="circular_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="stats.html#topic+integrate">integrate</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>circular.r</code> is the quantile function of the specified circular
bivariate distribution (analogous to <code>qnorm</code>, for example). The
quantity calculated by <code>circular.r</code> is sometimes called 'circular
error probable' (see Note).
</p>
<p>For detection functions with two parameters (intercept and scale) it is
enough to provide <code>sigma</code>. Otherwise, <code>detectpar</code> should be a
named list including parameter values for the requested detection
function (g0 may be omitted, and order does not matter).
</p>
<p>Detection functions in <span class="pkg">secr</span> are expressed in terms of the decline
in probability of detection with distance <code class="reqn">g(d)</code>, and both
<code>circular.r</code> and <code>circular.p</code> integrate this function by
default. Rather than integrating <code class="reqn">g(d)</code> itself, it may be more
appropriate to integrate <code class="reqn">g(d)</code> transformed to a hazard i.e. <code class="reqn">1
- log(-g(d))</code>. This is selected with <code>hazard = TRUE</code>.
</p>
<p>Integration may also fail with the message &ldquo;roundoff error is detected in the extrapolation table&rdquo;. 
Setting <code>upper</code> to a large number less than infinity sometimes corrects this.
</p>


<h3>Value</h3>

<p>Vector of values for the required radii or probabilities.
</p>


<h3>Note</h3>

<p>The term &lsquo;circular error probable&rsquo; has a military origin. It is
commonly used for GPS accuracy with the default probability level set to
0.5 (i.e. half of locations are further than CEP from the true
location). A circular bivariate normal distriubution is commonly assumed
for the circular error probable; this is equivalent to setting
<code>detectfn = "halfnormal"</code>.
</p>
<p>Closed-form expressions are used for the normal and uniform cases; in
the circular bivariate normal case, the relationship is <code class="reqn">r =
\sigma \sqrt{-2\mbox{ln}(1-p)} </code>. Otherwise,
the probability is computed numerically by integrating the radial
distribution. Numerical integration is not foolproof, so check
suspicious or extreme values.
</p>
<p>When <code>circular.r</code> is used with the default <code>sigma = 1</code>, the result
may be interpreted as the factor by which sigma needs to be inflated to
include the desired proportion of activity (e.g., 2.45 sigma for 95%
of points from a circular bivariate normal distribution fitted on the hazard
scale (detectfn = 14) OR 2.24 sigma on the probability scale (detectfn = 0)).
</p>


<h3>References</h3>

 
<p>Calhoun, J. B. and Casby, J. U. (1958) Calculation of home range and
density of small mammals. Public Health Monograph No. 55. United States
Government Printing Office.
</p>
<p>Johnson, R. A. and Wichern, D. W. (1982) Applied multivariate
statistical analysis. Prentice-Hall, Englewood Cliffs, New Jersey, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+detectfn">detectfn</a></code>,  <code><a href="#topic+detectfnplot">detectfnplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Calhoun and Casby (1958) p 3.
## give p = 0.3940, 0.8645, 0.9888
circular.p(1:3, hazard = FALSE)

## halfnormal, hazard-rate and exponential
circular.r ()
circular.r (detectfn = "HR", detectpar = list(sigma = 1, z = 4))
circular.r (detectfn = "EX")
circular.r (detectfn = "HHN")
circular.r (detectfn = "HHR", detectpar = list(sigma = 1, z = 4))
circular.r (detectfn = "HEX")

plot(seq(0, 5, 0.05), circular.p(r = seq(0, 5, 0.05)),
    type = "l", xlab = "Radius (multiples of sigma)", ylab = "Probability")
lines(seq(0, 5, 0.05), circular.p(r = seq(0, 5, 0.05), detectfn = 2),
    type = "l", col = "red")
lines(seq(0, 5, 0.05), circular.p(r = seq(0, 5, 0.05), detectfn = 1,
    detectpar = list(sigma = 1,z = 4)), type = "l", col = "blue")
abline (h = 0.95, lty = 2)

legend (2.8, 0.3, legend = c("halfnormal","hazard-rate, z = 4", "exponential"),
    col = c("black","blue","red"), lty = rep(1,3))

## in this example, a more interesting comparison would use
## sigma = 0.58 for the exponential curve.

</code></pre>

<hr>
<h2 id='clone'>
Replicate Rows
</h2><span id='topic+clone'></span><span id='topic+clone.default'></span><span id='topic+clone.popn'></span><span id='topic+clone.capthist'></span>

<h3>Description</h3>

<p>Clone rows of an object a constant or random number of times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## Default S3 method:
clone(object, type, ...)
  ## S3 method for class 'popn'
clone(object, type, ...)
  ## S3 method for class 'capthist'
clone(object, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clone_+3A_object">object</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="clone_+3A_type">type</code></td>
<td>
<p>character &lsquo;constant&rsquo;, &lsquo;poisson&rsquo;,  &lsquo;truncatedpoisson&rsquo; or &lsquo;nbinom&rsquo;</p>
</td></tr>
<tr><td><code id="clone_+3A_...">...</code></td>
<td>
<p>other arguments for distribution function </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ... argument specifies the number of times each row should be
repeated. For random distributions (Poisson or negative binomial) ...
provides the required parameter values: <code>lambda</code> for Poisson,
<code>size, prob</code> or <code>size, mu</code> for negative binomial.
</p>
<p>One application is to derive a population of cues from a popn object,
where each animal in the original popn generates a number of cues from
the same point.
</p>
<p>Cloning a capthist object replicates whole detection
histories. Individual covariates and detection-specific attributes
(e.g., signal strength or xy location in polygon) are also
replicated. Cloned data from single-catch traps will cause verify() to
fail, but a model may still be fitted in <code>secr.fit</code> by overriding
the check with <code>verify = FALSE</code>.
</p>


<h3>Value</h3>

<p>Object of same class as <code>object</code> but with varying number of
rows. For <code>clone.popn</code> and <code>capthist</code> an attribute &lsquo;freq&rsquo; is
set, a vector of length equal to the original number of rows giving the
number of repeats (including zeros).
</p>
<p>If <code>popn</code> or <code>capthist</code> is a multi-session object the returned value will be
a multi-session object of the same length.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.popn">sim.popn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## population of animals at 1 / hectare generates random
## Poisson number of cues, lambda = 5
mics4 &lt;- make.grid( nx = 2, ny = 2, spacing = 44, detector = "signal")
pop &lt;- sim.popn (D = 1, core = mics4, buffer = 300, nsessions = 6)
pop &lt;- clone (pop, "poisson", 5)
attr(pop[[1]],"freq")

clone(captdata, "poisson", 3)

# To avoid losing any individuals use zero-truncated Poisson
# First find lambda of truncated Poisson with given mean
getlambda &lt;- function (target) {
    fn &lt;- function(x) x / (1-exp(-x)) - target
    uniroot(interval = c(1e-8, target), f = fn)$root
}
clone(captdata, "truncatedpoisson", getlambda(3))

</code></pre>

<hr>
<h2 id='closedN'>
Closed population estimates
</h2><span id='topic+closedN'></span>

<h3>Description</h3>

<p>Estimate N, the size of a closed population, by several conventional
non-spatial capture&ndash;recapture methods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
closedN(object, estimator = NULL, level = 0.95, maxN = 1e+07,
    dmax = 10 )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closedN_+3A_object">object</code></td>
<td>
 <p><code><a href="#topic+capthist">capthist</a></code> object </p>
</td></tr>
<tr><td><code id="closedN_+3A_estimator">estimator</code></td>
<td>
<p> character; name of estimator (see Details) </p>
</td></tr>
<tr><td><code id="closedN_+3A_level">level</code></td>
<td>
<p> confidence level (1 &ndash; alpha) </p>
</td></tr>
<tr><td><code id="closedN_+3A_maxn">maxN</code></td>
<td>
<p> upper bound for population size </p>
</td></tr>
<tr><td><code id="closedN_+3A_dmax">dmax</code></td>
<td>
<p> numeric, the maximum AIC difference for inclusion in confidence set</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Data are provided as spatial capture histories, but the spatial
information (trapping locations) is ignored.
</p>
<p>AIC-based model selection is available for the maximum-likelihood
estimators <code>null</code>, <code>zippin</code>, <code>darroch</code>, <code>h2</code>, and
<code>betabinomial</code>.
</p>
<p>Model weights are calculated as </p>
<p style="text-align: center;"><code class="reqn">w_i = \frac{\exp(-\Delta_i / 2)}{
  \sum{\exp(-\Delta_i / 2)}}</code>
</p>

<p>Models for which dAICc &gt; <code>dmax</code> are given a weight of zero and are
excluded from the summation, as are non-likelihood models.  
</p>
<p>Computation of <code>null</code>, <code>zippin</code> and <code>darroch</code> estimates
differs slightly from Otis et al. (1978) in that the likelihood is
maximized over real values of N between <code>Mt1</code> and <code>maxN</code>,
whereas Otis et al. considered only integer values.
</p>
<p>Asymmetric confidence intervals are obtained in the same way for all
estimators, using a log transformation of <code class="reqn">\hat{N}-Mt1</code>
following Burnham et al. (1987), Chao (1987) and Rexstad and Burnham
(1991).
</p>
<p>The available estimators are
</p>

<table>
<tr>
 <td style="text-align: left;">
  Name </td><td style="text-align: left;"> Model </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Reference </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>null</code> </td><td style="text-align: left;"> M0 </td><td style="text-align: left;"> null </td><td style="text-align: left;"> Otis et al. 1978 p.105 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>zippin</code> </td><td style="text-align: left;"> Mb </td><td style="text-align: left;"> removal </td><td style="text-align: left;"> Otis et al. 1978 p.108 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>darroch</code> </td><td style="text-align: left;"> Mt </td><td style="text-align: left;"> Darroch </td><td style="text-align: left;"> Otis et al. 1978 p.106-7 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>h2</code> </td><td style="text-align: left;"> Mh </td><td style="text-align: left;"> 2-part finite mixture </td><td style="text-align: left;"> Pledger 2000 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>betabinomial</code> </td><td style="text-align: left;"> Mh </td><td style="text-align: left;"> Beta-binomial continuous mixture </td><td style="text-align: left;">
  Dorazio and Royle 2003 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>jackknife</code> </td><td style="text-align: left;"> Mh </td><td style="text-align: left;"> jackknife </td><td style="text-align: left;">  Burnham and Overton 1978 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>chao</code> </td><td style="text-align: left;"> Mh </td><td style="text-align: left;"> Chao's Mh estimator </td><td style="text-align: left;"> Chao 1987 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>chaomod</code> </td><td style="text-align: left;"> Mh </td><td style="text-align: left;"> Chao's modified Mh estimator </td><td style="text-align: left;"> Chao 1987 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>chao.th1</code> </td><td style="text-align: left;"> Mth </td><td style="text-align: left;"> sample coverage estimator 1 </td><td style="text-align: left;"> Lee and Chao 1994 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>chao.th2</code> </td><td style="text-align: left;"> Mth </td><td style="text-align: left;"> sample coverage estimator 2 </td><td style="text-align: left;"> Lee and Chao 1994 </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Value</h3>

<p>A dataframe with one row per estimator and columns
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p> model in the sense of Otis et al. 1978</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p> number of parameters estimated</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p> maximized log likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p> Akaike's information criterion</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with small-sample adjustment of Hurvich &amp; Tsai (1989)</p>
</td></tr>
<tr><td><code>dAICc</code></td>
<td>
<p> difference between AICc of this model and the one with
smallest AICc</p>
</td></tr>
<tr><td><code>Mt1</code></td>
<td>
<p> number of distinct individuals caught</p>
</td></tr>
<tr><td><code>Nhat</code></td>
<td>
<p> estimate of population size</p>
</td></tr>
<tr><td><code>seNhat</code></td>
<td>
<p> estimated standard error of Nhat</p>
</td></tr>
<tr><td><code>lclNhat</code></td>
<td>
<p> lower 100 x level % confidence limit </p>
</td></tr>
<tr><td><code>uclNhat</code></td>
<td>
<p> upper 100 x level % confidence limit </p>
</td></tr>
</table>


<h3>Warning</h3>

<p>If your data are from spatial sampling (e.g. grid trapping) it is
recommended that you do <em>not</em> use these methods to estimate
population size (see Efford and Fewster 2013). Instead, fit a spatial model
and estimate population size with <code><a href="#topic+region.N">region.N</a></code>.
</p>


<h3>Note</h3>

<p>Prof. Anne Chao generously allowed me to adapt her code for the
variance of the &lsquo;chao.th1&rsquo; and &lsquo;chao.th2&rsquo; estimators.
</p>
<p>Chao's estimators have been subject to various improvements not
included here (e.g., Chao et al. 2016).
</p>


<h3>References</h3>

<p>Burnham, K. P. and Overton, W. S. (1978) Estimating the size of a closed
population when capture probabilities vary among
animals. <em>Biometrika</em> <b>65</b>, 625&ndash;633.
</p>
<p>Chao, A. (1987) Estimating the population size for capture&ndash;recapture
data with unequal catchability. <em>Biometrics</em> <b>43</b>, 783&ndash;791.
</p>
<p>Chao, A., Ma, K. H., Hsieh,  T. C. and Chiu, Chun-Huo (2016) SpadeR: Species-Richness Prediction and
Diversity Estimation with R. R package version 0.1.1. https://CRAN.R-project.org/package=SpadeR
</p>
<p>Dorazio, R. M. and Royle, J. A. (2003) Mixture models for estimating the
size of a closed population when capture rates vary among
individuals. <em>Biometrics</em> <b>59</b>, 351&ndash;364.
</p>
<p>Efford, M. G. and Fewster, R. M. (2013) Estimating population
size by spatially explicit capture&ndash;recapture. <em>Oikos</em>
<b>122</b>, 918&ndash;928.
</p>
<p>Hurvich, C. M. and Tsai, C. L. (1989) Regression and time series model
selection in small samples. <em>Biometrika</em> <b>76</b>, 297&ndash;307.
</p>
<p>Lee, S.-M. and Chao, A. (1994) Estimating population size via sample
coverage for closed capture-recapture models. <em>Biometrics</em>
<b>50</b>, 88&ndash;97.
</p>
<p>Otis, D. L., Burnham, K. P., White, G. C. and Anderson, D. R. (1978)
Statistical inference from capture data on closed animal
populations. <em>Wildlife Monographs</em> <b>62</b>, 1&ndash;135.
</p>
<p>Pledger, S. (2000) Unified maximum likelihood estimates for closed
capture-recapture models using mixtures. <em>Biometrics</em> <b>56</b>,
434&ndash;442.
</p>
<p>Rexstad, E. and Burnham, K. (1991) User's guide for interactive program
CAPTURE. Colorado Cooperative Fish and Wildlife Research Unit, Fort
Collins, Colorado, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>,
<code><a href="#topic+closure.test">closure.test</a></code>,
<code><a href="#topic+region.N">region.N</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>closedN(deermouse.ESG)
</code></pre>

<hr>
<h2 id='closure.test'>
Closure tests
</h2><span id='topic+closure.test'></span>

<h3>Description</h3>

<p>Perform tests to determine whether a population sampled by
capture-recapture is closed to gains and losses over the period of sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
closure.test(object, SB = FALSE, min.expected = 2)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closure.test_+3A_object">object</code></td>
<td>
<p><code>capthist</code> object</p>
</td></tr>
<tr><td><code id="closure.test_+3A_sb">SB</code></td>
<td>
<p>logical, if TRUE then test of Stanley and Burnham 1999 is
calculated in addition to that of Otis et al. 1978</p>
</td></tr>
<tr><td><code id="closure.test_+3A_min.expected">min.expected</code></td>
<td>
<p>integer for the minimum expected count in any cell of a component 2x2 table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test of Stanley and Burnham in part uses a sum over 2x2 contingency
tables; any table with a cell whose expected count is less than
min.expected is dropped from the sum. The default value of 2 is that
used by CloseTest (Stanley and Richards 2005, T. Stanley pers. comm.;
see also Stanley and Burnham 1999 p. 203).
</p>


<h3>Value</h3>

<p>In the case of a single-session capthist object, either a vector with
the statistic (z-value) and p-value for the test of Otis et al. (1978
p. 120) or a list whose components are data frames with the statistics
and p-values for various tests and test components as follows &ndash;
</p>
<table>
<tr><td><code>Otis</code></td>
<td>
<p>Test of Otis et al. 1978</p>
</td></tr>
<tr><td><code>Xc</code></td>
<td>
<p>Overall test of Stanley and Burnham 1999</p>
</td></tr>
<tr><td><code>NRvsJS</code></td>
<td>
<p>Stanley and Burnham 1999</p>
</td></tr>
<tr><td><code>NMvsJS</code></td>
<td>
<p>Stanley and Burnham 1999</p>
</td></tr>
<tr><td><code>MtvsNR</code></td>
<td>
<p>Stanley and Burnham 1999</p>
</td></tr>
<tr><td><code>MtvsNM</code></td>
<td>
<p>Stanley and Burnham 1999</p>
</td></tr>
<tr><td><code>compNRvsJS</code></td>
<td>
<p>Occasion-specific components of NRvsJS</p>
</td></tr>
<tr><td><code>compNMvsJS</code></td>
<td>
<p>Occasion-specific components of NMvsJS</p>
</td></tr>
</table>
<p>Check the original papers for an explanation of the components of the Stanley and Burnham test.
</p>
<p>In the case of a multi-session object, a list with one component (as
above) for each session.
</p>


<h3>Note</h3>

<p>No omnibus test exists for closure: the existing tests may indicate
nonclosure even when a population is closed if other effects such as
trap response are present (see White et al. 1982 pp 96&ndash;97). The test of
Stanley and Burnham is sensitive to individual heterogeneity which is
inevitable in most spatial sampling, and it should not in general be
used for this sort of data.
</p>


<h3>References</h3>

<p>Otis, D. L., Burnham, K. P., White, G. C. and Anderson, D. R. (1978)
Statistical inference from capture data on closed animal
populations. <em>Wildlife Monographs</em> <b>62</b>, 1&ndash;135.
</p>
<p>Stanley, T. R. and Burnham, K. P. (1999) A closure test for
time-specific capture&ndash;recapture data. <em>Environmental and
Ecological Statistics</em> <b>6</b>, 197&ndash;209.
</p>
<p>Stanley, T. R. and Richards, J. D. (2005) A program for testing
capture&ndash;recapture data for closure. <em>Wildlife Society Bulletin</em>
<b>33</b>, 782&ndash;785.
</p>
<p>White, G. C., Anderson, D. R., Burnham, K. P. and Otis, D. L. (1982)
<em>Capture-recapture and removal methods for sampling closed
populations</em>. Los Alamos National Laboratory, Los Alamos, New Mexico.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> closure.test(captdata)
</code></pre>

<hr>
<h2 id='cluster'> Detector Clustering </h2><span id='topic+cluster'></span><span id='topic+clusterID'></span><span id='topic+clustertrap'></span><span id='topic+clusterID+3C-'></span><span id='topic+clustertrap+3C-'></span>

<h3>Description</h3>

<p>Clusters are uniform groups of detectors. Use these functions to
extract or replace cluster information of a <code>traps</code> object, or
extract cluster information for each detection in a <code>capthist</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterID(object)
clusterID(object) &lt;- value
clustertrap(object)
clustertrap(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_object">object</code></td>
<td>
 <p><code>traps</code> or <code>capthist</code> object </p>
</td></tr>
<tr><td><code id="cluster_+3A_value">value</code></td>
<td>
<p> factor (<code>clusterID</code>) or integer-valued vector
(<code>clustertrap</code>) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Easy access to attributes used to define compound designs, those in
which a detector array comprises several similar subunits
(&lsquo;clusters&rsquo;). &lsquo;clusterID&rsquo; identifies the detectors belonging to each
cluster, and &lsquo;clustertrap&rsquo; is a numeric index used to relate matching
detectors in different clusters.
</p>
<p>For replacement (&lsquo;traps&rsquo; only), the number of rows of <code>value</code>
must match exactly the number of detectors in <code>object</code>.
</p>
<p>&lsquo;clusterID&rsquo; and &lsquo;clustertrap&rsquo; are assigned automatically by
<code><a href="#topic+trap.builder">trap.builder</a></code>.
</p>


<h3>Value</h3>

<p>Factor (<code>clusterID</code>) or integer-valued vector
(<code>clustertrap</code>).
</p>
<p><code>clusterID(object)</code> may be NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+traps">traps</a></code>, <code><a href="#topic+trap.builder">trap.builder</a></code>, <code><a href="#topic+mash">mash</a></code>,
<code><a href="#topic+derivedCluster">derivedCluster</a></code>, <code><a href="#topic+cluster.counts">cluster.counts</a></code>,
<code><a href="#topic+cluster.centres">cluster.centres</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 25 4-detector clusters
mini &lt;- make.grid(nx = 2, ny = 2)
tempgrid &lt;- trap.builder (cluster = mini , method = "all",
    frame = expand.grid(x = seq(100, 500, 100), y = seq(100,
    500, 100)))
clusterID(tempgrid)
clustertrap(tempgrid)

tempCH &lt;- sim.capthist(tempgrid)
table(clusterID(tempCH)) ## detections per cluster
cluster.counts(tempCH)   ## distinct individuals

</code></pre>

<hr>
<h2 id='coef.secr'> Coefficients of secr Object </h2><span id='topic+coef.secr'></span>

<h3>Description</h3>

<p>Extract coefficients (estimated beta parameters) from a spatially
explicit capture&ndash;recapture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'secr'
 coef(object, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.secr_+3A_object">object</code></td>
<td>
 <p><code>secr</code> object output from <code>secr.fit</code> </p>
</td></tr>
<tr><td><code id="coef.secr_+3A_alpha">alpha</code></td>
<td>
<p> alpha level </p>
</td></tr>
<tr><td><code id="coef.secr_+3A_...">...</code></td>
<td>
<p> other arguments (not used currently) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per beta parameter and columns for the
coefficient, SE(coefficient), asymptotic lower and upper 100(1&ndash;alpha)
confidence limits.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+esa.plot">esa.plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load &amp; extract coefficients of previously fitted null model
coef(secrdemo.0)

</code></pre>

<hr>
<h2 id='collate'> Array of Parameter Estimates </h2><span id='topic+collate'></span><span id='topic+collate.secr'></span><span id='topic+collate.ipsecr'></span><span id='topic+collate.secrlist'></span>

<h3>Description</h3>

<p>Estimates from one or more openCR models are formed into an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secr'
collate(object, ..., realnames = NULL, betanames = NULL, newdata = NULL, 
    alpha = 0.05, perm = 1:4, fields = 1:4)

## S3 method for class 'ipsecr'
collate(object, ..., realnames = NULL, betanames = NULL, newdata = NULL, 
    alpha = 0.05, perm = 1:4, fields = 1:4)

## S3 method for class 'secrlist'
collate(object, ..., realnames = NULL, betanames = NULL, newdata = NULL, 
    alpha = 0.05, perm = 1:4, fields = 1:4)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collate_+3A_object">object</code></td>
<td>
<p>secr or secrlist object</p>
</td></tr>
<tr><td><code id="collate_+3A_...">...</code></td>
<td>
<p>other secr objects </p>
</td></tr> 
<tr><td><code id="collate_+3A_realnames">realnames</code></td>
<td>
<p> character vector of real parameter names </p>
</td></tr>
<tr><td><code id="collate_+3A_betanames">betanames</code></td>
<td>
<p> character vector of beta parameter names </p>
</td></tr>
<tr><td><code id="collate_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate models </p>
</td></tr>
<tr><td><code id="collate_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="collate_+3A_perm">perm</code></td>
<td>
<p> permutation of dimensions in output from <code>collate</code> </p>
</td></tr>
<tr><td><code id="collate_+3A_fields">fields</code></td>
<td>
<p> vector to restrict summary fields in output </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>collate</code> extracts parameter estimates from a set of fitted secr
model objects. 
</p>
<p><code>fields</code> may be used to select a subset of summary
fields (&quot;estimate&quot;,&quot;SE.estimate&quot;,&quot;lcl&quot;,&quot;ucl&quot;) by name or number. 
</p>


<h3>Value</h3>

<p>A 4-dimensional array of model-specific parameter estimates. By default, 
the dimensions correspond respectively to 
</p>

<ul>
<li><p> rows in <code>newdata</code> (usually sessions),
</p>
</li>
<li><p> models,
</p>
</li>
<li><p> statistic fields (estimate, SE.estimate, lcl, ucl), and 
</p>
</li>
<li><p> parameters (&quot;phi&quot;, &quot;sigma&quot; etc.).
</p>
</li></ul>

<p>It often helps to reorder the dimensions with the <code>perm</code> argument.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+modelAverage">modelAverage</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
collate (secrdemo.0, secrdemo.b, perm = c(4,2,3,1))[,,1,]

</code></pre>

<hr>
<h2 id='confint.secr'> Profile Likelihood Confidence Intervals </h2><span id='topic+confint.secr'></span>

<h3>Description</h3>

<p>Compute profile likelihood confidence intervals for &lsquo;beta&rsquo; or &lsquo;real&rsquo; parameters of a
spatially explicit capture-recapture model,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secr'
 confint(object, parm, level = 0.95, newdata = NULL,
tracelevel = 1, tol = 0.0001, bounds = NULL, ncores = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.secr_+3A_object">object</code></td>
<td>
 <p><code>secr</code> model object </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_parm">parm</code></td>
<td>
<p> numeric or character vector of parameters </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_level">level</code></td>
<td>
<p> confidence level (1 &ndash; alpha) </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate model </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_tracelevel">tracelevel</code></td>
<td>
<p> integer for level of detail in reporting (0,1,2) </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_tol">tol</code></td>
<td>
<p> absolute tolerance (passed to <a href="stats.html#topic+uniroot">uniroot</a>) </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_bounds">bounds</code></td>
<td>
<p> numeric vector of outer starting values &ndash; optional </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_ncores">ncores</code></td>
<td>
<p> number of threads used for parallel processing </p>
</td></tr>
<tr><td><code id="confint.secr_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>parm</code> is numeric its elements are interpreted as the indices of
&lsquo;beta&rsquo; parameters; character values are interpreted as &lsquo;real&rsquo;
parameters. Different methods are used for beta parameters and real
parameters. Limits for the <code class="reqn">j</code>-th beta parameter are found by a
numerical search for the value satisfying <code class="reqn">-2(l_j(\beta_j) - l) =
q</code>, where <code class="reqn">l</code> is the maximized log
likelihood, <code class="reqn">l_j(\beta_j)</code> is the maximized profile log
likelihood with <code class="reqn">\beta_j</code> fixed, and <code class="reqn">q</code> is the
<code class="reqn">100(1-\alpha)</code> quantile of the
<code class="reqn">\chi^2</code> distribution with one degree of freedom. Limits
for real parameters use the method of Lagrange multipliers (Fletcher and
Faddy 2007), except that limits for constant real parameters are
backtransformed from the limits for the relevant beta parameter.
</p>
<p>If <code>bounds</code> is provided it should be a 2-vector or matrix of 2
columns and length(parm) rows.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>


<h3>Value</h3>

 
<p>A matrix with one row for each parameter in <code>parm</code>, and columns
giving the lower (lcl) and upper (ucl) 100*<code>level</code>
</p>


<h3>Note</h3>

<p>Calculation may take a long time, so probably you will do it
only after selecting a final model. 
</p>
<p>The <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+uniroot">uniroot</a></code> is used to search for the roots of
<code class="reqn">-2(l_j(\beta_j) - l) = q</code> within a
suitable interval. The interval is anchored at one end by the MLE, and
at the other end by the MLE inflated by a small multiple of the
asymptotic standard error (1, 2, 4 or 8 SE are tried in turn, using the
smallest for which the interval includes a valid solution). 
</p>
<p>A more efficient algorithm was proposed by Venzon and Moolgavkar (1988);
it has yet to be implemented in <span class="pkg">secr</span>, but see <code>plkhci</code> in
the package <span class="pkg">Bhat</span> for another <span class="rlang"><b>R</b></span> implementation.
</p>


<h3>References</h3>

 
<p>Evans, M. A., Kim, H.-M. and O'Brien, T. E. (1996) An application of
profile-likelihood based confidence interval to capture&ndash;recapture
estimators. <em>Journal of Agricultural, Biological and Experimental
Statistics</em> <b>1</b>, 131&ndash;140.
</p>
<p>Fletcher, D. and Faddy, M. (2007) Confidence intervals for expected
abundance of rare species. <em>Journal of Agricultural, Biological and
Experimental Statistics</em> <b>12</b>, 315&ndash;324.
</p>
<p>Venzon, D. J. and Moolgavkar, S. H. (1988) A method for computing
profile-likelihood-based confidence intervals. <em>Applied Statistics</em>
<b>37</b>, 87&ndash;94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Limits for the constant real parameter "D"
confint(secrdemo.0, "D")   


## End(Not run)

</code></pre>

<hr>
<h2 id='contour'>
Contour Detection Probability
</h2><span id='topic+pdot.contour'></span><span id='topic+buffer.contour'></span>

<h3>Description</h3>

<p>Display contours of the net probability of detection p.(X), or the
area within a specified distance of detectors.  <code>buffer.contour</code>
adds a conventional &lsquo;boundary strip&rsquo; to a detector (trap) array, where
<code>buffer</code> equals the strip width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pdot.contour(traps, border = NULL, nx = 64, detectfn = 0,
    detectpar = list(g0 = 0.2, sigma = 25, z = 1), noccasions = NULL,
    binomN = NULL, levels = seq(0.1, 0.9, 0.1), poly =
    NULL, poly.habitat = TRUE, plt = TRUE, add = FALSE, fill = NULL, ...)

buffer.contour(traps, buffer, nx = 64, convex = FALSE, ntheta = 100,
     plt = TRUE, add = FALSE, poly = NULL, poly.habitat = TRUE, 
     fill = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour_+3A_traps">traps</code></td>
<td>
 <p><code>traps</code> object (or mask for <code>buffer.contour</code>) </p>
</td></tr>
<tr><td><code id="contour_+3A_border">border</code></td>
<td>
<p> width of blank margin around the outermost detectors </p>
</td></tr>
<tr><td><code id="contour_+3A_nx">nx</code></td>
<td>
<p> dimension of interpolation grid in x-direction </p>
</td></tr>
<tr><td><code id="contour_+3A_detectfn">detectfn</code></td>
<td>
<p> integer code or character string for shape of
detection function 0 = halfnormal etc. &ndash; see <a href="#topic+detectfn">detectfn</a></p>
</td></tr> 
<tr><td><code id="contour_+3A_detectpar">detectpar</code></td>
<td>
<p> list of values for named parameters of detection
function </p>
</td></tr>
<tr><td><code id="contour_+3A_noccasions">noccasions</code></td>
<td>
<p> number of sampling occasions</p>
</td></tr>
<tr><td><code id="contour_+3A_binomn">binomN</code></td>
<td>
<p> integer code for discrete distribution (see
<code><a href="#topic+secr.fit">secr.fit</a></code>) </p>
</td></tr>
<tr><td><code id="contour_+3A_levels">levels</code></td>
<td>
<p> vector of levels for p.(X)</p>
</td></tr>
<tr><td><code id="contour_+3A_poly">poly</code></td>
<td>
<p> matrix of two columns, the x and y
coordinates of a bounding polygon (optional) </p>
</td></tr>
<tr><td><code id="contour_+3A_poly.habitat">poly.habitat</code></td>
<td>
<p> logical as in <code><a href="#topic+make.mask">make.mask</a></code> </p>
</td></tr>
<tr><td><code id="contour_+3A_plt">plt</code></td>
<td>
<p> logical to plot contours </p>
</td></tr>
<tr><td><code id="contour_+3A_add">add</code></td>
<td>
<p> logical to add contour(s) to an existing plot </p>
</td></tr>
<tr><td><code id="contour_+3A_fill">fill</code></td>
<td>
<p> vector of colours to fill contours (optional)</p>
</td></tr>
<tr><td><code id="contour_+3A_...">...</code></td>
<td>
<p> other arguments to pass to <code>contour</code> </p>
</td></tr>
<tr><td><code id="contour_+3A_buffer">buffer</code></td>
<td>
<p> vector of buffer widths </p>
</td></tr>
<tr><td><code id="contour_+3A_convex">convex</code></td>
<td>
<p> logical, if TRUE the plotted contour(s) will be convex </p>
</td></tr>
<tr><td><code id="contour_+3A_ntheta">ntheta</code></td>
<td>
<p> integer value for smoothness of convex contours </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pdot.contour</code> constructs a rectangular mask and applies <code><a href="#topic+pdot">pdot</a></code> to
compute the p.(X) at each mask point.
</p>
<p>If <code>convex = FALSE</code>, <code>buffer.contour</code> constructs a mask and
contours the points on the basis of distance to the nearest detector at the
levels given in <code>buffer</code>.
</p>
<p>If <code>convex = TRUE</code>, <code>buffer.contour</code> constructs a set of
potential vertices by adding points on a circle of radius =
<code>buffer</code> to each detector location; the desired contour is the
convex hull of these points (this algorithm derives from Efford, 2012).
</p>
<p>If <code>traps</code> has a <a href="#topic+usage">usage</a> attribute then <code>noccasions</code> is
set accordingly; otherwise it must be provided.
</p>
<p>If <code>traps</code> is for multiple sessions then detectpar should be a list
of the same length, one component per session, and noccasions may be a
numeric vector of the same length.
</p>
<p>Increase <code>nx</code> for smoother lines, at the expense of speed.
</p>


<h3>Value</h3>

<p>Coordinates of the plotted contours are returned as a list with one
component per polygon. The list is returned invisibly if <code>plt =
    TRUE</code>.
</p>
<p>For multi-session input (<code>traps</code>) the value is a list of such
lists, one per session.
</p>


<h3>Note</h3>

<p>The precision (smoothness) of the fitted line in <code>buffer.contour</code>
is controlled by <code>ntheta</code> rather than <code>nx</code> when <code>convex
    = TRUE</code>.
</p>
<p>To suppress contour labels, include the argument <code>drawlabels =
  FALSE</code> (this will be passed via ... to <code>contour</code>). Other useful
arguments of <code>contour</code> are <code>col</code> (colour of contour lines)
and <code>lwd</code> (line width).
</p>
<p>You may wish to consider function st_buffer in package <span class="pkg">sf</span> as an
alternative to <code>buffer.contour</code>..
</p>
<p><code>buffer.contour</code> failed with multi-session <code>traps</code> before
<span class="pkg">secr</span> 2.8.0.
</p>


<h3>References</h3>

<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially
explicit capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand
<a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdot">pdot</a></code>, <code><a href="#topic+make.mask">make.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
possumtraps &lt;- traps(possumCH)

## convex and concave buffers
plot(possumtraps, border = 270)
buffer.contour(possumtraps, buffer = 100, add = TRUE, col = "blue")
buffer.contour(possumtraps, buffer = 100, convex = TRUE, add = TRUE)

## areas
buff.concave &lt;- buffer.contour(possumtraps, buffer = 100,
    plt = FALSE)
buff.convex  &lt;- buffer.contour(possumtraps, buffer = 100,
    plt = FALSE, convex = TRUE)
sum (sapply(buff.concave, polyarea)) ## sum over parts
sapply(buff.convex, polyarea)

## effect of nx on area
buff.concave2 &lt;- buffer.contour(possumtraps, buffer = 100,
    nx = 128, plt = FALSE)
sum (sapply(buff.concave2, polyarea))

## Not run: 

plot(possumtraps, border = 270)
pdot.contour(possumtraps, detectfn = 0, nx = 128, detectpar =
    detectpar(possum.model.0), levels = c(0.1, 0.01, 0.001),
    noccasions = 5, add = TRUE)

## clipping to polygon
olddir &lt;- setwd(system.file("extdata", package = "secr"))
possumtraps &lt;- traps(possumCH)
possumarea &lt;- read.table("possumarea.txt", header = TRUE)
par(xpd = TRUE, mar = c(1,6,6,6))
plot(possumtraps, border = 400, gridlines = FALSE)
pdot.contour(possumtraps, detectfn = 0, nx = 256, detectpar =
    detectpar(possum.model.0), levels = c(0.1, 0.01, 0.001),
    noccasions = 5, add = TRUE, poly = possumarea, col = "blue")
lines(possumarea)
setwd(olddir)
par(xpd = FALSE, mar = c(5,4,4,2) + 0.1)    ## reset to default


## End(Not run)

</code></pre>

<hr>
<h2 id='covariates'> Covariates Attribute </h2><span id='topic+covariates'></span><span id='topic+covariates+3C-'></span>

<h3>Description</h3>

<p>Extract or replace covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariates(object, ...)
covariates(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariates_+3A_object">object</code></td>
<td>
<p> an object of class <code>traps</code>, <code>popn</code>, <code>capthist</code>, or <code>mask</code> </p>
</td></tr>
<tr><td><code id="covariates_+3A_value">value</code></td>
<td>
<p> a dataframe of covariates </p>
</td></tr>
<tr><td><code id="covariates_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For replacement, the number of rows of <code>value</code> must match exactly the number of rows in <code>object</code>.
</p>


<h3>Value</h3>

<p>covariates(object) returns the dataframe of covariates associated with
<code>object</code>. <code>covariates(object)</code> may be NULL.
</p>
<p>Individual covariates are stored in the &lsquo;covariates&rsquo; attribute of a
<code>capthist</code> object.
</p>
<p>Covariates used for modelling density are stored in the &lsquo;covariates&rsquo;
attribute of a <code>mask</code> object.
</p>
<p>Detector covariates may vary between sampling occasions. In this case,
columns in the detector covariates data.frame are associated with
particular times; the matching is controlled by the
<code><a href="#topic+timevaryingcov">timevaryingcov</a></code> attribute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timevaryingcov">timevaryingcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## detector covariates
temptrap &lt;- make.grid(nx = 6, ny = 8)
covariates (temptrap) &lt;- data.frame(halfnhalf = 
    factor(rep(c("left","right"),c(24,24))) )
summary(covariates(temptrap))
</code></pre>

<hr>
<h2 id='CV'> Coefficient of Variation </h2><span id='topic+CV'></span><span id='topic+CVa'></span><span id='topic+CVa0'></span>

<h3>Description</h3>

<p>The coefficient of variation of effective sampling area predicts the
bias in estimated density (Efford and Mowat 2014). These functions
assist its calculation from fitted finite mixture models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
CV(x, p, na.rm = FALSE)
CVa0(object, ...)
CVa(object, sessnum = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CV_+3A_x">x</code></td>
<td>
<p>vector of numeric values </p>
</td></tr>
<tr><td><code id="CV_+3A_p">p</code></td>
<td>
<p>vector of class probabilities</p>
</td></tr>
<tr><td><code id="CV_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if TRUE missing values are dropped from x</p>
</td></tr>
<tr><td><code id="CV_+3A_object">object</code></td>
<td>
<p>fitted secr finite mixture model</p>
</td></tr>
<tr><td><code id="CV_+3A_sessnum">sessnum</code></td>
<td>
<p>integer sequence number of session to analyse </p>
</td></tr>
<tr><td><code id="CV_+3A_...">...</code></td>
<td>
<p>other arguments passed to predict.secr (e.g.,
<code>newdata</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CV</code> computes the coefficient of variation of <code>x</code>. If
<code>p</code> is provided then the distribution is assumed to be
discrete, with support <code>x</code> and class membership probabilities
<code>p</code> (scaled automatically to sum to 1.0).
</p>
<p><code>CVa</code> computes CV(<code class="reqn">a</code>) where <code class="reqn">a</code> is the effective
sampling area of Borchers and Efford (2008).
</p>
<p><code>CVa0</code> computes CV(a0) where a0 is the single-detector sampling
area defined as <code class="reqn">a_0 = 2 \pi \lambda_0 \sigma^2</code> (Efford and Mowat 2014); a0 is a convenient
surrogate for <em>a</em>, the effective sampling area. CV(a0) uses
either the fitted MLE of a0 (if the a0 parameterization has been
used), or a0 computed from the estimates of lambda0 and sigma.
</p>
<p><code>CVa</code> and <code>CVa0</code> do not work for models with individual
covariates.
</p>


<h3>Value</h3>

<p>Numeric
</p>


<h3>Note</h3>

<p>Do not confuse the function CVa with the estimated relative standard
error of the estimate of a from <code><a href="#topic+derived">derived</a></code>, also labelled CVa
in the output. The relative standard error RSE is often labelled CV
in the literature on capture&ndash;recapture, but this can cause unnecessary 
confusion. See also <code><a href="#topic+RSE">RSE</a></code>.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G. and Mowat, G. (2014) Compensatory heterogeneity in
capture&ndash;recapture data. <em>Ecology</em> <b>95</b>, 1341&ndash;1348.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CVpdot">CVpdot</a></code>, 
<code><a href="#topic+derived">derived</a></code>, 
<code><a href="#topic+details">details</a></code>, 
<code><a href="#topic+RSE">RSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## housemouse model
morning &lt;- subset(housemouse, occ = c(1,3,5,7,9))
msk &lt;- make.mask((traps(morning)), nx = 32) 
morning.h2   &lt;- secr.fit(morning, buffer = 20, model = list(g0~h2), mask = msk, 
    trace = FALSE)
CVa0(morning.h2 )


## End(Not run)

</code></pre>

<hr>
<h2 id='D.designdata'> Construct Density Design Data </h2><span id='topic+D.designdata'></span>

<h3>Description</h3>

<p>Internal function used by <code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+confint.secr">confint.secr</a></code>, and <code><a href="#topic+score.test">score.test</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.designdata (mask, Dmodel, grouplevels, sessionlevels, sessioncov =
NULL, meanSD = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D.designdata_+3A_mask">mask</code></td>
<td>
 <p><code><a href="#topic+mask">mask</a></code> object.</p>
</td></tr>
<tr><td><code id="D.designdata_+3A_dmodel">Dmodel</code></td>
<td>
<p> formula for density model </p>
</td></tr>
<tr><td><code id="D.designdata_+3A_grouplevels">grouplevels</code></td>
<td>
<p> vector of group names </p>
</td></tr>
<tr><td><code id="D.designdata_+3A_sessionlevels">sessionlevels</code></td>
<td>
<p> vector of character values for session names </p>
</td></tr>
<tr><td><code id="D.designdata_+3A_sessioncov">sessioncov</code></td>
<td>
<p> optional dataframe of values of session-specific
covariate(s). </p>
</td></tr>
<tr><td><code id="D.designdata_+3A_meansd">meanSD</code></td>
<td>
<p>optional external values for scaling x- and
y- coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal <span class="pkg">secr</span> function that you are unlikely ever to
use. Unlike <code><a href="#topic+secr.design.MS">secr.design.MS</a></code>, this function does <em>not</em>
call <code>model.matrix</code>.
</p>


<h3>Value</h3>

<p>Dataframe with one row for each combination of mask point, group and
session. Conceptually, we use a 3-D rectangular array with enough rows
to accommodate the largest mask, so some rows in the output may merely
hold space to enable easy indexing. The dataframe has an attribute
&lsquo;dimD&rsquo; that gives the relevant dimensions: <code> attr(dframe, "dimD") =
c(nmask, ngrp, R)</code>, where <code>nmask</code> is the number of mask points,
<code>ngrp</code> is the number of groups, and <code>R</code> is the number of
sessions. Columns correspond to predictor variables in Dmodel.
</p>
<p>The number of valid rows (points in each session-specific mask) is
stored in the attribute &lsquo;validMaskRows&rsquo;.
</p>
<p>For a single-session mask, <code>meanSD</code> is a 2 x 2 matrix of mean and
SD (rows) for x- and y-coordinates. For a multi-session mask, a list of
such objects. Ordinarily these values are from the meanSD attribute of
the mask, but they must be specified when applying a new mask to an
existing model.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+secr.design.MS">secr.design.MS</a></code> </p>

<hr>
<h2 id='deermouse'> Deermouse Live-trapping Datasets </h2><span id='topic+deermouse'></span><span id='topic+deermouse.ESG'></span><span id='topic+deermouse.WSG'></span>

<h3>Description</h3>

<p>Data of V. H. Reid from live trapping of deermice (<em>Peromyscus
maniculatus</em>) at two sites in Colorado, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
deermouse.ESG
deermouse.WSG

</code></pre>


<h3>Details</h3>

<p>Two datasets of V. H. Reid were described by Otis et al. (1978) and
distributed with their CAPTURE software (now available from
<a href="https://www.mbr-pwrc.usgs.gov/software.html">https://www.mbr-pwrc.usgs.gov/software.html</a>). They have been used in
several other papers on closed population methods (e.g., Huggins 1991,
Stanley and Richards 2005). This description is based on pages 32 and
87&ndash;93 of Otis et al. (1978).
</p>
<p>Both datasets are from studies in Rio Blanco County, Colorado, in the
summer of 1975. Trapping was for 6 consecutive nights. Traps were
arranged in a 9 x 11 grid and spaced 50 feet (15.2 m) apart.
</p>
<p>The first dataset was described by Otis et al. (1978: 32) as from 'a
drainage bottom of sagebrush, gambel oak, and serviceberry with pinyon
pine and juniper on the uplands'. By matching with the &lsquo;examples&rsquo; file
of CAPTURE this was from East Stuart Gulch (ESG).
</p>
<p>The second dataset (Otis et al. 1978: 87) was from Wet Swizer Creek or
Gulch (WSG) in August 1975. No specific vegetation description is given
for this site, but it is stated that Sherman traps were used and
trapping was done twice daily.
</p>
<p>Two minor inconsistencies should be noted. Although Otis et al. (1978)
said they used data from morning trap clearances, the capture histories
in &lsquo;examples&rsquo; from CAPTURE include a &lsquo;pm&rsquo; tag on each record. We
assume the error was in the text description, as their numerical results
can be reproduced from the data file. Huggins (1991) reproduced the East
Stuart Gulch dataset (omitting spatial data that were not relevant to his
method), but omitted two capture histories.
</p>
<p>The data are provided as two single-session <code>capthist</code> objects
&lsquo;deermouse.ESG&rsquo; and &lsquo;deermouse.WSG&rsquo;. Each has a dataframe of individual
covariates, but the fields differ between the two study areas. The
individual covariates of deermouse.ESG are sex (factor levels &lsquo;f&rsquo;, &lsquo;m&rsquo;),
age class (factor levels &lsquo;y&rsquo;, &lsquo;sa&rsquo;, &lsquo;a&rsquo;) and body weight in grams. The
individual covariates of deermouse.WSG are sex (factor levels &lsquo;f&rsquo;,&lsquo;m&rsquo;)
and age class (factor levels &lsquo;j&rsquo;, &lsquo;y&rsquo;, &lsquo;sa&rsquo;, &lsquo;a&rsquo;) (no data on body
weight). The aging criteria used by Reid are not recorded.
</p>
<p>The datasets were originally in the CAPTURE &lsquo;xy complete&rsquo; format which
for each detection gives the &lsquo;column&rsquo; and &lsquo;row&rsquo; numbers of the trap
(e.g. &lsquo; 9 5&rsquo; for a capture in the trap at position (x=9, y=5) on the
grid). Trap identifiers have been recoded as strings with no spaces by
inserting zeros (e.g. &lsquo;905&rsquo; in this example).
</p>
<p>Sherman traps are designed to capture one animal at a time, but the data
include double captures (1 at ESG and 8 at WSG &ndash; see Examples). The true
detector type therefore falls between &lsquo;single&rsquo; and &lsquo;multi&rsquo;. Detector
type is set to &lsquo;multi&rsquo; in the distributed data objects.
</p>

<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
 deermouse.ESG </td><td style="text-align: left;"> capthist object, East Stuart Gulch </td>
</tr>
<tr>
 <td style="text-align: left;">
 deermouse.WSG </td><td style="text-align: left;"> capthist object, Wet Swizer Gulch </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>File &lsquo;examples&rsquo; distributed with program CAPTURE.
</p>


<h3>References</h3>

<p>Huggins, R. M. (1991) Some practical aspects of a conditional likelihood
approach to capture experiments. <em>Biometrics</em> <b>47</b>, 725&ndash;732.
</p>
<p>Otis, D. L., Burnham, K. P., White, G. C. and Anderson, D. R. (1978)
Statistical inference from capture data on closed animal
populations. <em>Wildlife Monographs</em> <b>62</b>, 1&ndash;135.
</p>
<p>Stanley, T. R. and Richards, J. D. (2005) A program for testing
capture&ndash;recapture data for closure. <em>Wildlife Society Bulletin</em>
<b>33</b>, 782&ndash;785.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closure.test">closure.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
par(mfrow = c(1,2), mar = c(1,1,4,1))
plot(deermouse.ESG, title = "Peromyscus data from East Stuart Gulch",
    border = 10, gridlines = FALSE, tracks = TRUE)
plot(deermouse.WSG, title = "Peromyscus data from Wet Swizer Gulch",
    border = 10, gridlines = FALSE, tracks = TRUE)

closure.test(deermouse.ESG, SB = TRUE)

## reveal multiple captures
table(trap(deermouse.ESG), occasion(deermouse.ESG))
table(trap(deermouse.WSG), occasion(deermouse.WSG))

</code></pre>

<hr>
<h2 id='deleteMaskPoints'>Edit Mask Points</h2><span id='topic+deleteMaskPoints'></span>

<h3>Description</h3>

<p>Mask points may be removed by one of three methods:
clicking on points, clicking on vertices to define a polygon from
which points will be removed, or specifying a polygon to which the
mask will be clipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
deleteMaskPoints(mask, onebyone = TRUE, add = FALSE, poly = NULL,
 poly.habitat = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteMaskPoints_+3A_mask">mask</code></td>
<td>
<p>secr mask object</p>
</td></tr>
<tr><td><code id="deleteMaskPoints_+3A_onebyone">onebyone</code></td>
<td>
<p>logical; see Details</p>
</td></tr>
<tr><td><code id="deleteMaskPoints_+3A_add">add</code></td>
<td>
<p>logical; if true then the initial mask plot will be added
to an existing plot</p>
</td></tr>
<tr><td><code id="deleteMaskPoints_+3A_poly">poly</code></td>
<td>
<p>polygon defining habitat or non-habitat as described in
<code><a href="#topic+make.mask">make.mask</a></code></p>
</td></tr>
<tr><td><code id="deleteMaskPoints_+3A_poly.habitat">poly.habitat</code></td>
<td>
<p>logical; if TRUE polygon represents habitat</p>
</td></tr>
<tr><td><code id="deleteMaskPoints_+3A_...">...</code></td>
<td>
<p>other arguments to plot.mask</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method (onebyone = TRUE, poly = NULL) is to click on each
point to be removed. The nearest mask point will be selected.
</p>
<p>Setting onebyone = FALSE allows the user to click on the vertices of a
polygon within which all points are to be removed (the default) or
retained (<code>poly.habitat = TRUE</code>). Vertices need not
coincide with mask points.
</p>
<p>Defining <code>poly</code> here is equivalent to calling <code>make.mask</code>
with <code>poly</code> defined. <code>poly</code> one of the several types described 
in <code><a href="#topic+boundarytoSF">boundarytoSF</a></code>. Whether <code>poly</code> represents habitat or
non-habitat is toggled with <code>poly.habitat</code> &ndash; the default here
differs from <code><a href="#topic+make.mask">make.mask</a></code>.
</p>


<h3>Value</h3>

<p>A mask object, usually with fewer points than the input mask.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+subset.mask">subset.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    mask0 &lt;- make.mask (traps(captdata))
    ## Method 1 - click on each point to remove
    mask1 &lt;- deleteMaskPoints (mask0)
    ## Method 2 - click on vertices of removal polygon
    mask2 &lt;- deleteMaskPoints (mask0, onebyone = FALSE)
    ## Method 3 - predefined removal polygon
    plot(captdata)
    poly1 &lt;- locator(5)
    mask3 &lt;- deleteMaskPoints (mask0, poly = poly1)
}

</code></pre>

<hr>
<h2 id='derived'> Derived Parameters of Fitted SECR Model </h2><span id='topic+derived'></span><span id='topic+esa'></span><span id='topic+derived.secr'></span><span id='topic+derived.secrlist'></span>

<h3>Description</h3>

<p>Compute derived parameters of spatially explicit capture-recapture model. 
Density is a derived parameter when a model is fitted by maximizing the conditional likelihood. So also is the effective sampling area (in the sense of Borchers and Efford 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
derived(object, ...)

## S3 method for class 'secr'
derived(object, sessnum = NULL, groups = NULL, alpha = 0.05, 
    se.esa = FALSE, se.D = TRUE, loginterval = TRUE, distribution = NULL, 
    ncores = NULL, bycluster = FALSE, ...)

## S3 method for class 'secrlist'
derived(object, sessnum = NULL, groups = NULL, alpha = 0.05, 
    se.esa = FALSE, se.D = TRUE, loginterval = TRUE, distribution = NULL, 
    ncores = NULL, bycluster = FALSE, ...)

esa(object, sessnum = 1, beta = NULL, real = NULL, noccasions = NULL, 
    ncores = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derived_+3A_object">object</code></td>
<td>
 <p><code>secr</code> object output from <code>secr.fit</code>, or an
object of class <code>c("secrlist", "list")</code> </p>
</td></tr>
<tr><td><code id="derived_+3A_sessnum">sessnum</code></td>
<td>
<p> index of session in object$capthist for which output required </p>
</td></tr>
<tr><td><code id="derived_+3A_groups">groups</code></td>
<td>
<p> vector of covariate names to define group(s) (see Details) </p>
</td></tr>
<tr><td><code id="derived_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="derived_+3A_se.esa">se.esa</code></td>
<td>
<p> logical for whether to calculate SE(mean(esa)) </p>
</td></tr>
<tr><td><code id="derived_+3A_se.d">se.D</code></td>
<td>
<p> logical for whether to calculate SE(D-hat) </p>
</td></tr>
<tr><td><code id="derived_+3A_loginterval">loginterval</code></td>
<td>
<p> logical for whether to base interval on log(D)</p>
</td></tr>
<tr><td><code id="derived_+3A_distribution">distribution</code></td>
<td>
<p> character string for distribution of the number of individuals detected </p>
</td></tr>
<tr><td><code id="derived_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads used for parallel processing</p>
</td></tr>
<tr><td><code id="derived_+3A_bycluster">bycluster</code></td>
<td>
<p>logical; if TRUE results are reported separately for each cluster of detectors</p>
</td></tr>
<tr><td><code id="derived_+3A_beta">beta</code></td>
<td>
<p> vector of fitted parameters on transformed (link) scale </p>
</td></tr>
<tr><td><code id="derived_+3A_real">real</code></td>
<td>
<p> vector of &lsquo;real&rsquo; parameters </p>
</td></tr> 
<tr><td><code id="derived_+3A_noccasions">noccasions</code></td>
<td>
<p> integer number of sampling occasions (see Details) </p>
</td></tr> 
<tr><td><code id="derived_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The derived estimate of density is a Horvitz-Thompson-like estimate:
</p>
<p style="text-align: center;"><code class="reqn">\hat{D} = \sum\limits _{i=1}^{n} {a_i (\hat{\theta})^{-1}}</code>
</p>
<p> where <code class="reqn">a_i (\hat{\theta})</code> is the estimate of effective sampling area for animal
<code class="reqn">i</code> with detection parameter vector <code class="reqn">\theta</code>.
</p>
<p>A non-null value of the argument <code>distribution</code> overrides the value
in <code>object$details</code>. The sampling variance of <code class="reqn">\hat{D}</code>
from <code>secr.fit</code> by default is spatially unconditional
(<code>distribution = "Poisson"</code>). For sampling variance conditional on the population of the
habitat mask (and therefore dependent on the mask area), specify
<code>distribution = "binomial"</code>. The equation for the conditional
variance includes a factor <code class="reqn">(1 - a/A)</code> that disappears in the
unconditional (Poisson) variance (Borchers and Efford 2007). Thus the
conditional variance is always less than the unconditional variance. The
unconditional variance may in turn be an overestimate or (more likely)
an underestimate if the true spatial variance is non-Poisson.
</p>
<p>Derived parameters may be estimated for population subclasses (groups)
defined by the user with the <code>groups</code> argument. Each named factor
in <code>groups</code> should appear in the covariates dataframe of
object$capthist (or each of its components, in the case of a
multi-session dataset).
</p>
<p><code>esa</code> is used by <code>derived</code> to compute individual-specific
effective sampling areas: </p>
<p style="text-align: center;"><code class="reqn">a_i (\hat{\theta}) = \int _A \:
p.(\mathbf{X};\mathbf{z}_i, \mathbf{\hat{\theta}}) \; \mathrm{d}
\mathbf{X}</code>
</p>
<p> where
<code class="reqn">p.(\mathbf{X})</code> is the probability an individual at X is
detected at least once and the <code class="reqn">\mathbf{z}_i</code> are optional
individual covariates. Integration is over the area <code class="reqn">A</code> of the
habitat mask.
</p>
<p>The argument <code>noccasions</code> may be used to vary the number of
sampling occasions; it works only when detection parameters are constant
across individuals and across time.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>The effective sampling area &lsquo;esa&rsquo; (<code class="reqn">a(\hat{\theta})</code>)
reported by <code>derived</code> is equal to the harmonic mean of the
<code class="reqn">a_i (\hat{\theta})</code> (arithmetic
mean prior to version 1.5). The sampling variance of
<code class="reqn">a(\hat{\theta})</code> is estimated by
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\mbox{var}}(a(\hat{\theta})) = \hat{G}_\theta^T
\hat{V}_\theta \hat{G}_\theta, </code>
</p>

<p>where <code class="reqn">\hat{V}</code> is the asymptotic estimate of the
variance-covariance matrix of the beta detection parameters
(<code class="reqn">\theta</code>) and <code class="reqn">\hat{G}</code> is a numerical estimate
of the gradient of <code class="reqn">a(\theta)</code> with respect to
<code class="reqn">\theta</code>, evaluated at <code class="reqn">\hat{\theta}</code>.
</p>
<p>A 100(1&ndash;alpha)% asymptotic confidence interval is reported for
density. By default, this is asymmetric about the estimate because the
variance is computed by backtransforming from the log scale. You may 
also choose a symmetric interval (variance obtained on natural scale). 
</p>
<p>The vector of detection parameters for <code>esa</code> may be specified via
<code>beta</code> or <code>real</code>, with the former taking precedence. If
neither is provided then the fitted values in <code>object$fit$par</code> are
used. Specifying <code>real</code> parameter values bypasses the various
linear predictors. Strictly, the &lsquo;real&rsquo; parameters are for a naive
capture (animal not detected previously).
</p>
<p>The computation of sampling variances is relatively slow and may be
suppressed with <code>se.esa</code> and <code>se.D</code> as desired.
</p>
<p>For computing <code>derived</code> across multiple models in parallel see
<code><a href="#topic+par.derived">par.derived</a></code>.
</p>


<h3>Value</h3>

<p>Dataframe with one row for each derived parameter (&lsquo;esa&rsquo;, &lsquo;D&rsquo;) and
columns as below
</p>

<table>
<tr>
 <td style="text-align: left;">
estimate    </td><td style="text-align: left;"> estimate of derived parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
SE.estimate </td><td style="text-align: left;"> standard error of the estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
lcl         </td><td style="text-align: left;"> lower 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
ucl         </td><td style="text-align: left;"> upper 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
CVn         </td><td style="text-align: left;"> relative SE of number observed (Poisson or binomial assumption) </td>
</tr>
<tr>
 <td style="text-align: left;">
CVa         </td><td style="text-align: left;"> relative SE of effective sampling area </td>
</tr>
<tr>
 <td style="text-align: left;">
CVD         </td><td style="text-align: left;"> relative SE of density estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For a multi-session or multi-group analysis the value is a list
with one component for each session and group.
</p>
<p>The result will also be a list if <code>object</code> is an &lsquo;secrlist&rsquo;.
</p>


<h3>Warning</h3>

<p><code>derived()</code> may be applied to detection models fitted by maximizing the full likelihood (<code>CL = FALSE</code>). However, models using g (groups) will not be handled correctly.
</p>


<h3>Note</h3>

<p>Before version 2.1, the output table had columns for &lsquo;varcomp1&rsquo; (the variance in <code class="reqn">\hat{D}</code> due to variation in <code class="reqn">n</code>, i.e.,
Huggins' <code class="reqn">s^2</code>), and &lsquo;varcomp2&rsquo; (the variance in <code class="reqn">\hat{D}</code> due to uncertainty in estimates of detection parameters).
</p>
<p>These quantities are related to CVn and CVa as follows:
</p>
<p><code class="reqn">\mbox{CVn} = \sqrt{ \mbox{varcomp1} } / \hat{D} </code>
</p>
<p><code class="reqn">\mbox{CVa} = \sqrt{ \mbox{varcomp2} } / \hat{D} </code>
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2007) Supplements to Biometrics paper. Available online at <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>
<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>, <b>64</b>, 377&ndash;385.
</p>
<p>Huggins, R. M. (1989) On the statistical analysis of capture experiments. <em>Biometrika</em> <b>76</b>, 133&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.secr">predict.secr</a></code>,
<code><a href="#topic+print.secr">print.secr</a></code>,
<code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+empirical.varD">empirical.varD</a></code>
<code><a href="#topic+par.derived">par.derived</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## extract derived parameters from a model fitted previously
## by maximizing the conditional likelihood 
derived (secrdemo.CL)

## what happens when sampling variance is conditional on mask N?
derived(secrdemo.CL, distribution = "binomial")
## fitted g0, sigma
esa(secrdemo.CL)
## force different g0, sigma
esa(secrdemo.CL, real = c(0.2, 25))

## End(Not run)

</code></pre>

<hr>
<h2 id='details'> Detail Specification for secr.fit </h2><span id='topic+details'></span><span id='topic+fixedbeta'></span><span id='topic+LLonly'></span><span id='topic+param'></span><span id='topic+miscparm'></span><span id='topic+maxdistance'></span>

<h3>Description</h3>

<p>The function <code>secr.fit</code> allows many options. Some of these are used
infrequently and have been bundled as a single argument <code>details</code>
to simplify the documentation. They are described here.
</p>


<h3>Detail components</h3>

<p><code>details$autoini</code> specifies the session number from which to compute starting 
values (multi-session data only; default 1). From 4.0.0, the character value &lsquo;all&rsquo; 
first forms a single-session capthist using <code><a href="#topic+join">join</a></code>(); this may be slow or not 
work at all (especially with telemetry data).
</p>
<p><code>details$centred</code> = TRUE causes coordinates of both traps and mask
to be centred on the centroid of the traps, computed separately for each
session in the case of multi-session data. This may be necessary to
overcome numerical problems when x- or y-coordinates are large
numbers. The default is not to centre coordinates.
</p>
<p><code>details$chat</code> optionally specifies the overdispersion 
of unmarked sightings Tu and unidentified marked sightings Tm. It is used only 
for mark-resight models, and is usually computed within <code>secr.fit</code> 
(<code>details$nsim &gt; 0</code>), but may be provided by the user. For a single session 'chat' is a vector of length 2; for multiple sessions it is a 2-column matrix. 
</p>
<p><code>details$chatonly</code> = TRUE used with <code>details$nsim &gt; 0</code> causes the 
overdispersion statistics for sighting counts Tu and Tm to be estimated and 
returned as a vector or 2-column matrix (multi-session models), with no further
model fitting.
</p>
<p><code>details$contrasts</code> may be used to specify the coding of factor predictors. The value should be suitable for the 'contrasts.arg' argument of <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. See &lsquo;Trend across sessions&rsquo; in <a href="https://www.otago.ac.nz/density/pdfs/secr-multisession.pdf">secr-multisession.pdf</a> for an example.
</p>
<p><code>details$convexpolygon</code> may be set to FALSE for searches of non-convex polygons. This is slower than the default which requires poygons to be convex east-west (<a href="https://www.otago.ac.nz/density/pdfs/secr-polygondetectors.pdf">secr-polygondetectors.pdf</a>).
</p>
<p><code>details$debug</code> is an integer code used to control the printing of intermediate 
values (1,2) and to switch on the R code browser (3). In ordinary use it should not be 
changed from the default (0).
</p>
<p><code>details$Dfn</code> is a function for reparameterizing density models; this is set internally when Dlambda = TRUE. Exotic variations may be specified directly by the user when Dlambda = FALSE. The defaults (Dfn = NULL, Dlambda = FALSE) leave the original density model unchanged. Note there is no connection to userDfn (except that the two are incompatible).
</p>
<p><code>Dlambda</code> if TRUE causes reparameterization of density as the session-on-session finite rate of increase <code class="reqn">lambda</code>. Details at (<a href="https://www.otago.ac.nz/density/pdfs/secr-trend.pdf">secr-trend.pdf</a>).
</p>
<p><code>details$distribution</code> specifies the distribution of the number of
individuals detected <code class="reqn">n</code>; this may be conditional on the number in the
masked area (&quot;binomial&quot;) or unconditional (&quot;poisson&quot;).
<code>distribution</code> affects the sampling variance of the estimated
density. The default is &quot;poisson&quot;. The component &lsquo;distribution&rsquo; may also
take a numeric value larger than nrow(capthist), rather than &quot;binomial&quot;
or &quot;poisson&quot;. The likelihood then treats n as a binomial draw from a
superpopulation of this size, with consequences for the variance of
density estimates. This can help to reconcile MLE with Bayesian
estimates using data augmentation.
</p>
<p><code>details$fastproximity</code> controls special handling of data from binary proximity and count detectors. If TRUE and other conditions are met (no temporal variation or groups) then a multi-occasion capthist is automatically reduced to a count for a single occasion and further compressed by storing only non-zero counts, which can greatly speed up computation of the likelihood (default TRUE).
</p>
<p><code>details$fixedbeta</code> may be used to fix values of beta
parameters. It should be a numeric vector of length equal to the total
number of beta parameters (coefficients) in the model. Parameters to be
estimated are indicated by NA. Other elements should be valid values on
the link scale and will be substituted during likelihood
maximisation. Check the order of beta parameters in a previously fitted
model.
</p>
<p><code>details$grain</code> sets the grain argument for multithreading in RcppParallel parallelFor (default 1). 
<code>details$grain = 0</code> suppresses multithreading (equivalent to <code>ncores = 1</code>).
</p>
<p><code>details$hessian</code> is a character string controlling the computation
of the Hessian matrix from which variances and covariances are obtained.
Options are &quot;none&quot; (no variances), &quot;auto&quot; (the default) or &quot;fdhess&quot; (use
the function fdHess in <span class="pkg">nlme</span>).  If &quot;auto&quot; then the Hessian from the
optimisation function is used. See also method = &quot;none&quot; below.
</p>
<p><code>details$ignoreusage</code> = TRUE causes the function to ignore
usage (varying effort) information in the traps component. The default
(<code>details$ignoreusage</code> = FALSE) is to include usage in the model.
</p>
<p><code>details$intwidth2</code> controls the half-width of the interval
searched by optimise() for the maximum likelihood when there is a single
parameter. Default 0.8 sets the search interval to <code class="reqn">(0.2s, 1.8s)</code> where <code class="reqn">s</code>
is the &lsquo;start&rsquo; value.
</p>
<p><code>details$knownmarks</code> = FALSE causes secr.fit to fit a zero-truncated 
sightings-only model that implicitly estimates the number of marked individuals,
rather than inferring it from the number of rows in the capthist object.
</p>
<p><code>details$LLonly</code> = TRUE causes the function to returns a single
evaluation of the log likelihood at the &lsquo;start&rsquo; values.
</p>
<p><code>details$maxdistance</code> sets a limit to the centroid-to-mask distances considered. The centroid is the geometric mean of detection locations for each individual. If no limit is specified then summation is over all mask points. Specifying <code>maxdistance</code> can speed up computation; it is up to the user to select a limit that is large enough not to affect the likelihood (<code class="reqn">5\sigma</code>?).
</p>
<p><code>details$miscparm</code> (default NULL) is an optional numeric vector of
starting values for additional parameters used in a user-supplied
distance function (see &lsquo;userdist&rsquo; below). If the vector has a names
attribute then the names will be used for the corresponding coefficients
(&lsquo;beta&rsquo; parameters) which will otherwise be named &lsquo;miscparm1&rsquo;,
miscparm2' etc. These parameters are constant across each model and do
not appear in the model formula, but are estimated along with other
coefficients when the likelihood is maximised. Any transformation (link
function) etc. is handled by the user in the userdist function. The
coefficients appear in the output from <code><a href="#topic+coef.secr">coef.secr</a></code> and
<code><a href="#topic+vcov.secr">vcov.secr</a></code>, but not <code>predict.secr</code>.
</p>
<p><code>details$newdetector</code> specifies a detector type to use for this fit, 
replacing the previous <code>detector(traps(capthist))</code>. The value may be 
a vector (one value per occasion) or for multi-session data, a list of vectors. 
A scalar value (e.g. &quot;proximity&quot;) is otherwise used for all occasions and sessions. 
The true detector type is usually known and will be specified in the 'traps' attribute; 
<code>newdetector</code> is useful in simulation studies that examine the effect of misspecification. The capthist component of the output from secr.fit has the new type.
</p>
<p><code>details$nsim</code> specifies the number of replicate simulations to 
perform to estimate the overdispersion statistics for the sighting counts 
Tu and Tm. See also <code>details$chat</code> and <code>details$chatonly</code>.
</p>
<p><code>details$param</code> chooses between various parameterisations of the
SECR model. The default <code>details$param = 0</code> is the formulation in
Borchers and Efford (2008) and later papers.
</p>
<p><code>details$param = 1</code> was once used to select the Gardner &amp; Royle parameterisation of
the detection model (<em>p0</em>, <code class="reqn">\sigma</code>; Gardner et al. 2009) when
the detector type is &lsquo;multi&rsquo;. This parameterisation was discontinued in 2.10.0.
</p>
<p><code>details$param = 2</code> selects parameterisation in terms of
(<code class="reqn">esa(g_0, \sigma)</code>, <code class="reqn">\sigma</code>) (Efford and Mowat 2014).
</p>
<p><code>details$param = 3</code> selects parameterisation in terms of
(<code class="reqn">a_0(\lambda_0, \sigma)</code>, <code class="reqn">\sigma</code>) (Efford and Mowat 2014). This
parameterization is used automatically if a0 appears in the model (e.g.,
a0 ~ 1).
</p>
<p><code>details$param = 4</code> selects parameterisation of sigma in terms of
the coefficient sigmak and constant c (sigma = sigmak /
D^0.5 + c) (Efford et al. 2016). If c is not included explicitly in
the model (e.g., c ~ 1) then it is set to zero. This
parameterization is used automatically if sigmak appears in the model (e.g.,
sigmak ~ 1)
</p>
<p><code>details$param = 5</code> combines parameterisations (3) and (4) (first
compute sigma from D, then compute lambda0 from sigma).
</p>
<p><code>details$relativeD</code> fits a density model conditional on <code class="reqn">n</code> that describes
relative density instead of absolute density. This describes the distribution of 
tagged animals.
</p>
<p><code>details$savecall</code> determines whether the full call to <code>secr.fit</code> is 
saved in the output object. The default is TRUE except when called by 
<code>list.secr.fit</code> as names in the call are then evaluated, causing the 
output to become unwieldy.
</p>
<p><code>details$splitmarked</code> determines whether the home range centre of marked 
animals is allowed to move between the marking and sighting phases of a spatial 
capture&ndash;mark&ndash;resight study. The default is to assume a common home-range centre 
(<code>splitmarked = FALSE</code>). 
</p>
<p><code>details$telemetrytype</code> determines how telemetry data in the
attribute &lsquo;xylist&rsquo; are treated. &lsquo;none&rsquo; causes the xylist data to be
ignored. &lsquo;dependent&rsquo; uses information on the sampling distribution of
each home-range centre in the SECR likelihood. &lsquo;concurrent&rsquo; does that
and more: it splits capthist according to telemetry status and appends
all-zero histories to the telemetry part for any animals present in
xylist. The default is &lsquo;concurrent&rsquo;. 
</p>
<p><code>details$usecov</code> selects the mask covariate to be used for
normalization. NULL limits denominator for normalization to
distinguishing habitat from non-habitat.
</p>
<p><code>details$userDfn</code> is a user-provided function for modelling a density 
surface. See <a href="https://www.otago.ac.nz/density/pdfs/secr-densitysurfaces.pdf">secr-densitysurfaces.pdf</a>
</p>
<p><code>details$userdist</code> is either a function to compute non-Euclidean
distances between detectors and mask points, or a pre-computed matrix of
such distances. The first two arguments of the function should be
2-column matrices of x-y coordinates (respectively <code class="reqn">k</code> detectors and
<code class="reqn">m</code> mask points). The third argument is a habitat mask that defines
a non-Euclidean habitat geometry (a linear geometry is described in
documentation for the package &lsquo;secrlinear&rsquo;). The matrix
returned by the function must have exactly <code class="reqn">k</code> rows and <code class="reqn">m</code>
columns. When called with no arguments the function should return a
character vector of names for the required covariates of &lsquo;mask&rsquo;,
possibly including the dynamically computed density 'D' and a parameter
&lsquo;noneuc&rsquo; that will be fitted. A slightly expanded account is at
<a href="#topic+userdist">userdist</a>, and full documentation is in the separate
document <a href="https://www.otago.ac.nz/density/pdfs/secr-noneuclidean.pdf">secr-noneuclidean.pdf</a>.
</p>
<p>**Do not use &lsquo;userdist&rsquo; for polygon or transect detectors**
</p>


<h3>References</h3>

<p>Efford, M. G., Dawson, D. K., Jhala, Y. V. and Qureshi, Q. (2016) 
Density-dependent home-range size revealed by spatially explicit 
capture&ndash;recapture. <em>Ecography</em> <b>39</b>, 676&ndash;688.
</p>
<p>Efford, M. G. and Mowat, G. (2014) Compensatory heterogeneity in
capture&ndash;recapture data.<em>Ecology</em> <b>95</b>, 1341&ndash;1348.  
</p>
<p>Gardner, B., Royle, J. A. and Wegan, M. T. (2009) Hierarchical models
for estimating density from DNA mark-recapture studies. <em>Ecology</em>
<b>90</b>, 1106&ndash;1115.
</p>
<p>Royle, J. A., Chandler, R. B., Sun, C. C. and Fuller, A. K. (2013)
Integrating resource selection information with spatial
capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>4</b>, 520&ndash;530.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr.fit">secr.fit</a> </code>, <a href="#topic+userdist">userdist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Demo of miscparm and userdist
## We fix the usual 'sigma' parameter and estimate the same 
## quantity as miscparm[1]. Differences in CI reflect the implied use 
## of the identity link for miscparm[1]. 

mydistfn3 &lt;- function (xy1,xy2, mask) {
    if (missing(xy1)) return(character(0))
    xy1 &lt;- as.matrix(xy1)
    xy2 &lt;- as.matrix(xy2)
    miscparm &lt;- attr(mask, 'miscparm')
    distmat &lt;- edist(xy1,xy2) / miscparm[1]
    distmat
}

fit0 &lt;- secr.fit (captdata)
fit &lt;- secr.fit (captdata, fixed = list(sigma=1), details = 
    list(miscparm = c(sig = 20), userdist = mydistfn3))    
predict(fit0)
coef(fit)


## End(Not run)

</code></pre>

<hr>
<h2 id='detectfn'> Detection Functions </h2><span id='topic+Detection+20functions'></span><span id='topic+detectfn'></span>

<h3>Description</h3>

<p>A detection function relates the probability of detection <code class="reqn">g</code> or the
expected number of detections <code class="reqn">\lambda</code> for an animal to the
distance of a detector from a point usually thought of as its home-range
centre. In <span class="pkg">secr</span> only simple 2- or 3-parameter functions are
used. Each type of function is identified by its number or by a 2&ndash;3
letter code (version <code class="reqn">\ge</code> 2.6.0; see below). In most cases the name
may also be used (as a quoted string).
</p>
<p>Choice of detection function is usually not critical, and the default
&lsquo;HN&rsquo; is usually adequate.
</p>
<p>Functions (14)&ndash;(20) are parameterised in terms of the expected number
of detections <code class="reqn">\lambda</code>, or cumulative hazard, rather than
probability. &lsquo;Exposure&rsquo; (e.g. Royle and Gardner 2011) is another term
for cumulative hazard. This parameterisation is natural for the &lsquo;count&rsquo;
<a href="#topic+detector">detector</a> type or if the function is to be interpreted as a
distribution of activity (home range). When one of the functions
(14)&ndash;(19) is used to describe detection probability (i.e., for the binary
detectors &lsquo;single&rsquo;, &lsquo;multi&rsquo;,&lsquo;proximity&rsquo;,&lsquo;polygonX&rsquo; or
&lsquo;transectX&rsquo;), the expected number of detections is internally
transformed to a binomial probability using <code class="reqn">g(d) =
1-\exp(-\lambda(d))</code>.
</p>
<p>The hazard halfnormal (14) is similar to the halfnormal exposure function
used by Royle and Gardner (2011) except they omit the factor of 2 on
<code class="reqn">\sigma^2</code>, which leads to estimates of <code class="reqn">\sigma</code> that are larger
by a factor of sqrt(2). The hazard exponential (16) is identical to their
exponential function.
</p>

<table>
<tr>
 <td style="text-align: left;">
  Code </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Parameters </td><td style="text-align: left;"> Function </td>
</tr>
<tr>
 <td style="text-align: left;">
  
0  HN </td><td style="text-align: left;"> halfnormal </td><td style="text-align: left;"> g0, sigma </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0 \exp
  \left(\frac{-d^2} {2\sigma^2} \right) </code> </td>
</tr>
<tr>
 <td style="text-align: left;">

1  HR </td><td style="text-align: left;"> hazard rate </td><td style="text-align: left;"> g0, sigma, z </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0 [1 - \exp\{
  {-(^d/_\sigma)^{-z}} \}] </code> </td>
</tr>
<tr>
 <td style="text-align: left;">

2  EX </td><td style="text-align: left;"> exponential  </td><td style="text-align: left;"> g0, sigma </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0  \exp \{
    -(^d/_\sigma) \} </code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  
3 CHN </td><td style="text-align: left;"> compound halfnormal  </td><td style="text-align: left;"> g0, sigma, z </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0 [1
  - \{1 - \exp \left(\frac{-d^2} {2\sigma^2} \right)\} ^ z] </code> </td>
</tr>
<tr>
 <td style="text-align: left;">

4  UN </td><td style="text-align: left;"> uniform  </td><td style="text-align: left;"> g0, sigma </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0, d &lt;= \sigma;
  g(d) = 0, \mbox{otherwise}  </code> </td>
</tr>
<tr>
 <td style="text-align: left;">

5 WEX </td><td style="text-align: left;"> w exponential  </td><td style="text-align: left;"> g0, sigma, w </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0, d &lt; w;
  g(d) = g_0  \exp \left( -\frac{d-w}{\sigma} \right), \mbox{otherwise}
  </code>
 </td>
</tr>
<tr>
 <td style="text-align: left;">
 
6 ANN </td><td style="text-align: left;"> annular normal </td><td style="text-align: left;"> g0, sigma, w </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0 \exp
  \lbrace \frac{-(d-w)^2} {2\sigma^2} \rbrace </code> </td>
</tr>
<tr>
 <td style="text-align: left;">

7 CLN </td><td style="text-align: left;"> cumulative lognormal </td><td style="text-align: left;"> g0, sigma, z </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0
  [ 1 - F \lbrace(d-\mu)/s \rbrace ] </code>
 </td>
</tr>
<tr>
 <td style="text-align: left;">

8  CG </td><td style="text-align: left;"> cumulative gamma </td><td style="text-align: left;"> g0, sigma, z </td><td style="text-align: left;"> <code class="reqn"> g(d) = g_0
  \lbrace 1 - G (d; k, \theta)\rbrace </code>
 </td>
</tr>
<tr>
 <td style="text-align: left;">

9 BSS </td><td style="text-align: left;"> binary signal strength  </td><td style="text-align: left;"> b0, b1 </td><td style="text-align: left;"> <code class="reqn"> g(d) = 1 - F
    \lbrace - ( b_0 + b_1  d) \rbrace </code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  
10 SS </td><td style="text-align: left;"> signal strength  </td><td style="text-align: left;"> beta0, beta1, sdS </td><td style="text-align: left;"> <code class="reqn"> g(d) =1 -
  F[\lbrace c - (\beta_0 + \beta_1  d) \rbrace / s] </code> </td>
</tr>
<tr>
 <td style="text-align: left;">

11 SSS </td><td style="text-align: left;"> signal strength spherical </td><td style="text-align: left;"> beta0, beta1, sdS </td><td style="text-align: left;">
    <code class="reqn"> g(d) = 1 - F [ \lbrace c - (\beta_0 + \beta_1 (d-1) -  10 \log
      _{10}  d^2 ) \rbrace / s ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">

14 HHN </td><td style="text-align: left;"> hazard halfnormal </td><td style="text-align: left;"> lambda0, sigma </td><td style="text-align: left;"> <code class="reqn"> \lambda(d) = \lambda_0 \exp
  \left(\frac{-d^2} {2\sigma^2} \right) </code>; <code class="reqn">g(d) = 1-\exp(-\lambda(d))</code></td>
</tr>
<tr>
 <td style="text-align: left;">

15 HHR </td><td style="text-align: left;"> hazard hazard rate </td><td style="text-align: left;"> lambda0, sigma, z </td><td style="text-align: left;"> <code class="reqn"> \lambda(d)
  = \lambda_0 (1 - \exp \{ -(^d/_\sigma)^{-z} \}) </code>; <code class="reqn">g(d) = 1-\exp(-\lambda(d))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 
16 HEX </td><td style="text-align: left;"> hazard exponential </td><td style="text-align: left;"> lambda0, sigma </td><td style="text-align: left;"> <code class="reqn"> \lambda(d)
  = \lambda_0 \exp \{ -(^d/_\sigma) \} </code>; <code class="reqn">g(d) = 1-\exp(-\lambda(d))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 
17 HAN </td><td style="text-align: left;"> hazard annular normal </td><td style="text-align: left;"> lambda0, sigma, w </td><td style="text-align: left;"> <code class="reqn"> \lambda(d) = \lambda_0 \exp
  \lbrace \frac{-(d-w)^2} {2\sigma^2} \rbrace </code>; <code class="reqn">g(d) = 1-\exp(-\lambda(d))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">

18 HCG </td><td style="text-align: left;"> hazard cumulative gamma </td><td style="text-align: left;"> lambda0, sigma, z </td><td style="text-align: left;"> <code class="reqn"> \lambda(d) = \lambda_0
  \lbrace 1 - G (d; k, \theta)\rbrace </code>; <code class="reqn">g(d) = 1-\exp(-\lambda(d))</code>
 </td>
</tr>
<tr>
 <td style="text-align: left;">

19 HVP </td><td style="text-align: left;"> hazard variable power </td><td style="text-align: left;"> lambda0, sigma, z </td><td style="text-align: left;"> <code class="reqn"> \lambda(d)
  = \lambda_0 \exp \{ -(^d/_\sigma)^{z} \} </code>; <code class="reqn">g(d) = 1-\exp(-\lambda(d))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 
20 HPX </td><td style="text-align: left;"> hazard pixelar </td><td style="text-align: left;"> lambda0, sigma </td><td style="text-align: left;"> <code class="reqn"> g(d') = 1-exp(-\lambda(d')), d' &lt;= \sigma;
  g(d') = 0, \mbox{otherwise}  </code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 

</td>
</tr>

</table>

<p>Functions (1) and (15), the &quot;hazard-rate&quot; detection functions described by Hayes and Buckland
(1983), are not recommended for SECR because of their long tail, and
care is also needed with (2) and (16).
</p>
<p>Function (3), the compound halfnormal, follows Efford and Dawson (2009).
</p>
<p>Function (4) uniform is defined only for simulation as it poses problems
for likelihood maximisation by gradient methods. Uniform probability
implies uniform hazard, so there is no separate function &lsquo;HUN&rsquo;.
</p>
<p>For function (7), &lsquo;F&rsquo; is the standard normal distribution function and
<code class="reqn">\mu</code> and <code class="reqn">s</code> are the mean and standard deviation on the
log scale of a latent variable representing a threshold of detection
distance. See Note for the relationship to the fitted parameters sigma
and z.
</p>
<p>For functions (8) and (18), &lsquo;G&rsquo; is the cumulative distribution function of the
gamma distribution with shape parameter <em>k</em> ( = <code>z</code>) and scale
parameter <code class="reqn">\theta</code> ( = <code>sigma/z</code>). See R's
<code><a href="stats.html#topic+pgamma">pgamma</a></code>.
</p>
<p>For functions (9), (10) and (11), &lsquo;F&rsquo; is the standard normal
distribution function and <code class="reqn">c</code> is an arbitrary signal threshold. The two
parameters of (9) are functions of the parameters of (10) and (11):
<code class="reqn">b_0 = (\beta_0 - c) / sdS</code> and <code class="reqn">b_1 =
\beta_1 / s</code> (see Efford et al. 2009). Note that (9) does
not require signal-strength data or <code class="reqn">c</code>.
</p>
<p>Function (11) includes an additional &lsquo;hard-wired&rsquo; term for sound
attenuation due to spherical spreading. Detection probability at
distances less than 1 m is given by <code class="reqn">g(d) = 1 - F \lbrace(c -
  \beta_0) / sdS \rbrace</code>
</p>
<p>Functions (12) and (13) are undocumented methods for sound attenuation.
</p>
<p>Function (19) has been used in some published papers and is included for 
comparison (see e.g. Ergon and Gardner 2014).
</p>
<p>Function (20) assigns positive probability of detection only to points within a 
square pixel (cell) with side 2 sigma that is centred on the detector. 
(Typically used with fixed sigma = detector spacing / 2).
</p>


<h3>Note</h3>

<p>The parameters of function (7) are potentially confusing.  The fitted
parameters describe a latent threshold variable on the natural scale:
sigma (mean) = <code class="reqn">\exp(\mu + s^2 / 2)</code> and z
(standard deviation) = <code class="reqn">\sqrt{\exp(s^2 + 2
\mu)(\exp(s^2)-1)}</code>. As with other
detection functions, sigma is a spatial scale parameter, although in
this case it corresponds to the mean of the threshold variable; the
standard deviation of the threshold variable (z) determines the shape
(roughly 1/max(slope)) of the detection function.  </p>


<h3>References</h3>

<p>Efford, M. G. and Dawson, D. K. (2009) Effect of distance-related
heterogeneity on population size estimates from point counts. <em>Auk</em>
<b>126</b>, 100&ndash;111.
</p>
<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009) Population
density estimated from locations of individuals on a passive detector
array. <em>Ecology</em> <b>90</b>, 2676&ndash;2682.
</p>
<p>Ergon, T. and Gardner, B. (2014) Separating mortality and emigration: 
modelling space use, dispersal and survival with robust-design spatial 
capture&ndash;recapture data. <em>Methods in Ecology and Evolution</em> <b>5</b>, 
1327&ndash;1336.
</p>
<p>Hayes, R. J. and Buckland, S. T. (1983) Radial-distance models for the
line-transect method. <em>Biometrics</em> <b>39</b>, 29&ndash;42.
</p>
<p>Royle, J. A. and Gardner, B. (2011) Hierarchical spatial
capture&ndash;recapture models for estimating density from trapping
arrays. In: A.F. O'Connell, J.D. Nichols &amp; K.U. Karanth (eds)
<em>Camera Traps in Animal Ecology: Methods and Analyses</em>. Springer,
Tokyo.  Pp. 163&ndash;190.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+detectfnplot">detectfnplot</a></code> </p>

<hr>
<h2 id='detector'> Detector Type </h2><span id='topic+detector'></span><span id='topic+detector+3C-'></span><span id='topic+polygon'></span><span id='topic+polygonX'></span><span id='topic+transect'></span><span id='topic+transectX'></span><span id='topic+single'></span><span id='topic+multi'></span><span id='topic+proximity'></span><span id='topic+count'></span><span id='topic+capped'></span>

<h3>Description</h3>

<p>Extract or replace the detector type. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detector(object, ...)
detector(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detector_+3A_object">object</code></td>
<td>
<p> object with &lsquo;detector&rsquo; attribute e.g. <code>traps</code> </p>
</td></tr>
<tr><td><code id="detector_+3A_value">value</code></td>
<td>
<p> character string for detector type </p>
</td></tr>
<tr><td><code id="detector_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid detector types are &lsquo;single&rsquo;, &lsquo;multi&rsquo;, &lsquo;proximity&rsquo;, &lsquo;count&rsquo;, &lsquo;capped&rsquo;,
&lsquo;signal&rsquo;, &lsquo;polygon&rsquo;, &lsquo;transect&rsquo;, &lsquo;polygonX&rsquo;, and &lsquo;transectX&rsquo;. The
detector type is stored as an attribute of a <code>traps</code> object.
Detector types are mostly described by Efford et al. (2009a,b; see also
<a href="../doc/secr-overview.pdf">secr-overview.pdf</a>). Polygon and transect detector types are
for area and linear searches as described in
<a href="https://www.otago.ac.nz/density/pdfs/secr-polygondetectors.pdf">secr-polygondetectors.pdf</a> and Efford (2011). The &lsquo;signal&rsquo;
detector type is used for acoustic data as described in
<a href="https://www.otago.ac.nz/density/pdfs/secr-sound.pdf">secr-sound.pdf</a>.
</p>
<p>The &lsquo;capped&rsquo; detector type refers to binary proximity data in which no more than one individual may be detected at a detector on any occasion. The type is partially implemented in <span class="pkg">secr</span> 3.1.1: data may be simulated and manipulated, but for model fitting these are treated as proximity data by <code>secr.fit()</code>.
</p>


<h3>Value</h3>

<p>character string for detector type
</p>


<h3>References</h3>

<p>Efford, M. G. (2011) Estimation of population density by spatially
explicit capture&ndash;recapture with area searches. <em>Ecology</em>
<b>92</b>, 2202&ndash;2207.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009a) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>
<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009b) Population
density estimated from locations of individuals on a passive detector
array. <em>Ecology</em> <b>90</b>, 2676&ndash;2682.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+traps">traps</a></code>, <code><a href="utils.html#topic+RShowDoc">RShowDoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Default detector type is "multi"
temptrap &lt;- make.grid(nx = 6, ny = 8)
detector(temptrap) &lt;- "proximity"
summary(temptrap)
</code></pre>

<hr>
<h2 id='deviance'>
Deviance of fitted secr model and residual degrees of freedom
</h2><span id='topic+deviance'></span><span id='topic+df.residual'></span><span id='topic+deviance.secr'></span><span id='topic+df.residual.secr'></span>

<h3>Description</h3>

<p>Compute the deviance or residual degrees of freedom of a fitted secr
model, treating multiple sessions and groups as independent. The
likelihood of the saturated model depends on whether the &lsquo;conditional&rsquo;
or &lsquo;full&rsquo; form was used, and on the distribution chosen for the number
of individuals observed (Poisson or binomial).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'secr'
deviance(object, ...)
## S3 method for class 'secr'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance_+3A_object">object</code></td>
<td>
<p> secr object from secr.fit </p>
</td></tr>
<tr><td><code id="deviance_+3A_...">...</code></td>
<td>
<p> other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deviance is <code class="reqn">-2log(\hat{L}) + 2log(L_{sat})</code>, where <code class="reqn">\hat{L}</code> is the value of the
log-likelihood evaluated at its maximum, and <code class="reqn">L_{sat}</code> is the
log-likelihood of the saturated model, calculated thus:
</p>
<p>Likelihood conditional on <code class="reqn">n</code> -
</p>
<p><code class="reqn">L_{sat} = \log(n!) + \sum\limits _{\omega} [n_\omega \log (\frac{n_\omega}{n}) - \log 
 (n_\omega !)]</code>
</p>
<p>Full likelihood, Poisson <code class="reqn">n</code> -
</p>
<p><code class="reqn">L_{sat} = n\log(n) - n + \sum\limits _{\omega} [n_\omega \log (\frac{n_\omega}{n}) - \log (n_\omega !)]</code>
</p>
<p>Full likelihood, binomial <code class="reqn">n</code> -
</p>
<p><code class="reqn">L_{sat} = n\log(\frac{n}{N}) + (N-n)\log(\frac{N-n}{N}) + \log (\frac{N!}{(N-n)!}) + \sum\limits _{\omega} [n_\omega \log (\frac{n_\omega}{n}) - \log (n_\omega !)]</code>
</p>
<p><code class="reqn">n</code> is the number of individuals observed at least once, <code class="reqn">n_\omega</code> is the number of distinct histories, and <code class="reqn">N</code> is the number in a chosen area <code class="reqn">A</code> that we estimate by <code class="reqn">\hat{N} = \hat{D}A</code>.
</p>
<p>The residual degrees of freedom is the number of distinct detection
histories minus the number of parameters estimated. The detection
histories of two animals are always considered distinct if they belong to
different groups.
</p>
<p>When samples are (very) large the deviance is expected to be distributed
as <code class="reqn">\chi^2</code> with <code class="reqn">n_\omega - p</code> degrees of
freedom when <code class="reqn">p</code> parameters are estimated. In reality, simulation is
needed to assess whether a given value of the deviance indicates a
satisfactory fit, or to estimate the overdispersion parameter <code class="reqn">c</code>.
<code>sim.secr</code> is a convenient tool. 
</p>


<h3>Value</h3>

<p>The scalar numeric value of the deviance or the residual degress of freedom extracted
from the fitted model.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+sim.secr">sim.secr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
deviance(secrdemo.0)
df.residual(secrdemo.0)

</code></pre>

<hr>
<h2 id='discretize'>Rasterize Area Search or Transect Data</h2><span id='topic+discretize'></span>

<h3>Description</h3>

<p>It is sometimes useful to re-cast area-search (polygon or polygonX) data as if it was from a
set of closely spaced point detectors, i.e. to rasterize the detection locations. This function makes that conversion. Each polygon detector in the input is replaced by a number of point detectors, each representing a square pixel. Detections are mapped to the new detectors on the basis of their x-y coordinates.
</p>
<p>If <code>object</code> contains transect data the problem is passed to <code><a href="#topic+snip">snip</a></code> and <code>reduce.capthist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
discretize(object, spacing = 5, outputdetector = c("proximity", "count", "multi"), 
    tol = 0.001, cell.overlap = FALSE, type = c("centre","any", "all"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_object">object</code></td>
<td>
<p>secr capthist or traps object</p>
</td></tr>
<tr><td><code id="discretize_+3A_spacing">spacing</code></td>
<td>
<p>numeric spacing between point detectors in metres </p>
</td></tr>
<tr><td><code id="discretize_+3A_outputdetector">outputdetector</code></td>
<td>
<p>character output detector type</p>
</td></tr>
<tr><td><code id="discretize_+3A_tol">tol</code></td>
<td>
<p>numeric fractional inflation of perimeter (see Details)</p>
</td></tr>
<tr><td><code id="discretize_+3A_cell.overlap">cell.overlap</code></td>
<td>
<p>logical; if TRUE the area of overlap is stored in usage attribute </p>
</td></tr>
<tr><td><code id="discretize_+3A_type">type</code></td>
<td>
<p>character; see Details</p>
</td></tr>
<tr><td><code id="discretize_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+snip">snip</a></code> if object is transect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input should have detector type &lsquo;polygon&rsquo; or &lsquo;polygonX&rsquo;.
</p>
<p>A new array of equally spaced detectors is generated within
each polygon of the input, inflated radially by 1 + tol to avoid some
inclusion problems. The origin of the superimposed grid is fixed automatically. If <code>type = "centre"</code> detectors are included if they lie within the (inflated) polygon. Otherwise, the decision on whether to include a candidate new detector is based on the corner vertices of the cell around the detector (side = <code>spacing</code>); <code>type = "any"</code> and  <code>type = "all"</code> have the obvious meanings. 
</p>
<p><code>tol</code> may be negative, in which case the array(s) will be shrunk relative
to the polygon(s). 
</p>
<p>For irregular polygons the edge cells in the output may be only partially contained within the polygon they represent. Set <code>cell.overlap = TRUE</code> to retain the proportion of overlap as the &lsquo;usage&rsquo; of the new traps object. This can take a few seconds to compute. If &lsquo;usage&rsquo; is already defined then the new &lsquo;usage&rsquo; is the old multiplied by the proportion of overlap.
</p>
<p>Combining <code>type = "any"</code> and <code>cell.overlap = TRUE</code> with <code>tol</code> &gt; 0 can have the odd effect of including some marginal detectors that are assigned zero usage.
</p>
<p>With <code>type = "any"</code>, the sum of the overlap proportions times cell area is equal to the area of the polygons.
</p>


<h3>Value</h3>

<p>A capthist or traps object of the requested detector type, but otherwise
carrying forward all attributes of the input. The embedded traps object has a 
factor covariate &lsquo;polyID&rsquo; recording the polygon to which each point detector relates.
</p>


<h3>Note</h3>

<p>Consider the likely number of detectors in the output before you start. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce.capthist">reduce.capthist</a></code>, <code><a href="#topic+snip">snip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## generate some polygon data
pol &lt;- make.poly()
CH &lt;- sim.capthist(pol, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
plot(CH, border = 10, gridl = FALSE, varycol = FALSE)

## discretize and plot
CH1 &lt;- discretize(CH, spacing = 10, output = 'count')
plot(CH1, add = TRUE, cappar = list(col = 'orange'), varycol =
    FALSE, rad = 0)
plot(traps(CH1), add = TRUE)
# overlay cell boundaries
plot(as.mask(traps(CH1)), dots = FALSE, col = NA, meshcol = 'green', 
    add = TRUE)

## show how detections are snapped to new detectors
newxy &lt;- traps(CH1)[nearesttrap(xy(CH),traps(CH1)),]
segments(xy(CH)[,1], xy(CH)[,2], newxy[,1], newxy[,2])

plot(traps(CH), add = TRUE)  # original polygon

## Incomplete overlap

pol &lt;- rotate(make.poly(), 45)
CH2 &lt;- sim.capthist(pol, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
plot(CH2, border = 10, gridl = FALSE, varycol = FALSE)
CH3 &lt;- discretize(CH2, spacing = 10, output = 'count', type = 'any', 
    cell.overlap = TRUE, tol=0.05)
    
plot(CH3, add = TRUE, cappar = list(col = 'orange'), varycol =
    FALSE, rad = 0)
plot(traps(CH3), add = TRUE)

# overlay cell boundaries and usage
msk &lt;- as.mask(traps(CH3))
covariates(msk) &lt;- data.frame(usage = usage(traps(CH3))[,1])
plot(msk, dots = FALSE, cov='usage', meshcol = 'green', 
    add = TRUE)
    

## End(Not run)

</code></pre>

<hr>
<h2 id='distancetotrap'> Distance To Nearest Detector </h2><span id='topic+nearesttrap'></span><span id='topic+distancetotrap'></span>

<h3>Description</h3>

<p>Compute Euclidean distance from each of a set of points to the nearest
detector in an array, or return the sequence number of the detector
nearest each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
distancetotrap(X, traps)

nearesttrap(X, traps)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distancetotrap_+3A_x">X</code></td>
<td>
<p> coordinates </p>
</td></tr>
<tr><td><code id="distancetotrap_+3A_traps">traps</code></td>
<td>
<p> traps object or 2-column matrix of coordinates </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distancetotrap</code> returns the distance from each point in X to the
nearest detector in <code>traps</code>. It may be used to restrict the points
on a habitat mask.
</p>
<p>For traps objects with polygon detector type (polygon, polygonX), and for SpatialPolygons, 
the function sf::st_distance is used internally(from <span class="pkg">secr</span> 4.5.2).
</p>


<h3>Value</h3>

<p><code>distancetotrap</code> returns a vector of distances (assumed to be in metres). 
</p>
<p><code>nearesttrap</code> returns the index of the nearest trap. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+make.mask">make.mask</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## restrict a habitat mask to points within 70 m of traps  
  ## this is nearly equivalent to using make.mask with the 
  ## `trapbuffer' option
  temptrap &lt;- make.grid()
  tempmask &lt;- make.mask(temptrap)
  d &lt;- distancetotrap(tempmask, temptrap)
  tempmask &lt;- subset(tempmask, d &lt; 70)

</code></pre>

<hr>
<h2 id='Dsurface'> Density Surfaces </h2><span id='topic+Dsurface'></span><span id='topic+Dsurface-class'></span><span id='topic+print.Dsurface'></span><span id='topic+summary.Dsurface'></span>

<h3>Description</h3>

<p>S3 class for rasterized fitted density surfaces. A Dsurface is a type
of &lsquo;mask&rsquo; with covariate(s) for the predicted density at each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'Dsurface'
print(x, scale = 1, ...)
## S3 method for class 'Dsurface'
summary(object, scale = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dsurface_+3A_x">x</code>, <code id="Dsurface_+3A_object">object</code></td>
<td>
<p>Dsurface object to display</p>
</td></tr>
<tr><td><code id="Dsurface_+3A_scale">scale</code></td>
<td>
<p>numeric multiplier for density</p>
</td></tr>
<tr><td><code id="Dsurface_+3A_...">...</code></td>
<td>
<p>other arguments passed to print method for data frames or
summary method for masks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Dsurface will usually have been constructed with <code><a href="#topic+predictDsurface">predictDsurface</a></code>.
</p>
<p>The &lsquo;scale&rsquo; argument may be used to change the units of density from the default
(animals / hectare) to animals / km^2 (scale = 100) or animals / 100km^2
(scale = 10000).
</p>
<p>A virtual S4 class &lsquo;Dsurface&rsquo; is defined to allow the definition of a method for the generic function <code>raster</code> from the <span class="pkg">raster</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictDsurface">predictDsurface</a></code>, <code><a href="#topic+plot.Dsurface">plot.Dsurface</a></code>
</p>

<hr>
<h2 id='ellipse.secr'> Confidence Ellipses </h2><span id='topic+ellipse.secr'></span><span id='topic+ellipse.bvn'></span>

<h3>Description</h3>

<p>Plot joint confidence ellipse for two parameters of secr model, or for a
distribution of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ellipse.secr(object, par = c("g0", "sigma"), alpha = 0.05,
    npts = 100, plot = TRUE, linkscale = TRUE, add = FALSE,
    col = palette(), ...)

ellipse.bvn(xy, alpha = 0.05, npts = 100, centroid = TRUE, add = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse.secr_+3A_object">object</code></td>
<td>
<p><code>secr</code> object output from <code>secr.fit</code></p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_par">par</code></td>
<td>
<p>character vector of length two, the names of two &lsquo;beta&rsquo; parameters</p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_npts">npts</code></td>
<td>
<p>number of points on perimeter of ellipse</p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_plot">plot</code></td>
<td>
<p>logical for whether ellipse should be plotted</p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_linkscale">linkscale</code></td>
<td>
<p>logical; if FALSE then coordinates will be backtransformed from the link scale</p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_add">add</code></td>
<td>
<p>logical to add ellipse to an existing plot </p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_col">col</code></td>
<td>
<p>vector of one or more plotting colours</p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_...">...</code></td>
<td>
<p>arguments to pass to plot functions (or polygon() in the case
of ellipse.bvn)</p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_xy">xy</code></td>
<td>
<p>2-column matrix of coordinates</p>
</td></tr>
<tr><td><code id="ellipse.secr_+3A_centroid">centroid</code></td>
<td>
<p>logical; if TRUE the plotted ellipse is a confidence
region for the centroid of points in <code>xy</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ellipse.secr</code> calculates coordinates of a confidence ellipse from
the asymptotic variance-covariance matrix of the beta parameters
(coefficients), and optionally plots it.
</p>
<p>If <code>linkscale</code> == FALSE, the inverse of the appropriate link
transformation is applied to the coordinates of the ellipse, causing it
to deform.
</p>
<p>If <code>object</code> is a list of secr models then one ellipse is
constructed for each model. Colours are recycled as needed.
</p>
<p><code>ellipse.bvn</code> plots a bivariate normal confidence ellipse for the
centroid of a 2-dimensional distribution of points (default centroid =
TRUE), or a Jennrich and Turner (1969) elliptical home-range model.
</p>


<h3>Value</h3>

<p>A list containing the x and y coordinates is returned invisibly from
either function.
</p>


<h3>References</h3>

<p>Jennrich, R. I. and Turner, F. B. (1969) Measurement of
non-circular home range. <em>Journal of Theoretical Biology</em>,
<b>22</b>, 227&ndash;237.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ellipse.secr(secrdemo.0)

</code></pre>

<hr>
<h2 id='empirical.varD'>
Empirical Variance of H-T Density Estimate
</h2><span id='topic+empirical.varD'></span><span id='topic+derivednj'></span><span id='topic+derivedSession'></span><span id='topic+derivedMash'></span><span id='topic+derivedCluster'></span><span id='topic+derivedExternal'></span><span id='topic+derivedSystematic'></span>

<h3>Description</h3>

<p>Compute Horvitz-Thompson-like estimate of population density from a
previously fitted spatial detection model, and estimate its sampling
variance using the empirical spatial variance of the number observed
in replicate sampling units. Wrapper functions are provided for
several different scenarios, but all ultimately call
<code>derivednj</code>. The function <code>derived</code> also computes
Horvitz-Thompson-like estimates, but it assumes a Poisson or binomial
distribution of total number when computing the sampling variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
derivednj ( nj, esa, se.esa = NULL, method = c("SRS", "R2", "R3", "local",
    "poisson", "binomial"), xy = NULL, alpha = 0.05, loginterval = TRUE, 
    area = NULL, independent.esa = FALSE )

derivedMash ( object, sessnum = NULL,  method = c("SRS", "local"),
    alpha = 0.05, loginterval = TRUE)

derivedCluster ( object, method = c("SRS", "R2", "R3", "local", "poisson", "binomial"),
    alpha = 0.05, loginterval = TRUE)

derivedSession ( object,  method = c("SRS", "R2", "R3", "local", "poisson", "binomial"), 
    xy = NULL, alpha = 0.05, loginterval = TRUE, area = NULL, independent.esa = FALSE )

derivedExternal ( object, sessnum = NULL, nj, cluster, buffer = 100,
    mask = NULL, noccasions = NULL,  method = c("SRS", "local"), xy = NULL,
    alpha = 0.05, loginterval = TRUE)

derivedSystematic( object, xy, design = list(), basenx = 10, df = 9, extrapolate = TRUE,
    alpha = 0.05, loginterval = TRUE, independent.esa = FALSE, keep = FALSE,
    ncores = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empirical.varD_+3A_object">object</code></td>
<td>
<p>fitted secr model </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_nj">nj</code></td>
<td>
<p> vector of number observed in each sampling unit (cluster)</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_esa">esa</code></td>
<td>
<p>estimate of effective sampling area (<code class="reqn">\hat{a}</code>)</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_se.esa">se.esa</code></td>
<td>
<p> estimated standard error of effective sampling
area (<code class="reqn">\widehat{SE}(\hat{a})</code>)</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_method">method</code></td>
<td>
<p> character string &lsquo;SRS&rsquo; or &lsquo;local&rsquo; </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_xy">xy</code></td>
<td>
<p> dataframe of x- and y- coordinates (<code>method = "local"</code> only)</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_loginterval">loginterval</code></td>
<td>
<p> logical for whether to base interval on log(N)</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_area">area</code></td>
<td>
<p> area of region for method = &quot;binomial&quot; (hectares) </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_independent.esa">independent.esa</code></td>
<td>
<p>logical; controls variance contribution from esa (see Details) </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_sessnum">sessnum</code></td>
<td>
<p> index of session in object$capthist for which output required </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_cluster">cluster</code></td>
<td>
<p> &lsquo;traps&rsquo; object for a single cluster</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_buffer">buffer</code></td>
<td>
<p> width of buffer in metres (ignored if <code>mask</code>
provided) </p>
</td></tr> 
<tr><td><code id="empirical.varD_+3A_mask">mask</code></td>
<td>
<p> mask object for a single cluster of detectors </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_noccasions">noccasions</code></td>
<td>
<p>number of occasions (for <code>nj</code>) </p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_design">design</code></td>
<td>
<p>list specifying systematic design (see Details)</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_basenx">basenx</code></td>
<td>
<p>integer number of basis grid points in x-dimension</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_df">df</code></td>
<td>
<p>integer number of degrees of freedom for gam</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_extrapolate">extrapolate</code></td>
<td>
<p> logical; if FALSE then boxlet p values are inferred from nearest point inside convex hull of grid</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_keep">keep</code></td>
<td>
<p>logical; if TRUE then derivedSystematic saves key intermediate values as attributes</p>
</td></tr>
<tr><td><code id="empirical.varD_+3A_ncores">ncores</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>derivednj</code> accepts a vector of counts (<code>nj</code>), along with
<code class="reqn">\hat{a}</code> and <code class="reqn">\widehat{SE}(\hat{a})</code>.  The
argument <code>esa</code> may be a scalar or (if se.esa is NULL) 
a 2-column matrix with <code class="reqn">\hat{a_j}</code> and
<code class="reqn">\widehat{SE}(\hat{a_j})</code> for each replicate <code class="reqn">j</code> (row). 
In the special case that <code>nj</code>
is of length 1, or <code>method</code> takes the values &lsquo;poisson&rsquo; or
&lsquo;binomial&rsquo;, the variance is computed using a theoretical variance
rather than an empirical estimate. The value of <code>method</code>
corresponds to &lsquo;distribution&rsquo; in <code><a href="#topic+derived">derived</a></code>, and defaults to
&lsquo;poisson&rsquo;. For <code>method = 'binomial'</code> you must specify <code>area</code>
(see Examples).
</p>
<p>If <code>independent.esa</code> is TRUE then independence is assumed among 
cluster-specific estimates of esa, and esa variances are summed. The default 
is a weighted sum leading to higher overall variance.
</p>
<p><code>derivedCluster</code> accepts a model fitted to data from clustered
detectors; each <a href="#topic+cluster">cluster</a> is interpreted as a replicate
sample. It is assumed that the sets of individuals sampled by
different clusters do not intersect, and that all clusters have the
same geometry (spacing, detector number etc.).
</p>
<p><code>derivedMash</code> accepts a model fitted to clustered data that have
been &lsquo;mashed&rsquo; for fast processing (see <code><a href="#topic+mash">mash</a></code>); each
cluster is a replicate sample: the function uses the vector of cluster
frequencies (<code class="reqn">n_j</code>) stored as an attribute of the mashed
<code>capthist</code> by <code>mash</code>.
</p>
<p><code>derivedExternal</code> combines detection parameter estimates from a
fitted model with a vector of frequencies <code>nj</code> from replicate
sampling units configured as in <code>cluster</code>. Detectors in
<code>cluster</code> are assumed to match those in the fitted model with
respect to type and efficiency, but sampling duration
(<code>noccasions</code>), spacing etc. may differ. The <code>mask</code> should
match <code>cluster</code>; if <code>mask</code> is missing, one will be
constructed using the <code>buffer</code> argument and defaults from
<code>make.mask</code>.
</p>
<p><code>derivedSession</code> accepts a single fitted model that must span
multiple sessions; each session is interpreted as a replicate sample.
</p>
<p>Spatial variance is calculated by one of these methods
</p>

<table>
<tr>
 <td style="text-align: left;">
  Method </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>"SRS"</code> </td><td style="text-align: left;"> simple random sampling with identical clusters </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"R2"</code> </td><td style="text-align: left;"> variable cluster size cf Thompson (2002:70) estimator for line transects </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"R3"</code> </td><td style="text-align: left;"> variable cluster size cf Buckland et al. (2001)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"local"</code> </td><td style="text-align: left;"> neighbourhood variance estimator (Stevens and Olsen 2003) SUSPENDED in 4.4.7 </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>"poisson"</code> </td><td style="text-align: left;"> theoretical (model-based) variance </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"binomial"</code> </td><td style="text-align: left;"> theoretical (model-based) variance in given <code>area</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The weighted options R2 and R3 substitute <code class="reqn">\hat{a_j}</code> for line length <code class="reqn">l_k</code> in the corresponding formulae of Fewster et al. (2009, Eq 3,5). Density is estimated by <code class="reqn">D = n/A</code> where <code class="reqn">A = \sum a_j</code>. The variance of <code class="reqn">A</code> is estimated as the sum of the cluster-specific variances, assuming independence among clusters. Fewster et al. (2009) found that an alternative estimator for line transects derived by Thompson (2002) performed better when there were strong density gradients correlated with line length (R2 in Fewster et al. 2009, Eq 3).
</p>
<p>The neighborhood variance estimator is implemented in package <span class="pkg">spsurvey</span> and was originally proposed for generalized random tessellation stratified (GRTS) samples.  For &lsquo;local&rsquo; variance
estimates, the centre of each replicate must be provided in <code>xy</code>,
except where centres may be inferred from the data. It is unclear whether &lsquo;local&rsquo; can or should be used when clusters vary in size.
</p>
<p><code>derivedSystematic</code> implements the 'boxlet' variance estimator of Fewster (2011) for systematic designs using clustered detectors (an alternative to <code>derivedCluster</code> and <code>derivedSessions</code>). The method is experimental in secr 3.2.0 and may change. The &lsquo;design&rsquo; argument is a list with components corresponding to arguments of <code><a href="#topic+make.systematic">make.systematic</a></code>, (<code>n</code> and <code>origin</code> are ignored if provided):
</p>

<table>
<tr>
 <td style="text-align: left;">
Component </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cluster</code> </td><td style="text-align: left;"> traps object for a single cluster </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>region</code> </td><td style="text-align: left;"> 2-column matrix or SpatialPolygons </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>spacing</code> </td><td style="text-align: left;"> spacing between cluster origins </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>...</code> </td><td style="text-align: left;"> other arguments passed to <code><a href="#topic+trap.builder">trap.builder</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> e.g. <code>edgemethod</code>, <code>exclude</code>, <code>exclmethod</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If <code>region</code> is omitted from <code>design</code> then an attempt will be made to retrieve it from the mask attribute of <code>object</code> (this works if the call to <code><a href="#topic+make.mask">make.mask</a></code> used <code>keep.poly = TRUE</code>).
</p>


<h3>Value</h3>

<p>Dataframe with one row for each derived parameter (&lsquo;esa&rsquo;, &lsquo;D&rsquo;) and
columns as below
</p>

<table>
<tr>
 <td style="text-align: left;">
estimate    </td><td style="text-align: left;"> estimate of derived parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
SE.estimate </td><td style="text-align: left;"> standard error of the estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
lcl         </td><td style="text-align: left;"> lower 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
ucl         </td><td style="text-align: left;"> upper 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
CVn         </td><td style="text-align: left;"> relative SE of number observed (across sampling units) </td>
</tr>
<tr>
 <td style="text-align: left;">
CVa         </td><td style="text-align: left;"> relative SE of effective sampling area </td>
</tr>
<tr>
 <td style="text-align: left;">
CVD         </td><td style="text-align: left;"> relative SE of density estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>The variance of a Horvitz-Thompson-like estimate of density may be
estimated as the sum of two components, one due to uncertainty in the
estimate of effective sampling area (<code class="reqn">\hat{a}</code>) and the
other due to spatial variance in the total number of animals <code class="reqn">n</code>
observed on <code class="reqn">J</code> replicate sampling units (<code class="reqn">n =
    \sum_{j=1}^{J}{n_j}</code>). We use a delta-method approximation
that assumes independence of the components:
</p>
<p style="text-align: center;"><code class="reqn"> \widehat{\mbox{var}}(\hat{D}) = \hat{D}^2
    \{\frac{\widehat{\mbox{var}}(n)}{n^2} +
    \frac{\widehat{\mbox{var}}(\hat{a})}{\hat{a}^2}\} </code>
</p>

<p>where <code class="reqn">\widehat{\mbox{var}}(n) = \frac{J}{J-1}
  \sum_{j=1}^{J}(n_j-n/J)^2</code>. The
estimate of <code class="reqn">\mbox{var}(\hat{a})</code> is model-based while
that of <code class="reqn">\mbox{var}(n)</code> is design-based. This formulation follows
that of Buckland et al. (2001, p. 78) for conventional distance
sampling. Given sufficient independent replicates, it is a robust way
to allow for unmodelled spatial overdispersion.
</p>
<p>There is a complication in SECR owing to the fact that
<code class="reqn">\hat{a}</code> is a derived quantity (actually an integral)
rather than a model parameter. Its sampling variance
<code class="reqn">\mbox{var}(\hat{a})</code> is estimated indirectly in
<span class="pkg">secr</span> by combining the asymptotic estimate of the covariance
matrix of the fitted detection parameters <code class="reqn">\theta</code> with a
numerical estimate of the gradient of <code class="reqn">a(\theta)</code> with
respect to <code class="reqn">\theta</code>. This calculation is performed in
<code><a href="#topic+derived">derived</a></code>.
</p>


<h3>References</h3>

<p>Buckland, S. T., Anderson, D. R., Burnham, K. P., Laake, J. L., Borchers,
D. L. and Thomas, L. (2001) <em>Introduction to Distance Sampling:
Estimating Abundance of Biological Populations</em>. Oxford University
Press, Oxford.
</p>
<p>Fewster, R. M. (2011) Variance estimation for systematic designs in spatial 
surveys. <em>Biometrics</em> <b>67</b>, 1518&ndash;1531.
</p>
<p>Fewster, R. M., Buckland, S. T., Burnham, K. P., Borchers, D. L., Jupp, P. E., 
Laake, J. L. and Thomas, L. (2009) Estimating the encounter rate variance in 
distance sampling. <em>Biometrics</em> <b>65</b>, 225&ndash;236. 
</p>
<p>Stevens, D. L. Jr and Olsen, A. R. (2003) Variance estimation for
spatially balanced samples of environmental resources.
<em>Environmetrics</em> <b>14</b>, 593&ndash;610.
</p>
<p>Thompson, S. K. (2002) <em>Sampling</em>. 2nd edition. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derived">derived</a></code>, <code><a href="#topic+esa">esa</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The `ovensong' data are pooled from 75 replicate positions of a
## 4-microphone array. The array positions are coded as the first 4
## digits of each sound identifier. The sound data are initially in the
## object `signalCH'. We first impose a 52.5 dB signal threshold as in
## Dawson &amp; Efford (2009, J. Appl. Ecol. 46:1201--1209). The vector nj
## includes 33 positions at which no ovenbird was heard. The first and
## second columns of `temp' hold the estimated effective sampling area
## and its standard error.

## Not run: 

signalCH.525 &lt;- subset(signalCH, cutval = 52.5)
nonzero.counts &lt;- table(substring(rownames(signalCH.525),1,4))
nj &lt;- c(nonzero.counts, rep(0, 75 - length(nonzero.counts)))
temp &lt;- derived(ovensong.model.1, se.esa = TRUE)
derivednj(nj, temp["esa",1:2])

## The result is very close to that reported by Dawson &amp; Efford
## from a 2-D Poisson model fitted by maximizing the full likelihood.

## If nj vector has length 1, a theoretical variance is used...
msk &lt;- ovensong.model.1$mask
A &lt;- nrow(msk) * attr(msk, "area")
derivednj (sum(nj), temp["esa",1:2], method = "poisson")
derivednj (sum(nj), temp["esa",1:2], method = "binomial", area = A)

## Set up an array of small (4 x 4) grids,
## simulate a Poisson-distributed population,
## sample from it, plot, and fit a model.
## mash() condenses clusters to a single cluster

testregion &lt;- data.frame(x = c(0,2000,2000,0),
    y = c(0,0,2000,2000))
t4 &lt;- make.grid(nx = 4, ny = 4, spacing = 40)
t4.16 &lt;- make.systematic (n = 16, cluster = t4,
    region = testregion)
popn1 &lt;- sim.popn (D = 5, core = testregion,
    buffer = 0)
capt1 &lt;- sim.capthist(t4.16, popn = popn1)
fit1 &lt;- secr.fit(mash(capt1), CL = TRUE, trace = FALSE)

## Visualize sampling
tempmask &lt;- make.mask(t4.16, spacing = 10, type =
    "clusterbuffer")
plot(tempmask)
plot(t4.16, add = TRUE)
plot(capt1, add = TRUE)

## Compare model-based and empirical variances.
## Here the answers are similar because the data
## were simulated from a Poisson distribution,
## as assumed by \code{derived}

derived(fit1)
derivedMash(fit1)

## Now simulate a patchy distribution; note the
## larger (and more credible) SE from derivedMash().

popn2 &lt;- sim.popn (D = 5, core = testregion, buffer = 0,
    model2D = "hills", details = list(hills = c(-2,3)))
capt2 &lt;- sim.capthist(t4.16, popn = popn2)
fit2 &lt;- secr.fit(mash(capt2), CL = TRUE, trace = FALSE)
derived(fit2)
derivedMash(fit2)

## The detection model we have fitted may be extrapolated to
## a more fine-grained systematic sample of points, with
## detectors operated on a single occasion at each...
## Total effort 400 x 1 = 400 detector-occasions, compared
## to 256 x 5 = 1280 detector-occasions for initial survey.

t1 &lt;- make.grid(nx = 1, ny = 1)
t1.100 &lt;- make.systematic (cluster = t1, spacing = 100,
    region = testregion)
capt2a &lt;- sim.capthist(t1.100, popn = popn2, noccasions = 1)
## one way to get number of animals per point
nj &lt;- attr(mash(capt2a), "n.mash")
derivedExternal (fit2, nj = nj, cluster = t1, buffer = 100,
    noccasions = 1)

## Review plots
library(MASS)
base.plot &lt;- function() {
    eqscplot( testregion, axes = FALSE, xlab = "",
        ylab = "", type = "n")
    polygon(testregion)
}
par(mfrow = c(1,3), xpd = TRUE, xaxs = "i", yaxs = "i")
base.plot()
plot(popn2, add = TRUE, col = "blue")
mtext(side=3, line=0.5, "Population", cex=0.8, col="black")
base.plot()
plot (capt2a, add = TRUE,title = "Extensive survey")
base.plot()
plot(capt2, add = TRUE, title = "Intensive survey")
par(mfrow = c(1,1), xpd = FALSE, xaxs = "r", yaxs = "r")  ## defaults


## Weighted variance

derivedSession(ovenbird.model.1, method = "R2")


## End(Not run)

</code></pre>

<hr>
<h2 id='esa.plot'>
Mask Buffer Diagnostic Plot
</h2><span id='topic+esa.plot'></span>

<h3>Description</h3>

<p>Plot effective sampling area (Borchers and Efford 2008) as a function of increasing buffer width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
esa.plot (object, max.buffer = NULL, spacing = NULL, max.mask = NULL,
    detectfn, detectpar, noccasions, binomN = NULL, thin = 0.1,
    poly = NULL, poly.habitat = TRUE, session = 1, plt = TRUE, 
    type = c('density', 'esa', 'meanpdot', 'CVpdot'), n = 1, add = FALSE, 
    overlay = TRUE, conditional = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="esa.plot_+3A_object">object</code></td>
<td>
<p><code>traps</code> object or <code>secr</code> object output from <code>secr.fit</code> </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_max.buffer">max.buffer</code></td>
<td>
<p> maximum width of buffer in metres </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_spacing">spacing</code></td>
<td>
<p> distance between mask points </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_max.mask">max.mask</code></td>
<td>
 <p><code><a href="#topic+mask">mask</a></code> object </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_detectfn">detectfn</code></td>
<td>
<p> integer code or character string for shape of
detection function 0 = halfnormal etc. &ndash; see <a href="#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="esa.plot_+3A_detectpar">detectpar</code></td>
<td>
<p> list of values for named parameters of detection function </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_noccasions">noccasions</code></td>
<td>
<p> number of sampling occasions</p>
</td></tr>
<tr><td><code id="esa.plot_+3A_binomn">binomN</code></td>
<td>
<p> integer code for discrete distribution (see
<code><a href="#topic+secr.fit">secr.fit</a></code>) </p>
</td></tr>  
<tr><td><code id="esa.plot_+3A_thin">thin</code></td>
<td>
<p> proportion of mask points to retain in plot and output</p>
</td></tr>
<tr><td><code id="esa.plot_+3A_poly">poly</code></td>
<td>
<p> matrix of two columns interpreted as the x and y
coordinates of a bounding polygon (optional) </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_poly.habitat">poly.habitat</code></td>
<td>
<p>logical as in <code><a href="#topic+make.mask">make.mask</a></code> </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_session">session</code></td>
<td>
<p>vector of session indices (used if <code>object</code> spans multiple sessions)</p>
</td></tr>
<tr><td><code id="esa.plot_+3A_plt">plt</code></td>
<td>
<p> logical to plot results </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_type">type</code></td>
<td>
<p> character, what to plot </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_n">n</code></td>
<td>
<p> integer number of distinct individuals detected </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_add">add</code></td>
<td>
<p> logical to add line to an existing plot </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_overlay">overlay</code></td>
<td>
<p> logical; if TRUE then automatically <code>add = TRUE</code>
for plots after the first </p>
</td></tr>
<tr><td><code id="esa.plot_+3A_conditional">conditional</code></td>
<td>
<p>logical; if TRUE the reported mean and CV are conditional on detection 
(see <code><a href="#topic+CVpdot">CVpdot</a></code>)</p>
</td></tr>
<tr><td><code id="esa.plot_+3A_...">...</code></td>
<td>
<p> graphical arguments passed to plot() and lines()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effective sampling area (esa) is defined as the integral of net
capture probability (<code class="reqn">p.(\mathbf{X})</code>) over a
region. <code>esa.plot</code> shows the effect of increasing region size on
the value of esa for fixed values of the detection parameters. The
<code>max.buffer</code> or <code>max.mask</code> arguments establish the maximum
extent of the region; points (cells) within this mask are sorted by
their distance <code class="reqn">d_k</code> from the nearest detector. esa(buffer) is
defined as the cumulative sum of <code class="reqn">cp.(\mathbf{X})</code> for
<code class="reqn">d_k(\mathbf{X}) &lt;= \mbox{buffer}</code>, where <code class="reqn">c</code>
is the area associated with each cell.
</p>
<p>The default (<code>type = 'density'</code>) is to plot the reciprocal of esa
multiplied by <code>n</code>; this is on a more familiar scale (the density
scale) and hence is easier to interpret.
</p>
<p>Because <code>esa.plot</code> uses the criterion 'distance to nearest
detector', <code>max.mask</code> should be constructed to include all
habitable cells within the desired maximum buffer and no others. This
is achieved with <code>type = "trapbuffer"</code> in <code>make.mask</code>. It is
a good idea to set the <code>spacing</code> argument of <code>make.mask</code>
rather than relying on the default based on <code>nx</code>. Spacing may be
small (e.g. sigma/10) and the buffer of <code>max.mask</code> may be quite
large (e.g. 10 sigma), as computation is fast.
</p>
<p>Thinning serves to reduce redundancy in the plotted points, and (if
the result is saved and printed) to generate more legible numerical
output. Use <code>thin=1</code> to include all points.
</p>
<p><code>esa.plot</code> calls the internal function <code>esa.plot.secr</code> when
<code>object</code> is a fitted model. In this case <code>detectfn</code>,
<code>detectpar</code> and <code>noccasions</code> are inferred from
<code>object</code>. 
</p>


<h3>Value</h3>

<p>A dataframe with columns
</p>
<table>
<tr><td><code>buffer</code></td>
<td>
<p> buffer width </p>
</td></tr>
<tr><td><code>esa</code></td>
<td>
<p> computed effective sampling area </p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p> n/esa </p>
</td></tr> 
<tr><td><code>pdot</code></td>
<td>
 <p><code class="reqn">p.(\mathbf{X})</code> </p>
</td></tr>
<tr><td><code>pdotmin</code></td>
<td>
<p> cumulative minimum  (<code class="reqn">p.(\mathbf{X})</code>) </p>
</td></tr>
<tr><td><code>meanpdot</code></td>
<td>
<p> expected pdot across mask (see <code><a href="#topic+CVpdot">CVpdot</a></code>)</p>
</td></tr>
<tr><td><code>CVpdot</code></td>
<td>
<p> CV of pdot across mask (see <code><a href="#topic+CVpdot">CVpdot</a></code>)</p>
</td></tr>
</table>
<p>If <code>plt = TRUE</code> the dataframe is returned invisibly.
</p>


<h3>Note</h3>

<p>The response of effective sampling area to buffer width is just one
possible mask diagnostic; it's fast, graphic, and often
sufficient. <code><a href="#topic+mask.check">mask.check</a></code> performs more intensive checks,
usually for a smaller number of buffer widths.
</p>
<p>The old argument 'as.density' was superceded by 'type' in 3.1.7.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+pdot">pdot</a></code>, <code><a href="#topic+CVpdot">CVpdot</a></code>,
<code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+mask.check">mask.check</a></code>,
<code><a href="#topic+Detection+20functions">Detection functions</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## with previously fitted model
esa.plot(secrdemo.0)

## from scratch
trps &lt;- make.grid()
msk &lt;- make.mask(trps, buffer = 200, spacing = 5, type = "trapbuffer")
detectpar &lt;- list(g0 = 0.2, sigma = 25)
esa.plot(trps,,, msk, 0, detectpar, nocc = 10, col = "blue")
esa.plot(trps,,, msk, 0, detectpar, nocc = 5, col = "green",
    add = TRUE)

esa.plot(trps,,, msk, 0, detectpar, nocc = 5, thin = 0.002, plt = FALSE)


## End(Not run)

</code></pre>

<hr>
<h2 id='esa.plot.secr'>
Mask Buffer Diagnostic Plot (internal)
</h2><span id='topic+esa.plot.secr'></span>

<h3>Description</h3>

<p>Internal function used to plot effective sampling area (Borchers and
Efford 2008) as a function of increasing buffer width given an &lsquo;secr&rsquo;
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
esa.plot.secr (object, max.buffer = NULL, max.mask = NULL,
    thin = 0.1, poly = NULL, poly.habitat = TRUE, session = 1, plt = TRUE, 
    type = "density", add = FALSE, overlay = TRUE, conditional = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="esa.plot.secr_+3A_object">object</code></td>
<td>
<p><code>secr</code> object output from <code>secr.fit</code> </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_max.buffer">max.buffer</code></td>
<td>
<p> maximum width of buffer in metres </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_max.mask">max.mask</code></td>
<td>
 <p><code><a href="#topic+mask">mask</a></code> object </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_thin">thin</code></td>
<td>
<p> proportion of mask points to retain in plot and output</p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_poly">poly</code></td>
<td>
<p> matrix of two columns interpreted as the x and y
coordinates of a bounding polygon (optional) </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_poly.habitat">poly.habitat</code></td>
<td>
<p>logical as in <code><a href="#topic+make.mask">make.mask</a></code> </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_session">session</code></td>
<td>
<p>vector of session indices (used if <code>object</code> spans multiple sessions)</p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_plt">plt</code></td>
<td>
<p> logical to plot results </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_type">type</code></td>
<td>
<p> character; see <code><a href="#topic+esa.plot">esa.plot</a></code></p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_add">add</code></td>
<td>
<p> logical to add line to an existing plot </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_overlay">overlay</code></td>
<td>
<p> logical; if TRUE then automatically <code>add = TRUE</code>
for plots after the first </p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_conditional">conditional</code></td>
<td>
<p>logical; see <code><a href="#topic+esa.plot">esa.plot</a></code></p>
</td></tr>
<tr><td><code id="esa.plot.secr_+3A_...">...</code></td>
<td>
<p> graphical arguments passed to plot() and lines()</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>esa.plot.secr</code> provides a wrapper for <code><a href="#topic+esa.plot">esa.plot</a></code>
that is called internally from esa.plot when it is presented with an
secr object. Arguments of <code>esa.plot</code> such as <code>detectfn</code> are
inferred from the fitted model.
</p>
<p>If <code>max.mask</code> is not specified then a maximal mask of type
&lsquo;trapbuffer&rsquo; is constructed using <code>max.buffer</code> and the spacing of
the mask in <code>object</code>. In this case, if <code>max.buffer</code> is not
specified then it is set either to the width of the existing plot
(<code>add = TRUE</code>) or to 10 x sigma-hat from the fitted model in
<code>object</code> (<code>add = FALSE</code>).
</p>


<h3>Value</h3>

<p>see <code>esa.plot</code>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+esa.plot">esa.plot</a></code>, <code><a href="#topic+mask">mask</a></code>,
<code><a href="#topic+pdot">pdot</a></code>, <code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+mask.check">mask.check</a></code>,
<code><a href="#topic+Detection+20functions">Detection functions</a></code> 
</p>

<hr>
<h2 id='expected.n'>
Expected Number of Individuals
</h2><span id='topic+expected.n'></span>

<h3>Description</h3>

<p>Computes the expected number of individuals detected across a detector
layout or at each cluster of detectors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
expected.n(object, session = NULL, group = NULL, bycluster
    = FALSE, splitmask = FALSE, ncores = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected.n_+3A_object">object</code></td>
<td>
 <p><code>secr</code> object output from <code>secr.fit</code> </p>
</td></tr>
<tr><td><code id="expected.n_+3A_session">session</code></td>
<td>
<p> character session vector </p>
</td></tr>
<tr><td><code id="expected.n_+3A_group">group</code></td>
<td>
<p> group &ndash; for future use </p>
</td></tr>
<tr><td><code id="expected.n_+3A_bycluster">bycluster</code></td>
<td>
<p> logical to output the expected number for
clusters of detectors rather than whole array </p>
</td></tr>
<tr><td><code id="expected.n_+3A_splitmask">splitmask</code></td>
<td>
<p>logical for computation method (see Details)</p>
</td></tr>
<tr><td><code id="expected.n_+3A_ncores">ncores</code></td>
<td>
<p> integer number of threads to be used for parallel processing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected number of individuals detected is <code class="reqn">E(n) = \int p.(X)
  D(X) dX</code> where the integration is a
summation over <code>object$mask</code>. <code class="reqn">p.(X)</code> is the probability an
individual at <code class="reqn">X</code> will be detected at least once either on the
whole detector layout (<code>bycluster = FALSE</code>) or on the detectors
in a single cluster (see <a href="#topic+pdot">pdot</a> for more on <code class="reqn">p.</code>). <code class="reqn">D(X)</code>
is the expected density at <code class="reqn">X</code>, given the model. <code class="reqn">D(X)</code> is
constant (i.e. density surface flat) if <code>object$CL == TRUE</code> or
<code>object$model$D == ~1</code>, and for some other possible models.
</p>
<p>If the <code>bycluster</code> option is selected and detectors are not, in
fact, assigned to clusters then each detector will be treated as a
cluster, with a warning.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>By default, a full habitat mask is used for each cluster. This is the
more robust option. Alternatively, the mask may be split into subregions
defined by the cells closest to each cluster.
</p>
<p>The calculation takes account of any fitted continuous model for spatial
variation in density (note Warning).
</p>


<h3>Value</h3>

<p>The expected count (bycluster = FALSE) or a vector of expected counts,
one per cluster. For multi-session data, a list of such vectors.
</p>


<h3>Warning</h3>

<p>This function changed slightly between 2.1.0 and 2.1.1, and now
performs as indicated here when bycluster = TRUE and
clusters are not specified.
</p>
<p>Clusters of detectors are assumed to be independent (always true with detector types
&lsquo;proximity&rsquo;, &lsquo;count&rsquo; etc.). The computed E(n) does not apply when
there is competition among clusters of detectors.
</p>
<p>The prediction of density at present considers only the base level of
density covariates, such as cell-specific habitat variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+region.N">region.N</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

expected.n(secrdemo.0)
expected.n(secrdemo.0, bycluster = TRUE)
expected.n(ovenbird.model.D)

## Clustered design
mini &lt;- make.grid(nx = 3, ny = 3, spacing = 50, detector =
    "proximity")
tempgrids &lt;- trap.builder (cluster = mini , method = "all",
    frame = expand.grid(x = seq(1000, 9000, 2000),
    y = seq(1000, 9000, 2000)), plt = TRUE)
capt &lt;- sim.capthist(tempgrids, popn = list(D = 2))
tempmask &lt;- make.mask(tempgrids, buffer = 100,
    type = "clusterbuffer")
fit &lt;- secr.fit(capt, mask = tempmask, trace = FALSE)
En &lt;- expected.n(fit, bycluster = TRUE)

## GoF or overdispersion statistic
p &lt;- length(fit$fit$par)
y &lt;- cluster.counts(capt)
## scaled by n-p
sum((y - En)^2 / En) / (length(En)-p)
sum((y - En)^2 / En) / sum(y/En)


## End(Not run)

</code></pre>

<hr>
<h2 id='extractMoves'>Simulated Movements</h2><span id='topic+extractMoves'></span>

<h3>Description</h3>

<p>Extract movements from a previously simulated multi-session population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
extractMoves(pop, plotn = NULL, add = FALSE, collapse = TRUE, maxradius = Inf, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractMoves_+3A_pop">pop</code></td>
<td>
<p>popn object from <code><a href="#topic+sim.popn">sim.popn</a></code></p>
</td></tr>
<tr><td><code id="extractMoves_+3A_plotn">plotn</code></td>
<td>
<p>integer maximum number of instances to plot at each session</p>
</td></tr>
<tr><td><code id="extractMoves_+3A_add">add</code></td>
<td>
<p>logical for whether to add to existing plot</p>
</td></tr>
<tr><td><code id="extractMoves_+3A_collapse">collapse</code></td>
<td>
<p>logical; if TRUE plots for sessions 2, 3,... are added to the first</p>
</td></tr>
<tr><td><code id="extractMoves_+3A_maxradius">maxradius</code></td>
<td>
<p>numeric radius for selecting subset of initial locations</p>
</td></tr>
<tr><td><code id="extractMoves_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+arrows">arrows</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly used to check the movement simulations.
</p>
<p>Moves are constrained by the edge (argument &lsquo;edgemethod&rsquo; of <code><a href="#topic+sim.popn">sim.popn</a></code>). &lsquo;maxradius&rsquo; may be set to restrict the extraction to the subset of animals initially near the centroid of the arena in each session.
</p>
<p>Plotting uses the graphics function <code><a href="graphics.html#topic+arrows">arrows</a></code> that has some quirks, such as difficult-to-suppress warnings for zero-length moves. Set <code>code = 0</code> to suppress arrowheads; <code>length = 0.1</code> to shorten to 0.1 inches, etc.
</p>


<h3>Value</h3>

<p>List of data frames, one for each session but the last (columns &lsquo;x1&rsquo;,&lsquo;y1&rsquo;,&lsquo;x2&rsquo;,&lsquo;y2&rsquo;,&lsquo;d&rsquo;).
</p>


<h3>See Also</h3>

<p><a href="#topic+turnover">turnover</a>, <code><a href="#topic+sim.popn">sim.popn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
pop3 &lt;- sim.popn(D = 2, core = make.grid(), buffer = 200, nsessions = 3, 
    details = list(lambda = 1.0, movemodel = 'BVE', move.a = 50, 
    edgemethod = 'stop'))
m &lt;- extractMoves(pop3, plotn = 10, length = 0.1)
mean(unlist(sapply(m, '[', 'd')))    # less than nominal 2 x move.a

# For distances closer to nominal for BVE (2 x move.a = 100), 
# increase size of arena (e.g., buffer = 500) and consider only 
# central animals (e.g., maxradius = 300).

</code></pre>

<hr>
<h2 id='FAQ'> Frequently Asked Questions, And Others </h2><span id='topic+FAQ'></span>

<h3>Description</h3>

<p>A place for hints and miscellaneous advice. 
</p>


<h3>How do I install and start secr?</h3>

<p>Follow the usual procedure for installing from CRAN archive (see menu
item Packages | Install package(s)... in Windows). You also need to get
the package <span class="pkg">abind</span> from CRAN.
</p>
<p>Like other contributed packages, <b>secr</b> needs to be loaded before
each use e.g.,<code>library(secr)</code>.
</p>
<p>You can learn about changes in the current version with
<code>news(package = "secr")</code>.
</p>


<h3>How can I get help?</h3>

<p>There are three general ways of displaying documentation from within <span class="rlang"><b>R</b></span>.
Firstly, you can bring up help pages for particular functions from the
command prompt.  For example:
</p>
<p><code>?secr</code>
or
<code>?secr.fit</code>
</p>
<p>Secondly, help.search() lets you ask for a list of the help pages on a
vague topic (or just use ?? at the prompt).  For example:
</p>
<p><code>?? "linear models"</code>
</p>
<p>Thirdly, you can display various <span class="pkg">secr</span> documents listed in
<code><a href="#topic+secr-package">secr-package</a></code>.
</p>
<p>Tip: to search all secr help pages open the pdf version of the manual in
Acrobat Reader (<a href="https://www.otago.ac.nz/density/pdfs/secr-manual.pdf">secr-manual.pdf</a>; see also ?secr) and use
&lt;ctrl&gt; F.
</p>
<p>There is a support forum at <a href="http://www.phidot.org/forum/">http://www.phidot.org/forum/</a> under
&lsquo;DENSITY|secr&rsquo; and another at <a href="https://groups.google.com/forum/#!forum/secrgroup">secrgroup</a>. See below for
more <span class="rlang"><b>R</b></span> tips. Some specific problems with <code>secr.fit</code> are covered in
<a href="#topic+Troubleshooting">Troubleshooting</a>.
</p>


<h3> How should I report a problem? </h3>

<p>If you get really stuck or find something you think is a bug then please
report the problem to one of the online lists.
</p>
<p>You may be asked to send an actual dataset - ideally, the simplest one
that exhibits the problem. Use <code><a href="base.html#topic+save">save</a></code> to wrap
several <span class="rlang"><b>R</b></span> objects together in one .RData file, e.g.,
<code>save("captdata", "secrdemo.0", "secrdemo.b", file =
"mydata.RData")</code>. Also, paste into the text of your message the output
from <code>packageDescription( "secr" )</code>.
</p>


<h3> Why do I get different answers from secr and Density? </h3>

<p>Strictly speaking, this should not happen if you have specified the same
model and likelihood, although you may see a little variation due to the
different maximization algorithms. Likelihoods (and estimates) may
differ if you use different integration meshes (habitat masks), which
can easily happen because the programs differ in how they set up the
mesh.  If you want to make a precise comparison, save the Density mesh
to a file and read it into <span class="pkg">secr</span>, or vice versa.
</p>
<p>Extreme data, especially rare long-distance movements, may be handled
differently by the two programs. The &lsquo;minprob&rsquo; component of the
&lsquo;details&rsquo; argument of <code>secr.fit</code> sets a lower threshold of
probability for capture histories (smaller values are all set to
minprob), whereas Density has no explicit limit.
</p>


<h3> How can I speed up model fitting and model selection?</h3>

<p>There are many ways - see <a href="#topic+Speed+20tips">Speed tips</a> and 
<a href="https://www.otago.ac.nz/density/pdfs/secr-troubleshooting.pdf">secr-troubleshooting.pdf</a>.
</p>
<p>Keep the number of mask points to a minimum and avoid detection covariates with many levels.
</p>


<h3> Does secr use multiple cores?</h3>

<p>Some computations can be run in parallel on multiple processors (most desktops these days have multiple cores). Likelihood calculations in <code>secr.fit</code> assign capture histories to multiple parallel threads whenever possible. 
</p>
<p>The number of threads (cores) is controlled by an environment variable set by <code><a href="#topic+setNumThreads">setNumThreads</a></code> or the 'ncores' argument of some functions. 
</p>


<h3> Can a model use detector-level covariates that vary over
time?</h3>

<p>Yes. See ?timevaryingcov. However, a more direct way to control for
varying effort is provided - see the '<a href="#topic+usage">usage</a>' atribute, which
now allows a continuous measure of effort
(<a href="https://www.otago.ac.nz/density/pdfs/secr-varyingeffort.pdf">secr-varyingeffort.pdf</a>). 
</p>
<p>A tip: covariate models for detection fit more quickly when the covariate takes only a few different values. Use <code><a href="#topic+binCovariate">binCovariate</a></code> to bin values.
</p>


<h3>Things You Might Need To Know About <span class="rlang"><b>R</b></span></h3>

<p>The function <code>findFn</code> in package <span class="pkg">sos</span> lets you search CRAN for
R functions by matching text in their documentation.
</p>
<p>There is now a vast amount of <span class="rlang"><b>R</b></span> advice available on the web. For the
terminally frustrated, &lsquo;R inferno&rsquo; by Patrick Burns is recommended
(<a href="https://www.burns-stat.com/pages/Tutor/R_inferno.pdf">https://www.burns-stat.com/pages/Tutor/R_inferno.pdf</a>). &quot;If you are using
R and you think you're in hell, this is a map for you&quot;.
</p>
<p>Method functions for S3 classes cannot be listed in the usual way by
typing the function name at the <span class="rlang"><b>R</b></span> prompt because they are &lsquo;hidden&rsquo; in a
namespace. Get around this with getAnywhere(). For example:
</p>
<p><code>getAnywhere(print.secr)</code>
</p>
<p>R objects have &lsquo;attributes&rsquo; that usually are kept out of sight.
Important attributes are &lsquo;class&rsquo; (all objects), &lsquo;dim&rsquo; (matrices and
arrays) and &lsquo;names&rsquo; (lists). <span class="pkg">secr</span> hides quite a lot of useful data
as named &lsquo;attributes&rsquo;. Usually you will use summary and extraction
methods (<code>traps</code>, <code>covariates</code>, <code>usage</code> etc.) to view and change
the attributes of the various classes of object in <span class="pkg">secr</span>. If you're
curious, you can reveal the lot with &lsquo;attributes&rsquo;.  For example, with
the demonstration capture history data &lsquo;captdata&rsquo;:
</p>
<p><code>traps(captdata)       ## extraction method for `traps'</code>
</p>
<p><code>attributes(captdata)  ## all attributes</code>
</p>
<p>Also, the function <code>str</code> provides a compact summary of any object:
</p>
<p><code>str(captdata)</code>
</p>


<h3>References</h3>

<p>Claeskens, G. and Hjort N. L. (2008) <em>Model Selection and Model
Averaging</em>. Cambridge: Cambridge University Press.
</p>

<hr>
<h2 id='Fletcher.chat'>Estimate overdispersion</h2><span id='topic+Fletcher.chat'></span>

<h3>Description</h3>

 
<p>General function for estimating a variance inflation factor (<code class="reqn">\hat c</code>) from observed counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Fletcher.chat (observed, expected, np, verbose = TRUE, 
    type = c('Fletcher', 'Wedderburn', 'both'), multinomial = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fletcher.chat_+3A_observed">observed</code></td>
<td>
<p>integer vector of observed counts, or a list of such vectors</p>
</td></tr>
<tr><td><code id="Fletcher.chat_+3A_expected">expected</code></td>
<td>
<p>numeric vector of expected counts</p>
</td></tr>
<tr><td><code id="Fletcher.chat_+3A_np">np</code></td>
<td>
<p>integer number of parameters estimated</p>
</td></tr>
<tr><td><code id="Fletcher.chat_+3A_verbose">verbose</code></td>
<td>
<p>logical; if TRUE returns extended output</p>
</td></tr>
<tr><td><code id="Fletcher.chat_+3A_type">type</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="Fletcher.chat_+3A_multinomial">multinomial</code></td>
<td>
<p>logical; if TRUE, one df is subtracted for the constraint</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Fletcher.chat</code> applies the overdispersion formula of Fletcher (2012) or computes the conventional (Wedderburn 1974) variance inflation factor <code class="reqn">X^2/df</code>. It is used by <code><a href="#topic+chat.nk">chat.nk</a></code> and <code><a href="#topic+adjustVarD">adjustVarD</a></code>. The inputs &lsquo;observed&rsquo; and &lsquo;expected&rsquo; are vectors of counts (e.g., number of distinct individuals per detector); &lsquo;observed&rsquo; may also be a list of such vectors, possibly simulated.
</p>


<h3>Value</h3>

<p>Output depends on &lsquo;verbose&rsquo;, &lsquo;observed&rsquo; and &lsquo;type&rsquo;:
</p>
<p>&ndash; if &lsquo;observed&rsquo; is a list of nk vectors (usually generated by simulation) then the output is a vector of (Fletcher or Wedderburn) <code class="reqn">\hat c</code> values, one element for each component of &lsquo;observed&rsquo;, unless type = &quot;both&quot; when the output is a list of two such vectors. Argument &lsquo;verbose&rsquo; is ignored.
</p>
<p>&ndash; if &lsquo;observed&rsquo; is a simple vector then &lsquo;verbose&rsquo; output is a list comprising input values, various summary statistics, and the computed Fletcher overdispersion (&lsquo;chat&rsquo;). The statistic &lsquo;cX2&rsquo; is the conventional variance inflation factor of Wedderburn (1974) &ndash; <code class="reqn">X^2/df</code>. For <code>verbose = FALSE</code>, a single estimate of <code class="reqn">\hat c</code> is returned when <code>type = "Fletcher"</code> or <code>type = "Wedderburn"</code>, otherwise a vector of the two estimates.
</p>


<h3>References</h3>

<p>Fletcher, D. (2012) Estimating overdispersion when fitting a generalized linear model to sparse data.
<em>Biometrika</em> <b>99</b>, 230&ndash;237.
</p>
<p>Wedderburn, R. W. M. (1974) Quasi-likelihood functions, generalized linear models, and the Gauss-Newton
method. <em>Biometrika</em> <b>61</b>, 439&ndash;47.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chat.nk">chat.nk</a></code>,
<code><a href="#topic+adjustVarD">adjustVarD</a></code>
</p>

<hr>
<h2 id='fx.total'>Activity Centres of Detected and
Undetected Animals</h2><span id='topic+fx.total'></span>

<h3>Description</h3>

<p>The summed probability densities of both observed and
unobserved individuals are computed for a fitted model and dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fx.total(object, sessnum = 1, mask = NULL, ncores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fx.total_+3A_object">object</code></td>
<td>
<p>  a fitted secr model </p>
</td></tr>
<tr><td><code id="fx.total_+3A_sessnum">sessnum</code></td>
<td>
<p> session number if <code>object$capthist</code> spans
multiple sessions </p>
</td></tr>
<tr><td><code id="fx.total_+3A_mask">mask</code></td>
<td>
<p> x- and y- coordinates of points at which density will be
computed</p>
</td></tr>
<tr><td><code id="fx.total_+3A_ncores">ncores</code></td>
<td>
<p> integer number of threads to be used for parallel processing</p>
</td></tr>
<tr><td><code id="fx.total_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code>detectpar</code> and thence
to <code>predict.secr</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+fxi.secr">fxi.secr</a></code> for each detected animal and
overlays the results to obtain a summed probability density surface D.fx
for the locations of the home-range centres of detected individuals.
</p>
<p>A separate calculation using <code><a href="#topic+pdot">pdot</a></code> provides the expected
spatial distribution of undetected animals, as another density
surface: crudely, D.nc(X) = D(X) * ( 1 &ndash; pdot(X)).
</p>
<p>The pointwise sum of the two surfaces is sometimes used to represent the
spatial distrbution of the population, but see Notes.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>


<h3>Value</h3>

<p>An object of class &lsquo;Dsurface&rsquo; (a variety of mask) with a &lsquo;covariates&rsquo;
attribute that is a dataframe with columns &ndash;
</p>
<table>
<tr><td><code>D.fx</code></td>
<td>
<p>sum of <code><a href="#topic+fxi">fxi</a></code> over all detected individuals</p>
</td></tr>
<tr><td><code>D.nc</code></td>
<td>
<p>expected density of undetected (&lsquo;not caught&rsquo;) individuals</p>
</td></tr>
<tr><td><code>D.sum</code></td>
<td>
<p>sum of D.fx and D.nc</p>
</td></tr>
</table>
<p>All densities are in animals per hectare (the &lsquo;scale&rsquo; argument of
<code><a href="#topic+plot.Dsurface">plot.Dsurface</a></code> allows the units to be varied later).
</p>


<h3>Note</h3>

<p>The surface D.sum represents what is known from the data about a
specific realisation of the spatial point process for home range
centres: varying the intensity of sampling will change its shape. It is
not an unbiased estimate of a biologically meaningful density
surface. The surface will always tend to lack relief towards the edge of
a habitat mask where the main or only contribution is from D.nc.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fxi.secr">fxi.secr</a></code>, <code><a href="#topic+fxi.contour">fxi.contour</a></code>, <code><a href="#topic+pdot">pdot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

tmp &lt;- fx.total(secrdemo.0)

## to plot we must name one of the covariates:
## the Dsurface default 'D.0' causes an error 

plot(tmp, covariate = 'D.sum', col = terrain.colors(16),
   plottype = 'shaded')
plot(tmp, covariate = 'D.sum', col = 'white', add = TRUE,
   plottype = 'contour')
if (interactive()) {
    spotHeight(tmp, prefix = 'D.sum')
}

fxsurface &lt;- fx.total(ovenbird.model.D, sessnum = 3)
plot(fxsurface, covariate = 'D.sum')


## End(Not run)


</code></pre>

<hr>
<h2 id='fxi'> Probability Density of Home Range Centre </h2><span id='topic+fxi.contour'></span><span id='topic+fxi.mode'></span><span id='topic+fxi.secr'></span><span id='topic+fxi'></span>

<h3>Description</h3>

<p>Display contours of the probability density function for the estimated
location of one or more range centres, compute values for
particular points X, or compute mode of pdf. The pdf is given by
<code class="reqn">f(X_j|\omega_i) = \mbox{Pr}(\omega_i|X_j)\pi(X_j)</code>, where <code class="reqn">\pi(X)</code> is the probability density
of range centres across the mask (Borchers and Efford 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fxi.contour (object, i = 1, sessnum = 1, border = 100, nx = 64,
    levels = NULL, p = seq(0.1,0.9,0.1), plt = TRUE, add = FALSE,
    fitmode = FALSE, plotmode = FALSE, fill = NULL,
    output = c('list','sf','SPDF'), ncores = NULL, ...)
fxi.secr(object, i = NULL, sessnum = 1, X = NULL, ncores = NULL)
fxi.mode(object, i = 1, sessnum = 1, start = NULL, ncores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fxi_+3A_object">object</code></td>
<td>
<p> a fitted secr model </p>
</td></tr>
<tr><td><code id="fxi_+3A_i">i</code></td>
<td>
<p> integer or character vector of individuals (defaults to all in fxi.secr),
or a single individual as input to fxi.mode </p>
</td></tr>
<tr><td><code id="fxi_+3A_sessnum">sessnum</code></td>
<td>
<p> session number if <code>object$capthist</code> spans
multiple sessions</p>
</td></tr>
<tr><td><code id="fxi_+3A_border">border</code></td>
<td>
<p> width of blank margin around the outermost detectors </p>
</td></tr>
<tr><td><code id="fxi_+3A_nx">nx</code></td>
<td>
<p> dimension of interpolation grid in x-direction </p>
</td></tr>
<tr><td><code id="fxi_+3A_levels">levels</code></td>
<td>
<p> numeric vector of confidence levels for Pr(X|wi)</p>
</td></tr>
<tr><td><code id="fxi_+3A_p">p</code></td>
<td>
<p> numeric vector of contour levels as probabilities </p>
</td></tr>
<tr><td><code id="fxi_+3A_plt">plt</code></td>
<td>
<p>logical to plot contours</p>
</td></tr>
<tr><td><code id="fxi_+3A_add">add</code></td>
<td>
<p>logical to add contour(s) to an existing plot </p>
</td></tr>
<tr><td><code id="fxi_+3A_fitmode">fitmode</code></td>
<td>
<p>logical to refine estimate of mode of each pdf</p>
</td></tr>
<tr><td><code id="fxi_+3A_plotmode">plotmode</code></td>
<td>
<p>logical to plot mode of each pdf</p>
</td></tr>
<tr><td><code id="fxi_+3A_x">X</code></td>
<td>
<p>2-column matrix of x- and y- coordinates (defaults to mask)</p>
</td></tr>
<tr><td><code id="fxi_+3A_fill">fill</code></td>
<td>
<p> vector of colours to fill contours (optional)</p>
</td></tr>
<tr><td><code id="fxi_+3A_output">output</code></td>
<td>
<p> character; format of output (list, sf or SpatialPolygonsDataFrame)</p>
</td></tr>
<tr><td><code id="fxi_+3A_ncores">ncores</code></td>
<td>
<p> integer number of threadss to be used for parallel processing</p>
</td></tr>
<tr><td><code id="fxi_+3A_start">start</code></td>
<td>
<p> vector of x-y coordinates for maximization </p>
</td></tr>
<tr><td><code id="fxi_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>contour</code> or <code>nlm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fxi.contour</code> computes contours of probability density for one
or more detection histories. Increase <code>nx</code> for smoother
contours. If <code>levels</code> is not set, contour levels are set
to approximate the confidence levels in <code>p</code>.
</p>
<p><code>fxi.secr</code> computes the probability density for one or more
detection histories; <code>X</code> may contain coordinates for one or
several points; a dataframe or vector (x then y) will be coerced to a
matrix.
</p>
<p><code>fxi.mode</code> attempts to find the x- and y-coordinates
corresponding to the maximum of the pdf for a single detection history
(i.e. <code>i</code> is of length 1). <code>fxi.mode</code> calls
<code><a href="stats.html#topic+nlm">nlm</a></code>.
</p>
<p><code>fxi.contour</code> with <code>fitmode = TRUE</code> calls <code>fxi.mode</code>
for each individual. Otherwise, the reported mode is an approximation
(mean of coordinates of highest contour).
</p>
<p>If <code>i</code> is character it will be matched to row names of
object$capthist (restricted to the relevant session in the case of a
multi-session fit); otherwise it will be interpreted as a row number.
</p>
<p>Values of the pdf are normalised by dividing by the
integral of <code class="reqn">\mbox{Pr}(\omega_i|X)\pi(X)</code>
over the habitat mask in <code>object</code>. (May differ in secr 4.0).
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>If <code>start</code> is not provided to <code>fit.mode</code> then (from 2.9.4) the weighted mean of 
all detector sites is used (see Warning below).
</p>
<p>The ... argument gives additional control over a contour plot; for
example, set <code>drawlabels = FALSE</code> to suppress contour labels.
</p>


<h3>Value</h3>

<p><code>fxi.contour</code> (output = 'list') &ndash;
</p>
<p>Coordinates of the plotted contours are returned as a list with one
component per polygon. The list is returned invisibly if plt = TRUE.
</p>
<p>An additional component &lsquo;mode&rsquo; reports the x-y coordinates of the
highest point of each pdf (see Details).
</p>
<p><code>fxi.contour</code> (output = 'SPDF') &ndash;
</p>
<p>Contours are returned as a SpatialPolygonsDataFrame (see package
<span class="pkg">sp</span>) with one component per animal. The attributes dataframe has two columns, the x-
and y-coordinates of the mode. The SpatialPolygonsDataFrame is returned
invisibly if plt = TRUE.
</p>
<p><code>fxi.contour</code> (output = 'sf') &ndash; simple features 'sf' object, as for SPDF.
</p>
<p><code>fxi.secr</code> &ndash;
</p>
<p>Vector of probability densities
</p>
<p><code>fxi.mode</code> &ndash;
</p>
<p>List with components &lsquo;x&rsquo; and &lsquo;y&rsquo;
</p>


<h3>Warnings</h3>

<p><code>fxi.mode</code> may fail to find the true mode unless a good starting
point is provided. Note that the distribution may have multiple modes and 
only one is reported. The default value of <code>start</code> before <span class="pkg">secr</span> 2.9.4 
was the first detected location of the animal. 
</p>


<h3>Note</h3>

<p>From <span class="pkg">secr</span> 2.8.3, these functions work with both homogeneous
and inhomogeneous Poisson density models, and <code>fxi.secr</code> accepts
vector-valued <code>i</code>.
</p>
<p>See <code><a href="#topic+fx.total">fx.total</a></code> for a surface summed across individuals.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdot.contour">pdot.contour</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="#topic+fx.total">fx.total</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

fxi.secr(secrdemo.0, i = 1, X = c(365,605))

## contour first 5 detection histories
plot(secrdemo.0$capthist)
fxi.contour (secrdemo.0, i = 1:5, add = TRUE,
    plotmode = TRUE, drawlabels = FALSE)

## extract modes only
## these are more reliable than those from fit.mode called directly as
## they use a contour-based approximation for the starting point
fxiout &lt;- fxi.contour (secrdemo.0, i = 1:5, plt = FALSE, fitmode = TRUE)
t(sapply(fxiout, "[[", "mode"))

## using fill colours
## lty = 0 suppresses contour lines
## nx = 256 ensures smooth outline
plot(traps(captdata))
fxi.contour(secrdemo.0, i = 1:5, add = TRUE, p = c(0.5,0.95), drawlabels
    = FALSE, nx = 256, fill = topo.colors(4), lty = 0)

## output as simple features
sf &lt;- fxi.contour(secrdemo.0, i = 1:3, plt = FALSE, p = c(0.5,0.95),
    nx = 256, output = 'sf', fitmode = TRUE)

## save as ESRI shapefile testsf.shp etc.
library(sf)
st_write(sf, 'testsf.shp')
## plot contours and modes
plot(st_as_sfc(sf))    # outline only
points(sf$modex, sf$modey)

## output as SpatialPolygonsDataFrame
spdf &lt;- fxi.contour(secrdemo.0, i = 1:3, plt = FALSE, p = c(0.5,0.95),
    nx = 256, output = 'SPDF', fitmode = TRUE)
sp::plot(spdf)
points(data.frame(spdf))


## End(Not run)

</code></pre>

<hr>
<h2 id='gridCells'>Construct Grid Cells</h2><span id='topic+gridCells'></span>

<h3>Description</h3>

<p>Forms grid cells centred on input points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
gridCells(x, cellsize = spacing(x), crs = NA)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridCells_+3A_x">x</code></td>
<td>
<p>matrix or dataframe with x- and y-coordinates</p>
</td></tr>
<tr><td><code id="gridCells_+3A_cellsize">cellsize</code></td>
<td>
<p>length of gridcell side</p>
</td></tr>
<tr><td><code id="gridCells_+3A_crs">crs</code></td>
<td>
<p>crs description suitable for <code><a href="sf.html#topic+st_crs">st_crs</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument x will often be a traps or mask object with spacing attribute. Otherwise <code>cellsize</code> must be provided.
</p>


<h3>Value</h3>

<p>A simple features (sf) object of class &lsquo;sfc_MULTIPOLYGON&rsquo;.
</p>
<p><code>crs</code> may be the integer  EPSG code (e.g. 3578 Yukon Albers).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotMaskEdge">plotMaskEdge</a></code>, <code><a href="#topic+spacing">spacing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(gridCells(traps(captdata)))
plot(traps(captdata), add = TRUE)
</code></pre>

<hr>
<h2 id='hcov'> Hybrid Mixture Model </h2><span id='topic+hcov'></span>

<h3>Description</h3>

<p>The argument <code>hcov</code> in <code>secr.fit</code> is used to fit a hybrid
mixture model. &lsquo;Hybrid&rsquo; refers to a flexible combination of latent
classes (as in a finite mixture) and known classes (cf groups or
sessions). A hybrid mixture model includes a parameter &lsquo;pmix&rsquo; for the
mixing proportion and optionally allows detection parameters to be
modelled as class-specific ( ~ h2). This is particularly useful for
modelling sex ratio and sex differences in detection, and matches the
Bayesian sex-specific model of Gardner et al. (2010).
</p>
<p>For observed animals all of unknown class the model is identical to a
finite mixture (i.e. latent-class) model. For observed animals all of
known class, the classes are no longer &lsquo;latent&rsquo; and the model is
equivalent to a grouped model with an additional binomial factor for
class membership.
</p>


<h3>Assumptions</h3>

<p><code>hcov</code> identifies a single individual covariate (the class
covariate) that should be a factor with two levels, or contain
character values that will be coerced to a factor (e.g., &lsquo;f&rsquo;,
&lsquo;m&rsquo;). Missing values (NA) are used for individuals of unknown
class. If <code>hcov</code> has more than two levels, all but the first two
levels are converted to NA (but see exception for h3 models below).
</p>
<p>It is assumed that the probability of recording a missing value for
the class covariate is independent of the true class membership (e.g.,
sex equally likely to be recorded for males and females).
</p>


<h3>Operational details</h3>

<p>A hybrid mixture model is fitted whenever <code>hcov</code> is not
NULL. Mixture models include a parameter &lsquo;pmix&rsquo;, the mixing
proportion. If the covariate identified by <code>hcov</code> is missing (''
or NA) for all individuals <em>and</em> a mixture term (h2 or h3)
appears in the detection model (e.g., g0 ~ h2) then a conventional
finite mixture model is fitted (cf Pledger 2000, Borchers &amp; Efford
2008).
</p>
<p>As with finite mixture models, any detection parameter (g0, sigma
etc.) may be modelled as depending on mixture class by model
specifications such as (g0 ~ h2, sigma ~ h2). See Examples.
</p>
<p>In general <code>hcov</code> has been designed for two classes and two
classes are assumed if neither &lsquo;h2&rsquo; nor &lsquo;h3&rsquo; appears in the model
formulae. However, there is a small exception: <code>hcov</code> may have
three non-missing levels if &lsquo;h3&rsquo; appears in a model formula. Note
that h2 cannot be combined with h3; h3 is for advanced use only and
has not been fully tested.
</p>
<p>The number of fitted parameters is the same as the corresponding
finite mixture model if mixture terms (&lsquo;h2&rsquo;, &lsquo;h3&rsquo;) appear in the model
formulae. Otherwise (no mixture terms) estimating pmix requires a
single extra parameter. The estimate of pmix then depends solely on
the observed class proportions in the covariate, and the beta
variance-covariance matrix will show zero covariance of pmix with
other detection parameters.
</p>


<h3>Models for pmix</h3>

<p>Variation in the parameter pmix may be modelled across sessions i.e.,
models such as pmix ~ session or pmix ~ Session are valid, as are
formulae involving session covariates defined in the sessioncov
argument of secr.fit.
</p>
<p>If no mixture term appears in the formula for pmix then one is added
automatically (usually &lsquo;h2&rsquo;). This serves mostly to keep track of
values in the output.
</p>
<p>Attempting to model pmix as a function of individual covariates or
other within-session terms (t, b etc.) will cause an error.
</p>


<h3>Interpreting output</h3>

<p>When you display a fitted secr model the parameter estimates are in a
final section headed 'Fitted (real) parameters evaluated at base
levels of covariates'. The same output may be obtained by calling the
<code>predict</code> method directly. Calling <code>predict</code> has the advantage
that you can obtain estimates for levels of the covariates other than
the base levels, by specifying <code>newdata</code>. An example below shows
how to specify h2 in <code>newdata</code>. [Note: <code>predict</code>
is generic, and you must consult ?predict.secr to see the help for the
specific implementation of this method for fitted secr objects].
</p>
<p>The output from <code>predict.secr</code> for a mixture model is a list with
one component for each (possibly latent) class. Each row corresponds
to a fitted real parameter: ordinarily these include the detection
parameters (e.g., g0, sigma) and the mixing proportion (pmix).
</p>
<p>In the case of a model fitted by maximizing the full likelihood
(<code>CL = FALSE</code>), density D will also appear in the output. Note
that only one parameter for density is estimated, the total density
across classes. This total density figure appears twice in the
output, once for each class.
</p>
<p>The standard error (SE.estimate) is shown for each parameter. These
are asymptotic estimates back-transformed from the link scale. The
confidence limits are also back-transformed from the link scale (95%
CI by default; vary <code>alpha</code> in <code>predict.secr</code> if you want
e.g. 90% CI).
</p>
<p>The mixing proportion pmix depends on the composition of the sample
with respect to <code>hcov</code> and the detection model. For a null
detection model the mixing proportion is exactly the proportion in the
sample, with appropriate binomial confidence limits. Otherwise, the
mixing proportion adjusts for class differences in the probability and
scale of detection (see Examples).
</p>
<p>The preceding refers to the default behaviour when pmix ~ h2. It is
possible also to fix the mixing proportion at any arbitrary value
(e.g., fixed = list(pmix = 0.5) for 1:1 sex ratio).
</p>
<p>On output the classes are tagged with the factor levels of <code>hcov</code>,
regardless of how few or how many individuals were actually of known
class. If only a small fraction were of known class, and there is
cryptic variation unrelated to <code>hcov</code>, then the association
between the fitted classes and the nominal classes (i.e. levels of
<code>hcov</code>) may be weak, and should not be trusted.
</p>


<h3>Limitations</h3>

<p>Hybrid mixture models are incompatible with groups as presently
implemented.
</p>
<p>The hcov likelihood conditions on the number of known-class
individuals. A model fitted with <code>hcov = NULL</code> or with a
different hcov covariate has in effect a different data set, and
likelihoods, deviances or AICs cannot be compared. AIC can be used to
compare models provided they all have the same hcov covariate in the
call to <code>secr.fit</code>, whether or not h2 appears in the model
definition.
</p>


<h3>Likelihood</h3>

<p>The likelihood of the hybrid mixture model is detailed in an appendix of
the vignette <a href="https://www.otago.ac.nz/density/pdfs/secr-finitemixtures.pdf">secr-finitemixtures.pdf</a>.
</p>


<h3>References</h3>

<p>Borchers, D.L. and Efford, M.G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em> <b>64</b>,
377&ndash;385.
</p>
<p>Gardner, B., Royle, J.A., Wegan, M.T., Rainbolt, R. and Curtis,
P. (2010) Estimating black bear density using DNA data from hair
snares. <em>Journal of Wildlife Management</em> <b>74</b>, 318&ndash;325.
</p>
<p>Pledger, S. (2000) Unified maximum likelihood estimates for
closed capture&ndash;recapture models using mixtures. <em>Biometrics</em> <b>56</b>,
434&ndash;442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr.fit">secr.fit</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## house mouse dataset, morning trap clearances
## 81 female, 78 male, 1 unknown
morning &lt;- subset(housemouse, occ = c(1,3,5,7,9))
summary(covariates(morning))

## speedy model fitting with coarse mask
mmask &lt;- make.mask(traps(morning), buffer = 20, nx = 32)

## assuming equal detection of males and females
## fitted sex ratio p(female) = 0.509434 = 81 / (81 + 78)
fit.0 &lt;- secr.fit(morning, hcov = "sex", mask = mmask, trace = FALSE)
predict(fit.0)

## allowing sex-specific detection parameters
## this leads to new estimate of sex ratio 
fit.h2 &lt;- secr.fit(morning, hcov = "sex", mask = mmask, trace = FALSE,
    model = list(g0 ~ h2, sigma ~ h2))
predict(fit.h2)

## specifying newdata for h2 - equivalent to predict(fit.h2)
predict(fit.h2, newdata = data.frame(h2 = factor(c('f','m'))))

## conditional likelihood fit of preceding model
## estimate of sex ratio does not change 
fit.CL.h2 &lt;- secr.fit(morning, hcov = "sex", mask = mmask, trace = FALSE,
    CL = TRUE, model = list(g0 ~ h2, sigma ~ h2))
predict(fit.CL.h2)

## did sexes differ in detection parameters?
fit.CL.0 &lt;- secr.fit(morning, hcov = "sex", mask = mmask, trace = FALSE,
    CL = TRUE, model = list(g0 ~ 1, sigma ~ 1))
LR.test(fit.CL.h2, fit.CL.0)

## did sex ratio deviate from 1:1?
fit.CL.h2.50 &lt;- secr.fit(morning, hcov = "sex", mask = mmask, trace = FALSE,
    CL = TRUE, model = list(g0 ~ h2, sigma ~ h2), fixed = list(pmix = 0.5))
LR.test(fit.CL.h2, fit.CL.h2.50)

## did sexes show extra-compensatory variation in lambda0?
## (Efford and Mowat 2014)
fit.CL.a0 &lt;- secr.fit(morning, hcov = "sex", mask = mmask, trace = FALSE,
    CL = TRUE, model = list(a0 ~ 1, sigma ~ h2))
LR.test(fit.CL.h2, fit.CL.a0)

## trend in ovenbird sex ratio, assuming sex-specific detection
omask &lt;- make.mask(traps(ovenCH), buffer = 300, nx = 32)
fit.sextrend &lt;- secr.fit(ovenCH, model = list(g0~h2, sigma~h2, pmix~Session),
    hcov = "Sex", CL = TRUE, mask = omask, trace = FALSE)
predict(fit.sextrend)[1:5]


## End(Not run)

</code></pre>

<hr>
<h2 id='head'> First or Last Part of an Object </h2><span id='topic+head.mask'></span><span id='topic+head.Dsurface'></span><span id='topic+head.traps'></span><span id='topic+head.capthist'></span><span id='topic+tail.mask'></span><span id='topic+tail.Dsurface'></span><span id='topic+tail.traps'></span><span id='topic+tail.capthist'></span>

<h3>Description</h3>

<p>Returns the first or last parts of secr objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mask'
head(x, n=6L, ...)
## S3 method for class 'Dsurface'
head(x, n=6L, ...)
## S3 method for class 'traps'
head(x, n=6L, ...)
## S3 method for class 'capthist'
head(x, n=6L, ...)
## S3 method for class 'mask'
tail(x, n=6L, ...)
## S3 method for class 'Dsurface'
tail(x, n=6L, ...)
## S3 method for class 'traps'
tail(x, n=6L, ...)
## S3 method for class 'capthist'
tail(x, n=6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_+3A_x">x</code></td>
<td>
<p> &lsquo;mask&rsquo;, &lsquo;traps&rsquo; or &lsquo;capthist&rsquo; object </p>
</td></tr>
<tr><td><code id="head_+3A_n">n</code></td>
<td>
<p> a single integer. If positive, size for the resulting
object: number of elements for a vector (including lists), rows for a
matrix or data frame or lines for a function. If negative, all but the
n last/first number of elements of x. </p>
</td></tr>
<tr><td><code id="head_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code>subset</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These custom S3 methods retain the class of the target object, unlike the
default methods applied to &lsquo;mask&rsquo;, &lsquo;Dsurface&rsquo;, &lsquo;traps&rsquo; or &lsquo;capthist&rsquo; objects.
</p>


<h3>Value</h3>

<p>An object of the same class as x, but (usually) fewer rows.
</p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+head">head</a></code>, <code><a href="utils.html#topic+tail">tail</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>head(possummask)
</code></pre>

<hr>
<h2 id='homerange'> Home Range Statistics </h2><span id='topic+dbar'></span><span id='topic+RPSV'></span><span id='topic+MMDM'></span><span id='topic+ARL'></span><span id='topic+moves'></span><span id='topic+centroids'></span><span id='topic+ORL'></span><span id='topic+trapsPerAnimal'></span>

<h3>Description</h3>

<p>Some ad hoc measures of home range size may be calculated in <span class="pkg">secr</span>
from capture&ndash;recapture data:
</p>
<p><code>dbar</code> is the mean distance between consecutive capture locations,
pooled over individuals (e.g. Efford 2004). <code>moves</code> returns the
raw distances.
</p>
<p><code>MMDM</code> (for &lsquo;Mean Maximum Distance Moved&rsquo;) is the average maximum
distance between detections of each individual i.e. the observed range
length averaged over individuals (Otis et al. 1978).
</p>
<p><code>ARL</code> (or &lsquo;Asymptotic Range Length&rsquo;) is obtained by fitting an
exponential curve to the scatter of observed individual range length vs
the number of detections of each individual (Jett and Nichols 1987: 889).
</p>
<p><code>RPSV</code> (for &lsquo;Root Pooled Spatial Variance&rsquo;) is a measure of the 2-D
dispersion of the locations at which individual animals are detected,
pooled over individuals (cf Calhoun and Casby 1958, Slade and Swihart 1983).
</p>
<p><code>moves</code> reports the distance between successive detections of each animal.
</p>
<p><code>centroids</code> reports the averaged coordinates of each animal's detections
</p>
<p><code>ORL</code> reports the observed range length of each animal, the maximum 
distance between any two detections.
</p>
<p><code>trapsPerAnimal</code> tabulates the number of animals recorded at 1, 2, ..., K detectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbar(capthist, userdist = NULL, mask = NULL)
MMDM(capthist, min.recapt = 1, full = FALSE, userdist = NULL, mask = NULL)
ARL(capthist, min.recapt = 1, plt = FALSE, full = FALSE, userdist = NULL, mask = NULL)
moves(capthist, userdist = NULL, mask = NULL, names = FALSE)
RPSV(capthist, CC = FALSE)
ORL(capthist, userdist = NULL, mask = NULL)
centroids(capthist)
trapsPerAnimal(capthist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homerange_+3A_capthist">capthist</code></td>
<td>
<p> object of class <code><a href="#topic+capthist">capthist</a></code> </p>
</td></tr>
<tr><td><code id="homerange_+3A_userdist">userdist</code></td>
<td>
<p> function or matrix with user-defined distances</p>
</td></tr>
<tr><td><code id="homerange_+3A_mask">mask</code></td>
<td>
<p> habitat mask passed to userdist function, if required</p>
</td></tr>
<tr><td><code id="homerange_+3A_names">names</code></td>
<td>
<p> logical; should results be ordered alphanumerically by row names? </p>
</td></tr>
<tr><td><code id="homerange_+3A_min.recapt">min.recapt</code></td>
<td>
<p> integer minimum number of recaptures for a
detection history to be used </p>
</td></tr>
<tr><td><code id="homerange_+3A_plt">plt</code></td>
<td>
<p> logical; if TRUE observed range length is plotted against number
of recaptures </p>
</td></tr>
<tr><td><code id="homerange_+3A_full">full</code></td>
<td>
<p> logical; set to TRUE for detailed output </p>
</td></tr>
<tr><td><code id="homerange_+3A_cc">CC</code></td>
<td>
<p> logical for whether to use Calhoun and Casby formula </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dbar</code> is defined as &ndash;
</p>
<p style="text-align: center;"><code class="reqn">
\overline{d}=\frac{\sum\limits _{i=1}^{n}
                          \sum\limits _{j=1}^{n_i - 1}
                              \sqrt{(x_{i,j}-x_{i,j+1})^2 + (y_{i,j}-y_{i,j+1})^2}}
                         {\sum\limits _{i=1}^{n} (n_i-1)}</code>
</p>

<p>When <code>CC = FALSE</code>, <code>RPSV</code> is defined as &ndash;
</p>
<p style="text-align: center;"><code class="reqn">
 RPSV = \sqrt{
    \frac {\sum\limits _{i=1}^{n} \sum\limits _{j=1}^{n_i} [
	    (x_{i,j} - \overline x_i)^2 + (y_{i,j} - \overline y_i)^2
		]}{\sum\limits _{i=1}^{n} (n_i-1) - 1}}
	  </code>
</p>
<p>.
</p>
<p>Otherwise (<code>CC = TRUE</code>), <code>RPSV</code> uses the formula of Calhoun
and Casby (1958) with a different denominator &ndash; 	  
</p>
<p style="text-align: center;"><code class="reqn">
 s = \sqrt{
    \frac {\sum\limits _{i=1}^{n} \sum\limits _{j=1}^{n_i} [
	    (x_{i,j} - \overline x_i)^2 + (y_{i,j} - \overline y_i)^2
		]}{2\sum\limits _{i=1}^{n} (n_i-1)}}
	  </code>
</p>
<p>.
</p>
<p>The Calhoun and Casby formula (offered from 2.9.1) correctly estimates <code class="reqn">\sigma</code>
when trapping is on an infinite, fine grid, and is preferred
for this reason. The original RPSV
(<code>CC = FALSE</code>) is retained as the default for compatibility with
previous versions of <span class="pkg">secr</span>.
</p>
<p><code>RPSV</code> has a specific role as a proxy for
detection scale in inverse-prediction estimation of density (Efford
2004, 2023).
</p>
<p><code>RPSV</code> is used in <code>autoini</code> to obtain plausible starting
values for maximum likelihood estimation.
</p>
<p><code>MMDM</code> and <code>ARL</code> discard data from detection histories
containing fewer than <code>min.recapt</code>+1 detections.
</p>
<p>The <code>userdist</code> option is included for exotic non-Euclidean cases
(see e.g. <code>secr.fit</code> <a href="#topic+details">details</a>). RPSV is not defined for
non-Euclidean distances.
</p>
<p>If <code>capthist</code> comprises standalone telemetry data (all detector 'telemetry') 
then calculations are performed on the telemetry coordinates. If <code>capthist</code> 
combines telemetry data and conventional detections (&lsquo;multi&rsquo;, &lsquo;proximity&rsquo; etc.) 
then only the conventional data are summarised.
</p>
<p>Movements are reliably reported by <code>moves</code> only if there is a maximum of one detection per animal per occasion. The sequence of detections within any occasion is not known; where these occur the sequence used by <code>moves</code> is arbitrary (sequence follows detector index).
</p>


<h3>Value</h3>

<p>For <code>dbar</code>, <code>MMDM</code>, <code>ARL</code> and <code>RPSV</code> &ndash;
</p>
<p>Scalar distance in metres, or a list of such values if <code>capthist</code>
is a multi-session list.
</p>
<p>The <code>full</code> argument may be used with <code>MMDM</code> and <code>ARL</code> to
return more extensive output, particularly the observed range length for
each detection history.
</p>
<p>For <code>moves</code> &ndash;
</p>
<p>List with one component for each animal, a vector of distances, or numeric(0) if the animal is detected only once. A list of such lists if <code>capthist</code> is a multi-session list.
</p>
<p>For <code>centroids</code> &ndash;
</p>
<p>For a single-session capthist, a matrix of two columns, the x- and y-coordinates of the centroid of the detections of each animal. The number of detections is returned as the attribute &lsquo;Ndetections&rsquo;, a 1-column matrix.
</p>
<p>For a multi-session capthist, a 3-D array as before, but with a third dimension for the session. Centroid coordinates are missing (NA) if the animal was not detected in a session. The attribute &lsquo;Ndetections&rsquo; with the number of detections per animal and session is a matrix.
</p>
<p>For <code>trapsPerAnimal</code> &ndash;
</p>
<p>A vector with the number of animals detected at k detectors.
</p>


<h3>Note</h3>

<p>All measures are affected by the arrangement of detectors. <code>dbar</code>
is also affected quite strongly by serial correlation in the sampled
locations. Using <code>dbar</code> with &lsquo;proximity&rsquo; detectors raises a problem
of interpretation, as the original sequence of multiple detections
within an occasion is unknown. RPSV is a value analogous to the standard
deviation of locations about the home range centre.
</p>
<p>The value returned by <code>dbar</code> for &lsquo;proximity&rsquo; or &lsquo;count&rsquo; detectors
is of little use because multiple detections of an individual within an
occasion are in arbitrary order.
</p>
<p>Inclusion of these measures in the <span class="pkg">secr</span> package does not mean they are
recommended for general use! It is usually better to use a spatial
parameter from a fitted model (e.g., <code class="reqn">\sigma</code> of the
half-normal detection function). Even then, be careful that
<code class="reqn">\sigma</code> is not &lsquo;contaminated&rsquo; with behavioural effects (e.g.
attraction of animal to detector) or &lsquo;detection at a distance&rsquo;.
</p>
<p>The argument 'names' was added in 3.0.1. The default <code>names = FALSE</code> 
causes a change in behaviour from that version onwards.
</p>


<h3>References</h3>

<p>Calhoun, J. B. and Casby, J. U. (1958) Calculation of home range and
density of small mammals. Public Health
Monograph. No. 55. U.S. Government Printing Office.
</p>
<p>Efford, M. G. (2004) Density estimation in live-trapping studies.
<em>Oikos</em> <b>106</b>, 598&ndash;610.
</p>
<p>Efford, M. G. (2023) ipsecr: An R package for awkward spatial capture&ndash;recapture data.
<em>Methods in Ecology and Evolution</em> In press.
</p>
<p>Jett, D. A. and Nichols, J. D. (1987) A field comparison of nested grid
and trapping web density estimators. <em>Journal of Mammalogy</em>
<b>68</b>, 888&ndash;892.
</p>
<p>Otis, D. L., Burnham, K. P., White, G. C. and Anderson, D. R. (1978)
Statistical inference from capture data on closed animal
populations. <em>Wildlife Monographs</em> <b>62</b>, 1&ndash;135.
</p>
<p>Slade, N. A. and Swihart, R. K. (1983) Home range indices for the hispid
cotton rat (<em>Sigmodon hispidus</em>) in Northeastern Kansas. <em>Journal of
Mammalogy</em> <b>64</b>, 580&ndash;590.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+autoini">autoini</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
dbar(captdata)
RPSV(captdata)
RPSV(captdata, CC = TRUE)

centr &lt;- centroids(captdata)
plot(traps(captdata), border = 20 )
text(centr[,1], centr[,2], attr(centr, 'Ndetections'))
text(centr[,1]+2, centr[,2]+3, rownames(captdata), cex = 0.6,
    adj = 0)

</code></pre>

<hr>
<h2 id='hornedlizard'> Flat-tailed Horned Lizard Dataset </h2><span id='topic+hornedlizard'></span><span id='topic+hornedlizardCH'></span>

<h3>Description</h3>

<p>Data from multiple searches for flat-tailed horned lizards
(<em>Phrynosoma mcalli</em>) on a plot in Arizona, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hornedlizardCH</code></pre>


<h3>Details</h3>

<p>The flat-tailed horned lizard (<em>Phrynosoma mcalli</em>) is a desert
lizard found in parts of southwestern Arizona, southeastern California
and northern Mexico. There is considerable concern about its
conservation status. The species is cryptically coloured and has the
habit of burying under the sand when approached, making it difficult or
impossible to obtain a complete count (Grant and Doherty 2007).
</p>
<p>K. V. Young conducted a capture&ndash;recapture survey of flat-tailed horned
lizards 25 km south of Yuma, Arizona, in the Sonoran Desert. The habitat
was loose sand dominated by creosote bush and occasional bur-sage and
Galletta grass. A 9-ha plot was surveyed 14 times over 17 days (14 June
to 1 July 2005). On each occasion the entire 300 m x 300 m plot was
searched for lizards. Locations within the plot were recorded by
handheld GPS. Lizards were captured by hand and marked individually on
their underside with a permanent marker. Marks are lost when the lizard
sheds, but this happens infrequently and probably caused few or no
identification errors during the 2.5-week study.
</p>
<p>A total of 68 individuals were captured 134 times. Exactly half of the
individuals were recaptured at least once.
</p>
<p>Royle and Young (2008) analysed the present dataset to demonstrate a
method for density estimation using data augmentation and MCMC
simulation. They noted that the plot size was much larger than has been
suggested as being practical in operational monitoring efforts for this
species, that the plot was chosen specifically because a high density of
individuals was present, and that high densities typically correspond to
less movement in this species. The state space in their analysis was a
square comprising the searched area and a 100-m buffer (J. A. Royle
pers. comm.).
</p>
<p>The detector type for these data is &lsquo;polygonX&rsquo; and there is a single
detector (the square plot). The data comprise a capture history matrix
(the body of <code>hornedlizardCH</code>) and the x-y coordinates of each
positive detection (stored as an attribute that may be displayed with
the &lsquo;xy&rsquo; function); the &lsquo;traps&rsquo; attribute of <code>hornedlizardCH</code>
contains the vertices of the plot. See
<a href="../doc/secr-datainput.pdf">secr-datainput.pdf</a> for guidance on
data input.
</p>
<p>Non-zero entries in a polygonX capture-history matrix indicate the
number of the polygon containing the detection. In this case there was
just one polygon, so entries are 0 or 1. No animal can appear more than
once per occasion with the polygonX detector type, so there is no need
to specify &lsquo;binomN = 1&rsquo; in secr.fit.
</p>

<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
  hornedlizardCH </td><td style="text-align: left;"> single-session capthist object </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Royle and Young (2008) and J. A. Royle (pers. comm.), with additional
information from K. V. Young (pers. comm.).
</p>


<h3>References</h3>

<p>Efford, M. G. (2011) Estimation of population density by spatially
explicit capture&ndash;recapture analysis of data from area
searches. <em>Ecology</em> <b>92</b>, 2202&ndash;2207.
</p>
<p>Grant, T. J. and Doherty, P. F. (2007) Monitoring of the flat-tailed
horned lizard with methods incorporating detection
probability. <em>Journal of Wildlife Management</em> <b>71</b>, 1050&ndash;1056
</p>
<p>Marques, T. A., Thomas, L. and Royle, J. A. (2011) A hierarchical model
for spatial capture&ndash;recapture data: Comment. <em>Ecology</em> <b>92</b>,
526&ndash;528.
</p>
<p>Royle, J. A. and Young, K. V. (2008) A hierarchical model for spatial
capture&ndash;recapture data. <em>Ecology</em> <b>89</b>, 2281&ndash;2289.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+detector">detector</a></code>, <code><a href="#topic+reduce.capthist">reduce.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(hornedlizardCH, tracks = TRUE, varycol = FALSE,
    lab1 = TRUE, laboff = 6, border = 10, title =
    "Flat-tailed Horned Lizards (Royle &amp; Young 2008)")

table(table(animalID(hornedlizardCH)))
traps(hornedlizardCH)

## show first few x-y coordinates
head(xy(hornedlizardCH))

## Not run: 

## Compare default (Poisson) and binomial models for number
## caught
FTHL.fit &lt;- secr.fit(hornedlizardCH)
FTHLbn.fit &lt;- secr.fit(hornedlizardCH, details =
    list(distribution = "binomial"))
collate(FTHL.fit, FTHLbn.fit)[,,,"D"]

## Collapse occasions (does not run faster)
hornedlizardCH.14 &lt;- reduce(hornedlizardCH, newoccasions =
    list(1:14), outputdetector = "polygon")
FTHL14.fit &lt;- secr.fit(hornedlizardCH.14, binomN = 14)


## End(Not run)

</code></pre>

<hr>
<h2 id='housemouse'> House mouse live trapping data  </h2><span id='topic+housemouse'></span><span id='topic+Coulombe'></span>

<h3>Description</h3>

<p>Data of H. N. Coulombe from live trapping of feral house mice (<em>Mus
musculus</em>) in a salt marsh, California, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>housemouse</code></pre>


<h3>Details</h3>

<p>H. N. Coulombe conducted a live-trapping study on an outbreak of feral house
mice in a salt marsh in mid-December 1962 at Ballana Creek, Los Angeles
County, California. A square 10 x 10 grid was used with 100 Sherman
traps spaced 3 m apart. Trapping was done twice daily, morning and
evening, for 5 days.
</p>
<p>The dataset was described by Otis et al. (1978) and distributed with
their CAPTURE software (now available from
<a href="https://www.mbr-pwrc.usgs.gov/software.html">https://www.mbr-pwrc.usgs.gov/software.html</a>). Otis et
al. (1978 p. 62, 68) cite Coulombe's unpublished 1965 master's thesis
from the University of California, Los Angeles, California.
</p>
<p>The data are provided as a single-session <code>capthist</code> object. There
are two individual covariates: sex (factor levels &lsquo;f&rsquo;, &lsquo;m&rsquo;) and age
class (factor levels &lsquo;j&rsquo;, &lsquo;sa&rsquo;, &lsquo;a&rsquo;). The sex of two animals is not
available (NA); it is necessary to drop these records for analyses
using &lsquo;sex&rsquo; unless missing values are specifically allowed, as in <code><a href="#topic+hcov">hcov</a></code>.
</p>
<p>The datasets were originally in the CAPTURE &lsquo;xy complete&rsquo; format which
for each detection gives the &lsquo;column&rsquo; and &lsquo;row&rsquo; numbers of the trap
(e.g. &lsquo; 9 5&rsquo; for a capture in the trap at position (x=9, y=5) on the
grid). Trap identifiers have been recoded as strings with no spaces by
inserting zeros (e.g. &lsquo;0905&rsquo; in this example).
</p>
<p>Sherman traps are designed to capture one animal at a time, but the data
include 30 double captures and one occasion when there were 4
individuals in a trap at one time. The true detector type therefore
falls between &lsquo;single&rsquo; and &lsquo;multi&rsquo;. Detector type is set to &lsquo;multi&rsquo; in
the distributed data objects.
</p>
<p>Otis et al. (1978) report various analyses including a closure test on
the full data, and model selection and density estimation on data from
the mornings only. 
</p>


<h3>Source</h3>

<p>File &lsquo;examples&rsquo; distributed with program CAPTURE.
</p>


<h3>References</h3>

<p>Otis, D. L., Burnham, K. P., White, G. C. and Anderson, D. R. (1978)
Statistical inference from capture data on closed animal
populations. <em>Wildlife Monographs</em> <b>62</b>, 1&ndash;135.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(housemouse, title = paste("Coulombe (1965), Mus musculus,",
    "California salt marsh"), border = 5, rad = 0.5,
    gridlines = FALSE)

morning &lt;- subset(housemouse, occ = c(1,3,5,7,9))
summary(morning)

## drop 2 unknown-sex mice
known.sex &lt;- subset(housemouse, !is.na(covariates(housemouse)$sex))

## reveal multiple captures
table(trap(housemouse), occasion(housemouse))

## Not run: 

## assess need to distinguish morning and afternoon samples
housemouse.0 &lt;- secr.fit (housemouse, buffer = 20)
housemouse.ampm &lt;- secr.fit (housemouse, model = g0~tcov, buffer = 20,
    timecov = c(0,1,0,1,0,1,0,1,0,1))
AIC(housemouse.0, housemouse.ampm)


## End(Not run)

</code></pre>

<hr>
<h2 id='Internal'>Internal Functions</h2><span id='topic+boundarytoSF'></span><span id='topic+Dfn2'></span>

<h3>Description</h3>

 
<p>Various functions called internally by <span class="pkg">secr</span> and not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
boundarytoSF (poly)

Dfn2(designD, beta = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Internal_+3A_poly">poly</code></td>
<td>
<p>data to define one or more polygons</p>
</td></tr>
<tr><td><code id="Internal_+3A_designd">designD</code></td>
<td>
<p>dataframe of density design data (output from <code><a href="#topic+D.designdata">D.designdata</a></code>)</p>
</td></tr>
<tr><td><code id="Internal_+3A_beta">beta</code></td>
<td>
<p>numeric vector of beta values (see Details for NULL)</p>
</td></tr>
<tr><td><code id="Internal_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>boundarytoSF</code> converts various 
possible polygon input formats to a standard form (sfc).
</p>
<p>Possible inputs are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  Input </td><td style="text-align: left;"> From </td><td style="text-align: left;"> Note </td>
</tr>
<tr>
 <td style="text-align: left;">
  2-column matrix or dataframe </td><td style="text-align: left;"> base R</td>
</tr>
<tr>
 <td style="text-align: left;">
  SpatialPolygons </td><td style="text-align: left;"> <span class="pkg">sp</span> </td>
</tr>
<tr>
 <td style="text-align: left;">
  SpatialPolygonsDataFrame </td><td style="text-align: left;"> <span class="pkg">sp</span> </td>
</tr>
<tr>
 <td style="text-align: left;">
  SpatVector </td><td style="text-align: left;"> <span class="pkg">terra</span> </td>
</tr>
<tr>
 <td style="text-align: left;">
  sf </td><td style="text-align: left;"> <span class="pkg">sf</span> </td><td style="text-align: left;"> geometry type POLYGON or MULTIPOLYGON </td>
</tr>
<tr>
 <td style="text-align: left;">
  sfc </td><td style="text-align: left;"> <span class="pkg">sf</span> </td><td style="text-align: left;"> geometry type POLYGON or MULTIPOLYGON </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Matrix input defines a single polygon.
</p>
<p><code>Dfn2</code> is supplied automatically as 'details' argument Dfn in 
<code><a href="#topic+secr.fit">secr.fit</a></code> when the switch Dlambda is set to TRUE for the 
multi-session trend reparameterization of density. <code>Dfn2</code> 
uses beta = NULL to return the required number of density coefficients 
(beta parameters) in the model.
</p>


<h3>Value</h3>

<p><code>boundarytoSF</code> &ndash; Spatial object of <span class="pkg">sf</span> class sfc, containing 
a geometry set of type POLYGON or MULTIPOLYGON. NULL input results in NULL output.
</p>
<p><code>Dfn2</code> &ndash; Vector of density values on the link scale, suitable for the internal array (mask x groups x sessions).
</p>


<h3>References</h3>

<p>Hijmans, R. J. (2022) terra: Spatial Data Analysis. R package version 1.5-14. https://rspatial.org/terra/
</p>
<p>Pebesma, E. (2018) Simple features for R: standardized support for spatial vector data. <em>The R Journal</em> <b>10(1)</b>, 439&ndash;446.
https://doi.org/10.32614/RJ-2018-009
</p>
<p>Pebesma, E.J. and Bivand, R. S. (2005) Classes and methods for spatial data in R. <em>R News</em> <b>5(2)</b>, 9&ndash;13.
https://cran.r-project.org/doc/Rnews/Rnews_2005-2.pdf.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pointsInPolygon">pointsInPolygon</a></code>, 
<a href="https://www.otago.ac.nz/density/pdfs/secr-spatialdata.pdf">secr-spatialdata.pdf</a>,
</p>
<p><code><a href="#topic+predictDlambda">predictDlambda</a></code>,
<a href="https://www.otago.ac.nz/density/pdfs/secr-trend.pdf">secr-trend.pdf</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

poly &lt;- cbind(x = c(0,6,6,0,0), y = c(0,0,6,6,0))  
secr:::boundarytoSF(poly)


## End(Not run)

</code></pre>

<hr>
<h2 id='intervals'> Work with Open Population data </h2><span id='topic+intervals'></span><span id='topic+intervals+3C-'></span><span id='topic+sessionlabels'></span><span id='topic+sessionlabels+3C-'></span>

<h3>Description</h3>

<p>Functions for data manipulation 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
intervals(object, ...)
intervals(object) &lt;- value
sessionlabels(object, ...)
sessionlabels(object) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals_+3A_object">object</code></td>
<td>
<p> capthist object </p>
</td></tr>
<tr><td><code id="intervals_+3A_value">value</code></td>
<td>
<p> vector of intervals or primary session labels</p>
</td></tr>
<tr><td><code id="intervals_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>intervals</code> extracts the &lsquo;interval&rsquo; attribute if it exists.
</p>
<p>The attribute &lsquo;intervals&rsquo; is set automatically by the secr function
<code><a href="#topic+join">join</a></code>.
</p>
<p><code>sessionlabels</code> provides session names for the primary sessions encoded 
in a &ldquo;single-session&rdquo; capthist object (e.g., the result of <code>join</code>) 
that has an intervals attribute. The names are used by some summary functions 
in the package <span class="pkg">openCR</span> (M. Efford unpubl.) (<code>m.array</code>, <code>JS.counts</code>).
</p>
<p>The function <code><a href="#topic+session">session</a></code> has a different purpose: labelling
sessions in a multi-session capthist object. However, <code>session</code>
names of multi-session input are used automatically by <code><a href="#topic+join">join</a></code> to construct the
<code>sessionlabels</code> attribute of the resulting single-session object.
</p>


<h3>Value</h3>

<p>For <code>intervals</code>, a numeric vector of time intervals, one less than the number of occasions (secondary sessions). 
</p>
<p>For <code>sessionlabels</code>, a character vector of primary session names.
</p>


<h3>Note</h3>

<p>There is a naming conflict with the intervals function in <span class="pkg">nlme</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
singlesessionCH &lt;- join(ovenCH)
intervals(singlesessionCH)
sessionlabels(singlesessionCH)

</code></pre>

<hr>
<h2 id='join'> Combine or Split Sessions of capthist Object </h2><span id='topic+join'></span><span id='topic+unjoin'></span>

<h3>Description</h3>

<p> Make a single-session capthist object from a list of
single-session objects, or a multi-session capthist object.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 

join(object, remove.dupl.sites = TRUE, tol = 0.001, sites.by.name = FALSE,
    drop.sites = FALSE, intervals = NULL, sessionlabels = NULL, 
    timevaryingcov = NULL) 
    
unjoin(object, intervals, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_object">object</code></td>
<td>
<p>list of single-session objects, or a multi-session
capthist object [<code>join</code>], or a single-session capthist object [<code>unjoin</code>]</p>
</td></tr>
<tr><td><code id="join_+3A_remove.dupl.sites">remove.dupl.sites</code></td>
<td>
<p> logical; if TRUE then a single record is
retained for each trap site used in multiple input sessions </p>
</td></tr>
<tr><td><code id="join_+3A_tol">tol</code></td>
<td>
<p> absolute distance in metres within which sites are
considered identical </p>
</td></tr>
<tr><td><code id="join_+3A_sites.by.name">sites.by.name</code></td>
<td>
<p> logical; if TRUE and <code>remove.dupl.sites</code> then duplicate sites are inferred from row names rather than x-y coordinates</p>
</td></tr>
<tr><td><code id="join_+3A_drop.sites">drop.sites</code></td>
<td>
<p>logical; if TRUE then site information is discarded</p>
</td></tr>
<tr><td><code id="join_+3A_intervals">intervals</code></td>
<td>
<p> vector of times between sessions (join) or occasions (unjoin; zero indicates same session) </p>
</td></tr>
<tr><td><code id="join_+3A_sessionlabels">sessionlabels</code></td>
<td>
<p> vector of session names </p>
</td></tr>
<tr><td><code id="join_+3A_timevaryingcov">timevaryingcov</code></td>
<td>
<p> character vector of covariate names </p>
</td></tr>
<tr><td><code id="join_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code><a href="#topic+subset.capthist">subset.capthist</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>join</code></dt><dd>
<p>The input sessions are assumed to be of the same detector type and to
have the same attributes (e.g., covariates should be present for all
or none).
</p>
<p>The number of occasions (columns) in the output is equal to the sum of
the number of occasions in each input.
</p>
<p>Duplicates may be defined either as sites within a given distance (<code>tol</code>) or sites with the same name (<code>sites.by.name = TRUE</code>). Using site names is faster.
</p>
<p>For non-spatial analyses it is efficient to drop the third dimension and discard the traps attribute (<code>drop.sites = TRUE</code>).
</p>
<p>A new dataframe of individual covariates is formed using the covariates
for the first occurrence of each animal. 
</p>
<p>If <code>timevaryingcov</code> is given then for each name a new covariate is generated for each session and populated with values observed in that session, or NA if the animal was not detected. A &lsquo;timevaryingcov&rsquo; (list) attribute is created that associates each set of new session-specific columns with the corresponding old name, so that it may be used in formulae (see <code><a href="#topic+timevaryingcov">timevaryingcov</a></code>).
</p>
<p>Attributes xy and signal are handled appropriately, as is trap usage.
</p>
</dd>
<dt><code>unjoin</code></dt><dd>
<p>The input grouping of occasions (columns) into sessions is specified via
<code>intervals</code>. This is a vector of length one less than the number of
occasions (columns) in <code>object</code>. Elements greater than zero
indicate a new session.
</p>
<p>The <code>intervals</code> argument may be omitted if <code>object</code> has a
valid &lsquo;intervals&rsquo; attribute, as in the output from <code>join</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>For <code>join</code>, a single-session capthist object. The vector attribute &lsquo;intervals&rsquo; records the
distinction between occasions that are adjacent in the input (interval =
0) and those that are in consecutive sessions (e.g., interval = 1); &lsquo;intervals&rsquo;
has length one less than the number of occasions.
</p>
<p>For <code>unjoin</code>, a multi-session capthist object. Sessions are named
with integers.
</p>


<h3>Note</h3>

<p>Do not confuse <code>unjoin</code> with <code><a href="#topic+split.capthist">split.capthist</a></code> which
splits by row (animal) rather than by column (occasion).
</p>
<p>Occasions survive intact; to pool occasions use
<code><a href="#topic+reduce.capthist">reduce.capthist</a></code>.
</p>
<p><code>join</code> was modified in version 2.9.5 to check whether the
components of &lsquo;object&rsquo; all used the same detectors (&lsquo;traps&rsquo;) (putting
aside differences in usage). If the traps are identical and
remove.dupl.sites = TRUE then the resulting &lsquo;capthist&rsquo; uses the common list of
detectors, with a usage attribute formed by concatenating the usage
columns of the input. This is faster than the previous filtering
algorithm using &lsquo;tol&rsquo;; the older algorithm is still used if the traps differ. 
</p>
<p>Problems may be encountered with large datasets. These may be alleviated by setting sites.by.name = TRUE (if matching sites have matching names, avoiding the need for coordinate matching) or drop.sites = TRUE (if only non-spatial data are required for openCR).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MS.capthist">MS.capthist</a></code>, <code><a href="#topic+rbind.capthist">rbind.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
joined.ovenCH &lt;- join (ovenCH)
summary(joined.ovenCH)
attr(joined.ovenCH, "intervals")

summary(unjoin(joined.ovenCH))

## Not run: 

## suppose the 5-year ovenbird covariates include a column for weight
## (here generated as random numbers)
for (i in 1:5) covariates(ovenCH[[i]])$wt &lt;- runif(nrow(ovenCH[[i]]))
## construct single-session version of data for openCR
## identify 'wt' as varying across years
ovenCHj &lt;- join(ovenCH, timevaryingcov = 'wt')
head(covariates(ovenCHj))
timevaryingcov(ovenCHj)
## Use example: openCR.fit(ovenCHj, model = p~wt)


## End(Not run)


</code></pre>

<hr>
<h2 id='kfn'>Overlap Index</h2><span id='topic+kfn'></span>

<h3>Description</h3>

<p>Computes the overlap index of Efford et al. (2016) from various inputs, 
including fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
kfn(object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfn_+3A_object">object</code></td>
<td>
<p>fitted secr model, numeric vector, matrix, dataframe</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kfn</code> simply computes <code class="reqn">k = \sigma \sqrt D / 100</code>, where <code class="reqn">\sigma</code> is the sigma parameter of a fitted halfnormal detection function and <code class="reqn">D</code> is the corresponding density estimate. The factor of 1/100 adjusts for the units used in <span class="pkg">secr</span> (sigma in metres; D in animals per hectare).
</p>
<p>Input may be in any of these forms
</p>

<ol>
<li><p> vector with D and sigma in the first and second positions.
</p>
</li>
<li><p> matrix with each row as in (1)
</p>
</li>
<li><p> dataframe such as produced by <code><a href="#topic+predict.secr">predict.secr</a></code> with rows &lsquo;D&rsquo; and &lsquo;sigma&rsquo;, and column &lsquo;estimate&rsquo;.
</p>
</li>
<li><p> fitted <span class="pkg">secr</span> model
</p>
</li>
<li><p> a list of any of the above
</p>
</li></ol>



<h3>Value</h3>

<p>Numeric vector with elements &lsquo;D&rsquo;, &lsquo;sigma&rsquo; and &lsquo;k&rsquo;, or a matrix with these columns.
</p>


<h3>Note</h3>

<p>The index should not be taken too literally as a measure of overlap: it represents the overlap expected <em>if</em> activity centres are randomly distributed and <em>if</em> home ranges have bivariate normal utilisation. Thus it does <em>not</em> measure overlap due to social behaviour etc. except as that affects home range size.
</p>
<p>The index may be estimated directly using the sigmak parameterization 
(i.e., when sigmak appears in the model for <code><a href="#topic+secr.fit">secr.fit</a></code>). 
This provides SE and confidence limits for sigmak (= <code class="reqn">k</code>). However, 
the directly estimated value of sigmak lacks the unit correction and is 
therefore 100 <code class="reqn">\times</code> the value from <code>kfn</code>.
</p>


<h3>References</h3>

<p>Efford, M. G., Dawson, D. K., Jhala, Y. V. and Qureshi, Q. (2016) 
Density-dependent home-range size revealed by spatially explicit 
capture&ndash;recapture. <em>Ecography</em> <b>39</b>, 676&ndash;688.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.secr">predict.secr</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+details">details</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kfn(secrdemo.0)

## compare
## fitk &lt;- secr.fit(captdata, model = sigmak~1, buffer = 100, trace = FALSE)
## predict(fitk)

</code></pre>

<hr>
<h2 id='list.secr.fit'>Fit Multiple SECR Models</h2><span id='topic+list.secr.fit'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code><a href="#topic+secr.fit">secr.fit</a></code> that allows multiple models to be fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
list.secr.fit (..., constant = list(), prefix = "fit", names = NULL) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.secr.fit_+3A_...">...</code></td>
<td>
<p>varying arguments of <code>secr.fit</code></p>
</td></tr>
<tr><td><code id="list.secr.fit_+3A_constant">constant</code></td>
<td>
<p>list of named arguments held constant</p>
</td></tr>
<tr><td><code id="list.secr.fit_+3A_prefix">prefix</code></td>
<td>
<p>character prefix for automatic names</p>
</td></tr>
<tr><td><code id="list.secr.fit_+3A_names">names</code></td>
<td>
<p>character names of output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ... argument may be one or several vectors of the same length that refers to a different named argument of <code><a href="#topic+secr.fit">secr.fit</a></code>. <code>secr.fit</code> is called with the constant arguments plus the first value in each vector, then the second value, etc. The logic follows <code><a href="base.html#topic+mapply">mapply</a></code>.
</p>
<p>Each of the ... arguments may also be a named argument with a single value, although the compound values should be wrapped in list(), passed by name (in quotes), or placed in the 'constant' list to avoid misinterpretation. For example, the capthist argument of <code>secr.fit</code> should be be wrapped in list() or &quot; &quot; if it is placed outside 'constant'.
</p>
<p>'prefix' is used only if 'names' is not supplied.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+secrlist">secrlist</a></code> of model fits (see <code><a href="#topic+secr.fit">secr.fit</a></code>). 
</p>


<h3>Note</h3>

<p>This function replaces the previous function <code>par.secr.fit</code>: since the introduction of multi-threading in <span class="pkg">secr</span> 4.0 it is no longer efficient to use parallel worker processes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+AIC.secr">AIC.secr</a></code>,
<code><a href="#topic+predict.secr">predict.secr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# fit two detection models
fits &lt;- list.secr.fit (model = c(g0~1, g0~b), constant = list(captdata, trace = FALSE))
AIC(fits)

# alternatively,
fits &lt;- list.secr.fit ('captdata', model = c(g0~1, g0~b), trace = FALSE)
AIC(fits)

# replacing par.derived and par.region.N:

lapply(fits, derived)
lapply(fits, region.N)


## End(Not run)

</code></pre>

<hr>
<h2 id='LLsurface'>Plot Likelihood Surface</h2><span id='topic+LLsurface'></span><span id='topic+LLsurface.secr'></span>

<h3>Description</h3>

<p>LLsurface is a generic function to calculate log likelihood over a grid of values of 
two coefficients (beta parameters) from a fitted model and optionally make an 
approximate contour plot of the log likelihood surface.
</p>
<p>A method is provided for secr objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
LLsurface(object, ...)

## S3 method for class 'secr'
LLsurface(object, betapar = c("g0", "sigma"), xval = NULL,
    yval = NULL, centre = NULL, realscale = TRUE, plot = TRUE,
    plotfitted = TRUE, ncores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LLsurface_+3A_object">object</code></td>
<td>
<p>fitted model, <code>secr</code> object output from <code>secr.fit</code></p>
</td></tr>
<tr><td><code id="LLsurface_+3A_betapar">betapar</code></td>
<td>
<p>character vector giving the names of two beta parameters</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_xval">xval</code></td>
<td>
<p>vector of numeric values for x-dimension of grid</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_yval">yval</code></td>
<td>
<p>vector of numeric values for y-dimension of grid</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_centre">centre</code></td>
<td>
<p>  vector of central values for all beta parameters</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_realscale">realscale</code></td>
<td>
<p>logical. If TRUE input and output of x and y is on
the untransformed (inverse-link) scale.</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE a contour plot is produced</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_plotfitted">plotfitted</code></td>
<td>
<p>logical. If TRUE the MLE from <code>object</code> is shown on the plot (+)</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads for parallel processing</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>centre</code> is set by default to the fitted values of the beta
parameters in <code>object</code>. This has the effect of holding parameters
other than those in <code>betapar</code> at their fitted values.
</p>
<p>If <code>xval</code> or <code>yval</code> is not provided then 11 values are set at
equal spacing between 0.8 and 1.2 times the values in <code>centre</code> (on
the &lsquo;real&rsquo; scale if <code>realscale</code> = TRUE and on the &lsquo;beta&rsquo; scale
otherwise).
</p>
<p>Contour plots may be customized by passing graphical parameters through
the ... argument.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>


<h3>Value</h3>

<p>A matrix of the log likelihood evaluated at each
grid point (rows x, columns y), invisibly if <code>plot = TRUE</code>. 
Failed evaluations return NA.
</p>


<h3>Note</h3>

<p><code>LLsurface</code> works for named &lsquo;beta&rsquo; parameters rather than
&lsquo;real&rsquo; parameters. The default <code>realscale = TRUE</code> only works for
beta parameters that share the name of the real parameter to which
they relate i.e. the beta parameter for the base level of the real
parameter. This is because link functions are defined for real
parameters not beta parameters.
</p>
<p>The contours are approximate because they rely on
interpolation. See Examples for a more reliable way to compare the
likelihood at the MLE with nearby points on the surface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

LLsurface(secrdemo.CL, xval = seq(0.16,0.40,0.02),
    yval = 25:35, nlevels = 20)

## now verify MLE
## click on MLE and apparent `peak'
if (interactive()) {
    xy &lt;- locator(2)
    LLsurface(secrdemo.CL, xval = xy$x, yval = xy$y, plot = FALSE)
}


## End(Not run)
</code></pre>

<hr>
<h2 id='logit'> Logit Transformation </h2><span id='topic+logit'></span><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Transform real values to the logit scale, and the inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
invlogit(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p> vector of numeric values in (0,1) (possibly a probability) </p>
</td></tr>
<tr><td><code id="logit_+3A_y">y</code></td>
<td>
<p> vector of numeric values </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logit transformation is defined as <code class="reqn">\mathrm{logit}(x) = \mathrm{log}( \frac{x}{1-x})</code> for <code class="reqn">x \in (0,1)</code>.
</p>


<h3>Value</h3>

<p>Numeric value on requested scale.
</p>


<h3>Note</h3>

<p><code>logit</code> is equivalent to <code><a href="stats.html#topic+qlogis">qlogis</a></code>, and <code>invlogit</code> is equivalent to <code><a href="stats.html#topic+plogis">plogis</a></code> (both <span class="rlang"><b>R</b></span> functions in the <span class="pkg">stats</span> package).
<code>logit</code> and <code>invlogit</code> are used in <span class="pkg">secr</span> because they are slightly more robust to bad input, and their names are more memorable!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logit(0.5)
invlogit(logit(0.2))
</code></pre>

<hr>
<h2 id='logmultinom'>
Multinomial Coefficient of SECR Likelihood
</h2><span id='topic+logmultinom'></span>

<h3>Description</h3>

<p>Compute the constant multinomial component of the SECR log likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logmultinom(capthist, grp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logmultinom_+3A_capthist">capthist</code></td>
<td>
 <p><code><a href="#topic+capthist">capthist</a></code> object </p>
</td></tr>
<tr><td><code id="logmultinom_+3A_grp">grp</code></td>
<td>
<p> factor defining group membership, or a list (see Details) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a particular dataset and grouping, the multinomial coefficient is
a constant; it does not depend on the parameters and may be ignored
when maximizing the likelihood to obtain parameter
estimates. Nevertheless, the log likelihood reported by
<code>secr.fit</code> includes this component <em>unless</em> the
detector type is &lsquo;signal&rsquo;, &lsquo;polygon&rsquo;, &lsquo;polygonX&rsquo;, &lsquo;transect&rsquo; or
&lsquo;transectX&rsquo; (from 2.0.0).
</p>
<p>If <code>grp</code> is NULL then all animals are assumed to belong to one
group. Otherwise, the length of <code>grp</code> should equal the number of rows of
<code>capthist</code>.
</p>
<p><code>grp</code> may also be any vector that can be coerced
to a factor. If <code>capthist</code> is a multi-session capthist object
then <code>grp</code> should be a list with one factor per session.
</p>
<p>If capture histories are not assigned to groups the value is the
logarithm of
</p>
<p style="text-align: center;"><code class="reqn">{{n}\choose{n_1, ..., n_C}} = {{n!} \over {n_1! n_2! ... n_C!}} </code>
</p>
<p> where <code class="reqn">n</code> is the total number of
capture histories and <code class="reqn">n_1</code> ... <code class="reqn">n_C</code> are the frequencies with
which each of the <code class="reqn">C</code> unique capture histories were observed.
</p>
<p>If capture histories are assigned to <code class="reqn">G</code> groups the value is the
logarithm of </p>
<p style="text-align: center;"><code class="reqn">{ \prod_{g=1}^{G} {{n_g!} \over {n_{g1}! n_{g2}! ... n_{gC_g}}!}}  </code>
</p>
<p> where <code class="reqn">n_g</code> is the number of capture histories of
group <code class="reqn">g</code> and <code class="reqn">n_{g1}</code> ... <code class="reqn">n_{gC_g}</code> are the frequencies with
which each of the <code class="reqn">C_g</code> unique capture histories were observed for
group <code class="reqn">g</code>.
</p>
<p>For multi-session data, the value is the sum of the single-session
values. Both session structure and group structure therefore affect
the value computed. Users will seldom need this function.
</p>


<h3>Value</h3>

<p>The numeric value of the log likelihood component.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture&ndash;recapture: likelihood-based methods. In:
D. L. Thompson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer. Pp. 255&ndash;269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stoatDNA">stoatDNA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## no groups
logmultinom(stoatCH)

</code></pre>

<hr>
<h2 id='LR.test'> Likelihood Ratio Test </h2><span id='topic+LR.test'></span>

<h3>Description</h3>

<p>Compute likelihood ratio test to compare two fitted models, one nested within the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR.test(model1, model2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LR.test_+3A_model1">model1</code></td>
<td>
<p> fitted model </p>
</td></tr>
<tr><td><code id="LR.test_+3A_model2">model2</code></td>
<td>
<p> fitted model </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted models must be of a class for which there is a logLik
method (e.g., &lsquo;secr&rsquo; or &lsquo;lm&rsquo;). Check with <code>methods("logLik")</code>.
</p>
<p>The models must be nested (no check is performed - this is up to the
user), but either model1 or model2 may be the more general model.
</p>
<p>The models must also be compatible by the criteria of <code><a href="#topic+AICcompatible">AICcompatible</a></code>. 
</p>
<p>The test statistic is twice the difference of the maximized
likelihoods. It is compared to a chi-square distribution with df equal
to the number of extra parameters in the more complex model. 
</p>


<h3>Value</h3>

<p>Object of class &lsquo;htest&rsquo;, a list with components
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value the test statistic </p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom of the approximate chi-squared distribution of the test statistic </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>probability of test statistic assuming chi-square distribution</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>character string indicating the type of test performed </p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>character string with names of models compared </p>
</td></tr>
</table>


<h3>See Also</h3>

 
<p><code><a href="#topic+AICcompatible">AICcompatible</a></code>,
<code><a href="#topic+AIC.secr">AIC.secr</a></code>, 
<code><a href="#topic+score.test">score.test</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## two pre-fitted models
AIC (secrdemo.0, secrdemo.b)
LR.test  (secrdemo.0, secrdemo.b)

</code></pre>

<hr>
<h2 id='make.capthist'> Construct capthist Object </h2><span id='topic+make.capthist'></span>

<h3>Description</h3>

<p>Form a <code>capthist</code> object from a data frame of capture records and a <code>traps</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.capthist(captures, traps, fmt = c("trapID", "XY"), noccasions = NULL,
    covnames = NULL, bysession = TRUE, sortrows = TRUE,
    cutval = NULL, tol = 0.01, snapXY = FALSE, noncapt = "NONE", signalcovariates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.capthist_+3A_captures">captures</code></td>
<td>
<p> dataframe of capture records in one of two possible formats (see Details) </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_traps">traps</code></td>
<td>
<p> object of class <code>traps</code> describing an array of passive detectors </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_fmt">fmt</code></td>
<td>
<p> character string for capture format. </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_noccasions">noccasions</code></td>
<td>
<p> number of occasions on which detectors were operated </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_covnames">covnames</code></td>
<td>
<p> character vector of names for individual covariate fields </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_bysession">bysession</code></td>
<td>
<p> logical, if true then ID are made unique by session </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_sortrows">sortrows</code></td>
<td>
<p> logical, if true then rows are sorted in ascending order of animalID </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_cutval">cutval</code></td>
<td>
<p> numeric, threshold of signal strength for &lsquo;signal&rsquo; detector type </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_tol">tol</code></td>
<td>
<p> numeric, snap tolerance in metres</p>
</td></tr>
<tr><td><code id="make.capthist_+3A_snapxy">snapXY</code></td>
<td>
<p> logical; if TRUE then fmt = 'XY' uses nearest trap
within tol for non-polygon detectors </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_noncapt">noncapt</code></td>
<td>
<p> character value; animal ID used for &lsquo;no captures&rsquo; </p>
</td></tr>
<tr><td><code id="make.capthist_+3A_signalcovariates">signalcovariates</code></td>
<td>
<p>character vector of field names from
&lsquo;captures&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.capthist</code> is the most flexible way to prepare data for
<code>secr.fit</code>. See <code><a href="#topic+read.capthist">read.capthist</a></code> for a more streamlined
way to read data from text files for common detector types. Each row of
the input data frame <code>captures</code> represents a detection on one
occasion. The capture data frame may be formed from a text file with
<code>read.table</code>.
</p>
<p>Input formats are based on the Density software (Efford 2012; see also
<a href="../doc/secr-datainput.pdf">secr-datainput.pdf</a>). If <code>fmt =
"XY"</code> the required fields are (session, ID, occasion, x, y) in that
order. If <code>fmt = "trapID"</code> the required fields are (session, ID,
occasion, trap), where <code>trap</code> is the numeric index of the relevant
detector in <code>traps</code>. <code>session</code> and <code>ID</code> may be
character-, vector- or factor-valued; other required fields are
numeric. Fields are matched by position (column number), <em>not</em> by
name. Columns after the required fields are interpreted as individual
covariates that may be continuous (e.g., size) or categorical (e.g.,
age, sex).
</p>
<p>If <code>captures</code> has data from multiple sessions then <code>traps</code> may
be either a list of <code>traps</code> objects, one per session, or a single
<code>traps</code> object that is assumed to apply throughout. Similarly,
<code>noccasions</code> may be a vector specifying the number of occasions in
each session.
</p>
<p>Covariates are assumed constant for each individual; the first
non-missing value is used. The length of <code>covnames</code> should equal the
number of covariate fields in <code>captures</code>.
</p>
<p><code>bysession</code> takes effect when the same individual is detected in
two or more sessions: TRUE results in one capture history per session,
FALSE has the effect of generating a single capture history (this is not
appropriate for the models currently provided in <span class="pkg">secr</span>).
</p>
<p>Deaths are coded as negative values in the occasion field of
<code>captures</code>. Occasions should be numbered 1, 2, ..., noccasions. By
default, the number of occasions is the maximum value of &lsquo;occasion&rsquo; in
<code>captures</code>.
</p>
<p>Signal strengths may be provided in the fifth (fmt = trapID) or sixth
(fmt = XY) columns. Detections with signal strength missing (NA) or
below &lsquo;cutval&rsquo; are discarded.
</p>
<p>A session may result in no detections. In this case a null line is
included in <code>captures</code> using the animal ID field given by
<code>noncapt</code>, the maximum occasion number, and any trapID (e.g. &quot;sess1
NONE 5 1&quot; for a 5-occasion session) (or equivalently &quot;sess1 NONE 5 10
10&quot; for fmt = XY).
</p>
<p>Nonspatial data (Session, AnimalID, Occasion and possibly individual 
covariates) may be entered by omitting the &lsquo;traps&rsquo; argument or setting 
it to NULL.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+capthist">capthist</a></code> (a matrix or array of
detection data with attributes for detector positions etc.). For
&lsquo;single&rsquo; and &lsquo;multi&rsquo; detectors this is a matrix with one row per animal
and one column per occasion (dim(capthist)=c(nc,noccasions)); each
element is either zero (no detection) or a detector number (the row
number in <code>traps</code> <em>not</em> the row name). For &lsquo;proximity&rsquo;
detectors <code>capthist</code> is an array of values {-1, 0, 1} and
dim(capthist)=c(nc,noccasions,ntraps). The number of animals <code>nc</code>
is determined from the input, as is <code>noccasions</code> if it is not specified.
<code>traps</code>, <code>covariates</code> and other data are retained as
attributes of <code>capthist</code>.
</p>
<p>Deaths during the experiment are represented as negative values in <code>capthist</code>.
</p>
<p>For &lsquo;signal&rsquo; and &lsquo;signalnoise&rsquo; detectors, the columns of <code>captures</code>
identified in <code>signalcovariates</code> are saved along with signal
strength measurements in the attribute &lsquo;signalframe&rsquo;.
</p>
<p>If the input has data from multiple sessions then the output is an
object of class c(&quot;capthist&quot;, &quot;list&quot;) comprising a list of single-session
<code>capthist</code> objects.
</p>


<h3>Note</h3>

<p><code>make.capthist</code> requires that the data for <code>captures</code> and
<code>traps</code> already exist as <span class="rlang"><b>R</b></span> objects. To read data from external
(text) files, first use <code>read.table</code> and <code>read.traps</code>, or try
<code><a href="#topic+read.capthist">read.capthist</a></code> for a one-step solution.
</p>
<p>Prior to <span class="pkg">secr</span> 4.4.0, occasional valid records for &quot;multi&quot; and &quot;single&quot; detectors 
were rejected as duplicates.
</p>
<p>From <span class="pkg">secr</span> 4.5.0, &lsquo;snapXY&rsquo; works for transects as well as point detectors.
</p>


<h3>References</h3>

<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+traps">traps</a></code>,
<code><a href="#topic+read.capthist">read.capthist</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+sim.capthist">sim.capthist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## peek at demonstration data
head(captXY)
head(trapXY)

demotraps &lt;- read.traps(data = trapXY)
demoCHxy  &lt;- make.capthist (captXY, demotraps, fmt = "XY")

demoCHxy            ## print method for capthist
plot(demoCHxy)      ## plot method for capthist
summary(demoCHxy)   ## summary method for capthist


## To enter `count' data without manually repeating rows
## need a frequency vector f, length(f) == nrow(captXY)
n &lt;- nrow(captXY)
f &lt;- sample (1:5, size = n, prob = rep(0.2,5), replace = TRUE)
## repeat rows as required...
captXY &lt;- captXY[rep(1:n, f),]
counttraps &lt;- read.traps(data = trapXY, detector = "count")
countCH  &lt;- make.capthist (captXY, counttraps, fmt = "XY")

</code></pre>

<hr>
<h2 id='make.lacework'>Construct Lacework Detector Design</h2><span id='topic+make.lacework'></span>

<h3>Description</h3>

<p>A lacework design comprises a square grid with detectors placed at regular distances along the grid lines (Efford unpubl.). This requires fewer detectors than uniform coverage at close spacing and is simpler than clustered designs, while providing good spatial coverage and protection from alignment bias (Efford 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.lacework(region, spacing = c(100, 20), times = NULL, origin = NULL, 
    rotate = 0, radius = NULL, detector = "multi", keep.design = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.lacework_+3A_region">region</code></td>
<td>
<p>dataframe or SpatialPolygonsDataFrame with coordinates of perimeter</p>
</td></tr>
<tr><td><code id="make.lacework_+3A_spacing">spacing</code></td>
<td>
<p>numeric 2-vector with major (grid) and minor spacings, or minor spacing only</p>
</td></tr>
<tr><td><code id="make.lacework_+3A_times">times</code></td>
<td>
<p>numeric ratio major:minor spacing if spacing length 1</p>
</td></tr>
<tr><td><code id="make.lacework_+3A_origin">origin</code></td>
<td>
<p>numeric vector giving x- and y-cooordinates of fixed grid origin
(origin is otherwise random)</p>
</td></tr>
<tr><td><code id="make.lacework_+3A_rotate">rotate</code></td>
<td>
<p>numeric; number of degrees by which to rotate design clockwise 
about centroid of region bounding box</p>
</td></tr>
<tr><td><code id="make.lacework_+3A_radius">radius</code></td>
<td>
<p>numeric; detectors are dropped if they are further than this 
from a crossing</p>
</td></tr>    
<tr><td><code id="make.lacework_+3A_detector">detector</code></td>
<td>
<p>character detector type &ndash; see <code><a href="#topic+make.grid">make.grid</a></code></p>
</td></tr>   
<tr><td><code id="make.lacework_+3A_keep.design">keep.design</code></td>
<td>
<p>logical; if TRUE then input argument values are retained</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is tidy for the major spacing (<code>spacing[1]</code>) to be a multiple of the minor spacing (<code>spacing[2]</code>); precisely one detector is then placed at each grid intersection. This outcome may also be achieved by providing only the minor spacing in the <code>spacing</code> argument and specifying an integer value for <code>times</code>.
</p>
<p>In general it is better not to specify <code>origin</code>. Specifying both <code>origin</code> and <code>rotate</code> may result in incomplete coverage, as the desired grid is relative to the bounding box of the <em>rotated</em> region.
</p>
<p>Set <code>radius</code> &lt; spacing[1]/2 to break lacework into multiple cross-shaped arrays centred on the intersections (crossing points) and truncated at <code>radius</code> metres (assuming you follow advice and express all linear measurements in metres).
</p>
<p>The number of detectors should not exceed 5000.
</p>


<h3>Value</h3>

<p>An <span class="pkg">secr</span> traps object. The attribute &lsquo;crossings&rsquo; is a 2-column matrix with the coordinates of the intersection points. If <code>keep.design</code> is TRUE then the input argument values are retained in attribute &lsquo;design&rsquo; (a list with first component <code>function = 'make.lacework'</code>).
</p>


<h3>References</h3>

<p>Efford, M. G. (2019) Non-circular home ranges and the estimation of population density. <em>Ecology</em> <b>100</b>, e02580. https://esajournals.onlinelibrary.wiley.com/doi/10.1002/ecy.2580
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.systematic">make.systematic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trps &lt;- make.lacework(possumarea, c(1000,100), rotate = 45, detector = 'proximity')
plot(trps, gridspace = 1000)
lines(possumarea)
points(attr(trps, 'crossings'), pch = 16)

</code></pre>

<hr>
<h2 id='make.mask'> Build Habitat Mask </h2><span id='topic+make.mask'></span>

<h3>Description</h3>

<p>Construct a habitat mask object for spatially explicit capture-recapture. 
A mask object is a set of points with optional attributes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.mask(traps, buffer = 100, spacing = NULL, nx = 64, ny = 64, type =
    c("traprect", "trapbuffer", "pdot", "polygon", "clusterrect",
    "clusterbuffer", "rectangular", "polybuffer"), poly = NULL, poly.habitat = TRUE,
    cell.overlap = c("centre","any","all"), keep.poly = TRUE, check.poly = TRUE, 
    pdotmin = 0.001, random.origin = FALSE,
    ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.mask_+3A_traps">traps</code></td>
<td>
<p> object of class <code>traps</code> </p>
</td></tr>
<tr><td><code id="make.mask_+3A_buffer">buffer</code></td>
<td>
<p> width of buffer in metres </p>
</td></tr>
<tr><td><code id="make.mask_+3A_spacing">spacing</code></td>
<td>
<p> spacing between grid points (metres) </p>
</td></tr>
<tr><td><code id="make.mask_+3A_nx">nx</code></td>
<td>
<p> number of grid points in &lsquo;x&rsquo; direction </p>
</td></tr>
<tr><td><code id="make.mask_+3A_ny">ny</code></td>
<td>
<p> number of grid points in &lsquo;y&rsquo; direction (type = &lsquo;rectangular&rsquo;) </p>
</td></tr>
<tr><td><code id="make.mask_+3A_type">type</code></td>
<td>
<p> character string for method </p>
</td></tr>
<tr><td><code id="make.mask_+3A_poly">poly</code></td>
<td>
<p> bounding polygon to which mask should be clipped (see Details) </p>
</td></tr>
<tr><td><code id="make.mask_+3A_poly.habitat">poly.habitat</code></td>
<td>
<p> logical for whether poly represents habitat or
its inverse (non-habitat)</p>
</td></tr>
<tr><td><code id="make.mask_+3A_cell.overlap">cell.overlap</code></td>
<td>
<p>character string for cell vertices used to determine overlap with &lsquo;poly&rsquo;</p>
</td></tr>
<tr><td><code id="make.mask_+3A_keep.poly">keep.poly</code></td>
<td>
<p> logical; if TRUE any bounding polygon is saved as the
attribute &lsquo;polygon&rsquo; </p>
</td></tr>
<tr><td><code id="make.mask_+3A_check.poly">check.poly</code></td>
<td>
<p> logical; if TRUE a warning is given for traps that
lie outside a bounding polygon </p>
</td></tr>
<tr><td><code id="make.mask_+3A_pdotmin">pdotmin</code></td>
<td>
<p> minimum detection probability for inclusion in mask when <code>type = "pdot"</code> (optional) </p>
</td></tr>
<tr><td><code id="make.mask_+3A_random.origin">random.origin</code></td>
<td>
<p> logical; if TRUE the mask coordinates are jittered</p>
</td></tr>
<tr><td><code id="make.mask_+3A_...">...</code></td>
<td>
<p> additional arguments passed to <code>pdot</code> when <code>type = "pdot"</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;traprect&rsquo; method constructs a grid of points in the rectangle
formed by adding a buffer strip to the minimum and maximum x-y
coordinates of the detectors in <code>traps</code>. Both &lsquo;trapbuffer&rsquo; and
&lsquo;pdot&rsquo; start with a &lsquo;traprect&rsquo; mask and drop some points.
</p>
<p>The &lsquo;trapbuffer&rsquo; method restricts the grid to points within distance
<code>buffer</code> of any detector.
</p>
<p>The &lsquo;pdot&rsquo; method restricts the grid to points for which the net
detection probability <code class="reqn">p.(\mathbf{X})</code> (see
<code><a href="#topic+pdot">pdot</a></code>) is at least <code>pdotmin</code>. Additional parameters
are used by <code>pdot</code> (detectpar, noccasions). Set these with the
... argument; otherwise <code>make.mask</code> will silently use the
arbitrary defaults. <code>pdot</code> is currently limited to a halfnormal
detection function.
</p>
<p>The &lsquo;clusterrect&rsquo; method constructs a grid of rectangular submasks
centred on &lsquo;clusters&rsquo; of detectors generated with
<code><a href="#topic+trap.builder">trap.builder</a></code> (possibly indirectly by
<code><a href="#topic+make.systematic">make.systematic</a></code>). The &lsquo;clusterbuffer&rsquo; method resembles
&lsquo;trapbuffer&rsquo;, but is usually faster when traps are arranged in clusters
because it starts with a &lsquo;clusterrect&rsquo; mask.
</p>
<p>The &lsquo;rectangular&rsquo; method constructs a simple rectangular mask with the
given nx, ny and spacing. 
</p>
<p>The &lsquo;polybuffer&rsquo; method constructs a mask by buffering around the polygon specified in the &lsquo;poly&rsquo; argument. If that inherits from &lsquo;SpatialPolygons&rsquo; or &lsquo;sfc&rsquo; then the buffering is performed with sf::st_buffer. Otherwise, buffering is approximate, based on the distance to points on an initial discretized mask enclosed by &lsquo;poly&rsquo; (points at half the current &lsquo;spacing&rsquo;).
</p>
<p>If <code>poly</code> is specified, points outside <code>poly</code> are dropped (unless type = &quot;polybuffer&quot;). The default is to require only the centre to lie within <code>poly</code>; use <code>cell.overlap = "all"</code> to require all cell corners to lie within <code>poly</code>, or <code>cell.overlap = "any"</code> to accept cells with any corner in <code>poly</code>. The &lsquo;polygon&rsquo; method places points on a rectangular grid clipped to the
polygon (<code>buffer</code> is not used). Thus &lsquo;traprect&rsquo; is equivalent to
&lsquo;polygon&rsquo; when <code>poly</code> is supplied. <code>poly</code> may be either
</p>

<ul>
<li><p> a matrix or dataframe of two columns interpreted as x and y
coordinates, or
</p>
</li>
<li><p> an object from package &lsquo;sf&rsquo; with polygon geometries, or
</p>
</li>
<li><p> a SpatialPolygons or SpatialPolygonsDataFrame object as defined in the package &lsquo;sp&rsquo;,
possibly imported by reading a shapefile.
</p>
</li></ul>

<p>If <code>spacing</code> is not specified then it is determined by dividing the
range of the x coordinates (including any buffer) by <code>nx</code>.
</p>
<p><code>random.origin</code> shifts the origin of the mask by a uniform random displacement within a spacing x spacing grid cell, while ensuring that the mask also satisfies the buffer requirement. <code>random.origin</code> is available only for &lsquo;traprect&rsquo;, &lsquo;trapbuffer&rsquo;, &lsquo;polygon&rsquo;, and &lsquo;rectangular&rsquo; types, and <code>spacing</code> 
must be specified.
</p>


<h3>Value</h3>

<p>An object of class <code>mask</code>.  When <code>keep.poly = TRUE</code>,
<code>poly</code> and <code>poly.habitat</code> are saved as attributes of the
mask.
</p>


<h3>Note</h3>

<p>A warning is displayed if <code>type = "pdot"</code> and the buffer is too small to
include all points with <code class="reqn">p.</code> &gt; pdotmin.
</p>
<p>A habitat mask is needed to fit an SECR model and for some related
computations. The default mask settings in <code>secr.fit</code> may be good
enough, but it is preferable to use <code>make.mask</code> to construct a mask
in advance and to pass that mask as an argument to <code>secr.fit</code>.
</p>
<p>The function <code>buffer.contour</code> displays the extent of one or more
&lsquo;trapbuffer&rsquo; zones - i.e. the effect of buffering the detector array
with varying strip widths. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+read.mask">read.mask</a></code>, <code><a href="#topic+subset.mask">subset.mask</a></code>,
<code><a href="#topic+pdot">pdot</a></code>, <code><a href="#topic+buffer.contour">buffer.contour</a></code>, <code><a href="#topic+deleteMaskPoints">deleteMaskPoints</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temptrap &lt;- make.grid(nx = 10, ny = 10, spacing = 30)

## default method: traprect
tempmask &lt;- make.mask(temptrap, spacing = 5)
plot(tempmask)
summary (tempmask)

## make irregular detector array by subsampling 
## form mask by `trapbuffer' method
temptrap &lt;- subset (temptrap, sample(nrow(temptrap), size = 30))
tempmask &lt;- make.mask (temptrap, spacing = 5, type = "trapbuffer")
plot (tempmask)
plot (temptrap, add = TRUE)

## Not run: 

## form mask by "pdot" method
temptrap &lt;- make.grid(nx = 6, ny = 6)
tempmask &lt;- make.mask (temptrap, buffer = 150, type = "pdot", 
    pdotmin = 0.0001, detectpar = list(g0 = 0.1, sigma = 30),
    noccasions = 4)
plot (tempmask)
plot (temptrap, add = TRUE)

## Using an ESRI polygon shapefile for clipping (shapefile
## polygons may include multiple islands and holes).

library(sf)
shpfilename &lt;- system.file("extdata/possumarea.shp", package = "secr")
possumarea &lt;- st_read(shpfilename)

possummask2 &lt;- make.mask(traps(possumCH), spacing = 20,
    buffer = 250, type = "trapbuffer", poly = possumarea)
par(mar = c(1,6,6,6), xpd = TRUE)
plot (possummask2, ppoly = TRUE)
plot(traps(possumCH), add = TRUE)
par(mar = c(5,4,4,2) + 0.1, xpd = FALSE)

## if the polygon delineates non-habitat ...
seaPossumMask &lt;- make.mask(traps(possumCH), buffer = 1000, 
    type = "traprect", poly = possumarea, poly.habitat = FALSE)
plot(seaPossumMask)
plot(traps(possumCH), add = TRUE)
## this mask is not useful!


## End(Not run)


</code></pre>

<hr>
<h2 id='make.systematic'> Construct Systematic Detector Design </h2><span id='topic+make.systematic'></span>

<h3>Description</h3>

<p>A rectangular grid of clusters within a polygonal region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.systematic(n, cluster, region, spacing = NULL, origin = NULL, 
    originoffset = c(0,0), chequerboard = c('all','black','white'), 
    order = c('x', 'y', 'xb', 'yb'), rotate = 0,  centrexy = NULL,
    keep.design = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.systematic_+3A_n">n</code></td>
<td>
<p>integer approximate number of clusters (see Details) </p>
</td></tr>
<tr><td><code id="make.systematic_+3A_cluster">cluster</code></td>
<td>
<p>traps object defining a single cluster </p>
</td></tr>
<tr><td><code id="make.systematic_+3A_region">region</code></td>
<td>
<p>dataframe or SpatialPolygonsDataFrame with coordinates
of perimeter </p>
</td></tr>
<tr><td><code id="make.systematic_+3A_spacing">spacing</code></td>
<td>
<p> scalar distance between cluster centres </p>
</td></tr>
<tr><td><code id="make.systematic_+3A_origin">origin</code></td>
<td>
<p>vector giving x- and y-cooordinates of fixed grid origin
(origin is otherwise random)</p>
</td></tr>
<tr><td><code id="make.systematic_+3A_originoffset">originoffset</code></td>
<td>
<p> numeric; 2-vector (x,y offsets); see Details</p>
</td></tr>
<tr><td><code id="make.systematic_+3A_chequerboard">chequerboard</code></td>
<td>
<p> logical; if not &lsquo;all&rsquo; then alternate clusters are omitted </p>
</td></tr>
<tr><td><code id="make.systematic_+3A_order">order</code></td>
<td>
<p> character; sort order for clusters (see Details)</p>
</td></tr>
<tr><td><code id="make.systematic_+3A_rotate">rotate</code></td>
<td>
<p>numeric; number of degrees by which to rotate entire design clockwise 
about centroid of region bounding box</p>
</td></tr>
<tr><td><code id="make.systematic_+3A_centrexy">centrexy</code></td>
<td>
<p>numeric; 2-vector for centre of rotation, if any </p>
</td></tr>   
<tr><td><code id="make.systematic_+3A_keep.design">keep.design</code></td>
<td>
<p>logical; if TRUE then input argument values are retained</p>
</td></tr>
<tr><td><code id="make.systematic_+3A_...">...</code></td>
<td>
<p> arguments passed to <code>trap.builder</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>region</code> may be any shape. 
</p>
<p><code>region</code> may be one of the spatial classes described 
in <code><a href="#topic+boundarytoSF">boundarytoSF</a></code>. Otherwise,
<code>region</code> should be a dataframe with columns &lsquo;x&rsquo; and &lsquo;y&rsquo;.
</p>
<p><code>spacing</code> may be a vector with separate values for spacing in x-
and y- directions. If <code>spacing</code> is provided then <code>n</code> is ignored.
</p>
<p>If <code>n</code> is a scalar, the spacing of clusters is determined from
the area of the bounding box of <code>region</code> divided by the requested
number of clusters (this does not necessarily result in exactly n
clusters). If <code>n</code> is a vector of two integers these are taken to be
the number of columns and the number of rows.
</p>
<p>After preparing a frame of cluster centres, <code>make.systematic</code>
calls <code><a href="#topic+trap.builder">trap.builder</a></code> with method = &lsquo;all&rsquo;; ... allows the
arguments &lsquo;rotation&rsquo;, &lsquo;edgemethod&rsquo;, &lsquo;plt&rsquo;, and &lsquo;detector&rsquo; to be
passed. Setting the <code>trap.builder</code> arguments <code>frame</code>,
<code>method</code>, and <code>samplefactor</code> has no effect.
</p>
<p>Note the distinction between argument <code>rotate</code> and the <code>trap.builder</code> 
argument <code>rotation</code> that is applied separately to each cluster.
</p>
<p>If <code>origin</code> is not specified then a random uniform origin is chosen within a box (width = spacing) placed with its bottom left corner at the bottom left of the bounding box of <code>region</code>, shifted by <code>originoffset</code>. Before version 3.1.8 the behaviour of <code>make.systematic</code> was equivalent to <code>originoffset = c(wx,wy)</code> where <code>wx,wy</code> are the cluster half widths.   
</p>
<p><code>chequerboard = "black"</code> retains black &lsquo;squares&rsquo; and <code>chequerboard = "white"</code> retains white &lsquo;squares&rsquo;, where the lower left cluster in the candidate rectangle of cluster origins is black, as on a chess board. The effect is the same as increasing spacing by sqrt(2) and rotating through 45 degrees.
</p>
<p><code>order</code> determines the ordering of clusters in the resulting traps object. The options are a subset of those for <code>ID</code> argument of <code><a href="#topic+make.grid">make.grid</a></code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
     Option </td><td style="text-align: left;"> Sort order </td>
</tr>
<tr>
 <td style="text-align: left;">
     x </td><td style="text-align: left;">  column-dominant </td>
</tr>
<tr>
 <td style="text-align: left;">
     y </td><td style="text-align: left;">  row-dominant </td>
</tr>
<tr>
 <td style="text-align: left;">
     xb </td><td style="text-align: left;">  column-dominant boustrophedonical (alternate columns reversed) </td>
</tr>
<tr>
 <td style="text-align: left;">
     yb </td><td style="text-align: left;">  row-dominant boustrophedonical (alternate rows reversed) </td>
</tr>
<tr>
 <td style="text-align: left;">
     </td>
</tr>

</table>

<p><code>rotate</code> rotates the array about the given centre (default is centroid of the bounding box of <code>region</code>). 
</p>


<h3>Value</h3>

<p>A single-session &lsquo;traps&rsquo; object.
</p>
<p>From 3.2.0 these additional attributes are set &ndash;
</p>

<table>
<tr>
 <td style="text-align: left;">
origin </td><td style="text-align: left;"> coordinates of grid origin </td>
</tr>
<tr>
 <td style="text-align: left;">
centres </td><td style="text-align: left;"> coordinates of true cluster centres (cf <code><a href="#topic+cluster.centres">cluster.centres</a></code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
originbox </td><td style="text-align: left;"> vertices of rectangular spatial sampling frame for random origin </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>From 4.2.0 if <code>keep.design</code> is TRUE then the input argument values are retained in attribute &lsquo;design&rsquo; (a list with first component <code>function = 'make.systematic'</code>).
</p>


<h3>Note</h3>

<p>Do not confuse with the simpler function <code><a href="#topic+make.grid">make.grid</a></code>,
which places single detectors in a rectangular array.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trap.builder">trap.builder</a></code>, 
<code><a href="#topic+make.lacework">make.lacework</a></code>,
<code><a href="#topic+cluster.centres">cluster.centres</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mini &lt;- make.grid(nx = 2, ny = 2, spacing = 100)
region &lt;- cbind(x=c(0,2000,2000,0), y=c(0,0,2000,2000))
temp &lt;- make.systematic(25, mini, region, plt = TRUE)
temp &lt;- make.systematic(c(6, 6), mini, region, plt = TRUE,
    rotation = -1)

## Example using shapefile "possumarea.shp" in
## "extdata" folder. By default, each cluster is 
## a single multi-catch detector

## Not run: 

library(sf)
shpfilename &lt;- system.file("extdata/possumarea.shp", package = "secr")
possumarea &lt;- st_read(shpfilename)

possumgrid &lt;- make.systematic(spacing = 100, region =
    possumarea, plt = TRUE)

## or with 2 x 2 clusters
possumgrid2 &lt;- make.systematic(spacing = 300,
    cluster = make.grid(nx = 2, ny = 2, spacing = 100),
    region = possumarea, plt = TRUE, edgemethod =
    "allinside")
## label clusters
text(cluster.centres(possumgrid2), levels(clusterID
    (possumgrid2)), cex=0.7)

## If you have GPSBabel installed and on the Path
## then coordinates can be projected and uploaded
## to a GPS with `writeGPS', which also requires the
## package `proj4'. Defaults are for a Garmin GPS
## connected by USB.

if (interactive()) {
    writeGPS(possumgrid, proj = "+proj=nzmg")
}


## End(Not run)

</code></pre>

<hr>
<h2 id='make.traps'> Build Detector Array </h2><span id='topic+make.grid'></span><span id='topic+make.circle'></span><span id='topic+make.poly'></span><span id='topic+make.transect'></span><span id='topic+make.telemetry'></span>

<h3>Description</h3>

<p>Construct a rectangular array of detectors (trapping grid) or a circle of detectors or a polygonal search area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.grid(nx = 6, ny = 6, spacex = 20, spacey = spacex, spacing = NULL,
    detector = "multi", originxy = c(0,0), hollow = FALSE, ID = "alphay", 
    leadingzero = TRUE, markocc = NULL)

make.circle (n = 20, radius = 100, spacing = NULL, 
    detector = "multi", originxy = c(0,0), IDclockwise = TRUE, 
    leadingzero = TRUE, markocc = NULL)

make.poly (polylist = NULL, x = c(-50,-50,50,50),
    y = c(-50,50,50,-50), exclusive = FALSE, verify = TRUE)

make.transect (transectlist = NULL, x = c(-50,-50,50,50),
    y = c(-50,50,50,-50), exclusive = FALSE)

make.telemetry (xy = c(0,0)) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.traps_+3A_nx">nx</code></td>
<td>
<p> number of columns of detectors </p>
</td></tr>
<tr><td><code id="make.traps_+3A_ny">ny</code></td>
<td>
<p> number of rows of detectors </p>
</td></tr>
<tr><td><code id="make.traps_+3A_spacex">spacex</code></td>
<td>
<p> distance between detectors in &lsquo;x&rsquo; direction (nominally in metres)</p>
</td></tr>
<tr><td><code id="make.traps_+3A_spacey">spacey</code></td>
<td>
<p> distance between detectors in &lsquo;y&rsquo; direction (nominally in metres)</p>
</td></tr>
<tr><td><code id="make.traps_+3A_spacing">spacing</code></td>
<td>
<p> distance between detectors (x and y directions)</p>
</td></tr>
<tr><td><code id="make.traps_+3A_detector">detector</code></td>
<td>
<p> character value for detector type - &quot;single&quot;, &quot;multi&quot; etc. </p>
</td></tr>
<tr><td><code id="make.traps_+3A_originxy">originxy</code></td>
<td>
<p> vector origin for x-y coordinates </p>
</td></tr>
<tr><td><code id="make.traps_+3A_hollow">hollow</code></td>
<td>
<p> logical for hollow grid </p>
</td></tr>
<tr><td><code id="make.traps_+3A_id">ID</code></td>
<td>
<p> character string to control row names </p>
</td></tr>
<tr><td><code id="make.traps_+3A_leadingzero">leadingzero</code></td>
<td>
<p>logical; if TRUE numeric rownames are padded with leading zeros</p>
</td></tr>
<tr><td><code id="make.traps_+3A_markocc">markocc</code></td>
<td>
<p>integer vector of marking or sighting codes; see <code><a href="#topic+markocc">markocc</a></code></p>
</td></tr>
<tr><td><code id="make.traps_+3A_n">n</code></td>
<td>
<p> number of detectors </p>
</td></tr>
<tr><td><code id="make.traps_+3A_radius">radius</code></td>
<td>
<p> radius of circle  (nominally in metres) </p>
</td></tr>
<tr><td><code id="make.traps_+3A_idclockwise">IDclockwise</code></td>
<td>
<p> logical for numbering of detectors </p>
</td></tr>
<tr><td><code id="make.traps_+3A_polylist">polylist</code></td>
<td>
<p> list of dataframes with coordinates for polygons </p>
</td></tr>
<tr><td><code id="make.traps_+3A_transectlist">transectlist</code></td>
<td>
<p> list of dataframes with coordinates for transects </p>
</td></tr>
<tr><td><code id="make.traps_+3A_x">x</code></td>
<td>
<p> x coordinates of vertices </p>
</td></tr>
<tr><td><code id="make.traps_+3A_y">y</code></td>
<td>
<p> y coordinates of vertices </p>
</td></tr>
<tr><td><code id="make.traps_+3A_exclusive">exclusive</code></td>
<td>
<p> logical; if TRUE animal can be detected only once
per occasion </p>
</td></tr>
<tr><td><code id="make.traps_+3A_verify">verify</code></td>
<td>
<p> logical if TRUE then the resulting traps object is
checked with <code><a href="#topic+verify">verify</a></code></p>
</td></tr>
<tr><td><code id="make.traps_+3A_xy">xy</code></td>
<td>
<p>vector with coordinates of arbitrary point (e.g., centroid of fixes)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.grid</code> generates coordinates for <code>nx.ny</code> traps at
separations <code>spacex</code> and <code>spacey</code>. If <code>spacing</code> is
specified it replaces both <code>spacex</code> and <code>spacey</code>. The
bottom-left (southwest) corner is at <code>originxy</code>. For a hollow grid,
only detectors on the perimeter are retained. By default, identifiers
are constructed from a letter code for grid rows and an integer value
for grid columns (&quot;A1&quot;, &quot;A2&quot;,...). &lsquo;Hollow&rsquo; grids are always numbered
clockwise in sequence from the bottom-left corner. Other values of
<code>ID</code> have the following effects:
</p>

<table>
<tr>
 <td style="text-align: left;">
     ID </td><td style="text-align: left;">  Effect </td>
</tr>
<tr>
 <td style="text-align: left;">
     numx </td><td style="text-align: left;">  column-dominant numeric sequence </td>
</tr>
<tr>
 <td style="text-align: left;">
     numy </td><td style="text-align: left;">  row-dominant numeric sequence </td>
</tr>
<tr>
 <td style="text-align: left;">
     numxb </td><td style="text-align: left;">  column-dominant boustrophedonical numeric sequence (try it!) </td>
</tr>
<tr>
 <td style="text-align: left;">
     numyb </td><td style="text-align: left;">  row-dominant boustrophedonical numeric sequence </td>
</tr>
<tr>
 <td style="text-align: left;">
     alphax </td><td style="text-align: left;">  column-dominant alphanumeric </td>
</tr>
<tr>
 <td style="text-align: left;">
     alphay </td><td style="text-align: left;">  row-dominant alphanumeric </td>
</tr>
<tr>
 <td style="text-align: left;">
     xy </td><td style="text-align: left;">  combine column (x) and row(y) numbers </td>
</tr>
<tr>
 <td style="text-align: left;">     
  </td>
</tr>

</table>

<p>&lsquo;xy&rsquo; adds leading zeros as needed to give a string of constant length with
no blanks.
</p>
<p><code>make.circle</code> generates coordinates for n traps in a circle centred
on <code>originxy</code>. If <code>spacing</code> is specified then it overrides the
<code>radius</code> setting; the radius is adjusted to provide the requested
straightline distance between adjacent detectors. Traps are numbered
from the trap due east of the origin, either clockwise or anticlockwise
as set by <code>IDclockwise</code>. 
</p>
<p>Polygon vertices may be specified with <code>x</code> and <code>y</code> in the case
of a single polygon, or as <code>polylist</code> for one or more polygons. Each
component of <code>polylist</code> is a dataframe with columns &lsquo;x&rsquo; and &lsquo;y&rsquo;.
<code>polylist</code> takes precedence. <code>make.poly</code> automatically closes
the polygon by repeating the first vertex if the first and last vertices
differ.
</p>
<p>Transects are defined by a sequence of vertices as for polygons, except 
that they are not closed.
</p>
<p><code>make.telemetry</code> builds a simple traps object for the 'telemetry' detector type. The attribute 'telemetrytype' is set to &quot;independent&quot;. 
</p>
<p>Specialised functions for arrays using a triangular grid are described
separately (<code><a href="#topic+make.tri">make.tri</a></code>,  <code><a href="#topic+clip.hex">clip.hex</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>traps</code> comprising a data frame of x- and
y-coordinates, the detector type (&quot;single&quot;, &quot;multi&quot;, or &quot;proximity&quot; etc.),
and possibly other attributes.
</p>


<h3>Note</h3>

<p> Several methods are provided for manipulating detector arrays - see <code><a href="#topic+traps">traps</a></code>.
</p>


<h3>References</h3>

 
<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.traps">read.traps</a></code>,<code><a href="#topic+detector">detector</a></code>,
<code><a href="#topic+trap.builder">trap.builder</a></code>,<code><a href="#topic+make.systematic">make.systematic</a></code>,  
<code><a href="#topic+print.traps">print.traps</a></code>, <code><a href="#topic+plot.traps">plot.traps</a></code>,
<code><a href="#topic+traps">traps</a></code>, <code><a href="#topic+make.tri">make.tri</a></code>,
<code><a href="#topic+addTelemetry">addTelemetry</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo.traps &lt;- make.grid()
plot(demo.traps)

## compare numbering schemes
par (mfrow = c(2,4), mar = c(1,1,1,1), xpd = TRUE)
for (id in c("numx", "numy", "alphax", "alphay", "numxb", 
    "numyb"))
{
    temptrap &lt;- make.grid(nx = 7, ny = 5, ID = id)
    plot (temptrap, border = 10, label = TRUE, offset = 7, 
        gridl = FALSE)
}

temptrap &lt;- make.grid(nx = 7, ny = 5, hollow = TRUE)
plot (temptrap, border = 10, label = TRUE, gridl = FALSE)

plot(make.circle(n = 20, spacing = 30), label = TRUE, offset = 9)
summary(make.circle(n = 20, spacing = 30))


## jitter locations randomly within grid square
## and plot over `mask'
temptrap &lt;- make.grid(nx = 7, ny = 7, spacing = 30)
tempmask &lt;- make.mask(temptrap, buffer = 15, nx = 7, ny = 7)
temptrap[,] &lt;- temptrap[,] + 30 * (runif(7*7*2) - 0.5)
plot(tempmask, dots = FALSE, mesh = 'white')
plot(temptrap, add = TRUE)

</code></pre>

<hr>
<h2 id='make.tri'> Build Detector Array on Triangular or Hexagonal Grid </h2><span id='topic+make.tri'></span><span id='topic+clip.hex'></span>

<h3>Description</h3>

<p>Construct an array of detectors on a triangular grid and optionally
select a hexagonal subset of detectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.tri (nx = 10, ny = 12, spacing = 20, detector = "multi",
    originxy = c(0,0))

clip.hex (traps, side = 20, centre = c(50, 60*cos(pi/6)),
    fuzz = 1e-3, ID = "num", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.tri_+3A_nx">nx</code></td>
<td>
<p> number of columns of detectors </p>
</td></tr>
<tr><td><code id="make.tri_+3A_ny">ny</code></td>
<td>
<p> number of rows of detectors </p>
</td></tr>
<tr><td><code id="make.tri_+3A_spacing">spacing</code></td>
<td>
<p> distance between detectors (x and y directions)</p>
</td></tr>
<tr><td><code id="make.tri_+3A_detector">detector</code></td>
<td>
<p> character value for detector type - &quot;single&quot;, &quot;multi&quot; etc. </p>
</td></tr>
<tr><td><code id="make.tri_+3A_originxy">originxy</code></td>
<td>
<p> vector origin for x-y coordinates </p>
</td></tr>
<tr><td><code id="make.tri_+3A_traps">traps</code></td>
<td>
<p> traps object </p>
</td></tr>
<tr><td><code id="make.tri_+3A_side">side</code></td>
<td>
<p> length of hexagon side </p>
</td></tr>
<tr><td><code id="make.tri_+3A_centre">centre</code></td>
<td>
<p> x-y coordinates of hexagon centre </p>
</td></tr>
<tr><td><code id="make.tri_+3A_fuzz">fuzz</code></td>
<td>
<p> floating point fuzz value </p>
</td></tr>
<tr><td><code id="make.tri_+3A_id">ID</code></td>
<td>
<p> character string to control row names </p>
</td></tr>
<tr><td><code id="make.tri_+3A_...">...</code></td>
<td>
<p> other parameters passed to subset.traps (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.tri</code> generates coordinates for <code>nx.ny</code> traps at
separations <code>spacing</code>. The bottom-left (southwest) corner is at
<code>originxy</code>. Identifiers are numeric. See <code><a href="#topic+make.grid">make.grid</a></code>
for further explanation.
</p>
<p><code>clip.hex</code> clips a grid of detectors, retaining only
those within a bounding hexagon. Detectors are re-labelled according to
<code>ID</code> as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
     ID </td><td style="text-align: left;"> Effect </td>
</tr>
<tr>
 <td style="text-align: left;">
     NULL </td><td style="text-align: left;"> no change </td>
</tr>
<tr>
 <td style="text-align: left;">
     num </td><td style="text-align: left;"> numeric sequence </td>
</tr>
<tr>
 <td style="text-align: left;">
     alpha </td><td style="text-align: left;"> letter for`shell'; number within shell </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class <code>traps</code> comprising a data frame of x- and
y-coordinates, the detector type (&quot;single&quot;, &quot;multi&quot;, or &quot;proximity&quot; etc.),
and possibly other attributes.
</p>


<h3>Note</h3>

<p> Several methods are provided for manipulating detector arrays - see <code><a href="#topic+traps">traps</a></code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+make.grid">make.grid</a></code>, <code><a href="#topic+detector">detector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tri.grid &lt;- make.tri(spacing = 10)
plot(tri.grid, border = 5)

hex &lt;- clip.hex(tri.grid, side = 30, ID = "alpha")
plot (hex, add = TRUE, detpar = list(pch = 16, cex = 1.4),
    label = TRUE, offset = 2.5 )

</code></pre>

<hr>
<h2 id='makeStart'>
Initial Parameter Values
</h2><span id='topic+makeStart'></span>

<h3>Description</h3>

<p><code>makeStart()</code> wraps the code previously internal to <code>secr.fit()</code>. 
It will not usually be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
makeStart(start = NULL, parindx, capthist, mask, detectfn, link, 
    details = NULL, fixed = NULL, CL = FALSE, anypoly = FALSE, 
    anytrans = FALSE, alltelem = FALSE, sighting = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeStart_+3A_start">start</code></td>
<td>
<p>optional starting values as described for <code><a href="#topic+secr.fit">secr.fit</a></code></p>
</td></tr>
<tr><td><code id="makeStart_+3A_parindx">parindx</code></td>
<td>
<p>list with one component per real parameter giving corresponding indices of coefficients (beta parameters) </p>
</td></tr>
<tr><td><code id="makeStart_+3A_capthist">capthist</code></td>
<td>
 <p><code><a href="#topic+capthist">capthist</a></code> object including capture data and detector (trap) layout </p>
</td></tr>
<tr><td><code id="makeStart_+3A_mask">mask</code></td>
<td>
 <p><code><a href="#topic+mask">mask</a></code> object or (for a multi-session analysis) a list of <code>mask</code> objects, one for each session</p>
</td></tr>
<tr><td><code id="makeStart_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function 0 = halfnormal, 1 = hazard rate etc. &ndash; see
<a href="#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="makeStart_+3A_link">link</code></td>
<td>
<p>list of link function names (&quot;log&quot;, &quot;logit&quot;, &quot;identity&quot;) for each real parameter </p>
</td></tr>
<tr><td><code id="makeStart_+3A_details">details</code></td>
<td>
<p>list of additional arguments (see <code><a href="#topic+secr.fit">secr.fit</a></code>)</p>
</td></tr>
<tr><td><code id="makeStart_+3A_fixed">fixed</code></td>
<td>
<p>list with optional components corresponding to real parameters giving the 
scalar value to which the parameter is to be fixed </p>
</td></tr>
<tr><td><code id="makeStart_+3A_cl">CL</code></td>
<td>
<p>logical, if true then model does not include density </p>
</td></tr>
<tr><td><code id="makeStart_+3A_anypoly">anypoly</code></td>
<td>
<p>logical, TRUE if any polygon detectors</p>
</td></tr>
<tr><td><code id="makeStart_+3A_anytrans">anytrans</code></td>
<td>
<p>logical, TRUE if any transect detectors</p>
</td></tr>
<tr><td><code id="makeStart_+3A_alltelem">alltelem</code></td>
<td>
<p>logical, TRUE if any telemetry detectors</p>
</td></tr>
<tr><td><code id="makeStart_+3A_sighting">sighting</code></td>
<td>
<p>logical, TRUE if any sighting data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If &lsquo;start&rsquo; is a previously fitted model then only &lsquo;start&rsquo; and &lsquo;parindx&rsquo; are required.
</p>


<h3>Value</h3>

<p>Numeric vector with one value for each coefficient (beta parameter) in model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr.fit">secr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
makeStart(secrdemo.0, list(D = 1, g0 = 2:3, sigma = 4))

</code></pre>

<hr>
<h2 id='mask'> Mask Object </h2><span id='topic+mask'></span><span id='topic+mask-class'></span>

<h3>Description</h3>

<p>Encapsulate a habitat mask for spatially explicit capture&ndash;recapture. See also <a href="https://www.otago.ac.nz/density/pdfs/secr-habitatmasks.pdf">secr-habitatmasks.pdf</a>.
</p>


<h3>Details</h3>

<p>A habitat mask serves four main purposes in spatially explicit
capture&ndash;recapture. Firstly, it defines an outer limit to the area of
integration; habitat beyond the mask may be occupied, but animals there
should have negligible chance of being detected (see <code><a href="#topic+pdot">pdot</a></code>
and below). Secondly, it distinguishes sites in the vicinity of the
detector array that are &lsquo;habitat&rsquo; (i.e. have the potential to be
occupied) from &lsquo;non-habitat&rsquo;. Thirdly, it discretizes continuous habitat
as a list of points. Each point is notionally associated with a cell
(pixel) of uniform density. Discretization allows the SECR likelihood to
be evaluated by summing over grid cells. Fourthly, the x-y coordinates
of the mask and any habitat covariates may be used to build spatial
models of density. For example, a continuous or categorical habitat
covariate &lsquo;cover&rsquo; measured at each point on the mask might be used in a
formula for density such as D <code class="reqn">\sim</code>cover.
</p>
<p>In relation to the first purpose, the definition of &lsquo;negligible&rsquo; is
fluid. Any probability less than 0.001 seems OK in the sense of not
causing noticeable bias in density estimates, but this depends on the
shape of the detection function (fat-tailed functions such as 'hazard
rate' are problematic). New tools for evaluating masks appeared in
<span class="pkg">secr</span> 1.5 (<code><a href="#topic+mask.check">mask.check</a></code>, <code><a href="#topic+esa.plot">esa.plot</a></code>), and
<code><a href="#topic+suggest.buffer">suggest.buffer</a></code> automates selection of a buffer width.
</p>
<p>Mask points are stored in a data frame with columns &lsquo;x&rsquo; and &lsquo;y&rsquo;. The
number of rows equals the number of points.
</p>
<p>Possible mask attributes
</p>

<table>
<tr>
 <td style="text-align: left;">
Attribute </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
type </td><td style="text-align: left;"> `traprect', `trapbuffer', `pdot', `polygon', `clusterrect', `clusterbuffer' (see make.mask) or `user' </td>
</tr>
<tr>
 <td style="text-align: left;">
polygon </td><td style="text-align: left;"> vertices of polygon defining habitat boundary, for type = `polygon' </td>
</tr>
<tr>
 <td style="text-align: left;">
pdotmin </td><td style="text-align: left;"> threshold of p.(X) for type = `pdot' </td>
</tr>
<tr>
 <td style="text-align: left;">
covariates </td><td style="text-align: left;"> dataframe of site-specific covariates </td>
</tr>
<tr>
 <td style="text-align: left;">
meanSD </td><td style="text-align: left;"> data frame with centroid (mean and SD) of x and y coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
area </td><td style="text-align: left;"> area (ha) of the grid cell associated with each point </td>
</tr>
<tr>
 <td style="text-align: left;">
spacing </td><td style="text-align: left;"> nominal spacing (metres) between adjacent points </td>
</tr>
<tr>
 <td style="text-align: left;">
boundingbox </td><td style="text-align: left;"> data frame of 4 rows, the vertices of the bounding box of all grid cells in the mask </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Attributes other than <code>covariates</code> are generated automatically by
<code>make.mask</code>. Type &lsquo;user&rsquo; refers to masks input from a text file
with <code>read.mask</code>.
</p>
<p>A virtual S4 class &lsquo;mask&rsquo; is defined to allow the definition of a method
for the generic function <code>raster</code> from the <span class="pkg">raster</span> package.
</p>


<h3>Note</h3>

<p> A habitat mask is needed by <code>secr.fit</code>, but one will be
generated automatically if none is provided. You should be aware of this
and check that the default settings (e.g. <code>buffer</code>) are
appropriate.  </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+read.mask">read.mask</a></code>,
<code><a href="#topic+mask.check">mask.check</a></code>, <code><a href="#topic+esa.plot">esa.plot</a></code>,
<code><a href="#topic+suggest.buffer">suggest.buffer</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>
</p>

<hr>
<h2 id='mask.check'>
Mask Diagnostics
</h2><span id='topic+mask.check'></span>

<h3>Description</h3>

<p><code>mask.check</code> evaluates the effect of varying buffer width and
mask spacing on either the likelihood or density estimates from
secr.fit().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask.check(object, buffers = NULL, spacings = NULL, poly = NULL,
    LLonly = TRUE, realpar = NULL, session = 1, file = NULL,
    drop = "", tracelevel = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask.check_+3A_object">object</code></td>
<td>
<p>object of class &lsquo;capthist&rsquo; or &lsquo;secr&rsquo;</p>
</td></tr>
<tr><td><code id="mask.check_+3A_buffers">buffers</code></td>
<td>
<p>vector of buffer widths</p>
</td></tr>
<tr><td><code id="mask.check_+3A_spacings">spacings</code></td>
<td>
<p>vector of mask spacings</p>
</td></tr>
<tr><td><code id="mask.check_+3A_poly">poly</code></td>
<td>
<p> matrix of two columns, the x- and  y-coordinates of a bounding polygon (optional) </p>
</td></tr>
<tr><td><code id="mask.check_+3A_llonly">LLonly</code></td>
<td>
<p>logical; if TRUE then only the log likelihood is
computed</p>
</td></tr>
<tr><td><code id="mask.check_+3A_realpar">realpar</code></td>
<td>
<p>list of parameter values</p>
</td></tr>
<tr><td><code id="mask.check_+3A_session">session</code></td>
<td>
<p>vector of session indices (used if <code>object</code> spans multiple sessions)</p>
</td></tr>
<tr><td><code id="mask.check_+3A_file">file</code></td>
<td>
<p>name of output file (optional)</p>
</td></tr>
<tr><td><code id="mask.check_+3A_drop">drop</code></td>
<td>
<p>character vector: names of fitted secr object to omit</p>
</td></tr>
<tr><td><code id="mask.check_+3A_tracelevel">tracelevel</code></td>
<td>
<p>integer for level of detail in reporting (0,1,2)</p>
</td></tr>
<tr><td><code id="mask.check_+3A_...">...</code></td>
<td>
<p>other arguments passed to secr.fit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Masks of varying buffer width and spacing are constructed with the
&lsquo;trapbuffer&rsquo; method in <code>make.mask</code>, using the detector locations
(&lsquo;traps&rsquo;) from either a capthist object or a previous execution of
<code>secr.fit</code>. Default values are provided for <code>buffers</code> and
<code>spacings</code> if <code>object</code> is of class &lsquo;secr&rsquo; (respectively c(1,
1.5, 2) and c(1, 0.75, 0.5) times the values in the existing
mask). The default for <code>buffers</code> will not work if a detector is
on the mask boundary, as the inferred buffer is then 0.
</p>
<p>Variation in the mask may be assessed for its effect on &ndash;
</p>
   
<ul>
<li><p> the log-likelihood evaluated for given values of the
parameters (<code>LLonly = TRUE</code>)
</p>
</li>
<li><p> estimates from maximizing the likelihood with each mask
(<code>LLonly = FALSE</code>)      
</p>
</li></ul>
      
<p><code>realpar</code> should be a list with one named component for each real
parameter (see Examples). It is relevant only if <code>LLonly =
  TRUE</code>. <code>realpar</code> may be omitted if <code>object</code> is of class
&lsquo;secr&rsquo;; parameter values are then extracted from <code>object</code>.
</p>
<p><code>session</code> should be an integer or character vector suitable for
indexing sessions in <code>object</code>, or in <code>object$capthist</code> if
<code>object</code> is a fitted model. Each session is considered
separately; a model formula that refers to session or uses session
covariates will cause an error.
</p>
<p>If <code>file</code> is specified then detailed
results (including each model fit when <code>LLonly = FALSE</code>) are
saved to an external .RData file. Loading this file creates or
overwrites object(s) in the workspace: <code>mask.check.output</code> if
<code>LLonly = TRUE</code>, otherwise <code>mask.check.output</code> and
<code>mask.check.fit</code>. For multiple sessions these are replaced by
lists with one component per session (<code>mask.check.outputs</code> and
<code>mask.check.fits</code>). The <code>drop</code> argument is passed to
<code><a href="#topic+trim">trim</a></code> and applied to each fitted model; use it to save
space, at the risk of limiting further computation on the fitted
models.
</p>
<p><code>tracelevel&gt;0</code> causes more verbose reporting of progress during
execution.
</p>
<p>The ... argument may be used to override existing settings in
<code>object</code> - for example, a conditional likelihood fit (<code>CL =
  T</code>) may be selected even if the original model was fitted by
maximizing the full likelihood.
</p>


<h3>Value</h3>

<p>Array of log-likelihoods (<code>LLonly = TRUE</code>) or estimates
(<code>LLonly = FALSE</code>) for each combination of <code>buffers</code> and
<code>spacings</code>. The array has 3 dimensions if <code>LLonly = FALSE</code>
and both <code>buffers</code> and <code>spacings</code> have multiple levels;
otherwise it collapses to a matrix. Rows generally represent
<code>buffers</code>, but rows represent <code>spacings</code> if a single buffer
is specified.
</p>


<h3>Warning</h3>

<p><code>mask.check()</code> may fail if <code>object</code> is a fitted &lsquo;secr&rsquo; model
and a data object named in the original call of <code>secr.fit()</code>
(i.e. <code>object$call</code>) is no longer in the working environment
(<code>secr.fit</code> arguments capthist, mask, verify &amp; trace are
exempt). Fix by any of (1) applying <code>mask.check</code> directly to the
&lsquo;capthist&rsquo; object, specifying other arguments (<code>buffers</code>,
<code>spacings</code>, <code>realpar</code>) as needed, (2) re-fitting the model
and running <code>mask.check</code> in the same environment, (3) specifying
the offending argument(s) in ..., or (4) re-creating the required
data objects(s) in the working environment, possibly from saved inputs
in <code>object</code> (e.g., <code>mytimecov &lt;- myfit$timecov</code>).
</p>


<h3>Note</h3>

<p>When <code>LLonly = TRUE</code> the functionality of <code>mask.check</code>
resembles that of the &lsquo;Tools | ML SECR log likelihood&rsquo; menu option in
Density 5. The help page in Density 5 for ML SECR 2-D integration (see
index) may be helpful.
</p>
<p>Warning messages from <code>secr.fit</code> are suppressed. &lsquo;capthist&rsquo;
data provided via the <code>object</code> argument are checked with
<code><a href="#topic+verify.capthist">verify.capthist</a></code> if <code>tracelevel &gt; 0</code>.
</p>
<p>The likelihood-only method is fast, but not definitive. It is
reasonable to aim for stability in the third decimal place of the log
likelihood. Slight additional variation in the likelihood may cause
little change in the estimates; the only way to be sure is to check
these by setting <code>LLonly = FALSE</code>.
</p>
<p>The performance of a mask depends on the detection function; be sure
to set the <code>detectfn</code> argument appropriately. The hazard rate
function has a fat tail that can be problematic.
</p>
<p>When provided with an &lsquo;secr&rsquo; <code>object</code>, <code>mask.check</code>
constructs a default vector of buffer widths as multiples of the
buffer used in <code>object</code> <em>even though that value is not saved
explicitly</em>. For this trick, detector locations in
<code>traps(object$capthist)</code> are compared to the bounding box of
<code>object$mask</code>; the base level of buffer width is the maximum
possible within the bounding box.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esa.plot">esa.plot</a></code>, <code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## from a capthist object, specifying almost everything
mask.check (possumCH, spacings = c(20, 30), buffers =c(200, 300),
    realpar = list(g0 = 0.2, sigma = 50), CL = TRUE)

## from a fitted model, using defaults
mask.check (stoat.model.HN)
## LL did not change with varying buffer (rows) or spacing (cols):
##         78.125  58.59375   39.0625
## 1000 -144.0015 -144.0015 -144.0015
## 1500 -144.0017 -144.0017 -144.0017
## 2000 -144.0017 -144.0017 -144.0017

## fit new models for each combination of buffer &amp; spacing,
## and save fitted models to a file
mask.check (stoat.model.HN, buffers = 1500, spacings =
    c(40,60,80), LLonly = FALSE, file = "test", CL = TRUE)

## look in more detail at the preceding fits
## restores objects `mask.check.output' and `mask.check.fit'
load("test.RData")  
lapply(mask.check.fit, predict)
lapply(mask.check.fit, derived)

## multi-session data
mask.check(ovenbird.model.1, session = c("2005","2009"))

## clipping mask
txtfilename &lt;- system.file("extdata/possumarea.txt", package = "secr")
possumarea &lt;- read.table(txtfilename, header = TRUE)
mask.check (possum.model.0, spacings = c(20, 30), buffers =
    c(200, 300), poly = possumarea, LLonly = FALSE,
    file = "temp", CL = TRUE)

## review fitted models
load ("temp.RData")
par(mfrow = c(2,2), mar = c(1,4,4,4))
for (i in 1:4) {
    plot(traps(mask.check.fit[[i]]$capthist), border = 300,
        gridlines = FALSE)
    plot(mask.check.fit[[i]]$mask, add = TRUE)
    lines(possumarea)
    text ( 2698618, 6078427, names(mask.check.fit)[i])
    box()
}
par(mfrow = c(1,1), mar = c(5,4,4,2) + 0.1)    ## defaults


## End(Not run)

</code></pre>

<hr>
<h2 id='modelAverage'> Averaging of SECR Models Using Akaike's Information Criterion</h2><span id='topic+modelAverage'></span><span id='topic+modelAverage.secr'></span><span id='topic+modelAverage.secrlist'></span>

<h3>Description</h3>

<p>AIC- or AICc-weighted average of estimated &lsquo;real&rsquo; or &lsquo;beta&rsquo; parameters
from multiple fitted secr models, and the tabulation of estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secr'
modelAverage(object, ..., realnames = NULL, betanames = NULL, newdata = NULL, 
    alpha = 0.05, dmax = 10, covar = FALSE, average = c("link", "real"),
    criterion = c("AICc","AIC"), CImethod = c("Wald", "MATA"), chat = NULL)

## S3 method for class 'secrlist'
modelAverage(object, ..., realnames = NULL, betanames = NULL, newdata = NULL, 
    alpha = 0.05, dmax = 10, covar = FALSE, average = c("link", "real"),
    criterion = c("AICc","AIC"), CImethod = c("Wald", "MATA"), chat = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelAverage_+3A_object">object</code></td>
<td>
<p>secr or secrlist object</p>
</td></tr>
<tr><td><code id="modelAverage_+3A_...">...</code></td>
<td>
<p>other secr objects </p>
</td></tr> 
<tr><td><code id="modelAverage_+3A_realnames">realnames</code></td>
<td>
<p> character vector of real parameter names </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_betanames">betanames</code></td>
<td>
<p> character vector of beta parameter names </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate models </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_dmax">dmax</code></td>
<td>
<p> numeric, the maximum AIC or AICc difference for inclusion in confidence set </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_covar">covar</code></td>
<td>
<p> logical, if TRUE then return variance-covariance matrix </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_average">average</code></td>
<td>
<p> character string for scale on which to average real
parameters </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_criterion">criterion</code></td>
<td>
<p> character, information criterion to use for model weights</p>
</td></tr>  
<tr><td><code id="modelAverage_+3A_cimethod">CImethod</code></td>
<td>
<p> character, type of confidence interval (see Details)</p>
</td></tr>
<tr><td><code id="modelAverage_+3A_chat">chat</code></td>
<td>
<p>numeric optional variance inflation factor for quasi-AIC weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models to be compared must have been fitted to the same data and use the
same likelihood method (full vs conditional). If <code>realnames</code> =
NULL and <code>betanames</code> = NULL then all real parameters will be
averaged; in this case all models must use the same real parameters. To
average beta parameters, specify <code>betanames</code> (this is ignored if a
value is provided for <code>realnames</code>). See <code><a href="#topic+predict.secr">predict.secr</a></code>
for an explanation of the optional argument <code>newdata</code>;
<code>newdata</code> is ignored when averaging beta parameters. 
</p>
<p>Model-averaged estimates for parameter <code class="reqn">\theta</code> are given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta} = \sum\limits _k w_k \hat{\theta}_k</code>
</p>
<p> where the subscript <code class="reqn">k</code> refers to a specific
model and the <code class="reqn">w_k</code> are AIC or AICc weights (see
<code><a href="#topic+AIC.secr">AIC.secr</a></code> for details). Averaging of real parameters may be
done on the link scale before back-transformation
(<code>average="link"</code>) or after back-transformation
(<code>average="real"</code>).
</p>
<p>Models for which dAIC &gt; <code>dmax</code> (or dAICc &gt; <code>dmax</code>) are given a
weight of zero and effectively are excluded from averaging.
</p>
<p>Also, </p>
<p style="text-align: center;"><code class="reqn">\mbox{var} (\hat{\theta}) = \sum\limits _{k} { w_{k}
( \mbox{var}(\hat{\theta}_{k} | \beta _k) + \beta _k ^2)}
</code>
</p>

<p>where <code class="reqn">\hat{\beta} _k = \hat{\theta}_k - \hat{\theta}</code> and the variances are asymptotic estimates
from fitting each model <code class="reqn">k</code>. This follows Burnham and Anderson
(2004) rather than Buckland et al. (1997).
</p>
<p>Two methods are offered for confidence intervals. The default &lsquo;Wald&rsquo;
uses the above estimate of variance. The alternative &lsquo;MATA&rsquo;
(model-averaged tail area) avoids estimating a weighted variance and
is thought to provide better coverage at little cost in increased
interval length (Turek and Fletcher 2012). Turek and Fletcher (2012)
also found averaging with AIC weights (here <code>criterion = 'AIC'</code>)
preferable to using AICc weights, even for small
samples. <code>CImethod</code> does not affect the reported standard errors.
</p>
<p>If 'chat' is provided then quasi-AIC or quasi-AICc weights are used, 
depending on the value of 'criterion'.
</p>


<h3>Value</h3>

<p>For <code>modelAverage</code>, an array of model-averaged estimates, their
standard errors, and a <code class="reqn">100(1-\alpha)</code>% confidence
interval. The interval for real parameters is backtransformed from the
link scale. If there is only one row in <code>newdata</code> or beta
parameters are averaged or averaging is requested for only one parameter
then the array is collapsed to a matrix. If <code>covar = TRUE</code> then a
list is returned with separate components for the estimates and the
variance-covariance matrices.
</p>


<h3>Note</h3>

<p><code>modelAverage</code> replaces the deprecated function <code>model.average</code> 
whose name conflicted with a method in <span class="pkg">RMark</span>.</p>


<h3>References</h3>

 
<p>Buckland S. T., Burnham K. P. and Augustin, N. H. (1997) Model
selection: an integral part of inference. <em>Biometrics</em> <b>53</b>,
603&ndash;618.
</p>
<p>Burnham, K. P. and Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: A Practical Information-Theoretic Approach</em>.
Second edition. New York: Springer-Verlag.
</p>
<p>Burnham, K. P. and Anderson, D. R. (2004) Multimodel inference -
understanding AIC and BIC in model selection. <em>Sociological Methods
&amp; Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Turek, D. and Fletcher, D. (2012) Model-averaged Wald confidence
intervals. <em>Computational statistics and data analysis</em> <b>56</b>,
2809&ndash;2815.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+modelAverage">modelAverage</a></code>, 
<code><a href="#topic+AIC.secr">AIC.secr</a></code>, 
<code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+collate">collate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare two models fitted previously
## secrdemo.0 is a null model
## secrdemo.b has a learned trap response

modelAverage(secrdemo.0, secrdemo.b)
modelAverage(secrdemo.0, secrdemo.b, betanames = c("D","g0","sigma"))

## In this case we find the difference was actually trivial...
## (subscripting of output is equivalent to setting fields = 1)

</code></pre>

<hr>
<h2 id='ms'>
Multi-session Objects
</h2><span id='topic+ms'></span><span id='topic+ms.default'></span><span id='topic+ms.mask'></span><span id='topic+ms.secr'></span>

<h3>Description</h3>

<p>Logical function to distinguish objects that span multiple sessions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## Default S3 method:
ms(object, ...)
  ## S3 method for class 'mask'
ms(object, ...)
  ## S3 method for class 'secr'
ms(object, ...)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms_+3A_object">object</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="ms_+3A_...">...</code></td>
<td>
<p>other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test applied varies with the type of object. The default method uses
<code>inherits(object, "list")</code>.
</p>


<h3>Value</h3>

<p>logical, TRUE if <code>object</code> contains data for multiple sessions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ms(ovenCH)
ms(ovenbird.model.1)
ms(ovenCH[[1]])
</code></pre>

<hr>
<h2 id='newdata'>
Create Default Design Data
</h2><span id='topic+newdata'></span><span id='topic+makeNewData'></span><span id='topic+makeNewData.secr'></span><span id='topic+makeNewData.default'></span>

<h3>Description</h3>

<p>Internal function used to generate a dataframe containing design data
for the base levels of all predictors in an secr object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
makeNewData(object, all.levels = FALSE, ...)
## S3 method for class 'secr'
makeNewData(object, all.levels = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newdata_+3A_object">object</code></td>
<td>
<p>fitted secr model object</p>
</td></tr>
<tr><td><code id="newdata_+3A_all.levels">all.levels</code></td>
<td>
<p>logical; if TRUE then all levels of factors are included</p>
</td></tr>
<tr><td><code id="newdata_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>makeNewData</code> is used by <code>predict</code> in lieu of
user-specified &lsquo;newdata&rsquo;. There is seldom any need to call the function 
<code>makeNewData</code> directly.
</p>


<h3>Value</h3>

<p>A dataframe with one row for each session and group, and columns for the
predictors used by <code>object$model</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.secr">predict.secr</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## from previously fitted model
makeNewData(secrdemo.b)

</code></pre>

<hr>
<h2 id='nontarget'> Non-target Data </h2><span id='topic+nontarget'></span><span id='topic+nontarget+3C-'></span><span id='topic+interference'></span>

<h3>Description</h3>

<p>Non-target detections and interference events may be recorded in a binary detector 
x occasion matrix attached as an attribute to a single-session capthist object, 
or to each component of a multi-session capthist object. 
</p>
<p>Models fitted by <span class="pkg">secr</span> make no use of these data. They may be used in <span class="pkg">ipsecr</span>.
</p>
<p>From <span class="pkg">secr</span> 4.5.6, a summary of nontarget data is reported by the 
<code><a href="base.html#topic+summary">summary</a></code> method for capthist objects, and the <code><a href="#topic+verify">verify</a></code> 
method reports clashes between detections and nontarget data.
</p>
<p>Extraction and replacement funcions are provided from <span class="pkg">secr</span> 4.5.7 on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
nontarget(object, ...)
nontarget(object) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nontarget_+3A_object">object</code></td>
<td>
<p>capthist object</p>
</td></tr>
<tr><td><code id="nontarget_+3A_...">...</code></td>
<td>
<p>other argments (not used)</p>
</td></tr>
<tr><td><code id="nontarget_+3A_value">value</code></td>
<td>
<p> numeric binary matrix (rows = detectors, columns = occasions) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of rows should match the order of detectors in <code>traps(object)</code>. 
Matrix entries should be zero for trap x occasion combinations that were not used 
(see <a href="#topic+usage">usage</a>) or for which there is a corresponding detection.
</p>
<p><code>value</code> is coerced to a matrix before assignment.
</p>


<h3>Value</h3>

<p>For <code>nontarget()</code>, a matrix or list of matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.capthist">plot.capthist</a></code>, <code><a href="#topic+summary.capthist">summary.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
ch &lt;- captdata

# traps that caught something
caught &lt;- t(apply(ch, 2:3, sum))

# construct artificial nontarget data
# (positive for half the traps that caught nothing)
nontarget(ch) &lt;- (1-caught) * (runif(500)&gt;0.5)

head(caught)
head(nontarget(ch))

# the summary method recognises the 'nontarget' attribute
summary(ch)$nontarget

</code></pre>

<hr>
<h2 id='occasionKey'>Key to Petal Plot</h2><span id='topic+occasionKey'></span>

<h3>Description</h3>

<p>Displays a graphic key to the occasions corresponding to
petals in a petal plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>occasionKey(capthist, noccasions, rad = 3, x, y, px = 0.9, py = 0.9, 
                         title = 'Occasion', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occasionKey_+3A_capthist">capthist</code></td>
<td>
<p>single-session capthist object</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_noccasions">noccasions</code></td>
<td>
<p>number of petals (if <code>capthist</code> not provided)</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_rad">rad</code></td>
<td>
<p>distance of petal centre from key centre</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_x">x</code></td>
<td>
<p>numeric x coordinate for centre of key</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_y">y</code></td>
<td>
<p>numeric y coordinate for centre of key</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_px">px</code></td>
<td>
<p>x position as fraction of user coordinates</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_py">py</code></td>
<td>
<p>y position as fraction of user coordinates</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_title">title</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="occasionKey_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+text">text</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>capthist</code> or <code>noccasions</code> is required. It is assumed that a plot exists.
</p>
<p>Graphic arguments in ... are applied to both the title and the occasion numbers.
</p>


<h3>Value</h3>

<p>The key will be added to an existing plot. No value is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.capthist">plot.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(captdata, border = 50)
occasionKey(captdata, rad = 8, cex = 0.8)

</code></pre>

<hr>
<h2 id='ovenbird'> Ovenbird Mist-netting Dataset </h2><span id='topic+ovenbird'></span><span id='topic+ovenCH'></span><span id='topic+ovenCHp'></span><span id='topic+ovenbird.model.1'></span><span id='topic+ovenbird.model.D'></span><span id='topic+ovenmask'></span>

<h3>Description</h3>

<p>Data from a multi-year mist-netting study of ovenbirds (<em>Seiurus
aurocapilla</em>) at a site in Maryland, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ovenCH
ovenCHp
ovenbird.model.1
ovenbird.model.D
ovenmask

</code></pre>


<h3>Details</h3>

<p>From 2005 to 2009 D. K. Dawson and M. G. Efford conducted a
capture&ndash;recapture survey of breeding birds in deciduous forest at the
Patuxent Research Refuge near Laurel, Maryland, USA.  The forest was
described by Stamm, Davis &amp; Robbins (1960), and has changed little
since.  Analyses of data from previous mist-netting at the site by Chan
Robbins were described in Efford, Dawson &amp; Robbins (2004) and Borchers &amp;
Efford (2008).
</p>
<p>Forty-four mist nets (12 m long, 30-mm mesh) spaced 30 m apart on the
perimeter of a 600-m x 100-m rectangle were operated for approximately 9
hours on each of 9 or 10 non-consecutive days during late May and June
in each year.  Netting was passive (i.e. song playback was not used to
lure birds into the nets).  Birds received individually numbered bands,
and both newly banded and previously banded birds were released at the
net where captured.  Sex was determined in the hand from the presence of
a brood patch (females) or cloacal protuberance (males).  A small amount
of extra netting was done by other researchers after the main session in
some years.
</p>
<p>This dataset comprises all records of adult (after-hatch-year) ovenbirds
caught during the main session in each of the five years 2005&ndash;2009.  One
ovenbird was killed by a predator in the net in 2009, as indicated by a
negative net number in the dataset.  Sex was determined in the hand from
the presence of a brood patch (females) or cloacal protuberance (males).
Birds are listed by their band number (4-digit prefix, &lsquo;.&rsquo;, and 5-digit
number).  
</p>
<p>The data are provided as a multi-session <code>capthist</code> object
&lsquo;ovenCHp&rsquo;.  Sex is coded as a categorical individual covariate (&quot;M&quot;
or &quot;F&quot;).
</p>
<p>Recaptures at the same site within a day are not included in this dataset, 
so <code>ovenCHp</code> has detector type &lsquo;proximity&rsquo;. Previous versions of <span class="pkg">secr</span>
provided only a trimmed version of these data, retaining only one capture 
per bird per day (<code>ovenCH</code> with detector type &lsquo;multi&rsquo;). That may be 
obtained from <code>ovenCHp</code> as shown in the examples.
</p>
<p>Although several individuals were captured in
more than one year, no use is made of this information in the analyses
presently offered in <span class="pkg">secr</span>.
</p>
<p>An analysis of the data for males in the first four years showed that
they tended to avoid nets after their first capture within a season
(Dawson &amp; Efford 2009).  While the species was present consistently,
the number of detections in any one year was too small to give reliable
estimates of density; pooling of detection parameters across years
helped to improve precision.
</p>
<p>Included with the data are a mask and two models fitted to <code>ovenCH</code> as in
Examples. 
</p>

<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
  ovenCH </td><td style="text-align: left;"> multi-session capthist object (as multi-catch) </td>
</tr>
<tr>
 <td style="text-align: left;">
  ovenCHp </td><td style="text-align: left;"> multi-session capthist object (as binary proximity) </td>
</tr>
<tr>
 <td style="text-align: left;">
  ovenbird.model.1 </td><td style="text-align: left;"> fitted secr model -- null </td>
</tr>
<tr>
 <td style="text-align: left;">
  ovenbird.model.D </td><td style="text-align: left;"> fitted secr model -- trend in density across years
  </td>
</tr>
<tr>
 <td style="text-align: left;">
  ovenmask </td><td style="text-align: left;"> mask object </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>D. K. Dawson (<a href="mailto:ddawson@usgs.gov">ddawson@usgs.gov</a>) and M. G. Efford unpublished data.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture-recapture studies. <em>Biometrics</em> <b>64</b>,
377&ndash;385.
</p>
<p>Dawson, D. K. and Efford, M. G. (2009) Bird population density estimated from
acoustic signals. <em>Journal of Applied Ecology</em> <b>46</b>, 1201&ndash;1209.
</p>
<p>Efford, M. G., Dawson, D. K. and Robbins C. S. (2004) DENSITY: software
for analysing capture-recapture data from passive detector arrays.
<em>Animal Biodiversity and Conservation</em> <b>27</b>, 217&ndash;228.
</p>
<p>Stamm, D. D., Davis, D. E. and Robbins, C. S. (1960) A method of studying
wild bird populations by mist-netting and banding. <em>Bird-Banding</em> <b>31</b>,
115&ndash;130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## commands used to create ovenCH from the input files
## "netsites0509.txt" and "ovencapt.txt"
## for information only - these files not distributed

# netsites0509 &lt;- read.traps(file = "netsites0509.txt",
#    skip = 1, detector = "proximity")
# temp &lt;- read.table("ovencapt.txt", colClasses=c("character",
#     "character", "numeric", "numeric", "character"))
# ovenCHp &lt;- make.capthist(temp, netsites0509, covnames = "Sex")
# ovenCHp &lt;- reduce(ovenCHp, dropunused = FALSE) # drop repeat detections

par(mfrow = c(1,5), mar = c(1,1,4,1))
plot(ovenCHp, tracks = TRUE, varycol = TRUE)
par(mfrow = c(1,1), mar = c(5,4,4,2) + 0.1)  ## defaults

counts(ovenCHp, "n")

## Not run: 

## trimmed version of data - for consistency with earlier versions

ovenCH &lt;- reduce(ovenCHp, outputdetector = "multi", dropunused = FALSE)

## array constant over years, so build mask only once
ovenmask &lt;- make.mask(traps(ovenCH)[["2005"]], type = "pdot", 
    buffer = 400, spacing = 15, detectpar = list(g0 = 0.03, 
    sigma = 90), nocc = 10)

## fit constant-density model
ovenbird.model.1 &lt;- secr.fit(ovenCH, mask = ovenmask)

## fit temporal trend in density (Session capitalized)
ovenbird.model.D &lt;- secr.fit(ovenCH, mask = ovenmask, 
    model = list(D ~ Session))

## compare pre-fitted models
AIC(ovenbird.model.1, ovenbird.model.D)


## End(Not run)


</code></pre>

<hr>
<h2 id='ovensong'> Ovenbird Acoustic Dataset </h2><span id='topic+ovensong'></span><span id='topic+signalCH'></span><span id='topic+ovensong.model.1'></span><span id='topic+ovensong.model.2'></span>

<h3>Description</h3>

<p>Data from an acoustic survey of ovenbirds (<em>Seiurus
aurocapilla</em>) at a site in Maryland, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
signalCH
ovensong.model.1
ovensong.model.2

</code></pre>


<h3>Details</h3>

<p>In June 2007 D. K. Dawson and M. G. Efford used a moving 4-microphone array
to survey breeding birds in deciduous forest at the Patuxent Research
Refuge near Laurel, Maryland, USA. The data for ovenbirds were used to
demonstrate a new method for analysing acoustic data (Dawson and Efford
2009). See <code><a href="#topic+ovenbird">ovenbird</a></code> for mist-netting data from the same
site over 2005&ndash;2009, and for other background.
</p>
<p>Over five days, four microphones were placed in a square (21-m side)
centred at each of 75 points in a rectangular grid (spacing 50 m); on
each day points 100 m apart were sampled sequentially. Recordings of 5
minutes duration were made in .wav format on a 4-channel digital sound
recorder.
</p>
<p>The data are estimates of average power on each channel (microphone) for
the first song of each ovenbird distinguishable in a particular 5-minute
recording. Power was estimated with the sound analysis software Raven
Pro 1.4 (Charif et al. 2008), using a window of 0.7 s duration and
frequencies between 4200 and 5200 Hz, placed manually at the approximate
centre of each ovenbird song. Sometimes this frequency range was
obscured by insect noise so an alternative 1000-Hz range was measured
and the values were adjusted by regression.
</p>
<p>The data are provided as a single-session, single-occasion
<code>capthist</code> object <code>signalCH</code>. The &lsquo;signal&rsquo; attribute contains
the power measurement in decibels for each detected sound on each
channel where the power threshold is exceeded. As the threshold signal
(attribute <code>cutval</code> = 35) is less than any signal value in this
dataset, all detection histories are complete (1,1,1,1) across
microphones. For analysis Dawson and Efford applied a higher threshold
that treated weaker signals as &lsquo;not detected&rsquo; (see Examples).
</p>
<p>The row names of <code>signalCH</code> (e.g. &quot;3755AX&quot;) are formed from a
4-digit number indicating the sampling location (one of 75 points on a
50-m grid) and a letter A&ndash;D to distinguish individual ovenbirds within
a 5-minute recording; &lsquo;X&rsquo; indicates power values adjusted by regression.
</p>
<p>The default model for sound attenuation is a log-linear decline with
distance from the source (linear decline on dB scale). Including a
spherical spreading term in the sound attenuation model causes the
likelihood surface to become multimodal in this case. Newton-Raphson,
the default maximization method in <code>secr.fit</code>, is particularly
inclined to settle on a local maximum; in the example below we use a set
of starting values that have been found by trial and error to yield the
global maximum.
</p>
<p>Two fitted models are included (see Examples for details).
</p>

<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
  signalCH </td><td style="text-align: left;"> capthist object </td>
</tr>
<tr>
 <td style="text-align: left;">
  ovensong.model.1 </td><td style="text-align: left;"> fitted secr model -- spherical spreading </td>
</tr>
<tr>
 <td style="text-align: left;">
  ovensong.model.2 </td><td style="text-align: left;"> fitted secr model -- no spherical spreading </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>D. K. Dawson (<a href="mailto:ddawson@usgs.gov">ddawson@usgs.gov</a>) and M. G. Efford unpublished data.
</p>


<h3>References</h3>

<p>Charif, R. A., Waack, A. M. and Strickman, L. M. (2008) Raven Pro 1.3 User's
Manual. Cornell Laboratory of Ornithology, Ithaca, New York.
</p>
<p>Dawson, D. K. and Efford, M. G. (2009) Bird population density estimated from
acoustic signals. <em>Journal of Applied Ecology</em> <b>46</b>, 1201&ndash;1209.
</p>
<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009) Population density estimated
from locations of individuals on a passive detector array. <em>Ecology</em> <b>90</b>,
2676&ndash;2682.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+ovenbird">ovenbird</a></code>, <code><a href="#topic+Detection+20functions">Detection functions</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(signalCH)
traps(signalCH)
signal(signalCH)

## apply signal threshold
signalCH.525 &lt;- subset(signalCH, cutval = 52.5)

## Not run: 

## models with and without spherical spreading
omask &lt;- make.mask(traps(signalCH), buffer = 200)
ostart &lt;- c(log(20), 80, log(0.1), log(2))
ovensong.model.1 &lt;- secr.fit( signalCH.525, mask = omask, 
    start = ostart, detectfn = 11 ) 
ovensong.model.2 &lt;- secr.fit( signalCH.525, mask = omask, 
    start = ostart, detectfn = 10 ) 


## End(Not run)

## compare fit of models
AIC(ovensong.model.1, ovensong.model.2)

## density estimates, dividing by 75 to allow for replication
collate(ovensong.model.1, ovensong.model.2)[1,,,"D"]/75

## plot attenuation curves cf Dawson &amp; Efford (2009) Fig 5
pars1 &lt;- predict(ovensong.model.1)[c("beta0", "beta1"), "estimate"]
pars2 &lt;- predict(ovensong.model.2)[c("beta0", "beta1"), "estimate"]
attenuationplot(pars1, xval=0:150, spherical = TRUE, ylim = c(40,110))
attenuationplot(pars2, xval=0:150, spherical = FALSE, add = TRUE, 
    col = "red")
## spherical spreading only
pars1[2] &lt;- 0  
attenuationplot(pars1, xval=0:150, spherical = TRUE, add = TRUE, lty=2)

</code></pre>

<hr>
<h2 id='OVpossum'>Orongorongo Valley Brushtail Possums</h2><span id='topic+OVpossum'></span><span id='topic+OVpossumCH'></span>

<h3>Description</h3>

<p>A dataset from long-term capture-recapture trapping of brushtail possums
<em>Trichosurus vulpecula</em> in New Zealand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OVpossumCH</code></pre>


<h3>Format</h3>

<p>A multi-session capthist object of 6 sessions. Sessions are labeled
49&ndash;54, corresponding to February 1996, June 1996, September 1996,
February 1997, June 1997 and September 1997.
</p>


<h3>Details</h3>

<p>Brushtail possums are 2-4 kg largely arboreal marsupials that have
become pests of forests and farmland in New Zealand since their
introduction from Australia in the nineteenth century. Their population
dynamics in mixed native forest have been studied by capture-recapture
in the Orongorongo Valley near Wellington since 1966 (e.g. Crawley 1973,
Efford 1998, Efford and Cowan 2004).
</p>
<p>From 1996 to 2006, a grid of 167 traps set on the ground at 30-m spacing
was operated in an area of about 14 ha for 5 consecutive days three
times each year (Efford and Cowan 2004). Each trap could catch only one
animal, with rare exceptions when a young &lsquo;backrider&rsquo; entered the trap
with its mother. All animals were tagged and tattooed for individual
identification and released at the site of capture.
</p>
<p>A broad shingle riverbed forms a natural boundary on two sides of the
study grid. Much of the grid lies on a gently sloping old alluvial fan
and recent terraces, but to the southeast the valley side rises steeply
and, except where cut by streams, supports beech forest
(<em>Nothofagus truncata</em> and <em>Nothofagus solandri solandri</em>)
rather than the mixed broadleaf forest of the valley floor.
</p>
<p>This dataset relates to six five-day trapping sessions in 1996 and 1997,
a time of high and declining density. Possums are long-lived (up to
about 15 years) and as adults restrict their movements to a home range
of 1-10 ha. Breeding is seasonal, resulting in an influx of newly
independent juveniles in the first trapping of each calendar year.
</p>
<p>The dataset includes individual covariates not provided by Efford (2012):
&lsquo;sex&rsquo; (F or M) and &lsquo;Ageclass&rsquo; (1 for first year, 2 for older).
</p>
<p>A coarse habitat map is provided for the immediate vicinity of the
trapping grid as the shapefile &lsquo;OVforest.shp&rsquo; in the package &lsquo;extdata&rsquo;
folder. This distinguishes two forest classes (&lsquo;beech&rsquo; and &lsquo;non-beech&rsquo;),
and leaves out the shingle riverbed. The distinction between &lsquo;beech&rsquo; and
&lsquo;non-beech&rsquo; is mapped only to a distance of about 120 m from the
outermost traps. A text file 'leftbank.txt' in the same folder contains the x- and y- coordinates of the adjoining bank of the Orongorongo River. All coordinates relate to the old New Zealand Map Grid (NZMG), since replaced by the New Zealand Transverse Mercator grid (NZTM2000).
</p>
<p>The example code shows how to import the shapefile as a <span class="pkg">sp</span>
SpatialPolygonsDataFrame object and use it to construct a mask for
<code>secr.fit</code>.
</p>


<h3>Source</h3>

<p>Efford (2012) and unpublished data.
</p>


<h3>References</h3>

<p>Crawley, M. C. (1973) A live-trapping study of Australian brush-tailed
possums, <em>Trichosurus vulpecula</em> (Kerr), in the Orongorongo
Valley, Wellington, New Zealand. <em>Australian Journal of
Zoology</em> <b>21</b>, 75&ndash;90.
</p>
<p>Efford, M. G. (1998) Demographic consequences of sex-biased dispersal in
a population of brushtail possums. <em>Journal of Animal Ecology</em>
<b>67</b>, 503&ndash;517.
</p>
<p>Efford, M. G. (2012) DENSITY 5.0: software for spatially explicit
capture-recapture. Department of Mathematics and Statistics,
University of Otago, Dunedin, New
Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>
</p>
<p>Efford, M. G. and Cowan, P. E. (2004) Long-term population trend of
<em>Trichosurus vulpecula</em> in the Orongorongo Valley, New
Zealand. In: <em>The Biology of Australian Possums and
Gliders</em>. Edited by R. L. Goldingay and S. M. Jackson. Surrey
Beatty &amp; Sons, Chipping Norton. Pp. 471&ndash;483.
</p>
<p>Ward, G. D. (1978) Habitat use and home range of radio-tagged opossums 
<em>Trichosurus vulpecula</em> (Kerr) in New Zealand lowland forest. 
In: <em>The ecology of arboreal folivores</em>. Edited by G. G. Montgomery. 
Smithsonian Institute Press. Washington, D.C. Pp. 267&ndash;287.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(sf)

summary(OVpossumCH, terse = TRUE)
ovtrap &lt;- traps(OVpossumCH[[1]])

## retrieve and plot the forest map
OVforest &lt;- st_read(system.file("extdata/OVforest.shp", package = "secr"))
OVforest &lt;- as(OVforest, "Spatial")
forestcol &lt;- terrain.colors(6)[c(4,2,2)]
sp::plot(OVforest, col = forestcol)
plot(ovtrap, add = TRUE)

## construct a mask
## we omit forest across the river by selecting only
## forest polygons 1 and 2 
ovmask &lt;- make.mask(ovtrap, buffer = 120, type = 'trapbuffer',
    poly = OVforest[1:2,], spacing = 7.5, keep.poly = FALSE)
ovmask &lt;- addCovariates(ovmask, OVforest[1:2,])

## display mask
par(mar = c(0,0,0,8))
plot(ovmask, covariate = 'forest', dots = FALSE, col = forestcol)
plot(ovtrap, add = TRUE)

## add the left bank of the Orongorongo River
lines(read.table(system.file("extdata/leftbank.txt", package = "secr")))


## End(Not run)

</code></pre>

<hr>
<h2 id='Parallel'> Multi-core Processing </h2><span id='topic+Parallel'></span><span id='topic+ncores'></span><span id='topic+Multi-core+20processing'></span>

<h3>Description</h3>

<p>From version 4.0 <span class="pkg">secr</span> uses multi-threading in C++ (package <span class="pkg">RcppParallel</span>, Allaire et al. 2021) to speed likelihood evaluation and hence model fitting in <code>secr.fit</code>. Detection histories are distributed over threads. Setting <code>ncores = NULL</code> in functions with multi-threading uses the existing value from the environment variable RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>These functions use multi-threading and call <code>setNumThreads</code> internally:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+autoini">autoini</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+confint.secr">confint.secr</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+derived.secr">derived.secr</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+derivedSystematic">derivedSystematic</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+esa">esa</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fxi.secr">fxi.secr</a></code> and related functions </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+pdot">pdot</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+region.N">region.N</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+score.test">score.test</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+secr.fit">secr.fit</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>These functions use multi-threading without calling <code>setNumThreads</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+LLsurface.secr">LLsurface.secr</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+mask.check">mask.check</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+expected.n">expected.n</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+secr.test">secr.test</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+sim.secr">sim.secr</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other functions may use multithreading indirectly through a call to one of these functions. Examples are <code><a href="#topic+suggest.buffer">suggest.buffer</a></code> (<code>autoini</code>), <code><a href="#topic+esa.plot">esa.plot</a></code> (<code>pdot</code>), and <code><a href="#topic+bias.D">bias.D</a></code> (<code>pdot</code>).
</p>
<p>NOTE: The mechanism for setting the number of threads changed between versions 4.1.0 and 4.2.0. The default number of cores is now capped at 2 to meet CRAN requirements. Setting <code>ncores = NULL</code> previously specified one less than the maximum number of cores.
</p>
<p>Earlier versions of <span class="pkg">secr</span> made more limited use of multiple cores (CPUs)
through the package <span class="pkg"><a href="lattice.html#topic+parallel">parallel</a></span>. The functions <code><a href="#topic+par.secr.fit">par.secr.fit</a></code>, <code><a href="#topic+par.derived">par.derived</a></code>, and   <code><a href="#topic+par.region.N">par.region.N</a></code> are now deprecated because they were too slow. <code><a href="#topic+list.secr.fit">list.secr.fit</a></code> replaces <code>par.secr.fit</code>
</p>
<p>&lsquo;Unit&rsquo; refers to the unit of work sent to each worker process. As a guide, a &lsquo;large&rsquo; benefit means &gt;60% reduction in process time with
4 CPUs.
</p>
<p><span class="pkg">parallel</span> offers several different mechanisms, bringing together
the functionality of <span class="pkg">multicore</span> and <span class="pkg">snow</span>. The mechanism used
by <span class="pkg">secr</span> is the simplest available, and is expected to work across all
operating systems. Technically, it relies on Rscript and communication
between the master and worker processes is <em>via</em> sockets. As stated
in the <span class="pkg">parallel</span> documentation &quot;Users of Windows and Mac OS X may
expect pop-up dialog boxes from the firewall asking if an R process
should accept incoming connections&quot;. You may possibly get warnings from R 
about closing unused connections. These can safely be ignored.
</p>
<p>Use <code>parallel::detectCores()</code> to get
an idea of how many cores are available on your machine; this may (in
Windows) include virtual cores over and above the number of physical
cores. See RShowDoc(&quot;parallel&quot;, package = &quot;parallel&quot;) in core R for
explanation.
</p>
<p>In <code>secr.fit</code> the output component &lsquo;proctime&rsquo; misrepresents the
elapsed processing time when multiple cores are used.
</p>


<h3>Warning</h3>

<p>It appears that multicore operations in <span class="pkg">secr</span> using <span class="pkg">parallel</span> may fail if the packages <span class="pkg">snow</span> and <span class="pkg">snowfall</span> are also loaded. The error message is obscure:
</p>
<p>&ldquo;Error in UseMethod(&quot;sendData&quot;) : 
no applicable method for 'sendData' applied to an object of class &quot;SOCK0node&quot;&rdquo;
</p>


<h3>References</h3>

<p>Allaire, J. J., Francois, R., Ushey, K., Vandenbrouck, G., Geelnard, M. and Intel (2021)
RcppParallel: Parallel Programming Tools for 'Rcpp'. R package version 5.1.2.
https://CRAN.R-project.org/package=RcppParallel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

sessionInfo()
# R version 4.3.0 (2023-04-21 ucrt)
# Platform: x86_64-w64-mingw32/x64 (64-bit)
# Running under: Windows 11 x64 (build 22621)
# on Dell-XPS 8950 Intel i7-12700K
# ...
# see stackoverflow suggestion for microbenchmark list argument
# https://stackoverflow.com/questions/32950881/how-to-use-list-argument-in-microbenchmark

library(microbenchmark)
options(digits = 4)

## benefit from multi-threading in secr.fit

jobs &lt;- lapply(seq(2,8,2), function(nc) 
    bquote(suppressWarnings(secr.fit(captdata, trace = FALSE, ncores = .(nc)))))
microbenchmark(list = jobs, times = 10, unit = "seconds")
# [edited output]
# Unit: seconds
# expr     min      lq   mean median     uq    max neval
# ncores = 2 1.75880 2.27978 2.6680 2.7450 3.0960 3.4334    10
# ncores = 4 1.13549 1.16280 1.6120 1.4431 2.0041 2.4018    10
# ncores = 6 0.88003 0.98215 1.2333 1.1387 1.5175 1.6966    10
# ncores = 8 0.78338 0.90033 1.5001 1.0406 1.2319 4.0669    10

## sometimes (surprising) lack of benefit with ncores&gt;2

msk &lt;- make.mask(traps(ovenCH[[1]]), buffer = 300, nx = 25)
jobs &lt;- lapply(c(1,2,4,8), function(nc) 
    bquote(secr.fit(ovenCH, trace = FALSE, ncores = .(nc), mask = msk)))
microbenchmark(list = jobs, times = 10, unit = "seconds")
# [edited output]
# Unit: seconds
# expr     min      lq   mean median     uq    max neval
# ncores = 1 12.5010 13.4951 15.674 15.304 16.373 21.723    10
# ncores = 2 10.0363 11.8634 14.407 13.726 16.782 22.966    10
# ncores = 4  8.6335 10.3422 13.085 12.449 15.729 17.914    10
# ncores = 8  8.5286  9.9008 10.751 10.736 10.796 14.885    10

## and for simulation...

jobs &lt;- lapply(seq(2,8,2), function(nc)
    bquote(sim.secr(secrdemo.0, nsim = 20, tracelevel = 0,  ncores = .(nc))))
microbenchmark(list = jobs, times = 10, unit = "seconds")
# [edited output]
# Unit: seconds
# expr    min     lq   mean median     uq     max neval
# ncores = 2 48.610 49.932 59.032 52.485 54.730 119.905    10
# ncores = 4 29.480 29.996 30.524 30.471 31.418  31.612    10
# ncores = 6 22.583 23.594 24.148 24.354 24.644  25.388    10
# ncores = 8 19.924 20.651 25.581 21.002 21.696  51.920    10

## and log-likelihood surface

jobs &lt;- lapply(seq(2,8,2), function(nc) 
    bquote(suppressMessages(LLsurface(secrdemo.0,  ncores = .(nc)))))
microbenchmark(list = jobs, times = 10, unit = "seconds")
# [edited output]
# Unit: seconds
# expr    min     lq   mean median     uq    max neval
# ncores = 2 20.941 21.098 21.290 21.349 21.471 21.619    10
# ncores = 4 14.982 15.125 15.303 15.263 15.449 15.689    10
# ncores = 6 13.994 14.299 14.529 14.342 14.458 16.515    10
# ncores = 8 13.597 13.805 13.955 13.921 14.128 14.353    10


## End(Not run)

</code></pre>

<hr>
<h2 id='pdot'> Net Detection Probability </h2><span id='topic+pdot'></span><span id='topic+CVpdot'></span>

<h3>Description</h3>

<p>Compute spatially explicit net probability of detection for individual(s) 
at given coordinates (pdot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdot(X, traps, detectfn = 0, detectpar = list(g0 = 0.2,
    sigma = 25, z = 1), noccasions = NULL, binomN = NULL,
    userdist = NULL, ncores = NULL) 

CVpdot(..., conditional = FALSE)    

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdot_+3A_x">X</code></td>
<td>
<p> vector or 2-column matrix of coordinates </p>
</td></tr>
<tr><td><code id="pdot_+3A_traps">traps</code></td>
<td>
 <p><code>traps</code> object </p>
</td></tr>
<tr><td><code id="pdot_+3A_detectfn">detectfn</code></td>
<td>
<p> integer code for detection function q.v. </p>
</td></tr>
<tr><td><code id="pdot_+3A_detectpar">detectpar</code></td>
<td>
<p> a named list giving a value for each parameter of detection function </p>
</td></tr>
<tr><td><code id="pdot_+3A_noccasions">noccasions</code></td>
<td>
<p> number of sampling intervals (occasions) </p>
</td></tr>
<tr><td><code id="pdot_+3A_binomn">binomN</code></td>
<td>
<p> integer code for discrete distribution (see
<code><a href="#topic+secr.fit">secr.fit</a></code>) </p>
</td></tr>
<tr><td><code id="pdot_+3A_userdist">userdist</code></td>
<td>
<p>user-defined distance function or matrix (see <a href="#topic+userdist">userdist</a>)</p>
</td></tr>
<tr><td><code id="pdot_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads</p>
</td></tr>
<tr><td><code id="pdot_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>pdot</code></p>
</td></tr>
<tr><td><code id="pdot_+3A_conditional">conditional</code></td>
<td>
<p>logical; if TRUE then computed mean and CV are conditional on detection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>traps</code> has a <a href="#topic+usage">usage</a> attribute then <code>noccasions</code> is
set accordingly; otherwise it must be provided.
</p>
<p>The probability computed is <code class="reqn">p.(\mathbf{X}) = 1 - \prod\limits _{k}
\{1 - p_s(\mathbf{X},k)\}^{S}</code> where
the product is over the detectors in <code>traps</code>, excluding any not
used on a particular occasion. The per-occasion detection function
<code class="reqn">p_s</code> is halfnormal (0) by default, and is assumed not to vary
over the <code class="reqn">S</code> occasions.
</p>
<p>For detection functions (10) and (11) the signal threshold &lsquo;cutval&rsquo; should be
included in <code>detectpar</code>, e.g., <code>detectpar = list(beta0 = 103, beta1
= -0.11, sdS = 2, cutval = 52.5)</code>.
</p>
<p>The calculation is not valid for single-catch traps because
<code class="reqn">p.(\mathbf{X})</code> is reduced by competition between animals.
</p>
<p><code>userdist</code> cannot be set if &lsquo;traps&rsquo; is any of polygon, polygonX,
transect or transectX. if <code>userdist</code> is a function requiring
covariates or values of parameters &lsquo;D&rsquo; or &lsquo;noneuc&rsquo; then <code>X</code> must
have a covariates attribute with the required columns.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p><code>CVpdot</code> returns the expected mean and CV of pdot across the points listed in <code>X</code>, assuming uniform population density. <code>X</code> is usually a habitat mask. See Notes for details.
</p>


<h3>Value</h3>

<p>For <code>pdot</code>, a vector of probabilities, one for each row in X.
</p>
<p>For <code>CVpdot</code>, a named vector with elements &lsquo;meanpdot&rsquo; and &lsquo;CVpdot&rsquo;.
</p>


<h3>Note</h3>

<p><code>CVpdot</code> computes the mean <code class="reqn">\mu</code> and variance <code class="reqn">V</code> of the location-specific overall detection probability <code class="reqn">p.(\mathbf{X})</code> as follows.
</p>
<p style="text-align: center;"><code class="reqn">\mu = \int p.(\mathbf{X}) f(\mathbf{X}) d\mathbf{X},</code>
</p>

<p style="text-align: center;"><code class="reqn">V = \int p.(\mathbf{X})^2 f(\mathbf{X}) d\mathbf{X} - \mu^2.</code>
</p>

<p>For uniform density and <code>conditional = FALSE</code>, <code class="reqn">f(\mathbf{X})</code> is merely a scaling factor independent of <code class="reqn">\mathbf{X}</code>. 
</p>
<p>If <code>conditional = TRUE</code> then <code class="reqn">f(\mathbf{X}) = p.(\mathbf{X}) / \int p.(\mathbf{X}) d\mathbf{X}</code>. 
</p>
<p>The coefficient of variation is CV = <code class="reqn">\sqrt{V}/\mu</code>.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+secr">secr</a></code>, 
<code><a href="#topic+make.mask">make.mask</a></code>,
<code><a href="#topic+Detection+20functions">Detection functions</a></code>, 
<code><a href="#topic+pdot.contour">pdot.contour</a></code>,
<code><a href="#topic+CV">CV</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

  temptrap &lt;- make.grid()
  ## per-session detection probability for an individual centred
  ## at a corner trap. By default, noccasions = 5.
  pdot (c(0,0), temptrap, detectpar = list(g0 = 0.2, sigma = 25),
    noccasions = 5)
    
  msk &lt;- make.mask(temptrap, buffer = 100)
  CVpdot(msk, temptrap, detectpar = list(g0 = 0.2, sigma = 25),
    noccasions = 5)

## End(Not run)

</code></pre>

<hr>
<h2 id='PG'>Telemetry Fixes in Polygons</h2><span id='topic+PG'></span>

<h3>Description</h3>

<p>For a telemetry dataset, either as a standalone capthist object with
detector type &lsquo;telemetryonly&rsquo; or the xylist attribute of a combined capthist
object resulting from <code>addTelemetry</code>, determine the proportion of
fixes of each individual that lie within a set of polygons. Typically
used to obtain the proportion of fixes on a trapping grid, hence
&lsquo;proportion on grid&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PG(CH, poly = NULL, includeNULL = FALSE, plt = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PG_+3A_ch">CH</code></td>
<td>
<p> capthist object including telemetry locations</p>
</td></tr>
<tr><td><code id="PG_+3A_poly">poly</code></td>
<td>
<p> polygon object (see <code><a href="#topic+boundarytoSF">boundarytoSF</a></code>) </p>
</td></tr>
<tr><td><code id="PG_+3A_includenull">includeNULL</code></td>
<td>
<p> logical; if TRUE then missing values are returned
for animals without telemetry data</p>
</td></tr>
<tr><td><code id="PG_+3A_plt">plt</code></td>
<td>
<p> logical; if TRUE then poly and telemetry locations are plotted</p>
</td></tr>
<tr><td><code id="PG_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code><a href="#topic+buffer.contour">buffer.contour</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>poly</code> is obtained by applying
<code><a href="#topic+buffer.contour">buffer.contour</a></code> with arguments ... to the traps
attribute of <code>CH</code>. Note that either a positive <code>buffer</code>
argument or <code>convex = TRUE</code> is needed for the polygon to have
area &gt; 0.
</p>
<p>If <code>plt = TRUE</code>, <code>buffer.contour</code> is used to plot
<code>poly</code> and the points are overplotted (open circles outside,
filled circles inside). To control the framing of the plot, create an
initial plot (e.g., with plot.traps, setting the <code>border</code>
argument) and use <code>add = TRUE</code> (see Examples).
</p>


<h3>Value</h3>

<p>Numeric vector of proportions. If <code>includeNULL = TRUE</code> length
equal to number of animals (rows) in <code>CH</code>; otherwise length is
the number of animals for which there is telemetry data (because
xylist may cover only a subset of animals in <code>CH</code>).
</p>


<h3>References</h3>

<p>Grant, T. J. and Doherty, P. F. (2007) Monitoring of the flat-tailed
horned lizard with methods incorporating detection
probability. <em>Journal of Wildlife Management</em> <b>71</b>, 1050&ndash;1056
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addTelemetry">addTelemetry</a></code>,  <code><a href="#topic+buffer.contour">buffer.contour</a></code>, 
<code><a href="#topic+pointsInPolygon">pointsInPolygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
olddir &lt;- setwd('d:/density communication/combining telemetry and secr/possums')
CvilleCH &lt;- read.capthist('CVILLE summer captures 4occ.txt',
                          'CVILLE detectors summer 4occ.txt',
                          detector = 'single')
CvilleGPS &lt;- read.telemetry('CVILLE GPS Combined 4occ.txt')
CvilleGPSnew &lt;- read.telemetry('CVILLE summer GPS New occasions.txt')
setwd(olddir)

CvilleBoth &lt;- addTelemetry(CvilleCH, CvilleGPSnew)
plot(CvilleBoth, border = 400)
PG(CvilleBoth, buffer = 100, convex = TRUE, plt = TRUE, add = TRUE, 
    col = 'red')

###################################################################
## this code computes an area-adjusted density estimate
## cf Grant and Doherty 2007
PGD &lt;- function (CH, estimator = 'h2', ...) {
    pg &lt;- PG(CH, ...)
    PGbar &lt;- mean(pg)
    N &lt;- closedN(CH, estimator)
    A &lt;- polyarea(buffer.contour(traps(CH), ...)[[1]])
    Dhat &lt;- N$Nhat / A * PGbar
    varDhat &lt;- (N$Nhat^2 * var(pg) + PGbar^2 * N$seNhat^2) / A^2 
    c(Dhat = Dhat, seDhat = sqrt(varDhat))
}
plot(traps(CvilleBoth), border = 400)
PGD(CvilleBoth, buffer = 0, convex = TRUE, plt = TRUE, add = TRUE)
PGD(CvilleBoth, est='null', buffer = 0, convex = TRUE, plt = FALSE)

###################################################################
## this code generates a PG summary for telemetry records randomly
## translated and rotated, keeping the centres within a habitat mask

randomPG &lt;- function(CH, poly = NULL, mask, reorient = TRUE, nrepl = 1,
                     seed = 12345, ...) {
    moveone &lt;- function(xy, newcentre) {
        xy &lt;- sweep(xy,2,apply(xy,2,mean))
        if (reorient)  ## random rotation about centre
            xy &lt;- rotate(xy, runif(1)*360)
        sweep(xy,2,unlist(newcentre), "+")
    }
    onerepl &lt;- function(r) {   ## r is dummy for replicate
        centres &lt;- sim.popn(D = D, core = mask, model2D = "IHP",
                            Ndist = "fixed")
        xyl &lt;- mapply(moveone, xyl, split(centres, rownames(centres)))
        attr(CH, 'xylist') &lt;- xyl  ## substitute random placement
        PG(CH = CH , poly = poly, plt = FALSE, ...)
    }
    set.seed(seed)
    if (!requireNamespace('sf')) stop ("requires package sf")
    if (is.null(poly)) {
        poly &lt;- buffer.contour (traps(CH), ...)
        poly &lt;- lapply(poly, as.matrix)
        poly &lt;- sf::st_sfc(sf::st_polygon(poly))
    }
    xyl &lt;- telemetryxy(CH)
    D &lt;- length(xyl) / maskarea(mask)
    sapply(1:nrepl, onerepl)
}

mask &lt;- make.mask (traps(CvilleBoth), buffer = 400, type = "trapbuffer")
pg &lt;- randomPG (CvilleBoth, mask = mask, buffer = 100, convex = TRUE,
    nrepl = 20)
apply(pg, 1, mean)
###################################################################


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.capthist'> Plot Detection Histories </h2><span id='topic+plot.capthist'></span><span id='topic+plotMCP'></span>

<h3>Description</h3>

<p>Display a plot of detection (capture) histories or telemetry data over a map of the detectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'capthist'
plot(x, rad = 5, hidetraps = FALSE, tracks = FALSE,
    title = TRUE, subtitle = TRUE, add = FALSE, varycol = TRUE, 
    icolours = NULL, randcol = FALSE, lab1cap = FALSE, laboffset = 4, ncap = FALSE, 
    splitocc = NULL, col2 = "green", type = c("petal", "n.per.detector", "n.per.cluster",
        "sightings", "centres", "telemetry", "nontarget"),
    cappar = list(cex = 1.3, pch = 16, col = "blue"), 
    trkpar = list(col = "blue", lwd = 1), 
    labpar = list(cex = 0.7, col = "black"), ...)

plotMCP(x, add = FALSE, col = "black", fill = NA, lab1cap = FALSE, laboffset = 4,
    ncap = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.capthist_+3A_x">x</code></td>
<td>
<p> an object of class <code>capthist</code> </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_rad">rad</code></td>
<td>
<p> radial displacement of dot indicating each capture event from the detector location (used to separate overlapping points) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_hidetraps">hidetraps</code></td>
<td>
<p> logical indicating whether trap locations should be displayed </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_tracks">tracks</code></td>
<td>
<p> logical indicating whether consecutive locations of individual animals should be joined by a line </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_title">title</code></td>
<td>
<p> logical or character string for title </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_subtitle">subtitle</code></td>
<td>
<p> logical or character string for subtitle </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_add">add</code></td>
<td>
<p> logical for whether to add to existing plot </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_varycol">varycol</code></td>
<td>
<p> logical for whether to distinguish individuals by colour </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_icolours">icolours</code></td>
<td>
<p> vector of individual colours (when <code>varycol</code> =
TRUE), or colour scale (non-petal plots) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_randcol">randcol</code></td>
<td>
<p> logical to use random colours (<code>varycol</code> = TRUE) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_lab1cap">lab1cap</code></td>
<td>
<p> logical for whether to label the first capture of each animal </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_laboffset">laboffset</code></td>
<td>
<p> distance by which to offset labels from points </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_ncap">ncap</code></td>
<td>
<p> logical to display the number of detections per trap per occasion </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_splitocc">splitocc</code></td>
<td>
<p> optional occasion from which second colour is to be used  </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_col2">col2</code></td>
<td>
<p> second colour (used with <code>splitocc</code>) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_type">type</code></td>
<td>
<p> character string (&quot;petal&quot;, &quot;n.per.detector&quot; or &quot;n.per.cluster&quot;) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_cappar">cappar</code></td>
<td>
<p> list of named graphical parameters for detections (passed to <code>par</code>) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_trkpar">trkpar</code></td>
<td>
<p> list of named graphical parameters for tracks (passed to <code>par</code>) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_labpar">labpar</code></td>
<td>
<p> list of named graphical parameters for labels (passed to <code>par</code>) </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_...">...</code></td>
<td>
<p> arguments to be passed to <code>plot.traps</code> </p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_col">col</code></td>
<td>
<p>vector of line colour numbers or names (plotMCP only)</p>
</td></tr>
<tr><td><code id="plot.capthist_+3A_fill">fill</code></td>
<td>
<p>vector of fill colour numbers or names (plotMCP only)</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>By default, a &lsquo;petal&rsquo; plot is generated in the style of Density (Efford 2012)
using <code>eqscplot</code> from the MASS library. 
</p>
<p>If <code>type =
"n.per.detector"</code> or <code>type = "n.per.cluster"</code> the result is a
colour-coded plot of the number of individuals at each unit, pooled over
occasions. 
</p>
<p>If <code>type = "sightings"</code> the sightings of unmarked animals are 
displayed on a petal-like plot (requires mark-resight data) (see also <code><a href="#topic+sightingPlot">sightingPlot</a></code>).
</p>
<p>If <code>type = "centres"</code> then a single point is plotted for each animal, jittered on each axis by a random amount (limits +/- <code>rad</code>/2).
</p>
<p>If <code>type = "telemetry"</code> and the &lsquo;telemetryxy&rsquo; attribute is not NULL then the telemetry locations are plotted.
</p>
<p>If <code>type = "nontarget"</code> and the &lsquo;nontarget&rsquo; attribute is not NULL then the nontarget captures or interference events are plotted.
</p>
<p>If <code>title</code> = FALSE no title is displayed; if <code>title</code> = TRUE,
the session identifer is used for the title.
</p>
<p>If <code>subtitle</code> = FALSE no subtitle is displayed; if <code>subtitle</code>
= TRUE, the subtitle gives the numbers of occasions, detections and
individuals.
</p>
<p>If <code>x</code> is a multi-session capthist object then a separate plot is
produced for each session. Use <code>par(mfrow = c(nr, nc))</code> to allow a
grid of plots to be displayed simultaneously (nr rows x nc columns).
</p>
<p>These arguments are used only for petal plots: <code>rad</code>,
<code>tracks</code>, <code>varycol</code>, <code>randcol</code>, <code>lab1cap</code>,
<code>laboffset</code>, <code>ncap</code>, <code>splitocc</code>, <code>col2</code>,
<code>trkpar</code>, and <code>labpar</code>. Call <code><a href="#topic+occasionKey">occasionKey</a></code> 
to add a key to the petals.
</p>
<p>If <code>icolours = NULL</code> and <code>varycol = TRUE</code> then a vector of
colours is generated automatically as topo.colors((nrow(x)+1) * 1.5).
If there are too few values in <code>icolours</code> for the number of
individuals then colours will be re-used. 
</p>
<p><code>plotMCP</code> plots minimum convex polygons of individual location
data over a base plot of detector locations. Usually the data are
telemetry locations in the xylist attribute of the capthist
object; if this is not present and <code>x</code> is a polygon search
capthist then the individual xy data are plotted.
</p>


<h3>Value</h3>

<p>For <code>type = "petal"</code>, the number of detections in <code>x</code>.
For <code>type = "sightings"</code>, the number of sightings of unmarked animals in <code>x</code>.
For <code>type = "n.per.detector"</code> or <code>type = "n.per.cluster"</code>, a
dataframe with data for a legend (see Examples).
</p>
<p><code>plotMCP</code> invisibly returns a list in which each component is a
2-column (x,y) dataframe of boundary coordinates for one individual.
</p>


<h3>References</h3>

 
<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+capthist">capthist</a></code>, 
<code><a href="#topic+occasionKey">occasionKey</a></code>, 
<code><a href="#topic+sightingPlot">sightingPlot</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demotrap &lt;- make.grid()
tempcapt &lt;- sim.capthist(demotrap, 
    popn = list(D = 5, buffer = 50), 
    detectpar = list(g0 = 0.15, sigma = 30))
plot(tempcapt, border = 10, rad = 3, tracks = TRUE, 
    lab1cap = TRUE, laboffset = 2.5)

## type = n.per.cluster

## generate some captures
testregion &lt;- data.frame(x = c(0,2000,2000,0),
    y = c(0,0,2000,2000))
popn &lt;- sim.popn (D = 10, core = testregion, buffer = 0,
    model2D = "hills", details = list(hills = c(-2,3)))
t1 &lt;- make.grid(nx = 1, ny = 1)
t1.100 &lt;- make.systematic (cluster = t1, spacing = 100,
    region = testregion)
capt &lt;- sim.capthist(t1.100, popn = popn, noccasions = 1)

## now plot captures ...
temp &lt;- plot(capt, title = "Individuals per cluster",
    type = "n.per.cluster", hidetraps = FALSE,
    gridlines = FALSE, cappar = list(cex = 1.5))

if (interactive()) {
    ## add legend; click on map to place top left corner
    legend (locator(1), pch = 21, pt.bg = temp$colour,
        pt.cex = 1.3, legend = temp$legend, cex = 0.8)
}

## Not run: 

## try varying individual colours - requires RColorBrewer
library(RColorBrewer)
plot(infraCH[[2]], icolours = brewer.pal(12, "Set3"), tracks = TRUE,
    bg = "black", cappar = list(cex = 2), border = 10, rad = 2,
    gridlines = FALSE)

## generate telemetry data
te &lt;- make.telemetry()
tr &lt;- make.grid(detector = "proximity")
totalpop &lt;- sim.popn(tr, D = 20, buffer = 100)
tepop &lt;- subset(totalpop, runif(nrow(totalpop)) &lt; 0.05)
teCH &lt;- sim.capthist(te, popn = tepop, renumber=FALSE, detectfn = "HHN",
    detectpar = list(lambda0 = 3, sigma = 25))
plot(teCH, type = 'telemetry', tracks = TRUE)

## simple "centres" example
## polygon data require 'hazard' detection function 14:19
CH &lt;- sim.capthist(make.poly(), nocc = 20, detectfn = 'HHN', 
    detectpar = list(lambda0 = 1, sigma = 10))
plot(CH, cappar = list(col = 'orange'), varycol = FALSE, border = 10)
plot(CH, type = 'centres', add = TRUE, rad = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.mask'> Plot Habitat Mask, Density or Resource Surface </h2><span id='topic+plot.mask'></span><span id='topic+plot.Dsurface'></span><span id='topic+plot.Rsurface'></span><span id='topic+spotHeight'></span>

<h3>Description</h3>

<p>Plot a habitat mask either as points or as an <code>image</code>
plot. Colours maybe used to show the value of one mask covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mask'
plot(x, border = 20, add = FALSE, covariate = NULL, axes = FALSE,
    dots = TRUE, col = "grey", breaks = 10, meshcol = NA, ppoly = TRUE,
    polycol = "red", legend = TRUE, ...)

## S3 method for class 'Dsurface'
plot(x, covariate, group = NULL, plottype =
    "shaded", scale = 1, ...)

## S3 method for class 'Rsurface'
plot(x, covariate = "Resource", plottype =
    "shaded", scale = 1, ...)

spotHeight (object, prefix = NULL, dec = 2, point = FALSE, text = TRUE,
    sep = ", ",  session = 1, scale = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mask_+3A_x">x</code>, <code id="plot.mask_+3A_object">object</code></td>
<td>
<p> mask or Dsurface object </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_border">border</code></td>
<td>
<p> width of blank display border (metres) </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_add">add</code></td>
<td>
<p> logical for adding mask points to an existing plot </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_covariate">covariate</code></td>
<td>
<p> name (as character string in quotes) or column
number of a covariate to use for colouring </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_axes">axes</code></td>
<td>
<p> logical for plotting axes </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_dots">dots</code></td>
<td>
<p> logical for plotting mask points as dots, rather than as square pixels </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_col">col</code></td>
<td>
<p> colour(s) to use for plotting </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_breaks">breaks</code></td>
<td>
<p> an integer or a numeric vector &ndash; see <code><a href="base.html#topic+cut">cut</a></code> </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_meshcol">meshcol</code></td>
<td>
<p> colour for pixel borders (NA for none) </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_ppoly">ppoly</code></td>
<td>
<p> logical for whether the bounding polygon should be
plotted (if &lsquo;poly&rsquo; specified) </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_polycol">polycol</code></td>
<td>
<p> colour for outline of polygon (<code>ppoly</code> = TRUE) </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_legend">legend</code></td>
<td>
<p> logical; if TRUE a legend is plotted </p>
</td></tr>   
<tr><td><code id="plot.mask_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code>eqscplot</code> (in the case
of <code>plot.mask</code>), <code>plot.mask</code> (in the case of
<code>plot.Dsurface</code> and <code>plot.Rsurface</code>), and <code>points</code> or
<code>text</code> (in the case of <code>spotHeight</code>) </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_group">group</code></td>
<td>
<p> group for which plot required, if more than 1 </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_plottype">plottype</code></td>
<td>
<p> character string c(&quot;dots&quot;, &quot;shaded&quot;, &quot;contour&quot;,
&quot;persp&quot;) </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_scale">scale</code></td>
<td>
<p>numeric multiplier for density or other numeric covariate
(see <code><a href="#topic+Dsurface">Dsurface</a></code>)</p>
</td></tr>
<tr><td><code id="plot.mask_+3A_prefix">prefix</code></td>
<td>
<p>character vector for name(s) of covariate(s) to retrieve</p>
</td></tr>
<tr><td><code id="plot.mask_+3A_dec">dec</code></td>
<td>
<p> number of decimal places for rounding density </p>
</td></tr>
<tr><td><code id="plot.mask_+3A_point">point</code></td>
<td>
<p>logical for whether to plot point</p>
</td></tr>
<tr><td><code id="plot.mask_+3A_text">text</code></td>
<td>
<p>logical for whether to place density label on plot</p>
</td></tr>
<tr><td><code id="plot.mask_+3A_sep">sep</code></td>
<td>
<p>character separator for elements if length(prefix)&gt;1</p>
</td></tr>
<tr><td><code id="plot.mask_+3A_session">session</code></td>
<td>
<p>session number or identifier</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>dots</code> of <code>plot.mask</code> selects between two
distinct types of plot (dots and shaded (coloured) pixels).
</p>
<p><code>plot.Dsurface</code> and <code>plot.Rsurface</code> offer contour and
perspective plots in addition to the options in <code>plot.mask</code>. It may
take some experimentation to get what you want - see
<code><a href="graphics.html#topic+contour">contour</a></code> and <code><a href="graphics.html#topic+persp">persp</a></code>.
</p>
<p>For plot.Dsurface the default value of &lsquo;covariate&rsquo; is &lsquo;D&rsquo; unless the Dsurface has a &lsquo;parameter&rsquo; attribute of &lsquo;noneuc&rsquo;,
</p>
<p>If using a covariate or Dsurface or Rsurface to colour dots or pixels, the
<code>col</code> argument should be a colour vector of length equal to the
number of levels (the default palette from 2.9.0 is <code>terrain.colors</code>, and this
palette will also be used whenever there are too few levels in the
palette provided; see Notes for more on palettes). Border lines around
pixels are drawn in &lsquo;meshcol&rsquo;. Set this to NA to eliminate pixel
borders.
</p>
<p>If a <code>covariate</code> is specified in a call to <code>plot.Dsurface</code> then
that covariate will be plotted instead of density. This is a handy way
to contour a covariate (contouring is not available in <code>plot.mask</code>).
</p>
<p>If &lsquo;breaks&rsquo; is an integer then the range of the covariate is divided
into this number of equal intervals. Alternatively, &lsquo;breaks&rsquo; may be a
vector of break points (length one more than the number of
intervals). This gives more control and often &lsquo;prettier&rsquo; 
</p>
<p><code>spotHeight</code> may be used to interrogate a plot produced with
<code>plot.Dsurface</code> or <code>plot.Rsurface</code>, or by <code>plot.mask</code> if
the mask has covariates. <code>prefix</code> defaults to &lsquo;density.&rsquo; for
Dsurface objects and to '' (all covariates) for mask objects. The
predicted density or covariate at the nearest point is returned when the
user clicks on the plot. Multiple values may be displayed (e.g.,
<code>prefix = c("lcl","ucl")</code> if Dsurface includes confidence
limits). Click outside the mask or hit the Esc key to
end. <code>spotHeight</code> deals with one session at a time.
</p>
<p>Legend plotting is enabled only when a covariate is specified. It uses
<code><a href="graphics.html#topic+legend">legend</a></code> when <code>dots = TRUE</code> and
<code><a href="#topic+strip.legend">strip.legend</a></code> otherwise.
</p>


<h3>Value</h3>

<p>If <code>covariate</code> is specified and <code>plottype = "shaded"</code> then
<code>plot.mask</code> invisibly returns a character vector of the intervals
defined by &lsquo;breaks&rsquo; (useful for plotting a legend).
</p>
<p>If <code>plottype = "persp"</code> then <code>plot.mask</code> invisibly returns a the
perspective matrix that may be used to add to the plot with
<code><a href="grDevices.html#topic+trans3d">trans3d</a></code>.
</p>
<p><code>spotHeight</code> invisibly returns a dataframe of the extracted
values and their coordinates.
</p>


<h3>Note</h3>

<p><code>plot.mask()</code> acquired the argument &lsquo;legend&rsquo; in version 2.9.0,
and other changes (e.g., <code>breaks = 10</code>) may alter the output.
</p>
<p>Contouring requires a rectangular grid; if a Dsurface is not
rectangular then plot.Dsurface with <code>plottype = "contour"</code> triggers a call to
<code><a href="#topic+rectangularMask">rectangularMask</a></code>.
</p>
<p>The colour palettes <code>topo.colors</code>, <code>heat.colors</code> and
<code>terrain.colors</code> may be viewed with the <code>demo.pal</code> function in
the Examples code of their help page <a href="grDevices.html#topic+palettes">palettes</a>.
</p>
<p>The package <span class="pkg">RColorBrewer</span> is a good source of palettes. Try
<code>display.brewer.all()</code> and e.g., <code>col = brewer.pal(7, "YlGn")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colours">colours</a></code>,
<code><a href="#topic+mask">mask</a></code>,
<code><a href="#topic+Dsurface">Dsurface</a></code>,
<code><a href="#topic+rectangularMask">rectangularMask</a></code>,
<code><a href="graphics.html#topic+contour">contour</a></code>
<code><a href="graphics.html#topic+persp">persp</a></code>
<code><a href="#topic+strip.legend">strip.legend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple

temptrap &lt;- make.grid()
tempmask &lt;- make.mask(temptrap)
plot (tempmask)

## Not run: 

## restrict to points over an arbitrary detection threshold,
## add covariate, plot image and overlay traps

tempmask &lt;- subset(tempmask, pdot(tempmask, temptrap,
    noccasions = 5)&gt;0.001)
covariates (tempmask) &lt;- data.frame(circle = 
    exp(-(tempmask$x^2 + tempmask$y^2)/10000) )
plot (tempmask, covariate = "circle", dots = FALSE, axes = TRUE, 
    add = TRUE, breaks = 8, col = terrain.colors(8), mesh = NA)
plot (temptrap, add = TRUE)

## add a legend
par(cex = 0.9)
covrange &lt;- range(covariates(tempmask)$circle)
step &lt;- diff(covrange)/8
colourlev &lt;- terrain.colors(9)
zlev &lt;- format(round(seq(covrange[1],covrange[2],step),2))
legend (x = "topright", fill = colourlev, legend = zlev, 
    y.intersp = 0.8, title = "Covariate")

title("Colour mask points with p.(X) &gt; 0.001")
mtext(side=3,line=-1, "g0 = 0.2, sigma = 20, nocc = 5")

## Waitarere possum density surface extrapolated across region

regionmask &lt;- make.mask(traps(possumCH), buffer = 1000, spacing = 10,
    poly = possumremovalarea)
dts &lt;- distancetotrap(regionmask, possumarea)
covariates(regionmask) &lt;- data.frame(d.to.shore = dts)
shorePossums &lt;- predictDsurface(possum.model.Ds, regionmask)

## plot as coloured pixels with white lines
colourlev &lt;- terrain.colors(7)
plot(shorePossums, breaks = seq(0,3.5,0.5), plottype = "shaded",
    poly = FALSE, col = colourlev, mesh = NA)
plot(traps(possumCH), add = TRUE, detpar = list(col = "black"))
polygon(possumremovalarea)

## check some point densities
spotHeight(shorePossums, dec = 1, col = "black")

## add a legend
zlev &lt;- format(seq(0,3,0.5), digits = 1)
legend (x = "topright", fill = colourlev, legend =
    paste(zlev,"--"), y.intersp = 1, title = "Density / ha")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.popn'> Plot Population Object </h2><span id='topic+plot.popn'></span>

<h3>Description</h3>

<p>Display animal locations from a <code>popn</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'popn'
plot(x, add = FALSE, frame = TRUE,  
    circles = NULL, collapse = FALSE, seqcol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.popn_+3A_x">x</code></td>
<td>
<p> object of class <code>popn</code> </p>
</td></tr>
<tr><td><code id="plot.popn_+3A_add">add</code></td>
<td>
<p> logical to add points to an existing plot </p>
</td></tr>
<tr><td><code id="plot.popn_+3A_frame">frame</code></td>
<td>
<p> logical to add frame or polygon within which points were
simulated</p>
</td></tr>
<tr><td><code id="plot.popn_+3A_circles">circles</code></td>
<td>
<p> vector giving the radii if circles are to be plotted </p>
</td></tr>
<tr><td><code id="plot.popn_+3A_collapse">collapse</code></td>
<td>
<p> logical; if TRUE then multiple sessions are overlaid </p>
</td></tr>
<tr><td><code id="plot.popn_+3A_seqcol">seqcol</code></td>
<td>
<p> color used for first detection when collapse = TRUE (optional) </p>
</td></tr>
<tr><td><code id="plot.popn_+3A_...">...</code></td>
<td>
<p> arguments passed to <code>eqscplot</code> and <code>points</code> or
<code>symbols</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>circles</code> is provided then a circle of the given radius is
plotted for each animal using the <code>symbols</code> function. The
arguments <code>fg</code> and <code>bg</code> may be used to control the colour of
the perimeter and the fill of each circle (see Examples).
</p>
<p>For a multi-session popn with <code><a href="#topic+turnover">turnover</a></code>, <code>collapse = TRUE</code> 
allows successive locations to be joined with (<code>type = 'o'</code> or <code>type = 'l'</code>).
</p>
<p><code>seqcol</code> may be a single color, a vector of colours (one per session), 
or a vector of two colours, one for the first and one for all later sessions 
in which each animal was detected. 
</p>
<p>If ... includes 'col' then 'collapse' must be specified to avoid confusion, 
even for single-session data (see Examples).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+popn">popn</a></code>, <code><a href="#topic+sim.popn">sim.popn</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
temppopn &lt;- sim.popn(D = 5, expand.grid(
    x = c(0,100), y = c(0,100)))
# specify collapse to avoid partial match of col    
plot(temppopn, pch = 16, collapse = FALSE, col = "blue")

plot(temppopn, circles = 20, bg = "tan", fg = "white")
plot(temppopn, pch = 16, cex = 0.5, add = TRUE)

</code></pre>

<hr>
<h2 id='plot.secr'> Plot Detection Functions </h2><span id='topic+plot.secr'></span><span id='topic+plot.secrlist'></span><span id='topic+detectfnplot'></span><span id='topic+attenuationplot'></span>

<h3>Description</h3>

<p>Plot detection functions using estimates of parameters in an secr object, or as provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'secr'
plot(x, newdata = NULL, add = FALSE,
    sigmatick = FALSE, rgr = FALSE, limits = FALSE, alpha = 0.05,
    xval = 0:200, ylim = NULL, xlab = NULL, ylab = NULL, ...)

## S3 method for class 'secrlist'
plot(x, newdata = NULL, add = FALSE,
    sigmatick = FALSE, rgr = FALSE, limits = FALSE, alpha = 0.05,
    xval = 0:200, ylim = NULL, xlab = NULL, ylab = NULL, ...,
    overlay = TRUE)

detectfnplot (detectfn, pars, details = NULL, add = FALSE,
    sigmatick = FALSE, rgr = FALSE, hazard = FALSE, xval = 0:200, ylim = NULL,
    xlab = NULL, ylab = NULL, ...)

attenuationplot (pars, add = FALSE, spherical = TRUE,
    xval = 0:200, ylim = NULL, xlab = NULL, ylab = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.secr_+3A_x">x</code></td>
<td>
<p> an <code>secr</code> object </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_newdata">newdata</code></td>
<td>
<p> dataframe of data to form estimates </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_add">add</code></td>
<td>
<p> logical to add curve(s) to an existing plot </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_sigmatick">sigmatick</code></td>
<td>
<p> logical; if TRUE the scale parameter sigma is shown by a vertical line </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_rgr">rgr</code></td>
<td>
<p> logical; if TRUE a scaled curve r.g(r) is plotted instead of g(r) </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_hazard">hazard</code></td>
<td>
<p>logical; if TRUE the hazard of detection is plotted instead of probability</p>
</td></tr>
<tr><td><code id="plot.secr_+3A_limits">limits</code></td>
<td>
<p> logical; if TRUE pointwise confidence limits are drawn </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_xval">xval</code></td>
<td>
<p> vector of distances at for which detection to be plotted </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_ylim">ylim</code></td>
<td>
<p> vector length 2 giving limits of y axis </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_xlab">xlab</code></td>
<td>
<p> label for x axis </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_ylab">ylab</code></td>
<td>
<p> label for y axis </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_...">...</code></td>
<td>
<p> arguments to pass to <code>lines</code> </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_overlay">overlay</code></td>
<td>
<p> logical; if TRUE then automatically <code>add = TRUE</code>
for plots after the first </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of
detection function 0 = halfnormal etc. &ndash; see <a href="#topic+detectfn">detectfn</a> </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_pars">pars</code></td>
<td>
<p> list, vector or matrix of parameter values </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_details">details</code></td>
<td>
<p> list of ancillary parameters </p>
</td></tr>
<tr><td><code id="plot.secr_+3A_spherical">spherical</code></td>
<td>
<p> logical for whether to include spherical spreading term </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>newdata</code> is usually NULL, in which case one curve is plotted for
each session and group. Otherwise, <code>predict.secr</code> is used to form
estimates and plot a curve for each row in <code>newdata</code>.
</p>
<p>If axis labels are not provided they default to &lsquo;Distance (m)&rsquo; and &lsquo;Detection probability&rsquo; or &lsquo;Detection lambda&rsquo;.
</p>
<p><code>detectfnplot</code> is an alternative in which the user nominates the
type of function and provides parameter values. <code>pars</code> maybe a list
as from <code><a href="#topic+detectpar">detectpar</a></code>; it is first coerced to a numeric vector
with <code>unlist</code>. Parameter values must be in the expected order
(e.g. g0, sigma, z). If <code>pars</code> is a matrix then a separate
curve is plotted with the parameter values in each row.
</p>
<p>For <code>detectfnplot</code> the signal threshold parameters &lsquo;cutval&rsquo; and
&lsquo;spherical&rsquo; should be provided in <code>details</code> (see examples).
</p>
<p>Approximate confidence limits for g(r) are calculated using a numerical
first-order delta-method approximation to the standard error at each
<code>xval</code>. The distribution of g(r) is assumed to be normal on the logit scale for non-hazard functions (detectfn 0:13). For hazard detection functions (detectfn 14:18) the hazard is assumed (from version 3.1.1) to be distributed normally on the log scale. Limits are back-transformed to the probability scale g(r).
</p>
<p><code>attenuationplot</code> plots the expected decline in signal strength
with distance, given parameters <code class="reqn">\beta_0</code> and
<code class="reqn">\beta_1</code> for a log-linear model of sound attenuation.
</p>


<h3>Value</h3>

<p><code>plot.secr</code> invisibly returns a dataframe of the plotted values (or
a list of dataframes in the case that <code>newdata</code> has more than one
row).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Detection+20functions">Detection functions</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+secr">secr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot (secrdemo.b, xval = 0:100, ylim = c(0, 0.4))
## Add recapture probability
plot (secrdemo.b, newdata = data.frame(b = 1), add = TRUE,
    col = "red")

## signal strength detection: 70dB at source, attenuation
## 0.3dB/m, sdS 5dB; detection threshold 40 dB.
detectfnplot (detectfn = 10, c(70, -0.3, 5), details =
    list(cutval = 40))

## add a function with louder source and spherical spreading...
detectfnplot (detectfn = 11, c(110, -0.3, 5), details =
    list(cutval = 40), add = TRUE, col = "red")

## matching sound attenuation curves; `spherical-only' dashed line
attenuationplot (c(70, -0.3), spherical = FALSE, ylim=c(-10,110))
attenuationplot (c(110, 0), spherical = TRUE, add=TRUE, lty=2)
attenuationplot (c(110, -0.3), spherical = TRUE, add = TRUE,
    col = "red")

</code></pre>

<hr>
<h2 id='plot.traps'> Plot traps Object </h2><span id='topic+plot.traps'></span>

<h3>Description</h3>

<p>Map the locations of detectors (traps). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traps'
plot(x, border = 100, label = FALSE, offset = c(6,6), add = FALSE,
  hidetr = FALSE, detpar = list(), txtpar = list(), bg = "white",
  gridlines = !add, gridspace = 100, gridcol = "grey", 
  markused = FALSE, markvarying = FALSE, markvertices = FALSE,
  labelclusters = FALSE, frame = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.traps_+3A_x">x</code></td>
<td>
<p> a <code>traps</code> object </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_border">border</code></td>
<td>
<p> width of blank margin around the outermost detectors </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_label">label</code></td>
<td>
<p> logical indicating whether a text label should appear by each detector </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_offset">offset</code></td>
<td>
<p> vector displacement of label from point on x and y axes </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_add">add</code></td>
<td>
<p> logical to add detectors to an existing plot </p>
</td></tr> 
<tr><td><code id="plot.traps_+3A_hidetr">hidetr</code></td>
<td>
<p> logical to suppress plotting of detectors </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_detpar">detpar</code></td>
<td>
<p> list of named graphical parameters for detectors (passed to <code>par</code>) </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_txtpar">txtpar</code></td>
<td>
<p> list of named graphical parameters for labels (passed to <code>par</code>) </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_bg">bg</code></td>
<td>
<p> background colour </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_gridlines">gridlines</code></td>
<td>
<p> logical for plotting grid lines </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_gridspace">gridspace</code></td>
<td>
<p> spacing of gridlines </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_gridcol">gridcol</code></td>
<td>
<p> colour of gridlines </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_markused">markused</code></td>
<td>
<p> logical to distinguish detectors used on at least one
occasion</p>
</td></tr>
<tr><td><code id="plot.traps_+3A_markvarying">markvarying</code></td>
<td>
<p> logical to distinguish detectors whose usage varies among occasions </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_markvertices">markvertices</code></td>
<td>
<p> logical or 0,1,2 for plotting transect or polygon points </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_labelclusters">labelclusters</code></td>
<td>
<p> logical to label clusters</p>
</td></tr>
<tr><td><code id="plot.traps_+3A_frame">frame</code></td>
<td>
<p>data defining a boundary polygon (see <code><a href="#topic+boundarytoSF">boundarytoSF</a></code>  </p>
</td></tr>
<tr><td><code id="plot.traps_+3A_...">...</code></td>
<td>
<p> arguments to pass to <code>eqscplot</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>offset</code> may also be a scalar value for equal displacement on the x
and y axes. The <code>hidetr</code> option is most likely to be used when
plot.traps is called by plot.capthist. See <code><a href="graphics.html#topic+par">par</a></code> and
<code><a href="grDevices.html#topic+colours">colours</a></code> for more information on setting graphical
parameters. The initial values of graphical parameters are restored on
exit.
</p>
<p>Axes are not labeled. Use <code><a href="graphics.html#topic+axis">axis</a></code> and <code><a href="graphics.html#topic+mtext">mtext</a></code> if
necessary.
</p>
<p><code>markvertices</code> determines whether the vertices of each transect or
polygon will be emphasised by overplotting a point symbol
(detpar$pch). Value may be logical (TRUE, FALSE) or integer (0 = no
points, 1 = terminal vertices only, 2 = all vertices).
</p>
<p>From 4.4.0, polygon detectors are shaded with detpar$col and outlined (border) with detpar$fg. Use detpar$col = NA for no shading (transparent polygons).
</p>
<p><code>labelclusters</code> requires <code>x</code> to have attributes &lsquo;clusterID&rsquo; and
&lsquo;clustertrap&rsquo;.
</p>
<p>A boundary polygon is plotted in black if <code>frame</code> is not NULL.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+traps">traps</a></code>,
<code><a href="#topic+clusterID">clusterID</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'> temptrap &lt;- make.grid()
 plot (temptrap, detpar = list(pch = 16, col = "blue"), 
    label = TRUE, offset = 7)
</code></pre>

<hr>
<h2 id='plotMaskEdge'>Outline Around Mask Cells</h2><span id='topic+plotMaskEdge'></span>

<h3>Description</h3>

<p>Plots the outer edge of a  mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
plotMaskEdge(mask, plt = TRUE, add = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMaskEdge_+3A_mask">mask</code></td>
<td>
<p>secr habitat mask object</p>
</td></tr>
<tr><td><code id="plotMaskEdge_+3A_plt">plt</code></td>
<td>
<p>logical; if TRUE the edge is plotted</p>
</td></tr>
<tr><td><code id="plotMaskEdge_+3A_add">add</code></td>
<td>
<p>logical; if TRUE the line is added to an existing plot</p>
</td></tr>
<tr><td><code id="plotMaskEdge_+3A_...">...</code></td>
<td>
<p>other line plotting arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>May be slow. 
</p>


<h3>Value</h3>

<p>A numeric matrix of 4 columns is returned invisibly. The columns may be used as arguments x0, y0, x1, y1 in a call to segments().
</p>


<h3>Note</h3>

<p>A bug in <span class="pkg">secr</span> &lt;3.2.2 caused some internal lines to appear when the mask spacing was not an integer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gridCells">gridCells</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
plot(possummask)
plotMaskEdge (possummask, add = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='pmixProfileLL'>Mixture Model Check</h2><span id='topic+pmixProfileLL'></span>

<h3>Description</h3>

<p>Compute the profile likelihood of a finite mixture model for a
user-specified range of values for the mixing parameter. This provides a
check on multimodality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pmixProfileLL(CH, model = list(g0 ~ h2, sigma ~ h2), CL = TRUE, pmvals = seq(0.01,
 0.99, 0.01), pmi = 5, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmixProfileLL_+3A_ch">CH</code></td>
<td>
<p>capthist object</p>
</td></tr>
<tr><td><code id="pmixProfileLL_+3A_model">model</code></td>
<td>
<p>model as in <code><a href="#topic+secr.fit">secr.fit</a></code></p>
</td></tr>
<tr><td><code id="pmixProfileLL_+3A_cl">CL</code></td>
<td>
<p>logical as in in <code><a href="#topic+secr.fit">secr.fit</a></code></p>
</td></tr>
<tr><td><code id="pmixProfileLL_+3A_pmvals">pmvals</code></td>
<td>
<p>numeric vector of values for mixing parameter &lsquo;pmix&rsquo;</p>
</td></tr>
<tr><td><code id="pmixProfileLL_+3A_pmi">pmi</code></td>
<td>
<p>integer index of &lsquo;pmix&rsquo; in vector of coefficients (beta
parameters) for the specified model</p>
</td></tr>
<tr><td><code id="pmixProfileLL_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+secr.fit">secr.fit</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://www.otago.ac.nz/density/pdfs/secr-finitemixtures.pdf">secr-finitemixtures.pdf</a>.
</p>
<p>Choosing the wrong value for pmi results in the error message &quot;invalid fixed beta - require NP-vector&quot;. The easiest way to find the value of <code>pmi</code> is to inspect the
output from a previously fitted mixture model - either count the coefficients
or check fit$parindx$pmix (for a model named &lsquo;fit&rsquo;). It is assumed that &lsquo;pmix&rsquo; is the last real
parameter in the model, and that pmix is constant.
</p>


<h3>Value</h3>

<p>Numeric vector of profile likelihoods.
</p>


<h3>Note</h3>

<p>This is slow to execute and the results are hard to interpret. Use
only if you are confident.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

pmvals &lt;- seq(0.02,0.99,0.02)
mask &lt;- make.mask(traps(ovenCH[[1]]), nx = 32, buffer = 100)

## only g0 ~ h2, so reduce pmi from 5 to 4
outPL &lt;- pmixProfileLL(ovenCH[[1]], model = list(g0~h2), 
    mask = mask, pmvals, CL = TRUE, trace = FALSE, pmi = 4) 
    
plot(pmvals, outPL, xlim = c(0,1),
xlab = 'Fixed pmix', ylab = 'Profile log-likelihood')


## End(Not run)
</code></pre>

<hr>
<h2 id='pointsInPolygon'>Points Inside Polygon</h2><span id='topic+pointsInPolygon'></span>

<h3>Description</h3>

<p>Determines which of a set of  points lie inside a closed polygon or at
least one of a set of polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsInPolygon(xy, poly, logical = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsInPolygon_+3A_xy">xy</code></td>
<td>
<p>2-column matrix or dataframe of x-y coordinates for points to assess</p>
</td></tr>
<tr><td><code id="pointsInPolygon_+3A_poly">poly</code></td>
<td>
<p>2-column matrix or dataframe containing perimeter points of polygon, or
a SpatialPolygonsDataFrame object from package <span class="pkg">sp</span>, or a &lsquo;mask&rsquo;
object (see Warning)</p>
</td></tr>
<tr><td><code id="pointsInPolygon_+3A_logical">logical</code></td>
<td>
<p>logical to control the output when &lsquo;poly&rsquo; is a mask
(see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>poly</code> is a SpatialPolygonsDataFrame object then the method
<code>over</code> is used from <span class="pkg">sp</span>. This allows multiple polygons and
polygons with holes.
</p>
<p>If <code>poly</code> is an secr &lsquo;mask&rsquo; object then <code>xy</code> is discretized
and matched to the cells in <code>poly</code>. If <code>logical = FALSE</code>
then the returned value is a vector of integer indices to the row in
&lsquo;poly&rsquo; corresponding to each row of &lsquo;xy&rsquo;; otherwise the result is a
vector of logical values.
</p>
<p>Otherwise, the algorithm is adapted from some code posted on the S-news list
by Peter Perkins (23/7/1996). The polygon should be closed (last point
same as first).
</p>


<h3>Value</h3>

<p>Vector of logical or integer values, one for each row in <code>xy</code>
</p>


<h3>Warning</h3>

<p>If <code>poly</code> is a mask object then its cells must be
aligned to the x- and y- axes</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+over">over</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 100 random points in unit square
xy &lt;- matrix(runif(200), ncol = 2)
## triangle centred on (0.5, 0.5)
poly &lt;- data.frame(x = c(0.2,0.5,0.8,0.2), y = c(0.2,0.8,0.2,0.2))
plot(xy, pch = 1 + pointsInPolygon(xy, poly))
lines(poly)

</code></pre>

<hr>
<h2 id='polyarea'>
Area of Polygon(s)
</h2><span id='topic+polyarea'></span>

<h3>Description</h3>

<p>Area of a single closed polygon (simple x-y coordinate input) or of
multiple polygons, possibly with holes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyarea(xy, ha = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyarea_+3A_xy">xy</code></td>
<td>
<p>dataframe or list with components &lsquo;x&rsquo; and &lsquo;y&rsquo;, or a
SpatialPolygons or SpatialPolygonsDataFrame object from package <span class="pkg">sp</span>, or an <span class="pkg">sf</span> object with polygon data</p>
</td></tr>
<tr><td><code id="polyarea_+3A_ha">ha</code></td>
<td>
<p>logical if TRUE output is converted from square metres to hectares</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For sf, sfc, SpatialPolygons or SpatialPolygonsDataFrame objects, the package <span class="pkg">sf</span> is used.
</p>


<h3>Value</h3>

<p>A scalar.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buffer.contour">buffer.contour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>polyarea(make.grid(hollow = TRUE))
</code></pre>

<hr>
<h2 id='popn'> Population Object </h2><span id='topic+popn'></span>

<h3>Description</h3>

<p>Encapsulate the locations of a set of individual animals.
</p>


<h3>Details</h3>

<p>An object of class <code>popn</code> records the locations of a set of
individuals, together with ancillary data such as their sex.  Often used
for a realisation of a spatial point process (e.g. homogeneous Poisson)
with known density (intensity).  Locations are stored in a data frame
with columns &lsquo;x&rsquo; and &lsquo;y&rsquo;.
</p>
<p>A <code>popn</code> object has attributes
</p>

<table>
<tr>
 <td style="text-align: left;">
covariates </td><td style="text-align: left;"> data frame with numeric, factor or character variables to be used as individual covariates </td>
</tr>
<tr>
 <td style="text-align: left;">
model2D    </td><td style="text-align: left;"> 2-D distribution ("poisson", "cluster", "IHP", "linear" etc.) </td>
</tr>
<tr>
 <td style="text-align: left;">
Ndist      </td><td style="text-align: left;"> distribution of number of individuals ("poisson", "fixed") </td>
</tr>
<tr>
 <td style="text-align: left;">
boundingbox </td><td style="text-align: left;"> data frame of 4 rows, the vertices of the rectangular area </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The number of rows in <code>covariates</code> must match the length of
<code>x</code> and <code>y</code>. See <code><a href="#topic+sim.popn">sim.popn</a></code> for more information
on <code>Ndist</code> and <code>model2D</code>.
</p>


<h3>Note</h3>

<p> The <code>popn</code> class is used only occasionally: it is not central to spatially explicit capture recapture. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.popn">sim.popn</a></code>, <code><a href="#topic+plot.popn">plot.popn</a></code>, <code><a href="#topic+transformations">transformations</a></code> </p>

<hr>
<h2 id='possum'> Brushtail Possum Trapping Dataset </h2><span id='topic+possum'></span><span id='topic+possumCH'></span><span id='topic+possumarea'></span><span id='topic+possumremovalarea'></span><span id='topic+possummask'></span><span id='topic+possum.model.0'></span><span id='topic+possum.model.Ds'></span>

<h3>Description</h3>

<p>Data from a trapping study of brushtail possums at Waitarere, North
Island, New Zealand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
possumCH
possumarea
possumremovalarea
possummask
possum.model.0
possum.model.Ds

</code></pre>


<h3>Details</h3>

<p>Brushtail possums (<em>Trichosurus vulpecula</em>) are an unwanted
invasive species in New Zealand.  Although most abundant in forests,
where they occasionally exceed densities of 15 / ha, possums live
wherever there are palatable food plants and shelter.
</p>
<p>Efford et al. (2005) reported a live-trapping study of possums in
<em>Pinus radiata</em> plantation on coastal sand dunes.  The 300-ha site
at Waitarere in the North Island of New Zealand was a peninsula, bounded
on one side by the sea and on two other sides by the Manawatu river. 
Cage traps were set in groups of 36 at 20-m spacing around the perimeter
of five squares, each 180 m on a side.  The squares (&lsquo;hollow grids&rsquo;) were
centred at random points within the 300-ha area.  Animals were tagged and
released daily for 5 days in April 2002.  Subsequently, leg-hold trapping
was conducted on a trapping web centred on each square (data not
reported here), and strenuous efforts were made to remove all possums by
cyanide poisoning and further leghold trapping across the entire area. 
This yielded a density estimate of 2.26 possums / ha.
</p>
<p>Traps could catch at most one animal per day.  The live-trapped animals
comprised 46 adult females, 33 adult males, 10 immature females and 11
immature males; sex and/or age were not recorded for 4 individuals (M.
Coleman unpubl. data). These counts do not sum to the number of capture
histories - see Note.  One female possum was twice captured at two sites
on one day, having entered a second trap after being released; one
record in each pair was selected arbitrarily and discarded.
</p>
<p>The data are provided as a single-session <code>capthist</code> object
&lsquo;possumCH&rsquo;.  &lsquo;possummask&rsquo; is a matching mask object - see Examples.
Two fitted models are provided for illustration.
</p>
<p>The dataframe <code>possumarea</code> contains boundary coordinates of a
habitat polygon that is used to clip <code>possummask</code> at the shore
(from secr 1.5). <code>possumarea</code> comprises a single polygon
representing the extent of terrestrial vegetation to the west, north and
east, and an arbitrary straight southern boundary. The boundary is also
included as a shapefile and as a text file (&lsquo;possumarea.shp&rsquo; etc. and
&lsquo;possumarea.txt&rsquo; in the package &lsquo;extdata&rsquo; folder). See Examples in
<code><a href="#topic+make.mask">make.mask</a></code>.
</p>
<p>The dataframe <code>possumremovalarea</code> contains boundary coordinates of
another polygon, the nominal removal area of Efford et al. (2005 Fig. 1)
(from secr 2.3).
</p>

<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
  possumCH </td><td style="text-align: left;"> capthist object </td>
</tr>
<tr>
 <td style="text-align: left;">
  possummask </td><td style="text-align: left;"> mask object </td>
</tr>
<tr>
 <td style="text-align: left;">
  possumarea </td><td style="text-align: left;"> habitat perimeter </td>
</tr>
<tr>
 <td style="text-align: left;">
  possumremovalarea </td><td style="text-align: left;"> nominal boundary of removal region </td>
</tr>
<tr>
 <td style="text-align: left;">
  possum.model.0 </td><td style="text-align: left;"> fitted secr model -- null </td>
</tr>
<tr>
 <td style="text-align: left;">
  possum.model.Ds </td><td style="text-align: left;"> fitted secr model -- distance to shore </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>A significant problem with the data used by Efford et al. (2005) was
noticed recently. Five capture histories in possumCH are for animals
that had lost a previous tag. A further three histories may also have
been animals that were tagged previously or mis-recorded. Analyses that
treat each previously tagged animal as a new individual are in error
(this includes the published analyses, the pre-fitted models described
here, and those in the vignette secr-densitysurfaces.pdf). All eight
questionable histories are now indicated in possumCH with the logical
covariate &lsquo;prev.tagged&rsquo;.
</p>
<p>Methods have not yet been developed to adjust for tag loss in SECR
models. 
</p>


<h3>Source</h3>

<p>Landcare Research, New Zealand.
</p>


<h3>References</h3>

<p>Borchers, D.L. and Efford, M.G. (2008) Spatially explicit maximum
likelihood methods for capture-recapture studies. <em>Biometrics</em> <b>64</b>,
377&ndash;385.
</p>
<p>Efford, M. G., Dawson, D. K. and Robbins C. S. (2004) DENSITY: software
for analysing capture-recapture data from passive detector arrays.
<em>Animal Biodiversity and Conservation</em> <b>27</b>, 217&ndash;228. 
</p>
<p>Efford, M. G., Warburton, B., Coleman, M. C. and Barker, R. J. (2005) A
field test of two methods for density estimation. <em>Wildlife Society
Bulletin</em> <b>33</b>, 731&ndash;738.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(possummask)
plot(possumCH, tracks = TRUE, add = TRUE)
plot(traps(possumCH), add = TRUE)
lines(possumarea)
summary(possumCH)

## compare &amp; average pre-fitted models
AIC(possum.model.0, possum.model.Ds)
modelAverage(possum.model.0, possum.model.Ds)

## Not run: 

## Roughly estimate tag-loss error by dropping dubious histories
## i.e. restrict to "not previously tagged"
NPT &lt;- !covariates(possumCH)$prev.tagged
possum.model.0.NPT &lt;- secr.fit(subset(possumCH,NPT), mask =
    possummask, trace = FALSE)
predict(possum.model.0)[1,2]/ predict(possum.model.0.NPT)[1,2]
## ...about 9%

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.secr'> SECR Model Predictions </h2><span id='topic+predict.secr'></span><span id='topic+predict.secrlist'></span><span id='topic+detectpar'></span><span id='topic+detectpar.secr'></span>

<h3>Description</h3>

<p>Evaluate a spatially explicit capture&ndash;recapture model. That is, compute the &lsquo;real&rsquo; parameters corresponding to the &lsquo;beta&rsquo; parameters of a fitted model for arbitrary levels of any variables in the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secr'
predict(object, newdata = NULL, realnames = NULL, type = c("response", "link"), 
    se.fit = TRUE, alpha = 0.05, savenew = FALSE, ...)

## S3 method for class 'secrlist'
predict(object, newdata = NULL, realnames = NULL, type = c("response", "link"),
    se.fit = TRUE, alpha = 0.05, savenew = FALSE, ...)

## S3 method for class 'secr'
detectpar(object, ..., byclass = FALSE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.secr_+3A_object">object</code></td>
<td>
 <p><code>secr</code> object output from <code>secr.fit</code>, or list
of <code>secr</code> objects (secrlist) </p>
</td></tr>
<tr><td><code id="predict.secr_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate model </p>
</td></tr>
<tr><td><code id="predict.secr_+3A_realnames">realnames</code></td>
<td>
<p> character vector of real parameter names </p>
</td></tr>
<tr><td><code id="predict.secr_+3A_type">type</code></td>
<td>
<p> character; type of prediction required. The default (&quot;response&quot;) provides estimates of the &lsquo;real&rsquo; parameters.</p>
</td></tr> 
<tr><td><code id="predict.secr_+3A_se.fit">se.fit</code></td>
<td>
<p> logical for whether output should include SE and confidence intervals </p>
</td></tr>
<tr><td><code id="predict.secr_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="predict.secr_+3A_savenew">savenew</code></td>
<td>
<p> logical for whether newdata should be saved </p>
</td></tr>
<tr><td><code id="predict.secr_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code><a href="#topic+makeNewData">makeNewData</a></code> </p>
</td></tr>
<tr><td><code id="predict.secr_+3A_byclass">byclass</code></td>
<td>
<p> logical; if TRUE values are returned for each latent
class in a mixture model, or class in a hybrid mixture (hcov) model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variables in the various linear predictors are described in
<a href="https://www.otago.ac.nz/density/pdfs/secr-models.pdf">secr-models.pdf</a> and listed for the particular model in the
<code>vars</code> component of <code>object</code>.
</p>
<p>Optional <code>newdata</code> should be a dataframe with a column for each of
the variables in the model (see &lsquo;vars&rsquo; component of <code>object</code>).  If
<code>newdata</code> is missing then a dataframe is constructed automatically.
</p>
<p>Default <code>newdata</code> are for a naive animal on the first occasion;
numeric covariates are set to zero and factor covariates to their base
(first) level. From secr 3.1.4 the argument &lsquo;all.levels&rsquo; may be passed 
to <code><a href="#topic+makeNewData">makeNewData</a></code>; if TRUE then the default newdata includes 
all factor levels.
</p>
<p><code>realnames</code> may be used to select a subset of parameters.
</p>
<p>Standard errors for parameters on the response (real) scale are by the
delta method (Lebreton et al. 1992), and confidence intervals are
backtransformed from the link scale. 
</p>
<p>The value of <code>newdata</code> is optionally saved as an attribute.
</p>
<p><code>detectpar</code> is used to extract the detection parameter estimates
from a simple model to pass to functions such as
<code>esa.plot</code>. <code>detectpar</code> calls <code>predict.secr</code>. Parameters
will be evaluated by default at base levels of the covariates, although
this may be overcome by passing a one-line <code>newdata</code> to
<code>predict</code> via the ... argument. Groups and mixtures are a
headache for <code>detectpar</code>: it merely returns the estimated detection
parameters of the first group or mixture.
</p>
<p>If the &lsquo;a0&rsquo; parameterization has been used in <code>secr.fit</code> (i.e.,
<code>object$details$param == 3</code>) then <code>detectpar</code> automatically
backtransforms (a0, sigma) to (g0, sigma) or (lambda0, sigma) depending
on the value of <code>object$detectfn</code>.
</p>


<h3>Value</h3>

<p>When <code>se.fit</code> = FALSE, a dataframe identical to <code>newdata</code> except for the addition of one column for each &lsquo;real&rsquo; parameter. Otherwise, a list with one component for each row in <code>newdata</code>. Each component is a dataframe with one row for each &lsquo;real&rsquo; parameter (density, g0, sigma, b) and columns as below
</p>

<table>
<tr>
 <td style="text-align: left;">
link        </td><td style="text-align: left;"> link function </td>
</tr>
<tr>
 <td style="text-align: left;"> 
estimate    </td><td style="text-align: left;"> estimate of real parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
SE.estimate </td><td style="text-align: left;"> standard error of the estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
lcl         </td><td style="text-align: left;"> lower 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
ucl         </td><td style="text-align: left;"> upper 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When <code>newdata</code> has only one row, the structure of the list is
&lsquo;dissolved&rsquo; and the return value is one data frame.
</p>
<p>For <code>detectpar</code>, a list with the estimated values of detection
parameters (e.g., g0 and sigma if detectfn = &quot;halfnormal&quot;). In the case
of multi-session data the result is a list of lists (one list per
session).
</p>


<h3>Note</h3>

<p><code><a href="#topic+predictDsurface">predictDsurface</a></code> should be used for predicting density at many
points from a model with spatial variation. This deals automatically
with scaling of x- and y-coordinates, and is much is faster than
predict.secr. The resulting Dsurface object has its own plot method.
</p>
<p>The argument &lsquo;scaled&rsquo; was removed from both predict methods in version 2.10 as the scaleg0 and scalesigma features had been superceded by other parameterisations.
</p>
<p>Overdispersion results in confidence intervals that are too narrow. See <code><a href="#topic+adjustVarD">adjustVarD</a></code> for a partial solution.
</p>


<h3>References</h3>

 
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J. and Anderson, D. R. (1992) Modeling survival and testing biological hypotheses using marked animals: a unified approach with case studies. <em>Ecological Monographs</em> <b>62</b>, 67&ndash;118. </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+secr.fit">secr.fit</a></code>, 
<code><a href="#topic+predictDsurface">predictDsurface</a></code>,  
<code><a href="#topic+adjustVarD">adjustVarD</a></code>, 
<code><a href="#topic+makeNewData">makeNewData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load previously fitted secr model with trap response
## and extract estimates of `real' parameters for both
## naive (b = 0) and previously captured (b = 1) animals

predict (secrdemo.b, newdata = data.frame(b = 0:1))

## OR from secr 3.1.4 
predict (secrdemo.b, all.levels = TRUE)

temp &lt;- predict (secrdemo.b, all.levels = TRUE, save = TRUE)
attr(temp, "newdata")

detectpar(secrdemo.0)
</code></pre>

<hr>
<h2 id='predictDsurface'> Predict Density Surface </h2><span id='topic+predictDsurface'></span>

<h3>Description</h3>

<p>Predict density at each point on a raster mask from a fitted secr model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictDsurface(object, mask = NULL, se.D = FALSE, cl.D = FALSE, alpha =
0.05, parameter = c('D', 'noneuc'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictDsurface_+3A_object">object</code></td>
<td>
<p>fitted secr object</p>
</td></tr>
<tr><td><code id="predictDsurface_+3A_mask">mask</code></td>
<td>
<p>secr mask object</p>
</td></tr>
<tr><td><code id="predictDsurface_+3A_se.d">se.D</code></td>
<td>
<p> logical for whether to compute prediction SE</p>
</td></tr>
<tr><td><code id="predictDsurface_+3A_cl.d">cl.D</code></td>
<td>
<p> logical for whether to compute confidence limits</p>
</td></tr>
<tr><td><code id="predictDsurface_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for 100(1 &ndash; alpha)% confidence intervals </p>
</td></tr>
<tr><td><code id="predictDsurface_+3A_parameter">parameter</code></td>
<td>
<p> character for real parameter to predict</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions use the linear model for density on the link scale in the
fitted secr model &lsquo;object&rsquo;, or the fitted user-defined function, if
that was specified in <code>secr.fit</code>.
</p>
<p>If &lsquo;mask&rsquo; is NULL then predictions are for the mask component of
&lsquo;object&rsquo;.
</p>
<p>SE and confidence limits are computed only if specifically
requested. They are not available for user-defined density functions.
</p>
<p>Density is adjusted automatically for the number of clusters in
&lsquo;mashed&rsquo; models (see <code><a href="#topic+mash">mash</a></code>).
</p>


<h3>Value</h3>

<p>Object of class &lsquo;Dsurface&rsquo; inheriting from &lsquo;mask&rsquo;. Predicted densities
are added to the covariate dataframe (attribute &lsquo;covariates&rsquo;) as
column(s) with prefix &lsquo;D.&rsquo; If the model uses multiple groups, multiple
columns will be distinguished by the group name (e.g., &quot;D.F&quot; and
&quot;D.M&quot;). If groups are not defined the column is named &quot;D.0&quot;.
</p>
<p>For multi-session models the value is a multi-session mask.
</p>
<p>The pointwise prediction SE is saved as a covariate column prefixed
&lsquo;SE.&rsquo; (or multiple columns if multiple groups). Confidence limits are
likewise saved with prefixes &lsquo;lcl.&rsquo;  and &lsquo;ucl.&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.Dsurface">plot.Dsurface</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+predict.secr">predict.secr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## use canned possum model
shorePossums &lt;- predictDsurface(possum.model.Ds)
par(mar = c(1,1,1,6))
plot(shorePossums, plottype = "shaded", polycol = "blue", border = 100)
plot(traps(possumCH), detpar = list(col = "black"), add = TRUE)
par(mar = c(5,4,4,2) + 0.1)  ## reset to default
## extract and summarise
summary(covariates(shorePossums))

## Not run: 

## extrapolate to a new mask; add covariate needed by model; plot
regionmask &lt;- make.mask(traps(possumCH), buffer = 1000, spacing = 10,
    poly = possumremovalarea)
dts &lt;- distancetotrap(regionmask, possumarea)
covariates(regionmask) &lt;- data.frame(d.to.shore = dts)
regionPossums &lt;- predictDsurface(possum.model.Ds, regionmask,
    se.D = TRUE, cl.D = TRUE)
par(mfrow = c(1,2), mar = c(1,1,1,6))
plot(regionPossums, plottype = "shaded", mesh = NA, breaks = 20)
plot(regionPossums, plottype = "contour", add = TRUE)
plot(regionPossums, covariate = "SE", plottype = "shaded",
    mesh = NA, breaks = 20)
plot(regionPossums, covariate = "SE", plottype = "contour",
    add = TRUE)

## confidence surfaces
plot(regionPossums, covariate = "lcl", breaks = seq(0,3,0.2),
    plottype = "shaded")
plot(regionPossums, covariate = "lcl", plottype = "contour",
    add = TRUE, levels = seq(0,2.7,0.2))
title("lower 95% surface")
plot(regionPossums, covariate = "ucl", breaks=seq(0,3,0.2),
    plottype = "shaded")
plot(regionPossums, covariate = "ucl", plottype = "contour",
    add = TRUE, levels = seq(0,2.7,0.2))
title("upper 95% surface")

## annotate with CI
par(mfrow = c(1,1))
plot(regionPossums, plottype = "shaded", mesh = NA, breaks = 20)
plot(traps(possumCH), add = TRUE, detpar = list(col = "black"))

if (interactive()) {
    spotHeight(regionPossums, dec = 1, pre = c("lcl","ucl"), cex = 0.8)
}

## perspective plot
pm &lt;- plot(regionPossums, plottype = "persp", box = FALSE, zlim =
    c(0,3), phi=30, d = 5, col = "green", shade = 0.75, border = NA)
lines(trans3d (possumremovalarea$x, possumremovalarea$y,
     rep(1,nrow(possumremovalarea)), pmat = pm))

par(mfrow = c(1,1), mar = c(5, 4, 4, 2) + 0.1)  ## reset to default

## compare estimates of region N
## grid cell area is 0.01 ha
sum(covariates(regionPossums)[,"D.0"]) * 0.01
region.N(possum.model.Ds, regionmask)


## End(Not run)

</code></pre>

<hr>
<h2 id='print.capthist'> Print Detections </h2><span id='topic+print.capthist'></span>

<h3>Description</h3>

<p>Print method for <code>capthist</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'capthist'
print(x, ..., condense = FALSE, sortrows = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.capthist_+3A_x">x</code></td>
<td>
 <p><code>capthist</code> object </p>
</td></tr>
<tr><td><code id="print.capthist_+3A_...">...</code></td>
<td>
<p> arguments to pass to <code><a href="base.html#topic+print.default">print.default</a></code> </p>
</td></tr>
<tr><td><code id="print.capthist_+3A_condense">condense</code></td>
<td>
<p> logical, if true then use condensed format for 3-D data </p>
</td></tr>
<tr><td><code id="print.capthist_+3A_sortrows">sortrows</code></td>
<td>
<p> logical, if true then sort output by animal </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>condense</code> option may be used to format data from proximity
detectors in a slightly more readable form. Each row then presents the
detections of an individual in a particular trap, dropping rows (traps)
at which the particular animal was not detected.
</p>


<h3>Value</h3>

<p>Invisibly returns a dataframe (condense = TRUE) or array in the format printed.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+capthist">capthist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated detections of simulated default population of 5/ha
print(sim.capthist(make.grid(nx=5,ny=3)))
</code></pre>

<hr>
<h2 id='print.secr'> Print or Summarise secr Object </h2><span id='topic+print.secr'></span><span id='topic+summary.secr'></span>

<h3>Description</h3>

<p>Print results from fitting a spatially explicit capture&ndash;recapture model or
generate a list of summary values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'secr'
 print(x, newdata = NULL, alpha = 0.05, deriv = FALSE, call = TRUE, ...)
## S3 method for class 'secr'
 summary(object, newdata = NULL, alpha = 0.05, deriv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.secr_+3A_x">x</code></td>
<td>
 <p><code>secr</code> object output from <code>secr.fit</code> </p>
</td></tr>
<tr><td><code id="print.secr_+3A_object">object</code></td>
<td>
 <p><code>secr</code> object output from <code>secr.fit</code> </p>
</td></tr>
<tr><td><code id="print.secr_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate model </p>
</td></tr>
<tr><td><code id="print.secr_+3A_alpha">alpha</code></td>
<td>
<p> alpha level </p>
</td></tr>
<tr><td><code id="print.secr_+3A_deriv">deriv</code></td>
<td>
<p> logical for calculation of derived D and esa </p>
</td></tr>
<tr><td><code id="print.secr_+3A_call">call</code></td>
<td>
<p> logical; if TRUE the call is printed </p>
</td></tr>
<tr><td><code id="print.secr_+3A_...">...</code></td>
<td>
<p> other arguments optionally passed to derived.secr </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Results from <code>print.secr</code> are potentially complex and depend upon the analysis (see
below). Optional <code>newdata</code> should be a dataframe with a column for
each of the variables in the model. If <code>newdata</code> is missing then a
dataframe is constructed automatically.  Default <code>newdata</code> are for
a naive animal on the first occasion; numeric covariates are set to zero
and factor covariates to their base (first) level. Confidence intervals
are 100 (1 &ndash; alpha) % intervals.
</p>

<table>
<tr>
 <td style="text-align: left;">
call            </td><td style="text-align: left;"> the function call (optional) </td>
</tr>
<tr>
 <td style="text-align: left;">
version,time    </td><td style="text-align: left;"> secr version, date and time fitting started, and elapsed time </td>
</tr>
<tr>
 <td style="text-align: left;">

Detector type   </td><td style="text-align: left;"> `single', `multi', `proximity' etc. </td>
</tr>
<tr>
 <td style="text-align: left;">
Detector number </td><td style="text-align: left;"> number of detectors </td>
</tr>
<tr>
 <td style="text-align: left;">
Average spacing </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
x-range         </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
y-range         </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
New detector type </td><td style="text-align: left;"> as fitted when details$newdetector specified </td>
</tr>
<tr>
 <td style="text-align: left;">
N animals       </td><td style="text-align: left;"> number of distinct animals detected </td>
</tr>
<tr>
 <td style="text-align: left;">
N detections    </td><td style="text-align: left;"> number of detections </td>
</tr>
<tr>
 <td style="text-align: left;">
N occasions     </td><td style="text-align: left;"> number of sampling occasions </td>
</tr>
<tr>
 <td style="text-align: left;">
Mask area       </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

Model          </td><td style="text-align: left;"> model formula for each `real' parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
Fixed (real)   </td><td style="text-align: left;"> fixed real parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
Detection fn   </td><td style="text-align: left;"> detection function type (halfnormal or hazard-rate) </td>
</tr>
<tr>
 <td style="text-align: left;">
N parameters   </td><td style="text-align: left;"> number of parameters estimated  </td>
</tr>
<tr>
 <td style="text-align: left;">
Log likelihood </td><td style="text-align: left;"> log likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
AIC            </td><td style="text-align: left;"> Akaike's information criterion </td>
</tr>
<tr>
 <td style="text-align: left;">
AICc           </td><td style="text-align: left;"> AIC with small sample adjustment (Burnham and Anderson 2002) </td>
</tr>
<tr>
 <td style="text-align: left;">
Beta parameters </td><td style="text-align: left;"> coef of the fitted model, SE and confidence intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
vcov            </td><td style="text-align: left;"> variance-covariance matrix of beta parameters  </td>
</tr>
<tr>
 <td style="text-align: left;">
Real parameters </td><td style="text-align: left;"> fitted (real) parameters evaluated at base levels of covariates </td>
</tr>
<tr>
 <td style="text-align: left;">
Derived parameters </td><td style="text-align: left;"> derived estimates of density and mean effective sampling area (optional) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Derived parameters (see <code><a href="#topic+derived">derived</a></code>) are computed only if
<code>deriv = TRUE</code>.
</p>


<h3>Value</h3>

<p>The <code>summary</code> method constructs a list of outputs similar to those printed by the <code>print</code> method, but somewhat more concise and re-usable:
</p>

<table>
<tr>
 <td style="text-align: left;">
versiontime     </td><td style="text-align: left;"> secr version, and date and time fitting started </td>
</tr>
<tr>
 <td style="text-align: left;">

traps           </td><td style="text-align: left;"> detector summary </td>
</tr>
<tr>
 <td style="text-align: left;">
capthist        </td><td style="text-align: left;"> capthist summary </td>
</tr>
<tr>
 <td style="text-align: left;">
mask            </td><td style="text-align: left;"> mask summary </td>
</tr>
<tr>
 <td style="text-align: left;">
modeldetails    </td><td style="text-align: left;"> miscellaneous model characteristics (CL etc.) </td>
</tr>
<tr>
 <td style="text-align: left;">
AICtable        </td><td style="text-align: left;"> single-line output of AIC.secr </td>
</tr>
<tr>
 <td style="text-align: left;">
coef            </td><td style="text-align: left;"> table of fitted coefficients with CI </td>
</tr>
<tr>
 <td style="text-align: left;">
predicted       </td><td style="text-align: left;"> predicted values (`real' parameter estimates) </td>
</tr>
<tr>
 <td style="text-align: left;">
derived         </td><td style="text-align: left;"> output of derived.secr (optional) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

 
<p>Burnham, K. P. and Anderson, D. R. (2002) <em>Model selection and multimodel inference: a practical information-theoretic approach</em>. Second edition. New York: Springer-Verlag.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+AIC.secr">AIC.secr</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load &amp; print previously fitted null (constant parameter) model
print(secrdemo.0)

summary(secrdemo.0)

## combine AIC tables from list of summaries
do.call(AIC, lapply(list(secrdemo.b, secrdemo.0), summary))

## Not run: 

print(secrdemo.CL, deriv = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='print.traps'> Print Detectors </h2><span id='topic+print.traps'></span>

<h3>Description</h3>

<p>Print method for <code>traps</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traps'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.traps_+3A_x">x</code></td>
<td>
 <p><code>traps</code> object </p>
</td></tr>
<tr><td><code id="print.traps_+3A_...">...</code></td>
<td>
<p> arguments to pass to <code><a href="base.html#topic+print.default">print.default</a></code> </p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+traps">traps</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>print(make.grid(nx = 5, ny = 3))
</code></pre>

<hr>
<h2 id='randomHabitat'>Random Landscape</h2><span id='topic+randomHabitat'></span><span id='topic+randomDensity'></span>

<h3>Description</h3>

<p>The Modified Random Cluster algorithm of Saura and Martinez-Millan
(2000) is used to generate a mask object representing patches of
contiguous &lsquo;habitat&rsquo; cells (pixels) within a &lsquo;non-habitat&rsquo;
matrix (&lsquo;non-habitat&rsquo; cells are optionally dropped). Spatial autocorrelation
(fragmentation) of habitat patches is controlled via the parameter
&lsquo;p&rsquo;. &lsquo;A&rsquo; is the expected proportion of &lsquo;habitat&rsquo; cells.
</p>
<p><code>randomDensity</code> is a wrapper for <code>randomHabitat</code> that may be used as input to <code><a href="#topic+sim.popn">sim.popn</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
randomHabitat(mask, p = 0.5, A = 0.5, directions = 4, minpatch = 1,
drop = TRUE, covname = "habitat", plt = FALSE, seed = NULL)

randomDensity(mask, parm)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomHabitat_+3A_mask">mask</code></td>
<td>
<p>secr mask object to use as template</p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_p">p</code></td>
<td>
<p>parameter to control fragmentation</p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_a">A</code></td>
<td>
<p>parameter for expected proportion of habitat</p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_directions">directions</code></td>
<td>
<p>integer code for adjacency (rook's move 4 or queen's move 8)</p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_minpatch">minpatch</code></td>
<td>
<p>integer minimum size of patch</p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_drop">drop</code></td>
<td>
<p>logical for whether to drop non-habitat cells</p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_covname">covname</code></td>
<td>
<p>character name of covariate when <code>drop = FALSE</code></p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_plt">plt</code></td>
<td>
<p>logical for whether intermediate stages should be plotted</p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_seed">seed</code></td>
<td>
<p>either NULL or an integer that will be used in a call to <code>set.seed</code></p>
</td></tr>
<tr><td><code id="randomHabitat_+3A_parm">parm</code></td>
<td>
<p>list of arguments for <code>randomHabitat</code>, with added argument D</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Habitat is simulated within the region defined by the cells of
<a href="#topic+mask">mask</a>. The region may be non-rectangular.
</p>
<p>The algorithm comprises stages A-D:
</p>
<p>A. Randomly select proportion <code>p</code> of cells from the input mask
</p>
<p>B. Cluster selected cells with any immediate neighbours as defined by
<code>directions</code>
</p>
<p>C. Assign clusters to &lsquo;non-habitat&rsquo; (probability 1&ndash;A) and &lsquo;habitat&rsquo;
(probability A)
</p>
<p>D. Cells not in any cluster from (B) receive the habitat class of the
majority of the &lt;=8 adjacent cells assigned in (C), if there are any;
otherwise they are assigned at random (with probabilities 1&ndash;A, A).
</p>
<p>Fragmentation declines, and cluster size increases, as p increases up to the
&lsquo;percolation threshold&rsquo; which is about 0.59 in the default case (Saura
and Martinez-Millan 2000 p.664).
</p>
<p>If <code>minpatch &gt; 1</code> then habitat patches of less than <code>minpatch</code>
cells are converted to non-habitat, and vice versa. This is likely to
cause the proportion of habitat to deviate from <code>A</code>.
</p>
<p>If <code>drop = FALSE</code> a binary-valued (0/1) covariate with the
requested name is included in the output mask, which has the same extent
as the input. Otherwise, non-habitat cells are dropped and no covariate
is added.
</p>
<p>The argument &lsquo;parm&rsquo; for <code>randomDensity</code> is a list with average density D and an optional subset of named values to override the defaults (p = 0.5, A = 0.5, directions = 4, minpatch = 1, plt = FALSE, seed = NULL). &lsquo;rescale&rsquo; is a further optional component of &lsquo;parm&rsquo;; if &lsquo;rescale = TRUE&rsquo; then the pixel-specific densities are adjusted upwards by the factor 1/A to maintain the same expected number of activity centres as if the nominal density applied throughout. Arguments &lsquo;mask&rsquo; and &lsquo;drop&rsquo; of <code>randomHabitat</code> are substituted automatically.  
</p>


<h3>Value</h3>

<p>For randomHabitat &ndash;
</p>
<p>An object of class &lsquo;mask&rsquo;. By default (<code>drop = TRUE</code>) this
has fewer rows (points) than the input mask.
</p>
<p>The attribute &ldquo;type&rdquo; is a character string formed from <code>paste('MRC p=',p, ' A=',A, sep='')</code>.
</p>
<p>The <a href="base.html#topic+RNG">RNG</a> seed is stored as attribute &lsquo;seed&rsquo; (see <a href="#topic+secrRNG">secrRNG</a>).
</p>
<p>For randomDensity &ndash;
</p>
<p>A vector of cell-specific densities.
</p>


<h3>Note</h3>

<p>Single-linkage clustering and adjacency operations use functions
&lsquo;clump&rsquo; and &lsquo;adjacency&rsquo; of the package <span class="pkg">raster</span>; &lsquo;clump&rsquo; also
requires package <span class="pkg">igraph0</span> (<span class="pkg">raster</span> still uses this
deprecated version). Optional plotting
of intermediate stages (<code>plt = TRUE</code>) uses the plot method for
rasterLayers in <span class="pkg">raster</span>.
</p>
<p>A non-rectangular input mask is padded out to a rectangular rasterLayer
for operations in <span class="pkg">raster</span>; cells added as padding are ultimately
dropped.
</p>
<p>The procedure of Saura and Martinez-Millan (2000) has been followed as
far as possible, but this implementation may not match theirs in every
detail.
</p>
<p>This implementation allows only two habitat classes. The parameter A is
the <em>expected</em> value of the habitat proportion; the
<em>realised</em> habitat proportion may differ quite strongly from A,
especially for large p (e.g., p &gt; 0.5).
</p>
<p>Anisotropy is not implemented; it would require skewed adjacency
filters (i.e. other than rook- or queen-move filters) that are not
available in <span class="pkg">raster</span>.
</p>
<p>Gaussian random fields provide an alternative method for simulating 
random habitats (e.g., rLGCP option in <code><a href="#topic+sim.popn">sim.popn</a></code>).
</p>


<h3>References</h3>

<p>Hijmans, R. J. and van Etten, J. (2011) raster: Geographic analysis and
modeling with raster data. R package version 1.9-33.
<a href="https://CRAN.R-project.org/package=raster">https://CRAN.R-project.org/package=raster</a>.
</p>
<p>Saura, S. and Martinez-Millan, J. (2000) Landscape patterns simulation
with a modified random clusters method. <em>Landscape Ecology</em>,
<b>15</b>, 661&ndash;678.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+sim.popn">sim.popn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

tempmask &lt;- make.mask(nx = 100, ny = 100, spacing = 20)
mrcmask &lt;- randomHabitat(tempmask, p = 0.4, A = 0.4)
plot(mrcmask, dots = FALSE, col = "green")
pop &lt;- sim.popn(10, mrcmask, model2D = "IHP")
plot(pop, add = TRUE)

# OR
plot(sim.popn(D = randomDensity, core = tempmask, model2D = "IHP",
    details = list(D = 10, p = 0.4, A = 0.4, plt = TRUE)), 
    add = TRUE, frame = FALSE)

## plot intermediate steps A, C, D
opar &lt;- par(mfrow = c(1,3))
mrcmask &lt;- randomHabitat(tempmask, p = 0.4, A = 0.4, plt = TRUE)
par(opar) 

## keep non-habitat cells
mrcmask &lt;- randomHabitat(tempmask, p = 0.4, A = 0.4, drop = FALSE)
plot(mrcmask, covariate = "habitat", dots = FALSE,
    col = c("grey","green"), breaks = 2)

## effect of purging small patches
opar &lt;- par(mfrow=c(1,2))
mrcmask &lt;- randomHabitat(tempmask, p = 0.4, A = 0.4, minpatch = 1)
plot(mrcmask, dots = FALSE, col  ="green")
mrcmask &lt;- randomHabitat(tempmask, p = 0.4, A = 0.4, minpatch = 5)
plot(mrcmask, dots = FALSE, col  ="green")
par(opar)

## End(Not run)

</code></pre>

<hr>
<h2 id='raster'>Create a RasterLayer Object from Mask or Dsurface</h2><span id='topic+raster'></span><span id='topic+raster+2Cmask-method'></span><span id='topic+raster+2CDsurface-method'></span><span id='topic+rast'></span><span id='topic+rast+2Cmask-method'></span><span id='topic+rast+2CDsurface-method'></span>

<h3>Description</h3>

<p>Methods to convert <span class="pkg">secr</span> object to a RasterLayer object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'mask'
raster(x, covariate, values = 1, crs = NA)

## S4 method for signature 'Dsurface'
raster(x, covariate, values = 1, crs = NA)

## S4 method for signature 'mask'
rast(x, covariate, values = 1, crs = "")

## S4 method for signature 'Dsurface'
rast(x, covariate, values = 1, crs = "")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_+3A_x">x</code></td>
<td>
<p>mask or Dsurface object</p>
</td></tr>
<tr><td><code id="raster_+3A_covariate">covariate</code></td>
<td>
<p>character name of covariate to provide values for
RasterLayer</p>
</td></tr>
<tr><td><code id="raster_+3A_values">values</code></td>
<td>
<p>numeric values for RasterLayer</p>
</td></tr>
<tr><td><code id="raster_+3A_crs">crs</code></td>
<td>
<p>character or object of class CRS. Optional PROJ.4 type description of
a Coordinate Reference System (map projection). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to specify the values to be used. If <code>covariate</code> is provided then 
the values of the corresponding covariate of the mask or Dsurface are used. Otherwise, 
<code>values</code> is duplicated to the required number of rows.
</p>
<p>The resulting RasterLayer may optionally include a PROJ.4 map projection
defined via <code>crs</code>. The specification may be very simple (as in the
example below) or complex, including an explicit datum and other
arguments. Projections are used by <span class="pkg">sf</span>, <span class="pkg">terra</span>, <span class="pkg">raster</span>, 
<span class="pkg">sp</span> and other packages. See <code><a href="raster.html#topic+raster">raster</a></code> for 
further explanation and links.
</p>
<p>The S3 classes &lsquo;mask&rsquo; and &lsquo;Dsurface&rsquo; are defined in <span class="pkg">secr</span> as
virtual S4 classes. This enables these extensions to the list of S4
methods defined in <span class="pkg">raster</span>. 
</p>
<p>Although these methods work &lsquo;standalone&rsquo;, it is currently necessary to
load the <span class="pkg">terra</span> or <span class="pkg">raster</span> package to do much with the result (e.g., plot it).
</p>


<h3>Value</h3>

<p>RasterLayer (raster) 
</p>


<h3>Note</h3>

<p>Prior to <span class="pkg">secr</span> 2.9.5 these methods could fail unpredictably
because an intermediate array was badly dimensioned due to truncation of
a floating point value.
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+raster">raster</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

shorePossums &lt;- predictDsurface(possum.model.Ds)
tmp &lt;- raster(shorePossums, covariate = "D.0")
library(raster)
plot(tmp, useRaster = FALSE)

## alternative with same result
tmp &lt;- raster(shorePossums, values = covariates(shorePossums)$D.0)

## set the projection
## here the crs PROJ.4 spec refers simply to the old NZ metric grid
tmp &lt;- raster(shorePossums, "D.0", crs = "+proj=nzmg")
## check the projection
proj4string(tmp)
     

## End(Not run)

</code></pre>

<hr>
<h2 id='rbind.capthist'> Combine capthist Objects </h2><span id='topic+rbind.capthist'></span><span id='topic+MS.capthist'></span>

<h3>Description</h3>

<p>Form a single <code>capthist</code> object from two or more compatible <code>capthist</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  MS.capthist(...)
  
  ## S3 method for class 'capthist'
rbind(..., renumber = TRUE, pool = NULL, verify = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.capthist_+3A_...">...</code></td>
<td>
<p> one or more <code>capthist</code> objects or lists of
<code>capthist</code> objects </p>
</td></tr>
<tr><td><code id="rbind.capthist_+3A_renumber">renumber</code></td>
<td>
<p> logical, if TRUE assigns new composite individual ID </p>
</td></tr>
<tr><td><code id="rbind.capthist_+3A_pool">pool</code></td>
<td>
<p> list of vectors of session indices or names </p>
</td></tr>
<tr><td><code id="rbind.capthist_+3A_verify">verify</code></td>
<td>
<p> logical, if TRUE the output is checked with <code><a href="#topic+verify">verify</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MS.capthist</code> concatenates the sessions in the input objects as
one multi-session capthist object. Each session may use a different
detector array (traps) and a different number of sampling
occasions. Session names are derived implicitly from the inputs, or
may be given explicitly (see Examples); if any name is duplicated, all
will be replaced with sequential integers. The ... argument may include
lists of single-session capthist objects.
</p>
<p>The <code>rbind</code> method for capthist objects is used to pool capture data 
from more than one
session into a single session. The number of rows in the output
session is the sum of the number of rows in the input sessions
(i.e. each animal appears in only one session). Sessions to be pooled with 
<code>rbind</code> must have the same number of capture occasions and use the 
same detectors (traps). At present there is no function to pool capthist 
data from different detector arrays. For this it is recommended that you 
merge the input files and rebuild the capthist object from scratch.
</p>
<p>For <code>rbind.capthist</code>, the ... argument may be </p>

<ol>
<li><p> A series of single-session capthist objects, which are
pooled to form one new single-session object, or
</p>
</li>
<li><p> One multi-session capthist object, when the components of
&lsquo;pool&rsquo; are used to define combinations of old sessions; e.g. <code>pool =
    list(A=1:3, B=4:5)</code> produces an object with two sessions (named &lsquo;A&rsquo;
and &lsquo;B&rsquo;) from 5 old ones. If <code>pool = NULL</code> (the default) then all the
sessions are pooled to form one single-session capthist object.
</p>
</li></ol>

<p>The names of arguments other than ... should be given in full. If
<code>renumber = TRUE</code> (the default), the session name will be prepended
to the animal ID before pooling: animals 1, 2 and 3 in Session A will
become A.1, A.2 and A.3, while those in Session B become B.1, B.2 and
B.3. This ensures that each animal has a unique ID. If <code>renumber =
FALSE</code>, the animal IDs will not change.
</p>
<p>Other attributes (xy, signal) are handled appropriately. If the signal
threshold (attribute &lsquo;cutval&rsquo;) differs among sessions, the maximum is
used and detections of lower signal strength are discarded.
</p>
<p>The use of <code>rbind.capthist</code> to concatenate sessions is now deprecated: 
use <code>MS.capthist</code>. 
</p>
<p>Although <code>MS.capthist</code> looks like an S3 method, it isn't. The full function name must be used. <code>rbind.capthist</code> became an S3 method in <span class="pkg">secr</span> 3.1, so it is called as <code>rbind</code> alone.
</p>


<h3>Value</h3>

<p>For <code>MS.capthist</code>, a multi-session object of class &lsquo;capthist&rsquo; with
number of sessions equal to the number of sessions in the objects in
....
</p>
<p>For <code>rbind.capthist</code>, either an object of class &lsquo;capthist&rsquo; with one 
session formed by pooling the sessions in the input objects, or a 
capthist object with more than one session, each formed by pooling 
groups of sessions defined by the &lsquo;pool&rsquo; argument. Covariate columns that appear in
all input sessions are retained in the output. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+subset.capthist">subset.capthist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## extend a multi-session object
## we fake the 2010 data by copying from 2005
## note how we name the appended session
fakeCH &lt;- ovenCH[["2005"]]
MS.capthist(ovenCH, "2010" = fakeCH)

## simulate sessions for 2-part mixture
temptrap &lt;- make.grid(nx = 8, ny = 8)
temp1 &lt;- sim.capthist(temptrap,
    detectpar = list(g0 = 0.1, sigma = 40))
temp2 &lt;- sim.capthist(temptrap,
    detectpar = list(g0 = 0.2, sigma = 20))

## concatenate sessions
temp3 &lt;- MS.capthist(large.range = temp1, small.range = temp2)
summary(temp3)
## session-specific movement statistic
RPSV(temp3)

## pool sessions
temp4 &lt;- rbind(temp1, temp2)
summary(temp4)
RPSV(temp4)

## compare mixture to sum of components
## note `detectors visited' is not additive for 'multi' detector
## nor is `detectors used'
(summary(temp1)$counts +  summary(temp2)$counts) -
    summary(temp4)$counts

## Not run: 

## compare two different model fits 
tempfit3 &lt;- secr.fit(temp3, CL = TRUE, buffer = 150, model = list
    (g0 ~ session, sigma ~ session), trace = FALSE)
predict(tempfit3)

## if we can tell which animals had large ranges...
covariates(temp4) &lt;- data.frame(range.size = rep(c("large",
    "small"), c(nrow(temp1), nrow(temp2))))
tempfit4 &lt;- secr.fit(temp4, CL = TRUE, buffer = 150, model = list
    (g0 ~ range.size, sigma ~ range.size), trace = FALSE)
predict(tempfit4, newdata = data.frame(range.size = c("large",
    "small")))

## polygon data
pol1 &lt;- make.poly()
pol2 &lt;- make.poly(x = c(50,50,150,150))
ch1 &lt;- sim.capthist(pol1, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
ch2 &lt;- sim.capthist(pol2, popn = list(D = 30), detectfn = 'HHN', 
   detectpar = list(lambda0 = 0.3))
plot(ch1); plot(pol2, add = TRUE); plot(ch2, add = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='rbind.popn'> Combine popn Objects </h2><span id='topic+rbind.popn'></span>

<h3>Description</h3>

<p>Form a single <code>popn</code> object from two or more existing <code>popn</code> objects, or a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'popn'
 rbind(..., renumber = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.popn_+3A_...">...</code></td>
<td>
<p> one or more <code>popn</code> objects </p>
</td></tr>
<tr><td><code id="rbind.popn_+3A_renumber">renumber</code></td>
<td>
<p> logical for whether row names in the new object should be set to the row indices </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt to combine objects will fail if they conflict in their <code>covariates</code> 
attributes.  
</p>
<p>From <span class="pkg">secr</span> 3.1 this is an S3 method and list input is not allowed.
</p>


<h3>Value</h3>

<p>An object of class <code>popn</code> with number of rows equal to the sum of the rows in the input objects.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+popn">popn</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate and combine two subpopulations
trapobj &lt;- make.grid()
p1 &lt;- sim.popn(D = 3, core = trapobj)
p2 &lt;- sim.popn(D = 2, core = trapobj)
covariates(p1) &lt;- data.frame(size = rep("small", nrow(p1)))
covariates(p2) &lt;- data.frame(size = rep("large", nrow(p2)))
pop &lt;- rbind(p1,p2)

## or
pop &lt;- do.call(rbind, list(p1,p2))

</code></pre>

<hr>
<h2 id='rbind.traps'> Combine traps Objects </h2><span id='topic+rbind.traps'></span>

<h3>Description</h3>

<p>Form a single <code>traps</code> object from two or more existing <code>traps</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traps'
rbind(..., renumber = TRUE, addusage, checkdetector = TRUE, suffix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.traps_+3A_...">...</code></td>
<td>
<p> one or more <code>traps</code> objects </p>
</td></tr>
<tr><td><code id="rbind.traps_+3A_renumber">renumber</code></td>
<td>
<p> logical for whether row names in the new object
should be set to the row indices </p>
</td></tr>
<tr><td><code id="rbind.traps_+3A_addusage">addusage</code></td>
<td>
<p> integer vector; if specified and the inputs lack
usage attributes then a binary usage attribute will be generated
with the given number of occasions for each input </p>
</td></tr>
<tr><td><code id="rbind.traps_+3A_checkdetector">checkdetector</code></td>
<td>
<p>logical; if TRUE then variation in the detector attribute triggers a warning </p>
</td></tr>
<tr><td><code id="rbind.traps_+3A_suffix">suffix</code></td>
<td>
<p>logical; if TRUE then suffix to the row names indicates source </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt to combine objects will fail if they conflict in their
<code>covariates</code> attributes. Differences in the <code>usage</code>
attribute are handled as follows. If <code>usage</code> is missing for all
inputs and <code>addusage = TRUE</code> is specified then usage codes are
generated automatically (positive for the specified number of
occasions). If <code>usage</code> is specified for one input but not
other(s), the missing values are constructed assuming all detectors
were operated for the maximum number of occasions in any input. If
inputs differ in the number of &lsquo;usage&rsquo; columns (occasions), the
smaller matrices are padded with &lsquo;zero&rsquo; columns to the maximum number
of columns in any input.
</p>
<p>... may be a single multi-session traps object (from 2.10.0).
</p>
<p>By default (and always prior to 3.1.1) row names include a suffix 
(e.g., &quot;.1&quot;, or &quot;.2&quot;) to indicate the original object (first, second etc.). 
A suffix is added automatically to all names if any name is duplicated, and a warning is generated.
</p>


<h3>Value</h3>

<p>An object of class <code>traps</code> with number of rows equal to the sum of the rows in the input objects.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+traps">traps</a></code>, <code><a href="#topic+subset.traps">subset.traps</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## nested hollow grids
hollow1 &lt;- make.grid(nx = 8, ny = 8, hollow = TRUE)
hollow2 &lt;- shift(make.grid(nx = 6, ny = 6, hollow = TRUE), 
    c(20, 20))
nested &lt;- rbind (hollow1, hollow2)
plot(nested, gridlines = FALSE, label = TRUE)
</code></pre>

<hr>
<h2 id='read.capthist'> Import or export data </h2><span id='topic+read.capthist'></span><span id='topic+write.capthist'></span>

<h3>Description</h3>

<p>Data in the DENSITY formats for capture data and trap layouts may be
imported as a <code>capthist</code> object for analysis in <span class="pkg">secr</span>. Data in
a <code>capthist</code> object may also be exported in these formats for use
in DENSITY (Efford 2012). <code>read.capthist</code> inputs data from text
files and constructs a <code>capthist</code> object in one step using the
functions <code>read.traps</code> and <code>make.capthist</code>. Data may also be
read from Excel spreadsheets if the package <span class="pkg">readxl</span> is installed (see 
<a href="../doc/secr-datainput.pdf">secr-datainput.pdf</a>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
read.capthist(captfile, trapfile, detector = "multi", fmt = c("trapID","XY"),
    noccasions = NULL, covnames = NULL, trapcovnames = NULL,
    cutval = NULL, verify = TRUE, noncapt = "NONE", tol = 0.01, snapXY = FALSE, 
    markocc = NULL, ...)

write.capthist(object, filestem = deparse(substitute(object)),
     sess = "1", ndec = 2, covariates = FALSE, tonumeric = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.capthist_+3A_captfile">captfile</code></td>
<td>
<p> name of capture data file </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_trapfile">trapfile</code></td>
<td>
<p> name of trap layout file or (for a multi-session captfile) 
a vector of file names, one for each session</p>
</td></tr>
<tr><td><code id="read.capthist_+3A_detector">detector</code></td>
<td>
<p> character value for detector type (&lsquo;single&rsquo;, &lsquo;multi&rsquo;,
&lsquo;proximity&rsquo;, etc.) </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_fmt">fmt</code></td>
<td>
<p> character value for capture format (&lsquo;trapID&rsquo; or &lsquo;XY&rsquo;) </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_noccasions">noccasions</code></td>
<td>
<p> number of occasions on which detectors were
operated </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_covnames">covnames</code></td>
<td>
<p> character vector of names for individual covariate
fields in &lsquo;captfile&rsquo;</p>
</td></tr>
<tr><td><code id="read.capthist_+3A_trapcovnames">trapcovnames</code></td>
<td>
<p> character vector of names for detector covariate
fields in &lsquo;trapfile&rsquo;</p>
</td></tr>
<tr><td><code id="read.capthist_+3A_cutval">cutval</code></td>
<td>
<p> numeric, threshold of signal strength for &lsquo;signal&rsquo; detector type </p>
</td></tr> 
<tr><td><code id="read.capthist_+3A_verify">verify</code></td>
<td>
<p> logical if TRUE then the resulting capthist object is
checked with <code><a href="#topic+verify">verify</a></code></p>
</td></tr>
<tr><td><code id="read.capthist_+3A_noncapt">noncapt</code></td>
<td>
<p> character value; animal ID used for &lsquo;no captures&rsquo; </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_tol">tol</code></td>
<td>
<p> numeric, snap tolerance in metres</p>
</td></tr>
<tr><td><code id="read.capthist_+3A_snapxy">snapXY</code></td>
<td>
<p> logical; if TRUE then fmt = 'XY' uses nearest trap within tol </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_markocc">markocc</code></td>
<td>
<p>integer vector distinguishing marking occasions (1) from 
sighting occasions (0)</p>
</td></tr>
<tr><td><code id="read.capthist_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code>read.table</code>,
<code>write.table</code> and <code>count.fields</code> </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_object">object</code></td>
<td>
 <p><code>capthist</code> object with the captures and trap locations to export </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_filestem">filestem</code></td>
<td>
<p> character value used to form names of output files </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_sess">sess</code></td>
<td>
<p> character session identifier </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_ndec">ndec</code></td>
<td>
<p> number of digits after decimal point for x,y coordinates </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_covariates">covariates</code></td>
<td>
<p> logical or a character vector of covariates to
export </p>
</td></tr>
<tr><td><code id="read.capthist_+3A_tonumeric">tonumeric</code></td>
<td>
<p> logical for whether factor and character covariates should be
converted to numeric values on output</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.capthist</code>
</p>
<p><code>captfile</code> should record one detection on each line. A detection
comprises a session identifier, animal identifier, occasion number (1,
2,...,<em>S</em> where <em>S</em> is the number of occasions), and a
detector identifier (<code>fmt = "trapID"</code>) or X- and Y-coordinates
(<code>fmt = "XY"</code>). Each line of <code>trapfile</code> has a detector
identifier and its X- and Y-coordinates. In either file type the
identifiers (labels) may be numeric or alphanumeric values. Values
should be separated by blanks or tabs unless (i) the file name ends in
&lsquo;.csv&rsquo; or (ii) <code>sep = ","</code> is passed in ..., in which case commas
are assumed. Blank lines and any text after &lsquo;#&rsquo; are ignored. For further
details see <a href="../doc/secr-datainput.pdf">secr-datainput.pdf</a>,
<code><a href="#topic+make.capthist">make.capthist</a></code> and &lsquo;Data formats&rsquo; in the help for DENSITY.
</p>
<p>The <code>noccasions</code> argument is needed only if there were no
detections on the final occasion; it may be a positive integer (constant
across all sessions) or a vector of positive integers, one for each
session. <code>covnames</code> is needed only when <code>captfile</code> includes
individual covariates. Likewise for <code>trapcovnames</code> and
detector covariates. Values of <code>noccasions</code> and <code>covnames</code>
are passed directly to <code>make.capthist</code>, and <code>trapcovnames</code> is
passed to <code>read.traps</code>.
</p>
<p>A session identifier is required even for single-session
capture data. In the case of data from multiple sessions,
<code>trapfile</code> may be a vector of file names, one for each session.
</p>
<p>Additional data may be coded as for DENSITY. Specifically,
<code>captfile</code> may include extra columns of individual covariates, and
<code>trapfile</code> may code varying usage of each detector over occasions
and detector covariates.
</p>
<p><code>markocc</code> is needed only if sightings of unmarked animals are potentially 
recorded on some occasions. If the data span multiple sessions with differing
combinations of marking and sighting occasions then <code>markocc</code> may be a 
list with one vector per session.
</p>
<p>The function <code><a href="#topic+read.telemetry">read.telemetry</a></code> is a simplified version of 
<code>read.capthist</code> for telemetry data.
</p>
<p><code>write.capthist</code>
</p>
<p>For a single-session analysis, DENSITY requires one text file of
capture data and one text file with detector coordinates (the 'trap
layout' file).  <code>write.capthist</code> constructs names for these files
by appending &lsquo;capt.txt&rsquo; and &lsquo;trap.txt&rsquo; to <code>filestem</code> which
defaults to the name of the capthist object. If <code>filestem</code> is
empty then output goes to the console.
</p>
<p>If <code>object</code> contains multiple sessions with differing
<code>traps</code> then a separate trap layout file is exported for each
session and each file name includes the session name. All capture data
are exported to one file regardless of the number of sessions. The
DENSITY format used is &lsquo;TrapID&rsquo; except when x-y coordinates are
specific to a detection (i.e., polygon and transect detectors).
</p>
<p><code>covariates</code> controls the export of both detector and individual
covariates. If it is TRUE or FALSE then it is taken to apply to
both. A vector of covariate names is used as a lookup for both
detector and capthist covariate fields: covariates are exported if
their name matches; this may be used to export any combination of
(uniquely named) detector and capthist covariates.
</p>
<p>Existing text files will be replaced without warning. In the case of a
multi-session capthist file, session names are taken from
<code>object</code> rather than <code>sess</code>. Session names are truncated to
17 characters with blanks and commas removed.
</p>
<p>To export data in comma-delimited (&lsquo;.csv&rsquo;) format, pass <code>sep =
  ","</code> in .... The resulting files have extension &lsquo;.csv&rsquo; rather than
&lsquo;.txt&rsquo; and may be opened with spreadsheet software.
</p>


<h3>Warning</h3>

<p><code>write.capthist</code> does not work for mark&ndash;resight data.
</p>


<h3>Note</h3>

<p>The original DENSITY formats accommodate &lsquo;single&rsquo;, &lsquo;multi&rsquo; and &lsquo;proximity&rsquo;
data. Data for the newer detector types (&lsquo;count&rsquo;, &lsquo;signal&rsquo;, &lsquo;polygon&rsquo;,
&lsquo;polygonX&rsquo;, &lsquo;transect&rsquo;, &lsquo;transectX&rsquo; and &lsquo;telemetryonly&rsquo;) may be input using the
DENSITY formats with minor variations. They may also be output with
<code>write.capthist</code>, but a warning is given that DENSITY does not
understand these data types. See <code><a href="#topic+detector">detector</a></code> and
<a href="../doc/secr-datainput.pdf">secr-datainput.pdf</a> for more.
</p>
<p>The ... argument is useful for some special cases. For example, if
your input uses &lsquo;;&rsquo; instead of &lsquo;#&rsquo; for comments (&lsquo;;&rsquo; is also valid in
DENSITY) then set <code>comment.char = ";"</code> in <code>read.capthist</code>.
</p>
<p>In a similar fashion, write comma- or tab-separated values by
setting <code>sep = ","</code> or <code>sep = "\t"</code> respectively.
</p>
<p>The arguments of <code>count.fields</code> are a subset of those of
<code>read.table</code> so ... is limited to any of {sep, quote,
skip, blank.lines.skip, comment.char}.
</p>
<p>If you fail to set <code>fmt</code> correctly in <code>read.capthist</code> then the
error message from <code>verify</code> may be uninformative.
</p>


<h3>References</h3>

<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand
<a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.telemetry">read.telemetry</a></code>, <code><a href="#topic+read.traps">read.traps</a></code>, <code><a href="#topic+make.capthist">make.capthist</a></code>,
<code><a href="#topic+write.captures">write.captures</a></code>, <code><a href="#topic+write.traps">write.traps</a></code>, <code><a href="utils.html#topic+read.table">read.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## export ovenbird capture histories
## the files "ovenCHcapt.txt" and "ovenCHtrap.txt" are
## placed in the current folder (check with getwd() or dir())

## Not run: 
write.capthist(ovenCH)

## End(Not run)

</code></pre>

<hr>
<h2 id='read.mask'> Read Habitat Mask From File </h2><span id='topic+read.mask'></span>

<h3>Description</h3>

<p>Read coordinates of points on a habitat mask from a text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
read.mask(file = NULL, data = NULL, spacing = NULL, columns = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mask_+3A_file">file</code></td>
<td>
<p> character string with name of text file </p>
</td></tr>
<tr><td><code id="read.mask_+3A_data">data</code></td>
<td>
<p> dataframe </p>
</td></tr> 
<tr><td><code id="read.mask_+3A_spacing">spacing</code></td>
<td>
<p> spacing of grid points in metres </p>
</td></tr>
<tr><td><code id="read.mask_+3A_columns">columns</code></td>
<td>
<p> character vector naming the columns to save as covariates</p>
</td></tr>
<tr><td><code id="read.mask_+3A_...">...</code></td>
<td>
<p> other arguments to pass to <code>read.table</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For file input, the x and y coordinates are usually the first two values
on each line, separated by white space. If the file starts with a line
of column headers and &lsquo;header = TRUE&rsquo; is passed to <code>read.table</code> in
the ... argument then &lsquo;x&rsquo; and &lsquo;y&rsquo; need not be the first two fields.
</p>
<p><code>data</code> is an alternative input route if the x and y coordinates
already exist in <span class="rlang"><b>R</b></span> as columns in a dataframe. Only one of <code>data</code>
or <code>file</code> should be specified.
</p>
<p>The grid cell size <code>spacing</code> should be provided if known. If it is
not provided then an attempt is made to infer it from the minimum
spacing of points.  This can be slow and may demand more memory than is
available. In rare cases (highly fragmented masks) it may also yield the
wrong answer.
</p>
<p>From 2.3.0, additional columns in the input are saved as covariates. The
default (<code>columns = NULL</code>) is to save all columns.
</p>


<h3>Value</h3>

<p>object of class <code>mask</code> with type &lsquo;user&rsquo;
</p>


<h3>Note</h3>

<p><code>read.mask</code> creates a single-session mask. If used in
<code><a href="#topic+secr.fit">secr.fit</a></code> with a multi-session capthist object a
single-session mask will be replicated to the number of sessions. This
is appropriate if all sessions relate to the same geographical
region. If the &lsquo;sessions&rsquo; relate to different regions you will need to
construct a multi-session mask as a list of single-session
masks (e.g. <code>mask &lt;- list(mask1, mask2, mask3)</code>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mask">mask</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Replace file name with a valid local name and remove `#'
# read.mask (file = "c:\\myfolder\\mask.txt",
# spacing = 3, header = TRUE)
## "mask.txt" should have lines like this
# x   y
# 265 265
# 268 265
# ...
</code></pre>

<hr>
<h2 id='read.telemetry'> Import Telemetry Fixes </h2><span id='topic+read.telemetry'></span>

<h3>Description</h3>

<p>A shortcut function for constructing a telemetry capthist object from a file of
telemetry fixes. Telemetry data are generally similar in format to polygon data
(see also <code><a href="#topic+addTelemetry">addTelemetry</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.telemetry(file = NULL, data = NULL, covnames = NULL, verify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.telemetry_+3A_file">file</code></td>
<td>
<p>character name of text file </p>
</td></tr>
<tr><td><code id="read.telemetry_+3A_data">data</code></td>
<td>
<p>data.frame containing coordinate data (alternative to <code>file</code>) </p>
</td></tr>
<tr><td><code id="read.telemetry_+3A_covnames">covnames</code></td>
<td>
<p>character vector of names for individual covariates </p>
</td></tr>
<tr><td><code id="read.telemetry_+3A_verify">verify</code></td>
<td>
<p>logical for whether to check input </p>
</td></tr>
<tr><td><code id="read.telemetry_+3A_...">...</code></td>
<td>
<p>other arguments passed to countfields, read.table etc. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data may be in a text file (argument <code>file</code>) or a dataframe
(argument <code>data</code>). Data should be in the XY format for function 'read.capthist' 
i.e. the first 5 columns should be Session, ID, Occasion, X, Y. Further columns are 
treated as individual covariates.
</p>
<p>No &lsquo;traps&rsquo; input is required. A traps object is generated automatically.
</p>


<h3>Value</h3>

<p>An secr capthist object including attribute &lsquo;telemetryxy&rsquo; with the x-y
coordinates, and a &lsquo;traps&rsquo; object with detector type = &lsquo;telemetry&rsquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addTelemetry">addTelemetry</a></code>, <code><a href="#topic+read.capthist">read.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

olddir &lt;- setwd('D:/bears/alberta')
## peek at raw data
head(readLines('gps2008.txt'))
gps2008CH &lt;- read.telemetry("gps2008.txt")
setwd(olddir)

plot( gps2008CH, gridsp = 10000)
head(gps2008CH)
secr.fit(gps2008CH, start = log(4000), detectfn = 'HHN', 
    details = list(telemetryscale = 1e12))


## End(Not run)

</code></pre>

<hr>
<h2 id='read.traps'> Read Detector Data From File </h2><span id='topic+read.traps'></span>

<h3>Description</h3>

<p>Construct an object of class <code>traps</code> with detector locations from a text file or data frame. Usage per occasion and covariates may be included. Data may also be read from an Excel spreadsheet (see <a href="../doc/secr-datainput.pdf">secr-datainput.pdf</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.traps(file = NULL, data = NULL, detector = "multi", covnames =
NULL, binary.usage = TRUE, markocc = NULL, trapID = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.traps_+3A_file">file</code></td>
<td>
<p> character string with name of text file </p>
</td></tr>
<tr><td><code id="read.traps_+3A_data">data</code></td>
<td>
<p> data frame of detector coordinates </p>
</td></tr>
<tr><td><code id="read.traps_+3A_detector">detector</code></td>
<td>
<p> character string for detector type </p>
</td></tr>
<tr><td><code id="read.traps_+3A_covnames">covnames</code></td>
<td>
<p> character vector of names for detector covariate
fields </p>
</td></tr>
<tr><td><code id="read.traps_+3A_binary.usage">binary.usage</code></td>
<td>
<p>logical; if FALSE will read usage fields as
continuous effort</p>
</td></tr>
<tr><td><code id="read.traps_+3A_markocc">markocc</code></td>
<td>
<p>integer vector distinguishing marking occasions (1) from 
sighting occasions (0)</p>
</td></tr>
<tr><td><code id="read.traps_+3A_trapid">trapID</code></td>
<td>
<p>character column containing detector names (see Details)</p>
</td></tr>
<tr><td><code id="read.traps_+3A_...">...</code></td>
<td>
<p> other arguments to pass to <code>read.table</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads a text file in which the first column is a character string (see Note)
identifying a detector and the next two columns are its x- and
y-coordinates, separated by white space. The coordinates optionally may
be followed by a string of codes &lsquo;0&rsquo; or &lsquo;1&rsquo; indicating whether the
detector was operated on each occasion. Trap-specific covariates may be
added at the end of the line preceded by &lsquo;/&rsquo;. This format is compatible
with the Density software (Efford 2012), except that all detectors are
assumed to be of the same type (usage codes greater than 1 are treated
as 1), and more than one covariate may be specified.
</p>
<p>If <code>file</code> is missing then x-y coordinates will be taken instead
from <code>data</code>, which should include columns &lsquo;x&rsquo; and &lsquo;y&rsquo;. Row names of 
<code>data</code> are read as detector identifiers unless <code>trapID</code> is specified.
This option does not allow for <code>covariates</code> or <code>usage</code>, 
but they maybe added later.
</p>
<p><code>detector</code> specifies the behaviour of the detector following Efford
et al. (2009). &lsquo;single&rsquo; refers to a trap that is able to catch at most
one animal at a time; &lsquo;multi&rsquo; refers to a trap that may catch more than
one animal at a time. For both &lsquo;single&rsquo; and &lsquo;multi&rsquo; detectors a trapped
animals can appear at only one detector per occasion. Detectors of type
&lsquo;proximity&rsquo;, such as camera traps and hair snags for DNA sampling, allow
animals to be recorded at several detectors on one occasion. See
<code><a href="#topic+detector">detector</a></code> for further detector types.
</p>
<p>For polygon and transect detector types, each line corresponds to a
vertex and starts with a code to identify the polygon or transect (hence
the same code appears on 2 or more lines). For input from a dataframe
the code column should be named &lsquo;polyID&rsquo;. Also, usage and covariates
are for the polygon or transect as a whole and not for each
vertex. Usage and covariates are appended to the end of the line, just
as for point detectors (traps etc.). The usage and covariates for each
polygon or transect are taken from its first vertex. Although the
end-of-line strings of other vertices are not used, they cannot be blank
and should use the same spacing as the first vertex.
</p>


<h3>Value</h3>

<p>An object of class <code>traps</code> comprising a data frame of x- and
y-coordinates, the detector type (&lsquo;single&rsquo;, &lsquo;multi&rsquo;, &lsquo;proximity&rsquo;,
&lsquo;count&rsquo;, &lsquo;polygon&rsquo; etc.), and possibly other attributes.
</p>


<h3>Note</h3>

<p>Detector names, which become row names in the traps object, should not
contain underscores.
</p>
<p>Prior to 4.3.1 the function did not read usage or covariates from xls 
or data input.
</p>


<h3>References</h3>

 
<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+traps">traps</a></code>, <code><a href="#topic+make.grid">make.grid</a></code>, <code><a href="#topic+detector">detector</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## "trap.txt" should have lines like this 
# 1     365     365
# 2     365     395
# 3     365     425
# etc.
## in following, replace file name with a valid local name
filename &lt;- paste0(system.file("extdata", package = "secr"), '/trap.txt')
tr1 &lt;- read.traps (filename, detector = "proximity")
summary(tr1)

## Or if we have a dataframe of coordinates...
mytrapdf &lt;- data.frame(x = c(365,365,365), y = c(365,395,425),
                       row.names = c('A','B','C'))
mytrapdf
#     x   y
# A 365 365
# B 365 395
# C 365 425
## ...then we can convert it to a `traps' object with
tr2 &lt;- read.traps(data = mytrapdf)
summary(tr2)


## End(Not run)

</code></pre>

<hr>
<h2 id='rectangularMask'>Rectangular Mask</h2><span id='topic+rectangularMask'></span>

<h3>Description</h3>

<p>Convert a mask or Dsurface with an irregular outline into a mask or
Dsurface with a rectangular outline and the same bounding box. This
enables contour plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectangularMask(mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectangularMask_+3A_mask">mask</code></td>
<td>
<p>object of class mask or Dsurface</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariates of new points are set to missing. The operation may be
reversed (nearly) with <code>subset(rectmask, attr(rectmask, "OK"))</code>.
</p>
<p>The results are unpredictable if the mask has been rotated.
</p>


<h3>Value</h3>

<p>A rectangular mask or Dsurface with the same &lsquo;area&rsquo;, &lsquo;boundingbox&rsquo;,
&lsquo;meanSD&rsquo;, &lsquo;polygon&rsquo; and &lsquo;polygon.habitat&rsquo; attributes as <code>mask</code>. A
logical vector attribute &lsquo;OK&rsquo; is added identifying the points
inherited from <code>mask</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.Dsurface">plot.Dsurface</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rMask &lt;- rectangularMask(possummask)
plot(rMask)
plot(possummask, add = TRUE, col = "blue")

</code></pre>

<hr>
<h2 id='reduce'> Combine Columns </h2><span id='topic+reduce'></span><span id='topic+reduce.default'></span>

<h3>Description</h3>

<p>Combine columns in a matrix-like object to create a new data set using the first non-zero value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce (object, ...)
## Default S3 method:
reduce(object, columns, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_+3A_object">object</code></td>
<td>
<p> object that may be coerced to a matrix </p>
</td></tr>
<tr><td><code id="reduce_+3A_columns">columns</code></td>
<td>
<p> list in which each component is a vector of subscripts for columns to be pooled </p>
</td></tr>
<tr><td><code id="reduce_+3A_...">...</code></td>
<td>
<p> other arguments (not used currently) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first element of <code>columns</code> defines the columns of <code>object</code>
for the first new column, the second for the second new column etc.
This is a generic method. More useful methods exist for <code>capthist</code> and
<code>traps</code> objects.
</p>


<h3>Value</h3>

<p>A matrix with number of columns equal to <code>length(columns)</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+reduce.capthist">reduce.capthist</a></code>, <code><a href="#topic+reduce.traps">reduce.traps</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## matrix with random zeros
temp &lt;- matrix(runif(20), nc = 4)
temp[sample(20,10)] &lt;- 0
temp

reduce(temp, list(1:2, 3:4))

</code></pre>

<hr>
<h2 id='reduce.capthist'> Combine Occasions Or Detectors </h2><span id='topic+reduce.traps'></span><span id='topic+reduce.capthist'></span>

<h3>Description</h3>

<p>Use these methods to combine data from multiple occasions or multiple detectors in a
<code>capthist</code> or <code>traps</code> object, creating a new data set and possibly converting
between detector types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'traps'
reduce(object, newtraps = NULL, newoccasions = NULL, span = NULL, 
    rename = FALSE, newxy = c('mean', 'first'), ...)

## S3 method for class 'capthist'
reduce(object, newtraps = NULL, span = NULL, rename =
    FALSE, newoccasions = NULL, by = 1, outputdetector = NULL,
    select = c("last","first","random"), dropunused = TRUE, verify
    = TRUE, sessions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.capthist_+3A_object">object</code></td>
<td>
 <p><code>traps or capthist</code> object </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_newtraps">newtraps</code></td>
<td>
<p> list in which each component is a vector of
subscripts for detectors to be pooled </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_newoccasions">newoccasions</code></td>
<td>
<p> list in which each component is a vector of
subscripts for occasions to be pooled </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_span">span</code></td>
<td>
<p> numeric maximum span in metres of new detector </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_rename">rename</code></td>
<td>
<p>logical; if TRUE the new detectors will be numbered from
1, otherwise a name will be constructed from the old detector names</p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_newxy">newxy</code></td>
<td>
<p> character; coordinates when detectors grouped with &lsquo;newtraps&rsquo;</p>
</td></tr>  
<tr><td><code id="reduce.capthist_+3A_by">by</code></td>
<td>
<p> number of old occasions in each new occasion </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_outputdetector">outputdetector</code></td>
<td>
<p>character value giving <a href="#topic+detector">detector</a> type for output (defaults to input) </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_select">select</code></td>
<td>
<p> character value for method to resolve conflicts </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_dropunused">dropunused</code></td>
<td>
<p> logical, if TRUE any never-used detectors are dropped </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_verify">verify</code></td>
<td>
<p> logical, if TRUE the <code>verify</code> function is applied to the output </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_sessions">sessions</code></td>
<td>
<p> vector of session indices or names (optional) </p>
</td></tr>
<tr><td><code id="reduce.capthist_+3A_...">...</code></td>
<td>
<p> other arguments passed by reduce.capthist to reduce.traps, 
or by reduce.traps to hclust </p>
</td></tr>
</table>


<h3>Details</h3>

<p>reduce.traps &ndash;
</p>
<p>Grouping may be specified explicitly via <code>newtraps</code>, or
implicitly by <code>span</code>. 
</p>
<p>If <code>span</code> is specified a clustering of detector sites will be
performed with <code><a href="stats.html#topic+hclust">hclust</a></code> and detectors will be assigned to
groups with <code><a href="stats.html#topic+cutree">cutree</a></code>. The default algorithm in <code>hclust</code>
is complete linkage, which tends to yield compact, circular clusters;
each will have diameter less than or equal to <code>span</code>.
</p>
<p><code>newxy = 'first'</code> selects the coordinates of the first detector in a 
group defined by &lsquo;newtraps&rsquo;, rather then the average of all detectors in group.
</p>
<p>reduce.capthist &ndash;
</p>
<p>The first component of <code>newoccasions</code> defines the columns of
<code>object</code> for new occasion 1, the second for new occasion 2, etc. If
<code>newoccasions</code> is NULL then all occasions are output. Subscripts in a
component of <code>newoccasions</code> that do not match an occasion in the input
are ignored. When the output detector is one of the trap types
(&lsquo;single&rsquo;, &lsquo;multi&rsquo;), reducing capture occasions can result in locational
ambiguity for individuals caught on more than one occasion, and for
single-catch traps there may also be conflicts between individuals at
the same trap. The method for resolving conflicts among &lsquo;multi&rsquo;
detectors is determined by <code>select</code> which should be one of &lsquo;first&rsquo;,
&lsquo;last&rsquo; or &lsquo;random&rsquo;. With &lsquo;single&rsquo; detectors <code>select</code> is ignored and
the method is: first, randomly select* one trap per animal per day;
second, randomly select* one animal per trap per day; third, when
collapsing multiple days use the first capture, if any, in each
trap.
</p>
<p>Usage data in the <code>traps</code> attribute are also pooled if present;
usage is summed over contributing occasions and detectors. If there is
no 'usage' attribute in the input, and <code>outputdetector</code> is one of
'count', 'polygon', 'transect' and 'telemetry', a homogeneous (all-1's)
'usage' attribute is first generated for the input.
</p>
<p>* i.e., in the case of a single capture, use that capture; in the case of
multiple &lsquo;competing&rsquo; captures draw one at random.
</p>
<p>If <code>newoccasions</code> is not provided then old occasions are grouped into
new occasions as indicated by the <code>by</code> argument. For example, if
there are 15 old occasions and <code>by = 5</code> then new occasions will be
formed from occasions 1:5, 6:10, and 11:15. A warning is given when the
number of old occasions is not a multiple of <code>by</code> as then the final
new occasion will comprise fewer old occasions.
</p>
<p><code>dropunused = TRUE</code> has the possibly unintended effect of dropping
whole occasions on which there were no detections.
</p>
<p>A special use of the <code>by</code> argument is to combine all occasions into
one for each session in a multi-session dataset. This is done by setting
<code>by = "all"</code>.
</p>
<p><code>reduce.capthist</code> may be used with non-spatial capthist objects 
(NULL 'traps' attribute) by setting <code>verify = FALSE</code>.
</p>


<h3>Value</h3>

<p>reduce.traps &ndash;
</p>
<p>An object of class traps with detectors combined according to
<code>newtraps</code> or <code>span</code>. The new object has an attribute
&lsquo;newtrap&rsquo;, a vector of length equal to the original number of
detectors. Each element in newtrap is the index of the new detector to
which the old detector was assigned (see Examples).
</p>
<p>The object has no clusterID or clustertrap attribute.
</p>
<p>reduce.capthist &ndash;
</p>
<p>An object of class capthist with number of occasions (columns) equal to
<code>length(newoccasions)</code>; detectors may simulataneously be aggregated
as with <code>reduce.traps</code>. The detector type is inherited from <code>object</code>
unless a new type is specified with the argument
<code>outputdetector</code>. 
</p>


<h3>Warning</h3>

<p>The argument named &lsquo;columns&rsquo; was renamed to
&lsquo;newoccasions&rsquo; in version 2.5.0, and arguments were added to
reduce.capthist for the pooling of detectors. Old code should work as
before if all arguments are named and &lsquo;columns&rsquo; is changed. </p>


<h3>Note</h3>

<p>The reduce method may be used to re-assign the detector type (and
hence data format) of a capthist object without combining occasions or
detectors. Set the <code>object</code> and <code>outputdetector</code> arguments
and leave others at their default values.
</p>
<p>Automated clustering can produce unexpected outcomes. In particular,
there is no guarantee that clusters will be equal in size. You should
inspect the results of reduce.traps especially when using <code>span</code>.
</p>
<p><code>reduce.traps</code> is not implemented for polygons or transects.
</p>
<p>The function <code><a href="#topic+discretize">discretize</a></code> converts polygon data to
point-detector (multi, proximity or count) data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+subset.capthist">subset.capthist</a></code>,
<code><a href="#topic+discretize">discretize</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tempcapt &lt;- sim.capthist (make.grid(nx = 6, ny = 6), nocc = 6)
class(tempcapt)

pooled.tempcapt &lt;- reduce(tempcapt, newocc = list(1,2:3,4:6))
summary (pooled.tempcapt)

pooled.tempcapt2 &lt;- reduce(tempcapt, by = 2)
summary (pooled.tempcapt2)

## collapse multi-session dataset to single-session 'open population'
onesess &lt;- join(reduce(ovenCH, by = "all"))
summary(onesess)

# group detectors within 60 metres
plot (traps(captdata))
plot (reduce(captdata, span = 60), add = TRUE)

# plot linking old and new
old &lt;- traps(captdata)
new &lt;- reduce(old, span = 60)
newtrap &lt;- attr(new, "newtrap")
plot(old, border = 10)
plot(new, add = TRUE, detpar = list(pch = 16), label = TRUE)
segments (new$x[newtrap], new$y[newtrap], old$x, old$y)

## Not run: 

# compare binary proximity with collapsed binomial count
# expect TRUE for each year
for (y in 1:5) {
    CHA &lt;- abs(ovenCHp[[y]])   ## abs() to ignore one death
    usage(traps(CHA)) &lt;- matrix(1, 44, ncol(CHA))
    CHB &lt;- reduce(CHA, by = 'all', output = 'count')
    # summary(CHA, terse = TRUE)
    # summary(CHB, terse = TRUE)
    fitA &lt;- secr.fit(CHA, buffer = 300, trace = FALSE)
    fitB &lt;- secr.fit(CHB, buffer = 300, trace = FALSE, binomN = 1, biasLimit = NA)
    A &lt;- predict(fitA)[,-1] 
    B &lt;- predict(fitB)[,-1]
    cat(y, ' ', all(abs(A-B)/A &lt; 1e-5), '\n')
}
## multi-session fit
## expect TRUE overall
CHa &lt;- ovenCHp
for (y in 1:5) {
    usage(traps(CHa[[y]])) &lt;- matrix(1, 44, ncol(CHa[[y]]))
    CHa[[y]][,,] &lt;- abs(CHa[[y]][,,])
}
CHb &lt;- reduce(CHa, by = 'all', output = 'count')
summary(CHa, terse = TRUE)
summary(CHb, terse = TRUE)
fita &lt;- secr.fit(CHa, buffer = 300, trace = FALSE)
fitb &lt;- secr.fit(CHb, buffer = 300, trace = FALSE, binomN = 1, biasLimit = NA)
A &lt;- predict(fita)[[1]][,-1] 
B &lt;- predict(fitb)[[1]][,-1]
all(abs(A-B)/A &lt; 1e-5)


## End(Not run)

</code></pre>

<hr>
<h2 id='region.N'>Population Size</h2><span id='topic+region.N'></span><span id='topic+region.N.secr'></span><span id='topic+region.N.secrlist'></span><span id='topic+population+20size'></span>

<h3>Description</h3>

<p>Estimate the expected and realised populations in a region,
using a fitted spatially explicit capture&ndash;recapture model. Density is
assumed to follow an inhomogeneous Poisson process in two
dimensions. Expected <code class="reqn">N</code> is the volume under a fitted density
surface; realised <code class="reqn">N</code> is the number of individuals within the region
for the current realisation of the process (cf Johnson et al. 2010; see
Note). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
region.N(object, ...)

## S3 method for class 'secr'
region.N(object, region = NULL, spacing = NULL, session = NULL,
    group = NULL, se.N = TRUE, alpha = 0.05, loginterval = TRUE,
    keep.region = FALSE, nlowerbound = TRUE, RN.method = "poisson",
    pooled.RN = FALSE, ncores = NULL, ...)
    
## S3 method for class 'secrlist'
region.N(object, region = NULL, spacing = NULL, session = NULL,
    group = NULL, se.N = TRUE, alpha = 0.05, loginterval = TRUE,
    keep.region = FALSE, nlowerbound = TRUE, RN.method = "poisson",
    pooled.RN = FALSE, ncores = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="region.N_+3A_object">object</code></td>
<td>
 <p><code>secr</code> object output from <code>secr.fit</code> </p>
</td></tr>
<tr><td><code id="region.N_+3A_region">region</code></td>
<td>
<p> mask object defining the possibly non-contiguous region
for which population size is required, or vector polygon(s) (see
Details)</p>
</td></tr>
<tr><td><code id="region.N_+3A_spacing">spacing</code></td>
<td>
<p> spacing between grid points (metres) if region mask is
constructed on the fly </p>
</td></tr>
<tr><td><code id="region.N_+3A_session">session</code></td>
<td>
<p> character session </p>
</td></tr>
<tr><td><code id="region.N_+3A_group">group</code></td>
<td>
<p> group &ndash; for future use </p>
</td></tr>
<tr><td><code id="region.N_+3A_se.n">se.N</code></td>
<td>
<p> logical for whether to estimate SE(<code class="reqn">\hat{N}</code>)
and confidence interval </p>
</td></tr>
<tr><td><code id="region.N_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="region.N_+3A_loginterval">loginterval</code></td>
<td>
<p> logical for whether to base interval on log(N)</p>
</td></tr>
<tr><td><code id="region.N_+3A_keep.region">keep.region</code></td>
<td>
<p> logical for whether to save the raster region</p>
</td></tr>
<tr><td><code id="region.N_+3A_nlowerbound">nlowerbound</code></td>
<td>
<p> logical for whether to use n as lower bound when
computing log interval for realised N</p>
</td></tr>
<tr><td><code id="region.N_+3A_rn.method">RN.method</code></td>
<td>
<p> character string for method used to calculate
realised N (RN) and its sampling variance. &lsquo;poisson&rsquo; or &lsquo;MSPE&rsquo;.</p>
</td></tr>
<tr><td><code id="region.N_+3A_pooled.rn">pooled.RN</code></td>
<td>
<p> logical; if TRUE the estimate of realised N for a multi-session
model is computed as if for combined sampling with all detectors (see Details)</p>
</td></tr>
<tr><td><code id="region.N_+3A_ncores">ncores</code></td>
<td>
<p> integer number of threads to be used for parallel processing</p>
</td></tr>
<tr><td><code id="region.N_+3A_...">...</code></td>
<td>
<p> other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the density surface of the fitted model is flat
(i.e. <code>object$model$D == ~1</code> or <code>object$CL == TRUE</code>) then
<code class="reqn">E(N)</code> is simply the density multiplied by the area of <code>region</code>,
and the standard error is also a simple product. In the conditional
likelihood case, the density and standard error are obtained by first
calling <code>derived</code>.
</p>
<p>If, on the other hand, the density has been modelled then the density
surface is predicted at each point in <code>region</code> and <code class="reqn">E(N)</code> is
obtained by discrete summation. Pixel size may have a minor effect on
the result - check by varying <code>spacing</code>. Sampling variance is
determined by the delta method, using a numerical approximation to the
gradient of <code class="reqn">E(N)</code> with respect to each beta parameter.
</p>
<p>The region may be defined as a mask object (if omitted, the mask
component of <code>object</code> will be used). Alternatively, <code>region</code>
may be a SpatialPolygonsDataFrame object (see package <span class="pkg">sp</span>), and a
raster mask will be constructed on the fly using the specified
spacing. See <code><a href="#topic+make.mask">make.mask</a></code> for an example importing a
shapefile to a SpatialPolygonsDataFrame.
</p>
<p>Note: The option of specifying a polygon rather than a mask for
<code>region</code> does not work if the density model in <code>object</code> uses
spatial covariates: these must be passed in a mask.
</p>
<p>Group-specific N has yet to be implemented.
</p>
<p>Population size is adjusted automatically for the number of clusters
in &lsquo;mashed&rsquo; models (see <code><a href="#topic+mash">mash</a></code>). However, the population
size reported is that associated with a single cluster unless
<code>regionmask</code> is specified.
</p>
<p><code>pooled.RN = TRUE</code> handles the special case of a multi-session
model in which the region of interest spans several patches (i.e.,
sampling in each session is localised within <code>region</code>. This is not
yet fully implemented.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>Use <code><a href="#topic+par.region.N">par.region.N</a></code> to apply <code>region.N</code> in parallel to
several models.
</p>


<h3>Value</h3>

<p>If <code>se.N = FALSE</code>, the numeric value of expected population size,
otherwise, a dataframe with rows &lsquo;E.N&rsquo; and &lsquo;R.N&rsquo;, and columns as
below.
</p>

<table>
<tr>
 <td style="text-align: left;">
estimate    </td><td style="text-align: left;"> estimate of N (expected or realised, depending on row)</td>
</tr>
<tr>
 <td style="text-align: left;">
SE.estimate </td><td style="text-align: left;"> standard error of estimated N </td>
</tr>
<tr>
 <td style="text-align: left;">
lcl         </td><td style="text-align: left;"> lower 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
ucl         </td><td style="text-align: left;"> upper 100(1--alpha)% confidence limit </td>
</tr>
<tr>
 <td style="text-align: left;">
n           </td><td style="text-align: left;"> total number of individuals detected </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For multiple sessions, the value is a list with one component per
session, each component as above.
</p>
<p>If <code>keep.region = TRUE</code> then the mask object for the region is
saved as the attribute &lsquo;region&rsquo; (see Examples).
</p>
<p>The area in hectares of the region is saved as attribute &lsquo;regionarea&rsquo;.
</p>


<h3>Note</h3>

<p>The estimates of expected and realised <code class="reqn">N</code> are generally very
similar, or identical, but realised <code class="reqn">N</code> usually has lower
estimated variance, especially if the <code class="reqn">n</code> detected animals
comprise a large fraction. 
</p>
<p>Realised <code class="reqn">N</code> is given by <code class="reqn">R(N) = n + \int_B (1 - p.(X))D(X)
  dX</code> (the second term
represents undetected animals). This definition strictly holds only
when region B is at least as large as the region of integration used
to fit the model; only with this condition can we be sure all <code class="reqn">n</code>
detected animals have centres within B. The sampling variance of
<code class="reqn">R(N)</code>, technically a mean square prediction error (Johnson et al.
2010), is approximated by summing the expected Poisson variance of the
true number of undetected animals and a delta-method estimate of its
sampling variance, obtained as for <code class="reqn">E(N)</code>.
</p>
<p>By default, a shortcut is used to compute the sampling variance of
realised <code class="reqn">N</code>. With this option (RN.method = &lsquo;poisson&rsquo;) the
sampling variance is the sampling variance of <code class="reqn">E(N)</code> minus the
estimate of <code class="reqn">E(N)</code> (representing Poisson process variance). This
has been found to give reliable confidence intervals in simulations
(Efford and Fewster 2013).
</p>
<p>If RN.method is neither &lsquo;MSPE&rsquo; nor &lsquo;poisson&rsquo; (ignoring case) then
the estimate of expected <code class="reqn">N</code> is also used for realised <code class="reqn">N</code>,
and the &lsquo;poisson&rsquo; shortcut variance is used.
</p>
<p>Johnson et al. (2010) use the notation <code class="reqn">\mu(B)</code> for expected
<code class="reqn">N</code> and <code class="reqn">N(B)</code> for realised <code class="reqn">N</code> in region <code class="reqn">B</code>.
</p>
<p>In our case, the relative SE (CV) of <code class="reqn">\mu(B)</code> is the same as that
for the estimated density <code class="reqn">D</code> if <code class="reqn">D</code> has been estimated using
the Poisson distribution option in <code>secr.fit</code> or
<code>derived()</code>. If <code class="reqn">D</code> has been estimated with the binomial
distribution option, its relative SE for simple models will be the
same as that of <code class="reqn">N(B)</code>, assuming that <code class="reqn">B</code> is the full extent
of the original mask.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G. and Fewster, R. M. (2013) Estimating population size by
spatially explicit capture&ndash;recapture. <em>Oikos</em> <b>122</b>, 918&ndash;928.
</p>
<p>Johnson, D. S., Laake, J. L. and Ver Hoef, J. M. (2010) A model-based
approach for making ecological inference from distance sampling
data. <em>Biometrics</em> <b>66</b>, 310&ndash;318.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+derived">derived</a></code>, <code><a href="#topic+make.mask">make.mask</a></code>,
<code><a href="#topic+expected.n">expected.n</a></code>, <code><a href="#topic+closedN">closedN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## routine examples using arbitrary mask from model fit
region.N(secrdemo.0)
region.N(secrdemo.CL)
region.N(ovenbird.model.D)

## region defined as vector polygon
## retain and plot region mask
temp &lt;- region.N(possum.model.0, possumarea, spacing = 40,
    keep.region = TRUE)
temp
plot (attr(temp, "region"), type = "l")

## End(Not run)

</code></pre>

<hr>
<h2 id='RMarkInput'> Convert Data to RMark Input Format </h2><span id='topic+RMarkInput'></span><span id='topic+unRMarkInput'></span>

<h3>Description</h3>

<p>A single-session capthist object is formed by RMarkInput into a dataframe that may be
passed directly to RMark. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
RMarkInput(object, grouped = FALSE, covariates = TRUE)

unRMarkInput(df, covariates = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMarkInput_+3A_object">object</code></td>
<td>
<p>secr capthist object</p>
</td></tr>
<tr><td><code id="RMarkInput_+3A_grouped">grouped</code></td>
<td>
<p>logical for whether to replace each group of identical
capture histories with a single line</p>
</td></tr>
<tr><td><code id="RMarkInput_+3A_covariates">covariates</code></td>
<td>
<p>logical or character vector; see Details</p>
</td></tr>
<tr><td><code id="RMarkInput_+3A_df">df</code></td>
<td>
<p>dataframe with fields &lsquo;ch&rsquo; and &lsquo;freq&rsquo; </p>
</td></tr>
</table>


<h3>Details</h3>

<p>To convert a multi-session object first collapse the sessions with
<code><a href="#topic+join">join</a></code>.
</p>
<p>If <code>covariates</code> is TRUE then all columns of individual covariates
in the input are appended as columns in the output. If
<code>covariates</code> is a character-valued vector then only the specified
covariates will be appended.
</p>
<p>If both <code>grouped</code> and <code>covariates</code> are specified in
<code>RMarkInput</code>, <code>grouped</code> will be ignored, with a warning.
</p>


<h3>Value</h3>

<p>For RMarkInput &ndash;
</p>
<p>Dataframe with fields ch and freq. &lsquo;ch&rsquo; is a character string of 0's
and 1's. If <code>grouped = FALSE</code> the rownames are retained and the
value of &lsquo;freq&rsquo; is 1 or -1. Negative values of &lsquo;freq&rsquo; indicate
removal.
</p>
<p>The dataframe also includes individual covariates specified with
<code>covariates</code>.
</p>
<p>The attribute &lsquo;intervals&rsquo; is copied from &lsquo;object&rsquo;, if present;
otherwise it is set to a vector of zeros (indicating a
closed-population sample).
</p>
<p>For unRMarkInput &ndash;
</p>
<p>A single-session capthist object with no traps attribute and hence no
detector type (i.e. non-spatial capture histories). Covariates are
copied as requested. 
</p>
<p>From <span class="pkg">secr</span> 4.6.6, missing values (.) in input capture histories are 
converted to NA in the output, with a warning. The resulting capthist is 
unusable until the NAs are removed.
</p>


<h3>Note</h3>

<p>In versions before 2.4.0, a spurious occasion was added by
<code>RMarkInput</code> when grouped = FALSE. Thanks to Jeff Stetz for
spotting this.
</p>
<p>The default value for <code>grouped</code> changed to FALSE in secr 2.4.0.
</p>


<h3>References</h3>

<p>Laake, J. and Rexstad E. (2008) Appendix C. RMark - an alternative
approach to building linear models in MARK. In: Cooch, E. and White,
G. (eds) Program MARK: A Gentle Introduction. 6th edition. Available at
<a href="http://www.phidot.org/software/mark/docs/book/">http://www.phidot.org/software/mark/docs/book/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+join">join</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ovenCH is a 5-year mist-netting dataset
ovenRD &lt;- RMarkInput (join(ovenCH))
head(ovenRD)

unRMarkInput(ovenRD)

RMarkInput(deermouse.ESG, covariates = FALSE, grouped = TRUE)
RMarkInput(deermouse.ESG, covariates = TRUE)

## Not run: 
## fit robust-design model in RMark (MARK must be  installed)
library(RMark)
MarkPath &lt;- 'c:/MARK'    ## adjust for your installation
ovenRD.data &lt;- process.data(ovenRD, model = "Robust",
    time.interval = attr(ovenRD, "intervals"))
ovenRD.model &lt;- mark(data = ovenRD.data, model = "Robust",
    model.parameters = list(p = list(formula = ~1, share = TRUE),
    GammaDoublePrime = list(formula = ~1),
    GammaPrime = list(formula = ~1),
    f0 = list(formula = ~1)))   
cleanup(ask = FALSE)

## End(Not run)


</code></pre>

<hr>
<h2 id='RSE'>RSE from Fitted Model</h2><span id='topic+RSE'></span>

<h3>Description</h3>

<p>Precision of parameter estimates from an SECR model, expressed as relative standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
RSE(fit, parm = NULL, newdata = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSE_+3A_fit">fit</code></td>
<td>
<p>secr or openCR fitted model</p>
</td></tr>
<tr><td><code id="RSE_+3A_parm">parm</code></td>
<td>
<p>character; names of one or more real parameters (default all)</p>
</td></tr>
<tr><td><code id="RSE_+3A_newdata">newdata</code></td>
<td>
<p>dataframe of covariates for <code><a href="#topic+predict.secr">predict.secr</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative standard error (RSE) of parameter <code class="reqn">\theta</code> is <code class="reqn">RSE(\hat \theta) = \widehat{SE} (\theta) / {\hat \theta}</code>. 
</p>
<p>For a parameter estimated using a log link with single coefficient <code class="reqn">\beta</code>, the RSE is also <code class="reqn">\mbox{RSE}(\hat \theta) = \sqrt {\exp( \mbox{var}(\beta))-1}</code>.
This formula is used wherever applicable.
</p>


<h3>Value</h3>

<p>Named vector of RSE, or matrix if newdata has more than one row.
</p>


<h3>Note</h3>

<p>The less explicit abbreviation CV has been used for the same quantity (sometimes expressed as a percentage). CV is used also for the relative standard deviation of a distribution.
</p>


<h3>References</h3>

<p>Efford, M. G. and Boulanger, J. 2019. Fast evaluation of study designs for spatially explicit capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>10</b>, 1529&ndash;1535.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CV">CV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
RSE(secrdemo.0)

</code></pre>

<hr>
<h2 id='Rsurface'> Smoothed Resource Surface</h2><span id='topic+Rsurface'></span>

<h3>Description</h3>

<p>Creates a smoothed resource surface from a covariate of a
mask. Smoothing entails summing the value in each pixel weighted by a
detection kernel centred on the focal pixel. The detection kernel
represents home-range utilization with spatial scale sigma. The
resulting surface is equivalent to the denominator used by Royle et
al. (2013) to normalize site-specific detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Rsurface(mask, sigma, usecov = NULL, alpha2 = 1, detectfn = 'HHN', z = 1,
 inverse = FALSE, scale = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rsurface_+3A_mask">mask</code></td>
<td>
<p>secr habitat mask object (single-session)</p>
</td></tr>
<tr><td><code id="Rsurface_+3A_sigma">sigma</code></td>
<td>
<p>numeric spatial scale of home range model</p>
</td></tr>
<tr><td><code id="Rsurface_+3A_alpha2">alpha2</code></td>
<td>
<p>numeric coefficient of spatial covariate</p>
</td></tr>
<tr><td><code id="Rsurface_+3A_usecov">usecov</code></td>
<td>
<p>character name of resource covariate</p>
</td></tr>
<tr><td><code id="Rsurface_+3A_detectfn">detectfn</code></td>
<td>
<p>integer or character code for detection function</p>
</td></tr>
<tr><td><code id="Rsurface_+3A_z">z</code></td>
<td>
<p>numeric shape parameter of home range model</p>
</td></tr>
<tr><td><code id="Rsurface_+3A_inverse">inverse</code></td>
<td>
<p>logical; if TRUE the reciprocal of smoothed resource is returned</p>
</td></tr>
<tr><td><code id="Rsurface_+3A_scale">scale</code></td>
<td>
<p>logical; not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>detectfn</code> may be uniform (&lsquo;UN&rsquo;) or one of the
cumulative-hazard functions (&lsquo;HHN&rsquo;, &lsquo;HHR&rsquo;, &lsquo;HEX&rsquo;,
&lsquo;HAN&rsquo;, &lsquo;HCG&rsquo;) (or integer codes 4, 14:18; see
<a href="#topic+detectfn">detectfn</a>).
</p>
<p>The default &lsquo;HHN&rsquo; corresponds to a halfnormal function on the hazard
scale, or a bivariate circular normal home range.
</p>
<p>If <code>usecov</code> is not named then it takes the value 1.0 for all points
on the mask and zero otherwise.
</p>
<p>The Rsurface can be used implicitly to normalize detection probability when
fitting a model with detector-specific covariate equal to
<code>usecov</code> (see <a href="#topic+details">details</a>, but the process is intricate and not
fully documented).
</p>


<h3>Value</h3>

<p>An object with class c(&lsquo;Rsurface&rsquo;, &lsquo;mask&rsquo;, &lsquo;data.frame&rsquo;) and covariate &lsquo;Resource&rsquo;
(other covariates are retained from the input mask). The attribute
&lsquo;scale&rsquo; is 1.0 if <code>scale = FALSE</code>; otherwise it is the average of the
resource over the masked area.
</p>


<h3>Note</h3>

<p>Consider a focal pixel <b>s</b> and another point in the habitat mask
<b>x</b>, with distance <code class="reqn">d = |x - s|</code>. Weights are given by a kernel <code class="reqn">f(d)</code>. Typically the kernel
will be halfnormal <code class="reqn">f(d) = \exp(-d^2/(2\sigma^2))</code> (detectfn = &lsquo;HHN&rsquo;) or exponential
<code class="reqn">f(d) = \exp(-d/\sigma)</code> (detectfn =
&lsquo;HEX&rsquo;) (see <a href="#topic+detectfn">detectfn</a> for other possibilities).
</p>
<p>If <code class="reqn">z(x)</code> represents the covariate value at point
<b>x</b>, the summed resource availability at <b>s</b> is given by
</p>
<p style="text-align: center;"><code class="reqn">R(s) = \sum_x f(d)\, \exp(\alpha_2 \,
  z(x)).</code>
</p>

<p>This corresponds to the denominator of eqn 4 in Royle et al. (2013).
</p>
<p>By default, the numerical values reported by <code>Rsurface</code> are not raw
<code class="reqn">R</code> values. If <code>scale = TRUE</code>, values are standardized by
dividing by the mean: <code class="reqn">R'(s) = R(s) /
  (\sum_s R(s) / n)</code> where <code class="reqn">n</code> is the number of
pixels. Values of <code class="reqn">R'(s)</code> are centred on 1.0.
</p>
<p>If <code>inverse = TRUE</code>, the numeric values are <code class="reqn">1 /
  R'(s)</code>
or <code class="reqn">1 / R(s)</code> as determined by <code>scale</code>.
</p>


<h3>References</h3>

<p>Royle, J. A., Chandler, R. B., Sun, C. C. and Fuller, A. K. (2013)
Integrating resource selection information with spatial
capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>4</b>,
520&ndash;530.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+plot.Rsurface">plot.Rsurface</a></code>,
<code><a href="#topic+spotHeight">spotHeight</a></code>, <a href="#topic+details">details</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create binary covariate (0 outside habitat)
msk &lt;- make.mask(traps(possumCH), buffer = 800)
covariates(msk) &lt;- data.frame(z = as.numeric(pointsInPolygon
    (msk,possumarea)))

## derive and plot "resource availability"
Rs &lt;- Rsurface(msk, sigma = 100, usecov = 'z')
plot(Rs, plottype = 'contour', col = topo.colors(10))
lines(possumarea)

if (interactive()) {
    spotHeight(Rs, dec = 2)
}

</code></pre>

<hr>
<h2 id='score.test'> Score Test for SECR Models </h2><span id='topic+score.test'></span><span id='topic+score.table'></span>

<h3>Description</h3>

<p>Compute score tests comparing a fitted model and a more general alternative model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.test(secr, ..., betaindex = NULL, trace = FALSE, ncores = NULL, .relStep = 0.001,
    minAbsPar = 0.1)

score.table(object, ..., sort = TRUE, dmax = 10)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.test_+3A_secr">secr</code></td>
<td>
<p> fitted secr model </p>
</td></tr>
<tr><td><code id="score.test_+3A_...">...</code></td>
<td>
<p> one or more alternative models OR a fitted secr model </p>
</td></tr>
<tr><td><code id="score.test_+3A_trace">trace</code></td>
<td>
<p> logical. If TRUE then output one-line summary at each
evaluation of the likelihood </p>
</td></tr>
<tr><td><code id="score.test_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads for parallel processing</p>
</td></tr> 
<tr><td><code id="score.test_+3A_.relstep">.relStep</code></td>
<td>
<p>see <code><a href="nlme.html#topic+fdHess">fdHess</a></code></p>
</td></tr>
<tr><td><code id="score.test_+3A_minabspar">minAbsPar</code></td>
<td>
<p>see <code><a href="nlme.html#topic+fdHess">fdHess</a></code></p>
</td></tr>
<tr><td><code id="score.test_+3A_betaindex">betaindex</code></td>
<td>
<p> vector of indices mapping fitted values to parameters in the alternative model </p>
</td></tr>
<tr><td><code id="score.test_+3A_object">object</code></td>
<td>
<p> score.test object or list of such objects </p>
</td></tr>
<tr><td><code id="score.test_+3A_sort">sort</code></td>
<td>
<p> logical for whether output rows should be in descending order of AICc </p>
</td></tr>
<tr><td><code id="score.test_+3A_dmax">dmax</code></td>
<td>
<p> threshold of dAICc for inclusion in model set </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Score tests allow fast model selection (e.g. Catchpole &amp; Morgan 1996).
Only the simpler model need be fitted. This implementation uses the
observed information matrix, which may sometimes mislead (Morgan et al.
2007). The gradient and second derivative of the likelihood function are
evaluated numerically at the point in the parameter space of the second
model corresponding to the fit of the first model. This operation uses
the function <code>fdHess</code> of the <span class="pkg">nlme</span> package; the likelihood
must be evaluated several times, but many fewer times than would be
needed to fit the model. The score statistic is an approximation to the
likelihood ratio; this allows the difference in AIC to be estimated.
</p>
<p>Covariates are inferred from components of the reference model
<code>secr</code>. If the new models require additional covariates these may
usually be added to the respective component of <code>secr</code>. 
</p>
<p>Mapping of parameters between the fitted and alternative models
sometimes requires user intervention via the <code>betaindex</code> argument.
For example <code>betaindex</code> = c(1,2,4) is the correct mapping when
comparing the null model (D<code class="reqn">\sim{~}</code>1, g0<code class="reqn">\sim{~}</code>1,
sigma<code class="reqn">\sim{~}</code>1) to one with a behavioural effect on g0
(D<code class="reqn">\sim{~}</code>1, g0<code class="reqn">\sim{~}</code>b, sigma<code class="reqn">\sim{~}</code>1).
</p>
<p>The arguments <code>.relStep</code> and <code>minAbsPar</code> control the numerical
gradient calculation and are passed directly to
<code><a href="nlme.html#topic+fdHess">fdHess</a></code>. More investigation is needed to determine
optimal settings.
</p>
<p><code>score.table</code> summarises one or more score tests in the form of a
model comparison table. The ... argument here allows the inclusion of
additional score test objects (note the meaning differs from
<code>score.test</code>). Approximate AICc values are used to compute relative
AIC model weights for all models within dmax AICc units of the best
model.
</p>
<p>If <code>ncores = NULL</code> then the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS is used (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>


<h3>Value</h3>

<p>An object of class &lsquo;score.test&rsquo; that inherits from &lsquo;htest&rsquo;, a list with components
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value the chi-squared test statistic (score statistic)</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom of the approximate chi-squared distribution of the test statistic (difference in number of parameters H0, H1)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>probability of test statistic assuming chi-square distribution</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the type of test performed </p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>character string with null hypothesis, alternative hypothesis and arguments to function call from fit of H0 </p>
</td></tr>
<tr><td><code>H0</code></td>
<td>
<p>simpler model </p>
</td></tr>
<tr><td><code>np0</code></td>
<td>
<p>number of parameters in simpler model </p>
</td></tr>
<tr><td><code>H1</code></td>
<td>
<p>alternative model </p>
</td></tr>
<tr><td><code>H1.beta</code></td>
<td>
<p>coefficients of alternative model </p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's information criterion, approximated from score statistic </p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with small-sample adjustment of Hurvich &amp; Tsai 1989 </p>
</td></tr>
</table>
<p>If ... defines several alternative models then a list of score.test objects is returned.
</p>
<p>The output from <code>score.table</code> is a dataframe with one row per model, including the reference model. 
</p>


<h3>Note</h3>

<p>This implementation is experimental. The AIC values, and values derived
from them, are approximations that may differ considerably from AIC
values obtained by fitting and comparing the respective models. Use of
the observed information matrix may not be optimal.
</p>


<h3>References</h3>

 
<p>Catchpole, E. A. and Morgan, B. J. T. (1996) Model selection of ring-recovery models using score tests. <em>Biometrics</em> <b>52</b>, 664&ndash;672.
</p>
<p>Hurvich, C. M. and Tsai, C. L. (1989) Regression and time series model selection in small samples. <em>Biometrika</em> <b>76</b>, 297&ndash;307.
</p>
<p>McCrea, R. S. and Morgan, B. J. T. (2011) Multistate mark-recapture
model selection using score tests. <em>Biometrics</em> <b>67</b>,
234&ndash;241.
</p>
<p>Morgan, B. J. T., Palmer, K. J. and Ridout, M. S. (2007) Negative score test statistic. <em>American statistician</em> <b>61</b>, 285&ndash;288.
</p>


<h3>See Also</h3>

 
<p><code><a href="stats.html#topic+AIC">AIC</a></code>, 
<code><a href="#topic+LR.test">LR.test</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
    AIC (secrdemo.0, secrdemo.b)
    st &lt;- score.test (secrdemo.0, g0 ~ b)
    st
    score.table(st)

    ## adding a time covariate to separate occasions (1,2) from (3,4,5)
    secrdemo.0$timecov &lt;- data.frame(t2 = factor(c(1,1,2,2,2)))
    st2 &lt;- score.test (secrdemo.0, g0 ~ t2)
    score.table(st,st2)

## End(Not run)

</code></pre>

<hr>
<h2 id='secr-defunct'>Defunct Functions in Package <span class="pkg">secr</span></h2><span id='topic+secr-defunct'></span><span id='topic+model.average'></span><span id='topic+ip.secr'></span><span id='topic+pfn'></span><span id='topic+make.newdata'></span><span id='topic+secr.make.newdata'></span><span id='topic+read.SPACECAP'></span><span id='topic+write.SPACECAP'></span>

<h3>Description</h3>

<p>These functions are no longer available in <span class="pkg">secr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
# Defunct in 4.6.2 (2023-09-30)

model.average()

# Defunct in 4.5.10 (2023-03-10)

ip.secr()
pfn()

# Defunct in 4.4.2 (2021-05-04)

make.newdata()

# Defunct in 4.4.0 (2021-05-01)

secr.make.newdata()

# Defunct in 4.0.0 (2019-10-27)

read.SPACECAP()
write.SPACECAP()

</code></pre>


<h3>Details</h3>

<p>Some of these have stubs which report that they are defunct, but most have been 
removed completely (apart from being documented here). 
</p>
<p><code>model.average</code> is replaced by a method for &lsquo;secr&rsquo; and &lsquo;secrlist&rsquo; objects of the generic <code><a href="#topic+modelAverage">modelAverage</a></code>. The internal code is essentially the same for <code>model.average</code> and <code>modelAverage.secrlist</code>. The generic avoids a name conflict with RMark and is also used in <span class="pkg">openCR</span>.
</p>
<p><code>ip.secr</code> and <code>pfn</code> have been superceded by <code>ipsecr.fit</code> and 
<code>proxy.ms</code> in package <span class="pkg">ipsecr</span>.
</p>
<p>Internal functions <code>secr.make.newdata</code> and <code>make.newdata</code> were 
replaced with <code>makeNewData</code> generic from 4.4.2.
</p>
<p>SPACECAP was removed from the CRAN archive on 2019-08-31.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr-deprecated">secr-deprecated</a></code>
</p>

<hr>
<h2 id='secr-deprecated'>Deprecated Functions in Package <span class="pkg">secr</span></h2><span id='topic+secr-deprecated'></span><span id='topic+par.secr.fit'></span><span id='topic+par.region.N'></span><span id='topic+par.derived'></span>

<h3>Description</h3>

<p>These functions will be removed from future versions of <span class="pkg">secr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
par.secr.fit (arglist, ncores = 1, seed = NULL, trace = TRUE, logfile = "logfile.txt", 
    prefix = "fit.", LB = FALSE, save.intermediate = FALSE)
par.derived (secrlist, ncores = 1, ...)
par.region.N (secrlist, ncores = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secr-deprecated_+3A_arglist">arglist</code></td>
<td>
<p>list of argument lists for <code>secr.fit</code> or a character
vector naming such lists</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_ncores">ncores</code></td>
<td>
<p> integer number of cores to be used for parallel processing</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_seed">seed</code></td>
<td>
<p>integer pseudorandom number seed</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_trace">trace</code></td>
<td>
<p>logical; if TRUE intermediate output may be logged</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_logfile">logfile</code></td>
<td>
<p>character name of file to log progress reports</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_prefix">prefix</code></td>
<td>
<p>character prefix for names of output</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_lb">LB</code></td>
<td>
<p>logical; if TRUE then use load balancing</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_save.intermediate">save.intermediate</code></td>
<td>
<p>logical; if TRUE then each fit is saved to an external file</p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>derived</code> or <code>region.N</code></p>
</td></tr>
<tr><td><code id="secr-deprecated_+3A_secrlist">secrlist</code></td>
<td>
<p>secrlist object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the introduction of multi-threading in <span class="pkg">secr</span> 4.0 it is no longer efficient to use parallel worker processes.
</p>
<p><code><a href="#topic+list.secr.fit">list.secr.fit</a></code> replaces <code>par.secr.fit</code>.
</p>
<p>Functions par.derived and par.region.N can be replaced by a simple call of lapply (see Examples in <code><a href="#topic+list.secr.fit">list.secr.fit</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr-defunct">secr-defunct</a></code>, 
</p>

<hr>
<h2 id='secr.design.MS'> Construct Detection Model Design Matrices and Lookups </h2><span id='topic+secr.design.MS'></span><span id='topic+make.lookup'></span><span id='topic+insertdim'></span>

<h3>Description</h3>

<p>Internal functions used by <code><a href="#topic+secr.fit">secr.fit</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
secr.design.MS (capthist, models, timecov = NULL, sessioncov = NULL, 
    groups = NULL, hcov = NULL, dframe = NULL, naive = FALSE, CL = FALSE,
    keep.dframe = FALSE, full.dframe = FALSE, ignoreusage = FALSE, contrasts = NULL, ...)

make.lookup (tempmat)

insertdim (x, dimx, dims) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secr.design.MS_+3A_capthist">capthist</code></td>
<td>
 <p><code>capthist</code> object </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_models">models</code></td>
<td>
<p> list of formulae for parameters of detection </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_timecov">timecov</code></td>
<td>
<p> optional dataframe of values of time (occasion-specific) covariate(s). </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_sessioncov">sessioncov</code></td>
<td>
<p> optional dataframe of values of session-specific covariate(s). </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_groups">groups</code></td>
<td>
<p> optional vector of one or more variables with which to
form groups. Each element should be the name of a factor variable in
the <code>covariates</code> attribute of <code>capthist</code>. </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_hcov">hcov</code></td>
<td>
<p> character name of an individual (capthist) covariate for known class
membership in h2 models</p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_dframe">dframe</code></td>
<td>
<p> optional data frame of design data for detection parameters </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_naive">naive</code></td>
<td>
<p> logical if TRUE then modelled detection probability is for a naive animal (not caught previously); if FALSE then detection probability is contingent on individual's history of detection </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_cl">CL</code></td>
<td>
<p> logical; TRUE for model to be fitted by maximizing the conditional likelihood </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_keep.dframe">keep.dframe</code></td>
<td>
<p>logical; if TRUE the dataframe of design data is
included in the output</p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_full.dframe">full.dframe</code></td>
<td>
<p>logical; if FALSE then padding rows are purged from
output dframe (ignored if <code>keep.dframe = FALSE</code>)</p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_ignoreusage">ignoreusage</code></td>
<td>
<p>logical; if TRUE any usage attribute of traps(capthist)
is ignored</p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_contrasts">contrasts</code></td>
<td>
<p>contrast specification as for <code><a href="stats.html#topic+model.matrix">model.matrix</a></code></p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_...">...</code></td>
<td>
<p> other arguments passed to the <span class="rlang"><b>R</b></span> function
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code> </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_tempmat">tempmat</code></td>
<td>
<p>matrix for which row lookup required</p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_x">x</code></td>
<td>
<p>vector of character, numeric or factor values </p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_dimx">dimx</code></td>
<td>
<p>vector of notional dimensions for x to fill in target array</p>
</td></tr>
<tr><td><code id="secr.design.MS_+3A_dims">dims</code></td>
<td>
<p>vector of notional dimensions of target array</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are internal <span class="pkg">secr</span> functions that you are unlikely ever to
use. 
</p>
<p>Each real parameter is notionally different for each unique combination
of session, individual, occasion, detector and latent class, i.e., for <code class="reqn">R</code>
sessions, <code class="reqn">n</code> individuals, <code class="reqn">S</code> occasions and <code class="reqn">K</code> detectors
there are <em>potentially</em> <code class="reqn">R \times n \times S \times K</code> different values. Actual models always predict a <em>much</em> reduced set
of distinct values, and the number of rows in the design matrix is
reduced correspondingly; a parameter index array allows these to
retrieved for any combination of session, individual, occasion and
detector.
</p>
<p>The <code>keep.dframe</code> option is provided for the rare occasions that a
user may want to check the data frame that is an intermediate step in
computing each design matrix with <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> (i.e. the
data argument of <code>model.matrix</code>).
</p>
<p>... may be used to pass <code>contrasts.arg</code> to <code>model.matrix</code>. 
</p>


<h3>Value</h3>

<p>For <code>secr.design.MS</code>, a list with the components
</p>
<table>
<tr><td><code>designMatrices</code></td>
<td>
<p> list of reduced design matrices, one for each
real detection parameter </p>
</td></tr>
<tr><td><code>parameterTable</code></td>
<td>
<p> index to row of the reduced design matrix for
each real detection parameter; dim(parameterTable) = c(uniquepar, np),
where uniquepar is the number of unique combinations of paramater
values (uniquepar &lt; <code class="reqn">RnSKM</code>) and np is the number of parameters in
the detection model. </p>
</td></tr>
<tr><td><code>PIA</code></td>
<td>
<p> Parameter Index Array - index to row of parameterTable for
a given session, animal, occasion and detector; dim(PIA) =
c(R,n,S,K,M) </p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p> number of sessions</p>
</td></tr>
</table>
<p>If <code>models</code> is empty then all components are NULL except for PIA
which is an array of 1's (M set to 1).  
</p>
<p>Optionally (<code>keep.dframe = TRUE</code>) -
</p>
<table>
<tr><td><code>dframe</code></td>
<td>
<p> dataframe of design data, one column per covariate, one
row for each c(R,n,S,K,M). For multi-session models n, S, and K
refer to the maximum across sessions</p>
</td></tr>
<tr><td><code>validdim</code></td>
<td>
<p> list giving the valid dimensions (n, S, K, M) before padding</p>
</td></tr>
</table>
<p>For <code>make.lookup</code>, a list with components
</p>
<table>
<tr><td><code>lookup</code></td>
<td>
<p> matrix of unique rows</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p> indices in lookup of the original rows</p>
</td></tr>
</table>
<p>For <code>insertdim</code>, a vector with length prod(dims) containing the 
values replicated according to dimx.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+D.designdata">D.designdata</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>secr.design.MS (captdata, models = list(g0 = ~b))$designMatrices
secr.design.MS (captdata, models = list(g0 = ~b))$parameterTable

## peek at design data constructed for learned response model
head(captdata)
temp &lt;- secr.design.MS (captdata, models = list(g0 = ~b),
    keep.dframe = TRUE)
a1 &lt;- temp$dframe$animal == 1 &amp;  temp$dframe$detector %in% 8:10
temp$dframe[a1,]

## ... and trap specific learned response model
temp &lt;- secr.design.MS (captdata, models = list(g0 = ~bk),
    keep.dframe = TRUE)
a1 &lt;- temp$dframe$animal == 1 &amp;  temp$dframe$detector %in% 8:10
temp$dframe[a1,]

## place values 1:6 in different dimensions
insertdim(1:6, 1:2, c(2,3,6))
insertdim(1:6, 3, c(2,3,6))

</code></pre>

<hr>
<h2 id='secr.fit'> Spatially Explicit Capture&ndash;Recapture </h2><span id='topic+secr.fit'></span>

<h3>Description</h3>

<p>Estimate animal population density with data from an array of passive
detectors (traps) by fitting a spatial detection model by maximizing the
likelihood. Data must have been assembled as an object of class
<code>capthist</code>. Integration is by summation over the grid of points in
<code>mask</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
secr.fit (capthist, model = list(D~1, g0~1, sigma~1), mask = NULL, buffer = NULL,
    CL = FALSE, detectfn = NULL, binomN = NULL, start = NULL, link = list(),
    fixed = list(), timecov = NULL, sessioncov = NULL, hcov = NULL,
    groups = NULL, dframe = NULL, details = list(), method =
    "Newton-Raphson", verify = TRUE, biasLimit = 0.01, trace = NULL,
    ncores = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secr.fit_+3A_capthist">capthist</code></td>
<td>
 <p><code><a href="#topic+capthist">capthist</a></code> object including capture data and detector (trap) layout </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_mask">mask</code></td>
<td>
 <p><code><a href="#topic+mask">mask</a></code> object or (for a multi-session analysis) a list of <code>mask</code> objects, one for each session</p>
</td></tr>
<tr><td><code id="secr.fit_+3A_buffer">buffer</code></td>
<td>
<p> scalar mask buffer radius if <code>mask</code> not specified
(default 100 m)</p>
</td></tr>
<tr><td><code id="secr.fit_+3A_cl">CL</code></td>
<td>
<p> logical, if true then the model is fitted by maximizing the conditional likelihood </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of
detection function 0 = halfnormal, 1 = hazard rate etc. &ndash; see
<a href="#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="secr.fit_+3A_binomn">binomN</code></td>
<td>
<p> integer code for distribution of counts (see Details) </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_start">start</code></td>
<td>
<p> vector of initial values for beta parameters, or <code>secr</code> object from which they may be derived </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_link">link</code></td>
<td>
<p> list with optional components corresponding to &lsquo;real&rsquo;
parameters (e.g., &lsquo;D&rsquo;, &lsquo;g0&rsquo;, &lsquo;sigma&rsquo;), each a character string in
{&quot;log&quot;, &quot;logit&quot;, &quot;identity&quot;, &quot;sin&quot;} for the link function of one real parameter </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_fixed">fixed</code></td>
<td>
<p> list with optional components corresponding to real parameters giving the scalar value to which the parameter is to be fixed </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_model">model</code></td>
<td>
<p> list with optional components each symbolically defining a linear predictor for one real parameter using <code>formula</code> notation </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_timecov">timecov</code></td>
<td>
<p> optional dataframe of values of time (occasion-specific) covariate(s). </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_sessioncov">sessioncov</code></td>
<td>
<p> optional dataframe of values of session-specific covariate(s). </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_hcov">hcov</code></td>
<td>
<p> character name of individual covariate for known
membership of mixture classes. </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_groups">groups</code></td>
<td>
<p> optional vector of one or more variables with which to form groups. Each element should be the name of a factor variable in the <code>covariates</code> attribute of <code>capthist</code>. </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_dframe">dframe</code></td>
<td>
<p> optional data frame of design data for detection parameters </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_details">details</code></td>
<td>
<p> list of additional settings, mostly model-specific (see Details) </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_method">method</code></td>
<td>
<p> character string giving method for maximizing log likelihood </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_verify">verify</code></td>
<td>
<p> logical, if TRUE the input data are checked with <code><a href="#topic+verify">verify</a></code> </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_biaslimit">biasLimit</code></td>
<td>
<p> numeric threshold for predicted relative bias due to
buffer being too small </p>
</td></tr>
<tr><td><code id="secr.fit_+3A_trace">trace</code></td>
<td>
<p> logical, if TRUE then output each evaluation of the likelihood, and other messages</p>
</td></tr>
<tr><td><code id="secr.fit_+3A_ncores">ncores</code></td>
<td>
<p> integer number of threads to use for parallel processing</p>
</td></tr>
<tr><td><code id="secr.fit_+3A_...">...</code></td>
<td>
<p> other arguments passed to the maximization function </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>secr.fit</code> fits a SECR model by maximizing the likelihood. The
likelihood depends on the detector type (&quot;multi&quot;, &quot;proximity&quot;, &quot;count&quot;,
&quot;polygon&quot; etc.) of the <code>traps</code> attribute of <code>capthist</code>
(Borchers and Efford 2008, Efford, Borchers and Byrom 2009, Efford,
Dawson and Borchers 2009, Efford 2011). The &lsquo;multi&rsquo; form of the
likelihood is also used, with a warning, when detector type = &quot;single&quot;
(see Efford et al. 2009 for justification).
</p>
<p>The default <code>model</code> is null (<code>model = list(D~1, g0~1,
sigma~1)</code> for <code>detectfn = 'HN'</code> and <code>CL = FALSE</code>), meaning
constant density and detection probability). The set of variables
available for use in linear predictors includes some that are
constructed automatically (t, T, b, B, bk, Bk, k, K), group (g), and
others that appear in the <code>covariates</code> of the input data. See also
<code><a href="#topic+usage">usage</a></code> for varying effort, <code><a href="#topic+timevaryingcov">timevaryingcov</a></code> to
construct other time-varying detector covariates, and <a href="https://www.otago.ac.nz/density/pdfs/secr-models.pdf">secr-models.pdf</a>
and <a href="../doc/secr-overview.pdf">secr-overview.pdf</a> for more on
defining models.
</p>
<p><code>buffer</code> and <code>mask</code> are alternative ways to define the region
of integration (see <a href="#topic+mask">mask</a>). If <code>mask</code> is not specified then a
mask of type &quot;trapbuffer&quot; will be constructed automatically using the
specified buffer width in metres.
</p>
<p><code>hcov</code> is used to define a hybrid mixture model, used especially to
model sex differences (see <code><a href="#topic+hcov">hcov</a></code>). (Allows some animals to
be of unknown class).
</p>
<p>The length of <code>timecov</code> should equal the number of sampling
occasions (<code>ncol(capthist)</code>). Arguments <code>timecov</code>,
<code>sessioncov</code> and <code>groups</code> are used only when needed for terms
in one of the model specifications. Default <code>link</code> is <code>list(D="log",
g0="logit", sigma="log")</code>.
</p>
<p>If <code>start</code> is missing then <code><a href="#topic+autoini">autoini</a></code> is used for D, g0
and sigma, and other beta parameters are set initially to arbitrary
values, mostly zero. <code>start</code> may be a previously fitted model. In
this case, a vector of starting beta values is constructed from the old
(usually nested) model and additional betas are set to zero. Mapping of
parameters follows the default in <code><a href="#topic+score.test">score.test</a></code>, but user
intervention is not allowed. From 2.10.0 the new and old models need not
share all the same &lsquo;real&rsquo; parameters, but any new real parameters, such
as &lsquo;pmix&rsquo; for finite mixture models, receive a starting value of 0 on
the link scale (remembering e.g., invlogit(0) = 0.5 for parameter &lsquo;pmix&rsquo;).
</p>
<p><code>binomN</code> (previously a component of <code>details</code>) determines the
distribution that is fitted for the number of detections of an individual
at a particular detector, on a particular occasion, when the detectors
are of type &lsquo;count&rsquo;, &lsquo;polygon&rsquo; or &lsquo;transect&rsquo;:
</p>

<ul>
<li><p>binomN &gt; 1  &mdash; binomial with size binomN
</p>
</li>
<li><p>binomN = 1  &mdash; binomial with size determined by <a href="#topic+usage">usage</a>
</p>
</li>
<li><p>binomN = 0  &mdash; Poisson
</p>
</li></ul>

<p>The default with these detectors is to fit a Poisson distribution.
</p>
<p><code>details</code> is used for various specialized settings listed below. These are
described separately - see <code><a href="#topic+details">details</a></code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
autoini </td><td style="text-align: left;"> session to use for starting values (default 1) </td>
</tr>
<tr>
 <td style="text-align: left;">
centred </td><td style="text-align: left;"> centre x-y coordinates</td>
</tr>
<tr>
 <td style="text-align: left;">
chat </td><td style="text-align: left;"> overdispersion of sighting counts Tu, Tm </td>
</tr>
<tr>
 <td style="text-align: left;">
chatonly </td><td style="text-align: left;"> compute overdispersion for Tu and Tm, then exit </td>
</tr>
<tr>
 <td style="text-align: left;">
contrasts </td><td style="text-align: left;"> coding of factor predictors </td>
</tr>
<tr>
 <td style="text-align: left;">
convexpolygon </td><td style="text-align: left;"> allows non-convex polygons (slower) </td>
</tr>
<tr>
 <td style="text-align: left;">
Dfn </td><td style="text-align: left;"> reparameterization of density model (seldom used directly) </td>
</tr>
<tr>
 <td style="text-align: left;">
Dlambda </td><td style="text-align: left;"> switch density reparameterization to trend model </td>
</tr>
<tr>
 <td style="text-align: left;">
distribution </td><td style="text-align: left;"> binomial vs Poisson N</td>
</tr>
<tr>
 <td style="text-align: left;">
fastproximity </td><td style="text-align: left;"> special handling of binary proximity detectors </td>
</tr>
<tr>
 <td style="text-align: left;">
fixedbeta </td><td style="text-align: left;"> specify fixed beta parameter(s)</td>
</tr>
<tr>
 <td style="text-align: left;">
grain </td><td style="text-align: left;"> grain argument of RcppParallel::parallelFor </td>
</tr>
<tr>
 <td style="text-align: left;">
hessian </td><td style="text-align: left;"> variance method</td>
</tr>
<tr>
 <td style="text-align: left;">
ignoreusage </td><td style="text-align: left;"> override usage in traps object of capthist</td>
</tr>
<tr>
 <td style="text-align: left;">
intwidth2 </td><td style="text-align: left;"> controls optimise when only one parameter</td>
</tr>
<tr>
 <td style="text-align: left;">
knownmarks </td><td style="text-align: left;"> known or unknown number of marked animals in sighting-only model </td>
</tr>
<tr>
 <td style="text-align: left;">
LLonly </td><td style="text-align: left;"> compute one likelihood for values in <code>start</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
maxdistance </td><td style="text-align: left;"> distance threshold for selective mask </td>
</tr>
<tr>
 <td style="text-align: left;">
miscparm </td><td style="text-align: left;"> starting values for extra parameters fitted via userdist function </td>
</tr>
<tr>
 <td style="text-align: left;">
newdetector </td><td style="text-align: left;"> detector type to override detector(traps(capthist)) </td>
</tr>
<tr>
 <td style="text-align: left;">
nsim </td><td style="text-align: left;"> number of simulations to compute overdispersion </td>
</tr>
<tr>
 <td style="text-align: left;">
param </td><td style="text-align: left;"> optional parameterisation code</td>
</tr>
<tr>
 <td style="text-align: left;">
relativeD </td><td style="text-align: left;"> optional relative density conditional on <code class="reqn">n</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
savecall </td><td style="text-align: left;"> optionally suppress saving of call</td>
</tr>
<tr>
 <td style="text-align: left;">
telemetrytype </td><td style="text-align: left;"> treat telemetry data as independent, dependent or concurrent</td>
</tr>
<tr>
 <td style="text-align: left;">
normalize </td><td style="text-align: left;"> rescale detection to individual range use </td>
</tr>
<tr>
 <td style="text-align: left;">
usecov </td><td style="text-align: left;"> spatial covariate of use for normalization </td>
</tr>
<tr>
 <td style="text-align: left;">
userdist </td><td style="text-align: left;"> user-provided distance function or matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>A mark-resight model is fitted if the <code><a href="#topic+markocc">markocc</a></code> attribute of the capthist 
&lsquo;traps&rsquo; object includes sighting occasions. See the vignette 
<a href="https://www.otago.ac.nz/density/pdfs/secr-markresight.pdf">secr-markresight.pdf</a> 
for a full account.
</p>
<p>If <code>method = "Newton-Raphson"</code> then <code><a href="stats.html#topic+nlm">nlm</a></code> is
used to maximize the log likelihood (minimize the negative log
likelihood); otherwise <code><a href="stats.html#topic+optim">optim</a></code> is used with the
chosen method (&quot;BFGS&quot;, &quot;Nelder-Mead&quot;, etc.).  If maximization fails a
warning is given appropriate to the method.
</p>
<p>From secr 2.5.1, <code>method = "none"</code> may be used to skip likelihood
maximization and compute only the hessian for the current dataset at the
values in start, and the corresponding variance-covariance matrix of
beta parameters. The computation uses fdHess from <span class="pkg">nlme</span>.
</p>
<p>If <code>verify</code> = TRUE then <code><a href="#topic+verify">verify</a></code> is called to check
capthist and mask; analysis is aborted if &quot;errors&quot; are found. Some
conditions that trigger an &quot;error&quot; are benign (e.g., no detections in
some sessions of a multi-session study of a sparse population); use
<code>verify = FALSE</code> to avoid the check. See also Note.
</p>
<p>If <code>buffer</code> is used rather than <code>mask</code>, and <code>biasLimit</code>
is valid, then the estimated density is checked for bias due to the
choice of buffer. A warning is generated when <code>buffer</code> appears
to be too small (predicted RB(D-hat) &gt; <code>biasLimit</code>, default 1%
relative bias). The prediction uses <code><a href="#topic+bias.D">bias.D</a></code>. No check
is performed when <code>mask</code> is specified, when <code>biasLimit</code> is 0,
negative or NA, or when the detector type is &quot;polygon&quot;, &quot;transect&quot;,
&quot;polygonX&quot; or &quot;transectX&quot;.
</p>
<p>Function <code><a href="#topic+list.secr.fit">list.secr.fit</a></code> is a way to fit several models at once.
</p>


<h3>Value</h3>

<p>When <code>details$LLonly = TRUE</code> a single log-likelihood is returned, with attributes 
</p>
<table>
<tr><td><code>npar</code></td>
<td>
<p> number of parameters to be estimated,</p>
</td></tr> 
<tr><td><code>preptime</code></td>
<td>
<p> elapsed setup time in seconds,</p>
</td></tr>
<tr><td><code>LLtime</code></td>
<td>
<p> elapsed time for single likelihood evaluation, exclusive of setup.</p>
</td></tr>
</table>
<p>Otherwise, <code>secr.fit</code> returns an object of class secr representing the fitted SECR model.  This has
components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>function call) </p>
</td></tr>
<tr><td><code>capthist</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>detectfn</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>CL</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>timecov</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>sessioncov</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>hcov</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>dframe</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>designD</code></td>
<td>
<p>design matrix for density model; may be NULL</p>
</td></tr>
<tr><td><code>designNE</code></td>
<td>
<p>design matrix for noneuc model; may be NULL</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>reduced design matrices for detection parameters, parameter table and parameter
index array for actual animals (see <code><a href="#topic+secr.design.MS">secr.design.MS</a></code>)</p>
</td></tr>
<tr><td><code>design0</code></td>
<td>
<p>reduced design matrices for detection parameters, parameter table and parameter
index array for &lsquo;naive&rsquo; animal (see <code><a href="#topic+secr.design.MS">secr.design.MS</a></code>)</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>vector of starting values for beta parameters</p>
</td></tr> 
<tr><td><code>link</code></td>
<td>
<p>list with one component for each real parameter
(typically &lsquo;D&rsquo;, &lsquo;g0&rsquo;, &lsquo;sigma&rsquo;),giving the name of the link function
used for each real parameter.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>saved input</p>
</td></tr>  
<tr><td><code>parindx</code></td>
<td>
<p>list with one component for each real parameter giving
the indices of the &lsquo;beta&rsquo; parameters associated with each real
parameter</p>
</td></tr>  
<tr><td><code>model</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>vector of unique variable names in <code>model</code> </p>
</td></tr>
<tr><td><code>betanames</code></td>
<td>
<p>names of beta parameters</p>
</td></tr>
<tr><td><code>realnames</code></td>
<td>
<p>names of fitted (real) parameters </p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>list describing the fit (output from <code>nlm</code> or
<code>optim</code>) </p>
</td></tr>
<tr><td><code>beta.vcv</code></td>
<td>
<p>variance-covariance matrix of beta parameters </p>
</td></tr>  
<tr><td><code>smoothsetup</code></td>
<td>
<p>list of objects specifying smooths in <span class="pkg">mgcv</span></p>
</td></tr>
<tr><td><code>learnedresponse</code></td>
<td>
<p> logical; TRUE if any learned response in detection model</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>secr version number </p>
</td></tr>
<tr><td><code>starttime</code></td>
<td>
<p>character string of date and time at start of fit </p>
</td></tr>
<tr><td><code>proctime</code></td>
<td>
<p>processor time for model fit, in seconds </p>
</td></tr>
</table>
<p>The environment variable RCPP_PARALLEL_NUM_THREADS is updated if an integer value is provided for <code>ncores</code>.
</p>


<h3>Warning</h3>

<p>** Mark-resight data formats and models are experimental in secr 2.10.0 and subject to change **</p>


<h3>Note</h3>

<p>One system of units is used throughout <span class="pkg">secr</span>. Distances are in metres and
areas are in hectares (ha). The unit of density is animals per
hectare. 1 ha = 10000 m^2 = 0.01 km^2. To convert density to animals /
km^2, multiply by 100.
</p>
<p>When you display an &lsquo;secr&rsquo; object by typing its name at the command
prompt, you implicitly call its &lsquo;print&rsquo; method <code><a href="#topic+print.secr">print.secr</a></code>, which
in turn calls <code><a href="#topic+predict.secr">predict.secr</a></code> to tabulate estimates of the &lsquo;real&rsquo;
parameters. Confidence limits (lcl, ucl) are for a 100(1-alpha)%
interval, where alpha defaults to 0.05 (95% interval); alpha may be
varied in <code>print.secr</code> or <code>predict.secr</code>.
</p>
<p><code>AIC</code>, <code>logLik</code> and <code>vcov</code> methods are also
provided. Take care with using AIC: not all models are comparable (see
Notes section of <code><a href="#topic+AIC.secr">AIC.secr</a></code>) and large differences in AIC
may relate to trivial differences in estimated density.
</p>
<p><code>derived</code> is used to compute the derived parameters &lsquo;esa&rsquo;
(effective sampling area) and &lsquo;D&rsquo; (density) for models fitted by
maximizing the conditional likelihood (CL = TRUE).
</p>
<p>Components &lsquo;version&rsquo; and &lsquo;starttime&rsquo; were introduced in version 1.2.7,
and recording of the completion time in &lsquo;fitted&rsquo; was discontinued.
</p>
<p>The Newton-Raphson algorithm is fast, but it sometimes fails to compute
the information matrix correctly, causing some or all standard errors to
be set to NA. This usually indicates a major problem in fitting the
model, and parameter estimates should not be trusted. See
<a href="#topic+Troubleshooting">Troubleshooting</a>.
</p>
<p>The component D in output was replaced with N from version 2.3. Use
<code><a href="#topic+region.N">region.N</a></code> to obtain SE or confidence intervals for N-hat,
or to infer N for a different region.
</p>
<p>Prior to version 2.3.2 the buffer bias check could be switched off by
setting <code>verify = FALSE</code>. This is now done by setting
<code>biasLimit = 0</code> or <code>biasLimit = NA</code> .
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G. (2004) Density estimation in live-trapping studies.
<em>Oikos</em> <b>106</b>, 598&ndash;610.
</p>
<p>Efford, M. G. (2011) Estimation of population density by spatially
explicit capture&ndash;recapture with area searches. <em>Ecology</em>
<b>92</b>, 2202&ndash;2207.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture&ndash;recapture: likelihood-based methods. In:
D. L. Thompson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer. Pp. 255&ndash;269.
</p>
<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009) Population
density estimated from locations of individuals on a passive detector
array. <em>Ecology</em> <b>90</b>, 2676&ndash;2682.
</p>


<h3>See Also</h3>

<p><a href="#topic+Detection+20functions">Detection functions</a>,
<code><a href="#topic+AIC.secr">AIC.secr</a></code>,
<code><a href="#topic+capthist">capthist</a></code>,
<code><a href="#topic+details">details</a></code>,
<code><a href="#topic+derived">derived</a></code>,
<code><a href="#topic+hcov">hcov</a></code>,
<code><a href="#topic+mask">mask</a></code>,
<code><a href="#topic+list.secr.fit">list.secr.fit</a></code>,
<code><a href="#topic+predict.secr">predict.secr</a></code>,
<code><a href="#topic+print.secr">print.secr</a></code>,
<code><a href="#topic+region.N">region.N</a></code>,
<a href="#topic+Speed+20tips">Speed tips</a>
<a href="#topic+Troubleshooting">Troubleshooting</a>
<a href="#topic+userdist">userdist</a>
<code><a href="#topic+usage">usage</a></code>,
<code><a href="#topic+vcov.secr">vcov.secr</a></code>,
<code><a href="#topic+verify">verify</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## construct test data (array of 48 `multi-catch' traps)

detectors &lt;- make.grid (nx = 6, ny = 8, detector = "multi")
detections &lt;- sim.capthist (detectors, popn = list(D = 10,
    buffer = 100), detectpar = list(g0 = 0.2, sigma = 25))

## fit &amp; print null (constant parameter) model
secr0 &lt;- secr.fit (detections)
secr0   ## uses print method for secr

## compare fit of null model with learned-response model for g0

secrb &lt;- secr.fit (detections, model = g0~b)
AIC (secr0, secrb)

## typical result

##                  model   detectfn npar    logLik     AIC    AICc dAICc  AICwt
## secr0 D~1 g0~1 sigma~1 halfnormal    3 -347.1210 700.242 700.928 0.000 0.7733
## secrb D~1 g0~b sigma~1 halfnormal    4 -347.1026 702.205 703.382 2.454 0.2267

## End(Not run)
</code></pre>

<hr>
<h2 id='secr.test'>Goodness-of-Fit Test</h2><span id='topic+secr.test'></span>

<h3>Description</h3>

<p>Simple Monte-Carlo goodness-of-fit tests for full-likelihood SECR
models. The approach is to calculate a statistic from either the raw
data or a fitted model, and to relate this to the distribution of the
statistic under the original fitted model. The distribution is
estimated by simulating data from the model, and possibly re-fitting
the model to each simulated dataset.
</p>
<p>The suitability of different test statistics has yet to be assessed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
secr.test(object, nsim = 99, statfn, fit = FALSE, seed =
NULL, ncores = NULL, tracelevel = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secr.test_+3A_object">object</code></td>
<td>
<p>a fitted secr model</p>
</td></tr>
<tr><td><code id="secr.test_+3A_nsim">nsim</code></td>
<td>
<p>integer number of replicates</p>
</td></tr>
<tr><td><code id="secr.test_+3A_statfn">statfn</code></td>
<td>
<p>function to compute a numeric vector of one or more statistics from a
single-session &lsquo;capthist&rsquo; object or from a fitted model (see Details)</p>
</td></tr>
<tr><td><code id="secr.test_+3A_fit">fit</code></td>
<td>
<p>logical; if TRUE the model is re-fitted to each simulated
dataset</p>
</td></tr>
<tr><td><code id="secr.test_+3A_seed">seed</code></td>
<td>
<p>either NULL or an integer that will be used in a call to <code>set.seed</code></p>
</td></tr>
<tr><td><code id="secr.test_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads for parallel processing</p>
</td></tr>
<tr><td><code id="secr.test_+3A_tracelevel">tracelevel</code></td>
<td>
<p> see <code><a href="#topic+sim.secr">sim.secr</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic(s) may be computed either on a dataset or on a
fitted model, as determined by the argument <code>fit</code>. The single
argument expected by <code>statfn</code> should be either a &lsquo;capthist&rsquo; object
(<code>fit = FALSE</code>) or an &lsquo;secr&rsquo; object (<code>fit = TRUE</code>).
</p>
<p>The default statistic when <code>fit = FALSE</code> is the proportion of
individuals observed on only one occasion, which is equivalent to
<code>statfn = function(CH) c(f1 = sum(apply(abs(CH) &gt; 0,1,sum) == 1) /
nrow(CH))</code>. Repeat detections on one occasion at the same or different
detectors are not counted. The default statistic is therefore not
appropriate for some data, specifically from &lsquo;count&rsquo; or &lsquo;polygon&rsquo;
detectors with few occasions or only one.
</p>
<p>The default statistic when <code>fit = TRUE</code> is the deviance divided by
the residual degrees of freedom (i.e., <code>statfn = function(object)
  c(devdf = deviance(object) / df.residual(object))</code>). 
</p>
<p>The reported probability (p) is the rank of the observed value in the
vector combining the observed value and simulated values, divided by
(nsim + 1). Ranks are computed with <code><a href="base.html#topic+rank">rank</a></code> using the default
<code>ties.method = "average"</code>.
</p>
<p>Simulations take account of the usage attribute of detectors in the
original capthist object, given that usage was defined and ignoreusage was not
set.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p><code>statfn</code> may return a vector of statistics for each observed or
simulated dataset or model: then the value of each statistic will be
calculated for every simulated dataset, and summarised. If <code>fit =
TRUE</code> the vector of statistics may include both those computed on the
raw data (object$capthist) and the fitted model. 
</p>


<h3>Value</h3>

<p>An object of class <code>c('secrtest','list')</code> with components:
</p>
<table>
<tr><td><code>object</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>statfn</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>as input</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>list comprising the simulated values,
the observed value(s), and estimated probabilities</p>
</td></tr>
</table>
<p>For multi-session input when <code>fit = FALSE</code>, &lsquo;output&rsquo; is a list
in which each session provides one component.
</p>
<p>Print and plot methods are provided for &lsquo;secrtest&rsquo; objects.
</p>


<h3>Note</h3>

<p><code>simulate.secr</code> is always used to simulate the raw data, but
<code>simulate.secr</code> does not work for all types of fitted
model. Models fitted by maximizing the likelihood conditional on
<code class="reqn">n</code> (<code>CL = TRUE</code> in <code>secr.fit</code>) potentially include
individual covariates whose distribution in the population is
unknown. This precludes simulation, and conditional-likelihood models
in general are therefore not covered by <code>secr.test</code>.
</p>
<p>Other exclusions include exotic non-binary behavioural responses
(&ldquo;bn&quot;, &ldquo;bkn&quot;, &ldquo;bkc&quot;, &ldquo;Bkc&quot; - but these are generally undocumented
in any case).
</p>
<p>If <code>fit = TRUE</code> then <code>sim.secr</code> is used.
</p>
<p>At each simulation a new population is generated across the extent of
the original mask. If the extent is unduly large then time will be
wasted simulating the possibility of detection for many essentially
undetectable animals. This is an argument for keeping the mask tight -
large enough only to avoid mask-induced bias.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.secrtest">print.secrtest</a></code>,
<code><a href="#topic+plot.secrtest">plot.secrtest</a></code>,
<code><a href="#topic+simulate.secr">simulate.secr</a></code>,
<code><a href="#topic+sim.secr">sim.secr</a></code>,
<code><a href="#topic+deviance.secr">deviance.secr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

secr.test(secrdemo.0, nsim = 99)

secr.test(ovenbird.model.1, nsim = 20)

## example combining raw data summary and model fit
## assumes single-session
bothfn &lt;- function(object) {
    CH &lt;- object$capthist
    f1 &lt;- sum(apply(abs(CH) &gt; 0, 1, sum) == 1) / nrow(CH)
    devdf &lt;- deviance(object) / df.residual(object)
    c(f1 = f1, devdf = devdf)
}
test &lt;- secr.test (secrdemo.0, nsim = 19, statfn = bothfn, fit = TRUE)
test
plot(test, main = '')


## End(Not run)

</code></pre>

<hr>
<h2 id='secrdemo'> SECR Models Fitted to Demonstration Data </h2><span id='topic+secrdemo'></span><span id='topic+captXY'></span><span id='topic+trapXY'></span><span id='topic+captdata'></span><span id='topic+secrdemo.0'></span><span id='topic+secrdemo.b'></span><span id='topic+secrdemo.CL'></span>

<h3>Description</h3>

<p>Demonstration data from program Density are provided as text
files in the &lsquo;extdata&rsquo; folder, as raw dataframes (<code>trapXY</code>,
<code>captXY</code>), and as a combined <code>capthist</code> object
(<code>captdata</code>) ready for input to <code>secr.fit</code>.
</p>
<p>The fitted models are objects of class <code>secr</code> formed by 
</p>
<p><code>secrdemo.0 &lt;- secr.fit (captdata)</code>
</p>
<p><code>secrdemo.b &lt;- secr.fit (captdata, model = list(g0 = ~b))</code>
</p>
<p><code>secrdemo.CL &lt;- secr.fit (captdata, CL = TRUE) </code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(secrdemo)</code></pre>


<h3>Details</h3>

<p>The raw data are 235 fictional captures of 76 animals over 5 occasions
in 100 single-catch traps 30 metres apart on a square grid with origin
at (365,365).
</p>
<p>Dataframe <code>trapXY</code> contains the data from the Density input file
&lsquo;trap.txt&rsquo;, and <code>captXY</code> contains the data from &lsquo;capt.txt&rsquo; (Efford
2012).
</p>
<p>The fitted models use a halfnormal detection function and the likelihood
for multi-catch traps (expect estimates of g0 to be biased because of
trap saturation Efford et al.  2009). The first is a null model
(i.e. parameters constant) and the second fits a learned trap response.
</p>

<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
  captXY </td><td style="text-align: left;"> data.frame of capture data </td>
</tr>
<tr>
 <td style="text-align: left;">
  trapXY </td><td style="text-align: left;"> data.frame of trap locations </td>
</tr>
<tr>
 <td style="text-align: left;">
  captdata </td><td style="text-align: left;"> capthist object </td>
</tr>
<tr>
 <td style="text-align: left;">
  secrdemo.0 </td><td style="text-align: left;"> fitted secr model -- null </td>
</tr>
<tr>
 <td style="text-align: left;">
  secrdemo.b </td><td style="text-align: left;"> fitted secr model -- g0 trap response </td>
</tr>
<tr>
 <td style="text-align: left;">
  secrdemo.CL </td><td style="text-align: left;"> fitted secr model -- null, conditional likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+read.capthist">read.capthist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## navigate to folder with raw data files
olddir &lt;- setwd (system.file("extdata", package="secr"))

## construct capthist object from raw data
captdata  &lt;- read.capthist ("capt.txt", "trap.txt", fmt = "XY", detector = "single")

## generate demonstration fits
secrdemo.0 &lt;- secr.fit (captdata)
secrdemo.CL &lt;- secr.fit (captdata, CL = TRUE)
secrdemo.b &lt;- secr.fit (captdata, model = list(g0 ~ b))

## restore previous setting
setwd(olddir)

## End(Not run)

## display the null model fit, using the print method for secr
secrdemo.0

## compare fit of models
AIC(secrdemo.0, secrdemo.b)

## display estimates for the two models (single session)
collate(secrdemo.0, secrdemo.b)[1,,,]

</code></pre>

<hr>
<h2 id='secrRNG'> Random Number Seed </h2><span id='topic+random+20numbers'></span><span id='topic+seed'></span><span id='topic+secrRNG'></span>

<h3>Description</h3>

<p>The use of random number seeds in <span class="pkg">secr</span> is explained.
</p>


<h3>Random numbers in <span class="rlang"><b>R</b></span></h3>

<p><span class="rlang"><b>R</b></span> provides several kinds of random number generator (RNG) in the <span class="pkg">base</span> package (see <a href="base.html#topic+RNG">RNG</a>). These are used both explicitly, in functions such as <code><a href="stats.html#topic+runif">runif</a></code> and <code><a href="stats.html#topic+rnorm">rnorm</a></code>, and implicitly (<code><a href="base.html#topic+sample">sample</a></code>).
</p>
<p>A seed suitable for any kind of RNG is held in a vector of 626 integers named <code>.Random.seed</code>. The vector is not to be modified directly by users. Instead, to start a reproducible stream of random numbers, the user calls <code><a href="base.html#topic+set.seed">set.seed</a></code> with a single non-null integer argument. This has the effect of initialising <code>.Random.seed</code>. The value of <code>.Random.seed</code> may nevertheless be stored and restored to reset the RNG state.
</p>
<p><code><a href="base.html#topic+set.seed">set.seed</a></code> with a NULL argument initialises <code>.Random.seed</code> to an indeterminate (time- and process-dependent) value. The same happens if a random number function is called before <code>.Random.seed</code> has been set.
</p>


<h3>Handling of RNG seed for simulation in package <span class="pkg">stats</span></h3>

<p>The &lsquo;official&rsquo; approach to setting and storing the RNG seed is shown in code and documentation for the generic function <code><a href="#topic+simulate">simulate</a></code> in the <span class="pkg">stats</span> package. 
</p>

<ul>
<li><p> The generic has argument &lsquo;seed&rsquo; with default NULL. 
</p>
</li>
<li><p> If &lsquo;seed&rsquo; is non-null then <code>set.seed</code> is called.
</p>
</li>
<li><p> The returned value has an attribute &ldquo;seed&rdquo; whose value is either (i) if specified, the integer value of the &lsquo;seed&rsquo; argument (with its own attribute &ldquo;kind&rdquo; from RNGkind), or (ii) the original vector <code>.Random.seed</code>.
</p>
</li>
<li><p> On exit the RNG state in <code>.Random.seed</code> is reset to the value that applied when the function was called.
</p>
</li></ul>

<p>For NULL seed input, the saved RNGstate may be used to reset .Random.seed (see Examples).
</p>


<h3>Use of random numbers in <span class="pkg">secr</span></h3>

<p>Many functions in <span class="pkg">secr</span> call on random numbers, sometimes in unexpected places. For example <code><a href="#topic+autoini">autoini</a></code> selects a random sample to thin points and speed computation. In most functions there is no provision for direct control of the random number state: users won't usually care, and if they do then <code>set.seed</code> may be called for the particular <span class="rlang"><b>R</b></span> session. 
</p>
<p>However, control of the RNG seed is required for reproducible data generation in simulation functions. These functions typically have a &lsquo;seed&rsquo; argument that is used internally in a call to <code>set.seed</code>. Handling of seeds in the simulation functions of <span class="pkg">secr</span> largely follows <code>stats::simulate</code> as described in the preceding section.
</p>
<p>The relevant functions are &ndash;
</p>

<table>
<tr>
 <td style="text-align: left;">
Function </td><td style="text-align: left;"> Default </td><td style="text-align: left;"> Saved attribute </td><td style="text-align: left;"> Note </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+randomHabitat">randomHabitat</a></code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> seed or RNGstate</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+secr.test">secr.test</a></code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> seed or RNGstate </td><td style="text-align: left;"> calls and retains seed from <code>simulate.secr</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sim.capthist">sim.capthist</a></code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> seed or RNGstate </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sim.resight">sim.resight</a></code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> seed or RNGstate </td><td style="text-align: left;"> Seed may be passed in ... argument </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sim.popn">sim.popn</a></code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> seed or RNGstate </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sim.secr">sim.secr</a></code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> seed or RNGstate </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+simulate.secr">simulate.secr</a></code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> seed or RNGstate </td><td style="text-align: left;"> S3 method called by <code>sim.secr</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Setting <code>seed = NULL</code> in any of these functions has the effect of continuing the existing random number stream; it is not the same as calling <code>set.seed(NULL)</code>. 
</p>


<h3>Parallel processing</h3>

<p>Two models are used for parallel processing in <span class="pkg">secr</span>, corresponding to multi-threading with package <span class="pkg">RcppParallel</span> (e.g. <code><a href="#topic+secr.fit">secr.fit</a></code>) and parallel cores in package <span class="pkg">parallel</span> (e.g. <code><a href="#topic+chat.nk">chat.nk</a></code>).
</p>
<p>In the <span class="pkg">parallel</span> model the L'Ecuyer pseudorandom generator is used to provide a separate random number stream for each core (see <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>).
</p>
<p>When using <span class="pkg">Rcpp</span> the state of the random number generator is set in C++ with the call 
<code>RNGScope scope;</code>that automatically resets the state of the generator on exit (Eddelbuettel 2013 p. 115).
</p>
<p>Random number streams in separate <span class="pkg">RcppParallel</span> threads are (probably) not independent. Thus there are potential issues with RNG calls in multi-threaded code. However, in <span class="pkg">secr</span> 4.0 all RNG calls in C++ code are outside multi-threaded contexts, with the exception of simulations allowing for overdispersion in mark&ndash;resight estimates (Rcpp exported function sightingchatcpp). The implications for mark-resight estimates have not been explored, and it is unclear whether more elaborate solutions are needed.
</p>


<h3>References</h3>

<p>Eddelbuettel, D. 2013. Seamless R and C++ integration with Rcpp. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Parallel">Parallel</a></code>,
<code><a href="base.html#topic+set.seed">set.seed</a></code>, 
<code><a href="#topic+simulate">simulate</a></code>, 
<code><a href="#topic+sim.capthist">sim.capthist</a></code>, 
<code><a href="#topic+sim.popn">sim.popn</a></code>, 
<code><a href="#topic+sim.resight">sim.resight</a></code>,
<code><a href="#topic+secr.test">secr.test</a></code>,
<code><a href="#topic+simulate.secr">simulate.secr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

lmfit &lt;- lm(speed ~ dist, data = cars)

## 1. NULL seed
r1 &lt;- simulate(lmfit, seed = NULL)
r2 &lt;- simulate(lmfit, seed = NULL)
## restore RNGstate, assuming RNGkind unchanged
.Random.seed &lt;- attr(r1, "seed")
r3 &lt;- simulate(lmfit, seed = NULL)
r1[1:6,1]
r2[1:6,1]
r3[1:6,1]

## 2. explicit seed
r4 &lt;- simulate(lmfit, seed = 123)
r5 &lt;- simulate(lmfit, seed = attr(r4, "seed"))
r4[1:6,1]
r5[1:6,1]


## End(Not run)

</code></pre>

<hr>
<h2 id='secrtest'> Goodness-of-fit Test Results </h2><span id='topic+secrtest'></span><span id='topic+print.secrtest'></span><span id='topic+plot.secrtest'></span>

<h3>Description</h3>

<p>S3 class for results from <code><a href="#topic+secr.test">secr.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secrtest'
print(x, terse = TRUE, ...)
## S3 method for class 'secrtest'
plot(x, stat, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secrtest_+3A_x">x</code></td>
<td>
<p>secrtest object from <code><a href="#topic+secr.test">secr.test</a></code> </p>
</td></tr>
<tr><td><code id="secrtest_+3A_terse">terse</code></td>
<td>
<p>logical; if TRUE only p values are displayed</p>
</td></tr>
<tr><td><code id="secrtest_+3A_stat">stat</code></td>
<td>
<p>character; names of statistics to plot (default: all)</p>
</td></tr>
<tr><td><code id="secrtest_+3A_...">...</code></td>
<td>
<p>other arguments passed to hist by <code>plot.secrtest</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An &lsquo;secrtest&rsquo; object is output from <code><a href="#topic+secr.test">secr.test</a></code>.
</p>
<p><code>plot.secrtest</code> plots a histogram of the simulated values.
</p>
<p>If <code>plot.secrtest</code> is applied to an object with more than one
statistic then multiple plots are produced, so a multi-figure layout
should be prepared (<code>par(mfrow = c(1,2))</code> for 2 plots side by
side). Include the <code>hist</code> argument <code>main = ''</code> to suppress the
ugly plot labels, and ensure each statistic is named by <code>statfn</code> so
that the x-axis is labelled correctly (See the Examples in help for
<code><a href="#topic+secr.test">secr.test</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr.test">secr.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

tmp &lt;- secr.test(ovenbird.model.1)
if (inherits(tmp, 'secrtest')) {
    tmp  ## terse print
    print(tmp, terse = FALSE)
    par(mfrow = c(1,5))
    plot(tmp, main = '', xlim=c(0,1), breaks=seq(0,1,0.05))
    par(mfrow = c(1,1))    ## reset to default
}


## End(Not run)

</code></pre>

<hr>
<h2 id='session'> Session Vector </h2><span id='topic+session'></span><span id='topic+session+3C-'></span>

<h3>Description</h3>

<p>Extract or replace the session names of a <code>capthist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>session(object, ...)
session(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="session_+3A_object">object</code></td>
<td>
<p> object with &lsquo;session&rsquo; attribute e.g. <code>capthist</code> </p>
</td></tr>
<tr><td><code id="session_+3A_value">value</code></td>
<td>
<p> character vector or vector that may be coerced to character, one value per session </p>
</td></tr>
<tr><td><code id="session_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replacement values will be coerced to character.
</p>


<h3>Value</h3>

<p>a character vector with one value for each session in <code>capthist</code>
</p>


<h3>Note</h3>

<p>Like Density, <span class="pkg">secr</span> uses the term &lsquo;session&rsquo; for a
closed-population sample. A session usually includes data from several
closely-spaced capture occasions (often consecutive days). Each 'primary
session' in the &lsquo;robust&rsquo; design of Pollock (1982) would be treated as a
session in <span class="pkg">secr</span>. <span class="pkg">secr</span> also uses &lsquo;session&rsquo; for independent
subsets of the capture data distinguished by characteristics other than
sampling time (as above). For example, two grids trapped simultaneously
could be analysed as distinct sessions if (i) they were far enough
apart that there was negligible prospect of the same animal being caught
on both grids, and (ii) there was interest in comparing estimates from
the two grids, or fitting a common detection model.
</p>
<p>The log likelihood for a session model is the sum of the separate
session log likelihoods. Although this assumes independence of sampling,
parameters may be shared across sessions, or session-specific parameter
values may be functions of session-level covariates. For many purposes,
&lsquo;sessions&rsquo; are equivalent to &lsquo;groups&rsquo;. For multi-session models the
detector array and mask are specified separately for each session. Group
models are therefore generally simpler to implement. On the other hand,
sessions offer more flexibility in defining and evaluating
between-session models, including trend models.
</p>


<h3>References</h3>

 
<p>Pollock, K. H. (1982) A capture-recapture design robust to unequal
probability of capture. <em>Journal of Wildlife Management</em> <b>46</b>,
752&ndash;757.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+capthist">capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  session(captdata)
</code></pre>

<hr>
<h2 id='setNumThreads'>Number of Threads</h2><span id='topic+setNumThreads'></span>

<h3>Description</h3>

<p>Set or report the number of cores to be used for multi-threaded operations. A wrapper for the RcppParallel function setThreadOptions (Allaire et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
setNumThreads(ncores, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setNumThreads_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads to use</p>
</td></tr>
<tr><td><code id="setNumThreads_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>RcppParallel::setThreadOptions</code>, specifically stackSize</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>ncores</code> is NULL then the current value of the environment variable RCPP_PARALLEL_NUM_THREADS is used. RCPP_PARALLEL_NUM_THREADS defaults to 2 at the start of a session (assuming at least 2 logical cores available).
</p>
<p>Calling <code>setNumThreads()</code> with no arguments is a handy way to check how many threads are in use.
</p>
<p>The value of RCPP_PARALLEL_NUM_THREADS is also reset when a multi-threaded function such as <code>secr.fit</code> is called with a non-NULL value of the ncores argument. This value applies in later calls of <code>secr.fit</code> with <code>ncores = NULL</code> until changed.
</p>


<h3>Value</h3>

<p>The new value of the environment variable RCPP_PARALLEL_NUM_THREADS.
</p>


<h3>Note</h3>

<p>The mechanism for setting the number of threads changed between versions 4.1.0 and 4.2.0. The default number of cores is now capped at 2 to meet CRAN requirements. Setting <code>ncores = NULL</code> previously specified one less than the number of available cores.
</p>


<h3>References</h3>

<p>Allaire, J. J., Francois, R., Ushey, K., Vandenbrouck, G., Geelnard, M. and Intel (2019)
RcppParallel: Parallel Programming Tools for 'Rcpp'. R package version 4.4.4.
https://CRAN.R-project.org/package=RcppParallel.
</p>


<h3>See Also</h3>

<p><a href="#topic+Parallel">Parallel</a>,
<code><a href="RcppParallel.html#topic+setThreadOptions">setThreadOptions</a></code>
<code><a href="base.html#topic+Sys.getenv">Sys.getenv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# determine current number of threads

setNumThreads()

## Not run: 

# set new number of threads
setNumThreads(7)

# a call to secr.fit that specifies 'ncores' also sets the 
# number of threads, as we see here

fit &lt;- secr.fit(captdata, trace = FALSE, ncores = 8)
setNumThreads()


## End(Not run)

</code></pre>

<hr>
<h2 id='shareFactorLevels'>Fix Inconsistent Covariates</h2><span id='topic+shareFactorLevels'></span>

<h3>Description</h3>

<p>Factor covariates can give trouble in multi-session models if the levels differ among sessions. A warning is provided by <code>verify.capthist</code>. This function forces factor covariates to use the same levels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
shareFactorLevels(object, columns = NULL, stringsAsFactors = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shareFactorLevels_+3A_object">object</code></td>
<td>
<p>multi-session capthist object or list of traps or mask objects</p>
</td></tr>
<tr><td><code id="shareFactorLevels_+3A_columns">columns</code></td>
<td>
<p>indices of columns to fix (default all)</p>
</td></tr>
<tr><td><code id="shareFactorLevels_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical; if TRUE then character columns are converted to factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factor-valued covariates are coerced to use the same set of levels for each session of a multi-session capthist object or each component of a list of traps or masks. The combined level set is the union of all levels in separate sessions. The order of levels follows the default in <code><a href="base.html#topic+factor">factor</a></code> (alphabetical according to current locale).
</p>
<p>Setting <code>stringsAsFactors = TRUE</code> causes character-valued columns to be converted to factors.
</p>


<h3>Value</h3>

<p>An object of the same class as input. A single-session object is passed unchanged except for possible conversion of character values to factor (<code>stringsAsFactors = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+verify.capthist">verify.capthist</a></code>
</p>

<hr>
<h2 id='sighting'> Sighting Attributes </h2><span id='topic+markocc'></span><span id='topic+markocc+3C-'></span><span id='topic+sighting'></span><span id='topic+sightings'></span><span id='topic+Tu'></span><span id='topic+Tu+3C-'></span><span id='topic+Tm'></span><span id='topic+Tm+3C-'></span><span id='topic+Tn'></span><span id='topic+Tn+3C-'></span>

<h3>Description</h3>

<p>Extract or replace the <code>markocc</code> attribute of a <code>traps</code>
object that distinguishes marking occasions from sighting
occasions. Also, extract or replace the attributes Tu, Tm and Tn of a capthist
object, used for storing counts of sightings. All attributes are
optional, but Tu, Tm and Tn require markocc to be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markocc(object, ...)
markocc(object) &lt;- value
sighting(object)
Tu(object, ...)
Tu(object) &lt;- value
Tm(object, ...)
Tm(object) &lt;- value
Tn(object, ...)
Tn(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sighting_+3A_object">object</code></td>
<td>
 <p><code>traps</code> object (<code>markocc</code>) or capthist object
(<code>Tu</code>, <code>Tm</code>, <code>Tn</code>)</p>
</td></tr>
<tr><td><code id="sighting_+3A_value">value</code></td>
<td>
<p> numeric matrix of detectors x occasions, or a vector
(see Details) </p>
</td></tr>
<tr><td><code id="sighting_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For replacement of markocc, &lsquo;value&rsquo; should be a vector of integers
indicating the occasions on which animals are sighted only (0) or
marked or recaptured (1).
</p>
<p>For replacement of <code>Tu</code>, <code>Tm</code> or  <code>Tn</code>, &lsquo;value&rsquo; may be a scalar
(total count) or a detectors x occasions matrix.  
</p>


<h3>Value</h3>

<p>markocc(object) returns the markocc vector of the <code>traps</code>
object. <code>markocc(object)</code> may be NULL.
</p>
<p><code>Tu</code>, <code>Tm</code> and <code>Tn</code> return the respective attributes of a capthist object, or
NULL if they are unspecified.
</p>
<p>sighting(object) returns TRUE if the markocc attribute indicates at least one 
sighting-only occasion.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+traps">traps</a></code>,
<code><a href="#topic+addSightings">addSightings</a></code>,
<code><a href="#topic+sightingPlot">sightingPlot</a></code>,
<a href="https://www.otago.ac.nz/density/pdfs/secr-markresight.pdf">secr-markresight.pdf</a>
</p>

<hr>
<h2 id='signal'> Signal Fields </h2><span id='topic+signalframe'></span><span id='topic+signal.capthist'></span><span id='topic+noise.capthist'></span><span id='topic+signalframe+3C-'></span><span id='topic+signal'></span><span id='topic+noise'></span><span id='topic+signal+3C-'></span><span id='topic+noise+3C-'></span>

<h3>Description</h3>

<p>Extract or replace signal attributes of a &lsquo;capthist&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
signalframe(object)
signalframe(object) &lt;- value

## S3 method for class 'capthist'
signal(object, ...)
## S3 method for class 'capthist'
noise(object, ...)

signal(object) &lt;- value
noise(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_+3A_object">object</code></td>
<td>
<p> a &lsquo;capthist&rsquo; object </p>
</td></tr>
<tr><td><code id="signal_+3A_value">value</code></td>
<td>
<p> replacement value (see Details) </p>
</td></tr>
<tr><td><code id="signal_+3A_...">...</code></td>
<td>
<p> other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Signal attributes of a &lsquo;capthist&rsquo; object are stored in a dataframe
called the signalframe. This has one row per detection. The signalframe
includes the primary field &lsquo;signal&rsquo; and an unlimited number of other
fields. To extract the signal field alone use the signal method.
</p>
<p>These functions extract data on detections, ignoring occasions when an
animal was not detected. Detections are ordered by occasion, animalID
and trap.
</p>
<p>Replacement values must precisely match <code>object</code> in number of
detections and in their order.
</p>


<h3>Value</h3>

<p>For <code>signalframe</code> , a dataframe containing signal data and
covariates, one row per detection. The data frame has one row per
detection. See <code><a href="#topic+signalmatrix">signalmatrix</a></code> for a matrix with one row per
cue and columns for different microphones.
</p>
<p>For <code>signal</code> and <code>noise</code>, a numeric vector with one element per detection.
</p>
<p>If <code>object</code> has multiple sessions, the result is a list with one
component per session.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+signalmatrix">signalmatrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ovensong dataset has very simple signalframe
head(signalframe(signalCH))

</code></pre>

<hr>
<h2 id='signalmatrix'>
Reformat Signal Data
</h2><span id='topic+signalmatrix'></span>

<h3>Description</h3>

<p>Produce sound x microphone matrix, possibly with sound covariates as
extra columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signalmatrix(object, noise = FALSE, recodezero = FALSE,
    prefix = "Ch", signalcovariates = NULL, names = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signalmatrix_+3A_object">object</code></td>
<td>
<p>object inheriting from secr class &lsquo;capthist&rsquo;</p>
</td></tr>
<tr><td><code id="signalmatrix_+3A_noise">noise</code></td>
<td>
<p>logical; if TRUE, noise is extracted instead of signal</p>
</td></tr>
<tr><td><code id="signalmatrix_+3A_recodezero">recodezero</code></td>
<td>
<p>logical; if TRUE zero signals are set to NA</p>
</td></tr>
<tr><td><code id="signalmatrix_+3A_prefix">prefix</code></td>
<td>
<p>character value used to form channel names</p>
</td></tr>
<tr><td><code id="signalmatrix_+3A_signalcovariates">signalcovariates</code></td>
<td>
<p>character vector of covariate names from signalframe to
add as columns</p>
</td></tr>
<tr><td><code id="signalmatrix_+3A_names">names</code></td>
<td>
<p>character vector of column names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts signal or noise data from a capthist object, where
it is stored in the &lsquo;signalframe&rsquo; attribute, as a more natural sound x microphone
table. There is no equivalent replacement function.
</p>
<p>The <code>signalcovariates</code> argument may be used to specify additional
columns of the signal frame to collapse and add as columns to the right
of the actual signal data. Ordinarily there will be multiple rows in
signalframe for each row in the output; the covariate value is taken
from the first matching row.
</p>
<p>If <code>names</code> is not provided, column names are constructed from the
detector names. If the length of <code>names</code> is less than the number of
columns, simple numerical names are constructed.
</p>


<h3>Value</h3>

<p>A dataframe with dim = c(n,K+j) where n is the
number of separate sounds, K is the number of microphones, and j is the
number of covariates (by default j = 0).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ovensong">ovensong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## use 'secr' ovenbird data
signalmatrix(signalCH)

</code></pre>

<hr>
<h2 id='sim.capthist'> Simulate Detection Histories </h2><span id='topic+sim.capthist'></span><span id='topic+sim.resight'></span>

<h3>Description</h3>

<p>Create a set of capture or marking-and-resighting histories by simulated sampling
of a 2-D population using an array of detectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.capthist(traps, popn = list(D = 5, buffer = 100,
    Ndist = "poisson"), detectfn = 0, detectpar = list(),
    noccasions = 5, nsessions = 1, binomN = NULL, exactN = NULL,
    p.available = 1, renumber = TRUE, seed = NULL,
    maxperpoly = 100, chulltol = 0.001, userdist = NULL, 
    savepopn = FALSE)
sim.resight(traps, popn = list(D = 5, buffer = 100, Ndist = "poisson"), ...,
    pID = 1, unmarked = TRUE, nonID = TRUE,  unresolved = FALSE, unsighted = TRUE, 
    pmark = 0.5, Nmark = NULL, markingmask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.capthist_+3A_traps">traps</code></td>
<td>
 <p><code>traps</code> object with the locations and other attributes of detectors </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_popn">popn</code></td>
<td>
<p> locations of individuals in the population to be sampled, either as
a <code><a href="#topic+popn">popn</a></code> object (see <code><a href="#topic+sim.popn">sim.popn</a></code>) or a list with the named components. </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of
detection function 0 = halfnormal etc. &ndash; see <a href="#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_detectpar">detectpar</code></td>
<td>
<p> list of values for named parameters of detection function </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_noccasions">noccasions</code></td>
<td>
<p> number of occasions to simulate </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_nsessions">nsessions</code></td>
<td>
<p> number of sessions to simulate </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_binomn">binomN</code></td>
<td>
<p> integer code for distribution of counts (see Details) </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_exactn">exactN</code></td>
<td>
<p> integer number of telemetry fixes per occasion </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_p.available">p.available</code></td>
<td>
<p> vector of one or two probabilities (see Details) </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_renumber">renumber</code></td>
<td>
<p> logical for whether output rows should labeled sequentially (TRUE) or
retain the numbering of the population from which they were drawn (FALSE) </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_seed">seed</code></td>
<td>
<p>either NULL or an integer that will be used in a call to <code>set.seed</code></p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_maxperpoly">maxperpoly</code></td>
<td>
<p> integer maximum number of detections of an individual
in one polygon or transect on any occasion </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_chulltol">chulltol</code></td>
<td>
<p>numeric buffer (m) for polygon around telemetry
locations</p>
</td></tr> 
<tr><td><code id="sim.capthist_+3A_userdist">userdist</code></td>
<td>
<p>user-defined distance function or matrix (see <a href="#topic+details">details</a>)</p>
</td></tr>  
<tr><td><code id="sim.capthist_+3A_savepopn">savepopn</code></td>
<td>
<p> logical; if TRUE then the popn (input or simulated) is saved as an attribute</p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_...">...</code></td>
<td>
<p> arguments to pass to <code>sim.capthist</code> </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_pid">pID</code></td>
<td>
<p> probability of individual identification for marked animals </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_unmarked">unmarked</code></td>
<td>
<p> logical, if TRUE unmarked individuals are not recorded during &lsquo;sighting&rsquo; </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_nonid">nonID</code></td>
<td>
<p>logical, if TRUE then unidentified marked individuals are not recorded during &lsquo;sighting&rsquo; </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_unresolved">unresolved</code></td>
<td>
<p>logical, if TRUE then individuals of unresolved mark status are not recorded during &lsquo;sighting&rsquo; </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_unsighted">unsighted</code></td>
<td>
<p>logical, if TRUE and sighting only then capthist includes all-zero histories </p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_pmark">pmark</code></td>
<td>
<p> numeric probability that an individual is &lsquo;pre-marked&rsquo; (see Details)</p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_nmark">Nmark</code></td>
<td>
<p> number of individuals to be &lsquo;pre-marked&rsquo; (see Details)</p>
</td></tr>
<tr><td><code id="sim.capthist_+3A_markingmask">markingmask</code></td>
<td>
 <p><code>mask</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>popn</code> is not of class &lsquo;popn&rsquo; then a homogeneous Poisson
population with the desired density (animals/ha) is first simulated over
the rectangular area of the bounding box of <code>traps</code> plus a buffer
of the requested width (metres). The detection algorithm depends on the
detector type of <code>traps</code>. For &lsquo;proximity&rsquo; detectors, the actual
detection probability of animal <em>i</em> at detector <em>j</em> is the
naive probability given by the detection function. For &lsquo;single&rsquo; and
&lsquo;multi&rsquo; detectors the naive probability is modified by competition
between detectors and, in the case of &lsquo;single&rsquo; detectors, between animals. See
Efford (2004) and other papers below for details.
</p>
<p>Detection parameters in <code>detectpar</code> are specific to the detection
function, which is indicated by <code><a href="#topic+detectfn">detectfn</a></code>.
Parameters may vary with time - for this provide a vector of length
<code>noccasions</code>.  The g0 parameter may vary both by time and detector
- for this provide a matrix with <code>noccasions</code> rows and as many
columns as there are detectors. The default detection parameters are
<code>list(g0 = 0.2, sigma = 25, z = 1)</code>.
</p>
<p>The default is to simulate a single session. This may be overridden by
providing a list of populations to sample (argument <code>popn</code>) or by
specifying <code>nsessions</code> &gt; 1 (if both then the number of sessions must
match). Using <code>nsessions</code> &gt; 1 results in replicate samples of
populations with the same density etc. as specified directly in the
<code>popn</code> argument.
</p>
<p><code>binomN</code> determines the statistical distribution of the number of
detections of an individual at a particular &lsquo;count&rsquo; detector or polygon
on a particular occasion. A Poisson distribution is indicated by
<code>binomN = 0</code>; see <code><a href="#topic+secr.fit">secr.fit</a></code> for more. The distribution
is always Bernoulli (binary) for &lsquo;proximity&rsquo; and &lsquo;signal&rsquo; detectors.
</p>
<p>If <code>exactN</code> is not specified or zero then the number of telemetry
fixes is a random variable determined by the other detection settings.
</p>
<p><code>p.available</code> specifies temporary non-availability for detection in
multi-session simulations. If a single probability is specified then
temporary non-availability is random (independent from session to
session). If two probabilities are given then non-availability is
Markovian (dependent on previous state) and the two values are for
animals available and not available at the preceding session. In the
Markovian case, availability in the first session is assigned at random
according to the equilibrium probability p2 / (1 - p1 + p2). Incomplete
availability is not implemented for sampling lists of populations.
</p>
<p><code>detectpar</code> may include a component &lsquo;truncate&rsquo; for the distance
beyond which detection probability is set to zero. By default this value
is NULL (no specific limit).
</p>
<p><code>detectpar</code> may also include a component &lsquo;recapfactor&rsquo; for a
general learned trap response. For &lsquo;single&rsquo; and &lsquo;multi&rsquo; detector types
the probability of detection changes by this factor for all occasions
after the occasion of first capture. Attempted use with other detector
types causes an error. If recapfactor x g(d) &gt; 1.0, g(d) is truncated at
1.0. Other types of response (site-specific bk, Markovian B) are not
allowed.
</p>
<p>If <code>popn</code> is specified by an object of class &lsquo;popn&rsquo; then any
individual covariates will be passed on; the <code>covariates</code> attribute
of the output is otherwise set to NULL.
</p>
<p>The random number seed is managed as in <code><a href="stats.html#topic+simulate">simulate</a></code>.
</p>
<p><code>chulltol</code> is used only when simulating telemetry locations. By
default, a new 'traps' polygon is generated as the convex hull of the
simulated locations, with a slight (1 mm) added buffer to ensure
boundary points are within the polygon. Buffering is suppressed if
<code>chulltol</code> is NA or negative.
</p>
<p><code>userdist</code> cannot be set if &lsquo;traps&rsquo; is any of polygon, polygonX,
transect or transectX.
</p>
<p><code>sim.resight</code> generates mark-resight data. The &lsquo;markocc&rsquo; attribute 
of &lsquo;traps&rsquo; indicates the occasions which are for sighting-only (0) or 
marking and recapture (1). The number 
of occasions is determined by <code>markocc</code>. <code>sim.capthist</code> is first 
called with the arguments &lsquo;traps&rsquo; and .... The detector type of &lsquo;traps&rsquo; 
should be &lsquo;proximity&rsquo; or &lsquo;count&rsquo; for sighting occasions (markocc = 0). The detector type need not be the same for marking and sighting occasions ('multi' is allowed on marking occasions). If ... includes a non-null &lsquo;seed&rsquo; the 
random seed is reset in <code>sim.resight</code> and not passed to 
<code>sim.capthist</code>.
</p>
<p>A special case arises when all occasions are sighting-only. Then it is assumed that individuals in the population are marked prior to the start of sampling with a known spatial distribution (i.e. marking does not follow a spatial detection model). By default, animals throughout the buffered area are pre-marked with probability <code>pmark</code>. If <code>Nmark</code> is specified then a sample of size <code>Nmark</code> will be selected for marking, overriding <code>pmark</code>.
</p>
<p>The marked population may be restricted to a subset of the space spanned by <code>popn</code> by specifying <code>markingmask</code>, which may have a further covariate &lsquo;marking&rsquo; to vary the intensity of marking.
</p>


<h3>Value</h3>

<p>For <code>sim.capthist</code>, an object of class <code>capthist</code>, a 3-dimensional array 
with additional attributes. Rows represent
individuals and columns represent occasions; the third dimension, codes the number of 
detections at each detector (zero or one for trap detectors (&lsquo;single&rsquo;, &lsquo;multi&rsquo;) and binary proximity detectors.
</p>
<p>The initial state of the R random number generator is stored in the
&lsquo;seed&rsquo; attribute.
</p>
<p>For <code>sim.resight</code>, an object of class <code>capthist</code> for which the traps object has a markocc attribute (marking occasions), and there are further attributes Tu (sightings of unmarked animals) and Tm (sightings of marked but not 
identified animals).
</p>


<h3>Note</h3>

<p>External code is called to speed the simulations. The present version
assumes a null model, i.e., naive detection probability is constant
except for effects of distance and possibly time (using vector-valued
detection parameters from 1.2.10). You can, however, use
<code><a href="#topic+rbind.capthist">rbind.capthist</a></code> to combine detections of population
subclasses (e.g. males and females) simulated with different parameter
values. This is not valid for detector type &quot;single&quot; because it fails to
allow for competition for traps between subclasses. Future versions may
allow more complex models.
</p>
<p><code>truncate</code> has no effect (i) when using a uniform detection
function with radius (<code>sigma</code>) &lt;= <code>truncate</code> and (ii) with
signal strength detection (detectfn 10, 11). Note that truncated
detection functions are provided for de novo simulation, but are not
available when fitting models with in <code>secr.fit</code> or simulating from
a fitted model with <code>sim.secr</code>.
</p>
<p><code>maxperpoly</code> limits the size of the array allocated for
detections in C code; an error results if the is number is exceeded.
</p>
<p>Prior to 2.10.0 <code>sim.resight</code> interpreted length-2 vectors of detection parameters as referring to marking and sighting occasions; this feature has been discontinued.
</p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G. (2004) Density estimation in live-trapping studies.
<em>Oikos</em> <b>106</b>, 598&ndash;610.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>
<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009) Population
density estimated from locations of individuals on a passive detector
array. <em>Ecology</em> <b>90</b>, 2676&ndash;2682.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.popn">sim.popn</a></code>, <code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+traps">traps</a></code>,
<code><a href="#topic+popn">popn</a></code>, <code><a href="#topic+Detection+20functions">Detection functions</a></code>, <code><a href="stats.html#topic+simulate">simulate</a></code>,
<code><a href="#topic+Tu">Tu</a></code>, <code><a href="#topic+Tm">Tm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example
## detector = "multi" (default)
temptrap &lt;- make.grid(nx = 6, ny = 6, spacing = 20)
sim.capthist (temptrap, detectpar = list(g0 = 0.2, sigma = 20))

## with detector = "proximity", there may be more than one
## detection per individual per occasion
temptrap &lt;- make.grid(nx = 6, ny = 6, spacing = 20, detector =
    "proximity")
summary(sim.capthist (temptrap, detectpar = list(g0 = 0.2, 
    sigma = 20)))

## marking on occasions 1, 3 only
temptrap &lt;- make.grid(nx = 6, ny = 6, spacing = 20, detector = 'proximity')
markocc(temptrap) &lt;- c(1,0,1,0,0)
CH &lt;- sim.resight (temptrap, detectpar = list(g0 = 0.2, sigma = 20))
summary(CH)

## multiple sessions
grid4 &lt;- make.grid(nx = 2, ny = 2)
temp &lt;- sim.capthist (grid4, popn = list(D = 1), nsessions = 20)
summary(temp, terse = TRUE)

## unmarked or presence types
# grid &lt;- make.grid(nx = 10, ny = 10, detector = "unmarked")
# CH &lt;- sim.capthist (grid, noccasions = 5)
# CH
## "presence" and "unmarked" data are stored as "count" data
## behaviour is controlled by detector type, e.g.
# detector(traps(CH)) &lt;- "presence"
# CH


</code></pre>

<hr>
<h2 id='sim.popn'> Simulate 2-D Population </h2><span id='topic+sim.popn'></span><span id='topic+tile'></span>

<h3>Description</h3>

<p>Simulate a point process representing the locations of individual animals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
sim.popn (D, core, buffer = 100, model2D = c("poisson", "cluster",
  "IHP", "coastal", "hills", "linear", "even", "rLGCP", "rThomas"), 
  buffertype = c("rect", "concave", "convex"), poly = NULL, 
  covariates = list(sex = c(M = 0.5, F = 0.5)), number.from = 1, 
  Ndist = c("poisson", "fixed", "specified"), nsessions = 1, details = NULL, 
  seed = NULL, keep.mask = model2D %in% c("IHP", "linear"), 
  Nbuffer = NULL, age = FALSE, ...)

tile(popn, method = "reflect")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.popn_+3A_d">D</code></td>
<td>
<p> density animals / hectare (10 000 m^2) (see Details for
IHP case) </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_core">core</code></td>
<td>
<p> data frame of points defining the core area </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_buffer">buffer</code></td>
<td>
<p> buffer radius about core area </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_model2d">model2D</code></td>
<td>
<p> character string for 2-D distribution </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_buffertype">buffertype</code></td>
<td>
<p> character string for buffer type </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_poly">poly</code></td>
<td>
<p> bounding polygon (see Details)</p>
</td></tr>
<tr><td><code id="sim.popn_+3A_covariates">covariates</code></td>
<td>
<p> list of named covariates </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_number.from">number.from</code></td>
<td>
<p> integer ID for animal </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_ndist">Ndist</code></td>
<td>
<p> character string for distribution of number of individuals </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_nsessions">nsessions</code></td>
<td>
<p> number of sessions to simulate </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_details">details</code></td>
<td>
<p> optional list with additional parameters </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_seed">seed</code></td>
<td>
<p>either NULL or an integer that will be used in a call to <code>set.seed</code></p>
</td></tr>
<tr><td><code id="sim.popn_+3A_keep.mask">keep.mask</code></td>
<td>
<p>logical; if TRUE and model2D %in% c('IHP','linear')
then <code>core</code> is saved as the attribute &quot;mask&quot;</p>
</td></tr>
<tr><td><code id="sim.popn_+3A_nbuffer">Nbuffer</code></td>
<td>
<p>integer number of individuals to simulate</p>
</td></tr>
<tr><td><code id="sim.popn_+3A_age">age</code></td>
<td>
<p>logical; if TRUE then age covariate added for multisession popn with turnover</p>
</td></tr>
<tr><td><code id="sim.popn_+3A_...">...</code></td>
<td>
<p> arguments passed to subset if poly is not NULL</p>
</td></tr>
<tr><td><code id="sim.popn_+3A_popn">popn</code></td>
<td>
<p> popn object </p>
</td></tr>
<tr><td><code id="sim.popn_+3A_method">method</code></td>
<td>
<p> character string &quot;reflect&quot; or &quot;copy&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>core</code> must contain columns &lsquo;x&rsquo; and &lsquo;y&rsquo;; a <code>traps</code> object is
suitable. For <code>buffertype = "rect"</code>, animals are simulated in the
rectangular area obtained by extending the bounding box of <code>core</code>
by <code>buffer</code> metres to top and bottom, left and right. This box has
area <code class="reqn">A</code>. If <code>model2D = 'poisson'</code> the buffer type may also be &lsquo;convex&rsquo; (points within a buffered convex polygon) or &lsquo;concave&rsquo; (corresponding to a mask of type &lsquo;trapbuffer&rsquo;); these buffer types use <code><a href="#topic+buffer.contour">buffer.contour</a></code>.
</p>
<p>A notional random covariate &lsquo;sex&rsquo; is generated by default.
</p>
<p>Each element of <code>covariates</code> defines a categorical (factor)
covariate with the given probabilities of membership in each class. No
mechanism is provided for generating continuous covariates, but these
may be added later (see Examples).
</p>
<p>Ndist should usually be &lsquo;poisson&rsquo; or &lsquo;fixed&rsquo;. The number of individuals <code class="reqn">N</code> has
expected value <code class="reqn">DA</code>. If <code class="reqn">DA</code> is non-integer then Ndist = &quot;fixed&quot;
results in <code class="reqn">N \in \{ \mathrm{trunc}(DA), \mathrm{trunc}(DA)+1 \} </code>, with probabilities set to yield
<code class="reqn">DA</code> individuals on average. The option &lsquo;specified&rsquo; is undocumented;
it is used in some open-population simulations.
</p>
<p>If <code>model2D = "cluster"</code> then the simulated population approximates a Neyman-Scott
clustered Poisson distribution. Ancillary parameters are passed as
components of <code>details</code>: details$mu is the expected number of
individuals per cluster and details$hsigma is the spatial scale
(<code class="reqn">\sigma</code>) of a 2-D kernel for location within each cluster.
The algorithm is
</p>

<ol>
<li><p> Determine the number of clusters (parents) as a random Poisson variate
with <code class="reqn">\lambda = DA/\mu</code>
</p>
</li>
<li><p> Locate each parent by drawing uniform random x- and y-coordinates
</p>
</li>
<li><p> Determine number of offspring for each parent by drawing from a Poisson distribution with mean mu
</p>
</li>
<li><p> Locate offspring by adding random normal error to each parent coordinate
</p>
</li>
<li><p> Apply toroidal wrapping to ensure all offspring locations are
inside the buffered area
</p>
</li></ol>

<p>A special cluster option is selected if details$clone = &quot;constant&quot;: then each parent is cloned exactly details$mu times.
</p>
<p>Toroidal wrapping is a compromise. The result is more faithful to the
Neyman-Scott distribution if the buffer is large enough that only a
small proportion of the points are wrapped.
</p>
<p>If <code>model2D = "IHP"</code> then an inhomogeneous Poisson distribution is
simulated.  <code>core</code> should be a habitat <a href="#topic+mask">mask</a> and <code>D</code>
should be one of &ndash;
</p>

<ul>
<li><p> a vector of length equal to the number of cells (rows)
in <code>core</code>, 
</p>
</li>
<li><p> the name of a covariate in <code>core</code> that contains
cell-specific densities (animals / hectare),
</p>
</li>
<li><p> a function to generate the intensity of the distribution at each mask point, or
</p>
</li>
<li><p> a constant. 
</p>
</li></ul>

<p>If a function, <code>D</code> should take two arguments, a habitat mask and a list of parameter values ('core' and 'details' are passed internally as these arguments).
</p>
<p>The number
of individuals in each cell is either (i) Poisson-distributed with mean
<code class="reqn">DA</code> where <code class="reqn">A</code> is the cell area (an attribute of the mask)
(<code>Ndist = "poisson"</code>) or (ii) multinomial with size <code class="reqn">DA</code> and
relative cell probabilities given by D (<code>Ndist =
"fixed"</code>). <code>buffertype</code> and <code>buffer</code> are ignored, as the
extent of the population is governed entirely by the mask in
<code>core</code>.
</p>
<p>If <code>model2D = "linear"</code> then a linear population is simulated as
for <code>model2D = "IHP"</code>, except that <code>core</code> should be a
linearmask object from package <span class="pkg">secrlinear</span>, and density (D) is
expressed in animals per km. The documentation of <span class="pkg">secrlinear</span>
should be consulted for further detail (e.g. the wrapper function
<code>sim.linearpopn</code>).
</p>
<p>If <code>model2D = "coastal"</code> then a form of inhomogeneous Poisson
distribution is simulated in which the x- and y-coordinates are drawn from
independent Beta distributions. Default parameters generate the
&lsquo;coastal&rsquo; distribution used by Fewster and Buckland (2004) for
simulations of line-transect distance sampling (x ~ Beta(1, 1.5), y ~
Beta(5, 1), which places 50% of the population in the &lsquo;northern&rsquo; 13%
of the rectangle). The four Beta parameters may be supplied in the
vector component Beta of the &lsquo;details&rsquo; list (see Examples). The Beta
parameters (1,1) give a uniform distribution. Coordinates are scaled to
fit the limits of a sampled rectangle, so this method assumes buffertype
= &quot;rect&quot;.
</p>
<p>If <code>model2D = "hills"</code> then a form of inhomogeneous Poisson
distribution is simulated in which intensity is a sine curve in the x-
and y- directions (density varies symmetrically between 0 and 2 x D
along each axis). The number of hills in each direction (default 1) is
determined by the &lsquo;hills&rsquo; component of the &lsquo;details&rsquo; list (e.g. details
= list(hills=c(2,3)) for 6 hills). If either number is negative then
alternate rows will be offset by half a hill. Displacements of the
entire pattern to the right and top are indicated by further elements of
the &lsquo;hills&rsquo; component (e.g. details = list(hills=c(1,1,0.5,0.5)) for 1
hill shifted half a unit to the top right; coordinates are wrapped, so
the effect is to split the hill into the four corners). Negative
displacements are replaced by runif(1). Density is zero at the edge when
the displacement vector is (0,0) and rows are not offset.
</p>
<p>If <code>model2D = "even"</code> then the buffered area is divided into square cells with side sqrt(10000/D) and one animal is located at a random uniform location within each cell. If the height or width is not an exact multiple of the cell side then one whole extra row or column of cells is added; animals located at random in these cells are discarded if they fall outside the original area.
</p>
<p>From <span class="pkg">secr</span> 4.6.2, <code>sim.popn</code> provides an interface to two simulation functions from <span class="pkg">spatstat</span> (Baddeley et al. 2015): <code>rLGCP</code> and <code>rThomas</code>.
</p>
<p>If <code>model2D = "rLGCP"</code> then a log-gaussian Cox process is simulated within the buffered area. Function <code>rLGCP</code> in <span class="pkg">spatstat</span> calls functions from <span class="pkg">RandomFields</span> (Schlather et al. 2015; see Notes). Certain options are fixed: the correlation function is RMexp from RandomFields, and there is no provision for covariate effects. Clipping to a polygon (poly) and fixed-N (Ndist = &quot;fixed&quot;) are not supported. The algorithm first constructs the log spatial intensity as a realisation of a Gaussian random field; one realisation of an IHP with that intensity is then simulated. 
</p>
<p>The parameters for <code>model2D = "rLGCP"</code> are the scalar density (D) and the variance and spatial scale of the random field (passed as details arguments &lsquo;var&rsquo; and &lsquo;scale&rsquo;). The variance is on the log scale; the mean on the log scale is computed internally as mu = log(D) - var/2. var = 0 results in a random uniform (Poisson) distribution. When details$saveLambda = TRUE, the discretized intensity function is saved as the attribute &quot;Lambda&quot;, a habitat mask with covariate &quot;Lambda&quot; that may be used to construct further IHP realisations (see Examples). 
</p>
<p>If <code>model2D = "rThomas"</code> then a Thomas process is simulated. This is a special case of the Neyman-Scott process in which each parent gives rise to a Poisson number of offspring (see Notes). The expected number of offspring per parent and the spatial scatter about each parent are specified by the details arguments &lsquo;mu&rsquo; and &lsquo;scale&rsquo;. Argument &lsquo;kappa&rsquo; of <code>rThomas</code> (density of parent process) is computed as D/mu/1e4. Other arguments remain at their defaults, including &lsquo;expand&rsquo; (4 * scale). A dataframe of parent locations is saved in attribute &lsquo;parents&rsquo;. The intensity surface for each realisation is saved in attribute 'Lambda' when details$saveLambda = TRUE.
</p>
<p>If <code>poly</code> is specified, points outside <code>poly</code> are
dropped. <code>poly</code> may be one of the types descrbed in 
<code><a href="#topic+boundarytoSF">boundarytoSF</a></code>.
</p>
<p>The <code><a href="base.html#topic+subset">subset</a></code> method is called internally when <code>poly</code> is used;
the ... argument may be used to pass values for <code>keep.poly</code> and
<code>poly.habitat</code>.
</p>
<p>Multi-session populations may be generated with <code>nsessions &gt; 1</code>. 
Multi-session populations may be independent or generated by per capita 
turnover from a starting population. In the &lsquo;independent&rsquo; case
(<code>details$lambda</code> not specified) D or Nbuffer may be a vector of length equal to
<code>nsessions</code>. Turnover is controlled by survival, growth rate and movement
parameters provided as components of <code>details</code> and described in <a href="#topic+turnover">turnover</a>. 
The optional covariate 'age' is the number of sessions from the session of recruitment.
</p>
<p>The random number seed is managed as in <code>simulate.lm</code>.
</p>
<p>Function <code>tile</code> replicates a popn pattern by either reflecting or
copying and translating it to fill a 3 x 3 grid.
</p>


<h3>Value</h3>

<p>An object of class <code>c("popn", "data.frame")</code> a data frame with columns &lsquo;x&rsquo; and &lsquo;y&rsquo;. Rows correspond to individuals. Individual covariates (optional) are stored
as a data frame attribute. The initial state of the R random number generator is
stored in the &lsquo;seed&rsquo; attribute.
</p>
<p>If <code>model2D = "linear"</code> the output is of class <code>c("linearpopn",
  "popn", "data.frame")</code>.
</p>
<p>If <code>model2D = "IHP"</code> or <code>model2D = "linear"</code> the value of
<code>core</code> is stored in the &lsquo;mask&rsquo; attribute.
</p>


<h3>Notes</h3>

<p>Package RandomFields is not currently on CRAN. It may be installed with this code:
</p>
<p><code>install.packages("RandomFields", repos = c("https://spatstat.r-universe.dev", 
   "https://cloud.r-project.org"))</code>
</p>
<p><code>model2D = "rThomas"</code> and <code>model2D = "cluster"</code> (the builtin Neyman-Scott implementation) are equivalent. There may be some subtle differences. The <span class="pkg">spatstat</span> implementation is usually to be preferred.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E., and Turner, R. 2015. Spatial Point Patterns: Methodology and Applications with R. Chapman and Hall/CRC Press, London. ISBN 9781482210200, https://www.routledge.com/Spatial-Point-Patterns-Methodology-and-Applications-with-R/Baddeley-Rubak-Turner/p/book/9781482210200/. 
</p>
<p>Fewster, R. M. and Buckland, S. T. 2004. Assessment of distance
sampling estimators. In: S. T. Buckland, D. R. Anderson,
K. P. Burnham, J. L. Laake, D. L. Borchers and L. Thomas (eds)
<em>Advanced distance sampling</em>. Oxford University Press, Oxford,
U. K. Pp. 281&ndash;306.
</p>
<p>Schlather, M., Malinowski, A., Menck, P. J., Oesting, M. and Strokorb, K. 2015. Analysis, simulation and prediction of multivariate random fields with package RandomFields. <em>Journal of Statistical Software</em>, <b>63</b>, 1&ndash;25. URL
https://www.jstatsoft.org/v63/i08/.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+popn">popn</a></code>, <code><a href="#topic+plot.popn">plot.popn</a></code>,
<code><a href="#topic+randomHabitat">randomHabitat</a></code>, <a href="#topic+turnover">turnover</a>, 
<code><a href="stats.html#topic+simulate">simulate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
temppop &lt;- sim.popn (D = 10, expand.grid(x = c(0,100), y =
    c(0,100)), buffer = 50)

## plot, distinguishing "M" and "F"
plot(temppop, pch = 1, cex= 1.5,
    col = c("green","red")[covariates(temppop)$sex])

## add a continuous covariate
## assumes covariates(temppop) is non-null
covariates(temppop)$size &lt;- rnorm (nrow(temppop), mean = 15, sd = 3)
summary(covariates(temppop))

## Neyman-Scott cluster distribution (see also rThomas)
par(xpd = TRUE, mfrow=c(2,3))
for (h in c(5,15))
for (m in c(1,4,16)) {
    temppop &lt;- sim.popn (D = 10, expand.grid(x = c(0,100),
        y = c(0,100)), model2D = "cluster", buffer = 100,
        details = list(mu = m, hsigma = h))
    plot(temppop)
    text (50,230,paste(" mu =",m, "hsigma =",h))
}
par(xpd = FALSE, mfrow=c(1,1))   ## defaults

## Inhomogeneous Poisson distribution
xy &lt;- secrdemo.0$mask$x + secrdemo.0$mask$y - 900
tempD &lt;- xy^2 / 1000
plot(sim.popn(tempD, secrdemo.0$mask, model2D = "IHP"))

## Coastal distribution in 1000-m square, homogeneous in
## x-direction
arena &lt;- data.frame(x = c(0, 1000, 1000, 0),
    y = c(0, 0, 1000, 1000))
plot(sim.popn(D = 5, core = arena, buffer = 0, model2D =
    "coastal", details = list(Beta = c(1, 1, 5, 1))))

## Hills
plot(sim.popn(D = 100, core = arena, model2D = "hills",
    buffer = 0, details = list(hills = c(-2,3,0,0))), 
    cex = 0.4)

## tile demonstration
pop &lt;- sim.popn(D = 100, core = make.grid(), model2D = "coastal")
par(mfrow = c(1,2), mar = c(2,2,2,2))
plot(tile(pop, "copy"))
polygon(cbind(-100,200,200,-100), c(-100,-100,200,200),
    col = "red", density = 0)
title("copy")
plot(tile(pop, "reflect"))
polygon(cbind(-100,200,200,-100), c(-100,-100,200,200),
    col = "red", density = 0)
title("reflect")

## Not run: 

## simulate from inhomogeneous fitted density model

regionmask &lt;- make.mask(traps(possumCH), type = "polygon",
    spacing = 20, poly = possumremovalarea)
dts &lt;- distancetotrap(regionmask, possumarea)
covariates(regionmask) &lt;- data.frame(d.to.shore = dts)
dsurf &lt;- predictDsurface(possum.model.Ds, regionmask)
possD &lt;- covariates(dsurf)$D.0
posspop &lt;- sim.popn(D = possD, core = dsurf, model = "IHP")
plot(regionmask, dots = FALSE, ppoly = FALSE)
plot(posspop, add = TRUE, frame = FALSE)
plot(traps(possumCH), add = TRUE)

## randomHabitat demonstration
## - assumes igraph has been installed

# The wrapper function randomDensity may be passed to generate
# a new habitat map each time sim.popn is called. The `details' argument
# of sim.popn is passed to randomDensity as the `parm' argument.

tempmask &lt;- make.mask(nx = 100, ny = 100, spacing = 20)
pop &lt;- sim.popn(D = randomDensity, core = tempmask, model2D = "IHP",
    details = list(D = 10, p = 0.4, A = 0.5))
plot(attr(pop, 'mask'), cov = 'D', dots = FALSE)
plot(pop, add = TRUE)

## rLGCP demonstration
## - assumes spatstat and RandomFields have been installed

if (requireNamespace("spatstat") &amp;&amp; requireNamespace("RandomFields")) {
    msk &lt;- make.mask(traps(captdata))
    # details argument 'spacing' ensures core matches Lambda below
    pop &lt;- sim.popn(D = 20, core = msk, buffer = 0, 
        model2D = "rLGCP", details = list(var=1, scale = 30, saveLambda = TRUE), 
        seed = 1234)
    plot(pop)
    plot(traps(captdata), add = TRUE)

    # another IHP realisation from same LGCP intensity surface
    lgcp &lt;- attr(pop, 'Lambda')
    pop2 &lt;- sim.popn(D = 'Lambda', core = lgcp, model2D = "IHP")
    plot (lgcp, covariate = "Lambda", dots = FALSE)
    plot (pop2, add = TRUE, frame = FALSE)
    
    # check input and output masks match
    summary(lgcp)
    summary(msk)
}


## End(Not run)

</code></pre>

<hr>
<h2 id='sim.secr'>
Simulate From Fitted secr Model
</h2><span id='topic+simulate.secr'></span><span id='topic+sim.secr'></span><span id='topic+sim.detect'></span><span id='topic+simulate'></span>

<h3>Description</h3>

<p>Simulate a spatially distributed population, sample from that population
with an array of detectors, and optionally fit an SECR model to the
simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secr'
simulate(object, nsim = 1, seed = NULL, maxperpoly = 100,
    chat = 1, ...)

sim.secr(object, nsim = 1, extractfn = function(x) c(deviance =
    deviance(x), df = df.residual(x)), seed = NULL, maxperpoly = 100,
    data = NULL, tracelevel = 1, hessian = c("none", "auto", "fdHess"),
    start = object$fit$par, ncores = NULL)

sim.detect(object, popnlist, maxperpoly = 100, renumber = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.secr_+3A_object">object</code></td>
<td>
<p>a fitted secr model</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_nsim">nsim</code></td>
<td>
<p>integer number of replicates</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_seed">seed</code></td>
<td>
<p>either NULL or an integer that will be used in a call to <code>set.seed</code></p>
</td></tr>
<tr><td><code id="sim.secr_+3A_maxperpoly">maxperpoly</code></td>
<td>
<p> integer maximum number of detections of an individual
in one polygon or transect on any occasion </p>
</td></tr>
<tr><td><code id="sim.secr_+3A_chat">chat</code></td>
<td>
<p>real value for overdispersion parameter</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_ncores">ncores</code></td>
<td>
<p>integer number of threads used by <code>secr.fit</code></p>
</td></tr>
<tr><td><code id="sim.secr_+3A_extractfn">extractfn</code></td>
<td>
<p>function to extract output values from fitted model</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_data">data</code></td>
<td>
<p>optional list of simulated data saved from previous call to <code>simulate.secr</code></p>
</td></tr>
<tr><td><code id="sim.secr_+3A_tracelevel">tracelevel</code></td>
<td>
<p>integer for level of detail in reporting (0,1,2)</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_hessian">hessian</code></td>
<td>
<p>character or logical controlling the computation of the Hessian matrix</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_start">start</code></td>
<td>
<p>vector of starting &lsquo;beta&rsquo; values for <code>secr.fit</code></p>
</td></tr>
<tr><td><code id="sim.secr_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_popnlist">popnlist</code></td>
<td>
<p>list of popn objects</p>
</td></tr>
<tr><td><code id="sim.secr_+3A_renumber">renumber</code></td>
<td>
<p>logical; if TRUE then </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each replicate, <code>simulate.secr</code> calls <code><a href="#topic+sim.popn">sim.popn</a></code> to
generate session- and group-specific realizations of the (possibly
inhomogeneous) 2-D Poisson distribution fitted in <code>object</code>, across
the habitat mask(s) in <code>object</code>.  Group subpopulations are combined
using <code><a href="#topic+rbind.popn">rbind.popn</a></code> within each session; information to
reconstruct groups is retained in the individual-level factor
covariate(s) of the resulting <code>popn</code> object (corresponding to
<code>object$groups</code>).  Each population is then sampled using the fitted
detection model and detector (trap) array(s) in <code>object</code>.
</p>
<p>The random number seed is managed as in <code>simulate.lm</code>.
</p>
<p>Certain model types are not supported by <code>simulate.secr</code>. These
include models fitted using conditional likelihood (<code>object$CL =
TRUE</code>), telemetry models and exotic behavioural response models.
</p>
<p>Detector type is determined by <code>detector(traps(object$capthist))</code>.
</p>
<p><code>sim.secr</code> is a wrapper function. If <code>data = NULL</code> (the
default) then it calls <code>simulate.secr</code> to generate <code>nsim</code> new datasets. If
<code>data</code> is provided then <code>nsim</code> is taken to be
<code>length(data)</code>. <code>secr.fit</code> is called to fit the original model
to each new dataset. Results are summarized according to the
user-provided function <code>extractfn</code>. The default <code>extractfn</code>
returns the deviance and its degrees of freedom; a NULL value for
<code>extractfn</code> returns the fitted secr objects after
<code><a href="#topic+trim">trim</a></code>ming to reduce bulk. Simulation uses the detector type
of the data, even when another likelihood is fitted (this is the case
with single-catch data, for which a multi-catch likelihood is fitted).
Warning messages from <code>secr.fit</code> are suppressed.
</p>
<p><code>extractfn</code> should be a function that takes an <code>secr</code> object
as its only argument.
</p>
<p><code>tracelevel=0</code> suppresses most messages; <code>tracelevel=1</code> gives a
terse message at the start of each fit; <code>tracelevel=2</code> also sets
&lsquo;details$trace = TRUE&rsquo; for <code>secr.fit</code>, causing each likelihood
evaluation to be reported.
</p>
<p><code>hessian</code> controls computation of the Hessian matrix from which
variances and covariances are obtained. <code>hessian</code> replaces the
value in <code>object\$details</code>.  Options are &quot;none&quot; (no variances),
&quot;auto&quot; (the default) or &quot;fdhess&quot; (see <code><a href="#topic+secr.fit">secr.fit</a></code>). It is OK
(and faster) to use <code>hessian="none"</code> unless <code>extractfn</code> needs
variances or covariances. Logical TRUE and FALSE are interpreted by
<code>secr.fit</code> as &quot;auto&quot; and &quot;none&quot;.
</p>
<p>If <code>ncores = NULL</code> then the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS is used (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p><code>sim.capthist</code> is a more direct way to simulate data from a null
model (i.e. one with constant parameters for density and detection), or
from a time-varying model.
</p>
<p><code>sim.detect</code> is a function used internally that will not usually be
called directly.
</p>


<h3>Value</h3>

<p>For <code>simulate.secr</code>, a list of data sets (&lsquo;capthist&rsquo; objects). This
list has class <code>c("secrdata", "list")</code>; the initial state of the random
number generator (roughly, the value of .Random.seed) is stored as the
attribute &lsquo;seed&rsquo;.
</p>
<p>The value from <code>sim.secr</code> depends on <code>extractfn</code>: if that
returns a numeric vector of length <code>n.extract</code> then the value is a
matrix with <code>dim = c(nsim, n.extract)</code> (i.e., the matrix has one
row per replicate and one column for each extracted value). Otherwise,
the value returned by <code>sim.secr</code> is a list with one component per
replicate (strictly, an object of class = <code>c("secrlist", "list")</code>). Each
simulated fit may be retrieved <em>in toto</em> by specifying
<code>extractfn = identity</code>, or slimmed down by specifying
<code>extractfn = NULL</code> or <code>extractfn = trim</code>, which are
equivalent.
</p>
<p>For either form of output from <code>sim.secr</code> the initial state of the
random number generator is stored as the attribute &lsquo;seed&rsquo;.
</p>
<p>For <code>sim.detect</code> a list of &lsquo;capthist&rsquo; objects.
</p>


<h3>Warning</h3>

<p><code>sim.secr</code> does not work for mark&ndash;resight models.
</p>


<h3>Note</h3>

<p>The value returned by <code>simulate.secr</code> is a list of &lsquo;capthist&rsquo;
objects; if there is more than one session, each &lsquo;capthist&rsquo; is itself a
sort of list .
</p>
<p>The classes &lsquo;secrdata&rsquo; and &lsquo;secrlist&rsquo; are used only to override the ugly
and usually unwanted printing of the seed attribute. However, a few
other methods are available for &lsquo;secrlist&rsquo; objects
(e.g. <code>plot.secrlist</code>).
</p>
<p>The default value for <code>start</code> in <code>sim.secr</code> is the previously
fitted parameter vector. Alternatives are NULL or <code>object$start</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.capthist">sim.capthist</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="stats.html#topic+simulate">simulate</a></code>, <code><a href="#topic+secr.test">secr.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## previously fitted model
simulate(secrdemo.0, nsim = 2)

## The following has been superceded by secr.test()

## this would take a long time...
sims &lt;- sim.secr(secrdemo.0, nsim = 99)
deviance(secrdemo.0)
devs &lt;- c(deviance(secrdemo.0),sims$deviance)
quantile(devs, probs=c(0.95))
rank(devs)[1] / length(devs)

## to assess bias and CI coverage
extrfn &lt;- function (object) unlist(predict(object)["D",-1])
sims &lt;- sim.secr(secrdemo.0, nsim = 50, hessian = "auto",
    extractfn = extrfn)
sims

## with a larger sample, could get parametric bootstrap CI
quantile(sims[,1], c(0.025, 0.975))


## End(Not run)

</code></pre>

<hr>
<h2 id='skink'> Skink Pitfall Data </h2><span id='topic+skink'></span><span id='topic+infraCH'></span><span id='topic+lineoCH'></span><span id='topic+LStraps'></span>

<h3>Description</h3>

<p>Data from a study of skinks (<em>Oligosoma infrapunctatum</em> and
<em>O. lineoocellatum</em>) in New Zealand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
infraCH
lineoCH
LStraps

</code></pre>


<h3>Details</h3>

<p>Lizards were studied over several years on a steep bracken-covered
hillside on Lake Station in the Upper Buller Valley, South Island, New
Zealand. Pitfall traps (sunken cans baited with a morsel of fruit in
sugar syrup) were set in two large grids, each 11 x 21 traps nominally 5
meters apart, surveyed by tape and compass (locations determined later
with precision surveying equipment - see Examples). Three diurnal lizard
species were trapped: <em>Oligosoma infrapunctatum</em>,
<em>O. lineoocellatum</em> and <em>O. polychroma</em> (Scincidae). The
smallest species <em>O. polychroma</em> was seldom caught and these data
are not included. The two other species are almost equal in average size
(about 160 mm total length); they are long-lived and probably mature in
their second or third year. The study aimed to examine their habitat use
and competitive interactions.
</p>
<p>Traps were set for 12 3-day sessions over 1995&ndash;1996, but some sessions
yielded very few captures because skinks were inactive, and some sessions were
incomplete for logistical reasons. The data are from sessions 6 and 7 in
late spring (17&ndash;20 October 1995 and 14&ndash;17 November 1995). Traps were
cleared daily; the few skinks present when traps were closed on the
morning of the fourth day are treated as Day 3 captures. Individuals
were marked uniquely by clipping one toe on each foot. Natural toe loss
caused some problems with long-term identification; captures were
dropped from the dataset when identity was uncertain. Released animals
were occasionally recaptured in a different trap on the same day; these
records were also discarded.
</p>
<p>The data are provided as two two-session <code>capthist</code> objects
&lsquo;infraCH&rsquo; and &lsquo;lineoCH&rsquo;. Also included is &lsquo;LStraps&rsquo;, the <code>traps</code>
object with the coordinates and covariates of the trap sites (these data
are also embedded in each of the <code>capthist</code> objects). Pitfall traps
are multi-catch traps so <code>detector(LStraps)</code> = &lsquo;multi&rsquo;.  
</p>
<p>Habitat data for each trap site are included as a dataframe of trap
covariates in <code>LStraps</code>. Ground cover and vegetation were recorded
for a 1-m radius plot at each trap site. The dataframe also gives the
total number of captures of each species by site on 31 days between
April 1995 and March 1996, and the maximum potential annual solar
radiation calculated from slope and aspect (Frank and Lee 1966). Each
site was assigned to a habitat class by fuzzy clustering (Kaufman
and Rousseauw 1990; package <span class="pkg">cluster</span>) of a distance matrix using
the ground cover, vegetation and solar radiation variables. Sites in
class 1 were open with bare ground or low-canopy vegetation including
the heath-like <em>Leucopogon fraseri</em> and grasses; sites in class 2
had more-closed vegetation, lacking <em>Leucopogon fraseri</em> and with a
higher canopy that often included <em>Coriaria arborea</em>. Site
variables are listed with definitions in the attribute
<code>habitat.variables</code> of <code>LStraps</code> (see Examples).
</p>


<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
  infraCH </td><td style="text-align: left;"> multi-session capthist object O. infrapunctatum </td>
</tr>
<tr>
 <td style="text-align: left;">
  lineoCH </td><td style="text-align: left;"> multi-session capthist object O. lineoocellatum </td>
</tr>
<tr>
 <td style="text-align: left;">
  LStraps </td><td style="text-align: left;"> traps object -- Lake Station grids </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>





<h3>Source</h3>

<p>M. G. Efford, B. W. Thomas and N. J. Spencer unpublished data.
</p>


<h3>References</h3>

<p>Efford, M. G., Spencer, N. J., Thomas, B. W., Mason, R. F. and Williams,
P. In prep. Distribution of sympatric skink species in relation to habitat.
</p>
<p>Frank, E. C. and Lee , R. (1966) Potential solar beam irradiation on
slopes. <em>United States Forest Service Research Paper</em> RM-118.
</p>
<p>Kaufman, L. and Rousseauw, P. J. (1990) <em>Finding groups in data: an
introduction to cluster analysis.</em> John Wiley &amp; Sons, New York.
</p>
<p>Spencer, N. J., Thomas, B. W., Mason, R. F. and Dugdale, J. S. (1998)
Diet and life history variation in the sympatric lizards <em>Oligosoma
nigriplantare polychroma</em> and <em>Oligosoma lineoocellatum</em>. New
Zealand Journal of Zoology 25: 457&ndash;463.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+covariates">covariates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary (infraCH)
summary (lineoCH)

## check mean distance to nearest trap etc.
summary(LStraps)

## LStraps has several site covariates; terse descriptions are in
##  an extra attribute that may be displayed thus
attr(LStraps, "habitat.variables")

## For density modelling we need covariate values at each point in the
## habitat mask. This requires both on-grid interpolation and
## extrapolation beyond the grids. One (crude) possibility is to
## extrapolate a mask covariate from a covariate of the nearest trap:

LSmask &lt;- make.mask(LStraps, buffer = 30, type = "trapbuffer")
temp &lt;- nearesttrap(LSmask, LStraps)
habclass &lt;- covariates(LStraps)$class[temp]
habclass &lt;- factor (habclass, levels = c(1,2))
covariates(LSmask) &lt;- data.frame(habclass)

## plot mask with colour-coded covariate
par(fg = "white")  ## white pixel borders
plot (LSmask, covariate = "habclass", dots = FALSE, axes = FALSE,
    col = c("yellow", "green"), border = 0)
plot(LStraps, add = TRUE, detpar = list(pch = 16))
par(fg = "black")    ## default
</code></pre>

<hr>
<h2 id='smooths'> Smooth Terms in SECR Models </h2><span id='topic+smooths'></span>

<h3>Description</h3>

<p>From version 2.9.0, the model formulae provided to <code>secr.fit</code> may
include smooth terms as specified for the <span class="pkg">mgcv</span> function &lsquo;gam&rsquo;,
with some restrictions. Smooth terms may be used for both density and
detection parameters.
</p>


<h3>Details</h3>

<p>The specification of smooth terms is explained in
<code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>. Only a subset of options are relevant
to &lsquo;secr&rsquo;. Penalized splines are not available. The smooth function
may be &lsquo;s&rsquo; or &lsquo;te&rsquo;.
</p>
<p>The &lsquo;wiggliness&rsquo; of the curve is controlled by the argument k,
which in this implementation is set by the user. The argument &lsquo;fx&rsquo;
should be set to TRUE.
</p>
<p>See also the example in <a href="https://www.otago.ac.nz/density/pdfs/secr-densitysurfaces.pdf">secr-densitysurfaces.pdf</a>.
</p>


<h3>Background</h3>

<p>Regression splines are a very flexible way to represent non-linear
responses in generalized additive models (e.g., <span class="pkg">mgcv</span>, Wood
2006). Borchers and Kidney (2014) have shown how they may be used
to model 2-dimensional trend in density in <span class="pkg">secrgam</span>, an <span class="rlang"><b>R</b></span>
package that extends <span class="pkg">secr</span>. Their approach is to use <span class="pkg">mgcv</span>
to construct regression spline basis functions from mask x- and
y-coordinates, and possibly additional mask covariates, and to pass
these as covariates to <span class="pkg">secr</span>. The idea of using <span class="pkg">mgcv</span> to
construct the basis functions is applied within <span class="pkg">secr</span> from version 2.9.
</p>
<p>Smooth semi-parametric responses are also useful for modelling
variation in detection parameters such as g0 and sigma over time, or
in response to individual or detector-level covariates, when (1) a
linear or other parametric response is arbitrary or implausible, and
(2) sampling spans a range of times or levels of the covariate(s).
</p>
<p>For a concrete example, consider a population sampled monthly for a
year (i.e., 12 &lsquo;sessions&rsquo;). If home range size varies seasonally then
the parameter sigma may vary in a more-or-less sinusoidal fashion. A
linear trend is obviously inadequate, and a quadratic is not much
better. However, a sine curve is hard to fit (we would need to
estimate its phase, amplitude, mean and spatial scale) and assumes the
increase and decrease phases are equally steep. An extreme solution is
to treat month as a factor and estimate a separate parameter for each
level (month). A smooth (semi-parametric) curve may capture the main
features of seasonal variation with fewer parameters.
</p>


<h3>Warning</h3>

<p>This implementation of smooth models results in large fitted objects, on
account of the need to store setup information from <span class="pkg">mgcv</span>. It is
also vulnerable to future changes in <span class="pkg">mgcv</span>.
</p>
<p>Expect that the implementation will change in later versions of
<span class="pkg">secr</span>, and that smooth models fitted in the this version will not
necessarily be compatible with <code>predict</code> and
<code>predictDsurface</code> in later versions.
</p>


<h3>Note</h3>

<p>Setting the intercept of a smooth to zero is not a canned option in
<span class="pkg">mgcv</span>, and is not offered in <span class="pkg">secr</span>. It may be achieved by
placing a knot at zero and hacking the matrix of basis functions to
drop the corresponding column, plus some more jiggling.

</p>


<h3>References</h3>

 
<p>Borchers, D. L. and Kidney, D. (2014) <em>Flexible density surface estimation for spatially explicit capture&ndash;recapture surveys</em>. Technical Report, University of St Andrews.
</p>
<p>Wood, S. N. (2006) <em>Generalized Additive Models: An Introduction with
R.</em> Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## smooth density surface
possum.model.sxy &lt;- secr.fit(possumCH, mask = possummask,
    model = D ~ s(x,y, k = 6, fx = TRUE), trace = FALSE)
fittedsurface &lt;- predictDsurface(possum.model.sxy)
par(mar = c(1,1,1,6))
plot(fittedsurface)
plot(fittedsurface, plottype = 'contour', add = TRUE)
par(mar = c(5,4,4,2) + 0.1)  ## reset to default

## Now try smooth on g0

## For the smooth we use 'Session' which is coded numerically (0:4)
## rather than the factor 'session' ('2005', '2006', '2007', '2008',
## '2009')

ovenbird.model.g0 &lt;- secr.fit(ovenCH, mask = ovenmask,
    model = g0 ~ session, trace = FALSE)
ovenbird.model.sg0 &lt;- secr.fit(ovenCH, mask = ovenmask,
    model = g0 ~ s(Session, k = 3, fx = TRUE), trace = FALSE)

AIC(ovenbird.model.g0, ovenbird.model.sg0)

## Or over occasions within a session...

fit.sT3 &lt;- secr.fit(captdata, model = g0 ~ s(T, k = 3, fx = TRUE),
    trace = FALSE)
pred &lt;- predict(fit.sT3, newdata = data.frame(T = 0:4))

plot(sapply(pred, '[', 'g0', 'estimate'))


## End(Not run)

</code></pre>

<hr>
<h2 id='snip'>Slice Transect Into Shorter Sections</h2><span id='topic+snip'></span>

<h3>Description</h3>

<p>This function splits the transects in a &lsquo;transect&rsquo; or &lsquo;transectX&rsquo;
traps object into multiple shorter sections. The function may also be
applied directly to a capthist object based on transect data. This
makes it easy to convert detection data collected along linear
transects to point detection data (see Example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
snip(object, from = 0, by = 1000, length.out = NULL, keep.incomplete = TRUE, tol = 0.01)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snip_+3A_object">object</code></td>
<td>
<p>secr &lsquo;traps&rsquo; or &lsquo;capthist&rsquo; object based on transects</p>
</td></tr>
<tr><td><code id="snip_+3A_from">from</code></td>
<td>
<p>numeric starting posiiton (m)</p>
</td></tr>
<tr><td><code id="snip_+3A_by">by</code></td>
<td>
<p>numeric length of new transects (m) </p>
</td></tr>
<tr><td><code id="snip_+3A_length.out">length.out</code></td>
<td>
<p>numeric number of new transects, as alternative to &lsquo;by&rsquo;</p>
</td></tr>
<tr><td><code id="snip_+3A_keep.incomplete">keep.incomplete</code></td>
<td>
<p>logical; if TRUE then initial or terminal
sections of each original transect that are less than &lsquo;by&rsquo; will be
retained in the output</p>
</td></tr>
<tr><td><code id="snip_+3A_tol">tol</code></td>
<td>
<p>numeric tolerance for xyontransect (capthist only)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a positive <code>length.out</code> is specified, <code>by</code> will be computed as
<code>(transectlength(object) - from) / length.out</code>.
</p>


<h3>Value</h3>

<p>A &lsquo;traps&rsquo; or &lsquo;capthist&rsquo; object, according to the input.
If <code>keep.incomplete == FALSE</code> animals and detections from the
</p>


<h3>Warning</h3>

<p><code>snip</code> does not work for mark&ndash;resight data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transectlength">transectlength</a></code>, <code><a href="#topic+discretize">discretize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0, 4*pi, length = 41)
temptrans &lt;- make.transect(x = x*100, y = sin(x)*300)
plot (snip(temptrans, by = 200), markvertices = 1)

## Not run: 

## simulate some captures
tempcapt &lt;- sim.capthist(temptrans, popn = list(D = 2,
   buffer = 300), detectfn = 'HHN', binomN = 0,
   detectpar = list(lambda0 = 0.5, sigma = 50))

## snip capture histories
tempCH &lt;- snip(tempcapt, by = 20)

## collapse from 'transect' to 'count', discarding location within transects
tempCH &lt;- reduce(tempCH, outputdetector = "count")

## fit secr model and examine H-T estimates of density
## fails with detectfn = 'HN'
fit &lt;- secr.fit(tempCH, buffer = 300, CL = TRUE, detectfn = 'HHN', trace = FALSE)
derived(fit)

## also, may split an existing transect into equal lengths
## same result:
plot(snip(temptrans, by = transectlength(temptrans)/10),
    markvertices = 1)
plot(snip(temptrans, length.out = 10), markvertices = 1)


## End(Not run)

</code></pre>

<hr>
<h2 id='sort.capthist'>
Sort Rows of capthist or mask Object
</h2><span id='topic+sort.capthist'></span><span id='topic+sort.mask'></span>

<h3>Description</h3>

<p>Rows are sorted by fields in covariates or by a provided sort key of
length equal to the number of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'capthist'
sort(x, decreasing = FALSE, by = "",
    byrowname = TRUE,...)

## S3 method for class 'mask'
sort(x, decreasing = FALSE, by = "",
    byrowname = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.capthist_+3A_x">x</code></td>
<td>
<p><code>capthist</code> object
</p>
</td></tr>
<tr><td><code id="sort.capthist_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort be increasing or decreasing? </p>
</td></tr>
<tr><td><code id="sort.capthist_+3A_by">by</code></td>
<td>
<p>character vector (names of covariates) or data frame whose
columns will be used as sort keys</p>
</td></tr>
<tr><td><code id="sort.capthist_+3A_byrowname">byrowname</code></td>
<td>
<p>logical. Should row name be used as a final sort key?</p>
</td></tr>
<tr><td><code id="sort.capthist_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For multi-session <code>capthist</code> objects only the named covariate form
is suitable as the number of rows varies between sessions.
</p>
<p>If requested, rows are sorted by rowname within <code>by</code>. The effect of
the defaultsis to sort by rowname.
</p>
<p>The attribute markingpoints of a mask object is removed if present, as it is no longer meaningful.
</p>


<h3>Value</h3>

<p><code>capthist</code> or <code>mask</code> object with sorted rows; any relevant attributes are
also sorted (covariates, signal, xy)</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sort(ovenCH, by = "Sex")
covariates(ovenCH)[["2005"]]
covariates(sort(ovenCH, by = "Sex"))[["2005"]]
</code></pre>

<hr>
<h2 id='spacing'> Detector or Mask Spacing </h2><span id='topic+spacing'></span><span id='topic+spacing.traps'></span><span id='topic+spacing.mask'></span><span id='topic+spacing+3C-'></span>

<h3>Description</h3>

<p>Extract or replace the spacing attribute of a detector array or mask. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spacing(object, ...)
spacing(object) &lt;- value

## S3 method for class 'traps'
spacing(object, ..., recalculate = FALSE)
## S3 method for class 'mask'
spacing(object, ..., recalculate = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spacing_+3A_object">object</code></td>
<td>
<p> object with &lsquo;spacing&rsquo; attribute e.g. <code>traps</code> </p>
</td></tr>
<tr><td><code id="spacing_+3A_value">value</code></td>
<td>
<p> numeric value for spacing </p>
</td></tr>
<tr><td><code id="spacing_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
<tr><td><code id="spacing_+3A_recalculate">recalculate</code></td>
<td>
<p>logical; if TRUE compute average spacing afresh</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;spacing&rsquo; attribute of a detector array is the average distance from
one detector to the nearest other detector.
</p>
<p>The attribute was not always set by <code>make.grid()</code> and
<code>read.traps()</code> in versions of <span class="pkg">secr</span> before 1.5.0. If the
attribute is found to be NULL then <code>spacing</code> will compute it on the
fly.
</p>


<h3>Value</h3>

<p>scalar numeric value of mean spacing, or a vector if <code>object</code> has multiple sessions
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+traps">traps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temptrap &lt;- make.grid(nx = 6, ny = 8)
spacing(temptrap)
</code></pre>

<hr>
<h2 id='speed'> Speed Tips </h2><span id='topic+speed'></span><span id='topic+Speed+20tips'></span>

<h3>Description</h3>

<p>A list of ways to make <code><a href="#topic+secr.fit">secr.fit</a></code> run faster. 
</p>


<h3>Use an appropriate mask</h3>

<p>Check the extent and spacing of the habitat mask that you are using.
Execution time is roughly proportional to the number of mask points
(<code>nrow(mymask)</code>).  Default settings can lead to very large masks
for detector arrays that are elongated &lsquo;north-south&rsquo; because the number
of points in the east-west direction is fixed. Compare results with a
much sparser mask (e.g., nx = 32 instead of nx = 64).
</p>


<h3>Use conditional likelihood</h3>

<p>If you don't need to model variation in density over space or time then
consider maximizing the conditional likelihood in secr.fit (CL =
TRUE). This reduces the complexity of the optimization problem,
especially where there are several sessions and you want
session-specific density estimates (by default, derived() returns a
separate estimate for each session even if the detection parameters are
constant across sessions).
</p>


<h3>Model selection</h3>

<p>Do you really need to fit all those complex models? Chasing down small
decrements in AIC is so last-century. Remember that detection parameters
are mostly nuisance parameters, and models with big differences in AIC
may barely differ in their density estimates. This is a good topic for
further research - we seem to need a &lsquo;focussed information criterion&rsquo;
(Claeskens and Hjort 2008) to discern the differences that matter. Be
aware of the effects that can really make a difference: learned
responses (b, bk etc.) and massive unmodelled heterogeneity.
</p>
<p>Use score.test() to compare nested models. At each stage this
requires only the more simple model to have been fitted in full; further
processing is required to obtain a numerical estimate of the gradient of
the likelihood surface for the more complex model, but this is much
faster than maximizing the likelihood. The tradeoff is that the score
test is only approximate, and you may want to later verify the results
using a full AIC comparison.
</p>


<h3>Break problem down</h3>

<p>Suppose you are fitting models to multiple separate datasets that fit
the general description of &lsquo;sessions&rsquo;. If you are fitting separate
detection parameters to each session (i.e., you do not need to pool
detection information), and you are not modelling trend in density
across sessions, then it is much quicker to fit each session
separately than to try to do it all at once. See Examples.
</p>


<h3>Mash replicated clusters of detectors</h3>

<p>If your detectors are arranged in similar clusters (e.g., small square
grids) then try the function <code><a href="#topic+mash">mash</a></code>.
</p>


<h3>Reduce sparse &lsquo;proximity&rsquo; data to &lsquo;multi&rsquo;</h3>

<p>Full data from &lsquo;proximity&rsquo; detectors has dimensions n x S x K (n is
number of individuals, S is number of occasions, K is number of
traps). If the data are sparse (i.e. multiple detections of an
individual on one occasion are rare) then it is efficient to treat
proximity data as multi-catch data (dimension n x S, maximum of one
detection per occasion). Use <code>reduce(proxCH, outputdetector =
  "multi")</code>.
</p>


<h3> Use multiple cores when applicable </h3>

<p>Most computers these days have multiple processors and these will be used by <span class="pkg">secr</span> if the user sets <code>ncores</code> greater than one in <code>secr.fit</code>, <code>sim.secr</code> and some other functions. If <code>ncores = NULL</code> then the existing value from the environment variable RCPP_PARALLEL_NUM_THREADS is used (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>


<h3> Avoid covariates with many levels </h3>

<p>Categorical (factor) covariates with many levels and continuous
covariates that take many values are not handled efficiently in
secr.fit, and can dramatically slow down analyses and increase memory
requirements.
</p>


<h3> Set appropriate typsize </h3>

<p>Setting typsize manually in the call of 'secr.fit' can speed up fitting when 
magnitudes on the link scale are very different (for example, when an identity 
link is used for density and density is very small or very large).
</p>


<h3> Simulations </h3>

<p>Model fitting is not needed to assess power. The precision of estimates
from secr.fit can be predicted without laboriously fitting models to
simulated datasets. Just use <code>method = "none"</code> to obtain the asymptotic
variance at the known parameter values for which data have been
simulated (e.g. with sim.capthist()).
</p>
<p>Suppress computation of standard errors by derived(). For a
model fitted by conditional likelihood (CL = TRUE) the subsequent
computation of derived density estimates can take appreciable time. If
variances are not needed (e.g., when the aim is to predict the bias of
the estimator across a large number of simulations) it is efficient to
set se.D = FALSE in derived().
</p>
<p>It is tempting to save a list with the entire &lsquo;secr&rsquo; object from
each simulated fit, and to later extract summary statistics as
needed. Be aware that with large simulations the overheads associated
with storage of the list can become very large. The solution is to
anticipate the summary statistics you will want and save only these.
</p>


<h3>References</h3>

<p>Claeskens, G. and Hjort N. L. (2008) <em>Model Selection and Model
Averaging</em>. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## compare timing of combined model with separate single-session models
## for 5-session ovenbird mistnetting data: 2977/78 = 38-fold difference

setNumThreads(7)

system.time(fit1 &lt;- secr.fit(ovenCH, buffer = 300, trace = FALSE, 
    model = list(D ~ session, g0 ~ session, sigma ~ session)))
##    user  system elapsed 
## 1837.71   31.81  730.56 

system.time(fit2 &lt;- lapply (ovenCH, secr.fit, buffer = 300, trace = FALSE))
##   user  system elapsed 
##  43.74    0.46   11.13  

## ratio of density estimates
collate(fit1)[,1,1,"D"] / sapply(fit2, function(x) predict(x)["D","estimate"])
## session=2005 session=2006 session=2007 session=2008 session=2009 
##    1.0000198    1.0000603    0.9999761    0.9999737    0.9999539 


## End(Not run)

</code></pre>

<hr>
<h2 id='stoatDNA'> Stoat DNA Data </h2><span id='topic+stoatDNA'></span><span id='topic+stoatCH'></span><span id='topic+stoat.model.HN'></span><span id='topic+stoat.model.EX'></span>

<h3>Description</h3>

<p>Data of A. E. Byrom from a study of stoats (<em>Mustela erminea</em>) in
New Zealand. Individuals were identified from DNA in hair samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
stoatCH
stoat.model.HN
stoat.model.EX

</code></pre>


<h3>Details</h3>

<p>The data are from a pilot study of stoats in red beech (<em>Nothofagus fusca</em>)
forest in the Matakitaki Valley, South Island, New Zealand. Sticky
hair-sampling tubes (<em>n</em> = 94) were placed on a 3-km x 3-km grid
with 500-m spacing between lines and 250-m spacing along lines. Tubes
were baited with rabbit meat and checked daily for 7 days, starting on
15 December 2001. Stoat hair samples were identified to individual
using DNA microsatellites amplified by PCR from follicular tissue
(Gleeson et al. 2010). Six loci were amplified and the mean number of
alleles was 7.3 per locus. Not all loci could be amplified in 27% of
samples. A total of 40 hair samples were collected (Gleeson et
al. 2010), but only 30 appear in this dataset; the rest presumably
did not yield sufficient DNA for genotyping.
</p>
<p>The data are provided as a single-session <code>capthist</code> object
&lsquo;stoatCH&rsquo;. Hair tubes are &lsquo;proximity&rsquo; detectors which allow
an individual to be detected at multiple detectors on one occasion
(day), but there are no multiple detections in this dataset and for
historical reasons the data are provided as detector type &lsquo;multi&rsquo;. Two
pre-fitted models are included: <code>stoat.model.HN</code> and <code>stoat.model.EX</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
  Object </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
  stoatCH </td><td style="text-align: left;"> capthist object </td>
</tr>
<tr>
 <td style="text-align: left;">
  stoat.model.HN </td><td style="text-align: left;"> fitted secr model -- null, halfnormal detection function </td>
</tr>
<tr>
 <td style="text-align: left;">
  stoat.model.EX </td><td style="text-align: left;"> fitted secr model -- null, exponential detection function </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>The log-likelihood values reported for these data by <code>secr.fit</code>
differ by a constant from those published by Efford et al. (2009)
because the earlier version of DENSITY used in that analysis did not
include the multinomial coefficient, which in this case is log(20!) or
about +42.336. The previous analysis also used a coarser habitat mask
than the default in <span class="pkg">secr</span> (32 x 32 rather than 64 x 64) and this
slightly alters the log-likelihood and <code class="reqn">\Delta</code>AIC
values.
</p>
<p>Fitting the hazard-rate detection function previously required the
shape parameter z (or b) to be fixed, but the model can be fitted in
<span class="pkg">secr</span> without fixing z. However, the hazard rate function can
cause problems owing to its long tail, and it is not recommended. The
check on the buffer width, usually applied automatically on completion of
secr.fit, causes an error and must be suppressed with biasLimit = NA
(see Examples).
</p>
<p>Gleeson et al. (2010) address the question of whether there is enough
variability at the sampled microsatellite loci to distinguish
individuals. The reference to 98 sampling sites in that paper is a minor
error (A. E. Byrom pers. comm.).
</p>


<h3>Source</h3>

<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>


<h3>References</h3>

<p>Gleeson, D. M., Byrom, A. E. and Howitt, R. L. J. (2010) Non-invasive
methods for genotyping of stoats (<em>Mustela erminea</em>) in New
Zealand: potential for field applications. <em>New Zealand Journal of
Ecology</em> <b>34</b>, 356&ndash;359. Available on-line at
<a href="https://newzealandecology.org/nzje/2936/">https://newzealandecology.org/nzje/2936/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+Detection+20functions">Detection functions</a></code>,
<code><a href="#topic+secr.fit">secr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(stoatCH)

## Not run: 

stoat.model.HN &lt;- secr.fit(stoatCH, buffer = 1000, detectfn = 0)

# this generates an error unless we use biasLimit = NA
# to suppress the default bias check

stoat.model.EX &lt;- secr.fit(stoatCH, buffer = 1000, detectfn = 2)
confint(stoat.model.HN, "D")
## Profile likelihood interval(s)...
##         lcl        ucl
## D 0.01275125 0.04055662


## End(Not run)

## plot fitted detection functions
xv &lt;- seq(0,800,10)
plot(stoat.model.EX, xval = xv, ylim = c(0,0.12), limits = FALSE,
    lty = 2)
plot(stoat.model.HN, xval = xv, limits = FALSE, lty = 1, add = TRUE)

## review density estimates
collate(stoat.model.HN, stoat.model.EX,
    realnames = "D", perm = c(2,3,4,1))
modelAverage(stoat.model.HN, stoat.model.EX, realnames = "D")

</code></pre>

<hr>
<h2 id='strip.legend'>Colour Strip Legend</h2><span id='topic+strip.legend'></span>

<h3>Description</h3>

<p>This function is used with shaded plots to display a legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
strip.legend(xy, legend, col, legendtype = c("breaks", "intervals", "other"),
  tileborder = NA, height = 0.5, width = 0.06, inset = 0.06, text.offset = 0.02,
  text.cex = 0.9, xpd = TRUE, scale = 1, title = "", box = NA, box.col = par()$bg)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip.legend_+3A_xy">xy</code></td>
<td>
<p>location of legend (see Details)</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_legend">legend</code></td>
<td>
<p>character vector (see Details)</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_col">col</code></td>
<td>
<p>vector of colour values</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_legendtype">legendtype</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_tileborder">tileborder</code></td>
<td>
<p>colour of lines around each tile in the colour strip. Use
NA for none.</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_height">height</code></td>
<td>
<p>height of colour strip as a fraction of the plot dimensions</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_width">width</code></td>
<td>
<p>width of colour strip as a fraction of the plot dimensions</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_inset">inset</code></td>
<td>
<p>spacing between legend and outside plot boundary, as a
fraction of the plot dimensions</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_text.offset">text.offset</code></td>
<td>
<p>spacing between colour strip and text, as a
fraction of the plot dimensions</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_text.cex">text.cex</code></td>
<td>
<p>size of text font</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_xpd">xpd</code></td>
<td>
<p>logical, if TRUE the legend will use the margins of the plot</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_scale">scale</code></td>
<td>
<p>numeric; each value x will be displayed as scale * x</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_title">title</code></td>
<td>
<p>text displayed above legend</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_box">box</code></td>
<td>
<p>colour of frame, if framed, otherwise NA</p>
</td></tr>
<tr><td><code id="strip.legend_+3A_box.col">box.col</code></td>
<td>
<p>colour of background, if framed, otherwise ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location of the legend is determined by <code>xy</code> which may be one
of the character values &quot;topright&quot;, &quot;topleft&quot;, &quot;bottomright&quot;,
&quot;bottomleft&quot;, &quot;right&quot;, &quot;left&quot;, or the x-y coordinates (in
user units) of the top-left corner of the colour strip. Coordinates may
be given as a vector or a list, and the output from
<code><a href="graphics.html#topic+locator">locator</a></code>(1) is suitable.
</p>
<p>For more on colours, see notes in <code><a href="#topic+plot.mask">plot.mask</a></code> and
<code><a href="grDevices.html#topic+colors">colors</a></code> and <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>
</p>
<p>If <code>legendtype = 'breaks'</code> then labels are placed at the class
boundaries; otherwise, the labels are centred vertically. If
<code>legendtype = 'breaks'</code> or  <code>legendtype = 'intervals'</code> then
numeric values are extracted from the input, otherwise the text strings
in <code>legend</code> are used as provided. 
</p>
<p>The legend itself may be provided as a vector of values or as the class
labels output from <code><a href="#topic+plot.mask">plot.mask</a></code>. Class labels are generated
by <code><a href="base.html#topic+cut">cut</a></code> in the form &lsquo;(0,20]&rsquo;, &lsquo;(20,40]&rsquo;, etc. These are
parsed to construct either breaks (0,20,40,...) or intervals (&lsquo;0-20&rsquo;,
&lsquo;20-40&rsquo;,...) as requested in the <code>legendtype</code> argument.
</p>
<p><code>box</code> may also be TRUE/FALSE; if TRUE the foreground colour is used <code>par()$fg</code>.
</p>


<h3>Value</h3>

<p>Invisibly returns a vector of user coordinates for the left, right,
bottom and top of the colour strip.
</p>


<h3>Note</h3>

<p>From <span class="pkg">secr</span> 2.9.0, the default behaviour of <code>plot.mask</code> is to
call <code>strip.legend</code> to display a legend in the top right of the
plot, labeled at breaks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mask">plot.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

temptrap &lt;- make.grid()
tempmask &lt;- make.mask(temptrap)
covariates (tempmask) &lt;- data.frame(circle = 
    exp(-(tempmask$x^2 + tempmask$y^2)/10000) )
tmpleg &lt;- plot (tempmask, covariate = "circle", dots = FALSE, 
    breaks = 10, legend = FALSE)
strip.legend (xy = 'topright', col = terrain.colors(10),
    legend = tmpleg, title = "Test plot")

if (interactive()) {
    ## a custom axis using the returned values
    par(mar = c(2,2,2,6))
    plot (tempmask, covariate = "circle", dots = FALSE, 
        breaks = 10, legend = FALSE)
    b &lt;- strip.legend (locator(1), col = terrain.colors(10),
        legendtype = "other", legend = "    ", title = "Test plot",
         height = 0.3, box = NA)
    axis(side = 4, pos = b[2]+5, at = seq(b[4], b[3], length = 3),
        lab = seq(0,1,0.5), las = 1, tck = -0.02)
    par(mar = c(5,4,4,2) + 0.1)  ## reset to default
}

</code></pre>

<hr>
<h2 id='subset.capthist'> Subset or Split capthist Object </h2><span id='topic+subset.capthist'></span><span id='topic+split.capthist'></span>

<h3>Description</h3>

<p>Create a new <code>capthist</code> object or list of objects by selecting rows (individuals), columns (occasions) and traps from an existing <code>capthist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'capthist'
subset(x, subset = NULL, occasions = NULL, traps = NULL,
    sessions = NULL, cutval = NULL, dropnullCH = TRUE, dropnullocc = FALSE,
    dropunused = TRUE, droplowsignals = TRUE, dropNAsignals = FALSE,
    cutabssignal = TRUE, renumber = FALSE, ...)

## S3 method for class 'capthist'
split(x, f, drop = FALSE, prefix = "S", bytrap = FALSE, 
 byoccasion = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.capthist_+3A_x">x</code></td>
<td>
<p> object of class <code>capthist</code> </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_subset">subset</code></td>
<td>
<p> vector of subscripts to select rows (individuals) (see Details for variations)</p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_occasions">occasions</code></td>
<td>
<p> vector of subscripts to select columns (occasions) </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_traps">traps</code></td>
<td>
<p> vector of subscripts to select detectors (traps) </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_sessions">sessions</code></td>
<td>
<p> vector of subscripts to select sessions </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_cutval">cutval</code></td>
<td>
<p> new threshold for signal strength </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_dropnullch">dropnullCH</code></td>
<td>
<p> logical for whether null (all-zero) capture histories
should be dropped </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_dropnullocc">dropnullocc</code></td>
<td>
<p> logical for whether occasions with no detections should be dropped </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_dropunused">dropunused</code></td>
<td>
<p> logical for whether never-used detectors should be
dropped </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_droplowsignals">droplowsignals</code></td>
<td>
<p> logical for whether cutval should be applied at each
microphone rather than to sound as a whole </p>
</td></tr> 
<tr><td><code id="subset.capthist_+3A_dropnasignals">dropNAsignals</code></td>
<td>
<p> logical for whether detections with missing
signal should be dropped </p>
</td></tr> 
<tr><td><code id="subset.capthist_+3A_cutabssignal">cutabssignal</code></td>
<td>
<p> logical for whether to apply cutval to absolute
signal strength or the difference between signal and noise</p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_renumber">renumber</code></td>
<td>
<p> logical for whether row.names should be replaced with sequence number in new <code>capthist</code> </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_f">f</code></td>
<td>
<p> factor or object that may be coerced to a factor </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_drop">drop</code></td>
<td>
<p> logical indicating if levels that do not occur should be dropped (if f is a factor) </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_prefix">prefix</code></td>
<td>
<p> a character prefix to be used for component names when
values of f are numeric </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_bytrap">bytrap</code></td>
<td>
<p>logical; if TRUE then each level of f identifies traps
to include </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_byoccasion">byoccasion</code></td>
<td>
<p>logical; if TRUE then each level of f identifies occasions
to include </p>
</td></tr>
<tr><td><code id="subset.capthist_+3A_...">...</code></td>
<td>
<p> other arguments passed to subset.capthist (split.capthist)
or to optional subset function (subset.capthist) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subscript vectors may be either logical- (length equal to the relevant
dimension of <code>x</code>), character- or integer-valued. Subsetting is
applied to attributes (e.g. <code>covariates</code>, <code>traps</code>) as
appropriate. The default action is to include all animals, occasions,
and detectors if the relevant argument is omitted.
</p>
<p>When <code>traps</code> is provided, detections at other detectors are set to
zero, as if the detector had not been used, and the corresponding rows
are removed from <code>traps</code>. If the detector type is &lsquo;proximity&rsquo; then
selecting traps also reduces the third dimension of the capthist array. 
</p>
<p><code>split</code> generates a list in which each component is a
<code>capthist</code> object. Each component corresponds to a level of
<code>f</code>. Multi-session capthists are accepted in <span class="pkg">secr</span> &gt;= 4.4.0; 
<code>f</code> should then be a list of factors with one component per session 
and the same levels in all.
</p>
<p>To combine (pool) occasions use <code><a href="#topic+reduce.capthist">reduce.capthist</a></code>. There is
no equivalent of <code>unlist</code> for lists of <code>capthist</code> objects.
</p>
<p>The effect of <code>droplowsignals = FALSE</code> is to retain below-threshold
measurements of signal strength on all channels (microphones) as long as
the signal is above <code>cutval</code> on at least one. In this case all
retained sounds are treated as detected on all microphones. This fails
when signals are already missing on some channels.
</p>
<p>Subsetting is awkward with multi-session input when the criterion is an
individual covariate. See the Examples for one way this can be tackled.
</p>


<h3>Value</h3>

<p><code>capthist</code> object with the requested subset of observations, or a
list of such objects (i.e., a multi-session <code>capthist</code> object).
List input results in list output, except when a single session is
selected.
</p>


<h3>Warning</h3>

<p><code>split.capthist</code> does not work for mark&ndash;resight data.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+capthist">capthist</a></code>, 
<code><a href="#topic+rbind.capthist">rbind.capthist</a></code>, 
<code><a href="#topic+reduce.capthist">reduce.capthist</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tempcapt &lt;- sim.capthist (make.grid(nx = 6, ny = 6), noccasions = 6)
summary(subset(tempcapt, occasions = c(1,3,5)))

## Consider `proximity' detections at a random subset of detectors
## This would not make sense for `multi' detectors, as the 
## excluded detectors influence detection probabilities in 
## sim.capthist.

tempcapt2 &lt;- sim.capthist (make.grid(nx = 6, ny = 6, 
    detector = "proximity"), noccasions = 6)
tempcapt3 &lt;- subset(tempcapt2, traps = sample(1:36, 18, 
    replace = FALSE))
summary(tempcapt3)
plot(tempcapt3)

tempcapt4 &lt;- split (tempcapt2, f = sample (c("A","B"), 
    nrow(tempcapt2), replace = TRUE))
summary(tempcapt4)

## Split out captures on alternate rows of a grid
tempcapt5 &lt;- split(captdata, f = rep(1:2, 50), bytrap = TRUE)
summary(tempcapt5)

## Divide one session into two by occasion
tempcapt6 &lt;- split(captdata, f = factor(c(1,1,2,2,2)), byoccasion = TRUE)
summary(tempcapt6)

## Applying a covariate criterion across all sessions of a
## multi-session capthist object e.g. selecting male ovenbirds from the
## 2005--2009 ovenCH dataset. We include a restriction on occasions
## to demonstrate the use of 'MoreArgs'. Note that mapply() creates a
## list, and the class of the output must be restored manually.

ovenCH.males &lt;- mapply(subset, ovenCH,
    subset = lapply(ovenCH, function(x) covariates(x)$Sex == "M"),
    MoreArgs = list(occasions = 1:5))
class(ovenCH.males) &lt;- class(ovenCH)
summary(ovenCH.males, terse = TRUE)

## A simpler approach using a function to define subset
subsetfn &lt;- function(x, sex) covariates(x)$Sex == sex
ovenCH.males &lt;- subset(ovenCH, subset = subsetfn, sex = "M")
summary(ovenCH.males, terse = TRUE)

</code></pre>

<hr>
<h2 id='subset.mask'> Subset, Split or Combine Mask Objects </h2><span id='topic+subset.mask'></span><span id='topic+split.mask'></span><span id='topic+rbind.mask'></span>

<h3>Description</h3>

<p>Retain selected rows of a <code>mask</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mask'
subset(x, subset, ...)

## S3 method for class 'mask'
split(x, f, drop = FALSE, clusters = NULL, ...)

## S3 method for class 'mask'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.mask_+3A_x">x</code></td>
<td>
 <p><code>mask</code> object </p>
</td></tr>
<tr><td><code id="subset.mask_+3A_subset">subset</code></td>
<td>
<p> numeric or logical vector to select rows of mask </p>
</td></tr>
<tr><td><code id="subset.mask_+3A_f">f</code></td>
<td>
<p> factor or object that may be coerced to a factor </p>
</td></tr>
<tr><td><code id="subset.mask_+3A_drop">drop</code></td>
<td>
<p> logical indicating if levels that do not occur should be dropped (if f is a factor) </p>
</td></tr>
<tr><td><code id="subset.mask_+3A_clusters">clusters</code></td>
<td>
<p>list of traps objects, each defining a cluster (alternative to f)</p>
</td></tr>
<tr><td><code id="subset.mask_+3A_...">...</code></td>
<td>
<p> two or more <code>mask</code> objects (rbind only) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subscripts in <code>subset</code> may be of type integer, character or
logical as described in <code><a href="base.html#topic+Extract">Extract</a></code>.
</p>
<p>The <code>split</code> method may use either a factor f with one value for each row or a list of clusters, each a traps object. The output mask corresponding to each cluster is the subset of the original mask points that lie within buffer of a trap within the cluster; buffer is computed as the maximum distance between a mask point in <code>x</code> and any detector in <code>clusters</code>. Sub-masks specified with <code>clusters</code> may overlap.
</p>
<p>Covariates are ignored by <code>rbind.mask</code>.
</p>


<h3>Value</h3>

<p>For <code>subset</code>, an object of class &lsquo;mask&rsquo; with only the requested
subset of rows and &lsquo;type&rsquo; attribute set to &lsquo;subset&rsquo;.
</p>
<p>For <code>split</code>, a list of mask objects.
</p>
<p>For <code>rbind</code>, an object of class &lsquo;mask&rsquo; with all unique rows from
the masks in ..., and &lsquo;type&rsquo; attribute set to &lsquo;rbind&rsquo;.
</p>


<h3>Warning</h3>

<p>The spacing attribute is carried over from the input (it is not updated
automatically). In the case of very sparse masks (i.e. those with
isolated points) this may lead to an unexpected value for this
attribute. (Automatic updating requires excessive computation time
and/or memory for very large masks).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mask">mask</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>tempmask &lt;- make.mask(make.grid())
OK &lt;- (tempmask$x + tempmask$y) &gt; 100
tempmask &lt;- subset(tempmask, subset = OK)
plot(tempmask)

</code></pre>

<hr>
<h2 id='subset.popn'> Subset popn Object </h2><span id='topic+subset.popn'></span>

<h3>Description</h3>

<p>Retain selected rows of a popn object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'popn'
subset(x, subset = NULL, sessions = NULL, poly = NULL,
    poly.habitat = TRUE, keep.poly = TRUE, renumber = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.popn_+3A_x">x</code></td>
<td>
 <p><code>popn</code> object </p>
</td></tr>
<tr><td><code id="subset.popn_+3A_subset">subset</code></td>
<td>
<p> vector to subscript the rows of <code>x</code> </p>
</td></tr>
<tr><td><code id="subset.popn_+3A_sessions">sessions</code></td>
<td>
<p> vector to subscript sessions if <code>x</code> is a multi-session
population </p>
</td></tr>
<tr><td><code id="subset.popn_+3A_poly">poly</code></td>
<td>
<p> bounding polygon (see Details)</p>
</td></tr>
<tr><td><code id="subset.popn_+3A_poly.habitat">poly.habitat</code></td>
<td>
<p> logical for whether poly represents habitat or
its inverse (non-habitat)</p>
</td></tr>
<tr><td><code id="subset.popn_+3A_keep.poly">keep.poly</code></td>
<td>
<p> logical; if TRUE any bounding polygon is saved as the
attribute &lsquo;polygon&rsquo; </p>
</td></tr>
<tr><td><code id="subset.popn_+3A_renumber">renumber</code></td>
<td>
<p> logical for whether to renumber rows in output </p>
</td></tr>
<tr><td><code id="subset.popn_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subscripts in <code>subset</code> may be of type integer, character or
logical as described in <code><a href="base.html#topic+Extract">Extract</a></code>. By default, all rows are
retained.
</p>
<p>In the case of a multi-session popn object (a list of populations),
<code>subset</code> may be a list with one component for the subscripts in
each new session.
</p>
<p>If <code>poly</code> is specified, points outside <code>poly</code> are
dropped. <code>poly</code> may be one of the types descrbed in 
<code><a href="#topic+boundarytoSF">boundarytoSF</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>popn</code> with only the requested subset of rows.
Subsetting is applied to the <code>covariates</code> attribute if this is
present. Attributes &lsquo;Ndist&rsquo; and &lsquo;model2D&rsquo; are set to NULL.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+popn">popn</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
temppop &lt;- sim.popn (D = 10, expand.grid(x = c(0,100), y =
    c(0,100)), buffer = 50)
## 50% binomial sample of simulated population
temppops &lt;- subset(temppop, runif(nrow(temppop)) &lt; 0.5)
plot(temppop)
plot(temppops, add = TRUE, pch = 16)

</code></pre>

<hr>
<h2 id='subset.traps'> Subset traps Object </h2><span id='topic+subset.traps'></span><span id='topic+split.traps'></span>

<h3>Description</h3>

<p>Retain selected rows of a traps object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traps'
subset(x, subset = NULL, occasions = NULL, ...)
## S3 method for class 'traps'
split(x, f, drop = FALSE, prefix = "S", byoccasion = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.traps_+3A_x">x</code></td>
<td>
 <p><code>traps</code> object </p>
</td></tr>
<tr><td><code id="subset.traps_+3A_subset">subset</code></td>
<td>
<p> vector to subscript the rows of <code>x</code> </p>
</td></tr>
<tr><td><code id="subset.traps_+3A_occasions">occasions</code></td>
<td>
<p> vector to subscript columns in <code>usage(x)</code></p>
</td></tr>
<tr><td><code id="subset.traps_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions or to optional subset function (subset.traps)  </p>
</td></tr>
<tr><td><code id="subset.traps_+3A_f">f</code></td>
<td>
<p> factor or object that may be coerced to a factor </p>
</td></tr>
<tr><td><code id="subset.traps_+3A_drop">drop</code></td>
<td>
<p> logical indicating if levels that do not occur should be dropped (if f is a factor) </p>
</td></tr>
<tr><td><code id="subset.traps_+3A_prefix">prefix</code></td>
<td>
<p> a character prefix to be used for component names when
values of f are numeric </p>
</td></tr>
<tr><td><code id="subset.traps_+3A_byoccasion">byoccasion</code></td>
<td>
<p>logical ; if TRUE then f is used to split occasions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subscripts in <code>subset</code> may be of type integer, character or
logical as described in <code><a href="base.html#topic+Extract">Extract</a></code>. By default, all rows are retained.
</p>
<p>In the case of &lsquo;polygon&rsquo; and &lsquo;transect&rsquo; detectors, subsetting is done at
the level of whole polygons or transects. <code>subset</code> should therefore
have the same length as <code>levels(polyID(x))</code> or
<code>levels(transectID(x))</code>.
</p>
<p><code>split</code> generates a list in which each component is a <code>traps</code>
object. Each component corresponds to a level of <code>f</code>.  The argument
<code>x</code> of <code>split</code> cannot be a list (i.e. <code>x</code> must be a
single-session traps object). 
</p>
<p>If the levels of <code>f</code> are numeric, from version 2.10.3 a leading zero is inserted in the names of the output list to maintain the sort order.
</p>


<h3>Value</h3>

<p>An object of class <code>traps</code> with only the requested subset of rows.
Subsetting is applied to <code>usage</code> and <code>covariates</code> attributes
if these are present.
</p>
<p>Splitting with <code>byoccasion = TRUE</code> produces a list of traps
objects, each with usage codes for a subset of occasions. Traps not used
on any occasion within a session are automatically dropped from that
session.
</p>


<h3>Warning</h3>

<p><code>split.traps</code> does not work for mark&ndash;resight data.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+traps">traps</a></code>, 
<code><a href="#topic+rbind.traps">rbind.traps</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## odd-numbered traps only, using modulo operator
temptrap &lt;- make.grid(nx = 7, ny = 7)
t2 &lt;- subset(temptrap, as.logical(1:nrow(temptrap) %% 2))
plot(t2)

## this works also for even number of rows, but must change 'outer' call
temptrap &lt;- make.grid(nx = 8, ny = 8)
t3 &lt;- subset(temptrap, !as.logical(outer(1:8,1:8,'+')%%2))
plot(t3)
</code></pre>

<hr>
<h2 id='suggest.buffer'>
Mask Buffer Width
</h2><span id='topic+suggest.buffer'></span><span id='topic+bias.D'></span>

<h3>Description</h3>

<p>Determines a suitable buffer width for an integration <a href="#topic+mask">mask</a>. The
&lsquo;buffer&rsquo; in question defines a concave polygon around a detector array
constructed using <code>make.mask</code> with <code>type = "trapbuffer"</code>.  The
method relies on an approximation to the bias of maximum likelihood
density estimates (M. Efford unpubl).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest.buffer(object, detectfn = NULL, detectpar = NULL, 
    noccasions = NULL, ignoreusage = FALSE, ncores = NULL, RBtarget = 0.001,
    interval = NULL, binomN = NULL, ...)

bias.D (buffer, traps, detectfn, detectpar, noccasions, binomN = NULL,
    control = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suggest.buffer_+3A_object">object</code></td>
<td>
<p> single-session &lsquo;secr&rsquo;, &lsquo;traps&rsquo; or &lsquo;capthist&rsquo; object </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_detectfn">detectfn</code></td>
<td>
<p> integer code or character string for shape of
detection function 0 = halfnormal etc. &ndash; see <a href="#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_detectpar">detectpar</code></td>
<td>
<p> list of values for named parameters of detection
function &ndash; see <a href="#topic+detectpar">detectpar</a> </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_noccasions">noccasions</code></td>
<td>
<p> number of sampling occasions</p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_ignoreusage">ignoreusage</code></td>
<td>
<p>logical for whether to discard usage information from
<code>traps(capthist)</code></p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_ncores">ncores</code></td>
<td>
<p> integer number of threads to use for parallel processing</p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_rbtarget">RBtarget</code></td>
<td>
<p> numeric target for relative bias of density estimate </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_interval">interval</code></td>
<td>
<p> a vector containing the end-points of the interval to
be searched </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_binomn">binomN</code></td>
<td>
<p> integer code for distribution of counts (see
<code><a href="#topic+secr.fit">secr.fit</a></code>) </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_...">...</code></td>
<td>
<p> other argument(s) passed to <code>bias.D</code> </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_buffer">buffer</code></td>
<td>
<p> vector of buffer widths </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_traps">traps</code></td>
<td>
<p> &lsquo;traps&rsquo; object </p>
</td></tr>
<tr><td><code id="suggest.buffer_+3A_control">control</code></td>
<td>
<p> list of mostly obscure numerical settings (see Details) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic input style of <code>suggest.buffer</code> uses a &lsquo;traps&rsquo; object and
a detection model specified by &lsquo;detectpar&rsquo;, &lsquo;detectfn&rsquo; and &lsquo;noccasions&rsquo;,
plus a target relative bias (RB). A numerical search is conducted for
the buffer width that is predicted to deliver the requested RB. If
<code>interval</code> is omitted it defaults to (1, 100S) where S is the
spatial scale of the detection function (usually
<code>detectpar$sigma</code>). An error is reported if the required buffer
width is not within <code>interval</code>. This often happens with
heavy-tailed detection functions (e.g., hazard-rate): choose another
function, a larger <code>RBtarget</code> or a wider <code>interval</code>.
</p>
<p>Setting <code>ncores = NULL</code> uses the existing value from the environment variable 
RCPP_PARALLEL_NUM_THREADS (see <code><a href="#topic+setNumThreads">setNumThreads</a></code>).
</p>
<p>Convenient alternative input styles are &ndash;
</p>

<ul>
<li> <p><code>secr</code> object containing a fitted model. Values of &lsquo;traps&rsquo;,
&lsquo;detectpar&rsquo;, &lsquo;detectfn&rsquo; and &lsquo;noccasions&rsquo; are extracted from
<code>object</code> and any values supplied for these arguments are ignored.
</p>
</li>
<li> <p><code>capthist</code> object containing raw data. If <code>detectpar</code> is
not supplied then <code><a href="#topic+autoini">autoini</a></code> is used to get &lsquo;quick and dirty&rsquo;
values of <code>g0</code> and <code>sigma</code> for a halfnormal detection
function. <code>noccasions</code> is ignored. <code>autoini</code> tends to
underestimate <code>sigma</code>, and the resulting buffer also tends to be
too small.
</p>
</li></ul>

<p><code>bias.D</code> is called internally by <code>suggest.buffer</code>.
</p>


<h3>Value</h3>

<p><code>suggest.buffer</code> returns a scalar value for the suggested buffer
width in metres, or a vector of such values in the case of a
multi-session <code>object</code>.
</p>
<p><code>bias.D</code> returns a dataframe with columns <code>buffer</code> and <code>RB.D</code>
(approximate bias of density estimate using finite buffer width,
relative to estimate with infinite buffer).
</p>


<h3>Note</h3>

<p>The algorithm in <code>bias.D</code> uses one-dimensional numerical
integration of a polar approximation to site-specific detection
probability. This uses a further 3-part linear approximation for the
length of contours of distance-to-nearest-detector (<code class="reqn">r</code>) as a
function of <code class="reqn">r</code>.
</p>
<p>The approximation seems to work well for a compact detector array, but
it should not be taken as an estimate of the bias for any other purpose:
do <em>not</em> report <code>RB.D</code> as &quot;the relative bias of the density
estimate&quot;. <code>RB.D</code> addresses only the effect of using a finite
buffer. The effect of buffer width on final estimates should be checked
with <code><a href="#topic+mask.check">mask.check</a></code>.
</p>
<p>The default buffer type in <code>make.mask</code>, and hence in
<code>secr.fit</code>, is &lsquo;traprect&rsquo;, not &lsquo;trapbuffer&rsquo;, but a buffer width
that is adequate for &lsquo;trapbuffer&rsquo; is always adequate for &lsquo;traprect&rsquo;.
</p>
<p><code>control</code> contains various settings of little interest to the
user.
</p>
<p>The potential components of <code>control</code> are &ndash;
</p>

<dl>
<dt><code>method = 1 </code></dt><dd><p> code for method of modelling <em>p.(X)</em> as a
function of buffer (<em>q(r)</em>)</p>
</dd>
<dt><code>bfactor = 20 </code></dt><dd> <p><em>q(r)</em> vs <em>p.(X)</em> calibration
mask buffer width in multiples of trap spacing </p>
</dd>
<dt><code>masksample = 1000 </code></dt><dd><p> maximum number of points sampled from
calibration mask </p>
</dd>
<dt><code>spline.df = 10 </code></dt><dd><p> effective degrees of freedom for
<code>smooth.spline</code> </p>
</dd>
<dt><code>ncores = NULL</code></dt><dd><p> integer number of cores</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+make.mask">make.mask</a></code>, <code><a href="#topic+mask.check">mask.check</a></code>, <code><a href="#topic+esa.plot">esa.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

temptraps &lt;- make.grid()
detpar &lt;-  list(g0 = 0.2, sigma = 25)
suggest.buffer(temptraps, "halfnormal", detpar, 5)

suggest.buffer(secrdemo.0)

suggest.buffer(ovenCH[[1]])

RB &lt;- bias.D(50:150, temptraps, "halfnormal", detpar, 5)
plot(RB)

detpar &lt;-  list(g0 = 0.2, sigma = 25, z=5)
RB &lt;- bias.D(50:150, temptraps, "hazard rate", detpar, 5)
lines(RB)

## compare to esa plot
esa.plot (temptraps, max.buffer = 150, spacing = 4, detectfn = 0,
  detectpar = detpar, noccasions = 5, type = "density")

## compare detection histories and fitted model as input
suggest.buffer(captdata)
suggest.buffer(secrdemo.0)


## End(Not run)

</code></pre>

<hr>
<h2 id='summary.capthist'> Summarise Detections </h2><span id='topic+summary.capthist'></span><span id='topic+print.summary.capthist'></span><span id='topic+counts'></span>

<h3>Description</h3>

<p>Concise description of <code>capthist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'capthist'
summary(object, terse = FALSE, moves = FALSE, tpa = FALSE, ...)

## S3 method for class 'summary.capthist'
print(x, ...)

counts(CHlist, counts = "M(t+1)")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.capthist_+3A_object">object</code></td>
<td>
 <p><code><a href="#topic+capthist">capthist</a></code> object </p>
</td></tr>
<tr><td><code id="summary.capthist_+3A_terse">terse</code></td>
<td>
<p> logical; if TRUE return only summary counts </p>
</td></tr>
<tr><td><code id="summary.capthist_+3A_moves">moves</code></td>
<td>
<p> logical; if TRUE then summary includes detected movements </p>
</td></tr>
<tr><td><code id="summary.capthist_+3A_tpa">tpa</code></td>
<td>
<p> logical; if TRUE then summary includes number of detectors per animal</p>
</td></tr>
<tr><td><code id="summary.capthist_+3A_x">x</code></td>
<td>
 <p><code>summary.capthist</code> object </p>
</td></tr>
<tr><td><code id="summary.capthist_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions </p>
</td></tr>
<tr><td><code id="summary.capthist_+3A_chlist">CHlist</code></td>
<td>
<p> capthist object, especially a multi-session object </p>
</td></tr>
<tr><td><code id="summary.capthist_+3A_counts">counts</code></td>
<td>
<p> character vector of count names </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These counts are reported by <code>summary.capthist</code>  
</p>

<table>
<tr>
 <td style="text-align: left;">
  n </td><td style="text-align: left;"> number of individuals detected on each occasion </td>
</tr>
<tr>
 <td style="text-align: left;">
  u </td><td style="text-align: left;"> number of individuals detected for the first time on each occasion </td>
</tr>
<tr>
 <td style="text-align: left;">
  f </td><td style="text-align: left;"> number of individuals detected exactly f times </td>
</tr>
<tr>
 <td style="text-align: left;">
  M(t+1) </td><td style="text-align: left;"> cumulative number of individuals detected </td>
</tr>
<tr>
 <td style="text-align: left;">
  losses </td><td style="text-align: left;"> number of individuals reported as not released on each occasion </td>
</tr>
<tr>
 <td style="text-align: left;">
  detections </td><td style="text-align: left;"> number of detections, including within-occasion `recaptures' </td>
</tr>
<tr>
 <td style="text-align: left;">
  traps visited </td><td style="text-align: left;"> number of detectors at which at least one detection was recorded </td>
</tr>
<tr>
 <td style="text-align: left;">
  traps set </td><td style="text-align: left;"> number of detectors, excluding any `not set' in <code>usage</code> attribute of <code>traps</code> attribute </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The last two rows are dropped if the data are nonspatial (object has no traps attribute).
</p>
<p>Movements are as reported by <code><a href="#topic+moves">moves</a></code>. When <code>terse = TRUE</code> the number of non-zero moves is reported. The temporal sequence of detections at &lsquo;proximity&rsquo; and &lsquo;count&rsquo; detectors is not recorded in the capthist object, so the movement statistics are not to be taken too seriously. The problem is minimised when detections are sparse (seldom more than one per animal per occasion), and does not occur with 'single' or 'multi' detectors.
</p>
<p>The &lsquo;tpa&rsquo; option provides the frequency distribution of detectors per animal. When <code>terse = TRUE</code> the number of animals at &gt;= 2 detectors is reported ('Animal2').
</p>
<p><code>counts</code> may be used to return the specified counts in a compact 
session x occasion table. If more than one count is named then a list is returned
with one component for each type of count.
</p>


<h3>Value</h3>

<p>From <code>summary.capthist</code>, an object of class
<code>summary.capthist</code>, a list with at least these components
</p>
<table>
<tr><td><code>detector</code></td>
<td>
<p><code><a href="#topic+detector">detector</a></code> type (&quot;single&quot;, &quot;multi&quot;, &quot;proximity&quot; etc.)</p>
</td></tr>
<tr><td><code>ndetector</code></td>
<td>
<p>number of detectors </p>
</td></tr>
<tr><td><code>xrange</code></td>
<td>
<p>range of x coordinates of detectors </p>
</td></tr>
<tr><td><code>yrange</code></td>
<td>
<p>range of y coordinates of detectors </p>
</td></tr>
<tr><td><code>spacing</code></td>
<td>
<p>mean distance from each trap to nearest other trap </p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>matrix of summary counts (rows) by occasion (columns).  See Details.</p>
</td></tr>
<tr><td><code>dbar</code></td>
<td>
<p>mean recapture distance </p>
</td></tr>
<tr><td><code>RPSV</code></td>
<td>
<p>root pooled spatial variance </p>
</td></tr>
</table>
<p>or, when <code>terse = TRUE</code>, a vector (single session) or dataframe (multiple sessions) of counts (Occasions, Detections, Animals, Detectors, and optionally Moves and Animals2).
</p>
<p>A summary of individual covariates is provided if these are present (from <span class="pkg">secr</span> 4.0.1).
</p>
<p>A summary of interference/non-target captures is provided if there is a <a href="#topic+nontarget">nontarget</a> attribute (from <span class="pkg">secr</span> 4.5.5).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dbar">dbar</a></code>, <code><a href="#topic+RPSV">RPSV</a></code>, <code><a href="#topic+capthist">capthist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>temptrap &lt;- make.grid(nx = 5, ny = 3)
summary(sim.capthist(temptrap))
summary(sim.capthist(temptrap))$counts["n",]
summary(captdata, moves = TRUE)
</code></pre>

<hr>
<h2 id='summary.mask'> Summarise Habitat Mask </h2><span id='topic+summary.mask'></span><span id='topic+print.summary.mask'></span>

<h3>Description</h3>

<p>Concise summary of a <code>mask</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mask'
summary(object, ...)
## S3 method for class 'summary.mask'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mask_+3A_object">object</code></td>
<td>
 <p><code>mask</code> object </p>
</td></tr>
<tr><td><code id="summary.mask_+3A_x">x</code></td>
<td>
 <p><code>summary.mask</code> object </p>
</td></tr>
<tr><td><code id="summary.mask_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bounding box is the smallest rectangular area with edges parallel to the x- and y-axes that contains all points and their associated grid cells. A print method is provided for objects of class <code>summary.mask</code>.
</p>


<h3>Value</h3>

<p>Object of class &lsquo;summary.mask&rsquo;, a list with components
</p>
<table>
<tr><td><code>detector</code></td>
<td>
<p>character string for detector type (&quot;single&quot;,&quot;multi&quot;,&quot;proximity&quot;)</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>mask type (&quot;traprect&quot;, &quot;trapbuffer&quot;, &quot;pdot&quot;, &quot;polygon&quot;, &quot;user&quot;, &quot;subset&quot;)</p>
</td></tr>
<tr><td><code>nmaskpoints</code></td>
<td>
<p>number of points in mask</p>
</td></tr>
<tr><td><code>xrange</code></td>
<td>
<p>range of x coordinates</p>
</td></tr>
<tr><td><code>yrange</code></td>
<td>
<p>range of y coordinates</p>
</td></tr>
<tr><td><code>meanSD</code></td>
<td>
<p>dataframe with mean and SD of x, y, and each covariate </p>
</td></tr>
<tr><td><code>spacing</code></td>
<td>
<p>nominal spacing of points</p>
</td></tr>
<tr><td><code>cellarea</code></td>
<td>
<p>area (ha) of grid cell associated with each point</p>
</td></tr>
<tr><td><code>bounding box</code></td>
<td>
<p>dataframe with x-y coordinates for vertices of bounding box</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>summary of each covariate</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+mask">mask</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>tempmask &lt;- make.mask(make.grid())
## left to right gradient
covariates (tempmask) &lt;- data.frame(x = tempmask$x)
summary(tempmask)
</code></pre>

<hr>
<h2 id='summary.popn'> Summarise Simulated Population </h2><span id='topic+summary.popn'></span><span id='topic+print.summary.popn'></span>

<h3>Description</h3>

<p>Concise summary of a <code>popn</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'popn'
summary(object, collapse = FALSE, ...)
## S3 method for class 'summary.popn'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.popn_+3A_object">object</code></td>
<td>
 <p><code>popn</code> object </p>
</td></tr>
<tr><td><code id="summary.popn_+3A_collapse">collapse</code></td>
<td>
<p>logical; if TRUE multi-session popn objects are treated as a single open population</p>
</td></tr>
<tr><td><code id="summary.popn_+3A_x">x</code></td>
<td>
 <p><code>summary.popn</code> object </p>
</td></tr>
<tr><td><code id="summary.popn_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default each component of a multisession object is summarised separately. If <code>collapse = TRUE</code> then turnover and movements are collated across sessions, matching individuals by rownames.
</p>


<h3>Value</h3>

<p>For <code>summary.popn</code>, an object of class &lsquo;summary.popn&rsquo; with various components. For a multisession object and collapse = TRUE the descriptors include the numbers of new individuals (recruits) and lost individuals (deaths), and matrices showing the status of each animal in each session (&lsquo;status&rsquo; codes 0 not recruited yet; 1 alive; -1 dead) and movement from previous session if alive then (&lsquo;movements&rsquo;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.popn">sim.popn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

grid &lt;- make.grid(8,8)
turnover &lt;- list(phi = 0.8, lambda = 1)
pop &lt;- sim.popn(Nbuffer = 200, core = grid, buffer = 200, Ndist = 'fixed', 
    nsessions = 5, details = turnover)
summary(pop, collapse = TRUE)

</code></pre>

<hr>
<h2 id='summary.traps'> Summarise Detector Array </h2><span id='topic+summary.traps'></span><span id='topic+print.summary.traps'></span>

<h3>Description</h3>

<p>Concise description of <code>traps</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traps'
summary(object, getspacing = TRUE, covariates = FALSE, ...)
## S3 method for class 'summary.traps'
print(x, terse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.traps_+3A_object">object</code></td>
<td>
    <p><code><a href="#topic+traps">traps</a></code> object </p>
</td></tr>
<tr><td><code id="summary.traps_+3A_getspacing">getspacing</code></td>
<td>
<p> logical to calculate spacing of detectors from scratch </p>
</td></tr>
<tr><td><code id="summary.traps_+3A_covariates">covariates</code></td>
<td>
<p> logical; if true each covariate is summarised</p>
</td></tr>
<tr><td><code id="summary.traps_+3A_x">x</code></td>
<td>
 <p><code>summary.traps</code> object </p>
</td></tr>
<tr><td><code id="summary.traps_+3A_terse">terse</code></td>
<td>
<p> if TRUE suppress printing of usage and covariate summary </p>
</td></tr>
<tr><td><code id="summary.traps_+3A_...">...</code></td>
<td>
<p> arguments passed to other functions </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>object</code> includes both categorical (factor) covariates and
<code>usage</code>, usage is tabulated for each level of the covariates. 
</p>
<p>Computation of <code>spacing</code> (mean distance to nearest trap) is slow
and may hit a memory limit when there are many traps. In this case, turn
off the computation with <code>getspacing</code> = FALSE. 
</p>


<h3>Value</h3>

<p>An object of class <code>summary.traps</code>, a list with elements
</p>
<table>
<tr><td><code>detector</code></td>
<td>
<p><code><a href="#topic+detector">detector</a></code> type (&quot;single&quot;, &quot;multi&quot;, &quot;proximity&quot; etc.)</p>
</td></tr>
<tr><td><code>ndetector</code></td>
<td>
<p>number of detectors</p>
</td></tr>
<tr><td><code>xrange</code></td>
<td>
<p>range of x coordinates </p>
</td></tr>
<tr><td><code>yrange</code></td>
<td>
<p>range of y coordinates </p>
</td></tr>
<tr><td><code>spacing</code></td>
<td>
<p>mean distance from each trap to nearest other trap </p>
</td></tr>
<tr><td><code>usage</code></td>
<td>
<p>table of usage by occasion</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>summary of covariates</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+traps">traps</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>demo.traps &lt;- make.grid()
summary(demo.traps)   ## uses print method for summary.traps object
</code></pre>

<hr>
<h2 id='timevaryingcov'> Time-varying Covariates </h2><span id='topic+timevaryingcov'></span><span id='topic+timevaryingcov+3C-'></span>

<h3>Description</h3>

<p>Extract or replace time varying covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timevaryingcov(object, ...)
timevaryingcov(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timevaryingcov_+3A_object">object</code></td>
<td>
<p> an object of class <code>traps</code> or <code>capthist</code></p>
</td></tr>
<tr><td><code id="timevaryingcov_+3A_value">value</code></td>
<td>
<p> a list of named vectors </p>
</td></tr>
<tr><td><code id="timevaryingcov_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The timevaryingcov attribute is a list of one or more named vectors. 
Each vector identifies a subset of columns of covariates(object), one for each occasion. If character values are used they should correspond to covariate names.
</p>
<p>In <span class="pkg">secr</span> models, time-varying covariates are restricted to traps objects.  
Time-varying (session-specific) individual covariates may be used in <span class="pkg">openCR</span>. 
The following remarks apply to time-varying traps covariates.
</p>
<p>The name of the vector may be used in a model formula; when the model
is fitted, the value of the trap covariate on a particular occasion is
retrieved from the column indexed by the vector.
</p>
<p>For replacement, if <code>object</code> already has a <code><a href="#topic+usage">usage</a></code>
attribute, the length of each vector in <code>value</code> must match exactly
the number of columns in <code>usage(object)</code>.
</p>
<p>When converting a multi-session capthist object into a robust-design &ldquo;single-session&rdquo; object with function <code>join</code> the argument &lsquo;timevaryingcov&rsquo; is used to collate 
covariate values across sessions in a form suitable for inclusion in 
<span class="pkg">openCR</span> models (see <code><a href="#topic+join">join</a></code>).
</p>


<h3>Value</h3>

<p><code>timevaryingcov(object)</code> returns the timevaryingcov attribute of
<code>object</code> (may be NULL).
</p>


<h3>Note</h3>

<p>It is usually better to model varying effort directly, via the <a href="#topic+usage">usage</a>
attribute (see <a href="https://www.otago.ac.nz/density/pdfs/secr-varyingeffort.pdf">secr-varyingeffort.pdf</a>).
</p>
<p>Models for data from detectors of type &lsquo;multi&rsquo;, &lsquo;polygonX&rsquo; or &lsquo;transectX&rsquo; take much
longer to fit when detector covariates of any sort are used.
</p>
<p>Time-varying covariates are not available with the (default) 'fastproximity' option.
</p>
<p>See <a href="https://www.otago.ac.nz/density/pdfs/secr-varyingeffort.pdf">secr-varyingeffort.pdf</a> for input of detector covariates from a file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+join">join</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make a trapping grid with simple covariates
temptrap &lt;- make.grid(nx = 6, ny = 8, detector = "multi") 
covariates (temptrap) &lt;- data.frame(matrix(
    c(rep(1,48*3),rep(2,48*2)), ncol = 5))
head(covariates (temptrap))

# identify columns 1-5 as daily covariates
timevaryingcov(temptrap) &lt;- list(blockt = 1:5)
timevaryingcov(temptrap)

## Not run: 

# default density = 5/ha, noccasions = 5
CH &lt;- sim.capthist(temptrap, detectpar = list(g0 = c(0.15, 0.15,
    0.15, 0.3, 0.3), sigma = 25))

fit.1 &lt;- secr.fit(CH, trace = FALSE) 
fit.tvc2 &lt;- secr.fit(CH, model = g0 ~ blockt, trace = FALSE) 

# because variation aligns with occasions, we get the same with:
fit.t2 &lt;- secr.fit(CH, model = g0 ~ tcov, timecov = c(1,1,1,2,2),
    trace = FALSE) 

predict(fit.t2, newdata = data.frame(tcov = 1:2))
predict(fit.tvc2, newdata = data.frame(blockt = 1:2))

# now model some more messy variation
covariates (traps(CH))[1:10,] &lt;- 3
fit.tvc3 &lt;- secr.fit(CH, model = g0 ~ blockt, trace = FALSE) 

AIC(fit.tvc2, fit.t2, fit.tvc3)
# fit.tvc3 is the 'wrong' model


## End(Not run)

</code></pre>

<hr>
<h2 id='transformations'> Transform Point Array </h2><span id='topic+transformations'></span><span id='topic+flip'></span><span id='topic+flip.traps'></span><span id='topic+flip.popn'></span><span id='topic+rotate'></span><span id='topic+rotate.traps'></span><span id='topic+rotate.popn'></span><span id='topic+shift'></span><span id='topic+shift.traps'></span><span id='topic+shift.popn'></span><span id='topic+shift.mask'></span>

<h3>Description</h3>

<p>Flip (reflect), rotate or slide (translate) an array of points. Methods
are provided for &lsquo;traps&rsquo; objects that ensure other attributes are
retained. The methods may be used with <code><a href="#topic+rbind.traps">rbind.traps</a></code> to
create complex geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
flip (object, lr = FALSE, tb = FALSE, ...)
rotate (object, degrees, centrexy = NULL, ...)
shift (object, shiftxy, ...)

## S3 method for class 'traps'
 flip(object, lr = FALSE, tb = FALSE, ...)
## S3 method for class 'traps'
rotate(object, degrees, centrexy = NULL, ...)
## S3 method for class 'traps'
shift(object, shiftxy, ...)

## S3 method for class 'popn'
 flip(object, lr = FALSE, tb = FALSE, ...)
## S3 method for class 'popn'
rotate(object, degrees, centrexy = NULL, ...)
## S3 method for class 'popn'
shift(object, shiftxy, ...)

## S3 method for class 'mask'
shift(object, shiftxy, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformations_+3A_object">object</code></td>
<td>
<p> a 2-column matrix or object that can be coerced to a
matrix </p>
</td></tr>
<tr><td><code id="transformations_+3A_lr">lr</code></td>
<td>
<p> either logical for whether array should be flipped
left-right, or numeric value for x-coordinate of axis about which it
should be flipped left-right </p>
</td></tr>
<tr><td><code id="transformations_+3A_tb">tb</code></td>
<td>
<p> either logical for whether array should be flipped
top-bottom, or numeric value for y-coordinate of axis about which it
should be flipped top-bottom </p>
</td></tr>
<tr><td><code id="transformations_+3A_degrees">degrees</code></td>
<td>
<p> clockwise angle of rotation in degrees </p>
</td></tr>
<tr><td><code id="transformations_+3A_centrexy">centrexy</code></td>
<td>
<p> vector with xy coordinates of rotation centre </p>
</td></tr>
<tr><td><code id="transformations_+3A_shiftxy">shiftxy</code></td>
<td>
<p> vector of x and y displacements </p>
</td></tr>
<tr><td><code id="transformations_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flip</code> reflects points about a vertical or horizontal axis. Logical
values for <code>lr</code> or <code>tb</code> indicate that points should be flipped
about the mean on the relevant axis. Numeric values indicate the
particular axis value(s) about which points should be flipped.  The
default arguments result in no change.
</p>
<p><code>shift</code> shifts the location of each point by the desired amount
on each axis.
</p>
<p><code>rotate</code> rotates the array about a designated point. If
<code>centrexy</code> is NULL then rotation is about (0,0)
(<code>rotate.default</code>), the array centre (<code>rotate.traps</code>), or the
centre of the bounding box (<code>rotate.popn</code>).
</p>


<h3>Value</h3>

<p>A matrix or object of class &lsquo;traps&rsquo; or &lsquo;popn&rsquo; with the coordinates of each point
transformed as requested.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+traps">traps</a></code>, <code><a href="#topic+popn">popn</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp &lt;- matrix(runif (20) * 2 - 1, nc = 2)

## flip
temp2 &lt;- flip(temp, lr = 1)
plot(temp, xlim=c(-1.5,4), ylim = c(-1.5,1.5), pch = 16)
points (temp2, pch = 1)
arrows (temp[,1], temp[,2], temp2[,1], temp2[,2], length = 0.1)
abline(v = 1, lty = 2)

## rotate
temp2 &lt;- rotate(temp, 25)
plot(temp, xlim=c(-1.5,1.5), ylim = c(-1.5,1.5), pch = 16)
points (0,0, pch=2)
points (temp2, pch = 1)
arrows (temp[,1], temp[,2], temp2[,1], temp2[,2], length = 0.1)	

## shiftxy
temp2 &lt;- shift(temp, c(0.1, 0.1))
plot(temp, xlim=c(-1.5,1.5), ylim = c(-1.5,1.5), pch = 16)
points (0,0, pch=2)
points (temp2, pch = 1)
arrows (temp[,1], temp[,2], temp2[,1], temp2[,2], length = 0.1)	

## flip.traps
par(mfrow = c(1,2), xpd = TRUE)
traps1 &lt;- make.grid(nx = 8, ny = 6, ID = "numxb")
traps2 &lt;- flip (traps1, lr = TRUE)
plot(traps1, border = 5, label = TRUE, offset = 7, gridl = FALSE)
plot(traps2, border = 5, label = TRUE, offset = 7, gridl = FALSE)
par(mfrow = c(1,1), xpd = FALSE)

## rotate.traps
hollow1 &lt;- make.grid(nx = 8, ny = 8, hollow = TRUE)
nested &lt;- rbind (hollow1, rotate(hollow1, 45, c(70, 70)))
plot(nested, gridlines = FALSE)

## shift.traps
hollow1 &lt;- make.grid(nx = 8, ny = 8, hollow = TRUE)
hollow2 &lt;- shift(make.grid(nx = 6, ny = 6, hollow = TRUE), c(20, 20))
nested &lt;- rbind (hollow1, hollow2)
plot(nested, gridlines = FALSE, label = TRUE)

</code></pre>

<hr>
<h2 id='trap.builder'>
Complex Detector Layouts
</h2><span id='topic+trap.builder'></span><span id='topic+mash'></span><span id='topic+cluster.counts'></span><span id='topic+cluster.centres'></span>

<h3>Description</h3>

<p>Construct detector layouts comprising small arrays (clusters) replicated
across space, possibly at a probability sample of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
trap.builder (n = 10, cluster, region = NULL, frame = NULL, 
    method = c("SRS", "GRTS", "all", "rank"), 
    edgemethod = c("clip", "allowoverlap", "allinside", "anyinside", "centreinside"), 
    samplefactor = 2, ranks = NULL, rotation = NULL, detector,
    exclude = NULL, exclmethod = c("clip", "alloutside", "anyoutside", "centreoutside"), 
    plt = FALSE, add = FALSE, ...)

mash (object, origin = c(0,0), clustergroup = NULL, ...)

cluster.counts (object)

cluster.centres (object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trap.builder_+3A_n">n</code></td>
<td>
<p> integer number of clusters (ignored if method = &quot;all&quot;) </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_cluster">cluster</code></td>
<td>
<p> traps object </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_region">region</code></td>
<td>
<p> bounding polygon(s)</p>
</td></tr>
<tr><td><code id="trap.builder_+3A_frame">frame</code></td>
<td>
<p> data frame of points used as a finite sampling frame </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_method">method</code></td>
<td>
<p> character string (see Details) </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_edgemethod">edgemethod</code></td>
<td>
<p>character string (see Details) </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_samplefactor">samplefactor</code></td>
<td>
<p> oversampling to allow for rejection of edge clusters
(multiple of n) </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_ranks">ranks</code></td>
<td>
<p> vector of relative importance (see Details)</p>
</td></tr>
<tr><td><code id="trap.builder_+3A_rotation">rotation</code></td>
<td>
<p> angular rotation of each cluster about centre (degrees) </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_detector">detector</code></td>
<td>
<p> character detector type (see <code><a href="#topic+detector">detector</a></code>)</p>
</td></tr>
<tr><td><code id="trap.builder_+3A_exclude">exclude</code></td>
<td>
<p> polygon(s) from which detectors are to be excluded</p>
</td></tr>
<tr><td><code id="trap.builder_+3A_exclmethod">exclmethod</code></td>
<td>
<p>character string (see Details)</p>
</td></tr>
<tr><td><code id="trap.builder_+3A_plt">plt</code></td>
<td>
<p> logical: should array be plotted? </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_add">add</code></td>
<td>
<p> logical: add to existing plot </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_object">object</code></td>
<td>
<p> single-session multi-cluster capthist object, or traps
object for <code>cluster.centres</code> </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_origin">origin</code></td>
<td>
<p> new coordinate origin for detector array </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_clustergroup">clustergroup</code></td>
<td>
<p> list of vectors subscripting the clusters to be
mashed </p>
</td></tr>
<tr><td><code id="trap.builder_+3A_...">...</code></td>
<td>
<p>other arguments passed by trap.builder to spsurvey::grts (e.g., mindis) 
and by mash to make.capthist (e.g., sortrows)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The detector array in <code>cluster</code> is replicated <code>n</code>
times and translated to centres sampled from the area sampling frame
in <code>region</code> or the finite sampling frame in <code>frame</code>. Each
cluster may be rotated about its centre either by a fixed number of
degrees (<code>rotation</code> positive), or by a random angle (<code>rotation</code>
negative).
</p>
<p>If the <code>cluster</code> argument is not provided then single detectors of
the given type are placed according to the design.
</p>
<p>The sampling frame is finite (the points in <code>frame</code>) whenever
<code>frame</code> is not NULL. If <code>region</code> and <code>frame</code> are both
specified, sampling uses the finite frame but sites may be clipped
using the polygon.
</p>
<p><code>region</code> and <code>exclude</code> may be a two-column matrix or
dataframe of x-y coordinates for the boundary, or one of the other polygon 
sources listed in <code><a href="#topic+boundarytoSF">boundarytoSF</a></code> (these allow multiple polygons). 
</p>
<p><code>method</code> may be &quot;SRS&quot;, &quot;GRTS&quot;, &quot;all&quot; or &quot;rank&quot;. &quot;SRS&quot; takes a simple
random sample (without replacement in the case of a finite sampling
frame). &quot;GRTS&quot; takes a spatially representative sample using the
&lsquo;generalized random tessellation stratified&rsquo; (GRTS) method of Stevens
and Olsen (2004). &quot;all&quot; replicates <code>cluster</code> across all points in
the finite sampling frame. &quot;rank&quot; selects <code>n</code> sites from
<code>frame</code> on the basis of their ranking on the vector &lsquo;ranks&rsquo;,
which should have length equal to the number of rows in
<code>frame</code>; ties are resolved by drawing a site at random.
</p>
<p>Options for <code>edgemethod</code> are &ndash;
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>edgemethod</code> </td><td style="text-align: left;"> Description</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"clip"</code> </td><td style="text-align: left;"> reject any individual detectors outside <code>region</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"allowoverlap"</code> </td><td style="text-align: left;"> no action </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"allinside"</code> </td><td style="text-align: left;"> reject whole cluster if any component is outside <code>region</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"anyinside"</code> </td><td style="text-align: left;"> reject whole cluster if no component is inside <code>region</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"centreinside"</code> </td><td style="text-align: left;"> reject whole cluster if centre outside <code>region</code>, and clip to <code>region</code>
  </td>
</tr>

</table>

<p>Similarly, <code>exclmethod</code> may be &quot;clip&quot; (reject individual detectors), 
&quot;alloutside&quot; (reject whole cluster if any component is outside <code>exclude</code>) etc. 
Sufficient additional samples (<code>(samplefactor--1) * n</code>) must be drawn to 
allow for replacement of any rejected clusters; otherwise, an error is reported 
(&lsquo;not enough clusters within polygon&rsquo;).
</p>
<p>GRTS samples require function <code>grts</code> in version &gt;= 5.3.0 of package <span class="pkg">spsurvey</span> 
(Dumelle et al. 2022). More sophisticated stratified designs may be specified by using <code>grts</code>
directly.
</p>
<p><code>mash</code> collapses a multi-cluster capthist object as if all
detections were made on a single cluster. The new detector coordinates
in the &lsquo;traps&rsquo; attribute are for a single cluster with (min(x),
min(y)) given by <code>origin</code>. <code>clustergroup</code> optionally selects
one or more groups of clusters to mash; if <code>length(clustergroup)
  &gt; 1</code> then a multisession capthist object will be generated, one
&lsquo;session&rsquo; per clustergroup. By default, all clusters are mashed.
</p>
<p><code>mash</code> discards detector-level covariates and occasion-specific
&lsquo;usage&rsquo;, with a warning.
</p>
<p><code>cluster.counts</code> returns the number of <em>distinct</em>
individuals detected per cluster in a single-session multi-cluster
capthist object.
</p>
<p><code>cluster.centres</code> returns the centroid of the detector locations in each cluster. When clusters have been truncated these differ from the attribute <code>centres</code> set by <code><a href="#topic+make.systematic">make.systematic</a></code>.
</p>


<h3>Value</h3>

<p><code>trap.builder</code> produces an object of class &lsquo;traps&rsquo;.
</p>
<p><code>plt = TRUE</code> causes a plot to be displayed, including the polygon
or finite sampling frame as appropriate.
</p>
<p><code>mash</code> produces a capthist object with the same number of rows as
the input but different detector numbering and &lsquo;traps&rsquo;. An attribute
&lsquo;n.mash&rsquo; is a vector of the numbers recorded at each cluster; its
length is the number of clusters. An attribute &lsquo;centres&rsquo; is a
dataframe containing the x-y coordinates of the cluster centres. The
<code>predict</code> method for secr objects and the function <code>derived</code>
both recognise and adjust for mashing.
</p>
<p><code>cluster.counts</code> returns a vector with the number of individuals
detected at each cluster.
</p>
<p><code>cluster.centres</code> returns a dataframe of x- and y-coordinates.
</p>


<h3>Note</h3>

<p>The function <code><a href="#topic+make.systematic">make.systematic</a></code> should be used to generate
systematic random layouts. It calls <code>trap.builder</code>.
</p>
<p>The sequence number of the cluster to which each detector belongs, and
its within-cluster sequence number, may be retrieved with the
functions <code><a href="#topic+clusterID">clusterID</a></code> and <code><a href="#topic+clustertrap">clustertrap</a></code>.
</p>


<h3>References</h3>

<p>Dumelle, M., Kincaid, T. M., Olsen, A. R., and Weber, M. H. (2021). 
spsurvey: Spatial Sampling Design and Analysis. R package version 5.2.0.
</p>
<p>Stevens, D. L., Jr., and Olsen, A. R. (2004) Spatially-balanced
sampling of natural resources. <em>Journal of the American
Statistical Association</em> <b>99</b>, 262&ndash;278.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.grid">make.grid</a></code>, <code><a href="#topic+traps">traps</a></code>,
<code><a href="#topic+make.systematic">make.systematic</a></code>,
<code><a href="#topic+clusterID">clusterID</a></code>,
<code><a href="#topic+clustertrap">clustertrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## solitary detectors placed randomly within a rectangle
tempgrid &lt;- trap.builder (n = 10, method = "SRS",
    region = cbind(x = c(0,1000,1000,0),
    y = c(0,0,1000,1000)), plt = TRUE)

## one detector in each 100-m grid cell -
## a form of stratified simple random sample
origins &lt;- expand.grid(x = seq(0, 900, 100),
    y = seq(0, 1100, 100))
XY &lt;- origins + runif(10 * 12 * 2) * 100
temp &lt;- trap.builder (frame = XY, method = "all",
    detector = "multi")
## same as temp &lt;- read.traps(data = XY)
plot(temp, border = 0)  ## default grid is 100 m

## Not run: 

## simulate some data
## regular lattice of mini-arrays
minigrid &lt;- make.grid(nx = 3, ny = 3, spacing = 50,
    detector = "proximity")
tempgrid &lt;- trap.builder (cluster = minigrid , method =
    "all", frame = expand.grid(x = seq(1000, 5000, 2000),
    y = seq(1000, 5000, 2000)), plt = TRUE)
tempcapt &lt;- sim.capthist(tempgrid, popn = list(D = 10))
cluster.counts(tempcapt)
cluster.centres(tempgrid)

## "mash" the CH
summary(mash(tempcapt))

## compare timings (estimates are near identical)
tempmask1 &lt;- make.mask(tempgrid, type = "clusterrect",
    buffer = 200, spacing = 10)
fit1 &lt;- secr.fit(tempcapt, mask = tempmask1, trace = FALSE)        

tempmask2 &lt;- make.mask(minigrid, spacing = 10)
fit2 &lt;- secr.fit(mash(tempcapt), mask = tempmask2, trace = FALSE)  
## density estimate is adjusted automatically
## for the number of mashed clusters (9)

predict(fit1)
predict(fit2)
fit1$proctime
fit2$proctime

## SRS excluding detectors from a polygon

region &lt;- cbind(x = c(0,6000,6000,0,0), y = c(0,0,6000,6000,0))
exclude &lt;- cbind(x = c(3000,7000,7000,3000,3000), y = c(2000,2000,4000,4000,2000))
newgrid &lt;- trap.builder (n = 40, cluster = minigrid,
    method = "SRS", edgemethod = "allinside", region = region,
    exclude = exclude, exclmethod = "alloutside",
    plt = TRUE)

## two-phase design: preliminary sample across region,
## followed by selection of sites for intensive grids

arena &lt;- data.frame(x = c(0,2000,2000,0), y = c(0,0,2500,2500))
t1 &lt;- make.grid(nx = 1, ny = 1)
t4 &lt;- make.grid(nx = 4, ny = 4, spacing = 50)
singletraps &lt;- make.systematic (n = c(8,10), cluster = t1,
    region = arena)
CH &lt;- sim.capthist(singletraps, popn = list(D = 2))
plot(CH, type = "n.per.cluster", title = "Number per cluster")
temp &lt;- trap.builder(10, frame = traps(CH), cluster = t4,
    ranks = cluster.counts(CH), method = "rank",
    edgemethod = "allowoverlap", plt = TRUE, add = TRUE)

## GRTS sample of mini-grids within a rectangle
## GRTS uses package 'spsurvey' &gt;= 5.3.0

minigrid &lt;- make.grid(nx = 3, ny = 3, spacing = 50,
    detector = "proximity")
region &lt;- cbind(x = c(0,6000,6000,0,0), y = c(0,0,6000,6000,0))

if (requireNamespace("spsurvey", versionCheck = list(version = "&gt;=5.3.0"))) {

  tempgrid &lt;- trap.builder (n = 20, cluster = minigrid, region = region, 
      plt = TRUE, method = "GRTS")
  
  # specifying minimum distance between cluster origins
  tempgrid2 &lt;- trap.builder (n = 20, cluster = minigrid, region = region, 
      plt = TRUE, method = "GRTS", mindis = 500, maxtry = 10)
  # use spsurvey::warnprnt() to view warnings (e.g., maxtry inadequate)
  
}


## End(Not run)

</code></pre>

<hr>
<h2 id='traps'> Detector Array </h2><span id='topic+traps+20object'></span><span id='topic+traps'></span><span id='topic+traps+3C-'></span>

<h3>Description</h3>

<p>An object of class <code>traps</code> encapsulates a set of detector (trap)
locations and related data. A method of the same name extracts or
replaces the <code>traps</code> attribute of a <code>capthist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
traps(object, ...)
traps(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traps_+3A_object">object</code></td>
<td>
<p> a <code>capthist</code> object. </p>
</td></tr>
<tr><td><code id="traps_+3A_value">value</code></td>
<td>
 <p><code>traps</code> object to replace previous. </p>
</td></tr>
<tr><td><code id="traps_+3A_...">...</code></td>
<td>
<p> other arguments (not used). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>traps</code> holds detector (trap) locations as a
data frame of x-y coordinates. Trap identifiers are used as row names.
The required attribute &lsquo;detector&rsquo; records the type of detector
(&quot;single&quot;, &quot;multi&quot; or &quot;proximity&quot; etc.; see <code><a href="#topic+detector">detector</a></code> for
more).
</p>
<p>Other possible attributes of a <code>traps</code> object are:
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code><a href="#topic+spacing">spacing</a></code> </td><td style="text-align: left;"> mean distance to nearest detector </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>spacex</code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>spacey</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code><a href="#topic+covariates">covariates</a></code> </td><td style="text-align: left;"> dataframe of trap-specific covariates </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code><a href="#topic+clusterID">clusterID</a></code> </td><td style="text-align: left;"> identifier of the cluster to which each detector belongs  </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code><a href="#topic+clustertrap">clustertrap</a></code> </td><td style="text-align: left;"> sequence number of each trap within its cluster  </td>
</tr>
<tr>
 <td style="text-align: left;">  
 <code><a href="#topic+usage">usage</a></code> </td><td style="text-align: left;"> a traps x occasions matrix of effort (may be binary 
 0/1)</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code><a href="#topic+markocc">markocc</a></code> </td><td style="text-align: left;"> integer vector distinguishing marking occasions (1) from 
  sighting occasions (0) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>newtrap</code> </td><td style="text-align: left;"> vector recording aggregation of detectors by
 <code><a href="#topic+reduce.traps">reduce.traps</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">

   </td>
</tr>

</table>

<p>If usage is specified, at least one detector must be &lsquo;used&rsquo; (usage non-zero)
on each occasion.
</p>
<p>Various array geometries may be constructed with functions such as
<code><a href="#topic+make.grid">make.grid</a></code> and <code><a href="#topic+make.circle">make.circle</a></code>, and these may be
combined or placed randomly with <code><a href="#topic+trap.builder">trap.builder</a></code>. 
</p>


<h3>Note</h3>

<p>Generic methods are provided to select rows
(<code><a href="#topic+subset.traps">subset.traps</a></code>), combine two or more arrays
(<code><a href="#topic+rbind.traps">rbind.traps</a></code>), aggregate detectors
(<code><a href="#topic+reduce.traps">reduce.traps</a></code>), shift an array
(<code><a href="#topic+shift.traps">shift.traps</a></code>), or rotate an array
(<code><a href="#topic+rotate.traps">rotate.traps</a></code>).
</p>
<p>The attributes <code>usage</code> and <code>covariates</code> may be extracted or
replaced using generic methods of the same name.
</p>


<h3>References</h3>

 
<p>Efford, M. G. (2012) <em>DENSITY 5.0: software for spatially explicit
capture&ndash;recapture</em>. Department of Mathematics and Statistics,
University of Otago, Dunedin, New Zealand. <a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>.
</p>
<p>Efford, M. G., Borchers D. L. and Byrom, A. E. (2009) Density estimation
by spatially explicit capture-recapture: likelihood-based methods. In:
D. L. Thomson, E. G. Cooch and M. J. Conroy (eds) <em>Modeling
Demographic Processes in Marked Populations</em>. Springer, New York. Pp.
255&ndash;269.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+make.grid">make.grid</a></code>, <code><a href="#topic+read.traps">read.traps</a></code>,
<code><a href="#topic+rbind.traps">rbind.traps</a></code>, <code><a href="#topic+reduce.traps">reduce.traps</a></code>,
<code><a href="#topic+plot.traps">plot.traps</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>,
<code><a href="#topic+spacing">spacing</a></code>, <code><a href="#topic+detector">detector</a></code>,
<code><a href="#topic+covariates">covariates</a></code>, <code><a href="#topic+trap.builder">trap.builder</a></code>,
<code><a href="#topic+as.mask">as.mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
demotraps &lt;- make.grid(nx = 8, ny = 6, spacing = 30)
demotraps    ## uses print method for traps
summary (demotraps)

plot (demotraps, border = 50, label = TRUE, offset = 8, 
    gridlines=FALSE)  

## generate an arbitrary covariate `randcov'
covariates (demotraps) &lt;- data.frame(randcov = rnorm(48))

## overplot detectors that have high covariate values
temptr &lt;- subset(demotraps, covariates(demotraps)$randcov &gt; 0.5)
plot (temptr, add = TRUE, 
    detpar = list (pch = 16, col = "green", cex = 2))  
</code></pre>

<hr>
<h2 id='traps.info'> Detector Attributes </h2><span id='topic+searcharea'></span><span id='topic+polyID'></span><span id='topic+polyID+3C-'></span><span id='topic+transectID'></span><span id='topic+transectID+3C-'></span><span id='topic+transectlength'></span>

<h3>Description</h3>

<p>Extract or replace attributes of an object of class &lsquo;traps&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyID(object)
polyID(object) &lt;- value
transectID(object)
transectID(object) &lt;- value
searcharea(object)
transectlength(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traps.info_+3A_object">object</code></td>
<td>
<p> a &lsquo;traps&rsquo; object </p>
</td></tr>
<tr><td><code id="traps.info_+3A_value">value</code></td>
<td>
<p> replacement value (see Details) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;polyID&rsquo; and &lsquo;transectID&rsquo; functions assign and extract the attribute of a &lsquo;traps&rsquo;
object that relates vertices (rows) to particular polygons or transects. The
replacement value should be a factor of length equal to nrow(object).
</p>
<p>The &lsquo;searcharea&rsquo; of a &lsquo;polygon&rsquo; traps object is a vector of the areas of
the component polygons in hectares. This value is read-only.
</p>
<p>The &lsquo;transectlength&rsquo; of a &lsquo;transect&rsquo; traps object is a vector of the
lengths of the component transects in metres. This value is read-only.
</p>


<h3>Value</h3>

<p><code>polyID</code> - a factor with one level per polygon.
<code>searcharea</code> - numeric value of polygon areas, in hectares.
<code>transectlength</code> - numeric value of transect lengths, in metres.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+traps">traps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## default is a single polygon
temp &lt;- make.grid(detector = "polygon", hollow = TRUE)
polyID(temp)
plot(temp)

## split in two
temp &lt;- make.grid(detector = "polygon", hollow = TRUE)
polyID(temp) &lt;- factor(rep(c(1,2),rep(10,2)))
plot(temp)
 
</code></pre>

<hr>
<h2 id='Trend'> Density Trend </h2><span id='topic+predictDlambda'></span>

<h3>Description</h3>

<p>Functions for multi-session density trend analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
predictDlambda(object, alpha = 0.05)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trend_+3A_object">object</code></td>
<td>
<p>multi-session secr object output from secr.fit</p>
</td></tr>
<tr><td><code id="Trend_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage is described in <a href="https://www.otago.ac.nz/density/pdfs/secr-trend.pdf">secr-trend.pdf</a>. Briefly, setting details argument 'Dlambda' in '<code><a href="#topic+secr.fit">secr.fit</a></code> causes the density model (D~xxx) to be interpreted as a session-specific trend model with parameters for the initial density (D1) and each subsequent session-on-session change in density <code class="reqn">\lambda[t] = D[t+1]/D[t]</code>. 
</p>


<h3>Value</h3>

<p>A table of session-specific estimates (initial D, subsequent <code class="reqn">\lambda[t]</code>) with SE and confidence intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictDsurface">predictDsurface</a></code>, 
<code><a href="#topic+secr.fit">secr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# a model with constant lambda
msk &lt;- make.mask(traps(ovenCH[[1]]), buffer = 300, nx = 25)
fit &lt;- secr.fit(ovenCH, model = D~1, mask = msk, trace = FALSE, 
                 details = list(Dlambda = TRUE), ncores = 2)
predictDlambda(fit)



</code></pre>

<hr>
<h2 id='trim'>
Drop Unwanted List Components
</h2><span id='topic+trim'></span><span id='topic+trim.default'></span><span id='topic+trim.secr'></span><span id='topic+trim.secrlist'></span>

<h3>Description</h3>

<p>Drop unwanted components from a <code>list</code> object, usually to save space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## Default S3 method:
trim(object, drop, keep)
## S3 method for class 'secr'
trim(object, drop = c("call", "mask", "designD", "designNE", 
    "design", "design0"), keep = NULL)
## S3 method for class 'secrlist'
trim(object, drop = c("call", "mask", "designD", "designNE", 
    "design", "design0"), keep = NULL)

</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="trim_+3A_object">object</code></td>
<td>
<p> a list object </p>
</td></tr>
<tr><td><code id="trim_+3A_drop">drop</code></td>
<td>
<p> vector identifying components to be dropped </p>
</td></tr> 
<tr><td><code id="trim_+3A_keep">keep</code></td>
<td>
<p> vector identifying components to be kept </p>
</td></tr> 
</table>


<h3>Details</h3>

 
<p><code>drop</code> may be a character vector of names or a numeric vector of
indices. If both <code>drop</code> and <code>keep</code> are given then the action
is conservative, dropping only components in <code>drop</code> and not in
<code>keep</code>.
</p>
<p>Be warned that some further operations on fitted secr objects become
impossible once you have discarded the default components.
</p>


<h3>Value</h3>

<p>a list retaining selected components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
names(secrdemo.0)
names(trim(secrdemo.0))

object.size(secrdemo.0)
object.size(trim(secrdemo.0))

object.size(trim(secrlist(secrdemo.0, secrdemo.b)))

</code></pre>

<hr>
<h2 id='Troubleshooting'> Problems in Fitting SECR Models </h2><span id='topic+Troubleshooting'></span>

<h3>Description</h3>

<p>Although <code>secr.fit</code> is quite robust, it does not always
work. Inadequate data or an overambitious model occasionally cause
numerical problems in the algorithms used for fitting the model, or
problems of identifiability, as described for capture&ndash;recapture models
in general by Gimenez et al. (2004). Here are some tips that may help
you.
</p>
<p>This page has largely been superceded by <a href="https://www.otago.ac.nz/density/pdfs/secr-troubleshooting.pdf">secr-troubleshooting.pdf</a>.
</p>


<h3>The log-likelihood values shown with trace = TRUE are all NA</h3>

<p>Most likely you have infeasible starting values for the
parameters. try some alternatives, specifying them manually with the
<code>start</code> argument.
</p>


<h3>secr.fit finishes, but some or all of the variances are missing</h3>

<p>This usually means the model did not fit and the estimates should not
be trusted. Extremely large variances or standard errors also indicate
problems.
</p>

<ul>
<li><p> Try another maximization method (<code>method = "Nelder-Mead"</code>
is more robust than the default). The same maximum likelihood should
be found regardless of method, so AIC values are comparable across
methods.
</p>
</li>
<li><p> Repeat the maximization with different starting values. You can use
<code>secr.fit(..., start = last.model)</code> where <code>last.model</code> is a
previously fitted secr object.
</p>
</li>
<li><p> If you think the estimates are right but there was a problem
in computing the variances, try re-running secr.fit() with the
previous model as starting values (see preceding) and set
<code>method = "none"</code>. This bypasses maximization and computes the
variances afresh using <code>fdHess</code> from <span class="pkg">nlme</span>.
</p>
</li>
<li><p> Try a finer mask (e.g., vary argument <code>nx</code> in
<code><a href="#topic+make.mask">make.mask</a></code>). Check that the extent of the mask matches your
data.
</p>
</li>
<li><p> The maximization algorithms work poorly when the beta coefficients
are of wildly different magnitude. This may happen when using
covariates: ensure beta coefficients are similar (within a factor of
5&ndash;10 seems adequate, but this is not based on hard evidence) by scaling
any covariates you provide. This can be achieved by setting the
<code>typsize</code> argument of <code>nlm</code> or the <code>parscale</code>
control argument of <code>optim</code>.
</p>
</li>
<li><p> Examine the model. Boundary values (e.g., g0 near 1.0) may give
problems. In the case of more complicated models you may gain insight by
fixing the value of a difficult-to-estimate parameter (argument
<code>fixed</code>).
</p>
</li></ul>

<p>See also the section &lsquo;Potential problems&rsquo; in
<a href="https://www.otago.ac.nz/density/pdfs/secr-densitysurfaces.pdf">secr-densitysurfaces.pdf</a>.
</p>


<h3>secr.fit finishes with warning nlm code 3</h3>

<p>This condition does not invariably indicate a failure of model
fitting. Proceed with caution, checking as suggested in the preceding
section.
</p>


<h3>secr.fit crashes part of the way through maximization</h3>

<p>A feature of the maximization algorithm used by default in <code>nlm</code>
is that it takes a large step in the parameter space early on in the
maximization. The step may be so large that it causes floating point
underflow or overflow in one or more real parameters.  This can be
controlled by passing the &lsquo;stepmax&rsquo; argument of <code>nlm</code> in the
... argument of <code>secr.fit</code> (see first example). See also the
previous point about scaling of covariates.
</p>


<h3>secr.fit demands more memory than is available</h3>

<p>This is a problem particularly when using individual covariates in a
model fitted by maximizing the conditional likelihood. The memory
required is then roughly proportional to the product of the number of
individuals, the number of occasions, the number of detectors and the
number of latent classes (for finite-mixture models).  When maximizing
the full-likelihood, substitute &lsquo;number of groups&rsquo; for 'number of
individuals'. [The limit is reached in external C used for the
likelihood calculation, which uses the R function &lsquo;R_alloc&rsquo;.]
</p>
<p>The <code><a href="#topic+mash">mash</a></code> function may be used to reduce the number of
detectors when the design uses many identical and independent
clusters. Otherwise, apply your ingenuity to simplify your model,
e.g., by casting &lsquo;groups&rsquo; as &lsquo;sessions&rsquo;. Memory is less often an issue
on 64-bit systems (see link below).
</p>


<h3>Estimates from mixture models appear unstable</h3>

<p> These models
have known problems due to multimodality of the likelihood. See
<a href="https://www.otago.ac.nz/density/pdfs/secr-finitemixtures.pdf">secr-finitemixtures.pdf</a>.
</p>


<h3>References</h3>

<p>Gimenez, O., Viallefont, A., Catchpole, E. A., Choquet, R. and Morgan, B. J. T. (2004)
Methods for investigating parameter redundancy. <em>Animal Biodiversity and
Conservation</em> <b>27</b>, 561&ndash;572.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="base.html#topic+Memory-limits">Memory-limits</a></code> </p>

<hr>
<h2 id='turnover'> Specifying a Dynamic Population </h2><span id='topic+turnover'></span>

<h3>Description</h3>

<p><code>sim.popn</code> can simulate a multi-session population with known between-session survival, recruitment and movement probabilities. The parameter settings to achieve this are passed to <code>sim.popn</code> in its &lsquo;details&rsquo; argument. Components of &lsquo;details&rsquo; that are relevant to turnover are described below; see <code><a href="#topic+sim.popn">sim.popn</a></code> for others.
</p>
<p>Multi-session populations are generated in <code>sim.popn</code> whenever its argument &lsquo;nsessions&rsquo; is greater than 1. If <code>details$lambda</code> remains NULL (the default) then the population for each successive session is generated de novo from the given density model (model2D, D etc.). If a value is specified for <code>details$lambda</code> then only the first population is generated de novo; remaining populations are generated iteratively with probabilistic mortality, recruitment and movement as described here.
</p>


<h3>Turnover components of <code>sim.popn</code> details argument</h3>


<table>
<tr>
 <td style="text-align: left;">
Component </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Default </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>phi</code> </td><td style="text-align: left;"> per capita survival rate <code class="reqn">\phi</code> </td><td style="text-align: left;"> 0.7 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>survmodel</code> </td><td style="text-align: left;"> probability model for number of survivors </td><td style="text-align: left;"> ``binomial" </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>lambda</code> </td><td style="text-align: left;"> finite rate of increase <code class="reqn">\lambda = N_{t+1} / N_t</code> </td><td style="text-align: left;"> none </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>recrmodel</code> </td><td style="text-align: left;"> probability model for number of recruits </td><td style="text-align: left;"> ``poisson" </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>superN</code> </td><td style="text-align: left;"> optional superpopulation size for `multinomial' recruitment model</td><td style="text-align: left;"> see below </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Nrecruits</code> </td><td style="text-align: left;"> number of recruits to add at t+1 for `specified' recruitment model </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>movemodel</code> </td><td style="text-align: left;"> ``static", ``uncorrelated", ``normal", ``exponential", ``t2D" or a user function </td><td style="text-align: left;"> ``static" </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>move.a</code> </td><td style="text-align: left;"> first parameter of movement kernel (replacing sigma.m) </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>move.b</code> </td><td style="text-align: left;"> second parameter of movement kernel </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>edgemethod</code> </td><td style="text-align: left;"> treatment of animals that cross the boundary </td><td style="text-align: left;"> ``wrap" </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sigma.m</code> </td><td style="text-align: left;"> deprecated in 3.2.1; use move.a </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>wrap</code> </td><td style="text-align: left;"> deprecated in 3.1.6; use edgemethod </td><td style="text-align: left;"> TRUE i.e. edgemethod = ``wrap" </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Survival</h3>

<p>Survival is usually thought of as a Bernoulli process (outcome 0 or 1 for each individual) so the number of survivors <code class="reqn">S</code> is a binomial variable (survmodel = &quot;binomial&quot;). Another approach is to fix the proportion surviving, but this can be done exactly only when <code class="reqn">\phi N</code> is an integer. A (slightly ad hoc) solution is to randomly choose between the two nearest integers with probability designed in the long term (over many sessions) to give the required <code class="reqn">\phi</code> (survmodel = &quot;discrete&quot;).
</p>


<h3>Population growth and recruitment</h3>

<p>Per capita recruitment (<code class="reqn">f</code>) is the difference between lambda and phi (<code class="reqn">f = \lambda - \phi</code>), which must be non-negative (phi &gt; lambda causes an error). The number of recruits B is a random variable whose probability distribution is controlled by details$recrmodel:
</p>

<table>
<tr>
 <td style="text-align: left;">
Value </td><td style="text-align: left;"> Probability model </td>
</tr>
<tr>
 <td style="text-align: left;">
"constantN" </td><td style="text-align: left;"> Exact replacement of animals that die (B = <code class="reqn">N_t - S</code>)</td>
</tr>
<tr>
 <td style="text-align: left;">
"binomial" </td><td style="text-align: left;"> Binomial number of recruits (B ~ bin(<code class="reqn">N_t, f</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
"poisson" </td><td style="text-align: left;"> Poisson number of recruits (B ~ pois(<code class="reqn">f N_t</code>)) </td>
</tr>
<tr>
 <td style="text-align: left;">
"discrete" </td><td style="text-align: left;"> Minimum-variance number of recruits (see Survival) </td>
</tr>
<tr>
 <td style="text-align: left;">
"multinomial" </td><td style="text-align: left;"> The POPAN model, conditioning on superpopulation size (e.g., Schwarz and Arnason 1996)) </td>
</tr>
<tr>
 <td style="text-align: left;">
"specified" </td><td style="text-align: left;"> Add the number of recruits specified in Nrecruits (may be vector) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>In the case of binomial recruitment there is a maximum of one recruit per existing individual, so lambda &lt;= (phi+1). Multinomial recruitment requires a value for the superpopulation size. This may be provided as the details component &quot;superN&quot;. If not specified directly, a value is inferred by projecting a trial initial (simulated) population using the specified phi and lambda.
</p>
<p>Specifying the integer number of recruits in each year (recrmodel &lsquo;specified&rsquo;) overrides the value of lambda, but a non-null value should be given for lambda.
</p>


<h3>Movement</h3>

<p>Individuals may shift their home range centre between sessions. Movement probability is governed by a circular kernel specified by &lsquo;movemodel&rsquo; and the parameter values &lsquo;move.a&rsquo; and &lsquo;move.b&rsquo; (optional). By default there is no movement between sessions (movemodel = &quot;static&quot;). Other options are
</p>

<table>
<tr>
 <td style="text-align: left;">
``IND" </td><td style="text-align: left;"> ``uncorrelated" </td><td style="text-align: left;"> individuals are randomly assigned a new, independent location within the buffered area</td>
</tr>
<tr>
 <td style="text-align: left;">
``BVN" </td><td style="text-align: left;"> ``normal"</td><td style="text-align: left;"> bivariate normal (Gaussian) kernel with parameter move.a (previously called sigma.m)</td>
</tr>
<tr>
 <td style="text-align: left;">
``BVE" </td><td style="text-align: left;"> ``exponential" </td><td style="text-align: left;"> negative exponential (Laplace) kernel with parameter move.a </td>
</tr>
<tr>
 <td style="text-align: left;">
``BVT" </td><td style="text-align: left;"> ``t2D"</td><td style="text-align: left;"> circular 2-dimensional t-distribution with scale parameter move.a and shape parameter move.b = df/2 (2Dt of Clark et al. 1999)</td>
</tr>
<tr>
 <td style="text-align: left;">
``RDE" </td><td style="text-align: left;"> </td><td style="text-align: left;"> exponential distribution of radial distance (Ergon &amp; Gardner, 2014) </td>
</tr>
<tr>
 <td style="text-align: left;">
``RDG" </td><td style="text-align: left;"> </td><td style="text-align: left;"> gamma distribution of radial distance (Ergon &amp; Gardner, 2014) </td>
</tr>
<tr>
 <td style="text-align: left;">
``RDL" </td><td style="text-align: left;"> </td><td style="text-align: left;"> log-normal distribution of radial distance (Ergon &amp; Gardner, 2014) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;">  (parameterized with move.a = exp(mu), move.b = 1/CV^2 = 1 / (exp(SD^2) - 1) </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>

<p>The package <span class="pkg">openCR</span> &gt;=1.4.0 provides functions for constructing and plotting these kernels and summarising their properties (<code>make.kernel</code>; <code>plot</code> and <code>summary</code> methods for kernel objects). The <span class="pkg">secr</span> function <code><a href="#topic+extractMoves">extractMoves</a></code> is useful for checking simulations of movement.
</p>
<p>Models IND, BVN, BVE, and RDE may also be zero-inflated (suffix &ldquo;zi&quot;). The parameter &lsquo;move.a&rsquo; (INDzi) or &lsquo;move.b&rsquo; (BVNzi, BVEzi, RDEzi) is the zero-inflation probability. See Examples.
</p>
<p>In <span class="pkg">secr</span> &lt;3.2.1 sigma.m was also used to indicate two special cases; these continue to work but may be discontinued in the future:
</p>
<p>sigma.m = 0 corresponds to movemodel = &lsquo;static&rsquo;
</p>
<p>sigma.m &lt; 0 corresponds to movemodel = &lsquo;uncorrelated&rsquo;
</p>
<p>In <span class="pkg">secr</span> &gt;= 4.4.0, the &lsquo;movemodel&rsquo; component may also be a user-provided function with these characteristics: two or three arguments, the first being the number of centres to be moved (e.g., n) and the others parameters of the dispersal distribution (e.g., a,b); the function should return a matrix of n rows and 2 columns, the displacements in the x- and y-directions. The output is a set of random points from the bivariate dispersal kernel. The function will be called with the current number of centres and parameter values move.a and move.b as needed.
</p>
<p>If movement takes an animal across the boundary of the arena (buffered area) in <code>sim.popn</code> the component &quot;edgemethod&quot; comes into play. By default, locations are toroidally wrapped i.e. the animal re-joins the population on the opposing edge. Other options are &ldquo;clip&rdquo; (discard), &ldquo;clipandreplace&rdquo; (assign new identity at original location), &ldquo;stop&rdquo; (stop just inside the boundary), &ldquo;reflect&rdquo; (bounce off edges to the limit of the dispersal), &ldquo;normalize&rdquo; = &ldquo;truncate&rdquo; (truncate kernel and scale probability to 1.0) and &ldquo;none&quot; (allow centres outside the buffered area). The &ldquo;normalize&rdquo; option (new in <span class="pkg">secr</span> 4.3.3) can take longer as it repeatedly relocates each individual until its destination lies within the bounding box, up to a maximum of 500 attempts.
</p>


<h3>References</h3>

<p>Clark, J. S, Silman, M., Kern, R., Macklin, E. and HilleRisLambers, J. (1999) Seed dispersal near and far: patterns across temperate and tropical forests. <em>Ecology</em> <b>80</b>, 1475&ndash;1494.
</p>
<p>Nathan , R., Klein, E., Robledo-Arnuncio, J. J. and Revilla, E. (2012) 
Dispersal kernels: a review. In: J Clobert et al. <em>Dispersal Ecology and Evolution</em>. Oxford University Press. Pp 187&ndash;210.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.popn">sim.popn</a></code>, <code><a href="#topic+extractMoves">extractMoves</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
par (mfrow = c(2,3), mar = c(1,1,1,1))

## birth and death only
grid &lt;- make.grid(nx = 7, ny = 4, detector = 'proximity', spacing = 10)
pop &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 6,    
    details = list(lambda = 0.8, phi = 0.6))
sapply(pop, nrow)  ## how many individuals?
plot(pop)

## movement only
pop2 &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 6,    
    details = list(lambda = 1, phi = 1, movemodel = 'normal', 
    move.a = 10, edgemethod = "wrap"))
pop3 &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 6,    
    details = list(lambda = 1, phi = 1, movemodel = 'normal', 
    move.a = 10, edgemethod = "clip"))
pop4 &lt;- sim.popn (Nbuffer = 100, core = grid, nsessions = 10,    
    details = list(lambda = 1, phi = 1, movemodel = 'normal', 
    move.a = 10, edgemethod = "stop"))
sapply(pop2, nrow)  ## how many individuals?
plot(pop2)

## show effect of edgemethod --
## first session blue, last session red
cols &lt;- c('blue',rep('white',4),'red')
par (mfrow=c(1,2))
plot(pop2, collapse = TRUE, seqcol = cols)
plot(pop3, collapse = TRUE, seqcol = cols)

## zero-inflated movement
## move.b is zero-inflation probability
pop5 &lt;- sim.popn (Nbuffer = 1000, core = grid, nsessions = 6,    
     details = list(lambda = 1, phi = 1, movemodel = 'RDEzi', 
         move.a = 50, move.b = 0.5, edgemethod = "none"))
mean(do.call(rbind,extractMoves(pop5))$d)   # approx 50 * 0.5

</code></pre>

<hr>
<h2 id='updateCH'>Update Old capthist Format</h2><span id='topic+updateCH'></span>

<h3>Description</h3>

<p>Before version 3.0, the internal data format for data from exclusive detectors (single, multi, proximityX, transectX) was a matrix with one row per detected animal and one column per sampling occasion; each cell was either zero or the number of the detector at which the animal was detected (with switched sign if the animal died). The format for data from proximity and other detectors was a 3-dimensional array (third dimension corresponding to detectors) that allowed more than one detection per animal per occasion.
</p>
<p>From secr 3.0 all capthist data use the 3-D format internally. This simplifies a lot of the coding, and enables mixing of detector types within a session. The constraint that only one detection is allowed per animal per occasion at exclusive detectors is imposed by verify().
</p>
<p>The data input functions (read.capthist etc.) automatically generate objects in the new format. Objects created and saved under earlier versions should be converted if they relate to the &lsquo;exclusive&rsquo; detector types listed above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateCH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateCH_+3A_object">object</code></td>
<td>
<p>capthist object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reduce.capthist is applied with the nominal detector type as the outputdetector.
</p>


<h3>Value</h3>

<p>Object with same class as the input. 
</p>
<p>Updating has the side effect of discarding invalid supernumerary detections (e.g. if there were two detections of an animal on one occasion, only one will be included).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# if we had the old ovenCH !
sapply(ovenCH, dim)
sapply(updateCH(ovenCH), dim)

</code></pre>

<hr>
<h2 id='usage'> Detector Usage </h2><span id='topic+usage'></span><span id='topic+usage+3C-'></span><span id='topic+effort'></span>

<h3>Description</h3>

<p>Extract or replace usage (effort) information of a <code>traps</code> object
(optional).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usage(object, ...)
usage(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usage_+3A_object">object</code></td>
<td>
 <p><code>traps</code> object </p>
</td></tr>
<tr><td><code id="usage_+3A_value">value</code></td>
<td>
<p> numeric matrix of detectors x occasions </p>
</td></tr>
<tr><td><code id="usage_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In secr versions before 2.5.0, usage was defined as a binary value
(1 if trap <code class="reqn">k</code> used on occasion <code class="reqn">s</code>, zero otherwise).
</p>
<p>In later versions, usage may take nonnegative real values and will be
interpreted as effort. This corresponds to the constant T_s used for
the duration of sampling by Borchers and Efford (2008). Effort is
modelled as a known linear coefficient of detection probability on the
hazard scale
(<a href="https://www.otago.ac.nz/density/pdfs/secr-varyingeffort.pdf">secr-varyingeffort.pdf</a>;
Efford et al. 2013).
</p>
<p>For replacement of usage, various forms are possible for <code>value</code>:
</p>
<p>- a matrix in which the number of rows of <code>value</code> exactly
matches the number of traps <em>K</em> in <code>object</code>
</p>
<p>- a vector of two values, the usage (typically 1) and the number of
occasions <em>S</em> (a <em>K</em> x <em>S</em> matrix will be filled with
the first value)
</p>
<p>- a vector of <em>R+1</em> values where <em>R</em> is the number of
sessions in a multi-session object and elements <em>2..R+1</em> correspond to
the numbers of occasions <em>S1, S2,...</em> in each session
</p>
<p>- the usage only (typically 1) (only works when replacing an existing
usage matrix with known number of occasions).  
</p>


<h3>Value</h3>

<p>usage(object) returns the usage matrix of the <code>traps</code>
object. <code>usage(object)</code> may be NULL.
</p>


<h3>Note</h3>

<p>At present, assignment of usage to the traps objects of a multisession
capthist object results in the loss of session names from the latter.
</p>


<h3>References</h3>

<p>Efford, M. G., Borchers D. L. and Mowat, G. (2013) Varying effort in
capture&ndash;recapture studies. <em>Methods in Ecology
and Evolution</em> <b>4</b>, 629&ndash;636.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+traps">traps</a></code>,
<code><a href="#topic+usagePlot">usagePlot</a></code>,
<code><a href="#topic+read.capthist">read.capthist</a></code>,
<code><a href="#topic+addSightings">addSightings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo.traps &lt;- make.grid(nx = 6, ny = 8)
## random usage over 5 occasions
usage(demo.traps) &lt;- matrix (sample(0:1, 48*5, replace = TRUE, 
    p = c(0.5,0.5)), nc = 5)
usage(demo.traps)
summary(demo.traps)

usage(traps(ovenCH)) &lt;- c(1,9,10,10,10,10)
## restore lost names
names(ovenCH) &lt;- 2005:2009

</code></pre>

<hr>
<h2 id='usagePlot'>
Plot usage, detections or sightings.
</h2><span id='topic+usagePlot'></span><span id='topic+sightingPlot'></span>

<h3>Description</h3>

<p><code>usagePlot</code> displays variation in effort (usage) over detectors as a
bubble plot (circles with radius scaled so that area is proportional to
effort).
</p>
<p><code>sightingPlot</code> displays spatial variation in the number of sightings at each detector as a
bubble plot (circles with radius scaled so that area is proportional to either the average number per occasion or the total over occasions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
usagePlot(object, add = FALSE, occasions = NULL, col = "black", fill =
FALSE, scale = 2, metres = TRUE, rad = 5, ...)

sightingPlot(object, type = c("Detections", "Tu", "Tm", "Tn"), add = FALSE, 
occasions = "ALL", mean = TRUE, col = "black", fill = FALSE, scale = 2, 
metres = TRUE, dropunused = TRUE, title = type, legend = c(1, 2, 4, 8), 
px = 0.95, py = 0.95, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usagePlot_+3A_object">object</code></td>
<td>
<p>traps object with usage attribute</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_add">add</code></td>
<td>
<p>logical; if FALSE plot.traps is called to create a base plot</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_occasions">occasions</code></td>
<td>
<p>integer number(s) of the occasion(s) for which effort is
plotted, &quot;ALL&quot;, or NULL</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_col">col</code></td>
<td>
<p>character or integer colour value</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_fill">fill</code></td>
<td>
<p>logical; if TRUE the circle is filled with the line colour</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_scale">scale</code></td>
<td>
<p>numeric value used to scale radius</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_metres">metres</code></td>
<td>
<p>logical; if TRUE scale is a value in metres (see Details)</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_rad">rad</code></td>
<td>
<p>numeric; radial displacement of symbol centre for each occasion from
true detector location (metres) </p>
</td></tr>
<tr><td><code id="usagePlot_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot.traps</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_type">type</code></td>
<td>
<p>character to choose among sighting types and detections of marked animals</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_mean">mean</code></td>
<td>
<p>logical; if TRUE then the plotted value is the average over occasions, otherwise the sum</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_dropunused">dropunused</code></td>
<td>
<p>logical; if TRUE then detectors are omitted when they were unused on <code>occasions</code></p>
</td></tr>
<tr><td><code id="usagePlot_+3A_title">title</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_legend">legend</code></td>
<td>
<p>numeric values for which legend circles will be drawn</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_px">px</code></td>
<td>
<p>legend x position as fraction of user coordinates</p>
</td></tr>
<tr><td><code id="usagePlot_+3A_py">py</code></td>
<td>
<p>legend y position as fraction of user coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behaviour of <code>usagePlot</code> is described first. By default (<code>occasion = NULL</code>) circles representing usage on each
occasion are plotted around the detector location at distance
<code>rad</code>, as in the petal plot of
<code><a href="#topic+plot.capthist">plot.capthist</a></code>. Otherwise, the usage on a single
specified occasion, or summed over occasions
(<code>length(occasion)&gt;1</code>, or <code>occasion = "ALL"</code>), is plotted as
a circle centred at the detector location.
</p>
<p>Package <span class="pkg">sp</span> provides an alternative to <code>usagePlot</code> (see Examples).
</p>
<p><code>sightingPlot</code> may be used to display either detections of marked animals (whether or not <code>occasions</code> refers to sighting occasions) or any of the sighting attributes (unmarked sightings &lsquo;Tu&rsquo;, marked, unidentified sightings &lsquo;Tm&rsquo;, or other uncertain sightings &lsquo;Tn&rsquo;).
</p>
<p>If <code>py</code> is of length 2 then the values determine the vertical spread of symbols in the legend.
</p>
<p>For both functions &ndash;
</p>
<p>The <code>metres</code> argument switches between two methods. If <code>metres
= TRUE</code>, the <code>symbols</code> function is used with <code>inches = FALSE</code> to plot
circles with radius scaled in the units of <code>object</code> (i.e. metres;
<code>scale</code> is then the radius in metres of the symbol for a detector
with usage = 1.0).  Otherwise, plotting uses <code>points</code>; this has the
advantage of producing better filled circles, but a suitable value of
scale must be found by trial and error.
</p>


<h3>Value</h3>

<p>No value is returned by <code>usagePlot</code>.
</p>
<p><code>sightingPlot</code> invisibly returns a &lsquo;traps&rsquo; object with a covariate &lsquo;f&rsquo; holding the plotted values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+usage">usage</a></code>, <code><a href="graphics.html#topic+symbols">symbols</a></code>, <code><a href="sp.html#topic+bubble">bubble</a></code>,
<a href="#topic+sightings">sightings</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simgrid &lt;- make.grid(nx = 10, ny = 10, detector = "proximity")
usage(simgrid) &lt;- matrix(rep(1:10, 50), nrow = 100, ncol = 5)
usagePlot(simgrid, border = 20, scale = 1.5, fill = FALSE,
  metres = FALSE)

# It is hard to get the legend just right
# here is one attempt
legend (x = -50, y = 185, legend = c(1,2,5,10), pch = 1, pt.cex =
  c(1,2,5,10)^0.5 * 1.5, x.intersp = 3, y.intersp = 1.8, adj = 1,
  bty = "n", title = "Usage")

usagePlot(simgrid, occasion = NULL, border = 20, scale = 1.5, fill = FALSE,
  metres = FALSE)

## Not run: 
# bubble plot in package 'sp'
library(sp)
simgrid$usage &lt;- usage(simgrid)[,1]  ## occasion 1
class(simgrid) &lt;- "data.frame"
coordinates(simgrid) &lt;- c("x","y")
bubble(simgrid)   

## End(Not run)

</code></pre>

<hr>
<h2 id='userdist'> Non-Euclidean Distances </h2><span id='topic+userdist'></span><span id='topic+noneuc'></span>

<h3>Description</h3>

<p>Non-Euclidean distances have a variety of uses, some obscure. You
probably do not need them unless you have data from linear habitats,
covered in the forthcoming package <span class="pkg">secrlinear</span>. On the other hand,
they open up some intriguing possibilities for the advanced user. The
key is to provide an appropriate value for the component &lsquo;userdist&rsquo; of
the <code>details</code> argument of <code><a href="#topic+secr.fit">secr.fit</a></code>.
</p>
<p><code>details$userdist</code> is either a function to compute distances
between detectors and mask points, or a pre-computed matrix of such
distances. Pre-computing assumes the matrix is static (i.e. fixed and
not dependent on any estimated coefficients). The functions
<code><a href="#topic+edist">edist</a></code> and <code><a href="#topic+nedist">nedist</a></code> are useful for computing
static matrices of Euclidean or non-Euclidean distances (the latter is 
useful when there are barriers to movement).
</p>
<p>If <code>details$userdist</code> is a function then it should take the form
</p>
<p>userdist(xy1, xy2, mask)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="userdist_+3A_xy1">xy1</code></td>
<td>
<p>2-column matrix of x-y coordinates of <code class="reqn">k</code> detectors</p>
</td></tr>
<tr><td><code id="userdist_+3A_xy2">xy2</code></td>
<td>
<p>2-column matrix of x-y coordinates of <code class="reqn">m</code> mask points</p>
</td></tr>
<tr><td><code id="userdist_+3A_mask">mask</code></td>
<td>
<p>habitat mask defining a non-Euclidean habitat geometry</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix returned by the function must have exactly <code class="reqn">k</code> rows and
<code class="reqn">m</code> columns. The function name may be almost anything you like.
</p>
<p>The non-Euclidean habitat geometry may or may not require access to
local density (D), local (mask) covariates, and the estimation of
additional coefficients (beta variables). In order that secr.fit can
assemble these data, there is a mechanism for the user to indicate
which, if any, variables are required: when called with no arguments the
function should return a character vector of variable names. These may
include covariates of &lsquo;mask&rsquo;, the dynamically computed density 'D', and
a special real parameter &lsquo;noneuc&rsquo; for which one or more coefficients
will be fitted.
</p>
<p>&lsquo;noneuc&rsquo; is like 'D' in that it may be modelled as a function of any mask
covariates, session, Session, x, y, etc. The actual meaning attributed
to &lsquo;noneuc&rsquo; depends entirely on how it is used inside the function.
</p>
<p>The function may require no variables and not require estimation of
additional coefficients. This is the case for a simple linear geometry
as described in documentation for the package &lsquo;secrlinear&rsquo;.
</p>

<table>
<tr>
 <td style="text-align: left;">
  Value  </td><td style="text-align: left;"> Interpretation </td>
</tr>
<tr>
 <td style="text-align: left;">
  ''       </td><td style="text-align: left;"> no covariates etc. required </td>
</tr>
<tr>
 <td style="text-align: left;">
  'D'      </td><td style="text-align: left;"> density at each mask point </td>
</tr>
<tr>
 <td style="text-align: left;">
  'noneuc' </td><td style="text-align: left;"> a multi-purpose real parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> defined for each mask point </td>
</tr>
<tr>
 <td style="text-align: left;">
  c('D', 'noneuc') </td><td style="text-align: left;"> both of the preceding </td>
</tr>
<tr>
 <td style="text-align: left;">
  c('noneuc','habclass') </td><td style="text-align: left;"> both noneuc and the mask covariate
  'habclass' </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>

<p>The last case does not estimate a coefficient for habclass, it merely
makes the raw value available to whatever algorithm you implement. 
</p>
<p>The &lsquo;xy2&rsquo; and &lsquo;mask&rsquo; parameters of the userdist function overlap in
practice: xy1 and xy2 only define the points between which distances are
required, whereas mask is a carrier for any and all additional
information needed by the algorithm.
</p>
<p>Full documentation of the <span class="pkg">secr</span> capability for non-Euclidean
distances is in the separate document
<a href="https://www.otago.ac.nz/density/pdfs/secr-noneuclidean.pdf">secr-noneuclidean.pdf</a>,
which includes example code for the analysis of Sutherland et
al. (2015).
</p>


<h3>Compatibility</h3>

<p>User-specified distances are compatible with some but not all features
of <span class="pkg">secr</span>. Functions with a &lsquo;userdist&rsquo; argument are certainly
compatible, and others may be.
</p>
<p>With a static userdist, <code>region.N</code> will generally not calculate  population size for a region other than the original mask. If you want to supply a new mask in the &lsquo;region&rsquo; argument, replace x$details$userdist with a distance matrix appropriate to the new mask, where &lsquo;x&rsquo; is the name of the fitted model.
</p>
<p>User-specified distances cannot be used with polygon or transect
detectors.
</p>
<p>When using <code><a href="#topic+sim.capthist">sim.capthist</a></code> to simulate detections of a new
population from <code><a href="#topic+sim.popn">sim.popn</a></code> you must provide <code>userdist</code>
as a function rather than a matrix. This is because new animals are not
restricted to locations on the &lsquo;mask&rsquo; grid. 
</p>


<h3>References</h3>

<p>Sutherland, C., Fuller, A. K. and Royle, J. A. (2015) Modelling
non-Euclidean movement and landscape connectivity in highly structured
ecological networks. <em>Methods in Ecology and Evolution</em> <b>6</b>, 169&ndash;177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+details">details</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+nedist">nedist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see secr-noneuclidean.pdf

</code></pre>

<hr>
<h2 id='utility'>Utility Functions</h2><span id='topic+getMeanSD'></span><span id='topic+maskarea'></span><span id='topic+masklength'></span><span id='topic+edist'></span><span id='topic+nedist'></span>

<h3>Description</h3>

<p>Minor functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMeanSD(xy)
maskarea(mask, sessnum = 1)
masklength(mask, sessnum = 1)
edist(xy1, xy2)
nedist(xy1, xy2, mask, inf = Inf, ...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="utility_+3A_xy">xy</code></td>
<td>
<p>2-column matrix or dataframe</p>
</td></tr>
<tr><td><code id="utility_+3A_xy1">xy1</code></td>
<td>
<p>2-column matrix or dataframe</p>
</td></tr>
<tr><td><code id="utility_+3A_xy2">xy2</code></td>
<td>
<p>2-column matrix or dataframe</p>
</td></tr>
<tr><td><code id="utility_+3A_mask">mask</code></td>
<td>
<p>mask or linearmask object</p>
</td></tr>
<tr><td><code id="utility_+3A_sessnum">sessnum</code></td>
<td>
<p>integer; for multi-session masks, the number of the session</p>
</td></tr>
<tr><td><code id="utility_+3A_inf">inf</code></td>
<td>
<p>numeric value to use for +infinity</p>
</td></tr>
<tr><td><code id="utility_+3A_...">...</code></td>
<td>
<p>other arguments for <code><a href="gdistance.html#topic+transition">transition</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getmeanSD</code> is used by <code><a href="#topic+make.mask">make.mask</a></code> to standardize
mask coordinates.
</p>
<p>For <code>masklength</code> the input should be a linear mask from <span class="pkg">secrlinear</span>.
</p>
<p><code>edist</code> computes the Euclidean distance between each point in xy1
and each point in xy2. (This duplicates the functionality of &lsquo;rdist&rsquo;
in package <span class="pkg">fields</span>).
</p>
<p><code>nedist</code> computes the non-Euclidean distance between each point
in xy1 and each point in xy2, in two dimensions. The calculation uses
<span class="pkg">gdistance</span> (van Etten 2017; see also Csardi &amp; Nepusz 2006): a
transition layer is formed representing the connections between
adjacent points in <code>mask</code>. By default, points within a 16-point
neighbourhood are considered &lsquo;adjacent&rsquo;. Distances are obtained by
Dijkstra's (1959) algorithm as least cost paths through the graph of
all points in the mask.
</p>
<p><code>nedist</code> has some subtle options. If &lsquo;mask&rsquo; is missing then the
transition layer will be formed from &lsquo;xy2&rsquo;. If &lsquo;mask&rsquo; has a covariate
named &lsquo;noneuc&rsquo; then this will be used to weight distances. The ...
argument of <code>nedist</code> allows the user to vary arguments of
<code><a href="gdistance.html#topic+transition">transition</a></code> (defaults transitionFunction =
mean and directions = 16). Be warned this can lead to unexpected
results! Point pairs that are completely separated receive the
distance +Inf unless a finite value is provided for the argument
&lsquo;inf&rsquo;. See
<a href="https://www.otago.ac.nz/density/pdfs/secr-noneuclidean.pdf">secr-noneuclidean.pdf</a>
for uses of <code>nedist</code>.
</p>


<h3>Value</h3>

<p>For <code>getMeanSD</code>, a dataframe with columns &lsquo;x&rsquo; and &lsquo;y&rsquo; and two
rows, mean and SD.
</p>
<p>For <code>maskarea</code>, the summed area of mask cells in hectares (ha).
</p>
<p>For <code>masklength</code>, the summed length of mask cells in kilometers (km).
</p>
<p>For <code>edist</code> and <code>nedist</code>, a matrix with dim = c(nrow(xy1), nrow(xy2)).
</p>


<h3>References</h3>

<p>Dijkstra, E. W. (1959) A note on two problems in connexion with
graphs. <em>Numerische Mathematik</em>, <b>1</b>, 269&ndash;271.
</p>
<p>Csardi, G. and Nepusz, T. (2006) The igraph software package for complex
network research. <em>InterJournal</em>, <b>1695</b>. <a href="https://igraph.org">https://igraph.org</a>
</p>
<p>van Etten, J. (2017) R package gdistance: Distances and routes on
geographical grids. <em>Journal of Statistical Software</em>, <b>76(1)</b>, 1&ndash;21.
<a href="https://doi.org/10.18637/jss.v076.i13">doi:10.18637/jss.v076.i13</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getMeanSD(possummask)

</code></pre>

<hr>
<h2 id='vcov.secr'> Variance - Covariance Matrix of SECR Parameters </h2><span id='topic+vcov.secr'></span>

<h3>Description</h3>

<p>Variance-covariance matrix of beta or real parameters from fitted secr model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'secr'
vcov(object, realnames = NULL, newdata = NULL, 
    byrow = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.secr_+3A_object">object</code></td>
<td>
<p> secr object output from the function <code><a href="#topic+secr.fit">secr.fit</a></code> </p>
</td></tr>
<tr><td><code id="vcov.secr_+3A_realnames">realnames</code></td>
<td>
<p> vector of character strings for names of &lsquo;real&rsquo; parameters </p>
</td></tr>
<tr><td><code id="vcov.secr_+3A_newdata">newdata</code></td>
<td>
<p> dataframe of predictor values </p>
</td></tr>
<tr><td><code id="vcov.secr_+3A_byrow">byrow</code></td>
<td>
<p> logical for whether to compute covariances among &lsquo;real&rsquo; parameters for each row of new data, or among rows for each real parameter</p>
</td></tr>
<tr><td><code id="vcov.secr_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, returns the matrix of variances and covariances among the
estimated model coefficients (beta parameters). 
</p>
<p>If <code>realnames</code> and <code>newdata</code> are specified, the result is
either a matrix of variances and covariances for each &lsquo;real&rsquo; parameter
among the points in predictor-space given by the rows of <code>newdata</code>
or among real parameters for each row of <code>newdata</code>. Failure to
specify <code>newdata</code> results in a list of variances only.
</p>


<h3>Value</h3>

<p>A matrix containing the variances and covariances among beta parameters
on the respective link scales, or a list of among-parameter variance-covariance
matrices, one for each row of <code>newdata</code>, or a list of among-row variance-covariance
matrices, one for each &lsquo;real&rsquo; parameter.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+print.secr">print.secr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## previously fitted secr model
vcov(secrdemo.0)
</code></pre>

<hr>
<h2 id='verify'>
Check SECR Data
</h2><span id='topic+verify'></span><span id='topic+verify.default'></span><span id='topic+verify.traps'></span><span id='topic+verify.capthist'></span><span id='topic+verify.mask'></span>

<h3>Description</h3>

<p>Check that the data and attributes of an object are internally consistent to avoid crashing functions such as <code>secr.fit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
verify(object, report, ...)
## S3 method for class 'traps'
verify(object, report = 2, ...)
## S3 method for class 'capthist'
verify(object, report = 2, tol = 0.01, ...)
## S3 method for class 'mask'
verify(object, report = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_+3A_object">object</code></td>
<td>

<p>an object of class &lsquo;traps&rsquo;, &lsquo;capthist&rsquo; or &lsquo;mask&rsquo;
</p>
</td></tr>
<tr><td><code id="verify_+3A_report">report</code></td>
<td>

<p>integer code for level of reporting to the console. 0 = no report, 1 = errors only, 2 = full.
</p>
</td></tr>
<tr><td><code id="verify_+3A_tol">tol</code></td>
<td>

<p>numeric tolerance for deviations from transect line (m)
</p>
</td></tr>
<tr><td><code id="verify_+3A_...">...</code></td>
<td>
 
<p>other arguments (not used) 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks are performed specific to the class of &lsquo;object&rsquo;. The default
method is called when no specific method is available (i.e. class not
&lsquo;traps&rsquo;, &lsquo;capthist&rsquo; or &lsquo;mask&rsquo;), and does not perform any checks.
</p>
<p><code>verify.capthist</code>
</p>
 
<ol>
<li><p> No &lsquo;traps&rsquo; component
</p>
</li>
<li><p> Invalid &lsquo;traps&rsquo; component reported by verify.traps 
</p>
</li>
<li><p> No live detections
</p>
</li>
<li><p> Missing values not allowed in capthist
</p>
</li>
<li><p> Live detection(s) after reported dead
</p>
</li>
<li><p> Empty detection histories (except concurrent telemetry and all-sighting data)
</p>
</li>
<li><p> More than one capture in single-catch trap(s)
</p>
</li>
<li><p> More than one detection per detector per occasion at proximity detector(s)
</p>
</li>
<li><p> Signal detector signal(s) less than threshold or invalid threshold
</p>
</li>
<li><p> Number of rows in &lsquo;traps&rsquo; object not compatible with reported detections
</p>
</li>
<li><p> Number of rows in dataframe of individual covariates differs from capthist
</p>
</li>
<li><p> Number of occasions in usage matrix differs from capthist
</p>
</li>
<li><p> Detections at unused detectors
</p>
</li>
<li><p> Number of coordinates does not match number of detections
(&lsquo;polygon&rsquo;, &lsquo;polygonX&rsquo;, &lsquo;transect&rsquo; or &lsquo;transectX&rsquo; detectors)
</p>
</li>
<li><p> Coordinates of detection(s) outside polygons (&lsquo;polygon&rsquo; or &lsquo;polygonX&rsquo; detectors)
</p>
</li>
<li><p> Coordinates of detection(s) do not lie on any transect
(&lsquo;transect&rsquo; or &lsquo;transectX&rsquo; detectors)
</p>
</li>
<li><p> Row names (animal identifiers) not unique
</p>
</li>
<li><p> Levels of factor covariate(s) differ between sessions
</p>
</li></ol>

<p><code>verify.traps</code>
</p>

<ol>
<li><p> Missing detector coordinates not allowed
</p>
</li>
<li><p> Number of rows in dataframe of detector covariates differs from expected
</p>
</li>
<li><p> Number of detectors in usage matrix differs from expected
</p>
</li>
<li><p> Occasions with no used detectors
</p>
</li>
<li><p> Polygons overlap
</p>
</li>
<li><p> Polygons concave east-west (&lsquo;polygon&rsquo; detectors)
</p>
</li>
<li><p> PolyID missing or not factor
</p>
</li>
<li><p> Polygon detector is concave in east-west direction
</p>
</li>
<li><p> Levels of factor trap covariate(s) differ between sessions
</p>
</li></ol>

<p><code>verify.mask</code>
</p>

<ol>
<li><p> Valid x and y coordinates
</p>
</li>
<li><p> Number of rows in covariates dataframe differs from expected
</p>
</li>
<li><p> Levels of factor mask covariate(s) differ between sessions
</p>
</li></ol>

<p>Earlier errors may mask later errors: fix &amp; re-run.
</p>


<h3>Value</h3>

 
<p>A list with the component <code>errors</code>, a logical value indicating
whether any errors were found. If <code>object</code> contains multi-session
data then session-specific results are contained in a further list
component <code>bysession</code>.
</p>
<p>Full reporting is the same as &lsquo;errors only&rsquo; except that a message is
posted when no errors are found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capthist">capthist</a></code>, <code><a href="#topic+secr.fit">secr.fit</a></code>, <code><a href="#topic+shareFactorLevels">shareFactorLevels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verify(captdata)

## create null (complete) usage matrix, and mess it up
temptraps &lt;- make.grid()
usage(temptraps) &lt;- matrix(1, nr = nrow(temptraps), nc = 5)
usage(temptraps)[,5] &lt;- 0
verify (temptraps)

## create mask, and mess it up
tempmask &lt;- make.mask(temptraps)
verify(tempmask)
tempmask[1,1] &lt;- NA
verify(tempmask)

</code></pre>

<hr>
<h2 id='write.captures'> Write Data to Text File </h2><span id='topic+write.captures'></span><span id='topic+write.traps'></span><span id='topic+write.mask'></span>

<h3>Description</h3>

<p>Export detections or detector layout or mask to a text file in format suitable
for input to DENSITY. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
write.captures(object, file = "", deblank = TRUE, header = TRUE,
    append = FALSE, sess = "1", ndec = 2, covariates = FALSE, tonumeric
    = TRUE, ...)

write.traps(object, file = "", deblank = TRUE,  header = TRUE,
    ndec = 2, covariates = FALSE, ...)

write.mask(object, file = "", header = TRUE, ndec = 2, covariates = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.captures_+3A_object">object</code></td>
<td>
 <p><code>capthist</code> or <code>traps</code> object </p>
</td></tr>
<tr><td><code id="write.captures_+3A_file">file</code></td>
<td>
<p> character name of output file </p>
</td></tr>
<tr><td><code id="write.captures_+3A_deblank">deblank</code></td>
<td>
<p> logical; if TRUE remove any blanks from character string used to identify detectors </p>
</td></tr>
<tr><td><code id="write.captures_+3A_header">header</code></td>
<td>
<p> logical; if TRUE output descriptive header </p>
</td></tr>
<tr><td><code id="write.captures_+3A_append">append</code></td>
<td>
<p> logical; if TRUE output is appended to an existing file </p>
</td></tr>
<tr><td><code id="write.captures_+3A_sess">sess</code></td>
<td>
<p> character session identifier </p>
</td></tr>
<tr><td><code id="write.captures_+3A_ndec">ndec</code></td>
<td>
<p> number of digits after decimal point for x,y coordinates </p>
</td></tr>
<tr><td><code id="write.captures_+3A_covariates">covariates</code></td>
<td>
<p> logical or a character vector of covariates to
export </p>
</td></tr>
<tr><td><code id="write.captures_+3A_tonumeric">tonumeric</code></td>
<td>
<p> logical for whether factor and character covariates should be
converted to numeric values on output</p>
</td></tr>
<tr><td><code id="write.captures_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code>write.table</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Existing file will be replaced without warning if <code>append =
  FALSE</code>. In the case of a multi-session capthist file, session names
are taken from <code>object</code> rather than <code>sess</code>.
</p>
<p><code><a href="#topic+write.capthist">write.capthist</a></code> is generally simpler to use if you want to export
both the capture data and trap layout from a <code>capthist</code> object.
</p>
<p>By default individual covariates are not exported. When exported they
are repeated for each detection of an individual. Factor covariates
are coerced to numeric before export.
</p>
<p>For <code>write.mask</code>, <code>header = TRUE</code> also causes column names to be exposed.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.capthist">as.data.frame.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  write.captures (captdata)

</code></pre>

<hr>
<h2 id='writeGPS'>
Upload to GPS
</h2><span id='topic+writeGPS'></span>

<h3>Description</h3>

<p>Upload a set of point locations as waypoints to a GPS unit connected
by USB or via a serial port. Intended primarily for detector locations
in a traps object. Uses the GPSBabel package which must have been
installed. Coordinates are first inverse-projected to latitude and
longitude using function <code><a href="sf.html#topic+st_transform">st_transform</a></code> from <span class="pkg">sf</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
writeGPS(xy, o = "garmin", F = "usb:", proj = "+proj=nzmg")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeGPS_+3A_xy">xy</code></td>
<td>
<p>2-column matrix or dataframe of x-y coordinates</p>
</td></tr>
<tr><td><code id="writeGPS_+3A_o">o</code></td>
<td>
<p>character output format (see GPSBabel documentation)</p>
</td></tr>
<tr><td><code id="writeGPS_+3A_f">F</code></td>
<td>
<p>character for destination (see Details)</p>
</td></tr>
<tr><td><code id="writeGPS_+3A_proj">proj</code></td>
<td>
<p>character string describing projection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is derived in part from <code>readGPS</code> in <span class="pkg">maptools</span>.
</p>
<p>For users of Garmin GPS units, useful values of <code>o</code> are &quot;garmin&quot;
for direct upload via USB or serial ports, and &quot;gdb&quot; for a file in
Mapsource database format.
</p>
<p><code>F</code> may be &quot;usb:&quot; or &quot;com4:&quot; etc. for upload via USB or serial
ports, or the name of a file to create.
</p>
<p>The <code>proj</code> argument may be complex. For further information see the
Examples and the vignette 
<a href="https://www.otago.ac.nz/density/pdfs/secr-spatialdata.pdf">secr-spatialdata.pdf</a>.
If <code>proj</code> is an empty string then coordinates are assumed already to
be latitudes (column 1) and longitudes (column 2).
</p>
<p>Waypoint names are derived from the rownames of <code>xy</code>.
</p>


<h3>Value</h3>

<p>No value is returned. The effect is to upload waypoints to an attached
GPS or file. 
</p>


<h3>Note</h3>

<p>GPSBabel is available free from
<a href="https://www.gpsbabel.org/">https://www.gpsbabel.org/</a>. Remember to add it to the Path. On
Windows this means following something like Settings &gt; Control panel &gt;
System &gt; Advanced settings &gt; Environment variables &gt; (select Path) Edit
and adding &quot;;C:/Program Files (x86)/gpsbabel&quot; to the end (without the
quotes). Or &quot;;C:/Program Files/gpsbabel&quot; on 32-bit systems.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.systematic">make.systematic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example using shapefile "possumarea.shp" in
## "extdata" folder. As 'cluster' is not specified,
## the grid comprises single multi-catch detectors.

## Not run: 

## test for availability of GPSBabel

if (nzchar(Sys.which("gpsbabel"))) {

library(sf)
shpfilename &lt;- system.file("extdata/possumarea.shp", package = "secr")
possumarea &lt;- st_read(shpfilename)

possumgrid &lt;- make.systematic(spacing = 100, region = possumarea, 
    plt = TRUE)

## May upload directly to GPS...
# writeGPS(possumgrid, proj = "+proj=nzmg")

## ...or save as Mapsource file
writeGPS(possumgrid, o = "gdb", F = "tempgrid.gdb",
    proj = "+proj=nzmg")

## If `region' had been specified in another projection we
## would need to specify this as in Proj.4. Here is a
## hypothetical example for New Zealand Transverse Mercator
## with datum NZGD2000 (EPSG:2193)

NZTM &lt;- paste("+proj=tmerc +lat_0=0 +lon_0=173 +k=0.9996",
    "+x_0=1600000 +y_0=10000000 +ellps=GRS80",
    " +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")

# writeGPS(possumgridNZTM, o = "gdb", F = "tempNZTM.txt", 
#    proj = NZTM)

## Or to upload coordinates from UTM Zone 18 in eastern
## Maryland, USA...

# writeGPS(MarylandUTMgrid, proj = 
#    "+proj=utm +zone=18 +ellps=WGS84")

}


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
