<!DOCTYPE html><html lang="en"><head><title>Help for package doRedis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {doRedis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#doRedis-package'><p>A Redis parallel back end for foreach.</p></a></li>
<li><a href='#.doRedis'><p>internal function called by foreach</p></a></li>
<li><a href='#jobs'><p>List doRedis jobs</p></a></li>
<li><a href='#logger'><p>Print a timestamped message to the  standard error stream.</p></a></li>
<li><a href='#redisConnect'><p>Explicitly connect to a Redis server.</p></a></li>
<li><a href='#redisDelete'><p>A convenience function to delete a Redis key</p></a></li>
<li><a href='#redisGet'><p>A convenience function to return an R value from a Redis key.</p></a></li>
<li><a href='#redisSet'><p>A convenience function to set an R value in a Redis key</p></a></li>
<li><a href='#redisWorker'><p>Initialize a doRedis worker process.</p></a></li>
<li><a href='#registerDoRedis'><p>Register the Redis back end for foreach.</p></a></li>
<li><a href='#removeJob'><p>Remove Redis keys associated with one or more doRedis jobs</p></a></li>
<li><a href='#removeQueue'><p>Remove a doRedis queue and delete all associated keys from Redis.</p></a></li>
<li><a href='#setChunkSize'><p>Set the default granularity of distributed tasks.</p></a></li>
<li><a href='#setExport'><p>Manually add symbol names to the worker environment export list.</p></a></li>
<li><a href='#setFtinterval'><p>Set the fault tolerance check interval in seconds.</p></a></li>
<li><a href='#setPackages'><p>Manually set package names in the worker environment package list.</p></a></li>
<li><a href='#setProgress'><p>Progress bar</p></a></li>
<li><a href='#startLocalWorkers'><p>Start one or more background R worker processes on the local system.</p></a></li>
<li><a href='#tasks'><p>List running doRedis tasks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'Foreach' Parallel Adapter Using the 'Redis' Database</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-5-1</td>
</tr>
<tr>
<td>Author:</td>
<td>B. W. Lewis &lt;blewis@illposed.net&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>B. W. Lewis &lt;blewis@illposed.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Create and manage fault-tolerant task queues for the 'foreach' package using the 'Redis' key/value database.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bwlewis/doRedis/issues">https://github.com/bwlewis/doRedis/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), foreach(&ge; 1.3.0), iterators(&ge; 1.0.0), utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>redux, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-02 01:25:00 UTC; blewis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-02 11:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='doRedis-package'>A Redis parallel back end for foreach.</h2><span id='topic+doRedis-package'></span>

<h3>Description</h3>

<p>The doRedis package imlpements an elastic parallel back end
for foreach using the Redis key/value database.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerDoRedis">registerDoRedis</a></code>, <code><a href="#topic+startLocalWorkers">startLocalWorkers</a></code>
</p>

<hr>
<h2 id='.doRedis'>internal function called by foreach</h2><span id='topic+.doRedis'></span>

<h3>Description</h3>

<p>internal function called by foreach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.doRedis(obj, expr, envir, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".doRedis_+3A_obj">obj</code></td>
<td>
<p>a foreach object</p>
</td></tr>
<tr><td><code id=".doRedis_+3A_expr">expr</code></td>
<td>
<p>the expression to evaluate</p>
</td></tr>
<tr><td><code id=".doRedis_+3A_envir">envir</code></td>
<td>
<p>the expression environment</p>
</td></tr>
<tr><td><code id=".doRedis_+3A_data">data</code></td>
<td>
<p>a list of parameters from registerDoRedis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the foreach result
</p>

<hr>
<h2 id='jobs'>List doRedis jobs</h2><span id='topic+jobs'></span>

<h3>Description</h3>

<p>List doRedis jobs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jobs(queue = "*")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jobs_+3A_queue">queue</code></td>
<td>
<p>List jobs for the specified queue, or set to &quot;*&quot; to list jobs for all queues</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame listing jobs by row with variables queue, id, user, host and time (submitted).
</p>

<hr>
<h2 id='logger'>Print a timestamped message to the  standard error stream.</h2><span id='topic+logger'></span>

<h3>Description</h3>

<p>Use to help debug remote doRedis workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger(msg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logger_+3A_msg">msg</code></td>
<td>
<p>a character message to print to the standard error stream</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The character message that was printed, decorated with time and system info.
</p>

<hr>
<h2 id='redisConnect'>Explicitly connect to a Redis server.</h2><span id='topic+redisConnect'></span>

<h3>Description</h3>

<p>This function is normally not needed, use the redux package functions instead,
or simply registerDoRedis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redisConnect(host = "localhost", port = 6379L, password, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redisConnect_+3A_host">host</code></td>
<td>
<p>character Redis host name</p>
</td></tr>
<tr><td><code id="redisConnect_+3A_port">port</code></td>
<td>
<p>integer Redis port number</p>
</td></tr>
<tr><td><code id="redisConnect_+3A_password">password</code></td>
<td>
<p>optional character Redis password</p>
</td></tr>
<tr><td><code id="redisConnect_+3A_...">...</code></td>
<td>
<p>optional additional arguments for compatability with old rredis, ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+registerDoRedis">registerDoRedis</a></code>, <code><a href="#topic+redisWorker">redisWorker</a></code>, <code><a href="#topic+startLocalWorkers">startLocalWorkers</a></code>
</p>

<hr>
<h2 id='redisDelete'>A convenience function to delete a Redis key</h2><span id='topic+redisDelete'></span>

<h3>Description</h3>

<p>A convenience function to delete a Redis key
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redisDelete(key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redisDelete_+3A_key">key</code></td>
<td>
<p>(character or raw) Redis key name to delete</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Redis status message
</p>


<h3>See Also</h3>

<p><code>hiredis</code>
</p>

<hr>
<h2 id='redisGet'>A convenience function to return an R value from a Redis key.</h2><span id='topic+redisGet'></span>

<h3>Description</h3>

<p>This function assumes the value associated with the Redis key
is a serialized (binary) R value and unserializes it on return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redisGet(key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redisGet_+3A_key">key</code></td>
<td>
<p>(character or raw) Redis key name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Unserialized R value.
</p>


<h3>See Also</h3>

<p><code>hiredis</code>
</p>

<hr>
<h2 id='redisSet'>A convenience function to set an R value in a Redis key</h2><span id='topic+redisSet'></span>

<h3>Description</h3>

<p>This function serializes the val argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redisSet(key, val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redisSet_+3A_key">key</code></td>
<td>
<p>(character or raw) Redis key name</p>
</td></tr>
<tr><td><code id="redisSet_+3A_val">val</code></td>
<td>
<p>R value to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Redis status message
</p>


<h3>See Also</h3>

<p><code>hiredis</code>
</p>

<hr>
<h2 id='redisWorker'>Initialize a doRedis worker process.</h2><span id='topic+redisWorker'></span>

<h3>Description</h3>

<p>The redisWorker function enrolls the current R session in one or
more doRedis worker pools specified by the work queue names. The worker
loop takes over the R session until the work queue(s) are deleted, after
which the worker loop exits after the <code>linger</code> period, or until
the worker has processed <code>iter</code> tasks.
Running workers also terminate after network activity with Redis remains
inactive for longer than the <code>timeout</code> period set in the <code>redisConnect</code>
function. That value defaults internally to 30 seconds in <code>redisWorker</code>.
You can increase it by including a timeout=n argument value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redisWorker(
  queue,
  host = "localhost",
  port = 6379,
  iter = Inf,
  linger = 30,
  log = stderr(),
  connected = FALSE,
  password = NULL,
  loglevel = 0,
  timelimit = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redisWorker_+3A_queue">queue</code></td>
<td>
<p>work queue name or a vector of queue names</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_host">host</code></td>
<td>
<p>Redis database host name or IP address</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_port">port</code></td>
<td>
<p>Redis database port number</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_iter">iter</code></td>
<td>
<p>maximum number of tasks to process before exiting the worker loop</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_linger">linger</code></td>
<td>
<p>timeout in seconds after which the work queue is deleted that the worker terminates</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_log">log</code></td>
<td>
<p>print messages to the specified file connection</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_connected">connected</code></td>
<td>
<p>set to <code>TRUE</code> to reuse an existing open connection to Redis, otherwise establish a new one</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_password">password</code></td>
<td>
<p>optional Redis database password</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_loglevel">loglevel</code></td>
<td>
<p>set to &gt; 0 to increase verbosity in the log</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_timelimit">timelimit</code></td>
<td>
<p>set to &gt; 0 to specify a task time limit in seconds, after which worker processes are killed; beware that setting this value &gt; 0 will terminate any R worker process if their task takes too long.</p>
</td></tr>
<tr><td><code id="redisWorker_+3A_...">...</code></td>
<td>
<p>Optional additional parameters passed to <code><a href="#topic+redisConnect">redisConnect</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL is invisibly returned.
</p>


<h3>Note</h3>

<p>The worker connection to Redis uses a TCP timeout value of 30 seconds by
default. That means that the worker will exit after about 30 seconds of inactivity.
If you want the worker to remain active for longer periods, set the <code>timeout</code>
option to a larger value.
</p>
<p>Use the <code>linger</code> option to instruct the worker to linger for up to the indicated
number of seconds after the listening work queue has been removed. After at most that
interval, the worker will exit after removing the queue.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerDoRedis">registerDoRedis</a></code>, <code><a href="#topic+startLocalWorkers">startLocalWorkers</a></code>
</p>

<hr>
<h2 id='registerDoRedis'>Register the Redis back end for foreach.</h2><span id='topic+registerDoRedis'></span>

<h3>Description</h3>

<p>The doRedis package imlpements a simple but flexible parallel back end
for foreach that uses Redis for inter-process communication. The work
queue name specifies the base name of a small set of Redis keys that the
coordinator and worker processes use to exchange data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerDoRedis(
  queue,
  host = "localhost",
  port = 6379,
  password,
  ftinterval = 30,
  chunkSize = 1,
  progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="registerDoRedis_+3A_queue">queue</code></td>
<td>
<p>A work queue name</p>
</td></tr>
<tr><td><code id="registerDoRedis_+3A_host">host</code></td>
<td>
<p>The Redis server host name or IP address</p>
</td></tr>
<tr><td><code id="registerDoRedis_+3A_port">port</code></td>
<td>
<p>The Redis server port number</p>
</td></tr>
<tr><td><code id="registerDoRedis_+3A_password">password</code></td>
<td>
<p>An optional Redis database password</p>
</td></tr>
<tr><td><code id="registerDoRedis_+3A_ftinterval">ftinterval</code></td>
<td>
<p>Default fault tolerance interval in seconds</p>
</td></tr>
<tr><td><code id="registerDoRedis_+3A_chunksize">chunkSize</code></td>
<td>
<p>Default iteration granularity, see <code><a href="#topic+setChunkSize">setChunkSize</a></code></p>
</td></tr>
<tr><td><code id="registerDoRedis_+3A_progress">progress</code></td>
<td>
<p>(logical) Show progress bar for computations?</p>
</td></tr>
<tr><td><code id="registerDoRedis_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+redisConnect">redisConnect</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Back-end worker R processes  advertise their availablility for work
with the <code><a href="#topic+redisWorker">redisWorker</a></code> function.
</p>
<p>The doRedis parallel back end tolerates faults among the worker processes and
automatically resubmits failed tasks. It is also portable and supports
heterogeneous sets of workers, even across operative systems.  The back end
supports dynamic pools of worker processes.  New workers may be added to work
queues at any time and can be used by running foreach computations.
</p>


<h3>Value</h3>

<p><code>NULL</code> is invisibly returned; this function is called for side effect of registering a foreach backend.
</p>


<h3>Note</h3>

<p>All doRedis functions require access to a Redis database server (not included
with this package).
</p>
<p>Worker processes default to same random number generator as
the coordinator process by default with seeds set per iteration rather than per
worker to yield reproducible output independent of the number of worker
processes. The L'Ecuyer-CMRG RNG available from the parallel package is
recommended when high-quality distributed pseudorandom numbers are needed.
See package vignette for more details and additional options.
</p>
<p>Avoid using fork-based parallel functions within doRedis expressions.
Use of <code>mclapply</code> and similar functions in the body of a doRedis foreach
loop can result in worker faults.
</p>


<h3>See Also</h3>

<p><code>foreach</code>, <code><a href="#topic+doRedis-package">doRedis-package</a></code>, <code><a href="#topic+setChunkSize">setChunkSize</a></code>, <code><a href="#topic+removeQueue">removeQueue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only run if a Redis server is running
if (redux::redis_available()) {
## The example assumes that a Redis server is running on the local host
## and standard port.

# 1. Start a single local R worker process
startLocalWorkers(n=1, queue="jobs", linger=1)

# 2. Run a simple sampling approximation of pi:
registerDoRedis("jobs")
pie = foreach(j=1:10, .combine=sum, .multicombine=TRUE) %dopar%
        4 * sum((runif(1000000) ^ 2 + runif(1000000) ^ 2) &lt; 1) / 10000000
removeQueue("jobs")
print(pie)

# Note that removing the work queue automatically terminates worker processes.
}

</code></pre>

<hr>
<h2 id='removeJob'>Remove Redis keys associated with one or more doRedis jobs</h2><span id='topic+removeJob'></span>

<h3>Description</h3>

<p>Remove Redis keys associated with one or more doRedis jobs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeJob(job)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeJob_+3A_job">job</code></td>
<td>
<p>Either a named character vector with &quot;queue&quot; and &quot;id&quot; entries corresponding to a doRedis
job queue and job id, or a list with equal-length &quot;queue&quot; and &quot;id&quot; entries, or a data frame with
&quot;queue&quot; and &quot;id&quot; entries, for example as returned by <code><a href="#topic+jobs">jobs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> is invisibly returned; this function is used for its side effect&ndash;in particular, removing all Redis keys associated with the specified job.
</p>

<hr>
<h2 id='removeQueue'>Remove a doRedis queue and delete all associated keys from Redis.</h2><span id='topic+removeQueue'></span>

<h3>Description</h3>

<p>Removing a doRedis queue cleans up associated keys in the Redis
database and signals to workers listening on the queue to terminate.
Workers terminate after their timeout period after their work
queue is deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeQueue(queue)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeQueue_+3A_queue">queue</code></td>
<td>
<p>the doRedis queue name</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> is invisibly returned; this function is called for the side effect of removing
Redis keys associated with the specified queue.
</p>


<h3>Note</h3>

<p>Workers listening for work on more than one queue will only
terminate after all their queues have been deleted. See <code><a href="#topic+registerDoRedis">registerDoRedis</a></code>
for an example.
</p>

<hr>
<h2 id='setChunkSize'>Set the default granularity of distributed tasks.</h2><span id='topic+setChunkSize'></span>

<h3>Description</h3>

<p>A job is the collection of all tasks in a foreach loop.
A task is a collection of loop iterations of at most size <code>chunkSize</code>.
R workers are assigned work by task in blocks of at most
<code>chunkSize</code> loop iterations per task.
The default value is one iteration per task.
Setting the default chunk size larger for shorter-running jobs can
substantially improve performance. Setting this value too high can
negatively impact load-balancing across workers, however.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setChunkSize(value = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setChunkSize_+3A_value">value</code></td>
<td>
<p>positive integer chunk size setting</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>value</code> is invisibly returned; this value is called for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only run if a Redis server is running
if (redux::redis_available()) {

# Start a single local R worker process
startLocalWorkers(n=1, queue="jobs", linger=1)

# Register the work queue with the coordinator R process
registerDoRedis("jobs")

# Compare verbose task submission output from...
setChunkSize(1)
foreach(j=1:4, .combine=c, .verbose=TRUE) %dopar% j

# with the verbose task submission output from:
setChunkSize(2)
foreach(j=1:4, .combine=c, .verbose=TRUE) %dopar% j

# Clean up
removeQueue("jobs")
}

</code></pre>

<hr>
<h2 id='setExport'>Manually add symbol names to the worker environment export list.</h2><span id='topic+setExport'></span>

<h3>Description</h3>

<p>The setExport function lets users manually declare symbol names
of corresponding objects that should be exported to workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setExport(names = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setExport_+3A_names">names</code></td>
<td>
<p>A character vector of symbol names to export.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>foreach</code> function includes a similar <code>.export</code> parameter.
</p>
<p>We provide this supplemental export option for users without direct access
to the <code>foreach</code> function, for example, when <code>foreach</code> is used
inside another package.
</p>


<h3>Value</h3>

<p>The value of <code>names</code> is invisibly returned (this function is used ofr its side effect).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
registerDoRedis("work queue")
startLocalWorkers(n=1, queue="work queue", linger=1)

f &lt;- function() pi

(foreach(1) %dopar% tryCatch(eval(call("f")), error = as.character))
# Returns the error converted to a message:
# Error in eval(call("f")) : task 1 failed - could not find function "f"

# Manually export the symbol f:
setExport("f")
(foreach(1) %dopar% eval(call("f")))
# Now f is found.

removeQueue("work queue")

## End(Not run)

</code></pre>

<hr>
<h2 id='setFtinterval'>Set the fault tolerance check interval in seconds.</h2><span id='topic+setFtinterval'></span>

<h3>Description</h3>

<p>Failed tasks are automatically re-submitted to the work queue.
The <code>setFtinterval</code> sets an upper bound on how frequently
the system checks for failure. See the package vignette for
discussion and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFtinterval(value = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setFtinterval_+3A_value">value</code></td>
<td>
<p>positive integer number of seconds</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>value</code> is invisibly returned (this function is used for its side effect).
</p>

<hr>
<h2 id='setPackages'>Manually set package names in the worker environment package list.</h2><span id='topic+setPackages'></span>

<h3>Description</h3>

<p>The <code>setPackages</code> function lets users manually declare packages
that R worker processes need to load before running their tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPackages(packages = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPackages_+3A_packages">packages</code></td>
<td>
<p>A character vector of package names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>foreach</code> function includes a similar <code>.packages</code> parameter.
</p>
<p>Defines a way to set the foreach <code>.packages</code> option for users without direct access
to the <code>foreach</code> function, for example, when <code>foreach</code> is used
inside another package.
</p>


<h3>Value</h3>

<p>The value of <code>packages</code> is invisibly returned (this function is used for its side effect).
</p>

<hr>
<h2 id='setProgress'>Progress bar</h2><span id='topic+setProgress'></span>

<h3>Description</h3>

<p>Progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setProgress(value = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setProgress_+3A_value">value</code></td>
<td>
<p>if <code>TRUE</code>, display a text progress bar indicating status of the computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>value</code> is invisibly returned (this function is used for its side effect).
</p>

<hr>
<h2 id='startLocalWorkers'>Start one or more background R worker processes on the local system.</h2><span id='topic+startLocalWorkers'></span>

<h3>Description</h3>

<p>Use <code>startLocalWorkers</code> to start one or more doRedis R worker processes
in the background. The worker processes are started on the local system using
the <code>redisWorker</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startLocalWorkers(
  n,
  queue,
  host = "localhost",
  port = 6379,
  iter = Inf,
  linger = 30,
  log = stdout(),
  Rbin = paste(R.home(component = "bin"), "R", sep = "/"),
  password,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startLocalWorkers_+3A_n">n</code></td>
<td>
<p>number of workers to start</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_queue">queue</code></td>
<td>
<p>work queue name</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_host">host</code></td>
<td>
<p>Redis database host name or IP address</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_port">port</code></td>
<td>
<p>Redis database port number</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_iter">iter</code></td>
<td>
<p>maximum number of tasks to process before exiting the worker loop</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_linger">linger</code></td>
<td>
<p>timeout in seconds after which the work queue is deleted that the worker terminates</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_log">log</code></td>
<td>
<p>print messages to the specified file connection</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_rbin">Rbin</code></td>
<td>
<p>full path to the command-line R program</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_password">password</code></td>
<td>
<p>optional Redis database password</p>
</td></tr>
<tr><td><code id="startLocalWorkers_+3A_...">...</code></td>
<td>
<p>optional additional parameters passed to the <code><a href="#topic+redisWorker">redisWorker</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Running workers self-terminate after a <code>linger</code> period if their work queues are deleted with the
<code>removeQueue</code> function, or when network activity with Redis remains
inactive for longer than the <code>timeout</code> period set in the <code>redisConnect</code>
function. That value defaults internally to 3600 (one hour) in <code>startLocalWorkers</code>.
You can increase it by including a timeout=n argument value.
</p>


<h3>Value</h3>

<p>NULL is invisibly returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerDoRedis">registerDoRedis</a></code>, <code><a href="#topic+redisWorker">redisWorker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only run if a Redis server is running
if (redux::redis_available()) {
## The example assumes that a Redis server is running on the local host
## and standard port.

# Start a single local R worker process
startLocalWorkers(n=1, queue="R jobs", linger=1)

# Run a simple sampling approximation of pi:
registerDoRedis("R jobs")
print(foreach(j=1:10, .combine=sum, .multicombine=TRUE) %dopar%
        4 * sum((runif(1000000) ^ 2 + runif(1000000) ^ 2) &lt; 1) / 10000000)

# Clean up
removeQueue("R jobs")
}

</code></pre>

<hr>
<h2 id='tasks'>List running doRedis tasks</h2><span id='topic+tasks'></span>

<h3>Description</h3>

<p>List running doRedis tasks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tasks(queue = "*", id = "*")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tasks_+3A_queue">queue</code></td>
<td>
<p>List jobs for the specified queue, or set to &quot;*&quot; to list jobs for all queues</p>
</td></tr>
<tr><td><code id="tasks_+3A_id">id</code></td>
<td>
<p>List tasks for the specified job id, or set to &quot;*&quot; to list tasks for all job ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame listing jobs by row with variables queue, id, user, coordinator, time, iter, host, pid (see Note)
</p>


<h3>Note</h3>

<p>The returned values indicate
</p>

<ol>
<li> <p><code>queue</code> the doRedis queue name
</p>
</li>
<li> <p><code>id</code> the doRedis job id
</p>
</li>
<li> <p><code>user</code> the user running the job
</p>
</li>
<li> <p><code>coordinator</code> the host name or I.P. address where the job was submitted (and the coordinator R process runs)
</p>
</li>
<li> <p><code>time</code> system time on the worker node when the task was started
</p>
</li>
<li> <p><code>iter</code> the loop iterations being run by the task
</p>
</li>
<li> <p><code>host</code> the host name or I.P. address where the task is running
</p>
</li>
<li> <p><code>pid</code> the process ID of the R worker running the task on <code>host</code>
</p>
</li></ol>

<p>Tasks are listed until a key associated with them expires in Redis. Thus running tasks
are not explicitly removed from the task list immediately when they terminate, but may
linger on the list for a short while after (a few seconds).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
