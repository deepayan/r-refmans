<!DOCTYPE html><html><head><title>Help for package growth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {growth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#carma'><p>Continuous ARMA for Unequally Spaced Repeated Measurements</p></a></li>
<li><a href='#corgram'><p>Calculate and Plot a Correlogram</p></a></li>
<li><a href='#elliptic'><p>Nonlinear Multivariate Elliptically-contoured Repeated Measurements Models</p>
with AR(1) and Two Levels of Variance Components</a></li>
<li><a href='#pergram'><p>Calculate and Plot a Periodogram</p></a></li>
<li><a href='#potthoff'><p>Potthoff and Roy Growth Curve Model</p></a></li>
<li><a href='#rmaov'><p>Split-plot ANOVA Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Normal and Elliptically-Contoured Repeated
Measurements Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.4), rmutil</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting various normal theory (growth
    curve) and elliptically-contoured repeated measurements models
    with ARMA and random effects dependence.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.commanster.eu/rcode.html">http://www.commanster.eu/rcode.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/swihart/growth/issues">https://github.com/swihart/growth/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-04 17:03:32 UTC; swihartbj</td>
</tr>
<tr>
<td>Author:</td>
<td>Bruce Swihart [cre, aut],
  Jim Lindsey [aut] (Jim created this package, Bruce is maintaining the
    CRAN version)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bruce Swihart &lt;bruce.swihart@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-04 17:23:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='carma'>Continuous ARMA for Unequally Spaced Repeated Measurements</h2><span id='topic+carma'></span><span id='topic+fitted.carma'></span><span id='topic+mprofile.carma'></span><span id='topic+residuals.carma'></span><span id='topic+coef.carma'></span><span id='topic+deviance.carma'></span><span id='topic+print.carma'></span>

<h3>Description</h3>

<p><code>carma</code> is designed to handle a polynomial within subject design matrix
with unequally spaced observations which can be at different times for
different subjects. The origin of time is taken as the mean time of all the
subjects. The within subject errors are assumed to be independent Gaussian
or have a continuous time ARMA(p,q) Gaussian structure with the option to
include measurement error. The between subject random coefficients are
assumed to have an arbitrary covariance matrix. The fixed effect design
matrix is a polynomial of equal or higher order than the within subject
design matrix. This matrix can be augmented by covariates multiplied by
polynomial design matrices of any order up to the order of the first
partition of the design matrix. The method is based on exact maximum
likelihood using the Kalman filter to calculate the likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carma(response = NULL, ccov = NULL, times = NULL, torder = 0,
  interaction, arma = c(0, 0, 0), parma = NULL, pre = NULL,
  position = NULL, iopt = TRUE, resid = TRUE,
  transform = "identity", delta = NULL, envir = parent.frame(),
  print.level = 0, typsize = abs(p), ndigit = 10, gradtol = 1e-05,
  steptol = 1e-05, iterlim = 100, fscale = 1, stepmax = 10 * sqrt(p
  %*% p))

## S3 method for class 'carma'
coef(object, ...)

## S3 method for class 'carma'
deviance(object, ...)

## S3 method for class 'carma'
residuals(object, recursive = TRUE, ...)

## S3 method for class 'carma'
print(x, digits = max(3, .Options$digits - 3),
  correlation = TRUE, ...)

## S3 method for class 'carma'
mprofile(z, times = NULL, ccov, plotse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carma_+3A_response">response</code></td>
<td>
<p>A list of two column matrices with response values and times
for each individual, one matrix or dataframe of response values, or an
object of either class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to be
used here.</p>
</td></tr>
<tr><td><code id="carma_+3A_ccov">ccov</code></td>
<td>
<p>A matrix of columns of baseline covariates with one row per
individual, a model formula using vectors of the same size, or an object of
class, <code>tccov</code> (created by <code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>). If response
has class, <code>repeated</code>, the covariates must be specified as a Wilkinson
and Rogers formula unless none are to be used.</p>
</td></tr>
<tr><td><code id="carma_+3A_times">times</code></td>
<td>
<p>When response is a matrix, a vector of possibly unequally
spaced times when they are the same for all individuals or a matrix of
times. Not necessary if equally spaced. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="carma_+3A_torder">torder</code></td>
<td>
<p>Order of the polynomial in time to be fitted.</p>
</td></tr>
<tr><td><code id="carma_+3A_interaction">interaction</code></td>
<td>
<p>Vector indicating order of interactions of covariates
with time.</p>
</td></tr>
<tr><td><code id="carma_+3A_arma">arma</code></td>
<td>
<p>Vector of three values: order of AR, order of MA, binary
indicator for presence of measurement error. Not required for an AR(1) if an
initial estimate is supplied. If only one value is supplied, it is assumed
to be the order of the AR.</p>
</td></tr>
<tr><td><code id="carma_+3A_parma">parma</code></td>
<td>
<p>Initial estimates of ARMA parameters. For example, with
<code>arma=c(1,0,0)</code>, an AR(1), the parameter is <code>parma[1]=log(theta)</code>,
where <code>theta</code> is the positive, continuous time autoregressive
coefficient. The finite step autoregression coefficient for a step of length
<code>delta</code> is then <code>alpha=exp(-delta*theta)</code> i.e.
<code>alpha=exp(-delta*exp(parma[1]))</code>.</p>
</td></tr>
<tr><td><code id="carma_+3A_pre">pre</code></td>
<td>
<p>Initial estimates of random effect parameters.</p>
</td></tr>
<tr><td><code id="carma_+3A_position">position</code></td>
<td>
<p>Two column matrix with rows giving index positions of random
effects in the covariance matrix.</p>
</td></tr>
<tr><td><code id="carma_+3A_iopt">iopt</code></td>
<td>
<p>TRUE if optimization should be performed.</p>
</td></tr>
<tr><td><code id="carma_+3A_resid">resid</code></td>
<td>
<p>TRUE if residuals to be calculated.</p>
</td></tr>
<tr><td><code id="carma_+3A_transform">transform</code></td>
<td>
<p>Transformation of the response variable: <code>identity</code>,
<code>exp</code>, <code>square</code>, <code>sqrt</code>, or <code>log</code>.</p>
</td></tr>
<tr><td><code id="carma_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement for each
response value, set to unity by default. For example, if a response is
measured to two decimals, <code>delta=0.01</code>. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="carma_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="carma_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="carma_+3A_object">object</code></td>
<td>
<p>An object of class, <code>carma</code>.</p>
</td></tr>
<tr><td><code id="carma_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="carma_+3A_recursive">recursive</code></td>
<td>
<p>If TRUE, recursive residuals or fitted values are given;
otherwise, marginal ones.</p>
</td></tr>
<tr><td><code id="carma_+3A_x">x</code></td>
<td>
<p>An object of class, <code>carma</code>.</p>
</td></tr>
<tr><td><code id="carma_+3A_digits">digits</code></td>
<td>
<p>number of digits to print.</p>
</td></tr>
<tr><td><code id="carma_+3A_correlation">correlation</code></td>
<td>
<p>logical; print correlations.</p>
</td></tr>
<tr><td><code id="carma_+3A_z">z</code></td>
<td>
<p>An object of class, <code>carma</code>.</p>
</td></tr>
<tr><td><code id="carma_+3A_plotse">plotse</code></td>
<td>
<p>Plot the standard errors around the marginal profile curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For clustered (non-longitudinal) data, where only random effects will be
fitted, <code>times</code> are not necessary.
</p>
<p>Marginal and individual profiles can be plotted using
<code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and <code><a href="rmutil.html#topic+iprofile">iprofile</a></code> and
residuals with <code><a href="rmutil.html#topic+plot.residuals">plot.residuals</a></code>.
</p>
<p>For any ARMA of order superior to an AR(1), the (complex) roots of the
characteristic equation are printed out; see Jones and Ackerson (1991) for
their use in calculation of the covariance function.
</p>


<h3>Value</h3>

<p>A list of class <code>carma</code> is returned that contains all of the
relevant information calculated, including error codes.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>coef</code>: Coefficients
</p>
</li>
<li> <p><code>deviance</code>: Deviance
</p>
</li>
<li> <p><code>residuals</code>: Residuals
</p>
</li>
<li> <p><code>print</code>: Print method
</p>
</li>
<li> <p><code>mprofile</code>: Special marginal profiles with SEs
</p>
</li></ul>


<h3>Author(s)</h3>

<p>R.H. Jones and J.K. Lindsey
</p>


<h3>References</h3>

<p>Jones, R. H. and Ackerson, L. M. (1991) Serial correlation in
unequally spaced longitudinal data. Biometrika, 77, 721-731.
</p>
<p>Jones, R.H. (1993) Longitudinal Data Analysis with Serial Correlation: A
State-space Approach. Chapman and Hall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elliptic">elliptic</a></code>, <code><a href="repeated.html#topic+gar">gar</a></code>,
<code><a href="repeated.html#topic+gnlmix">gnlmix</a></code>, <code><a href="repeated.html#topic+glmm">glmm</a></code>,
<code><a href="repeated.html#topic+gnlmm">gnlmm</a></code>, <code><a href="rmutil.html#topic+iprofile">iprofile</a></code>,
<code><a href="repeated.html#topic+kalseries">kalseries</a></code>, <code><a href="rmutil.html#topic+mprofile">mprofile</a></code>,
<code><a href="rmutil.html#topic+plot.residuals">plot.residuals</a></code>, <code><a href="#topic+potthoff">potthoff</a></code>,
<code><a href="rmutil.html#topic+read.list">read.list</a></code>, <code><a href="rmutil.html#topic+restovec">restovec</a></code>,
<code><a href="rmutil.html#topic+rmna">rmna</a></code>, <code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>,
<code><a href="rmutil.html#topic+tvctomat">tvctomat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- matrix(rnorm(40),ncol=5)
x1 &lt;- gl(2,4)
x2 &lt;- gl(2,1,8)
# independence with time trend
carma(y, ccov=~x1, torder=2)
# AR(1)
carma(y, ccov=~x1, torder=2, arma=c(1,0,0), parma=-0.5)
carma(y, ccov=~x1, torder=3, interact=3, arma=c(1,0,0), parma=-1)
# ARMA(2,1)
carma(y, ccov=~x1+x2, interact=c(2,0), torder=3,arma=c(2,1,0),
	parma=c(0.3,2,0.7))
# random intercept
carma(y, ccov=~x1+x2, interact=c(2,0), torder=3, pre=-0.4, 
	position=c(1,1))
# random coefficients
carma(y, ccov=~x1+x2, interact=c(2,0), torder=3, pre=c(-0.4,0.1), 
	position=rbind(c(1,1),c(2,2)))

</code></pre>

<hr>
<h2 id='corgram'>Calculate and Plot a Correlogram</h2><span id='topic+corgram'></span>

<h3>Description</h3>

<p><code>corgram</code> calculates the values of a correlogram (autocorrelation
function or ACF) and plots it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corgram(y, wt = 1, maxlag = NULL, partial = FALSE, add = FALSE,
  lty = 1, xlim = NULL, ylim = NULL, xlab = NULL, ylab = NULL,
  main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corgram_+3A_y">y</code></td>
<td>
<p>A time series vector.</p>
</td></tr>
<tr><td><code id="corgram_+3A_wt">wt</code></td>
<td>
<p>Indicator vector with zeros for values to be ignored.</p>
</td></tr>
<tr><td><code id="corgram_+3A_maxlag">maxlag</code></td>
<td>
<p>Maximum number of lags for which the correlation is to be
calculated.</p>
</td></tr>
<tr><td><code id="corgram_+3A_partial">partial</code></td>
<td>
<p>If TRUE, the partial autocorrelation function (PACF) is
plotted.</p>
</td></tr>
<tr><td><code id="corgram_+3A_add">add</code></td>
<td>
<p>If TRUE, adds a new correlogram to an existing plot.</p>
</td></tr>
<tr><td><code id="corgram_+3A_lty">lty</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="corgram_+3A_xlim">xlim</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="corgram_+3A_ylim">ylim</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="corgram_+3A_xlab">xlab</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="corgram_+3A_ylab">ylab</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="corgram_+3A_main">main</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="corgram_+3A_...">...</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>corgram</code> returns a two-column matrix containing the (partial)
correlogram coordinates.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rnorm(100)
corgram(y)
corgram(y, partial=TRUE)
</code></pre>

<hr>
<h2 id='elliptic'>Nonlinear Multivariate Elliptically-contoured Repeated Measurements Models
with AR(1) and Two Levels of Variance Components</h2><span id='topic+elliptic'></span><span id='topic+fitted.elliptic'></span><span id='topic+residuals.elliptic'></span><span id='topic+deviance.elliptic'></span><span id='topic+print.elliptic'></span>

<h3>Description</h3>

<p><code>elliptic</code> fits special cases of the multivariate
elliptically-contoured distribution, the multivariate normal, Student t, and
power exponential distributions. The latter includes the multivariate normal
(power=1), a multivariate Laplace (power=0.5), and the multivariate uniform
(power -&gt; infinity) distributions as special cases. As well, another form of
multivariate skew Laplace distribution is also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptic(response = NULL, model = "linear", distribution = "normal",
  times = NULL, dose = NULL, ccov = NULL, tvcov = NULL,
  nest = NULL, torder = 0, interaction = NULL,
  transform = "identity", link = "identity",
  autocorr = "exponential", pell = NULL, preg = NULL, covfn = NULL,
  pvar = var(y), varfn = NULL, par = NULL, pre = NULL,
  delta = NULL, shfn = FALSE, common = FALSE, twins = FALSE,
  envir = parent.frame(), print.level = 0, ndigit = 10,
  gradtol = 1e-05, steptol = 1e-05, iterlim = 100, fscale = 1,
  stepmax = 10 * sqrt(theta %*% theta), typsize = abs(c(theta)))

## S3 method for class 'elliptic'
deviance(object, ...)

## S3 method for class 'elliptic'
fitted(object, recursive = FALSE, ...)

## S3 method for class 'elliptic'
residuals(object, recursive = FALSE, ...)

## S3 method for class 'elliptic'
print(x, digits = max(3, .Options$digits - 3),
  correlation = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptic_+3A_response">response</code></td>
<td>
<p>A list of two or three column matrices with response values,
times, and possibly nesting categories, for each individual, one matrix or
dataframe of response values, or an object of class, <code>response</code>
(created by <code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to be
used here.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_model">model</code></td>
<td>
<p>The model to be fitted for the location. Builtin choices are
(1) <code>linear</code> for linear models with time-varying covariate; if
<code>torder &gt; 0</code>, a polynomial in time is automatically fitted; (2)
<code>logistic</code> for a four-parameter logistic growth curve; (3) <code>pkpd</code>
for a first-order one-compartment pharmacokinetic model. Otherwise, set this
to a function of the parameters or a formula beginning with ~, specifying
either a linear regression function for the location parameter in the
Wilkinson and Rogers notation or a general function with named unknown
parameters that describes the location, returning a vector the same length
as the number of observations, in which case <code>ccov</code> and <code>tvcov</code>
cannot be used.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_distribution">distribution</code></td>
<td>
<p>Multivariate <code>normal</code>, <code>power exponential</code>,
<code>Student t</code>, or skew <code>Laplace</code> distribution. The latter is not an
elliptical distribution. Note that the latter has a different
parametrization of the skew (family) parameter than the univariate skew
Laplace distribution in <code><a href="rmutil.html#topic+dskewlaplace">dskewlaplace</a></code>:
<code class="reqn">skew=\frac{\sigma(1-\nu^2)}{\sqrt{2}\nu}</code>. Here, zero skew yields a symmetric distribution.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_times">times</code></td>
<td>
<p>When <code>response</code> is a matrix, a vector of possibly
unequally spaced times when they are the same for all individuals or a
matrix of times. Not necessary if equally spaced. Ignored if response has
class, <code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_dose">dose</code></td>
<td>
<p>A vector of dose levels for the <code>pkpd model</code>, one per
individual.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_ccov">ccov</code></td>
<td>
<p>A vector or matrix containing time-constant baseline covariates
with one line per individual, a model formula using vectors of the same
size, or an object of class, <code>tccov</code> (created by
<code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>). If response has class, <code>repeated</code>,
with a <code>linear</code>, <code>logistic</code>, or <code>pkpd</code> model, the covariates
must be specified as a Wilkinson and Rogers formula unless none are to be
used. For the <code>pkpd</code> and <code>logistic</code> models, all variables must be
binary (or factor variables) as different values of all parameters are
calculated for all combinations of these variables (except for the logistic
model when a time-varying covariate is present). It cannot be used when
model is a function.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_tvcov">tvcov</code></td>
<td>
<p>A list of vectors or matrices with time-varying covariates for
each individual (one column per variable), a matrix or dataframe of such
covariate values (if only one covariate), or an object of class,
<code>tvcov</code> (created by <code><a href="rmutil.html#topic+tvctomat">tvctomat</a></code>). If times are not
the same as for responses, the list can be created with
<code><a href="rmutil.html#topic+gettvc">gettvc</a></code>. If response has class, <code>repeated</code>, with a
<code>linear</code>, <code>logistic</code>, or <code>pkpd</code> model, the covariates must be
specified as a Wilkinson and Rogers formula unless none are to be used. Only
one time-varying covariate is allowed except for the <code>linear model</code>; if
more are required, set <code>model</code> equal to the appropriate mean function.
This argument cannot be used when model is a function.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_nest">nest</code></td>
<td>
<p>When <code>response</code> is a matrix, a vector of length equal to
the number of responses per individual indicating which responses belong to
which nesting category. Categoriess must be consecutive increasing integers.
This option should always be specified if nesting is present. Ignored if
response has class, <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_torder">torder</code></td>
<td>
<p>When the <code>linear model</code> is chosen, order of the
polynomial in time to be fitted.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_interaction">interaction</code></td>
<td>
<p>Vector of length equal to the number of time-constant
covariates, giving the levels of interactions between them and the
polynomial in time in the <code>linear model</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_transform">transform</code></td>
<td>
<p>Transformation of the response variable: <code>identity</code>,
<code>exp</code>, <code>square</code>, <code>sqrt</code>, or <code>log</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_link">link</code></td>
<td>
<p>Link function for the location: <code>identity</code>, <code>exp</code>,
<code>square</code>, <code>sqrt</code>, or <code>log</code>. For the <code>linear model</code>, if
not the <code>identity</code>, initial estimates of the regression parameters must
be supplied (intercept, polynomial in time, time-constant covariates,
time-varying covariates, in that order).</p>
</td></tr>
<tr><td><code id="elliptic_+3A_autocorr">autocorr</code></td>
<td>
<p>The form of the autocorrelation function: <code>exponential</code>
is the usual <code class="reqn">\rho^{|t_i-t_j|}</code>; <code>gaussian</code> is
<code class="reqn">\rho^{(t_i-t_j)^2}</code>; <code>cauchy</code> is
<code class="reqn">1/(1+\rho(t_i-t_j)^2)</code>; <code>spherical</code> is
<code class="reqn">((|t_i-t_j|\rho)^3-3|t_i-t_j|\rho+2)/2</code>
for <code class="reqn">|t_i-t_j|\leq1/\rho</code> and zero otherwise;
<code>IOU</code> is the integrated Ornstein-Uhlenbeck process, <code class="reqn">(2\rho
\min(t_i,t_j)+\exp(-\rho t_i) </code><code class="reqn">+\exp(-\rho t_j)-1
-\exp(\rho|ti-t_j|))/2\rho^3</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_pell">pell</code></td>
<td>
<p>Initial estimate of the power parameter of the multivariate
power exponential distribution, of the degrees of freedom parameter of the
multivariate Student t distribution, or of the asymmetry parameter of the
multivariate Laplace distribution. If not supplied for the latter, asymmetry
depends on the regression equation in <code>model</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_preg">preg</code></td>
<td>
<p>Initial parameter estimates for the regression model. Only
required for <code>linear model</code> if the <code>link</code> is not the
<code>identity</code> or a variance (dispersion) function is fitted.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_covfn">covfn</code></td>
<td>
<p>Either a function or a formula beginning with ~, specifying how
the covariance depends on covariates: either a linear regression function in
the Wilkinson and Rogers notation or a general function with named unknown
parameters.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_pvar">pvar</code></td>
<td>
<p>Initial parameter estimate for the variance or dispersion. If
more than one value is provided, the log variance/dispersion depends on a
polynomial in time. With the <code>pkpd model</code>, if four values are supplied,
a nonlinear regression for the variance/dispersion is fitted.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_varfn">varfn</code></td>
<td>
<p>The builtin variance (dispersion) function has the
variance/dispersion proportional to a function of the location: pvar*v(mu) =
<code>identity</code> or <code>square</code>. If pvar contains two initial values, an
additive constant is included: pvar(1)+pvar(2)*v(mu). Otherwise, either a
function or a formula beginning with ~, specifying either a linear
regression function in the Wilkinson and Rogers notation or a general
function with named unknown parameters for the log variance can be supplied.
If it contains unknown parameters, the keyword <code>mu</code> may be used to
specify a function of the location parameter.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_par">par</code></td>
<td>
<p>If supplied, an initial estimate for the autocorrelation
parameter.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_pre">pre</code></td>
<td>
<p>Zero, one or two parameter estimates for the variance components,
depending on the number of levels of nesting. If covfn is specified, this
contains the initial estimates of the regression parameters.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement for each
response value, set to unity by default. For example, if a response is
measured to two decimals, <code>delta=0.01</code>. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_shfn">shfn</code></td>
<td>
<p>If TRUE, the supplied variance (dispersion) function depends on
the mean function. The name of this mean function must be the last argument
of the variance/dispersion function.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_common">common</code></td>
<td>
<p>If TRUE, <code>mu</code> and <code>varfn</code> must both be either
functions with, as argument, a vector of parameters having some or all
elements in common between them so that indexing is in common between them
or formulae with unknowns. All parameter estimates must be supplied in
<code>preg</code>. If FALSE, parameters are distinct between the two functions and
indexing starts at one in each function.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_twins">twins</code></td>
<td>
<p>Only possible when there are two observations per individual
(e.g. twin data). If TRUE and <code>covfn</code> is supplied, allows the
covariance to vary across pairs of twins with the diagonal &quot;variance&quot; of the
covariance matrix remaining constant.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_object">object</code></td>
<td>
<p>An object of class, <code>elliptic</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_recursive">recursive</code></td>
<td>
<p>If TRUE, recursive residuals or fitted values are given;
otherwise, marginal ones. In all cases, raw residuals are returned, not
standardized by the standard deviation (which may be changing with
covariates or time).</p>
</td></tr>
<tr><td><code id="elliptic_+3A_x">x</code></td>
<td>
<p>An object of class, <code>elliptic</code>.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_digits">digits</code></td>
<td>
<p>number of digits to print.</p>
</td></tr>
<tr><td><code id="elliptic_+3A_correlation">correlation</code></td>
<td>
<p>logical; print correlations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With two levels of nesting, the first is the individual and the second will
consist of clusters within individuals.
</p>
<p>For clustered (non-longitudinal) data, where only random effects will be
fitted, <code>times</code> are not necessary.
</p>
<p>This function is designed to fit linear and nonlinear models with
time-varying covariates observed at arbitrary time points. A continuous-time
AR(1) and zero, one, or two levels of nesting can be handled. Recall that
zero correlation (all zeros off-diagonal in the covariance matrix) only
implies independence for the multivariate normal distribution.
</p>
<p>Nonlinear regression models can be supplied as formulae where parameters are
unknowns in which case factor variables cannot be used and parameters must
be scalars. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>
<p>Recursive fitted values and residuals are only available for the
multivariate normal distribution with a linear model without a variance
function and with either an AR(1) of <code>exponential</code> form and/or one
level of random effect. In these cases, marginal and individual profiles can
be plotted using <code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and
<code><a href="rmutil.html#topic+iprofile">iprofile</a></code> and residuals with
<code><a href="rmutil.html#topic+plot.residuals">plot.residuals</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>elliptic</code> is returned that contains all of the
relevant information calculated, including error codes.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>deviance</code>: Deviance method
</p>
</li>
<li> <p><code>fitted</code>: Fitted method
</p>
</li>
<li> <p><code>residuals</code>: Residuals method
</p>
</li>
<li> <p><code>print</code>: Print method
</p>
</li></ul>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>References</h3>

<p>Lindsey, J.K. (1999) Multivariate elliptically-contoured
distributions for repeated measurements. Biometrics 55, 1277-1280.
</p>
<p>Kotz, S., Kozubowski, T.J., and Podgorski, K. (2001) The Laplace
Distribution and Generalizations. A Revisit with Applications to
Communications, Economics, Engineering, and Finance. Basel: Birkhauser, Ch.
6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+carma">carma</a></code>, <code><a href="rmutil.html#topic+dpowexp">dpowexp</a></code>,
<code><a href="rmutil.html#topic+dskewlaplace">dskewlaplace</a></code>, <code><a href="rmutil.html#topic+finterp">finterp</a></code>,
<code><a href="repeated.html#topic+gar">gar</a></code>, <code><a href="rmutil.html#topic+gettvc">gettvc</a></code>,
<code><a href="repeated.html#topic+gnlmix">gnlmix</a></code>, <code><a href="repeated.html#topic+glmm">glmm</a></code>,
<code><a href="repeated.html#topic+gnlmm">gnlmm</a></code>, <code><a href="gnlm.html#topic+gnlr">gnlr</a></code>,
<code><a href="rmutil.html#topic+iprofile">iprofile</a></code>, <code><a href="repeated.html#topic+kalseries">kalseries</a></code>,
<code><a href="rmutil.html#topic+mprofile">mprofile</a></code>, <code><a href="#topic+potthoff">potthoff</a></code>,
<code><a href="rmutil.html#topic+read.list">read.list</a></code>, <code><a href="rmutil.html#topic+restovec">restovec</a></code>,
<code><a href="rmutil.html#topic+rmna">rmna</a></code>, <code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>,
<code><a href="rmutil.html#topic+tvctomat">tvctomat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# linear models
y &lt;- matrix(rnorm(40),ncol=5)
x1 &lt;- gl(2,4)
x2 &lt;- gl(2,1,8)
# independence with time trend
elliptic(y, ccov=~x1, torder=2)
# AR(1)
elliptic(y, ccov=~x1, torder=2, par=0.1)
elliptic(y, ccov=~x1, torder=3, interact=3, par=0.1)
# random intercept
elliptic(y, ccov=~x1+x2, interact=c(2,0), torder=3, pre=2)
#
# nonlinear models
time &lt;- rep(1:20,2)
dose &lt;- c(rep(2,20),rep(5,20))
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*time)-exp(-exp(p[1])*time)))
shape &lt;- function(p) exp(p[1]-p[2])*time*dose*exp(-exp(p[1])*time)
conc &lt;- matrix(rnorm(40,mu(log(c(1,0.3,0.2))),sqrt(shape(log(c(0.1,0.4))))),
	ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
	ncol=20,byrow=TRUE)[,1:19])
conc &lt;- ifelse(conc&gt;0,conc,0.01)
# with builtin function
# independence
elliptic(conc, model="pkpd", preg=log(c(0.5,0.4,0.1)), dose=c(2,5))
# AR(1)
elliptic(conc, model="pkpd", preg=log(c(0.5,0.4,0.1)), dose=c(2,5),
	par=0.1)
# add variance function
elliptic(conc, model="pkpd", preg=log(c(0.5,0.4,0.1)), dose=c(2,5),
	par=0.1, varfn=shape, pvar=log(c(0.5,0.2)))
# multivariate power exponential distribution
elliptic(conc, model="pkpd", preg=log(c(0.5,0.4,0.1)), dose=c(2,5),
	par=0.1, varfn=shape, pvar=log(c(0.5,0.2)), pell=1,
	distribution="power exponential")
# multivariate Student t distribution
elliptic(conc, model="pkpd", preg=log(c(0.5,0.4,0.1)), dose=c(2,5),
	par=0.1, varfn=shape, pvar=log(c(0.5,0.2)), pell=5,
	distribution="Student t")
# multivariate Laplace distribution
elliptic(conc, model="pkpd", preg=log(c(0.5,0.4,0.1)), dose=c(2,5),
	par=0.1, varfn=shape, pvar=log(c(0.5,0.2)),
	distribution="Laplace")
# or equivalently with user-specified function
# independence
elliptic(conc, model=mu, preg=log(c(0.5,0.4,0.1)))
# AR(1)
elliptic(conc, model=mu, preg=log(c(0.5,0.4,0.1)), par=0.1)
# add variance function
elliptic(conc, model=mu, preg=log(c(0.5,0.4,0.1)), par=0.1,
	varfn=shape, pvar=log(c(0.5,0.2)))
# multivariate power exponential distribution
elliptic(conc, model=mu, preg=log(c(0.5,0.4,0.1)), par=0.1,
	varfn=shape, pvar=log(c(0.5,0.2)), pell=1,
	distribution="power exponential")
# multivariate Student t distribution
elliptic(conc, model=mu, preg=log(c(0.5,0.4,0.1)), par=0.1,
	varfn=shape, pvar=log(c(0.5,0.2)), pell=5,
	distribution="Student t")
# multivariate Laplace distribution
elliptic(conc, model=mu, preg=log(c(0.5,0.4,0.1)), par=0.1,
	varfn=shape, pvar=log(c(0.5,0.2)), pell=5,
	distribution="Laplace")
# or with user-specified formula
# independence
elliptic(conc, model=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*time)-exp(-exp(absorption)*time)),
	preg=list(absorption=log(0.5),elimination=log(0.4),
	volume=log(0.1)))
# AR(1)
elliptic(conc, model=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*time)-exp(-exp(absorption)*time)),
	preg=list(absorption=log(0.5),elimination=log(0.4),volume=log(0.1)),
	par=0.1)
# add variance function
elliptic(conc, model=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*time)-exp(-exp(absorption)*time)),
	preg=list(absorption=log(0.5),elimination=log(0.4),volume=log(0.1)),
	varfn=~exp(b1-b2)*time*dose*exp(-exp(b1)*time),
	par=0.1, pvar=list(b1=log(0.5),b2=log(0.2)))
# variance as function of the mean
elliptic(conc, model=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*time)-exp(-exp(absorption)*time)),
	preg=list(absorption=log(0.5),elimination=log(0.4),volume=log(0.1)),
	varfn=~d*log(mu),shfn=TRUE,par=0.1, pvar=list(d=1))
# multivariate power exponential distribution
elliptic(conc, model=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*time)-exp(-exp(absorption)*time)),
	preg=list(absorption=log(0.5),elimination=log(0.4),volume=log(0.1)),
	varfn=~exp(b1-b2)*time*dose*exp(-exp(b1)*time),
	par=0.1, pvar=list(b1=log(0.5),b2=log(0.2)), pell=1,
	distribution="power exponential")
# multivariate Student t distribution
elliptic(conc, model=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*time)-exp(-exp(absorption)*time)),
	preg=list(absorption=log(0.5),elimination=log(0.4),volume=log(0.1)),
	varfn=~exp(b1-b2)*time*dose*exp(-exp(b1)*time),
	par=0.1, pvar=list(b1=log(0.5),b2=log(0.2)), pell=5,
	distribution="Student t")
# multivariate Laplace distribution
elliptic(conc, model=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*time)-exp(-exp(absorption)*time)),
	preg=list(absorption=log(0.5),elimination=log(0.4),volume=log(0.1)),
	varfn=~exp(b1-b2)*time*dose*exp(-exp(b1)*time),
	par=0.1, pvar=list(b1=log(0.5),b2=log(0.2)), pell=5,
	distribution="Laplace")
#
# generalized logistic regression with square-root transformation
# and square  link
time &lt;- rep(seq(10,200,by=10),2)
mu &lt;- function(p) {
	yinf &lt;- exp(p[2])
	yinf*(1+((yinf/exp(p[1]))^p[4]-1)*exp(-yinf^p[4]
		*exp(p[3])*time))^(-1/p[4])}
y &lt;- matrix(rnorm(40,sqrt(mu(c(2,1.5,0.05,-2))),0.05)^2,ncol=20,byrow=TRUE)
y[,2:20] &lt;- y[,2:20]+0.5*(y[,1:19]-matrix(mu(c(2,1.5,0.05,-2)),
	ncol=20,byrow=TRUE)[,1:19])
y &lt;- ifelse(y&gt;0,y,0.01)
# with builtin function
# independence
elliptic(y, model="logistic", preg=c(2,1,0.1,-1), trans="sqrt",
	link="square")
# the same model with AR(1)
elliptic(y, model="logistic", preg=c(2,1,0.1,-1), trans="sqrt",
	link="square", par=0.4)
# the same model with AR(1) and one component of variance
elliptic(y, model="logistic", preg=c(2,1,0.1,-1),
	trans="sqrt", link="square", pre=1, par=0.4)
# or equivalently with user-specified function
# independence
elliptic(y, model=mu, preg=c(2,1,0.1,-1), trans="sqrt",
	link="square")
# the same model with AR(1)
elliptic(y, model=mu, preg=c(2,1,0.1,-1), trans="sqrt",
	link="square", par=0.4)
# the same model with AR(1) and one component of variance
elliptic(y, model=mu, preg=c(2,1,0.1,-1),
	trans="sqrt", link="square", pre=1, par=0.4)
# or equivalently with user-specified formula
# independence
elliptic(y, model=~exp(yinf)*(1+((exp(yinf-y0))^b4-1)*
	exp(-exp(yinf*b4+b3)*time))^(-1/b4),
	preg=list(y0=2,yinf=1,b3=0.1,b4=-1), trans="sqrt", link="square")
# the same model with AR(1)
elliptic(y, model=~exp(yinf)*(1+((exp(yinf-y0))^b4-1)*
	exp(-exp(yinf*b4+b3)*time))^(-1/b4),
	preg=list(y0=2,yinf=1,b3=0.1,b4=-1), trans="sqrt",
	link="square", par=0.1)
# add one component of variance
elliptic(y, model=~exp(yinf)*(1+((exp(yinf-y0))^b4-1)*
	exp(-exp(yinf*b4+b3)*time))^(-1/b4),
	preg=list(y0=2,yinf=1,b3=0.1,b4=-1),
	trans="sqrt", link="square", pre=1, par=0.1)
#
# multivariate power exponential and Student t distributions for outliers
y &lt;- matrix(rcauchy(40,mu(c(2,1.5,0.05,-2)),0.05),ncol=20,byrow=TRUE)
y[,2:20] &lt;- y[,2:20]+0.5*(y[,1:19]-matrix(mu(c(2,1.5,0.05,-2)),
	ncol=20,byrow=TRUE)[,1:19])
y &lt;- ifelse(y&gt;0,y,0.01)
# first with normal distribution
elliptic(y, model="logistic", preg=c(1,1,0.1,-1))
elliptic(y, model="logistic", preg=c(1,1,0.1,-1), par=0.5)
# then power exponential
elliptic(y, model="logistic", preg=c(1,1,0.1,-1), pell=1,
	distribution="power exponential")
elliptic(y, model="logistic", preg=c(1,1,0.1,-1), par=0.5, pell=1,
	distribution="power exponential")
# finally Student t
elliptic(y, model="logistic", preg=c(1,1,0.1,-1), pell=1,
	distribution="Student t")
elliptic(y, model="logistic", preg=c(1,1,0.1,-1), par=0.5, pell=1,
	distribution="Student t")

</code></pre>

<hr>
<h2 id='pergram'>Calculate and Plot a Periodogram</h2><span id='topic+pergram'></span><span id='topic+plot.pergram'></span><span id='topic+plot_cum'></span><span id='topic+plot_cum.pergram'></span>

<h3>Description</h3>

<p><code>pergram</code> calculates the values of a periodogram, <code>plot.pergram</code>
plots it, and <code>plot.cum.pergram</code> plots the corresponding cumulative
periodogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pergram(y)

## S3 method for class 'pergram'
plot(x, add = FALSE, lty = 1, xlab = "Frequency",
  ylab = "Periodogram", main = "Periodogram", ylim = c(0, max(po[,
  2])), ...)

## S3 method for class 'pergram'
plot_cum(x, xlab = "Frequency", ylab = "Periodogram",
  main = "Cumulative periodogram", ylim = c(0, max(cpo + 1.358/(a +
  0.12 + 0.11/a))), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pergram_+3A_y">y</code></td>
<td>
<p>A time series vector.</p>
</td></tr>
<tr><td><code id="pergram_+3A_x">x</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="pergram_+3A_add">add</code></td>
<td>
<p>If TRUE, adds a new periodogram to an existing plot.</p>
</td></tr>
<tr><td><code id="pergram_+3A_lty">lty</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="pergram_+3A_xlab">xlab</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="pergram_+3A_ylab">ylab</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="pergram_+3A_main">main</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="pergram_+3A_ylim">ylim</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
<tr><td><code id="pergram_+3A_...">...</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pergram</code> prints and returns a two-column matrix of class,
<code>pergram</code>, containing the periodogram.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot</code>: Plot method
</p>
</li>
<li> <p><code>plot_cum</code>: Plot_cum method
</p>
</li></ul>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rnorm(100)
print(z &lt;- pergram(y))
plot(z)
plot_cum(z)

</code></pre>

<hr>
<h2 id='potthoff'>Potthoff and Roy Growth Curve Model</h2><span id='topic+potthoff'></span>

<h3>Description</h3>

<p><code>potthoff</code> fits the Potthoff and Roy repeated measurements growth curve
model with unstructured covariance matrix to completely balanced data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potthoff(response, x = NULL, ccov = NULL, times = NULL, torder = 0,
  orthogonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="potthoff_+3A_response">response</code></td>
<td>
<p>A matrix or dataframe of response values.</p>
</td></tr>
<tr><td><code id="potthoff_+3A_x">x</code></td>
<td>
<p>A matrix defining the complete intersubject differences or a
Wilkinson and Rogers formula that will create one.</p>
</td></tr>
<tr><td><code id="potthoff_+3A_ccov">ccov</code></td>
<td>
<p>A matrix of columns of the baseline covariates to be actually
fitted, with one row per individual or a W&amp;R formula that will create one.</p>
</td></tr>
<tr><td><code id="potthoff_+3A_times">times</code></td>
<td>
<p>A vector of unequally spaced times when they are the same for
all individuals. Not necessary if equally spaced.</p>
</td></tr>
<tr><td><code id="potthoff_+3A_torder">torder</code></td>
<td>
<p>Order of the polynomial in time to be fitted. If non-numeric,
the full model in time is fitted.</p>
</td></tr>
<tr><td><code id="potthoff_+3A_orthogonal">orthogonal</code></td>
<td>
<p>If TRUE, uses orthogonal polynomials for time, otherwise
only centres times at their mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class potthoff is returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+carma">carma</a></code>, <code><a href="#topic+elliptic">elliptic</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- matrix(rnorm(40),ncol=5)
x &lt;- gl(2,4)
# full model with treatment effect
potthoff(y, ~x, torder="f", ccov=~x)
# no time trend with treatment effect
potthoff(y, ~x, torder=0, ccov=~x)
# quadratic time with treatment effect
potthoff(y, ~x, torder=2, ccov=~x)
# full model without treatment effect
potthoff(y, ~x, torder="f")
# linear time without treatment effect
potthoff(y, ~x, torder=1)

</code></pre>

<hr>
<h2 id='rmaov'>Split-plot ANOVA Model</h2><span id='topic+rmaov'></span>

<h3>Description</h3>

<p><code>rmaov</code> performs the classical balanced split-plot ANOVA, with
<code>summary</code> providing the table. This is the so-called repeated measures
ANOVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmaov(response, tvcov = NULL, ccov = NULL, analysis = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmaov_+3A_response">response</code></td>
<td>
<p>A matrix or dataframe of response values with units as rows
and repeated measures as columns.</p>
</td></tr>
<tr><td><code id="rmaov_+3A_tvcov">tvcov</code></td>
<td>
<p>A numeric vector or factor variable defining the clusters. If
there are several levels of nesting, a matrix or dataframe with columns of
such variables defining the nested clusters starting with the highest level
(that is, from slowest to fastest varying). If not provided, each response
value of a unit is assumed to belong to a different cluster (that is, one
factor with <code>ncol(response)</code> levels is assumed).</p>
</td></tr>
<tr><td><code id="rmaov_+3A_ccov">ccov</code></td>
<td>
<p>A vector or factor variable for one inter-subject covariate or a
matrix, dataframe, or list of several such variables.</p>
</td></tr>
<tr><td><code id="rmaov_+3A_analysis">analysis</code></td>
<td>
<p>If FALSE, the design matrix is set up, but the analysis is
not performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For unbalanced data, <code><a href="#topic+elliptic">elliptic</a></code> will perform the
analysis for one or two levels of nesting.
</p>


<h3>Value</h3>

<p>The fitted model is returned.
</p>


<h3>Author(s)</h3>

<p>Ralf Goertz (ralf.goertz@uni-jena.de)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+carma">carma</a></code>, <code><a href="#topic+elliptic">elliptic</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+potthoff">potthoff</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# vision data for 7 individuals, with response a 7x8 matrix
# two levels of nesting: 4 levels of power for each eye
y &lt;- matrix(rnorm(56),ncol=8)
tvc &lt;- data.frame(eye=c(rep(1,4),rep(2,4)),power=c(1:4,1:4))
summary(rmaov(y, tvc))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
