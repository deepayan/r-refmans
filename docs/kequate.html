<!DOCTYPE html><html><head><title>Help for package kequate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kequate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cdist'><p>Conditional Mean, Variance, Skewness and Kurtosis</p></a></li>
<li><a href='#cdist-class'><p>Class &quot;cdist&quot;</p></a></li>
<li><a href='#FTres'>
<p>Freeman-Tukey Residuals</p></a></li>
<li><a href='#genseed'>
<p>Standard Error of the Difference Between Two Equating Functions</p></a></li>
<li><a href='#genseed-class'><p>Class &quot;genseed&quot;</p></a></li>
<li><a href='#getEq'><p>Retrieve Equated Values</p></a></li>
<li><a href='#getEqirt'><p>Retrieve Equated Values From an IRT-Equating</p></a></li>
<li><a href='#getEqlin'><p>Retrieve Equated Values of the Linear Equating</p></a></li>
<li><a href='#getEquating'><p>Retrieve Information From an Equating</p></a></li>
<li><a href='#getH'><p>Retrieve the Continuization Bandwidths</p></a></li>
<li><a href='#getPre'><p>Retrieve the Percent Relative Error</p></a></li>
<li><a href='#getScores'><p>Retrieve the Score Vectors of an Equating</p></a></li>
<li><a href='#getSee'><p>Retrieve Standard Errors From an Equating</p></a></li>
<li><a href='#getSeed'><p>Retrieve the Standard Errors of the Difference Between Two Equatings</p></a></li>
<li><a href='#getSeeirt'><p>Retrieve Standard Errors of Equating From an IRT-Equating</p></a></li>
<li><a href='#getSeelin'><p>Retrieve Standard Errors From a Linear Equating</p></a></li>
<li><a href='#getType'><p>Retrieve the Type of Equating</p></a></li>
<li><a href='#irtose'>
<p>Item Response Theory Observed-Score Kernel Equating</p></a></li>
<li><a href='#kefreq'>
<p>Test Score Frequency Tabulation</p></a></li>
<li><a href='#keout-class'><p>Class &quot;keout&quot;</p></a></li>
<li><a href='#kequate'>
<p>Test Equating Using the Kernel Method</p></a></li>
<li><a href='#kequate-package'>
<p>The Kernel Method of Test Equating</p></a></li>
<li><a href='#plot-methods'><p> ~~ Methods for Function plot  ~~</p></a></li>
<li><a href='#PREp'>
<p>Percent Relative Error</p></a></li>
<li><a href='#simeq'><p>Simulated Test Data</p></a></li>
<li><a href='#summary-methods'><p> ~~ Methods for Function summary  ~~</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Kernel Method of Test Equating</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the kernel method of test equating as defined in von Davier, A. A., Holland, P. W. and Thayer, D. T. (2004) &lt;<a href="https://doi.org/10.1007%2Fb97446">doi:10.1007/b97446</a>&gt; and Andersson, B. and Wiberg, M. (2017) &lt;<a href="https://doi.org/10.1007%2Fs11336-016-9528-7">doi:10.1007/s11336-016-9528-7</a>&gt; using the CB, EG, SG, NEAT CE/PSE and NEC designs, supporting Gaussian, logistic and uniform kernels and unsmoothed and pre-smoothed input data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.11.0), methods, stats, graphics, ltm</td>
</tr>
<tr>
<td>Imports:</td>
<td>equateIRT, mirt, utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-12 20:13:13 UTC; bjorn</td>
</tr>
<tr>
<td>Author:</td>
<td>Björn Andersson <a href="https://orcid.org/0000-0002-9007-2440"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kenny Bränberg [aut],
  Marie Wiberg <a href="https://orcid.org/0000-0001-5549-8262"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Björn Andersson &lt;bjoern.h.andersson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-13 07:52:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='cdist'>Conditional Mean, Variance, Skewness and Kurtosis</h2><span id='topic+cdist'></span>

<h3>Description</h3>

<p>Calculates conditional means, variances, skewnesses and kurtoses for observed and estimated bivariate probability distributions of test scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdist(est, obs, xscores, ascores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdist_+3A_est">est</code></td>
<td>

<p>Matrix of estimated bivariate score probabilities.
</p>
</td></tr>
<tr><td><code id="cdist_+3A_obs">obs</code></td>
<td>

<p>Matrix of observed bivariate score probabilities.
</p>
</td></tr>
<tr><td><code id="cdist_+3A_xscores">xscores</code></td>
<td>

<p>Optional argument to specify the score vector for test X.
</p>
</td></tr>
<tr><td><code id="cdist_+3A_ascores">ascores</code></td>
<td>

<p>Optional argument to specify the score vector for test A.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'cdist' containing the following slots
</p>
<table>
<tr><td><code>est1</code></td>
<td>
<p>Matrix of conditional means, variances, skewnesses and kurtoses of X given A for the estimated score distribution.</p>
</td></tr>
<tr><td><code>est2</code></td>
<td>
<p>Matrix of conditional means, variances, skewnesses and kurtoses of A given X for the estimated score distribution.</p>
</td></tr>
<tr><td><code>obs1</code></td>
<td>
<p>Matrix of conditional means, variances, skewnesses and kurtoses of X given A for the observed score distribution.</p>
</td></tr>
<tr><td><code>obs2</code></td>
<td>
<p>Matrix of conditional means, variances, skewnesses and kurtoses of A given X for the observed score distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>References</h3>

<p>von Davier, A.A., Holland, P.W., Thayer, D.T. (2004). <em>The Kernel Method of Test Equating.</em> Springer-Verlag New York.
</p>
<p>Holland, P.W.,  Thayer, D. (1998). Univariate and Bivariate Loglinear Models for Discrete Test Score Distributions <em>ETS Technical Report No</em> <b>98-1</b>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
<code><a href="#topic+PREp">PREp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqdata&lt;-data.frame(X=c(1,2,2,1,2,2,2,2,3,1,2,1,4,2,1,1,3,3,3,3), 
A=(c(0,2,1,1,0,3,1,2,2,0,2,0,3,1,1,2,2,2,1,2)))
Pdata&lt;-kefreq(freqdata$X, 0:5, freqdata$A, 0:3)
Pglm&lt;-glm(frequency~X+I(X^2)+A+I(A^2)+X:A, data=Pdata, family="poisson", x=TRUE)
Pobs&lt;-matrix(Pdata$freq, nrow=6)/sum(Pglm$y)
Pest&lt;-matrix(Pglm$fitted.values, nrow=6)/sum(Pglm$y)
cdP&lt;-cdist(Pest, Pobs, 0:5, 0:3)
plot(cdP)
</code></pre>

<hr>
<h2 id='cdist-class'>Class &quot;cdist&quot;</h2><span id='topic+cdist-class'></span>

<h3>Description</h3>

<p>Stores conditional means, variances, skewnesses and kurtoses of observed and estimated bivariate distributions of test scores.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("cdist", ...)</code>.

</p>


<h3>Slots</h3>


<dl>
<dt>est1</dt><dd><p>Matrix of conditional means, variances, skewnesses and kurtoses of X given A for the estimated score distribution.</p>
</dd>
<dt>est2</dt><dd><p>Matrix of conditional means, variances, skewnesses and kurtoses of A given X for the estimated score distribution.</p>
</dd>
<dt>obs1</dt><dd><p>Matrix of conditional means, variances, skewnesses and kurtoses of X given A for the observed score distribution.</p>
</dd>
<dt>obs2</dt><dd><p>Matrix of conditional means, variances, skewnesses and kurtoses of A given X for the observed score distribution.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "keout")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cdist">cdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("cdist")
</code></pre>

<hr>
<h2 id='FTres'>
Freeman-Tukey Residuals
</h2><span id='topic+FTres'></span>

<h3>Description</h3>

<p>Calculates the Freeman-Tukey residuals for log-linear models of frequency data. If the frequencies 
are assumed to be Poisson distributed, then the Freeman-Tukey residuals are approximately normal 
distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTres(obs, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FTres_+3A_obs">obs</code></td>
<td>

<p>A numeric vector containing the observed frequencies.
</p>
</td></tr>
<tr><td><code id="FTres_+3A_fit">fit</code></td>
<td>

<p>A numeric vector containing the estimated frequencies.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an observed frequency <code class="reqn">n_{i}</code> and the estimated frequency <code class="reqn">m_{i}</code>, the Freeman-Tukey residual <code class="reqn">FT_{i}</code> is defined as<br />
<code class="reqn">FT_{i} = \sqrt{n_{i}}+\sqrt{n_{i}+1}-\sqrt{4m_{i}+1}.</code>
</p>


<h3>Value</h3>

<p>A numeric vector containing the Freeman-Tukey residuals.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>References</h3>

<p>Andersson, B., Branberg, K., and Wiberg, M. (2013). Performing the Kernel Method of Test Equating with the Package <b>kequate</b>. <em>Journal of Statistical Software</em>, <b>55(6)</b>, 1&ndash;25. &lt;doi:10.18637/jss.v055.i06&gt;
</p>
<p>Holland, P.W,  Thayer, D. (1998). Univariate and Bivariate Loglinear Models for Discrete Test Score Distributions <em>ETS Technical Report No</em> <b>98-1</b>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example data:
P&lt;-c(5, 20, 35, 25, 15)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
res&lt;-FTres(glmx$y, glmx$fitted.values)
</code></pre>

<hr>
<h2 id='genseed'>
Standard Error of the Difference Between Two Equating Functions
</h2><span id='topic+genseed'></span>

<h3>Description</h3>

<p>Given two equating functions with associated standard error vectors, the standard error of the difference between two equating functions (SEED) is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genseed(in1, in2, linear = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genseed_+3A_in1">in1</code></td>
<td>

<p>S4 object of class keout containing information about the first equating function, as created by the function kequate.
</p>
</td></tr>
<tr><td><code id="genseed_+3A_in2">in2</code></td>
<td>

<p>S4 object of class keout containing information about the second equating function, as created by the function kequate.
</p>
</td></tr>
<tr><td><code id="genseed_+3A_linear">linear</code></td>
<td>

<p>A logical vector indicating if the two linear equatings are to be compared instead of the two equipercentile equatings. Default is FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard error of the difference between two equating functions (SEED) can be used to compare equating functions and decide which is most suitable to use. For example, if the difference between a linear and an equipercentile equating function is small and within the boundaries of the estimated SEED the simpler linear equating function may be preferable. Any two equipercentile or linear equating functions can be compared using genseed, given that the log-linear model is identical between the two (and that the designs are comparable). As an example, it is impossible to compare an EG equating to an SG equating in this manner as the log-linear models are not the same. It is however useful to compare a chain equating to a post-stratification equating in the NEAT design, or to compare post-stratification equatings with different weights. 
</p>


<h3>Value</h3>

<p>A data frame containing the difference between the equated values of two equating functions and the SEED of the two equatings for equating X to Y (eqYxD and SEEDYx).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>References</h3>

<p>Andersson, B., Branberg, K., and Wiberg, M. (2013). Performing the Kernel Method of Test Equating with the Package <b>kequate</b>. <em>Journal of Statistical Software</em>, <b>55(6)</b>, 1&ndash;25. &lt;doi:10.18637/jss.v055.i06&gt;
</p>
<p>von Davier, A.A., Holland, P.W., Thayer, D.T. (2004). <em>The Kernel Method of Test Equating.</em> Springer-Verlag New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
keEGnew&lt;-kequate("EG", 0:4, 0:4, glmx, glmy, hx=0.33, hy=0.33)
SEEDEG&lt;-genseed(keEG, keEGnew)
plot(SEEDEG)
</code></pre>

<hr>
<h2 id='genseed-class'>Class &quot;genseed&quot;</h2><span id='topic+genseed-class'></span>

<h3>Description</h3>

<p>Stores the difference between two equatings which use identical log-linear models, along with the standard error of the difference of the two equatings.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("genseed", ...)</code>.

</p>


<h3>Slots</h3>


<dl>
<dt><code>out</code>:</dt><dd><p>Object of class <code>"data.frame"</code> containing the difference between the equated values of two equating functions and the SEED of the two equatings for equating X to Y (eqYxD and SEEDYx).
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "genseed")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("genseed")
</code></pre>

<hr>
<h2 id='getEq'>Retrieve Equated Values</h2><span id='topic+getEq'></span><span id='topic+getEq-class'></span><span id='topic+getEq+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the equated values from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEq(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEq_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the equated values.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
<code><a href="#topic+PREp">PREp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getEq(keEG)
</code></pre>

<hr>
<h2 id='getEqirt'>Retrieve Equated Values From an IRT-Equating</h2><span id='topic+getEqirt'></span><span id='topic+getEqirt-class'></span><span id='topic+getEqirt+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the equated values of the IRT observed score equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEqirt(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEqirt_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the equated values of the IRT-equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irtmatX&lt;-matrix(0, 4, 3)
irtmatX[,1]&lt;-c(0.1, 0.3, 0.2, 0.5)
irtmatX[,2]&lt;-c(0.2, 0.5, 0.4, 0.7)
irtmatX[,3]&lt;-c(0.3, 0.7, 0.6, 0.9)
irtmatY&lt;-matrix(0, 4, 3)
irtmatY[,1]&lt;-c(0.15, 0.2, 0.1, 0.4)
irtmatY[,2]&lt;-c(0.2, 0.4, 0.3, 0.6)
irtmatY[,3]&lt;-c(0.25, 0.6, 0.5, 0.8)
irtX&lt;-c(12, 32, 54, 22, 10)
irtY&lt;-c(24, 36, 48, 12, 10)
xirt=0:4
glmXirt&lt;-glm(irtX~xirt+I(xirt^2), family="poisson", x=TRUE)
glmYirt&lt;-glm(irtY~xirt+I(xirt^2), family="poisson", x=TRUE)
keEGirt&lt;-kequate("EG", 0:4, 0:4, glmXirt, glmYirt, irtx=irtmatX, irty=irtmatY)
getEqirt(keEGirt)
</code></pre>

<hr>
<h2 id='getEqlin'>Retrieve Equated Values of the Linear Equating</h2><span id='topic+getEqlin'></span><span id='topic+getEqlin-class'></span><span id='topic+getEqlin+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the equated values of the linear equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEqlin(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEqlin_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the equated valuesof the linear equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getEqlin(keEG)
</code></pre>

<hr>
<h2 id='getEquating'>Retrieve Information From an Equating</h2><span id='topic+getEquating'></span><span id='topic+getEquating-class'></span><span id='topic+getEquating+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve information from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEquating(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEquating_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the equated values, standard errors of equating, cumulative distribution functions for the equated tests, estimated score probabilities for the equated tests and other information about the equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getEquating(keEG)
</code></pre>

<hr>
<h2 id='getH'>Retrieve the Continuization Bandwidths</h2><span id='topic+getH'></span><span id='topic+getH-class'></span><span id='topic+getH+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the bandwidths used in an equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getH_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the values of h used in the equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getH(keEG)
</code></pre>

<hr>
<h2 id='getPre'>Retrieve the Percent Relative Error</h2><span id='topic+getPre'></span><span id='topic+getPre-class'></span><span id='topic+getPre+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the percent relative error (PRE) used in an equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPre(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPre_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the PRE of the equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getPre(keEG)
</code></pre>

<hr>
<h2 id='getScores'>Retrieve the Score Vectors of an Equating</h2><span id='topic+getScores'></span><span id='topic+getScores-class'></span><span id='topic+getScores+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the type of equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScores(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getScores_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the score vector(s) used in the equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getScores(keEG)
</code></pre>

<hr>
<h2 id='getSee'>Retrieve Standard Errors From an Equating</h2><span id='topic+getSee'></span><span id='topic+getSee-class'></span><span id='topic+getSee+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the standard errors of an equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSee(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSee_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the standard errors of the equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getSee(keEG)
</code></pre>

<hr>
<h2 id='getSeed'>Retrieve the Standard Errors of the Difference Between Two Equatings</h2><span id='topic+getSeed'></span><span id='topic+getSeed-class'></span><span id='topic+getSeed+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the standard error of the difference between an equipercentile equating and a linear equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSeed(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSeed_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class genseed containing the difference between an equipercentile and a linear equating and the standard errors of the difference between an equipercentile equating and a linear equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>, <code><a href="#topic+genseed">genseed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
keEGseed&lt;-getSeed(keEG)
plot(keEGseed)
</code></pre>

<hr>
<h2 id='getSeeirt'>Retrieve Standard Errors of Equating From an IRT-Equating</h2><span id='topic+getSeeirt'></span><span id='topic+getSeeirt-class'></span><span id='topic+getSeeirt+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the standard errors of the IRT-equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSeeirt(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSeeirt_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the standard errors of the IRT-equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irtmatX&lt;-matrix(0, 4, 3)
irtmatX[,1]&lt;-c(0.1, 0.3, 0.2, 0.5)
irtmatX[,2]&lt;-c(0.2, 0.5, 0.4, 0.7)
irtmatX[,3]&lt;-c(0.3, 0.7, 0.6, 0.9)
irtmatY&lt;-matrix(0, 4, 3)
irtmatY[,1]&lt;-c(0.15, 0.2, 0.1, 0.4)
irtmatY[,2]&lt;-c(0.2, 0.4, 0.3, 0.6)
irtmatY[,3]&lt;-c(0.25, 0.6, 0.5, 0.8)
irtX&lt;-c(12, 32, 54, 22, 10)
irtY&lt;-c(24, 36, 48, 12, 10)
xirt=0:4
glmXirt&lt;-glm(irtX~xirt+I(xirt^2), family="poisson", x=TRUE)
glmYirt&lt;-glm(irtY~xirt+I(xirt^2), family="poisson", x=TRUE)
keEGirt&lt;-kequate("EG", 0:4, 0:4, glmXirt, glmYirt, irtx=irtmatX, irty=irtmatY)
getSeeirt(keEGirt)
</code></pre>

<hr>
<h2 id='getSeelin'>Retrieve Standard Errors From a Linear Equating</h2><span id='topic+getSeelin'></span><span id='topic+getSeelin-class'></span><span id='topic+getSeelin+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the standard errors of a linear equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSeelin(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSeelin_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the standard errors of the linear equating.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getSeelin(keEG)
</code></pre>

<hr>
<h2 id='getType'>Retrieve the Type of Equating</h2><span id='topic+getType'></span><span id='topic+getType-class'></span><span id='topic+getType+2Ckeout-method'></span>

<h3>Description</h3>

<p>Function to retrieve the type of equating from an object of class keout created by kequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getType(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getType_+3A_object">object</code></td>
<td>

<p>An object of class keout as created by the function kequate.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector describing the type of equating conducted.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
getType(keEG)
</code></pre>

<hr>
<h2 id='irtose'>
Item Response Theory Observed-Score Kernel Equating
</h2><span id='topic+irtose'></span>

<h3>Description</h3>

<p>A function to conduct an equating between two parallel tests using item response theory (IRT) observed-score kernel equating. Designs available are equivalent groups (EG) and non-equivalent groups with anchor test using chain equating (NEAT CE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irtose(design="CE", P, Q, x, y, a=0, qpoints=seq(-6, 6, by=0.1), model="2pl", catsX=0, 
catsY=0, catsA=0, see="analytical", replications=199, kernel="gaussian", 
h=list(hx=0, hy=0, hxP=0, haP=0, hyQ=0, haQ=0), 
hlin=list(hxlin=0, hylin=0, hxPlin=0, haPlin=0, hyQlin=0, haQlin=0), KPEN=0, wpen=0.5, 
linear=FALSE, slog=1, bunif=1, altopt=FALSE, wS=0.5, eqcoef="mean-mean", robust=FALSE,
distribution = list("normal", par = data.frame(mu = 0, sigma = 1)), DS = FALSE, 
CV = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irtose_+3A_design">design</code></td>
<td>

<p>A character vector indicating which design to use. Possible designs are EG, CE and PSE.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_p">P</code></td>
<td>

<p>Object of class &quot;matrix&quot; or an object created by the R package ltm containing either the responses for each question in  group P or the estimated IRT model in group P.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_q">Q</code></td>
<td>

<p>Object of class &quot;matrix&quot; or an object created by the R package ltm containing either the responses for each question in  group Q or the estimated IRT model in group Q.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_x">x</code></td>
<td>

<p>Vector of possible score values of the main test X to be equated.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_y">y</code></td>
<td>

<p>Vector of possible score values of the main test Y to be equated.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_a">a</code></td>
<td>

<p>Vector of possible score values of the anchor test A. (Required for all NEAT designs.)
</p>
</td></tr>
<tr><td><code id="irtose_+3A_qpoints">qpoints</code></td>
<td>

<p>A numeric vector containing the quadrature points used in the equating. If not specified, the quadrature points from the IRT models will be used.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_model">model</code></td>
<td>

<p>A character vector indicating which IRT model to use. Available models for dichotomoous data are 2pl and 3pl while available models for polytomous data are GPCM and GRM. Default is &quot;2pl&quot;.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_catsx">catsX</code></td>
<td>

<p>The number of category answers for each item on test X. (GPCM and GRM only.)
</p>
</td></tr>
<tr><td><code id="irtose_+3A_catsy">catsY</code></td>
<td>

<p>The number of category answers for each item on test Y. (GPCM and GRM only.)
</p>
</td></tr>
<tr><td><code id="irtose_+3A_catsa">catsA</code></td>
<td>

<p>The number of category answers for each item on test A. (GPCM and GRM only.)
</p>
</td></tr>
<tr><td><code id="irtose_+3A_see">see</code></td>
<td>

<p>A character vector indicating which standard errors of equating to use. Options are &quot;analytical&quot; and &quot;bootstrap&quot;, with default &quot;analytical&quot;. If using the double smoothing bandwidth selection method (DS = TRUE), the bootstrap is not supported.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_replications">replications</code></td>
<td>

<p>The number of bootstrap replications if using the bootstrap standard error calculations. Default is 199.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_kernel">kernel</code></td>
<td>

<p>A character vector indicating which kernel to use, either &quot;gaussian&quot;, &quot;logistic&quot;, &quot;stdgaussian&quot; or &quot;uniform&quot;. Default is &quot;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_h">h</code></td>
<td>

<p>Optional argument to specify the continuization parameters manually as a list with suitable bandwidth parameters. In an EG design or a NEAT PSE design: hx and hy, in a NEAT CE design: hxP, haP, hyQ and haQ. (If linear=TRUE, then these arguments have no effect.) 
</p>
</td></tr>
<tr><td><code id="irtose_+3A_hlin">hlin</code></td>
<td>

<p>Optional argument to specify the linear continuization parameters manually as a list with suitable bandwidth parameters. In an EG design or a NEAT PSE design: hxlin and hylin, in a NEAT CE design: hxPlin, haPlin, hyQlin and haQlin.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_slog">slog</code></td>
<td>

<p>The parameter used in defining the logistic kernel. Default is 1.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_bunif">bunif</code></td>
<td>

<p>The parameter used in defining the uniform kernel. Default is 0.5.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_kpen">KPEN</code></td>
<td>

<p>The constant used in deciding the optimal continuization parameter. Default is 0. 
</p>
</td></tr>
<tr><td><code id="irtose_+3A_wpen">wpen</code></td>
<td>

<p>An argument denoting at which point the derivatives in the second part of the penalty function should be evaluated. Default is 1/4.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_linear">linear</code></td>
<td>

<p>Logical denoting if only a linear equating is to be performed. Default is FALSE. 
</p>
</td></tr>
<tr><td><code id="irtose_+3A_altopt">altopt</code></td>
<td>

<p>Logical which sets the bandwidth parameter equal to a variant of Silverman's rule of thumb. Default is FALSE. 
</p>
</td></tr>
<tr><td><code id="irtose_+3A_ws">wS</code></td>
<td>

<p>The weighting of group P in a PSE equating. Default is 0.5.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_eqcoef">eqcoef</code></td>
<td>

<p>Character vector indicating which equating coefficients to use. Options are &quot;mean-mean&quot;, &quot;mean-gmean&quot;, &quot;mean-sigma&quot;, &quot;Stocking-Lord&quot; and &quot;Haebara&quot;. Default is &quot;mean-mean&quot;. (Only for PSE. With polytomous IRT models, only &quot;mean-mean&quot; is available.)
</p>
</td></tr>
<tr><td><code id="irtose_+3A_robust">robust</code></td>
<td>

<p>Logical indicating whether the robust covariance matrix should be calculated for the IRT model. Warning: is slow for large models and large sample sizes. Default is FALSE. (Only for 2pl and GPCM models.)
</p>
</td></tr>
<tr><td><code id="irtose_+3A_distribution">distribution</code></td>
<td>

<p>A list containing information regarding the latent distribution. Default is the standard normal distribution. (Currently not in use.)
</p>
</td></tr>
<tr><td><code id="irtose_+3A_ds">DS</code></td>
<td>

<p>Logical which enables bandwidth selection with the double smoothing method.
</p>
</td></tr>
<tr><td><code id="irtose_+3A_cv">CV</code></td>
<td>

<p>Logical which enables bandwidth selection with the cross-validation method.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of class 'keout' which includes the following slots (accessed by using the get functions):
</p>
<table>
<tr><td><code>coveqYx</code></td>
<td>
<p>The asymptotic covariance matrix of the equating function.</p>
</td></tr>
<tr><td><code>Pest</code></td>
<td>
<p>The estimated probability matrix over population P.</p>
</td></tr>
<tr><td><code>Pobs</code></td>
<td>
<p>The observed probability matrix over population P.</p>
</td></tr>
<tr><td><code>Qest</code></td>
<td>
<p>The estimated probability matrix over population Q.</p>
</td></tr>
<tr><td><code>Qobs</code></td>
<td>
<p>The observed probability matrix over population Q.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>A list containing the score vectors for the tests to be equated and, in a NEAT CE design, the score vector of the anchor test. Also included are the estimated score probabilities and the continuized cumulative distribution functions for the respective tests.</p>
</td></tr>
<tr><td><code>linear</code></td>
<td>
<p>A logical vector. TRUE if linear=TRUE was specified, otherwise FALSE.</p>
</td></tr>
<tr><td><code>PRE</code></td>
<td>
<p>A data frame containing the percent relative error in the ten first moments between the equated scores and the reference distribution. (For chain equating, the PRE is calculated for the linking from X to A and the linking from A to Y.)</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>A data frame containing the continuization parameters used in the equating.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>A character vector denoting the kernel used.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character vector describing the design used.</p>
</td></tr>
<tr><td><code>equating</code></td>
<td>
<p>A data frame containing the equated values from X to Y and the associated standard errors (for either an equipercentile or a linear equating), as well as the SEED between the equipercentile and linear equating functions and the equated values and the associated standard errors in the linear case (if an equipercentile equating is conducted).</p>
</td></tr>
<tr><td><code>see</code></td>
<td>
<p>A character vector denoting which standard errors of equating are used.</p>
</td></tr>
<tr><td><code>replications</code></td>
<td>
<p>A numeric vector denoting the number of replications used when calculating the bootstrap standard errors of equating.</p>
</td></tr>
<tr><td><code>irt</code></td>
<td>
<p>A list containing the objects from the package ltm and the adjusted asymptotic covariance matrices of the item parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="mailto:bjoern.h.andersson@gmail.com">bjoern.h.andersson@gmail.com</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>References</h3>

<p>Andersson, B. (2016). Asymptotic Standard Errors of Observed-Score Equating With Polytomous IRT
Models. <em>Journal of Educational Measurement</em>, <b>53</b>, 459–477.
</p>
<p>Andersson, B. (2018). Asymptotic Variance of Linking Coefficient Estimators for Polytomous IRT Models. <em>Applied Psychological Measurement</em>, <b>42</b>, 192–205.
</p>
<p>Andersson, B. and Wiberg, M. (2017). Item Response Theory Observed-Score Kernel Equating. <em>Psychometrika</em>, <b>83</b>, 48–67. 
</p>
<p>von Davier, A.A., Holland, P.W., and Thayer, D.T. (2004). <em>The Kernel Method of Test Equating.</em> Springer-Verlag New York.
</p>
<p>Ogasawara, H. (2003). Asymptotic standard errors of IRT observed-score equating methods. <em>Psychometrika</em>, <b>68</b>, 193-211.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Generate data, non-equivalent groups with chain equating design
akX &lt;- runif(15, 0.5, 2)
bkX &lt;- rnorm(15)
akY &lt;- runif(15, 0.5, 2)
bkY &lt;- rnorm(15)
akA &lt;- runif(15, 0.5, 2)
bkA &lt;- rnorm(15)

dataP &lt;- matrix(0, nrow = 1000, ncol = 30)
dataQ &lt;- matrix(0, nrow = 1000, ncol = 30)

for(i in 1:1000){
	ability &lt;- rnorm(1)
	dataP[i,1:15] &lt;- (1 / (1 + exp(-akX * (ability - bkX)))) &gt; runif(15)
	dataP[i,16:30] &lt;- (1 / (1 + exp(-akA * (ability - bkA)))) &gt; runif(15)
}

for(i in 1:1000){
	ability &lt;- rnorm(1, mean = 0.5)
	dataQ[i,1:15] &lt;- (1 / (1 + exp(-akY * (ability - bkY)))) &gt; runif(15)
	dataQ[i,16:30] &lt;- (1 / (1 + exp(-akA * (ability - bkA)))) &gt; runif(15)
}
#Estimate the 2-PL IRT model with package ltm
sim2plP &lt;- ltm(dataP ~ z1, IRT.param = TRUE)
sim2plQ &lt;- ltm(dataQ ~ z1, IRT.param = TRUE)

#Equate the two tests
sim2plan &lt;- irtose("CE", sim2plP, sim2plQ, 0:15, 0:15, 0:15)

## End(Not run)
</code></pre>

<hr>
<h2 id='kefreq'>
Test Score Frequency Tabulation
</h2><span id='topic+kefreq'></span>

<h3>Description</h3>

<p>Tabulates the frequencies of score values/combinations of score values from data at the individual 
level. Can handle univariate or bivariate scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kefreq(in1, xscores, in2, ascores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kefreq_+3A_in1">in1</code></td>
<td>

<p>A numeric vector with the total test scores on test X for each individual.
</p>
</td></tr>
<tr><td><code id="kefreq_+3A_xscores">xscores</code></td>
<td>

<p>A numeric vector containing the possible score values on tests X and Y.
</p>
</td></tr>
<tr><td><code id="kefreq_+3A_in2">in2</code></td>
<td>

<p>A numeric vector with the total test scores on test Y or test A for each individual.
</p>
</td></tr>
<tr><td><code id="kefreq_+3A_ascores">ascores</code></td>
<td>

<p>A numeric vector containing the possible score values on test A.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Test data often consists of data at the individual level, i.e. there is a data frame, matrix or vector containing the total test score for each test taker along with other possible information about each  test taker such as the total anchor test score. In order to use such data in equating, the data needs to be converted into frequencies for each score value or combination of score values. The function kefreq handles both univariate and bivariate data, resulting in a data frame that is ordered correctly for usage with the kequate function to equate two tests. In the case of univariate data, only the first two arguments should be specified. In the case of equating using an SG design, only the first score value vector should be provided since the score values are the same for the two tests. All arguments should be used for a NEAT design.
</p>


<h3>Value</h3>

<p>A data frame containing the score values and the frequencies associated with each score value/score value combination, sorted in the manner appropriate for usage with functions glm and kequate.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>References</h3>

<p>Andersson, B., Branberg, K., and Wiberg, M. (2013). Performing the Kernel Method of Test Equating with the Package <b>kequate</b>. <em>Journal of Statistical Software</em>, <b>55(6)</b>, 1&ndash;25. &lt;doi:10.18637/jss.v055.i06&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>, <code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqdata &lt;- data.frame(X=c(1,2,2,1,2,2,2,2,3,1,2,1,4,2,1,1,3,3,3,3), 
A=(c(0,2,1,1,0,3,1,2,2,0,2,0,3,1,1,2,2,2,1,2)))
Pdata &lt;- kefreq(freqdata$X, 0:5, freqdata$A, 0:3)
</code></pre>

<hr>
<h2 id='keout-class'>Class &quot;keout&quot;</h2><span id='topic+keout-class'></span>

<h3>Description</h3>

<p>Information relating to an equating between two tests X and Y.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("keout", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Cr</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The C-matrix from the log-linear model of test X on population P. (EG design only)</p>
</dd>
<dt><code>Cs</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The C-matrix from the log-linear model of test Y on population Q. (EG design only)</p>
</dd>
<dt><code>Cp</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The C-matrix from the log-linear model of tests X and Y or X and A on population P. (CB design: C-matrix from the log-linear model for the first group) (CB/SG/NEAT CE/NEAT PSE/NEC designs only)</p>
</dd>
<dt><code>Cq</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The C-matrix from the log-linear model of tests X and Y or X and A on population Q. (CB design: C-matrix from the log-linear model for the second group) (CB/NEAT CE/NEAT PSE/NEC designs only)</p>
</dd>
<dt><code>coveqYx</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Matrix containing the covariance matrix of the equating function. (IRT-OSE only)</p>
</dd>
<dt><code>SEEvect</code>:</dt><dd><p>Object of class <code>"SEEvect"</code>. Matrices containing the standard error vectors for the equatings. If linear=TRUE, then only the standard error vectors for the linear case are included.</p>
</dd>
<dt><code>Pest</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The estimated probability matrix over population P.</p>
</dd>
<dt><code>Pobs</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The observed probability matrix over population P.</p>
</dd>
<dt><code>Qest</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The estimated probability matrix over population Q.</p>
</dd>
<dt><code>Qobs</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The observed probability matrix over population Q.</p>
</dd>
<dt><code>scores</code>:</dt><dd><p>Object of class <code>"list"</code>. A list of data frames containing the score value vectors for the tests X and Y (all designs except NEAT CE) or the score value vectors for the tests X, Y and A (only for NEAT CE). Also included are the estimated score probabilities and the continuized cumulative distribution functions for the respective tests.</p>
</dd>
<dt><code>linear</code>:</dt><dd><p>Object of class <code>"logical"</code>. A logical vector. TRUE if linear=TRUE was specified, otherwise FALSE.</p>
</dd>
<dt><code>pdereqYx</code>:</dt><dd><p>Object of class <code>"matrix"</code>. A matrix with the partial derivative vectors for the equating function.</p>
</dd>
<dt><code>PRE</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. A data frame containing the percent relative error (PRE) in the ten first moments between the equated scores and the reference distribution. (For chain equating, the PRE is calculated for the linking from X to A and the linking from A to Y.)</p>
</dd>
<dt><code>h</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. A data frame containing the continuization parameters used in the equating.</p>
</dd>
<dt><code>kernel</code>:</dt><dd><p>Object of class <code>"character"</code>. A character vector denoting the kernel used.</p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code>. A character vector describing the design used.</p>
</dd>
<dt><code>equating</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. A data frame containing the equated values from X to Y and the associated standard errors (for either an equipercentile or a linear equating), as well as the SEED between the equipercentile and linear equating functions and the equated values and the associated standard errors  in the linear case (if an equipercentile equating is conducted).</p>
</dd>
<dt><code>irt</code>:</dt><dd><p>Object of class <code>"list"</code>. A list containing the objects from the package ltm containing the IRT models specified, and the asymptotic covariance matrix of the item parameters under the regular IRT parametrization. (IRT-OSE only)</p>
</dd>
<dt><code>see</code>:</dt><dd><p>Object of class <code>"character"</code>. A character vector denoting which type of standard errors of equating that are used: analytical or bootstrap.</p>
</dd>
<dt><code>replications</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The number of bootstrap replications if using the bootstrap standard error calculations.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "keout")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "keout")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("keout")
</code></pre>

<hr>
<h2 id='kequate'>
Test Equating Using the Kernel Method
</h2><span id='topic+kequate'></span><span id='topic+kequateCB'></span><span id='topic+kequateEG'></span><span id='topic+kequateNEAT_CE'></span><span id='topic+kequateNEAT_PSE'></span><span id='topic+kequateSG'></span>

<h3>Description</h3>

<p>A function to conduct an equating between two parallel tests using kernel equating. Designs available are equivalent groups (EG), single group (SG), counterbalanced (CB), non-equivalent groups with anchor test using either chain equating (NEAT CE) or post-stratification equating (NEAT PSE) and non-equivalent groups using covariates (NEC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kequate(design, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kequate_+3A_design">design</code></td>
<td>

<p>A character vector indicating which design to use. Possible designs are: EG, SG, CB, NEAT_CE, NEAT_PSE or NEC.
</p>
</td></tr>
<tr><td><code id="kequate_+3A_...">...</code></td>
<td>

<p>Further arguments which partly depend on the design chosen. (See section Details for further information.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Besides the above argument, additional arguments must be provided for the different equating designs.
</p>


<h4>EG design</h4>

<p><br />
&lsquo;x&rsquo;    A vector of possible score values on the test X to be equated, ordered from the lowest to the highest score. 
</p>
<p>&lsquo;y&rsquo;    A vector of possible score values on the test Y to be equated, ordered from the lowest to the highest score.  
</p>
<p>&lsquo;r&rsquo;,&lsquo;s&rsquo;    Numeric vectors containing the estimated or observed score probabilities for tests X and Y respectively.  Alternatively objects of class &lsquo;glm&rsquo;.  
</p>
<p>&lsquo;DMP&rsquo;, &lsquo;DMQ&rsquo;    The design matrices from the log-linear models for the estimated score probabilities for X and Y.  Not needed if arguments r and s are of class &lsquo;glm&rsquo;.  
</p>
<p>&lsquo;N&rsquo;, &lsquo;M&rsquo;    The sample sizes of the groups taking tests X and Y, respectively.  Not needed if arguments r and s are of class &lsquo;glm&rsquo;.  
</p>
<p>&lsquo;hx&rsquo;, &lsquo;hy&rsquo;    Optional arguments to specify the continuization parameters manually.  (If linear=TRUE, then these arguments have no effect.)  
</p>
<p>&lsquo;hxlin&rsquo;, &lsquo;hylin&rsquo;    Optional arguments to specify the continuization parameters manually in the linear case.
</p>
<p>&lsquo;KPEN&rsquo;    The constant used in deciding the optimal continuization parameter.  Default is 0.
</p>
<p>&lsquo;wpen&rsquo;    An argument denoting at which point the derivatives in the second part of the penalty function should be evaluated. Default is 1/4.
</p>
<p>&lsquo;linear&rsquo;    Logical denoting if only a linear equating is to be performed.  Default is FALSE.
</p>
<p>&lsquo;irtx&rsquo;, &lsquo;irty&rsquo; Optional arguments to provide matrices of probabilities to answer correctly to the questions on the parallel tests X and Y, as estimated in an Item Response Theory (IRT) model.
</p>
<p>&lsquo;smoothed&rsquo;    A logical argument denoting if the data provided are pre-smoothed or not. Default is TRUE.
</p>
<p>&lsquo;kernel&rsquo;    A character vector indicating which kernel to use, either &quot;gaussian&quot;, &quot;logistic&quot;, &quot;stdgaussian&quot; or &quot;uniform&quot;. Default is &quot;gaussian&quot;.
</p>
<p>&lsquo;slog&rsquo;    The parameter used in defining the logistic kernel. Default is 1.
</p>
<p>&lsquo;bunif&rsquo;    The parameter used in defining the uniform kernel. Default is 0.5.
</p>
<p>&lsquo;altopt&rsquo;    Logical which sets the bandwidth parameter equal to a variant of Silverman's rule of thumb. Default is FALSE.
</p>
<p>&lsquo;DS&rsquo;    Logical which enables bandwidth selection with the double smoothing method.
</p>



<h4>SG design</h4>

<p><br />
&lsquo;x&rsquo;    A vector of possible score values on the test X to be equated, ordered from the lowest to the highest score. 
</p>
<p>&lsquo;y&rsquo;    A vector of possible score values on the test Y to be equated, ordered from the lowest to the highest score.  
</p>
<p>&lsquo;P&rsquo;    The estimated or observed probability matrix for scores on tests X and Y, where the columns denote scores on test Y and the rows denote scores on test X. Alternatively a vector of score probabilities or an object of class &lsquo;glm&rsquo;, where the entries are ordered first by the Y-scores and then by the X-scores.
</p>
<p>&lsquo;DM&rsquo;    The design matrix used in the log-linear model. Not needed if the argument P is of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;N&rsquo;    The sample size. Not needed if the argument P is of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;hx&rsquo;, &lsquo;hy&rsquo;    Optional arguments to specify the continuization parameter manually. (If linear=TRUE, then these arguments have no effect.)
</p>
<p>&lsquo;hxlin&rsquo;, &lsquo;hylin&rsquo;    Optional arguments to specify the continuization parameters manually in the linear case.
</p>
<p>&lsquo;KPEN&rsquo;    The constant used in deciding the optimal continuization parameter. Default is 0. 
</p>
<p>&lsquo;wpen&rsquo;    An argument denoting at which point the derivatives in the second part of the penalty function should be evaluated. Default is 1/4.
</p>
<p>&lsquo;linear&rsquo;    Logical denoting if only a linear equating is to be performed. Default is FALSE.
</p>
<p>&lsquo;irtx&rsquo;, &lsquo;irty&rsquo;    Optional arguments to provide matrices of probabilities to answer correctly to the questions on the parallel tests X and Y, as estimated in an Item Response Theory (IRT) model.
</p>
<p>&lsquo;smoothed&rsquo;    A logical argument denoting if the data provided are pre-smoothed or not. Default is TRUE.
</p>
<p>&lsquo;kernel&rsquo;    A character vector indicating which kernel to use, either &quot;gaussian&quot;, &quot;logistic&quot;, &quot;stdgaussian&quot; or &quot;uniform&quot;. Default is &quot;gaussian&quot;.
</p>
<p>&lsquo;slog&rsquo;    The parameter used in defining the logistic kernel. Default is 1.
</p>
<p>&lsquo;bunif&rsquo;    The parameter used in defining the uniform kernel. Default is 0.5.
</p>
<p>&lsquo;DS&rsquo;    Logical which enables bandwidth selection with the double smoothing method.
</p>
<p>&lsquo;CV&rsquo;    Logical which enables bandwidth selection with the cross-validation method.
</p>



<h4>CB design</h4>

<p><br />
&lsquo;x&rsquo;    A vector of possible score values on the test X to be equated, ordered from the lowest to the highest score. 
</p>
<p>&lsquo;y&rsquo;    A vector of possible score values on the test Y to be equated, ordered from the lowest to the highest score.  
</p>
<p>&lsquo;P12&rsquo;, &lsquo;P21&rsquo;    The estimated or observed probability matrices for scores on first taking test X and then taking test Y, and first taking test Y and then taking test X respectively, where the rows denote scores on tests X and the columns denote scores on test Y. Alternatively numeric vectors or objects of class &lsquo;glm&rsquo;, where the entries are ordered first by the Y-scores and then by the X-scores.
</p>
<p>&lsquo;DM12&rsquo;, &lsquo;DM21&rsquo;    The design matrices from the log-linear models for the estimated score probabilities for the two test groups. Not needed if arguments P12 and P21 are of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;N&rsquo;, &lsquo;M&rsquo;    The sample sizes for the tests X and A and the tests Y and A, respectively. Not needed if arguments P12 and P21 are of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;hx&rsquo;, &lsquo;hy&rsquo;    Optional arguments to specify the continuization parameters manually. (If linear=TRUE, then these arguments have no effect)
</p>
<p>&lsquo;hxlin&rsquo;, &lsquo;hylin&rsquo;    Optional arguments to specify the continuization parameters manually in the linear case. (Applies both when linear=FALSE and when linear=TRUE.)
</p>
<p>&lsquo;wcb&rsquo;    The weighting of the two groups. Default is 0.5.
</p>
<p>&lsquo;KPEN&rsquo;    Optional argument to specify the constant used in deciding the optimal continuization parameter. Default is 0. 
</p>
<p>&lsquo;wpen&rsquo;    An argument denoting at which point the derivatives in the second part of the penalty function should be evaluated. Default is 1/4.
</p>
<p>&lsquo;linear&rsquo;    Optional logical argument denoting if only a linear equating is to be performed. Default is FALSE.
</p>
<p>&lsquo;irtx&rsquo;, &lsquo;irty&rsquo; Optional arguments to provide matrices of probabilities to answer correctly to the questions on the parallel tests X and Y, as estimated in an Item Response Theory (IRT) model.
</p>
<p>&lsquo;smoothed&rsquo;    A logical argument denoting if the data provided are pre-smoothed or not. Default is TRUE.
</p>
<p>&lsquo;kernel&rsquo;    A character vector indicating which kernel to use, either &quot;gaussian&quot;, &quot;logistic&quot;, &quot;stdgaussian&quot; or &quot;uniform&quot;. Default is &quot;gaussian&quot;.
</p>
<p>&lsquo;slog&rsquo;    The parameter used in defining the logistic kernel. Default is 1.
</p>
<p>&lsquo;bunif&rsquo;    The parameter used in defining the uniform kernel. Default is 0.5.
</p>
<p>&lsquo;altopt&rsquo;    Logical which sets the bandwidth parameter equal to a variant of Silverman's rule of thumb. Default is FALSE.
</p>
<p>&lsquo;DS&rsquo;    Logical which enables bandwidth selection with the double smoothing method.
</p>
<p>&lsquo;CV&rsquo;    Logical which enables bandwidth selection with the cross-validation method.
</p>



<h4>NEAT PSE or NEC design</h4>

<p><br />
&lsquo;x&rsquo;    A vector of possible score values on the test X to be equated, ordered from the lowest to the highest score. 
</p>
<p>&lsquo;y&rsquo;    A vector of possible score values on the test Y to be equated, ordered from the lowest to the highest score.  
</p>
<p>&lsquo;P&rsquo;, &lsquo;Q&rsquo;    The estimated or observed probability matrices for scores on tests X and A and tests Y and A respectively, where the rows denote scores on tests X or Y and the columns denote scores on test A. Alternatively numeric vectors or objects of class &lsquo;glm&rsquo;, where the entries are ordered first by the X-scores/Y-scores and then by the A-scores.
</p>
<p>&lsquo;DMP&rsquo;, &lsquo;DMQ&rsquo;    The design matrices from the log-linear models for the estimated score probabilities for X and A and Y and A. Not needed if arguments P and Q are of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;N&rsquo;, &lsquo;M&rsquo;    The sample sizes for the tests X and A and the tests Y and A, respectively. Not needed if arguments P and Q are of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;w&rsquo;    The weighting of the synthetic population. Default is 0.5.
</p>
<p>&lsquo;hx&rsquo;, &lsquo;hy&rsquo;    Optional arguments to specify the continuization parameters manually. (If linear=TRUE, then these arguments have no effect)
</p>
<p>&lsquo;hxlin&rsquo;, &lsquo;hylin&rsquo;    Optional arguments to specify the continuization parameters manually in the linear case. (Applies both when linear=FALSE and when linear=TRUE.)
</p>
<p>&lsquo;KPEN&rsquo;    Optional argument to specify the constant used in deciding the optimal continuization parameter. Default is 0. 
</p>
<p>&lsquo;wpen&rsquo;    An argument denoting at which point the derivatives in the second part of the penalty function should be evaluated. Default is 1/4.
</p>
<p>&lsquo;linear&rsquo;    Optional logical argument denoting if only a linear equating is to be performed. Default is FALSE.
</p>
<p>&lsquo;irtx&rsquo;, &lsquo;irty&rsquo; Optional arguments to provide matrices of probabilities to answer correctly to the questions on the parallel tests X and Y, as estimated in an Item Response Theory (IRT) model.
</p>
<p>&lsquo;smoothed&rsquo;    A logical argument denoting if the data provided are pre-smoothed or not. Default is TRUE.
</p>
<p>&lsquo;kernel&rsquo;    A character vector indicating which kernel to use, either &quot;gaussian&quot;, &quot;logistic&quot;, &quot;stdgaussian&quot; or &quot;uniform&quot;. Default is &quot;gaussian&quot;.
</p>
<p>&lsquo;slog&rsquo;    The parameter used in defining the logistic kernel. Default is 1.
</p>
<p>&lsquo;bunif&rsquo;    The parameter used in defining the uniform kernel. Default is 0.5.
</p>
<p>&lsquo;altopt&rsquo;    Logical which sets the bandwidth parameter equal to a variant of Silverman's rule of thumb. Default is FALSE.
</p>
<p>&lsquo;DS&rsquo;    Logical which enables bandwidth selection with the double smoothing method.
</p>
<p>&lsquo;CV&rsquo;    Logical which enables bandwidth selection with the cross-validation method.
</p>



<h4>NEAT CE design</h4>

<p><br />
&lsquo;x&rsquo;    A vector of possible score values on the test X to be equated, ordered from the lowest to the highest score. 
</p>
<p>&lsquo;y&rsquo;    A vector of possible score values on the test Y to be equated, ordered from the lowest to the highest score.  
</p>
<p>&lsquo;a&rsquo;    A vector containing the possible score values on the anchor test, ordered from the lowest score to the highest.
</p>
<p>&lsquo;P&rsquo;, &lsquo;Q&rsquo;    The estimated or observed probability matrices for scores on tests X and A and tests Y and A respectively, where the rows denote scores on test X or Y and the columns denote scores on test A. Alternatively numeric vectors or objects of class &lsquo;glm&rsquo;, where the entries are ordered first by the X-scores/Y-scores and then by the A-scores.
</p>
<p>&lsquo;DMP&rsquo;, &lsquo;DMQ&rsquo;    The design matrices from the log-linear models for the estimated score probabilities for X and A and Y and A, respectively. Not needed if arguments P and Q are of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;N&rsquo;, &lsquo;M&rsquo;    The sample sizes for the tests X and A and the tests Y and A, respectively. Not needed if arguments P and Q are of class &lsquo;glm&rsquo;.
</p>
<p>&lsquo;hxP&rsquo;, &lsquo;hyQ&rsquo;, &lsquo;haP&rsquo;, &lsquo;haQ&rsquo;    Optional arguments to specify the continuization parameters manually. (If linear=TRUE, then these arguments have no effect.)
</p>
<p>&lsquo;hxPlin&rsquo;, &lsquo;hyQlin&rsquo;, &lsquo;haPlin&rsquo;, &lsquo;haQlin&rsquo;    Optional arguments to specify the continuization parameters manually in the linear case. (Applies both when linear=FALSE and when linear=TRUE.)
</p>
<p>&lsquo;KPEN&rsquo;    Optional argument to specify the constant used in deciding the optimal continuization parameter. Default is 0.
</p>
<p>&lsquo;wpen&rsquo;    An argument denoting at which point the derivatives in the second part of the penalty function should be evaluated. Default is 1/4.
</p>
<p>&lsquo;linear&rsquo;    Optional logical argument denoting if only a linear equating is to be performed. Default is FALSE.
</p>
<p>&lsquo;irtx&rsquo;, &lsquo;irty&rsquo; Optional arguments to provide matrices of probabilities to answer correctly to the questions on the parallel tests X and Y, as estimated in an Item Response Theory (IRT) model.
</p>
<p>&lsquo;smoothed&rsquo;    A logical argument denoting if the data provided are pre-smoothed or not. Default is TRUE.
</p>
<p>&lsquo;kernel&rsquo;    A character vector indicating which kernel to use, either &quot;gaussian&quot;, &quot;logistic&quot;, &quot;stdgaussian&quot; or &quot;uniform&quot;. Default is &quot;gaussian&quot;.
</p>
<p>&lsquo;slog&rsquo;    The parameter used in defining the logistic kernel. Default is 1.
</p>
<p>&lsquo;bunif&rsquo;    The parameter used in defining the uniform kernel. Default is 0.5.
</p>
<p>&lsquo;altopt&rsquo;    Logical which sets the bandwidth parameter equal to a variant of Silverman's rule of thumb. Default is FALSE.
</p>
<p>&lsquo;DS&rsquo;    Logical which enables bandwidth selection with the double smoothing method.
</p>
<p>&lsquo;CV&rsquo;    Logical which enables bandwidth selection with the cross-validation method.
</p>



<h3>Value</h3>

<p>Kequate returns an S4 object of class 'keout' which includes the following slots (accessed by using the get functions):
</p>
<table>
<tr><td><code>Cr</code></td>
<td>
<p>The C-matrix from the log-linear model of test X on population P. (EG design only)</p>
</td></tr>
<tr><td><code>Cs</code></td>
<td>
<p>The C-matrix from the log-linear model of test Y on population Q. (EG design only)</p>
</td></tr>
<tr><td><code>Cp</code></td>
<td>
<p>The C-matrix from the log-linear model of tests X and Y or X and A on population P. (SG/NEAT CE/NEAT PSE/NEC designs only)</p>
</td></tr>
<tr><td><code>Cq</code></td>
<td>
<p>The C-matrix from the log-linear model of tests X and Y or X and A on population Q. (NEAT CE/NEAT PSE/NEC designs only)</p>
</td></tr>
<tr><td><code>SEEvect</code></td>
<td>
<p>An object of class SEEvect consisting of matrices containing the standard error vectors for the equatings. If linear=TRUE, then only the standard error vectors for the linear case are included.</p>
</td></tr>
<tr><td><code>Pest</code></td>
<td>
<p>The estimated probability matrix over population P.</p>
</td></tr>
<tr><td><code>Pobs</code></td>
<td>
<p>The observed probability matrix over population P.</p>
</td></tr>
<tr><td><code>Qest</code></td>
<td>
<p>The estimated probability matrix over population Q.</p>
</td></tr>
<tr><td><code>Qobs</code></td>
<td>
<p>The observed probability matrix over population Q.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>A list containing the score vectors for the tests to be equated and, in a NEAT CE design, the score vector of the anchor test. Also included are the estimated score probabilities and the continuized cumulative distribution functions for the respective tests.</p>
</td></tr>
<tr><td><code>linear</code></td>
<td>
<p>A logical vector. TRUE if linear=TRUE was specified, otherwise FALSE.</p>
</td></tr>
<tr><td><code>PRE</code></td>
<td>
<p>A data frame containing the percent relative error in the ten first moments between the equated scores and the reference distribution. (For chain equating, the PRE is calculated for the linking from X to A and the linking from A to Y.)</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>A data frame containing the continuization parameters used in the equating.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>A character vector denoting the kernel used.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character vector describing the design used.</p>
</td></tr>
<tr><td><code>equating</code></td>
<td>
<p>A data frame containing the equated values from X to Y and the associated standard errors (for either an equipercentile or a linear equating), as well as the SEED between the equipercentile and linear equating functions and the equated values and the associated standard errors in the linear case (if an equipercentile equating is conducted).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>References</h3>

<p>Andersson, B., Branberg, K., and Wiberg, M. (2013). Performing the Kernel Method of Test Equating with the Package <b>kequate</b>. <em>Journal of Statistical Software</em>, <b>55(6)</b>, 1&ndash;25. &lt;doi:10.18637/jss.v055.i06&gt;
</p>
<p>von Davier, A.A., Holland, P.W., Thayer, D.T. (2004). <em>The Kernel Method of Test Equating.</em> Springer-Verlag New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>,<code><a href="#topic+kefreq">kefreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#EG toy example with different kernels
P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
keEGlog&lt;-kequate("EG", 0:4, 0:4, glmx, glmy, kernel="logistic", slog=sqrt(3)/pi)
keEGuni&lt;-kequate("EG", 0:4, 0:4, glmx, glmy, kernel="uniform", bunif=sqrt(3))
plot(keEG)

## Not run: 
#NEAT example using simulated data
data(simeq)
freq1 &lt;- kefreq(simeq$bivar1$X, 0:20, simeq$bivar1$A, 0:10)
freq2 &lt;- kefreq(simeq$bivar2$Y, 0:20, simeq$bivar2$A, 0:10)
glm1&lt;-glm(frequency~I(X)+I(X^2)+I(X^3)+I(X^4)+I(X^5)+I(A)+I(A^2)+I(A^3)+I(A^4)+
I(A):I(X)+I(A):I(X^2)+I(A^2):I(X)+I(A^2):I(X^2), family="poisson", data=freq1, x=TRUE)
glm2&lt;-glm(frequency~I(X)+I(X^2)+I(A)+I(A^2)+I(A^3)+I(A^4)+I(A):I(X)+I(A):I(X^2)+
I(A^2):I(X)+I(A^2):I(X^2), family="poisson", data=freq2, x=TRUE)
keNEATPSE &lt;- kequate("NEAT_PSE", 0:20, 0:20, glm1, glm2)
keNEATCE &lt;- kequate("NEAT_CE", 0:20, 0:20, 0:10, glm1, glm2)
summary(keNEATPSE)
summary(keNEATCE)

#IRT observed-score equating
keNEATCEirt &lt;- kequate("NEAT_CE", 0:20, 0:20, 0:10, glm1, glm2, irtx=simeq$irtNEATx, 
irty=simeq$irtNEATy)
getEquating(keNEATCEirt)

## End(Not run)
</code></pre>

<hr>
<h2 id='kequate-package'>
The Kernel Method of Test Equating
</h2><span id='topic+kequate-package'></span>

<h3>Description</h3>

<p>The kernel equating technique for equating test scores is implemented, supporting the Equivalent Groups (EG), Single Group (SG), Counterbalanced (CB), Non-Equivalent groups with Anchor Test Chain Equating (NEAT CE), Non-Equivalent groups with Anchor Test Post-Stratification Equating (NEAT PSE) and Non-Equivalent groups with Covariates (NEC) designs. Support for three types of kernels is provided: Gaussian, logistic and uniform. Standard errors of equating and standard errors of the difference between two equating functions are provided for all designs and kernels. Also included are functions aiding the search for a proper log-linear pre-smoothing model and the ability to use Item Response Theory Observed Score Equating (IRT-OSE) in the Kernel Equating framework.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> kequate</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.6.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-04-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;=2.11.0), methods, graphics, stats, ltm</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Björn Andersson, Kenny Branberg and Marie Wiberg
</p>
<p>Maintainer: Björn Andersson <a href="mailto:bjoern.h.andersson@gmail.com">bjoern.h.andersson@gmail.com</a>
</p>


<h3>References</h3>

<p>Andersson, B. and Wiberg, M. (2017). Item Response Theory Observed-Score Kernel Equating. <em>Psychometrika</em>, <b>83</b>, 48–67. &lt;doi:10.1007/s11336-016-9528-7&gt;
</p>
<p>Andersson, B., Branberg, K., and Wiberg, M. (2013). Performing the Kernel Method of Test Equating with the Package <b>kequate</b>. <em>Journal of Statistical Software</em>, <b>55(6)</b>, 1&ndash;25. &lt;doi:10.18637/jss.v055.i06&gt;
</p>
<p>Branberg, K. and Wiberg, M. (2011). Observed Score Linear Equating with Covariates.  <em>Journal of Educational Measurement</em>, <b>44(4)</b>, 419&ndash;440. &lt;doi:10.1111/j.1745-3984.2011.00153.x&gt;
</p>
<p>von Davier, A.A., Holland, P.W., and Thayer, D.T. (2004). <em>The Kernel Method of Test Equating.</em> Springer-Verlag New York.
</p>
<p>Holland, P.W. and Thayer, D. (1998). Univariate and Bivariate Loglinear Models for Discrete Test Score Distributions <em>ETS Technical Report No</em> <b>98-1</b>.
</p>

<hr>
<h2 id='plot-methods'> ~~ Methods for Function plot  ~~</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY+2CANY-method'></span><span id='topic+plot+2Ccdist+2CANY-method'></span><span id='topic+plot+2Cgenseed+2CANY-method'></span><span id='topic+plot+2Ckeout+2CANY-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>plot</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "cdist")</code></dt><dd>
<p>Plots the conditional means and variances of an observed and an estimated bivariate test score distribution.
</p>
</dd>
<dt><code>signature(x = "genseed")</code></dt><dd>
<p>Plots the difference between two equating functions with +/- 2*SEED boundaries for both equating from X to Y and from Y to X.
</p>
</dd>
<dt><code>signature(x = "keout")</code></dt><dd>
<p>Plots the equated values from the equating against the score values of the equated test.
</p>
</dd>
</dl>

<hr>
<h2 id='PREp'>
Percent Relative Error
</h2><span id='topic+PREp'></span>

<h3>Description</h3>

<p>Calculates the percent relative error (PRE) between an equated distribution and the reference distribution for the first ten moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PREp(eq, obs, r, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PREp_+3A_eq">eq</code></td>
<td>

<p>A numeric vector containing the equated values from X to Y or Y to X.
</p>
</td></tr>
<tr><td><code id="PREp_+3A_obs">obs</code></td>
<td>

<p>The score vector of test Y or X.
</p>
</td></tr>
<tr><td><code id="PREp_+3A_r">r</code></td>
<td>

<p>A vector of probabilities corresponding to the equated values.
</p>
</td></tr>
<tr><td><code id="PREp_+3A_s">s</code></td>
<td>

<p>A vector of probabilities corresponding to the score values of test Y or X.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If we equate test X to test Y, then we have equated values eYx with estimated probabilities r and estimated probabilities s for the score values on Y. To compare the moments between these two distributions, we can calculate the percent relative error (PRE) between them. If we denote the p:th moment of Y and eYx by <code class="reqn">\mu(Y)</code> and <code class="reqn">\mu(eYx)</code> respectively, the PRE for moment p is defined as
</p>
<p style="text-align: center;"><code class="reqn">PRE(p) = \frac{100 \mu(eYx)-\mu(Y)}{\mu(Y)}.</code>
</p>



<h3>Value</h3>

<p>A numeric  vector containing the percentage relative error for the first ten moments.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:bjorn.andersson@statistik.uu.se">bjorn.andersson@statistik.uu.se</a><br />
<a href="mailto:kenny.branberg@stat.umu.se">kenny.branberg@stat.umu.se</a><br />
<a href="mailto:marie.wiberg@stat.umu.se">marie.wiberg@stat.umu.se</a>
</p>


<h3>References</h3>

<p>Andersson, B., Branberg, K., Wiberg, M. (2013). Performing the Kernel Method of Test Equating with the Package <b>kequate</b>. <em>Journal of Statistical Software</em>, <b>55(6)</b>, 1&ndash;25. &lt;doi: 10.18637/jss.v055.i06&gt;
</p>
<p>von Davier, A.A., Holland, P.W., Thayer, D.T. (2004). <em>The Kernel Method of Test Equating.</em> Springer-Verlag New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>
<code><a href="#topic+kequate">kequate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P&lt;-c(5, 20, 35, 25, 15)
Q&lt;-c(10, 30, 30, 20, 10)
x&lt;-0:4
glmx&lt;-glm(P~I(x)+I(x^2), family="poisson", x=TRUE)
glmy&lt;-glm(Q~I(x)+I(x^2), family="poisson", x=TRUE)
keEG&lt;-kequate("EG", 0:4, 0:4, glmx, glmy)
PREp(getEq(keEG), 0:4, glmx$fitted.values/100, glmy$fitted.values/100)
</code></pre>

<hr>
<h2 id='simeq'>Simulated Test Data</h2><span id='topic+simeq'></span>

<h3>Description</h3>

<p>Contains bivariate test score data (bivar1 and bivar2), IRT data (irtNEATx and irtNEATy), data from an equivalent groups (EG) design (FXEGglm and FYEGglm) and data from a non-equivalent groups with covariates (NEC) design (testdata1 and testdata2), for usage in equating.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simeq)</code></pre>


<h3>Format</h3>

<p>A list containing the data frames bivar1 and bivar2 with 1000 observations each, two 5x20 matrices irtNEATx and irtNEATy, two glm objects FXEGglm and FYEGglm and two data frames testdata1 and testdata2.</p>


<h3>Source</h3>

<p>The EG data is taken from the log-linear models specified in von Davier (2004). The remaining data was generated in R.</p>


<h3>References</h3>

<p>Branberg, K. and Wiberg, M. (2011). Observed Score Linear Equating with Covariates.  <em>Journal of Educational Measurement</em>, <b>44(4)</b>, 419&ndash;440. &lt;doi:10.1111/j.1745-3984.2011.00153.x&gt;
</p>
<p>von Davier, A.A., Holland, P.W., Thayer, D.T. (2004). <em>The Kernel Method of Test Equating.</em> Springer-Verlag New York.
</p>

<hr>
<h2 id='summary-methods'> ~~ Methods for Function summary  ~~</h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2Ckeout-method'></span><span id='topic+summary+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>summary</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>

</dd>
<dt><code>signature(object = "keout")</code></dt><dd>

</dd>
<dt><code>signature(object = "sparseMatrix")</code></dt><dd>

</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
