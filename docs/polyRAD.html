<!DOCTYPE html><html><head><title>Help for package polyRAD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polyRAD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Accessors'>
<p>Accessor Functions for RADdata Objects</p></a></li>
<li><a href='#AddAlleleFreqByTaxa'>
<p>Estimate Local Allele Frequencies for Each Taxon Based on Population Structure</p></a></li>
<li><a href='#AddAlleleFreqHWE'>
<p>Estimate Allele Frequencies in a RADdata Object Assuming Hardy-Weinberg Equilibrium</p></a></li>
<li><a href='#AddAlleleFreqMapping'>
<p>Estimate Allele Frequencies in a Mapping Population</p></a></li>
<li><a href='#AddAlleleLinkages'>
<p>Identify and Utilize Linked Alleles for Estimating Genotype Priors</p></a></li>
<li><a href='#AddGenotypeLikelihood'>
<p>Estimate Genotype Likelihoods in a RADdata object</p></a></li>
<li><a href='#AddGenotypePosteriorProb'>
<p>Estimate Posterior Probabilities of Genotypes</p></a></li>
<li><a href='#AddGenotypePriorProb_ByTaxa'>
<p>Estimate Prior Genotype Probabilities on a Per-Taxon Basis</p></a></li>
<li><a href='#AddGenotypePriorProb_Even'>
<p>Add Uniform Priors to a RADdata Object</p></a></li>
<li><a href='#AddGenotypePriorProb_HWE'>
<p>Estimate Genotype Prior Probabilities In the Absence of Population Structure</p></a></li>
<li><a href='#AddGenotypePriorProb_Mapping2Parents'>
<p>Expected Genotype Frequencies in Mapping Populations</p></a></li>
<li><a href='#AddPCA'>
<p>Perform Principal Components Analysis on &ldquo;RADdata&rdquo; Object</p></a></li>
<li><a href='#AddPloidyChiSq'>
<p>Chi-Square Test on Genotype Likelihood Distributions</p></a></li>
<li><a href='#AddPloidyLikelihood'>
<p>Likelihoods for Possible Ploidies Based on Genotype Distributions</p></a></li>
<li><a href='#CanDoGetWeightedMeanGeno'>
<p>Check Whether <code>GetWeightedMeanGenotypes</code> Can Be Run</p></a></li>
<li><a href='#EstimateContaminationRate'>
<p>Estimate Sample Contamination Using Blanks</p></a></li>
<li><a href='#ExamineGenotype'>
<p>Plots to Examine Genotype Calling at a Single Taxon and Allele</p></a></li>
<li><a href='#exampleRAD'>
<p>Miniature Datasets for Testing polyRAD Functions</p></a></li>
<li><a href='#ExpectedHindHe'>
<p>Simulate Data to Get Expected Distribution of Hind/He</p></a></li>
<li><a href='#ExportGAPIT'>
<p>Export RADdata Object for Use by Other R Packages</p></a></li>
<li><a href='#GetLikelyGen'>
<p>Output the Most Likely Genotype</p></a></li>
<li><a href='#GetWeightedMeanGenotypes'>
<p>Export Numeric Genotype Values from Posterior Probabilities</p></a></li>
<li><a href='#HindHe'>
<p>Identify Non-Mendelian Loci and Taxa that Deviate from Ploidy Expectations</p></a></li>
<li><a href='#InbreedingFromHindHe'>
<p>Estimate Inbreeding from Hind/He for a Given Ploidy</p></a></li>
<li><a href='#IterateHWE'>
<p>Iteratively Estimate Population Parameters and Genotypes In a Diversity Panel</p></a></li>
<li><a href='#LocusInfo'>
<p>Get Information about a Single Locus</p></a></li>
<li><a href='#MakeTasselVcfFilter'>
<p>Filter Lines of a VCF File By Call Rate and Allele Frequency</p></a></li>
<li><a href='#MergeIdenticalHaplotypes'>
<p>Merge Alleles with Identical DNA Sequences</p></a></li>
<li><a href='#MergeRareHaplotypes'>
<p>Consolidate Reads from Rare Alleles</p></a></li>
<li><a href='#MergeTaxaDepth'>
<p>Combine Read Depths from Multiple Taxa into One Taxon</p></a></li>
<li><a href='#OneAllelePerMarker'>
<p>Return the Index of One Allele for Each Locus</p></a></li>
<li><a href='#PipelineMapping2Parents'>
<p>Run polyRAD Pipeline on a Mapping Population</p></a></li>
<li><a href='#RADdata'>
<p>RADdata object constructor</p></a></li>
<li><a href='#RADdata2VCF'>
<p>Export RADdata Genotypes to VCF</p></a></li>
<li><a href='#readDArTag'>
<p>Import Data from DArT Sequencing</p></a></li>
<li><a href='#readHMC'>
<p>Import read depth from UNEAK</p></a></li>
<li><a href='#readProcessIsoloci'>
<p>Import Read Depth from Output of process_isoloci.py</p></a></li>
<li><a href='#readProcessSamMulti'>
<p>Import Preliminary Data to Determine Parameters for Isolocus Sorting</p></a></li>
<li><a href='#readStacks'>
<p>Import Read Depth from Stacks</p></a></li>
<li><a href='#readTagDigger'>
<p>Import Read Counts from TagDigger</p></a></li>
<li><a href='#readTASSELGBSv2'>
<p>Import Read Depth and Alignment from TASSEL GBS v2</p></a></li>
<li><a href='#reverseComplement'>
<p>Reverse Complement of DNA Sequence Stored as Character String</p></a></li>
<li><a href='#SetBlankTaxa'>
<p>Functions to Assign Taxa to Specific Roles</p></a></li>
<li><a href='#StripDown'>
<p>Remove Unneeded Slots to Conserve Memory</p></a></li>
<li><a href='#SubsetByLocus'>
<p>Create RADdata Objects with a Subset of Loci</p></a></li>
<li><a href='#SubsetByPloidy'>
<p>Create a RADdata object with a Subset of Possible Ploidies</p></a></li>
<li><a href='#SubsetByTaxon'>
<p>Create RADdata Object with a Subset of Taxa</p></a></li>
<li><a href='#TestOverdispersion'>
<p>Test the Fit of Read Depth to Beta-Binomial Distribution</p></a></li>
<li><a href='#VCF2RADdata'>
<p>Create a RADdata Object from a VCF File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Genotype Calling with Uncertainty from Sequencing Data in
Polyploids and Diploids</td>
</tr>
<tr>
<td>Author:</td>
<td>Lindsay V. Clark <a href="https://orcid.org/0000-0002-3881-9252"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  U.S. National Science Foundation [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lindsay V. Clark &lt;Lindsay.Clark@seattlechildrens.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>fastmatch, pcaMethods, Rcpp, stringi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rrBLUP, Rsamtools, GenomeInfoDb, Biostrings, GenomicRanges,
VariantAnnotation, SummarizedExperiment, S4Vectors, IRanges,
BiocGenerics, knitr, rmarkdown, GenomicFeatures, ggplot2,
adegenet</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Read depth data from genotyping-by-sequencing (GBS) or restriction 
  site-associated DNA sequencing (RAD-seq) are imported and used to make Bayesian
  probability estimates of genotypes in polyploids or diploids.  The genotype 
  probabilities, posterior mean genotypes, or most probable genotypes can then
  be exported for downstream analysis.  'polyRAD' is described by Clark et al.
  (2019) &lt;<a href="https://doi.org/10.1534%2Fg3.118.200913">doi:10.1534/g3.118.200913</a>&gt;, and the Hind/He statistic for marker
  filtering is described by Clark et al. (2022) &lt;<a href="https://doi.org/10.1186%2Fs12859-022-04635-9">doi:10.1186/s12859-022-04635-9</a>&gt;.
  A variant calling pipeline for highly duplicated genomes is also included and
  is described by Clark et al. (2020, Version 1) &lt;<a href="https://doi.org/10.1101%2F2020.01.11.902890">doi:10.1101/2020.01.11.902890</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lvclark/polyRAD">https://github.com/lvclark/polyRAD</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-06 16:52:52 UTC; lclar5</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-06 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Accessors'>
Accessor Functions for RADdata Objects
</h2><span id='topic+GetTaxa'></span><span id='topic+GetLoci'></span><span id='topic+GetLocDepth'></span><span id='topic+GetContamRate'></span><span id='topic+SetContamRate'></span><span id='topic+nTaxa'></span><span id='topic+nLoci'></span><span id='topic+nAlleles'></span><span id='topic+GetAlleleNames'></span><span id='topic+GetTaxaPloidy'></span><span id='topic+SetTaxaPloidy'></span><span id='topic+GetTaxaByPloidy'></span><span id='topic+GetTaxaByPloidy.RADdata'></span>

<h3>Description</h3>

<p>These functions can be used for accessing and replacing data within
a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  Data slots that do not yet have
accessors can be accessed and replaced using the <code>$</code> operator or the
<code>attr</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTaxa(object, ...)
GetLoci(object, ...)
GetLocDepth(object, ...)
GetContamRate(object, ...)
SetContamRate(object, value, ...)
nTaxa(object, ...)
nLoci(object, ...)
nAlleles(object, ...)
GetAlleleNames(object, ...)
GetTaxaPloidy(object, ...)
SetTaxaPloidy(object, value, ...)
GetTaxaByPloidy(object, ...)

## S3 method for class 'RADdata'
GetTaxaByPloidy(object, ploidy, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Accessors_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="Accessors_+3A_value">value</code></td>
<td>

<p>A value to assign.  For <code>SetContamRate</code>, a number generally ranging 
from zero to 0.01 indicating the expected rate of sample cross-contamination.
For <code>SetTaxaPloidy</code>, a vector of integers indicating ploidy, with one
value for each taxon.  If the vector for <code>SetTaxaPloidy</code> is named, the
names should correspond to taxa names in the object.
</p>
</td></tr>
<tr><td><code id="Accessors_+3A_ploidy">ploidy</code></td>
<td>

<p>An integer indicating a single ploidy for which to return taxa.
</p>
</td></tr>
<tr><td><code id="Accessors_+3A_...">...</code></td>
<td>

<p>Additional arguments (none currently supported).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>GetTaxa</code> and <code>GetLoci</code>, a character vector listing taxa names
or loci names, respectively.  For <code>GetLocDepth</code>, a named matrix with
taxa in rows and loci in columns, giving the total read depth for each taxon
and locus.  For <code>GetContamRate</code>, a number indicating the expected 
contamination rate that is stored in the object.  For <code>SetContamRate</code>, a
<code>"RADdata"</code> object with an updated contamination rate.
For <code>nTaxa</code>, the number of taxa in the object.  For <code>nLoci</code>, the 
number of loci in the object.  For <code>nAlleles</code>, the
number of alleles across all loci in the object.  For <code>GetAlleleNames</code>,
the names of all alleles.  For <code>GetTaxaPloidy</code>, a named integer vector
indicating the ploidy of each taxon.  For <code>SetTaxaPloidy</code>, a
<code>"RADdata"</code> object with the taxa ploidies updated.  For
<code>GetTaxaByPloidy</code>, a character vector listing taxa.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SetBlankTaxa">SetBlankTaxa</a></code> for functions that assign taxa to particular roles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)
GetTaxa(exampleRAD)
GetLoci(exampleRAD)
GetLocDepth(exampleRAD)
GetContamRate(exampleRAD)
exampleRAD &lt;- SetContamRate(exampleRAD, 0.0000001)
GetContamRate(exampleRAD)
nTaxa(exampleRAD)
nAlleles(exampleRAD)
GetAlleleNames(exampleRAD)
GetTaxaPloidy(exampleRAD)
exampleRAD &lt;- SetTaxaPloidy(exampleRAD, rep(c(2, 5), time = c(75, 25)))
GetTaxaByPloidy(exampleRAD, 2)
</code></pre>

<hr>
<h2 id='AddAlleleFreqByTaxa'>
Estimate Local Allele Frequencies for Each Taxon Based on Population Structure
</h2><span id='topic+AddAlleleFreqByTaxa'></span><span id='topic+AddAlleleFreqByTaxa.RADdata'></span>

<h3>Description</h3>

<p>This function estimates allele frequencies per taxon, rather than for the whole
population.  The best estimated genotypes (either <code>object$depthRatio</code> or
<code>GetWeightedMeanGenotypes(object)</code>) are regressed against principal 
coordinate axes.  The regression coefficients are then in turn used to 
predict allele frequencies from PC axes.  Allele frequencies outside of a 
user-defined range are then adjusted so that they fall within that range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAlleleFreqByTaxa(object, ...)
## S3 method for class 'RADdata'
AddAlleleFreqByTaxa(object, minfreq = 0.0001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddAlleleFreqByTaxa_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  <code><a href="#topic+AddPCA">AddPCA</a></code> should have already
been run.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqByTaxa_+3A_minfreq">minfreq</code></td>
<td>

<p>The minimum allowable allele frequency to be output.  The maximum allowable
allele frequency will be calculated as <code>1 - minfreq</code>.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqByTaxa_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every allele, all PC axes stored in <code>object$PCA</code> are used for 
generating regression coefficients and making predictions, regardless of whether
they are significantly associated with the allele.
</p>
<p><code>object$depthRatio</code> has missing data for loci with no reads; these missing
data are omitted on a per-allele basis when calculating regression coefficients.
However, allele frequencies are output for all taxa at all alleles, because
there are no missing data in the PC axes.  The output of 
<code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> has no missing data, so missing data are
not an issue when calculating regression coefficients using that method.
</p>
<p>After predicting allele frequencies from the regression coefficients, the
function loops through all loci and taxa to adjust allele frequencies if necessary.
This is needed because otherwise some allele frequencies will be below zero or
above one (typically in subpopulations where alleles are near fixation), 
which interferes with prior genotype probability estimation.  For a 
given taxon and locus, any allele frequencies below <code>minfreq</code> are adjusted
to be equal to <code>minfreq</code>, and any allele frequencies above <code>1 - minfreq</code>
are adjusted to be <code>1 - minfreq</code>.  Remaining allele frequencies are adjusted
so that all allele frequencies for the taxon and locus sum to one.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to the one passed to the function, but with
a matrix of allele frequencies added to the <code>$alleleFreqByTaxa</code> slot.  Taxa
are in rows and alleles in columns.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypePriorProb_ByTaxa">AddGenotypePriorProb_ByTaxa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(exampleRAD)
# do PCA
exampleRAD &lt;- AddPCA(exampleRAD, nPcsInit = 3)

# get allele frequencies
exampleRAD &lt;- AddAlleleFreqByTaxa(exampleRAD)

exampleRAD$alleleFreqByTaxa[1:10,]
</code></pre>

<hr>
<h2 id='AddAlleleFreqHWE'>
Estimate Allele Frequencies in a RADdata Object Assuming Hardy-Weinberg Equilibrium
</h2><span id='topic+AddAlleleFreqHWE'></span><span id='topic+AddAlleleFreqHWE.RADdata'></span>

<h3>Description</h3>

<p>Allele frequencies are estimated based on the best parameters available.
<code>object$alleleFreqByTaxa</code> is used if available.  If <code>object$alleleFreqByTaxa</code>
is null, <code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> is used, and if that isn't possible
<code>object$depthRatio</code> is used.  From whichever of the three options is used, 
column means are taken, the output of which is stored as <code>object$alleleFreq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAlleleFreqHWE(object, ...)
## S3 method for class 'RADdata'
AddAlleleFreqHWE(object, excludeTaxa = GetBlankTaxa(object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddAlleleFreqHWE_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqHWE_+3A_excludetaxa">excludeTaxa</code></td>
<td>

<p>A character vector indicating taxa that should be excluded from the calculation.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqHWE_+3A_...">...</code></td>
<td>

<p>Included to allow more arguments in the future, although none are currently used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to the one passed to the function, but 
with allele frequencies added to <code>object$alleleFreq</code>, and <code>"HWE"</code>
as the value for the <code>"alleleFreqType"</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddAlleleFreqMapping">AddAlleleFreqMapping</a></code>, <code><a href="#topic+AddGenotypePriorProb_HWE">AddGenotypePriorProb_HWE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in an example dataset
data(exampleRAD)
exampleRAD

# add allele frequencies
exampleRAD &lt;- AddAlleleFreqHWE(exampleRAD)
exampleRAD$alleleFreq
</code></pre>

<hr>
<h2 id='AddAlleleFreqMapping'>
Estimate Allele Frequencies in a Mapping Population
</h2><span id='topic+AddAlleleFreqMapping'></span><span id='topic+AddAlleleFreqMapping.RADdata'></span>

<h3>Description</h3>

<p>Estimate allele frequencies using data from a mapping population, assuming
a fixed set of allele frequencies are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAlleleFreqMapping(object, ...)
## S3 method for class 'RADdata'
AddAlleleFreqMapping(object, expectedFreqs = seq(0, 1, 0.25),
                     allowedDeviation = 0.05,
                     excludeTaxa = c(GetDonorParent(object),
                                     GetRecurrentParent(object),
                                     GetBlankTaxa(object)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddAlleleFreqMapping_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  The donor and recurrent parent should have
been assigned with <code><a href="#topic+SetDonorParent">SetDonorParent</a></code> and 
<code><a href="#topic+SetRecurrentParent">SetRecurrentParent</a></code>, respectively.  If this is not a backcross
population, it does not matter which is the donor or recurrent parent.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqMapping_+3A_expectedfreqs">expectedFreqs</code></td>
<td>

<p>A numeric vector listing all expected allele frequencies in the mapping
population.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqMapping_+3A_alloweddeviation">allowedDeviation</code></td>
<td>

<p>A value indicating how far an observed allele frequency can deviate from an
expected allele frequency and still be categorized as that allele frequency.
Must be no more than half the smallest interval seen in <code>expectedFreqs</code>.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqMapping_+3A_excludetaxa">excludeTaxa</code></td>
<td>

<p>A character vector indicating taxa that should be excluded from the allele 
frequency estimate.
</p>
</td></tr>
<tr><td><code id="AddAlleleFreqMapping_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to the method for <code>"RADdata"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allele frequencies are first estimated as the column means of 
<code>object$depthRatio</code> (unless posterior genotype probabilities and ploidy
chi-squared values have already been calculated, in which case 
<code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> is run and the column means of its output are
taken), excluding any taxa listed in <code>excludeTaxa</code>.
These are then categorized based on which, if any, expected allele frequency
they match with, based on the intervals described by <code>expectedFreqs</code> and
<code>allowedDeviation</code>.  If an allele frequency does not fall within any of
these intervals it is classified as <code>NA</code>; otherwise it is converted to the
matching value in <code>expectedFreqs</code>.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to the one passed to the function, but with
allele frequencies added to <code>object$alleleFreq</code>, and <code>"mapping"</code>
as the <code>"alleleFreqType"</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
data(exampleRAD_mapping)
exampleRAD_mapping

# specify parents
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")

# estimate allele frequencies in diploid BC1 population
exampleRAD_mapping &lt;- AddAlleleFreqMapping(exampleRAD_mapping,
                        expectedFreqs = c(0.25, 0.75),
                        allowedDeviation = 0.08)
                        
exampleRAD_mapping$alleleFreq
</code></pre>

<hr>
<h2 id='AddAlleleLinkages'>
Identify and Utilize Linked Alleles for Estimating Genotype Priors
</h2><span id='topic+AddAlleleLinkages'></span><span id='topic+AddAlleleLinkages.RADdata'></span><span id='topic+AddGenotypePriorProb_LD'></span><span id='topic+AddGenotypePriorProb_LD.RADdata'></span>

<h3>Description</h3>

<p><code>AddAlleleLinkages</code> finds alleles, if any, in linkage disequilibrium 
with each allele in a <code><a href="#topic+RADdata">RADdata</a></code> object, and computes a correlation
coefficient representing the strength of the linkage.  
<code>AddGenotypePriorProb_LD</code> adds a second set of prior genotype 
probabilities to a <code>RADdata</code> object based on the genotype posterior
probabilities at linked alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAlleleLinkages(object, ...)
## S3 method for class 'RADdata'
AddAlleleLinkages(object, type, linkageDist, minCorr,
                  excludeTaxa = character(0), ...)
                  
AddGenotypePriorProb_LD(object, ...)
## S3 method for class 'RADdata'
AddGenotypePriorProb_LD(object, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddAlleleLinkages_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object with genomic alignment data stored in 
<code>object$locTable$Chr</code> and <code>object$locTable$pos</code>.
</p>
</td></tr>
<tr><td><code id="AddAlleleLinkages_+3A_type">type</code></td>
<td>

<p>A character string, either &ldquo;mapping&rdquo;, &ldquo;hwe&rdquo;, or 
&ldquo;popstruct&rdquo;, to indicate the type of population being analyzed.
</p>
</td></tr>
<tr><td><code id="AddAlleleLinkages_+3A_linkagedist">linkageDist</code></td>
<td>

<p>A number, indicating the distance in basepairs from a locus within which to
search for linked alleles.
</p>
</td></tr>
<tr><td><code id="AddAlleleLinkages_+3A_mincorr">minCorr</code></td>
<td>

<p>A number ranging from zero to one indicating the minimum correlation needed
for an allele to be used for genotype prediction at another allele.
</p>
</td></tr>
<tr><td><code id="AddAlleleLinkages_+3A_excludetaxa">excludeTaxa</code></td>
<td>

<p>A character vector listing taxa to be excluded from correlation estimates.
</p>
</td></tr>
<tr><td><code id="AddAlleleLinkages_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are primarily designed to be used internally by the
<a href="#topic+IterateHWE">pipeline</a> functions.
</p>
<p><code>AddAlleleLinkages</code> obtains genotypic values using 
<code>GetWeightedMeanGenotypes</code>, then regresses those values for a given 
allele against those values for nearby alleles to obtain correlation coefficients.
For the population structure model, the genotypic values for an allele are
first regressed on the PC axes from <code>object$PCA</code>, then the residuals are
regressed on the genotypic values at nearby alleles to obtain correlation
coefficients.
</p>
<p><code>AddGenotypePriorProb_LD</code> makes a second set of priors in addition to
<code>object$priorProb</code>.  This second set of priors has one value per
inheritance mode per taxon per allele per possible allele copy number.
Where <code class="reqn">K</code> is the ploidy, with allele copy number <code class="reqn">c</code> ranging from 0 to
<code class="reqn">K</code>, <code class="reqn">i</code> is an allele, <code class="reqn">j</code> is a linked allele at a different locus
out of <code class="reqn">J</code> total alleles linked to <code class="reqn">i</code>,
<code class="reqn">r_{ij}</code> is the correlation coefficient between those alleles, <code class="reqn">t</code> is a
taxon, <code class="reqn">post_{cjt}</code> is the posterior probability of a given allele copy
number for a given allele in a given taxon, and <code class="reqn">prior_{cit}</code> is the
prior probability for a given allele copy number for a given allele in a given
taxon based on linkage alone:
</p>
<p style="text-align: center;"><code class="reqn">prior_{cit} = \frac{\prod_{j = 1}^J{post_{cjt} * r_{ij} + (1 - r_{ij})/(K + 1)}}{\sum_{c = 0}^K{\prod_{j = 1}^J{post_{cjt} * r_{ij} + (1 - r_{ij})/(K + 1)}}}</code>
</p>

<p>For mapping populations, <code>AddGenotypePriorProb_LD</code> uses the above formula
when each allele only has two possible genotypes (i.e. test-cross segregation).
When more genotypes are possible, <code>AddGenotypePriorProb_LD</code> instead estimates 
prior probabilities as fitted values when the posterior probabilities for
a given allele are regressed on the posterior probabilities for a linked allele.
This allows loci with different segregation patterns to be informative for
predicting genotypes, and for cases where two alleles are in phase for some but not
all parental copies.
</p>


<h3>Value</h3>

<p>A <code>RADdata</code> object is returned.  For <code>AddAlleleLinkages</code>, it has a new slot
called <code>$alleleLinkages</code> that is a list, with one item in the list for each
allele in the dataset.  Each item is a data frame, with indices for linked alleles
in the first column, and correlation coefficients in the second column.
</p>
<p>For <code>AddGenotypePriorProb_LD</code>, the object has a new slot called 
<code>$priorProbLD</code>.  This is a list much like <code>$posteriorProb</code>, with one list
item per inheritance mode, and each item being an array with allele copy number in
the first dimension, taxa in the second dimension, and alleles in the third dimension.
Values indicate genotype prior probabilities based on linked alleles alone.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypePriorProb_HWE">AddGenotypePriorProb_HWE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
data(Msi01genes)

# Run non-LD pop structure pipeline
Msi01genes &lt;- IteratePopStruct(Msi01genes, tol = 0.01, nPcsInit = 10)

# Add linkages
Msi01genes &lt;- AddAlleleLinkages(Msi01genes, "popstruct", 1e4, 0.05)
# Get new posterior probabilities based on those linkages
Msi01genes &lt;- AddGenotypePriorProb_LD(Msi01genes, "popstruct")

# Preview results
Msi01genes$priorProbLD[[1,2]][,1:10,1:10]
</code></pre>

<hr>
<h2 id='AddGenotypeLikelihood'>
Estimate Genotype Likelihoods in a RADdata object
</h2><span id='topic+AddGenotypeLikelihood'></span><span id='topic+AddGenotypeLikelihood.RADdata'></span><span id='topic+AddDepthSamplingPermutations'></span>

<h3>Description</h3>

<p>For each possible allele copy number across each possible ploidy in each taxon,
<code>AddGenotypeLikelihood</code> estimates the probability of observing the 
distribution of read counts that are recorded for that taxon and locus.
<code>AddDepthSamplingPermutations</code> is called by <code>AddGenotypeLikelihood</code>
the first time it is run, so that part of the likelihood calcluation is
stored in the <code>RADdata</code> object and doesn't need to be re-run on each
iteration of the <a href="#topic+IterateHWE">pipeline</a> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddGenotypeLikelihood(object, ...)

## S3 method for class 'RADdata'
AddGenotypeLikelihood(object, overdispersion = 9, ...)

AddDepthSamplingPermutations(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddGenotypeLikelihood_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="AddGenotypeLikelihood_+3A_overdispersion">overdispersion</code></td>
<td>

<p>An overdispersion parameter.  Higher values will cause the expected read depth
distribution to more resemble the binomial distribution.  Lower values indicate
more overdispersion, <em>i.e.</em> sample-to-sample variance in the probability
of observing reads from a given allele.
</p>
</td></tr>
<tr><td><code id="AddGenotypeLikelihood_+3A_...">...</code></td>
<td>

<p>Other arguments; none are currently used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If allele frequencies are not already recorded in <code>object</code>, they will 
be added using <code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>.  Allele frequencies are then
used for estimating the probability of sampling an allele from a genotype due
to sample contamination.  Given a known genotype with <code class="reqn">x</code> copies of 
allele <code class="reqn">i</code>, ploidy <code class="reqn">k</code>, allele frequency <code class="reqn">p_i</code> in the population used for
making sequencing libraries, and contamination rate <code class="reqn">c</code>, the probabiity of 
sampling a read <code class="reqn">r_i</code> from that locus corresponding to that allele is
</p>
<p style="text-align: center;"><code class="reqn">P(r_i | x) = \frac{x}{k} * (1 - c) + p_i * c</code>
</p>

<p>To estimate the genotype likelihood, where <code class="reqn">nr_i</code> is the number of reads 
corresponding to allele <code class="reqn">i</code> for a given taxon and locus and <code class="reqn">nr_j</code> is the
number of reads corresponding to all other alleles for that taxon and locus:
</p>
<p style="text-align: center;"><code class="reqn">P(nr_i, nr_j | x) = {{nr_i + nr_j}\choose{nr_i}} * \frac{B[P(r_i | x) * d + nr_i, [1 - P(r_i | x)] * d + nr_j]]}{B[P(r_i | x) * d, [1 - P(r_i | x)] * d]}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">{{nr_i + nr_j}\choose{nr_i}} = \frac{(nr_i + nr_j)!}{nr_i! * nr_j!}</code>
</p>

<p>B is the beta function, and <code class="reqn">d</code> is the overdispersion parameter set by 
<code>overdispersion</code>.  <code class="reqn">{{nr_i + nr_j}\choose{nr_i}}</code>
is calculated by <code>AddDepthSamplingPermutations</code>.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to that passed to the function, but with
genotype likelihoods stored in <code>object$genotypeLikelihood</code>.  This item is a 
two dimensional list, with one row for each ploidy listed
in <code>object$possiblePloidies</code>, ignoring differences between 
autopolyploids and allopolyploids, and one column for each ploidy listed in
<code>object$taxaPloidy</code>.  Each item in the list is a three-dimensional 
array with number of allele copies in the first dimension, taxa in the second dimension,
and alleles in the third dimension.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddAlleleFreqMapping">AddAlleleFreqMapping</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset and add allele frequency
data(exampleRAD)
exampleRAD &lt;- AddAlleleFreqHWE(exampleRAD)

# estimate genotype likelihoods
exampleRAD &lt;- AddGenotypeLikelihood(exampleRAD)

# inspect the results
# the first ten individuals and first two alleles, assuming diploidy
exampleRAD$alleleDepth[1:10,1:2]
exampleRAD$genotypeLikelihood[[1]][,1:10,1:2]
# assuming tetraploidy
exampleRAD$genotypeLikelihood[[2]][,1:10,1:2]
</code></pre>

<hr>
<h2 id='AddGenotypePosteriorProb'>
Estimate Posterior Probabilities of Genotypes
</h2><span id='topic+AddGenotypePosteriorProb'></span>

<h3>Description</h3>

<p>Given a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object containing genotype prior probabilities
and genotype likelihoods, this function estimates genotype posterior
probabilities and adds them to the <code>$posteriorProb</code> slot of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddGenotypePosteriorProb(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddGenotypePosteriorProb_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  Prior genotype probabilities and
genotype likelihood should have already been added.
</p>
</td></tr>
<tr><td><code id="AddGenotypePosteriorProb_+3A_...">...</code></td>
<td>

<p>Potential future arguments (none currently in use).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to that passed to the function, but 
with a two-dimensional list added to the <code>$posteriorProb</code> slot.  Rows of
the list correspont to <code>object$possiblePloidies</code>, and columns to unique
values in <code>object$taxaPloidy</code>, similarly to <code>object$priorProb</code>. Each
item of the list is a three dimensional array, with allele copy number in the
first dimension, taxa in the second dimension, and alleles in the third
dimension. For each allele and taxa, posterior probabilities will sum to one
across all potential allele copy numbers.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>, 
<code><a href="#topic+AddGenotypePriorProb_Mapping2Parents">AddGenotypePriorProb_Mapping2Parents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset and set some parameters
data(exampleRAD_mapping)
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")
exampleRAD_mapping &lt;- AddAlleleFreqMapping(exampleRAD_mapping,
                                           expectedFreqs = c(0.25, 0.75),
                                           allowedDeviation = 0.08)
exampleRAD_mapping &lt;- AddGenotypeLikelihood(exampleRAD_mapping)
exampleRAD_mapping &lt;- AddGenotypePriorProb_Mapping2Parents(exampleRAD_mapping,
                                                      n.gen.backcrossing = 1)
                                                      
# estimate posterior probabilities
exampleRAD_mapping &lt;- AddGenotypePosteriorProb(exampleRAD_mapping)
# examine the results
exampleRAD_mapping$posteriorProb[[1,1]][,3,]
</code></pre>

<hr>
<h2 id='AddGenotypePriorProb_ByTaxa'>
Estimate Prior Genotype Probabilities on a Per-Taxon Basis
</h2><span id='topic+AddGenotypePriorProb_ByTaxa'></span><span id='topic+AddGenotypePriorProb_ByTaxa.RADdata'></span>

<h3>Description</h3>

<p>Using local allele frequencies estimated by <code><a href="#topic+AddAlleleFreqByTaxa">AddAlleleFreqByTaxa</a></code>
and assuming Hardy-Weinberg Equilibruim or inbreeding on a local scale,
<code>AddGenotypePriorProb_ByTaxa</code> estimates prior genotype probabilities at
each taxon, allele, and possible ploidy.  These are then stored in the
<code>$priorProb</code> slot of the <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddGenotypePriorProb_ByTaxa(object, ...)
## S3 method for class 'RADdata'
AddGenotypePriorProb_ByTaxa(object, selfing.rate = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddGenotypePriorProb_ByTaxa_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  <code><a href="#topic+AddAlleleFreqByTaxa">AddAlleleFreqByTaxa</a></code> should have
already been run.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_ByTaxa_+3A_selfing.rate">selfing.rate</code></td>
<td>

<p>A number ranging from zero to one indicating the frequency of
self-fertilization in the species.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_ByTaxa_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to that passed to the function, but with a
two-dimensional list added to the <code>$priorProb</code> slot.  Each row in the list
corresponds to one ploidy in <code>object$possiblePloidies</code>, and each column
to a unique ploidy in <code>object$taxaPloidy</code>. Each item is a three-dimensional
array with 
allele copy number in the first dimension, taxa in the second dimension, and
alleles in the third dimension.  The values in the array are prior genotype
probabilities.  Additionally, <code>"taxon"</code> is recorded in the 
<code>"priorType"</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypePriorProb_HWE">AddGenotypePriorProb_HWE</a></code> for equations used for genotype prior
probability estimation.
</p>
<p><code><a href="#topic+AddGenotypePriorProb_Mapping2Parents">AddGenotypePriorProb_Mapping2Parents</a></code>,
<code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(exampleRAD)
# do PCA
exampleRAD &lt;- AddPCA(exampleRAD, nPcsInit = 3)
# get allele frequencies
exampleRAD &lt;- AddAlleleFreqByTaxa(exampleRAD)

# add prior probabilities
exampleRAD &lt;- AddGenotypePriorProb_ByTaxa(exampleRAD)

exampleRAD$priorProb[[1,1]][,1,]
exampleRAD$priorProb[[2,1]][,1,]
exampleRAD$priorProb[[1,1]][,2,]
exampleRAD$priorProb[[2,1]][,2,]
exampleRAD$priorProb[[1,2]][,1,]

# try it with inbreeding, for diploid samples only
exampleRAD2 &lt;- SubsetByTaxon(exampleRAD, GetTaxa(exampleRAD)[exampleRAD$taxaPloidy == 2])
exampleRAD2 &lt;- AddGenotypePriorProb_ByTaxa(exampleRAD2, selfing.rate = 0.5)

exampleRAD2$priorProb[[1,1]][,1,]
</code></pre>

<hr>
<h2 id='AddGenotypePriorProb_Even'>
Add Uniform Priors to a RADdata Object
</h2><span id='topic+AddGenotypePriorProb_Even'></span>

<h3>Description</h3>

<p>To estimate genotype posterior probabilities based on read depth alone, without
taking any population parameters into account, this function can be used to set
a uniform prior probability on all possible genotypes.  This function is not
part of any pipeline but can be used for very rough and quick genotype
estimates, when followed by <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>,
<code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>, <code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>, and
<code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> or <code><a href="#topic+GetProbableGenotypes">GetProbableGenotypes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddGenotypePriorProb_Even(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddGenotypePriorProb_Even_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Even_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &ldquo;RADdata&rdquo; object identical that passed to the function, but with
data stored in one new slot:
</p>
<table>
<tr><td><code>priorProb</code></td>
<td>
<p>A two-dimensional list of matrices, with rows corresponding
to <code>object$possiblePloidies</code> and columns corresponding to unique values in
<code>object$taxaPloidy</code>. Each item in the list is a matrix.  
For each matrix, allele copy number (from zero to the total
ploidy) is in rows, and alleles are in columns.  Each value is 
<code class="reqn">1 / (ploidy + 1).</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>Values in <code>object$ploidyChiSq</code> may not be particularly meaningful
under uniform priors.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypePriorProb_HWE">AddGenotypePriorProb_HWE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)

exampleRAD &lt;- AddGenotypePriorProb_Even(exampleRAD)
exampleRAD$priorProb

# finish protocol to get genotypes
exampleRAD &lt;- AddGenotypeLikelihood(exampleRAD)
exampleRAD &lt;- AddPloidyChiSq(exampleRAD)
exampleRAD &lt;- AddGenotypePosteriorProb(exampleRAD)

genmat &lt;- GetWeightedMeanGenotypes(exampleRAD)
genmat
</code></pre>

<hr>
<h2 id='AddGenotypePriorProb_HWE'>
Estimate Genotype Prior Probabilities In the Absence of Population Structure
</h2><span id='topic+AddGenotypePriorProb_HWE'></span><span id='topic+AddGenotypePriorProb_HWE.RADdata'></span>

<h3>Description</h3>

<p>Assuming Hardy-Weinberg Equilibrium, this function uses allele frequencies
and possible ploidies stored in a &ldquo;<a href="#topic+RADdata">RADdata</a>&rdquo; object to estimate
genotype frequencies in the population, then stores these genotype 
frequencies in the <code>$priorProb</code> slot.  Inbreeding can also be simulated
using the <code>selfing.rate</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddGenotypePriorProb_HWE(object, ...)
## S3 method for class 'RADdata'
AddGenotypePriorProb_HWE(object, selfing.rate = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddGenotypePriorProb_HWE_+3A_object">object</code></td>
<td>

<p>A &ldquo;RADdata&rdquo; object that has had allele frequencies added with
<code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_HWE_+3A_selfing.rate">selfing.rate</code></td>
<td>

<p>A number ranging from zero to one indicating the frequency of
self-fertilization in the species.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_HWE_+3A_...">...</code></td>
<td>

<p>Additional arguments (none currently implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an autopolyploid, or within one subgenome of an allopolyploid,
genotype prior probabilities are estimated as:
</p>
<p style="text-align: center;"><code class="reqn">P(G_i) = {k \choose i} p^i * (1 - p)^{k - i}</code>
</p>

<p>where <code class="reqn">k</code> is the ploidy, <code class="reqn">i</code> is the copy number of a given allele,
and <code class="reqn">p</code> is the allele frequency in the population.
</p>
<p>If the selfing rate is above zero and ploidy is even, genotype prior
probabilities are adjusted according to Equation 6 of de Silva et al. (2005):
</p>
<p style="text-align: center;"><code class="reqn">P(G_{self}) = (1 - s)(I - sA)^{-1}P(G)</code>
</p>

<p>where <code class="reqn">s</code> is the selfing rate.  <code class="reqn">A</code> is a <code class="reqn">k + 1 \times k + 1</code> matrix,
with each column representing the allele copy number from 0 to <code class="reqn">k</code> of a
parental genotype, and each row representing the allele copy number from 0 to
<code class="reqn">k</code> of a progeny genotype, and matrix elements representing the frequencies
of progeny after self-fertilization (each column summing to one).
</p>


<h3>Value</h3>

<p>A &ldquo;RADdata&rdquo; object identical that passed to the function, but with
data stored in one new slot:
</p>
<table>
<tr><td><code>priorProb</code></td>
<td>
<p>A two-dimensional list of matrices, with rows corresponding to
<code>object$possiblePloidies</code> and columns corresponding to unique values in
<code>object$taxaPloidy</code>. Each item in the list is a matrix.  
For each matrix, allele copy number (from zero to the total
ploidy) is in rows, and alleles are in columns.  Each value is the probability
of sampling an individual with that allele copy number from the population.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>De Silva, H. N., Hall, A. J., Rikkerink, E., and Fraser, L. G. (2005)
Estimation of allele frequencies in polyploids under
certain patterns of inheritance.  <em>Heredity</em> <b>95</b>, 327&ndash;334.
<a href="https://doi.org/10.1038/sj.hdy.6800728">doi:10.1038/sj.hdy.6800728</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypePriorProb_Mapping2Parents">AddGenotypePriorProb_Mapping2Parents</a></code>, <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>,
<code><a href="#topic+AddGenotypePriorProb_ByTaxa">AddGenotypePriorProb_ByTaxa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in an example dataset
data(exampleRAD)
# add allele frequencies
exampleRAD &lt;- AddAlleleFreqHWE(exampleRAD)
# add inheritance modes
exampleRAD$possiblePloidies &lt;- list(2L, 4L, c(2L, 2L))

# estimate genotype prior probabilities
exampleRAD &lt;- AddGenotypePriorProb_HWE(exampleRAD)

# examine results
exampleRAD$alleleFreq
exampleRAD$priorProb

# try it with inbreeding, for diploids only
exampleRAD2 &lt;- SubsetByTaxon(exampleRAD, GetTaxa(exampleRAD)[exampleRAD$taxaPloidy == 2])
exampleRAD2 &lt;- AddGenotypePriorProb_HWE(exampleRAD2, selfing.rate = 0.5)
exampleRAD2$priorProb
</code></pre>

<hr>
<h2 id='AddGenotypePriorProb_Mapping2Parents'>
Expected Genotype Frequencies in Mapping Populations
</h2><span id='topic+AddGenotypePriorProb_Mapping2Parents'></span><span id='topic+AddGenotypePriorProb_Mapping2Parents.RADdata'></span><span id='topic+EstimateParentalGenotypes'></span><span id='topic+EstimateParentalGenotypes.RADdata'></span>

<h3>Description</h3>

<p><code>EstimateParentalGenotypes</code> estimates the most likely genotypes of two
parent taxa.  Using those parental genotypes,
<code>AddGenotypePriorProb_Mapping2Parents</code> estimates expected genotype
frequencies for a population of progeny, which are added to the
<code>"<a href="#topic+RADdata">RADdata</a>"</code> object in the <code>$priorProb</code> slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddGenotypePriorProb_Mapping2Parents(object, ...)
## S3 method for class 'RADdata'
AddGenotypePriorProb_Mapping2Parents(object,
    donorParent = GetDonorParent(object), 
    recurrentParent = GetRecurrentParent(object), 
    n.gen.backcrossing = 0, n.gen.intermating = 0, n.gen.selfing = 0,
    minLikelihoodRatio = 10, ...)
    
EstimateParentalGenotypes(object, ...)
## S3 method for class 'RADdata'
EstimateParentalGenotypes(object,
    donorParent = GetDonorParent(object), 
    recurrentParent = GetRecurrentParent(object), 
    n.gen.backcrossing = 0, n.gen.intermating = 0, n.gen.selfing = 0,
    minLikelihoodRatio = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  Ideally this should be set up as a mapping
population using <code><a href="#topic+SetDonorParent">SetDonorParent</a></code>, <code><a href="#topic+SetRecurrentParent">SetRecurrentParent</a></code>,
and <code><a href="#topic+AddAlleleFreqMapping">AddAlleleFreqMapping</a></code>.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_...">...</code></td>
<td>

<p>Additional arguments, listed below, to be passed to the method for 
<code>"RADdata"</code> objects.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_donorparent">donorParent</code></td>
<td>
<p>A character string indicating which taxon is the donor 
parent.  If backcrossing was not performed, it does not matter which was the
donor or recurrent parent.</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_recurrentparent">recurrentParent</code></td>
<td>
<p>A character string indicating which taxon is the
recurrent parent.</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_n.gen.backcrossing">n.gen.backcrossing</code></td>
<td>

<p>An integer, zero or greater, indicating how many generations of backcrossing
to the recurrent parent were performed.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_n.gen.intermating">n.gen.intermating</code></td>
<td>

<p>An integer, zero or greater, indicating how many generations of intermating
within the population were performed.  (Values above one should not have
an effect on the genotype priors that are output, <em>i.e.</em> 
genotype probabilities after one generation of random mating are identical
to genotype probabilities after &gt;1 generation of random mating, assuming no
genetic drift or selection).
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_n.gen.selfing">n.gen.selfing</code></td>
<td>

<p>An integer, zero or greater, indicating how many generations of selfing were
performed.
</p>
</td></tr>
<tr><td><code id="AddGenotypePriorProb_Mapping2Parents_+3A_minlikelihoodratio">minLikelihoodRatio</code></td>
<td>

<p>The minimum likelihood ratio for determining parental genotypes with 
confidence, to be passed to <code><a href="#topic+GetLikelyGen">GetLikelyGen</a></code> for both
parental taxa.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AddGenotypePriorProb_Mapping2Parents</code> examines the parental and progeny
ploidies stored in <code>object$taxaPloidy</code> and throws an error if they do not
meet expectations.  In particular, all progeny must be the same ploidy, and that
must be the ploidy that would be expected if the parents produced normal gametes.
For example in an F1 cross, if one parent was diploid and the other tetraploid,
all progeny must be triploid.  If both parents are tetraploid, all progeny must
be tetraploid.
</p>
<p>The most likely genotypes for the two parents are estimated by
<code>EstimateParentalGenotypes</code> using
<code><a href="#topic+GetLikelyGen">GetLikelyGen</a></code>.  If parental gentoypes don't match progeny allele
frequencies, the function attempts to correct the parental genotypes to the
most likely combination that matches the allele frequency.
</p>
<p>For each ploidy being examined, F1 genotype probabilities are then calculated
by <code>AddGenotypePriorProb_Mapping2Parents</code>.
Genotype probabilities are updated for each backcrossing generation, then each
intermating generation, then each selfing generation.
</p>
<p>The default, with <code>n.gen.backcrossing = 0</code>, <code>n.gen.intermating = 0</code>
and <code>n.gen.selfing = 0</code>, will simulate an F1 population.  A BC1F2
population, for example, would have <code>n.gen.backcrossing = 1</code>, 
<code>n.gen.intermating = 0</code> and <code>n.gen.selfing = 1</code>.  A typical F2 
population would have <code>n.gen.selfing = 1</code> and the other two parameters
set to zero.  However, in a self-incompatible species where many F1 are 
intermated to produce the F2, one would instead use 
<code>n.gen.intermating = 1</code> and set the other parameters to zero.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to that passed to the function, but with
data stored in three new slots:
</p>
<table>
<tr><td><code>priorProb</code></td>
<td>
<p>A two-dimensional list of matrices, with rows corresponding to
<code>object$possiblePloidies</code> and columns corresponding to unique values in
<code>object$taxaPloidy</code>. Each item in the list is a matrix.  
For each matrix, allele copy number (from zero to the total
ploidy) is in rows, and alleles are in columns.  Each value is the probability
of sampling an individual with that allele copy number from the population.
For any taxa ploidies other than the progeny ploidy, even priors are returned.</p>
</td></tr>
<tr><td><code>likelyGeno_donor</code></td>
<td>
<p>A matrix of the donor parent genotypes that were
used for estimating genotype prior probabilities.  Formatted like the
output of <code><a href="#topic+GetLikelyGen">GetLikelyGen</a></code>.</p>
</td></tr>
<tr><td><code>likelyGeno_recurrent</code></td>
<td>
<p>A matrix of the recurrent parent genotypes
that were use for estimating gentoype prior probabilities.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For the time being, in allopolyploids it is assumed that copies of an allele
are distributed among as few isoloci as possible.  For example, if an
autotetraploid genotype had two copies of allele A and two copies of allele
B, it is assumed to be AA BB rather than AB AB.  This may be remedied in the
future by examining distribution of genotype likelihoods.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>, <code><a href="#topic+AddGenotypePriorProb_HWE">AddGenotypePriorProb_HWE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset and set some parameters
data(exampleRAD_mapping)
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")
exampleRAD_mapping &lt;- AddAlleleFreqMapping(exampleRAD_mapping,
                                           expectedFreqs = c(0.25, 0.75),
                                           allowedDeviation = 0.08)
exampleRAD_mapping &lt;- AddGenotypeLikelihood(exampleRAD_mapping)

# examine the dataset
exampleRAD_mapping
exampleRAD_mapping$alleleFreq

# estimate genotype priors for a BC1 population
exampleRAD_mapping &lt;- AddGenotypePriorProb_Mapping2Parents(exampleRAD_mapping,
                                                      n.gen.backcrossing = 1)
exampleRAD_mapping$priorProb
</code></pre>

<hr>
<h2 id='AddPCA'>
Perform Principal Components Analysis on &ldquo;RADdata&rdquo; Object
</h2><span id='topic+AddPCA'></span><span id='topic+AddPCA.RADdata'></span>

<h3>Description</h3>

<p>This function uses read depth ratios or posterior genotype probabilities
(the latter preferentially) as input data for principal components analysis.
The PCA scores are then stored in the <code>$PCA</code> slot of the
<code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddPCA(object, ...)
## S3 method for class 'RADdata'
AddPCA(object, nPcsInit = 10, maxR2changeratio = 0.05, 
                         minPcsOut = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddPCA_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="AddPCA_+3A_npcsinit">nPcsInit</code></td>
<td>

<p>The number of principal component axes to initially calculate.
</p>
</td></tr>
<tr><td><code id="AddPCA_+3A_maxr2changeratio">maxR2changeratio</code></td>
<td>

<p>This number determines how many principal component axes are retained.  The 
difference in <code class="reqn">R^2</code> values between the first and second axes 
is multiplied by <code>maxR2changeratio</code>.  The last axis retained is the first
axis after which the <code class="reqn">R^2</code> value changes by less than this value.
Lower values of <code>maxR2changeratio</code> will result in more axes being retained.
</p>
</td></tr>
<tr><td><code id="AddPCA_+3A_minpcsout">minPcsOut</code></td>
<td>

<p>The minimum number of PC axes to output, which can override 
<code>maxR2changeratio</code>.
</p>
</td></tr>
<tr><td><code id="AddPCA_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the <code>pca</code> function from the
<span class="pkg">pcaMethods</span> BioConductor package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PPCA (probabalistic PCA) method from <span class="pkg">pcaMethods</span> is used,
due to the high missing data rate that is typical of genotyping-by-sequencing
datasets.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to the one passed to the function, but with
a matrix added to the <code>$PCA</code> slot.  This matrix contains PCA scores, with
taxa in rows, and PC axes in columns.
</p>


<h3>Note</h3>

<p>If you see the error 
</p>
<p><code>Error in if (rel_ch &lt; threshold &amp; count &gt; 5) { : 
  missing value where TRUE/FALSE needed</code>
</p>
<p>try lowering <code>nPcsInit</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddAlleleFreqByTaxa">AddAlleleFreqByTaxa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(exampleRAD)
# do PCA
exampleRAD &lt;- AddPCA(exampleRAD, nPcsInit = 3)

plot(exampleRAD$PCA[,1], exampleRAD$PCA[,2])
</code></pre>

<hr>
<h2 id='AddPloidyChiSq'>
Chi-Square Test on Genotype Likelihood Distributions
</h2><span id='topic+AddPloidyChiSq'></span><span id='topic+AddPloidyChiSq.RADdata'></span>

<h3>Description</h3>

<p>This function is intended to help identify the correct inheritance mode for
each locus in a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  Expected genotype frequencies
are taken from <code>object$priorProb</code>.  Observed genotype frequencies are
estimated from <code>object$genotypeLikelihood</code>, where each taxon has a
partial assignment to each genotype, proportional to genotype likelihoods.
A <code class="reqn">\chi ^ 2</code> statistic is then estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddPloidyChiSq(object, ...)
## S3 method for class 'RADdata'
AddPloidyChiSq(object, excludeTaxa = GetBlankTaxa(object),
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddPloidyChiSq_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  Genotype prior probabilities and
likelihoods should have been added.
</p>
</td></tr>
<tr><td><code id="AddPloidyChiSq_+3A_excludetaxa">excludeTaxa</code></td>
<td>

<p>A character vector indicating names of taxa to exclude from calculations.
</p>
</td></tr>
<tr><td><code id="AddPloidyChiSq_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to other methods (none currently in use).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parents (in mapping populations) and blank taxa are automatically excluded
from calculations.
</p>
<p>Genotypes with zero prior probability would result in an infinite 
A <code class="reqn">\chi ^ 2</code> statistic and therefore are excluded from
the calculation.  However, the total number of observations (total number
of taxa) remains the same, so that if there are many taxa with high
likelihood for a genotype with zero prior probability, 
<code class="reqn">\chi ^ 2</code> will be high.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to the one passed to the function,
but with a matrix added to the <code>$ploidyChiSq</code>
slot.  This matrix has inheritance rows (matching <code>object$priorProb</code>) in
rows and alleles in columns.  <code>object$ploidyChiSq</code> contains the 
<code class="reqn">\chi ^ 2</code> values.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>, <code><a href="#topic+AddPloidyLikelihood">AddPloidyLikelihood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset and set some parameters
data(exampleRAD_mapping)
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")
exampleRAD_mapping &lt;- AddAlleleFreqMapping(exampleRAD_mapping,
                                           expectedFreqs = c(0.25, 0.75),
                                           allowedDeviation = 0.08)
exampleRAD_mapping &lt;- AddGenotypeLikelihood(exampleRAD_mapping)
exampleRAD_mapping &lt;- AddGenotypePriorProb_Mapping2Parents(exampleRAD_mapping,
                                                      n.gen.backcrossing = 1)
                                                      
# get chi-squared values
exampleRAD_mapping &lt;- AddPloidyChiSq(exampleRAD_mapping)
# view chi-squared and p-values (diploid only)
exampleRAD_mapping$ploidyChiSq
</code></pre>

<hr>
<h2 id='AddPloidyLikelihood'>
Likelihoods for Possible Ploidies Based on Genotype Distributions
</h2><span id='topic+AddPloidyLikelihood'></span><span id='topic+AddPloidyLikelihood.RADdata'></span>

<h3>Description</h3>

<p>Given prior genotype probabilities, and a set of high-confidence 
genotypes estimated with <code><a href="#topic+GetLikelyGen">GetLikelyGen</a></code>, this function
estimates the probability of observing that distribution of genotypes
and stores the probability in the <code>$ploidyLikelihood</code> slot of the
<code>"RADdata"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddPloidyLikelihood(object, ...)
## S3 method for class 'RADdata'
AddPloidyLikelihood(object, excludeTaxa = GetBlankTaxa(object), 
                            minLikelihoodRatio = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddPloidyLikelihood_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  Prior genotype probabilities and
genotype likelihoods should have already been added using the appropriate
functions.
</p>
</td></tr>
<tr><td><code id="AddPloidyLikelihood_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the method for <code>"RADdata"</code>.
</p>
</td></tr>
<tr><td><code id="AddPloidyLikelihood_+3A_excludetaxa">excludeTaxa</code></td>
<td>

<p>A character vector indicating taxa that should be excluded from calculations.
</p>
</td></tr>
<tr><td><code id="AddPloidyLikelihood_+3A_minlikelihoodratio">minLikelihoodRatio</code></td>
<td>

<p>A number, one or higher, to be passed to <code>GetLikelyGen</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to estimate the correct inheritance mode for
each locus.  This function may be deleted in the future in favor of better
alternatives.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to that passed to the function, but with
results added to the <code>$ploidyLikelihood</code> slot.  This has one row for each
possible ploidy (each ploidy with data in <code>$priorProb</code>), and one column
for each allele.  Each element of the matrix is the multinomial probability 
of seeing that distribution of genotypes given the prior probabilities.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (object, ...) 
{
    UseMethod("AddPloidyLikelihood", object)
  }
</code></pre>

<hr>
<h2 id='CanDoGetWeightedMeanGeno'>
Check Whether <code>GetWeightedMeanGenotypes</code> Can Be Run
</h2><span id='topic+CanDoGetWeightedMeanGeno'></span>

<h3>Description</h3>

<p>This function is used internally by <code><a href="#topic+AddPCA">AddPCA</a></code>, 
<code><a href="#topic+AddAlleleFreqByTaxa">AddAlleleFreqByTaxa</a></code>, and the internal function <code>.alleleFreq</code>
to test whether <code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> can be run on a
<code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CanDoGetWeightedMeanGeno(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CanDoGetWeightedMeanGeno_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="CanDoGetWeightedMeanGeno_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single Boolean value.  To be <code>TRUE</code>, <code>object$posteriorProb</code> must be
non-null, and either there must be only one possible ploidy, or 
<code>object$ploidyChiSq</code> must be non-null.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>, <code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)

CanDoGetWeightedMeanGeno(exampleRAD)

exampleRAD &lt;- AddAlleleFreqHWE(exampleRAD)
exampleRAD &lt;- AddGenotypePriorProb_HWE(exampleRAD)
exampleRAD &lt;- AddGenotypeLikelihood(exampleRAD)
exampleRAD &lt;- AddPloidyChiSq(exampleRAD)
exampleRAD &lt;- AddGenotypePosteriorProb(exampleRAD)

CanDoGetWeightedMeanGeno(exampleRAD)
</code></pre>

<hr>
<h2 id='EstimateContaminationRate'>
Estimate Sample Contamination Using Blanks
</h2><span id='topic+EstimateContaminationRate'></span><span id='topic+EstimateContaminationRate.RADdata'></span>

<h3>Description</h3>

<p>Based on mean read depth at blank and non-blank taxa, estimate sample
cross-contamination and add that information to the <code>"<a href="#topic+RADdata">RADdata</a>"</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateContaminationRate(object, ...)
## S3 method for class 'RADdata'
EstimateContaminationRate(object, multiplier = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimateContaminationRate_+3A_object">object</code></td>
<td>

<p>A <code>"RADdata"</code> object where <code><a href="#topic+SetBlankTaxa">SetBlankTaxa</a></code> has already
been used to assign one or more taxa as blanks.
</p>
</td></tr>
<tr><td><code id="EstimateContaminationRate_+3A_multiplier">multiplier</code></td>
<td>

<p>A single numeric value, or a named numeric vector with one value per blank
taxon in <code>object</code>, with names matching the blank taxa names.  Read depth
at blank taxa will be multiplied by this number when estimating sample 
cross-contamination.  See example below.
</p>
</td></tr>
<tr><td><code id="EstimateContaminationRate_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates sample cross-contamination assuming that the only
source of contamination is from adapter or sample spill-over between wells
during library preparation, or contamination among the libraries themselves.
If you anticipate a higher rate of contamination during DNA extraction before
library preparation, you may wish to increase the value using
<code><a href="#topic+SetContamRate">SetContamRate</a></code>.
</p>
<p>It is important to set the contamination rate to a reasonably accurate value
(<em>i.e.</em> the right order of magnitude) in order for <span class="pkg">polyRAD</span> to
be able to identify homozygotes that may otherwise appear heterozygous due
to contamination.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to <code>object</code> but with the 
<code>"contamRate"</code> attribute adjusted.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dataset for this example
data(Msi01genes)

# give the name of the taxon that is blank
Msi01genes &lt;- SetBlankTaxa(Msi01genes, "blank")

# Fifteen libraries were done; blank is pooled over all of them, and
# most other samples are pooled over two libraries.
mymult &lt;- 2/15

# estimate the contamination rate
Msi01genes &lt;- EstimateContaminationRate(Msi01genes, multiplier = mymult)
</code></pre>

<hr>
<h2 id='ExamineGenotype'>
Plots to Examine Genotype Calling at a Single Taxon and Allele
</h2><span id='topic+ExamineGenotype'></span><span id='topic+ExamineGenotype.RADdata'></span>

<h3>Description</h3>

<p>For a given taxon and allele, this function generates barplots showing read
depth ratio, posterior mean genotype, genotype prior probabilities, genotype
likelihoods, and genotype posterior probabilities. It is intended as a sanity
check on genotype calling, as well as a means to visually demonstrate the
concept of Bayesian genotype calling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExamineGenotype(object, ...)

## S3 method for class 'RADdata'
ExamineGenotype(object, taxon, allele, pldindex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExamineGenotype_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object for which genotype calling has already been performed.
</p>
</td></tr>
<tr><td><code id="ExamineGenotype_+3A_taxon">taxon</code></td>
<td>

<p>A single character string indicating the taxon to show.
</p>
</td></tr>
<tr><td><code id="ExamineGenotype_+3A_allele">allele</code></td>
<td>

<p>A single character string indicating the allele to show.
</p>
</td></tr>
<tr><td><code id="ExamineGenotype_+3A_pldindex">pldindex</code></td>
<td>

<p>An index of which inheritance mode to use within <code>object$possiblePloidies</code>.
</p>
</td></tr>
<tr><td><code id="ExamineGenotype_+3A_...">...</code></td>
<td>

<p>Other arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A barplot is generated. Invisibly, a list is returned:
</p>
<table>
<tr><td><code>alleleDepth</code></td>
<td>
<p>Sequence read depth for the selected allele.</p>
</td></tr>
<tr><td><code>antiAlleleDepth</code></td>
<td>
<p>Sequence read depth for all other alleles at the locus.</p>
</td></tr>
<tr><td><code>depthRatio</code></td>
<td>
<p>Proportion of reads at this taxon and locus belonging to this allele.</p>
</td></tr>
<tr><td><code>priorProb</code></td>
<td>
<p>A vector of genotype prior probabilities.</p>
</td></tr>
<tr><td><code>genotypeLikelhood</code></td>
<td>
<p>A vector of genotype likelihoods.</p>
</td></tr>
<tr><td><code>posteriorProb</code></td>
<td>
<p>A vector of genotype posterior probabilities.</p>
</td></tr>
<tr><td><code>postMean</code></td>
<td>
<p>The posterior mean genotype on a scale of 0 to 1.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)

exampleRAD &lt;- IterateHWE(exampleRAD)

eg &lt;- ExamineGenotype(exampleRAD, "sample088", "loc1_T")
</code></pre>

<hr>
<h2 id='exampleRAD'>
Miniature Datasets for Testing polyRAD Functions
</h2><span id='topic+exampleRAD'></span><span id='topic+exampleRAD_mapping'></span><span id='topic+Msi01genes'></span>

<h3>Description</h3>

<p><code>exampleRAD</code> and <code>exampleRAD_mapping</code> are two very small
simulated <code>"<a href="#topic+RADdata">RADdata</a>"</code> datasets for testing polyRAD
functions.  Each has four loci.  <code>exampleRAD</code> is a 
natural population of 100 individuals with a mix of diploid and tetraploid 
loci, with 80 individuals diploid and 20 individuals triploid.
<code>exampleRAD_mapping</code> is a diploid BC1 mapping population with two parents
and 100 progeny.
<code>Msi01genes</code> is a <code>"RADdata"</code> object with 585 taxa and 24 loci,
containing real data from <em>Miscanthus sinensis</em>, obtained by using
<code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code> on the file Msi01genes.vcf.  Most individuals
in <code>Msi01genes</code> are diploid, with three haploids and one triploid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleRAD)
data(exampleRAD_mapping)
data(Msi01genes)
</code></pre>


<h3>Format</h3>

<p>See the format described in <code>"<a href="#topic+RADdata">RADdata</a>"</code>.
</p>


<h3>Source</h3>

<p>Randomly generated using a script available in
polyRAD/extdata/simulate_rad_data.R.
</p>
<p><em>M. sinensis</em> sequencing data available at
<a href="https://www.ncbi.nlm.nih.gov//bioproject/PRJNA207721">https://www.ncbi.nlm.nih.gov//bioproject/PRJNA207721</a>, with full genotype
calls at <a href="https://doi.org/10.13012/B2IDB-1402948_V1">doi:10.13012/B2IDB-1402948_V1</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)
exampleRAD
data(exampleRAD_mapping)
exampleRAD_mapping
data(Msi01genes)
Msi01genes
</code></pre>

<hr>
<h2 id='ExpectedHindHe'>
Simulate Data to Get Expected Distribution of Hind/He
</h2><span id='topic+ExpectedHindHe'></span><span id='topic+SimGenotypes'></span><span id='topic+SimAlleleDepth'></span><span id='topic+SimGenotypesMapping'></span><span id='topic+ExpectedHindHeMapping'></span>

<h3>Description</h3>

<p>These functions were created to help users determine an appropriate cutoff for
filtering loci based on <code class="reqn">H_{ind}/H_E</code> after running
<code><a href="#topic+HindHe">HindHe</a></code> and <code><a href="#topic+InbreedingFromHindHe">InbreedingFromHindHe</a></code>.
<code>ExpectedHindHe</code> takes allele frequencies, sample size, and read depths from
a <code><a href="#topic+RADdata">RADdata</a></code> object, simulates genotypes and allelic read depths from
these assuming Mendelian inheritance, and then estimates
<code class="reqn">H_{ind}/H_E</code> for each simulated locus.
<code>ExpectedHindHeMapping</code> performs similar simulation and estimation, but
in mapping populations based on parental genotypes and expected distribution
of progeny genotypes.
<code>SimGenotypes</code>, <code>SimGenotypesMapping</code>, and
<code>SimAlleleDepth</code> are internal functions used by <code>ExpectedHindHe</code>
and <code>ExpectedHindHeMapping</code>
but are provided at the user level since they may be more broadly useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectedHindHe(object, ploidy = object$possiblePloidies[[1]], inbreeding = 0,
               overdispersion = 20, contamRate = 0, errorRate = 0.001,
               reps = ceiling(5000/nLoci(object)),
               quiet = FALSE, plot = TRUE)

ExpectedHindHeMapping(object, ploidy = object$possiblePloidies[[1]],
                      n.gen.backcrossing = 0, n.gen.selfing = 0,
                      overdispersion = 20, contamRate = 0, errorRate = 0.001,
                      freqAllowedDeviation = 0.05, 
                      minLikelihoodRatio = 10, reps = ceiling(5000/nLoci(object)),
                      quiet = FALSE, plot = TRUE)

SimGenotypes(alleleFreq, alleles2loc, nsam, inbreeding, ploidy)

SimGenotypesMapping(donorGen, recurGen, alleles2loc, nsam,
                    ploidy.don, ploidy.rec,
                    n.gen.backcrossing, n.gen.selfing)

SimAlleleDepth(locDepth, genotypes, alleles2loc, overdispersion = 20,
               contamRate = 0, errorRate = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpectedHindHe_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_ploidy">ploidy</code></td>
<td>

<p>A single integer indicating the ploidy to use for genotype simulation.
For <code>ExpectedHindHe</code> and <code>ExpectedHindHeMapping</code>,
this number will be multiplied by the values in <code>GetTaxaPloidy(object)</code>
then divided by two to determine the ploidy of each individual for simulation.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_inbreeding">inbreeding</code></td>
<td>

<p>A number ranging from 0 to 1 indicating the amount of inbreeding (<code class="reqn">F</code>).
This represents inbreeding from all sources (population structure,
self-fertilization, etc.) and can be estimated with <code>InbreedingFromHindHe</code>.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_overdispersion">overdispersion</code></td>
<td>

<p>Overdispersion parameter as described in <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>.
Lower values will cause allelic read depth distributions to deviate further from
expectations based on allele copy number.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_contamrate">contamRate</code></td>
<td>

<p>Sample cross-contamination rate to simulate.  Although 0 is the default, 0.001
is also reasonable.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_errorrate">errorRate</code></td>
<td>

<p>Sequencing error rate to simulate. For Illumina reads, 0.001 is a reasonable
value. An error is assumed to have an equal chance of converting an allele to
any other allele at the locus, although this is somewhat of an
oversimplification.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_reps">reps</code></td>
<td>

<p>The number of times to simulate the data and estimate <code class="reqn">H_{ind}/H_E</code>.
This can generally be left at the default, but
set it higher than 1 if you want to see within-locus variance in the estimate.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_quiet">quiet</code></td>
<td>

<p>Boolean indicating whether to suppress messages and results printed to console.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_plot">plot</code></td>
<td>

<p>Boolean indicating whether to plot a histogram of <code class="reqn">H_{ind}/H_E</code>
values.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_n.gen.backcrossing">n.gen.backcrossing</code></td>
<td>

<p>An integer indicating the number of generations of backcrossing.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_n.gen.selfing">n.gen.selfing</code></td>
<td>

<p>An integer indicating the number of generations of self-fertilization.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_freqalloweddeviation">freqAllowedDeviation</code></td>
<td>

<p>The amount by which allele frequencies are allowed to deviate from expected
allele frequencies.  See <code><a href="#topic+AddAlleleFreqMapping">AddAlleleFreqMapping</a></code>.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_minlikelihoodratio">minLikelihoodRatio</code></td>
<td>

<p>Minimum likelihood ratio for determining the most likely parental genotypes.
See <code><a href="#topic+GetLikelyGen">GetLikelyGen</a></code>.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_allelefreq">alleleFreq</code></td>
<td>

<p>A vector of allele frequencies, as can be found in the <code>$alleleFreq</code> slot
of a <code>RADdata</code> object after running <code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_alleles2loc">alleles2loc</code></td>
<td>

<p>An integer vector assigning alleles to loci, as can be found in the
<code>$alleles2loc</code> slot of a <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_nsam">nsam</code></td>
<td>

<p>An integer indicating the number of samples (number of taxa) to simulate.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_donorgen">donorGen</code></td>
<td>

<p>A vector indicating genotypes of the donor parent (which can be either parent
if backcrossing was not performed), with one value for each allele in the
dataset, and numbers indicating the copy number of each allele.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_recurgen">recurGen</code></td>
<td>

<p>A vector indicating genotypes of the recurrent parent, as with <code>donorGen</code>.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_ploidy.don">ploidy.don</code></td>
<td>

<p>A single integer indicating the ploidy of the donor parent.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_ploidy.rec">ploidy.rec</code></td>
<td>

<p>A single integer indicating the ploidy of the recurrent parent.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_locdepth">locDepth</code></td>
<td>

<p>An integer matrix indicating read depth at each taxon and locus.  Formatted as
the <code>$locDepth</code> slot of a <code>RADdata</code> object, notably with columns
named by locus number rather than locus name.
</p>
</td></tr>
<tr><td><code id="ExpectedHindHe_+3A_genotypes">genotypes</code></td>
<td>

<p>A numeric matrix, formatted as the output of <code><a href="#topic+GetProbableGenotypes">GetProbableGenotypes</a></code>
or <code>SimGenotypes</code>, indicating genotypes as allele copy number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To prevent highly inflated values in the output, <code>ExpectedHindHe</code> filters
loci with minor allele frequencies below five times the sequencing error rate.
</p>


<h3>Value</h3>

<p><code>ExpectedHindHe</code> and <code>ExpectedHindHeMapping</code> invisibly return a
matrix, with loci in rows and reps in
columns, containing <code class="reqn">H_{ind}/H_E</code> from the simulated loci.
</p>
<p><code>SimGenotypes</code> and <code>SimGenotypesMapping</code> return a numeric matrix of
allele copy number, with samples
in rows and alleles in columns, similar to that produced by
<code><a href="#topic+GetProbableGenotypes">GetProbableGenotypes</a></code>.
</p>
<p><code>SimAlleleDepth</code> returns an integer matrix of allelic read depth, with
samples in rows and alleles in columns, similar to the <code>$alleleDepth</code>
slot of a <code>RADdata</code> object.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Clark, L. V., Mays, W., Lipka, A. E. and Sacks, E. J. (2022) A population-level
statistic for assessing Mendelian behavior of genotyping-by-sequencing data
from highly duplicated genomes. <em>BMC Bioinformatics</em> <b>23</b>, 101,
doi:10.1186/s12859-022-04635-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load dataset for the example
data(exampleRAD)
exampleRAD &lt;- AddAlleleFreqHWE(exampleRAD)

# Simulate genotypes
simgeno &lt;- SimGenotypes(exampleRAD$alleleFreq, exampleRAD$alleles2loc, 10, 0.2, 2)

# Simulate reads
simreads &lt;- SimAlleleDepth(exampleRAD$locDepth[1:10,], simgeno, exampleRAD$alleles2loc)

# Get expected Hind/He distribution if all loci in exampleRAD were well-behaved
ExpectedHindHe(exampleRAD, reps = 10)

# Mapping population example
data(exampleRAD_mapping)
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")
exampleRAD_mapping &lt;- AddAlleleFreqMapping(exampleRAD_mapping,
                                           expectedFreqs = c(0.25, 0.75),
                                           allowedDeviation = 0.08)
exampleRAD_mapping &lt;- AddGenotypeLikelihood(exampleRAD_mapping)
exampleRAD_mapping &lt;- EstimateParentalGenotypes(exampleRAD_mapping,
                                                n.gen.backcrossing = 1)

simgenomap &lt;- SimGenotypesMapping(exampleRAD_mapping$likelyGeno_donor[1,],
                                  exampleRAD_mapping$likelyGeno_recurrent[1,],
                                  exampleRAD_mapping$alleles2loc,
                                  nsam = 10, ploidy.don = 2, ploidy.rec = 2,
                                  n.gen.backcrossing = 1,
                                  n.gen.selfing = 0)
                                  
ExpectedHindHeMapping(exampleRAD_mapping, n.gen.backcrossing = 1, reps = 10)
</code></pre>

<hr>
<h2 id='ExportGAPIT'>
Export RADdata Object for Use by Other R Packages
</h2><span id='topic+ExportGAPIT'></span><span id='topic+Export_rrBLUP_Amat'></span><span id='topic+Export_rrBLUP_GWAS'></span><span id='topic+Export_TASSEL_Numeric'></span><span id='topic+Export_polymapR'></span><span id='topic+Export_polymapR_probs'></span><span id='topic+Export_MAPpoly'></span><span id='topic+Export_GWASpoly'></span><span id='topic+Export_Structure'></span><span id='topic+Export_adegenet_genind'></span>

<h3>Description</h3>

<p>After a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object has been run through a pipeline such as
<code><a href="#topic+IteratePopStruct">IteratePopStruct</a></code>, these functions can be used to export
the genotypes to R packages and other software that can
perform genome-wide association and genomic prediction.  <code>ExportGAPIT</code>,
<code>Export_rrBLUP_Amat</code>, <code>Export_rrBLUP_GWAS</code>, <code>Export_GWASpoly</code>,
and <code>Export_TASSEL_Numeric</code> all export continuous numerical genotypes 
generated by <code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code>.  <code>Export_polymapR</code>,
<code>Export_Structure</code>, and <code>Export_adegenet_genind</code> use 
<code><a href="#topic+GetProbableGenotypes">GetProbableGenotypes</a></code> to export discrete 
genotypes.  <code>Export_MAPpoly</code> and <code>Export_polymapR_probs</code> export
genotype posterior probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportGAPIT(object, onePloidyPerAllele = FALSE)

Export_rrBLUP_Amat(object, naIfZeroReads = FALSE, 
                   onePloidyPerAllele = FALSE)

Export_rrBLUP_GWAS(object, naIfZeroReads = FALSE, 
                   onePloidyPerAllele = FALSE)

Export_TASSEL_Numeric(object, file, naIfZeroReads = FALSE,
                      onePloidyPerAllele = FALSE)

Export_polymapR(object, naIfZeroReads = TRUE,
                progeny = GetTaxa(object)[!GetTaxa(object) %in% 
                  c(GetDonorParent(object), GetRecurrentParent(object),
                    GetBlankTaxa(object))])

Export_polymapR_probs(object, maxPcutoff = 0.9,
                      correctParentalGenos = TRUE,
                      multiallelic = "correct")

Export_MAPpoly(object, file, pheno = NULL, ploidyIndex = 1,
               progeny = GetTaxa(object)[!GetTaxa(object) %in% 
                 c(GetDonorParent(object), GetRecurrentParent(object),
                   GetBlankTaxa(object))],
               digits = 3)

Export_GWASpoly(object, file, naIfZeroReads = TRUE, postmean = TRUE, digits = 3,
                splitByPloidy = TRUE)

Export_Structure(object, file, includeDistances = FALSE, extraCols = NULL,
                 missingIfZeroReads = TRUE)

Export_adegenet_genind(object, ploidyIndex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportGAPIT_+3A_object">object</code></td>
<td>

<p>A <code>"RADdata"</code> object with posterior genotype probabilities
already estimated.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_oneploidyperallele">onePloidyPerAllele</code></td>
<td>

<p>Logical.  If <code>TRUE</code>, for each allele the inheritance mode with the
lowest <code class="reqn">\chi ^ 2</code> value is selected and is assumed to be
the true inheritance mode.  If <code>FALSE</code>, inheritance modes are weighted
by inverse <code class="reqn">\chi ^ 2</code> values for each allele, and mean
genotypes that have been weighted across inheritance modes are returned.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_naifzeroreads">naIfZeroReads</code></td>
<td>

<p>A logical indicating whether <code>NA</code> should be inserted into the 
output matrix for any taxa and loci where the total read depth for
the locus is zero.  If <code>FALSE</code>, the output for these genotypes is
essentially the mode (for <code>Export_polymapR</code> and <code>Export_GWASpoly</code>)
or mean (for others) across prior genotype probabilities, since
prior and posterior genotype probabilities are equal when there are no
reads.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_file">file</code></td>
<td>

<p>A character string indicating a file path to which to write.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_pheno">pheno</code></td>
<td>

<p>A data frame or matrix of phenotypic values, with progeny in rows and traits
in columns.  Columns should be named.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_ploidyindex">ploidyIndex</code></td>
<td>

<p>Index, within <code>object$possiblePloidies</code>, of the ploidy to be exported.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_progeny">progeny</code></td>
<td>

<p>A character vector indicating which individuals to export as progeny of the
cross.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_maxpcutoff">maxPcutoff</code></td>
<td>

<p>A cutoff for posterior probabilities, below which genotypes will be reported
as 'NA' in the 'geno' column.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_correctparentalgenos">correctParentalGenos</code></td>
<td>

<p>Passed to <code><a href="#topic+GetProbableGenotypes">GetProbableGenotypes</a></code>. If <code>TRUE</code>, parental genotypes
are corrected based on progeny allele frequencies.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_multiallelic">multiallelic</code></td>
<td>

<p>Passed to <code><a href="#topic+GetProbableGenotypes">GetProbableGenotypes</a></code>. Under the default, genotypes at
multiallelic loci will be corrected to sum to the ploidy.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_digits">digits</code></td>
<td>

<p>Number of decimal places to which to round genotype probabilities or posterior
mean genotypes in the output file.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_postmean">postmean</code></td>
<td>

<p>Logical. If <code>TRUE</code>, posterior mean genotypes will be output.  If
<code>FALSE</code>, discrete genotypes will be output.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_splitbyploidy">splitByPloidy</code></td>
<td>

<p>Logical. If <code>TRUE</code> and there are multiple <code>taxaPloidy</code> values in the
dataset, multiple files are written, one per ploidy.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_includedistances">includeDistances</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the second row of the Structure file will contain
distances between markers, which can be used by the linkage model in Structure.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_extracols">extraCols</code></td>
<td>

<p>An optional data frame, with one row per taxon, containing columns of data
to output to the left of the genotypes in the Structure file.
</p>
</td></tr>
<tr><td><code id="ExportGAPIT_+3A_missingifzeroreads">missingIfZeroReads</code></td>
<td>

<p>See <code>naIfZeroReads</code>.  If <code>TRUE</code>, a value of <code>-9</code> will be output
for any genotypes with zero reads, indicating that those genotypes are missing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">GAPIT</span>, <span class="pkg">FarmCPU</span>, <span class="pkg">rrBLUP</span>, <span class="pkg">TASSEL</span>, and <span class="pkg">GWASpoly</span> allow
genotypes to be a continuous numeric variable.  <span class="pkg">MAPpoly</span> and <span class="pkg">polymapR</span>
allow for import of genotype probabilities.
<span class="pkg">GAPIT</span> does not allow missing data, hence there is no <code>naIfZeroReads</code>
argument for <code>ExportGAPIT</code>.  Genotypes are exported on a scale of -1
to 1 for <span class="pkg">rrBLUP</span>, on a scale of 0 to 2 for <span class="pkg">GAPIT</span> and <span class="pkg">FarmCPU</span>,
and on a scale of 0 to 1 for <span class="pkg">TASSEL</span>.
</p>
<p>For all functions except <code>Export_Structure</code> and <code>Export_adegenet_genind</code>,
one allele per marker is dropped.  <code>Export_MAPpoly</code>
also drops alleles where one or both parental genotypes could not be determined,
and where both parents are homozygotes.
</p>
<p>For <code>ExportGAPIT</code>
and <code>Export_rrBLUP_GWAS</code>, chromosome and position are filled with dummy
data if they do not exist in <code>object$locTable</code>.  For <code>Export_TASSEL_Numeric</code>,
allele names are exported, but no chromosome or position information per se.
</p>
<p>If the chromosomes in <code>object$locTable</code> are in character format,
<code>ExportGAPIT</code>, <code>Export_MAPpoly</code>, and <code>Export_GWASpoly</code> will
attempt to extract chromosome numbers.
</p>
<p>For <span class="pkg">polymapR</span> there must only be one possible inheritance mode across loci
(one value in <code>object$possiblePloidies</code>) in the <code>RADdata</code> object, although
triploid F1 populations derived from diploid and tetraploid parents are allowed.
See <code><a href="#topic+SubsetByPloidy">SubsetByPloidy</a></code> for help reducing a <code>RADdata</code> object to a
single inheritance mode.
</p>
<p><span class="pkg">MAPpoly</span> only
allows one ploidy, but <code>Export_MAPpoly</code> allows the user to select which
inheritance mode from the <code>RADdata</code> object to use.  (This is due to how internal
<span class="pkg">polyRAD</span> functions are coded.)
</p>


<h3>Value</h3>

<p>For <code>ExportGAPIT</code>, a list:
</p>
<table>
<tr><td><code>GD</code></td>
<td>
<p>A data frame with taxa in the first column and alleles (markers)
in subsequent columns, containing the genotypes.  To be passed to the <code>GD</code>
argument for <code>GAPIT</code> or <code>FarmCPU</code>.</p>
</td></tr>
<tr><td><code>GM</code></td>
<td>
<p>A data frame with the name, chromosome number, and position of
every allele (marker).  To be passed to the <code>GM</code> argument for <code>GAPIT</code>
or <code>FarmCPU</code>.</p>
</td></tr>
</table>
<p>For <code>Export_rrBLUP_Amat</code>, a matrix with taxa in rows and alleles (markers)
in columns, containing genotype data.  This can be passed to <code>A.mat</code> in
<span class="pkg">rrBLUP</span>.
</p>
<p>For <code>Export_rrBLUP_GWAS</code>, a data frame with alleles (markers) in rows.
The first three columns contain the marker names, chromosomes, and positions,
and the remaining columns each represent one taxon and contain the genotype
data.  This can be passed to the <code>GWAS</code> function in <span class="pkg">rrBLUP</span>.
</p>
<p><code>Export_TASSEL_Numeric</code> and <code>Export_MAPpoly</code> write a file but does
not return an object.
</p>
<p>For <code>Export_polymapR</code>, a matrix of integers indicating the most probable 
allele copy number, with markers in rows and individuals in columns.  The 
parents are listed first, followed by all progeny.
</p>
<p>For <code>Export_polymapR_probs</code>, a data frame suitable to pass to the
<code>probgeno_df</code> argument of <a href="polymapR.html#topic+checkF1">checkF1</a>.  Note that under
default parameters, in some cases the <code>maxP</code>, <code>maxgeno</code>, and
<code>geno</code> columns may not actually reflect the maximum posterior probability
if genotype correction was performed.
</p>
<p>For <code>Export_adegenet_genind</code>, a <code><a href="adegenet.html#topic+genind">&quot;genind&quot;</a></code> object.
</p>
<p><code>Export_MAPpoly</code>, <code>Export_GWASpoly</code>, and <code>Export_Structure</code>
write files but do not return
an object.  Files output by <code>Export_GWASpoly</code> are comma delimited and
in numeric format.  Sample and locus names are included in the file output
by <code>Export_Structure</code>, and the number of rows for each sample is
equal to the highest ploidy as determined by the <code>taxaPloidy</code> slot and the
output of <code>GetProbableGenotypes</code>.
</p>


<h3>Note</h3>

<p><span class="pkg">rrBLUP</span> and <span class="pkg">polymapR</span> are available through CRAN, and <span class="pkg">GAPIT</span>
and <span class="pkg">FarmCPU</span> must be downloaded from the Zhang lab website.  <span class="pkg">MAPpoly</span>
is available on GitHub but not yet on CRAN.  <span class="pkg">GWASpoly</span> is available from
GitHub.
</p>
<p>In my experience with <span class="pkg">TASSEL 5</span>, numerical genotype files that are too large do 
not load/display properly.  If you run into this problem I recommend using
<code><a href="#topic+SplitByChromosome">SplitByChromosome</a></code> to split your <code>RADdata</code> object into 
multiple smaller objects, which can then be exported to separate files using
<code>Export_TASSEL_Numeric</code>.  If performing GWAS, you may also need to compute 
a kinship matrix using separate software such as <span class="pkg">rrBLUP</span>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><b>GAPIT and FarmCPU:</b>
</p>
<p><a href="https://zzlab.net/GAPIT/">https://zzlab.net/GAPIT/</a>
</p>
<p>Lipka, A. E., Tian, F., Wang, Q., Peiffer, J., Li, M., Bradbury, P. J., 
Gore, M. A., Buckler, E. S. and Zhang, Z. (2012) GAPIT: genome association 
and prediction integrated tool.  <em>Bioinformatics</em> <b>28</b>, 2397&ndash;2399.
</p>
<p><a href="https://zzlab.net/FarmCPU/">https://zzlab.net/FarmCPU/</a>
</p>
<p>Liu, X., Huang, M., Fan, B., Buckler, E. S., Zhang, Z. (2016) Iterative usage
of fixed and random effects models for powerful and efficient genome-wide
association studies.  <em>PLoS Genetics</em> <b>12</b>, e1005767.
</p>
<p><b>rrBLUP:</b>
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic 
Selection with R Package rrBLUP.  <em>The Plant Genome</em> <b>4</b>, 250&ndash;255.
</p>
<p><b>TASSEL:</b>
</p>
<p><a href="https://www.maizegenetics.net/tassel">https://www.maizegenetics.net/tassel</a>
</p>
<p>Bradbury, P. J., Zhang, Z., Kroon, D. E., Casstevens, T. M., Ramdoss, Y. 
and Buckler, E. S. (2007) TASSEL: Software for association mapping of complex 
traits in diverse samples. <em>Bioinformatics</em> <b>23</b>, 2633&ndash;2635.
</p>
<p><b>polymapR:</b>
</p>
<p>Bourke, P., van Geest, G., Voorrips, R. E., Jansen, J., Kranenberg, T.,
Shahin, A., Visser, R. G. F., Arens, P., Smulders, M. J. M. and Maliepaard, C.
(2018) polymapR: linkage analysis and genetic map construction from F1 
populations of outcrossing polyploids. <em>Bioinformatics</em> <b>34</b>, 
3496&ndash;3502.
</p>
<p><b>MAPpoly:</b>
</p>
<p><a href="https://github.com/mmollina/MAPpoly">https://github.com/mmollina/MAPpoly</a>
</p>
<p>Mollinari, M. and Garcia, A. A. F. (2018) Linkage analysis and haplotype
phasing in experimental autopolyploid populations with high ploidy level using
hidden Markov models.  <em>bioRxiv</em> doi: https://doi.org/10.1101/415232.
</p>
<p><b>GWASpoly:</b>
</p>
<p><a href="https://github.com/jendelman/GWASpoly">https://github.com/jendelman/GWASpoly</a>
</p>
<p>Rosyara, U. R., De Jong, W. S., Douches, D. S., and Endelman, J. B.  (2016)
Software for Genome-Wide Association Studies in Autopolyploids and Its 
Application to Potato.  <em>Plant Genome</em> <b>9</b>.
</p>
<p><b>Structure:</b>
</p>
<p><a href="https://web.stanford.edu/group/pritchardlab/structure.html">https://web.stanford.edu/group/pritchardlab/structure.html</a>
</p>
<p>Hubisz, M. J., Falush, D., Stephens, M. and Pritchard, J. K. (2009)
Inferring weak population structure with the assistance of sample
group information.  <em>Molecular Ecology Resources</em> <b>9</b>,
1322&ndash;1332.
</p>
<p>Falush, D., Stephens, M. and Pritchard, J. K.  (2007)
Inferences of population structure using multilocus genotype data:
dominant markers and null alleles.  <em>Molecular Ecology Notes</em>
<b>7</b>, 574&ndash;578
</p>
<p>Falush, D., Stephens, M. and Pritchard, J. K.  (2003)
Inferences of population structure using multilocus genotype data:
linked loci and correlated allele frequencies.
<em>Genetics</em> <b>164</b>, 1567&ndash;1587.
</p>
<p>Pritchard, J. K., Stephens, M. and Donnelly, P.  (2000)
Inference of population structure using multilocus genotype data.
<em>Genetics</em> <b>155</b>, 945&ndash;959.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code>, <code><a href="#topic+RADdata2VCF">RADdata2VCF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
data(exampleRAD)
# get genotype posterior probabilities
exampleRAD &lt;- IterateHWE(exampleRAD)

# export to GAPIT
exampleGAPIT &lt;- ExportGAPIT(exampleRAD)

# export to rrBLUP
example_rrBLUP_A &lt;- Export_rrBLUP_Amat(exampleRAD)
example_rrBLUP_GWAS &lt;- Export_rrBLUP_GWAS(exampleRAD)

# export to TASSEL
outfile &lt;- tempfile() # temporary file for example
Export_TASSEL_Numeric(exampleRAD, outfile)

# for mapping populations
data(exampleRAD_mapping)

# specify donor and recurrent parents
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")

# run the pipeline
exampleRAD_mapping &lt;- PipelineMapping2Parents(exampleRAD_mapping)

# convert to polymapR format
examplePMR &lt;- Export_polymapR(exampleRAD_mapping)

examplePMR2 &lt;- Export_polymapR_probs(exampleRAD_mapping)

# export to MAPpoly
outfile2 &lt;- tempfile() # temporary file for example
# generate a dummy phenotype matrix containing random numbers
mypheno &lt;- matrix(rnorm(200), nrow = 100, ncol = 2,
                  dimnames = list(GetTaxa(exampleRAD_mapping)[-(1:2)],
                                  c("Height", "Yield")))
Export_MAPpoly(exampleRAD_mapping, file = outfile2, pheno = mypheno)

# load data into MAPpoly
# require(mappoly)
# mydata &lt;- read_geno_prob(outfile2)

# export to GWASpoly
outfile3 &lt;- tempfile() # temporary file for example
Export_GWASpoly(SubsetByPloidy(exampleRAD, list(2)), outfile3)

# export to Structure
outfile4 &lt;- tempfile() # temporary file for example
Export_Structure(exampleRAD, outfile4)

# export to adegenet
if(requireNamespace("adegenet", quietly = TRUE)){
  mygenind &lt;- Export_adegenet_genind(exampleRAD)
}
</code></pre>

<hr>
<h2 id='GetLikelyGen'>
Output the Most Likely Genotype
</h2><span id='topic+GetLikelyGen'></span>

<h3>Description</h3>

<p>For a single taxon in a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object, <code>GetLikelyGen</code>
returns the most likely genotype (expressed in allele copy number) for each
allele and each possible ploidy.  The likelihoods used for determining 
genotypes are those stored in <code>object$genotypeLikelihood</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLikelyGen(object, taxon, minLikelihoodRatio = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetLikelyGen_+3A_object">object</code></td>
<td>

<p>A <code>"RADdata"</code> object.
</p>
</td></tr>
<tr><td><code id="GetLikelyGen_+3A_taxon">taxon</code></td>
<td>

<p>A character string indicating the taxon for which genotypes should be
returned.
</p>
</td></tr>
<tr><td><code id="GetLikelyGen_+3A_minlikelihoodratio">minLikelihoodRatio</code></td>
<td>

<p>A number indicating the minimum ratio of the likelihood of the most likely
genotype to the likelihood of the second-most likely genotype for any
genotype to be output for a given allele.  If this number is one or less,
all of the most likely genotypes will be output regardless of likelihood 
ratio.  Where filtering is required so that only high confidence genotypes
are retained, this number should be increased.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with ploidies in rows (named with ploidies converted to character 
format) and alleles in columns.  Each value indicates the most likely number
of copies of that allele that the taxon has, assuming that ploidy.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset for this example
data(exampleRAD)
# add allele frequencies and genotype likelihoods
exampleRAD &lt;- AddAlleleFreqHWE(exampleRAD)
exampleRAD &lt;- AddGenotypeLikelihood(exampleRAD)

# get most likely genotypes
GetLikelyGen(exampleRAD, "sample001")
GetLikelyGen(exampleRAD, "sample082")

# try different filtering
GetLikelyGen(exampleRAD, "sample001", minLikelihoodRatio = 1)
GetLikelyGen(exampleRAD, "sample001", minLikelihoodRatio = 100)
</code></pre>

<hr>
<h2 id='GetWeightedMeanGenotypes'>
Export Numeric Genotype Values from Posterior Probabilities
</h2><span id='topic+GetWeightedMeanGenotypes'></span><span id='topic+GetWeightedMeanGenotypes.RADdata'></span><span id='topic+GetProbableGenotypes'></span><span id='topic+GetProbableGenotypes.RADdata'></span>

<h3>Description</h3>

<p>These functions calculate numerical genotype values using posterior
probabilities in a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object, and output
those values as a matrix of taxa by alleles.
<code>GetWeightedMeanGenotypes</code> returns continuous genotype values, 
weighted by posterior genotype probabilities (<em>i.e.</em> posterior mean
genotypes).  
<code>GetProbableGenotypes</code> returns discrete genotype values indicating
the most probable genotype.  If the <code>"<a href="#topic+RADdata">RADdata</a>"</code> 
object includes more than one possible inheritance mode, the 
<code>$ploidyChiSq</code> slot is used for selecting or weighting 
inheritance modes for each allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetWeightedMeanGenotypes(object, ...)
## S3 method for class 'RADdata'
GetWeightedMeanGenotypes(object, minval = 0, maxval = 1, 
                         omit1allelePerLocus = TRUE, 
                         omitCommonAllele = TRUE,
                         naIfZeroReads = FALSE, 
                         onePloidyPerAllele = FALSE, ...)

GetProbableGenotypes(object, ...)
## S3 method for class 'RADdata'
GetProbableGenotypes(object, omit1allelePerLocus = TRUE,
                     omitCommonAllele = TRUE,
                     naIfZeroReads = FALSE, 
                     correctParentalGenos = TRUE,
                     multiallelic = "correct", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.  Posterior genotype probabilities should
have been added with <code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>, and if there is
more than one possible ploidy,
ploidy chi-squared values should have been added with 
<code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_...">...</code></td>
<td>

<p>Additional arguments, listed below, to be passed to the method for
<code>"RADdata"</code>.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_minval">minval</code></td>
<td>

<p>The number that should be used for indicating that a taxon has zero
copies of an allele.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_maxval">maxval</code></td>
<td>

<p>The number that should be used for indicating that a taxon has the
maximum copies of an allele (equal to the ploidy of the locus).
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_omit1alleleperlocus">omit1allelePerLocus</code></td>
<td>

<p>A logical indicating whether one allele per locus should be omitted
from the output, in order to reduce the number of variables and
prevent singularities for 
genome-wide association and genomic prediction.  The value for one
allele can be predicted from the values from all other alleles at
its locus.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_omitcommonallele">omitCommonAllele</code></td>
<td>

<p>A logical, passed to the <code>commonAllele</code> argument of 
<code><a href="#topic+OneAllelePerMarker">OneAllelePerMarker</a></code>, indicating whether the most common allele
for each locus should be omitted (as opposed to simply the first allele
for each locus).  Ignored if <code>omit1allelePerLocus = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_naifzeroreads">naIfZeroReads</code></td>
<td>

<p>A logical indicating whether <code>NA</code> should be inserted into the 
output matrix for any taxa and loci where the total read depth for
the locus is zero.  If <code>FALSE</code>, the output for these genotypes is
essentially calculated using prior genotype probabilities, since
prior and posterior genotype probabilities are equal when there are no
reads.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_oneploidyperallele">onePloidyPerAllele</code></td>
<td>

<p>Logical.  If <code>TRUE</code>, for each allele the inheritance mode with the
lowest <code class="reqn">\chi ^ 2</code> value is selected and is assumed to be
the true inheritance mode.  If <code>FALSE</code>, inheritance modes are weighted
by inverse <code class="reqn">\chi ^ 2</code> values for each allele, and mean
genotypes that have been weighted across inheritance modes are returned.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_correctparentalgenos">correctParentalGenos</code></td>
<td>

<p>Logical.  If <code>TRUE</code> and if the dataset was processed with
<code><a href="#topic+PipelineMapping2Parents">PipelineMapping2Parents</a></code>, the parental genotypes that are output
are corrected according to the progeny allele frequencies, using the 
<code>likelyGeno_donor</code> and <code>likelyGeno_recurrent</code> slots in <code>object</code>.
For the ploidy of the marker, the appropriate ploidy for the parents is 
selected using the <code>donorPloidies</code> and <code>recurrentPloidies</code> slots.
</p>
</td></tr>
<tr><td><code id="GetWeightedMeanGenotypes_+3A_multiallelic">multiallelic</code></td>
<td>

<p>A string indicating how to handle cases where allele copy number across all
alleles at a locus does not sum to the ploidy.  To retain the most probable
copy number for each allele, even if they don't sum to the ploidy across
all alleles, use <code>"ignore"</code>.  To be conservative and convert these allele
copy numbers to <code>NA</code>, use <code>"na"</code>.  To adjust allele copy numbers to
match the ploidy (adding or subtracting allele copies while maximizing the
product of posterior probabilities across alleles), use <code>"correct"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each inheritance mode <code class="reqn">m</code>, taxon <code class="reqn">t</code>, allele <code class="reqn">a</code>, allele copy number 
<code class="reqn">i</code>, total ploidy <code class="reqn">k</code>, and posterior genotype probability <code class="reqn">p_{i,t,a,m}</code>,
posterior mean genotype <code class="reqn">g_{t,a,m}</code> is estimated by <code>GetWeightedMeanGenotypes</code> as:
</p>
<p style="text-align: center;"><code class="reqn">g_{t,a,m} = \sum_{i = 0}^k p_{i,t,a,m} * \frac{i}{k}</code>
</p>

<p>For <code>GetProbableGenotypes</code>, the genotype is the one with the maximum posterior
probability:
</p>
<p style="text-align: center;"><code class="reqn">g_{t,a,m} = i | \max_{i = 0}^k{p_{i,t,a,m}}</code>
</p>

<p>When there are multiple inheritance modes and <code>onePloidyPerAllele = FALSE</code>,
the weighted genotype is estimated by <code>GetWeightedMeanGenotypes</code> as:
</p>
<p style="text-align: center;"><code class="reqn">g_{t,a} = \sum_m [ g_{t,a,m} * \frac{1}{\chi^2_{m,a}} / \sum_m \frac{1}{\chi^2_{m,a}}]</code>
</p>

<p>In <code>GetProbableGenotypes</code>, or <code>GetWeightedMeanGenotypes</code>
when there are multiple inheritance modes and <code>onePloidyPerAllele = TRUE</code>,
the genotype is simply the one corresponding to the inheritance mode with the minimum
<code class="reqn">\chi ^2</code> value:
</p>
<p style="text-align: center;"><code class="reqn">g_{t,a} = g_{t,a,m} | \min_m{\chi^2_{m,a}}</code>
</p>



<h3>Value</h3>

<p>For <code>GetWeightedMeanGenotypes</code>,
a named matrix, with taxa in rows and alleles in columns,
and values ranging from <code>minval</code> to <code>maxval</code>.
These values can be treated as continuous genotypes.
</p>
<p>For <code>GetProbableGenotypes</code>, a list:
</p>
<table>
<tr><td><code>genotypes</code></td>
<td>

<p>A named integer matrix, with taxa in rows and alleles in columns,
and values ranging from zero to the maximum ploidy for
each allele.  These values can be treated as discrete genotypes.
</p>
</td></tr>
<tr><td><code>ploidy_index</code></td>
<td>

<p>A vector with one value per allele.  It contains the index
of the most likely inheritance mode of that allele in 
<code>object$priorProbPloidies</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data(exampleRAD_mapping)

# run a genotype calling pipeline; 
# substitute with any pipeline and parameters
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")
exampleRAD_mapping &lt;- PipelineMapping2Parents(exampleRAD_mapping,
                                 n.gen.backcrossing = 1, useLinkage = FALSE)


# get weighted mean genotypes
wmg &lt;- GetWeightedMeanGenotypes(exampleRAD_mapping)
# examine the results
wmg[1:10,]

# get most probable genotypes
pg &lt;- GetProbableGenotypes(exampleRAD_mapping, naIfZeroReads = TRUE)
# examine the results
pg$genotypes[1:10,]
</code></pre>

<hr>
<h2 id='HindHe'>
Identify Non-Mendelian Loci and Taxa that Deviate from Ploidy Expectations
</h2><span id='topic+HindHe'></span><span id='topic+HindHe.RADdata'></span><span id='topic+HindHeMapping'></span><span id='topic+HindHeMapping.RADdata'></span>

<h3>Description</h3>

<p><code>HindHe</code> and <code>HindHeMapping</code> both generate a matrix of values, with
taxa in rows and loci in columns.  The mean value of the matrix is expected to
be a certain value depending on the ploidy and, in the case of natural
populations and diversity panels, the inbreeding coefficient.  <code>colMeans</code>
of the matrix can be used to filter non-Mendelian loci from the dataset.
<code>rowMeans</code> of the matrix can be used to identify taxa that are not the
expected ploidy, are interspecific hybrids, or are a mix of multiple samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HindHe(object, ...)

## S3 method for class 'RADdata'
HindHe(object, omitTaxa = GetBlankTaxa(object), ...)

HindHeMapping(object, ...)

## S3 method for class 'RADdata'
HindHeMapping(object, n.gen.backcrossing = 0, n.gen.intermating = 0,
              n.gen.selfing = 0, ploidy = object$possiblePloidies[[1]],
              minLikelihoodRatio = 10,
              omitTaxa = c(GetDonorParent(object), GetRecurrentParent(object), 
                           GetBlankTaxa(object)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HindHe_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object.  Genotype calling does not need to have been
performed yet.  If the population is a mapping population,
<code><a href="#topic+SetDonorParent">SetDonorParent</a></code> and <code><a href="#topic+SetRecurrentParent">SetRecurrentParent</a></code> should have
been run already.
</p>
</td></tr>
<tr><td><code id="HindHe_+3A_omittaxa">omitTaxa</code></td>
<td>

<p>A character vector indicating names of taxa not to be included in the output.
For <code>HindHe</code>, these taxa will also be omitted from allele frequency
estimations.
</p>
</td></tr>
<tr><td><code id="HindHe_+3A_n.gen.backcrossing">n.gen.backcrossing</code></td>
<td>

<p>The number of generations of backcrossing performed in a mapping population.  
</p>
</td></tr>
<tr><td><code id="HindHe_+3A_n.gen.intermating">n.gen.intermating</code></td>
<td>

<p>The number of generations of intermating performed in a mapping population.
Included for consistency with <code><a href="#topic+PipelineMapping2Parents">PipelineMapping2Parents</a></code>, but
currently will give an error if set to any value other than zero.  If the most
recent generation in your mapping population was random mating among all
progeny, use <code>HindHe</code> instead of <code>HindHeMapping</code>.
</p>
</td></tr>
<tr><td><code id="HindHe_+3A_n.gen.selfing">n.gen.selfing</code></td>
<td>

<p>The number of generations of self-fertilization performed in a mapping population.
</p>
</td></tr>
<tr><td><code id="HindHe_+3A_ploidy">ploidy</code></td>
<td>

<p>A single value indicating the assumed ploidy to test.  Currently, only
autopolyploid and diploid inheritance modes are supported.
</p>
</td></tr>
<tr><td><code id="HindHe_+3A_minlikelihoodratio">minLikelihoodRatio</code></td>
<td>

<p>Used internally by <code><a href="#topic+EstimateParentalGenotypes">EstimateParentalGenotypes</a></code> as a threshold for
certainty of parental genotypes.  Decrease this value if too many markers are
being discarded from the calculation.
</p>
</td></tr>
<tr><td><code id="HindHe_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are especially useful for highly duplicated genomes, in which
RAD tag alignments may have been incorrect, resulting in groups of alleles that
do not represent true Mendelian loci.  The statistic that is calculated is based
on the principle that observed heterozygosity will be higher than expected
heterozygosity if a &quot;locus&quot; actually represents two or more collapsed paralogs.
However, the statistic uses read depth in place of genotypes, eliminating the
need to perform genotype calling before filtering.
</p>
<p>For a given taxon * locus, <code class="reqn">H_{ind}</code> is the probability that two
sequencing reads, sampled without replacement, are different alleles (RAD tags).
</p>
<p>In <code>HindHe</code>, <code class="reqn">H_E</code> is the expected heterozygosity, estimated from
allele frequencies by taking the column means of <code>object$depthRatios</code>.
This is also the estimated probability that if two alleles were sampled at
random from the population at a given locus, they would be different alleles.
</p>
<p>In <code>HindHeMapping</code>, <code class="reqn">H_E</code> is the average probability that in
a random progeny, two alleles sampled without replacement would be different.
The number of generations of backcrossing and self-fertilization, along with the
ploidy and estimated parental genotypes, are needed to make this calculation.
The function essentially simulates the mapping population based on parental
genotypes to determine <code class="reqn">H_E</code>.
</p>
<p>The expectation is that
</p>
<p style="text-align: center;"><code class="reqn">H_{ind}/H_E = \frac{ploidy - 1}{ploidy} * (1 - F)</code>
</p>

<p>in a diversity panel, where <code class="reqn">F</code> is the inbreeding coefficient, and
</p>
<p style="text-align: center;"><code class="reqn">H_{ind}/H_E = \frac{ploidy - 1}{ploidy}</code>
</p>

<p>in a mapping population.  Loci that have much higher average values likely
represent collapsed paralogs that should be removed from the dataset.  Taxa
with much higher average values may be higher ploidy than expected,
interspecific hybrids, or multiple samples mixed together.
</p>


<h3>Value</h3>

<p>A named matrix, with taxa in rows and loci in columns.  For <code>HindHeMapping</code>,
loci are omitted if consistent parental genotypes could not be determined across
alleles.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Clark, L. V., Mays, W., Lipka, A. E. and Sacks, E. J. (2022) A population-level
statistic for assessing Mendelian behavior of genotyping-by-sequencing data
from highly duplicated genomes. <em>BMC Bioinformatics</em> <b>23</b>, 101,
doi:10.1186/s12859-022-04635-9.
</p>
<p>A seminar describing
<code class="reqn">H_{ind}/H_E</code> is available at <a href="https://youtu.be/Z2xwLQYc8OA?t=1678">https://youtu.be/Z2xwLQYc8OA?t=1678</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InbreedingFromHindHe">InbreedingFromHindHe</a></code>,
<code><a href="#topic+ExpectedHindHe">ExpectedHindHe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)

hhmat &lt;- HindHe(exampleRAD)
colMeans(hhmat, na.rm = TRUE) # near 0.5 for diploid loci, 0.75 for tetraploid loci

data(exampleRAD_mapping)
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")

hhmat2 &lt;- HindHeMapping(exampleRAD_mapping, n.gen.backcrossing = 1)
colMeans(hhmat2, na.rm = TRUE) # near 0.5; all loci diploid
</code></pre>

<hr>
<h2 id='InbreedingFromHindHe'>
Estimate Inbreeding from Hind/He for a Given Ploidy
</h2><span id='topic+InbreedingFromHindHe'></span>

<h3>Description</h3>

<p>After running <code><a href="#topic+HindHe">HindHe</a></code> and examining the distribution of values
across taxa and loci, <code>InbreedingFromHindHe</code> can be used to estimate
the inbreeding statistic <code class="reqn">F</code> from the median or mode value of
<code class="reqn">H_{ind}/H_E</code>.  The statistic estimated encompasses inbreeding
from all sources, including population structure, self-fertilization, and
preferential mating among relatives.  It is intended to be used as input to
the <code>process_isoloci.py</code> script.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InbreedingFromHindHe(hindhe, ploidy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InbreedingFromHindHe_+3A_hindhe">hindhe</code></td>
<td>

<p>A value for <code class="reqn">H_{ind}/H_E</code>.  It should generally range from zero to
one.
</p>
</td></tr>
<tr><td><code id="InbreedingFromHindHe_+3A_ploidy">ploidy</code></td>
<td>

<p>A single integer indicating the ploidy of the population.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number indicating the inbreeding statistic <code class="reqn">F</code>.  This is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">1 - hindhe * ploidy / (ploidy - 1)</code>
</p>



<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HindHe">HindHe</a></code>, <code><a href="#topic+ExpectedHindHe">ExpectedHindHe</a></code>,
<code><a href="#topic+readProcessSamMulti">readProcessSamMulti</a></code>, <code><a href="#topic+readProcessIsoloci">readProcessIsoloci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>InbreedingFromHindHe(0.5, 2)
InbreedingFromHindHe(0.4, 2)
InbreedingFromHindHe(0.5, 4)
</code></pre>

<hr>
<h2 id='IterateHWE'>
Iteratively Estimate Population Parameters and Genotypes In a Diversity Panel
</h2><span id='topic+IterateHWE'></span><span id='topic+IterateHWE_LD'></span><span id='topic+IteratePopStruct'></span><span id='topic+IteratePopStructLD'></span>

<h3>Description</h3>

<p>These are wrapper function that iteratively run other <span class="pkg">polyRAD</span> functions 
until allele frequencies stabilize to within a user-defined threshold.  Genotype
posterior probabilities can then be exported for downstream analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IterateHWE(object, selfing.rate = 0, tol = 1e-05,
           excludeTaxa = GetBlankTaxa(object),
           overdispersion = 9)

IterateHWE_LD(object, selfing.rate = 0, tol = 1e-05, 
              excludeTaxa = GetBlankTaxa(object),
              LDdist = 1e4, minLDcorr = 0.2,
              overdispersion = 9)

IteratePopStruct(object, selfing.rate = 0, tol = 1e-03,
                 excludeTaxa = GetBlankTaxa(object),
                 nPcsInit = 10, minfreq = 0.0001,
                 overdispersion = 9, maxR2changeratio = 0.05)

IteratePopStructLD(object, selfing.rate = 0, tol = 1e-03,
                   excludeTaxa = GetBlankTaxa(object),
                   nPcsInit = 10, minfreq = 0.0001, LDdist = 1e4, 
                   minLDcorr = 0.2,
                   overdispersion = 9, maxR2changeratio = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IterateHWE_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_selfing.rate">selfing.rate</code></td>
<td>

<p>A number ranging from zero to one indicating the frequency of
self-fertilization in the species.  For individuals with odd ploidy
(e.g. triploids), the selfing rate is always treated as zero and a warning is
printed if a value above zero is provided.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_tol">tol</code></td>
<td>

<p>A number indicating when the iteration should end.  It indicates the maximum mean 
difference in allele frequencies between iterations that is tolerated.  Larger
numbers will lead to fewer iterations.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_excludetaxa">excludeTaxa</code></td>
<td>

<p>A character vector indicating names of taxa that should be excluded from allele 
frequency estimates and chi-squared estimates.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_npcsinit">nPcsInit</code></td>
<td>

<p>An integer indicating the number of principal component axes to initially 
estimate from <code>object$depthRatio</code>.  Passed to <code><a href="#topic+AddPCA">AddPCA</a></code>.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_minfreq">minfreq</code></td>
<td>

<p>A number indicating the minimum allele frequency allowed.  Passed to
<code><a href="#topic+AddAlleleFreqByTaxa">AddAlleleFreqByTaxa</a></code>.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_lddist">LDdist</code></td>
<td>

<p>The distance, in basepairs, within which to search for alleles that may be in
linkage disequilibrium with a given allele.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_minldcorr">minLDcorr</code></td>
<td>

<p>The minimum correlation coefficient between two alleles 
for linkage disequilibrium between those alleles to be used by the pipeline
for genotype estimation; see <code><a href="#topic+AddAlleleLinkages">AddAlleleLinkages</a></code>.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_overdispersion">overdispersion</code></td>
<td>

<p>Overdispersion parameter; see <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>.
</p>
</td></tr>
<tr><td><code id="IterateHWE_+3A_maxr2changeratio">maxR2changeratio</code></td>
<td>

<p>This number determines how many principal component axes are retained.  The 
difference in <code class="reqn">R^2</code> values between the first and second axes 
is multiplied by <code>maxR2changeratio</code>.  The last axis retained is the first
axis after which the <code class="reqn">R^2</code> value changes by less than this value.
Lower values of <code>maxR2changeratio</code> will result in more axes being retained.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>IterateHWE</code>, the following functions are run iteratively,
assuming no population structure:
<code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>, 
<code><a href="#topic+AddGenotypePriorProb_HWE">AddGenotypePriorProb_HWE</a></code>, <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>,
<code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>, and <code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>.
</p>
<p><code>IterateHWE_LD</code> runs each of the functions listed for <code>IterateHWE</code>
once, then runs <code><a href="#topic+AddAlleleLinkages">AddAlleleLinkages</a></code>.  It then runs
<code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>, <code><a href="#topic+AddGenotypePriorProb_HWE">AddGenotypePriorProb_HWE</a></code>,
<code><a href="#topic+AddGenotypePriorProb_LD">AddGenotypePriorProb_LD</a></code>, <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>,
<code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>, and <code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>
iteratively until allele frequencies converge.
</p>
<p>For <code>IteratePopStruct</code>, the following functions are run iteratively,
modeling population structure:
<code><a href="#topic+AddPCA">AddPCA</a></code>, <code><a href="#topic+AddAlleleFreqByTaxa">AddAlleleFreqByTaxa</a></code>, 
<code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>, <code><a href="#topic+AddGenotypePriorProb_ByTaxa">AddGenotypePriorProb_ByTaxa</a></code>,
<code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>, <code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>, and
<code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>.
After the first PCA analysis, the number of principal component axes is not
allowed to decrease, and can only increase by one from one round to the next,
in order to help the algorithm converge.
</p>
<p><code>IteratePopStructLD</code> runs each of the functions listed for 
<code>IteratePopStruct</code> once, then runs <code><a href="#topic+AddAlleleLinkages">AddAlleleLinkages</a></code>.
It then runs  
<code><a href="#topic+AddAlleleFreqHWE">AddAlleleFreqHWE</a></code>, <code><a href="#topic+AddGenotypePriorProb_ByTaxa">AddGenotypePriorProb_ByTaxa</a></code>,
<code><a href="#topic+AddGenotypePriorProb_LD">AddGenotypePriorProb_LD</a></code>,
<code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>, <code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>, 
<code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>, <code><a href="#topic+AddPCA">AddPCA</a></code>, 
and <code><a href="#topic+AddAlleleFreqByTaxa">AddAlleleFreqByTaxa</a></code> iteratively until convergence of
allele frequencies.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to that passed to the function, but with
<code>$alleleFreq</code>, <code>$priorProb</code>, <code>$depthSamplingPermutations</code>,
<code>$genotypeLikelihood</code>, 
<code>$ploidyChiSq</code>, and <code>$posteriorProb</code> slots added.  
For <code>IteratePopStruct</code> and <code>IteratePopStructLD</code>, 
<code>$alleleFreqByTaxa</code> and <code>$PCA</code> are also added.  For 
<code>IteratePopStructLD</code> and <code>IterateHWE_LD</code>, <code>$alleleLinkages</code> 
and <code>$priorProbLD</code> are also added.
</p>


<h3>Note</h3>

<p>If you see the error 
</p>
<p><code>Error in if (rel_ch &lt; threshold &amp; count &gt; 5) { : 
  missing value where TRUE/FALSE needed</code>
</p>
<p>try lowering <code>nPcsInit</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> for outputting genotypes in a 
useful format after iteration is completed.
</p>
<p><code><a href="#topic+StripDown">StripDown</a></code> to remove memory-hogging slots that are no longer
needed after the pipeline has been run.
</p>
<p><code><a href="#topic+PipelineMapping2Parents">PipelineMapping2Parents</a></code> for mapping populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dataset
data(exampleRAD)

# iteratively estimate parameters
exampleRAD &lt;- IterateHWE(exampleRAD)

# export results
GetWeightedMeanGenotypes(exampleRAD)

# re-load to run pipeline assuming population structure
data(exampleRAD)

# run pipeline
exampleRAD &lt;- IteratePopStruct(exampleRAD, nPcsInit = 3)

# export results
GetWeightedMeanGenotypes(exampleRAD)

# dataset for LD pipeline
data(Msi01genes)

# run HWE + LD pipeline
mydata1 &lt;- IterateHWE_LD(Msi01genes)

# run pop. struct + LD pipeline
# (tolerance raised to make example run faster)
mydata2 &lt;- IteratePopStructLD(Msi01genes, tol = 0.01)
</code></pre>

<hr>
<h2 id='LocusInfo'>
Get Information about a Single Locus
</h2><span id='topic+LocusInfo'></span><span id='topic+LocusInfo.RADdata'></span>

<h3>Description</h3>

<p>This function returns, and optionally prints, information about a single locus
with a <code><a href="#topic+RADdata">RADdata</a></code> object, including alignment position, allele
sequences, and genes overlapping the site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocusInfo(object, ...)
## S3 method for class 'RADdata'
LocusInfo(object, locus, genome = NULL,
          annotation = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocusInfo_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="LocusInfo_+3A_locus">locus</code></td>
<td>

<p>A character string indicating the name of the locus to display.  Alternatively,
a character string indicating the name of an allele, for which the 
corresponding locus will be identified.
</p>
</td></tr>
<tr><td><code id="LocusInfo_+3A_genome">genome</code></td>
<td>

<p>An optional <code><a href="Rsamtools.html#topic+FaFile-class">FaFile</a></code> or 
<code><a href="BSgenome.html#topic+BSgenome-class">BSgenome</a></code>
object containing the reference genome sequence.
</p>
</td></tr>
<tr><td><code id="LocusInfo_+3A_annotation">annotation</code></td>
<td>

<p>An optional <code><a href="GenomicFeatures.html#topic+TxDb-class">TxDb</a></code> object containing the genome annotation.
</p>
</td></tr>
<tr><td><code id="LocusInfo_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, results will be printed to the console.
</p>
</td></tr>
<tr><td><code id="LocusInfo_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The locus name, allele names, and allele sequences are always returned (although
allele names are not printed with <code>verbose</code>).  If the chromosome and 
position are known, those are also returned and printed.  If <code>annotation</code>
is provided, the function will return and print genes that overlap the locus.
If <code>annotation</code> and <code>genome</code> are provided, the function will attempt
to identify any amino acid changes caused by the alleles, using
<code><a href="VariantAnnotation.html#topic+predictCoding-methods">predictCoding</a></code> 
internally.  Identification of
amino acid changes will work if the <code>RADdata</code> object was created with
<code>VCF2RADdata</code> using the <code>refgenome</code> argument to fill in non-variable
sites, and/or if the alleles are only one nucleotide long.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Locus</code></td>
<td>
<p>The name of the locus.</p>
</td></tr>
<tr><td><code>Chromosome</code></td>
<td>
<p>The chromosome name, if present.</p>
</td></tr>
<tr><td><code>Position</code></td>
<td>
<p>The position in base pairs on the chromosome, if present.</p>
</td></tr>
<tr><td><code>Alleles</code></td>
<td>
<p>Allele names for the locus.</p>
</td></tr>
<tr><td><code>Haplotypes</code></td>
<td>
<p>Allele sequences for the locus, in the same order.</p>
</td></tr>
<tr><td><code>Frequencies</code></td>
<td>
<p>Allele frequencies, if present, in the same order.</p>
</td></tr>
<tr><td><code>Transcripts</code></td>
<td>
<p>Transcripts overlapping the locus, if an annotation was
provided but it wasn't possible to predict amino acid changes.</p>
</td></tr>
<tr><td><code>PredictCoding</code></td>
<td>
<p>The output of <code>predictCoding</code>, if it was run.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="GenomicFeatures.html#topic+makeTxDbFromGFF">makeTxDbFromGFF</a></code>, <code><a href="#topic+GetLoci">GetLoci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)
exampleRAD &lt;- AddAlleleFreqHWE(exampleRAD)
loc2info &lt;- LocusInfo(exampleRAD, "loc2")
</code></pre>

<hr>
<h2 id='MakeTasselVcfFilter'>
Filter Lines of a VCF File By Call Rate and Allele Frequency
</h2><span id='topic+MakeTasselVcfFilter'></span>

<h3>Description</h3>

<p>This function creates another function that can be used as a prefilter
by the function <code>filterVcf</code> in the package <span class="pkg">VariantAnnotation</span>.
The user can set a minimum number of indiviuals with reads and a minimum
number of individuals with the minor allele (either the alternative or
reference allele).  The filter can be used to generate a smaller VCF file 
before reading with <code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeTasselVcfFilter(min.ind.with.reads = 200, min.ind.with.minor.allele = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeTasselVcfFilter_+3A_min.ind.with.reads">min.ind.with.reads</code></td>
<td>

<p>An integer indicating the minimum number of individuals that must have
reads in order for a marker to be retained.
</p>
</td></tr>
<tr><td><code id="MakeTasselVcfFilter_+3A_min.ind.with.minor.allele">min.ind.with.minor.allele</code></td>
<td>

<p>An integer indicating the minimum number of individuals that must have
the minor allele in order for a marker to be retained.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes the VCF file was output by the TASSEL GBSv2
pipeline.  This means that each genotype field begins with two digits
ranging from zero to three
separated by a forward slash to indicate the called genotype, followed
by a colon.
</p>


<h3>Value</h3>

<p>A function is returned.  The function takes as its only argument a character
vector representing a set of lines from a VCF file, with each line representing
one SNP.  The function returns a logical vector the same length as the
character vector, with <code>TRUE</code> if the SNP meets the threshold for call rate
and minor allele frequency, and <code>FALSE</code> if it does not.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://bitbucket.org/tasseladmin/tassel-5-source/wiki/Tassel5GBSv2Pipeline">https://bitbucket.org/tasseladmin/tassel-5-source/wiki/Tassel5GBSv2Pipeline</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make the filtering function
filterfun &lt;- MakeTasselVcfFilter(300, 15)


# Executable code excluded from CRAN testing for taking &gt;10 s:

require(VariantAnnotation)
# get the example VCF installed with polyRAD
exampleVCF &lt;- system.file("extdata", "Msi01genes.vcf", package = "polyRAD")
exampleBGZ &lt;- paste(exampleVCF, "bgz", sep = ".")

# zip and index the file using Tabix (if not done already)
if(!file.exists(exampleBGZ)){
  exampleBGZ &lt;- bgzip(exampleVCF)
  indexTabix(exampleBGZ, format = "vcf")
}

# make a temporary file
# (for package checks; you don't need to do this in your own code)
outfile &lt;- tempfile(fileext = ".vcf")

# filter to a new file
filterVcf(exampleBGZ, destination = outfile, 
          prefilters = FilterRules(list(filterfun)))

</code></pre>

<hr>
<h2 id='MergeIdenticalHaplotypes'>
Merge Alleles with Identical DNA Sequences
</h2><span id='topic+MergeIdenticalHaplotypes'></span>

<h3>Description</h3>

<p>If any alleles within a locus have identical <code>alleleNucleotides</code> values
(including those identical based on IUPAC ambiguity codes),
this function merges those alleles, summing their read depths.  This function is
primarily intended to be used internally in cases where tags vary in length
within a locus, resulting in truncated <code>alleleNucleotides</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MergeIdenticalHaplotypes(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MergeIdenticalHaplotypes_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object.
</p>
</td></tr>
<tr><td><code id="MergeIdenticalHaplotypes_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RADdata</code> object identical to <code>object</code>, but with alleles merged.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MergeRareHaplotypes">MergeRareHaplotypes</a></code>, <code><a href="#topic+readProcessIsoloci">readProcessIsoloci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)
# change a haplotype for this example
exampleRAD$alleleNucleotides[5] &lt;- "GY"

nAlleles(exampleRAD)
exampleRAD &lt;- MergeIdenticalHaplotypes(exampleRAD)
nAlleles(exampleRAD)
</code></pre>

<hr>
<h2 id='MergeRareHaplotypes'>
Consolidate Reads from Rare Alleles
</h2><span id='topic+MergeRareHaplotypes'></span><span id='topic+MergeRareHaplotypes.RADdata'></span>

<h3>Description</h3>

<p><code>MergeRareHaplotypes</code> searches for rare alleles in a
<code>"<a href="#topic+RADdata">RADdata</a>"</code> object, and merges them into the most similar allele
at the same locus based on nucleotide sequence (or the most common allele if
multiple are equally similar).  Read
depth is summed across merged alleles, and the <code>alleleNucleotides</code> slot
of the <code>"RADdata"</code> object contains IUPAC ambiguity codes to indicate 
nucleotide differences across merged alleles.  This function is designed to be
used immediately after data import.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MergeRareHaplotypes(object, ...)
## S3 method for class 'RADdata'
MergeRareHaplotypes(object, min.ind.with.haplotype = 10, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MergeRareHaplotypes_+3A_object">object</code></td>
<td>

<p>A <code>"RADdata"</code> object.
</p>
</td></tr>
<tr><td><code id="MergeRareHaplotypes_+3A_min.ind.with.haplotype">min.ind.with.haplotype</code></td>
<td>

<p>The minimum number of taxa having reads from a given allele for that allele to
not be merged.
</p>
</td></tr>
<tr><td><code id="MergeRareHaplotypes_+3A_...">...</code></td>
<td>

<p>Additional arguments; none implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alleles with zero reads across the entire dataset are removed by
<code>MergeRareHaplotypes</code> without merging nucleotide sequences.  After
merging, at least one allele is left, even if it has fewer than 
<code>min.ind.with.haplotype</code> taxa with reads, as long as it has more than zero
taxa with reads.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to <code>object</code>, but with its 
<code>$alleleDepth</code>, <code>$antiAlleleDepth</code>, <code>$depthRatio</code>,
<code>$depthSamplingPermutations</code>, <code>$alleleNucleotides</code>, and
<code>$alleles2loc</code> arguments adjusted after merging alleles.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SubsetByLocus">SubsetByLocus</a></code>, <code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>, <code><a href="#topic+readStacks">readStacks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)
exampleRAD2 &lt;- MergeRareHaplotypes(exampleRAD, 
                                   min.ind.with.haplotype = 20)
exampleRAD$alleleDepth[21:30,6:7]
exampleRAD2$alleleDepth[21:30,6,drop=FALSE]
exampleRAD$alleleNucleotides
exampleRAD2$alleleNucleotides
</code></pre>

<hr>
<h2 id='MergeTaxaDepth'>
Combine Read Depths from Multiple Taxa into One Taxon
</h2><span id='topic+MergeTaxaDepth'></span><span id='topic+MergeTaxaDepth.RADdata'></span>

<h3>Description</h3>

<p>This function should be used in situations where data that were imported as
separate taxa should be merged into a single taxon.  The function should be
used before any of the pipeline functions for genotype calling.  Read depths
are summed across duplicate taxa and output as a single taxon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MergeTaxaDepth(object, ...)

## S3 method for class 'RADdata'
MergeTaxaDepth(object, taxa, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MergeTaxaDepth_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object.
</p>
</td></tr>
<tr><td><code id="MergeTaxaDepth_+3A_taxa">taxa</code></td>
<td>

<p>A character vector indicating taxa to be merged.  The first taxon in the vector
will be used to name the combined taxon in the output.
</p>
</td></tr>
<tr><td><code id="MergeTaxaDepth_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Examples of reasons to use this function:
</p>

<ul>
<li><p> Duplicate samples across different libraries were given different
names so that preliminary analysis could confirm that they were truly the same
(<em>i.e.</em> no mix-ups) before combining them.
</p>
</li>
<li><p> Typos in the key file for the SNP mining software (TASSEL, Stacks, etc.)
caused duplicate samples to have different names when they really should have
had the same name.
</p>
</li></ul>

<p>To merge multiple sets of taxa into multiple combined taxa, this function can
be run multiple times or in a loop.
</p>


<h3>Value</h3>

<p>A <code>RADdata</code> object derived from <code>object</code>.  The <code>alleleDepth</code>,
<code>antiAlleleDepth</code>, <code>locDepth</code>, <code>depthRatio</code>, and
<code>depthSamplingPermutation</code> slots, and <code>"taxa"</code> and <code>"nTaxa"</code>
attributes, have been changed accordingly to reflect the merge.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SubsetByTaxon">SubsetByTaxon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dataset for this example
data(exampleRAD)

# merge the first three taxa into one
exampleRADm &lt;- MergeTaxaDepth(exampleRAD, c("sample001", "sample002", "sample003"))

# inspect read depth
exampleRAD$alleleDepth[1:3,]
exampleRADm$alleleDepth[1:3,]
</code></pre>

<hr>
<h2 id='OneAllelePerMarker'>
Return the Index of One Allele for Each Locus
</h2><span id='topic+OneAllelePerMarker'></span><span id='topic+OneAllelePerMarker.RADdata'></span>

<h3>Description</h3>

<p>This function exists primarily to be called by functions such as 
<code><a href="#topic+AddPCA">AddPCA</a></code> and <code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code>
that may need to exclude one allele per locus to avoid mathematical
singularities.  For a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object, it returns
the indices of one allele per locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OneAllelePerMarker(object, ...)
## S3 method for class 'RADdata'
OneAllelePerMarker(object, commonAllele = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OneAllelePerMarker_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="OneAllelePerMarker_+3A_commonallele">commonAllele</code></td>
<td>

<p>If <code>TRUE</code>, the index of the most common allele for each locus is 
returned, according to <code>object$alleleFreq</code>.  If <code>FALSE</code>, 
the index of the first allele for each locus is returned.
</p>
</td></tr>
<tr><td><code id="OneAllelePerMarker_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector indicating the index of one allele for each locus
in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetTaxa">GetTaxa</a></code> for a list of accessors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleRAD)

OneAllelePerMarker(exampleRAD)

OneAllelePerMarker(exampleRAD, commonAllele = TRUE)
</code></pre>

<hr>
<h2 id='PipelineMapping2Parents'>
Run polyRAD Pipeline on a Mapping Population
</h2><span id='topic+PipelineMapping2Parents'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code><a href="#topic+AddAlleleFreqMapping">AddAlleleFreqMapping</a></code>,
<code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>, 
<code><a href="#topic+AddGenotypePriorProb_Mapping2Parents">AddGenotypePriorProb_Mapping2Parents</a></code>,
<code><a href="#topic+AddPloidyChiSq">AddPloidyChiSq</a></code>, and <code><a href="#topic+AddGenotypePosteriorProb">AddGenotypePosteriorProb</a></code>.
It covers the full pipeline for estimating genotype posterior probabilities
from read depth in a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object containing data from
a mapping population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PipelineMapping2Parents(object, n.gen.backcrossing = 0,
                        n.gen.intermating = 0, n.gen.selfing = 0, 
                        minLikelihoodRatio = 10, freqAllowedDeviation = 0.05, 
                        freqExcludeTaxa = c(GetDonorParent(object), 
                                            GetRecurrentParent(object), 
                                            GetBlankTaxa(object)),
                        useLinkage = TRUE, linkageDist = 1e7,
                        minLinkageCorr = 0.5, overdispersion = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PipelineMapping2Parents_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_n.gen.backcrossing">n.gen.backcrossing</code></td>
<td>

<p>An integer, zero or greater, indicating how many generations of 
backcrossing to the recurrent parent were performed.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_n.gen.intermating">n.gen.intermating</code></td>
<td>

<p>An integer, zero or greater, indicating how many generations of 
intermating within the population were performed.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_n.gen.selfing">n.gen.selfing</code></td>
<td>

<p>An integer, zero or greater, indicating how many generations of
selfing were performed.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_minlikelihoodratio">minLikelihoodRatio</code></td>
<td>

<p>The minimum likelihood ratio for determining parental genotypes with
confidence, to be passed to <code><a href="#topic+GetLikelyGen">GetLikelyGen</a></code> for both
parental taxa.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_freqalloweddeviation">freqAllowedDeviation</code></td>
<td>

<p>For <code><a href="#topic+AddAlleleFreqMapping">AddAlleleFreqMapping</a></code>, the amount by which an allele
frequency can deviate from an expected allele frequency in order to be
counted as that allele frequency.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_freqexcludetaxa">freqExcludeTaxa</code></td>
<td>

<p>A character vector indicating taxa to exclude from allele frequency
estimates and ploidy <code class="reqn">\chi ^ 2</code> estimates.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_uselinkage">useLinkage</code></td>
<td>

<p>Boolean.  Should genotypes at nearby loci (according to genomic alignment
data) be used for updating genotype priors?
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_linkagedist">linkageDist</code></td>
<td>

<p>A number, in basepairs, indicating the maximum distance for linked loci.
Ignored if <code>useLinkage = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_minlinkagecorr">minLinkageCorr</code></td>
<td>

<p>A number ranging from zero to one.  Indicates the minimum correlation 
coeffienct between weighted mean genotypes at two alleles in order for linkage
data to be used for updating genotype priors. Ignored if 
<code>useLinkage = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="PipelineMapping2Parents_+3A_overdispersion">overdispersion</code></td>
<td>

<p>Overdispersion parameter; see <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="#topic+IterateHWE">IterateHWE</a></code> and <code><a href="#topic+IteratePopStruct">IteratePopStruct</a></code>,
<code>PipelineMapping2Parents</code> only runs through each function once,
rather than iteratively until convergence.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object identical to that passed to the function, with
the following slots added: <code>$alleleFreq</code>, <code>depthSamplingPermutations</code>,
<code>$genotypeLikelihood</code>,
<code>likelyGeno_donor</code>, <code>likelyGeno_recurrent</code>, <code>$priorProb</code>,
<code>$ploidyChiSq</code>, <code>$posteriorProb</code>, and if <code>useLinkage = TRUE</code>,
<code>$alleleLinkages</code> and <code>$priorProbLD</code>.  See the documentation
for the functions listed in the description for more details on the
data contained in these slots.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SetDonorParent">SetDonorParent</a></code> and <code>SetRecurrentParent</code> to indicate which
individuals are the parents before running the function.
</p>
<p><code><a href="#topic+AddGenotypePriorProb_Mapping2Parents">AddGenotypePriorProb_Mapping2Parents</a></code> for how ploidy of parents and
progeny is interpreted.
</p>
<p><code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> or <code><a href="#topic+Export_polymapR">Export_polymapR</a></code> for
exporting genotypes from the resulting object.
</p>
<p><code><a href="#topic+StripDown">StripDown</a></code> to remove memory-hogging slots that are no longer
needed after the pipeline has been run.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data for the example
data(exampleRAD_mapping)

# specify donor and recurrent parents
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")

# run the pipeline
exampleRAD_mapping &lt;- PipelineMapping2Parents(exampleRAD_mapping,
                                 n.gen.backcrossing = 1)
                                 
# export results
wmgeno &lt;- GetWeightedMeanGenotypes(exampleRAD_mapping)[-(1:2),]
wmgeno
</code></pre>

<hr>
<h2 id='RADdata'>
RADdata object constructor
</h2><span id='topic+RADdata'></span><span id='topic+plot.RADdata'></span>

<h3>Description</h3>

<p><code>RADdata</code> is used internally to generate objects of the S3 class 
&ldquo;RADdata&rdquo; by <span class="pkg">polyRAD</span> functions for importing read depth data.
It is also available at the user level for cases where the data for import are
not already in a format supported by <span class="pkg">polyRAD</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RADdata(alleleDepth, alleles2loc, locTable, possiblePloidies, contamRate,
        alleleNucleotides, taxaPloidy)
        
## S3 method for class 'RADdata'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RADdata_+3A_alleledepth">alleleDepth</code></td>
<td>

<p>An integer matrix, with taxa in rows and alleles in columns.  Taxa names should
be included as row names.  Each value indicates the number of reads for a given
allele in a given taxon.  There should be no <code>NA</code> values; use zero to 
indicate no reads.
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_alleles2loc">alleles2loc</code></td>
<td>

<p>An integer vector with one value for each column of <code>alleleDepth</code>.  The 
number indicates the identity of the locus to which the allele belongs.  A 
locus can have any number of alleles assigned to it (including zero).
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_loctable">locTable</code></td>
<td>

<p>A data frame, where locus names are row names.  There must be at least as 
many rows as the highest value of <code>alleles2loc</code>; each number in 
<code>alleles2loc</code> corresponds to a row index in <code>locTable</code>.  No columns
are required, although if provided a column named &ldquo;Chr&rdquo; will be used for
indicating chromosome identities, a column named &ldquo;Pos&rdquo; will be used
for indicating physical position, and a column named &ldquo;Ref&rdquo; will be used
to indicate the reference sequence.
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list, where each item in the list is an integer vector (or a numeric vector
that can be converted to integer).  Each vector indicates an inheritance 
pattern that markers in the dataset might obey.  <code>2</code> indicates diploid,
<code>4</code> indicates autotetraploid, <code>c(2, 2)</code> indicates allotetraploid,
<em>etc.</em>
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_contamrate">contamRate</code></td>
<td>

<p>A number ranging from zero to one (although in practice probably less than 
0.01) indicating the expected sample cross-contamination rate.
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_allelenucleotides">alleleNucleotides</code></td>
<td>

<p>A character vector with one value for each column of 
<code>alleleDepth</code>, indicating the DNA sequence for that allele.  Typically 
only the sequence at variable sites is provided, although intervening 
non-variable sequence can also be provided.
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>An integer vector indicating ploidies of taxa.  If a single value is provided,
it will be assumed that all taxa are the same ploidy.  Otherwise, one value
must be provided for each taxon.  If unnamed, it is assumed that taxa are in
the same order as the rows of <code>alleleDepth</code>.  If named, names must match
the row names of <code>alleleDepth</code> but do not need to be in the same order.
This value is used as a multiplier with <code>possiblePloidies</code>; see Details.
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_x">x</code></td>
<td>

<p>A &ldquo;RADdata&rdquo; object.
</p>
</td></tr>
<tr><td><code id="RADdata_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to <code>plot</code>, for example <code>col</code> or 
<code>pch</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a single locus, ideally the string provided in <code>locTable$Ref</code> and all
strings in <code>alleleNucleotides</code> are the same length, so that SNPs and indels
may be matched by position.  The character &ldquo;-&rdquo; indicates a deletion with
respect to the reference, and can be used within <code>alleleNucleotides</code>.  The
character &ldquo;.&rdquo; is a placeholder where other alleles have an insertion with
respect to the reference, and may be used in <code>locTable$Ref</code> and
<code>alleleNucleotides</code>.  Note that it is possible for the sequence in
<code>locTable$Ref</code> to be absent from <code>alleleNucleotides</code> if the reference
haplotype is absent from the dataset, as may occur if the reference genome is that
of a related species and not the actual study species.  For the
<code>alleleNucleotides</code> vector, the attribute <code>"Variable_sites_only"</code>
indicates whether non-variable sequence in between variants is included; this
needs to be <code>FALSE</code> for other functions to determine the position of each
variant within the set of tags.
</p>
<p>Inheritance mode is determined by multiplying the values in
<code>possiblePloidies</code> by the values in <code>taxaPloidy</code> and dividing by two.
For example, if you wanted to assume autotetraploid inheritance across the
entire dataset, you could set <code>possiblePloidies = list(4)</code> and
<code>taxaPloidy = 2</code>, or alternatively <code>possiblePloidies = list(2)</code> and
<code>taxaPloidy = 4</code>.  To indicate a mix of diploid and allotetraploid
inheritance across loci, set <code>possiblePloidies = list(2, c(2, 2))</code> and
<code>taxaPloidy = 2</code>.  If taxa themselves vary in ploidy, provide one
value of <code>taxaPloidy</code> for each taxon.  All inheritance modes listed in
<code>possiblePloidies</code> apply equally to all taxa, even when ploidy varies
by taxon.
</p>


<h3>Value</h3>

<p>An object of the S3 class &ldquo;RADdata&rdquo;.  The following slots are available
using the <code>$</code> operator:
</p>
<table>
<tr><td><code>alleleDepth</code></td>
<td>
<p>Identical to the argument provided to the function.</p>
</td></tr>
<tr><td><code>alleles2loc</code></td>
<td>
<p>Identical to the argument provided to the function.</p>
</td></tr>
<tr><td><code>locTable</code></td>
<td>
<p>Identical to the argument provided to the function.</p>
</td></tr>
<tr><td><code>possiblePloidies</code></td>
<td>
<p>The <code>possiblePloidies</code> argument, converted to
integer.</p>
</td></tr>
<tr><td><code>locDepth</code></td>
<td>
<p>A matrix with taxa in rows and loci in columns, with read 
depth summed across all alleles for each locus.  Column names are locus 
numbers rather than locus names.  See <code><a href="#topic+GetLocDepth">GetLocDepth</a></code> for retrieving
the same matrix but with locus names as column names.</p>
</td></tr>
<tr><td><code>depthSamplingPermutations</code></td>
<td>
<p>A numeric matrix with taxa in rows and 
alleles in columns.  It is calculated as <code class="reqn">log(locDepth choose alleleDepth)</code>.
This is used as a coefficient for likelihood estimations done by other
<span class="pkg">polyRAD</span> functions (<em>i.e.</em> <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>).</p>
</td></tr>
<tr><td><code>depthRatio</code></td>
<td>
<p>A numeric matrix with taxa in rows and alleles in columns.
Calculated as <code class="reqn">alleleDepth / locDepth</code>.  Used by other <span class="pkg">polyRAD</span>
functions for rough estimation of genotypes and allele frequency.</p>
</td></tr>
<tr><td><code>antiAlleleDepth</code></td>
<td>
<p>An integer matrix with taxa in rows and alleles in
columns.  For each allele, the number of reads from the locus that do NOT
belong to that allele.  Calculated as <code class="reqn">locDepth - alleleDepth</code>. Used for
likelihood estimations by other <span class="pkg">polyRAD</span> functions.</p>
</td></tr>
<tr><td><code>alleleNucleotides</code></td>
<td>
<p>Identical to the argument provided to the 
function.</p>
</td></tr>
<tr><td><code>taxaPloidy</code></td>
<td>
<p>A named integer vector with one value per taxon, indicating
the ploidy of taxa.</p>
</td></tr>
</table>
<p>The object additionally has several attributes (see <code><a href="base.html#topic+attr">attr</a></code>):
</p>
<table>
<tr><td><code>taxa</code></td>
<td>
<p>A character vector listing all taxa names, in the same order as
the rows of <code>alleleDepth</code>.</p>
</td></tr>
<tr><td><code>nTaxa</code></td>
<td>
<p>An integer indicating the number of taxa.</p>
</td></tr>
<tr><td><code>nLoc</code></td>
<td>
<p>An integer indicating the number of loci in <code>locTable</code>.</p>
</td></tr>
<tr><td><code>contamRate</code></td>
<td>
<p>Identical to the argument provided to the function.</p>
</td></tr>
</table>
<p>The <code>plot</code> method performs a principal components analysis with 
<code><a href="#topic+AddPCA">AddPCA</a></code> if not already done, then plots the first two axes.
Points represent individuals (taxa).  If mapping population parents have been
noted in the object (see <code><a href="#topic+SetDonorParent">SetDonorParent</a></code>), they are indicated in
the plot.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p>Data import functions that internally call <code>RADdata</code>:
</p>
<p><code><a href="#topic+readHMC">readHMC</a></code>, <code><a href="#topic+readTagDigger">readTagDigger</a></code>, 
<code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>, <code><a href="#topic+readStacks">readStacks</a></code>,
<code><a href="#topic+readTASSELGBSv2">readTASSELGBSv2</a></code>, <code><a href="#topic+readProcessSamMulti">readProcessSamMulti</a></code>,
<code><a href="#topic+readProcessIsoloci">readProcessIsoloci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the dataset
mydepth &lt;- matrix(sample(100, 16), nrow = 4, ncol = 4,
                  dimnames = list(paste("taxon", 1:4, sep = ""),
                  paste("loc", c(1,1,2,2), "_", c(0,1,0,1), sep = "")))
mydata &lt;- RADdata(mydepth, c(1L,1L,2L,2L), 
                  data.frame(row.names = c("loc1", "loc2"), Chr = c(1,1),
                             Pos = c(2000456, 5479880)),
                  list(2, c(2,2)), 0.001, c("A", "G", "G", "T"), 6)

# inspect the dataset
mydata
mydata$alleleDepth
mydata$locDepth
mydata$depthRatio
mydata$taxaPloidy

# the S3 class structure is flexible; other data can be added
mydata$GPS &lt;- data.frame(row.names = attr(mydata, "taxa"),
                         Lat = c(43.12, 43.40, 43.05, 43.27),
                         Long = -c(70.85, 70.77, 70.91, 70.95))
mydata$GPS

# If you have NA in your alleleDepth matrix to indicate zero reads,
# perform the following before running the RADdata constructor:
mydepth[is.na(mydepth)] &lt;- 0L

# plotting a RADdata object
plot(mydata)
</code></pre>

<hr>
<h2 id='RADdata2VCF'>
Export RADdata Genotypes to VCF
</h2><span id='topic+RADdata2VCF'></span>

<h3>Description</h3>

<p>Converts genotype calls from <span class="pkg">polyRAD</span> into VCF format. The user may send
the results directly to a file, or to a
<code><a href="VariantAnnotation.html#topic+VCF-class">CollapsedVCF</a></code> for further manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RADdata2VCF(object, file = NULL, asSNPs = TRUE, hindhe = TRUE,
            sampleinfo = data.frame(row.names = GetTaxa(object)),
            contigs = data.frame(row.names = unique(object$locTable$Chr)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RADdata2VCF_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object in which genotype calling has been performed.
It is also important for the data to have been imported in a way that preserves
variant positions (i.e. <code><a href="#topic+readProcessIsoloci">readProcessIsoloci</a></code>,
<code><a href="#topic+readTASSELGBSv2">readTASSELGBSv2</a></code>,
<code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code> using the <code>refgenome</code> argument).
</p>
</td></tr>
<tr><td><code id="RADdata2VCF_+3A_file">file</code></td>
<td>

<p>An optional character string or connection indicating where to write the file.
Append mode may be used with connections if multiple RADdata objects need to be
written to one VCF.
</p>
</td></tr>
<tr><td><code id="RADdata2VCF_+3A_assnps">asSNPs</code></td>
<td>

<p>Boolean indicating whether to convert haplotypes to individual SNPs and indels.
</p>
</td></tr>
<tr><td><code id="RADdata2VCF_+3A_hindhe">hindhe</code></td>
<td>

<p>Boolean indicating whether to export a mean value of Hind/He
(see <code><a href="#topic+HindHe">HindHe</a></code>) for every sample and locus.
</p>
</td></tr>
<tr><td><code id="RADdata2VCF_+3A_sampleinfo">sampleinfo</code></td>
<td>

<p>A data frame with optional columns indicating any sample metadata to export
to &quot;SAMPLE&quot; header lines.
</p>
</td></tr>
<tr><td><code id="RADdata2VCF_+3A_contigs">contigs</code></td>
<td>

<p>A data frame with optional columns providing information about contigs to
export to &quot;contig&quot; header lines.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the FORMAT fields exported are GT (genotype), AD (allelic read depth),
and DP (read depth).  Genotype posterior probabilities are not exported due to
the mathematical intractability of converting pseudo-biallelic probabilities to
multiallelic probabilities.
</p>
<p>Genotypes exported to the GT field are obtained internally using
<code><a href="#topic+GetProbableGenotypes">GetProbableGenotypes</a></code>.
</p>
<p>INFO fields exported include the standard fields NS (number of samples with more
than zero reads) and DP (total depth across samples) as well as the custom fields
LU (index of the marker in the original RADdata object) and HH (Hind/He statistic
for the marker).
</p>
<p>This function requires the BioConductor package <span class="pkg">VariantAnnotation</span>.
See <a href="https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html">https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html</a>
for installation instructions.
</p>


<h3>Value</h3>

<p>A <code><a href="VariantAnnotation.html#topic+VCF-class">CollapsedVCF</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://samtools.github.io/hts-specs/VCFv4.3.pdf">https://samtools.github.io/hts-specs/VCFv4.3.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>, <code><a href="#topic+ExportGAPIT">ExportGAPIT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up example dataset for export.
# You DO NOT need to adjust attr or locTable in your own dataset.
data(exampleRAD)
attr(exampleRAD$alleleNucleotides, "Variable_sites_only") &lt;- FALSE
exampleRAD$locTable$Ref &lt;- 
  exampleRAD$alleleNucleotides[match(1:nLoci(exampleRAD), exampleRAD$alleles2loc)]
exampleRAD &lt;- IterateHWE(exampleRAD)

# An optional table of sample data
sampleinfo &lt;- data.frame(row.names = GetTaxa(exampleRAD),
                         Population = rep(c("North", "South"), each = 50))

# Add contig information (fill in with actual data rather than random)
mycontigs &lt;- data.frame(row.names = c("1", "4", "6", "9"), length = sample(1e8, 4),
                        URL = rep("ftp://mygenome.com/mygenome.fa", 4))

# Set up a file destination for this example
# (It is not necessary to use tempfile with your own data)
outfile &lt;- tempfile(fileext = ".vcf")


# Export VCF
testvcf &lt;- RADdata2VCF(exampleRAD, file = outfile, sampleinfo = sampleinfo,
                       contigs = mycontigs)

</code></pre>

<hr>
<h2 id='readDArTag'>
Import Data from DArT Sequencing
</h2><span id='topic+readDArTag'></span>

<h3>Description</h3>

<p><a href="https://www.diversityarrays.com/">Diversity Array Technologies (DArT)</a>
provides a tag-based genotyping-by-sequencing service. Together with
<a href="https://breedinginsight.org/">Breeding Insight</a>, a format was
developed indicting haplotype sequence and read depth, and that format is
imported by this function to make a <code><a href="#topic+RADdata">RADdata</a></code> object. The target
SNP and all off-target SNPs within the amplicon are imported as haplotypes.
Because the file format does not indicate strandedness of the tag, BLAST
results are used so that sequence and position are accurately stored in the
<code>RADdata</code> object.  See the &ldquo;extdata&rdquo; folder of the <span class="pkg">polyRAD</span>
installation for example files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDArTag(file, botloci = NULL, blastfile = NULL, excludeHaps = NULL,
           includeHaps = NULL, n.header.rows = 0, sample.name.row = 1,
           trim.sample.names = "_[^_]+_[ABCDEFGH][[:digit:]][012]?$",
           sep.counts = ",", sep.blast = "\t", possiblePloidies = list(2),
           taxaPloidy = 2L, contamRate = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDArTag_+3A_file">file</code></td>
<td>

<p>The file name of a spreadsheet from DArT indicating haplotype sequence and read
depth.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_botloci">botloci</code></td>
<td>

<p>A character vector indicating the names of loci for which the sequence is on the
bottom strand with respect to the reference genome.  All other loci are assumed
to be on the top strand.  Only one of <code>blastfile</code> and <code>botloci</code> should
be provided.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_blastfile">blastfile</code></td>
<td>

<p>File name for BLAST results for haplotypes. The file should be in tabular format
with <code>qseqid</code>, <code>sseqid</code>, <code>sstart</code>, <code>send</code>, and <code>pident</code>
columns, indicated with column headers.  Only one of <code>blastfile</code> and
<code>botloci</code> should be provided.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_excludehaps">excludeHaps</code></td>
<td>

<p>Optional.  Character vector with names of haplotypes (from the &ldquo;AlleleID&rdquo;
column) that should not be imported.  Should not be used if <code>includeHaps</code>
is provided.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_includehaps">includeHaps</code></td>
<td>

<p>Optional.  Character vector with names of haplotypes (from the &ldquo;AlleleID&rdquo;
column) that should be imported.  Should not be used if <code>excludeHaps</code> is
provided.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_n.header.rows">n.header.rows</code></td>
<td>

<p>Integer.  The number of header rows in <code>file</code>, not including the full row
of column headers.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_sample.name.row">sample.name.row</code></td>
<td>

<p>Integer.  The row within <code>file</code> from which sample names should be derived.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_trim.sample.names">trim.sample.names</code></td>
<td>

<p>A regular expression indicating text to trim off of sample names.  Use <code>""</code>
if no trimming should be performed.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_sep.counts">sep.counts</code></td>
<td>

<p>The field separator character for <code>file</code>.  The default assumes CSV.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_sep.blast">sep.blast</code></td>
<td>

<p>The field separator character for the BLAST results.  The default assumes
tab-delimited.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list indicating possible inheritance modes.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readDArTag_+3A_contamrate">contamRate</code></td>
<td>

<p>Expected sample cross-contamination rate. See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;CloneID&rdquo; column is used for locus names, and is assumed to contain
the chromosome (or scaffold) name and position, separated by an underscore.
The position is assumed to refer to the target SNP, which is identified by
comparing the &ldquo;Ref_001&rdquo; and &ldquo;Alt_002&rdquo; sequences.  The position
is then converted to refer to the beginning of the tag (which may have been
reverse complemented depending on BLAST results), since additional SNPs may
be present.  This facilitates accurate export to VCF using
<code><a href="#topic+RADdata2VCF">RADdata2VCF</a></code>.
</p>
<p>Column names for the BLAST file can be &ldquo;Query&rdquo;, &ldquo;Subject&rdquo;,
&ldquo;S_start&rdquo;, &ldquo;S_end&rdquo;, and &ldquo;%Identity&rdquo;, for compatibility
with Breeding Insight formats.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object ready for QC and genotype calling. Assuming
the &ldquo;Ref_001&rdquo; and &ldquo;Alt_002&rdquo; alleles were not excluded, the
<code>locTable</code> slot will include columns for chromosome, position, strand, and
reference sequence.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://www.diversityarrays.com/">https://www.diversityarrays.com/</a>
</p>
<p><a href="https://breedinginsight.org/">https://breedinginsight.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reverseComplement">reverseComplement</a></code>
</p>
<p><code><a href="#topic+readTagDigger">readTagDigger</a></code>, <code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>, 
<code><a href="#topic+readStacks">readStacks</a></code>, <code><a href="#topic+readTASSELGBSv2">readTASSELGBSv2</a></code>,
<code><a href="#topic+readHMC">readHMC</a></code>
</p>
<p><code><a href="#topic+RADdata2VCF">RADdata2VCF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Older Excellence in Breeding version
# Example files installed with polyRAD
dartfile &lt;- system.file("extdata", "DArTag_example.csv", package = "polyRAD")
blastfile &lt;- system.file("extdata", "DArTag_BLAST_example.txt",
                         package = "polyRAD")

# One haplotype doesn't seem to have correct alignment (see BLAST results)
exclude_hap &lt;- c("Chr1_30668472|RefMatch_004")

# Import data
mydata &lt;- readDArTag(dartfile, blastfile = blastfile,
                      excludeHaps = exclude_hap,
                      possiblePloidies = list(4),
                      n.header.rows = 7, sample.name.row = 7)
                      
## Newer Excellence in Breeding version (2022)
# Example files installed with polyRAD
dartfile &lt;- system.file("extdata", "DArTag_example2.csv", package = "polyRAD")
blastfile &lt;- system.file("extdata", "DArTag_BLAST_example2.txt",
                         package = "polyRAD")

# One haplotype doesn't seem to have correct alignment (see BLAST results)
exclude_hap &lt;- c("Chr1_30668472|RefMatch_0004")

# Import data
mydata &lt;- readDArTag(dartfile, blastfile = blastfile,
                      excludeHaps = exclude_hap,
                      possiblePloidies = list(4),
                      n.header.rows = 0, sample.name.row = 1)
</code></pre>

<hr>
<h2 id='readHMC'>
Import read depth from UNEAK
</h2><span id='topic+readHMC'></span>

<h3>Description</h3>

<p>This function reads the &ldquo;HapMap.hmc.txt&rdquo; and &ldquo;HapMap.fas.txt&rdquo;
files output by the UNEAK pipeline and uses the data to generate a 
&ldquo;RADdata&rdquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readHMC(file, includeLoci = NULL, shortIndNames = TRUE, 
        possiblePloidies = list(2), taxaPloidy = 2L, contamRate = 0.001,
        fastafile = sub("hmc.txt", "fas.txt", file, fixed = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readHMC_+3A_file">file</code></td>
<td>

<p>Name of the file containing read depth (typically &ldquo;HapMap.hmc.txt&rdquo;).
</p>
</td></tr>
<tr><td><code id="readHMC_+3A_includeloci">includeLoci</code></td>
<td>

<p>An optional character vector of loci to be included in the output.
</p>
</td></tr>
<tr><td><code id="readHMC_+3A_shortindnames">shortIndNames</code></td>
<td>

<p>Boolean.  If TRUE, taxa names will be shortened with respect to those in the
file, eliminating all text after and including the first underscore.
</p>
</td></tr>
<tr><td><code id="readHMC_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list of numeric vectors indicating potential inheritance modes of SNPs in the
dataset.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readHMC_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readHMC_+3A_contamrate">contamRate</code></td>
<td>

<p>A number ranging from zero to one (typically small) indicating the expected 
rate of sample cross-contamination.
</p>
</td></tr>
<tr><td><code id="readHMC_+3A_fastafile">fastafile</code></td>
<td>

<p>Name of the file containing tag sequences (typically &ldquo;HapMap.fas.txt&rdquo;).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object containing read depth, taxa and locus names, and
nucleotides at variable sites.
</p>


<h3>Note</h3>

<p>UNEAK is not able to report read depths greater than 127, which may be 
problematic for high depth data on polyploid organisms.  The UNEAK
pipeline is no longer being updated and is currently only available with
archived versions of TASSEL.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Lu, F., Lipka, A. E., Glaubitz, J., Elshire, R., Cherney, J. H., Casler, M. D.,
Buckler, E. S. and Costich, D. E. (2013) Switchgrass genomic diversity, ploidy, 
and evolution: novel insights from a network-based SNP discovery protocol.  
<em>PLoS Genetics</em> <b>9</b>, e1003215.
</p>
<p><a href="https://www.maizegenetics.net/tassel">https://www.maizegenetics.net/tassel</a>
</p>
<p><a href="https://tassel.bitbucket.io/TasselArchived.html">https://tassel.bitbucket.io/TasselArchived.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readTagDigger">readTagDigger</a></code>, <code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>, 
<code><a href="#topic+readStacks">readStacks</a></code>, <code><a href="#topic+readTASSELGBSv2">readTASSELGBSv2</a></code>,
<code><a href="#topic+readDArTag">readDArTag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for this example we'll create dummy files rather than using real ones
hmc &lt;- tempfile()
write.table(data.frame(rs = c("TP1", "TP2", "TP3"),
                       ind1_merged_X3 = c("15|0", "4|6", "13|0"),
                       ind2_merged_X3 = c("0|0", "0|1", "0|5"),
                       HetCount_allele1 = c(0, 1, 0),
                       HetCount_allele2 = c(0, 1, 0),
                       Count_allele1 = c(15, 4, 13),
                       Count_allele2 = c(0, 7, 5),
                       Frequency = c(0, 0.75, 0.5)), row.names = FALSE,
            quote = FALSE, col.names = TRUE, sep = "\t", file = hmc)
fas &lt;- tempfile()
writeLines(c("&gt;TP1_query_64",
             "TGCAGAAAAAAAACGCTCGATGCCCCCTAATCCGTTTTCCCCATTCCGCTCGCCCCATCGGAGT",
             "&gt;TP1_hit_64",
             "TGCAGAAAAAAAACGCTCGATGCCCCCTAATCCGTTTTCCCCATTCCGCTCGCCCCATTGGAGT",
             "&gt;TP2_query_64",
             "TGCAGAAAAACAACACCCTAGGTAACAACCATATCTTATATTGCCGAATAAAAAACAACACCCC",
             "&gt;TP2_hit_64",
             "TGCAGAAAAACAACACCCTAGGTAACAACCATATCTTATATTGCCGAATAAAAAATAACACCCC",
             "&gt;TP3_query_64",
             "TGCAGAAAACATGGAGAGGGAGATGGCACGGCAGCACCACCGCTGGTCCGCTGCCCGTTTGCGG",
             "&gt;TP3_hit_64",
             "TGCAGAAAACATGGAGATGGAGATGGCACGGCAGCACCACCGCTGGTCCGCTGCCCGTTTGCGG"),
             fas)

# now read the data
mydata &lt;- readHMC(hmc, fastafile = fas)

# inspect the results
mydata
mydata$alleleDepth
mydata$alleleNucleotides
row.names(mydata$locTable)
</code></pre>

<hr>
<h2 id='readProcessIsoloci'>
Import Read Depth from Output of process_isoloci.py
</h2><span id='topic+readProcessIsoloci'></span>

<h3>Description</h3>

<p>After process_isoloci.py is used to assign RAD tags to alignment locations
within a highly duplicated genome, <code>readProcessIsoloci</code> imports the
resulting CSV to a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProcessIsoloci(sortedfile, min.ind.with.reads = 200,
                   min.ind.with.minor.allele = 10,
                   min.median.read.depth = 10,
                   possiblePloidies = list(2), taxaPloidy = 2L,
                   contamRate = 0.001,
                   nameFromTagStart = TRUE, mergeRareHap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProcessIsoloci_+3A_sortedfile">sortedfile</code></td>
<td>

<p>File path to a CSV output by process_isoloci.py.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_min.ind.with.reads">min.ind.with.reads</code></td>
<td>

<p>Minimum number of individuals with reads needed to retain a locus.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_min.ind.with.minor.allele">min.ind.with.minor.allele</code></td>
<td>

<p>Minimum number of individuals with reads in a minor allele needed to retain
a locus.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_min.median.read.depth">min.median.read.depth</code></td>
<td>

<p>Minimum median read depth across individuals (including individuals with depth 0)
needed to retain a locus.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list indicating possible inheritance modes of loci.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_contamrate">contamRate</code></td>
<td>

<p>Approximate rate of cross-contamination among samples.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_namefromtagstart">nameFromTagStart</code></td>
<td>

<p>If <code>TRUE</code> loci will be named based on the alignment position and strand
of the RAD tag itself.  If <code>FALSE</code>, loci will be named based on the leftmost
position of the variable region of the RAD tag.  In either case,
<code>locTable$Pos</code> within the output will indicate the position of the variable
region of the tag.
</p>
</td></tr>
<tr><td><code id="readProcessIsoloci_+3A_mergerarehap">mergeRareHap</code></td>
<td>

<p>Boolean indicating whether to run <code><a href="#topic+MergeRareHaplotypes">MergeRareHaplotypes</a></code> after
building the <code>"RADdata"</code> object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+MergeIdenticalHaplotypes">MergeIdenticalHaplotypes</a></code> is used internally by this function to
merge alleles with identical sequence for the region shared by all tags, in
cases where tags vary in length within a locus.
</p>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object containing read depth and alignment positions
from <code>sortedfile</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readProcessSamMulti">readProcessSamMulti</a></code>
</p>

<hr>
<h2 id='readProcessSamMulti'>
Import Preliminary Data to Determine Parameters for Isolocus Sorting
</h2><span id='topic+readProcessSamMulti'></span>

<h3>Description</h3>

<p>This function imports the files output by <code>process_sam_multi.py</code> to a
<code>"<a href="#topic+RADdata">RADdata</a>"</code> object so that <code><a href="#topic+HindHe">HindHe</a></code> can be run to
filter samples and determine optimal parameters for <code>process_isoloci.py</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProcessSamMulti(alignfile,
                    depthfile = sub("align", "depth", alignfile),
                    expectedLoci = 1000,
                    min.ind.with.reads = 200,
                    min.ind.with.minor.allele = 10,
                    possiblePloidies = list(2), taxaPloidy = 2L,
                    contamRate = 0.001,
                    expectedAlleles = expectedLoci * 15,
                    maxLoci = expectedLoci)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProcessSamMulti_+3A_alignfile">alignfile</code></td>
<td>

<p>A file output by <code>process_sam_multi.py</code>, generally in the format
<code>prefix_1_align.csv</code>.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_depthfile">depthfile</code></td>
<td>

<p>A file output by <code>process_sam_multi.py</code>, generally in the format
<code>prefix_1_depth.csv</code>.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_expectedloci">expectedLoci</code></td>
<td>

<p>The number of loci expected in the final object. The default, 1000, is fairly
small because this function is intended to be used for preliminary analysis only.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_min.ind.with.reads">min.ind.with.reads</code></td>
<td>

<p>The minimum number of taxa with reads needed in order for a locus to be retained
in the output.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_min.ind.with.minor.allele">min.ind.with.minor.allele</code></td>
<td>

<p>The minimum number of taxa with the same minor allele needed in order for a
locus to be retained in the output.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list indicating expected inheritance modes for markers.  See
<code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_contamrate">contamRate</code></td>
<td>

<p>A number ranging from zero to one (although in practice probably less than 0.01)
indicating the expected sample cross-contamination rate.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_expectedalleles">expectedAlleles</code></td>
<td>

<p>The expected number of alleles in the dataset.
</p>
</td></tr>
<tr><td><code id="readProcessSamMulti_+3A_maxloci">maxLoci</code></td>
<td>

<p>The maximum number of loci to import before ceasing to read the file.  Set to
<code>Inf</code> if you want to read the entire file.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"RADdata"</code> object.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readProcessIsoloci">readProcessIsoloci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myRAD &lt;- readProcessSamMulti("mydata_2_align.csv")

## End(Not run)
</code></pre>

<hr>
<h2 id='readStacks'>
Import Read Depth from Stacks
</h2><span id='topic+readStacks'></span>

<h3>Description</h3>

<p>Using the catalog files output by cstacks and matches file output by sstacks,
this function imports read depth into a <code><a href="#topic+RADdata">RADdata</a></code> object.  If
genomic alignments were used, alignment data can optionally be imported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readStacks(allelesFile, matchesFolder, version = 2,
           min.ind.with.reads = 200,
           min.ind.with.minor.allele = 10, readAlignmentData = FALSE, 
           sumstatsFile = "populations.sumstats.tsv",
           possiblePloidies = list(2), taxaPloidy = 2L, contamRate = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readStacks_+3A_allelesfile">allelesFile</code></td>
<td>

<p>Path to the &quot;alleles&quot; file from the Stacks catalog.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_matchesfolder">matchesFolder</code></td>
<td>

<p>Path to the folder containing &quot;matches&quot; files to import.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_version">version</code></td>
<td>

<p>Either the number 1 or 2, indicating the version of Stacks.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_min.ind.with.reads">min.ind.with.reads</code></td>
<td>

<p>For filtering loci.  A locus must have at least this many samples with
reads in order to be retained.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_min.ind.with.minor.allele">min.ind.with.minor.allele</code></td>
<td>

<p>For filtering loci.  A locus must have at least this many samples with
reads for the minor allele in order to be retained.  For loci with more
than two alleles, at least two alleles must be present in at least this
many individuals.  This argument is also passed internally to the 
<code>min.ind.with.haplotype</code> argument of <code><a href="#topic+MergeRareHaplotypes">MergeRareHaplotypes</a></code>
to consolidate reads from rare alleles.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_readalignmentdata">readAlignmentData</code></td>
<td>

<p>If <code>TRUE</code> and <code>version = 1</code>, the &quot;tags&quot; file from the Stacks catalog will be read,
and chromosome, position, and strand will be imported to the <code>locTable</code>
slot of the output.  It is assumed that the &quot;tags&quot; file is in the same
directory as the &quot;alleles&quot; file.  If <code>TRUE</code> and <code>version = 2</code>,
<code>sumstatsFile</code> will be used for import of chromosome and position data.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_sumstatsfile">sumstatsFile</code></td>
<td>

<p>The name of the file containing summary statistics for loci.  Ignored
unless <code>version = 2</code> and <code>readAlignmentData = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list indicating possible inheritance modes in the dataset.
See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readStacks_+3A_contamrate">contamRate</code></td>
<td>

<p>A number from 0 to 1 (generally very small) indicating the expected rate of
cross contamination between samples.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object.
</p>


<h3>Note</h3>

<p>This function has been tested with output from Stacks 1.47.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Stacks website: <a href="http://catchenlab.life.illinois.edu/stacks/">http://catchenlab.life.illinois.edu/stacks/</a>
</p>
<p>Rochette, N. and Catchen, J. (2017) Deriving genotypes from RAD-seq short-read data 
using Stacks. <em>Nature Protocols</em> <b>12</b>, 2640&ndash;2659.
</p>
<p>Catchen, J., Hohenlohe, P. A., Bassham, S., Amores, A., and Cresko., W. A. (2013) 
Stacks: an analysis tool set for population genomics. <em>Molecular Ecology</em>
<b>22</b>, 3124&ndash;3140.
</p>
<p>Catchen, J. M., Amores, A., Hohenlohe, P., Cresko, W., and Postlethwait, J. H. (2011)
Stacks: building and genotyping loci de novo from short-read sequences. 
<em>G3: Genes, Genomes, Genetics</em> <b>1</b>, 171&ndash;182.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>, <code><a href="#topic+readTagDigger">readTagDigger</a></code>,
<code><a href="#topic+readHMC">readHMC</a></code>, <code><a href="#topic+readTASSELGBSv2">readTASSELGBSv2</a></code>,
<code><a href="#topic+readDArTag">readDArTag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Assuming the working directory contains the catalog and all matches files:

myStacks &lt;- readStacks("batch_1.catalog.alleles.tsv", ".", 
                       version = 1,
                       readAlignmentData = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='readTagDigger'>
Import Read Counts from TagDigger
</h2><span id='topic+readTagDigger'></span>

<h3>Description</h3>

<p><code>readTagDigger</code> reads the CSV output containing read counts
from TagDigger and generates a <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
Optionally, it can also import a tag database generated by the
Tag Manager program within TagDigger, containing information 
such as alignment position, to be stored in the <code>$locTable</code>
slot of the <code>"RADdata"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readTagDigger(countfile, includeLoci = NULL, 
              possiblePloidies = list(2), taxaPloidy = 2L,
              contamRate = 0.001,
              dbfile = NULL, dbColumnsToKeep = NULL, 
              dbChrCol = "Chr", dbPosCol = "Pos", 
              dbNameCol = "Marker name")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readTagDigger_+3A_countfile">countfile</code></td>
<td>

<p>Name of the file containing read counts.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_includeloci">includeLoci</code></td>
<td>

<p>An optional character vector containing names of loci to retain in
the output.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list of numeric vectors indicating potential inheritance modes of SNPs in the
dataset.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_contamrate">contamRate</code></td>
<td>

<p>A number ranging from zero to one (typically small) indicating the expected 
rate of sample cross-contamination.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_dbfile">dbfile</code></td>
<td>

<p>Optionally, name of the Tag Manager database file.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_dbcolumnstokeep">dbColumnsToKeep</code></td>
<td>

<p>Optionally, a character vector indicating the names of columns to keep
from the database file.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_dbchrcol">dbChrCol</code></td>
<td>

<p>The name of the column containing the chromosome number in the database file.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_dbposcol">dbPosCol</code></td>
<td>

<p>The name of the column indicating alignment position in the database file.
</p>
</td></tr>
<tr><td><code id="readTagDigger_+3A_dbnamecol">dbNameCol</code></td>
<td>

<p>The name of the column containing marker names in the database file.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nucleotides associated with the alleles, to be stored in the 
<code>$alleleNucleotides</code> slot, are extracted from the allele names in the
read counts file.  It is assumed that the allele names first contain the
marker name, followed by an underscore, followed by the nucleotide(s) at
any variable positions.
</p>


<h3>Value</h3>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p><a href="https://github.com/lvclark/tagdigger">https://github.com/lvclark/tagdigger</a>
</p>
<p>Clark, L. V. and Sacks, E. J. (2016) TagDigger: User-friendly extraction 
of read counts from GBS and RAD-seq data.  <em>Source Code for Biology
and Medicine</em> <b>11</b>, 11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readHMC">readHMC</a></code>, <code><a href="#topic+readStacks">readStacks</a></code>, <code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>,
<code><a href="#topic+readTASSELGBSv2">readTASSELGBSv2</a></code>, <code><a href="#topic+readDArTag">readDArTag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for this example we'll create dummy files
countfile &lt;- tempfile()
write.csv(data.frame(row.names = c("Sample1", "Sample2", "Sample3"),
                     Mrkr1_A_0 = c(0, 20, 4),
                     Mrkr1_G_1 = c(7, 0, 12)),
          file = countfile, quote = FALSE)
dbfile &lt;- tempfile()
write.csv(data.frame(Marker.name = "Mrkr1", Chr = 5, Pos = 66739827),
          file = dbfile, row.names = FALSE, quote = FALSE)

# read the data
myrad &lt;- readTagDigger(countfile, dbfile = dbfile)
</code></pre>

<hr>
<h2 id='readTASSELGBSv2'>
Import Read Depth and Alignment from TASSEL GBS v2 
</h2><span id='topic+readTASSELGBSv2'></span>

<h3>Description</h3>

<p>This function reads TagTaxaDist and SAM files output by the TASSEL 5 GBS v2
pipeline, and generates a <code><a href="#topic+RADdata">RADdata</a></code> object suitable for downstream
processing for genotype estimation.  It elimintes the need to run the 
DiscoverySNPCallerPluginV2 or the ProductionSNPCallerPluginV2, since 
<span class="pkg">polyRAD</span> operates on haplotypes rather than SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readTASSELGBSv2(tagtaxadistFile, samFile, min.ind.with.reads = 200, 
                min.ind.with.minor.allele = 10, possiblePloidies = list(2),
                taxaPloidy = 2L, contamRate = 0.001, chromosomes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readTASSELGBSv2_+3A_tagtaxadistfile">tagtaxadistFile</code></td>
<td>

<p>File name or path to a tab-delimited text file of read depth generated by the
GetTagTaxaDistFromDBPlugin in TASSEL.
</p>
</td></tr>
<tr><td><code id="readTASSELGBSv2_+3A_samfile">samFile</code></td>
<td>

<p>File name or path to the corresponding SAM file containing alignment
information for the same set of tags.  This file is obtained by running the
TagExportToFastqPlugin in TASSEL, followed by alignment using Bowtie2 or BWA.
</p>
</td></tr>
<tr><td><code id="readTASSELGBSv2_+3A_min.ind.with.reads">min.ind.with.reads</code></td>
<td>

<p>Integer used for marker filtering.  The minimum number of individuals that must
have read depth above zero for a locus to be retained in the output.
</p>
</td></tr>
<tr><td><code id="readTASSELGBSv2_+3A_min.ind.with.minor.allele">min.ind.with.minor.allele</code></td>
<td>

<p>Integer used for marker filtering.  The minimum number of individuals
possessing reads for the minor allele for a locus to be retained in the output.
This value is also passed to the <code>min.ind.with.haplotype</code> argument of
<code><a href="#topic+MergeRareHaplotypes">MergeRareHaplotypes</a></code>.
</p>
</td></tr>
<tr><td><code id="readTASSELGBSv2_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list indicating inheritance modes that might be encountered in the 
dataset.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readTASSELGBSv2_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readTASSELGBSv2_+3A_contamrate">contamRate</code></td>
<td>

<p>A number indicating the expected sample cross-contamination rate.  See
<code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="readTASSELGBSv2_+3A_chromosomes">chromosomes</code></td>
<td>

<p>A character vector of chromosome names, indicating chromosomes to be retained
in the output.  If <code>NULL</code>, all chromosomes to be retained.  This argument
is intended to be used for reading data in a chromosome-wise fashion in order
to conserve computer memory.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RADdata</code> object containing read depth and alignment infomation from
the two input files.
</p>


<h3>Note</h3>

<p>Sequence tags must be identical in length to be assigned to the same locus by
this function.  This is to prevent errors with 
<code><a href="#topic+MergeRareHaplotypes">MergeRareHaplotypes</a></code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>TASSEL GBSv2 pipeline: <a href="https://bitbucket.org/tasseladmin/tassel-5-source/wiki/Tassel5GBSv2Pipeline">https://bitbucket.org/tasseladmin/tassel-5-source/wiki/Tassel5GBSv2Pipeline</a>
</p>
<p>Bowtie2: <a href="https://bowtie-bio.sourceforge.net/bowtie2/index.shtml">https://bowtie-bio.sourceforge.net/bowtie2/index.shtml</a>
</p>
<p>BWA: <a href="https://bio-bwa.sourceforge.net/">https://bio-bwa.sourceforge.net/</a>
</p>


<h3>See Also</h3>

<p>Other data import functions:  <code><a href="#topic+readStacks">readStacks</a></code>, <code><a href="#topic+readHMC">readHMC</a></code>,
<code><a href="#topic+readTagDigger">readTagDigger</a></code>, <code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>,
<code><a href="#topic+readDArTag">readDArTag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get files for this example
samfile &lt;- system.file("extdata", "exampleTASSEL_SAM.txt",
                       package = "polyRAD")
ttdfile &lt;- system.file("extdata", "example_TagTaxaDist.txt",
                       package = "polyRAD")

# import data
myrad &lt;- readTASSELGBSv2(ttdfile, samfile, min.ind.with.reads = 8,
                         min.ind.with.minor.allele = 2)
</code></pre>

<hr>
<h2 id='reverseComplement'>
Reverse Complement of DNA Sequence Stored as Character String
</h2><span id='topic+reverseComplement'></span><span id='topic+reverseComplement+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Whereas the <code>reverseComplement</code> function available in <span class="pkg">Biostrings</span> only
functions on <code>XString</code> and <code>XStringSet</code> objects, the version in
<span class="pkg">polyRAD</span> also works on character strings.  It is written as an S4 method
in order to avoid conflict with <span class="pkg">Biostrings</span>.  It is primarily included for
internal use by <span class="pkg">polyRAD</span>, but may be helpful at the user level as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverseComplement(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverseComplement_+3A_x">x</code></td>
<td>

<p>A vector of character strings indicating DNA sequence using IUPAC codes.
</p>
</td></tr>
<tr><td><code id="reverseComplement_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readDArTag">readDArTag</a></code> uses this function internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reverseComplement(c("AAGT", "CCA"))
</code></pre>

<hr>
<h2 id='SetBlankTaxa'>
Functions to Assign Taxa to Specific Roles
</h2><span id='topic+SetBlankTaxa'></span><span id='topic+GetBlankTaxa'></span><span id='topic+SetDonorParent'></span><span id='topic+GetDonorParent'></span><span id='topic+SetRecurrentParent'></span><span id='topic+GetRecurrentParent'></span>

<h3>Description</h3>

<p>These functions are used for assigning and retrieving taxa from a 
<code>"<a href="#topic+RADdata">RADdata</a>"</code> object that serve particular roles in the dataset.
Blank taxa can be used for estimating the contamination rate (see 
<code><a href="#topic+EstimateContaminationRate">EstimateContaminationRate</a></code>), and the donor and recurrent parents
are used for determining
expected genotype distributions in mapping populations.  Many functions
in <span class="pkg">polyRAD</span> will automatically exclude taxa from analysis if they
have been assigned to one of these roles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetBlankTaxa(object, value)
GetBlankTaxa(object, ...)
SetDonorParent(object, value)
GetDonorParent(object, ...)
SetRecurrentParent(object, value)
GetRecurrentParent(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetBlankTaxa_+3A_object">object</code></td>
<td>

<p>A <code>"<a href="#topic+RADdata">RADdata</a>"</code> object.
</p>
</td></tr>
<tr><td><code id="SetBlankTaxa_+3A_value">value</code></td>
<td>

<p>A character string (or a character vector for <code>SetBlankTaxa</code>) indicating
the taxon or taxa to be assigned to the role.
</p>
</td></tr>
<tr><td><code id="SetBlankTaxa_+3A_...">...</code></td>
<td>

<p>Other arguments (none currently supported).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the &ldquo;Get&rdquo; functions, a character vector indicating the taxon or taxa
that have been assigned to that role.  For the &ldquo;Set&rdquo; functions, a
<code>"<a href="#topic+RADdata">RADdata</a>"</code> object identical to the one passed to the function, but
with new taxa assigned to that role.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AddGenotypePriorProb_Mapping2Parents">AddGenotypePriorProb_Mapping2Parents</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign parents in a mapping population
data(exampleRAD_mapping)
exampleRAD_mapping &lt;- SetDonorParent(exampleRAD_mapping, "parent1")
exampleRAD_mapping &lt;- SetRecurrentParent(exampleRAD_mapping, "parent2")
GetDonorParent(exampleRAD_mapping)
GetRecurrentParent(exampleRAD_mapping)

# assign blanks
exampleRAD_mapping &lt;- SetBlankTaxa(exampleRAD_mapping, 
                                   c("progeny019", "progeny035"))
GetBlankTaxa(exampleRAD_mapping)
</code></pre>

<hr>
<h2 id='StripDown'>
Remove Unneeded Slots to Conserve Memory
</h2><span id='topic+StripDown'></span><span id='topic+StripDown.RADdata'></span>

<h3>Description</h3>

<p>This function is designed to be used after a <code><a href="#topic+RADdata">RADdata</a></code> object
has been processed by one of the <a href="#topic+IterateHWE">pipeline</a> functions.  
Slots that are no longer needed are removed in order to conserve memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StripDown(object, ...)
## S3 method for class 'RADdata'
StripDown(object, 
          remove.slots = c("depthSamplingPermutations",
                           "depthRatio", "antiAlleleDepth",
                           "genotypeLikelihood", "priorProb",
                           "priorProbLD"),
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StripDown_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="StripDown_+3A_remove.slots">remove.slots</code></td>
<td>

<p>A character vector listing slots that will be removed.
</p>
</td></tr>
<tr><td><code id="StripDown_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default slots that are removed take up a lot of memory but are not used
by the export functions.  Other slots to consider removing are 
<code>alleleFreq</code>, <code>alleleFreqByTaxa</code>, <code>PCA</code>, <code>locDepth</code>, 
<code>alleleDepth</code>, and <code>alleleLinkages</code>.  Of course, if you
have custom uses for some of the slots that are removed by default, you can 
change the <code>remove.slots</code> vector to not include them.
</p>
<p>The function will throw an error if the user attempts to remove key slots that
are needed for export and downstream analysis, including:
</p>

<ul>
<li><p> alleles2loc
</p>
</li>
<li><p> alleleNucleotides
</p>
</li>
<li><p> locTable
</p>
</li>
<li><p> possiblePloidies
</p>
</li>
<li><p> ploidyChiSq
</p>
</li>
<li><p> posteriorProb
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>RADdata</code> object 
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SubsetByTaxon">SubsetByTaxon</a></code>, <code><a href="#topic+SubsetByLocus">SubsetByLocus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a dataset for this example
data(exampleRAD)

# run a pipeline
exampleRAD &lt;- IterateHWE(exampleRAD)

# check the size of the resulting object
object.size(exampleRAD)

# remove unneeded slots
exampleRAD &lt;- StripDown(exampleRAD)

# check object size again
object.size(exampleRAD)
</code></pre>

<hr>
<h2 id='SubsetByLocus'>
Create RADdata Objects with a Subset of Loci
</h2><span id='topic+SubsetByLocus'></span><span id='topic+SubsetByLocus.RADdata'></span><span id='topic+SplitByChromosome'></span><span id='topic+SplitByChromosome.RADdata'></span><span id='topic+RemoveMonomorphicLoci'></span><span id='topic+RemoveMonomorphicLoci.RADdata'></span><span id='topic+RemoveHighDepthLoci'></span><span id='topic+RemoveHighDepthLoci.RADdata'></span><span id='topic+RemoveUngenotypedLoci'></span><span id='topic+RemoveUngenotypedLoci.RADdata'></span>

<h3>Description</h3>

<p>These functions take a <code><a href="#topic+RADdata">RADdata</a></code> object as input and generate smaller <code>RADdata</code>
objects containing only the specified loci.  <code>SubsetByLocus</code> allows the
user to specify which loci are kept, whereas <code>SplitByChromosome</code> creates
multiple <code>RADdata</code> objects representing chromosomes or sets of chromosomes.
<code>RemoveMonomorphicLoci</code> eliminates any loci with fewer than two alleles.
<code>RemoveHighDepthLoci</code> eliminates loci that have especially high read
depth in order to eliminate false loci originating from repetitive sequence.
<code>RemoveUngenotypedLoci</code> is intended for datasets that have been run
through <code><a href="#topic+PipelineMapping2Parents">PipelineMapping2Parents</a></code> and may have some genotypes that
are missing or non-variable due to how priors were determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetByLocus(object, ...)
## S3 method for class 'RADdata'
SubsetByLocus(object, loci, ...)

SplitByChromosome(object, ...)
## S3 method for class 'RADdata'
SplitByChromosome(object, chromlist = NULL, chromlist.use.regex = FALSE, 
                  fileprefix = "splitRADdata", ...)
                  
RemoveMonomorphicLoci(object, ...)
## S3 method for class 'RADdata'
RemoveMonomorphicLoci(object, verbose = TRUE, ...)

RemoveHighDepthLoci(object, ...)
## S3 method for class 'RADdata'
RemoveHighDepthLoci(object, max.SD.above.mean = 2, verbose = TRUE, ...)

RemoveUngenotypedLoci(object, ...)
## S3 method for class 'RADdata'
RemoveUngenotypedLoci(object, removeNonvariant = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubsetByLocus_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_loci">loci</code></td>
<td>

<p>A character or numeric vector indicating which loci to include in the output
<code>RADdata</code> object.  If numeric, it refers to row numbers in 
<code>object$locTable</code>.  If character, it refers to row names in 
<code>object$locTable</code>.
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_chromlist">chromlist</code></td>
<td>

<p>An optional list indicating how chromosomes should be split into separate
<code>RADdata</code> objects.  Each item in the list is a vector of the same 
class as <code>object$locTable$Chr</code> (character or numeric) containing the
names of chromosomes that should go into one group.  If not provided, each
chromosome will be sent to a separate <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_chromlist.use.regex">chromlist.use.regex</code></td>
<td>

<p>If <code>TRUE</code>, the character strings in <code>chromlist</code> will be treated
as regular expressions for searching chromosome names.  For example, if
one wanted all chromosomes beginning with the string &quot;scaffold&quot; to go 
into one <code>RADdata</code> object, one could include the string
<code>"^scaffold"</code> as an item in <code>chromlist</code> and set 
<code>chromlist.use.regex = TRUE</code>.  If <code>FALSE</code>, exact matches to
chromosome names will be used.
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_fileprefix">fileprefix</code></td>
<td>

<p>A character string indicating the prefix of .RData files to export.  
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_max.sd.above.mean">max.SD.above.mean</code></td>
<td>

<p>The maximum number of standard deviations above the mean read depth that a
locus can be in order to be retained.
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, print out information about the original number of loci and
the number of loci that were retained.  For <code>RemoveHighDepthLoci</code>, a
histogram is also plotted showing mean depth per locus, and the cutoff for
removing loci.
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_removenonvariant">removeNonvariant</code></td>
<td>

<p>If <code>TRUE</code>, in addition to removing loci where posterior probabilities are
missing, loci will be removed where posterior probabilities are uniform across
the population.
</p>
</td></tr>
<tr><td><code id="SubsetByLocus_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SubsetByLocus</code> may be useful if the user has used their own filtering
criteria to determine a set of loci to retain, and wants to create a new
dataset with only those loci.  It can be used at any point in the analysis
process.
</p>
<p><code>SplitByChromosome</code> is intended to make large datasets more manageable
by breaking them into smaller datasets that can be processed independently,
either in parallel computing jobs on a cluster, or one after another on a
computer with limited RAM.  Generally it should be used immediately after
data import.  Rather than returning new <code>RADdata</code> objects, it saves
them individually to separate workspace image files, which can than be 
loaded one at a time to run analysis pipelines such as <code><a href="#topic+IteratePopStruct">IteratePopStruct</a></code>.
<code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> or one of the export functions can be 
run on each resulting <code>RADdata</code> object, and the resulting matrices
concatenated with <code>cbind</code>.
</p>
<p><code>SplitByChromosome</code>, <code>RemoveMonomorphicLoci</code>, and 
<code>RemoveHighDepthLoci</code> use <code>SubsetByLocus</code> internally.
</p>


<h3>Value</h3>

<p><code>SubsetByLocus</code>, <code>RemoveMonomorphicLoci</code>, 
<code>RemoveHighDepthLoci</code>, and <code>RemoveUngenotypedLoci</code> return a <code>RADdata</code>
object with all the slots and attributes of <code>object</code>, but only 
containing the loci listed in <code>loci</code>, only loci with two or more
alleles, only loci without abnormally high depth, or only loci where posterior
probabilities are non-missing and variable, respectively.
</p>
<p><code>SplitByChromosome</code> returns a character vector containing file names
where .RData files have been saved.  Each .RData file contains one 
<code>RADdata</code> object named <code>splitRADdata</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VCF2RADdata">VCF2RADdata</a></code>, <code><a href="#topic+SubsetByTaxon">SubsetByTaxon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a dataset for this example
data(exampleRAD)
exampleRAD

# just keep the first and fourth locus
subsetRAD &lt;- SubsetByLocus(exampleRAD, c(1, 4))
subsetRAD

# split by groups of chromosomes
exampleRAD$locTable
tf &lt;- tempfile()
splitfiles &lt;- SplitByChromosome(exampleRAD, list(c(1, 4), c(6, 9)),
                                fileprefix = tf)
load(splitfiles[1])
splitRADdata

# filter out monomorphic loci (none removed in example)
filterRAD &lt;- RemoveMonomorphicLoci(exampleRAD)

# filter out high depth loci (none removed in this example)
filterRAD2 &lt;- RemoveHighDepthLoci(filterRAD)

# filter out loci with missing or non-variable genotypes 
# (none removed in this example)
filterRAD3 &lt;- IterateHWE(filterRAD2)
filterRAD3 &lt;- RemoveUngenotypedLoci(filterRAD3)
</code></pre>

<hr>
<h2 id='SubsetByPloidy'>
Create a RADdata object with a Subset of Possible Ploidies
</h2><span id='topic+SubsetByPloidy'></span><span id='topic+SubsetByPloidy.RADdata'></span>

<h3>Description</h3>

<p>This function is used for removing some of the ploidies (i.e. inheritance modes
possible across loci)
stored in a <code><a href="#topic+RADdata">RADdata</a></code> object.  If genotype calling has already
been performed, all of the relevant slots will be subsetted to only keep the
ploidies that the user indicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetByPloidy(object, ...)
## S3 method for class 'RADdata'
SubsetByPloidy(object, ploidies, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubsetByPloidy_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="SubsetByPloidy_+3A_ploidies">ploidies</code></td>
<td>

<p>A list, formatted like <code>object$possiblePloidies</code>, indicating ploidies to
retain.  Each item in the list is a vector, where <code>2</code> indicates diploid,
<code>c(2, 2)</code> allotetraploid, <code>4</code> autotetraploid, etc.
</p>
</td></tr>
<tr><td><code id="SubsetByPloidy_+3A_...">...</code></td>
<td>

<p>Other arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that slots of <code>object</code> are subsetted but not recalculated.  For
example, <code><a href="#topic+GetWeightedMeanGenotypes">GetWeightedMeanGenotypes</a></code> takes a weighted mean across
ploidies, which is in turn used for estimating allele frequencies and 
performing PCA.  If the values in <code>object$ploidyChiSq</code> are considerably
higher for the ploidies being removed than for the ploidies being retained,
this difference is likely to be small and not substantially impact genotype
calling.  Otherwise, it may be advisable to 
<a href="#topic+IterateHWE">re-run genotype calling</a> after running <code>SubsetByPloidy</code>.
</p>


<h3>Value</h3>

<p>A <code>RADdata</code> object identical to <code>object</code>, but only containing data
relevant to the inheritance modes listed in <code>ploidies</code>.
</p>


<h3>Note</h3>

<p>If you only wish to retain taxa of a certain ploidy, instead do
</p>
<p><code>object &lt;- SubsetByTaxon(object, GetTaxaByPloidy(object, 4))</code>
</p>
<p>to, for example, only retain tetraploid taxa.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SubsetByTaxon">SubsetByTaxon</a></code>, <code><a href="#topic+SubsetByLocus">SubsetByLocus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example dataset assuming diploidy or autotetraploidy
data(exampleRAD)
exampleRAD &lt;- IterateHWE(exampleRAD)
# Subset to only keep tetraploid results
exampleRAD &lt;- SubsetByPloidy(exampleRAD, ploidies = list(4))
</code></pre>

<hr>
<h2 id='SubsetByTaxon'>
Create RADdata Object with a Subset of Taxa
</h2><span id='topic+SubsetByTaxon'></span><span id='topic+SubsetByTaxon.RADdata'></span>

<h3>Description</h3>

<p>This function is used for removing some of the taxa from a dataset stored in a
<code><a href="#topic+RADdata">RADdata</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetByTaxon(object, ...)
## S3 method for class 'RADdata'
SubsetByTaxon(object, taxa, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubsetByTaxon_+3A_object">object</code></td>
<td>

<p>A <code>RADdata</code> object.
</p>
</td></tr>
<tr><td><code id="SubsetByTaxon_+3A_taxa">taxa</code></td>
<td>

<p>A character or numeric vector indicating which taxa to retain in the output.
</p>
</td></tr>
<tr><td><code id="SubsetByTaxon_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be used for subsetting a <code>RADdata</code> object either
immediately after data import, or after additional analysis has been
performed.  Note however that estimation of allele frequencies, genotype
prior probabilities, PCA, <em>etc.</em> are very dependent on what samples
are included in the dataset.  If those calculations have already been 
performed, the results will be transferred to the new object but not
recalculated.
</p>


<h3>Value</h3>

<p>A <code>RADdata</code> object containing only the taxa listed in <code>taxa</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SubsetByLocus">SubsetByLocus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data for this example
data(exampleRAD)
exampleRAD

# just keep the first fifty taxa
subsetRAD &lt;- SubsetByTaxon(exampleRAD, 1:50)
subsetRAD

</code></pre>

<hr>
<h2 id='TestOverdispersion'>
Test the Fit of Read Depth to Beta-Binomial Distribution
</h2><span id='topic+TestOverdispersion'></span><span id='topic+TestOverdispersion.RADdata'></span>

<h3>Description</h3>

<p>This function is intended to help the user select a value to pass to the
<code>overdispersion</code> argument of <code><a href="#topic+AddGenotypeLikelihood">AddGenotypeLikelihood</a></code>,
generally via pipeline functions such as <code><a href="#topic+IterateHWE">IterateHWE</a></code> or
<code><a href="#topic+PipelineMapping2Parents">PipelineMapping2Parents</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestOverdispersion(object, ...)

## S3 method for class 'RADdata'
TestOverdispersion(object, to_test = seq(6, 20, by = 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestOverdispersion_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object.  Genotype calling does not need to have
been performed, although for mapping populations it might be helpful to
have done a preliminary run of <code>PipelineMapping2Parents</code> without
linkage.
</p>
</td></tr>
<tr><td><code id="TestOverdispersion_+3A_to_test">to_test</code></td>
<td>

<p>A vector containing values to test.  These are values that will potentially
be used for the <code>overdispersion</code> argument of a pipeline function.  They
should all be positive numbers.
</p>
</td></tr>
<tr><td><code id="TestOverdispersion_+3A_...">...</code></td>
<td>

<p>Additional arguments (none implemented).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no genotype calling has been performed, a single iteration under HWE using
default parameters will be done.  <code>object$ploidyChiSq</code> is then examined
to determine the most common/most likely inheritance mode for the whole
dataset.  The alleles that are examined are only those where this
inheritance mode has the lowest chi-squared value.
</p>
<p>Within this inheritance mode and allele set, genotypes are selected where the
posterior probability of having a single copy of the allele is at least 0.95.
Read depth for these genotypes is then analyzed.  For each genotype, a 
two-tailed probability is calculated for the read depth ratio to deviate from 
the expected ratio by at least that much under the beta-binomial distribution.
This test is performed for each overdispersion value provided in
<code>to_test</code>.
</p>


<h3>Value</h3>

<p>A list of the same length as <code>to_test</code> plus one.  The names of the list are
<code>to_test</code> converted to a character vector.  Each item in the list is a
vector of p-values, one per examined genotype, of the read depth ratio for
that genotype to deviate that much from the expected ratio.  The last item,
named &quot;optimal&quot;, is a single number indicating the optimal value for the
overdispersion parameter based on the p-value distributions.  If the optimal
value was the minimum or maximum tested, <code>NA</code> is returned in the
<code>"optimal"</code> slot to encourage the user to test other values.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dataset with overdispersion
data(Msi01genes)

# test several values for the overdispersion parameter
myP &lt;- TestOverdispersion(Msi01genes, to_test = 8:10)

# view results as quantiles
sapply(myP[names(myP) != "optimal"],
       quantile, probs = c(0.01, 0.25, 0.5, 0.75, 0.99))
</code></pre>

<hr>
<h2 id='VCF2RADdata'>
Create a RADdata Object from a VCF File
</h2><span id='topic+VCF2RADdata'></span>

<h3>Description</h3>

<p>This function reads a Variant Call Format (VCF) file containing allelic read depth
and SNP alignment positions, such as can be produced by TASSEL or GATK, and 
generates a <code><a href="#topic+RADdata">RADdata</a></code> dataset to be used for genotype calling in
<span class="pkg">polyRAD</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCF2RADdata(file, phaseSNPs = TRUE, tagsize = 80, refgenome = NULL, 
            tol = 0.01, al.depth.field = "AD", min.ind.with.reads = 200, 
            min.ind.with.minor.allele = 10, possiblePloidies = list(2), 
            taxaPloidy = 2L, contamRate = 0.001, 
            samples = VariantAnnotation::samples(VariantAnnotation::scanVcfHeader(file)),
            svparam = VariantAnnotation::ScanVcfParam(fixed = "ALT", info = NA,
                                                      geno = al.depth.field,
                                                      samples = samples), 
            yieldSize = 5000, expectedAlleles = 5e+05, expectedLoci = 1e+05,
            maxLoci = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VCF2RADdata_+3A_file">file</code></td>
<td>

<p>The path to a VCF file to be read.  This can be uncompressed, bgzipped using
Samtools or Bioconductor, or a <code>TabixFile</code> object from Bioconductor.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_phasesnps">phaseSNPs</code></td>
<td>

<p>If <code>TRUE</code>, markers that appear to have come from the same set of reads
will be phased and grouped into haplotypes.  Otherwise, each row of the file
will be kept as a distinct marker.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_tagsize">tagsize</code></td>
<td>

<p>The read length, minus any barcode sequence, that was used for genotyping.  In TASSEL,
this is the same as the kmerLength option.  This argument is used for grouping
SNPs into haplotypes and is ignored if <code>phaseSNPs = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_refgenome">refgenome</code></td>
<td>

<p>Optional.  The name of a FASTA file, or an <code>FaFile</code> object, containing
the reference genome.  When grouping SNPs into haplotypes, if provided this 
reference genome is used to insert non-variable nucleotides between the variable
nucleotides in the <code>alleleNucleotides</code> slot of the <code>RADdata</code> output.
Ignored if <code>phaseSNPs = FALSE</code>.  Useful if exact SNP positions need to be
retained for downstream analysis after genotype calling in <span class="pkg">polyRAD</span>.
In particular this argument is necessary if you plan to export genotype calls
back to VCF.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_tol">tol</code></td>
<td>

<p>The proportion by which two SNPs can differ in read depth and still be merged
into one group for phasing.  Ignored if <code>phaseSNPs = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_al.depth.field">al.depth.field</code></td>
<td>

<p>The name of the genotype field in the VCF file that contains read depth at 
each allele.  This should be &quot;AD&quot; unless your format is very unusual.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_min.ind.with.reads">min.ind.with.reads</code></td>
<td>

<p>Integer used for filtering SNPs.  To be retained, a SNP must have at least
this many samples with reads.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_min.ind.with.minor.allele">min.ind.with.minor.allele</code></td>
<td>

<p>Integer used for filtering SNPs.  To be retained, a SNP must have at least
this many samples with the minor allele.  When there are more than two
alleles, at least two alleles must have at least this many samples with
reads for the SNP to be retained.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_possibleploidies">possiblePloidies</code></td>
<td>

<p>A list indicating inheritance modes that might be encountered in the 
dataset.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_taxaploidy">taxaPloidy</code></td>
<td>

<p>A single integer, or an integer vector with one value per taxon, indicating
ploidy.  See <code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_contamrate">contamRate</code></td>
<td>

<p>A number indicating the expected sample cross-contamination rate.  See
<code><a href="#topic+RADdata">RADdata</a></code>.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_samples">samples</code></td>
<td>

<p>A character vector containing the names of samples from the file to 
export to the <code>RADdata</code> object.  The default is all samples.
If a subset is provided, filtering with <code>min.ind.with.reads</code> and
<code>min.ind.with.minor.allele</code> is performed within that subset.  Ignored
if a different <code>samples</code> argument is provided within <code>svparam</code>.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_svparam">svparam</code></td>
<td>

<p>A <code><a href="VariantAnnotation.html#topic+ScanVcfParam-class">ScanVcfParam</a></code> object to be
used with <code><a href="VariantAnnotation.html#topic+readVcf-methods">readVcf</a></code>.  The primary
reasons to change this from the default would be 1) if you want additional
FIXED or INFO fields from the file to be exported to the <code>locTable</code>
slot of the <code>RADdata</code> object, and/or 2) if you only want to import
particular regions of the genome, as specified with the <code>which</code>
argument of <code>ScanVcfParam</code>.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_yieldsize">yieldSize</code></td>
<td>

<p>An integer indicating the number of lines of the file to read at once.
Increasing this number will make the function faster but consume more RAM.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_expectedalleles">expectedAlleles</code></td>
<td>

<p>An integer indicating the approximate number of alleles that are expected
to be imported after filtering and phasing.  If this number is too low,
the function may slow down considerably.  Increasing this number 
increases the amount of RAM used by the function.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_expectedloci">expectedLoci</code></td>
<td>

<p>An integer indicating the approximate number of loci that are expected
to be imported after filtering and phasing.  If this number is too low,
the function may slow down considerably.  Increasing this number 
increases the amount of RAM used by the function.
</p>
</td></tr>
<tr><td><code id="VCF2RADdata_+3A_maxloci">maxLoci</code></td>
<td>

<p>An integer indicating the approximate maximum number of loci to return.  If
provided, the function will stop reading the file once it has found at least
this many loci that pass filtering and phasing.  This argument is intended to
be used for generating small <code>RADdata</code> objects for testing purposes, and
should be left <code>NA</code> under normal circumstances.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the BioConductor package <span class="pkg">VariantAnnotation</span>.
See <a href="https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html">https://bioconductor.org/packages/release/bioc/html/VariantAnnotation.html</a>
for installation instructions.
</p>
<p>If you anticipate running <code>VCF2RADdata</code> on the same file more than once,
it is recommended to run <code>bgzip</code> and <code>indexTabix</code> from the package
<span class="pkg">Rsamtools</span> once before running <code>VCF2RADdata</code>.  See examples.
</p>
<p><code>min.ind.with.minor.allele</code> is used for filtering SNPs as the VCF file is
read.  Additionally, because phasing SNPs into haplotypes can cause some 
haplotypes to fail to pass this threshold, <code>VCF2RADdata</code> internally runs
<code><a href="#topic+MergeRareHaplotypes">MergeRareHaplotypes</a></code> with 
<code>min.ind.with.haplotype = min.ind.with.minor.allele</code>, then
<code><a href="#topic+RemoveMonomorphicLoci">RemoveMonomorphicLoci</a></code>, before returning the
final <code>RADdata</code> object.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+RADdata">RADdata</a></code> object.
</p>


<h3>Note</h3>

<p>In the <code>python</code> directory of the <span class="pkg">polyRAD</span> installation, there is a
script called <code>tassel_vcf_tags.py</code> that can identify the full tag
sequence(s) for every allele imported by <code>VCF2RADdata</code>.
</p>


<h3>Author(s)</h3>

<p>Lindsay V. Clark
</p>


<h3>References</h3>

<p>Variant Call Format specification: <a href="http://samtools.github.io/hts-specs/">http://samtools.github.io/hts-specs/</a>
</p>
<p>TASSEL GBSv2 pipeline: <a href="https://bitbucket.org/tasseladmin/tassel-5-source/wiki/Tassel5GBSv2Pipeline">https://bitbucket.org/tasseladmin/tassel-5-source/wiki/Tassel5GBSv2Pipeline</a>
</p>
<p>GATK: <a href="https://gatk.broadinstitute.org/hc/en-us">https://gatk.broadinstitute.org/hc/en-us</a>
</p>
<p>Tassel4-Poly: <a href="https://github.com/guilherme-pereira/tassel4-poly">https://github.com/guilherme-pereira/tassel4-poly</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MakeTasselVcfFilter">MakeTasselVcfFilter</a></code> for filtering to a smaller VCF file before
reading with <code>VCF2RADdata</code>.
</p>
<p>To export to VCF: <code><a href="#topic+RADdata2VCF">RADdata2VCF</a></code>
</p>
<p>Other data import functions:  <code><a href="#topic+readStacks">readStacks</a></code>, <code><a href="#topic+readHMC">readHMC</a></code>,
<code><a href="#topic+readTagDigger">readTagDigger</a></code>, <code><a href="#topic+readTASSELGBSv2">readTASSELGBSv2</a></code>,
<code><a href="#topic+readProcessIsoloci">readProcessIsoloci</a></code>, <code><a href="#topic+readDArTag">readDArTag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the example VCF installed with polyRAD
exampleVCF &lt;- system.file("extdata", "Msi01genes.vcf", package = "polyRAD")


# loading VariantAnnotation namespace takes &gt;10s,
# so is excluded from CRAN checks

require(VariantAnnotation)

# Compress and index the VCF before reading, if not already done
if(!file.exists(paste(exampleVCF, "bgz", sep = "."))){
  vcfBG &lt;- bgzip(exampleVCF)
  indexTabix(vcfBG, "vcf")
}

# Read into RADdata object
myRAD &lt;- VCF2RADdata(exampleVCF, expectedLoci = 100, expectedAlleles = 500)

# Example of subsetting by genomic region (first 200 kb on Chr01)
mysv &lt;- ScanVcfParam(fixed = "ALT", info = NA, geno = "AD",
                     samples = samples(scanVcfHeader(exampleVCF)),
                     which = GRanges("01", IRanges(1, 200000)))
myRAD2 &lt;- VCF2RADdata(exampleVCF, expectedLoci = 100, expectedAlleles = 500,
                      svparam = mysv, yieldSize = NA_integer_)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
