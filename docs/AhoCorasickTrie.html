<!DOCTYPE html><html lang="en"><head><title>Help for package AhoCorasickTrie</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AhoCorasickTrie}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AhoCorasickTrie'><p>AhoCorasickTrie: fast searching for multiple keywords in multiple texts</p></a></li>
<li><a href='#AhoCorasickSearch'><p>Fast searching for one or more keywords in one or more texts</p></a></li>
<li><a href='#AhoCorasickSearchList'><p>Fast searching for one or more keywords in a list of texts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Searching for Multiple Keywords in Multiple Texts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Aho-Corasick is an optimal algorithm for finding many
    keywords in a text. It can locate all matches in a text in O(N+M) time; i.e.,
    the time needed scales linearly with the number of keywords (N) and the size of
    the text (M). Compare this to the naive approach which takes O(N*M) time to loop
    through each pattern and scan for it in the text. This implementation builds the
    trie (the generic name of the data structure) and runs the search in a single
    function call. If you want to search multiple texts with the same trie, the
    function will take a list or vector of texts and return a list of matches to
    each text. By default, all 128 ASCII characters are allowed in both the keywords
    and the text. A more efficient trie is possible if the alphabet size can be
    reduced. For example, DNA sequences use at most 19 distinct characters and
    usually only 4; protein sequences use at most 26 distinct characters and usually
    only 20. UTF-8 (Unicode) matching is not currently supported.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/chambm/AhoCorasickTrie">https://github.com/chambm/AhoCorasickTrie</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chambm/AhoCorasickTrie/issues">https://github.com/chambm/AhoCorasickTrie/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>microbenchmark, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-04 20:49:23 UTC; Matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Chambers [aut, cre],
  Tomas Petricek [aut, cph],
  Vanderbilt University [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Chambers &lt;matt.chambers42@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-05 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AhoCorasickTrie'>AhoCorasickTrie: fast searching for multiple keywords in multiple texts</h2><span id='topic+AhoCorasickTrie-package'></span><span id='topic+AhoCorasickTrie'></span>

<h3>Description</h3>

<p>Builds an Aho-Corasick trie from one or more keywords and uses it to
search one or more texts. For a large number of keywords, Aho-Corasick is much faster
than a naive approach (such as <code>lapply(keywords, gregexpr, text)</code>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matt Chambers <a href="mailto:matt.chambers42@gmail.com">matt.chambers42@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Tomas Petricek [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Vanderbilt University [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/chambm/AhoCorasickTrie">https://github.com/chambm/AhoCorasickTrie</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/chambm/AhoCorasickTrie/issues">https://github.com/chambm/AhoCorasickTrie/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AhoCorasickSearch'>Fast searching for one or more keywords in one or more texts</h2><span id='topic+AhoCorasickSearch'></span>

<h3>Description</h3>

<p>Builds an Aho-Corasick trie from one or more keywords and uses it to
search one or more texts. For a large number of keywords, Aho-Corasick is much faster
than a naive approach (such as <code>lapply(keywords, gregexpr, text)</code>).
</p>
<p>Use <code><a href="#topic+AhoCorasickSearchList">AhoCorasickSearchList</a></code> instead of <code><a href="#topic+AhoCorasickSearch">AhoCorasickSearch</a></code> when you want to keep the matches
of each input text separate. If the input texts have names, the resulting list of matches will include those
names and non-matched texts will be excluded from the results. If the input texts do
not have names, then the resulting list of matches will be in the same order as the
input texts, and non-matched texts will be kept to preserve that order. Thus, it is more
efficient to use named input texts (so non-matched texts can be dropped).
</p>
<p>The default alphabet allows all 128 ASCII characters in the keywords and the texts.
Characters outside this range will cause an error. A more efficient trie is possible
if the alphabet size can be reduced. For example, DNA sequences use at most 19 distinct
characters and usually only 4; protein sequences use at most 26 distinct characters and
usually only 20. Set the <code>alphabet</code> parameter if a reduced alphabet is appropriate.
</p>
<p>UTF-8 (Unicode) matching is not currently supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AhoCorasickSearch(
  keywords,
  text,
  alphabet = "ascii",
  groupByKeyword = FALSE,
  iterationFeedback = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AhoCorasickSearch_+3A_keywords">keywords</code></td>
<td>
<p>Character vector of one or more keywords</p>
</td></tr>
<tr><td><code id="AhoCorasickSearch_+3A_text">text</code></td>
<td>
<p>Character vector of one or more texts to search</p>
</td></tr>
<tr><td><code id="AhoCorasickSearch_+3A_alphabet">alphabet</code></td>
<td>
<p>Alphabet to use; one of <code>ascii</code>, <code>aminoacid</code>, or <code>nucleicacid</code></p>
</td></tr>
<tr><td><code id="AhoCorasickSearch_+3A_groupbykeyword">groupByKeyword</code></td>
<td>
<p>If true, matches are grouped by keyword (instead of by text)</p>
</td></tr>
<tr><td><code id="AhoCorasickSearch_+3A_iterationfeedback">iterationFeedback</code></td>
<td>
<p>When set to a positive integer <code>i</code>, console output will indicate when searching every <code>i</code>th text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matches, grouped by either text or by keyword
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://www.codeproject.com/Articles/12383/Aho-Corasick-string-matching-in-C">Aho-Corasick string matching in C#</a> for the article this package is based on
</p>
</li>
<li> <p><code>Biostrings matchPDict</code> for a more memory efficient, but DNA-only, implementation of the algorithm
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>listEquals = function(a, b) { is.null(unlist(a)) &amp;&amp; is.null(unlist(b)) ||
                              !is.null(a) &amp;&amp; !is.null(b) &amp;&amp; all(unlist(a) == unlist(b)) }

# 1. Search for multiple keywords in a single text
keywords = c("Abra", "cadabra", "is", "the", "Magic", "Word")
oneSearch = AhoCorasickSearch(keywords, "Is Abracadabra the Magic Word?")
stopifnot(listEquals(oneSearch[[1]][[1]], list(keyword="Abra", offset=4)))
stopifnot(listEquals(oneSearch[[1]][[2]], list(keyword="cadabra", offset=8)))
stopifnot(listEquals(oneSearch[[1]][[3]], list(keyword="the", offset=16)))
stopifnot(listEquals(oneSearch[[1]][[4]], list(keyword="Magic", offset=20)))
stopifnot(listEquals(oneSearch[[1]][[5]], list(keyword="Word", offset=26)))

# 2. Search multiple named texts in a named list with keyword grouping and aminoacid alphabet
# * all matches to a keyword are accessed by name
# * non-matched keywords are dropped
proteins = c(protein1="PEPTIDEPEPTIDEDADADARARARARAKEKEKEKEPEPTIDE",
             protein2="DERPADERPAPEWPEWPEEPEERAWRAWWARRAGTAGPEPTIDEKESEQUENCE")
peptides = c("PEPTIDE", "DERPA", "SEQUENCE", "KEKE", "PEPPIE")

peptideSearch = AhoCorasickSearch(peptides, proteins, alphabet="aminoacid", groupByKeyword=TRUE)
stopifnot(listEquals(peptideSearch$PEPTIDE, list(list(keyword="protein1", offset=1),
                                                 list(keyword="protein1", offset=8),
                                                 list(keyword="protein1", offset=37),
                                                 list(keyword="protein2", offset=38))))
stopifnot(listEquals(peptideSearch$DERPA, list(list(keyword="protein2", offset=1),
                                               list(keyword="protein2", offset=6))))
stopifnot(listEquals(peptideSearch$SEQUENCE, list(list(keyword="protein2", offset=47))))
stopifnot(listEquals(peptideSearch$KEKE, list(list(keyword="protein1", offset=29),
                                              list(keyword="protein1", offset=31),
                                              list(keyword="protein1", offset=33))))
stopifnot(listEquals(peptideSearch$PEPPIE, NULL))

# 3. Grouping by keyword without text names: offsets are given without reference to the text
names(proteins) = NULL
peptideSearch = AhoCorasickSearch(peptides, proteins, groupByKeyword=TRUE)
stopifnot(listEquals(peptideSearch$PEPTIDE, list(1, 8, 37, 38)))
stopifnot(listEquals(peptideSearch$DERPA, list(1, 6)))
stopifnot(listEquals(peptideSearch$SEQUENCE, list(47)))
stopifnot(listEquals(peptideSearch$KEKE, list(29, 31, 33)))
</code></pre>

<hr>
<h2 id='AhoCorasickSearchList'>Fast searching for one or more keywords in a list of texts</h2><span id='topic+AhoCorasickSearchList'></span>

<h3>Description</h3>

<p>Builds an Aho-Corasick trie from one or more keywords and uses it to search a list of
one or more texts. For a large number of keywords, Aho-Corasick is much faster
than a naive approach (such as <code>lapply(keywords, gregexpr, text)</code>).
</p>
<p>Use <code><a href="#topic+AhoCorasickSearchList">AhoCorasickSearchList</a></code> instead of <code><a href="#topic+AhoCorasickSearch">AhoCorasickSearch</a></code> when you want to keep the matches
of each input sublist separate. If the sublists of the input list have names, the resulting list of lists
will use those names, but sublists with no matches will still be in the resulting list.
If the texts of the sublists have names, the resulting sublists of matches will use
those names, and the texts with no matches will be dropped. If the input texts do
not have names, then the resulting sublists of matches will be in the same order as the
input texts, and non-matched texts will be kept to preserve that order. Thus, it is more
efficient to use named input texts (so non-matched texts can be dropped).
</p>
<p>The default alphabet allows all 128 ASCII characters in the keywords and the texts.
Characters outside this range will cause an error. A more efficient trie is possible
if the alphabet size can be reduced. For example, DNA sequences use at most 19 distinct
characters and usually only 4; protein sequences use at most 26 distinct characters and
usually only 20. Set the <code>alphabet</code> parameter if a reduced alphabet is appropriate.
</p>
<p>UTF-8 (Unicode) matching is not currently supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AhoCorasickSearchList(
  keywords,
  textList,
  alphabet = "ascii",
  groupByKeyword = FALSE,
  iterationFeedback = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AhoCorasickSearchList_+3A_keywords">keywords</code></td>
<td>
<p>Character vector of one or more keywords</p>
</td></tr>
<tr><td><code id="AhoCorasickSearchList_+3A_textlist">textList</code></td>
<td>
<p>List of lists, each sublist with one or more texts to search</p>
</td></tr>
<tr><td><code id="AhoCorasickSearchList_+3A_alphabet">alphabet</code></td>
<td>
<p>Alphabet to use; one of <code>ascii</code>, <code>aminoacid</code>, or <code>nucleicacid</code></p>
</td></tr>
<tr><td><code id="AhoCorasickSearchList_+3A_groupbykeyword">groupByKeyword</code></td>
<td>
<p>If true, matches are grouped by keyword (instead of by text)</p>
</td></tr>
<tr><td><code id="AhoCorasickSearchList_+3A_iterationfeedback">iterationFeedback</code></td>
<td>
<p>When set to a positive integer <code>i</code>, console output will indicate when searching every <code>i</code>th text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of lists of matches, grouped by either text or by keyword (each list of texts gets its own list of matches)
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://www.codeproject.com/Articles/12383/Aho-Corasick-string-matching-in-C">Aho-Corasick string matching in C#</a> for the article this package is based on
</p>
</li>
<li> <p><code>Biostrings matchPDict</code> for a more memory efficient, but DNA-only, implementation of the algorithm
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>listEquals = function(a, b) { is.null(unlist(a)) &amp;&amp; is.null(unlist(b)) ||
                              !is.null(a) &amp;&amp; !is.null(b) &amp;&amp; all(unlist(a) == unlist(b)) }
keywords = c("Abra", "cadabra", "is", "the", "Magic", "Word")

# 1. Search a list of lists without names
# * sublists are accessed by index
# * texts are accessed by index
# * non-matched texts are kept (input index order is preserved)
listSearch = AhoCorasickSearchList(keywords,
                                   list(c("What in", "the world"),
                                        c("is"),
                                        "secret about",
                                        "the Magic Word?"))
stopifnot(listEquals(listSearch[[1]][[1]], list()))
stopifnot(listEquals(listSearch[[1]][[2]][[1]], list(keyword="the", offset=1)))
stopifnot(listEquals(listSearch[[2]][[1]][[1]], list(keyword="is", offset=1)))
stopifnot(listEquals(listSearch[[3]], list()))
stopifnot(listEquals(listSearch[[4]][[1]][[1]], list(keyword="the", offset=1)))
stopifnot(listEquals(listSearch[[4]][[1]][[2]], list(keyword="Magic", offset=5)))
stopifnot(listEquals(listSearch[[4]][[1]][[3]], list(keyword="Word", offset=11)))

# 2. Search a named list of named lists
# * sublists are accessed by name
# * matched texts are accessed by name
# * non-matched texts are dropped
namedSearch = AhoCorasickSearchList(keywords,
                                    list(subject=c(phrase1="What in", phrase2="the world"),
                                         verb=c(phrase1="is"),
                                         predicate1=c(phrase1="secret about"),
                                         predicate2=c(phrase1="the Magic Word?")))
stopifnot(listEquals(namedSearch$subject$phrase2[[1]], list(keyword="the", offset=1)))
stopifnot(listEquals(namedSearch$verb$phrase1[[1]], list(keyword="is", offset=1)))
stopifnot(listEquals(namedSearch$predicate1, list()))
stopifnot(listEquals(namedSearch$predicate2$phrase1[[1]], list(keyword="the", offset=1)))
stopifnot(listEquals(namedSearch$predicate2$phrase1[[2]], list(keyword="Magic", offset=5)))
stopifnot(listEquals(namedSearch$predicate2$phrase1[[3]], list(keyword="Word", offset=11)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
