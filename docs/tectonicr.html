<!DOCTYPE html><html lang="en-US"><head><title>Help for package tectonicr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tectonicr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tectonicr'><p>library(tectonicr)</p></a></li>
<li><a href='#abs_vel'><p>Absolute Plate Velocity</p></a></li>
<li><a href='#angle_vectors'><p>Angle Between Two Vectors</p></a></li>
<li><a href='#angle-conversion'><p>Degrees to Radians</p></a></li>
<li><a href='#axes'><p>Plot axes</p></a></li>
<li><a href='#circle_mean_diff'><p>Circular Mean Difference</p></a></li>
<li><a href='#circle_stats'><p>Summary Statistics of Circular Data</p></a></li>
<li><a href='#circular_dispersion_boot'><p>Bootstrapped Estimates for Circular Dispersion</p></a></li>
<li><a href='#circular_mode'><p>Circular Mode</p></a></li>
<li><a href='#circular_plot'><p>Circular plot</p></a></li>
<li><a href='#circular_qqplot'><p>Quantile-Quantile Linearised Plot for Circular Distributions</p></a></li>
<li><a href='#circular_range'><p>Circular Range</p></a></li>
<li><a href='#circular_sd_error'><p>Standard Error of Mean Direction of Circular Data</p></a></li>
<li><a href='#circular_summary'><p>Circular Summary Statistics</p></a></li>
<li><a href='#compact-grid'><p>Compact Smoothed Stress Field</p></a></li>
<li><a href='#confidence'><p>Confidence Interval around the Mean Direction of Circular Data</p></a></li>
<li><a href='#confidence_interval_fisher'><p>Confidence Interval around the Mean Direction of Circular Data after Fisher (1993)</p></a></li>
<li><a href='#conjugate_Q4'><p>Conjugation of a Quaternion</p></a></li>
<li><a href='#coordinate_mod'><p>Coordinate Correction</p></a></li>
<li><a href='#coordinates'><p>Coordinate Transformations</p></a></li>
<li><a href='#coordinates2'><p>Coordinate Transformations</p></a></li>
<li><a href='#cpm_models'><p>Global model of current plate motions</p></a></li>
<li><a href='#deviation_norm'><p>Normalize Angle Between Two Directions</p></a></li>
<li><a href='#deviation_shmax'><p>Deviation of Observed and Predicted Directions of Maximum Horizontal Stress</p></a></li>
<li><a href='#dispersion'><p>Circular Distance and Dispersion</p></a></li>
<li><a href='#dist_greatcircle'><p>Distance between points</p></a></li>
<li><a href='#distance_binned_stats'><p>Distance Binned Summary Statistics</p></a></li>
<li><a href='#distance_from_pb'><p>Distance from plate boundary</p></a></li>
<li><a href='#distance_mod'><p>Normalize angular distance on a sphere distance</p></a></li>
<li><a href='#dummy'><p>Plate Stress Dummy Grid</p></a></li>
<li><a href='#earth_radius'><p>Earth's radius in km</p></a></li>
<li><a href='#equivalent_rotation'><p>Equivalent rotation</p></a></li>
<li><a href='#est.kappa'><p>Concentration parameter of von Mises distribution</p></a></li>
<li><a href='#euler_pole'><p>Euler pole object</p></a></li>
<li><a href='#euler_to_Q4'><p>Quaternion from Euler angle-axis representation for rotations</p></a></li>
<li><a href='#get_azimuth'><p>Azimuth Between two Points</p></a></li>
<li><a href='#get_distance'><p>Helper function to Distance from plate boundary</p></a></li>
<li><a href='#get_projected_pb_strike'><p>Helper function to get Distance from plate boundary</p></a></li>
<li><a href='#get_relrot'><p>Helper function to Equivalent rotation</p></a></li>
<li><a href='#import_WSM2016'><p>World Stress Map Database (WSM) Release 2016</p></a></li>
<li><a href='#is.euler'><p>Check if object is euler.pole</p></a></li>
<li><a href='#is.Q4'><p>Check if object is quaternion</p></a></li>
<li><a href='#kernel_dispersion'><p>Adaptive Kernel Dispersion</p></a></li>
<li><a href='#kuiper_test'><p>Kuiper Test of Circular Uniformity</p></a></li>
<li><a href='#line_azimuth'><p>Extract azimuths of line segments</p></a></li>
<li><a href='#mean_resultant_length'><p>Mean Resultant Length</p></a></li>
<li><a href='#mean_SC'><p>Mean Cosine and Sine</p></a></li>
<li><a href='#model_shmax'><p>Theoretical Direction of Maximum Horizontal Stress in the</p>
geographical reference system.</a></li>
<li><a href='#norm_chisq'><p>Normalized Chi-Squared Test for Circular Data</p></a></li>
<li><a href='#normalize_Q4'><p>Quaternion normalization</p></a></li>
<li><a href='#nuvel1'><p>NUVEL-1 Global model of current plate motions</p></a></li>
<li><a href='#nuvel1_plates'><p>Plate Boundaries on the Earth</p></a></li>
<li><a href='#parse_wsm'><p>Numerical values to World Stress Map Quality Ranking</p></a></li>
<li><a href='#pb2002'><p>Global model of current plate motions</p></a></li>
<li><a href='#plates'><p>Plate Boundaries on the Earth</p></a></li>
<li><a href='#plot_density'><p>Circular Density Plot</p></a></li>
<li><a href='#plot_points'><p>Add Points to a Circular Plot</p></a></li>
<li><a href='#PoR_azi'><p>Azimuth Conversion from Geographical to PoR Coordinate Reference System</p></a></li>
<li><a href='#PoR_coordinates'><p>Coordinates of the Pole of Rotation Reference System</p></a></li>
<li><a href='#PoR_crs'><p>PoR coordinate reference system</p></a></li>
<li><a href='#PoR_distance'><p>Distance to Pole of Rotation</p></a></li>
<li><a href='#PoR_map'><p>Map of data in Pole of Rotation reference frame</p></a></li>
<li><a href='#PoR_stress2grid'><p>Spatial Interpolation of SHmax in PoR Coordinate Reference System</p></a></li>
<li><a href='#por_transformation'><p>Conversion between spherical PoR to geographical coordinate system</p></a></li>
<li><a href='#por_transformation_df'><p>Conversion between spherical PoR to geographical coordinate system of data.frames</p></a></li>
<li><a href='#por_transformation_quat'><p>Conversion between PoR to geographical coordinate system using quaternions</p></a></li>
<li><a href='#por_transformation_sf'><p>Conversion between PoR to geographical coordinates of sf data</p></a></li>
<li><a href='#PoR2Geo_azimuth'><p>Azimuth Conversion From PoR to Geographical Coordinate Reference System</p></a></li>
<li><a href='#PositionCenterSpoke'><p>Centrically aligned geom_spoke marker</p></a></li>
<li><a href='#prd_err'><p>Error of Model's Prediction</p></a></li>
<li><a href='#product_Q4'><p>Product of quaternions</p></a></li>
<li><a href='#projected_pb_strike'><p>Strike of the plate boundary projected on data point</p></a></li>
<li><a href='#Q4_to_euler'><p>Euler angle/axis from quaternion</p></a></li>
<li><a href='#quick_plot'><p>Plotting Stress Analysis Results</p></a></li>
<li><a href='#raster_transformation'><p>Conversion between PoR to geographical coordinate reference system of raster</p>
data</a></li>
<li><a href='#rayleigh_test'><p>Rayleigh Test of Circular Uniformity</p></a></li>
<li><a href='#relative_rotation'><p>Relative rotation between two rotations</p></a></li>
<li><a href='#roll_circstats'><p>Apply Rolling Functions using Circular Statistics</p></a></li>
<li><a href='#rolling_test'><p>Apply Rolling Functions using Circular Statistical Tests for Uniformity</p></a></li>
<li><a href='#rolling_test_dist'><p>Apply Rolling Functions using Circular Statistics</p></a></li>
<li><a href='#rose'><p>Rose Diagram</p></a></li>
<li><a href='#rose_bw'><p>Selecting optimal number of bins and width for rose diagrams</p></a></li>
<li><a href='#rose_geom'><p>Direction Lines and Fans in Circular Diagram</p></a></li>
<li><a href='#rose_stats'><p>Show Average Direction and Spread in Rose Diagram</p></a></li>
<li><a href='#rotate_lines'><p>Rotate Lines</p></a></li>
<li><a href='#rotation_Q4'><p>Rotation of a vector by a quaternion</p></a></li>
<li><a href='#sample_median'><p>Circular Sample Median and Deviation</p></a></li>
<li><a href='#second_central_moment'><p>Second Central Momentum</p></a></li>
<li><a href='#spec_atan'><p>Quadrant-specific inverse of the tangent</p></a></li>
<li><a href='#spherical_angle'><p>Angle along great circle on spherical surface</p></a></li>
<li><a href='#stress_analysis'><p>Quick analysis of a stress data set</p></a></li>
<li><a href='#stress_colors'><p>Color palette for stress regime</p></a></li>
<li><a href='#stress_data'><p>Example crustal stress dataset</p></a></li>
<li><a href='#stress_paths'><p>Theoretical Plate Tectonic Stress Paths</p></a></li>
<li><a href='#stress2grid'><p>Spatial Interpolation of SHmax</p></a></li>
<li><a href='#superimposed_shmax'><p>SHmax direction resulting from multiple plate boundaries</p></a></li>
<li><a href='#superimposed_shmax_PB'><p>SHmax direction resulting from multiple plate boundaries considering distance</p>
to plate boundaries</a></li>
<li><a href='#tectonicr.colors'><p>Colors for input variables</p></a></li>
<li><a href='#trigon'><p>Trigonometric Functions in Degrees</p></a></li>
<li><a href='#vcross'><p>Vector cross product</p></a></li>
<li><a href='#vm_qqplot'><p>von Mises Quantile-Quantile Plot</p></a></li>
<li><a href='#vonmises'><p>The von Mises Distribution</p></a></li>
<li><a href='#watson_test'><p>Watson's <code class="reqn">U^2</code> Test of Circular Uniformity</p></a></li>
<li><a href='#weighted_rayleigh'><p>Weighted Goodness-of-fit Test for Circular Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analyzing the Orientation of Maximum Horizontal Stress</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Models the direction of the maximum horizontal stress using
    relative plate motion parameters. Statistical algorithms to evaluate
    the modeling results compared with the observed data. Provides plots
    to visualize the results. Methods described in Stephan et al. (2023)
    &lt;<a href="https://doi.org/10.1038%2Fs41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>&gt; and Wdowinski (1998)
    &lt;<a href="https://doi.org/10.1016%2FS0079-1946%2898%2900091-3">doi:10.1016/S0079-1946(98)00091-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tobiste.github.io/tectonicr/">https://tobiste.github.io/tectonicr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tobiste/tectonicr/issues">https://github.com/tobiste/tectonicr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, circular (&ge; 0.5.0), dplyr, ggplot2, lifecycle, methods,
RColorBrewer, sf, smoothr (&ge; 1.0.1), spatstat.explore (&ge;
3.2.7), spatstat.geom (&ge; 3.2.9), spatstat.univar (&ge; 2.0.3),
spatstat.utils (&ge; 3.0.4), terra, tidyr, viridis, zoo (&ge;
1.8.12)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggforce, knitr, rmarkdown, roxygen2, testthat (&ge; 3.0.0),
tidyterra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-28 13:08:47 UTC; tstephan</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Stephan <a href="https://orcid.org/0000-0002-9290-014X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Stephan &lt;tobias.stephan1@yahoo.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-01 01:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tectonicr'>library(tectonicr)</h2><span id='topic+tectonicr'></span><span id='topic+tectonicr-package'></span>

<h3>Description</h3>

<p>Modeling the Direction of the Maximum Horizontal Stress using Relative Plate
Motion
</p>


<h3>Details</h3>

<p>Further details and theoretical background are provided by Wdowinski
(1998) and Stephan et al. (2023).
</p>


<h3>Note</h3>

<p>A list of documented functions may be viewed by typing
<code>help(package="tectonicr")</code>.
</p>


<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>References</h3>

<p>Wdowinski (1998) &quot;A theory of intraplate tectonics&quot;.
<em>JGR: Solid Earth</em>, 103(3), 5037&lt;U+2013&gt;5059.
</p>
<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the horizontal
orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023).
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tobiste.github.io/tectonicr/">https://tobiste.github.io/tectonicr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tobiste/tectonicr/issues">https://github.com/tobiste/tectonicr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abs_vel'>Absolute Plate Velocity</h2><span id='topic+abs_vel'></span>

<h3>Description</h3>

<p>Calculates the absolute angular velocity of plate motion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_vel(w, alpha, r = earth_radius())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs_vel_+3A_w">w</code></td>
<td>
<p>Angular velocity or rate or angle of rotation</p>
</td></tr>
<tr><td><code id="abs_vel_+3A_alpha">alpha</code></td>
<td>
<p>Angular distance to Euler pole or small circle around Euler pole</p>
</td></tr>
<tr><td><code id="abs_vel_+3A_r">r</code></td>
<td>
<p>Radius. Default is WGS84 Earth's radius (6371.009 km)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric (unit of velocity: km/Myr)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+earth_radius">earth_radius()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abs_vel(0.21, 0)
abs_vel(0.21, 45)
abs_vel(0.21, 90)
</code></pre>

<hr>
<h2 id='angle_vectors'>Angle Between Two Vectors</h2><span id='topic+angle_vectors'></span>

<h3>Description</h3>

<p>Calculates the angle between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_vectors(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angle_vectors_+3A_x">x</code>, <code id="angle_vectors_+3A_y">y</code></td>
<td>
<p>Vectors in Cartesian coordinates. Can be vectors of three numbers
or a matrix of 3 columns (x, y, z)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. angle in degrees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- c(1, -2, 3)
v &lt;- c(-2, 1, 1)
angle_vectors(u, v)
</code></pre>

<hr>
<h2 id='angle-conversion'>Degrees to Radians</h2><span id='topic+angle-conversion'></span><span id='topic+rad2deg'></span><span id='topic+deg2rad'></span>

<h3>Description</h3>

<p>Helper functions to transform between angles in degrees and
radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad2deg(rad)

deg2rad(deg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angle-conversion_+3A_rad">rad</code></td>
<td>
<p>(array of) angles in radians.</p>
</td></tr>
<tr><td><code id="angle-conversion_+3A_deg">deg</code></td>
<td>
<p>(array of) angles in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. angle in degrees or radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deg2rad(seq(-90, 90, 15))
rad2deg(seq(-pi / 2, pi / 2, length = 13))
</code></pre>

<hr>
<h2 id='axes'>Plot axes</h2><span id='topic+axes'></span>

<h3>Description</h3>

<p>Show direction axes in a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axes(
  x,
  y,
  angle,
  radius = 0.5,
  arrow.code = 1,
  arrow.length = 0,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axes_+3A_x">x</code>, <code id="axes_+3A_y">y</code></td>
<td>
<p>coordinates of points</p>
</td></tr>
<tr><td><code id="axes_+3A_angle">angle</code></td>
<td>
<p>Azimuth in degrees</p>
</td></tr>
<tr><td><code id="axes_+3A_radius">radius</code></td>
<td>
<p>length of axis</p>
</td></tr>
<tr><td><code id="axes_+3A_arrow.code">arrow.code</code></td>
<td>
<p>integer. Kind of arrow head. The default is <code>1</code>, i.e. no
arrow head. See <code><a href="graphics.html#topic+arrows">graphics::arrows()</a></code> for details</p>
</td></tr>
<tr><td><code id="axes_+3A_arrow.length">arrow.length</code></td>
<td>
<p>numeric Length of the edges of the arrow head (in
inches). (Ignored if <code>arrow.code = 1</code>)</p>
</td></tr>
<tr><td><code id="axes_+3A_add">add</code></td>
<td>
<p>logical. add to existing plot?</p>
</td></tr>
<tr><td><code id="axes_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+arrows">graphics::arrows()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
axes(san_andreas$lon, san_andreas$lat, san_andreas$azi, add = FALSE)
</code></pre>

<hr>
<h2 id='circle_mean_diff'>Circular Mean Difference</h2><span id='topic+circle_mean_diff'></span><span id='topic+circular_mean_difference'></span><span id='topic+circular_mean_difference_alt'></span>

<h3>Description</h3>

<p>Circular Mean Difference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_mean_difference(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_mean_difference_alt(x, w = NULL, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_mean_diff_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circle_mean_diff_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circle_mean_diff_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circle_mean_diff_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>References</h3>

<p>Mardia, K.V., and Jupp, P.E (1999). Directional Statistics,
Wiley Series in Probability and Statistics. John Wiley &amp; Sons, Inc.,
Hoboken, NJ, USA. <a href="https://doi.org/10.1002/9780470316979">doi:10.1002/9780470316979</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
circular_mean_difference(san_andreas$azi)
circular_mean_difference(san_andreas$azi, 1 / san_andreas$unc)

circular_mean_difference_alt(san_andreas$azi)
circular_mean_difference_alt(san_andreas$azi, 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='circle_stats'>Summary Statistics of Circular Data</h2><span id='topic+circle_stats'></span><span id='topic+circular_mean'></span><span id='topic+circular_var'></span><span id='topic+circular_sd'></span><span id='topic+circular_median'></span><span id='topic+circular_quantiles'></span><span id='topic+circular_IQR'></span><span id='topic+sample_circular_dispersion'></span>

<h3>Description</h3>

<p>Calculate the (weighted median) and standard deviation
of orientation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_mean(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_var(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_sd(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_median(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_quantiles(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_IQR(x, w = NULL, axial = TRUE, na.rm = TRUE)

sample_circular_dispersion(x, w = NULL, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_stats_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circle_stats_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circle_stats_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circle_stats_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Note</h3>

<p>Weighting may be the reciprocal of the data uncertainties.
</p>
<p>Weightings have no effect on quasi-median and quasi-quantiles if
<code>length(x) %% 2 != 1</code> and <code>length(x) %% 4 == 0</code>, respectively.
</p>


<h3>References</h3>

<p>Mardia, K.V. (1972). Statistics of Directional Data: Probability and
Mathematical Statistics. London: Academic Press.
</p>
<p>Mardia, K.V., and Jupp, P.E (1999). Directional Statistics,
Wiley Series in Probability and Statistics. John Wiley &amp; Sons, Inc.,
Hoboken, NJ, USA. <a href="https://doi.org/10.1002/9780470316979">doi:10.1002/9780470316979</a>
</p>
<p>Ziegler, M. O.; Heidbach O. (2019). Manual of the Matlab Script
Stress2Grid v1.1. <em>WSM Technical Report</em> 19-02,
GFZ German Research Centre for Geosciences. <a href="https://doi.org/10.2312/wsm.2019.002">doi:10.2312/wsm.2019.002</a>
</p>
<p>Heidbach, O., Tingay, M., Barth, A., Reinecker, J., Kurfess, D., &amp; Mueller,
B. (2010). Global crustal stress pattern based on the World Stress Map
database release 2008. <em>Tectonophysics</em> <strong>482</strong>, 3&lt;U+2013&gt;15,
<a href="https://doi.org/10.1016/j.tecto.2009.07.023">doi:10.1016/j.tecto.2009.07.023</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rvm(10, 0, 100) %% 180
unc &lt;- stats::runif(100, 0, 10)
circular_mean(x, 1 / unc)
circular_var(x, 1 / unc)
sample_circular_dispersion(x, 1 / unc)
circular_sd(x, 1 / unc)
circular_median(x, 1 / unc)
circular_quantiles(x, 1 / unc)
circular_IQR(x, 1 / unc)

data("san_andreas")
circular_mean(san_andreas$azi)
circular_mean(san_andreas$azi, 1 / san_andreas$unc)
circular_median(san_andreas$azi)
circular_median(san_andreas$azi, 1 / san_andreas$unc)
circular_quantiles(san_andreas$azi)
circular_quantiles(san_andreas$azi, 1 / san_andreas$unc)
circular_var(san_andreas$azi)
circular_var(san_andreas$azi, 1 / san_andreas$unc)
sample_circular_dispersion(san_andreas$azi, 1 / san_andreas$unc)

data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_mean(sa.por$azi.PoR, 1 / san_andreas$unc)
circular_median(sa.por$azi.PoR, 1 / san_andreas$unc)
circular_var(sa.por$azi.PoR, 1 / san_andreas$unc)
sample_circular_dispersion(sa.por$azi.PoR, 1 / san_andreas$unc)
circular_quantiles(sa.por$azi.PoR, 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='circular_dispersion_boot'>Bootstrapped Estimates for Circular Dispersion</h2><span id='topic+circular_dispersion_boot'></span>

<h3>Description</h3>

<p>Calculates bootstrapped estimates of the circular dispersion,
its standard error and its confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_dispersion_boot(
  x,
  y = NULL,
  w = NULL,
  w.y = NULL,
  R = 1000,
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_dispersion_boot_+3A_x">x</code></td>
<td>
<p>numeric values in degrees.</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_y">y</code></td>
<td>
<p>numeric. The angle(s) about which the angles <code>x</code> disperse (in degrees).</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_w">w</code>, <code id="circular_dispersion_boot_+3A_w.y">w.y</code></td>
<td>
<p>(optional) Weights for <code>x</code> and <code>y</code>, respectively. A vector of
positive numbers and of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. positive integer
(1000 by default).</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence: <code class="reqn">(1 - \alpha \%)/100</code>.
(<code>0.95</code> by default).</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="boot.html#topic+boot">boot::boot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing:
</p>

<dl>
<dt><code>MLE</code></dt><dd><p>the maximum likelihood estimate of the circular dispersion</p>
</dd>
<dt><code>sde</code></dt><dd><p>standard error of MLE</p>
</dd>
<dt><code>CI</code></dt><dd><p>lower and upper limit of the confidence interval of MLE</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+circular_dispersion">circular_dispersion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_dispersion(sa.por$azi.PoR, y = 135, w = 1 / san_andreas$unc)
circular_dispersion_boot(sa.por$azi.PoR, y = 135, w = 1 / san_andreas$unc, R = 1000)
</code></pre>

<hr>
<h2 id='circular_mode'>Circular Mode</h2><span id='topic+circular_mode'></span>

<h3>Description</h3>

<p>MLE angle (maximum density) using a von Mises distribution kernel with
specified concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_mode(x, kappa = NULL, axial = TRUE, n = 512)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_mode_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circular_mode_+3A_kappa">kappa</code></td>
<td>
<p>von Mises distribution concentration parameter. Will be
estimated using <code><a href="#topic+est.kappa">est.kappa()</a></code> if not provided.</p>
</td></tr>
<tr><td><code id="circular_mode_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).#' @param kappa</p>
</td></tr>
<tr><td><code id="circular_mode_+3A_n">n</code></td>
<td>
<p>the number of equally spaced points at which the density is to be estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rvm(10, 0, 100)
circular_mode(x, kappa = est.kappa(x))
</code></pre>

<hr>
<h2 id='circular_plot'>Circular plot</h2><span id='topic+circular_plot'></span>

<h3>Description</h3>

<p>Circular plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_plot(
  main = NULL,
  labels = TRUE,
  at = seq(0, 360 - 45, 45),
  cborder = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_plot_+3A_main">main</code></td>
<td>
<p>Character string specifying the title of the plot.</p>
</td></tr>
<tr><td><code id="circular_plot_+3A_labels">labels</code></td>
<td>
<p>Either a logical value indicating whether to plot labels
next to the tick marks, or a vector of labels for the tick marks.</p>
</td></tr>
<tr><td><code id="circular_plot_+3A_at">at</code></td>
<td>
<p>Optional vector of angles at which tick marks should be plotted.
Set <code>at=numeric(0)</code> to suppress tick marks.</p>
</td></tr>
<tr><td><code id="circular_plot_+3A_cborder">cborder</code></td>
<td>
<p>logical. Border of rose plot.</p>
</td></tr>
<tr><td><code id="circular_plot_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>plot.default()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Note</h3>

<p>Polar diagram where angles increase clockwise.
</p>

<hr>
<h2 id='circular_qqplot'>Quantile-Quantile Linearised Plot for Circular Distributions</h2><span id='topic+circular_qqplot'></span>

<h3>Description</h3>

<p>Uniformly distributed orientations should yield a straight line through the
origin. Systematic departures from linearity will indicate preferred
orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_qqplot(
  x,
  axial = TRUE,
  xlab = paste("i/(n+1)"),
  ylab = NULL,
  main = "Circular Quantile-Quantile Plot",
  add_line = TRUE,
  col = "#B63679FF",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_qqplot_+3A_x">x</code></td>
<td>
<p>numeric. Angles in degrees</p>
</td></tr>
<tr><td><code id="circular_qqplot_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)</p>
</td></tr>
<tr><td><code id="circular_qqplot_+3A_xlab">xlab</code>, <code id="circular_qqplot_+3A_ylab">ylab</code>, <code id="circular_qqplot_+3A_main">main</code></td>
<td>
<p>plot labels.</p>
</td></tr>
<tr><td><code id="circular_qqplot_+3A_add_line">add_line</code></td>
<td>
<p>logical. Whether to connect the points by straight lines?</p>
</td></tr>
<tr><td><code id="circular_qqplot_+3A_col">col</code></td>
<td>
<p>color for the dots.</p>
</td></tr>
<tr><td><code id="circular_qqplot_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>References</h3>

<p>Borradaile, G. J. (2003). Statistics of earth
science data: their distribution in time, space, and orientation (Vol. 351,
p. 329). Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># von Mises distribution
x_vm &lt;- rvm(100, mean = 0, kappa = 2)
circular_qqplot(x_vm, pch = 20)

x_norm &lt;- rnorm(100, mean = 0, sd = 25)
circular_qqplot(x_norm, pch = 20)

# uniform (random) data
x_unif &lt;- runif(100, 0, 360)
circular_qqplot(x_unif, pch = 20)
</code></pre>

<hr>
<h2 id='circular_range'>Circular Range</h2><span id='topic+circular_range'></span>

<h3>Description</h3>

<p>Length of the smallest arc which contains all the observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_range(x, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_range_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circular_range_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circular_range_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. angle in degrees
</p>


<h3>References</h3>

<p>Mardia, K.V., and Jupp, P.E (1999). Directional Statistics,
Wiley Series in Probability and Statistics. John Wiley &amp; Sons, Inc.,
Hoboken, NJ, USA. <a href="https://doi.org/10.1002/9780470316979">doi:10.1002/9780470316979</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roulette &lt;- c(43, 45, 52, 61, 75, 88, 88, 279, 357)
circular_range(roulette, axial = FALSE)

data("san_andreas")
circular_range(san_andreas$azi)
</code></pre>

<hr>
<h2 id='circular_sd_error'>Standard Error of Mean Direction of Circular Data</h2><span id='topic+circular_sd_error'></span>

<h3>Description</h3>

<p>Measure of the chance variation expected from sample to sample in estimates
of the mean direction.
It is a parametric estimate of the the circular standard error of the mean direction
by the particular form of the standard error for the von Mises distribution.
The approximated standard error of the mean direction is computed by the mean
resultant length and the MLE concentration parameter <code class="reqn">\kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_sd_error(x, w = NULL, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_sd_error_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circular_sd_error_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circular_sd_error_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circular_sd_error_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical Analysis of Circular Data, Cambridge University Press.
</p>
<p>Davis (1986) Statistics and data analysis in geology. 2nd ed., John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_resultant_length">mean_resultant_length()</a></code>, <code><a href="#topic+circular_mean">circular_mean()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
circular_sd_error(finland_stria, axial = FALSE)

data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_sd_error(sa.por$azi.PoR, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='circular_summary'>Circular Summary Statistics</h2><span id='topic+circular_summary'></span>

<h3>Description</h3>

<p>Circular mean, standard deviation, variance, quasi-quantiles, mode,
95% confidence angle, standardized skewness and kurtosis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_summary(x, w = NULL, kappa = NULL, axial = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circular_summary_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circular_summary_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circular_summary_+3A_kappa">kappa</code></td>
<td>
<p>numeric. von Mises distribution concentration parameter used
for the circular mode. Will be estimated using <code><a href="#topic+est.kappa">est.kappa()</a></code> if not provided.</p>
</td></tr>
<tr><td><code id="circular_summary_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circular_summary_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+circular_sd">circular_sd()</a></code>, <code><a href="#topic+circular_var">circular_var()</a></code>,
<code><a href="#topic+circular_quantiles">circular_quantiles()</a></code>, <code><a href="#topic+confidence_angle">confidence_angle()</a></code>, <code><a href="#topic+second_central_moment">second_central_moment()</a></code>,
<code><a href="#topic+circular_mode">circular_mode()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_summary(sa.por$azi.PoR)
circular_summary(sa.por$azi.PoR, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='compact-grid'>Compact Smoothed Stress Field</h2><span id='topic+compact-grid'></span><span id='topic+compact_grid'></span><span id='topic+compact_grid2'></span>

<h3>Description</h3>

<p>Filter smoothed stress field containing a range of search radii or kernel
half widths to find shortest wavelength (R) with the least circular sd. or
dispersion (or any statistic) for each coordinate, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact_grid(x, type = c("stress", "dispersion"))

compact_grid2(x, ..., FUN = min)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compact-grid_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+stress2grid">stress2grid()</a></code>, <code><a href="#topic+PoR_stress2grid">PoR_stress2grid()</a></code>,
<code><a href="#topic+stress2grid_stats">stress2grid_stats()</a></code>, or <code><a href="#topic+kernel_dispersion">kernel_dispersion()</a></code></p>
</td></tr>
<tr><td><code id="compact-grid_+3A_type">type</code></td>
<td>
<p>character. Type of the grid <code>x</code>. Either <code>"stress"</code> (when input
is <code><a href="#topic+stress2grid">stress2grid()</a></code> or <code><a href="#topic+PoR_stress2grid">PoR_stress2grid()</a></code>) or <code>"dispersion"</code> (when input
is <code><a href="#topic+kernel_dispersion">kernel_dispersion()</a></code>).</p>
</td></tr>
<tr><td><code id="compact-grid_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;tidy-select&gt;&#8288;</code> One unquoted expression separated by
commas. Variable names can be used as if they were positions in the data
frame. Variable must be a column in <code>x</code>.</p>
</td></tr>
<tr><td><code id="compact-grid_+3A_fun">FUN</code></td>
<td>
<p>function is used to aggregate the data using the search radius
<code>R</code>. Default is <code><a href="base.html#topic+min">min()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stress2grid">stress2grid()</a></code>, <code><a href="#topic+PoR_stress2grid">PoR_stress2grid()</a></code>, <code><a href="#topic+kernel_dispersion">kernel_dispersion()</a></code>,
<code><a href="#topic+stress2grid_stats">stress2grid_stats()</a></code>, <code><a href="dplyr.html#topic+dplyr_tidy_select">dplyr::dplyr_tidy_select()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
res &lt;- stress2grid(san_andreas)
compact_grid(res)

## Not run: 
res2 &lt;- stress2grid_stats(san_andreas)
compact_grid2(res2, var, FUN = min)

## End(Not run)
</code></pre>

<hr>
<h2 id='confidence'>Confidence Interval around the Mean Direction of Circular Data</h2><span id='topic+confidence'></span><span id='topic+confidence_angle'></span><span id='topic+confidence_interval'></span>

<h3>Description</h3>

<p>Probabilistic limit on the location of the true or population mean direction,
assuming that the estimation errors are normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidence_angle(x, conf.level = 0.95, w = NULL, axial = TRUE, na.rm = TRUE)

confidence_interval(x, conf.level = 0.95, w = NULL, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confidence_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="confidence_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence: <code class="reqn">(1 - \alpha \%)/100</code>.
(<code>0.95</code> by default).</p>
</td></tr>
<tr><td><code id="confidence_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="confidence_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="confidence_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence angle gives the interval, i.e. plus and minus the confidence angle,
around the mean direction of a particular sample, that contains the true
mean direction under a given level of confidence.
</p>


<h3>Value</h3>

<p>Angle in degrees
</p>


<h3>References</h3>


<ul>
<li><p> Davis (1986) Statistics and data analysis in geology. 2nd ed., John Wiley
&amp; Sons.
</p>
</li>
<li><p> Jammalamadaka, S. Rao and Sengupta, A. (2001). Topics in Circular
Statistics, Sections 3.3.3 and 3.4.1, World Scientific Press, Singapore.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mean_resultant_length">mean_resultant_length()</a></code>, <code><a href="#topic+circular_sd_error">circular_sd_error()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
confidence_angle(finland_stria, axial = FALSE)
confidence_interval(finland_stria, axial = FALSE)

data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
confidence_angle(sa.por$azi.PoR, w = 1 / san_andreas$unc)
confidence_interval(sa.por$azi.PoR, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='confidence_interval_fisher'>Confidence Interval around the Mean Direction of Circular Data after Fisher (1993)</h2><span id='topic+confidence_interval_fisher'></span>

<h3>Description</h3>

<p>For large samples (<code>n &gt;=25</code>) i performs are parametric estimate based on
<code><a href="#topic+sample_circular_dispersion">sample_circular_dispersion()</a></code>. For smaller size samples, it returns a
bootstrap estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidence_interval_fisher(
  x,
  conf.level = 0.95,
  w = NULL,
  axial = TRUE,
  na.rm = TRUE,
  boot = FALSE,
  R = 1000L,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confidence_interval_fisher_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="confidence_interval_fisher_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence: <code class="reqn">(1 - \alpha \%)/100</code>.
(<code>0.95</code> by default).</p>
</td></tr>
<tr><td><code id="confidence_interval_fisher_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="confidence_interval_fisher_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="confidence_interval_fisher_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="confidence_interval_fisher_+3A_boot">boot</code></td>
<td>
<p>logical. Force bootstrap estimation</p>
</td></tr>
<tr><td><code id="confidence_interval_fisher_+3A_r">R</code></td>
<td>
<p>integer. number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="confidence_interval_fisher_+3A_quiet">quiet</code></td>
<td>
<p>logical. Prints the used estimation (parametric or bootstrap).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical Analysis of Circular Data, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
confidence_interval_fisher(finland_stria, axial = FALSE)
confidence_interval_fisher(finland_stria, axial = FALSE, boot = TRUE)

data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
confidence_interval_fisher(sa.por$azi.PoR, w = 1 / san_andreas$unc)
confidence_interval_fisher(sa.por$azi.PoR, w = 1 / san_andreas$unc, boot = TRUE)
</code></pre>

<hr>
<h2 id='conjugate_Q4'>Conjugation of a Quaternion</h2><span id='topic+conjugate_Q4'></span>

<h3>Description</h3>

<p>Inverse rotation given by conjugated quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjugate_Q4(q, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conjugate_Q4_+3A_q">q</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
<tr><td><code id="conjugate_Q4_+3A_normalize">normalize</code></td>
<td>
<p>logical. Whether a quaternion normalization should be applied (TRUE) or not (FALSE, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>

<hr>
<h2 id='coordinate_mod'>Coordinate Correction</h2><span id='topic+coordinate_mod'></span><span id='topic+longitude_modulo'></span><span id='topic+latitude_modulo'></span>

<h3>Description</h3>

<p>Corrects the longitudes or latitudes to value between -180.0 and
180.0 or -90 and 90 degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longitude_modulo(x)

latitude_modulo(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordinate_mod_+3A_x">x</code></td>
<td>
<p>Longitude(s) or latitude(s) in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>longitude_modulo(-361 + 5 * 360)
latitude_modulo(-91 + 5 * 180)
</code></pre>

<hr>
<h2 id='coordinates'>Coordinate Transformations</h2><span id='topic+coordinates'></span><span id='topic+cartesian_to_geographical'></span><span id='topic+geographical_to_cartesian'></span><span id='topic+geographical_to_spherical'></span>

<h3>Description</h3>

<p>Converts vector between Cartesian and geographical coordinate
systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartesian_to_geographical(n)

geographical_to_cartesian(p)

geographical_to_spherical(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordinates_+3A_n">n</code></td>
<td>
<p>Cartesian coordinates (x, y, z) as vector</p>
</td></tr>
<tr><td><code id="coordinates_+3A_p">p</code></td>
<td>
<p>Geographical coordinates (latitude, longitude) as vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions return a (2- or 3-dimensional) vector representing a
point in the requested coordinate system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cartesian_to_spherical">cartesian_to_spherical()</a></code> and <code><a href="#topic+spherical_to_cartesian">spherical_to_cartesian()</a></code> for
conversions to spherical coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(1, -2, 3)
cartesian_to_geographical(n)
p &lt;- c(50, 10)
geographical_to_cartesian(p)
</code></pre>

<hr>
<h2 id='coordinates2'>Coordinate Transformations</h2><span id='topic+coordinates2'></span><span id='topic+cartesian_to_spherical'></span><span id='topic+spherical_to_cartesian'></span><span id='topic+spherical_to_geographical'></span>

<h3>Description</h3>

<p>Converts vector between Cartesian and spherical coordinate
systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartesian_to_spherical(n)

spherical_to_cartesian(p)

spherical_to_geographical(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordinates2_+3A_n">n</code></td>
<td>
<p>Cartesian coordinates (x, y, z) as three-column vector</p>
</td></tr>
<tr><td><code id="coordinates2_+3A_p">p</code></td>
<td>
<p>Spherical coordinates (colatitude, azimuth) as two-column vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions return a (2- or 3-dimensional) vector representing a
point in the requested coordinate system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cartesian_to_geographical">cartesian_to_geographical()</a></code> and <code><a href="#topic+geographical_to_cartesian">geographical_to_cartesian()</a></code> for
conversions to geographical coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(1, -2, 3)
cartesian_to_spherical(n)
p &lt;- c(50, 10)
spherical_to_cartesian(p)
</code></pre>

<hr>
<h2 id='cpm_models'>Global model of current plate motions</h2><span id='topic+cpm_models'></span>

<h3>Description</h3>

<p>Compilation of global models for current plate motions, including
NUVEL1 (DeMets et al. 1990),
NNR-NUVEL1A (DeMets et al., 1990),
NNR-MORVEL56 (Argus et al., 2011),
REVEL (Sella et al., 2002),
GSRM2.1 (Kreemer et al., 2014),
HS2-NUVEL1 (Gripp and Gordon, 1990),
HS3-NUVEL1A (Gripp and Gordon, 2002),
P073 (Chase 1978),
AM1-2 (Minster and Jordan, 1978),
ITRF2020-PPM (Altamimi et al. 2023),
and
PB2002 (Bird, 2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('cpm_models')
</code></pre>


<h3>Format</h3>

<p>list containing objects of class <code>data.frame</code>
</p>

<dl>
<dt>plate.name</dt><dd><p>The rotating plate</p>
</dd>
<dt>plate.rot</dt><dd><p>The abbreviation of the plate's name</p>
</dd>
<dt>lat,lon</dt><dd><p>Coordinates of the Pole of Rotation</p>
</dd>
<dt>angle</dt><dd><p>The amount of rotation (angle in 1 Myr)</p>
</dd>
<dt>plate.fix</dt><dd><p>The anchored plate, i.e. <code>plate.rot</code> moves relative
to  <code>plate.fix</code></p>
</dd>
<dt>model</dt><dd><p>Model for current global plate motion</p>
</dd>
</dl>



<h3>References</h3>

<p>Altamimi, Z., Mtivier, L., Rebischung, P., Collilieux, X., Chanard, K.,
Barnoud, J., 2023. ITRF2020 Plate Motion Model. <em>Geophys. Res. Lett.</em>
<strong>50</strong>, 17. <a href="https://doi.org/10.1029/2023GL106373">doi:10.1029/2023GL106373</a>
</p>
<p>Argus, D.F., Gordon, R.G., 1991. No-net-rotation model of
current plate velocities incorporating plate motion model NUVEL-1.
<em>Geophys. Res. Lett.</em> <strong>18</strong>, 20392042. doi: 10.1029/91GL01532
</p>
<p>Argus, D. F., Gordon, R. G., &amp; DeMets, C. (2011). Geologically
current motion of 56 plates relative to the no-net-rotation reference frame.
<em>Geochemistry, Geophysics, Geosystems</em>, <strong>12</strong>(11).
10.1029/2011GC003751.
</p>
<p>Chase, C.G. (1978). Plate kinematics: The Americas, East Africa, and the rest
of the world. <em>Earth Planet. Sci. Lett.</em> <strong>37</strong>, 355368.
doi: <a href="https://doi.org/10.1016/0012-821X%2878%2990051-1">doi:10.1016/0012-821X(78)90051-1</a>
</p>
<p>Bird, P. (2003), An updated digital model of plate boundaries,
<em>Geochem. Geophys. Geosyst.</em>, <strong>4</strong>, 1027, doi: 10.1029/2001GC000252, 3.
</p>
<p>DeMets, C., Gordon, R. G., Argus, D. F., &amp; Stein, S. (1990).
Current plate motions. <em>Geophysical Journal International</em>, <strong>101</strong>(2),
425-478. <a href="https://doi.org/10.1111/j.1365-246X.1990.tb06579.x">doi:10.1111/j.1365-246X.1990.tb06579.x</a>.
</p>
<p>Gripp, A. E., &amp; Gordon, R. G. (2002). Young tracks of hotspots and current
plate velocities. <em>Geophysical Journal International</em>, <strong>150</strong>(2), 321&lt;U+2013&gt;361.
<a href="https://doi.org/10.1046/j.1365-246X.2002.01627.x">doi:10.1046/j.1365-246X.2002.01627.x</a>.
</p>
<p>Kreemer, C., Blewitt, G., &amp; Klein, E. C. (2014). A geodetic plate motion
and Global Strain Rate Model. <em>Geochemistry, Geophysics, Geosystems</em>,
<strong>15</strong>(10), 3849&lt;U+2013&gt;3889. doi: 10.1002/2014GC005407.
</p>
<p>Minster, J. and Jorda, T. (1978). Present-day plate motions.
<em>Journal of Geophysical Research</em>, <strong>83</strong>, <a href="https://doi.org/10.1029/jb083ib11p05331">doi:10.1029/jb083ib11p05331</a>.
</p>
<p>Sella, G. F., Dixon, T. H., &amp; Mao, A. (2002). REVEL: A model for Recent
plate velocities from space geodesy. <em>Journal of Geophysical Research: Solid
Earth</em>, <strong>107</strong>(B4). doi: 10.1029/2000jb000033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("cpm_models")
head(cpm_models[[1]])
</code></pre>

<hr>
<h2 id='deviation_norm'>Normalize Angle Between Two Directions</h2><span id='topic+deviation_norm'></span>

<h3>Description</h3>

<p>Normalizes the angle between two directions to the acute angle
in between, i.e. angles between 0 and 90<code class="reqn">^\circ</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviation_norm(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviation_norm_+3A_x">x</code>, <code id="deviation_norm_+3A_y">y</code></td>
<td>
<p>Minuend and subtrahend. Both numeric vectors of angles in degrees.
If <code>y</code> is missing, it treats <code>x</code> as difference. If not, length of subtrahend
<code>y</code> is either <code>1</code> or equal to <code>length(x)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, acute angles between two directions, i.e. values
between 0 and 90<code class="reqn">^\circ</code>
</p>


<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deviation_norm(175, 5)
deviation_norm(c(175, 95, 0), c(5, 85, NA))
deviation_norm(c(-5, 85, 95, 175, 185, 265, 275, 355, 365))
</code></pre>

<hr>
<h2 id='deviation_shmax'>Deviation of Observed and Predicted Directions of Maximum Horizontal Stress</h2><span id='topic+deviation_shmax'></span>

<h3>Description</h3>

<p>Calculate the angular difference between the observed and modeled direction
of maximum horizontal stresses (<code class="reqn">\sigma_{Hmax}</code>) along
great circles, small circles, and
loxodromes of the relative plate motion's Euler pole
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviation_shmax(prd, obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviation_shmax_+3A_prd">prd</code></td>
<td>
<p><code>data.frame</code> containing the modeled azimuths of
<code class="reqn">\sigma_{Hmax}</code>, i.e.
the return object from <code>model_shmax()</code></p>
</td></tr>
<tr><td><code id="deviation_shmax_+3A_obs">obs</code></td>
<td>
<p>Numeric vector containing the observed azimuth of
<code class="reqn">\sigma_{Hmax}</code>,
same length as <code>prd</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>data.frame</code>
</p>

<dl>
<dt>dev.gc</dt><dd><p>Deviation of observed stress from modeled
<code class="reqn">\sigma_{Hmax}</code> following
great circles</p>
</dd>
<dt>dev.sc</dt><dd><p>Small circles</p>
</dd>
<dt>dev.ld.cw</dt><dd><p>Clockwise loxodromes</p>
</dd>
<dt>dev.ld.ccw</dt><dd><p>Counter-clockwise loxodromes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_shmax">model_shmax()</a></code> to calculate the theoretical direction of
<code class="reqn">\sigma_{Hmax}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

# the point where we want to model the SHmax direction:
point &lt;- data.frame(lat = 45, lon = 20)

prd &lt;- model_shmax(point, PoR)
deviation_shmax(prd, obs = 90)
</code></pre>

<hr>
<h2 id='dispersion'>Circular Distance and Dispersion</h2><span id='topic+dispersion'></span><span id='topic+circular_distance'></span><span id='topic+circular_dispersion'></span><span id='topic+circular_distance_alt'></span><span id='topic+circular_dispersion_alt'></span>

<h3>Description</h3>

<p>Circular distance between two angles and circular dispersion of angles
about a specified angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_distance(x, y, axial = TRUE, na.rm = TRUE)

circular_dispersion(
  x,
  y = NULL,
  w = NULL,
  w.y = NULL,
  axial = TRUE,
  na.rm = TRUE
)

circular_distance_alt(x, y, axial = TRUE, na.rm = TRUE)

circular_dispersion_alt(
  x,
  y = NULL,
  w = NULL,
  w.y = NULL,
  axial = TRUE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dispersion_+3A_x">x</code>, <code id="dispersion_+3A_y">y</code></td>
<td>
<p>vectors of numeric values in degrees. <code>length(y)</code> is either
<code>1</code> or <code>length(x)</code></p>
</td></tr>
<tr><td><code id="dispersion_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="dispersion_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_w">w</code>, <code id="dispersion_+3A_w.y">w.y</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>. <code>w.y</code> is the (optional) weight of <code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+circular_distance_alt">circular_distance_alt()</a></code> and <code><a href="#topic+circular_dispersion_alt">circular_dispersion_alt()</a></code> are the alternative
versions in Mardia and Jupp (2000), pp. 19-20.
The alternative dispersion has a minimum at the sample median.
</p>


<h3>Value</h3>

<p><code>circular_distance</code>returns a numeric vector of positive numbers,
<code>circular_dispersion</code>returns a positive number.
</p>


<h3>Note</h3>

<p>If <code>y</code> is <code>NULL</code>, than the circular variance is returned.
</p>


<h3>References</h3>

<p>Mardia, K.V. (1972). Statistics of Directional Data: Probability
and Mathematical Statistics. London: Academic Press.
</p>
<p>Mardia, K.V., and Jupp, P.E (1999). Directional Statistics,
Wiley Series in Probability and Statistics. John Wiley &amp; Sons, Inc.,
Hoboken, NJ, USA. <a href="https://doi.org/10.1002/9780470316979">doi:10.1002/9780470316979</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+circular_var">circular_var()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(0, 2, 359, 6, 354)
circular_distance(a, 10) # distance to single value

b &lt;- a + 90
circular_distance(a, b) # distance to multiple values

data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_dispersion(sa.por$azi.PoR, y = 135)
circular_dispersion(sa.por$azi.PoR, y = 135, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='dist_greatcircle'>Distance between points</h2><span id='topic+dist_greatcircle'></span>

<h3>Description</h3>

<p>Returns the great circle distance between a location and all grid point in km
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_greatcircle(
  lat1,
  lon1,
  lat2,
  lon2,
  r = earth_radius(),
  method = c("haversine", "orthodrome", "vincenty", "euclidean")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_greatcircle_+3A_lat1">lat1</code>, <code id="dist_greatcircle_+3A_lon1">lon1</code></td>
<td>
<p>numeric vector. coordinate of point(s) 1 (degrees).</p>
</td></tr>
<tr><td><code id="dist_greatcircle_+3A_lat2">lat2</code>, <code id="dist_greatcircle_+3A_lon2">lon2</code></td>
<td>
<p>numeric vector. coordinates of point(s) 2 (degrees).</p>
</td></tr>
<tr><td><code id="dist_greatcircle_+3A_r">r</code></td>
<td>
<p>numeric. radius of the sphere (default = 6371.0087714 km, i.e. the
radius of the Earth)</p>
</td></tr>
<tr><td><code id="dist_greatcircle_+3A_method">method</code></td>
<td>
<p>Character. Formula for calculating great circle distance,
one of:
</p>

<dl>
<dt><code>"haversine"</code></dt><dd><p>great circle distance based on the haversine
formula that is optimized for 64-bit floating-point numbers (the default)</p>
</dd>
<dt><code>"orthodrome"</code></dt><dd><p>great circle distance based on the spherical law of cosines</p>
</dd>
<dt><code>"vincenty"</code></dt><dd><p>distance based on the Vincenty formula for an
ellipsoid with equal major and minor axes</p>
</dd>
<dt>&quot;euclidean&quot;</dt><dd><p>Euclidean distance (not great circle distance!)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with length equal to <code>length(lat1)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orthodrome">orthodrome()</a></code>, <code><a href="#topic+haversine">haversine()</a></code>, <code><a href="#topic+vincenty">vincenty()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_greatcircle(lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32))
dist_greatcircle(
  lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32),
  method = "orthodrome"
)
dist_greatcircle(
  lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32),
  method = "vincenty"
)
dist_greatcircle(
  lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32),
  method = "euclidean"
)
</code></pre>

<hr>
<h2 id='distance_binned_stats'>Distance Binned Summary Statistics</h2><span id='topic+distance_binned_stats'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Circular summary statistics over intervals of distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_binned_stats(
  azi,
  distance,
  n.breaks = 10,
  width.breaks = NULL,
  unc = NULL,
  prd = NULL,
  prd.error = NULL,
  kappa = 2,
  R = 1000,
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_binned_stats_+3A_azi">azi</code></td>
<td>
<p>numeric. Azimuth values in degrees.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_distance">distance</code></td>
<td>
<p>numeric. the independent variable along the values in <code>azi</code>
are sorted, e.g. the plate boundary distances</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_n.breaks">n.breaks</code></td>
<td>
<p>numeric. number (greater than or equal to 2) giving the
number of equal-sized intervals into which <code>distance</code> is to be cut.
Default is 10. Will be ignored if <code>width.breaks</code> is specified.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_width.breaks">width.breaks</code></td>
<td>
<p>numeric. The width of the intervals into which <code>distance</code>
is to be cut.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_unc">unc</code></td>
<td>
<p>(optional) Uncertainties of <code>azi</code> (in degrees) acting as inverse
weighting factors for statistics.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_prd">prd</code></td>
<td>
<p>(optional) numeric. A predicted orientation in degrees.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_prd.error">prd.error</code></td>
<td>
<p>(optional) numeric. The uncertainty of the predicted
orientation in degrees.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_kappa">kappa</code></td>
<td>
<p>numeric. Concentration parameter applied for the circular mode.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_r">R</code></td>
<td>
<p>integer. Number of bootstrap iterates for estimating the error of
the dispersion.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_conf.level">conf.level</code></td>
<td>
<p>The level of confidence for confidence interval and
bootstrapped standard error of dispersion.</p>
</td></tr>
<tr><td><code id="distance_binned_stats_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="ggplot2.html#topic+cut_interval">ggplot2::cut_interval()</a></code> and [<code><a href="ggplot2.html#topic+cut_interval">ggplot2::cut_width()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble containing the <code>n</code> values for <code>azi</code>in each bin, min/median/max
distance of the bin, and the summary statistics for <code>azi</code>.
If <code>prd</code> is specified, the normal Chi-squared statistic, dispersion and its
standard error are returned as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circular_summary">circular_summary()</a></code>, <code><a href="#topic+circular_dispersion">circular_dispersion()</a></code>, and <code><a href="#topic+circular_dispersion_boot">circular_dispersion_boot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")
data("san_andreas")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
san_andreas$distance &lt;- distance_from_pb(
  x = san_andreas,
  PoR = PoR,
  pb = plate_boundary,
  tangential = TRUE
)
dat &lt;- san_andreas |&gt; cbind(PoR_shmax(san_andreas, PoR, "right"))

distance_binned_stats(dat$azi.PoR,
  distance = dat$distance, width.breaks = 1,
  unc = dat$unc, prd = 135
) |&gt; head()
</code></pre>

<hr>
<h2 id='distance_from_pb'>Distance from plate boundary</h2><span id='topic+distance_from_pb'></span>

<h3>Description</h3>

<p>Absolute distance of data points from the nearest plate boundary in degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_from_pb(x, PoR, pb, tangential = FALSE, km = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_from_pb_+3A_x">x</code></td>
<td>
<p><code>sf</code> or <code>data.frame</code> objects of the data.points in geographical coordinate system</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Pole of Rotation</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_pb">pb</code></td>
<td>
<p><code>sf</code> objects of the  plate boundary
geometries in the geographical coordinate system</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_tangential">tangential</code></td>
<td>
<p>Logical. Whether the plate boundary is a tangential
boundary (<code>TRUE</code>) or an inward and outward boundary (<code>FALSE</code>, the
default).</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_km">km</code></td>
<td>
<p>Logical. Whether the distance is expressed in kilometers
(<code>TRUE</code>) or in degrees (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="smoothr.html#topic+densify">smoothr::densify()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance to the plate boundary is the longitudinal or
latitudinal difference between the data point and the plate boundary
(along the closest latitude or longitude) for inward/outward or tangential
plate boundaries, respectively.
</p>


<h3>Value</h3>

<p>Numeric vector of the great circle distances
</p>


<h3>References</h3>

<p>Wdowinski, S. (1998). A theory of intraplate tectonics. Journal
of Geophysical Research: Solid Earth, 103(3), 5037&lt;U+2013&gt;5059.
http://dx.doi.org/10.1029/97JB03390
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
res &lt;- distance_from_pb(
  x = san_andreas, PoR = na_pa, pb = plate_boundary, tangential = TRUE
)
head(res)

res.km &lt;- distance_from_pb(
  x = san_andreas, PoR = na_pa, pb = plate_boundary, tangential = TRUE, km = TRUE
)
range(res.km)
</code></pre>

<hr>
<h2 id='distance_mod'>Normalize angular distance on a sphere distance</h2><span id='topic+distance_mod'></span>

<h3>Description</h3>

<p>Helper function to express angular distance on the sphere in
the range of 0 to 180 degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_mod(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_mod_+3A_x">x</code></td>
<td>
<p>numeric, angular distance (in degrees)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>

<hr>
<h2 id='dummy'>Plate Stress Dummy Grid</h2><span id='topic+dummy'></span><span id='topic+smallcircle_dummy'></span><span id='topic+greatcircle_dummy'></span><span id='topic+loxodrome_dummy'></span>

<h3>Description</h3>

<p>Helper functions to create a dummy grid for small circles,
great circles, and loxodromes of an Euler pole
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smallcircle_dummy(n)

greatcircle_dummy(n)

loxodrome_dummy(n, angle, cw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummy_+3A_n">n</code></td>
<td>
<p>Number of curves</p>
</td></tr>
<tr><td><code id="dummy_+3A_angle">angle</code></td>
<td>
<p>Direction of loxodromes (in degree)</p>
</td></tr>
<tr><td><code id="dummy_+3A_cw">cw</code></td>
<td>
<p>logical. Sense of loxodromes: <code>TRUE</code> for clockwise
loxodromes (right-lateral displaced plate boundaries). <code>FALSE</code> for
counterclockwise loxodromes (left-lateral displaced plate boundaries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>

<hr>
<h2 id='earth_radius'>Earth's radius in km</h2><span id='topic+earth_radius'></span>

<h3>Description</h3>

<p>IERS mean radius of Earth in km (based on WGS 84)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earth_radius()
</code></pre>


<h3>Value</h3>

<p>numeric value
</p>

<hr>
<h2 id='equivalent_rotation'>Equivalent rotation</h2><span id='topic+equivalent_rotation'></span>

<h3>Description</h3>

<p>Transforms a sequence of rotations into a new reference system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent_rotation(x, fixed, rot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equivalent_rotation_+3A_x">x</code></td>
<td>
<p>Object of class <code>"data.frame"</code> containing the Euler poles of
plate rotations:
</p>

<dl>
<dt><code>plate.rot</code></dt><dd><p>Moving plate</p>
</dd>
<dt><code>lat</code>, <code>lon</code></dt><dd><p>coordinates of Euler pole</p>
</dd>
<dt><code>angle</code></dt><dd><p>Angle of rotation</p>
</dd>
<dt><code>plate.fix</code></dt><dd><p>Fixed plate</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="equivalent_rotation_+3A_fixed">fixed</code></td>
<td>
<p>plate that will be regarded as fixed. Has to be one out of
<code>x$plate.fix</code></p>
</td></tr>
<tr><td><code id="equivalent_rotation_+3A_rot">rot</code></td>
<td>
<p>(optional) plate that will be regarded as rotating. Has to be one out of
<code>x$plate.rot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sequence of plate rotations in new reference system. Same object
class as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relative_rotation">relative_rotation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuvel1) # load the NUVEL1 rotation parameters

# all nuvel1 rotation equivalent to fixed Africa:
equivalent_rotation(nuvel1, fixed = "af")
# relative plate motion between Eurasia and India:
equivalent_rotation(nuvel1, "eu", "in")
</code></pre>

<hr>
<h2 id='est.kappa'>Concentration parameter of von Mises distribution</h2><span id='topic+est.kappa'></span>

<h3>Description</h3>

<p>Computes the maximum likelihood estimate of <code class="reqn">\kappa</code>, the concentration
parameter of a von Mises distribution, given a set of angular measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.kappa(x, w = NULL, bias = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.kappa_+3A_x">x</code></td>
<td>
<p>numeric. angles in degrees</p>
</td></tr>
<tr><td><code id="est.kappa_+3A_w">w</code></td>
<td>
<p>numeric. weightings</p>
</td></tr>
<tr><td><code id="est.kappa_+3A_bias">bias</code></td>
<td>
<p>logical parameter determining whether a bias correction is used
in the computation of the MLE. Default for bias is <code>FALSE</code> for no bias
correction.</p>
</td></tr>
<tr><td><code id="est.kappa_+3A_...">...</code></td>
<td>
<p>optional parameters passed to <code>circular_mean()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
est.kappa(rvm(100, 90, 10), w = 1 / runif(100, 0, 10))
</code></pre>

<hr>
<h2 id='euler_pole'>Euler pole object</h2><span id='topic+euler_pole'></span>

<h3>Description</h3>

<p>Creates an object of the orientation of the Euler pole axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler_pole(x, y, z = NA, geo = TRUE, angle = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euler_pole_+3A_x">x</code></td>
<td>
<p>latitude or x coordinate of Euler pole axis</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_y">y</code></td>
<td>
<p>longitude or y</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_z">z</code></td>
<td>
<p>z coordinate</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_geo">geo</code></td>
<td>
<p>logical, <code>TRUE</code> (the default) if Euler pole axis is given in
geographical coordinates (latitude, longitude). <code>FALSE</code> if given in
Cartesian coordinates (<code>x</code>, <code>y</code>, <code>z</code>)</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_angle">angle</code></td>
<td>
<p>(optional) Angle of rotation in degrees (CCW rotation if angle
is positive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"euler.pole"</code> containing the Euler pole
axis in both geographical and Cartesian coordinates and the angle of rotation
in radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euler_pole(90, 0, angle = 45)
euler_pole(0, 0, 1, geo = FALSE)
</code></pre>

<hr>
<h2 id='euler_to_Q4'>Quaternion from Euler angle-axis representation for rotations</h2><span id='topic+euler_to_Q4'></span>

<h3>Description</h3>

<p>Quaternion from Euler angle-axis representation for rotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler_to_Q4(x, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euler_to_Q4_+3A_x">x</code></td>
<td>
<p><code>"euler.pole"</code> object</p>
</td></tr>
<tr><td><code id="euler_to_Q4_+3A_normalize">normalize</code></td>
<td>
<p>logical. Whether a quaternion normalization should be applied (TRUE) or not (FALSE, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>

<hr>
<h2 id='get_azimuth'>Azimuth Between two Points</h2><span id='topic+get_azimuth'></span>

<h3>Description</h3>

<p>Calculate initial bearing (or forward azimuth/direction) to go
from point <code>a</code> to point <code>b</code> following great circle arc on a
sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_azimuth(lat_a, lon_a, lat_b, lon_b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_azimuth_+3A_lat_a">lat_a</code>, <code id="get_azimuth_+3A_lat_b">lat_b</code></td>
<td>
<p>Numeric. Latitudes of a and b (in degrees).</p>
</td></tr>
<tr><td><code id="get_azimuth_+3A_lon_a">lon_a</code>, <code id="get_azimuth_+3A_lon_b">lon_b</code></td>
<td>
<p>Numeric. Longitudes of a and b (in degrees).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+get_azimuth">get_azimuth()</a></code> is based on the spherical law of tangents.
This formula is for the initial bearing (sometimes referred to as
forward azimuth) which if followed in a straight line along a great circle
arc will lead from the start point <code>a</code> to the end point <code>b</code>.
</p>
<p style="text-align: center;"><code class="reqn">\theta = \arctan2 (\sin \Delta\lambda
\cos\psi_2, \cos\psi_1 \sin\psi_1-\sin\psi_1 \cos\psi_2 \cos\Delta\lambda)</code>
</p>

<p>where  <code class="reqn">\psi_1, \lambda_1</code> is the start point, <code class="reqn">\psi_2</code>,
<code class="reqn">\lambda_2</code> the end point (<code class="reqn">\Delta\lambda</code> is the difference in
longitude).
</p>


<h3>Value</h3>

<p>numeric. Azimuth in degrees
</p>


<h3>References</h3>

<p><a href="http://www.movable-type.co.uk/scripts/latlong.html">http://www.movable-type.co.uk/scripts/latlong.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>berlin &lt;- c(52.517, 13.4) # Berlin
tokyo &lt;- c(35.7, 139.767) # Tokyo
get_azimuth(berlin[1], berlin[2], tokyo[1], tokyo[2])
</code></pre>

<hr>
<h2 id='get_distance'>Helper function to Distance from plate boundary</h2><span id='topic+get_distance'></span>

<h3>Description</h3>

<p>Helper function to Distance from plate boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance(lon, lat, pb.coords, tangential, km)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_distance_+3A_lon">lon</code>, <code id="get_distance_+3A_lat">lat</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="get_distance_+3A_pb.coords">pb.coords</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="get_distance_+3A_tangential">tangential</code>, <code id="get_distance_+3A_km">km</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+distance_from_pb">distance_from_pb()</a></code>
</p>

<hr>
<h2 id='get_projected_pb_strike'>Helper function to get Distance from plate boundary</h2><span id='topic+get_projected_pb_strike'></span>

<h3>Description</h3>

<p>Helper function to get Distance from plate boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_projected_pb_strike(lon, lat, pb.coords, pb.bearing, tangential)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_projected_pb_strike_+3A_lon">lon</code>, <code id="get_projected_pb_strike_+3A_lat">lat</code>, <code id="get_projected_pb_strike_+3A_pb.bearing">pb.bearing</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="get_projected_pb_strike_+3A_pb.coords">pb.coords</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="get_projected_pb_strike_+3A_tangential">tangential</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+projected_pb_strike">projected_pb_strike()</a></code>
</p>

<hr>
<h2 id='get_relrot'>Helper function to Equivalent rotation</h2><span id='topic+get_relrot'></span>

<h3>Description</h3>

<p>Helper function to Equivalent rotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_relrot(plate.rot, lat, lon, angle, fixed, fixed.ep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_relrot_+3A_plate.rot">plate.rot</code>, <code id="get_relrot_+3A_fixed">fixed</code></td>
<td>
<p>character or numeric</p>
</td></tr>
<tr><td><code id="get_relrot_+3A_lat">lat</code>, <code id="get_relrot_+3A_lon">lon</code>, <code id="get_relrot_+3A_angle">angle</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="get_relrot_+3A_fixed.ep">fixed.ep</code></td>
<td>
<p>data.frame</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+equivalent_rotation">equivalent_rotation()</a></code>
</p>

<hr>
<h2 id='import_WSM2016'>World Stress Map Database (WSM) Release 2016</h2><span id='topic+import_WSM2016'></span><span id='topic+download_WSM2016'></span><span id='topic+load_WSM2016'></span>

<h3>Description</h3>

<p>Download WSM2016 database from the GFZ sever and applies optional filters.
If <code>destdir</code> is specified, the data can be reloaded in a later R session
using <code>load_WSM2016()</code> using the same arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_WSM2016(destdir = tempdir(), load = TRUE, ...)

load_WSM2016(
  file,
  quality = c("A", "B", "C", "D", "E"),
  lat_range = c(-90, 90),
  lon_range = c(-180, 180),
  depth_range = c(-Inf, Inf),
  method = c("BO", "BOC", "BOT", "BS", "DIF", "FMA", "FMF", "FMS", "GFI", "GFM", "GFS",
    "GVA", "HF", "HFG", "HFM", "HFP", "OC", "PC", "SWB", "SWL", "SWS"),
  regime = c("N", "NS", "T", "TS", "S", NA)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_WSM2016_+3A_destdir">destdir</code></td>
<td>
<p>where to save files, defaults to <code><a href="base.html#topic+tempfile">base::tempdir()</a></code>,
<code><a href="base.html#topic+getwd">base::getwd()</a></code> is also possible.</p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_load">load</code></td>
<td>
<p><code>TRUE</code> load the dataset into R, <code>FALSE</code> return the
file name of the downloaded object.</p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_...">...</code></td>
<td>
<p>(optional) arguments passed to <code><a href="#topic+load_WSM2016">load_WSM2016()</a></code></p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from.</p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_quality">quality</code></td>
<td>
<p>a character vectors containing the quality levels to be
included. Includes all quality ranks (A-E) by default.</p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_lat_range">lat_range</code>, <code id="import_WSM2016_+3A_lon_range">lon_range</code></td>
<td>
<p>two-element numeric vectors giving the range of
latitudes and longitudes (in degrees).</p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_depth_range">depth_range</code></td>
<td>
<p>two-element numeric vectors giving the depth interval
(in km)</p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_method">method</code></td>
<td>
<p>a character vectors containing the methods of stress inversion
to be included. Includes all methods by default. See WSM2016 manual for used
acronyms.</p>
</td></tr>
<tr><td><code id="import_WSM2016_+3A_regime">regime</code></td>
<td>
<p>a character vectors containing the stress regimes to be
included. Acronyms: <code>"N"</code> - normal, <code>"T"</code> - thrust, <code>"S"</code> - strike-slip,
<code>"NS"</code> - oblique normal, <code>"TS"</code> - oblique thrust, and <code>NA</code> - unknown faulting</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object of and the parsed numeric uncertainty (<code>unc</code>) based on
the reported standard deviation and the quality rank. If <code>load=FALSE</code>,
the path to the downloaded file is returned.
</p>


<h3>Note</h3>

<p>Because of R-compatibility and easy readability reasons, the downloaded
dataset is a modified version of the original, WSM server version:
All column names have been changed from uppercase (in the original dataset) to
lowercase characters.
Unknown azimuth values are represented by <code>NA</code> values instead of <code>999</code> in
the original.
Unknown regimes are represented by <code>NA</code> instead of &quot;U&quot; in the original.
</p>


<h3>Source</h3>

<p><a href="https://datapub.gfz-potsdam.de/download/10.5880.WSM.2016.001/wsm2016.csv">https://datapub.gfz-potsdam.de/download/10.5880.WSM.2016.001/wsm2016.csv</a>
</p>


<h3>References</h3>

<p>Heidbach, O., M. Rajabi, X. Cui, K. Fuchs, B. M&lt;U+00FC&gt;ller, J.
Reinecker, K. Reiter, M. Tingay, F. Wenzel, F. Xie, M. O. Ziegler,
M.-L. Zoback, and M. D. Zoback (2018): The World Stress Map database
release 2016: Crustal stress pattern across scales. <em>Tectonophysics</em>,
<strong>744</strong>, 484-498, <a href="https://doi.org/10.1016/j.tecto.2018.07.007">doi:10.1016/j.tecto.2018.07.007</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
download_WSM2016(
  quality = c("A", "B", "C"), lat_range = c(51, 72),
  lon_range = c(-180, -130), depth_range = c(0, 10), method = "FMS"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='is.euler'>Check if object is euler.pole</h2><span id='topic+is.euler'></span>

<h3>Description</h3>

<p>Check if object is euler.pole
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.euler(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.euler_+3A_x">x</code></td>
<td>
<p>object of class <code>"euler.pole"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is.Q4'>Check if object is quaternion</h2><span id='topic+is.Q4'></span>

<h3>Description</h3>

<p>Check if object is quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Q4(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.Q4_+3A_x">x</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='kernel_dispersion'>Adaptive Kernel Dispersion</h2><span id='topic+kernel_dispersion'></span><span id='topic+dispersion_grid'></span>

<h3>Description</h3>

<p>Stress field and wavelength analysis using circular dispersion
(or other statistical estimators for dispersion)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_dispersion(
  x,
  stat = c("dispersion", "nchisq", "rayleigh"),
  grid = NULL,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2.5,
  min_data = 3,
  threshold = 1,
  arte_thres = 200,
  dist_threshold = 0.1,
  R_range = seq(100, 2000, 100),
  ...
)

dispersion_grid(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_dispersion_+3A_x">x</code></td>
<td>
<p><code>sf</code> object containing
</p>

<dl>
<dt>azi</dt><dd><p>Azimuth in degree</p>
</dd>
<dt>unc</dt><dd><p>Uncertainties of azimuth in degree</p>
</dd>
<dt>prd</dt><dd><p>Predicted value for azimuth</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_stat">stat</code></td>
<td>
<p>The measurement of dispersion to be calculated. Either
<code>"dispersion"</code> (default), <code>"nchisq"</code>, or <code>"rayleigh"</code> for circular
dispersion, normalized Chi-squared test statistic, or Rayleigh test
statistic.</p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_grid">grid</code></td>
<td>
<p>(optional) Point object of class <code>sf</code>.</p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_lon_range">lon_range</code>, <code id="kernel_dispersion_+3A_lat_range">lat_range</code></td>
<td>
<p>(optional) numeric vector specifying the minimum
and maximum longitudes and latitudes (are ignored if <code>"grid"</code> is specified).</p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_gridsize">gridsize</code></td>
<td>
<p>Numeric. Target spacing of the regular grid in decimal
degree. Default is 2.5. (is ignored if <code>"grid"</code> is specified)</p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_min_data">min_data</code></td>
<td>
<p>Integer. Minimum number of data per bin. Default is <code>3</code></p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. Threshold for stat value (default is <code>1</code>)</p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_arte_thres">arte_thres</code></td>
<td>
<p>Numeric. Maximum distance (in km) of the grid point to the
next data point. Default is 200</p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_dist_threshold">dist_threshold</code></td>
<td>
<p>Numeric. Distance weight to prevent overweight of data
nearby (<code>0</code> to <code>1</code>). Default is <code>0.1</code></p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_r_range">R_range</code></td>
<td>
<p>Numeric value or vector specifying the (adaptive) kernel
half-width(s) as search radius (in km). Default is <code>seq(50, 1000, 50)</code></p>
</td></tr>
<tr><td><code id="kernel_dispersion_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="#topic+dist_greatcircle">dist_greatcircle()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object containing
</p>

<dl>
<dt>lon,lat</dt><dd><p>longitude and latitude in degree</p>
</dd>
<dt>stat</dt><dd><p>output of function defined in <code>stat</code></p>
</dd>
<dt>R</dt><dd><p>The rearch radius in km.</p>
</dd>
<dt>mdr</dt><dd><p>Mean distance of datapoints per search radius</p>
</dd>
<dt>N</dt><dd><p>Number of data points in search radius</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>dispersion_grid()</code> was renamed to <code>kernel_dispersion()</code> to create
a more consistent API.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circular_dispersion">circular_dispersion()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>, <code><a href="#topic+rayleigh_test">rayleigh_test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
san_andreas_por &lt;- san_andreas
san_andreas_por$azi &lt;- PoR_shmax(san_andreas, PoR, "right")$azi.PoR
san_andreas_por$prd &lt;- 135
kernel_dispersion(san_andreas_por)
</code></pre>

<hr>
<h2 id='kuiper_test'>Kuiper Test of Circular Uniformity</h2><span id='topic+kuiper_test'></span>

<h3>Description</h3>

<p>Kuiper's test statistic is a rotation-invariant Kolmogorov-type test statistic.
The critical values of a modified Kuiper's test statistic are used according
to the tabulation given in Stephens (1970).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kuiper_test(x, alpha = 0, axial = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kuiper_test_+3A_x">x</code></td>
<td>
<p>numeric vector containing the circular data which are expressed in degrees</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the test. Valid levels are <code>0.01</code>, <code>0.05</code>, and <code>0.1</code>.
This argument may be omitted (<code>NULL</code>, the default), in which case, a range for the p-value will be returned.</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or circular, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_quiet">quiet</code></td>
<td>
<p>logical. Prints the test's decision.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>statistic &gt; p.value</code>, the null hypothesis is rejected.
If not, randomness (uniform distribution) cannot be excluded.
</p>


<h3>Value</h3>

<p>list containing the test statistic <code>statistic</code> and the significance
level <code>p.value</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Mardia and Jupp (2001), pp. 93
pidgeon_homing &lt;- c(55, 60, 65, 95, 100, 110, 260, 275, 285, 295)
kuiper_test(pidgeon_homing, alpha = .05)

# San Andreas Fault Data:
data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
kuiper_test(sa.por$azi.PoR, alpha = .05)
</code></pre>

<hr>
<h2 id='line_azimuth'>Extract azimuths of line segments</h2><span id='topic+line_azimuth'></span><span id='topic+lines_azimuths'></span>

<h3>Description</h3>

<p>Extract azimuths of line segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_azimuth(x, warn = TRUE)

lines_azimuths(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line_azimuth_+3A_x">x</code></td>
<td>
<p>sf object of type <code>"LINESTRING"</code> or <code>"MULTILINESTRING"</code></p>
</td></tr>
<tr><td><code id="line_azimuth_+3A_warn">warn</code></td>
<td>
<p>logical; if <code>TRUE</code>, warn if <code>"MULTILINESTRING"</code> (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to perform <code>line_azimuth()</code> on single line objects, i.e.
type <code>"LINESTRING"</code>, instead of <code>"MULTILINESTRING"</code>. This is because the azimuth
of the last point of a line will be calculated to the first point of the
next line otherwise. This will cause a warning message (if <code>warn = TRUE</code>).
For <code>"MULTILINESTRING"</code> objects, use <code>lines_azimuths()</code>.
</p>


<h3>Value</h3>

<p>sf object of type <code>"POINT"</code> with the columns and entries of the first row of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")

# one line:
subset(plates, pair == "af-eu") |&gt;
  smoothr::densify() |&gt;
  line_azimuth()

# multiple lines:
lines_azimuths(plates[1:5, ])
</code></pre>

<hr>
<h2 id='mean_resultant_length'>Mean Resultant Length</h2><span id='topic+mean_resultant_length'></span>

<h3>Description</h3>

<p>Measure of spread around the circle. It should be noted that:
If R=0, then the data is completely spread around the circle.
If R=1, the data is completely concentrated on one point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_resultant_length(x, w = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_resultant_length_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees, for which the
mean, median or standard deviation are required.</p>
</td></tr>
<tr><td><code id="mean_resultant_length_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers, of the same length as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="mean_resultant_length_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>References</h3>

<p>Mardia, K.V. (1972). Statistics of Directional Data: Probability
and Mathematical Statistics. London: Academic Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
mean_resultant_length(finland_stria, w = NULL, na.rm = FALSE) # 0.800
</code></pre>

<hr>
<h2 id='mean_SC'>Mean Cosine and Sine</h2><span id='topic+mean_SC'></span>

<h3>Description</h3>

<p>Mean Cosine and Sine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_SC(x, w = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_SC_+3A_x">x</code></td>
<td>
<p>angles in degrees</p>
</td></tr>
<tr><td><code id="mean_SC_+3A_w">w</code></td>
<td>
<p>weightings</p>
</td></tr>
<tr><td><code id="mean_SC_+3A_na.rm">na.rm</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named two element vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1)
x &lt;- rvm(100, 0, 5)
mean_SC(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='model_shmax'>Theoretical Direction of Maximum Horizontal Stress in the
geographical reference system.</h2><span id='topic+model_shmax'></span>

<h3>Description</h3>

<p>Models the direction of maximum horizontal stress
<code class="reqn">\sigma_{Hmax}</code> along great circles, small circles, and
loxodromes at a given point or points according to the relative plate motion
in the geographical coordinate reference system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_shmax(df, euler)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_shmax_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>).</p>
</td></tr>
<tr><td><code id="model_shmax_+3A_euler">euler</code></td>
<td>
<p><code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\sigma_{Hmax}</code> following <em>great circles</em> is the
(initial) bearing between the given point and the pole of relative plate
motion. <code class="reqn">\sigma_{Hmax}</code> along <em>small circles</em>, clockwise, and
counter-clockwise <em>loxodromes</em> is 90<code class="reqn">^{\circ}</code>,
+45<code class="reqn">^{\circ}</code>, and 135<code class="reqn">^{\circ}</code>
(-45<code class="reqn">^{\circ}</code>) to this great circle bearing, respectively.
</p>


<h3>Value</h3>

<p><code>data.frame</code>
</p>

<dl>
<dt>gc</dt><dd><p>Azimuth of modeled <code class="reqn">\sigma_{Hmax}</code> following
great circles</p>
</dd>
<dt>sc</dt><dd><p>Small circles</p>
</dd>
<dt>ld.cw</dt><dd><p>Clockwise loxodromes</p>
</dd>
<dt>ld.ccw</dt><dd><p>Counter-clockwise loxodromes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deviation_shmax">deviation_shmax()</a></code> to compute the deviation of the modeled direction
from the observed direction of <code class="reqn">\sigma_{Hmax}</code>.
<code><a href="#topic+PoR_shmax">PoR_shmax()</a></code> to calculate the azimuth of <code class="reqn">\sigma_{Hmax}</code>
in the pole of rotation reference system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
euler &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

# the point where we mant to model the SHmax direction:
point &lt;- data.frame(lat = 45, lon = 20)

model_shmax(point, euler)
</code></pre>

<hr>
<h2 id='norm_chisq'>Normalized Chi-Squared Test for Circular Data</h2><span id='topic+norm_chisq'></span>

<h3>Description</h3>

<p>A quantitative comparison between the predicted and observed directions of
<code class="reqn">\sigma_{Hmax}</code> is obtained by the calculation of the average
azimuth and by a normalized <code class="reqn">\chi^2</code> test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_chisq(obs, prd, unc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_chisq_+3A_obs">obs</code></td>
<td>
<p>Numeric vector containing the observed azimuth of
<code class="reqn">\sigma_{Hmax}</code>,
same length as <code>prd</code></p>
</td></tr>
<tr><td><code id="norm_chisq_+3A_prd">prd</code></td>
<td>
<p>Numeric vector containing the modeled azimuths of
<code class="reqn">\sigma_{Hmax}</code>, i.e.
the return object from <code>model_shmax()</code></p>
</td></tr>
<tr><td><code id="norm_chisq_+3A_unc">unc</code></td>
<td>
<p>Uncertainty of observed <code class="reqn">\sigma_{Hmax}</code>, either a
numeric vector or a number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalized <code class="reqn">\chi^2</code> test is
</p>
<p style="text-align: center;"><code class="reqn"> {Norm} \chi^2_i =
 = \frac{
   \sum^M_{i = 1} \left( \frac{\alpha_i - \alpha_{{predict}}}{\sigma_i}
   \right) ^2}
   {\sum^M_{i = 1} \left( \frac{90}{\sigma_i} \right) ^2 }</code>
</p>

<p>The value of the chi-squared test statistic is a number between 0 and 1
indicating the quality of the predicted <code class="reqn">\sigma_{Hmax}</code>
directions. Low values
(<code class="reqn">\le 0.15</code>) indicate good agreement,
high values (<code class="reqn">&gt; 0.7</code>) indicate a systematic misfit between predicted and
observed <code class="reqn">\sigma_{Hmax}</code> directions.
</p>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>References</h3>

<p>Wdowinski, S., 1998, A theory of intraplate
tectonics. <em>Journal of Geophysical Research: Solid Earth</em>, <strong>103</strong>,
5037-5059, doi: 10.1029/97JB03390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to
# Pacific plate
data(san_andreas)
point &lt;- data.frame(lat = 45, lon = 20)
prd &lt;- model_shmax(point, PoR)
norm_chisq(obs = c(50, 40, 42), prd$sc, unc = c(10, NA, 5))

data(san_andreas)
prd2 &lt;- PoR_shmax(san_andreas, PoR, type = "right")
norm_chisq(obs = prd2$azi.PoR, 135, unc = san_andreas$unc)
</code></pre>

<hr>
<h2 id='normalize_Q4'>Quaternion normalization</h2><span id='topic+normalize_Q4'></span>

<h3>Description</h3>

<p>Quaternion normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_Q4(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_Q4_+3A_q">q</code></td>
<td>
<p>quaternion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>

<hr>
<h2 id='nuvel1'>NUVEL-1 Global model of current plate motions</h2><span id='topic+nuvel1'></span>

<h3>Description</h3>

<p>NNR-NUVEL-1 global model of current plate motions by DeMets et al. 1990
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('nuvel1')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code>
</p>

<dl>
<dt>plate.name</dt><dd><p>The rotating plate</p>
</dd>
<dt>plate.rot</dt><dd><p>The abbreviation of the plate's name</p>
</dd>
<dt>lat,lon</dt><dd><p>Coordinates of the Pole of Rotation</p>
</dd>
<dt>angle</dt><dd><p>The amount of rotation (angle in 1 Myr)</p>
</dd>
<dt>plate.fix</dt><dd><p>The anchored plate, i.e. <code>plate.rot</code> moves relative
to  <code>plate.fix</code></p>
</dd>
<dt>source</dt><dd><p>Reference to underlying study</p>
</dd>
</dl>



<h3>References</h3>

<p>DeMets, C., Gordon, R. G., Argus, D. F., &amp; Stein, S. (1990).
Current plate motions. <em>Geophysical Journal International</em>, <strong>101</strong>(2),
425-478. <a href="https://doi.org/10.1111/j.1365-246X.1990.tb06579.x">doi:10.1111/j.1365-246X.1990.tb06579.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
head("nuvel1")
</code></pre>

<hr>
<h2 id='nuvel1_plates'>Plate Boundaries on the Earth</h2><span id='topic+nuvel1_plates'></span>

<h3>Description</h3>

<p>Global set of present plate boundaries on the Earth based on NUVEL-1 model by
DeMets et al. 1990
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('nuvel1_plates')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>
</p>


<h3>References</h3>

<p>DeMets, C., Gordon, R. G., Argus, D. F., &amp; Stein, S. (1990).
Current plate motions. <em>Geophysical Journal International</em>, <strong>101</strong>(2),
425-478. <a href="https://doi.org/10.1111/j.1365-246X.1990.tb06579.x">doi:10.1111/j.1365-246X.1990.tb06579.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1_plates")
head("nuvel1_plates")
</code></pre>

<hr>
<h2 id='parse_wsm'>Numerical values to World Stress Map Quality Ranking</h2><span id='topic+parse_wsm'></span><span id='topic+parse_wsm_quality'></span><span id='topic+quantise_wsm_quality'></span>

<h3>Description</h3>

<p>Assigns numeric values of the precision (sd.) of each measurement to the
categorical quality ranking of the World Stress Map (A, B, C, D, E).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_wsm_quality(x)

quantise_wsm_quality(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_wsm_+3A_x">x</code></td>
<td>
<p>Either a string or a character/factor vector of WSM quality ranking</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"numeric"</code>. the standard deviation of stress azimuth
</p>


<h3>Note</h3>

<p><code>quantise_wsm_quality()</code> was renamed to <code>parse_wsm_quality()</code> to create
a more consistent API.
</p>


<h3>References</h3>

<p>Heidbach, O., Barth, A., M&lt;U+00FC&gt;ller, B., Reinecker, J.,
Stephansson, O., Tingay, M., Zang, A. (2016). WSM quality
ranking scheme, database description and analysis guidelines for stress
indicator. <em>World Stress Map Technical Report</em> <strong>16-01</strong>, GFZ German Research
Centre for Geosciences. <a href="https://doi.org/10.2312/wsm.2016.001">doi:10.2312/wsm.2016.001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_wsm_quality(c("A", "B", "C", "D", NA, "E"))
data("san_andreas")
parse_wsm_quality(san_andreas$quality)
</code></pre>

<hr>
<h2 id='pb2002'>Global model of current plate motions</h2><span id='topic+pb2002'></span>

<h3>Description</h3>

<p>PB2002 global model of current plate motions by Bird 2003
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('pb2002')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code>
</p>

<dl>
<dt>plate.name</dt><dd><p>The rotating plate</p>
</dd>
<dt>plate.rot</dt><dd><p>The abbreviation of the plate's name</p>
</dd>
<dt>lat,lon</dt><dd><p>Coordinates of the Pole of Rotation</p>
</dd>
<dt>angle</dt><dd><p>The amount of rotation (angle in 1 Myr)</p>
</dd>
<dt>plate.fix</dt><dd><p>The anchored plate, i.e. <code>plate.rot</code> moves relative
to <code>plate.fix</code></p>
</dd>
<dt>source</dt><dd><p>Reference to underlying study</p>
</dd>
</dl>



<h3>References</h3>

<p>Bird, P. (2003), An updated digital model of plate boundaries,
<em>Geochem. Geophys. Geosyst.</em>, <strong>4</strong>, 1027, doi: 10.1029/2001GC000252, 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pb2002")
head("pb2002")
</code></pre>

<hr>
<h2 id='plates'>Plate Boundaries on the Earth</h2><span id='topic+plates'></span>

<h3>Description</h3>

<p>Global set of present plate boundaries on the Earth based on PB2002 model by
Bird (2003). Contains the plate boundary displacement types such as inward,
outward, or tangentially displacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('plates')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>
</p>


<h3>References</h3>

<p>Bird, P. (2003), An updated digital model of plate boundaries,
<em>Geochem. Geophys. Geosyst.</em>, <strong>4</strong>, 1027, doi: 10.1029/2001GC000252, 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
head("plates")
</code></pre>

<hr>
<h2 id='plot_density'>Circular Density Plot</h2><span id='topic+plot_density'></span>

<h3>Description</h3>

<p>Plot the multiples of a von Mises density distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_density(
  x,
  kappa = NULL,
  axial = TRUE,
  n = 512,
  norm.density = FALSE,
  ...,
  scale = 1.1,
  shrink = 1,
  add = TRUE,
  main = NULL,
  labels = TRUE,
  at = seq(0, 360 - 45, 45),
  cborder = TRUE,
  grid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_density_+3A_x">x</code></td>
<td>
<p>Data to be plotted. A numeric vector containing angles (in degrees).</p>
</td></tr>
<tr><td><code id="plot_density_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter for the von Mises distribution.
Small kappa gives smooth density lines. Will be estimated using <code><a href="#topic+est.kappa">est.kappa()</a></code> if not provided.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="plot_density_+3A_n">n</code></td>
<td>
<p>the number of equally spaced points at which the density is to be estimated.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_norm.density">norm.density</code></td>
<td>
<p>logical. Normalize the density?</p>
</td></tr>
<tr><td><code id="plot_density_+3A_...">...</code></td>
<td>
<p>Further graphical parameters may also be supplied as arguments.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_scale">scale</code></td>
<td>
<p>radius of plotted circle. Default is <code>1.1</code>.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted function. Default is 1.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_add">add</code></td>
<td>
<p>logical. Add to existing plot? (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="plot_density_+3A_main">main</code></td>
<td>
<p>Character string specifying the title of the plot.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_labels">labels</code></td>
<td>
<p>Either a logical value indicating whether to plot labels
next to the tick marks, or a vector of labels for the tick marks.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_at">at</code></td>
<td>
<p>Optional vector of angles at which tick marks should be plotted.
Set <code>at=numeric(0)</code> to suppress tick marks.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_cborder">cborder</code></td>
<td>
<p>logical. Border of rose plot.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_grid">grid</code></td>
<td>
<p>logical. Whether a grid should be added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot or calculated densities as numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dvm">dvm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the rose histogram first:
rose(san_andreas$azi, dots = TRUE, stack = TRUE, dot_cex = 0.5, dot_pch = 21)

# Add density curve outside of main plot:
plot_density(san_andreas$azi,
  kappa = 100, col = "#51127CFF", shrink = 1.5,
  norm.density = FALSE
)

# Plot density inside plot only:
plot_density(san_andreas$azi,
  kappa = 100, col = "#51127CFF", add = FALSE,
  scale = .5, shrink = 2, norm.density = TRUE, grid = TRUE
)
</code></pre>

<hr>
<h2 id='plot_points'>Add Points to a Circular Plot</h2><span id='topic+plot_points'></span>

<h3>Description</h3>

<p>Add points to a plot of circular data points on the current graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_points(
  x,
  axial = TRUE,
  stack = FALSE,
  binwidth = 1,
  cex = 1,
  sep = 0.025,
  jitter_factor = 0,
  ...,
  scale = 1.1,
  add = TRUE,
  main = NULL,
  labels = TRUE,
  at = seq(0, 360 - 45, 45),
  cborder = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_points_+3A_x">x</code></td>
<td>
<p>Data to be plotted. A numeric vector containing angles (in degrees).</p>
</td></tr>
<tr><td><code id="plot_points_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="plot_points_+3A_stack">stack</code></td>
<td>
<p>logical: if <code>TRUE</code>, points are stacked on the perimeter of the
circle.
Otherwise, all points are plotted on the perimeter of the circle. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_binwidth">binwidth</code></td>
<td>
<p>numeric. Bin width (in degrees) for the stacked dot plots.
ignored when <code>stack==FALSE</code>. Is set to <code>1</code> degree by default.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_cex">cex</code></td>
<td>
<p>character (or symbol) expansion: a numerical vector. This works as
a multiple of <code>par("cex")</code>.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_sep">sep</code></td>
<td>
<p>constant used to specify the distance between stacked points, if
<code>stack==TRUE</code> or in the case of more than one dataset. Default is <code>0.025</code>;
smaller values will create smaller spaces.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_jitter_factor">jitter_factor</code></td>
<td>
<p>numeric. Adds a small amount of random variation to the
location of each points along radius that is added to <code>scale</code>. Jitter is
ignored when <code>stack==TRUE</code>). If <code>0</code>, no jitter is added (by default); if
negative, the points fall into the circle.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_...">...</code></td>
<td>
<p>Further graphical parameters may also be supplied as arguments.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_scale">scale</code></td>
<td>
<p>radius of plotted circle. Default is <code>1.1</code>.
Larger values shrink the circle, while smaller values enlarge the circle.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_add">add</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="plot_points_+3A_main">main</code></td>
<td>
<p>Character string specifying the title of the plot.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_labels">labels</code></td>
<td>
<p>Either a logical value indicating whether to plot labels
next to the tick marks, or a vector of labels for the tick marks.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_at">at</code></td>
<td>
<p>Optional vector of angles at which tick marks should be plotted.
Set <code>at=numeric(0)</code> to suppress tick marks.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_cborder">cborder</code></td>
<td>
<p>logical. Border of rose plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with information on the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvm(100, mean = 90, k = 5)

# plot poinit without jitter
plot_points(x, add = FALSE)

# with some jitter
plot_points(x, jitter_factor = .2, add = FALSE)

# stacked dots:
plot_points(x, stack = TRUE, binwidth = 3, add = FALSE)
</code></pre>

<hr>
<h2 id='PoR_azi'>Azimuth Conversion from Geographical to PoR Coordinate Reference System</h2><span id='topic+PoR_azi'></span><span id='topic+PoR_azimuth'></span><span id='topic+PoR_shmax'></span>

<h3>Description</h3>

<p>Transforms azimuths and models the direction of maximum horizontal stress
<code class="reqn">\sigma_{Hmax}</code> in the Euler pole (Pole of Rotation)
coordinate reference system. When type of plate boundary is given, it also
gives the deviation from the theoretically predicted azimuth of
<code class="reqn">\sigma_{Hmax}</code>, the circular distance, and the normalized
<code class="reqn">\chi^2</code> statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_azimuth(x, PoR, axial = TRUE)

PoR_shmax(x, PoR, type = c("none", "in", "out", "right", "left"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoR_azi_+3A_x">x</code></td>
<td>
<p><code>sf</code> object or a <code>data.frame</code> containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>). <code>x</code> must contain the direction of
<code class="reqn">\sigma_{Hmax}</code> as column <code>azi</code> and its standard deviation
as <code>unc</code> (the latter is optional)</p>
</td></tr>
<tr><td><code id="PoR_azi_+3A_por">PoR</code></td>
<td>
<p><code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler  pole</p>
</td></tr>
<tr><td><code id="PoR_azi_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the azimuth is axial (0-180) or directional (0-360).</p>
</td></tr>
<tr><td><code id="PoR_azi_+3A_type">type</code></td>
<td>
<p>Character. Type of plate boundary (optional). Can be
<code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively. If <code>"none"</code> (the default), only
the PoR-equivalent azimuth is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The azimuth of <code class="reqn">\sigma_{Hmax}</code> in the pole of rotation
reference system is
approximate 0 (or 180), 45, 90, 135 degrees if the stress is sourced by an
outward, sinistral, inward, or dextral moving plate boundary, respectively.
directions of <code class="reqn">\sigma_{Hmax}</code> with respect to the four
plate boundary types.
</p>


<h3>Value</h3>

<p><code>PoR_azimuth</code> returns numeric vector of the transformed azimuth in degrees.
<code>PoR_shmax</code> returns either a numeric vector of the azimuths in the
transformed coordinate system (in degrees), or a <code>"data.frame"</code> with
</p>

<dl>
<dt><code>azi.PoR</code></dt><dd><p>the transformed azimuths (in degrees),</p>
</dd>
<dt><code>prd</code></dt><dd><p>the predicted azimuths (in degrees),</p>
</dd>
<dt><code>dev</code></dt><dd><p>the deviation between the transformed and the predicted azimuth (in degrees),</p>
</dd>
<dt><code>nchisq</code></dt><dd><p>the Norm <code class="reqn">\chi^2</code> test statistic, and</p>
</dd>
<dt><code>cdist</code></dt><dd><p>the angular distance between the transformed and the predicted azimuth.</p>
</dd>
</dl>



<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_shmax">model_shmax()</a></code> to compute the theoretical direction of
<code class="reqn">\sigma_{Hmax}</code> in the geographical reference system.
<code><a href="#topic+deviation_shmax">deviation_shmax()</a></code> to compute the deviation of the modeled direction
from the observed direction of <code class="reqn">\sigma_{Hmax}</code>.
<code><a href="#topic+norm_chisq">norm_chisq()</a></code> to calculate the normalized <code class="reqn">\chi^2</code>
statistics. <code><a href="#topic+circular_distance">circular_distance()</a></code> to calculate the angular distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("san_andreas")
res &lt;- PoR_shmax(san_andreas, PoR, type = "right")
head(res)
</code></pre>

<hr>
<h2 id='PoR_coordinates'>Coordinates of the Pole of Rotation Reference System</h2><span id='topic+PoR_coordinates'></span>

<h3>Description</h3>

<p>Retrieve the PoR equivalent coordinates of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_coordinates(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoR_coordinates_+3A_x">x</code></td>
<td>
<p><code>sf</code> or <code>data.frame</code> containing lat and lon coordinates
(<code>lat</code>, <code>lon</code>)</p>
</td></tr>
<tr><td><code id="PoR_coordinates_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+PoR_coordinates">PoR_coordinates()</a></code> returns <code>data.frame</code> with the PoR coordinates
(<code>lat.PoR</code>, <code>lon.PoR</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
data("san_andreas")

# coordinates from sf object
san_andreas.por_sf &lt;- PoR_coordinates(san_andreas, por)
head(san_andreas.por_sf)

# coordinates from data.frame
san_andreas.por_df &lt;- PoR_coordinates(sf::st_drop_geometry(san_andreas), por)
head(san_andreas.por_df)
</code></pre>

<hr>
<h2 id='PoR_crs'>PoR coordinate reference system</h2><span id='topic+PoR_crs'></span>

<h3>Description</h3>

<p>Create the reference system transformed in Euler pole
coordinate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_crs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoR_crs_+3A_x">x</code></td>
<td>
<p><code>"data.frame"</code> or <code>"euler.pole"</code> object containing the
geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PoR coordinate reference system is oblique transformation of the
geographical coordinate system with the Euler pole coordinates being the the
translation factors.
</p>


<h3>Value</h3>

<p>Object of class <code>crs</code>
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
PoR_crs(por)
</code></pre>

<hr>
<h2 id='PoR_distance'>Distance to Pole of Rotation</h2><span id='topic+PoR_distance'></span>

<h3>Description</h3>

<p>Retrieve the (angular) distance to the PoR (Euler pole).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_distance(x, PoR, FUN = orthodrome)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoR_distance_+3A_x">x</code></td>
<td>
<p><code>sf</code> or <code>data.frame</code> containing lat and lon coordinates
(<code>lat</code>, <code>lon</code>)</p>
</td></tr>
<tr><td><code id="PoR_distance_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
<tr><td><code id="PoR_distance_+3A_fun">FUN</code></td>
<td>
<p>function to calculate the great-circle distance.
<code><a href="#topic+orthodrome">orthodrome()</a></code>, <code><a href="#topic+haversine">haversine()</a></code> (the default), or <code><a href="#topic+vincenty">vincenty()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
data("san_andreas")

# distance form sf object
PoR_distance(san_andreas, por)

# distance form data.frame
PoR_distance(sf::st_drop_geometry(san_andreas), por)
PoR_distance(sf::st_drop_geometry(san_andreas), por, FUN = orthodrome)
PoR_distance(sf::st_drop_geometry(san_andreas), por, FUN = vincenty)
</code></pre>

<hr>
<h2 id='PoR_map'>Map of data in Pole of Rotation reference frame</h2><span id='topic+PoR_map'></span>

<h3>Description</h3>

<p>Transforms the spatial data and azimuths into the PoR reference frame and
shows them in a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_map(
  x,
  PoR,
  pb = NULL,
  type = c("none", "in", "out", "right", "left"),
  show.deviation = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoR_map_+3A_x">x</code>, <code id="PoR_map_+3A_pb">pb</code></td>
<td>
<p><code>sf</code> objects of the data points and the plate
boundary geometries in the geographical coordinate system</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class
<code>"euler.pole"</code>
containing the geographical coordinates of the Pole of Rotation</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_type">type</code></td>
<td>
<p>Character. Type of plate boundary (optional). Can be
<code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively. If <code>"none"</code> (the default), only
the PoR-equivalent azimuth is returned.</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_show.deviation">show.deviation</code></td>
<td>
<p>logical.
Whether the data should be color-coded according to the deviation from the
prediction, or according to the stress regime? Is ignored if <code>type=='none'</code>.</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="#topic+tectonicr.colors">tectonicr.colors()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>, <code><a href="#topic+axes">axes()</a></code>, <code><a href="#topic+tectonicr.colors">tectonicr.colors()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
PoR_map(san_andreas, PoR = na_pa, pb = plate_boundary, type = "right", show.deviation = TRUE)
</code></pre>

<hr>
<h2 id='PoR_stress2grid'>Spatial Interpolation of SHmax in PoR Coordinate Reference System</h2><span id='topic+PoR_stress2grid'></span><span id='topic+PoR_stress2grid_stats'></span>

<h3>Description</h3>

<p>The data is transformed into the PoR system before the
interpolation. The interpolation grid is returned in geographical coordinates
and azimuths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_stress2grid(
  x,
  PoR,
  grid = NULL,
  PoR_grid = TRUE,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2.5,
  ...
)

PoR_stress2grid_stats(
  x,
  PoR,
  grid = NULL,
  PoR_grid = TRUE,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoR_stress2grid_+3A_x">x</code></td>
<td>
<p><code>sf</code> object containing
</p>

<dl>
<dt>azi</dt><dd><p>SHmax in degree</p>
</dd>
<dt>unc</dt><dd><p>Uncertainties of SHmax in degree</p>
</dd>
<dt>type</dt><dd><p>Methods used for the determination of the orientation of SHmax</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class
<code>"euler.pole"</code> containing the geographical coordinates of the Euler pole</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_grid">grid</code></td>
<td>
<p>(optional) Point object of class <code>sf</code>.</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_por_grid">PoR_grid</code></td>
<td>
<p>logical. Whether the grid should be generated based on the
coordinate range in the PoR (<code>TRUE</code>, the default) CRS or the geographical CRS
(<code>FALSE</code>). Is ignored if <code>grid</code> is specified.</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_lon_range">lon_range</code>, <code id="PoR_stress2grid_+3A_lat_range">lat_range</code></td>
<td>
<p>(optional) numeric vector specifying the minimum
and maximum longitudes and latitudes (are ignored if <code>"grid"</code> is specified).</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_gridsize">gridsize</code></td>
<td>
<p>Numeric. Target spacing of the regular grid in decimal
degree. Default is 2.5 (is ignored if <code>grid</code> is specified)</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+stress2grid">stress2grid()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stress field and wavelength analysis in PoR system and back-transformed
</p>


<h3>Value</h3>

<p><code>sf</code> object containing
</p>

<dl>
<dt>lon,lat</dt><dd><p>longitude and latitude in geographical CRS (in degrees)</p>
</dd>
<dt>lon.PoR,lat.PoR</dt><dd><p>longitude and latitude in PoR CRS (in degrees)</p>
</dd>
<dt>azi</dt><dd><p>geographical mean SHmax in degree</p>
</dd>
<dt>azi.PoR</dt><dd><p>PoR mean SHmax in degree</p>
</dd>
<dt>sd</dt><dd><p>Standard deviation of SHmax in degrees</p>
</dd>
<dt>R</dt><dd><p>Search radius in km</p>
</dd>
<dt>mdr</dt><dd><p>Mean distance of datapoints per search radius</p>
</dd>
<dt>N</dt><dd><p>Number of data points in search radius</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stress2grid">stress2grid()</a></code>, <code><a href="#topic+compact_grid">compact_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
PoR_stress2grid(san_andreas, PoR)

## Not run: 
PoR_stress2grid_stats(san_andreas, PoR)

## End(Not run)
</code></pre>

<hr>
<h2 id='por_transformation'>Conversion between spherical PoR to geographical coordinate system</h2><span id='topic+por_transformation'></span><span id='topic+geographical_to_PoR'></span><span id='topic+PoR_to_geographical'></span>

<h3>Description</h3>

<p>Transformation from spherical PoR to geographical coordinate system and
vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographical_to_PoR(x, PoR)

PoR_to_geographical(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="por_transformation_+3A_x">x</code></td>
<td>
<p>Can be either a <code>"data.frame"</code> containing <code>lat</code> and <code>lon</code>
coordinates of a point in the geographical CRS or the <code>lat.PoR</code>,
<code>lon.PoR</code>) of the point in the PoR CRS,
a two-column matrix containing the lat and lon coordinates,
a <code>sf</code> object, or a <code>raster</code> object.</p>
</td></tr>
<tr><td><code id="por_transformation_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of same type of <code>x</code> with the transformed coordinates. If <code>x</code>
was a <code>data.frame</code>, transformed coordinates are named <code>lat.PoR</code> and <code>lon.PoR</code> for PoR CRS,
or <code>lat</code> and <code>lon</code> for geographical CRS).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
data("san_andreas")
san_andreas.por &lt;- geographical_to_PoR(san_andreas, por)
head(san_andreas.por)
head(PoR_to_geographical(san_andreas.por, por))
</code></pre>

<hr>
<h2 id='por_transformation_df'>Conversion between spherical PoR to geographical coordinate system of data.frames</h2><span id='topic+por_transformation_df'></span><span id='topic+geographical_to_PoR_df'></span><span id='topic+PoR_to_geographical_df'></span>

<h3>Description</h3>

<p>Transformation from spherical PoR to geographical coordinate system and
vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographical_to_PoR_df(x, PoR)

PoR_to_geographical_df(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="por_transformation_df_+3A_x">x</code></td>
<td>
<p><code>"data.frame"</code> containing <code>lat</code> and <code>lon</code>
coordinates of a point in the geographical CRS or the <code>lat.PoR</code>,
<code>lon.PoR</code>) of the point in the PoR CRS.</p>
</td></tr>
<tr><td><code id="por_transformation_df_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"data.frame"</code> with the transformed coordinates
(<code>lat.PoR</code> and <code>lon.PoR</code> for PoR CRS,
or <code>lat</code> and <code>lon</code> for geographical CRS).
</p>

<hr>
<h2 id='por_transformation_quat'>Conversion between PoR to geographical coordinate system using quaternions</h2><span id='topic+por_transformation_quat'></span><span id='topic+geographical_to_PoR_quat'></span><span id='topic+PoR_to_geographical_quat'></span>

<h3>Description</h3>

<p>Helper function for the transformation from PoR to geographical coordinate
system or vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographical_to_PoR_quat(x, PoR)

PoR_to_geographical_quat(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="por_transformation_quat_+3A_x">x</code>, <code id="por_transformation_quat_+3A_por">PoR</code></td>
<td>
<p>two-column vectors containing the lat and lon coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two-element numeric vector
</p>

<hr>
<h2 id='por_transformation_sf'>Conversion between PoR to geographical coordinates of sf data</h2><span id='topic+por_transformation_sf'></span><span id='topic+PoR_to_geographical_sf'></span><span id='topic+geographical_to_PoR_sf'></span>

<h3>Description</h3>

<p>Transform spatial objects from PoR to geographical coordinate reference
system and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_to_geographical_sf(x, PoR)

geographical_to_PoR_sf(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="por_transformation_sf_+3A_x">x</code></td>
<td>
<p><code>sf</code>, <code>SpatRast</code>, or <code>Raster*</code> object of the data
points in geographical or PoR coordinate system</p>
</td></tr>
<tr><td><code id="por_transformation_sf_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PoR coordinate reference system is oblique transformation of the
geographical coordinate system with the Euler pole coordinates being the
translation factors.
</p>


<h3>Value</h3>

<p><code>sf</code> or <code>SpatRast</code> object of the data points in the
transformed geographical or PoR coordinate system
</p>

<hr>
<h2 id='PoR2Geo_azimuth'>Azimuth Conversion From PoR to Geographical Coordinate Reference System</h2><span id='topic+PoR2Geo_azimuth'></span>

<h3>Description</h3>

<p>Conversion of PoR azimuths into geographical azimuths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR2Geo_azimuth(x, PoR, axial = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoR2Geo_azimuth_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> containing the PoR equivalent azimuths
(<code>azi.PoR</code>), and either the geographical coordinates of the
point(s) or the PoR-equivalent coordinates.</p>
</td></tr>
<tr><td><code id="PoR2Geo_azimuth_+3A_por">PoR</code></td>
<td>
<p><code>data.frame</code> containing the geographical location of
the Euler pole (<code>lat</code>, <code>lon</code>)</p>
</td></tr>
<tr><td><code id="PoR2Geo_azimuth_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the azimuth is axial (0-180) or directional (0-360).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of transformed azimuths (in degrees)
</p>


<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
data("san_andreas")
san_andreas$azi.PoR &lt;- PoR_shmax(san_andreas, PoR)

# convert back to geo CRS
PoR2Geo_azimuth(san_andreas, PoR) |&gt; head()
</code></pre>

<hr>
<h2 id='PositionCenterSpoke'>Centrically aligned geom_spoke marker</h2><span id='topic+PositionCenterSpoke'></span>

<h3>Description</h3>

<p><code>"position"</code> subclass &quot;center_spoke&quot; to center
<code>ggplot::geom_spoke()</code> marker at its origin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PositionCenterSpoke
</code></pre>


<h3>Format</h3>

<p>An object of class <code>PositionCenterSpoke</code> (inherits from <code>Position</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>


<h3>Source</h3>

<p><a href="https://stackoverflow.com/questions/55474143/how-to-center-geom-spoke-around-their-origin">https://stackoverflow.com/questions/55474143/how-to-center-geom-spoke-around-their-origin</a>
</p>

<hr>
<h2 id='prd_err'>Error of Model's Prediction</h2><span id='topic+prd_err'></span>

<h3>Description</h3>

<p>The maximum error in the model's predicted azimuth given the Pole of
rotations uncertainty and distance of the data point to the pole.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prd_err(dist_PoR, sigma_PoR = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prd_err_+3A_dist_por">dist_PoR</code></td>
<td>
<p>Distance to Euler pole (great circle distance, in degree)</p>
</td></tr>
<tr><td><code id="prd_err_+3A_sigma_por">sigma_PoR</code></td>
<td>
<p>uncertainty of the position of the Pole of rotation
(in degree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector. The maximum error for azimuths prediction (in degree)
</p>


<h3>References</h3>

<p>Ramsay, J.A. Folding and fracturing of rocks. McGraw-Hill, New York, 1967.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code> and <code><a href="#topic+model_shmax">model_shmax()</a></code> for the model's prediction, and
<code><a href="#topic+orthodrome">orthodrome()</a></code> for great circle distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prd_err(67, 1)

# San Andreas example:
data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
data("san_andreas")
d &lt;- PoR_distance(san_andreas, por)
prd_err(d)
</code></pre>

<hr>
<h2 id='product_Q4'>Product of quaternions</h2><span id='topic+product_Q4'></span>

<h3>Description</h3>

<p>Helper function for multiplication of two quaternions.
Concatenation of two rotations R1 followed by R2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>product_Q4(q1, q2, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="product_Q4_+3A_q1">q1</code>, <code id="product_Q4_+3A_q2">q2</code></td>
<td>
<p>two objects of class <code>"quaternion"</code>. first rotation R1 expressed by q1 followed by second rotation R2 expressed by q2</p>
</td></tr>
<tr><td><code id="product_Q4_+3A_normalize">normalize</code></td>
<td>
<p>logical. Whether a quaternion normalization should be applied (TRUE) or not (FALSE, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>


<h3>Note</h3>

<p>Multiplication is not commutative.
</p>

<hr>
<h2 id='projected_pb_strike'>Strike of the plate boundary projected on data point</h2><span id='topic+projected_pb_strike'></span>

<h3>Description</h3>

<p>The fault's strike in the PoR CRS projected on the data point along the
predicted stress trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projected_pb_strike(x, PoR, pb, tangential = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projected_pb_strike_+3A_x">x</code>, <code id="projected_pb_strike_+3A_pb">pb</code></td>
<td>
<p><code>sf</code> objects of the data points and the plate boundary
geometries in the geographical coordinate system</p>
</td></tr>
<tr><td><code id="projected_pb_strike_+3A_por">PoR</code></td>
<td>
<p>Pole of rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
<tr><td><code id="projected_pb_strike_+3A_tangential">tangential</code></td>
<td>
<p>Logical. Whether the plate boundary is a tangential
boundary (<code>TRUE</code>) or an inward and outward boundary (<code>FALSE</code>, the
default).</p>
</td></tr>
<tr><td><code id="projected_pb_strike_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="smoothr.html#topic+densify">smoothr::densify()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful to calculate the beta angle, i.e. the angle
between SHmax direction (in PoR CRS!) and the fault's strike (in PoR CRS).
The beta angle is the same in geographical and PoR coordinates.
</p>


<h3>Value</h3>

<p>Numeric vector of the strike direction of the plate boundary
(in degree)
</p>


<h3>Note</h3>

<p>The algorithm calculates the great circle bearing between line
vertices. Since transform plate boundaries represent small circle lines in
the PoR system, this great-circle azimuth is only a approximation of the
true (small-circle) azimuth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
res &lt;- projected_pb_strike(
  x = san_andreas, PoR = na_pa, pb = plate_boundary, tangential = TRUE
)
head(res)
head(san_andreas$azi - res) # beta angle
</code></pre>

<hr>
<h2 id='Q4_to_euler'>Euler angle/axis from quaternion</h2><span id='topic+Q4_to_euler'></span>

<h3>Description</h3>

<p>Euler angle/axis from quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q4_to_euler(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Q4_to_euler_+3A_q">q</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"euler.pole"</code> object
</p>

<hr>
<h2 id='quick_plot'>Plotting Stress Analysis Results</h2><span id='topic+quick_plot'></span>

<h3>Description</h3>

<p>Creates a set of plots including
the azimuth as a function of the distance to the plate boundary,
the Norm Chi-squared as a function of the distance to the plate boundary,
the circular distance (and dispersion) a function of the distance to the
plate boundary, a von-Mises QQ plot, and a rose diagram of the
quality-weighted frequency distribution of the azimuths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quick_plot(azi, distance, prd, unc = NULL, regime, width = 51)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quick_plot_+3A_azi">azi</code></td>
<td>
<p>numeric. Azimuth of <code class="reqn">\sigma_{Hmax}</code></p>
</td></tr>
<tr><td><code id="quick_plot_+3A_distance">distance</code></td>
<td>
<p>numeric. Distance to plate boundary</p>
</td></tr>
<tr><td><code id="quick_plot_+3A_prd">prd</code></td>
<td>
<p>numeric. the predicted direction of <code class="reqn">\sigma_{Hmax}</code></p>
</td></tr>
<tr><td><code id="quick_plot_+3A_unc">unc</code></td>
<td>
<p>numeric. Uncertainty of observed <code class="reqn">\sigma_{Hmax}</code>,
either a numeric vector or a number</p>
</td></tr>
<tr><td><code id="quick_plot_+3A_regime">regime</code></td>
<td>
<p>character vector. The stress
regime (following the classification of the World Stress Map)</p>
</td></tr>
<tr><td><code id="quick_plot_+3A_width">width</code></td>
<td>
<p>integer. window width (in number of observations) for moving
average of the azimuths, circular dispersion, and Norm Chi-square statistics.
If <code>NULL</code>, an optimal width will be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot 1 shows the transformed azimuths as a function of the distance to the
plate boundary. The red line indicates the rolling circular mean, stippled
red lines indicate the 95% confidence interval about the mean.
</p>
<p>Plot 2 shows the normalized <code class="reqn">\chi^2</code> statistics as a
function of the distance to the plate boundary. The red line shows the
rolling <code class="reqn">\chi^2</code> statistic.
</p>
<p>Plot 3 shows the circular distance of the transformed azimuths to the
predicted azimuth, as a function of the distance to the plate boundary. The
red line shows the rolling circular dispersion about the prediction.
</p>
<p>Plot 4 give the rose diagram of the transformed azimuths.
</p>


<h3>Value</h3>

<p>four R base plots
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>, <code><a href="#topic+distance_from_pb">distance_from_pb()</a></code>, <code><a href="#topic+circular_mean">circular_mean()</a></code>,
<code><a href="#topic+circular_dispersion">circular_dispersion()</a></code>, <code><a href="#topic+confidence_interval_fisher">confidence_interval_fisher()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>,
<code><a href="#topic+weighted_rayleigh">weighted_rayleigh()</a></code>, <code><a href="#topic+vm_qqplot">vm_qqplot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
res &lt;- PoR_shmax(san_andreas, na_pa, "right")
d &lt;- distance_from_pb(san_andreas, na_pa, plate_boundary, tangential = TRUE)
quick_plot(res$azi.PoR,
  distance = d, prd = res$prd, unc = san_andreas$unc,
  regime = san_andreas$regime
)
</code></pre>

<hr>
<h2 id='raster_transformation'>Conversion between PoR to geographical coordinate reference system of raster
data</h2><span id='topic+raster_transformation'></span><span id='topic+geographical_to_PoR_raster'></span><span id='topic+PoR_to_geographical_raster'></span>

<h3>Description</h3>

<p>Helper function to transform raster data set from PoR to geographical
coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographical_to_PoR_raster(x, PoR)

PoR_to_geographical_raster(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raster_transformation_+3A_x">x</code></td>
<td>
<p><code>"SpatRaster"</code> or <code>"RasterLayer"</code></p>
</td></tr>
<tr><td><code id="raster_transformation_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p>terra &quot;SpatRaster&quot; object
</p>

<hr>
<h2 id='rayleigh_test'>Rayleigh Test of Circular Uniformity</h2><span id='topic+rayleigh_test'></span>

<h3>Description</h3>

<p>Performs a Rayleigh test for uniformity of circular/directional data by
assessing the significance of the mean resultant length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rayleigh_test(x, mu = NULL, axial = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rayleigh_test_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees</p>
</td></tr>
<tr><td><code id="rayleigh_test_+3A_mu">mu</code></td>
<td>
<p>(optional) The specified or known mean direction (in degrees) in
alternative hypothesis</p>
</td></tr>
<tr><td><code id="rayleigh_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rayleigh_test_+3A_quiet">quiet</code></td>
<td>
<p>logical. Prints the test's decision.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code class="reqn">H_0</code>:</dt><dd><p>angles are randomly distributed around the circle.</p>
</dd>
<dt><code class="reqn">H_1</code>:</dt><dd><p>angles are from unimodal distribution with unknown mean
direction and mean resultant length (when <code>mu</code> is <code>NULL</code>. Alternatively (when
<code>mu</code> is specified),
angles are uniformly distributed around a specified direction.</p>
</dd>
</dl>

<p>If <code>statistic &gt; p.value</code>, the null hypothesis is rejected,
i.e. the length of the mean resultant differs significantly from zero, and
the angles are not randomly distributed.
</p>


<h3>Value</h3>

<p>a list with the components:
</p>

<dl>
<dt><code>R</code> or <code>C</code></dt><dd><p>mean resultant length or the dispersion (if <code>mu</code> is
specified). Small values of <code>R</code> (large values of <code>C</code>) will reject
uniformity. Negative values of <code>C</code> indicate that vectors point in opposite
directions (also lead to rejection).</p>
</dd>
<dt><code>statistic</code></dt><dd><p>test statistic</p>
</dd>
<dt><code>p.value</code></dt><dd><p>significance level of the test statistic</p>
</dd>
</dl>



<h3>Note</h3>

<p>Although the Rayleigh test is consistent against (non-uniform)
von Mises alternatives, it is not consistent against alternatives with
<code>p = 0</code> (in particular, distributions with antipodal symmetry, i.e. axial
data). Tests of non-uniformity which are consistent against all alternatives
include Kuiper's test (<code><a href="#topic+kuiper_test">kuiper_test()</a></code>) and Watson's <code class="reqn">U^2</code> test
(<code><a href="#topic+watson_test">watson_test()</a></code>).
</p>


<h3>References</h3>

<p>Mardia and Jupp (2000). Directional Statistics. John Wiley and Sons.
</p>
<p>Wilkie (1983): Rayleigh Test for Randomness of Circular Data. Appl.
Statist. 32, No. 3, pp. 311-312
</p>
<p>Jammalamadaka, S. Rao and Sengupta, A. (2001). Topics in Circular Statistics,
Sections 3.3.3 and 3.4.1, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_resultant_length">mean_resultant_length()</a></code>, <code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>,
<code><a href="#topic+kuiper_test">kuiper_test()</a></code>, <code><a href="#topic+watson_test">watson_test()</a></code>, <code><a href="#topic+weighted_rayleigh">weighted_rayleigh()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Mardia and Jupp (2001), pp. 93
pidgeon_homing &lt;- c(55, 60, 65, 95, 100, 110, 260, 275, 285, 295)
rayleigh_test(pidgeon_homing, axial = FALSE)

# Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
rayleigh_test(finland_stria, axial = FALSE)
rayleigh_test(finland_stria, mu = 105, axial = FALSE)

# Example data from Mardia and Jupp (2001), pp. 99
atomic_weight &lt;- c(
  rep(0, 12), rep(3.6, 1), rep(36, 6), rep(72, 1),
  rep(108, 2), rep(169.2, 1), rep(324, 1)
)
rayleigh_test(atomic_weight, 0, axial = FALSE)

# San Andreas Fault Data:
data(san_andreas)
rayleigh_test(san_andreas$azi)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
rayleigh_test(sa.por$azi.PoR, mu = 135)
</code></pre>

<hr>
<h2 id='relative_rotation'>Relative rotation between two rotations</h2><span id='topic+relative_rotation'></span><span id='topic+rotation'></span><span id='topic+quaternion'></span>

<h3>Description</h3>

<p>Calculates the relative rotation between two rotations, i.e. the
difference from rotation 1 to rotation 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative_rotation(r1, r2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relative_rotation_+3A_r1">r1</code>, <code id="relative_rotation_+3A_r2">r2</code></td>
<td>
<p>Objects of class <code>"euler.pole"</code>. First rotation is
<code>r1</code>, followed rotation <code>r2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>. Euler axes
(geographical coordinates) and Euler angles (in degrees)
</p>


<h3>References</h3>

<p>Schaeben, H., Kroner, U. and Stephan, T. (2021). Euler Poles of
Tectonic Plates. In B. S. Daza Sagar, Q. Cheng, J. McKinley and F. Agterberg
(Eds.), <em>Encyclopedia of Mathematical Geosciences. Encyclopedia of Earth Sciences Series</em>
(pp. 1&ndash;7). Springer Nature Switzerland AG 2021.
doi: 10.1007/978-3-030-26050-7_435-1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+euler_pole">euler_pole()</a></code> for class <code>"euler.pole"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- euler_pole(90, 0, angle = 45)
b &lt;- euler_pole(0, 0, 1, geo = FALSE, angle = -15)
relative_rotation(a, b)
relative_rotation(b, a)
</code></pre>

<hr>
<h2 id='roll_circstats'>Apply Rolling Functions using Circular Statistics</h2><span id='topic+roll_circstats'></span>

<h3>Description</h3>

<p>A generic function for applying a function to rolling margins of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_circstats(
  x,
  w = NULL,
  FUN,
  axial = TRUE,
  na.rm = TRUE,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roll_circstats_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_width">width</code></td>
<td>
<p>integer specifying the window width (in numbers of observations)
which is aligned to the original sample according to the <code>align</code> argument.
If <code>NULL</code>, an optimal width is calculated.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_by.column">by.column</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>FUN</code> is applied to each column
separately.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_partial">partial</code></td>
<td>
<p>logical or numeric. If <code>FALSE</code> then <code>FUN</code> is only
applied when all indexes of the rolling window are within the observed time
range. If <code>TRUE</code> (default), then the subset of indexes that are in range
are passed to <code>FUN</code>. A numeric argument to partial can be used to determine
the minimal window size for partial computations. See below for more details.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_fill">fill</code></td>
<td>
<p>a three-component vector or list (recycled otherwise) providing
filling values at the left/within/to the right of the data range. See the
fill argument of <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code> for details</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="zoo.html#topic+rollapply">zoo::rollapply()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector  with the results of the rolling function.
</p>


<h3>Note</h3>

<p>If the rolling statistics are applied to values that are a function of
distance it is recommended to sort the values first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")
data("san_andreas")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
distance &lt;- distance_from_pb(
  x = san_andreas,
  PoR = PoR,
  pb = plate_boundary,
  tangential = TRUE
)
dat &lt;- san_andreas[order(distance), ]
roll_circstats(dat$azi, w = 1 / dat$unc, circular_mean, width = 51) |&gt; head()
</code></pre>

<hr>
<h2 id='rolling_test'>Apply Rolling Functions using Circular Statistical Tests for Uniformity</h2><span id='topic+rolling_test'></span><span id='topic+roll_normchisq'></span><span id='topic+roll_rayleigh'></span><span id='topic+roll_dispersion'></span><span id='topic+roll_confidence'></span><span id='topic+roll_dispersion_CI'></span><span id='topic+roll_dispersion_sde'></span>

<h3>Description</h3>

<p>A generic function for applying a function to rolling margins of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_normchisq(
  obs,
  prd,
  unc = NULL,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_rayleigh(
  obs,
  prd,
  unc = NULL,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_dispersion(
  x,
  y,
  w = NULL,
  w.y = NULL,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_confidence(
  x,
  conf.level = 0.95,
  w = NULL,
  axial = TRUE,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_dispersion_CI(
  x,
  y,
  w = NULL,
  w.y = NULL,
  R,
  conf.level = 0.95,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_dispersion_sde(
  x,
  y,
  w = NULL,
  w.y = NULL,
  R,
  conf.level = 0.95,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rolling_test_+3A_obs">obs</code></td>
<td>
<p>Numeric vector containing the observed azimuth of
<code class="reqn">\sigma_{Hmax}</code>,
same length as <code>prd</code></p>
</td></tr>
<tr><td><code id="rolling_test_+3A_prd">prd</code></td>
<td>
<p>Numeric vector containing the modeled azimuths of
<code class="reqn">\sigma_{Hmax}</code>, i.e.
the return object from <code>model_shmax()</code></p>
</td></tr>
<tr><td><code id="rolling_test_+3A_unc">unc</code></td>
<td>
<p>Uncertainty of observed <code class="reqn">\sigma_{Hmax}</code>, either a
numeric vector or a number</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_width">width</code></td>
<td>
<p>integer specifying the window width (in numbers of observations)
which is aligned to the original sample according to the <code>align</code> argument.
If <code>NULL</code>, an optimal width is estimated.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_by.column">by.column</code></td>
<td>
<p>logical. If <code>TRUE</code>, FUN is applied to each column
separately.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_partial">partial</code></td>
<td>
<p>logical or numeric. If <code>FALSE</code> then <code>FUN</code> is only
applied when all indexes of the rolling window are within the observed time
range. If <code>TRUE</code> (default), then the subset of indexes that are in range
are passed to <code>FUN</code>. A numeric argument to partial can be used to determine
the minimal window size for partial computations. See below for more details.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_fill">fill</code></td>
<td>
<p>a three-component vector or list (recycled otherwise) providing
filling values at the left/within/to the right of the data range. See the
fill argument of <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code> for details</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="zoo.html#topic+rollapply">zoo::rollapply()</a></code></p>
</td></tr>
<tr><td><code id="rolling_test_+3A_x">x</code>, <code id="rolling_test_+3A_y">y</code></td>
<td>
<p>numeric. Directions in degrees</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_w">w</code>, <code id="rolling_test_+3A_w.y">w.y</code></td>
<td>
<p>(optional) Weights of <code>x</code> and <code>y</code>, respectively. A vector of
positive numbers and of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence: <code class="reqn">(1 - \alpha \%)/100</code>.
(<code>0.95</code> by default).</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the test statistic of the rolling test.
<code>roll_dispersion_CI</code> returns a 2-column matrix with the lower and the upper
confidence limits
</p>


<h3>Note</h3>

<p>If the rolling functions are applied to values that are a function of
distance it is recommended to sort the values first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")
data("san_andreas")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
distance &lt;- distance_from_pb(
  x = san_andreas,
  PoR = PoR,
  pb = plate_boundary,
  tangential = TRUE
)
dat &lt;- san_andreas[order(distance), ]
dat.PoR &lt;- PoR_shmax(san_andreas, PoR, "right")
roll_normchisq(dat.PoR$azi.PoR, 135, dat$unc) |&gt; head()
roll_rayleigh(dat.PoR$azi.PoR, prd = 135, unc = dat$unc) |&gt; head()
roll_dispersion(dat.PoR$azi.PoR, y = 135, w = 1 / dat$unc) |&gt; head()
roll_confidence(dat.PoR$azi.PoR, w = 1 / dat$unc) |&gt; head()

roll_dispersion_CI(dat.PoR$azi.PoR, y = 135, w = 1 / dat$unc, R = 10) |&gt; head()

</code></pre>

<hr>
<h2 id='rolling_test_dist'>Apply Rolling Functions using Circular Statistics</h2><span id='topic+rolling_test_dist'></span><span id='topic+distroll_circstats'></span><span id='topic+distroll_confidence'></span><span id='topic+distroll_dispersion'></span><span id='topic+distroll_dispersion_sde'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
A generic function for applying a function to rolling margins of an array
along an additional value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distroll_circstats(
  x,
  distance,
  FUN,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  w = NULL,
  sort = TRUE,
  ...
)

distroll_confidence(
  x,
  distance,
  w = NULL,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  sort = TRUE,
  ...
)

distroll_dispersion(
  x,
  y,
  w = NULL,
  w.y = NULL,
  distance,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  sort = TRUE,
  ...
)

distroll_dispersion_sde(
  x,
  y,
  w = NULL,
  w.y = NULL,
  distance,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  sort = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rolling_test_dist_+3A_x">x</code>, <code id="rolling_test_dist_+3A_y">y</code></td>
<td>
<p>vectors of numeric values in degrees. <code>length(y)</code> is either 1 or
<code>length(x)</code></p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_distance">distance</code></td>
<td>
<p>numeric. the independent variable along the values in <code>x</code>
are sorted, e.g. the plate boundary distances</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_width">width</code></td>
<td>
<p>numeric. the range across <code>distance</code> on which <code>FUN</code> should be
applied on <code>x</code>. If <code>NULL</code>, then width is a number that separates the
distances in 10 equal groups.</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_min_n">min_n</code></td>
<td>
<p>integer. The minimum values that should be considered in <code>FUN</code>
(2 by default), otherwise <code>NA</code>.</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_align">align</code></td>
<td>
<p>specifies whether the index of the result should be left- or
right-aligned or centered (default) compared to the rolling window of
observations. This argument is only used if width represents widths.</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_w">w</code></td>
<td>
<p>numeric. the weighting for <code>x</code></p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_sort">sort</code></td>
<td>
<p>logical. Should the values be sorted after <code>distance</code> prior to
applying the function (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code></p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_w.y">w.y</code></td>
<td>
<p>numeric. the weighting for <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>two-column vectors of (sorted) <code>x</code> and the rolled statistics along
<code>distance</code>.
</p>


<h3>Note</h3>

<p><code>distroll_circstats()</code> and friends are complete, and for new code it is
recommended switching to <code><a href="#topic+distance_binned_stats">distance_binned_stats()</a></code>,
which is fasrter, easier to use, more featureful, and still under active development.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")
data("san_andreas")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
san_andreas$distance &lt;- distance_from_pb(
  x = san_andreas,
  PoR = PoR,
  pb = plate_boundary,
  tangential = TRUE
)
dat &lt;- san_andreas |&gt; cbind(PoR_shmax(san_andreas, PoR, "right"))

distroll_circstats(dat$azi.PoR,
  distance = dat$distance,
  w = 1 / dat$unc, FUN = circular_mean
) |&gt; head()
distroll_confidence(dat$azi.PoR, distance = dat$distance, w = 1 / dat$unc) |&gt; head()
distroll_dispersion(dat$azi.PoR,
  y = 135,
  distance = dat$distance, w = 1 / dat$unc
) |&gt; head()
distroll_dispersion_sde(dat$azi.PoR,
  y = 135,
  distance = dat$distance, w = 1 / dat$unc, R = 100
) |&gt; head()

# New functions
distance_binned_stats(
  dat$azi.PoR,
  distance = dat$distance, width.breaks = 1, unc = dat$unc, prd = 135
) |&gt; head()
</code></pre>

<hr>
<h2 id='rose'>Rose Diagram</h2><span id='topic+rose'></span>

<h3>Description</h3>

<p>Plots a rose diagram (rose of directions), the analogue of a
histogram or density plot for angular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose(
  x,
  weights = NULL,
  binwidth = NULL,
  bins = NULL,
  axial = TRUE,
  equal_area = TRUE,
  muci = TRUE,
  round_binwidth = 0,
  mtext = "N",
  main = NULL,
  sub = NULL,
  at = seq(0, 360 - 45, 45),
  cborder = TRUE,
  labels = TRUE,
  col = "grey",
  dots = FALSE,
  dot_pch = 1,
  dot_cex = 1,
  dot_col = "slategrey",
  stack = FALSE,
  jitter_factor = 0,
  grid = FALSE,
  grid.lines = seq(0, 135, 45),
  grid.circles = seq(0.2, 1, 0.2),
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rose_+3A_x">x</code></td>
<td>
<p>Data to be plotted. A numeric vector containing angles (in degrees).</p>
</td></tr>
<tr><td><code id="rose_+3A_weights">weights</code></td>
<td>
<p>Optional vector of numeric weights associated with x.</p>
</td></tr>
<tr><td><code id="rose_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins (in degrees).</p>
</td></tr>
<tr><td><code id="rose_+3A_bins">bins</code></td>
<td>
<p>number of arcs to partition the circle width.
Overridden by <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="rose_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_+3A_equal_area">equal_area</code></td>
<td>
<p>Logical. Whether the radii of the bins are proportional to
the frequencies (<code>equal_area=FALSE</code>, i.e. equal-angle) or proportional to the
square-root of the frequencies (<code>equal_area=TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_+3A_muci">muci</code></td>
<td>
<p>logical. Whether the mean and its 95% CI are added to the plot
or not.</p>
</td></tr>
<tr><td><code id="rose_+3A_round_binwidth">round_binwidth</code></td>
<td>
<p>integer. Number of decimal places of bin width (0 by
default).</p>
</td></tr>
<tr><td><code id="rose_+3A_mtext">mtext</code></td>
<td>
<p>character. String to be drawn at the top margin of the plot
(<code>"N"</code> by default)</p>
</td></tr>
<tr><td><code id="rose_+3A_main">main</code>, <code id="rose_+3A_sub">sub</code></td>
<td>
<p>Character string specifying the title and subtitle of the
plot. If <code>sub = NULL</code>, it will show the bin width.</p>
</td></tr>
<tr><td><code id="rose_+3A_at">at</code></td>
<td>
<p>Optional vector of angles at which tick marks should be plotted.
Set <code>at=numeric(0)</code> to suppress tick marks.</p>
</td></tr>
<tr><td><code id="rose_+3A_cborder">cborder</code></td>
<td>
<p>logical. Border of rose plot.</p>
</td></tr>
<tr><td><code id="rose_+3A_labels">labels</code></td>
<td>
<p>Either a logical value indicating whether to plot labels
next to the tick marks, or a vector of labels for the tick marks.</p>
</td></tr>
<tr><td><code id="rose_+3A_col">col</code></td>
<td>
<p>fill color of bins</p>
</td></tr>
<tr><td><code id="rose_+3A_dots">dots</code></td>
<td>
<p>logical. Whether a circular dot plot should be added
(<code>FALSE</code> is the default).</p>
</td></tr>
<tr><td><code id="rose_+3A_dot_cex">dot_cex</code>, <code id="rose_+3A_dot_pch">dot_pch</code>, <code id="rose_+3A_dot_col">dot_col</code></td>
<td>
<p>Plotting arguments for circular dot plot</p>
</td></tr>
<tr><td><code id="rose_+3A_stack">stack</code></td>
<td>
<p>logical. Groups and stacks the dots if <code>TRUE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rose_+3A_jitter_factor">jitter_factor</code></td>
<td>
<p>Add a small amount of noise to the angles' radius that
is added to <code>scale</code>. Jitter is ignored when <code>stack==TRUE</code>).
If <code>0</code>, no jitter is added (by default); if negative, the points fall into
the circle.</p>
</td></tr>
<tr><td><code id="rose_+3A_grid">grid</code></td>
<td>
<p>logical. Whether to add a grid. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rose_+3A_grid.lines">grid.lines</code>, <code id="rose_+3A_grid.circles">grid.circles</code></td>
<td>
<p>numeric. Adds a sequence of straight grid
lines and circles based on angles and radii, respectively. Ignored when
<code>grid=FALSE</code></p>
</td></tr>
<tr><td><code id="rose_+3A_add">add</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="rose_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spatstat.explore.html#topic+rose">spatstat.explore::rose()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A window (class <code>"owin"</code>) containing the plotted region or a <code>list</code>
of the calculated frequencies.
</p>


<h3>Note</h3>

<p>If <code>bins</code> and <code>binwidth</code> are <code>NULL</code>, an optimal bin width will be
calculated using Scott (1979):
</p>
<p style="text-align: center;"><code class="reqn"> w_b = \frac{R}{n^{\frac{1}{3}}}
</code>
</p>

<p>with n being the length of <code>x</code>, and the range R being either 180 or 360
degree for axial or directional data, respectively.
</p>
<p>If <code>"axial" == TRUE</code>, the binwidth is adjusted to guarantee symmetrical fans.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvm(100, mean = 90, k = 5)
rose(x, axial = FALSE, border = TRUE, grid = TRUE)

data("san_andreas")
rose(san_andreas$azi, main = "equal area")
rose(san_andreas$azi, equal_area = FALSE, main = "equal angle")

# weighted frequencies:
rose(san_andreas$azi, weights = 1 / san_andreas$unc, main = "weighted")

# add dots:
rose(san_andreas$azi, dots = TRUE, main = "dot plot", jitter = .2)

# stack dots:
rose(san_andreas$azi,
  dots = TRUE, stack = TRUE, dot_cex = 0.5, dot_pch = 21,
  main = "stacked dot plot"
)
</code></pre>

<hr>
<h2 id='rose_bw'>Selecting optimal number of bins and width for rose diagrams</h2><span id='topic+rose_bw'></span><span id='topic+rose_bins'></span><span id='topic+rose_binwidth'></span>

<h3>Description</h3>

<p>Selecting optimal number of bins and width for rose diagrams
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_bins(n, round = FALSE)

rose_binwidth(n, axial = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rose_bw_+3A_n">n</code></td>
<td>
<p>Integer. number of data</p>
</td></tr>
<tr><td><code id="rose_bw_+3A_round">round</code></td>
<td>
<p>Logical. Whether bin width is round to zero digits
(<code>round=TRUE</code>, the default)
or as is (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rose_bw_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_bw_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+rose_bw">rose_bw()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rose_geom'>Direction Lines and Fans in Circular Diagram</h2><span id='topic+rose_geom'></span><span id='topic+rose_line'></span><span id='topic+rose_fan'></span>

<h3>Description</h3>

<p>Direction Lines and Fans in Circular Diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_line(x, radius = 1, axial = TRUE, add = TRUE, ...)

rose_fan(x, d, radius = 1, axial = TRUE, add = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rose_geom_+3A_x">x</code></td>
<td>
<p>angles in degrees</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_radius">radius</code></td>
<td>
<p>of the plotted circle</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether <code>x</code> are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_add">add</code></td>
<td>
<p>logical. Add to existing plot?</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+segments">graphics::segments()</a></code> or
<code><a href="graphics.html#topic+polygon">graphics::polygon()</a></code></p>
</td></tr>
<tr><td><code id="rose_geom_+3A_d">d</code></td>
<td>
<p>width of a fan (in degrees)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>angles &lt;- c(0, 10, 45)
radius &lt;- c(.7, 1, .2)
lwd &lt;- c(2, 1, .75)
col &lt;- c(1, 2, 3)
rose_line(angles, radius = radius, axial = FALSE, add = FALSE, lwd = lwd, col = col)
</code></pre>

<hr>
<h2 id='rose_stats'>Show Average Direction and Spread in Rose Diagram</h2><span id='topic+rose_stats'></span>

<h3>Description</h3>

<p>Adds the average direction (and its spread) to an existing rose diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_stats(
  x,
  weights = NULL,
  axial = TRUE,
  avg = c("mean", "median", "sample_median"),
  spread = c("CI", "fisher", "sd", "IQR", "mdev"),
  f = 1,
  avg.col = "#B63679FF",
  avg.lty = 2,
  avg.lwd = 1.5,
  spread.col = ggplot2::alpha("#B63679FF", 0.2),
  spread.border = FALSE,
  spread.lty = NULL,
  spread.lwd = NULL,
  add = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rose_stats_+3A_x">x</code></td>
<td>
<p>Data to be plotted. A numeric vector containing angles (in degrees).</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_weights">weights</code></td>
<td>
<p>Optional vector of numeric weights associated with x.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg">avg</code></td>
<td>
<p>character. The average estimate for x. Either the circular mean
(<code>"mean"</code>, the default), the circular Quasi Median (<code>"median"</code>), or the
sample median (<code>"sample_median"</code>).</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread">spread</code></td>
<td>
<p>character. The measure of spread to be plotted as a fan.
Either 95% confidence interval (<code>"CI"</code>, the default), Fishers confidence interval (<code>"fisher"</code>), the circular
standard deviation (<code>"sd"</code>), the Quasi interquartile range on the circle
(<code>"IQR"</code>), or the sampke median deviation (<code>"mdev"</code>). <code>NULL</code> if no fan should be drawn.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_f">f</code></td>
<td>
<p>factor applied on spread. <code>1</code> by default.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg.col">avg.col</code></td>
<td>
<p>color for the average line</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg.lty">avg.lty</code></td>
<td>
<p>line type of the average line</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg.lwd">avg.lwd</code></td>
<td>
<p>line width of the average line</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.col">spread.col</code></td>
<td>
<p>color of the spread fan</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.border">spread.border</code></td>
<td>
<p>logical. Whether to draw a border of the fan or not.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.lty">spread.lty</code></td>
<td>
<p>line type of the spread fan's border</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.lwd">spread.lwd</code></td>
<td>
<p>line width of the spread fan's border</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_add">add</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>circular_plot()</code> if add is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rose">rose()</a></code> for plotting the rose diagram, and
<code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+circular_median">circular_median()</a></code>, <code><a href="#topic+circular_sample_median">circular_sample_median()</a></code>,
<code><a href="#topic+confidence_interval">confidence_interval()</a></code>, <code><a href="#topic+confidence_interval_fisher">confidence_interval_fisher()</a></code>,
<code><a href="#topic+circular_sd">circular_sd()</a></code>, <code><a href="#topic+circular_IQR">circular_IQR()</a></code>, <code><a href="#topic+circular_sample_median_deviation">circular_sample_median_deviation()</a></code>
for statistical parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
rose(san_andreas$azi, weights = 1 / san_andreas$unc, muci = FALSE)
rose_stats(san_andreas$azi, weights = 1 / san_andreas$unc, avg = "sample_median", spread = "mdev")
</code></pre>

<hr>
<h2 id='rotate_lines'>Rotate Lines</h2><span id='topic+rotate_lines'></span>

<h3>Description</h3>

<p>Rotates a set of straight lines around an angle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_lines(theta, p, centre)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_lines_+3A_theta">theta</code></td>
<td>
<p>Angle of rotation (in degree)</p>
</td></tr>
<tr><td><code id="rotate_lines_+3A_p">p</code></td>
<td>
<p>Coordinates of the lines end points</p>
</td></tr>
<tr><td><code id="rotate_lines_+3A_centre">centre</code></td>
<td>
<p>Coordinates of the center point of rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code>
</p>

<hr>
<h2 id='rotation_Q4'>Rotation of a vector by a quaternion</h2><span id='topic+rotation_Q4'></span>

<h3>Description</h3>

<p>Rotation of a vector by a quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation_Q4(q, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotation_Q4_+3A_q">q</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
<tr><td><code id="rotation_Q4_+3A_p">p</code></td>
<td>
<p>three-column vector (Cartesian coordinates) of unit length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>three-column vector (Cartesian coordinates) of unit length
</p>

<hr>
<h2 id='sample_median'>Circular Sample Median and Deviation</h2><span id='topic+sample_median'></span><span id='topic+circular_sample_median'></span><span id='topic+circular_sample_median_deviation'></span>

<h3>Description</h3>

<p>Sample median direction for a vector of circular data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_sample_median(x, axial = TRUE, na.rm = TRUE)

circular_sample_median_deviation(x, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_median_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="sample_median_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="sample_median_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical Analysis of Circular Data, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rvm(n = 100, mean = 0, kappa = 10)
circular_sample_median(x)
circular_sample_median_deviation(x)

data("san_andreas")
circular_sample_median(san_andreas$azi)
circular_sample_median_deviation(san_andreas$azi)
</code></pre>

<hr>
<h2 id='second_central_moment'>Second Central Momentum</h2><span id='topic+second_central_moment'></span>

<h3>Description</h3>

<p>Measures the skewness (a measure of the asymmetry of the probability
distribution) and the kurtosis (measure of the &quot;tailedness&quot; of the probability
distribution). Standardized versions are the skewness and kurtosis normalized
by the mean resultant length, Mardia 1972).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>second_central_moment(x, w = NULL, axial = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="second_central_moment_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="second_central_moment_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="second_central_moment_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="second_central_moment_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Negative values of skewness indicate skewed data in counterclockwise
direction.
</p>
<p>Large kurtosis values indicate tailed, values close to <code>0</code> indicate packed
data.
</p>


<h3>Value</h3>

<p>list containing
</p>

<dl>
<dt><code>skewness</code></dt><dd><p>second central sine momentum, i.e. the skewness</p>
</dd>
<dt><code>std_skewness</code></dt><dd><p>standardized skewness</p>
</dd>
<dt><code>kurtosis</code></dt><dd><p>second central cosine momentum, i.e. the kurtosis</p>
</dd>
<dt><code>std_kurtosis</code></dt><dd><p>standardized kurtosis</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
second_central_moment(sa.por$azi.PoR)
second_central_moment(sa.por$azi.PoR, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='spec_atan'>Quadrant-specific inverse of the tangent</h2><span id='topic+spec_atan'></span><span id='topic+atan2_spec'></span><span id='topic+atan2d_spec'></span>

<h3>Description</h3>

<p>Returns the quadrant specific inverse of the tangent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atan2_spec(x, y)

atan2d_spec(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spec_atan_+3A_x">x</code>, <code id="spec_atan_+3A_y">y</code></td>
<td>
<p>dividend and divisor that comprise the sum of sines and cosines,
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao, and Ambar Sengupta (2001). Topics in
circular statistics. Vol. 5. world scientific.
</p>

<hr>
<h2 id='spherical_angle'>Angle along great circle on spherical surface</h2><span id='topic+spherical_angle'></span><span id='topic+orthodrome'></span><span id='topic+haversine'></span><span id='topic+vincenty'></span>

<h3>Description</h3>

<p>Smallest angle between two points on the surface of a sphere, measured along
the surface of the sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthodrome(lat1, lon1, lat2, lon2)

haversine(lat1, lon1, lat2, lon2)

vincenty(lat1, lon1, lat2, lon2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spherical_angle_+3A_lat1">lat1</code>, <code id="spherical_angle_+3A_lat2">lat2</code></td>
<td>
<p>numeric vector. latitudes of point 1 and 2 (in radians)</p>
</td></tr>
<tr><td><code id="spherical_angle_+3A_lon1">lon1</code>, <code id="spherical_angle_+3A_lon2">lon2</code></td>
<td>
<p>numeric vector. longitudes of point 1 and 2 (in radians)</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>"orthodrome"</code></dt><dd><p>based on the spherical law of cosines</p>
</dd>
<dt><code>"haversine"</code></dt><dd><p>uses haversine formula that is
optimized for 64-bit floating-point numbers</p>
</dd>
<dt><code>"vincenty"</code></dt><dd><p>uses Vincenty formula for an ellipsoid
with equal major and minor axes</p>
</dd>
</dl>



<h3>Value</h3>

<p>numeric. angle in radians
</p>


<h3>References</h3>


<ul>
<li><p> Imboden, C. &amp; Imboden, D. (1972). Formel fuer Orthodrome und Loxodrome bei
der Berechnung von Richtung und Distanz zwischen Beringungs- und
Wiederfundort.
<em>Die Vogelwarte</em> <strong>26</strong>, 336-346.
</p>
</li>
<li><p> Sinnott, Roger W. (1984). Virtues of the Haversine. <em>Sky and telescope</em>
<strong>68</strong>(2), 158.
Vincenty, T. (1975). Direct and inverse solutions of geodesics on the
ellipsoid with application of nested equations. <em>Survey Review</em>, <strong>23</strong>(176),
88&lt;U+2013&gt;93. <a href="https://doi.org/10.1179/sre.1975.23.176.88">doi:10.1179/sre.1975.23.176.88</a>.
</p>
</li>
<li> <p><a href="http://www.movable-type.co.uk/scripts/latlong.html">http://www.movable-type.co.uk/scripts/latlong.html</a>
</p>
</li>
<li> <p><a href="http://www.edwilliams.org/avform147.htm">http://www.edwilliams.org/avform147.htm</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>berlin &lt;- c(52.52, 13.41) |&gt; deg2rad()
calgary &lt;- c(51.04, -114.072) |&gt; deg2rad()
orthodrome(berlin[1], berlin[2], calgary[1], calgary[2])
haversine(berlin[1], berlin[2], calgary[1], calgary[2])
vincenty(berlin[1], berlin[2], calgary[1], calgary[2])
</code></pre>

<hr>
<h2 id='stress_analysis'>Quick analysis of a stress data set</h2><span id='topic+stress_analysis'></span>

<h3>Description</h3>

<p>Returns the converted azimuths, distances to the plate boundary,
statistics of the model, and some plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress_analysis(
  x,
  PoR,
  type = c("none", "in", "out", "right", "left"),
  pb,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stress_analysis_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> or <code>sf</code> object containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>), the direction of
<code class="reqn">\sigma_{Hmax}</code> <code>azi</code> and its standard deviation
<code>unc</code> (optional)</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>data.frame</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_type">type</code></td>
<td>
<p>Character. Type of plate boundary (optional). Can be
<code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively. If <code>"none"</code> (the default), only
the PoR-equivalent azimuth is returned.</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_pb">pb</code></td>
<td>
<p>(optional) <code>sf</code> object of the plate boundary geometries in the
geographical coordinate system</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_plot">plot</code></td>
<td>
<p>(logical). Whether to produce a plot additional to output.</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="#topic+distance_from_pb">distance_from_pb()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following values:
</p>

<dl>
<dt><code>results</code></dt><dd><p>data.frame showing the the coordinate and azimuth conversions
(<code>lat.PoR</code>, <code>lon.PoR</code>, and <code>azi.PoR</code>), the predicted azimuths (<code>prd</code>),
deviation angle from predicted (<code>dev</code>), circular distance (<code>cdist</code>),
misfit to predicted stress direction (<code>nchisq</code>) and, if given, distance to tested
plate boundary (<code>distance</code>)</p>
</dd>
<dt><code>stats</code></dt><dd><p>array with circular (weighted) mean, circular standard
deviation, circular variance, circular median, skewness, kurtosis, the 95%
confidence angle, circular dispersion, and the normalized Chi-squared test
statistic</p>
</dd>
<dt><code>test</code></dt><dd><p>list containing the test results of the (weighted) Rayleigh
test against the uniform distribution about the predicted orientation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>, <code><a href="#topic+distance_from_pb">distance_from_pb()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>, <code><a href="#topic+quick_plot">quick_plot()</a></code>, <code><a href="#topic+circular_summary">circular_summary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
stress_analysis(san_andreas, na_pa, type = "right", plate_boundary, plot = TRUE)

</code></pre>

<hr>
<h2 id='stress_colors'>Color palette for stress regime</h2><span id='topic+stress_colors'></span>

<h3>Description</h3>

<p>Color palette for stress regime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress_colors()
</code></pre>


<h3>Value</h3>

<p>function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stress_colors()
</code></pre>

<hr>
<h2 id='stress_data'>Example crustal stress dataset</h2><span id='topic+stress_data'></span><span id='topic+san_andreas'></span><span id='topic+tibet'></span><span id='topic+iceland'></span>

<h3>Description</h3>

<p>Subsets of the World Stress Map (WSM) compilation of information on the
crustal present-day stress field (Version 1.1. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('san_andreas')

data('tibet')

data('iceland')
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> object / <code>data.frame</code> with 10 columns. Each row represents a different in-situ stress measurement:
</p>

<dl>
<dt>id</dt><dd><p>Measurement identifier</p>
</dd>
<dt>lat</dt><dd><p>latitude in degrees</p>
</dd>
<dt>lon</dt><dd><p>longitude in degrees</p>
</dd>
<dt>azi</dt><dd><p>SHmax azimuth in degrees</p>
</dd>
<dt>unc</dt><dd><p>MMeasruement standard eviation (in degrees)</p>
</dd>
<dt>type</dt><dd><p>Type of measurement</p>
</dd>
<dt>depth</dt><dd><p>Depth in km</p>
</dd>
<dt>quality</dt><dd><p>WSM quality rank</p>
</dd>
<dt>regime</dt><dd><p>Stress regime</p>
</dd>
</dl>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1126 rows and 10 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1165 rows and 10 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 490 rows and 10 columns.
</p>


<h3>Details</h3>


<dl>
<dt><code style="white-space: pre;">&#8288;'san_andreas"&#8288;</code></dt><dd><p>contains 407 stress data adjacent to the San Andreas
Fault to be tested against a tangentially displaced plate boundary.</p>
</dd>
<dt><code>"tibet"</code></dt><dd><p> contains 947 stress data from the Himalaya and Tibetan
plateau to be tested against an inward-moving displaced plate boundary.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;'iceland&#8288;</code></dt><dd><p>contains 201 stress data from Iceland to be tested against a
outward-moving displaced plate boundary.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.world-stress-map.org/">https://www.world-stress-map.org/</a>
</p>


<h3>References</h3>

<p>Heidbach, O., M. Rajabi, X. Cui, K. Fuchs, B. M&lt;U+00FC&gt;ller, J.
Reinecker, K. Reiter, M. Tingay, F. Wenzel, F. Xie, M. O. Ziegler,
M.-L. Zoback, and M. D. Zoback (2018): The World Stress Map database
release 2016: Crustal stress pattern across scales. <em>Tectonophysics</em>,
<strong>744</strong>, 484-498, <a href="https://doi.org/10.1016/j.tecto.2018.07.007">doi:10.1016/j.tecto.2018.07.007</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+download_WSM2016">download_WSM2016()</a></code> for description of columns and stress regime
acronyms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
head(san_andreas)

data("tibet")
head(tibet)

data("iceland")
head(iceland)
</code></pre>

<hr>
<h2 id='stress_paths'>Theoretical Plate Tectonic Stress Paths</h2><span id='topic+stress_paths'></span><span id='topic+eulerpole_paths'></span><span id='topic+eulerpole_smallcircles'></span><span id='topic+eulerpole_greatcircles'></span><span id='topic+eulerpole_loxodromes'></span>

<h3>Description</h3>

<p>Construct <code class="reqn">\sigma_{Hmax}</code> lines that are
following small circles, great circles, or loxodromes of an Euler pole for
the relative plate motion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulerpole_paths(x, type = c("sc", "gc", "ld"), n = 10, angle = 45, cw)

eulerpole_smallcircles(x, n = 10)

eulerpole_greatcircles(x, n = 10)

eulerpole_loxodromes(x, n = 10, angle = 45, cw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stress_paths_+3A_x">x</code></td>
<td>
<p>Either an object of class <code>"euler.pole"</code> or <code>"data.frame"</code>
containing coordinates of Euler pole in lat, lon, and rotation angle
(optional).</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of curves to export. Either
<code>"sm"</code> for small circles (default), <code>"gc"</code> for great circles, or
<code>"ld"</code> for loxodromes.</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_n">n</code></td>
<td>
<p>Number of equally spaced curves; <code>n = 10</code> by default (angular
distance between curves: <code>180 / n</code>)</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_angle">angle</code></td>
<td>
<p>Direction of loxodromes; <code>angle = 45</code> by default.</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_cw">cw</code></td>
<td>
<p>logical. Sense of loxodromes: <code>TRUE</code> for clockwise
loxodromes (left-lateral displaced plate boundaries). <code>FALSE</code> for
counterclockwise loxodromes (right-lateral displaced plate boundaries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximum horizontal stress can be aligned to three types of curves
related to relative plate motion:
</p>

<dl>
<dt>Small circles</dt><dd><p>Lines that have a constant distance to the Euler pole.
If <code>x</code> contains <code>angle</code>, output additionally gives absolute
velocity on small circle (degree/Myr -&gt; km/Myr).</p>
</dd>
<dt>Great circles</dt><dd><p>Paths of the shortest distance between the Euler
pole and its antipodal position.</p>
</dd>
<dt>Loxodromes</dt><dd><p>Lines of constant bearing, i.e. curves cutting small
circles at a constant angle.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>sf</code> object
</p>


<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to
# Pacific plate

eulerpole_smallcircles(por)
eulerpole_greatcircles(por)
eulerpole_loxodromes(x = por, angle = 45, n = 10, cw = FALSE)
eulerpole_loxodromes(x = por, angle = 30, cw = TRUE)
eulerpole_smallcircles(data.frame(lat = 30, lon = 10))
</code></pre>

<hr>
<h2 id='stress2grid'>Spatial Interpolation of SHmax</h2><span id='topic+stress2grid'></span><span id='topic+stress2grid_stats'></span>

<h3>Description</h3>

<p>Stress field interpolation and wavelength analysis using a kernel (weighted)
mean/median and standard deviation/IQR of stress data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress2grid(
  x,
  stat = c("mean", "median"),
  grid = NULL,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2,
  min_data = 3L,
  threshold = 25,
  arte_thres = 200,
  method_weighting = FALSE,
  quality_weighting = TRUE,
  dist_weight = c("inverse", "linear", "none"),
  idp = 1,
  qp = 1,
  mp = 1,
  dist_threshold = 0.1,
  R_range = seq(50, 1000, 50),
  ...
)

stress2grid_stats(
  x,
  grid = NULL,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2,
  min_data = 4L,
  threshold = 25,
  arte_thres = 200,
  method_weighting = FALSE,
  quality_weighting = TRUE,
  dist_weight = c("inverse", "linear", "none"),
  idp = 1,
  qp = 1,
  mp = 1,
  dist_threshold = 0.1,
  R_range = seq(50, 1000, 50),
  kappa = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stress2grid_+3A_x">x</code></td>
<td>
<p><code>sf</code> object containing
</p>

<dl>
<dt>azi</dt><dd><p>SHmax in degree</p>
</dd>
<dt>unc</dt><dd><p>(optional) Uncertainties of SHmax in degree</p>
</dd>
<dt>type</dt><dd><p>(optional) Methods used for the determination of the direction
of SHmax</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stress2grid_+3A_stat">stat</code></td>
<td>
<p>whether the direction of interpolated SHmax is based on the
circular mean and standard deviation (<code>"mean"</code>, the default) or the
circular median and interquartile range (<code>"median"</code>)</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_grid">grid</code></td>
<td>
<p>(optional) Point object of class <code>sf</code>.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_lon_range">lon_range</code>, <code id="stress2grid_+3A_lat_range">lat_range</code></td>
<td>
<p>(optional) numeric vector specifying the minimum
and maximum longitudes and latitudes (ignored if <code>grid</code> is specified).</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_gridsize">gridsize</code></td>
<td>
<p>numeric. Target spacing of the regular grid in decimal
degree. Default is <code>2.5</code>. (is ignored if <code>grid</code> is specified)</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_min_data">min_data</code></td>
<td>
<p>integer. Minimum number of data per bin. Default is <code>3</code> for
<code><a href="#topic+stress2grid">stress2grid()</a></code>and <code>4</code> for <code><a href="#topic+stress2grid_stats">stress2grid_stats()</a></code>.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_threshold">threshold</code></td>
<td>
<p>numeric. Threshold for deviation of direction. Default is
<code>25</code></p>
</td></tr>
<tr><td><code id="stress2grid_+3A_arte_thres">arte_thres</code></td>
<td>
<p>numeric. Maximum distance (in km) of the grid point to the
next data point. Default is <code>200</code></p>
</td></tr>
<tr><td><code id="stress2grid_+3A_method_weighting">method_weighting</code></td>
<td>
<p>logical. If a method weighting should be applied:
Default is <code>FALSE</code>. If <code>FALSE</code>, overwrites <code>mp</code>.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_quality_weighting">quality_weighting</code></td>
<td>
<p>logical. If a quality weighting should be applied:
Default is <code>TRUE</code>. If <code>FALSE</code>, overwrites <code>qp</code>.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_dist_weight">dist_weight</code></td>
<td>
<p>Distance weighting method which should be used. One of
<code>"none"</code>, <code>"linear"</code>, or <code>"inverse"</code> (the default).</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_idp">idp</code>, <code id="stress2grid_+3A_qp">qp</code>, <code id="stress2grid_+3A_mp">mp</code></td>
<td>
<p>numeric. The weighting power of inverse distance, quality
and method. Default is <code>1</code>. The higher the value, the more weight it will
put. When set to <code>0</code>, no weighting is applied. <code>idp</code> is only effective if
inverse distance weighting (<code>dist_weight="inverse"</code>) is applied.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_dist_threshold">dist_threshold</code></td>
<td>
<p>numeric. Distance weight to prevent overweight of data
nearby (0 to 1). Default is <code>0.1</code></p>
</td></tr>
<tr><td><code id="stress2grid_+3A_r_range">R_range</code></td>
<td>
<p>numeric value or vector specifying the kernel half-width(s),
i.e. the search radius (in km). Default is <code>seq(50, 1000, 50)</code></p>
</td></tr>
<tr><td><code id="stress2grid_+3A_...">...</code></td>
<td>
<p>(optional) arguments to <code><a href="#topic+dist_greatcircle">dist_greatcircle()</a></code></p>
</td></tr>
<tr><td><code id="stress2grid_+3A_kappa">kappa</code></td>
<td>
<p>numeric. von Mises distribution concentration parameter used
for the circular mode. Will be estimated using <code><a href="#topic+est.kappa">est.kappa()</a></code> if not provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+stress2grid">stress2grid()</a></code> is a modified version of the MATLAB script
&quot;stress2grid&quot; by Ziegler and Heidbach (2019).
<code><a href="#topic+stress2grid_stats">stress2grid_stats()</a></code> is based on <code><a href="#topic+stress2grid">stress2grid()</a></code> but yields more circular
summary statistics (see <code><a href="#topic+circular_summary">circular_summary()</a></code>).
</p>


<h3>Value</h3>

<p><code>sf</code> object containing
</p>

<dl>
<dt>lon,lat</dt><dd><p>longitude and latitude in degrees</p>
</dd>
<dt>azi</dt><dd><p>Mean SHmax in degree</p>
</dd>
<dt>sd</dt><dd><p>Standard deviation of SHmax in degrees</p>
</dd>
<dt>R</dt><dd><p>Search radius in km</p>
</dd>
<dt>mdr</dt><dd><p>Mean distance of datapoints per search radius</p>
</dd>
<dt>N</dt><dd><p>Number of data points in search radius</p>
</dd>
</dl>

<p>When <code><a href="#topic+stress2grid_stats">stress2grid_stats()</a></code>, <code>azi</code> and <code>sd</code> are replaced by the output of
<code><a href="#topic+circular_summary">circular_summary()</a></code>.
</p>


<h3>Source</h3>

<p><a href="https://github.com/MorZieg/Stress2Grid">https://github.com/MorZieg/Stress2Grid</a>
</p>


<h3>References</h3>

<p>Ziegler, M. and Heidbach, O. (2019).
Matlab Script Stress2Grid v1.1. GFZ Data Services. <a href="https://doi.org/10.5880/wsm.2019.002">doi:10.5880/wsm.2019.002</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist_greatcircle">dist_greatcircle()</a></code>, <code><a href="#topic+PoR_stress2grid">PoR_stress2grid()</a></code>, <code><a href="#topic+compact_grid">compact_grid()</a></code>,
<code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+circular_median">circular_median()</a></code>, <code><a href="#topic+circular_sd">circular_sd()</a></code>, <code><a href="#topic+circular_summary">circular_summary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
stress2grid(san_andreas, stat = "median")
## Not run: 
stress2grid_stats(san_andreas)

## End(Not run)
</code></pre>

<hr>
<h2 id='superimposed_shmax'>SHmax direction resulting from multiple plate boundaries</h2><span id='topic+superimposed_shmax'></span>

<h3>Description</h3>

<p>Calculates a <code class="reqn">\sigma_{Hmax}</code> direction at given coordinates,
sourced by multiple plate boundaries. This first-order approximation is the
circular mean of the superimposed theoretical directions, weighted by the
rotation rates of the underlying PoRs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superimposed_shmax(df, PoRs, types, absolute = TRUE, PoR_weighting = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="superimposed_shmax_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>), and the direction of
<code class="reqn">\sigma_{Hmax}</code> <code>azi</code> (in degrees)</p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_pors">PoRs</code></td>
<td>
<p>multirow <code>data.frame</code> or <code>"euler.pole"</code> object that must contain <code>lat</code>,
<code>lon</code> and <code>angle</code></p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_types">types</code></td>
<td>
<p>character vector with length equal to number of rows in <code>PoRs</code>.
Type of plate boundary. Must be <code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively.</p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_absolute">absolute</code></td>
<td>
<p>logical. Whether the resultant azimuth should be weighted
using the absolute rotation at the points or the angular rotation of the PoRs.</p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_por_weighting">PoR_weighting</code></td>
<td>
<p>(optional) numeric vector with length equal to number of rows in
<code>PoRs</code>. Extra weightings for the used PoRs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two column vector. <code>azi</code> is the resultant azimuth in degrees /
geographical CRS), <code>R</code> is the resultant length.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_shmax">model_shmax()</a></code>
</p>
<p><code><a href="#topic+superimposed_shmax_PB">superimposed_shmax_PB()</a></code> for considering distances to plate boundaries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(san_andreas)
data(nuvel1)
pors &lt;- subset(nuvel1, plate.rot %in% c("eu", "na"))
res &lt;- superimposed_shmax(san_andreas, pors, types = c("in", "right"), PoR_weighting = c(2, 1))
head(res)
</code></pre>

<hr>
<h2 id='superimposed_shmax_PB'>SHmax direction resulting from multiple plate boundaries considering distance
to plate boundaries</h2><span id='topic+superimposed_shmax_PB'></span>

<h3>Description</h3>

<p>Calculates a <code class="reqn">\sigma_{Hmax}</code> direction at given coordinates,
sourced by multiple plate boundaries. This first-order approximation is the
circular mean of the superimposed theoretical directions, weighted by the
rotation rates of the underlying PoRs, the inverse distance to the plate
boundaries, and the type of plate boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superimposed_shmax_PB(
  x,
  pbs,
  model,
  rotation_weighting = TRUE,
  type_weights = c(divergent = 1, convergent = 3, transform_L = 2, transform_R = 2),
  idp = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="superimposed_shmax_PB_+3A_x">x</code></td>
<td>
<p>grid. An object of <code>sf</code>, <code>sfc</code> or 2-column matrix</p>
</td></tr>
<tr><td><code id="superimposed_shmax_PB_+3A_pbs">pbs</code></td>
<td>
<p>plate boundaries. <code>sf</code> object</p>
</td></tr>
<tr><td><code id="superimposed_shmax_PB_+3A_model">model</code></td>
<td>
<p><code>data.frame</code> containing the Euler pole parameters. See
<code><a href="#topic+equivalent_rotation">equivalent_rotation()</a></code> for details.</p>
</td></tr>
<tr><td><code id="superimposed_shmax_PB_+3A_rotation_weighting">rotation_weighting</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="superimposed_shmax_PB_+3A_type_weights">type_weights</code></td>
<td>
<p>named vector.</p>
</td></tr>
<tr><td><code id="superimposed_shmax_PB_+3A_idp">idp</code></td>
<td>
<p>numeric. Weighting power of inverse distance. The higher the
number, the less impact far-distant boundaries have. When set to <code>0</code>, no
weighting is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two-column matrix. <code>azi</code> is the resultant azimuth (in degrees), <code>R</code>
is the resultant length.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+superimposed_shmax">superimposed_shmax()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_grid &lt;- sf::st_make_grid(san_andreas, what = "centers", cellsize = 1)
na_plate &lt;- subset(plates, plateA == "na" | plateB == "na")
cpm &lt;- cpm_models[["NNR-MORVEL56"]]

# make divergent to ridge-push:
na_plate &lt;- transform(na_plate, type = ifelse(na_plate$pair == "eu-na", "convergent", type))

res &lt;- superimposed_shmax_PB(na_grid, na_plate, model = cpm, idp = 2)
head(res)
</code></pre>

<hr>
<h2 id='tectonicr.colors'>Colors for input variables</h2><span id='topic+tectonicr.colors'></span>

<h3>Description</h3>

<p>assigns colors to continuous or categorical values for plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tectonicr.colors(
  x,
  n = 10,
  pal = NULL,
  categorical = FALSE,
  na.value = "grey",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tectonicr.colors_+3A_x">x</code></td>
<td>
<p>values for color assignment</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_n">n</code></td>
<td>
<p>integer. number of colors for continuous colors (i.e.
'categorical = FALSE&ldquo;).</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_pal">pal</code></td>
<td>
<p>either a named vector specifying the colors for categorical
values, or a color function. If <code>NULL</code>, default colors are
<code>RColorBrewer::brewer.pal()</code>
(<code>categorical = TRUE</code>) and <code>viridis::viridis()</code> (<code>categorical = FALSE</code>).</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_categorical">categorical</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_na.value">na.value</code></td>
<td>
<p>color for <code>NA</code> values (categorical).</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_...">...</code></td>
<td>
<p>optional arguments passed to palette function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named color vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>val1 &lt;- c("N", "S", "T", "T", NA)
tectonicr.colors(val1, categorical = TRUE)
tectonicr.colors(val1, pal = stress_colors(), categorical = TRUE)

val2 &lt;- runif(10)
tectonicr.colors(val2, n = 5)
</code></pre>

<hr>
<h2 id='trigon'>Trigonometric Functions in Degrees</h2><span id='topic+trigon'></span><span id='topic+sind'></span><span id='topic+cosd'></span><span id='topic+tand'></span><span id='topic+asind'></span><span id='topic+acosd'></span><span id='topic+atand'></span><span id='topic+atan2d'></span><span id='topic+cot'></span><span id='topic+cotd'></span>

<h3>Description</h3>

<p>Trigonometric functions expecting input in degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sind(x)

cosd(x)

tand(x)

asind(x)

acosd(x)

atand(x)

atan2d(x1, x2)

cot(x)

cotd(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trigon_+3A_x">x</code>, <code id="trigon_+3A_x1">x1</code>, <code id="trigon_+3A_x2">x2</code></td>
<td>
<p>Numeric or complex vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar or vector of numeric values.
</p>

<hr>
<h2 id='vcross'>Vector cross product</h2><span id='topic+vcross'></span>

<h3>Description</h3>

<p>Vector or cross product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcross(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcross_+3A_x">x</code>, <code id="vcross_+3A_y">y</code></td>
<td>
<p>numeric vectors of length 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of length 3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcross(c(1, 2, 3), c(4, 5, 6))
</code></pre>

<hr>
<h2 id='vm_qqplot'>von Mises Quantile-Quantile Plot</h2><span id='topic+vm_qqplot'></span>

<h3>Description</h3>

<p>Produces a Q-Q plot of the data against a specified von Mises distribution
to graphically assess the goodness of fit of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vm_qqplot(
  x,
  w = NULL,
  axial = TRUE,
  mean = NULL,
  kappa = NULL,
  xlab = "von Mises quantile function",
  ylab = "Empirical quantile function",
  main = "von Mises Q-Q Plot",
  col = "#B63679FF",
  add_line = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vm_qqplot_+3A_x">x</code></td>
<td>
<p>numeric. Angles in degrees</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_w">w</code></td>
<td>
<p>numeric. optional weightings for <code>x</code> to estimate <code>mean</code> and <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_mean">mean</code></td>
<td>
<p>numeric. Circular mean of the von Mises distribution. If <code>NULL</code>,
it will be estimated from <code>x</code>.</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_kappa">kappa</code></td>
<td>
<p>numeric. Concentration parameter of the von Mises distribution.
If <code>NULL</code>, it will be estimated from <code>x</code>.</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_xlab">xlab</code>, <code id="vm_qqplot_+3A_ylab">ylab</code>, <code id="vm_qqplot_+3A_main">main</code></td>
<td>
<p>plot labels.</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_col">col</code></td>
<td>
<p>color for the dots.</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_add_line">add_line</code></td>
<td>
<p>logical. Whether to connect the points by straight lines?</p>
</td></tr>
<tr><td><code id="vm_qqplot_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># von Mises distribution
x_vm &lt;- rvm(100, mean = 0, kappa = 4)
vm_qqplot(x_vm, axial = FALSE, pch = 20)

# uniform distribution
x_unif &lt;- runif(100, 0, 360)
vm_qqplot(x_unif, axial = FALSE, pch = 20)
</code></pre>

<hr>
<h2 id='vonmises'>The von Mises Distribution</h2><span id='topic+vonmises'></span><span id='topic+rvm'></span><span id='topic+dvm'></span><span id='topic+pvm'></span><span id='topic+qvm'></span>

<h3>Description</h3>

<p>Density, probability distribution function, quantiles, and random generation
for the circular normal distribution with mean and kappa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvm(n, mean, kappa)

dvm(theta, mean, kappa, log = FALSE, axial = FALSE)

pvm(theta, mean, kappa, from = NULL, tol = 1e-20)

qvm(p, mean = 0, kappa, from = NULL, tol = .Machine$double.eps^(0.6), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vonmises_+3A_n">n</code></td>
<td>
<p>integer. Number of observations in degrees</p>
</td></tr>
<tr><td><code id="vonmises_+3A_mean">mean</code></td>
<td>
<p>numeric. Mean angle in degrees</p>
</td></tr>
<tr><td><code id="vonmises_+3A_kappa">kappa</code></td>
<td>
<p>numeric. Concentration parameter in the range (0, Inf]</p>
</td></tr>
<tr><td><code id="vonmises_+3A_theta">theta</code></td>
<td>
<p>numeric. Angular value in degrees</p>
</td></tr>
<tr><td><code id="vonmises_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="vonmises_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="vonmises_+3A_from">from</code></td>
<td>
<p>if <code>NULL</code> is set to <code class="reqn">\mu-\pi</code>. This is the value from
which the pvm and qvm are evaluated. in degrees.</p>
</td></tr>
<tr><td><code id="vonmises_+3A_tol">tol</code></td>
<td>
<p>numeric. The precision in evaluating the distribution function or the quantile.</p>
</td></tr>
<tr><td><code id="vonmises_+3A_p">p</code></td>
<td>
<p>numeric. Vector of probabilities with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="vonmises_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="stats.html#topic+integrate">stats::integrate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dvm</code> gives the density,
<code>pvm</code> gives the probability of the von Mises distribution function,
<code>rvm</code> generates random deviates (in degrees), and
<code>qvm</code> provides quantiles (in degrees).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rvm(5, mean = 90, kappa = 2)

dvm(x, mean = 90, kappa = 2)
dvm(x, mean = 90, kappa = 2, axial = TRUE)

pvm(x, mean = 90, kappa = 2)
qvm(c(.25, .5, .75), mean = 90, kappa = 2)
</code></pre>

<hr>
<h2 id='watson_test'>Watson's <code class="reqn">U^2</code> Test of Circular Uniformity</h2><span id='topic+watson_test'></span>

<h3>Description</h3>

<p>Watson's test statistic is a rotation-invariant Cramer - von Mises test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watson_test(
  x,
  alpha = 0,
  dist = c("uniform", "vonmises"),
  axial = TRUE,
  mu = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="watson_test_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees</p>
</td></tr>
<tr><td><code id="watson_test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the test. Valid levels are <code>0.01</code>, <code>0.05</code>,
and <code>0.1</code>.
This argument may be omitted (<code>NULL</code>, the default), in which case, a range
for the p-value will be returned.</p>
</td></tr>
<tr><td><code id="watson_test_+3A_dist">dist</code></td>
<td>
<p>Distribution to test for. The default, <code>"uniform"</code>, is the
uniform distribution. <code>"vonmises"</code> tests the von Mises distribution.</p>
</td></tr>
<tr><td><code id="watson_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or circular, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="watson_test_+3A_mu">mu</code></td>
<td>
<p>(optional) The specified mean direction (in degrees) in alternative
hypothesis</p>
</td></tr>
<tr><td><code id="watson_test_+3A_quiet">quiet</code></td>
<td>
<p>logical. Prints the test's decision.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>statistic &gt; p.value</code>, the null hypothesis is rejected.
If not, randomness (uniform distribution) cannot be excluded.
</p>


<h3>Value</h3>

<p>list containing the test statistic <code>statistic</code> and the significance
level <code>p.value</code>.
</p>


<h3>References</h3>

<p>Mardia and Jupp (2000). Directional Statistics. John Wiley and
Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Mardia and Jupp (2001), pp. 93
pidgeon_homing &lt;- c(55, 60, 65, 95, 100, 110, 260, 275, 285, 295)
watson_test(pidgeon_homing, alpha = .05)

# San Andreas Fault Data:
data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
watson_test(sa.por$azi.PoR, alpha = .05)
watson_test(sa.por$azi.PoR, alpha = .05, dist = "vonmises")
</code></pre>

<hr>
<h2 id='weighted_rayleigh'>Weighted Goodness-of-fit Test for Circular Data</h2><span id='topic+weighted_rayleigh'></span>

<h3>Description</h3>

<p>Weighted version of the Rayleigh test (or V0-test) for uniformity against a
distribution with a priori expected von Mises concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_rayleigh(x, mu = NULL, w = NULL, axial = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_rayleigh_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees</p>
</td></tr>
<tr><td><code id="weighted_rayleigh_+3A_mu">mu</code></td>
<td>
<p>The <em>a priori</em> expected direction (in degrees) for the alternative
hypothesis.</p>
</td></tr>
<tr><td><code id="weighted_rayleigh_+3A_w">w</code></td>
<td>
<p>numeric vector weights of length <code>length(x)</code>. If <code>NULL</code>, the
non-weighted Rayleigh test is performed.</p>
</td></tr>
<tr><td><code id="weighted_rayleigh_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="weighted_rayleigh_+3A_quiet">quiet</code></td>
<td>
<p>logical. Prints the test's decision.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Null hypothesis is uniformity (randomness). The alternative is a
distribution with a (specified) mean direction (<code>mu</code>).
If <code>statistic &gt;= p.value</code>, the null hypothesis of randomness is rejected and
angles derive from a distribution with a (or the specified) mean direction.
</p>


<h3>Value</h3>

<p>a list with the components:
</p>

<dl>
<dt><code>R</code> or <code>C</code></dt><dd><p>mean resultant length or the dispersion (if <code>mu</code> is
specified). Small values of <code>R</code> (large values of <code>C</code>) will reject
uniformity. Negative values of <code>C</code> indicate that vectors point in opposite
directions (also lead to rejection).</p>
</dd>
<dt><code>statistic</code></dt><dd><p>Test statistic</p>
</dd>
<dt><code>p.value</code></dt><dd><p>significance level of the test statistic</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rayleigh_test">rayleigh_test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("cpm_models")
data(san_andreas)
PoR &lt;- equivalent_rotation(cpm_models[["NNR-MORVEL56"]], "na", "pa")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
data("iceland")
PoR.ice &lt;- equivalent_rotation(cpm_models[["NNR-MORVEL56"]], "eu", "na")
ice.por &lt;- PoR_shmax(iceland, PoR.ice, "out")
data("tibet")
PoR.tib &lt;- equivalent_rotation(cpm_models[["NNR-MORVEL56"]], "eu", "in")
tibet.por &lt;- PoR_shmax(tibet, PoR.tib, "in")

# GOF test:
weighted_rayleigh(tibet.por$azi.PoR, mu = 90, w = 1 / tibet$unc)
weighted_rayleigh(ice.por$azi.PoR, mu = 0, w = 1 / iceland$unc)
weighted_rayleigh(sa.por$azi.PoR, mu = 135, w = 1 / san_andreas$unc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
