<!DOCTYPE html><html><head><title>Help for package tectonicr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tectonicr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tectonicr'><p>library(tectonicr)</p></a></li>
<li><a href='#abs_vel'><p>Absolute Plate Velocity</p></a></li>
<li><a href='#angle_vectors'><p>Angle Between Two Vectors</p></a></li>
<li><a href='#angle-conversion'><p>Degrees to Radians</p></a></li>
<li><a href='#axes'><p>Plot axes</p></a></li>
<li><a href='#circle_stats'><p>Summary Statistics of Circular Data</p></a></li>
<li><a href='#circular_dispersion_boot'><p>Bootstrapped estimates for circular dispersion</p></a></li>
<li><a href='#circular_sd_error'><p>Standard Error of Mean Direction of Circular Data</p></a></li>
<li><a href='#compact_grid'><p>Compact smoothed stress field</p></a></li>
<li><a href='#confidence'><p>Confidence Interval around the Mean Direction of Circular Data</p></a></li>
<li><a href='#conjugate_Q4'><p>Conjugation of a Quaternion</p></a></li>
<li><a href='#coordinate_mod'><p>Coordinate Correction</p></a></li>
<li><a href='#coordinates'><p>Coordinate Transformations</p></a></li>
<li><a href='#coordinates2'><p>Coordinate Transformations</p></a></li>
<li><a href='#cpm_models'><p>Global model of current plate motions</p></a></li>
<li><a href='#deviation_norm'><p>Normalize Angle Between Two Directions</p></a></li>
<li><a href='#deviation_shmax'><p>Deviation of Observed and Predicted Directions of Maximum Horizontal Stress</p></a></li>
<li><a href='#dispersion'><p>Circular distance and dispersion</p></a></li>
<li><a href='#dispersion_grid'><p>Spatial analysis of dispersion</p></a></li>
<li><a href='#dist_greatcircle'><p>Distance between points</p></a></li>
<li><a href='#distance_from_pb'><p>Distance from plate boundary</p></a></li>
<li><a href='#distance_mod'><p>Normalize angular distance on a sphere distance</p></a></li>
<li><a href='#dummy'><p>Plate Stress Dummy Grid</p></a></li>
<li><a href='#earth_radius'><p>Earth's radius in km</p></a></li>
<li><a href='#equivalent_rotation'><p>Equivalent rotation</p></a></li>
<li><a href='#est.kappa'><p>Concentration parameter of von Mises distribution</p></a></li>
<li><a href='#euler_pole'><p>Euler pole object</p></a></li>
<li><a href='#euler_to_Q4'><p>Quaternion from Euler angle-axis representation for rotations</p></a></li>
<li><a href='#get_azimuth'><p>Azimuth Between two Points</p></a></li>
<li><a href='#get_distance'><p>Helper function to Distance from plate boundary</p></a></li>
<li><a href='#get_projected_pb_strike'><p>Helper function to get Distance from plate boundary</p></a></li>
<li><a href='#get_relrot'><p>Helper function to Equivalent rotation</p></a></li>
<li><a href='#iceland'><p>Example stress data for outward-moving displaced plate boundary</p></a></li>
<li><a href='#is.euler'><p>Check if object is euler.pole</p></a></li>
<li><a href='#is.Q4'><p>Check if object is quaternion</p></a></li>
<li><a href='#kuiper_test'><p>Kuiper Test of Circular Uniformity</p></a></li>
<li><a href='#line_azimuth'><p>Extract azimuths of line segments</p></a></li>
<li><a href='#mean_resultant_length'><p>Mean Resultant Length</p></a></li>
<li><a href='#model_shmax'><p>Theoretical Direction of Maximum Horizontal Stress in the</p>
geographical reference system.</a></li>
<li><a href='#norm_chisq'><p>Normalized Chi-Squared Test for Circular Data</p></a></li>
<li><a href='#normalize_Q4'><p>Quaternion normalization</p></a></li>
<li><a href='#nuvel1'><p>NUVEL-1 Global model of current plate motions</p></a></li>
<li><a href='#nuvel1_plates'><p>Plate Boundaries on the Earth</p></a></li>
<li><a href='#pb2002'><p>Global model of current plate motions</p></a></li>
<li><a href='#plates'><p>Plate Boundaries on the Earth</p></a></li>
<li><a href='#PoR_coordinates'><p>PoR coordinates</p></a></li>
<li><a href='#PoR_crs'><p>PoR coordinate reference system</p></a></li>
<li><a href='#PoR_map'><p>Plot data in PoR map</p></a></li>
<li><a href='#PoR_shmax'><p>Direction of Maximum Horizontal Stress in PoR reference</p>
system</a></li>
<li><a href='#PoR_stress2grid'><p>Spatial interpolation of SHmax in PoR coordinate reference system</p></a></li>
<li><a href='#por_transformation_df'><p>Conversion between spherical PoR to geographical coordinate system</p></a></li>
<li><a href='#por_transformation_quat'><p>Conversion between PoR to geographical coordinate system using quaternions</p></a></li>
<li><a href='#por_transformation_sf'><p>Conversion between PoR to geographical coordinates of spatial data</p></a></li>
<li><a href='#PoR2Geo_azimuth'><p>Azimuth conversion from PoR to geographical coordinate reference system</p></a></li>
<li><a href='#PositionCenterSpoke'><p>Centrically aligned geom_spoke marker</p></a></li>
<li><a href='#prd_err'><p>Error of Model's Prediction</p></a></li>
<li><a href='#product_Q4'><p>Product of quaternions</p></a></li>
<li><a href='#projected_pb_strike'><p>Strike of the plate boundary projected on data point</p></a></li>
<li><a href='#Q4_to_euler'><p>Euler angle/axis from quaternion</p></a></li>
<li><a href='#quantise_wsm_quality'><p>Numerical values to World Stress Map Quality Ranking</p></a></li>
<li><a href='#quick_plot'><p>Plotting stress analysis results</p></a></li>
<li><a href='#raster_transformation'><p>Conversion between PoR to geographical coordinate reference system of raster</p>
data</a></li>
<li><a href='#rayleigh_test'><p>Rayleigh Test of Circular Uniformity</p></a></li>
<li><a href='#relative_rotation'><p>Relative rotation between two rotations</p></a></li>
<li><a href='#roll_circstats'><p>Apply Rolling Functions using Circular Statistics</p></a></li>
<li><a href='#rolling_test'><p>Apply Rolling Functions using Circular Statistical Tests for Uniformity</p></a></li>
<li><a href='#rolling_test_dist'><p>Apply Rolling Functions using Circular Statistics</p></a></li>
<li><a href='#rose'><p>Rose Diagram</p></a></li>
<li><a href='#rose_baseplot'><p>Rose Diagram</p></a></li>
<li><a href='#rose_bw'><p>Selecting optimal number of bins and width for rose diagrams</p></a></li>
<li><a href='#rose_geom'><p>Lines and fans in rose diagram</p></a></li>
<li><a href='#rose_stats'><p>Show Average Direction and Spread in Rose Diagram</p></a></li>
<li><a href='#rotate_lines'><p>Rotate Lines</p></a></li>
<li><a href='#rotation_Q4'><p>Rotation of a vector by a quaternion</p></a></li>
<li><a href='#san_andreas'><p>Example stress data for tangentially displaced plate boundary</p></a></li>
<li><a href='#spec_atan'><p>Quadrant-specific inverse of the tangent</p></a></li>
<li><a href='#spherical_angle'><p>Angle along great circle on spherical surface</p></a></li>
<li><a href='#stress_analysis'><p>Quick analysis of a stress data set</p></a></li>
<li><a href='#stress_colors'><p>Color palette for stress regime</p></a></li>
<li><a href='#stress_paths'><p>Theoretical Plate Tectonic Stress Paths</p></a></li>
<li><a href='#stress2grid'><p>Spatial interpolation of SHmax</p></a></li>
<li><a href='#superimposed_shmax'><p>SHmax direction resulting from multiple plate boundaries</p></a></li>
<li><a href='#tectonicr.colors'><p>Colors for input variables</p></a></li>
<li><a href='#tibet'><p>Example stress data for inward-moving displaced plate boundary</p></a></li>
<li><a href='#trigon'><p>Trigonometric Functions in Degrees</p></a></li>
<li><a href='#vcross'><p>Vector cross product</p></a></li>
<li><a href='#vonmises'><p>The von Mises Distribution</p></a></li>
<li><a href='#watson_test'><p>Watson's <code class="reqn">U^2</code> Test of Circular Uniformity</p></a></li>
<li><a href='#weighted_rayleigh'><p>Weighted Goodness-of-fit Test for Circular Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analyzing the Orientation of Maximum Horizontal Stress</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.95</td>
</tr>
<tr>
<td>Description:</td>
<td>Models the direction of the maximum horizontal stress using
    relative plate motion parameters. Statistical algorithms to evaluate
    the modeling results compared with the observed data. Provides plots
    to visualize the results. Methods described in Stephan et al. (2023)
    &lt;<a href="https://doi.org/10.1038%2Fs41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>&gt; and Wdowinski (1998)
    &lt;<a href="https://doi.org/10.1016%2FS0079-1946%2898%2900091-3">doi:10.1016/S0079-1946(98)00091-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tobiste.github.io/tectonicr/">https://tobiste.github.io/tectonicr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tobiste/tectonicr/issues">https://github.com/tobiste/tectonicr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, dplyr, ggplot2, methods, RColorBrewer, sf, smoothr,
spatstat.explore, spatstat.geom, spatstat.utils, terra, tidyr,
viridis, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggforce, knitr, rmarkdown, roxygen2, testthat (&ge; 3.0.0),
tidyterra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-02 00:51:31 UTC; tobis</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Stephan <a href="https://orcid.org/0000-0002-9290-014X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Stephan &lt;tobias.stephan1@yahoo.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-02 04:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tectonicr'>library(tectonicr)</h2><span id='topic+tectonicr'></span><span id='topic+_PACKAGE'></span><span id='topic+tectonicr-package'></span>

<h3>Description</h3>

<p>Modeling the Direction of the Maximum Horizontal Stress using Relative Plate
Motion
</p>


<h3>Details</h3>

<p>Further details and theoretical background are provided by Wdowinski
(1998) and Stephan et al. (2023).
</p>


<h3>Note</h3>

<p>A list of documented functions may be viewed by typing
<code>help(package="tectonicr")</code>.
</p>


<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>References</h3>

<p>Wdowinski (1998) &quot;A theory of intraplate tectonics&quot;.
<em>JGR: Solid Earth</em>, 103(3), 5037–5059.
</p>
<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the horizontal
orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023).
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tobiste.github.io/tectonicr/">https://tobiste.github.io/tectonicr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tobiste/tectonicr/issues">https://github.com/tobiste/tectonicr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abs_vel'>Absolute Plate Velocity</h2><span id='topic+abs_vel'></span>

<h3>Description</h3>

<p>Calculates the absolute angular velocity of plate motion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_vel(w, alpha, r = earth_radius())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abs_vel_+3A_w">w</code></td>
<td>
<p>Angular velocity or rate or angle of rotation</p>
</td></tr>
<tr><td><code id="abs_vel_+3A_alpha">alpha</code></td>
<td>
<p>Angular distance to Euler pole or small circle around Euler pole</p>
</td></tr>
<tr><td><code id="abs_vel_+3A_r">r</code></td>
<td>
<p>Radius. Default is WGS84 Earth's radius (6371.009 km)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric (unit of velocity: km/Myr)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+earth_radius">earth_radius()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abs_vel(0.21, 0)
abs_vel(0.21, 45)
abs_vel(0.21, 90)
</code></pre>

<hr>
<h2 id='angle_vectors'>Angle Between Two Vectors</h2><span id='topic+angle_vectors'></span>

<h3>Description</h3>

<p>Calculates the angle between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_vectors(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_vectors_+3A_x">x</code>, <code id="angle_vectors_+3A_y">y</code></td>
<td>
<p>Vectors in Cartesian coordinates. Can be vectors of three numbers
or a matrix of 3 columns (x, y, z)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. angle in degrees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- c(1, -2, 3)
v &lt;- c(-2, 1, 1)
angle_vectors(u, v)
</code></pre>

<hr>
<h2 id='angle-conversion'>Degrees to Radians</h2><span id='topic+angle-conversion'></span><span id='topic+rad2deg'></span><span id='topic+deg2rad'></span>

<h3>Description</h3>

<p>Helper functions to transform between angles in degrees and
radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad2deg(rad)

deg2rad(deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle-conversion_+3A_rad">rad</code></td>
<td>
<p>(array of) angles in radians.</p>
</td></tr>
<tr><td><code id="angle-conversion_+3A_deg">deg</code></td>
<td>
<p>(array of) angles in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. angle in degrees or radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deg2rad(seq(-90, 90, 15))
rad2deg(seq(-pi / 2, pi / 2, length = 13))
</code></pre>

<hr>
<h2 id='axes'>Plot axes</h2><span id='topic+axes'></span>

<h3>Description</h3>

<p>Plot axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axes(
  x,
  y,
  angle,
  radius = 0.5,
  arrow.code = 1,
  arrow.length = 0,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axes_+3A_x">x</code>, <code id="axes_+3A_y">y</code></td>
<td>
<p>coordinates of points</p>
</td></tr>
<tr><td><code id="axes_+3A_angle">angle</code></td>
<td>
<p>Azimuth in degrees</p>
</td></tr>
<tr><td><code id="axes_+3A_radius">radius</code></td>
<td>
<p>length of axis</p>
</td></tr>
<tr><td><code id="axes_+3A_arrow.code">arrow.code</code></td>
<td>
<p>integer. Kind of arrow head. The default is <code>1</code>, i.e. no
arrow head. See <code><a href="graphics.html#topic+arrows">graphics::arrows()</a></code> for details</p>
</td></tr>
<tr><td><code id="axes_+3A_arrow.length">arrow.length</code></td>
<td>
<p>numeric Length of the edges of the arrow head (in
inches). (Ignored if <code>arrow.code = 1</code>)</p>
</td></tr>
<tr><td><code id="axes_+3A_add">add</code></td>
<td>
<p>logical. add to existing plot?</p>
</td></tr>
<tr><td><code id="axes_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+arrows">graphics::arrows()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
axes(san_andreas$lon, san_andreas$lat, san_andreas$azi, add = FALSE)
</code></pre>

<hr>
<h2 id='circle_stats'>Summary Statistics of Circular Data</h2><span id='topic+circle_stats'></span><span id='topic+circular_mean'></span><span id='topic+circular_var'></span><span id='topic+circular_sd'></span><span id='topic+circular_median'></span><span id='topic+circular_quantiles'></span><span id='topic+circular_IQR'></span>

<h3>Description</h3>

<p>Calculate the (weighted median) and standard deviation
of orientation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_mean(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_var(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_sd(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_median(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_quantiles(x, w = NULL, axial = TRUE, na.rm = TRUE)

circular_IQR(x, w = NULL, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle_stats_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circle_stats_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circle_stats_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circle_stats_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Note</h3>

<p>Weighting may be the reciprocal of the data uncertainties.
</p>
<p>Weightings have no effect on quasi-median and quasi-quantiles if
<code>length(x) %% 2 != 1</code> and <code>length(x) %% 4 == 0</code>, respectively.
</p>


<h3>References</h3>


<ul>
<li><p> Mardia, K.V. (1972). Statistics of Directional Data: Probability and
Mathematical Statistics. London: Academic Press.
</p>
</li>
<li><p> Ziegler, M. O.; Heidbach O. (2019). Manual of the Matlab Script
Stress2Grid v1.1. <em>WSM Technical Report</em> 19-02,
GFZ German Research Centre for Geosciences. <a href="https://doi.org/10.2312/wsm.2019.002">doi:10.2312/wsm.2019.002</a>
</p>
</li>
<li><p> Heidbach, O., Tingay, M., Barth, A., Reinecker, J., Kurfess, D., &amp; Mueller,
B. (2010). Global crustal stress pattern based on the World Stress Map
database release 2008. <em>Tectonophysics</em> <strong>482</strong>, 3–15,
<a href="https://doi.org/10.1016/j.tecto.2009.07.023">doi:10.1016/j.tecto.2009.07.023</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvm(10, 0, 100) %% 180
unc &lt;- stats::runif(100, 0, 10)
circular_mean(x, 1 / unc)
circular_var(x, 1 / unc)
circular_sd(x, 1 / unc)
circular_median(x, 1 / unc)
circular_quantiles(x, 1 / unc)
circular_IQR(x, 1 / unc)

data("san_andreas")
circular_mean(san_andreas$azi)
circular_mean(san_andreas$azi, 1 / san_andreas$unc)
circular_median(san_andreas$azi)
circular_median(san_andreas$azi, 1 / san_andreas$unc)
circular_quantiles(san_andreas$azi)
circular_quantiles(san_andreas$azi, 1 / san_andreas$unc)
circular_var(san_andreas$azi)
circular_var(san_andreas$azi, 1 / san_andreas$unc)

data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_mean(sa.por$azi.PoR, 1 / san_andreas$unc)
circular_median(sa.por$azi.PoR, 1 / san_andreas$unc)
circular_var(sa.por$azi.PoR, 1 / san_andreas$unc)
circular_quantiles(sa.por$azi.PoR, 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='circular_dispersion_boot'>Bootstrapped estimates for circular dispersion</h2><span id='topic+circular_dispersion_boot'></span>

<h3>Description</h3>

<p>Calculates bootstrapped estimates of the circular dispersion,
its standard error and its confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_dispersion_boot(
  x,
  y = NULL,
  w = NULL,
  w.y = NULL,
  R = 1000,
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circular_dispersion_boot_+3A_x">x</code></td>
<td>
<p>numeric values in degrees.</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_y">y</code></td>
<td>
<p>numeric. The angle(s) about which the angles <code>x</code> disperse (in degrees).</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_w">w</code>, <code id="circular_dispersion_boot_+3A_w.y">w.y</code></td>
<td>
<p>(optional) Weights for <code>x</code> and <code>y</code>, respectively. A vector of
positive numbers and of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. positive integer
(1000 by default).</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence: <code class="reqn">(1 - \alpha \%)/100</code>.
(<code>0.95</code> by default).</p>
</td></tr>
<tr><td><code id="circular_dispersion_boot_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="boot.html#topic+boot">boot::boot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing:
</p>

<dl>
<dt><code>MLE</code></dt><dd><p>the maximum likelihood estimate of the circular dispersion</p>
</dd>
<dt><code>sde</code></dt><dd><p>standard error of MLE</p>
</dd>
<dt><code>CI</code></dt><dd><p>lower and upper limit of the confidence interval of MLE</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+circular_dispersion">circular_dispersion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_dispersion(sa.por$azi.PoR, y = 135, w = 1 / san_andreas$unc)
circular_dispersion_boot(sa.por$azi.PoR, y = 135, w = 1 / san_andreas$unc, R = 1000)
</code></pre>

<hr>
<h2 id='circular_sd_error'>Standard Error of Mean Direction of Circular Data</h2><span id='topic+circular_sd_error'></span>

<h3>Description</h3>

<p>Measure of the chance variation expected from sample to sample in estimates of the mean direction.
The approximated standard error of the mean direction is computed by the mean
resultant length and the MLE concentration parameter <code class="reqn">\kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_sd_error(x, w = NULL, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circular_sd_error_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="circular_sd_error_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="circular_sd_error_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circular_sd_error_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Angle in degrees
</p>


<h3>References</h3>

<p>Davis (1986) Statistics and data analysis in geology. 2nd ed., John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_resultant_length">mean_resultant_length()</a></code>, <code><a href="#topic+circular_mean">circular_mean()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
circular_sd_error(finland_stria, axial = FALSE)

data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_sd_error(sa.por$azi.PoR, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='compact_grid'>Compact smoothed stress field</h2><span id='topic+compact_grid'></span>

<h3>Description</h3>

<p>Filter smoothed stress field to smallest wavelength (R) for each coordinate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact_grid(x, type = c("stress2grid", "dispersion_grid"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compact_grid_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+stress2grid">stress2grid()</a></code> or <code><a href="#topic+PoR_stress2grid">PoR_stress2grid()</a></code></p>
</td></tr>
<tr><td><code id="compact_grid_+3A_type">type</code></td>
<td>
<p>character. Type of the grid <code>x</code>. Either &quot;stress2grid&quot; of
&quot;dispersion_grid&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
res &lt;- stress2grid(san_andreas)
compact_grid(res)
</code></pre>

<hr>
<h2 id='confidence'>Confidence Interval around the Mean Direction of Circular Data</h2><span id='topic+confidence'></span><span id='topic+confidence_angle'></span><span id='topic+confidence_interval'></span>

<h3>Description</h3>

<p>Probabilistic limit on the location of the true or population mean direction,
assuming that the estimation errors are normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidence_angle(x, conf.level = 0.95, w = NULL, axial = TRUE, na.rm = TRUE)

confidence_interval(x, conf.level = 0.95, w = NULL, axial = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confidence_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="confidence_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence: <code class="reqn">(1 - \alpha \%)/100</code>.
(<code>0.95</code> by default).</p>
</td></tr>
<tr><td><code id="confidence_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="confidence_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="confidence_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence angle gives the interval, i.e. plus and minus the confidence angle,
around the mean direction of a particular sample, that contains the true
mean direction under a given level of confidence.
</p>


<h3>Value</h3>

<p>Angle in degrees
</p>


<h3>References</h3>


<ul>
<li><p> Davis (1986) Statistics and data analysis in geology. 2nd ed., John Wiley
&amp; Sons.
</p>
</li>
<li><p> Jammalamadaka, S. Rao and Sengupta, A. (2001). Topics in Circular
Statistics, Sections 3.3.3 and 3.4.1, World Scientific Press, Singapore.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mean_resultant_length">mean_resultant_length()</a></code>, <code><a href="#topic+circular_sd_error">circular_sd_error()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
confidence_angle(finland_stria, axial = FALSE)

data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
confidence_angle(sa.por$azi.PoR, w = 1 / san_andreas$unc)
confidence_interval(sa.por$azi.PoR, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='conjugate_Q4'>Conjugation of a Quaternion</h2><span id='topic+conjugate_Q4'></span>

<h3>Description</h3>

<p>Inverse rotation given by conjugated quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjugate_Q4(q, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conjugate_Q4_+3A_q">q</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
<tr><td><code id="conjugate_Q4_+3A_normalize">normalize</code></td>
<td>
<p>logical. Whether a quaternion normalization should be applied (TRUE) or not (FALSE, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>

<hr>
<h2 id='coordinate_mod'>Coordinate Correction</h2><span id='topic+coordinate_mod'></span><span id='topic+longitude_modulo'></span><span id='topic+latitude_modulo'></span>

<h3>Description</h3>

<p>Corrects the longitudes or latitudes to value between -180.0 and
180.0 or -90 and 90 degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longitude_modulo(x)

latitude_modulo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinate_mod_+3A_x">x</code></td>
<td>
<p>Longitude(s) or latitude(s) in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>longitude_modulo(-361 + 5 * 360)
latitude_modulo(-91 + 5 * 180)
</code></pre>

<hr>
<h2 id='coordinates'>Coordinate Transformations</h2><span id='topic+coordinates'></span><span id='topic+cartesian_to_geographical'></span><span id='topic+geographical_to_cartesian'></span><span id='topic+geographical_to_spherical'></span>

<h3>Description</h3>

<p>Converts vector between Cartesian and geographical coordinate
systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartesian_to_geographical(n)

geographical_to_cartesian(p)

geographical_to_spherical(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinates_+3A_n">n</code></td>
<td>
<p>Cartesian coordinates (x, y, z) as vector</p>
</td></tr>
<tr><td><code id="coordinates_+3A_p">p</code></td>
<td>
<p>Geographical coordinates (latitude, longitude) as vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions return a (2- or 3-dimensional) vector representing a
point in the requested coordinate system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cartesian_to_spherical">cartesian_to_spherical()</a></code> and <code><a href="#topic+spherical_to_cartesian">spherical_to_cartesian()</a></code> for
conversions to spherical coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(1, -2, 3)
cartesian_to_geographical(n)
p &lt;- c(50, 10)
geographical_to_cartesian(p)
</code></pre>

<hr>
<h2 id='coordinates2'>Coordinate Transformations</h2><span id='topic+coordinates2'></span><span id='topic+cartesian_to_spherical'></span><span id='topic+spherical_to_cartesian'></span><span id='topic+spherical_to_geographical'></span>

<h3>Description</h3>

<p>Converts vector between Cartesian and spherical coordinate
systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartesian_to_spherical(n)

spherical_to_cartesian(p)

spherical_to_geographical(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinates2_+3A_n">n</code></td>
<td>
<p>Cartesian coordinates (x, y, z) as three-column vector</p>
</td></tr>
<tr><td><code id="coordinates2_+3A_p">p</code></td>
<td>
<p>Spherical coordinates (colatitude, azimuth) as two-column vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions return a (2- or 3-dimensional) vector representing a
point in the requested coordinate system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cartesian_to_geographical">cartesian_to_geographical()</a></code> and <code><a href="#topic+geographical_to_cartesian">geographical_to_cartesian()</a></code> for
conversions to geographical coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(1, -2, 3)
cartesian_to_spherical(n)
p &lt;- c(50, 10)
spherical_to_cartesian(p)
</code></pre>

<hr>
<h2 id='cpm_models'>Global model of current plate motions</h2><span id='topic+cpm_models'></span>

<h3>Description</h3>

<p>Compilation of global models for current plate motions, including
NNR-NUVEL1A (DeMets et al., 1990),
NNR-MORVEL56 (Argus et al., 2011),
REVEL (Sella et al., 2002),
GSRM2.1 (Kreemer et al., 2014)
HS-NUVEL1A (Gripp and Gordon, 2002), and
PB2002 (Bird, 2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('cpm_models')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code>
</p>

<dl>
<dt>plate.name</dt><dd><p>The rotating plate</p>
</dd>
<dt>plate.rot</dt><dd><p>The abbreviation of the plate's name</p>
</dd>
<dt>lat,lon</dt><dd><p>Coordinates of the Pole of Rotation</p>
</dd>
<dt>angle</dt><dd><p>The amount of rotation (angle in 1 Myr)</p>
</dd>
<dt>plate.fix</dt><dd><p>The anchored plate, i.e. <code>plate.rot</code> moves relative
to  <code>plate.fix</code></p>
</dd>
<dt>model</dt><dd><p>Model for current global plate motion</p>
</dd>
</dl>



<h3>References</h3>

<p>Argus, D. F., Gordon, R. G., &amp; DeMets, C. (2011). Geologically
current motion of 56 plates relative to the no-net-rotation reference frame.
<em>Geochemistry, Geophysics, Geosystems</em>, <strong>12</strong>(11).
doi: 10.1029/2011GC003751.
</p>
<p>Bird, P. (2003), An updated digital model of plate boundaries,
<em>Geochem. Geophys. Geosyst.</em>, <strong>4</strong>, 1027, doi: 10.1029/2001GC000252, 3.
</p>
<p>DeMets, C., Gordon, R. G., Argus, D. F., &amp; Stein, S. (1990).
Current plate motions. <em>Geophysical Journal International</em>, <strong>101</strong>(2),
425-478. <a href="https://doi.org/10.1111/j.1365-246X.1990.tb06579.x">doi:10.1111/j.1365-246X.1990.tb06579.x</a>.
</p>
<p>Gripp, A. E., &amp; Gordon, R. G. (2002). Young tracks of hotspots and current
plate velocities. <em>Geophysical Journal International</em>, <strong>150</strong>(2), 321–361.
<a href="https://doi.org/10.1046/j.1365-246X.2002.01627.x">doi:10.1046/j.1365-246X.2002.01627.x</a>.
</p>
<p>Kreemer, C., Blewitt, G., &amp; Klein, E. C. (2014). A geodetic plate motion
and Global Strain Rate Model. <em>Geochemistry, Geophysics, Geosystems</em>,
<strong>15</strong>(10), 3849–3889. doi: 10.1002/2014GC005407.
</p>
<p>Sella, G. F., Dixon, T. H., &amp; Mao, A. (2002). REVEL: A model for Recent
plate velocities from space geodesy. <em>Journal of Geophysical Research: Solid
Earth</em>, <strong>107</strong>(B4). doi: 10.1029/2000jb000033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("cpm_models")
head("cpm_models")
</code></pre>

<hr>
<h2 id='deviation_norm'>Normalize Angle Between Two Directions</h2><span id='topic+deviation_norm'></span>

<h3>Description</h3>

<p>Normalizes the angle between two directions to the acute angle
in between, i.e. angles between 0 and 90°
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviation_norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviation_norm_+3A_x">x</code></td>
<td>
<p>numeric vector containing angles in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, acute angles between two directions, i.e. values
between 0 and 90°
</p>


<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deviation_norm(91)
deviation_norm(c(-91, NA, 23497349))
</code></pre>

<hr>
<h2 id='deviation_shmax'>Deviation of Observed and Predicted Directions of Maximum Horizontal Stress</h2><span id='topic+deviation_shmax'></span>

<h3>Description</h3>

<p>Calculate the angular difference between the observed and modeled direction
of maximum horizontal stresses (<code class="reqn">\sigma_{Hmax}</code>) along
great circles, small circles, and
loxodromes of the relative plate motion's Euler pole
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviation_shmax(prd, obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviation_shmax_+3A_prd">prd</code></td>
<td>
<p><code>data.frame</code> containing the modeled azimuths of
<code class="reqn">\sigma_{Hmax}</code>, i.e.
the return object from <code>model_shmax()</code></p>
</td></tr>
<tr><td><code id="deviation_shmax_+3A_obs">obs</code></td>
<td>
<p>Numeric vector containing the observed azimuth of
<code class="reqn">\sigma_{Hmax}</code>,
same length as <code>prd</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>data.frame</code>
</p>

<dl>
<dt>dev.gc</dt><dd><p>Deviation of observed stress from modeled
<code class="reqn">\sigma_{Hmax}</code> following
great circles</p>
</dd>
<dt>dev.sc</dt><dd><p>Small circles</p>
</dd>
<dt>dev.ld.cw</dt><dd><p>Clockwise loxodromes</p>
</dd>
<dt>dev.ld.ccw</dt><dd><p>Counter-clockwise loxodromes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_shmax">model_shmax()</a></code> to calculate the theoretical direction of
<code class="reqn">\sigma_{Hmax}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

# the point where we want to model the SHmax direction:
point &lt;- data.frame(lat = 45, lon = 20)

prd &lt;- model_shmax(point, PoR)
deviation_shmax(prd, obs = 90)
</code></pre>

<hr>
<h2 id='dispersion'>Circular distance and dispersion</h2><span id='topic+dispersion'></span><span id='topic+circular_distance'></span><span id='topic+circular_dispersion'></span>

<h3>Description</h3>

<p>Circular distance between two angles and circular dispersion of angles
about a specified angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular_distance(x, y, axial = TRUE, na.rm = TRUE)

circular_dispersion(
  x,
  y = NULL,
  w = NULL,
  w.y = NULL,
  norm = FALSE,
  axial = TRUE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_+3A_x">x</code>, <code id="dispersion_+3A_y">y</code></td>
<td>
<p>vectors of numeric values in degrees. <code>length(y)</code> is either
<code>1</code> or <code>length(x)</code></p>
</td></tr>
<tr><td><code id="dispersion_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="dispersion_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_w">w</code>, <code id="dispersion_+3A_w.y">w.y</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>. <code>w.y</code> is the (optional) weight of <code>y</code>.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_norm">norm</code></td>
<td>
<p>logical. Whether the dispersion should be normalized by the
maximum possible angular difference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>circular_distance</code>returns a numeric vector of positive numbers,
<code>circular_dispersion</code>returns a positive number.
</p>


<h3>Note</h3>

<p>If <code>from</code> is <code>NULL</code>, than the circular variance is returned.
</p>


<h3>References</h3>

<p>Mardia, K.V. (1972). Statistics of Directional Data: Probability
and Mathematical Statistics. London: Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+circular_var">circular_var()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(0, 2, 359, 6, 354)
circular_distance(a, 10) # distance to single value

b &lt;- a + 90
circular_distance(a, b) # distance to multiple values

data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
circular_dispersion(sa.por$azi.PoR, y = 135)
circular_dispersion(sa.por$azi.PoR, y = 135, w = 1 / san_andreas$unc)
</code></pre>

<hr>
<h2 id='dispersion_grid'>Spatial analysis of dispersion</h2><span id='topic+dispersion_grid'></span>

<h3>Description</h3>

<p>Stress field and wavelength analysis using circular dispersion
(or other statistical estimators for dispersion)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersion_grid(
  x,
  stat = c("dispersion", "nchisq", "rayleigh"),
  grid = NULL,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2.5,
  min_data = 3,
  threshold = 1,
  arte_thres = 200,
  dist_threshold = 0.1,
  R_range = seq(100, 2000, 100),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_grid_+3A_x">x</code></td>
<td>
<p><code>sf</code> object containing
</p>

<dl>
<dt>azi</dt><dd><p>Azimuth in degree</p>
</dd>
<dt>unc</dt><dd><p>Uncertainties of azimuth in degree</p>
</dd>
<dt>prd</dt><dd><p>Predicted value for azimuth</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_stat">stat</code></td>
<td>
<p>The measurement of dispersion to be calculated. Either
<code>"dispersion"</code> (default), <code>"nchisq"</code>, or <code>"rayleigh"</code> for circular dispersion,
normalized Chi-squared test statistic, or Rayleigh test statistic.</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_grid">grid</code></td>
<td>
<p>(optional) Point object of class <code>sf</code>.</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_lon_range">lon_range</code>, <code id="dispersion_grid_+3A_lat_range">lat_range</code></td>
<td>
<p>(optional) numeric vector specifying the minimum
and maximum longitudes and latitudes (are ignored if <code>"grid"</code> is specified).</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_gridsize">gridsize</code></td>
<td>
<p>Numeric. Target spacing of the regular grid in decimal
degree. Default is 2.5. (is ignored if <code>"grid"</code> is specified)</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_min_data">min_data</code></td>
<td>
<p>Integer. Minimum number of data per bin. Default is 3</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. Threshold for stat value (default is 1)</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_arte_thres">arte_thres</code></td>
<td>
<p>Numeric. Maximum distance (in km) of the gridpoint to the
next datapoint. Default is 200</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_dist_threshold">dist_threshold</code></td>
<td>
<p>Numeric. Distance weight to prevent overweight of data
nearby
(0 to 1). Default is 0.1</p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_r_range">R_range</code></td>
<td>
<p>Numeric value or vector specifying the search radius (in km).
Default is <code>seq(50, 1000, 50)</code></p>
</td></tr>
<tr><td><code id="dispersion_grid_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="#topic+dist_greatcircle">dist_greatcircle()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object containing
</p>

<dl>
<dt>lon,lat</dt><dd><p>longitude and latitude in degree</p>
</dd>
<dt>stat</dt><dd><p>output of function defined in <code>stat</code></p>
</dd>
<dt>R</dt><dd><p>Search radius in km</p>
</dd>
<dt>mdr</dt><dd><p>Mean distance of datapoints per search radius</p>
</dd>
<dt>N</dt><dd><p>Number of data points in search radius</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+circular_dispersion">circular_dispersion()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>, <code><a href="#topic+rayleigh_test">rayleigh_test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
san_andreas_por &lt;- san_andreas
san_andreas_por$azi &lt;- PoR_shmax(san_andreas, PoR, "right")$azi.PoR
san_andreas_por$prd &lt;- 135
dispersion_grid(san_andreas_por)
</code></pre>

<hr>
<h2 id='dist_greatcircle'>Distance between points</h2><span id='topic+dist_greatcircle'></span>

<h3>Description</h3>

<p>Returns the great circle distance between a location and all grid point in km
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_greatcircle(
  lat1,
  lon1,
  lat2,
  lon2,
  r = earth_radius(),
  method = c("haversine", "orthodrome", "vincenty", "euclidean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_greatcircle_+3A_lat1">lat1</code>, <code id="dist_greatcircle_+3A_lon1">lon1</code></td>
<td>
<p>numeric vector. coordinate of point(s) 1 (degrees).</p>
</td></tr>
<tr><td><code id="dist_greatcircle_+3A_lat2">lat2</code>, <code id="dist_greatcircle_+3A_lon2">lon2</code></td>
<td>
<p>numeric vector. coordinates of point(s) 2 (degrees).</p>
</td></tr>
<tr><td><code id="dist_greatcircle_+3A_r">r</code></td>
<td>
<p>numeric. radius of the sphere (default = 6371.0087714 km, i.e. the
radius of the Earth)</p>
</td></tr>
<tr><td><code id="dist_greatcircle_+3A_method">method</code></td>
<td>
<p>Character. Formula for calculating great circle distance,
one of:
</p>

<dl>
<dt><code>"haversine"</code></dt><dd><p>great circle distance based on the haversine
formula that is optimized for 64-bit floating-point numbers (the default)</p>
</dd>
<dt><code>"orthodrome"</code></dt><dd><p>great circle distance based on the spherical law of cosines</p>
</dd>
<dt><code>"vincenty"</code></dt><dd><p>distance based on the Vincenty formula for an
ellipsoid with equal major and minor axes</p>
</dd>
<dt>&quot;euclidean&quot;</dt><dd><p>Euclidean distance (not great circle distance!)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with length equal to <code>length(lat1)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orthodrome">orthodrome()</a></code>, <code><a href="#topic+haversine">haversine()</a></code>, <code><a href="#topic+vincenty">vincenty()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_greatcircle(lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32))
dist_greatcircle(
  lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32),
  method = "orthodrome"
)
dist_greatcircle(
  lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32),
  method = "vincenty"
)
dist_greatcircle(
  lat1 = 20, lon1 = 12, lat2 = c(50, 30), lon2 = c(40, 32),
  method = "euclidean"
)
</code></pre>

<hr>
<h2 id='distance_from_pb'>Distance from plate boundary</h2><span id='topic+distance_from_pb'></span>

<h3>Description</h3>

<p>Absolute distance of data points from the nearest plate boundary in degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_from_pb(x, PoR, pb, tangential = FALSE, km = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_from_pb_+3A_x">x</code>, <code id="distance_from_pb_+3A_pb">pb</code></td>
<td>
<p><code>sf</code> objects of the data points and the plate boundary
geometries in the geographical coordinate system</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Pole of Rotation</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_tangential">tangential</code></td>
<td>
<p>Logical. Whether the plate boundary is a tangential
boundary (<code>TRUE</code>) or an inward and outward boundary (<code>FALSE</code>, the
default).</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_km">km</code></td>
<td>
<p>Logical. Whether the distance is expressed in kilometers
(<code>TRUE</code>) or in degrees (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="distance_from_pb_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="smoothr.html#topic+densify">smoothr::densify()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance to the plate boundary is the longitudinal or
latitudinal difference between the data point and the plate boundary
(along the closest latitude or longitude) for inward/outward or tangential
plate boundaries, respectively.
</p>


<h3>Value</h3>

<p>Numeric vector of the great circle distances
</p>


<h3>References</h3>

<p>Wdowinski, S. (1998). A theory of intraplate tectonics. Journal
of Geophysical Research: Solid Earth, 103(3), 5037–5059.
http://dx.doi.org/10.1029/97JB03390
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
res &lt;- distance_from_pb(
  x = san_andreas, PoR = na_pa, pb = plate_boundary, tangential = TRUE
)
head(res)

res.km &lt;- distance_from_pb(
  x = san_andreas, PoR = na_pa, pb = plate_boundary, tangential = TRUE, km = TRUE
)
range(res.km)
</code></pre>

<hr>
<h2 id='distance_mod'>Normalize angular distance on a sphere distance</h2><span id='topic+distance_mod'></span>

<h3>Description</h3>

<p>Helper function to express angular distance on the sphere in
the range of 0 to 180 degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_mod(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_mod_+3A_x">x</code></td>
<td>
<p>numeric, angular distance (in degrees)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>

<hr>
<h2 id='dummy'>Plate Stress Dummy Grid</h2><span id='topic+dummy'></span><span id='topic+smallcircle_dummy'></span><span id='topic+greatcircle_dummy'></span><span id='topic+loxodrome_dummy'></span>

<h3>Description</h3>

<p>Helper functions to create a dummy grid for small circles,
great circles, and loxodromes of an Euler pole
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smallcircle_dummy(n)

greatcircle_dummy(n)

loxodrome_dummy(n, angle, cw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_+3A_n">n</code></td>
<td>
<p>Number of curves</p>
</td></tr>
<tr><td><code id="dummy_+3A_angle">angle</code></td>
<td>
<p>Direction of loxodromes (in degree)</p>
</td></tr>
<tr><td><code id="dummy_+3A_cw">cw</code></td>
<td>
<p>logical. Sense of loxodromes: <code>TRUE</code> for clockwise
loxodromes (right-lateral displaced plate boundaries). <code>FALSE</code> for
counterclockwise loxodromes (left-lateral displaced plate boundaries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>

<hr>
<h2 id='earth_radius'>Earth's radius in km</h2><span id='topic+earth_radius'></span>

<h3>Description</h3>

<p>IERS mean radius of Earth in km (based on WGS 84)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earth_radius()
</code></pre>


<h3>Value</h3>

<p>numeric value
</p>

<hr>
<h2 id='equivalent_rotation'>Equivalent rotation</h2><span id='topic+equivalent_rotation'></span>

<h3>Description</h3>

<p>Transforms a sequence of rotations into a new reference system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent_rotation(x, fixed, rot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalent_rotation_+3A_x">x</code></td>
<td>
<p>Object of class <code>"data.frame"</code> containing the Euler poles of
plate rotations:
</p>

<dl>
<dt><code>plate.rot</code></dt><dd><p>Moving plate</p>
</dd>
<dt><code>lat</code>, <code>lon</code></dt><dd><p>coordinates of Euler pole</p>
</dd>
<dt><code>angle</code></dt><dd><p>Angle of rotation</p>
</dd>
<dt><code>plate.fix</code></dt><dd><p>Fixed plate</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="equivalent_rotation_+3A_fixed">fixed</code></td>
<td>
<p>plate that will be regarded as fixed. Has to be one out of
<code>x$plate.fix</code></p>
</td></tr>
<tr><td><code id="equivalent_rotation_+3A_rot">rot</code></td>
<td>
<p>(optional) plate that will be regarded as rotating. Has to be one out of
<code>x$plate.rot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sequence of plate rotations in new reference system. Same object
class as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relative_rotation">relative_rotation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuvel1) # load the NUVEL1 rotation parameters

# all nuvel1 rotation equivalent to fixed Africa:
equivalent_rotation(nuvel1, fixed = "af")
# relative plate motion between Eurasia and India:
equivalent_rotation(nuvel1, "eu", "in")
</code></pre>

<hr>
<h2 id='est.kappa'>Concentration parameter of von Mises distribution</h2><span id='topic+est.kappa'></span>

<h3>Description</h3>

<p>Computes the maximum likelihood estimate of <code class="reqn">\kappa</code>, the concentration
parameter of a von Mises distribution, given a set of angular measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.kappa(x, w = NULL, bias = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.kappa_+3A_x">x</code></td>
<td>
<p>numeric. angles in degrees</p>
</td></tr>
<tr><td><code id="est.kappa_+3A_w">w</code></td>
<td>
<p>numeric. weightings</p>
</td></tr>
<tr><td><code id="est.kappa_+3A_bias">bias</code></td>
<td>
<p>logical parameter determining whether a bias correction is used
in the computation of the MLE. Default for bias is <code>FALSE</code> for no bias
correction.</p>
</td></tr>
<tr><td><code id="est.kappa_+3A_...">...</code></td>
<td>
<p>optional paramters passed to <code>circular_mean()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est.kappa(rvm(100, 90, 10), w = 1 / runif(100, 0, 10))
</code></pre>

<hr>
<h2 id='euler_pole'>Euler pole object</h2><span id='topic+euler_pole'></span>

<h3>Description</h3>

<p>Creates an object of the orientation of the Euler pole axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler_pole(x, y, z = NA, geo = TRUE, angle = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euler_pole_+3A_x">x</code></td>
<td>
<p>latitude or x coordinate of Euler pole axis</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_y">y</code></td>
<td>
<p>longitude or y</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_z">z</code></td>
<td>
<p>z coordinate</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_geo">geo</code></td>
<td>
<p>logical, <code>TRUE</code> (the default) if Euler pole axis is given in
geographical coordinates (latitude, longitude). <code>FALSE</code> if given in
Cartesian coordinates (<code>x</code>, <code>y</code>, <code>z</code>)</p>
</td></tr>
<tr><td><code id="euler_pole_+3A_angle">angle</code></td>
<td>
<p>(optional) Angle of rotation in degrees (CCW rotation if angle
is positive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"euler.pole"</code> containing the Euler pole
axis in both geographical and Cartesian coordinates and the angle of rotation
in radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euler_pole(90, 0, angle = 45)
euler_pole(0, 0, 1, geo = FALSE)
</code></pre>

<hr>
<h2 id='euler_to_Q4'>Quaternion from Euler angle-axis representation for rotations</h2><span id='topic+euler_to_Q4'></span>

<h3>Description</h3>

<p>Quaternion from Euler angle-axis representation for rotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler_to_Q4(x, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euler_to_Q4_+3A_x">x</code></td>
<td>
<p><code>"euler.pole"</code> object</p>
</td></tr>
<tr><td><code id="euler_to_Q4_+3A_normalize">normalize</code></td>
<td>
<p>logical. Whether a quaternion normalization should be applied (TRUE) or not (FALSE, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>

<hr>
<h2 id='get_azimuth'>Azimuth Between two Points</h2><span id='topic+get_azimuth'></span>

<h3>Description</h3>

<p>Calculate initial bearing (or forward azimuth/direction) to go
from point <code>a</code> to point <code>b</code> following great circle arc on a
sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_azimuth(lat_a, lon_a, lat_b, lon_b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_azimuth_+3A_lat_a">lat_a</code>, <code id="get_azimuth_+3A_lat_b">lat_b</code></td>
<td>
<p>Numeric. Latitudes of a and b (in degrees).</p>
</td></tr>
<tr><td><code id="get_azimuth_+3A_lon_a">lon_a</code>, <code id="get_azimuth_+3A_lon_b">lon_b</code></td>
<td>
<p>Numeric. Longitudes of a and b (in degrees).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+get_azimuth">get_azimuth()</a></code> is based on the spherical law of tangents.
This formula is for the initial bearing (sometimes referred to as
forward azimuth) which if followed in a straight line along a great circle
arc will lead from the start point <code>a</code> to the end point <code>b</code>.
</p>
<p style="text-align: center;"><code class="reqn">\theta = \arctan2 (\sin \Delta\lambda
\cos\psi_2, \cos\psi_1 \sin\psi_1-\sin\psi_1 \cos\psi_2 \cos\Delta\lambda)</code>
</p>

<p>where  <code class="reqn">\psi_1, \lambda_1</code> is the start point, <code class="reqn">\psi_2</code>,
<code class="reqn">\lambda_2</code> the end point (<code class="reqn">\Delta\lambda</code> is the difference in
longitude).
</p>


<h3>Value</h3>

<p>numeric. Azimuth in degrees
</p>


<h3>References</h3>

<p><a href="http://www.movable-type.co.uk/scripts/latlong.html">http://www.movable-type.co.uk/scripts/latlong.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>berlin &lt;- c(52.517, 13.4) # Berlin
tokyo &lt;- c(35.7, 139.767) # Tokyo
get_azimuth(berlin[1], berlin[2], tokyo[1], tokyo[2])
</code></pre>

<hr>
<h2 id='get_distance'>Helper function to Distance from plate boundary</h2><span id='topic+get_distance'></span>

<h3>Description</h3>

<p>Helper function to Distance from plate boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance(lon, lat, pb.coords, tangential, km)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_distance_+3A_lon">lon</code>, <code id="get_distance_+3A_lat">lat</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="get_distance_+3A_pb.coords">pb.coords</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="get_distance_+3A_tangential">tangential</code>, <code id="get_distance_+3A_km">km</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+distance_from_pb">distance_from_pb()</a></code>
</p>

<hr>
<h2 id='get_projected_pb_strike'>Helper function to get Distance from plate boundary</h2><span id='topic+get_projected_pb_strike'></span>

<h3>Description</h3>

<p>Helper function to get Distance from plate boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_projected_pb_strike(lon, lat, pb.coords, pb.bearing, tangential)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_projected_pb_strike_+3A_lon">lon</code>, <code id="get_projected_pb_strike_+3A_lat">lat</code>, <code id="get_projected_pb_strike_+3A_pb.bearing">pb.bearing</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="get_projected_pb_strike_+3A_pb.coords">pb.coords</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="get_projected_pb_strike_+3A_tangential">tangential</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+projected_pb_strike">projected_pb_strike()</a></code>
</p>

<hr>
<h2 id='get_relrot'>Helper function to Equivalent rotation</h2><span id='topic+get_relrot'></span>

<h3>Description</h3>

<p>Helper function to Equivalent rotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_relrot(plate.rot, lat, lon, angle, fixed, fixed.ep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_relrot_+3A_plate.rot">plate.rot</code>, <code id="get_relrot_+3A_fixed">fixed</code></td>
<td>
<p>character or numeric</p>
</td></tr>
<tr><td><code id="get_relrot_+3A_lat">lat</code>, <code id="get_relrot_+3A_lon">lon</code>, <code id="get_relrot_+3A_angle">angle</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="get_relrot_+3A_fixed.ep">fixed.ep</code></td>
<td>
<p>data.frame</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+equivalent_rotation">equivalent_rotation()</a></code>
</p>

<hr>
<h2 id='iceland'>Example stress data for outward-moving displaced plate boundary</h2><span id='topic+iceland'></span>

<h3>Description</h3>

<p>Subset of the World Stress Map (WSM) compilation of information on the
crustal present-day stress field (Version 2016). Subset contains stress data
of Iceland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('iceland')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"sf"</code>
</p>


<h3>Source</h3>

<p><a href="https://www.world-stress-map.org/">https://www.world-stress-map.org/</a>
</p>


<h3>References</h3>

<p>Heidbach, O., M. Rajabi, X. Cui, K. Fuchs, B. Müller, J.
Reinecker, K. Reiter, M. Tingay, F. Wenzel, F. Xie, M. O. Ziegler,
M.-L. Zoback, and M. D. Zoback (2018): The World Stress Map database
release 2016: Crustal stress pattern across scales. <em>Tectonophysics</em>,
<strong>744</strong>, 484-498, <a href="https://doi.org/10.1016/j.tecto.2018.07.007">doi:10.1016/j.tecto.2018.07.007</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iceland")
head(iceland)
</code></pre>

<hr>
<h2 id='is.euler'>Check if object is euler.pole</h2><span id='topic+is.euler'></span>

<h3>Description</h3>

<p>Check if object is euler.pole
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.euler(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.euler_+3A_x">x</code></td>
<td>
<p>object of class <code>"euler.pole"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is.Q4'>Check if object is quaternion</h2><span id='topic+is.Q4'></span>

<h3>Description</h3>

<p>Check if object is quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Q4(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.Q4_+3A_x">x</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='kuiper_test'>Kuiper Test of Circular Uniformity</h2><span id='topic+kuiper_test'></span>

<h3>Description</h3>

<p>Kuiper test for circular random distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kuiper_test(x, alpha = 0, axial = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kuiper_test_+3A_x">x</code></td>
<td>
<p>numeric vector containing the circular data which are expressed in degrees</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the test. Valid levels are <code>0.01</code>, <code>0.05</code>, and <code>0.1</code>.
This argument may be omitted (<code>NULL</code>, the default), in which case, a range for the p-value will be returned.</p>
</td></tr>
<tr><td><code id="kuiper_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or circular, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kuiper's test statistic is a rotation-invariant Kolmogorov-type test statistic.
The critical values of a modified Kuiper's test statistic are used according
to the tabulation given in Stephens (1970).
</p>
<p>If <code>statistic &gt; p.value</code>, the null hypothesis is rejected.
If not, randomness (uniform distribution) cannot be excluded.
</p>


<h3>Value</h3>

<p>list containing the test statistic <code>statistic</code> and the significance
level <code>p.value</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Mardia and Jupp (2001), pp. 93
pidgeon_homing &lt;- c(55, 60, 65, 95, 100, 110, 260, 275, 285, 295)
kuiper_test(pidgeon_homing, alpha = .05)

# San Andreas Fault Data:
data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
kuiper_test(sa.por$azi.PoR, alpha = .05)
</code></pre>

<hr>
<h2 id='line_azimuth'>Extract azimuths of line segments</h2><span id='topic+line_azimuth'></span><span id='topic+lines_azimuths'></span>

<h3>Description</h3>

<p>Extract azimuths of line segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_azimuth(x)

lines_azimuths(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_azimuth_+3A_x">x</code></td>
<td>
<p>sf object of type <code>"LINESTRING"</code> or <code>"MULTILINESTRING"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to perform <code>line_azimuth()</code> on single line objects, i.e.
type <code>"LINESTRING"</code>, instead of <code>"MULTILINESTRING"</code>. This is because the azimuth
of the last point of a line will be calculated to the first point of the
next line otherwise. This will cause a warning message. For <code>MULTILINESTRING</code>
objects, use <code>lines_azimuths()</code>.
</p>


<h3>Value</h3>

<p>sf object of type <code>"POINT"</code> with the columns and entries of the first row of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates", package = "tectonicr")
subset(plates, pair == "af-eu") |&gt;
  smoothr::densify() |&gt;
  line_azimuth()

line_azimuth(plates)
</code></pre>

<hr>
<h2 id='mean_resultant_length'>Mean Resultant Length</h2><span id='topic+mean_resultant_length'></span>

<h3>Description</h3>

<p>Measure of spread around the circle. It should be noted that:
If R=0, then the data is completely spread around the circle.
If R=1, the data is completely concentrated on one point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_resultant_length(x, w = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_resultant_length_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees, for which the
mean, median or standard deviation are required.</p>
</td></tr>
<tr><td><code id="mean_resultant_length_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers, of the same length as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="mean_resultant_length_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>References</h3>

<p>Mardia, K.V. (1972). Statistics of Directional Data: Probability
and Mathematical Statistics. London: Academic Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
mean_resultant_length(finland_stria, w = NULL, na.rm = FALSE) # 0.800
</code></pre>

<hr>
<h2 id='model_shmax'>Theoretical Direction of Maximum Horizontal Stress in the
geographical reference system.</h2><span id='topic+model_shmax'></span>

<h3>Description</h3>

<p>Models the direction of maximum horizontal stress
<code class="reqn">\sigma_{Hmax}</code> along great circles, small circles, and
loxodromes at a given point or points according to the relative plate motion
in the geographical coordinate reference system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_shmax(df, euler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_shmax_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>).</p>
</td></tr>
<tr><td><code id="model_shmax_+3A_euler">euler</code></td>
<td>
<p><code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\sigma_{Hmax}</code> following <em>great circles</em> is the
(initial) bearing between the given point and the pole of relative plate
motion. <code class="reqn">\sigma_{Hmax}</code> along <em>small circles</em>, clockwise, and
counter-clockwise <em>loxodromes</em> is 90<code class="reqn">^{\circ}</code>,
+45<code class="reqn">^{\circ}</code>, and 135<code class="reqn">^{\circ}</code>
(-45<code class="reqn">^{\circ}</code>) to this great circle bearing, respectively.
</p>


<h3>Value</h3>

<p><code>data.frame</code>
</p>

<dl>
<dt>gc</dt><dd><p>Azimuth of modeled <code class="reqn">\sigma_{Hmax}</code> following
great circles</p>
</dd>
<dt>sc</dt><dd><p>Small circles</p>
</dd>
<dt>ld.cw</dt><dd><p>Clockwise loxodromes</p>
</dd>
<dt>ld.ccw</dt><dd><p>Counter-clockwise loxodromes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deviation_shmax">deviation_shmax()</a></code> to compute the deviation of the modeled direction
from the observed direction of <code class="reqn">\sigma_{Hmax}</code>.
<code><a href="#topic+PoR_shmax">PoR_shmax()</a></code> to calculate the azimuth of <code class="reqn">\sigma_{Hmax}</code>
in the pole of rotation reference system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
euler &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

# the point where we mant to model the SHmax direction:
point &lt;- data.frame(lat = 45, lon = 20)

model_shmax(point, euler)
</code></pre>

<hr>
<h2 id='norm_chisq'>Normalized Chi-Squared Test for Circular Data</h2><span id='topic+norm_chisq'></span>

<h3>Description</h3>

<p>A quantitative comparison between the predicted and observed directions of
<code class="reqn">\sigma_{Hmax}</code> is obtained by the calculation of the average
azimuth and by a normalized <code class="reqn">\chi^2</code> test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_chisq(obs, prd, unc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_chisq_+3A_obs">obs</code></td>
<td>
<p>Numeric vector containing the observed azimuth of
<code class="reqn">\sigma_{Hmax}</code>,
same length as <code>prd</code></p>
</td></tr>
<tr><td><code id="norm_chisq_+3A_prd">prd</code></td>
<td>
<p>Numeric vector containing the modeled azimuths of
<code class="reqn">\sigma_{Hmax}</code>, i.e.
the return object from <code>model_shmax()</code></p>
</td></tr>
<tr><td><code id="norm_chisq_+3A_unc">unc</code></td>
<td>
<p>Uncertainty of observed <code class="reqn">\sigma_{Hmax}</code>, either a
numeric vector or a number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalized <code class="reqn">\chi^2</code> test is
</p>
<p style="text-align: center;"><code class="reqn"> {Norm} \chi^2_i =
 = \frac{
   \sum^M_{i = 1} \left( \frac{\alpha_i - \alpha_{{predict}}}{\sigma_i}
   \right) ^2}
   {\sum^M_{i = 1} \left( \frac{90}{\sigma_i} \right) ^2 }</code>
</p>

<p>The value of the chi-squared test statistic is a number between 0 and 1
indicating the quality of the predicted <code class="reqn">\sigma_{Hmax}</code>
directions. Low values
(<code class="reqn">\le 0.15</code>) indicate good agreement,
high values (<code class="reqn">&gt; 0.7</code>) indicate a systematic misfit between predicted and
observed <code class="reqn">\sigma_{Hmax}</code> directions.
</p>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>References</h3>

<p>Wdowinski, S., 1998, A theory of intraplate
tectonics. <em>Journal of Geophysical Research: Solid Earth</em>, <strong>103</strong>,
5037-5059, doi: 10.1029/97JB03390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to
# Pacific plate
data(san_andreas)
point &lt;- data.frame(lat = 45, lon = 20)
prd &lt;- model_shmax(point, PoR)
norm_chisq(obs = c(50, 40, 42), prd$sc, unc = c(10, NA, 5))

data(san_andreas)
prd2 &lt;- PoR_shmax(san_andreas, PoR, type = "right")
norm_chisq(obs = prd2$azi.PoR, 135, unc = san_andreas$unc)
</code></pre>

<hr>
<h2 id='normalize_Q4'>Quaternion normalization</h2><span id='topic+normalize_Q4'></span>

<h3>Description</h3>

<p>Quaternion normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_Q4(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_Q4_+3A_q">q</code></td>
<td>
<p>quaternion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>

<hr>
<h2 id='nuvel1'>NUVEL-1 Global model of current plate motions</h2><span id='topic+nuvel1'></span>

<h3>Description</h3>

<p>NNR-NUVEL-1 global model of current plate motions by DeMets et al. 1990
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('nuvel1')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code>
</p>

<dl>
<dt>plate.name</dt><dd><p>The rotating plate</p>
</dd>
<dt>plate.rot</dt><dd><p>The abbreviation of the plate's name</p>
</dd>
<dt>lat,lon</dt><dd><p>Coordinates of the Pole of Rotation</p>
</dd>
<dt>angle</dt><dd><p>The amount of rotation (angle in 1 Myr)</p>
</dd>
<dt>plate.fix</dt><dd><p>The anchored plate, i.e. <code>plate.rot</code> moves relative
to  <code>plate.fix</code></p>
</dd>
<dt>source</dt><dd><p>Reference to underlying study</p>
</dd>
</dl>



<h3>References</h3>

<p>DeMets, C., Gordon, R. G., Argus, D. F., &amp; Stein, S. (1990).
Current plate motions. <em>Geophysical Journal International</em>, <strong>101</strong>(2),
425-478. <a href="https://doi.org/10.1111/j.1365-246X.1990.tb06579.x">doi:10.1111/j.1365-246X.1990.tb06579.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
head("nuvel1")
</code></pre>

<hr>
<h2 id='nuvel1_plates'>Plate Boundaries on the Earth</h2><span id='topic+nuvel1_plates'></span>

<h3>Description</h3>

<p>Global set of present plate boundaries on the Earth based on NUVEL-1 model by
DeMets et al. 1990
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('nuvel1_plates')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>
</p>


<h3>References</h3>

<p>DeMets, C., Gordon, R. G., Argus, D. F., &amp; Stein, S. (1990).
Current plate motions. <em>Geophysical Journal International</em>, <strong>101</strong>(2),
425-478. <a href="https://doi.org/10.1111/j.1365-246X.1990.tb06579.x">doi:10.1111/j.1365-246X.1990.tb06579.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1_plates")
head("nuvel1_plates")
</code></pre>

<hr>
<h2 id='pb2002'>Global model of current plate motions</h2><span id='topic+pb2002'></span>

<h3>Description</h3>

<p>PB2002 global model of current plate motions by Bird 2003
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('pb2002')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code>
</p>

<dl>
<dt>plate.name</dt><dd><p>The rotating plate</p>
</dd>
<dt>plate.rot</dt><dd><p>The abbreviation of the plate's name</p>
</dd>
<dt>lat,lon</dt><dd><p>Coordinates of the Pole of Rotation</p>
</dd>
<dt>angle</dt><dd><p>The amount of rotation (angle in 1 Myr)</p>
</dd>
<dt>plate.fix</dt><dd><p>The anchored plate, i.e. <code>plate.rot</code> moves relative
to <code>plate.fix</code></p>
</dd>
<dt>source</dt><dd><p>Reference to underlying study</p>
</dd>
</dl>



<h3>References</h3>

<p>Bird, P. (2003), An updated digital model of plate boundaries,
<em>Geochem. Geophys. Geosyst.</em>, <strong>4</strong>, 1027, doi: 10.1029/2001GC000252, 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pb2002")
head("pb2002")
</code></pre>

<hr>
<h2 id='plates'>Plate Boundaries on the Earth</h2><span id='topic+plates'></span>

<h3>Description</h3>

<p>Global set of present plate boundaries on the Earth based on PB2002 model by
Bird (2003). Contains the plate boundary displacement types such as inward,
outward, or tangentially displacement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('plates')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code>
</p>


<h3>References</h3>

<p>Bird, P. (2003), An updated digital model of plate boundaries,
<em>Geochem. Geophys. Geosyst.</em>, <strong>4</strong>, 1027, doi: 10.1029/2001GC000252, 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
head("plates")
</code></pre>

<hr>
<h2 id='PoR_coordinates'>PoR coordinates</h2><span id='topic+PoR_coordinates'></span>

<h3>Description</h3>

<p>Retrieve the PoR equivalent coordinates of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_coordinates(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoR_coordinates_+3A_x">x</code></td>
<td>
<p><code>sf</code> or <code>data.frame</code> containing lat and lon coordinates
(<code>lat</code>, <code>lon</code>)</p>
</td></tr>
<tr><td><code id="PoR_coordinates_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the PoR coordinates
(<code>lat.PoR</code>, <code>lon.PoR</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
data("san_andreas")
san_andreas.por_sf &lt;- PoR_coordinates(san_andreas, por)
head(san_andreas.por_sf)
san_andreas.por_df &lt;- PoR_coordinates(sf::st_drop_geometry(san_andreas), por)
head(san_andreas.por_df)
</code></pre>

<hr>
<h2 id='PoR_crs'>PoR coordinate reference system</h2><span id='topic+PoR_crs'></span>

<h3>Description</h3>

<p>Create the reference system transformed in Euler pole
coordinate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_crs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoR_crs_+3A_x">x</code></td>
<td>
<p><code>"data.frame"</code> or <code>"euler.pole"</code> object containing the
geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PoR coordinate reference system is oblique transformation of the
geographical coordinate system with the Euler pole coordinates being the the
translation factors.
</p>


<h3>Value</h3>

<p>Object of class <code>crs</code>
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
PoR_crs(por)
</code></pre>

<hr>
<h2 id='PoR_map'>Plot data in PoR map</h2><span id='topic+PoR_map'></span>

<h3>Description</h3>

<p>Plot data in PoR map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_map(
  x,
  PoR,
  pb = NULL,
  type = c("none", "in", "out", "right", "left"),
  deviation = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoR_map_+3A_x">x</code>, <code id="PoR_map_+3A_pb">pb</code></td>
<td>
<p><code>sf</code> objects of the data points and the plate
boundary geometries in the geographical coordinate system</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class
<code>"euler.pole"</code>
containing the geographical coordinates of the Pole of Rotation</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_type">type</code></td>
<td>
<p>Character. Type of plate boundary (optional). Can be
<code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively. If <code>"none"</code> (the default), only
the PoR-equivalent azimuth is returned.</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_deviation">deviation</code></td>
<td>
<p>logical.
Whether the data should be color-coded according to the deviation from the
prediction, or according to the stress regime?</p>
</td></tr>
<tr><td><code id="PoR_map_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="#topic+tectonicr.colors">tectonicr.colors()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>, <code><a href="#topic+axes">axes()</a></code>, <code><a href="#topic+tectonicr.colors">tectonicr.colors()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
PoR_map(san_andreas, PoR = na_pa, pb = plate_boundary, type = "right", deviation = TRUE)
</code></pre>

<hr>
<h2 id='PoR_shmax'>Direction of Maximum Horizontal Stress in PoR reference
system</h2><span id='topic+PoR_shmax'></span>

<h3>Description</h3>

<p>Models the direction of maximum horizontal stress
<code class="reqn">\sigma_{Hmax}</code> in the Euler pole (Pole of Rotation)
coordinate reference system. When type of plate boundary is given, it also
gives the deviation from the theoretically predicted azimuth of
<code class="reqn">\sigma_{Hmax}</code>, the deviation, and the normalized
<code class="reqn">\chi^2</code> statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_shmax(df, PoR, type = c("none", "in", "out", "right", "left"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoR_shmax_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>), the direction of
<code class="reqn">\sigma_{Hmax}</code> <code>azi</code> and its standard deviation
<code>unc</code> (optional)</p>
</td></tr>
<tr><td><code id="PoR_shmax_+3A_por">PoR</code></td>
<td>
<p><code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler  pole</p>
</td></tr>
<tr><td><code id="PoR_shmax_+3A_type">type</code></td>
<td>
<p>Character. Type of plate boundary (optional). Can be
<code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively. If <code>"none"</code> (the default), only
the PoR-equivalent azimuth is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The azimuth of <code class="reqn">\sigma_{Hmax}</code> in the pole of rotation
reference system is
approximate 0 (or 180), 45, 90, 135 degrees if the stress is sourced by an
outward, sinistral, inward, or dextral moving plate boundary, respectively.
directions of <code class="reqn">\sigma_{Hmax}</code> with respect to the four
plate boundary types.
</p>


<h3>Value</h3>

<p>Either a numeric vector of the azimuths in the transformed coordinate
system (in degrees), or a <code>"data.frame"</code> with
</p>

<dl>
<dt><code>azi.PoR</code></dt><dd><p>the transformed azimuths (in degrees),</p>
</dd>
<dt><code>prd</code></dt><dd><p>the predicted azimuths (in degrees),</p>
</dd>
<dt><code>dev</code></dt><dd><p>the deviation between the transformed and the predicted azimuth (in degrees),</p>
</dd>
<dt><code>nchisq</code></dt><dd><p>the Norm <code class="reqn">\chi^2</code> test statistic, and</p>
</dd>
<dt><code>cdist</code></dt><dd><p>the angular distance between the transformed and the predicted azimuth.</p>
</dd>
</dl>



<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_shmax">model_shmax()</a></code> to compute the theoretical direction of
<code class="reqn">\sigma_{Hmax}</code> in the geographical reference system.
<code><a href="#topic+deviation_shmax">deviation_shmax()</a></code> to compute the deviation of the modeled direction
from the observed direction of <code class="reqn">\sigma_{Hmax}</code>.
<code><a href="#topic+norm_chisq">norm_chisq()</a></code> to calculate the normalized <code class="reqn">\chi^2</code>
statistics. <code><a href="#topic+circular_distance">circular_distance()</a></code> to calculate the angular distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("san_andreas")
res &lt;- PoR_shmax(san_andreas, PoR, type = "right")
head(res)
</code></pre>

<hr>
<h2 id='PoR_stress2grid'>Spatial interpolation of SHmax in PoR coordinate reference system</h2><span id='topic+PoR_stress2grid'></span>

<h3>Description</h3>

<p>The data is transformed into the PoR system before the
interpolation. The interpolation grid is returned in geographical coordinates
and azimuths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_stress2grid(
  x,
  PoR,
  grid = NULL,
  PoR_grid = TRUE,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoR_stress2grid_+3A_x">x</code></td>
<td>
<p><code>sf</code> object containing
</p>

<dl>
<dt>azi</dt><dd><p>SHmax in degree</p>
</dd>
<dt>unc</dt><dd><p>Uncertainties of SHmax in degree</p>
</dd>
<dt>type</dt><dd><p>Methods used for the determination of the orientation of SHmax</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler  pole</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_grid">grid</code></td>
<td>
<p>(optional) Point object of class <code>sf</code>.</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_por_grid">PoR_grid</code></td>
<td>
<p>logical. Whether the grid should be generated based on the
coordinate range in the PoR (<code style="white-space: pre;">&#8288;"TRUE&#8288;</code>, the default) CRS or the geographical CRS
(<code style="white-space: pre;">&#8288;"FALSE&#8288;</code>). Is ignored if <code>"grid"</code> is specified.</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_lon_range">lon_range</code>, <code id="PoR_stress2grid_+3A_lat_range">lat_range</code></td>
<td>
<p>(optional) numeric vector specifying the minimum
and maximum longitudes and latitudes (are ignored if <code>"grid"</code> is specified).</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_gridsize">gridsize</code></td>
<td>
<p>Numeric. Target spacing of the regular grid in decimal
degree. Default is 2.5 (is ignored if <code>"grid"</code> is specified)</p>
</td></tr>
<tr><td><code id="PoR_stress2grid_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+stress2grid">stress2grid()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stress field and wavelength analysis in PoR system and back-transformed
</p>


<h3>Value</h3>

<p><code>sf</code> object containing
</p>

<dl>
<dt>lon,lat</dt><dd><p>longitude and latitude in geographical CRS (in degrees)</p>
</dd>
<dt>lon.PoR,lat.PoR</dt><dd><p>longitude and latitude in PoR CRS (in degrees)</p>
</dd>
<dt>azi</dt><dd><p>geographical mean SHmax in degree</p>
</dd>
<dt>azi.PoR</dt><dd><p>PoR mean SHmax in degree</p>
</dd>
<dt>sd</dt><dd><p>Standard deviation of SHmax in degrees</p>
</dd>
<dt>R</dt><dd><p>Search radius in km</p>
</dd>
<dt>mdr</dt><dd><p>Mean distance of datapoints per search radius</p>
</dd>
<dt>N</dt><dd><p>Number of data points in search radius</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stress2grid">stress2grid()</a></code>, <code><a href="#topic+compact_grid">compact_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
PoR_stress2grid(san_andreas, PoR)
</code></pre>

<hr>
<h2 id='por_transformation_df'>Conversion between spherical PoR to geographical coordinate system</h2><span id='topic+por_transformation_df'></span><span id='topic+geographical_to_PoR'></span><span id='topic+PoR_to_geographical'></span>

<h3>Description</h3>

<p>Transformation from spherical PoR to geographical coordinate system and
vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographical_to_PoR(x, PoR)

PoR_to_geographical(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="por_transformation_df_+3A_x">x</code></td>
<td>
<p><code>"data.frame"</code> containing <code>lat</code> and <code>lon</code>
coordinates of a point in the geographical CRS or the <code>lat.PoR</code>,
<code>lon.PoR</code>) of the point in the PoR CRS.</p>
</td></tr>
<tr><td><code id="por_transformation_df_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"data.frame"</code> with the transformed coordinates
(<code>lat.PoR</code> and <code>lon.PoR</code> for PoR CRS,
or <code>lat</code> and <code>lon</code> for geographical CRS).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
data("san_andreas")
san_andreas.por &lt;- geographical_to_PoR(san_andreas, por)
head(san_andreas.por)
head(PoR_to_geographical(san_andreas.por, por))
</code></pre>

<hr>
<h2 id='por_transformation_quat'>Conversion between PoR to geographical coordinate system using quaternions</h2><span id='topic+por_transformation_quat'></span><span id='topic+geographical_to_PoR_quat'></span><span id='topic+PoR_to_geographical_quat'></span>

<h3>Description</h3>

<p>Helper function for the transformation from PoR to geographical coordinate
system or vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographical_to_PoR_quat(x, PoR)

PoR_to_geographical_quat(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="por_transformation_quat_+3A_x">x</code>, <code id="por_transformation_quat_+3A_por">PoR</code></td>
<td>
<p>two-column vectors containing the lat and lon coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two-element numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ep.geo &lt;- c(20, 33)
q.geo &lt;- c(10, 45)
q.por &lt;- geographical_to_PoR_quat(q.geo, ep.geo)
q.por
PoR_to_geographical_quat(q.por, ep.geo)
</code></pre>

<hr>
<h2 id='por_transformation_sf'>Conversion between PoR to geographical coordinates of spatial data</h2><span id='topic+por_transformation_sf'></span><span id='topic+PoR_to_geographical_sf'></span><span id='topic+geographical_to_PoR_sf'></span>

<h3>Description</h3>

<p>Transform spatial objects from PoR to geographical coordinate reference
system and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR_to_geographical_sf(x, PoR)

geographical_to_PoR_sf(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="por_transformation_sf_+3A_x">x</code></td>
<td>
<p><code>sf</code>, <code>SpatRast</code>, or <code>Raster*</code> object of the data
points in geographical or PoR coordinate system</p>
</td></tr>
<tr><td><code id="por_transformation_sf_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PoR coordinate reference system is oblique transformation of the
geographical coordinate system with the Euler pole coordinates being the
translation factors.
</p>


<h3>Value</h3>

<p><code>sf</code> or <code>SpatRast</code> object of the data points in the
transformed geographical or PoR coordinate system
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to Pacific plate
data("san_andreas")
san_andreas.por &lt;- geographical_to_PoR_sf(san_andreas, PoR)
PoR_to_geographical_sf(san_andreas.por, PoR)
</code></pre>

<hr>
<h2 id='PoR2Geo_azimuth'>Azimuth conversion from PoR to geographical coordinate reference system</h2><span id='topic+PoR2Geo_azimuth'></span>

<h3>Description</h3>

<p>Conversion of PoR azimuths into geographical azimuths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoR2Geo_azimuth(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoR2Geo_azimuth_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> containing the PoR equivalent azimuths
(<code>azi.PoR</code>), and either the geographical coordinates of the
point(s) or the PoR-equivalent coordinates.</p>
</td></tr>
<tr><td><code id="PoR2Geo_azimuth_+3A_por">PoR</code></td>
<td>
<p><code>data.frame</code> containing the geographical location of
the Euler pole (<code>lat</code>, <code>lon</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of transformed azimuths (in degrees)
</p>


<h3>References</h3>

<p>Stephan, T., Enkelmann, E., and Kroner, U. &quot;Analyzing the
horizontal orientation of the crustal stress adjacent to plate boundaries&quot;.
<em>Sci Rep</em> 13. 15590 (2023). <a href="https://doi.org/10.1038/s41598-023-42433-2">doi:10.1038/s41598-023-42433-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
# North America relative to Pacific plate:
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
data("san_andreas")
head(san_andreas$azi)
san_andreas$azi.PoR &lt;- PoR_shmax(san_andreas, PoR)
res.geo &lt;- PoR2Geo_azimuth(san_andreas, PoR)
head(res.geo)
</code></pre>

<hr>
<h2 id='PositionCenterSpoke'>Centrically aligned geom_spoke marker</h2><span id='topic+PositionCenterSpoke'></span>

<h3>Description</h3>

<p><code>"position"</code> subclass &quot;center_spoke&quot; to center
<code>ggplot::geom_spoke()</code> marker at its origin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PositionCenterSpoke
</code></pre>


<h3>Format</h3>

<p>An object of class <code>PositionCenterSpoke</code> (inherits from <code>Position</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>


<h3>Source</h3>

<p><a href="https://stackoverflow.com/questions/55474143/how-to-center-geom-spoke-around-their-origin">https://stackoverflow.com/questions/55474143/how-to-center-geom-spoke-around-their-origin</a>
</p>

<hr>
<h2 id='prd_err'>Error of Model's Prediction</h2><span id='topic+prd_err'></span>

<h3>Description</h3>

<p>The maximum error in the model's predicted azimuth given the Pole of
rotations uncertainty and distance of the data point to the pole.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prd_err(dist_PoR, sigma_PoR = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prd_err_+3A_dist_por">dist_PoR</code></td>
<td>
<p>Distance to Euler pole (great circle distance, in degree)</p>
</td></tr>
<tr><td><code id="prd_err_+3A_sigma_por">sigma_PoR</code></td>
<td>
<p>uncertainty of the position of the Pole of rotation
(in degree).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector. The maximum error for azimuths prediction (in degree)
</p>


<h3>References</h3>

<p>Ramsay, J.A. Folding and fracturing of rocks. McGraw-Hill, New York, 1967.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code> and <code><a href="#topic+model_shmax">model_shmax()</a></code> for the model's prediction, and
<code><a href="#topic+orthodrome">orthodrome()</a></code> for great circle distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prd_err(67, 1)
</code></pre>

<hr>
<h2 id='product_Q4'>Product of quaternions</h2><span id='topic+product_Q4'></span>

<h3>Description</h3>

<p>Helper function for multiplication of two quaternions.
Concatenation of two rotations R1 followed by R2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>product_Q4(q1, q2, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="product_Q4_+3A_q1">q1</code>, <code id="product_Q4_+3A_q2">q2</code></td>
<td>
<p>two objects of class <code>"quaternion"</code>. first rotation R1 expressed by q1 followed by second rotation R2 expressed by q2</p>
</td></tr>
<tr><td><code id="product_Q4_+3A_normalize">normalize</code></td>
<td>
<p>logical. Whether a quaternion normalization should be applied (TRUE) or not (FALSE, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>"quaternion"</code>
</p>


<h3>Note</h3>

<p>Multiplication is not commutative.
</p>

<hr>
<h2 id='projected_pb_strike'>Strike of the plate boundary projected on data point</h2><span id='topic+projected_pb_strike'></span>

<h3>Description</h3>

<p>The fault's strike in the PoR CRS projected on the data point along the
predicted stress trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projected_pb_strike(x, PoR, pb, tangential = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projected_pb_strike_+3A_x">x</code>, <code id="projected_pb_strike_+3A_pb">pb</code></td>
<td>
<p><code>sf</code> objects of the data points and the plate boundary
geometries in the geographical coordinate system</p>
</td></tr>
<tr><td><code id="projected_pb_strike_+3A_por">PoR</code></td>
<td>
<p>Pole of rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
<tr><td><code id="projected_pb_strike_+3A_tangential">tangential</code></td>
<td>
<p>Logical. Whether the plate boundary is a tangential
boundary (<code>TRUE</code>) or an inward and outward boundary (<code>FALSE</code>, the
default).</p>
</td></tr>
<tr><td><code id="projected_pb_strike_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="smoothr.html#topic+densify">smoothr::densify()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful to calculate the beta angle, i.e. the angle
between SHmax direction (in PoR CRS!) and the fault's strike (in PoR CRS).
The beta angle is the same in geographical and PoR coordinates.
</p>


<h3>Value</h3>

<p>Numeric vector of the strike direction of the plate boundary
(in degree)
</p>


<h3>Note</h3>

<p>The algorithm calculates the great circle bearing between line
vertices. Since transform plate boundaries represent small circle lines in
the PoR system, this great-circle azimuth is only a approximation of the
true (small-circle) azimuth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
res &lt;- projected_pb_strike(
  x = san_andreas, PoR = na_pa, pb = plate_boundary, tangential = TRUE
)
head(res)
head(san_andreas$azi - res) # beta angle
</code></pre>

<hr>
<h2 id='Q4_to_euler'>Euler angle/axis from quaternion</h2><span id='topic+Q4_to_euler'></span>

<h3>Description</h3>

<p>Euler angle/axis from quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q4_to_euler(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q4_to_euler_+3A_q">q</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"euler.pole"</code> object
</p>

<hr>
<h2 id='quantise_wsm_quality'>Numerical values to World Stress Map Quality Ranking</h2><span id='topic+quantise_wsm_quality'></span>

<h3>Description</h3>

<p>Assigns numeric values of the precision of each measurement to the
categorical quality ranking of the World Stress Map (A, B, C, D).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantise_wsm_quality(regime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantise_wsm_quality_+3A_regime">regime</code></td>
<td>
<p>Either a string or a character vector of WSM quality ranking</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"integer"</code> or vector of type <code>"integer"</code>
</p>


<h3>References</h3>

<p>Heidbach, O., Barth, A., Müller, B., Reinecker, J.,
Stephansson, O., Tingay, M., Zang, A. (2016). WSM quality
ranking scheme, database description and analysis guidelines for stress
indicator. <em>World Stress Map Technical Report</em> <strong>16-01</strong>, GFZ German Research
Centre for Geosciences. <a href="https://doi.org/10.2312/wsm.2016.001">doi:10.2312/wsm.2016.001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quantise_wsm_quality(c("A", "B", "C", "D", NA))
data("san_andreas")
quantise_wsm_quality(san_andreas$quality)
</code></pre>

<hr>
<h2 id='quick_plot'>Plotting stress analysis results</h2><span id='topic+quick_plot'></span>

<h3>Description</h3>

<p>Creates a set of plots including
the azimuth as a function of the distance to the plate boundary,
the Norm Chi-squared as a function of the distance to the plate boundary,
the circular distance (and dispersion) a function of the distance to the
plate boundary, and a rose diagram of the frequency distribution of the
azimuths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quick_plot(azi, distance, prd, unc = NULL, regime, width = 51)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quick_plot_+3A_azi">azi</code></td>
<td>
<p>numeric. Azimuth of <code class="reqn">\sigma_{Hmax}</code></p>
</td></tr>
<tr><td><code id="quick_plot_+3A_distance">distance</code></td>
<td>
<p>numeric. Distance to plate boundary</p>
</td></tr>
<tr><td><code id="quick_plot_+3A_prd">prd</code></td>
<td>
<p>numeric. the predicted direction of <code class="reqn">\sigma_{Hmax}</code></p>
</td></tr>
<tr><td><code id="quick_plot_+3A_unc">unc</code></td>
<td>
<p>numeric. Uncertainty of observed <code class="reqn">\sigma_{Hmax}</code>,
either a numeric vector or a number</p>
</td></tr>
<tr><td><code id="quick_plot_+3A_regime">regime</code></td>
<td>
<p>character vector. The stress
regime (following the classification of the World Stress Map)</p>
</td></tr>
<tr><td><code id="quick_plot_+3A_width">width</code></td>
<td>
<p>integer. window width (in number of observations) for moving
average of the azimuths, circular dispersion, and Norm Chi-square statistics.
If <code>NULL</code>, an optimal width will be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot 1 shows the transformed azimuths as a function of the distance to the
plate boundary. The red line indicates the rolling circular mean, stippled
red lines indicate the 95% confidence interval about the mean.
</p>
<p>Plot 2 shows the normalized <code class="reqn">\chi^2</code> statistics as a
function of the distance to the plate boundary. The red line shows the
rolling <code class="reqn">\chi^2</code> statistic.
</p>
<p>Plot 3 shows the circular distance of the transformed azimuths to the
predicted azimuth, as a function of the distance to the plate boundary. The
red line shows the rolling circular dispersion about the prediction.
</p>
<p>Plot 4 give the rose diagram of the transformed azimuths.
</p>


<h3>Value</h3>

<p>four R base plots
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>, <code><a href="#topic+distance_from_pb">distance_from_pb()</a></code>, <code><a href="#topic+circular_mean">circular_mean()</a></code>,
<code><a href="#topic+circular_dispersion">circular_dispersion()</a></code>, <code><a href="#topic+confidence_angle">confidence_angle()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>,
<code><a href="#topic+weighted_rayleigh">weighted_rayleigh()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
res &lt;- PoR_shmax(san_andreas, na_pa, "right")
d &lt;- distance_from_pb(san_andreas, na_pa, plate_boundary, tangential = TRUE)
quick_plot(res$azi.PoR, d, res$prd, san_andreas$unc, san_andreas$regime)
</code></pre>

<hr>
<h2 id='raster_transformation'>Conversion between PoR to geographical coordinate reference system of raster
data</h2><span id='topic+raster_transformation'></span><span id='topic+geographical_to_PoR_raster'></span><span id='topic+PoR_to_geographical_raster'></span>

<h3>Description</h3>

<p>Helper function to transform raster data set from PoR to geographical
coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geographical_to_PoR_raster(x, PoR)

PoR_to_geographical_raster(x, PoR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_transformation_+3A_x">x</code></td>
<td>
<p><code>"SpatRaster"</code> or <code>"RasterLayer"</code></p>
</td></tr>
<tr><td><code id="raster_transformation_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>"data.frame"</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
</table>


<h3>Value</h3>

<p>terra &quot;SpatRaster&quot; object
</p>

<hr>
<h2 id='rayleigh_test'>Rayleigh Test of Circular Uniformity</h2><span id='topic+rayleigh_test'></span>

<h3>Description</h3>

<p>Performs a Rayleigh test of uniformity (or randomness), assessing the
significance of the mean resultant length.
The alternative hypothesis is an unimodal distribution with unknown mean
direction and unknown mean resultant length if <code>mu</code> is <code>NULL</code>.
If <code>mu</code> is specified the alternative hypothesis is a unimodal distribution with a
specified mean direction and unknown mean resultant length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rayleigh_test(x, mu = NULL, axial = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rayleigh_test_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees</p>
</td></tr>
<tr><td><code id="rayleigh_test_+3A_mu">mu</code></td>
<td>
<p>(optional) The specified or known mean direction (in degrees) in alternative hypothesis</p>
</td></tr>
<tr><td><code id="rayleigh_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>statistic &gt; p.value</code>, the null hypothesis is rejected,
i.e. the length of the mean resultant differs significantly from zero.
If not, randomness (uniform distribution) cannot be excluded.
</p>


<h3>Value</h3>

<p>a list with the components:
</p>

<dl>
<dt><code>statistic</code></dt><dd><p>mean resultant length</p>
</dd>
<dt><code>p.value</code></dt><dd><p>significance level of the test statistic</p>
</dd>
<dt><code>p.value2</code></dt><dd><p>modified significance level (Cordeiro and Ferrari, 1991)</p>
</dd>
</dl>



<h3>Note</h3>

<p>Although the Rayleigh test is consistent against (non-uniform)
von Mises alternatives, it is not consistent against alternatives with <code>p = 0</code>
(in particular, distributions with antipodal symmetry, i.e. axial data).
Tests of non-uniformity which are consistent against all alternatives
include Kuiper’s test (<code><a href="#topic+kuiper_test">kuiper_test()</a></code>) and Watson’s <code class="reqn">U^2</code> test
(<code><a href="#topic+watson_test">watson_test()</a></code>).
</p>


<h3>References</h3>

<p>Mardia and Jupp (2000). Directional Statistics. John Wiley and Sons.
</p>
<p>Wilkie (1983): Rayleigh Test for Randomness of Circular Data. Appl. Statist. 32, No. 3, pp. 311-312
</p>
<p>Jammalamadaka, S. Rao and Sengupta, A. (2001). Topics in Circular Statistics, Sections 3.3.3 and 3.4.1, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_resultant_length">mean_resultant_length()</a></code>, <code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>, <code><a href="#topic+kuiper_test">kuiper_test()</a></code>, <code><a href="#topic+watson_test">watson_test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Mardia and Jupp (2001), pp. 93
pidgeon_homing &lt;- c(55, 60, 65, 95, 100, 110, 260, 275, 285, 295)
rayleigh_test(pidgeon_homing, axial = FALSE)

# Example data from Davis (1986), pp. 316
finland_stria &lt;- c(
  23, 27, 53, 58, 64, 83, 85, 88, 93, 99, 100, 105, 113,
  113, 114, 117, 121, 123, 125, 126, 126, 126, 127, 127, 128, 128, 129, 132,
  132, 132, 134, 135, 137, 144, 145, 145, 146, 153, 155, 155, 155, 157, 163,
  165, 171, 172, 179, 181, 186, 190, 212
)
rayleigh_test(finland_stria, axial = FALSE)
rayleigh_test(finland_stria, mu = 105, axial = FALSE)

# Example data from Mardia and Jupp (2001), pp. 99
atomic_weight &lt;- c(
  rep(0, 12), rep(3.6, 1), rep(36, 6), rep(72, 1),
  rep(108, 2), rep(169.2, 1), rep(324, 1)
)
rayleigh_test(atomic_weight, 0, axial = FALSE)

# San Andreas Fault Data:
data(san_andreas)
rayleigh_test(san_andreas$azi)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
rayleigh_test(sa.por$azi.PoR, mu = 135)
</code></pre>

<hr>
<h2 id='relative_rotation'>Relative rotation between two rotations</h2><span id='topic+relative_rotation'></span><span id='topic+rotation'></span><span id='topic+quaternion'></span>

<h3>Description</h3>

<p>Calculates the relative rotation between two rotations, i.e. the
difference from rotation 1 to rotation 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative_rotation(r1, r2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relative_rotation_+3A_r1">r1</code>, <code id="relative_rotation_+3A_r2">r2</code></td>
<td>
<p>Objects of class <code>"euler.pole"</code>. First rotation is
<code>r1</code>, followed rotation <code>r2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>. Euler axes
(geographical coordinates) and Euler angles (in degrees)
</p>


<h3>References</h3>

<p>Schaeben, H., Kroner, U. and Stephan, T. (2021). Euler Poles of
Tectonic Plates. In B. S. Daza Sagar, Q. Cheng, J. McKinley and F. Agterberg
(Eds.), <em>Encyclopedia of Mathematical Geosciences. Encyclopedia of Earth Sciences Series</em>
(pp. 1&ndash;7). Springer Nature Switzerland AG 2021.
doi: 10.1007/978-3-030-26050-7_435-1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+euler_pole">euler_pole()</a></code> for class <code>"euler.pole"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- euler_pole(90, 0, angle = 45)
b &lt;- euler_pole(0, 0, 1, geo = FALSE, angle = -15)
relative_rotation(a, b)
relative_rotation(b, a)
</code></pre>

<hr>
<h2 id='roll_circstats'>Apply Rolling Functions using Circular Statistics</h2><span id='topic+roll_circstats'></span>

<h3>Description</h3>

<p>A generic function for applying a function to rolling margins of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_circstats(
  x,
  w = NULL,
  FUN,
  axial = TRUE,
  na.rm = TRUE,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_circstats_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_w">w</code></td>
<td>
<p>(optional) Weights. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value indicating whether <code>NA</code> values in <code>x</code>
should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_width">width</code></td>
<td>
<p>integer specifying the window width (in numbers of observations)
which is aligned to the original sample according to the <code>align</code> argument.
If <code>NULL</code>, an optimal width is calculated.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_by.column">by.column</code></td>
<td>
<p>logical. If <code>TRUE</code>, FUN is applied to each column separately.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_partial">partial</code></td>
<td>
<p>logical or numeric. If <code>FALSE</code> then <code>FUN</code> is only
applied when all indexes of the rolling window are within the observed time
range. If <code>TRUE</code> (default), then the subset of indexes that are in range
are passed to <code>FUN</code>. A numeric argument to partial can be used to determine
the minimal window size for partial computations. See below for more details.</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_fill">fill</code></td>
<td>
<p>a three-component vector or list (recycled otherwise) providing
filling values at the left/within/to the right of the data range. See the
fill argument of <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code> for details</p>
</td></tr>
<tr><td><code id="roll_circstats_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="zoo.html#topic+rollapply">zoo::rollapply</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector  with the results of the rolling function.
</p>


<h3>Note</h3>

<p>If the rolling statistics are applied to values that are a function of
distance it is recommended to sort the values first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")
data("san_andreas")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
distance &lt;- distance_from_pb(
  x = san_andreas,
  PoR = PoR,
  pb = plate_boundary,
  tangential = TRUE
)
dat &lt;- san_andreas[order(distance), ]
roll_circstats(dat$azi, w = 1 / dat$unc, circular_mean, width = 51)
</code></pre>

<hr>
<h2 id='rolling_test'>Apply Rolling Functions using Circular Statistical Tests for Uniformity</h2><span id='topic+rolling_test'></span><span id='topic+roll_normchisq'></span><span id='topic+roll_rayleigh'></span><span id='topic+roll_dispersion'></span><span id='topic+roll_confidence'></span><span id='topic+roll_dispersion_CI'></span><span id='topic+roll_dispersion_sde'></span>

<h3>Description</h3>

<p>A generic function for applying a function to rolling margins of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_normchisq(
  obs,
  prd,
  unc = NULL,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_rayleigh(
  obs,
  prd,
  unc = NULL,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_dispersion(
  x,
  y,
  w = NULL,
  w.y = NULL,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_confidence(
  x,
  conf.level = 0.95,
  w = NULL,
  axial = TRUE,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_dispersion_CI(
  x,
  y,
  w = NULL,
  w.y = NULL,
  R,
  conf.level = 0.95,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)

roll_dispersion_sde(
  x,
  y,
  w = NULL,
  w.y = NULL,
  R,
  conf.level = 0.95,
  width = NULL,
  by.column = FALSE,
  partial = TRUE,
  fill = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rolling_test_+3A_obs">obs</code></td>
<td>
<p>Numeric vector containing the observed azimuth of
<code class="reqn">\sigma_{Hmax}</code>,
same length as <code>prd</code></p>
</td></tr>
<tr><td><code id="rolling_test_+3A_prd">prd</code></td>
<td>
<p>Numeric vector containing the modeled azimuths of
<code class="reqn">\sigma_{Hmax}</code>, i.e.
the return object from <code>model_shmax()</code></p>
</td></tr>
<tr><td><code id="rolling_test_+3A_unc">unc</code></td>
<td>
<p>Uncertainty of observed <code class="reqn">\sigma_{Hmax}</code>, either a
numeric vector or a number</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_width">width</code></td>
<td>
<p>integer specifying the window width (in numbers of observations)
which is aligned to the original sample according to the <code>align</code> argument.
If <code>NULL</code>, an optimal width is estimated.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_by.column">by.column</code></td>
<td>
<p>logical. If <code>TRUE</code>, FUN is applied to each column separately.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_partial">partial</code></td>
<td>
<p>logical or numeric. If <code>FALSE</code> then <code>FUN</code> is only
applied when all indexes of the rolling window are within the observed time
range. If <code>TRUE</code> (default), then the subset of indexes that are in range
are passed to <code>FUN</code>. A numeric argument to partial can be used to determine
the minimal window size for partial computations. See below for more details.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_fill">fill</code></td>
<td>
<p>a three-component vector or list (recycled otherwise) providing
filling values at the left/within/to the right of the data range. See the
fill argument of <code><a href="zoo.html#topic+na.fill">zoo::na.fill()</a></code> for details</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="zoo.html#topic+rollapply">zoo::rollapply()</a></code></p>
</td></tr>
<tr><td><code id="rolling_test_+3A_x">x</code>, <code id="rolling_test_+3A_y">y</code></td>
<td>
<p>numeric. Directions in degrees</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_w">w</code>, <code id="rolling_test_+3A_w.y">w.y</code></td>
<td>
<p>(optional) Weights of <code>x</code> and <code>y</code>, respectively. A vector of positive numbers and of the same
length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence: <code class="reqn">(1 - \alpha \%)/100</code>.
(<code>0.95</code> by default).</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. pi-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rolling_test_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the test statistic of the rolling test.
<code>roll_dispersion_CI</code> returns a 2-column matrix with the lower and the upper confidence limits
</p>


<h3>Note</h3>

<p>If the rolling functions are applied to values that are a function of
distance it is recommended to sort the values first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")
data("san_andreas")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
distance &lt;- distance_from_pb(
  x = san_andreas,
  PoR = PoR,
  pb = plate_boundary,
  tangential = TRUE
)
dat &lt;- san_andreas[order(distance), ]
dat.PoR &lt;- PoR_shmax(san_andreas, PoR, "right")
roll_normchisq(dat.PoR$azi.PoR, 135, dat$unc)
roll_rayleigh(dat.PoR$azi.PoR, prd = 135, unc = dat$unc)
roll_dispersion(dat.PoR$azi.PoR, y = 135, w = 1 / dat$unc)
roll_confidence(dat.PoR$azi.PoR, w = 1 / dat$unc)

roll_dispersion_CI(dat.PoR$azi.PoR, y = 135, w = 1 / dat$unc, R = 10)

</code></pre>

<hr>
<h2 id='rolling_test_dist'>Apply Rolling Functions using Circular Statistics</h2><span id='topic+rolling_test_dist'></span><span id='topic+distroll_circstats'></span><span id='topic+distroll_confidence'></span><span id='topic+distroll_dispersion'></span><span id='topic+distroll_dispersion_sde'></span>

<h3>Description</h3>

<p>A generic function for applying a function to rolling margins of an array
along an additional value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distroll_circstats(
  x,
  distance,
  FUN,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  w = NULL,
  sort = TRUE,
  ...
)

distroll_confidence(
  x,
  distance,
  w = NULL,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  sort = TRUE,
  ...
)

distroll_dispersion(
  x,
  y,
  w = NULL,
  w.y = NULL,
  distance,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  sort = TRUE,
  ...
)

distroll_dispersion_sde(
  x,
  y,
  w = NULL,
  w.y = NULL,
  distance,
  width = NULL,
  min_n = 2,
  align = c("right", "center", "left"),
  sort = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rolling_test_dist_+3A_x">x</code>, <code id="rolling_test_dist_+3A_y">y</code></td>
<td>
<p>vectors of numeric values in degrees. <code>length(y)</code> is either 1 or
<code>length(x)</code></p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_distance">distance</code></td>
<td>
<p>numeric. the independent variable along the values in <code>x</code>
are sorted, e.g. the plate boundary distances</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_width">width</code></td>
<td>
<p>numeric. the range across <code>distance</code> on which <code>FUN</code> should be
applied on <code>x</code>. If <code>NULL</code>, then width is a number that separates the
distances in 10 equal groups.</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_min_n">min_n</code></td>
<td>
<p>integer. The minimum values that should be considered in <code>FUN</code>
(2 by default), otherwise <code>NA</code>.</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_align">align</code></td>
<td>
<p>specifies whether the index of the result should be left- or
right-aligned or centered (default) compared to the rolling window of
observations. This argument is only used if width represents widths.</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_w">w</code></td>
<td>
<p>numeric. the weighting for <code>x</code></p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_sort">sort</code></td>
<td>
<p>logical. Should the values be sorted after <code>distance</code> prior to
applying the function (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code></p>
</td></tr>
<tr><td><code id="rolling_test_dist_+3A_w.y">w.y</code></td>
<td>
<p>numeric. the weighting for <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>two-column vectors of (sorted) <code>x</code> and the rolled statistics along
<code>distance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")
data("san_andreas")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
san_andreas$distance &lt;- distance_from_pb(
  x = san_andreas,
  PoR = PoR,
  pb = plate_boundary,
  tangential = TRUE
)
dat &lt;- san_andreas |&gt; cbind(PoR_shmax(san_andreas, PoR, "right"))

distroll_circstats(dat$azi.PoR, distance = dat$distance, w = 1 / dat$unc, FUN = circular_mean)
distroll_confidence(dat$azi.PoR, distance = dat$distance, w = 1 / dat$unc)
distroll_dispersion(dat$azi.PoR, y = 135, distance = dat$distance, w = 1 / dat$unc)
distroll_dispersion_sde(dat$azi.PoR, y = 135, distance = dat$distance, w = 1 / dat$unc, R = 100)
</code></pre>

<hr>
<h2 id='rose'>Rose Diagram</h2><span id='topic+rose'></span>

<h3>Description</h3>

<p>Plots a rose diagram (rose of directions), the analogue of a
histogram or density plot for angular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose(
  x,
  weights = NULL,
  binwidth = NULL,
  bins = NULL,
  axial = TRUE,
  equal_area = TRUE,
  clockwise = TRUE,
  muci = TRUE,
  round_binwidth = 0,
  mtext = "N",
  main = NULL,
  sub = NULL,
  at = seq(0, 360 - 45, 45),
  col = "grey",
  dots = FALSE,
  dot_pch = 1,
  dot_cex = 1,
  dot_col = "grey",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_+3A_x">x</code></td>
<td>
<p>Data to be plotted. A numeric vector containing angles (in degrees).</p>
</td></tr>
<tr><td><code id="rose_+3A_weights">weights</code></td>
<td>
<p>Optional vector of numeric weights associated with x.</p>
</td></tr>
<tr><td><code id="rose_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins (in degrees).</p>
</td></tr>
<tr><td><code id="rose_+3A_bins">bins</code></td>
<td>
<p>number of arcs to partition the circle width.
Overridden by <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="rose_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_+3A_equal_area">equal_area</code></td>
<td>
<p>Logical. Whether the radii of the bins are proportional to
the frequencies (<code>equal_area=FALSE</code>, i.e. equal-angle) or proportional to the
square-root of the frequencies (<code>equal_area=TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_+3A_clockwise">clockwise</code></td>
<td>
<p>Logical. Whether angles increase in the
clockwise direction (<code>clockwise=TRUE</code>, the default) or anti-clockwise,
counter-clockwise direction (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rose_+3A_muci">muci</code></td>
<td>
<p>logical. Whether the mean and its 95% CI are added to the plot
or not.</p>
</td></tr>
<tr><td><code id="rose_+3A_round_binwidth">round_binwidth</code></td>
<td>
<p>integer. Number of decimal places of bin width (0 by
default).</p>
</td></tr>
<tr><td><code id="rose_+3A_mtext">mtext</code></td>
<td>
<p>character. String to be drawn at the top margin of the plot
(<code>"N"</code> by default)</p>
</td></tr>
<tr><td><code id="rose_+3A_main">main</code>, <code id="rose_+3A_sub">sub</code></td>
<td>
<p>Character string specifying the title and subtitle of the
plot. If <code>sub = NULL</code>, it will show the bin width.</p>
</td></tr>
<tr><td><code id="rose_+3A_at">at</code></td>
<td>
<p>Optional vector of angles at which tick marks should be plotted.
Set <code>at=numeric(0)</code> to suppress tick marks.</p>
</td></tr>
<tr><td><code id="rose_+3A_col">col</code></td>
<td>
<p>fill color of bins</p>
</td></tr>
<tr><td><code id="rose_+3A_dots">dots</code></td>
<td>
<p>logical. Whether a circular dot plot should be added
(<code>FALSE</code> is the default).</p>
</td></tr>
<tr><td><code id="rose_+3A_dot_cex">dot_cex</code>, <code id="rose_+3A_dot_pch">dot_pch</code>, <code id="rose_+3A_dot_col">dot_col</code></td>
<td>
<p>Plotting arguments for circular dot plot</p>
</td></tr>
<tr><td><code id="rose_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spatstat.explore.html#topic+rose">spatstat.explore::rose()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A window (class <code>"owin"</code>) containing the plotted region.
</p>


<h3>Note</h3>

<p>If <code>bins</code> and <code>binwidth</code> are <code>NULL</code>, an optimal bin width will be
calculated using Scott (1979):
</p>
<p style="text-align: center;"><code class="reqn"> w_b = \frac{R}{n^{\frac{1}{3}}}
</code>
</p>

<p>with n being the length of <code>x</code>, and the range R being either 180 or 360
degree for axial or directional data, respectively.
</p>
<p>If <code>"axial" == TRUE</code>, the binwidth is adjusted to guarantee symmetrical fans.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvm(100, mean = 90, k = 5)
rose(x, axial = FALSE, border = TRUE)

data("san_andreas")
rose(san_andreas$azi, dots = TRUE, main = "dot plot")
rose(san_andreas$azi, weights = 1 / san_andreas$unc, main = "weighted")
</code></pre>

<hr>
<h2 id='rose_baseplot'>Rose Diagram</h2><span id='topic+rose_baseplot'></span>

<h3>Description</h3>

<p>Rose Diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_baseplot(
  start = -90,
  clockwise = TRUE,
  main = NULL,
  labels = TRUE,
  at = seq(0, 360 - 45, 45),
  cborder = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_baseplot_+3A_start">start</code></td>
<td>
<p>The starting direction for measurement of angles, that is, the
spatial direction which corresponds to a measured angle of zero. Either a
character string giving a compass direction (<code>"N"</code> for north, <code>"S"</code> for south,
<code>"E"</code> for east, or <code>"W"</code> for west) or a number giving the angle from the the
horizontal (East) axis to the starting direction. For example, if
<code>clockwise=FALSE</code>, then <code>start=90</code> and <code>start="N"</code> are
equivalent. The default is to measure angles anti-clockwise from the
horizontal axis (East direction).</p>
</td></tr>
<tr><td><code id="rose_baseplot_+3A_clockwise">clockwise</code></td>
<td>
<p>Logical. Whether angles increase in the
clockwise direction (<code>clockwise=TRUE</code>, the default) or anti-clockwise,
counter-clockwise direction (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rose_baseplot_+3A_main">main</code></td>
<td>
<p>Character string specifying the title of the plot.</p>
</td></tr>
<tr><td><code id="rose_baseplot_+3A_labels">labels</code></td>
<td>
<p>Either a logical value indicating whether to plot labels
next to the tick marks, or a vector of labels for the tick marks.</p>
</td></tr>
<tr><td><code id="rose_baseplot_+3A_at">at</code></td>
<td>
<p>Optional vector of angles at which tick marks should be plotted.
Set <code>at=numeric(0)</code> to suppress tick marks.</p>
</td></tr>
<tr><td><code id="rose_baseplot_+3A_cborder">cborder</code></td>
<td>
<p>logical. Border of rose plot.</p>
</td></tr>
<tr><td><code id="rose_baseplot_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>plot.default()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>

<hr>
<h2 id='rose_bw'>Selecting optimal number of bins and width for rose diagrams</h2><span id='topic+rose_bw'></span><span id='topic+rose_bins'></span><span id='topic+rose_binwidth'></span>

<h3>Description</h3>

<p>Selecting optimal number of bins and width for rose diagrams
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_bins(n, round = FALSE)

rose_binwidth(n, axial = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_bw_+3A_n">n</code></td>
<td>
<p>Integer. number of data</p>
</td></tr>
<tr><td><code id="rose_bw_+3A_round">round</code></td>
<td>
<p>Logical. Whether bin width is round to zero digits
(<code>round=TRUE</code>, the default)
or as is (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="rose_bw_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_bw_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+rose_bw">rose_bw()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rose_geom'>Lines and fans in rose diagram</h2><span id='topic+rose_geom'></span><span id='topic+rose_line'></span><span id='topic+rose_fan'></span>

<h3>Description</h3>

<p>Lines and fans in rose diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_line(x, radius = 1, axial = TRUE, add = TRUE, ...)

rose_fan(x, d, radius = 1, axial = TRUE, add = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_geom_+3A_x">x</code></td>
<td>
<p>angles in degrees</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_radius">radius</code></td>
<td>
<p>of the rose diagram</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether x are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_add">add</code></td>
<td>
<p>logical. Add to existing plot?</p>
</td></tr>
<tr><td><code id="rose_geom_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+segments">graphics::segments()</a></code> or
<code><a href="graphics.html#topic+polygon">graphics::polygon()</a></code></p>
</td></tr>
<tr><td><code id="rose_geom_+3A_d">d</code></td>
<td>
<p>width of a fan (in degrees)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(0, 10, 45)
radius &lt;- c(.7, 1, .2)
lwd &lt;- c(2, 1, .75)
col &lt;- c(1, 2, 3)
rose_line(c(0, 10, 45), radius = radius, axial = FALSE, add = FALSE, lwd = lwd, col = col)
</code></pre>

<hr>
<h2 id='rose_stats'>Show Average Direction and Spread in Rose Diagram</h2><span id='topic+rose_stats'></span>

<h3>Description</h3>

<p>Adds the average direction (and its spread) to an existing rose diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_stats(
  x,
  weights = NULL,
  axial = TRUE,
  avg = c("mean", "median"),
  spread = c("CI", "sd", "IQR"),
  avg.col = "#85112AFF",
  avg.lty = 2,
  avg.lwd = 1.5,
  spread.col = ggplot2::alpha("#85112AFF", 0.2),
  spread.border = FALSE,
  spread.lty = NULL,
  spread.lwd = NULL,
  add = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_stats_+3A_x">x</code></td>
<td>
<p>Data to be plotted. A numeric vector containing angles (in degrees).</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_weights">weights</code></td>
<td>
<p>Optional vector of numeric weights associated with x.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_axial">axial</code></td>
<td>
<p>Logical. Whether data are uniaxial (<code>axial=FALSE</code>)
or biaxial (<code>TRUE</code>, the default).</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg">avg</code></td>
<td>
<p>character. The average estimate for x. Either the circular mean
(<code>"mean"</code>, the default) or the circular Quasi Median (<code>"median"</code>)</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread">spread</code></td>
<td>
<p>character. The measure of spread to be plotted as a fan.
Either the 95% confidence interval (<code>"CI"</code>, the default), the circular
standard deviation (<code>"sd"</code>), or the Quasi interquartile range on the circle
(<code>"IQR"</code>). <code>NULL</code> if no fan should be drawn.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg.col">avg.col</code></td>
<td>
<p>color for the average line</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg.lty">avg.lty</code></td>
<td>
<p>line type of the average line</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_avg.lwd">avg.lwd</code></td>
<td>
<p>line width of the average line</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.col">spread.col</code></td>
<td>
<p>color of the spread fan</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.border">spread.border</code></td>
<td>
<p>logical. Whether to draw a border of the fan or not.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.lty">spread.lty</code></td>
<td>
<p>line type of the spread fan's border</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_spread.lwd">spread.lwd</code></td>
<td>
<p>line width of the spread fan's border</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_add">add</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="rose_stats_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>rose_baseplot()</code> if add is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rose">rose()</a></code> for plotting the rose diagram, and
<code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+circular_median">circular_median()</a></code>, <code><a href="#topic+confidence_interval">confidence_interval()</a></code>,
<code><a href="#topic+circular_sd">circular_sd()</a></code>, <code><a href="#topic+circular_IQR">circular_IQR()</a></code> for statistical parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
rose(san_andreas$azi, weights = 1 / san_andreas$unc, muci = FALSE)
rose_stats(san_andreas$azi, weights = 1 / san_andreas$unc, avg = "median", spread = "IQR")
</code></pre>

<hr>
<h2 id='rotate_lines'>Rotate Lines</h2><span id='topic+rotate_lines'></span>

<h3>Description</h3>

<p>Rotates a set of straight lines around an angle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_lines(theta, p, centre)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_lines_+3A_theta">theta</code></td>
<td>
<p>Angle of rotation (in degree)</p>
</td></tr>
<tr><td><code id="rotate_lines_+3A_p">p</code></td>
<td>
<p>Coordinates of the lines end points</p>
</td></tr>
<tr><td><code id="rotate_lines_+3A_centre">centre</code></td>
<td>
<p>Coordinates of the center point of rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code>
</p>

<hr>
<h2 id='rotation_Q4'>Rotation of a vector by a quaternion</h2><span id='topic+rotation_Q4'></span>

<h3>Description</h3>

<p>Rotation of a vector by a quaternion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation_Q4(q, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotation_Q4_+3A_q">q</code></td>
<td>
<p>object of class <code>"quaternion"</code></p>
</td></tr>
<tr><td><code id="rotation_Q4_+3A_p">p</code></td>
<td>
<p>three-column vector (Cartesian coordinates) of unit length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>three-column vector (Cartesian coordinates) of unit length
</p>

<hr>
<h2 id='san_andreas'>Example stress data for tangentially displaced plate boundary</h2><span id='topic+san_andreas'></span>

<h3>Description</h3>

<p>Subset of the World Stress Map (WSM) compilation of information on the
crustal present-day stress field (Version 2016). Subset contains stress data
adjacent to the San Andreas Fault.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('san_andreas')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"sf"</code>
</p>


<h3>Source</h3>

<p><a href="https://www.world-stress-map.org/">https://www.world-stress-map.org/</a>
</p>


<h3>References</h3>

<p>Heidbach, O., M. Rajabi, X. Cui, K. Fuchs, B. Müller, J.
Reinecker, K. Reiter, M. Tingay, F. Wenzel, F. Xie, M. O. Ziegler,
M.-L. Zoback, and M. D. Zoback (2018): The World Stress Map database
release 2016: Crustal stress pattern across scales. <em>Tectonophysics</em>,
<strong>744</strong>, 484-498, <a href="https://doi.org/10.1016/j.tecto.2018.07.007">doi:10.1016/j.tecto.2018.07.007</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
head(san_andreas)
</code></pre>

<hr>
<h2 id='spec_atan'>Quadrant-specific inverse of the tangent</h2><span id='topic+spec_atan'></span><span id='topic+atan2_spec'></span><span id='topic+atan2d_spec'></span>

<h3>Description</h3>

<p>Returns the quadrant specific inverse of the tangent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atan2_spec(x, y)

atan2d_spec(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_atan_+3A_x">x</code>, <code id="spec_atan_+3A_y">y</code></td>
<td>
<p>dividend and divisor that comprise the sum of sines and cosines,
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao, and Ambar Sengupta (2001). Topics in
circular statistics. Vol. 5. world scientific.
</p>

<hr>
<h2 id='spherical_angle'>Angle along great circle on spherical surface</h2><span id='topic+spherical_angle'></span><span id='topic+orthodrome'></span><span id='topic+haversine'></span><span id='topic+vincenty'></span>

<h3>Description</h3>

<p>Smallest angle between two points on the surface of a sphere, measured along
the surface of the sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthodrome(lat1, lon1, lat2, lon2)

haversine(lat1, lon1, lat2, lon2)

vincenty(lat1, lon1, lat2, lon2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spherical_angle_+3A_lat1">lat1</code>, <code id="spherical_angle_+3A_lat2">lat2</code></td>
<td>
<p>numeric vector. latitudes of point 1 and 2 (in radians)</p>
</td></tr>
<tr><td><code id="spherical_angle_+3A_lon1">lon1</code>, <code id="spherical_angle_+3A_lon2">lon2</code></td>
<td>
<p>numeric vector. longitudes of point 1 and 2 (in radians)</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>"orthodrome"</code></dt><dd><p>based on the spherical law of cosines</p>
</dd>
<dt><code>"haversine"</code></dt><dd><p>uses haversine formula that is
optimized for 64-bit floating-point numbers</p>
</dd>
<dt><code>"vincenty"</code></dt><dd><p>uses Vincenty formula for an ellipsoid
with equal major and minor axes</p>
</dd>
</dl>



<h3>Value</h3>

<p>numeric. angle in radians
</p>


<h3>References</h3>


<ul>
<li><p> Imboden, C. &amp; Imboden, D. (1972). Formel fuer Orthodrome und Loxodrome bei
der Berechnung von Richtung und Distanz zwischen Beringungs- und
Wiederfundort.
<em>Die Vogelwarte</em> <strong>26</strong>, 336-346.
</p>
</li>
<li><p> Sinnott, Roger W. (1984). Virtues of the Haversine. <em>Sky and telescope</em>
<strong>68</strong>(2), 158.
Vincenty, T. (1975). Direct and inverse solutions of geodesics on the
ellipsoid with application of nested equations. <em>Survey Review</em>, <strong>23</strong>(176),
88–93. <a href="https://doi.org/10.1179/sre.1975.23.176.88">doi:10.1179/sre.1975.23.176.88</a>.
</p>
</li>
<li> <p><a href="http://www.movable-type.co.uk/scripts/latlong.html">http://www.movable-type.co.uk/scripts/latlong.html</a>
</p>
</li>
<li> <p><a href="http://www.edwilliams.org/avform147.htm">http://www.edwilliams.org/avform147.htm</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>berlin &lt;- c(52.52, 13.41)
calgary &lt;- c(51.04, -114.072)
orthodrome(berlin[1], berlin[2], calgary[1], calgary[2])
haversine(berlin[1], berlin[2], calgary[1], calgary[2])
vincenty(berlin[1], berlin[2], calgary[1], calgary[2])
</code></pre>

<hr>
<h2 id='stress_analysis'>Quick analysis of a stress data set</h2><span id='topic+stress_analysis'></span>

<h3>Description</h3>

<p>Returns the converted azimuths, distances to the plate boundary,
statistics of the model, and some plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress_analysis(
  x,
  PoR,
  type = c("none", "in", "out", "right", "left"),
  pb,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stress_analysis_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> or <code>sf</code> object containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>), the direction of
<code class="reqn">\sigma_{Hmax}</code> <code>azi</code> and its standard deviation
<code>unc</code> (optional)</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_por">PoR</code></td>
<td>
<p>Pole of Rotation. <code>data.frame</code> or object of class <code>"euler.pole"</code>
containing the geographical coordinates of the Euler pole</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_type">type</code></td>
<td>
<p>Character. Type of plate boundary (optional). Can be
<code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively. If <code>"none"</code> (the default), only
the PoR-equivalent azimuth is returned.</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_pb">pb</code></td>
<td>
<p>(optional) <code>sf</code> object of the plate boundary geometries in the geographical
coordinate system</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_plot">plot</code></td>
<td>
<p>(logical). Whether to produce a plot additional to output.</p>
</td></tr>
<tr><td><code id="stress_analysis_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="#topic+distance_from_pb">distance_from_pb()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following values:
</p>

<dl>
<dt><code>results</code></dt><dd><p>data.frame showing the the coordinate and azimuth conversions
(<code>lat.PoR</code>, <code>lon.PoR</code>, and <code>azi.PoR</code>), the predicted azimuths (<code>prd</code>),
deviation angle from predicted (<code>dev</code>), circular distance (<code>cdist</code>),
misfit to predicted stress direction (<code>nchisq</code>) and, if given, distance to tested
plate boundary (<code>distance</code>)</p>
</dd>
<dt><code>stats</code></dt><dd><p>array with circular (weighted) mean, circular standard deviation, circular variance, circular dispersion, the 95% confidence angle, and the normalized Chi-squared test statistic</p>
</dd>
<dt><code>test</code></dt><dd><p>list containting the test results of the (weighted) Rayleigh test against the uniform distribution about the predicted  orientation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+PoR_shmax">PoR_shmax()</a></code>, <code><a href="#topic+distance_from_pb">distance_from_pb()</a></code>, <code><a href="#topic+norm_chisq">norm_chisq()</a></code>, <code><a href="#topic+quick_plot">quick_plot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("nuvel1")
na_pa &lt;- subset(nuvel1, nuvel1$plate.rot == "na")

data("plates")
plate_boundary &lt;- subset(plates, plates$pair == "na-pa")

data("san_andreas")
stress_analysis(san_andreas, na_pa, type = "right", plate_boundary, plot = TRUE)

</code></pre>

<hr>
<h2 id='stress_colors'>Color palette for stress regime</h2><span id='topic+stress_colors'></span>

<h3>Description</h3>

<p>Color palette for stress regime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress_colors()
</code></pre>


<h3>Value</h3>

<p>function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stress_colors()
</code></pre>

<hr>
<h2 id='stress_paths'>Theoretical Plate Tectonic Stress Paths</h2><span id='topic+stress_paths'></span><span id='topic+eulerpole_paths'></span><span id='topic+eulerpole_smallcircles'></span><span id='topic+eulerpole_greatcircles'></span><span id='topic+eulerpole_loxodromes'></span>

<h3>Description</h3>

<p>Construct <code class="reqn">\sigma_{Hmax}</code> lines that are
following small circles, great circles, or loxodromes of an Euler pole for
the relative plate motion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulerpole_paths(x, type = c("sc", "gc", "ld"), n = 10, angle, cw)

eulerpole_smallcircles(x, n = 10)

eulerpole_greatcircles(x, n = 10)

eulerpole_loxodromes(x, n = 10, angle = 45, cw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stress_paths_+3A_x">x</code></td>
<td>
<p>Either an object of class <code>"euler.pole"</code> or <code>"data.frame"</code>
containing coordinates of Euler pole in lat, lon, and rotation angle
(optional).</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_type">type</code></td>
<td>
<p>Character string specifying the type of curves to export. Either
<code>"sm"</code> for small circles (default), <code>"gc"</code> for great circles, or
<code>"ld"</code> for loxodromes.</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_n">n</code></td>
<td>
<p>Number of equally spaced curves; <code>n = 10</code> by default (angular
distance between curves: <code>180 / n</code>)</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_angle">angle</code></td>
<td>
<p>Direction of loxodromes; <code>angle = 45</code> by default.</p>
</td></tr>
<tr><td><code id="stress_paths_+3A_cw">cw</code></td>
<td>
<p>logical. Sense of loxodromes: <code>TRUE</code> for clockwise
loxodromes (left-lateral displaced plate boundaries). <code>FALSE</code> for
counterclockwise loxodromes (right-lateral displaced plate boundaries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximum horizontal stress can be aligned to three types of curves
related to relative plate motion:
</p>

<dl>
<dt>Small circles</dt><dd><p>Lines that have a constant distance to the Euler pole.
If <code>x</code> contains <code>angle</code>, output additionally gives absolute
velocity on small circle (degree/Myr -&gt; km/Myr).</p>
</dd>
<dt>Great circles</dt><dd><p>Paths of the shortest distance between the Euler
pole and its antipodal position.</p>
</dd>
<dt>Loxodromes</dt><dd><p>Lines of constant bearing, i.e. curves cutting small
circles at a constant angle.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>sf</code> object
</p>


<h3>Author(s)</h3>

<p>Tobias Stephan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("nuvel1")
por &lt;- subset(nuvel1, nuvel1$plate.rot == "na") # North America relative to
# Pacific plate

eulerpole_smallcircles(por)
eulerpole_greatcircles(por)
eulerpole_loxodromes(x = por, angle = 45, n = 10, cw = FALSE)
eulerpole_loxodromes(x = por, angle = 30, cw = TRUE)
eulerpole_smallcircles(data.frame(lat = 30, lon = 10))
</code></pre>

<hr>
<h2 id='stress2grid'>Spatial interpolation of SHmax</h2><span id='topic+stress2grid'></span>

<h3>Description</h3>

<p>Stress field and wavelength analysis using (weighted) mean/median and
standard deviation/IQR of stress data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stress2grid(
  x,
  stat = c("mean", "median"),
  grid = NULL,
  lon_range = NULL,
  lat_range = NULL,
  gridsize = 2.5,
  min_data = 3,
  threshold = 25,
  arte_thres = 200,
  method_weighting = FALSE,
  quality_weighting = TRUE,
  dist_weight = c("inverse", "linear", "none"),
  dist_threshold = 0.1,
  R_range = seq(50, 1000, 50),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stress2grid_+3A_x">x</code></td>
<td>
<p><code>sf</code> object containing
</p>

<dl>
<dt>azi</dt><dd><p>SHmax in degree</p>
</dd>
<dt>unc</dt><dd><p>Uncertainties of SHmax in degree</p>
</dd>
<dt>type</dt><dd><p>Methods used for the determination of the direction of SHmax</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stress2grid_+3A_stat">stat</code></td>
<td>
<p>Should the direction of interpolated SHmax be based  on the
circular mean and standard deviation (<code>"mean"</code>, the default) or on the
circular median
and interquartile range (<code>"median"</code>)?</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_grid">grid</code></td>
<td>
<p>(optional) Point object of class <code>sf</code>.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_lon_range">lon_range</code>, <code id="stress2grid_+3A_lat_range">lat_range</code></td>
<td>
<p>(optional) numeric vector specifying the minimum
and maximum longitudes and latitudes (are ignored if <code>"grid"</code> is specified).</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_gridsize">gridsize</code></td>
<td>
<p>Numeric. Target spacing of the regular grid in decimal
degree. Default is 2.5. (is ignored if <code>"grid"</code> is specified)</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_min_data">min_data</code></td>
<td>
<p>Integer. Minimum number of data per bin. Default is 3</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. Threshold for deviation of direction. Default is
25</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_arte_thres">arte_thres</code></td>
<td>
<p>Numeric. Maximum distance (in km) of the gridpoint to the
next
datapoint. Default is 200</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_method_weighting">method_weighting</code></td>
<td>
<p>Logical. If a method weighting should be applied:
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_quality_weighting">quality_weighting</code></td>
<td>
<p>Logical. If a quality weighting should be applied:
Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_dist_weight">dist_weight</code></td>
<td>
<p>Distance weighting method which should be used. One of
<code>"none"</code>, <code>"linear"</code>, or <code>"inverse"</code> (the default).</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_dist_threshold">dist_threshold</code></td>
<td>
<p>Numeric. Distance weight to prevent overweight of data
nearby
(0 to 1). Default is 0.1</p>
</td></tr>
<tr><td><code id="stress2grid_+3A_r_range">R_range</code></td>
<td>
<p>Numeric value or vector specifying the search radius (in km).
Default is <code>seq(50, 1000, 50)</code></p>
</td></tr>
<tr><td><code id="stress2grid_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="#topic+dist_greatcircle">dist_greatcircle()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Updated version of the MATLAB script &quot;stress2grid&quot;
</p>


<h3>Value</h3>

<p><code>sf</code> object containing
</p>

<dl>
<dt>lon,lat</dt><dd><p>longitude and latitude in degrees</p>
</dd>
<dt>azi</dt><dd><p>Mean SHmax in degree</p>
</dd>
<dt>sd</dt><dd><p>Standard deviation of SHmax in degrees</p>
</dd>
<dt>R</dt><dd><p>Search radius in km</p>
</dd>
<dt>mdr</dt><dd><p>Mean distance of datapoints per search radius</p>
</dd>
<dt>N</dt><dd><p>Number of data points in search radius</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/MorZieg/Stress2Grid">https://github.com/MorZieg/Stress2Grid</a>
</p>


<h3>References</h3>

<p>Ziegler, M. O. and Heidbach, O. (2019).
Matlab Script Stress2Grid v1.1. GFZ Data Services. <a href="https://doi.org/10.5880/wsm.2019.002">doi:10.5880/wsm.2019.002</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist_greatcircle">dist_greatcircle()</a></code>, <code><a href="#topic+PoR_stress2grid">PoR_stress2grid()</a></code>, <code><a href="#topic+compact_grid">compact_grid()</a></code>,
<code><a href="#topic+circular_mean">circular_mean()</a></code>, <code><a href="#topic+circular_median">circular_median()</a></code>, <code><a href="#topic+circular_sd">circular_sd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("san_andreas")
stress2grid(san_andreas)
</code></pre>

<hr>
<h2 id='superimposed_shmax'>SHmax direction resulting from multiple plate boundaries</h2><span id='topic+superimposed_shmax'></span>

<h3>Description</h3>

<p>Calculates a <code class="reqn">\sigma_{Hmax}</code> direction at given coordinates,
sourced by multiple plate boundaries. This first-order approximation is the
circular mean of the superimposed theoretical directions, weighted by the
rotation rates of the underlying PoRs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superimposed_shmax(df, PoRs, types, absolute = TRUE, PoR_weighting = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superimposed_shmax_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> containing the coordinates of the point(s)
(<code>lat</code>, <code>lon</code>), and the direction of
<code class="reqn">\sigma_{Hmax}</code> <code>azi</code> (in degrees)</p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_pors">PoRs</code></td>
<td>
<p>multirow <code>data.frame</code> or <code>"euler.pole"</code> object that must contain <code>lat</code>,
<code>lon</code> and <code>angle</code></p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_types">types</code></td>
<td>
<p>character vector with length equal to number of rows in <code>PoRs</code>.
Type of plate boundary. Must be <code>"out"</code>, <code>"in"</code>, <code>"right"</code>, or
<code>"left"</code> for outward, inward, right-lateral, or left-lateral
moving plate boundaries, respectively.</p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_absolute">absolute</code></td>
<td>
<p>logical. Whether the resultant azimuth should be weighted
using the absolute rotation at the points or the angular rotation of the PoRs.</p>
</td></tr>
<tr><td><code id="superimposed_shmax_+3A_por_weighting">PoR_weighting</code></td>
<td>
<p>(optional) numeric vector with length equal to number of rows in
<code>PoRs</code>. Extra weightings for the used PoRs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. Resultant azimuth in degrees and geographical CRS
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_shmax">model_shmax()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(san_andreas)
data(nuvel1)
pors &lt;- subset(nuvel1, plate.rot %in% c("eu", "na"))
superimposed_shmax(san_andreas, pors, types = c("in", "right"), PoR_weighting = c(2, 1))
</code></pre>

<hr>
<h2 id='tectonicr.colors'>Colors for input variables</h2><span id='topic+tectonicr.colors'></span>

<h3>Description</h3>

<p>assigns colors to continuous or categorical values for plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tectonicr.colors(
  x,
  n = 10,
  pal = NULL,
  categorical = FALSE,
  na.value = "grey",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tectonicr.colors_+3A_x">x</code></td>
<td>
<p>values for color assignment</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_n">n</code></td>
<td>
<p>integer. number of colors for continuous colors (i.e.
'categorical = FALSE&ldquo;).</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_pal">pal</code></td>
<td>
<p>either a named vector specifying the colors for categorical
values, or a color function. If <code>NULL</code>, default colors are
<code>RColorBrewer::brewer.pal()</code>
(<code>categorical = TRUE</code>) and <code>viridis::viridis()</code> (<code>categorical = FALSE</code>).</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_categorical">categorical</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_na.value">na.value</code></td>
<td>
<p>color for <code>NA</code> values (categorical).</p>
</td></tr>
<tr><td><code id="tectonicr.colors_+3A_...">...</code></td>
<td>
<p>optional arguments passed to palette function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named color vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>val1 &lt;- c("N", "S", "T", "T", NA)
tectonicr.colors(val1, categorical = TRUE)
tectonicr.colors(val1, pal = stress_colors(), categorical = TRUE)

val2 &lt;- runif(10)
tectonicr.colors(val2, n = 5)
</code></pre>

<hr>
<h2 id='tibet'>Example stress data for inward-moving displaced plate boundary</h2><span id='topic+tibet'></span>

<h3>Description</h3>

<p>Subset of the World Stress Map (WSM) compilation of information on the
crustal present-day stress field (Version 2016). Subset contains stress data
of the Himalaya and Tibetan plateau
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data('tibet')
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"sf"</code>
</p>


<h3>Source</h3>

<p><a href="https://www.world-stress-map.org/">https://www.world-stress-map.org/</a>
</p>


<h3>References</h3>

<p>Heidbach, O., M. Rajabi, X. Cui, K. Fuchs, B. Müller, J.
Reinecker, K. Reiter, M. Tingay, F. Wenzel, F. Xie, M. O. Ziegler,
M.-L. Zoback, and M. D. Zoback (2018): The World Stress Map database
release 2016: Crustal stress pattern across scales. <em>Tectonophysics</em>,
<strong>744</strong>, 484-498, <a href="https://doi.org/10.1016/j.tecto.2018.07.007">doi:10.1016/j.tecto.2018.07.007</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("tibet")
head(tibet)
</code></pre>

<hr>
<h2 id='trigon'>Trigonometric Functions in Degrees</h2><span id='topic+trigon'></span><span id='topic+sind'></span><span id='topic+cosd'></span><span id='topic+tand'></span><span id='topic+asind'></span><span id='topic+acosd'></span><span id='topic+atand'></span><span id='topic+atan2d'></span><span id='topic+cot'></span><span id='topic+cotd'></span>

<h3>Description</h3>

<p>Trigonometric functions expecting input in degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sind(x)

cosd(x)

tand(x)

asind(x)

acosd(x)

atand(x)

atan2d(x1, x2)

cot(x)

cotd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trigon_+3A_x">x</code>, <code id="trigon_+3A_x1">x1</code>, <code id="trigon_+3A_x2">x2</code></td>
<td>
<p>Numeric or complex vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar or vector of numeric values.
</p>

<hr>
<h2 id='vcross'>Vector cross product</h2><span id='topic+vcross'></span>

<h3>Description</h3>

<p>Vector or cross product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcross(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcross_+3A_x">x</code>, <code id="vcross_+3A_y">y</code></td>
<td>
<p>numeric vectors of length 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of length 3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcross(c(1, 2, 3), c(4, 5, 6))
</code></pre>

<hr>
<h2 id='vonmises'>The von Mises Distribution</h2><span id='topic+vonmises'></span><span id='topic+rvm'></span><span id='topic+dvm'></span><span id='topic+pvm'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation for the circular normal
distribution with mean and kappa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvm(n, mean, kappa)

dvm(theta, mean, kappa)

pvm(theta, mean, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vonmises_+3A_n">n</code></td>
<td>
<p>number of observations in degrees</p>
</td></tr>
<tr><td><code id="vonmises_+3A_mean">mean</code></td>
<td>
<p>mean in degrees</p>
</td></tr>
<tr><td><code id="vonmises_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter</p>
</td></tr>
<tr><td><code id="vonmises_+3A_theta">theta</code></td>
<td>
<p>angular value in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvm(100, mean = 90, k = 100)
dvm(x, mean = 90, k = 100)
</code></pre>

<hr>
<h2 id='watson_test'>Watson's <code class="reqn">U^2</code> Test of Circular Uniformity</h2><span id='topic+watson_test'></span>

<h3>Description</h3>

<p>Watson's test for circular random distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watson_test(
  x,
  alpha = 0,
  dist = c("uniform", "vonmises"),
  axial = TRUE,
  mu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watson_test_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees</p>
</td></tr>
<tr><td><code id="watson_test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the test. Valid levels are <code>0.01</code>, <code>0.05</code>, and <code>0.1</code>.
This argument may be omitted (<code>NULL</code>, the default), in which case, a range for the p-value will be returned.</p>
</td></tr>
<tr><td><code id="watson_test_+3A_dist">dist</code></td>
<td>
<p>Distribution to test for. The default, <code>"uniform"</code>, is the
uniform distribution. <code>"vonmises"</code> tests the von Mises distribution.</p>
</td></tr>
<tr><td><code id="watson_test_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or circular, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="watson_test_+3A_mu">mu</code></td>
<td>
<p>(optional) The specified or known mean direction (in degrees) in alternative hypothesis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Watson's test statistic is a rotation-invariant Cramer - von Mises test statistic.
If <code>statistic &gt; p.value</code>, the null hypothesis is rejected.
If not, randomness (uniform distribution) cannot be excluded.
</p>


<h3>Value</h3>

<p>list containing the test statistic <code>statistic</code> and the significance
level <code>p.value</code>.
</p>


<h3>References</h3>

<p>Mardia and Jupp (2000). Directional Statistics. John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data from Mardia and Jupp (2001), pp. 93
pidgeon_homing &lt;- c(55, 60, 65, 95, 100, 110, 260, 275, 285, 295)
watson_test(pidgeon_homing, alpha = .05)

# San Andreas Fault Data:
data(san_andreas)
data("nuvel1")
PoR &lt;- subset(nuvel1, nuvel1$plate.rot == "na")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
watson_test(sa.por$azi.PoR, alpha = .05)
watson_test(sa.por$azi.PoR, alpha = .05, dist = "vonmises")
</code></pre>

<hr>
<h2 id='weighted_rayleigh'>Weighted Goodness-of-fit Test for Circular Data</h2><span id='topic+weighted_rayleigh'></span>

<h3>Description</h3>

<p>Weighted version of the Rayleigh test (or V0-test) for uniformity against a
distribution with a priori expected von Mises concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_rayleigh(x, prd = NULL, unc, axial = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_rayleigh_+3A_x">x</code></td>
<td>
<p>numeric vector. Values in degrees</p>
</td></tr>
<tr><td><code id="weighted_rayleigh_+3A_prd">prd</code></td>
<td>
<p>The a priori expected direction (in degrees) for the alternative
hypothesis.</p>
</td></tr>
<tr><td><code id="weighted_rayleigh_+3A_unc">unc</code></td>
<td>
<p>numeric. The standard deviations of <code>x</code>. If <code>NULL</code>, the non-weighted
Rayleigh test is performed.</p>
</td></tr>
<tr><td><code id="weighted_rayleigh_+3A_axial">axial</code></td>
<td>
<p>logical. Whether the data are axial, i.e. <code class="reqn">\pi</code>-periodical
(<code>TRUE</code>, the default) or directional, i.e. <code class="reqn">2 \pi</code>-periodical (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Null hypothesis is uniformity (randomness). The alternative is a
distribution with a specified mean direction (<code>prd</code>).
If <code>statistic &gt; p.value</code>, the null hypothesis is rejected.
If not, the alternative cannot be excluded.
</p>


<h3>Value</h3>

<p>a list with the components:
</p>

<dl>
<dt><code>statistic</code></dt><dd><p>Test statistic</p>
</dd>
<dt><code>p.value</code></dt><dd><p>significance level of the test statistic</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rayleigh_test">rayleigh_test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("cpm_models")
data(san_andreas)
PoR &lt;- equivalent_rotation(subset(cpm_models, model == "NNR-MORVEL56"), "na", "pa")
sa.por &lt;- PoR_shmax(san_andreas, PoR, "right")
data("iceland")
PoR.ice &lt;- equivalent_rotation(subset(cpm_models, model == "NNR-MORVEL56"), "eu", "na")
ice.por &lt;- PoR_shmax(iceland, PoR.ice, "out")
data("tibet")
PoR.tib &lt;- equivalent_rotation(subset(cpm_models, model == "NNR-MORVEL56"), "eu", "in")
tibet.por &lt;- PoR_shmax(tibet, PoR.tib, "in")

# GOF test:
weighted_rayleigh(tibet.por$azi.PoR, prd = 90, unc = tibet$unc)
weighted_rayleigh(ice.por$azi.PoR, prd = 0, unc = iceland$unc)
weighted_rayleigh(sa.por$azi.PoR, prd = 135, unc = san_andreas$unc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
