<!DOCTYPE html><html><head><title>Help for package simITS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simITS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_lagged_covariates'><p>Augment dataframe with lagged covariates</p></a></li>
<li><a href='#adjust_data'><p>Adjust an outcome time series based on the group weights.</p></a></li>
<li><a href='#aggregate_data'><p>Aggregate grouped data</p></a></li>
<li><a href='#aggregate_simulation_results'><p>Test a passed test statistic on the simulated data</p></a></li>
<li><a href='#calculate_average_outcome'><p>Summary function for summarize.simulation.results</p></a></li>
<li><a href='#calculate_group_weights'><p>Calculate proportion of subgroups across time</p></a></li>
<li><a href='#extrapolate_model'><p>Extrapolate pre-policy data to post-policy era</p></a></li>
<li><a href='#fit_model_default'><p>Default ITS model</p></a></li>
<li><a href='#generate_fake_data'><p>Make fake data for testing purposes.</p></a></li>
<li><a href='#generate_fake_grouped_data'><p>A fake DGP with time varying categorical covariate for illustrating the code.</p></a></li>
<li><a href='#make_envelope_graph'><p>Make envelope style graph with associated smoothed trendlines</p></a></li>
<li><a href='#make_fit_season_model'><p>Make a fit_model that takes a seasonality component</p></a></li>
<li><a href='#make_many_predictions'><p>Generate a collection of raw counterfactual trajectories</p></a></li>
<li><a href='#make_model_smoother'><p>Make a smoother that fits a model and then smooths residuals</p></a></li>
<li><a href='#meck_subgroup'><p>Mecklenberg data by subgroup of charge type</p></a></li>
<li><a href='#mecklenberg'><p>Mecklenberg PSA Reform Data</p></a></li>
<li><a href='#newjersey'><p>New Jersey PSA Reform aggregate data</p></a></li>
<li><a href='#process_outcome_model'><p>Generate an ITS extrapolation simulation.</p></a></li>
<li><a href='#simITS'><p><code>simITS</code> package overview</p></a></li>
<li><a href='#smooth_residuals'><p>Smooth residuals after model fit</p></a></li>
<li><a href='#smooth_series'><p>Smooth a series using a static loess smoother</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis via Simulation of Interrupted Time Series (ITS) Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses simulation to create prediction intervals for
    post-policy outcomes in interrupted time series (ITS) designs,
    following Miratrix (2020) &lt;<a href="https://arxiv.org/abs/2002.05746">arXiv:2002.05746</a>&gt;. This package provides
    methods for fitting ITS models with lagged outcomes and variables to
    account for temporal dependencies.  It then conducts inference via
    simulation, simulating a set of plausible counterfactual post-policy
    series to compare to the observed post-policy series. This package
    also provides methods to visualize such data, and also to incorporate
    seasonality models and smoothing and aggregation/summarization.  This
    work partially funded by Arnold Ventures in collaboration with
    MDRC.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>dplyr, R (&ge; 2.10), rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arm, ggplot2, knitr, plyr, purrr, rmarkdown, stats, testthat
(&ge; 2.1.0), tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-20 13:24:23 UTC; lmiratrix</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Miratrix [aut, cre],
  Brit Henderson [ctb],
  Chloe Anderson [ctb],
  Arnold Ventures [fnd],
  MDRC [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Miratrix &lt;lmiratrix@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-20 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_lagged_covariates'>Augment dataframe with lagged covariates</h2><span id='topic+add_lagged_covariates'></span>

<h3>Description</h3>

<p>Take outcome and a list of covariates and add new columns with lagged
versions.  Assumes rows of dataframe are in time ascending order.  Lagged
outcome canonically called 'lag.outcome'.  Covariates 'lag.XXX'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lagged_covariates(dat, outcomename, covariates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lagged_covariates_+3A_dat">dat</code></td>
<td>
<p>The dataframe</p>
</td></tr>
<tr><td><code id="add_lagged_covariates_+3A_outcomename">outcomename</code></td>
<td>
<p>The outcome of interest (string)</p>
</td></tr>
<tr><td><code id="add_lagged_covariates_+3A_covariates">covariates</code></td>
<td>
<p>The covariates to lag along with the outcome. This can be
either of two things.  First, it can be a list of string names.  Covariates
can also be a function with a &quot;lags&quot; attribute with the listed covariates
(as returned by, e.g., make_fit_season_model)  (which is a list of string
names). NULL if no covariates other than outcome should be lagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Augmented dataframe with lagged covariates as new columns. Will
clobber old columns if the names (of form &quot;lag.XXXX&quot;) conflict.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "newjersey" )
newjersey = add_lagged_covariates(newjersey, "n.warrant", c("sin.m","cos.m" ) )
head( newjersey[ c( "n.warrant", "sin.m", "lag.outcome", "lag.sin.m" ) ] )
</code></pre>

<hr>
<h2 id='adjust_data'>Adjust an outcome time series based on the group weights.</h2><span id='topic+adjust_data'></span>

<h3>Description</h3>

<p>Reweight the components of a series to match target weights for several
categories. This is a good preprocessing step to adjust for time-varying
covariates such as changing mix of case types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_data(
  dat,
  outcomename,
  groupname,
  Nname,
  pi_star,
  is_count = FALSE,
  include_aggregate = FALSE,
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_data_+3A_dat">dat</code></td>
<td>
<p>Dataframe of data.  Requires an N column of total cases
represented in each row.</p>
</td></tr>
<tr><td><code id="adjust_data_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column that has the outcome to calculated adjusted
values for.</p>
</td></tr>
<tr><td><code id="adjust_data_+3A_groupname">groupname</code></td>
<td>
<p>Name of categorical covariate that determines the groups.</p>
</td></tr>
<tr><td><code id="adjust_data_+3A_nname">Nname</code></td>
<td>
<p>Name of column in dat that contains total cases (this is the
name of the variable used to generate the weights in pi_star).</p>
</td></tr>
<tr><td><code id="adjust_data_+3A_pi_star">pi_star</code></td>
<td>
<p>The target weights.  Each month will have its groups
re-weighted to match these target weights.</p>
</td></tr>
<tr><td><code id="adjust_data_+3A_is_count">is_count</code></td>
<td>
<p>Indicator of whether outcome is count data or a continuous
measure (this impacts how aggregation is done).</p>
</td></tr>
<tr><td><code id="adjust_data_+3A_include_aggregate">include_aggregate</code></td>
<td>
<p>Include aggregated (unadjusted) totals in the output
as well.</p>
</td></tr>
<tr><td><code id="adjust_data_+3A_covariates">covariates</code></td>
<td>
<p>Covariates to be passed to aggregation (list of string
variable names).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of adjusted data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "meck_subgroup" )
head( meck_subgroup )
pis = calculate_group_weights( "category", Nname="n.cases", 
                               meck_subgroup, t_min=0, t_max= max( meck_subgroup$month ) )
pis

agg = aggregate_data( meck_subgroup, 
                      outcomename="pbail", groupname="category", Nname="n.cases", 
                      is_count=FALSE,
                      rich = TRUE, covariates = NULL )
head( agg )  


adjdat = adjust_data( meck_subgroup, "pbail", "category", "n.cases", pis, include_aggregate=TRUE )
head( adjdat )
</code></pre>

<hr>
<h2 id='aggregate_data'>Aggregate grouped data</h2><span id='topic+aggregate_data'></span>

<h3>Description</h3>

<p>This will take a dataframe with each row being the outcomes, etc., for a
given group for a given month and aggregate those groups for each month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_data(
  dat,
  outcomename,
  groupname,
  Nname,
  is_count = FALSE,
  rich = TRUE,
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_data_+3A_dat">dat</code></td>
<td>
<p>Dataframe with one row for each time point and group that we are
going to post stratify on.  This dataframe should also have an column with
passed name &quot;Nname&quot; indicating the number of cases that make up each given
row. It should have a 'month' column for the time.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_outcomename">outcomename</code></td>
<td>
<p>String name of the outcome variable in dat.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_groupname">groupname</code></td>
<td>
<p>Name of the column that has the grouping categorical
variable</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_nname">Nname</code></td>
<td>
<p>Name of variable holding the counts (weight) in each group.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_is_count">is_count</code></td>
<td>
<p>If TRUE the data are counts, and should be aggregated by sum
rather than by mean.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_rich">rich</code></td>
<td>
<p>If TRUE, add a bunch of extra columns with proportions of the
month that are each group and so forth.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_covariates">covariates</code></td>
<td>
<p>group-invariant covariates to preserve in the augmented
rich dataframe.  These are not used in this method for any calculations.
Pass as list of column names of dat</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of aggregated data, one row per month.  If rich=TRUE many
extra columns with further information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "meck_subgroup" )
head( meck_subgroup )
pis = calculate_group_weights( "category", Nname="n.cases", 
                               meck_subgroup, t_min=0, t_max= max( meck_subgroup$month ) )
pis

agg = aggregate_data( meck_subgroup, 
                      outcomename="pbail", groupname="category", Nname="n.cases", 
                      is_count=FALSE,
                      rich = TRUE, covariates = NULL )
head( agg )  


adjdat = adjust_data( meck_subgroup, "pbail", "category", "n.cases", pis, include_aggregate=TRUE )
head( adjdat )
</code></pre>

<hr>
<h2 id='aggregate_simulation_results'>Test a passed test statistic on the simulated data</h2><span id='topic+aggregate_simulation_results'></span>

<h3>Description</h3>

<p>This method is used to look at summary statistics such as
average impact post-policy, and see how the predictive distribution
compares to the observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_simulation_results(
  orig.data,
  predictions,
  outcomename,
  summarizer = calculate_average_outcome,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_simulation_results_+3A_orig.data">orig.data</code></td>
<td>
<p>The raw data (dataframe)</p>
</td></tr>
<tr><td><code id="aggregate_simulation_results_+3A_predictions">predictions</code></td>
<td>
<p>The results from process_outcome_model.</p>
</td></tr>
<tr><td><code id="aggregate_simulation_results_+3A_outcomename">outcomename</code></td>
<td>
<p>Outcome to use.</p>
</td></tr>
<tr><td><code id="aggregate_simulation_results_+3A_summarizer">summarizer</code></td>
<td>
<p>A function to calculate some summary quantity, Default:
calculate_average_outcome</p>
</td></tr>
<tr><td><code id="aggregate_simulation_results_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the summarizer function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length two, with first item being the observed value of the
test statistic and the second being a numeric vector representing the
emperical reference distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predictions = process_outcome_model( "pbail", mecklenberg,
                                    t0=0, R = 5,
                                    summarize = FALSE, smooth=FALSE )
sstat = aggregate_simulation_results( orig.data = mecklenberg, outcomename = "pbail",
                                     predictions = predictions, months = 1:18 )
sstat$t
sstat$t.obs

</code></pre>

<hr>
<h2 id='calculate_average_outcome'>Summary function for summarize.simulation.results</h2><span id='topic+calculate_average_outcome'></span>

<h3>Description</h3>

<p>Given a set of simulation runs, estimate average impact over range of months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_average_outcome(res, outcomename, months = 1:54, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_average_outcome_+3A_res">res</code></td>
<td>
<p>Dataframe of a single series (simulated or otherwise)</p>
</td></tr>
<tr><td><code id="calculate_average_outcome_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of outcome in res</p>
</td></tr>
<tr><td><code id="calculate_average_outcome_+3A_months">months</code></td>
<td>
<p>Which months to average over, Default: 1:18</p>
</td></tr>
<tr><td><code id="calculate_average_outcome_+3A_...">...</code></td>
<td>
<p>Other parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single number (in this case mean of given months)
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+aggregate_simulation_results">aggregate_simulation_results</a></code> for how this function would be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( mecklenberg )
calculate_average_outcome( mecklenberg, "pbail", months=1:24 )
calculate_average_outcome( mecklenberg, "pbail", months = 1:18 )
</code></pre>

<hr>
<h2 id='calculate_group_weights'>Calculate proportion of subgroups across time</h2><span id='topic+calculate_group_weights'></span>

<h3>Description</h3>

<p>Calculate overall proportion of cases in each group that lie within a given
interval of time defined by t_min and t_max.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_group_weights(
  groupname,
  dat,
  t_min,
  t_max = max(dat$month),
  Nname = "N"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_group_weights_+3A_groupname">groupname</code></td>
<td>
<p>Name of the column that has the grouping categorical
variable</p>
</td></tr>
<tr><td><code id="calculate_group_weights_+3A_dat">dat</code></td>
<td>
<p>Dataframe with one row for each time point and group that we are
going to post stratify on.  This dataframe should also have an column with
passed name &quot;Nname&quot; indicating the number of cases that make up each given
row. It should have a 'month' column for the time.</p>
</td></tr>
<tr><td><code id="calculate_group_weights_+3A_t_min">t_min</code></td>
<td>
<p>The start month to aggregate cases over.</p>
</td></tr>
<tr><td><code id="calculate_group_weights_+3A_t_max">t_max</code></td>
<td>
<p>The final month (default is last month).</p>
</td></tr>
<tr><td><code id="calculate_group_weights_+3A_nname">Nname</code></td>
<td>
<p>Name of variable holding the counts (weight) in each group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of each group along with overall average group weight in
the specified timespan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "meck_subgroup" )
head( meck_subgroup )
pis = calculate_group_weights( "category", Nname="n.cases", 
                               meck_subgroup, t_min=0, t_max= max( meck_subgroup$month ) )
pis

agg = aggregate_data( meck_subgroup, 
                      outcomename="pbail", groupname="category", Nname="n.cases", 
                      is_count=FALSE,
                      rich = TRUE, covariates = NULL )
head( agg )  


adjdat = adjust_data( meck_subgroup, "pbail", "category", "n.cases", pis, include_aggregate=TRUE )
head( adjdat )
</code></pre>

<hr>
<h2 id='extrapolate_model'>Extrapolate pre-policy data to post-policy era</h2><span id='topic+extrapolate_model'></span>

<h3>Description</h3>

<p>This function takes a fitted model and uses it to make the post-policy
predictions by simulating data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrapolate_model(
  M0,
  outcomename,
  dat,
  t0,
  R = 400,
  summarize = FALSE,
  smooth = FALSE,
  smoother = smooth_series,
  full_output = FALSE,
  fix_parameters = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrapolate_model_+3A_m0">M0</code></td>
<td>
<p>The fit model</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_outcomename">outcomename</code></td>
<td>
<p>Outcome of interest (name of column)</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_dat">dat</code></td>
<td>
<p>Dataframe with data being analyzed.</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_t0">t0</code></td>
<td>
<p>Last pre-policy timepoint</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_r">R</code></td>
<td>
<p>Number of replications</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_summarize">summarize</code></td>
<td>
<p>Boolean, TRUE means collapse all simulated trajectories into
single aggregate. FALSE means return all paths.</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_smooth">smooth</code></td>
<td>
<p>Boolean.  TRUE means fit a smoother to the trajectories and
look at distribution of smoothed trajectories.  FALSE means look at raw
data treajectories.</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_smoother">smoother</code></td>
<td>
<p>Function to do smoothing, if smoothing set to TRUE.  Default
is smooth_series()</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_full_output">full_output</code></td>
<td>
<p>TRUE means smoother returns residuals as well as smoothed
series.</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_fix_parameters">fix_parameters</code></td>
<td>
<p>Keep the parameters in the model M0 as fixed; do not
add parameter uncertainty.</p>
</td></tr>
<tr><td><code id="extrapolate_model_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to smoother (e.g, bandwidth).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns corresponding to the simulations.  If
summarize=TRUE, one row per month in original data.  If FALSE, all the
details of all the runs are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+process_outcome_model">process_outcome_model</a></code> for wrapper function for this
method that is easier to use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mecklenberg" )
mecklenberg = add_lagged_covariates( mecklenberg, "pbail"  )
mecklenberg.pre = dplyr::filter( mecklenberg, month &lt;= 0 )
M0 = fit_model_default( mecklenberg.pre, "pbail" )
res = extrapolate_model( M0, "pbail", mecklenberg, 0, 1,
                         smooth=TRUE)
tail( res )
</code></pre>

<hr>
<h2 id='fit_model_default'>Default ITS model</h2><span id='topic+fit_model_default'></span>

<h3>Description</h3>

<p>This fits the model 'outcomename ~ lag.outcome + month', with no
covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model_default(dat, outcomename, lagless = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_model_default_+3A_dat">dat</code></td>
<td>
<p>Dataframe of pre-policy data to fit model to.  Needs a &quot;month&quot; column</p>
</td></tr>
<tr><td><code id="fit_model_default_+3A_outcomename">outcomename</code></td>
<td>
<p>Outcome of interest</p>
</td></tr>
<tr><td><code id="fit_model_default_+3A_lagless">lagless</code></td>
<td>
<p>Boolean, include the lagged outcome, or not?</p>
</td></tr>
<tr><td><code id="fit_model_default_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the lm() call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fit model (a 'lm' object from a 'lm()' call) from fitting a simple
regression of outcome onto month and lagged month.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mecklenberg = add_lagged_covariates(mecklenberg, "pbail")
meck.pre = filter( mecklenberg, month &lt;= 0 )
mod = fit_model_default( meck.pre, "pbail", lagless = TRUE )
summary( mod )
mod = fit_model_default( meck.pre, "pbail", lagless = FALSE )
summary( mod )
</code></pre>

<hr>
<h2 id='generate_fake_data'>Make fake data for testing purposes.</h2><span id='topic+generate_fake_data'></span>

<h3>Description</h3>

<p>Defaults have heavy seasonality, and an extra bump in impact kicks in at 12
months post-policy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_fake_data(
  t_min = -40,
  t_max = 9,
  t0 = 0,
  rho = 0.5,
  sd.omega = 1,
  coef_line = c(20, 0.05),
  coef_q = c(1, 0, -1, 0),
  coef_temp = 0.1,
  coef_sin = c(0, 0),
  coef_tx = c(0, 0.25, 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_fake_data_+3A_t_min">t_min</code></td>
<td>
<p>Index of first month</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_t_max">t_max</code></td>
<td>
<p>Index of last month</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_t0">t0</code></td>
<td>
<p>Last pre-policy time point</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_rho">rho</code></td>
<td>
<p>Autocorrelation</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_sd.omega">sd.omega</code></td>
<td>
<p>Standard deviation of the true residual</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_coef_line">coef_line</code></td>
<td>
<p>Intercept and slope of the main trendline (list of 2).</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_coef_q">coef_q</code></td>
<td>
<p>Coefficients for the four quarters (list of 4).</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_coef_temp">coef_temp</code></td>
<td>
<p>Coefficient for temperature.</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_coef_sin">coef_sin</code></td>
<td>
<p>Coefficents for sin and cos features (list of 2)</p>
</td></tr>
<tr><td><code id="generate_fake_data_+3A_coef_tx">coef_tx</code></td>
<td>
<p>Coefficient for treatment post-policy (list of 3, initial
offset, initial slope, additional slope past 12 months).  Treatment is a
piecewise linear function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> having <code>month</code> , <code>temperature</code> ,
<code>sin.m</code> , <code>cos.m</code> , <code>Q1</code>, <code>Q2</code> , <code>Q3</code>, <code>Q4</code>,
<code>post</code> , <code>Ystr0</code> , <code>Ystr</code> , <code>Y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdat = generate_fake_data(-100,100, rho = 0.95, coef_q=c(0,0,0,0), coef_temp = 0)
plot( fdat$month, fdat$Y, type="l" )
fdat2 = generate_fake_data(-100, 100, rho = 0.0, coef_q=c(0,0,0,0), coef_temp = 0)
plot( fdat$month, fdat2$Y, type="l" )
</code></pre>

<hr>
<h2 id='generate_fake_grouped_data'>A fake DGP with time varying categorical covariate for illustrating the code.</h2><span id='topic+generate_fake_grouped_data'></span>

<h3>Description</h3>

<p>This code makes synthetic grouped data that can be used to illustrate
benefits of post stratification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_fake_grouped_data(
  t_min,
  t0,
  t_max,
  method = c("complex", "linear", "jersey")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_fake_grouped_data_+3A_t_min">t_min</code></td>
<td>
<p>Index of first month</p>
</td></tr>
<tr><td><code id="generate_fake_grouped_data_+3A_t0">t0</code></td>
<td>
<p>last pre-policy timepoint</p>
</td></tr>
<tr><td><code id="generate_fake_grouped_data_+3A_t_max">t_max</code></td>
<td>
<p>Index of last month</p>
</td></tr>
<tr><td><code id="generate_fake_grouped_data_+3A_method">method</code></td>
<td>
<p>Type of post-stratification structure to generate (three designs of 'complex', 'linear' and 'jersey' were originally concieved of when designing simulation studies with different types of structure).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of fake data, with one row per group per time period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdat = generate_fake_grouped_data(t_min=-5,t_max=10, t0 = 0)
table( fdat$month )
table( fdat$type )
</code></pre>

<hr>
<h2 id='make_envelope_graph'>Make envelope style graph with associated smoothed trendlines</h2><span id='topic+make_envelope_graph'></span>

<h3>Description</h3>

<p>This method builds a ggplot object with the trendline and prediction
envelope. It can be customized after the fact by adding more ggplot layers
via normal ggplot &quot;+&quot; syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_envelope_graph(envelope, t0, ylab = "Y", xlab = "month")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_envelope_graph_+3A_envelope">envelope</code></td>
<td>
<p>The result of a 'process_outcome_model()' call, i.e.
dataframe with columns of original data, imputed data and, potentially,
smoothed data.</p>
</td></tr>
<tr><td><code id="make_envelope_graph_+3A_t0">t0</code></td>
<td>
<p>Last pre-policy timepoint. Will draw vertical line here.</p>
</td></tr>
<tr><td><code id="make_envelope_graph_+3A_ylab">ylab</code></td>
<td>
<p>Y label of plot</p>
</td></tr>
<tr><td><code id="make_envelope_graph_+3A_xlab">xlab</code></td>
<td>
<p>X label of plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (does not yet display) a ggplot plot object containing the
time series along with extrapolation and prediction envelope. This plot can
be augmented and changed via standard ggplot commands.
</p>


<h3>See Also</h3>

<p>The <code>ggplot2</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "mecklenberg" )
t0 = 0
envelope = process_outcome_model( "pbail", mecklenberg, 
                                  t0=t0, R = 10, 
                                  summarize = TRUE, smooth=FALSE )
make_envelope_graph(envelope, t0=t0, ylab = "Proportion given bail") +
  ggplot2::labs( title="Sample ITS plot")
data( "mecklenberg" )
t0 = 0
envelope = process_outcome_model( "pbail", mecklenberg, 
                                  t0=t0, R = 10, 
                                  summarize = TRUE, smooth=FALSE )
make_envelope_graph(envelope, t0=t0, ylab = "Proportion given bail") +
  ggplot2::labs( title="Sample ITS plot")
</code></pre>

<hr>
<h2 id='make_fit_season_model'>Make a fit_model that takes a seasonality component</h2><span id='topic+make_fit_season_model'></span>

<h3>Description</h3>

<p>This method returns a function that will fit a model both with and without
lagged outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fit_season_model(formula, no_lag = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_fit_season_model_+3A_formula">formula</code></td>
<td>
<p>Formula specifying seasonality.  No outcome or month needed.</p>
</td></tr>
<tr><td><code id="make_fit_season_model_+3A_no_lag">no_lag</code></td>
<td>
<p>Formula specifying additional variables to not lag (usually used due
to colinearity of lagged outcomes, such as with a sin and cos component).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You hand it a formula object specifying the seasonality, e.g., &quot; ~ Q2 + Q3 +
Q4&quot;, if you have quarterly season effects. This method assumes you want
models with a linear month component as well, and will add that and an
intercept in automatically.
</p>


<h3>Value</h3>

<p>A callable function that takes the arguments of dat, outcomename, and a lagless flag (see,
e.g., the parameters listed in 'fit_model_default()').
</p>


<h3>See Also</h3>

<p>fit_model_default for the type of function this method will generate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "newjersey")
modF = make_fit_season_model( ~ temperature )
newjersey = add_lagged_covariates( newjersey, "n.warrant", covariates = c("temperature") )
modF( newjersey, "n.warrant" )
</code></pre>

<hr>
<h2 id='make_many_predictions'>Generate a collection of raw counterfactual trajectories</h2><span id='topic+make_many_predictions'></span><span id='topic+make_many_predictions_plug'></span>

<h3>Description</h3>

<p>Given a fit linear model 'fit0', generate R prediction series starting at t0.
This takes model uncertainty into account by pulling from the
pseudo-posterior of the model parameters (from Gelman and Hill arm package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_many_predictions(fit0, dat, R, outcomename, t0)

make_many_predictions_plug(fit0, dat, R, outcomename, t0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_many_predictions_+3A_fit0">fit0</code></td>
<td>
<p>The fit linear model to simulate from.</p>
</td></tr>
<tr><td><code id="make_many_predictions_+3A_dat">dat</code></td>
<td>
<p>A dataframe with the covariates needed by the model fit0 for both
pre and post-policy months.</p>
</td></tr>
<tr><td><code id="make_many_predictions_+3A_r">R</code></td>
<td>
<p>Number of series to generate.</p>
</td></tr>
<tr><td><code id="make_many_predictions_+3A_outcomename">outcomename</code></td>
<td>
<p>The name of the column in dat which is our outcome.</p>
</td></tr>
<tr><td><code id="make_many_predictions_+3A_t0">t0</code></td>
<td>
<p>Last month of pre-policy.  Will start predicting at t0+1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the collection of predicted series, one row per
month per replicate (so will have R*nrow(dat) rows).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>make_many_predictions_plug</code>: This version makes multiple predictions
using estimated parameters without additional uncertainty. This takes point
estimates from the fit model as fixed parameters. WARNING: This method will
not capture true uncertainty as it is not taking parameter uncertainty into
account.
</p>
</li></ul>


<h3>References</h3>

<p>The 'arm' package, see
<a href="https://cran.r-project.org/package=arm">https://cran.r-project.org/package=arm</a>
</p>
<p>Also see Gelman, A., &amp; Hill, J. (2007). Data analysis using regression and
multilevelhierarchical models (Vol. 1). New York, NY, USA: Cambridge
University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mecklenberg" )
mecklenberg = add_lagged_covariates( mecklenberg, "pbail"  )
mecklenberg.pre = dplyr::filter( mecklenberg, month &lt;= 0 )
M0 = fit_model_default( mecklenberg.pre, "pbail" )
res = make_many_predictions( M0, dat=mecklenberg, outcome="pbail", t0=0, R=2 )
tail( res )
</code></pre>

<hr>
<h2 id='make_model_smoother'>Make a smoother that fits a model and then smooths residuals</h2><span id='topic+make_model_smoother'></span>

<h3>Description</h3>

<p>This helper function gives back a function that takes the resulting
simulation data from a single iteration of the simulation, and fits
'fit_model' to it, smoothes the residuals, and puts the predictions from
'fit_model' back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_model_smoother(fit_model, covariates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_model_smoother_+3A_fit_model">fit_model</code></td>
<td>
<p>A function that takes data, fits a linear model, and returns
the fit model. This function needs an option to include (or not) lagged
covariates.</p>
</td></tr>
<tr><td><code id="make_model_smoother_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe with all covariates needed in the model fitting
defined by fit_model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be used to build smoothers that smooth using models other than the
model being used for extrapolation (e.g., a model without temperature).
</p>
<p>Resulting functions have the following parameters: 'res' (the data), 't0'
(start time), 'outcomename', 'post.only' flag (for smoothing only post data
or not), and 'smooth_k', a tuning parameter for degree of smoothing.
</p>


<h3>Value</h3>

<p>A smoother function that can be passed to the smoothing routines.
This function is of the form listed above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "newjersey")
modA = make_fit_season_model( ~ temperature )
modB = make_fit_season_model( ~ sin.m + cos.m )
newjersey = add_lagged_covariates( newjersey, "n.warrant", 
                                   covariates = c("sin.m", "cos.m", "temperature") )
smoother = make_model_smoother( fit_model = modA, covariates = newjersey )
class(smoother)

# Pass made function to process_outcome_model()
envelope = process_outcome_model( "n.warrant", newjersey, t0=-8, R = 1,
                                  summarize = TRUE, smooth=TRUE, 
                                  smoother = smoother, smooth_k = 11,
                                  fit.model = modB )

</code></pre>

<hr>
<h2 id='meck_subgroup'>Mecklenberg data by subgroup of charge type</h2><span id='topic+meck_subgroup'></span>

<h3>Description</h3>

<p>Mecklenberg data that gives proportion of different charge categories of cases given bail (by month).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meck_subgroup
</code></pre>


<h3>Format</h3>

<p>A data frame with 144 rows and 5 variables:
</p>

<dl>
<dt><code>month</code></dt><dd><p>integer Month, with 0 being month of policy implementation.</p>
</dd>
<dt><code>n.cases</code></dt><dd><p>integer Number of cases of that subgroup for that month</p>
</dd>
<dt><code>n.bail</code></dt><dd><p>interger Total number of cases given bail for that subgroup for that month</p>
</dd>
<dt><code>pbail</code></dt><dd><p>double Proportion of new cases in given subgroup in that month assigned bail</p>
</dd> 
<dt><code>category</code></dt><dd><p>character Category of group (charge type).</p>
</dd>
</dl>


<hr>
<h2 id='mecklenberg'>Mecklenberg PSA Reform Data</h2><span id='topic+mecklenberg'></span>

<h3>Description</h3>

<p>Monthly aggregate outcomes of various measures of interest from Mecklenberg. See MDRC Report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mecklenberg
</code></pre>


<h3>Format</h3>

<p>A data frame with 54 rows and 10 variables:
</p>

<dl>
<dt><code>month</code></dt><dd><p>integer Month, with 0 being month of policy implementation.</p>
</dd>
<dt><code>karr</code></dt><dd><p>integer Total count of arrests.</p>
</dd>
<dt><code>pbail</code></dt><dd><p>double Proportion of cases in a given month assigned bail (or outright detention).</p>
</dd>
<dt><code>pptrel</code></dt><dd><p>double Proportion of cases assigned to pretrial supervised release.</p>
</dd>
<dt><code>pror</code></dt><dd><p>double Proportion of cases released on own recognizance.</p>
</dd>
<dt><code>pb4c</code></dt><dd><p>double Proportion of cases assigned to money bail (alternate coding from pbail, above).</p>
</dd>
<dt><code>avg_days_initial</code></dt><dd><p>double Average number of days spent detained before release due to bail, case resolution, etc.</p>
</dd>
<dt><code>avg_t2d</code></dt><dd><p>double Average time to case resolution (in days).</p>
</dd>
<dt><code>pstint7</code></dt><dd><p>double Proportion detained longer than 7 days.</p>
</dd>
<dt><code>pstint30</code></dt><dd><p>double Proportion detained longer than 30 days.</p>
</dd>
</dl>


<hr>
<h2 id='newjersey'>New Jersey PSA Reform aggregate data</h2><span id='topic+newjersey'></span>

<h3>Description</h3>

<p>Montly aggregate counts of arrests of different types in New Jersey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newjersey
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 rows and 11 variables:
</p>

<dl>
<dt><code>month</code></dt><dd><p>integer Index of month.</p>
</dd>
<dt><code>sin.m</code></dt><dd><p>double cos of month number</p>
</dd>
<dt><code>cos.m</code></dt><dd><p>double sin of month number</p>
</dd>
<dt><code>M12</code></dt><dd><p>integer Month number</p>
</dd>
<dt><code>Q1</code></dt><dd><p>integer Indicator of 1st quarter.</p>
</dd>
<dt><code>Q2</code></dt><dd><p>integer Indicator of 2nd quarter.</p>
</dd>
<dt><code>Q3</code></dt><dd><p>integer Indicator of 3rd quarter.</p>
</dd>
<dt><code>Q4</code></dt><dd><p>integer Indicator of 4th quarter.</p>
</dd>
<dt><code>n.warrant</code></dt><dd><p>double Number of warrant arrests</p>
</dd>
<dt><code>n.summons</code></dt><dd><p>double Number of summons arrests</p>
</dd>
<dt><code>n</code></dt><dd><p>double Total number of arrests</p>
</dd>
<dt><code>temperature</code></dt><dd><p>double Average temperature in New Jersey that month.</p>
</dd>
</dl>


<hr>
<h2 id='process_outcome_model'>Generate an ITS extrapolation simulation.</h2><span id='topic+process_outcome_model'></span>

<h3>Description</h3>

<p>This is the primary function to use to use this approach on a given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_outcome_model(
  outcomename,
  dat,
  t0,
  R = 400,
  summarize = FALSE,
  smooth = FALSE,
  smoother = NULL,
  fit_model = fit_model_default,
  covariates = NULL,
  plug_in = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_outcome_model_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column in dat containing the time series.</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_dat">dat</code></td>
<td>
<p>Dataframe with a 'month' column for time.  'month' is assumed to
be a sequence of integer values.</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_t0">t0</code></td>
<td>
<p>Last pre-policy timepoint</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_r">R</code></td>
<td>
<p>Number of simulated pre-policy extrapolations to generate.</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_summarize">summarize</code></td>
<td>
<p>Summarise the series? (TRUE/FALSE)</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_smooth">smooth</code></td>
<td>
<p>Smooth the series? (TRUE/FALSE)</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_smoother">smoother</code></td>
<td>
<p>Function to smooth residuals, if smoothing set to TRUE.  If
NULL, will dynamically make a model smoother based on the fit_model method
if covariates are passed.  Otherwise it will use the simple smoother on the
outcomes.</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_fit_model">fit_model</code></td>
<td>
<p>The function used to fit the model to simulate from. (This
model could be a seasonality model. Default is simple linear model with no
covariates.)</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_covariates">covariates</code></td>
<td>
<p>Vector of covariate names of all covariates used in the
passed model function fit_model.  If null, will attempt to get list of
covariates form the &quot;lags&quot; attribute of the passed 'fit_model'.</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_plug_in">plug_in</code></td>
<td>
<p>Use the estimated parameters as fixed and do not include extra
uncertainty of parameter estimation in the simulation. (Not recommended as
it destroys inference.)</p>
</td></tr>
<tr><td><code id="process_outcome_model_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to 'extrapolate_model()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Take a given outcome variable, fit an ITS model, use it to extrapolate R
plusible trajectories, and then using these trajectories, generate final
impact results by averaging (if summarize is set to TRUE).
</p>
<p>This function is basically a wrapper for 'extrapolate_model()' with some
extra calls to 'make_model_smoother()' to prepare, in the case of smoothing,
and adding on a summary trend via 'generate_Ybars()' in the case of
summarizing.
</p>


<h3>Value</h3>

<p>If summarize=TRUE, A dataframe with several columns of interest and
one row per month of data. The columns are Ymin and Ymax, the limits of the
envelope, 'range', the range of the envelope, 'SE', the standard deviation
of the trajectories at that time point, 'Ysmooth' the median smoothed value
at that time point (if smoothing), 'Ystar' the median unsmoothed value at
that time point (regardless of smooth flag), 'Y', the observed outcome,
'Ysmooth1', the smoothed observed outcomes, and 'Ybar' the predicted
outcome given the model with no autoregressive aspect.
</p>
<p>If summarize=FALSE, a dataframe of all the raw series generated.
</p>


<h3>See Also</h3>

<p>The core internal function that this method is a wrapper for is <code><a href="#topic+extrapolate_model">extrapolate_model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "mecklenberg" )
t0 = 0
envelope = process_outcome_model( "pbail", mecklenberg, 
                                  t0=t0, R = 10, 
                                  summarize = TRUE, smooth=FALSE )
make_envelope_graph(envelope, t0=t0, ylab = "Proportion given bail") +
  ggplot2::labs( title="Sample ITS plot")
</code></pre>

<hr>
<h2 id='simITS'><code>simITS</code> package overview</h2><span id='topic+simITS'></span>

<h3>Description</h3>

<p>Analysis via Simulation of Interrupted Time Series
</p>


<h3>Details</h3>

<p>This package is based on the backbone analytic code for the analyses in,
e.g., Redcross et al. (2019) or Golub et al. (2019).  See companion paper
Miratrix (2020) for technical discussion of the overall approach.
</p>
<p>Broadly, this package provides methods for fitting Interrupted Time Series
models with lagged outcomes and variables to account for temporal
dependencies.  It then conducts inference via simulation, simulating a set of
plausible counterfactual post-policy series to compare to the observed
post-policy series. This package provides methods to visualize such data, and
also to incorporate seasonality models and smoothing and
aggregation/summarization. See the vignette for a guide of how to conduct
such analyses.
</p>


<h3>References</h3>

<p>Redcross, C., Henderson, B., Valentine, E. &amp; Miratrix, L. (2019).
Evaluation of pretrial justice system reforms that use the public safety
assessment: Effects in Mecklenburg County, North Carolina. Technical
report, MDRC <a href="https://www.mdrc.org/publication/evaluation-pretrial-justice-system-reforms-use-public-safety-assessment">(link)</a>
</p>
<p>Golub, C. A., Redcross, C., Valentine, E., &amp; Miratrix, L. (2019).
Evaluation of pretrial justice system reforms that use the public safety
assessment: Effects of New Jerseyâ€™s criminal justice reform. Technical
report, MDRC. <a href="https://www.mdrc.org/publication/evaluation-pretrial-justice-system-reforms-use-public-safety-assessment-0">(link)</a>
</p>
<p>Miratrix, L. (2020). Using Simulation to Analyze Interrupted Time Series
Designs <a href="https://arxiv.org/abs/2002.05746">(link)</a>
</p>

<hr>
<h2 id='smooth_residuals'>Smooth residuals after model fit</h2><span id='topic+smooth_residuals'></span>

<h3>Description</h3>

<p>Smooth a series by fitting the model to the data, smoothing the residuals,
and then putting the model predictions back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_residuals(
  res,
  t0,
  outcomename,
  post.only = TRUE,
  smooth_k = SMOOTH_K,
  fit_model = fit_model_default,
  covariates = res,
  full_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_residuals_+3A_res">res</code></td>
<td>
<p>A dataframe with a month column and an 'outcomename' column (which
is the column that will be smoothed).</p>
</td></tr>
<tr><td><code id="smooth_residuals_+3A_t0">t0</code></td>
<td>
<p>last pre-policy timepoint</p>
</td></tr>
<tr><td><code id="smooth_residuals_+3A_outcomename">outcomename</code></td>
<td>
<p>String name of the outcome variable in dat.</p>
</td></tr>
<tr><td><code id="smooth_residuals_+3A_post.only">post.only</code></td>
<td>
<p>If TRUE fit model and smooth post-policy only. WHY fit model
on post-policy data only?  Because this will make sure the fixed pre-policy
does not dominate too much?  We are focusing on post-policy so we want a
good fitting model for that so we can get our residuals as &quot;white noise&quot; as
possible before smoothing.</p>
</td></tr>
<tr><td><code id="smooth_residuals_+3A_smooth_k">smooth_k</code></td>
<td>
<p>A rough proxy for the number of observations to primarily
consider to kernal weight in the neighborhood of each timepoint (this is a
bandwidth, and the loess smoother gets smooth_k / n as a span value).  We
want to smooth with an absolute bandwidth, not one as function of how long
the time series is.</p>
</td></tr>
<tr><td><code id="smooth_residuals_+3A_fit_model">fit_model</code></td>
<td>
<p>A function that takes data, fits a linear model, and returns
the fit model. This function needs an option to include (or not) lagged
covariates.</p>
</td></tr>
<tr><td><code id="smooth_residuals_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe with all covariates needed in the model fitting
defined by fit_model.</p>
</td></tr>
<tr><td><code id="smooth_residuals_+3A_full_output">full_output</code></td>
<td>
<p>If TRUE give back pieces for diagnostics of smoothing
process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use loess smoother on complete series of residuals including original data
pre-policy and synthetic data post policy (i.e., smooth the entire plausible
series).
</p>


<h3>Value</h3>

<p>A numeric vector of the smoothed residuals.  If full_output=TRUE
return a dataframe with several other columns: 'resid', the residuals based
on Ystar and the model, &lsquo;residStar' the smoothed residuals, &rsquo;Ybar.sm' the
structural predictions of the model used for smoothing.  Here the smoothed
values will be 'Ysmooth'.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+smooth_series">smooth_series</a></code> for a more vanilla version that
smooths without the model fitting step.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( "newjersey" )
smooth = smooth_series( newjersey, outcomename = "n.warrant", t0= -8,
                        smooth_k = 30,
                        post.only = FALSE)
plot( newjersey$month, newjersey$n.warrant )
lines( newjersey$month, smooth, col="red" )  

mod =  make_fit_season_model( ~ temperature )
newjersey = add_lagged_covariates( newjersey, outcomename = "n.warrant", 
                                   covariates = c("temperature") )

smooth = smooth_residuals( newjersey, outcomename = "n.warrant", t0=-8,
                           smooth_k = 30,
                           post.only = FALSE,
                           fit_model = mod )
plot( newjersey$month, newjersey$n.warrant )
lines( newjersey$month, smooth, col="red" )  
</code></pre>

<hr>
<h2 id='smooth_series'>Smooth a series using a static loess smoother</h2><span id='topic+smooth_series'></span>

<h3>Description</h3>

<p>Use loess smoother on complete series of residuals including original data
pre-policy and synthetic data post policy (i.e., smooth the entire plausible
series).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_series(res, outcomename, t0, smooth_k = SMOOTH_K, post.only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_series_+3A_res">res</code></td>
<td>
<p>A dataframe with a month column and an 'outcomename' column (which
is the column that will be smoothed).</p>
</td></tr>
<tr><td><code id="smooth_series_+3A_outcomename">outcomename</code></td>
<td>
<p>String name of the outcome variable in dat.</p>
</td></tr>
<tr><td><code id="smooth_series_+3A_t0">t0</code></td>
<td>
<p>last pre-policy timepoint</p>
</td></tr>
<tr><td><code id="smooth_series_+3A_smooth_k">smooth_k</code></td>
<td>
<p>A rough proxy for the number of observations to primarily
consider to kernal weight in the neighborhood of each timepoint (this is a
bandwidth, and the loess smoother gets smooth_k / n as a span value).  We
want to smooth with an absolute bandwidth, not one as function of how long
the time series is.</p>
</td></tr>
<tr><td><code id="smooth_series_+3A_post.only">post.only</code></td>
<td>
<p>If TRUE fit model and smooth post-policy only. WHY fit model
on post-policy data only?  Because this will make sure the fixed pre-policy
does not dominate too much?  We are focusing on post-policy so we want a
good fitting model for that so we can get our residuals as &quot;white noise&quot; as
possible before smoothing.</p>
</td></tr>
<tr><td><code id="smooth_series_+3A_...">...</code></td>
<td>
<p>Extra arguments (not used in this function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method takes several parameters it does not use, to maintain
compatability with smooth_residuals.
</p>


<h3>Value</h3>

<p>An updated version of the 'res' dataframe with 'Ysmooth', the
smoothed predictions of the original Ystar outcome.  Also includes 'Ystar'
the original sequence to be smoothed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( "newjersey" )
smooth = smooth_series( newjersey, outcomename = "n.warrant", t0= -8,
                        smooth_k = 30,
                        post.only = FALSE)
plot( newjersey$month, newjersey$n.warrant )
lines( newjersey$month, smooth, col="red" )  

mod =  make_fit_season_model( ~ temperature )
newjersey = add_lagged_covariates( newjersey, outcomename = "n.warrant", 
                                   covariates = c("temperature") )

smooth = smooth_residuals( newjersey, outcomename = "n.warrant", t0=-8,
                           smooth_k = 30,
                           post.only = FALSE,
                           fit_model = mod )
plot( newjersey$month, newjersey$n.warrant )
lines( newjersey$month, smooth, col="red" )  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
