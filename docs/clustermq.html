<!DOCTYPE html><html><head><title>Help for package clustermq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustermq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustermq-package'><p>Evaluate Function Calls on HPC Schedulers (LSF, SGE, SLURM)</p></a></li>
<li><a href='#.onAttach'><p>Report queueing system on package attach if not set</p></a></li>
<li><a href='#.onLoad'><p>Select the queueing system on package loading</p></a></li>
<li><a href='#check_args'><p>Function to check arguments with which Q() is called</p></a></li>
<li><a href='#chunk'><p>Subset index chunk for processing</p></a></li>
<li><a href='#cmq_foreach'><p>clustermq foreach handler</p></a></li>
<li><a href='#fill_template'><p>Fill a template string with supplied values</p></a></li>
<li><a href='#host'><p>Construct the ZeroMQ host address</p></a></li>
<li><a href='#LOCAL'><p>Placeholder for local processing</p></a></li>
<li><a href='#LSF'><p>LSF scheduler functions</p></a></li>
<li><a href='#master'><p>Master controlling the workers</p></a></li>
<li><a href='#msg_fmt'><p>Message format for logging</p></a></li>
<li><a href='#MULTICORE'><p>Process on multiple cores on one machine</p></a></li>
<li><a href='#MULTIPROCESS'><p>Process on multiple processes on one machine</p></a></li>
<li><a href='#Pool'><p>Class for basic queuing system functions</p></a></li>
<li><a href='#Q'><p>Queue function calls on the cluster</p></a></li>
<li><a href='#Q_rows'><p>Queue function calls defined by rows in a data.frame</p></a></li>
<li><a href='#QSys'><p>Class for basic queuing system functions</p></a></li>
<li><a href='#register_dopar_cmq'><p>Register clustermq as 'foreach' parallel handler</p></a></li>
<li><a href='#SGE'><p>SGE scheduler functions</p></a></li>
<li><a href='#SLURM'><p>SLURM scheduler functions</p></a></li>
<li><a href='#SSH'><p>SSH scheduler functions</p></a></li>
<li><a href='#ssh_proxy'><p>SSH proxy for different schedulers</p></a></li>
<li><a href='#summarize_result'><p>Print a summary of errors and warnings that occurred during processing</p></a></li>
<li><a href='#vec_lookup'><p>Lookup table for return types to vector NAs</p></a></li>
<li><a href='#work_chunk'><p>Function to process a chunk of calls</p></a></li>
<li><a href='#worker'><p>R worker submitted as cluster job</p></a></li>
<li><a href='#workers'><p>Creates a pool of workers</p></a></li>
<li><a href='#wrap_error'><p>Wraps an error in a condition object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Evaluate Function Calls on HPC Schedulers (LSF, SGE, SLURM,
PBS/Torque)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Schubert &lt;mschu.dev@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluate arbitrary function calls using workers on HPC schedulers
    in single line of code. All processing is done on the network without
    accessing the file system. Remote schedulers are supported via SSH.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mschubert.github.io/clustermq/">https://mschubert.github.io/clustermq/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mschubert/clustermq/issues">https://github.com/mschubert/clustermq/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>ZeroMQ (libzmq) &gt;= 4.3.0 (optional; otherwise
bundled)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, narray, globals, progress, R6, Rcpp, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocParallel, callr, devtools, foreach, iterators, knitr,
parallel, rmarkdown, roxygen2 (&ge; 5.0.0), testthat, tools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 09:16:20 UTC; mschu</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Schubert <a href="https://orcid.org/0000-0002-6862-5221"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  ZeroMQ authors [aut, cph] (source files in 'src/libzmq' and
    'src/cppzmq')</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 15:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustermq-package'>Evaluate Function Calls on HPC Schedulers (LSF, SGE, SLURM)</h2><span id='topic+clustermq'></span><span id='topic+clustermq-package'></span>

<h3>Description</h3>

<p>Provides the <code>Q</code> function to send arbitrary function calls to
workers on HPC schedulers without relying on network-mounted storage.
Allows using remote schedulers via SSH.
</p>


<h3>Details</h3>

<p>Under the hood, this will submit a cluster job that connects to the master
via TCP the master will then send the function and argument chunks to the
worker and the worker will return the results to the master until everything
is done and you get back your result
</p>
<p>Computations are done entirely on the network and without any temporary
files on network-mounted storage, so there is no strain on the file system
apart from starting up R once per job. This removes the biggest bottleneck
in distributed computing.
</p>
<p>Using this approach, we can easily do load-balancing, i.e. workers that get
their jobs done faster will also receive more function calls to work on. This
is especially useful if not all calls return after the same time, or one
worker has a high load.
</p>
<p>For more detailed usage instructions, see the documentation of the <code>Q</code>
function.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Schubert <a href="mailto:mschu.dev@gmail.com">mschu.dev@gmail.com</a> (<a href="https://orcid.org/0000-0002-6862-5221">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> ZeroMQ authors (source files in 'src/libzmq' and 'src/cppzmq') [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mschubert.github.io/clustermq/">https://mschubert.github.io/clustermq/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mschubert/clustermq/issues">https://github.com/mschubert/clustermq/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.onAttach'>Report queueing system on package attach if not set</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Report queueing system on package attach if not set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>default arg for compatibility</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>default arg for compatibility</p>
</td></tr>
</table>

<hr>
<h2 id='.onLoad'>Select the queueing system on package loading</h2><span id='topic+.onLoad'></span>

<h3>Description</h3>

<p>This is done by setting the variable 'qsys' in the package environment
to the object that contains the desired queueing system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onLoad(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onLoad_+3A_libname">libname</code></td>
<td>
<p>default arg for compatibility</p>
</td></tr>
<tr><td><code id=".onLoad_+3A_pkgname">pkgname</code></td>
<td>
<p>default arg for compatibility</p>
</td></tr>
</table>

<hr>
<h2 id='check_args'>Function to check arguments with which Q() is called</h2><span id='topic+check_args'></span>

<h3>Description</h3>

<p>Function to check arguments with which Q() is called
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args(fun, iter, const = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_+3A_fun">fun</code></td>
<td>
<p>A function to call</p>
</td></tr>
<tr><td><code id="check_args_+3A_iter">iter</code></td>
<td>
<p>Objects to be iterated in each function call</p>
</td></tr>
<tr><td><code id="check_args_+3A_const">const</code></td>
<td>
<p>A list of constant arguments passed to each function call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed iterated argument list if 'iter' is a list
</p>

<hr>
<h2 id='chunk'>Subset index chunk for processing</h2><span id='topic+chunk'></span>

<h3>Description</h3>

<p>'attr' in '[.data.frame' takes too much CPU time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_+3A_x">x</code></td>
<td>
<p>Index data.frame</p>
</td></tr>
<tr><td><code id="chunk_+3A_i">i</code></td>
<td>
<p>Rows to subset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x[i,]
</p>

<hr>
<h2 id='cmq_foreach'>clustermq foreach handler</h2><span id='topic+cmq_foreach'></span>

<h3>Description</h3>

<p>clustermq foreach handler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmq_foreach(obj, expr, envir, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmq_foreach_+3A_obj">obj</code></td>
<td>
<p>Returned from foreach::foreach, containing the following variables:
args    : Arguments passed, each as a call
argnames: character vector of arguments passed
evalenv : Environment where to evaluate the arguments
export  : character vector of variable names to export to nodes
packages: character vector of required packages
verbose : whether to print status messages [logical]
errorHandling: string of function name to call error with, e.g. &quot;stop&quot;</p>
</td></tr>
<tr><td><code id="cmq_foreach_+3A_expr">expr</code></td>
<td>
<p>An R expression in curly braces</p>
</td></tr>
<tr><td><code id="cmq_foreach_+3A_envir">envir</code></td>
<td>
<p>Environment where to evaluate the arguments</p>
</td></tr>
<tr><td><code id="cmq_foreach_+3A_data">data</code></td>
<td>
<p>Common arguments passed by register_dopcar_cmq(), e.g. n_jobs</p>
</td></tr>
</table>

<hr>
<h2 id='fill_template'>Fill a template string with supplied values</h2><span id='topic+fill_template'></span>

<h3>Description</h3>

<p>Fill a template string with supplied values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_template(template, values, required = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_template_+3A_template">template</code></td>
<td>
<p>A character string of a submission template</p>
</td></tr>
<tr><td><code id="fill_template_+3A_values">values</code></td>
<td>
<p>A named list of key-value pairs</p>
</td></tr>
<tr><td><code id="fill_template_+3A_required">required</code></td>
<td>
<p>Keys that must be present in the template (default: none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A template where placeholder fields were replaced by values
</p>

<hr>
<h2 id='host'>Construct the ZeroMQ host address</h2><span id='topic+host'></span>

<h3>Description</h3>

<p>Construct the ZeroMQ host address
</p>


<h3>Usage</h3>

<pre><code class='language-R'>host(
  node = getOption("clustermq.host", Sys.info()["nodename"]),
  ports = 6000:9999,
  n = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="host_+3A_node">node</code></td>
<td>
<p>Node or device name</p>
</td></tr>
<tr><td><code id="host_+3A_ports">ports</code></td>
<td>
<p>Range of ports to consider</p>
</td></tr>
<tr><td><code id="host_+3A_n">n</code></td>
<td>
<p>How many addresses to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The possible addresses as character vector
</p>

<hr>
<h2 id='LOCAL'>Placeholder for local processing</h2><span id='topic+LOCAL'></span>

<h3>Description</h3>

<p>Mainly so tests pass without setting up a scheduler
</p>

<hr>
<h2 id='LSF'>LSF scheduler functions</h2><span id='topic+LSF'></span>

<h3>Description</h3>

<p>Derives from QSys to provide LSF-specific functions
</p>

<hr>
<h2 id='master'>Master controlling the workers</h2><span id='topic+master'></span>

<h3>Description</h3>

<p>exchanging messages between the master and workers works the following way:
* we have submitted a job where we don't know when it will start up
* it starts, sends is a message list(id=0) indicating it is ready
* we send it the function definition and common data
* we also send it the first data set to work on
* when we get any id &gt; 0, it is a result that we store
* and send the next data set/index to work on
* when computatons are complete, we send id=0 to the worker
* it responds with id=-1 (and usage stats) and shuts down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>master(
  pool,
  iter,
  rettype = "list",
  fail_on_error = TRUE,
  chunk_size = NA,
  timeout = Inf,
  max_calls_worker = Inf,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="master_+3A_pool">pool</code></td>
<td>
<p>Instance of Pool object</p>
</td></tr>
<tr><td><code id="master_+3A_iter">iter</code></td>
<td>
<p>Objects to be iterated in each function call</p>
</td></tr>
<tr><td><code id="master_+3A_rettype">rettype</code></td>
<td>
<p>Return type of function</p>
</td></tr>
<tr><td><code id="master_+3A_fail_on_error">fail_on_error</code></td>
<td>
<p>If an error occurs on the workers, continue or fail?</p>
</td></tr>
<tr><td><code id="master_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of function calls to chunk together
defaults to 100 chunks per worker or max. 500 kb per chunk</p>
</td></tr>
<tr><td><code id="master_+3A_timeout">timeout</code></td>
<td>
<p>Maximum time in seconds to wait for worker (default: Inf)</p>
</td></tr>
<tr><td><code id="master_+3A_max_calls_worker">max_calls_worker</code></td>
<td>
<p>Maxmimum number of function calls that will be sent to one worker</p>
</td></tr>
<tr><td><code id="master_+3A_verbose">verbose</code></td>
<td>
<p>Print progress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of whatever 'fun' returned
</p>

<hr>
<h2 id='msg_fmt'>Message format for logging</h2><span id='topic+msg_fmt'></span>

<h3>Description</h3>

<p>Message format for logging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msg_fmt(verbose = TRUE)
</code></pre>

<hr>
<h2 id='MULTICORE'>Process on multiple cores on one machine</h2><span id='topic+MULTICORE'></span>

<h3>Description</h3>

<p>Derives from QSys to provide multicore-specific functions
</p>

<hr>
<h2 id='MULTIPROCESS'>Process on multiple processes on one machine</h2><span id='topic+MULTIPROCESS'></span>

<h3>Description</h3>

<p>Derives from QSys to provide callr-specific functions
</p>

<hr>
<h2 id='Pool'>Class for basic queuing system functions</h2><span id='topic+Pool'></span>

<h3>Description</h3>

<p>Provides the basic functions needed to communicate between machines
This should abstract most functions of rZMQ so the scheduler
implementations can rely on the higher level functionality
</p>

<hr>
<h2 id='Q'>Queue function calls on the cluster</h2><span id='topic+Q'></span>

<h3>Description</h3>

<p>Queue function calls on the cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q(
  fun,
  ...,
  const = list(),
  export = list(),
  pkgs = c(),
  seed = 128965,
  memory = NULL,
  template = list(),
  n_jobs = NULL,
  job_size = NULL,
  split_array_by = -1,
  rettype = "list",
  fail_on_error = TRUE,
  workers = NULL,
  log_worker = FALSE,
  chunk_size = NA,
  timeout = Inf,
  max_calls_worker = Inf,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q_+3A_fun">fun</code></td>
<td>
<p>A function to call</p>
</td></tr>
<tr><td><code id="Q_+3A_...">...</code></td>
<td>
<p>Objects to be iterated in each function call</p>
</td></tr>
<tr><td><code id="Q_+3A_const">const</code></td>
<td>
<p>A list of constant arguments passed to each function call</p>
</td></tr>
<tr><td><code id="Q_+3A_export">export</code></td>
<td>
<p>List of objects to be exported to the worker</p>
</td></tr>
<tr><td><code id="Q_+3A_pkgs">pkgs</code></td>
<td>
<p>Character vector of packages to load on the worker</p>
</td></tr>
<tr><td><code id="Q_+3A_seed">seed</code></td>
<td>
<p>A seed to set for each function call</p>
</td></tr>
<tr><td><code id="Q_+3A_memory">memory</code></td>
<td>
<p>Short for template=list(memory=value)</p>
</td></tr>
<tr><td><code id="Q_+3A_template">template</code></td>
<td>
<p>A named list of values to fill in template</p>
</td></tr>
<tr><td><code id="Q_+3A_n_jobs">n_jobs</code></td>
<td>
<p>The number of LSF jobs to submit; upper limit of jobs
if job_size is given as well</p>
</td></tr>
<tr><td><code id="Q_+3A_job_size">job_size</code></td>
<td>
<p>The number of function calls per job</p>
</td></tr>
<tr><td><code id="Q_+3A_split_array_by">split_array_by</code></td>
<td>
<p>The dimension number to split any arrays in '...'; default: last</p>
</td></tr>
<tr><td><code id="Q_+3A_rettype">rettype</code></td>
<td>
<p>Return type of function call (vector type or 'list')</p>
</td></tr>
<tr><td><code id="Q_+3A_fail_on_error">fail_on_error</code></td>
<td>
<p>If an error occurs on the workers, continue or fail?</p>
</td></tr>
<tr><td><code id="Q_+3A_workers">workers</code></td>
<td>
<p>Optional instance of QSys representing a worker pool</p>
</td></tr>
<tr><td><code id="Q_+3A_log_worker">log_worker</code></td>
<td>
<p>Write a log file for each worker</p>
</td></tr>
<tr><td><code id="Q_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of function calls to chunk together
defaults to 100 chunks per worker or max. 10 kb per chunk</p>
</td></tr>
<tr><td><code id="Q_+3A_timeout">timeout</code></td>
<td>
<p>Maximum time in seconds to wait for worker (default: Inf)</p>
</td></tr>
<tr><td><code id="Q_+3A_max_calls_worker">max_calls_worker</code></td>
<td>
<p>Maxmimum number of chunks that will be sent to one worker</p>
</td></tr>
<tr><td><code id="Q_+3A_verbose">verbose</code></td>
<td>
<p>Print status messages and progress bar (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of whatever 'fun' returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Run a simple multiplication for numbers 1 to 3 on a worker node
fx = function(x) x * 2
Q(fx, x=1:3, n_jobs=1)
# list(2,4,6)

# Run a mutate() call in dplyr on a worker node
iris %&gt;%
    mutate(area = Q(`*`, e1=Sepal.Length, e2=Sepal.Width, n_jobs=1))
# iris with an additional column 'area'

## End(Not run)
</code></pre>

<hr>
<h2 id='Q_rows'>Queue function calls defined by rows in a data.frame</h2><span id='topic+Q_rows'></span>

<h3>Description</h3>

<p>Queue function calls defined by rows in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q_rows(
  df,
  fun,
  const = list(),
  export = list(),
  pkgs = c(),
  seed = 128965,
  memory = NULL,
  template = list(),
  n_jobs = NULL,
  job_size = NULL,
  rettype = "list",
  fail_on_error = TRUE,
  workers = NULL,
  log_worker = FALSE,
  chunk_size = NA,
  timeout = Inf,
  max_calls_worker = Inf,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q_rows_+3A_df">df</code></td>
<td>
<p>data.frame with iterated arguments</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_fun">fun</code></td>
<td>
<p>A function to call</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_const">const</code></td>
<td>
<p>A list of constant arguments passed to each function call</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_export">export</code></td>
<td>
<p>List of objects to be exported to the worker</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_pkgs">pkgs</code></td>
<td>
<p>Character vector of packages to load on the worker</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_seed">seed</code></td>
<td>
<p>A seed to set for each function call</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_memory">memory</code></td>
<td>
<p>Short for template=list(memory=value)</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_template">template</code></td>
<td>
<p>A named list of values to fill in template</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_n_jobs">n_jobs</code></td>
<td>
<p>The number of LSF jobs to submit; upper limit of jobs
if job_size is given as well</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_job_size">job_size</code></td>
<td>
<p>The number of function calls per job</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_rettype">rettype</code></td>
<td>
<p>Return type of function call (vector type or 'list')</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_fail_on_error">fail_on_error</code></td>
<td>
<p>If an error occurs on the workers, continue or fail?</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_workers">workers</code></td>
<td>
<p>Optional instance of QSys representing a worker pool</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_log_worker">log_worker</code></td>
<td>
<p>Write a log file for each worker</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of function calls to chunk together
defaults to 100 chunks per worker or max. 10 kb per chunk</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_timeout">timeout</code></td>
<td>
<p>Maximum time in seconds to wait for worker (default: Inf)</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_max_calls_worker">max_calls_worker</code></td>
<td>
<p>Maxmimum number of chunks that will be sent to one worker</p>
</td></tr>
<tr><td><code id="Q_rows_+3A_verbose">verbose</code></td>
<td>
<p>Print status messages and progress bar (default: TRUE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Run a simple multiplication for data frame columns x and y on a worker node
fx = function (x, y) x * y
df = data.frame(x = 5, y = 10)
Q_rows(df, fx, job_size = 1)
# [1] 50

# Q_rows also matches the names of a data frame with the function arguments
fx = function (x, y) x - y
df = data.frame(y = 5, x = 10)
Q_rows(df, fx, job_size = 1)
# [1] 5

## End(Not run)
</code></pre>

<hr>
<h2 id='QSys'>Class for basic queuing system functions</h2><span id='topic+QSys'></span>

<h3>Description</h3>

<p>Provides the basic functions needed to communicate between machines
This should abstract most functions of rZMQ so the scheduler
implementations can rely on the higher level functionality
</p>

<hr>
<h2 id='register_dopar_cmq'>Register clustermq as 'foreach' parallel handler</h2><span id='topic+register_dopar_cmq'></span>

<h3>Description</h3>

<p>Register clustermq as 'foreach' parallel handler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_dopar_cmq(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_dopar_cmq_+3A_...">...</code></td>
<td>
<p>List of arguments passed to the 'Q' function, e.g. n_jobs</p>
</td></tr>
</table>

<hr>
<h2 id='SGE'>SGE scheduler functions</h2><span id='topic+SGE'></span>

<h3>Description</h3>

<p>Derives from QSys to provide SGE-specific functions
</p>

<hr>
<h2 id='SLURM'>SLURM scheduler functions</h2><span id='topic+SLURM'></span>

<h3>Description</h3>

<p>Derives from QSys to provide SLURM-specific functions
</p>

<hr>
<h2 id='SSH'>SSH scheduler functions</h2><span id='topic+SSH'></span>

<h3>Description</h3>

<p>Derives from QSys to provide SSH-specific functions
</p>

<hr>
<h2 id='ssh_proxy'>SSH proxy for different schedulers</h2><span id='topic+ssh_proxy'></span>

<h3>Description</h3>

<p>Do not call this manually, the SSH qsys will do that
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssh_proxy(fwd_port, qsys_id = qsys_default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssh_proxy_+3A_fwd_port">fwd_port</code></td>
<td>
<p>The port of the master address to connect to
(remote end of reverse tunnel)</p>
</td></tr>
<tr><td><code id="ssh_proxy_+3A_qsys_id">qsys_id</code></td>
<td>
<p>Character string of QSys class to use</p>
</td></tr>
</table>

<hr>
<h2 id='summarize_result'>Print a summary of errors and warnings that occurred during processing</h2><span id='topic+summarize_result'></span>

<h3>Description</h3>

<p>Print a summary of errors and warnings that occurred during processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_result(
  result,
  n_errors,
  n_warnings,
  cond_msgs,
  at = length(result),
  fail_on_error = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_result_+3A_result">result</code></td>
<td>
<p>A list or vector of the processing result</p>
</td></tr>
<tr><td><code id="summarize_result_+3A_n_errors">n_errors</code></td>
<td>
<p>How many errors occurred</p>
</td></tr>
<tr><td><code id="summarize_result_+3A_n_warnings">n_warnings</code></td>
<td>
<p>How many warnings occurred</p>
</td></tr>
<tr><td><code id="summarize_result_+3A_cond_msgs">cond_msgs</code></td>
<td>
<p>Error and warnings messages, we display first 50</p>
</td></tr>
<tr><td><code id="summarize_result_+3A_at">at</code></td>
<td>
<p>How many calls were procesed  up to this point</p>
</td></tr>
<tr><td><code id="summarize_result_+3A_fail_on_error">fail_on_error</code></td>
<td>
<p>Stop if error(s) occurred</p>
</td></tr>
</table>

<hr>
<h2 id='vec_lookup'>Lookup table for return types to vector NAs</h2><span id='topic+vec_lookup'></span>

<h3>Description</h3>

<p>Lookup table for return types to vector NAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_lookup
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>

<hr>
<h2 id='work_chunk'>Function to process a chunk of calls</h2><span id='topic+work_chunk'></span>

<h3>Description</h3>

<p>Each chunk comes encapsulated in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>work_chunk(
  df,
  fun,
  const = list(),
  rettype = "list",
  common_seed = NULL,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="work_chunk_+3A_df">df</code></td>
<td>
<p>A data.frame with call IDs as rownames and arguments as columns</p>
</td></tr>
<tr><td><code id="work_chunk_+3A_fun">fun</code></td>
<td>
<p>The function to call</p>
</td></tr>
<tr><td><code id="work_chunk_+3A_const">const</code></td>
<td>
<p>Constant arguments passed to each call</p>
</td></tr>
<tr><td><code id="work_chunk_+3A_rettype">rettype</code></td>
<td>
<p>Return type of function</p>
</td></tr>
<tr><td><code id="work_chunk_+3A_common_seed">common_seed</code></td>
<td>
<p>A seed offset common to all function calls</p>
</td></tr>
<tr><td><code id="work_chunk_+3A_progress">progress</code></td>
<td>
<p>Logical indicated whether to display a progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of call results (or try-error if they failed)
</p>

<hr>
<h2 id='worker'>R worker submitted as cluster job</h2><span id='topic+worker'></span>

<h3>Description</h3>

<p>Do not call this manually, the master will do that
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worker(master, ..., verbose = TRUE, context = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="worker_+3A_master">master</code></td>
<td>
<p>The master address (tcp://ip:port)</p>
</td></tr>
<tr><td><code id="worker_+3A_...">...</code></td>
<td>
<p>Catch-all to not break older template values (ignored)</p>
</td></tr>
<tr><td><code id="worker_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print debug messages</p>
</td></tr>
<tr><td><code id="worker_+3A_context">context</code></td>
<td>
<p>ZeroMQ context (for internal testing)</p>
</td></tr>
</table>

<hr>
<h2 id='workers'>Creates a pool of workers</h2><span id='topic+workers'></span>

<h3>Description</h3>

<p>Creates a pool of workers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workers(
  n_jobs,
  data = NULL,
  reuse = TRUE,
  template = list(),
  log_worker = FALSE,
  qsys_id = getOption("clustermq.scheduler", qsys_default),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workers_+3A_n_jobs">n_jobs</code></td>
<td>
<p>Number of jobs to submit (0 implies local processing)</p>
</td></tr>
<tr><td><code id="workers_+3A_data">data</code></td>
<td>
<p>Set common data (function, constant args, seed)</p>
</td></tr>
<tr><td><code id="workers_+3A_reuse">reuse</code></td>
<td>
<p>Whether workers are reusable or get shut down after call</p>
</td></tr>
<tr><td><code id="workers_+3A_template">template</code></td>
<td>
<p>A named list of values to fill in template</p>
</td></tr>
<tr><td><code id="workers_+3A_log_worker">log_worker</code></td>
<td>
<p>Write a log file for each worker</p>
</td></tr>
<tr><td><code id="workers_+3A_qsys_id">qsys_id</code></td>
<td>
<p>Character string of QSys class to use</p>
</td></tr>
<tr><td><code id="workers_+3A_verbose">verbose</code></td>
<td>
<p>Print message about worker startup</p>
</td></tr>
<tr><td><code id="workers_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the qsys constructor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of the QSys class
</p>

<hr>
<h2 id='wrap_error'>Wraps an error in a condition object</h2><span id='topic+wrap_error'></span>

<h3>Description</h3>

<p>Wraps an error in a condition object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_error(call)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
