<!DOCTYPE html><html lang="en"><head><title>Help for package clusTransition</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clusTransition}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Clustering-class'><p>Class Clustering</p></a></li>
<li><a href='#Clusters'><p>Clustering.</p></a></li>
<li><a href='#Data2D'><p>Synthetic Datasets (Two Dimensional)</p></a></li>
<li><a href='#Data3D'><p>Synthetic Datasets (Three Dimensional)</p></a></li>
<li><a href='#extTransitionCan'><p>External Transition Candidate.</p></a></li>
<li><a href='#extTransitionCount'><p>External Transition Count</p></a></li>
<li><a href='#internalTransition'><p>Internal Transition Candidates.</p></a></li>
<li><a href='#intTransitionCan-class'><p>Internal Transition Candidates</p></a></li>
<li><a href='#Monic'><p>An S4 class that contain time steps</p></a></li>
<li><a href='#moplot'><p>plot Method for output</p></a></li>
<li><a href='#Overlap'><p>Overlap</p></a></li>
<li><a href='#OverLap-class'><p>Overlap between clusters</p></a></li>
<li><a href='#show+2CMonic-method'><p>Show Method for output</p></a></li>
<li><a href='#Transition'><p>Monitor Transitions in Cluster Solutions.</p></a></li>
<li><a href='#TransitionCan-class'><p>External Transition Candidates</p></a></li>
<li><a href='#TransitionCount-class'><p>External Transition Count</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Monitor Changes in Cluster Solutions of Dynamic Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Muhammad Atif</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Muhammad Atif &lt;muhammad96_atif@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Monitor and trace changes in clustering solutions of accumulating datasets 
    at successive time points. The clusters can adopt External and Internal transition at 
    succeeding time points. The External transitions comprise of Survived, Merged, Split, 
    Disappeared, and newly Emerged candidates. In contrast, Internal transition includes changes 
    in location and cohesion of the survived clusters. The package uses MONIC framework developed by 
    Spiliopoulou, Ntoutsi, Theodoridis, and Schult (2006)&lt;<a href="https://doi.org/10.1145%2F1150402.1150491">doi:10.1145/1150402.1150491</a>&gt; .</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), flexclust, methods, graphics</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-22 11:59:15 UTC; Atif</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-22 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Clustering-class'>Class Clustering</h2><span id='topic+Clustering-class'></span><span id='topic+Clustering'></span>

<h3>Description</h3>

<p>Partition data into clusters
</p>


<h3>Details</h3>

<p>Object of class <code>Clustering</code> containing clustering solution of cumulative dataset D_i. The object of class
<code>Clustering</code> comprise of four slots. Slot <code>Clusters</code> contain data items of each cluster, slot <code>Centers</code> contain
cluster centers, slot <code>k</code> contain the number of centers, while slot <code>clusterMem</code> contain cluster memberships vector.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Cluster</code></dt><dd><p>List of matrices, where each element of the list include data items belonging to the corresponding cluster.</p>
</dd>
<dt><code>Centers</code></dt><dd><p>Matrix of cluster centers.</p>
</dd>
<dt><code>k</code></dt><dd><p>Number of centers.</p>
</dd>
<dt><code>clusterMem</code></dt><dd><p>Numeric vector of cluster membership.</p>
</dd>
</dl>

<hr>
<h2 id='Clusters'>Clustering.</h2><span id='topic+Clusters'></span><span id='topic+Clusters+2CClustering+2Cmatrix+2Cnumeric-method'></span><span id='topic+Clusters+2CClustering-method'></span>

<h3>Description</h3>

<p>Initialize slots of class <code>Clustering</code> by partitioning the dataset into <code>k</code> clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Clusters(object, x, k)

## S4 method for signature 'Clustering,matrix,numeric'
Clusters(object, x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Clusters_+3A_object">object</code></td>
<td>
<p>An object of class <code>Clustering</code>.</p>
</td></tr>
<tr><td><code id="Clusters_+3A_x">x</code></td>
<td>
<p>Numeric matrix of data.</p>
</td></tr>
<tr><td><code id="Clusters_+3A_k">k</code></td>
<td>
<p>Number of centers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs <code>cclust</code> function from &quot;flexclust&quot; package with default settings i.e.
method = &quot;kmeans&quot;, dist = &quot;euclidean&quot;, and partition the dataset. Returns object of class <code>Clustering</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>Clustering</code>
</p>

<hr>
<h2 id='Data2D'>Synthetic Datasets (Two Dimensional)</h2><span id='topic+Data2D'></span>

<h3>Description</h3>

<p>A list of datasets generated at four time points containing two variables and cluster membership at each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Data2D
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<dl>
<dt>x1</dt><dd><p>X1.</p>
</dd>
<dt>x2</dt><dd><p>X2.</p>
</dd>
<dt>class</dt><dd><p>Class membership.</p>
</dd>
</dl>


<hr>
<h2 id='Data3D'>Synthetic Datasets (Three Dimensional)</h2><span id='topic+Data3D'></span>

<h3>Description</h3>

<p>A list of datasets generated at four points containing three variables and cluster membership at each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Data3D
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<dl>
<dt>x1</dt><dd><p>X1.</p>
</dd>
<dt>x2</dt><dd><p>X2.</p>
</dd>
<dt>x3</dt><dd><p>X3.</p>
</dd>
<dt>class</dt><dd><p>Class membership.</p>
</dd>
</dl>


<hr>
<h2 id='extTransitionCan'>External Transition Candidate.</h2><span id='topic+extTransitionCan'></span><span id='topic+extTransitionCan+2CTransitionCan-method'></span><span id='topic+extTransitionCan-method'></span>

<h3>Description</h3>

<p>This S4 method trace cluster solutions of dynamic dataset, and identify the candidates
that experience external transition from first clustering and emerged at second clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extTransitionCan(object)

## S4 method for signature 'TransitionCan'
extTransitionCan(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extTransitionCan_+3A_object">object</code></td>
<td>
<p>An object of class Transitioncan</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class TransitionCan
</p>

<hr>
<h2 id='extTransitionCount'>External Transition Count</h2><span id='topic+extTransitionCount'></span><span id='topic+extTransitionCount+2CTransitionCount-method'></span><span id='topic+extTransitionCount-method'></span>

<h3>Description</h3>

<p>Trace cluster solutions of dynamic datasets and count the number of clusters that experiences
external transition from first clustering. The external transition includes survived, split into various daughters,
spliced into one, disappeared, and newly emerged candidates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extTransitionCount(object)

## S4 method for signature 'TransitionCount'
extTransitionCount(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extTransitionCount_+3A_object">object</code></td>
<td>
<p>An object of class <code>Transitioncount</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class <code>TransitionCount</code>
</p>

<hr>
<h2 id='internalTransition'>Internal Transition Candidates.</h2><span id='topic+internalTransition'></span><span id='topic+internalTransition+2CintTransitionCan-method'></span><span id='topic+internalTransition-method'></span>

<h3>Description</h3>

<p>This method identify internal transition of the survived clusters,
obtained from 'extTransitionCan()' method.
</p>
<p>Trace clustering solutions of cumulative datasets and identify the survived clusters
experiencing Internal transitions. Internal transition includes the change in location and density
of the survived candidates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internalTransition(object)

## S4 method for signature 'intTransitionCan'
internalTransition(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internalTransition_+3A_object">object</code></td>
<td>
<p>An object of class <code>intTransitionCan</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class <code>intTransitionCan</code>
</p>

<hr>
<h2 id='intTransitionCan-class'>Internal Transition Candidates</h2><span id='topic+intTransitionCan-class'></span><span id='topic+intTransitionCan'></span>

<h3>Description</h3>

<p>Class containing results of Internal Transition of survived clusters from first clustering <code class="reqn">\xi_1</code>.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intTransitionCan-class_+3A_object">object</code></td>
<td>
<p>An object of class Transitioncan</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>Location.diff</code></dt><dd><p>Vector of integers containing difference in location (= Distance bw cluster centers/min(rx,ry)).</p>
</dd>
<dt><code>Compactness.diff</code></dt><dd><p>Vector of integers containing Change in density of survived clusters (d(rx, ry)).</p>
</dd>
<dt><code>Location_thrHold</code></dt><dd><p>Minimum value of threshold for shift in location.</p>
</dd>
<dt><code>Density_thrHold</code></dt><dd><p>Minimum value of threshold for change in density.</p>
</dd>
<dt><code>ShiftLocCan</code></dt><dd><p>Vector of integers containing Survived candidates with shift in their location.</p>
</dd>
<dt><code>NoShiftLocCan</code></dt><dd><p>Vector of integers containing Survived candidates with no Shift in their Location.</p>
</dd>
<dt><code>MoreCompactCan</code></dt><dd><p>Vector of integers containing Survived Candidates Which becomes more compact.</p>
</dd>
<dt><code>MoreDiffuseCan</code></dt><dd><p>Vector of integers containing Survived Candidates Which becomes more diffuse.</p>
</dd>
<dt><code>NoChangeCompactCan</code></dt><dd><p>Vector of integers containing Survived candidates with no change in compactness.</p>
</dd>
</dl>

<hr>
<h2 id='Monic'>An S4 class that contain time steps</h2><span id='topic+Monic'></span>

<h3>Description</h3>

<p>An S4 class that contain time steps
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Monic_+3A_object">object</code></td>
<td>
<p>An object of class <code>Transitioncan</code></p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>TimeStep</code></dt><dd><p>Time Steps</p>
</dd>
</dl>

<hr>
<h2 id='moplot'>plot Method for output</h2><span id='topic+moplot'></span><span id='topic+moplot+2CMonic-method'></span><span id='topic+moplot-method'></span>

<h3>Description</h3>

<p>This method plot 3 barplot and 1 line graph. The first stack barplot shows
SurvivalRatio and AbsorptionRatio, second barplot shows number of newly emerged clusters
at each time stamp, third barplot shows number of disapeared clusters at each time stamp. The line
graph shows passforward Ratio and Survival Ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moplot(object)

## S4 method for signature 'Monic'
moplot(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moplot_+3A_object">object</code></td>
<td>
<p>An object of class Monic</p>
</td></tr>
</table>

<hr>
<h2 id='Overlap'>Overlap</h2><span id='topic+Overlap'></span><span id='topic+Overlap+2COverLap+2CClustering+2CClustering-method'></span><span id='topic+OverLap+2C'></span><span id='topic+Clustering+2C'></span><span id='topic+Clustering-method'></span><span id='topic+Overlap+2COverLap+2CANY+2CANY-method'></span><span id='topic+OverLap+2CANY+2CANY-methods'></span>

<h3>Description</h3>

<p>Initialize slots of class <code>OverLap</code> by importing clustering solutions of dynamic
datasets at two consecutive time points. Clusters at each time point should be provided as a list of
matrices, where each matrix contains dataset belongs to the corresponding cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Overlap(object, e1, e2)

## S4 method for signature 'OverLap,Clustering,Clustering'
Overlap(object, e1, e2)

## S4 method for signature 'OverLap,ANY,ANY'
Overlap(object, e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Overlap_+3A_object">object</code></td>
<td>
<p>An object of class <code>OverLap</code></p>
</td></tr>
<tr><td><code id="Overlap_+3A_e1">e1</code></td>
<td>
<p>An object of class <code>Clustering</code>, or any object that can be coerced, such as list of matrices
or data frames that contain clusters from first clustering.</p>
</td></tr>
<tr><td><code id="Overlap_+3A_e2">e2</code></td>
<td>
<p>An object of class <code>Clustering</code>, or any object that can be coerced, such as list of matrices
or data frames that contain clusters from second clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class <code>OverLap</code>.
</p>

<hr>
<h2 id='OverLap-class'>Overlap between clusters</h2><span id='topic+OverLap-class'></span><span id='topic+OverLap'></span>

<h3>Description</h3>

<p>Contains matrix of similarity indices between clusters, after clustering dynamic datasets at consecutive time points.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Overlap</code></dt><dd><p>A numeric matrix containing the similarity index between clusters extracted at time point <code>t_1</code> and <code>t_2</code>.
The rows of the matrix illustrate clusters extracted from first clustering <code class="reqn">\xi_1(time point t_1)</code>,whereas columns represent
clusters extracted from second clustering <code class="reqn">\xi_2(time point t_2)</code>.</p>
</dd>
<dt><code>rx</code></dt><dd><p>A numeric vector containg radius of each cluster from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>ry</code></dt><dd><p>A numeric vector containg radius of each cluster from second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
<dt><code>Centersx</code></dt><dd><p>A numeric vector containing centers of clusters from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>Centersy</code></dt><dd><p>A numeric vector containing centers of clusters from second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
<dt><code>avgDisx</code></dt><dd><p>A numeric vector containing average distance between points in a cluster from its center in first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>avgDisy</code></dt><dd><p>A numeric vector containing average distance between points in a cluster from its center in second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
<dt><code>clusterMem</code></dt><dd><p>A vector of integers containing cluster membership from second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
</dl>

<hr>
<h2 id='show+2CMonic-method'>Show Method for output</h2><span id='topic+show+2CMonic-method'></span><span id='topic+show-method'></span>

<h3>Description</h3>

<p>Show Method for output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Monic'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CMonic-method_+3A_object">object</code></td>
<td>
<p>An object of class Monic</p>
</td></tr>
</table>

<hr>
<h2 id='Transition'>Monitor Transitions in Cluster Solutions.</h2><span id='topic+Transition'></span>

<h3>Description</h3>

<p>Model and trace the evolution of clusters evolving over time in cumulative
datasets. A typical call to <code>Transition()</code> function involves three essential pieces:
the data input <code>(listdata, listclus, overlap)</code>, choice of window <code>swSize</code>,
and the threshold parameters. The function either receive a list of datasets arriving at
time points <code>t_1, t_2, t_3, ..., t_n</code> respectively, list of clustering solutions
extracted from cumulative datasets at successive time points, or list of objects of class
<code>OverLap</code> (see <strong>Details</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Transition(
  listdata,
  swSize = 1,
  Overlap = NULL,
  listclus = NULL,
  typeind = 1,
  Survival_thrHold = 0.7,
  Split_thrHold = 0.3,
  location_thrHold = 0.3,
  density_thrHold = 0.3,
  k = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Transition_+3A_listdata">listdata</code></td>
<td>
<p>List of numeric matrices containing datasets <code>d_1, d_2, ..., d_n</code>,
or a list of objects that can be coerced to such matrices, for instance, data frames.
Each element of the list contain dataset <code>d_i</code> evolving at corresponding time point
<code>t_i</code>. The number of clusters in each accumulative data matrix is specified by the
argument <code>k</code>.</p>
</td></tr>
<tr><td><code id="Transition_+3A_swsize">swSize</code></td>
<td>
<p>Integer value (1, length(listdata)) indicating size of the sliding window. As time goes
by, each window consist only objects that fall in the interval [t-swSize+1, t], while older objects
are discarded. The default value of <code>swSize = 1</code> indicate landmark window model, where objects over
the entire history are included i.e. [1, t]. Size of sliding window can only be provided if <code>listdata</code>
arguments is choosen. If there are total <code>n</code> time stamps and a window of size <code>swSize</code> is
selected then entire history would be devided into <code>n-swSize+2</code> window panes.</p>
</td></tr>
<tr><td><code id="Transition_+3A_overlap">Overlap</code></td>
<td>
<p>A list of objects as produced by the <code>Overlap()</code> method. The object contains a matrix of similarity
indices between clusters, and the summaries of clusters extracted at first and second clustering.</p>
</td></tr>
<tr><td><code id="Transition_+3A_listclus">listclus</code></td>
<td>
<p><code>listclus</code> is a list of nested lists containing clustering solutions <code class="reqn">\xi_1, \xi_2, ..., \xi_n</code> at
time points <code>{t1, t2,···, tn}</code> respectively, and having the same length as the number of time points. The <code>i^th</code>
element of <code>listclus</code> is a nested list that contain set of clusters as matrices at corresponding time point <code>t_i</code>
i.e. <code class="reqn">\xi_i = {X1, X2,···, Xki}</code>. For more details, <em>see</em> <strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="Transition_+3A_typeind">typeind</code></td>
<td>
<p>Type indicator. <code>typeind = 1</code> indicates that the raw data is provided in
<code>listdata</code> argument, <code>typeind = 2</code> indicates that the <code>OverLap</code> objects are provided,
whereas <code>typeind = 3</code> indicates that list of clusters are provided using <code>listclus</code> argument.</p>
</td></tr>
<tr><td><code id="Transition_+3A_survival_thrhold">Survival_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for survival of clusters.</p>
</td></tr>
<tr><td><code id="Transition_+3A_split_thrhold">Split_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for split of clusters.</p>
</td></tr>
<tr><td><code id="Transition_+3A_location_thrhold">location_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for shift in location of survived clusters.</p>
</td></tr>
<tr><td><code id="Transition_+3A_density_thrhold">density_thrHold</code></td>
<td>
<p>A numeric value (0,1) indicating minimum threshold value for changes in density of Survived clusters.</p>
</td></tr>
<tr><td><code id="Transition_+3A_k">k</code></td>
<td>
<p>Numeric Vector of length <code>vector("numeric", length = n-swSize+2)</code>. In the case of landmark window, its length
is <code>n</code>, whereas in case of sliding window model its length is <code>n-swSize+2</code>, where <code>n</code> is the number of time points
and <code>swSize</code> is the size of the sliding window. This argument should only be provided if <code>listdata</code> argument is chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Transition()</code> function apply 'MONIC' algorithm presented by Spiliopoulou et.al (2006) to trace
changes in cluster solutions of dynamic data sets. The changes includes two types of transition i.e. External transition
and Internal transition. External Transition consist of 'Survive', 'Split', 'Merge', 'Disappeared' and 'newly emerged' candidates,
while Internal transition consist of changes in location and cohesion of the survived clusters. The <code>listdata</code> argument
allow user to import dynamic datasets as a list of matrices or data frames, where each element of the list is a matrix containing
data set at a single time point. Each dataset are clustered by 'kmeans' algorithm using default settings of <code>cclust()</code> function
from <code>flexclust</code> package. The number of clusters at each time stamp can be import by <code>k</code> argument of the function,
which is a vector of integers encompassing number of partitions in corresponding datasets of <code>listdata</code> argument. Once the datasets are
clustered, the 'Overlap' matrices in clustering at consecutive time stamps are calculated. The Overlap matrix is
calculated by using algorithm presented by Ntoutsi, I., et.al (2012). These 'Overlap' matrices are used to trace the
transitions occurred in cluster solutions.
Alternatively, the user can directly import list of 'Overlap' matrices between consecutive clustering. The Overlap
matrix can be calculated using <code>Overlap(obj, e1, e2)</code> method of the package, where 'obj' is the object of class
<code>OverLap</code> and e1, e2 are any clustering at time stamp i and j respectively.
As a third option user can provide list of clusters at each data point utilizing <code>listclus</code> argument. Each element
of the <code>listclus</code> is a nested list, which holds clusters at a single time stamp.
</p>


<h3>Value</h3>

<p>Returns A list of class <code>Monic</code>.
</p>
<table role = "presentation">
<tr><td><code>Survive</code></td>
<td>
<p>Number of clusters survived.</p>
</td></tr>
<tr><td><code>Merged</code></td>
<td>
<p>Number of clusters merged.</p>
</td></tr>
<tr><td><code>Split</code></td>
<td>
<p>Number of clusters split.</p>
</td></tr>
<tr><td><code>Died</code></td>
<td>
<p>Number of clusters disappeared.</p>
</td></tr>
<tr><td><code>new.Emerged</code></td>
<td>
<p>Number of newly emerged clusters, which are not upshot of any external transition.</p>
</td></tr>
<tr><td><code>SurvivalCanx</code></td>
<td>
<p>A vector of integers indicating candidates from the first clustering
survived to the latter time stamp</p>
</td></tr>
<tr><td><code>SurvivalCany</code></td>
<td>
<p>A vector of integers indicating candidates of second clustering, that
clinch the survival candidates from first clustering.</p>
</td></tr>
<tr><td><code>SplitCanx</code></td>
<td>
<p>A vector of integers indicating candidate(s) that split into various daughter clusters from
first clustering.</p>
</td></tr>
<tr><td><code>SplitCany</code></td>
<td>
<p>List of integer vector(s) designating candidates appeared, as a result of splits
from first clustering.</p>
</td></tr>
<tr><td><code>MergeCanx</code></td>
<td>
<p>List of integer vector(s) designating Candidates that spliced together to form
new clusters. Each element of the list gives candidates that merge together to form one.</p>
</td></tr>
<tr><td><code>MergeCany</code></td>
<td>
<p>Vector of integers designating candidates that emerged, as a result of merger
of different candidates from first clustering.</p>
</td></tr>
<tr><td><code>EmergCan</code></td>
<td>
<p>Vector of integers contain Newly emerged candidates, which are not result of
any external transition.</p>
</td></tr>
<tr><td><code>SurvivalRatio</code></td>
<td>
<p>The Ratio of survived clusters at second clustering to the total number
of clusters at first clustering.</p>
</td></tr>
<tr><td><code>AbsorptionRatio</code></td>
<td>
<p>Ratio of number of merged clusters to total number of clusters at first
clustering.</p>
</td></tr>
<tr><td><code>passforwardRatio</code></td>
<td>
<p>Sum of SurvivalRatio and AbsorptionRatio. This gives the ratio of
clusters that is also present at second clustering either in the form of survival or absorption.</p>
</td></tr>
<tr><td><code>Overlap</code></td>
<td>
<p>A numeric matrix containing overlap of the two clustering. The rows of matrix
indicate first clustering, while columns indicate second clustering.</p>
</td></tr>
<tr><td><code>Centersx</code></td>
<td>
<p>A matrix of cluster centers from first clustering.</p>
</td></tr>
<tr><td><code>Centersx</code></td>
<td>
<p>A matrix of cluster centers from second clustering.</p>
</td></tr>
<tr><td><code>rx</code></td>
<td>
<p>A numeric vector containing radius of each cluster from first clustering.</p>
</td></tr>
<tr><td><code>ry</code></td>
<td>
<p>A numeric vector containing radius of each cluster from second clustering.</p>
</td></tr>
<tr><td><code>avgDisx</code></td>
<td>
<p>A numeric vector containing average distance of points in a cluster from its center in first clustering.</p>
</td></tr>
<tr><td><code>avgDisy</code></td>
<td>
<p>A numeric vector containing average distance of points in a cluster from its center in second clustering.</p>
</td></tr>
<tr><td><code>ShiftLocCan</code></td>
<td>
<p>A vector of integers comprises of Survived candidates with shift in location.</p>
</td></tr>
<tr><td><code>NoShiftLocCan</code></td>
<td>
<p>A vector of integers comprises of Survived candidates with no shift in location.</p>
</td></tr>
<tr><td><code>MoreCompactCan</code></td>
<td>
<p>A Vector of integers comprises of Survived candidates, which becomes more compact.</p>
</td></tr>
<tr><td><code>MoreDiffuseCan</code></td>
<td>
<p>A Vector of integers comprises of Survived candidates, which becomes more diffuse.</p>
</td></tr>
<tr><td><code>NoChangeCompactCan</code></td>
<td>
<p>A Vector of integers comprises of Survived candidates, with no changes in compactness.</p>
</td></tr>
<tr><td><code>Location.diff</code></td>
<td>
<p>A numeric vector containing Distance between the centers of survived clusters.</p>
</td></tr>
<tr><td><code>Compactness.diff</code></td>
<td>
<p>A numeric vector containing Difference between compactness of survived clusters.</p>
</td></tr>
<tr><td><code>Cluster_Tracex</code></td>
<td>
<p>A vector containing result of each cluster from first clustering.</p>
</td></tr>
<tr><td><code>Cluster_Tracey</code></td>
<td>
<p>A Vector representing result of each cluster from second clustering.</p>
</td></tr>
<tr><td><code>clusterMem</code></td>
<td>
<p>A vector of integers (from 1 to k) indicating the point to which cluster it is allocated from second clusterig.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Spiliopoulou, M., Ntoutsi, I., Theodoridis, Y., Schult, R. MONIC: modeling and monitoring cluster
transitions. In: Eliassi-Rad, T., Ungar, L. H., Craven, M., Gunopulos, D. (eds.) ACM SIGKDD 2006, pp. 706-711. ACM, Philadelphia (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1: typeind = 1 (listdata Argument)

d1 &lt;- Data2D[[1]][c("X1", "X2")]
d2 &lt;- Data2D[[2]][c("X1", "X2")]
d3 &lt;- Data2D[[3]][c("X1", "X2")]

listdata &lt;- list(d1, d2, d3)

p &lt;- Transition(listdata = listdata, swSize = 1, typeind = 1, Survival_thrHold = 0.8,
                Split_thrHold = 0.3, density_thrHold = 0.3, location_thrHold = 0.3, k = c(3,3,2))

### Example 2: typeind = 3 (listclus Argument)

D1 &lt;- d1
D2 &lt;- merge(d1, d2, all.x = TRUE, all.y = TRUE)
D3 &lt;- merge(D2, d3, all.x = TRUE, all.y = TRUE)

set.seed(10)
f1 &lt;- kmeans(D1, 3)
C1 &lt;- list()
for(i in 1:3)C1[[i]] &lt;- D1[f1$cluster == i, ]
f2 &lt;- kmeans(D2, 3)
C2 &lt;- list()
for(i in 1:3)C2[[i]] &lt;- D2[f2$cluster == i, ]
f3 &lt;- kmeans(D3, 2)
C3 &lt;- list()
for(i in 1:2)C3[[i]] &lt;- D3[f3$cluster == i, ]

listclus &lt;- list(C1, C2, C3)

p &lt;- Transition(listclus = listclus, typeind = 3, Survival_thrHold = 0.8,
                Split_thrHold = 0.3, density_thrHold = 0.3, location_thrHold = 0.3)

### Example 3: typeind = 3 (Overlap Argument)

obj &lt;- new("OverLap")
Overlap1 &lt;- Overlap(obj, e1 = C1, e2 = C2)
Overlap2 &lt;- Overlap(obj, e1 = C2, e2 = C3)

Overlap &lt;- list(Overlap1, Overlap2)
p &lt;- Transition(Overlap = Overlap, typeind = 2, Survival_thrHold = 0.8,
                Split_thrHold = 0.3, density_thrHold = 0.3, location_thrHold = 0.3)


</code></pre>

<hr>
<h2 id='TransitionCan-class'>External Transition Candidates</h2><span id='topic+TransitionCan-class'></span><span id='topic+TransitionCan'></span>

<h3>Description</h3>

<p>Class containing candidates that adopted external transition from first clustering <code class="reqn">\xi_1</code>,
and emerged as new clusters at second clustering <code class="reqn">\xi_2</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>SurvivalCanx</code></dt><dd><p>Vector of integers comprising Candidates that Survive from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>SurvivalCany</code></dt><dd><p>Vector of integers comprising Candidates that Survive to second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
<dt><code>SplitCanx</code></dt><dd><p>Vector of integers comprising Candidates that Sliced into Various daughter Clusters from
first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>SplitCany</code></dt><dd><p>List of integer vectors comprising Candidates that emerged as daughter clusters in second clustering <code class="reqn">\xi_2</code>
because of Split from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>MergeCanx</code></dt><dd><p>List of integer vectors comprising Candidates from first clustering <code class="reqn">\xi_1</code> that are merged.
Each slot of list indicates the clusters that merge together from first clustering.</p>
</dd>
<dt><code>MergeCany</code></dt><dd><p>Vector of integers comprising Candidates that emerged in second clustering <code class="reqn">\xi_2</code> because
of merging various clusters from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>EmergCan</code></dt><dd><p>Newley emerged candidates which are not a result of any external transition from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>Cluster_Tracey</code></dt><dd><p>Vector of Cluster Trace from second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
</dl>

<hr>
<h2 id='TransitionCount-class'>External Transition Count</h2><span id='topic+TransitionCount-class'></span><span id='topic+TransitionCount'></span>

<h3>Description</h3>

<p>Trace cluster solutions of dynamic datasets at consecutive
time points and counts the clusters that experiences external transition.
External transition includes Survive, Split, Merge, newly emerged, and Died candidates.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Survive</code></dt><dd><p>Number of candidates survive from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>Split</code></dt><dd><p>Number of candidates from first clustering <code class="reqn">\xi_1</code> that split into several daughter clusters at second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
<dt><code>Merge</code></dt><dd><p>Number of candidates from first clustering <code class="reqn">\xi_1</code> that merge toghter at second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
<dt><code>Died</code></dt><dd><p>Number of candidates from first clusterin <code class="reqn">\xi_1</code> that disapeared at second clustering <code class="reqn">\xi_2</code>.</p>
</dd>
<dt><code>SurvivalRatio</code></dt><dd><p>Ratio of survive clusters to total number of clusters from first clusering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>AbsorptionRatio</code></dt><dd><p>Ratio of Merged clusters to total number of clusters from first clusering <code class="reqn">\xi_1</code>.</p>
</dd>
<dt><code>passforwardRatio</code></dt><dd><p>Sum of SurvivalRatio and AbsorptionRatio.</p>
</dd>
<dt><code>Survival_thrHold</code></dt><dd><p>Threshold for survival of clusters.</p>
</dd>
<dt><code>Split_thrHold</code></dt><dd><p>Threhold for split of clusters.</p>
</dd>
<dt><code>Cluster_Tracex</code></dt><dd><p>Vector containing each cluster result from first clustering <code class="reqn">\xi_1</code>.</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
