<!DOCTYPE html><html><head><title>Help for package humaniformat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {humaniformat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#first_name'><p>Get or set a name's first name</p></a></li>
<li><a href='#format_period'><p>Reformat Period-Separated Names</p></a></li>
<li><a href='#format_reverse'><p>Reformat Reversed Names</p></a></li>
<li><a href='#humaniformat'><p>A Parser for Human Names</p></a></li>
<li><a href='#last_name'><p>Get or set a name's last name</p></a></li>
<li><a href='#middle_name'><p>Get or set a name's middle name</p></a></li>
<li><a href='#parse_names'><p>Parse Human Names</p></a></li>
<li><a href='#salutation'><p>Get or set a name's saltation</p></a></li>
<li><a href='#suffix'><p>Get or set a name's suffix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Parser for Human Names</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-04-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Oliver Keyes [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oliver Keyes &lt;ironholds@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Human names are complicated and nonstandard things. Humaniformat,
    which is based on Anthony Ettinger's 'humanparser' project (https://github.com/
    chovy/humanparser) provides functions for parsing human names, making a best-
    guess attempt to distinguish sub-components such as prefixes, suffixes, middle
    names and salutations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ironholds/humaniformat/">https://github.com/ironholds/humaniformat/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ironholds/humaniformat/issues">https://github.com/ironholds/humaniformat/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, methods</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-24 18:50:06 UTC; ironholds</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-24 23:15:03</td>
</tr>
</table>
<hr>
<h2 id='first_name'>Get or set a name's first name</h2><span id='topic+first_name'></span><span id='topic+first_name+3C-'></span>

<h3>Description</h3>

<p>as in the lubridate package, individual components of a name
can be both extracted or set using the relevant function call - see the
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_name(x)

first_name(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_name_+3A_x">x</code></td>
<td>
<p>a name, or vector of names</p>
</td></tr>
<tr><td><code id="first_name_+3A_value">value</code></td>
<td>
<p>a replacement value for x's first name.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+salutation">salutation</a></code>, <code><a href="#topic+middle_name">middle_name</a></code>, <code><a href="#topic+last_name">last_name</a></code> 
and <code><a href="#topic+suffix">suffix</a></code> for other accessors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Get a first name
example_name &lt;- "Mr Jim Jeffries"
first_name(example_name)

#Set a first name
first_name(example_name) &lt;- "Prof"
</code></pre>

<hr>
<h2 id='format_period'>Reformat Period-Separated Names</h2><span id='topic+format_period'></span>

<h3>Description</h3>

<p>a common pattern for names is for first and middle names to be represented
by initials. Unfortunately depending on how this is done, that can make things problematic;
&quot;G. K. Chesterton&quot; is easy to parse, but &quot;G.K. Chesterton&quot; or &quot;G.K.Chesterton&quot; is not.
<code>format_period</code> takes names that are period-separated in this fashion and reformats
them to ensure there are spaces between each initial. Periods after any space in the name
are preserved, so &quot;G.K. Chesterton, M.D.&quot; does not become &quot;G. K. Chesterton, M. D. &quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_period(names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_period_+3A_names">names</code></td>
<td>
<p>a vector of names following this convention. Names that lack periods will
be returned entirely intact, so assuming you don't have (legitimate) periods in names
not following this format, there's no need to worry if your vector has mixed formatting.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+format_reverse">format_reverse</a></code> for names stored as &quot;Lastname, Firstname&quot;, and
<code><a href="#topic+parse_names">parse_names</a></code> to parse the output of this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_period("G.K.Chesterton")

</code></pre>

<hr>
<h2 id='format_reverse'>Reformat Reversed Names</h2><span id='topic+format_reverse'></span>

<h3>Description</h3>

<p>a common pattern for names is 'Lastname Suffix, Salutation Firstname' -
or to put that more practically, 'Jeffries PhD, Mr Bernard'. <code>format_reverse</code>
takes these reversed names and reformats them to a form that <code><a href="#topic+parse_names">parse_names</a></code>
can handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_reverse(names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_reverse_+3A_names">names</code></td>
<td>
<p>a vector of names following this convention. Names that lack commas will
be returned entirely intact, so assuming you don't have (legitimate) commas in names
not following this format, there's no need to worry if your vector has mixed formatting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the reformatted names
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_names">parse_names</a></code>, which works more reliably if reversed names have
been reformatted, and <code><a href="#topic+format_period">format_period</a></code> for period-separated names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Take a reversed name and un-reverse it
format_reverse("Keyes, Oliver")

</code></pre>

<hr>
<h2 id='humaniformat'>A Parser for Human Names</h2><span id='topic+humaniformat'></span><span id='topic+humaniformat-package'></span>

<h3>Description</h3>

<p>Human names are complicated and nonstandard things. Humaniformat attempts to provide functions for parsing those names,
making a best-guess attempt to distinguish sub-components such as prefixes, suffixes, middle names and salutations.
</p>

<hr>
<h2 id='last_name'>Get or set a name's last name</h2><span id='topic+last_name'></span><span id='topic+last_name+3C-'></span>

<h3>Description</h3>

<p>as in the lubridate package, individual components of a name
can be both extracted or set using the relevant function call - see the
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_name(x)

last_name(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_name_+3A_x">x</code></td>
<td>
<p>a name, or vector of names</p>
</td></tr>
<tr><td><code id="last_name_+3A_value">value</code></td>
<td>
<p>a replacement value for x's last name.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+salutation">salutation</a></code>, <code><a href="#topic+first_name">first_name</a></code>, <code><a href="#topic+middle_name">middle_name</a></code>
and <code><a href="#topic+suffix">suffix</a></code> for other accessors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Get a last name
example_name &lt;- "Mr Jim Toby Jeffries"
last_name(example_name)

#Set a last name
last_name(example_name) &lt;- "Smith"
</code></pre>

<hr>
<h2 id='middle_name'>Get or set a name's middle name</h2><span id='topic+middle_name'></span><span id='topic+middle_name+3C-'></span>

<h3>Description</h3>

<p>as in the lubridate package, individual components of a name
can be both extracted or set using the relevant function call - see the
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>middle_name(x)

middle_name(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="middle_name_+3A_x">x</code></td>
<td>
<p>a name, or vector of names</p>
</td></tr>
<tr><td><code id="middle_name_+3A_value">value</code></td>
<td>
<p>a replacement value for x's middle name.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+salutation">salutation</a></code>, <code><a href="#topic+first_name">first_name</a></code>, <code><a href="#topic+last_name">last_name</a></code> 
and <code><a href="#topic+suffix">suffix</a></code> for other accessors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Get a middle name
example_name &lt;- "Mr Jim Toby Jeffries"
middle_name(example_name)

#Set a middle name
middle_name(example_name) &lt;- "Richard"
</code></pre>

<hr>
<h2 id='parse_names'>Parse Human Names</h2><span id='topic+parse_names'></span>

<h3>Description</h3>

<p>human names are complex things; sometimes people have honorifics, or not. Or a single middle name, or many. Or
a compound surname, or not a compound surname but 'PhD' at the end of their name, and augh.
</p>
<p><code>parse_names</code> provides a simple
function for taking consistently formatted human names and splitting them into <code>salutation</code>, <code>first_name</code>,
<code>middle_name</code>, <code>last_name</code> and <code>suffix</code>. It is capable of dealing with compound surnames, multiple middle names,
and similar variations, and is fully vectorised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_names(names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_names_+3A_names">names</code></td>
<td>
<p>a character vector of names to parse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the columns <code>salutation</code>, <code>first_name</code>,
<code>middle_name</code>, <code>last_name</code>, <code>suffix</code> and <code>full_name</code> (which contains the original name). In the
event that a name doesn't <em>have</em> a salutation, middle name, suffix, or so on, an NA will appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse a simple name
parse_names("Oliver Keyes")

# Parse a more complex name
parse_names("Hon. Oliver Timothy Keyes Esq.")

</code></pre>

<hr>
<h2 id='salutation'>Get or set a name's saltation</h2><span id='topic+salutation'></span><span id='topic+salutation+3C-'></span>

<h3>Description</h3>

<p>as in the lubridate package, individual components of a name
can be both extracted or set using the relevant function call - see the
examples. In the event that you attempt to set a component to NA, no modification
will be made; in the event that you try to get a component that isn't present, an
NA will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salutation(x)

salutation(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="salutation_+3A_x">x</code></td>
<td>
<p>a name, or vector of names</p>
</td></tr>
<tr><td><code id="salutation_+3A_value">value</code></td>
<td>
<p>a replacement value for x's salutation</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+first_name">first_name</a></code>, <code><a href="#topic+middle_name">middle_name</a></code>, <code><a href="#topic+last_name">last_name</a></code> 
and <code><a href="#topic+suffix">suffix</a></code> for other accessors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Get a salutation
example_name &lt;- "Mr Jim Jeffries"
salutation(example_name)

#Set a salutation
salutation(example_name) &lt;- "Prof"
</code></pre>

<hr>
<h2 id='suffix'>Get or set a name's suffix</h2><span id='topic+suffix'></span><span id='topic+suffix+3C-'></span>

<h3>Description</h3>

<p>as in the lubridate package, individual components of a name
can be both extracted or set using the relevant function call - see the
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suffix(x)

suffix(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suffix_+3A_x">x</code></td>
<td>
<p>a name, or vector of names</p>
</td></tr>
<tr><td><code id="suffix_+3A_value">value</code></td>
<td>
<p>a replacement value for x's suffix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+salutation">salutation</a></code>, <code><a href="#topic+first_name">first_name</a></code>, <code><a href="#topic+middle_name">middle_name</a></code>
and <code><a href="#topic+last_name">last_name</a></code> for other accessors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Get a suffix]
example_name &lt;- "Mr Jim Toby Jeffries Esq"
suffix(example_name)

#Set a suffix
suffix(example_name) &lt;- "PhD"
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
