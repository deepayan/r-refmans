<!DOCTYPE html><html><head><title>Help for package easyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {easyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%ni%'><p>Not-In</p></a></li>
<li><a href='#astext'><p>As Text</p></a></li>
<li><a href='#atype'><p>Auto-Type</p></a></li>
<li><a href='#begin'><p>Begin</p></a></li>
<li><a href='#binbyvol'><p>Bin by Volume</p></a></li>
<li><a href='#bindf'><p>Bind Rows with Factors</p></a></li>
<li><a href='#cache.init'><p>Initialize cache.</p></a></li>
<li><a href='#cache.ok'><p>Check Cache Status</p></a></li>
<li><a href='#cblind'><p>cblind</p></a></li>
<li><a href='#cc'><p>Concatenate.</p></a></li>
<li><a href='#char2fac'><p>Characters to Factors</p></a></li>
<li><a href='#charnum'><p>Check for Number Formatted as Character.</p></a></li>
<li><a href='#checkeq'><p>Check Value or Control Total</p></a></li>
<li><a href='#clear.cache'><p>Clear Cache</p></a></li>
<li><a href='#coalf'><p>Factor-friendly Coalesce</p></a></li>
<li><a href='#crun'><p>Concatenate and run.</p></a></li>
<li><a href='#ddiff'><p>Date difference (or difference in days).</p></a></li>
<li><a href='#dict'><p>Get Data Dictionary</p></a></li>
<li><a href='#drows'><p>Get Rows with Duplicates</p></a></li>
<li><a href='#ecopy'><p>Copy to Clipboard</p></a></li>
<li><a href='#eq'><p>NA-Friendly Equality Comparison</p></a></li>
<li><a href='#fac2char'><p>Factors to Characters</p></a></li>
<li><a href='#fjoinf'><p>Full Join with Factors</p></a></li>
<li><a href='#fldict'><p>Get Data Dictionary for Files in Folder</p></a></li>
<li><a href='#fmat'><p>Number Formatter</p></a></li>
<li><a href='#getbetterint'><p>Get better Int</p></a></li>
<li><a href='#getinfo'><p>Get Info</p></a></li>
<li><a href='#gr'><p>Golden Ratio</p></a></li>
<li><a href='#hashfiles'><p>Hash Files</p></a></li>
<li><a href='#headers_row'><p>Identify headers row.</p></a></li>
<li><a href='#ijoinf'><p>Inner Join with Factors</p></a></li>
<li><a href='#ischar'><p>Shorthand for is.character</p></a></li>
<li><a href='#isdate'><p>Shorthand for lubridate::is.Date</p></a></li>
<li><a href='#isfac'><p>Shorthand for is.factor</p></a></li>
<li><a href='#isnum'><p>Shorthand for is.numeric</p></a></li>
<li><a href='#isval'><p>Is Valid / Is a Value / NA NULL Check</p></a></li>
<li><a href='#jrepl'><p>Join and Replace Values.</p></a></li>
<li><a href='#left'><p>left</p></a></li>
<li><a href='#likedate'><p>Like Date</p></a></li>
<li><a href='#ljoinf'><p>Left Join with Factors</p></a></li>
<li><a href='#match.factors'><p>Match Factors.</p></a></li>
<li><a href='#mdiff'><p>Date Difference in Months</p></a></li>
<li><a href='#mid'><p>mid</p></a></li>
<li><a href='#na'><p>Shorthand for is.na</p></a></li>
<li><a href='#namesx'><p>Names Like</p></a></li>
<li><a href='#nan'><p>Shorthand for is.nan</p></a></li>
<li><a href='#nanull'><p>NA / NULL Check</p></a></li>
<li><a href='#nastrings'><p>NA Strings</p></a></li>
<li><a href='#null'><p>Shorthand for is.null</p></a></li>
<li><a href='#pad0'><p>Pad with Zeros</p></a></li>
<li><a href='#qdiff'><p>Date Difference in Quarters</p></a></li>
<li><a href='#rany_fixColNames'><p>Fix column names.</p></a></li>
<li><a href='#read.any'><p>Read Any File</p></a></li>
<li><a href='#read.txt'><p>Read File as Text</p></a></li>
<li><a href='#right'><p>right</p></a></li>
<li><a href='#runfolder'><p>Run Folder</p></a></li>
<li><a href='#rx'><p>Read Excel</p></a></li>
<li><a href='#save.cache'><p>Save Cache</p>
</p>
<p>Saves the arguments to a cache file, using the cache.num last checked with cache.ok.</p></a></li>
<li><a href='#sch'><p>Search a Data Frame.</p></a></li>
<li><a href='#spl'><p>Sample</p></a></li>
<li><a href='#states'><p>states</p></a></li>
<li><a href='#strx'><p>Structure with Like</p></a></li>
<li><a href='#sumnum'><p>Summarize All Numeric Columns</p></a></li>
<li><a href='#tcmsg'><p>tryCatch with Message</p></a></li>
<li><a href='#tcol'><p>Transpose at Column.</p></a></li>
<li><a href='#tcwarn'><p>tryCatch with warning</p></a></li>
<li><a href='#tobool'><p>Convert to Logical/Boolean</p></a></li>
<li><a href='#tochar'><p>Shorthand for as.character</p></a></li>
<li><a href='#todate'><p>Convert to Date</p></a></li>
<li><a href='#tonum'><p>Convert to Number</p></a></li>
<li><a href='#usepkg'><p>Use Package</p></a></li>
<li><a href='#validate.equal'><p>Validate Equal</p></a></li>
<li><a href='#w'><p>Write</p></a></li>
<li><a href='#xldate'><p>Convert Excel Number to Date</p></a></li>
<li><a href='#ydiff'><p>Date Difference in Years</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Helpful Functions from Oliver Wyman Actuarial Consulting</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryce Chamberlain &lt;bryce.chamberlain@oliverwyman.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Makes difficult operations easy. Includes these types of functions: 
    shorthand, type conversion, data wrangling, and work flow. 
    Also includes some helpful data objects: NA strings, U.S. state list, color blind charting colors. 
    Built and shared by Oliver Wyman Actuarial Consulting. Accepting proposed contributions through GitHub.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/oliver-wyman-actuarial/easyr">https://github.com/oliver-wyman-actuarial/easyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/oliver-wyman-actuarial/easyr/issues">https://github.com/oliver-wyman-actuarial/easyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, digest, dplyr, foreign, glue, Hmisc, lubridate,
methods, readxl, rlang, rprojroot, stringr, XML</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pdftools, qs, rstudioapi, testthat (&ge; 3.0.0), readxlsb</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 22:40:43 UTC; bryce.chamberlain</td>
</tr>
<tr>
<td>Author:</td>
<td>Oliver Wyman Actuarial Consulting [aut, cph],
  Bryce Chamberlain [aut, cre],
  Rajesh Sahasrabuddhe [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-09 16:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25ni+25'>Not-In</h2><span id='topic++25ni+25'></span>

<h3>Description</h3>

<p>Opposite of 
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>needle %ni% haystack
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25ni+2B25_+3A_needle">needle</code></td>
<td>
<p>Vector to search for.</p>
</td></tr>
<tr><td><code id="+2B25ni+2B25_+3A_haystack">haystack</code></td>
<td>
<p>Vector to search in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean vector/value of comparisons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(1,3,11) %ni% 1:10
</code></pre>

<hr>
<h2 id='astext'>As Text</h2><span id='topic+astext'></span>

<h3>Description</h3>

<p>Prints a vector as text you can copy and paste back into the code. Helpful for copying vectors into code for testing and validation.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>astext(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="astext_+3A_x">x</code></td>
<td>
<p>Vector to represent as text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector represented as a character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>astext( c( 1, 2, 4 ) )
astext( c( 'a', 'b', 'c' ) )
</code></pre>

<hr>
<h2 id='atype'>Auto-Type</h2><span id='topic+atype'></span>

<h3>Description</h3>

<p>Use easyr date and number and conversion functions to automatically convert data to the most useful type available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atype(
  x,
  auto_convert_dates = TRUE,
  allow_times = FALSE,
  check_numbers = TRUE,
  nazero = FALSE,
  check_logical = TRUE,
  isexcel = TRUE,
  stringsAsFactors = FALSE,
  nastrings = easyr::nastrings,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atype_+3A_x">x</code></td>
<td>
<p>Data to auto-type.</p>
</td></tr>
<tr><td><code id="atype_+3A_auto_convert_dates">auto_convert_dates</code></td>
<td>
<p>Choose to convert dates.</p>
</td></tr>
<tr><td><code id="atype_+3A_allow_times">allow_times</code></td>
<td>
<p>Choose if you want to get times. Only use this if your data has times, otherwise there is a small chance it will prevent proper date conversion.</p>
</td></tr>
<tr><td><code id="atype_+3A_check_numbers">check_numbers</code></td>
<td>
<p>Choose to convert numbers.</p>
</td></tr>
<tr><td><code id="atype_+3A_nazero">nazero</code></td>
<td>
<p>Convert NAs in numeric columns to 0.</p>
</td></tr>
<tr><td><code id="atype_+3A_check_logical">check_logical</code></td>
<td>
<p>Choose to convert numbers.</p>
</td></tr>
<tr><td><code id="atype_+3A_isexcel">isexcel</code></td>
<td>
<p>By default, we assume this data may have come from excel. This is to assist in date conversion from excel integers. If you know it didn't and are having issues with data conversion, set this to FALSE.</p>
</td></tr>
<tr><td><code id="atype_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Convert strings/characters to factors to save compute time, RAM/memory, and storage space.</p>
</td></tr>
<tr><td><code id="atype_+3A_nastrings">nastrings</code></td>
<td>
<p>Strings to consider NA.</p>
</td></tr>
<tr><td><code id="atype_+3A_exclude">exclude</code></td>
<td>
<p>Column name(s) to exclude.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Author: Bryce Chamberlain.
</p>


<h3>Value</h3>

<p>Data frame with column types automatically converted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data in all-characters.
x = data.frame(
     char = c( 'abc', 'def' ),
     num = c( '1', '2' ),
     date = c( '1/1/2018', '2018-2-01' ),
     na = c( NA, NA ),
     bool = c( 'TRUE', 'FALSE' ),
     stringsAsFactors = FALSE
)

# different atype options. Note how the output types change.
str( atype( x ) )
str( atype( x, exclude = 'date' ) )
str( atype( x, auto_convert_dates = FALSE ) )
str( atype( x, check_logical = FALSE ) )
</code></pre>

<hr>
<h2 id='begin'>Begin</h2><span id='topic+begin'></span>

<h3>Description</h3>

<p>Perform common operations before running a script. Includes clearing environment objects, disabling scientific notation, loading common packages, and setting the working directory to the location of the current file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>begin(
  wd = NULL,
  load = c("magrittr", "dplyr"),
  keep = NULL,
  scipen = FALSE,
  verbose = TRUE,
  repos = "http://cran.us.r-project.org"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="begin_+3A_wd">wd</code></td>
<td>
<p>Path to set as working directory. If blank, the location of the current file open in RStudio will be used if available. If FALSE, the working directory will not be changed.</p>
</td></tr>
<tr><td><code id="begin_+3A_load">load</code></td>
<td>
<p>Packages to load. If not available, they'll be installed.</p>
</td></tr>
<tr><td><code id="begin_+3A_keep">keep</code></td>
<td>
<p>Environment objects to keep. If blank, all objects will be removed from the environment.</p>
</td></tr>
<tr><td><code id="begin_+3A_scipen">scipen</code></td>
<td>
<p>Do scientific notation in output?</p>
</td></tr>
<tr><td><code id="begin_+3A_verbose">verbose</code></td>
<td>
<p>Print information about what the function is doing?</p>
</td></tr>
<tr><td><code id="begin_+3A_repos">repos</code></td>
<td>
<p>choose the URL to install from.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
begin()
</code></pre>

<hr>
<h2 id='binbyvol'>Bin by Volume</h2><span id='topic+binbyvol'></span>

<h3>Description</h3>

<p>Bins a numerical column according to another numerical column's volume.
For example if I want to bin a column &quot;Age&quot; (of people) into 10 deciles according to &quot;CountofPeople&quot; then I will get Age breakpoints returned by my function such that there is 10
This function handles NA's as their own separate bin, and handles any special values you want to separate out.
Author: Scott Sobel. Tech Review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binbyvol(df, groupby, vol, numbins)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binbyvol_+3A_df">df</code></td>
<td>
<p>(Data Frame) Your data.</p>
</td></tr>
<tr><td><code id="binbyvol_+3A_groupby">groupby</code></td>
<td>
<p>(Character) Name of the column you'll create cuts in. Must be the character name of a numeric column.</p>
</td></tr>
<tr><td><code id="binbyvol_+3A_vol">vol</code></td>
<td>
<p>(Character) Name of the column for which which each cut will have an equal percentage of volume.</p>
</td></tr>
<tr><td><code id="binbyvol_+3A_numbins">numbins</code></td>
<td>
<p>Number of bins to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Age breakpoints returned by my function such that there is 10
</p>


<h3>Examples</h3>

<pre><code class='language-R'># bin Sepal.Width according to Sepal.Length.
iris$bin &lt;- binbyvol(iris, 'Sepal.Width', 'Sepal.Length', 5)

# check the binning success.
aggregate( Sepal.Length ~ bin, data = iris, sum )
</code></pre>

<hr>
<h2 id='bindf'>Bind Rows with Factors</h2><span id='topic+bindf'></span>

<h3>Description</h3>

<p>Matches factor levels before binding rows. If factors have 0 levels it will change the column to character to avoid errors.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindf(..., sort.levels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bindf_+3A_...">...</code></td>
<td>
<p>data to be binded</p>
</td></tr>
<tr><td><code id="bindf_+3A_sort.levels">sort.levels</code></td>
<td>
<p>Sort the factor levels after combining them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binded data, with any factors modified to contain all levels in the binded data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create data where factors have different levels.
df1 = data.frame(
  factor1 = c( 'a', 'b', 'c' ),
  factor2 = c( 'high', 'medium', 'low' ),
  factor.join = c( '0349038u093843', '304359867893753', '3409783509735' ),
  numeric = c( 1, 2, 3 ),
  logical = c( TRUE, TRUE, TRUE )
)#' 
df2 = data.frame(
  factor1 = c( 'd', 'e', 'f' ),
  factor2 = c( 'low', 'medium', 'high' ),
  factor.join = c( '32532532536', '304359867893753', '32534745876' ),
  numeric = c( 4, 5, 6 ),
  logical = c( FALSE, FALSE, FALSE )
)

# bindf preserves factors but combines levels.
# factor-friendly functions default to ordered levels.
str( df1 )
str( bindf( df1, df2 ) )
</code></pre>

<hr>
<h2 id='cache.init'>Initialize cache.</h2><span id='topic+cache.init'></span>

<h3>Description</h3>

<p>Set cache info so easyr can manage the cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache.init(
  caches,
  at.path,
  verbose = TRUE,
  save.only = FALSE,
  skip.missing = TRUE,
  n_processes = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache.init_+3A_caches">caches</code></td>
<td>
<p>List of lists with properties name, depends.on. See example.</p>
</td></tr>
<tr><td><code id="cache.init_+3A_at.path">at.path</code></td>
<td>
<p>Where to save the cache. If NULL, a cache/ folder will be created in the current working directory.</p>
</td></tr>
<tr><td><code id="cache.init_+3A_verbose">verbose</code></td>
<td>
<p>Print via cat() information about cache operations.</p>
</td></tr>
<tr><td><code id="cache.init_+3A_save.only">save.only</code></td>
<td>
<p>Choose not to load the cache. Use this if you need to check cache validity in multiple spots but only want to load at the last check.</p>
</td></tr>
<tr><td><code id="cache.init_+3A_skip.missing">skip.missing</code></td>
<td>
<p>Passed to hashfiles, choose if an error occurs if a depends.on file isn't found.</p>
</td></tr>
<tr><td><code id="cache.init_+3A_n_processes">n_processes</code></td>
<td>
<p>Passed to qs to determine how many cores/workers to use when reading/saving data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># initialize a cache with 1 cache which depends on files in the current working directory.
# this will create a cache folder in your current working directory.
# then, you call functions to check and build the cache.
## Not run: 

  folder = system.file('extdata', package = 'easyr')
  cache.init(

   # Initial file read (raw except for renaming).
   caches = list(
     list( 
      name = 'prep-files',
      depends.on = paste0(folder, '/script.R')
     )
   ),

   at.path = paste0(tempdir(), '/cache')

  )


## End(Not run)
</code></pre>

<hr>
<h2 id='cache.ok'>Check Cache Status</h2><span id='topic+cache.ok'></span>

<h3>Description</h3>

<p>Check a cache and if necessary clear it to trigger a re-cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache.ok(cache.num, do.load = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache.ok_+3A_cache.num">cache.num</code></td>
<td>
<p>The index/number for the cache we are checking in the cache.info list.</p>
</td></tr>
<tr><td><code id="cache.ok_+3A_do.load">do.load</code></td>
<td>
<p>Load the cache if it is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicating if the cache is acceptable. FALSE indicates the cache doesn't exist or is invalid so code should be run again.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># check the first cache to see if it exists and dependent files haven't changed.
# if this is TRUE, code in brackets will get skipped and the cache will be loaded instead.
# set do.load = FALSE if you have multiple files that build a cache, 
#    to prevent multiple cache loads.
# output will be printed to the console to tell you if the cache was loaded or re-built.
## Not run: 
  if( ! cache.ok(1) ){

    # do stuff
  
    # if this is the final file for this cache, 
    #   end with save.cache to save passed objects as a cache.
    save.cache(iris)
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='cblind'>cblind</h2><span id='topic+cblind'></span>

<h3>Description</h3>

<p>Color pallette that is effective for color-blind clients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cblind
</code></pre>


<h3>Format</h3>

<p>Named vector of hex colors.
</p>

<hr>
<h2 id='cc'>Concatenate.</h2><span id='topic+cc'></span>

<h3>Description</h3>

<p>Shorthand function for paste.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc(..., sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to paste0. Typcially a list of vectors or values to be concatenated.</p>
</td></tr>
<tr><td><code id="cc_+3A_sep">sep</code></td>
<td>
<p>(Optional) Separator between concatenated items.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of pasted/concatenated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc( 1, 2, 4 )
x = data.frame( c1 = c( 1, 2, 4 ), c2 = c( 3, 5, 7 ) )
cc( x$c1, x$c2 )
cc( x$c1, x$c2, sep = '-' )
</code></pre>

<hr>
<h2 id='char2fac'>Characters to Factors</h2><span id='topic+char2fac'></span>

<h3>Description</h3>

<p>Convert all character columns in a data frame to factors.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2fac(x, sortlevels = FALSE, na_level = "(Missing)")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2fac_+3A_x">x</code></td>
<td>
<p>Data frame to modify.</p>
</td></tr>
<tr><td><code id="char2fac_+3A_sortlevels">sortlevels</code></td>
<td>
<p>Choose whether to sort levels. This is the default R behavior and is therefore likely faster, but it may change the order of the data and this can be problematic so the default is FALSE.</p>
</td></tr>
<tr><td><code id="char2fac_+3A_na_level">na_level</code></td>
<td>
<p>some functions don't like factors to have NAs so we replace NAs with this value for factors only. Set NULL to skip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with converted factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char2fac( iris )
</code></pre>

<hr>
<h2 id='charnum'>Check for Number Formatted as Character.</h2><span id='topic+charnum'></span>

<h3>Description</h3>

<p>Checks a vector or value to see if it is a number formatted as a character. Useful for checking columns formatted with $ or commas, etc.
Author: Bryce Chamberlain. Tech review: Dominic Dillingham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charnum(x, na_strings = easyr::nastrings, run_unique = TRUE, check_date = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charnum_+3A_x">x</code></td>
<td>
<p>Vector to check.</p>
</td></tr>
<tr><td><code id="charnum_+3A_na_strings">na_strings</code></td>
<td>
<p>Strings to consider NA.</p>
</td></tr>
<tr><td><code id="charnum_+3A_run_unique">run_unique</code></td>
<td>
<p>Convert to unique variables before checking. In some cases, this can make it take longer than necessary. In most, it will make it faster.</p>
</td></tr>
<tr><td><code id="charnum_+3A_check_date">check_date</code></td>
<td>
<p>Check for a date, in which case it isn't a number. If you have already checked a date and know it isn't, set this to FALSE to run faster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True/false value indicating if the vector is a number formatted as a character. Helpful for checking before calling easyr:tonum().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>charnum( c( 
   '123', '$50.02', '30%', '(300.01)', '-10', '1 230.4', NA, '-', '', "3.7999999999999999E-2" 
 ))
charnum( c( '123', 'abc', '30%', NA) )
# returns FALSE since this can be converted to a date:
charnum( c( '20180101' ))
</code></pre>

<hr>
<h2 id='checkeq'>Check Value or Control Total</h2><span id='topic+checkeq'></span>

<h3>Description</h3>

<p>Check actual versus expected values and get helpful metrics back.
Author: Bryce Chamberlain. Tech review: Lindsay Smeltzer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkeq(expected, actual, desc = "", acceptable_pct_diff = 1e-08, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkeq_+3A_expected">expected</code></td>
<td>
<p>The expected value of the metric.</p>
</td></tr>
<tr><td><code id="checkeq_+3A_actual">actual</code></td>
<td>
<p>The actual value of the metric.</p>
</td></tr>
<tr><td><code id="checkeq_+3A_desc">desc</code></td>
<td>
<p>(Optional) Description of the metric being checked.</p>
</td></tr>
<tr><td><code id="checkeq_+3A_acceptable_pct_diff">acceptable_pct_diff</code></td>
<td>
<p>(Optional) Acceptable percentage difference when checking values. Checked as an absolute value.</p>
</td></tr>
<tr><td><code id="checkeq_+3A_digits">digits</code></td>
<td>
<p>(Optional) Digits to round to. Without rounding you get errors from floating values. Set to NA to avoid rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Message (via cat) indicating success or errors out in case of failure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkeq(expected=100,actual=100,desc='A Match')
</code></pre>

<hr>
<h2 id='clear.cache'>Clear Cache</h2><span id='topic+clear.cache'></span>

<h3>Description</h3>

<p>Clears all caches or the cache related to the passed cache info list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear.cache(cache = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear.cache_+3A_cache">cache</code></td>
<td>
<p>The cache list to clear.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FALSE if a cache info list item is passed in order to assist other functions in returning this value, otherwise NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this will only have an effect if a current cache exists.
## Not run: 
  clear.cache()

## End(Not run)

</code></pre>

<hr>
<h2 id='coalf'>Factor-friendly Coalesce</h2><span id='topic+coalf'></span>

<h3>Description</h3>

<p>Coalesce function that matches and updates factor levels appropriately.
Checks each argument vector starting with the first until a non-NA value is found.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalf_+3A_...">...</code></td>
<td>
<p>Source vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(c(1:5, NA, NA, NA))
coalf(x, 0L)
</code></pre>

<hr>
<h2 id='crun'>Concatenate and run.</h2><span id='topic+crun'></span>

<h3>Description</h3>

<p>Concatenate arguments and run them as a command. Shorthand for eval( parse( text = paste0( ... ) ) ).
Consider also using base::get() which can be used to get an object from a string, but only if it already exists.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crun(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crun_+3A_...">...</code></td>
<td>
<p>Character(s) to be concatenated and run as a command.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>crun( 'print(', '"hello world!"', ')')
crun('T', 'RUE')
</code></pre>

<hr>
<h2 id='ddiff'>Date difference (or difference in days).</h2><span id='topic+ddiff'></span>

<h3>Description</h3>

<p>Date difference (or difference in days).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddiff(x, y, unit = "day", do.date.convert = TRUE, do.numeric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddiff_+3A_x">x</code></td>
<td>
<p>Vector of starting dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="ddiff_+3A_y">y</code></td>
<td>
<p>Vector of ending dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="ddiff_+3A_unit">unit</code></td>
<td>
<p>Character indicating what to use as the unit of difference. Values like d, y, m or day, year, month will work. Takes just the first letter in lower-case to determine unit.</p>
</td></tr>
<tr><td><code id="ddiff_+3A_do.date.convert">do.date.convert</code></td>
<td>
<p>Convert to dates before running the difference. If you know your columns are already dates, setting to FALSE will make your code run faster.</p>
</td></tr>
<tr><td><code id="ddiff_+3A_do.numeric">do.numeric</code></td>
<td>
<p>Convert the output to a number instead of a date difference object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddiff( lubridate::mdy( '1/1/2018' ), lubridate::mdy( '3/4/2018' ) )
</code></pre>

<hr>
<h2 id='dict'>Get Data Dictionary</h2><span id='topic+dict'></span>

<h3>Description</h3>

<p>Get information about a Data Frame or Data Table. Use getinfo to explore a single column instead.
If you like, use ecopy function or agument to copy to the clipboard so that it can be pasted into Excel. Otherwise it returns a data frame.
Author: Scott Sobel. Tech Review &amp; Modifications: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict(
  x,
  topn = 5,
  botn = 5,
  na.strings = easyr::nastrings,
  do.atype = TRUE,
  ecopy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dict_+3A_x">x</code></td>
<td>
<p>Data Frame or Data Table.</p>
</td></tr>
<tr><td><code id="dict_+3A_topn">topn</code></td>
<td>
<p>Number of top values to print.</p>
</td></tr>
<tr><td><code id="dict_+3A_botn">botn</code></td>
<td>
<p>Number of bottom values to print.</p>
</td></tr>
<tr><td><code id="dict_+3A_na.strings">na.strings</code></td>
<td>
<p>Strings to consider NA.</p>
</td></tr>
<tr><td><code id="dict_+3A_do.atype">do.atype</code></td>
<td>
<p>Auto-determine variable types. If your data already has types set, skip this to speed up the code.</p>
</td></tr>
<tr><td><code id="dict_+3A_ecopy">ecopy</code></td>
<td>
<p>Use ecopy function or agument to copy to the clipboard so that it can be pasted into Excel.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dict(iris)
</code></pre>

<hr>
<h2 id='drows'>Get Rows with Duplicates</h2><span id='topic+drows'></span>

<h3>Description</h3>

<p>Pulls all rows with duplicates in a column, not just the duplicate row.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drows(x, c, na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drows_+3A_x">x</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="drows_+3A_c">c</code></td>
<td>
<p>Column as vector or string.</p>
</td></tr>
<tr><td><code id="drows_+3A_na">na</code></td>
<td>
<p>Consider multiple NAs as duplicates?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rows from the data frame in which the column is duplicated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddt = bindf( cars, utils::head( cars, 10 ) )
drows( ddt, 'speed' )
</code></pre>

<hr>
<h2 id='ecopy'>Copy to Clipboard</h2><span id='topic+ecopy'></span>

<h3>Description</h3>

<p>Copies a data.frame or anything that can be converted into a data.frame. After running this, you can use ctrl+v or Edit &gt; Paste to paste it to another program, typically Excel.
A simple use case would be ecopy(names(df)) to copy the names of a data frame to the clipboard to paste to Excel or Outlook.
Author: Scott Sobel. Tech Review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecopy(x, showrowcolnames = c("cols", "rows", "both", "none"), show = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecopy_+3A_x">x</code></td>
<td>
<p>Object you'd like to copy to the clipboard.</p>
</td></tr>
<tr><td><code id="ecopy_+3A_showrowcolnames">showrowcolnames</code></td>
<td>
<p>(Optional) Show row and column names. Choose 'none', 'cols', 'rows', or 'both'.</p>
</td></tr>
<tr><td><code id="ecopy_+3A_show">show</code></td>
<td>
<p>(Optional Boolean)  Set to 'show' if you want to also print the object to the console.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ecopy( iris, showrowcolnames = "cols", show = 'show' )
ecopy(iris)
</code></pre>

<hr>
<h2 id='eq'>NA-Friendly Equality Comparison</h2><span id='topic+eq'></span>

<h3>Description</h3>

<p>Vectorized flexible equality comparison which considers NAs as a value. Returns TRUE if both values are NA, and FALSE when only one is NA. 
The standard == comparison returns NA in both of these cases and sometimes this is interpreted unexpectedly.
Author: Bryce Chamberlain. Tech Review: Maria Gonzalez.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eq(x, y, do.nanull.equal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eq_+3A_x">x</code></td>
<td>
<p>First vector/value for comparison.</p>
</td></tr>
<tr><td><code id="eq_+3A_y">y</code></td>
<td>
<p>Second vector/value for comparison.</p>
</td></tr>
<tr><td><code id="eq_+3A_do.nanull.equal">do.nanull.equal</code></td>
<td>
<p>Return TRUE if both inputs are NA or NULL (tested via easyr::nanull).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean vector/value of comparisons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(NA,'NA',1,2,'c') == c(NA,NA,1,2,'a') # regular equality check.
eq(c(NA,'NA',1,2,'c'),c(NA,NA,1,2,'a')) # check with eq.
</code></pre>

<hr>
<h2 id='fac2char'>Factors to Characters</h2><span id='topic+fac2char'></span>

<h3>Description</h3>

<p>Convert all factor columns in a data frame to characters.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac2char(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac2char_+3A_x">x</code></td>
<td>
<p>Data frame to modify.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with converted characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char2fac( iris )
</code></pre>

<hr>
<h2 id='fjoinf'>Full Join with Factors</h2><span id='topic+fjoinf'></span>

<h3>Description</h3>

<p>Matches factor levels before full join via merge.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fjoinf(
  data.left,
  data.right,
  by,
  sort.levels = TRUE,
  restrict.levels = FALSE,
  na_level = "(Missing)"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fjoinf_+3A_data.left">data.left</code></td>
<td>
<p>Left data. Only rows that matche the join will be included (may still result in duplication).</p>
</td></tr>
<tr><td><code id="fjoinf_+3A_data.right">data.right</code></td>
<td>
<p>Right data. All of this data will be preservered in the join (may also result in duplication).</p>
</td></tr>
<tr><td><code id="fjoinf_+3A_by">by</code></td>
<td>
<p>Columns to join on.</p>
</td></tr>
<tr><td><code id="fjoinf_+3A_sort.levels">sort.levels</code></td>
<td>
<p>Sort the factor levels after combining them.</p>
</td></tr>
<tr><td><code id="fjoinf_+3A_restrict.levels">restrict.levels</code></td>
<td>
<p>Often the joined data won't use all the levels in both datasets. Set to TRUE to remove factor levels that aren't in the joined data.</p>
</td></tr>
<tr><td><code id="fjoinf_+3A_na_level">na_level</code></td>
<td>
<p>some functions don't like factors to have NAs so we replace NAs with this value for factors only. Set NULL to skip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Joined data, with any factors modified to contain all levels in the joined data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df1 = data.frame(
  factor1 = c( 'a', 'b', 'c' ),
  factor2 = c( 'high', 'medium', 'low' ),
  factor.join = c( '0349038u093843', '304359867893753', '3409783509735' ),
  numeric = c( 1, 2, 3 ),
  logical = c( TRUE, TRUE, TRUE )
)

df2 = data.frame(
  factor1 = c( 'd', 'e', 'f' ),
  factor2 = c( 'low', 'medium', 'high' ),
  factor.join = c( '32532532536', '304359867893753', '32534745876' ),
  numeric = c( 4, 5, 6 ),
  logical = c( FALSE, FALSE, FALSE )
)

fjoinf( df1, df2, by = 'factor.join' )

</code></pre>

<hr>
<h2 id='fldict'>Get Data Dictionary for Files in Folder</h2><span id='topic+fldict'></span>

<h3>Description</h3>

<p>Get information about data files in a folder path. Use dict() on a single data frame or getinfo(0) to explore a single column.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fldict(
  folder = NULL,
  file.list = NULL,
  pattern = "^[^~]+[.](xls[xmb]?|csv|rds|xml)",
  ignore.case = TRUE,
  recursive = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fldict_+3A_folder">folder</code></td>
<td>
<p>File path of the folder to create a dictionary for. Pass either this or file.list. file.list will override this argument.</p>
</td></tr>
<tr><td><code id="fldict_+3A_file.list">file.list</code></td>
<td>
<p>List of files to create a combined dictionary for. Pass either this or folder. This will ovveride folder.</p>
</td></tr>
<tr><td><code id="fldict_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to match files in the folder. By default we use a pattern that matches read.any-compatible data files and skips temporary Office files. Passed to list.files.</p>
</td></tr>
<tr><td><code id="fldict_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Ignore case when checking pattern. Passed to list.files.</p>
</td></tr>
<tr><td><code id="fldict_+3A_recursive">recursive</code></td>
<td>
<p>Check files recursively. Passed to list.files.</p>
</td></tr>
<tr><td><code id="fldict_+3A_verbose">verbose</code></td>
<td>
<p>Print helpful information.</p>
</td></tr>
<tr><td><code id="fldict_+3A_...">...</code></td>
<td>
<p>Other arguments to read.any for reading in files. Consider using a first_column_name vector, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the properties:
</p>
<table>
<tr><td><code>s</code></td>
<td>
<p>Summary data of each dataset.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>Line data with a row for each column in each dataset.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
folder = system.file('extdata', package = 'easyr')
fl = fldict(folder)
names(fl)

fl$sheets
fl$columns

</code></pre>

<hr>
<h2 id='fmat'>Number Formatter</h2><span id='topic+fmat'></span>

<h3>Description</h3>

<p>Flexible number formatter for easier formatting from numbers and dates into characters for display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmat(
  x = NULL,
  type = c("auto", ",", "$", "%", ".", "mdy", "ymd", "date", "dollar", "dollars",
    "count", "percentage", "decimal"),
  do.return = c("formatted", "highcharter"),
  digits = NULL,
  with.unit = FALSE,
  do.date.sep = "/",
  do.remove.spaces = FALSE,
  digits.cutoff = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmat_+3A_x">x</code></td>
<td>
<p>Vector of values to convert. If retu</p>
</td></tr>
<tr><td><code id="fmat_+3A_type">type</code></td>
<td>
<p>Type of format to return. If do.return == 'highcharter' this is not required.</p>
</td></tr>
<tr><td><code id="fmat_+3A_do.return">do.return</code></td>
<td>
<p>Information to return. &quot;formatted&quot; returns a vector of formatted values.</p>
</td></tr>
<tr><td><code id="fmat_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding. If left blank, the funtion will guess at the best digits.</p>
</td></tr>
<tr><td><code id="fmat_+3A_with.unit">with.unit</code></td>
<td>
<p>For large numbers, choose to add a suffix for fewer characters, like M for million, etc.</p>
</td></tr>
<tr><td><code id="fmat_+3A_do.date.sep">do.date.sep</code></td>
<td>
<p>Separator for date formatting.</p>
</td></tr>
<tr><td><code id="fmat_+3A_do.remove.spaces">do.remove.spaces</code></td>
<td>
<p>Remove extra spaces in return.</p>
</td></tr>
<tr><td><code id="fmat_+3A_digits.cutoff">digits.cutoff</code></td>
<td>
<p>Amount at which to show 0 digits. Allows for flexibility of rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information requested via do.return.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fmat( 1000, 'dollar', digits = 2 )

</code></pre>

<hr>
<h2 id='getbetterint'>Get better Int</h2><span id='topic+getbetterint'></span>

<h3>Description</h3>

<p>Takes bucket names of binned values such as [1e3,2e3) or [0.1234567, 0.2) and formats the values nicely into values such as 1,000-2,000 or 0.12-0.20
Author: Scott Sobel. Tech Review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getbetterint(int)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getbetterint_+3A_int">int</code></td>
<td>
<p>Vector of character bucket names to transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of transformed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris$bin &lt;- binbyvol( iris, 'Sepal.Width', 'Sepal.Length', 5 )
getbetterint( iris$bin )
</code></pre>

<hr>
<h2 id='getinfo'>Get Info</h2><span id='topic+getinfo'></span>

<h3>Description</h3>

<p>Get information about a Column in a Data Frame or Data Table. Use getdatadict to explore all columns in a dataset instead.
Author: Scott Sobel. Tech Review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getinfo(
  df,
  colname,
  topn = 5,
  botn = 5,
  graph = TRUE,
  ordered = TRUE,
  display = TRUE,
  cutoff = 20,
  main = NULL,
  cex = 0.9,
  xcex = 0.9,
  bins = 50,
  col = "light blue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getinfo_+3A_df">df</code></td>
<td>
<p>Data Frame or Data Table.</p>
</td></tr>
<tr><td><code id="getinfo_+3A_colname">colname</code></td>
<td>
<p>(Character) Name of the column to get information about.</p>
</td></tr>
<tr><td><code id="getinfo_+3A_topn">topn</code></td>
<td>
<p>(Optional) Number of top values to print.</p>
</td></tr>
<tr><td><code id="getinfo_+3A_botn">botn</code></td>
<td>
<p>(Optional) Number of bottom values to print.</p>
</td></tr>
<tr><td><code id="getinfo_+3A_graph">graph</code></td>
<td>
<p>(Boolean Optional) Output a chart of the column.</p>
</td></tr>
<tr><td><code id="getinfo_+3A_ordered">ordered</code></td>
<td>
<p>(Optional)</p>
</td></tr>
<tr><td><code id="getinfo_+3A_display">display</code></td>
<td>
<p>(Optional)</p>
</td></tr>
<tr><td><code id="getinfo_+3A_cutoff">cutoff</code></td>
<td>
<p>(Optional)</p>
</td></tr>
<tr><td><code id="getinfo_+3A_main">main</code></td>
<td>
<p>(Optional)</p>
</td></tr>
<tr><td><code id="getinfo_+3A_cex">cex</code></td>
<td>
<p>(Optional)</p>
</td></tr>
<tr><td><code id="getinfo_+3A_xcex">xcex</code></td>
<td>
<p>(Optional)</p>
</td></tr>
<tr><td><code id="getinfo_+3A_bins">bins</code></td>
<td>
<p>(Optional)</p>
</td></tr>
<tr><td><code id="getinfo_+3A_col">col</code></td>
<td>
<p>(Optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Only if display = FALSE, returns information about the column. Otherwise information comes through the graphing pane and the console (via cat/print).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getinfo(iris,'Sepal.Width')
getinfo(iris,'Species')
</code></pre>

<hr>
<h2 id='gr'>Golden Ratio</h2><span id='topic+gr'></span>

<h3>Description</h3>

<p>Get the golden ratio.
Author: Bryce Chamberlain. Tech Review: Maria Gonzalez.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr()
</code></pre>


<h3>Value</h3>

<p>The golden ratio: (1+sqrt(5)) / 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gr()
</code></pre>

<hr>
<h2 id='hashfiles'>Hash Files</h2><span id='topic+hashfiles'></span>

<h3>Description</h3>

<p>Get a hash value representing a list of files. Useful for determining if files have changed in order to reset dependent caches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hashfiles(
  x,
  skip.missing = FALSE,
  full.hash = FALSE,
  verbose = FALSE,
  skiptemp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hashfiles_+3A_x">x</code></td>
<td>
<p>Input which specifies which files to hash. This can be a vector mix of paths and files.</p>
</td></tr>
<tr><td><code id="hashfiles_+3A_skip.missing">skip.missing</code></td>
<td>
<p>Skip missing files. Default is to throw an error if a file isn't found.</p>
</td></tr>
<tr><td><code id="hashfiles_+3A_full.hash">full.hash</code></td>
<td>
<p>By default we just hash the file info (name, size, created/modified time). Set this to TRUE to read the file and hash the contents.</p>
</td></tr>
<tr><td><code id="hashfiles_+3A_verbose">verbose</code></td>
<td>
<p>Print helpful messages from code.</p>
</td></tr>
<tr><td><code id="hashfiles_+3A_skiptemp">skiptemp</code></td>
<td>
<p>Skip temporary MS Office files like &quot;~$Simd Loss Eval 2018-06-30.xlsx&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String representing hash of files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder = system.file('extdata', package = 'easyr')
hashfiles(folder)
</code></pre>

<hr>
<h2 id='headers_row'>Identify headers row.</h2><span id='topic+headers_row'></span>

<h3>Description</h3>

<p>Identify the row with headers in a data frame.
It should NOT be used directly (that's why it isn't exported), but will be called by function [read.any] as necessary, with the applicable defaults set by that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headers_row(
  x,
  headers_on_row = NA,
  first_column_name = NA,
  field_name_map = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headers_row_+3A_x">x</code></td>
<td>
<p>Data frame to work with.</p>
</td></tr>
<tr><td><code id="headers_row_+3A_headers_on_row">headers_on_row</code></td>
<td>
<p>The specific row with headers on it.</p>
</td></tr>
<tr><td><code id="headers_row_+3A_first_column_name">first_column_name</code></td>
<td>
<p>A known column(s) that can be used to find the header row. This is more flexible, but only used if headers_on_row is not available. If multiple are possible, use a vector argument here.</p>
</td></tr>
<tr><td><code id="headers_row_+3A_field_name_map">field_name_map</code></td>
<td>
<p>field_name_map from read.any.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with headers_already_column_names (TRUE/FALSE); headers_on_row (1-indexed number of the to match standard R indexing).
</p>

<hr>
<h2 id='ijoinf'>Inner Join with Factors</h2><span id='topic+ijoinf'></span>

<h3>Description</h3>

<p>Matches factor levels before inner join via merge.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ijoinf(
  data.left,
  data.right,
  by,
  sort.levels = TRUE,
  restrict.levels = FALSE,
  na_level = "(Missing)"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ijoinf_+3A_data.left">data.left</code></td>
<td>
<p>Left data. Only rows that matche the join will be included (may still result in duplication).</p>
</td></tr>
<tr><td><code id="ijoinf_+3A_data.right">data.right</code></td>
<td>
<p>Right data. Only rows that matche the join will be included (may also result in duplication).</p>
</td></tr>
<tr><td><code id="ijoinf_+3A_by">by</code></td>
<td>
<p>Columns to join on.</p>
</td></tr>
<tr><td><code id="ijoinf_+3A_sort.levels">sort.levels</code></td>
<td>
<p>Sort the factor levels after combining them.</p>
</td></tr>
<tr><td><code id="ijoinf_+3A_restrict.levels">restrict.levels</code></td>
<td>
<p>Often the joined data won't use all the levels in both datasets. Set to TRUE to remove factor levels that aren't in the joined data.</p>
</td></tr>
<tr><td><code id="ijoinf_+3A_na_level">na_level</code></td>
<td>
<p>some functions don't like factors to have NAs so we replace NAs with this value for factors only. Set NULL to skip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Joined data, with any factors modified to contain all levels in the joined data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df1 = data.frame(
  factor1 = c( 'a', 'b', 'c' ),
  factor2 = c( 'high', 'medium', 'low' ),
  factor.join = c( '0349038u093843', '304359867893753', '3409783509735' ),
  numeric = c( 1, 2, 3 ),
  logical = c( TRUE, TRUE, TRUE )
)

df2 = data.frame(
  factor1 = c( 'd', 'e', 'f' ),
  factor2 = c( 'low', 'medium', 'high' ),
  factor.join = c( '32532532536', '304359867893753', '32534745876' ),
  numeric = c( 4, 5, 6 ),
  logical = c( FALSE, FALSE, FALSE )
)

ljoinf( df1, df2, by = 'factor.join' )

</code></pre>

<hr>
<h2 id='ischar'>Shorthand for is.character</h2><span id='topic+ischar'></span>

<h3>Description</h3>

<p>Shorthand for is.character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ischar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ischar_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ischar( 'a character' )
ischar(1)
</code></pre>

<hr>
<h2 id='isdate'>Shorthand for lubridate::is.Date</h2><span id='topic+isdate'></span>

<h3>Description</h3>

<p>Shorthand for lubridate::is.Date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isdate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isdate_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isdate( lubridate::mdy( '10/1/2014' ) )
isdate(1)
</code></pre>

<hr>
<h2 id='isfac'>Shorthand for is.factor</h2><span id='topic+isfac'></span>

<h3>Description</h3>

<p>Shorthand for is.factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isfac(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isfac_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isfac( factor( c( 'a', 'b', 'c' ) ) )
isfac(1)
</code></pre>

<hr>
<h2 id='isnum'>Shorthand for is.numeric</h2><span id='topic+isnum'></span>

<h3>Description</h3>

<p>Shorthand for is.numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isnum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isnum_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isnum(1)
isnum( factor( c( 'a', 'b', 'c' ) ) )
</code></pre>

<hr>
<h2 id='isval'>Is Valid / Is a Value / NA NULL Check</h2><span id='topic+isval'></span>

<h3>Description</h3>

<p>Facilitates checking for missing values which may cause errors later in code. 
NULL values can cause errors on is.na checks, and is.na can cause warnings if it is inside if() and is passed multiple values.
This function makes it easier to check for missing values before trying to operate on a variable. 
It will NOT check for strings like &quot;&quot;  or &quot;NA&quot;. Only NULL and NA values will return TRUE.
Author: Bryce Chamberlain. Tech Review: Maria Gonzalez.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isval(x, na_strings = easyr::nastrings, do.test.each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isval_+3A_x">x</code></td>
<td>
<p>Object to check. In the case of a data frame or vector, it will check the first (non-NULL) value.</p>
</td></tr>
<tr><td><code id="isval_+3A_na_strings">na_strings</code></td>
<td>
<p>(Optional) Set the strings you want to consider NA. These will be applied after stringr::str_trim on x.</p>
</td></tr>
<tr><td><code id="isval_+3A_do.test.each">do.test.each</code></td>
<td>
<p>Return a vector of results to check each element instead of checking the entire object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True/false indicating if the argument is NA, NULL, or an empty/NA string/vector. For speect, only the first value is checked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isval( NULL )
isval( NA )
isval( c( NA , NULL ) )
isval( c( 1, 2, 3 ) )
isval( c( NA, 2, 3 ) )
isval( c( 1, 2, NA ) ) # only the first values is checked, so this will come back FALSE.
isval( c( NULL, 2, 3 ) ) # NULL values get skipped in a vector.
isval( data.frame() )
isval( dplyr::group_by( dplyr::select( cars, speed, dist ), speed ) ) # test a tibble.
isval( "#VALUE!" ) # test an excel error code.
</code></pre>

<hr>
<h2 id='jrepl'>Join and Replace Values.</h2><span id='topic+jrepl'></span>

<h3>Description</h3>

<p>Replace a columns values with matches in a different dataset.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jrepl(
  x,
  y,
  by,
  replace.cols,
  na.only = FALSE,
  only.rows = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jrepl_+3A_x">x</code></td>
<td>
<p>Main dataset which will have new values. This data set will be returned with new values.</p>
</td></tr>
<tr><td><code id="jrepl_+3A_y">y</code></td>
<td>
<p>Supporting dataset which has the id and new values.</p>
</td></tr>
<tr><td><code id="jrepl_+3A_by">by</code></td>
<td>
<p>Vector of join column names. A character vector if the names match. A named character vector if they don't.</p>
</td></tr>
<tr><td><code id="jrepl_+3A_replace.cols">replace.cols</code></td>
<td>
<p>Vector of replacement column names, similar format as by.</p>
</td></tr>
<tr><td><code id="jrepl_+3A_na.only">na.only</code></td>
<td>
<p>Only replace values that are NA.</p>
</td></tr>
<tr><td><code id="jrepl_+3A_only.rows">only.rows</code></td>
<td>
<p>Select rows to be affected. Default checks all rows.</p>
</td></tr>
<tr><td><code id="jrepl_+3A_verbose">verbose</code></td>
<td>
<p>Print via cat information about the replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with new values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df1 = utils::head( sleep )
group.reassign = data.frame( 
  id.num = factor( c( 1, 3, 4 ) ), 
group.replace = factor( c( 99, 99, 99 ) ) 
)

jrepl( 
  x = df1, 
  y = group.reassign, 
  by = c( 'ID' = 'id.num' ), 
  replace.cols = c( 'group' = 'group.replace' ) 
)

# doesn't affect since there are no NAs in group.
jrepl( 
  x = df1,
  y = group.reassign, 
  by = c( 'ID' = 'id.num' ), 
  replace.cols = c( 'group' = 'group.replace' ), 
  na.only = TRUE  
) 
</code></pre>

<hr>
<h2 id='left'>left</h2><span id='topic+left'></span>

<h3>Description</h3>

<p>Behaves like Excel's LEFT, RIGHT, and MID functions
Author: Dave. Tech review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left(string, char)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="left_+3A_string">string</code></td>
<td>
<p>String to process.</p>
</td></tr>
<tr><td><code id="left_+3A_char">char</code></td>
<td>
<p>Number of characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>left( "leftmidright", 4 )
</code></pre>

<hr>
<h2 id='likedate'>Like Date</h2><span id='topic+likedate'></span>

<h3>Description</h3>

<p>Check if a column can be converted to a date. Helpful for checking a column before actually converting it.
Author: Bryce Chamberlain. Tech review: Dominic Dillingham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likedate(
  x,
  na_strings = easyr::nastrings,
  run_unique = TRUE,
  aggressive.extraction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likedate_+3A_x">x</code></td>
<td>
<p>Value or vector to check.</p>
</td></tr>
<tr><td><code id="likedate_+3A_na_strings">na_strings</code></td>
<td>
<p>Vector of characters to consider NA. Like Date will treat these values like NA.</p>
</td></tr>
<tr><td><code id="likedate_+3A_run_unique">run_unique</code></td>
<td>
<p>Convert to unique variables before checking. In some cases, this can make it take longer than necessary. In most, it will make it faster.</p>
</td></tr>
<tr><td><code id="likedate_+3A_aggressive.extraction">aggressive.extraction</code></td>
<td>
<p>todate will take dates inside long strings (like filenames) and convert them to dates. This seems to be the preferred outcome, so we leave it as default (TRUE). However, if you want to avoid this you can do so via this option (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicating if the entire vector can be converted to a date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c('20171124','2017/12/24',NA,'12/24/2017','March 3rd, 2015','Mar 3, 2016')
likedate(x)
likedate(c(123,456,NA))
if(likedate(x)) t &lt;- todate(x)
likedate(lubridate::mdy('1-1-2014'))
likedate( '3312019' )
likedate( '2019.1.3' )
</code></pre>

<hr>
<h2 id='ljoinf'>Left Join with Factors</h2><span id='topic+ljoinf'></span>

<h3>Description</h3>

<p>Matches factor levels before left join via merge.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ljoinf(
  data.left,
  data.right,
  by,
  sort.levels = TRUE,
  restrict.levels = FALSE,
  na_level = "(Missing)"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ljoinf_+3A_data.left">data.left</code></td>
<td>
<p>Left data. All of this data will be preservered in the join (may still result in duplication).</p>
</td></tr>
<tr><td><code id="ljoinf_+3A_data.right">data.right</code></td>
<td>
<p>Right data. Only rows that matche the join will be included (may also result in duplication).</p>
</td></tr>
<tr><td><code id="ljoinf_+3A_by">by</code></td>
<td>
<p>Columns to join on.</p>
</td></tr>
<tr><td><code id="ljoinf_+3A_sort.levels">sort.levels</code></td>
<td>
<p>Sort the factor levels after combining them.</p>
</td></tr>
<tr><td><code id="ljoinf_+3A_restrict.levels">restrict.levels</code></td>
<td>
<p>Often the joined data won't use all the levels in both datasets. Set to TRUE to remove factor levels that aren't in the joined data.</p>
</td></tr>
<tr><td><code id="ljoinf_+3A_na_level">na_level</code></td>
<td>
<p>some functions don't like factors to have NAs so we replace NAs with this value for factors only. Set NULL to skip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Joined data, with any factors modified to contain all levels in the joined data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df1 = data.frame(
  factor1 = c( 'a', 'b', 'c' ),
  factor2 = c( 'high', 'medium', 'low' ),
  factor.join = c( '0349038u093843', '304359867893753', '3409783509735' ),
  numeric = c( 1, 2, 3 ),
  logical = c( TRUE, TRUE, TRUE )
)

df2 = data.frame(
  factor1 = c( 'd', 'e', 'f' ),
  factor2 = c( 'low', 'medium', 'high' ),
  factor.join = c( '32532532536', '304359867893753', '32534745876' ),
  numeric = c( 4, 5, 6 ),
  logical = c( FALSE, FALSE, FALSE )
)

ljoinf( df1, df2, by = 'factor.join' )

</code></pre>

<hr>
<h2 id='match.factors'>Match Factors.</h2><span id='topic+match.factors'></span>

<h3>Description</h3>

<p>Modifies two datasets so matching factor columns have the same levels. Typically this is used prior to joining or bind_rows in the easyr functions bindf, ijoinf, lfjoinf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.factors(df1, df2, by = NA, sort.levels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.factors_+3A_df1">df1</code></td>
<td>
<p>First data set.</p>
</td></tr>
<tr><td><code id="match.factors_+3A_df2">df2</code></td>
<td>
<p>Second data set.</p>
</td></tr>
<tr><td><code id="match.factors_+3A_by">by</code></td>
<td>
<p>Columns to join on, comes from the function using match.factors (ljoinf, fjoinf, ijoinf).</p>
</td></tr>
<tr><td><code id="match.factors_+3A_sort.levels">sort.levels</code></td>
<td>
<p>Sort the factor levels after combining them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the same data but with factors modified as applicable. All factors are checked if no 'by' argument is passed. Otherwise only the 'by' argument is checked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df1 = data.frame(
  factor1 = c( 'a', 'b', 'c' ),
  factor2 = c( 'high', 'medium', 'low' ),
  factor.join = c( '0349038u093843', '304359867893753', '3409783509735' ),
  numeric = c( 1, 2, 3 ),
  logical = c( TRUE, TRUE, TRUE )
)

df2 = data.frame(
  factor1 = c( 'd', 'e', 'f' ),
  factor2 = c( 'low', 'medium', 'high' ),
  factor.join = c( '32532532536', '304359867893753', '32534745876' ),
  numeric = c( 4, 5, 6 ),
  logical = c( FALSE, FALSE, FALSE )
)

t = match.factors( df1, df2 )
levels( df1$factor1 )
levels( t[[1]]$factor1 )
levels( t[[2]]$factor1 )

</code></pre>

<hr>
<h2 id='mdiff'>Date Difference in Months</h2><span id='topic+mdiff'></span>

<h3>Description</h3>

<p>Date Difference in Months
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdiff(x, y, do.date.convert = TRUE, do.numeric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdiff_+3A_x">x</code></td>
<td>
<p>Vector of starting dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="mdiff_+3A_y">y</code></td>
<td>
<p>Vector of ending dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="mdiff_+3A_do.date.convert">do.date.convert</code></td>
<td>
<p>Convert to dates before running the difference. If you know your columns are already dates, setting to FALSE will make your code run faster.</p>
</td></tr>
<tr><td><code id="mdiff_+3A_do.numeric">do.numeric</code></td>
<td>
<p>Convert the output to a number instead of a date difference object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdiff( lubridate::mdy( '1/1/2018' ), lubridate::mdy( '3/4/2018' ) )
</code></pre>

<hr>
<h2 id='mid'>mid</h2><span id='topic+mid'></span>

<h3>Description</h3>

<p>Behaves like Excel's LEFT, RIGHT, and MID functions
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mid(string, start, nchars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mid_+3A_string">string</code></td>
<td>
<p>String to process.</p>
</td></tr>
<tr><td><code id="mid_+3A_start">start</code></td>
<td>
<p>Index (1-index) to start at.</p>
</td></tr>
<tr><td><code id="mid_+3A_nchars">nchars</code></td>
<td>
<p>Number of characters to read in from start.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mid( "leftmidright", 5, 3 )
</code></pre>

<hr>
<h2 id='na'>Shorthand for is.na</h2><span id='topic+na'></span>

<h3>Description</h3>

<p>Shorthand for is.na
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na(NA)
na(1)
</code></pre>

<hr>
<h2 id='namesx'>Names Like</h2><span id='topic+namesx'></span>

<h3>Description</h3>

<p>Get column names that match a pattern.
Author: Scott Sobel. Tech review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namesx(df, char, fixed = TRUE, ignore.case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="namesx_+3A_df">df</code></td>
<td>
<p>Object with names you'd like to search.</p>
</td></tr>
<tr><td><code id="namesx_+3A_char">char</code></td>
<td>
<p>Regex chracter to match to columns.</p>
</td></tr>
<tr><td><code id="namesx_+3A_fixed">fixed</code></td>
<td>
<p>Match as a string, not a regular expression.</p>
</td></tr>
<tr><td><code id="namesx_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Ignore case in matches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of matched names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namesx( iris,'len' )
namesx( iris,'Len' )
</code></pre>

<hr>
<h2 id='nan'>Shorthand for is.nan</h2><span id='topic+nan'></span>

<h3>Description</h3>

<p>Shorthand for is.nan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nan_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nan( NaN )
nan(1)
</code></pre>

<hr>
<h2 id='nanull'>NA / NULL Check</h2><span id='topic+nanull'></span>

<h3>Description</h3>

<p>Facilitates checking for missing values which may cause errors later in code. 
NULL values can cause errors on is.na checks, and is.na can cause warnings if it is inside if() and is passed multiple values.
This function makes it easier to check for missing values before trying to operate on a variable. 
It will NOT check for strings like &quot;&quot;  or &quot;NA&quot;. Only NULL and NA values will return TRUE.
Author: Bryce Chamberlain. Tech Review: Maria Gonzalez.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanull(x, na_strings = easyr::nastrings, do.test.each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanull_+3A_x">x</code></td>
<td>
<p>Vector to check. In the case of a data frame or vector, it will check the first (non-NULL) value.</p>
</td></tr>
<tr><td><code id="nanull_+3A_na_strings">na_strings</code></td>
<td>
<p>(Optional) Set the strings you want to consider NA. These will be applied after stringr::str_trim on x.</p>
</td></tr>
<tr><td><code id="nanull_+3A_do.test.each">do.test.each</code></td>
<td>
<p>Return a vector of results to check each element instead of checking the entire object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True/false indicating if the argument is NA, NULL, or an empty/NA string/vector. For speect, only the first value is checked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nanull( NULL )
nanull( NA )
nanull( c( NA , NULL ) )
nanull( c( 1, 2, 3 ) )
nanull( c( NA, 2, 3 ) )
nanull( c( 1, 2, NA ) ) # only the first values is checked, so this will come back FALSE.
nanull( c( NULL, 2, 3 ) ) # NULL values get skipped in a vector.
nanull( data.frame() )
nanull( dplyr::group_by( dplyr::select( cars, speed, dist ), speed ) ) # test a tibble.
</code></pre>

<hr>
<h2 id='nastrings'>NA Strings</h2><span id='topic+nastrings'></span>

<h3>Description</h3>

<p>A list of strings to consider NA. Includes blank string, &quot;NA&quot;, excel errors, etc. Used throughout easyr for checking NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nastrings
</code></pre>


<h3>Format</h3>

<p>A vector of values.
</p>

<hr>
<h2 id='null'>Shorthand for is.null</h2><span id='topic+null'></span>

<h3>Description</h3>

<p>Shorthand for is.null
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>null( NULL )
null(1)
</code></pre>

<hr>
<h2 id='pad0'>Pad with Zeros</h2><span id='topic+pad0'></span>

<h3>Description</h3>

<p>Adds leading zeros to a numeric vector to make each value a specific length. For values shorter than length passed, leading zeros are removed.
Author: Scott Sobel. Tech Review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad0(x, len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad0_+3A_x">x</code></td>
<td>
<p>Vector.</p>
</td></tr>
<tr><td><code id="pad0_+3A_len">len</code></td>
<td>
<p>Number of characters you want in each value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with padded values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pad0( c(123,00123,5), len = 5 )
pad0( c(123,00123,5), len = 2 )
pad0( '1234', 5 )
</code></pre>

<hr>
<h2 id='qdiff'>Date Difference in Quarters</h2><span id='topic+qdiff'></span>

<h3>Description</h3>

<p>Date Difference in Quarters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdiff(x, y, do.date.convert = TRUE, do.numeric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdiff_+3A_x">x</code></td>
<td>
<p>Vector of starting dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="qdiff_+3A_y">y</code></td>
<td>
<p>Vector of ending dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="qdiff_+3A_do.date.convert">do.date.convert</code></td>
<td>
<p>Convert to dates before running the difference. If you know your columns are already dates, setting to FALSE will make your code run faster.</p>
</td></tr>
<tr><td><code id="qdiff_+3A_do.numeric">do.numeric</code></td>
<td>
<p>Convert the output to a number instead of a date difference object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qdiff( lubridate::mdy( '1/1/2018' ), lubridate::mdy( '3/4/2018' ) )
</code></pre>

<hr>
<h2 id='rany_fixColNames'>Fix column names.</h2><span id='topic+rany_fixColNames'></span>

<h3>Description</h3>

<p>Code to fix column names, since this has to be done up to twice will reading in files.
It should NOT be used directly (that's why it isn't exported), but will be called by function [read.any] as necessary, with the applicable defaults set by that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rany_fixColNames(col_names, fix.dup.column.names, nastrings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rany_fixColNames_+3A_col_names">col_names</code></td>
<td>
<p>Vector/value of colum names/name.</p>
</td></tr>
<tr><td><code id="rany_fixColNames_+3A_fix.dup.column.names">fix.dup.column.names</code></td>
<td>
<p>Adds 'DUPLICATE #' to duplicated column names to avoid errors with duplicate names.</p>
</td></tr>
<tr><td><code id="rany_fixColNames_+3A_nastrings">nastrings</code></td>
<td>
<p>Characters/strings to read as NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fixed names.
</p>

<hr>
<h2 id='read.any'>Read Any File</h2><span id='topic+read.any'></span>

<h3>Description</h3>

<p>Flexible read function to handle many types of files. Currently handles CSV, TSV, DBF, RDS, XLS (incl. when formatted as HTML), and XLSX.
Also handles common issues like strings being read in as factors (strings are NOT read in as factors by this function, you'd need to convert them later). 
Author: Bryce Chamberlain. Tech Review: Dominic Dillingham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.any(
  filename = NA,
  folder = NA,
  sheet = 1,
  file_type = "",
  first_column_name = NA,
  header = TRUE,
  headers_on_row = NA,
  nrows = -1L,
  row.names.column = NA,
  row.names.remove = TRUE,
  make.names = FALSE,
  field_name_map = NA,
  require_columns = NA,
  all_chars = FALSE,
  auto_convert_dates = TRUE,
  allow_times = FALSE,
  check_numbers = TRUE,
  nazero = FALSE,
  check_logical = TRUE,
  stringsAsFactors = FALSE,
  na_strings = easyr::nastrings,
  na_level = "(Missing)",
  ignore_rows_with_na_at = NA,
  drop.na.cols = TRUE,
  drop.na.rows = TRUE,
  fix.dup.column.names = TRUE,
  do.trim.sheetname = TRUE,
  x = NULL,
  isexcel = FALSE,
  encoding = "unknown",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.any_+3A_filename">filename</code></td>
<td>
<p>File path and name for the file to be read in.</p>
</td></tr>
<tr><td><code id="read.any_+3A_folder">folder</code></td>
<td>
<p>Folder path to look for the file in.</p>
</td></tr>
<tr><td><code id="read.any_+3A_sheet">sheet</code></td>
<td>
<p>The sheet to read in.</p>
</td></tr>
<tr><td><code id="read.any_+3A_file_type">file_type</code></td>
<td>
<p>Specify the file type (CSV, TSV, DBF). If not provided, R will use the file extension to determine the file type. Useful when the file extension doesn't indicate the file type, like .rpt, etc.</p>
</td></tr>
<tr><td><code id="read.any_+3A_first_column_name">first_column_name</code></td>
<td>
<p>Define headers location by providing the name of the left-most column. Alternatively, you can choose the row via the [headers_on_row] argument.</p>
</td></tr>
<tr><td><code id="read.any_+3A_header">header</code></td>
<td>
<p>Choose if your file contains headers.</p>
</td></tr>
<tr><td><code id="read.any_+3A_headers_on_row">headers_on_row</code></td>
<td>
<p>Choose a specific row number to use as headers. Use this when you want to tell read.any exactly where the headers are.</p>
</td></tr>
<tr><td><code id="read.any_+3A_nrows">nrows</code></td>
<td>
<p>Number of rows to read. Leave blank/NA to read all rows. This only speeds up file reads (CSV, XLSX, etc.), not compressed data that must be read all at once. This is applied BEFORe headers_on_row or first_column_name removes top rows, so it should be greater than those values if headers aren't in the first row.</p>
</td></tr>
<tr><td><code id="read.any_+3A_row.names.column">row.names.column</code></td>
<td>
<p>Specify the column (by character name) to use for row names. This drops the columns and lets rows be referenced directly with this id. Must be unique values.</p>
</td></tr>
<tr><td><code id="read.any_+3A_row.names.remove">row.names.remove</code></td>
<td>
<p>If you move a column to row names, it is removed from the data by default. If you'd like to keep it, set this to FALSE.</p>
</td></tr>
<tr><td><code id="read.any_+3A_make.names">make.names</code></td>
<td>
<p>Apply make.names function to make column names R-friendly (replaces non-characters with ., starting numbers with x, etc.)</p>
</td></tr>
<tr><td><code id="read.any_+3A_field_name_map">field_name_map</code></td>
<td>
<p>Rename fields for consistency. Provide as a named vector where the names are the file's names and the vector values are the output names desired. See examples for how to create this input.</p>
</td></tr>
<tr><td><code id="read.any_+3A_require_columns">require_columns</code></td>
<td>
<p>List of required columns to check for. Calls stop() with helpful message if any aren't found.</p>
</td></tr>
<tr><td><code id="read.any_+3A_all_chars">all_chars</code></td>
<td>
<p>Keep all column types as characters. This makes using bind_rows easer, then you can use atype() later to set types.</p>
</td></tr>
<tr><td><code id="read.any_+3A_auto_convert_dates">auto_convert_dates</code></td>
<td>
<p>Identify date fields and automatically convert them to dates</p>
</td></tr>
<tr><td><code id="read.any_+3A_allow_times">allow_times</code></td>
<td>
<p>imes are not allowed in reading data in to facilitate easy binding. If you need times though, set this to TRUE.</p>
</td></tr>
<tr><td><code id="read.any_+3A_check_numbers">check_numbers</code></td>
<td>
<p>Identfy numbers formatted as characters and convert them as such.</p>
</td></tr>
<tr><td><code id="read.any_+3A_nazero">nazero</code></td>
<td>
<p>Convert NAs in numeric columns to 0.</p>
</td></tr>
<tr><td><code id="read.any_+3A_check_logical">check_logical</code></td>
<td>
<p>Identfy logical columns formatted as characters (Yes/No, etc) or numbers (0,1) and convert them as such.</p>
</td></tr>
<tr><td><code id="read.any_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Convert characters to factors to increase processing speed and reduce file size.</p>
</td></tr>
<tr><td><code id="read.any_+3A_na_strings">na_strings</code></td>
<td>
<p>Strings to treat like NA. By default we use the easyr NA strings.</p>
</td></tr>
<tr><td><code id="read.any_+3A_na_level">na_level</code></td>
<td>
<p>dplyr doesn't like factors to have NAs so we replace NAs with this value for factors only. Set NULL to skip.</p>
</td></tr>
<tr><td><code id="read.any_+3A_ignore_rows_with_na_at">ignore_rows_with_na_at</code></td>
<td>
<p>Vector or value, numeric or character, identifying column(s) that require a value. read.any will remove these rows after colname swaps and read, before type conversion. Especially helpful for removing things like page numbers at the bottom of an excel report that break type discovery. Suggest using the claim number column here.</p>
</td></tr>
<tr><td><code id="read.any_+3A_drop.na.cols">drop.na.cols</code></td>
<td>
<p>Drop columns with only NA values.</p>
</td></tr>
<tr><td><code id="read.any_+3A_drop.na.rows">drop.na.rows</code></td>
<td>
<p>Drop rows with only NA values.</p>
</td></tr>
<tr><td><code id="read.any_+3A_fix.dup.column.names">fix.dup.column.names</code></td>
<td>
<p>Adds 'DUPLICATE #' to duplicated column names to avoid issues with multiple columns having the same name.</p>
</td></tr>
<tr><td><code id="read.any_+3A_do.trim.sheetname">do.trim.sheetname</code></td>
<td>
<p>read.any will trim sheet names to get better matches. This will cause an error if the actual sheet name has spaces on the left or right side. Disable this functionality here.</p>
</td></tr>
<tr><td><code id="read.any_+3A_x">x</code></td>
<td>
<p>If you want to use read.any functionality on an existing data frame, pass it with this argument.</p>
</td></tr>
<tr><td><code id="read.any_+3A_isexcel">isexcel</code></td>
<td>
<p>If you want to use read.any functionality on an existing data frame, you can tell read.any that this data came from excel using isexcel manually. This comes in handy when excel-integer date conversions are necessary.</p>
</td></tr>
<tr><td><code id="read.any_+3A_encoding">encoding</code></td>
<td>
<p>Encoding passed to fread and read.csv.</p>
</td></tr>
<tr><td><code id="read.any_+3A_verbose">verbose</code></td>
<td>
<p>Print helpful information via cat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the data that was read.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
folder = system.file('extdata', package = 'easyr')
read.any('date-time.csv', folder = folder)

# if dates are being converted incorrectly, disable date conversion:
read.any('date-time.csv', folder = folder, auto_convert_dates = FALSE)

# to handle type conversions manually:
read.any('date-time.csv', folder = folder, all_chars = TRUE)

</code></pre>

<hr>
<h2 id='read.txt'>Read File as Text</h2><span id='topic+read.txt'></span>

<h3>Description</h3>

<p>Read File as Text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.txt(filename, folder = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.txt_+3A_filename">filename</code></td>
<td>
<p>File path and name for the file to be read in.</p>
</td></tr>
<tr><td><code id="read.txt_+3A_folder">folder</code></td>
<td>
<p>Folder path to look for the file in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character variable containing the text in the file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# write a files.
path = tempfile()
cat( "some text", file = path )

# read the file.
read.txt( path )

# cleanum.
file.remove( path )

</code></pre>

<hr>
<h2 id='right'>right</h2><span id='topic+right'></span>

<h3>Description</h3>

<p>Behaves like Excel's LEFT, RIGHT, and MID functions
Author: Dave. Tech review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>right(string, char)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="right_+3A_string">string</code></td>
<td>
<p>String to process.</p>
</td></tr>
<tr><td><code id="right_+3A_char">char</code></td>
<td>
<p>Number of characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>right( "leftmidright",5 )
</code></pre>

<hr>
<h2 id='runfolder'>Run Folder</h2><span id='topic+runfolder'></span>

<h3>Description</h3>

<p>Run all the R scripts in a folder.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runfolder(
  path,
  recursive = FALSE,
  is.local = TRUE,
  check.fn = NULL,
  run.files = NULL,
  verbose = TRUE,
  edit.on.err = TRUE,
  pattern = "[.][Rr]$"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runfolder_+3A_path">path</code></td>
<td>
<p>Folder to run.</p>
</td></tr>
<tr><td><code id="runfolder_+3A_recursive">recursive</code></td>
<td>
<p>Run all folder children also.</p>
</td></tr>
<tr><td><code id="runfolder_+3A_is.local">is.local</code></td>
<td>
<p>Code is running on a local machine, not a Shiny server. Helpful for skipping items that can be problematic on the server. In this case, printing to the log.</p>
</td></tr>
<tr><td><code id="runfolder_+3A_check.fn">check.fn</code></td>
<td>
<p>Function to run after reach file is read-in.</p>
</td></tr>
<tr><td><code id="runfolder_+3A_run.files">run.files</code></td>
<td>
<p>Optionally pass the list of files to run. Otherwise, list.files will be run on the folder.</p>
</td></tr>
<tr><td><code id="runfolder_+3A_verbose">verbose</code></td>
<td>
<p>Print names of files and run-time via cat.</p>
</td></tr>
<tr><td><code id="runfolder_+3A_edit.on.err">edit.on.err</code></td>
<td>
<p>Open the running file if an error occurs.</p>
</td></tr>
<tr><td><code id="runfolder_+3A_pattern">pattern</code></td>
<td>
<p>Passed to list.files. Pattern to match/filter files.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># runfolder( 'R' )
</code></pre>

<hr>
<h2 id='rx'>Read Excel</h2><span id='topic+rx'></span>

<h3>Description</h3>

<p>This gets a bit complex since many errors can occur when reading in excel files. We've done our best to handle common ones.
Requires packages: openxlsx, readxl, XML (these are required by easyr).
It should NOT be used directly (that's why it isn't exported), but will be called by function [read.any] as necessary, with the applicable defaults set by that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx(filename, sheet, first_column_name, nrows, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_+3A_filename">filename</code></td>
<td>
<p>File path and name for the file to be read in.</p>
</td></tr>
<tr><td><code id="rx_+3A_sheet">sheet</code></td>
<td>
<p>The sheet to read in.</p>
</td></tr>
<tr><td><code id="rx_+3A_first_column_name">first_column_name</code></td>
<td>
<p>Pass a column name to help the function find the header row.</p>
</td></tr>
<tr><td><code id="rx_+3A_nrows">nrows</code></td>
<td>
<p>Number of rows to read in.</p>
</td></tr>
<tr><td><code id="rx_+3A_verbose">verbose</code></td>
<td>
<p>Print helpful messages via cat().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data object
</p>

<hr>
<h2 id='save.cache'>Save Cache
Saves the arguments to a cache file, using the cache.num last checked with cache.ok.</h2><span id='topic+save.cache'></span>

<h3>Description</h3>

<p>Save Cache
</p>
<p>Saves the arguments to a cache file, using the cache.num last checked with cache.ok.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.cache(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.cache_+3A_...">...</code></td>
<td>
<p>Objects to save.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># check the first cache to see if it exists and dependent files haven't changed.
# if this check is TRUE, code in brackets will get skipped and the cache will be loaded instead.
# set do.load = FALSE if you have multiple files that build a cache, 
#    to prevent multiple cache loads.
# output will be printed to the console to tell you if the cache was loaded or re-built.
## Not run: 
  if( ! cache.ok(1) ){

    # do stuff
  
    # if this is the final file for this cache, 
    #   end with save.cache to save passed objects as a cache.
    save.cache(iris)

  }

  # delete the cache folder to close out the example.
  system( "rm -r cache" )


## End(Not run)
</code></pre>

<hr>
<h2 id='sch'>Search a Data Frame.</h2><span id='topic+sch'></span>

<h3>Description</h3>

<p>Searches all columns for a term and returns all rows with at least one match.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sch(
  x,
  pattern,
  ignore.case = FALSE,
  fixed = FALSE,
  pluscols = NULL,
  exact = FALSE,
  trim = TRUE,
  spln = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sch_+3A_x">x</code></td>
<td>
<p>Data to search.</p>
</td></tr>
<tr><td><code id="sch_+3A_pattern">pattern</code></td>
<td>
<p>Regex patter to search. Most normal search terms will work fine, too.</p>
</td></tr>
<tr><td><code id="sch_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Ignore case in search (uses grepl).</p>
</td></tr>
<tr><td><code id="sch_+3A_fixed">fixed</code></td>
<td>
<p>Passed to grepl to match string as-is instead of using regex. See ?grepl.</p>
</td></tr>
<tr><td><code id="sch_+3A_pluscols">pluscols</code></td>
<td>
<p>choose columns to return in addition to those where matches are found. Can be a name, number or 'all' to bring back all columns.</p>
</td></tr>
<tr><td><code id="sch_+3A_exact">exact</code></td>
<td>
<p>Find exact matches intead of pattern matching.</p>
</td></tr>
<tr><td><code id="sch_+3A_trim">trim</code></td>
<td>
<p>Use trimws to trim columns before exact matching.</p>
</td></tr>
<tr><td><code id="sch_+3A_spln">spln</code></td>
<td>
<p>Sample data use easyr::spl() before searching. This will speed up searching in large datasets when you only need to identify columns, not all data that matches. See ?spl n argument for more info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matching rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sch( iris, 'seto' )
sch( iris, 'seto', pluscols='all' )
sch( iris, 'seto', pluscols='Sepal.Width' )
sch( iris, 'seto', exact = TRUE ) # message no matches and return NULL
</code></pre>

<hr>
<h2 id='spl'>Sample</h2><span id='topic+spl'></span>

<h3>Description</h3>

<p>Extracts a uniform random sample from a dataset or vector. Provides a simpler API than base R.
Author: Bryce Chamberlain. Tech Review: Maria Gonzalez.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl(x, n = 10, warn = TRUE, replace = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spl_+3A_x">x</code></td>
<td>
<p>Data to sample from.</p>
</td></tr>
<tr><td><code id="spl_+3A_n">n</code></td>
<td>
<p>Number or percentage of rows/values to return. If less than 1 it will be interpreted as a percentage.</p>
</td></tr>
<tr><td><code id="spl_+3A_warn">warn</code></td>
<td>
<p>Warn if sampling more than the size of the data.</p>
</td></tr>
<tr><td><code id="spl_+3A_replace">replace</code></td>
<td>
<p>Whether or not to sample with replacement.</p>
</td></tr>
<tr><td><code id="spl_+3A_seed">seed</code></td>
<td>
<p>Set a seed to allow consistent/replicable sampling.</p>
</td></tr>
<tr><td><code id="spl_+3A_...">...</code></td>
<td>
<p>Other parameters passed to sample()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sample dataframe/vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spl( c(1:100) )
spl( c(1:100), n = 50 )
spl( iris )
</code></pre>

<hr>
<h2 id='states'>states</h2><span id='topic+states'></span>

<h3>Description</h3>

<p>Helpful info for states. Right now, just a mapping of abbreviations to names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>states
</code></pre>


<h3>Format</h3>

<p>Data frame.
</p>

<hr>
<h2 id='strx'>Structure with Like</h2><span id='topic+strx'></span>

<h3>Description</h3>

<p>Runs str function but only for names matching a character value (regex).
Author: Scott Sobel. Tech Review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strx(df, char, ignore.case = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strx_+3A_df">df</code></td>
<td>
<p>Object with names you'd like to search.</p>
</td></tr>
<tr><td><code id="strx_+3A_char">char</code></td>
<td>
<p>Regex (character value) to match.</p>
</td></tr>
<tr><td><code id="strx_+3A_ignore.case">ignore.case</code></td>
<td>
<p>(Optional) Ignore case when matching.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>strx(iris,'length')
</code></pre>

<hr>
<h2 id='sumnum'>Summarize All Numeric Columns</h2><span id='topic+sumnum'></span>

<h3>Description</h3>

<p>Easily summarize at all numeric variables. Helpful for flexibly summarizing without knowing the columns. Defaults to sum but you can send a custom function through also. Typically pass in a data frame after group_by.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumnum(x, do.fun = NULL, except = c(), do.ungroup = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumnum_+3A_x">x</code></td>
<td>
<p>Grouped tibble to summarize.</p>
</td></tr>
<tr><td><code id="sumnum_+3A_do.fun">do.fun</code></td>
<td>
<p>Function to use for the summary. Passed to dplyr::summarize(). Can be a custom function. Defaults to sum().</p>
</td></tr>
<tr><td><code id="sumnum_+3A_except">except</code></td>
<td>
<p>Columns names, numbers, or a logical vector indicating columns NOT to summarize.</p>
</td></tr>
<tr><td><code id="sumnum_+3A_do.ungroup">do.ungroup</code></td>
<td>
<p>Run dplyr::ungroup() after summarizing the prevent future issues with grouping.</p>
</td></tr>
<tr><td><code id="sumnum_+3A_...">...</code></td>
<td>
<p>Extra args passed to dplyr::summarize() which are applied as arguments to the function passed in do.fun.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summarized data frame or tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(dplyr)
require(easyr)

sumnum( group_by( cars, speed ) )
sumnum( group_by( cars, speed ), mean )
sumnum( cars )

</code></pre>

<hr>
<h2 id='tcmsg'>tryCatch with Message</h2><span id='topic+tcmsg'></span>

<h3>Description</h3>

<p>Easy Try/Catch implementation to return the same message on error or warning. Makes it easier to write tryCatches.
Author: Bryce Chamberlain. Tech review: Lindsay Smelzter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcmsg(code_block, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcmsg_+3A_code_block">code_block</code></td>
<td>
<p>Code to run in Try Catch.</p>
</td></tr>
<tr><td><code id="tcmsg_+3A_...">...</code></td>
<td>
<p>Strings to concatenate to form the message that is returned.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({ 
   tcmsg({ NULL = 1 }, 'Cannot assign to NULL','variable' ) 
 }, 
 error = function(e) print( e ) 
 )

tryCatch({ 
   tcmsg({ as.numeric('abc') },'Issue in as.numeric()') 
  }, 
  warning = function(e) print( e ) 
)
</code></pre>

<hr>
<h2 id='tcol'>Transpose at Column.</h2><span id='topic+tcol'></span>

<h3>Description</h3>

<p>Transpose operation that sets column names equal to a column in the original data.
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcol(x, header, cols.colname = "col", do.atype = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcol_+3A_x">x</code></td>
<td>
<p>Data frame to be transposed.</p>
</td></tr>
<tr><td><code id="tcol_+3A_header">header</code></td>
<td>
<p>Column name/number to be used as column names of transposed data.</p>
</td></tr>
<tr><td><code id="tcol_+3A_cols.colname">cols.colname</code></td>
<td>
<p>Name to use for the column of column names in the transposed data.</p>
</td></tr>
<tr><td><code id="tcol_+3A_do.atype">do.atype</code></td>
<td>
<p>Transpose convertes to strings, since data types are uncertain. Run atype to automatically correct variable typing where possible. This will slow the result a bit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transposed data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # create a summary dataset from iris.
 x = dplyr::summarize_at( 
  dplyr::group_by( iris, Species ), 
  dplyr::vars( Sepal.Length, Sepal.Width ), list(sum) 
 )
 # run tcol
 tcol( x, 'Species' )
</code></pre>

<hr>
<h2 id='tcwarn'>tryCatch with warning</h2><span id='topic+tcwarn'></span>

<h3>Description</h3>

<p>Easy Try/Catch implementation to return the same message as a warning on error or warning. Makes it easier to write tryCatches.
Author: Bryce Chamberlain. Tech review: Lindsay Smelzter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcwarn(code_block, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcwarn_+3A_code_block">code_block</code></td>
<td>
<p>Code to run in Try Catch.</p>
</td></tr>
<tr><td><code id="tcwarn_+3A_...">...</code></td>
<td>
<p>Strings to concatenate to form the message that is returned.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch({
   tcwarn({ NULL = 1 },'Cannot assign to NULL','variable') 
 }, 
 warning = function(e) print( e ) 
)

tryCatch({ 
   tcwarn({ as.numeric('abc') },'Issue in as.numeric()') 
 }, 
 warning = function(e) print( e )
)
</code></pre>

<hr>
<h2 id='tobool'>Convert to Logical/Boolean</h2><span id='topic+tobool'></span>

<h3>Description</h3>

<p>Flexible boolean conversion. 
Author: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobool(
  x,
  preprocessed.values = NULL,
  nastrings = easyr::nastrings,
  ifna = c("return-unchanged", "error", "warning", "return-na"),
  verbose = TRUE,
  true.vals = c("true", "1", "t", "yes"),
  false.vals = c("false", "0", "f", "no")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tobool_+3A_x">x</code></td>
<td>
<p>Value or vector to be converted.</p>
</td></tr>
<tr><td><code id="tobool_+3A_preprocessed.values">preprocessed.values</code></td>
<td>
<p>Strings need to have NAs set, lowercase and be trimmed before they can be checked. To avoid doing this multiple times, you can pass these processed values to the function.</p>
</td></tr>
<tr><td><code id="tobool_+3A_nastrings">nastrings</code></td>
<td>
<p>Vector of characters to be considered NAs. todate will treat these like NAs. Defaults to the easyr::nastrings list.</p>
</td></tr>
<tr><td><code id="tobool_+3A_ifna">ifna</code></td>
<td>
<p>Action to take if NAs are created. 'return-unchanged'  returns the sent vector unchanged; 'warning' results in a warning and returns the converted vector with new NAs; 'error' results in an error.</p>
</td></tr>
<tr><td><code id="tobool_+3A_verbose">verbose</code></td>
<td>
<p>Choose to view messaging.</p>
</td></tr>
<tr><td><code id="tobool_+3A_true.vals">true.vals</code></td>
<td>
<p>Values to consider as TRUE.</p>
</td></tr>
<tr><td><code id="tobool_+3A_false.vals">false.vals</code></td>
<td>
<p>Values to consider as FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Converted logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tobool( c( 'true', 'FALSE', 0, 1, NA, 'yes', 'NO' ) )
</code></pre>

<hr>
<h2 id='tochar'>Shorthand for as.character</h2><span id='topic+tochar'></span>

<h3>Description</h3>

<p>Shorthand for as.character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tochar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tochar_+3A_x">x</code></td>
<td>
<p>Value to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as.character result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tochar(NA)
tochar(1)
</code></pre>

<hr>
<h2 id='todate'>Convert to Date</h2><span id='topic+todate'></span>

<h3>Description</h3>

<p>Flexible date conversion function using lubridate. Works with dates in many formats, without needing to know the format in advance. 
Only use this if you don't know the format of the dates before hand. Otherwise, lubridate functions parse_date_time, mdy, etc. should be used.
Author: Bryce Chamberlain. Tech review: Dominic Dillingham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>todate(
  x,
  nastrings = easyr::nastrings,
  aggressive.extraction = TRUE,
  preprocessed.values = NULL,
  ifna = c("return-unchanged", "error", "warning", "return-na"),
  verbose = TRUE,
  allow_times = FALSE,
  do.month.char = TRUE,
  do.excel = TRUE,
  min.acceptable = lubridate::ymd("1920-01-01"),
  max.acceptable = lubridate::ymd("2050-01-01")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="todate_+3A_x">x</code></td>
<td>
<p>Value or vector to be converted.</p>
</td></tr>
<tr><td><code id="todate_+3A_nastrings">nastrings</code></td>
<td>
<p>Vector of characters to be considered NAs. todate will treat these like NAs. Defaults to the easyr::nastrings list.</p>
</td></tr>
<tr><td><code id="todate_+3A_aggressive.extraction">aggressive.extraction</code></td>
<td>
<p>todate will take dates inside long strings (like filenames) and convert them to dates. This seems to be the preferred outcome, so we leave it as default (TRUE). However, if you want to avoid this you can do so via this option (FALSE).</p>
</td></tr>
<tr><td><code id="todate_+3A_preprocessed.values">preprocessed.values</code></td>
<td>
<p>Strings need to have NAs set, lowercase and be trimmed before they can be checked. To avoid doing this multiple times, you can pass these processed values to the function.</p>
</td></tr>
<tr><td><code id="todate_+3A_ifna">ifna</code></td>
<td>
<p>Action to take if NAs are created. 'return-unchanged'  returns the sent vector unchanged; 'warning' results in a warning and returns the converted vector with new NAs; 'error' results in an error; 'return-na' returns new NAs without a warning.</p>
</td></tr>
<tr><td><code id="todate_+3A_verbose">verbose</code></td>
<td>
<p>Choose to view messaging.</p>
</td></tr>
<tr><td><code id="todate_+3A_allow_times">allow_times</code></td>
<td>
<p>Set to TRUE to allow DateTimes as output, otherwise this will always convert to Dates (losing time information). This is better for binding data, hence the default FALSE.</p>
</td></tr>
<tr><td><code id="todate_+3A_do.month.char">do.month.char</code></td>
<td>
<p>Attempt to convert month names in text. lubridate does this by default, but sometimes it can result in inaccurate dates. For example, &quot;Feb 2017&quot; is converted to 2-20-2017 even though no day was given.</p>
</td></tr>
<tr><td><code id="todate_+3A_do.excel">do.excel</code></td>
<td>
<p>Check for excel-formatted numbers.</p>
</td></tr>
<tr><td><code id="todate_+3A_min.acceptable">min.acceptable</code></td>
<td>
<p>Set NA if converted value is less than this value. Helps to prevent numbers from being assumed as dates. Set NULL to skip this check. Does not affect character conversions.</p>
</td></tr>
<tr><td><code id="todate_+3A_max.acceptable">max.acceptable</code></td>
<td>
<p>Set NA if converted value is greater than this value. Helps to prevent numbers from being assumed as dates. Set NULL to skip this check. Does not affect character conversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Converted vector using lubridate::parse_date_time(x,c('mdy','ymd','dmy'))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c( '20171124', '2017/12/24', NA, '12/24/2017', '5/11/2017 1:51PM' ) 
x2 &lt;- todate(x)
x2
</code></pre>

<hr>
<h2 id='tonum'>Convert to Number</h2><span id='topic+tonum'></span>

<h3>Description</h3>

<p>Flexible number conversion for converting strings to numbers. Handles $ , ' and spaces.
Author: Bryce Chamberlain. Tech review: Dominic Dillingham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tonum(
  x,
  preprocessed.values = NULL,
  nastrings = easyr::nastrings,
  ifna = c("return-unchanged", "error", "warning", "return-na"),
  verbose = TRUE,
  nazero = FALSE,
  checkdate = TRUE,
  remove.chars = FALSE,
  do.logical = TRUE,
  do.try.integer = TRUE,
  multipliers = c(`%` = 1/100, K = 1000, M = 1000^2, B = 1000^3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tonum_+3A_x">x</code></td>
<td>
<p>Vector to convert.</p>
</td></tr>
<tr><td><code id="tonum_+3A_preprocessed.values">preprocessed.values</code></td>
<td>
<p>Strings need to have NAs set, lowercase and be trimmed before they can be checked. To avoid doing this multiple times, you can pass these processed values to the function.</p>
</td></tr>
<tr><td><code id="tonum_+3A_nastrings">nastrings</code></td>
<td>
<p>Vector of characters to be considered NAs. todate will treat these like NAs. Defaults to the easyr::nastrings list.</p>
</td></tr>
<tr><td><code id="tonum_+3A_ifna">ifna</code></td>
<td>
<p>Action to take if NAs are created. 'return-unchanged'  returns the sent vector unchanged; 'warning' results in a warning and returns the converted vector with new NAs; 'error' results in an error; return-na returns data with new NAs and prints via cat if verbose.</p>
</td></tr>
<tr><td><code id="tonum_+3A_verbose">verbose</code></td>
<td>
<p>Choose to view messaging.</p>
</td></tr>
<tr><td><code id="tonum_+3A_nazero">nazero</code></td>
<td>
<p>(Optional) Convert NAs to 0. Defaults to TRUE, if FALSE NAs will stay NA.</p>
</td></tr>
<tr><td><code id="tonum_+3A_checkdate">checkdate</code></td>
<td>
<p>Check if the column is a date first. If this has already been done, set this to FALSE so it doesn't run again.</p>
</td></tr>
<tr><td><code id="tonum_+3A_remove.chars">remove.chars</code></td>
<td>
<p>Remove characters for aggressive conversion to numbers.</p>
</td></tr>
<tr><td><code id="tonum_+3A_do.logical">do.logical</code></td>
<td>
<p>Check for logical-form vectors.</p>
</td></tr>
<tr><td><code id="tonum_+3A_do.try.integer">do.try.integer</code></td>
<td>
<p>Return an integer if possible. Integers are a more compact data type and should be used whenever possible.</p>
</td></tr>
<tr><td><code id="tonum_+3A_multipliers">multipliers</code></td>
<td>
<p>Named vector of factor symbols and values to check. Setting to NULL may speed up operations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Converted vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tonum( c('123','$50.02','30%','(300.01)',NA,'-','') )
tonum( c('123','$50.02','30%','(300.01)',NA,'-',''), nazero = FALSE )
tonum( c( '$(3,891)M', '4B', '3.41K', '30', '40K' ) )
</code></pre>

<hr>
<h2 id='usepkg'>Use Package</h2><span id='topic+usepkg'></span>

<h3>Description</h3>

<p>Installs a package if it needs to be installed, and calls require to load the package.
Author: Scott Sobel. Tech Review: Bryce Chamberlain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usepkg(packages, noCache = FALSE, repos = "http://cran.us.r-project.org")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usepkg_+3A_packages">packages</code></td>
<td>
<p>Character or character vector with names of the packages you want to use.</p>
</td></tr>
<tr><td><code id="usepkg_+3A_nocache">noCache</code></td>
<td>
<p>When checking packages, you can choose to ignore the cached list, which will increase accuracy but decrease speed.</p>
</td></tr>
<tr><td><code id="usepkg_+3A_repos">repos</code></td>
<td>
<p>choose the URL to install from.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># packages shouldn't be installed during tests or examples according to CRAN. 
# therefore, examples cannot be provided because CRAN now runs donttest examples.
</code></pre>

<hr>
<h2 id='validate.equal'>Validate Equal</h2><span id='topic+validate.equal'></span>

<h3>Description</h3>

<p>Check various properties of 2 data frames to ensure they are equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate.equal(
  df1,
  df2,
  id.column = NULL,
  regex.remove = "[^A-z0-9.+\\/,-]",
  do.set.NA = TRUE,
  nastrings = easyr::nastrings,
  match.round.to.digits = 4,
  do.all.columns.before.err = FALSE,
  check.column.order = FALSE,
  sort.by.id = TRUE,
  acceptable.pct.rows.diff = 0,
  acceptable.pct.vals.diff = 0,
  return.summary = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate.equal_+3A_df1">df1</code></td>
<td>
<p>First data frame  to compare.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_df2">df2</code></td>
<td>
<p>Second data frame to compare.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_id.column">id.column</code></td>
<td>
<p>If available, a column to use as an ID. Helpful in various checks and output.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_regex.remove">regex.remove</code></td>
<td>
<p>Pattern to remove from strings. Used in gsub to remove characters we don't want to consider when comparing values. Set to NULL, NA, or &quot;&quot; to leave strings unchanged.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_do.set.na">do.set.NA</code></td>
<td>
<p>Remove NA strings.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_nastrings">nastrings</code></td>
<td>
<p>Strings to consider NA.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_match.round.to.digits">match.round.to.digits</code></td>
<td>
<p>Round numbers to these digits before checking equality.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_do.all.columns.before.err">do.all.columns.before.err</code></td>
<td>
<p>Check all columns before returning an error. Takes longer but returns more detail. If FALSE, stops at first column that doesn't match and returns mismatches.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_check.column.order">check.column.order</code></td>
<td>
<p>Enforce same column order.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_sort.by.id">sort.by.id</code></td>
<td>
<p>Sort by the id column before making comparisons.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_acceptable.pct.rows.diff">acceptable.pct.rows.diff</code></td>
<td>
<p>If you are OK with differences in a few rows, set this value. If fewer rows in a column don't match, the function will consider the columns equivalent. Iterpreted as a percentage (it gets divided by 100).</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_acceptable.pct.vals.diff">acceptable.pct.vals.diff</code></td>
<td>
<p>If you are OK with small differences in values, set this value. If the difference in numeric values is less, the function will consider the values equivalent. Iterpreted as a percentage (it gets divided by 100) and compared to absolute value of percentage difference.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_return.summary">return.summary</code></td>
<td>
<p>Return 2 items in a list, the row mismatches and a summary of row mismatches.</p>
</td></tr>
<tr><td><code id="validate.equal_+3A_verbose">verbose</code></td>
<td>
<p>Print helpful information via cat().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>May return information about mismatches. Otherwise doesn't return anything (NULL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate.equal( iris, iris )

</code></pre>

<hr>
<h2 id='w'>Write</h2><span id='topic+w'></span>

<h3>Description</h3>

<p>Improved write function. Writes to csv without row names and automatically adds .csv to the file name if it isn't there already. Changes to .csv if another extension is passed.
Easier to type than write.csv(row.names=F).
Author: Bryce Chamberlain. Tech reveiw: Maria Gonzalez.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w(x, filename = "out", row.names = FALSE, na = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_+3A_x">x</code></td>
<td>
<p>Data frame to write to file.</p>
</td></tr>
<tr><td><code id="w_+3A_filename">filename</code></td>
<td>
<p>(Optional) Filename to use.</p>
</td></tr>
<tr><td><code id="w_+3A_row.names">row.names</code></td>
<td>
<p>(Optional) Specify if you want to include row names/numbers in the output file.</p>
</td></tr>
<tr><td><code id="w_+3A_na">na</code></td>
<td>
<p>(Optional) String to print for NAs. Defaults to an empty/blank string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># write the cars dataset.
path = paste0( tempdir(), '/out.csv' )
w( cars, path )

# cleanup.
file.remove( path )
</code></pre>

<hr>
<h2 id='xldate'>Convert Excel Number to Date</h2><span id='topic+xldate'></span>

<h3>Description</h3>

<p>Converts dates formatted as long integers from Excel to Date format in R, accounting for known Excel leap year errors.
Author: Bryce Chamberlain. Tech review: Dominic Dillingham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xldate(
  x,
  origin = "1899-12-30",
  nastrings = easyr::nastrings,
  preprocessed.values = NULL,
  ifna = c("return-unchanged", "error", "warning", "return-na"),
  verbose = TRUE,
  allow_times = FALSE,
  do.month.char = TRUE,
  min.acceptable = lubridate::ymd("1920-01-01"),
  max.acceptable = lubridate::ymd("2050-01-01")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xldate_+3A_x">x</code></td>
<td>
<p>Vector of values.</p>
</td></tr>
<tr><td><code id="xldate_+3A_origin">origin</code></td>
<td>
<p>Zero value to use in date conversion. Older version of excel might use a different value.</p>
</td></tr>
<tr><td><code id="xldate_+3A_nastrings">nastrings</code></td>
<td>
<p>Vector of characters to be considered NAs. todate will treat these like NAs. Defaults to the easyr::nastrings list.</p>
</td></tr>
<tr><td><code id="xldate_+3A_preprocessed.values">preprocessed.values</code></td>
<td>
<p>Strings need to have NAs set, lowercase and be trimmed before they can be checked. To avoid doing this twice, you can tell the function that it has already been done.</p>
</td></tr>
<tr><td><code id="xldate_+3A_ifna">ifna</code></td>
<td>
<p>Action to take if NAs are created. 'return-unchanged'  returns the sent vector unchanged; 'warning' results in a warning and returns the converted vector with new NAs; 'error' results in an error.</p>
</td></tr>
<tr><td><code id="xldate_+3A_verbose">verbose</code></td>
<td>
<p>Choose to view messaging.</p>
</td></tr>
<tr><td><code id="xldate_+3A_allow_times">allow_times</code></td>
<td>
<p>Return values with time, not just the date.</p>
</td></tr>
<tr><td><code id="xldate_+3A_do.month.char">do.month.char</code></td>
<td>
<p>Convert month character names like Feb, March, etc.</p>
</td></tr>
<tr><td><code id="xldate_+3A_min.acceptable">min.acceptable</code></td>
<td>
<p>Set NA if converted value is less than this value. Helps to prevent numbers from being assumed as dates. Set NULL to skip this check.</p>
</td></tr>
<tr><td><code id="xldate_+3A_max.acceptable">max.acceptable</code></td>
<td>
<p>Set NA if converted value is greater than this value. Helps to prevent numbers from being assumed as dates. Set NULL to skip this check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of converted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xldate( c('7597', '42769', '47545', NA ) )
</code></pre>

<hr>
<h2 id='ydiff'>Date Difference in Years</h2><span id='topic+ydiff'></span>

<h3>Description</h3>

<p>Date Difference in Years
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ydiff(x, y, do.date.convert = TRUE, do.numeric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ydiff_+3A_x">x</code></td>
<td>
<p>Vector of starting dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="ydiff_+3A_y">y</code></td>
<td>
<p>Vector of ending dates or items that can be converted to dates by todate.</p>
</td></tr>
<tr><td><code id="ydiff_+3A_do.date.convert">do.date.convert</code></td>
<td>
<p>Convert to dates before running the difference. If you know your columns are already dates, setting to FALSE will make your code run faster.</p>
</td></tr>
<tr><td><code id="ydiff_+3A_do.numeric">do.numeric</code></td>
<td>
<p>Convert the output to a number instead of a date difference object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ydiff( lubridate::mdy( '1/1/2018' ), lubridate::mdy( '3/4/2018' ) )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
