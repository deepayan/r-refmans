<!DOCTYPE html><html><head><title>Help for package LEGIT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LEGIT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backward_step'><p>Internal function that does the backward step for the stepwise IM function.</p>
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</a></li>
<li><a href='#backward_step_IM'><p>Internal function that does the backward step for the stepwise IM function.</p>
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</a></li>
<li><a href='#best_model'><p>Best model</p></a></li>
<li><a href='#best_model.elastic_net_var_select'><p>Best model from elastic net variable selection</p></a></li>
<li><a href='#bootstrap_var_select'><p>Bootstrap variable selection (for IMLEGIT)</p></a></li>
<li><a href='#elastic_net_var_select'><p>Elastic net for variable selection in IMLEGIT model</p></a></li>
<li><a href='#example_2way'><p>Simulated example of a 2 way interaction GxE model.</p></a></li>
<li><a href='#example_2way_lme4'><p>Simulated example of a 3 way interaction GxExZ model</p></a></li>
<li><a href='#example_3way'><p>Simulated example of a 3 way interaction GxExz model</p></a></li>
<li><a href='#example_3way_3latent'><p>Simulated example of a 3 way interaction GxExZ model</p></a></li>
<li><a href='#example_with_crossover'><p>Simulated example of a 2 way interaction GxE model with crossover point.</p></a></li>
<li><a href='#forward_step'><p>Internal function that does the forward step for the stepwise function.</p>
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</a></li>
<li><a href='#forward_step_IM'><p>Internal function that does the forward step for the stepwise function.</p>
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</a></li>
<li><a href='#genetic_var_select'><p>Parallel genetic algorithm variable selection (for IMLEGIT)</p></a></li>
<li><a href='#GxE_interaction_RoS'><p>Regions of significance using Johnson-Neyman technique</p></a></li>
<li><a href='#GxE_interaction_test'><p>Testing of the GxE interaction</p></a></li>
<li><a href='#IMLEGIT'><p>Independent Multiple Latent Environmental &amp; Genetic InTeraction (IMLEGIT) model</p></a></li>
<li><a href='#IMLEGIT_cv'><p>Cross-validation for the IMLEGIT model</p></a></li>
<li><a href='#IMLEGIT_net'><p>Independent Multiple Latent Environmental &amp; Genetic InTeraction (IMLEGIT) model with Elastic Net on the latent variables. Do not use on it's own, use elastic_net_var_select instead.</p></a></li>
<li><a href='#IMLEGIT_to_LEGIT'><p>IMLEGIT to LEGIT</p></a></li>
<li><a href='#LEGIT'><p>Latent Environmental &amp; Genetic InTeraction (LEGIT) model</p></a></li>
<li><a href='#LEGIT_cv'><p>Cross-validation for the LEGIT model</p></a></li>
<li><a href='#LEGIT_to_IMLEGIT'><p>LEGIT to IMLEGIT</p></a></li>
<li><a href='#longitudinal_folds'><p>Longitudinal folds</p></a></li>
<li><a href='#nes_var_select'><p>Parallel natural evolutionary variable selection assuming bernouilli distribution (for IMLEGIT)</p></a></li>
<li><a href='#plot.elastic_net_var_select'><p>Plot function for the output of elastic_net_var_select</p></a></li>
<li><a href='#plot.LEGIT'><p>Plot</p></a></li>
<li><a href='#predict.IMLEGIT'><p>Predictions of IMLEGIT fits</p></a></li>
<li><a href='#predict.LEGIT'><p>Predictions of LEGIT fits</p></a></li>
<li><a href='#r1nes_var_select'><p>Parallel natural evolutionary variable selection assuming multivariate normal search distribution with a simple covariance matrix parametrization (for IMLEGIT)</p></a></li>
<li><a href='#rGE'><p>Gene-Environment correlation estimation and testing</p></a></li>
<li><a href='#rGE.IMLEGIT'><p>Gene-Environment correlation estimation and testing of IMLEGIT models</p></a></li>
<li><a href='#rGE.LEGIT'><p>Gene-Environment correlation estimation and testing of LEGIT models</p></a></li>
<li><a href='#stepwise_search'><p>Stepwise search for the best subset of genetic variants or environments with the LEGIT model</p></a></li>
<li><a href='#stepwise_search_IM'><p>Stepwise search for the best subset of elements in the latent variables with the IMLEGIT model</p></a></li>
<li><a href='#summary.elastic_net_var_select'><p>Summary function for the output of elastic_net_var_select</p></a></li>
<li><a href='#summary.IMLEGIT'><p>Summarizing IMLEGIT fits</p></a></li>
<li><a href='#summary.LEGIT'><p>Summarizing LEGIT fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Latent Environmental &amp; Genetic InTeraction (LEGIT) Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexia Jolicoeur-Martineau &lt;alexia.jolicoeur-martineau@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexia Jolicoeur-Martineau &lt;alexia.jolicoeur-martineau@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Constructs genotype x environment interaction (GxE) models where
    G is a weighted sum of genetic variants (genetic score) and E is a weighted
    sum of environments (environmental score) using the alternating optimization algorithm 
    by Jolicoeur-Martineau et al. (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1703.08111">doi:10.48550/arXiv.1703.08111</a>&gt;. This approach has greatly 
    enhanced predictive power over traditional GxE models which include only a single 
    genetic variant and a single environmental exposure. Although this approach was 
    originally made for GxE modelling, it is flexible and does not require the use of 
    genetic and environmental variables. It can also handle more than 2 latent variables 
    (rather than just G and E) and 3-way interactions or more. The LEGIT model produces 
    highly interpretable results and is very parameter-efficient thus it can even be 
    used with small sample sizes (n &lt; 250). Tools to determine the type of interaction
    (vantage sensitivity, diathesis-stress or differential susceptibility), with any 
    number of genetic variants or environments, are available &lt;<a href="https://doi.org/10.48550/arXiv.1712.04058">doi:10.48550/arXiv.1712.04058</a>&gt;. The 
    software can now produce mixed-effects LEGIT models through the lme4 package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>pROC, foreach, snow, doSNOW, utils, iterators, Hmisc,
grDevices, boot, RColorBrewer, glmnet, lme4, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>formula.tools, stats, graphics</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 17:47:23 UTC; alexi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 15:12:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='backward_step'>Internal function that does the backward step for the stepwise IM function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</h2><span id='topic+backward_step'></span>

<h3>Description</h3>

<p>Internal function that does the backward step for the stepwise IM function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backward_step(
  fit,
  data,
  formula,
  interactive_mode = FALSE,
  genes_current = NULL,
  env_current = NULL,
  genes_dropped = NULL,
  env_dropped = NULL,
  search = "genes",
  search_criterion = "AIC",
  p_threshold = 0.2,
  exclude_worse_AIC = TRUE,
  max_steps = 100,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_genes = NULL,
  start_env = NULL,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  print = TRUE,
  test_only = FALSE
)
</code></pre>


<h3>Value</h3>

<p>Returns fit, start_genes, start_env and genes_current, genes_dropped if search=&quot;genes&quot; or env_current and env_dropped if search=&quot;env&quot;.
</p>

<hr>
<h2 id='backward_step_IM'>Internal function that does the backward step for the stepwise IM function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</h2><span id='topic+backward_step_IM'></span>

<h3>Description</h3>

<p>Internal function that does the backward step for the stepwise IM function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backward_step_IM(
  fit,
  data,
  formula,
  interactive_mode = FALSE,
  latent_var_current = NULL,
  latent_var_dropped = NULL,
  search = NULL,
  search_criterion = "AIC",
  p_threshold = 0.2,
  exclude_worse_AIC = TRUE,
  max_steps = 100,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_latent_var = start_latent_var,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  print = TRUE,
  test_only = FALSE
)
</code></pre>


<h3>Value</h3>

<p>Returns fit, start_latent_var, latent_var_current and latent_var_dropped.
</p>

<hr>
<h2 id='best_model'>Best model</h2><span id='topic+best_model'></span>

<h3>Description</h3>

<p>Best model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_model(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_model_+3A_object">object</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="best_model_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Best model
</p>

<hr>
<h2 id='best_model.elastic_net_var_select'>Best model from elastic net variable selection</h2><span id='topic+best_model.elastic_net_var_select'></span>

<h3>Description</h3>

<p>Best model from elastic net variable selection (based on selected criteria)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elastic_net_var_select'
best_model(object, criterion, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_model.elastic_net_var_select_+3A_object">object</code></td>
<td>
<p>An object of class &quot;elastic_net_var_select&quot;, usually, a result of a call to elastic_net_var_select.</p>
</td></tr>
<tr><td><code id="best_model.elastic_net_var_select_+3A_criterion">criterion</code></td>
<td>
<p>Criteria used to determine which model is the best. If <code>search_criterion="AIC"</code>, uses the AIC, if <code>search_criterion="AICc"</code>, uses the AICc, if <code>search_criterion="BIC"</code>, uses the BIC, if <code>search_criterion="cv_R2"</code>, uses the cross-validation R-squared, if <br /> <code>search_criterion="cv_AUC"</code>, uses the cross-validated AUC, if <code>search_criterion="cv_Huber"</code>, uses the Huber cross-validation error, if <code>search_criterion="cv_L1"</code>, uses the L1-norm cross-validation error (Default = &quot;AIC&quot;). The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers. For all criterion, lower is better, with the exception of <code>search_criterion="cv_R2"</code> and <code>search_criterion="cv_AUC"</code>.</p>
</td></tr>
<tr><td><code id="best_model.elastic_net_var_select_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the best IMLEGIT model resulting from the glmnet path with associated information.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N = 1000
train = example_3way(N, sigma=1, logit=FALSE, seed=7)
g1_bad = rbinom(N,1,.30)
g2_bad = rbinom(N,1,.30)
g3_bad = rbinom(N,1,.30)
g4_bad = rbinom(N,1,.30)
g5_bad = rbinom(N,1,.30)
train$G = cbind(train$G, g1_bad, g2_bad, g3_bad, g4_bad, g5_bad)
lv = list(G=train$G, E=train$E)
fit = elastic_net_var_select(train$data, lv, y ~ G*E)
summary(fit)
best_model(fit, criterion="BIC")
 # Instead of taking the best, if you want the model with "Model index"=17 from summary, do
plot(fit)
# With Cross-validation
fit = elastic_net_var_select(train$data, lv, y ~ G*E, cross_validation=TRUE, cv_iter=1, cv_folds=5)
best_model(fit, criterion="cv_R2")
# Elastic net only applied on G
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(1))
# Elastic net only applied on E
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2))
# Most E variables not removed, use lambda_mult &gt; 1 to remove more
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2), lambda_mult=5)
# Lasso (only L1 regularization)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, alpha=1)
# Want more lambdas (useful if # of variables is large)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, n_lambda = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='bootstrap_var_select'>Bootstrap variable selection (for IMLEGIT)</h2><span id='topic+bootstrap_var_select'></span>

<h3>Description</h3>

<p>[Very slow, not recommended] Creates bootstrap samples, runs a stepwise search on all of them and then reports the percentage of times that each variable was selected. This is very computationally demanding. With small sample sizes, variable selection can be unstable and bootstrap can be used to give us an idea of the degree of certitude that a variable should be included or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_var_select(
  data,
  formula,
  boot_iter = 1000,
  boot_size = NULL,
  boot_group = NULL,
  latent_var_original = NULL,
  latent_var_extra = NULL,
  search_type = "bidirectional-forward",
  search = 0,
  search_criterion = "AIC",
  forward_exclude_p_bigger = 0.2,
  backward_exclude_p_smaller = 0.01,
  exclude_worse_AIC = TRUE,
  max_steps = 100,
  start_latent_var = NULL,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  progress = TRUE,
  n_cluster = 1,
  best_subsets = 5,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_var_select_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_boot_iter">boot_iter</code></td>
<td>
<p>number of bootstrap samples (Default = 1000).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_boot_size">boot_size</code></td>
<td>
<p>Optional size of the bootstrapped samples (Default = number of observations).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_boot_group">boot_group</code></td>
<td>
<p>Optional vector which represents the group associated with each observation. Sampling will be done by group instead of by observations (very important if you have longitudinal data). The sample sizes of the bootstrap samples might differ by up to &quot;<code>boot_size</code> - maximum group size&quot; observations.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_latent_var_original">latent_var_original</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ...</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_latent_var_extra">latent_var_extra</code></td>
<td>
<p>list of data.frame (with the same structure as latent_var_original) containing the additional elements to try including inside the latent variables. Set to NULL if using a backward search.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_search_type">search_type</code></td>
<td>
<p>If <code>search_type="forward"</code>, uses a forward search. If <code>search_type="backward"</code>, uses backward search. If <code>search_type="bidirectional-forward"</code>, uses bidirectional search (that starts as a forward search). If <code>search_type="bidirectional-backward"</code>, uses bidirectional search (that starts as a backward search).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_search">search</code></td>
<td>
<p>If <code>search=0</code>, uses a stepwise search for all latent variables. Otherwise, if search = i, uses a stepwise search on the i-th latent variable (Default = 0).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_search_criterion">search_criterion</code></td>
<td>
<p>Criterion used to determine which variable is the best to add or worst to drop. If <code>search_criterion="AIC"</code>, uses the AIC, if <code>search_criterion="AICc"</code>, uses the AICc, if <code>search_criterion="BIC"</code>, uses the BIC (Default = &quot;AIC&quot;).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_forward_exclude_p_bigger">forward_exclude_p_bigger</code></td>
<td>
<p>If p-value &gt; <code>forward_exclude_p_bigger</code>, we do not consider the variable for inclusion in the forward steps (Default = .20). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to 1 to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_backward_exclude_p_smaller">backward_exclude_p_smaller</code></td>
<td>
<p>If p-value &lt; <code>backward_exclude_p_smaller</code>, we do not consider the variable for removal in the backward steps (Default = .01). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to 0 to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_exclude_worse_aic">exclude_worse_AIC</code></td>
<td>
<p>If AIC with variable &gt; AIC without variable, we ignore the variable (Default = TRUE). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to FALSE to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_max_steps">max_steps</code></td>
<td>
<p>Maximum number of steps taken (Default = 50).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_start_latent_var">start_latent_var</code></td>
<td>
<p>Optional list of starting points for each latent variable (The list must have the same length as the number of latent variables and each element of the list must have the same length as the number of variables of the corresponding latent variable).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_seed">seed</code></td>
<td>
<p>Optional seed for bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_progress">progress</code></td>
<td>
<p>If TRUE, shows the progress done (Default=TRUE).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of parallel clusters, I recommend using the number of CPU cores - 1 (Default = 1).</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_best_subsets">best_subsets</code></td>
<td>
<p>If <code>best_subsets = k</code>, the output will show the k most frequently chosen subsets of variables (Default = 5)</p>
</td></tr>
<tr><td><code id="bootstrap_var_select_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors containing the percentage of times that each variable was selected within each latent variable.
</p>


<h3>References</h3>

<p>Peter C Austin and Jack V Tu. <em>Bootstrap Methods for Developing Predictive Models</em> (2012). dx.doi.org/10.1198/0003130043277.
</p>
<p>Mark Reiser, Lanlan Yao, Xiao Wang, Jeanne Wilcox and Shelley Gray. <em>A Comparison of Bootstrap Confidence Intervals for Multi-level Longitudinal Data Using Monte-Carlo Simulation</em> (2017). 10.1007/978-981-10-3307-0_17.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example
train = example_3way_3latent(250, 2, seed=777)
# Bootstrap with Bidirectional-backward search for everything based on AIC
# Normally you should use a lot more than 10 iterations and extra CPUs (n_cluster)
boot = bootstrap_var_select(train$data, latent_var_extra=NULL, 
latent_var_original=train$latent_var,
formula=y ~ E*G*Z,search_type="bidirectional-backward", search=0, 
search_criterion="AIC", boot_iter=10, n_cluster=1)
# Assuming it's longitudinal with 5 timepoints, even though it's not
id = factor(rep(1:50,each=5))
boot_longitudinal = bootstrap_var_select(train$data, latent_var_extra=NULL, 
latent_var_original=train$latent_var,
formula=y ~ E*G*Z,search_type="bidirectional-backward", search=0, 
search_criterion="AIC", boot_iter=10, n_cluster=1, boot_group=id)

## End(Not run)
</code></pre>

<hr>
<h2 id='elastic_net_var_select'>Elastic net for variable selection in IMLEGIT model</h2><span id='topic+elastic_net_var_select'></span>

<h3>Description</h3>

<p>[Fast and accurate, highly recommended] Apply Elastic Net (from the glmnet package) with IMLEGIT to obtain the order of variable removal that makes the most sense. The output shows the information criterion at every step, so you can decide which variable to retain. It is significantly faster (seconds/minutes instead of hours) than all other variable selection approaches (except for stepwise) and it is very accurate. Note that, as opposed to LEGIT/IMLEGIT, the parameters of variables inside the latent variables are not L1-normalized; instead, its the main model parameters which are L1-normalized. This is needed to make elastic net works. It doesn't matter in the end, because we only care about which variables were removed and we only output the IMLEGIT models without elastic net penalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic_net_var_select(
  data,
  latent_var,
  formula,
  latent_var_searched = NULL,
  cross_validation = FALSE,
  alpha = 0.75,
  standardize = TRUE,
  lambda_path = NULL,
  lambda_mult = 1,
  lambda_min = 1e-04,
  n_lambda = 100,
  start_latent_var = NULL,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  print = TRUE,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic_net_var_select_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ... (See examples below for more details)</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_latent_var_searched">latent_var_searched</code></td>
<td>
<p>Optional If not null, you must specify a vector containing all indexes of the latent variables you want to use elastic net on. Ex: If latent_var=list(G=genes, E=env), specifying latent_var_search=c(1,2) will use both, latent_var_search=1 will only do it for G, and latent_var_search=2 will only do it for E.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_cross_validation">cross_validation</code></td>
<td>
<p>(Optional) If TRUE, will return cross-validation criterion (slower, but very good criterion).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter (between 0 and 1). 1 leads to lasso, 0 leads to ridge. See glmnet package manual for more information. We recommend somewhere betwen .50 and 1.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, standardize all variables inside every latent_var component. Note that if FALSE, glmnet will still standardize and unstandardize, but it will do so for each model (i.e., when at the step of estimating the parameters of latent variable G it standardize them, apply glmnet, then unstandarize them). This means that fixed parameters in the alternating steps are not standardized when standardize=FALSE. In practice, we found that standardize=FALSE leads to weird paths that do not always make sense. In the end, we only care about the order of the variable removal from the glmnet. We highly recommend standardize=TRUE for best results.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_lambda_path">lambda_path</code></td>
<td>
<p>Optional vector of all lambda (penalty term for elastic net, see glmnet package manual). By default, we automatically determine it.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_lambda_mult">lambda_mult</code></td>
<td>
<p>scalar which multiplies the maximum lambda (penalty term for elastic net, see glmnet package manual) from the lambda path determined automatically. Sometimes, the maximum lambda found automatically is too big or too small and you may not want to spend the effort to manually set your own lambda path. This is where this comes in, you can simply scale lambda max up or down. (Default = 1)</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_lambda_min">lambda_min</code></td>
<td>
<p>minimum lambda (penalty term for elastic net, see glmnet package manual) from the lambda path. (Default = .0001)</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_n_lambda">n_lambda</code></td>
<td>
<p>Number of lambda (penalty term for elastic net, see glmnet package manual) in lambda path. Make lower for faster training, or higher for more precision. If you have many variables, make it bigger than 100 (Default = 100).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_start_latent_var">start_latent_var</code></td>
<td>
<p>Optional list of starting points for each latent variable (The list must have the same length as the number of latent variables and each element of the list must have the same length as the number of variables of the corresponding latent variable).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification (binary outcome).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_print">print</code></td>
<td>
<p>If FALSE, nothing except warnings will be printed. (Default = TRUE).</p>
</td></tr>
<tr><td><code id="elastic_net_var_select_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the class &quot;elastic_net_var_select&quot; which is list containing, in the following order: the criterion at each lambda, the coefficients of the latent variables at each lambda, the fits of each IMLEGIT models for each variable retained at each lambda, and the vector of lambda used.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N = 1000
train = example_3way(N, sigma=1, logit=FALSE, seed=7)
g1_bad = rbinom(N,1,.30)
g2_bad = rbinom(N,1,.30)
g3_bad = rbinom(N,1,.30)
g4_bad = rbinom(N,1,.30)
g5_bad = rbinom(N,1,.30)
train$G = cbind(train$G, g1_bad, g2_bad, g3_bad, g4_bad, g5_bad)
lv = list(G=train$G, E=train$E)
fit = elastic_net_var_select(train$data, lv, y ~ G*E)
summary(fit)
best_model(fit, criterion="BIC")
 # Instead of taking the best, if you want the model with "Model index"=17 from summary, do
plot(fit)
# With Cross-validation
fit = elastic_net_var_select(train$data, lv, y ~ G*E, cross_validation=TRUE, cv_iter=1, cv_folds=5)
best_model(fit, criterion="cv_R2")
# Elastic net only applied on G
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(1))
# Elastic net only applied on E
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2))
# Most E variables not removed, use lambda_mult &gt; 1 to remove more
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2), lambda_mult=5)
# Lasso (only L1 regularization)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, alpha=1)
# Want more lambdas (useful if # of variables is large)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, n_lambda = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='example_2way'>Simulated example of a 2 way interaction GxE model.</h2><span id='topic+example_2way'></span>

<h3>Description</h3>

<p>Simulated example of a 2 way interaction GxE model (where G and E are latent variables). 
</p>
<p style="text-align: center;"><code class="reqn">g_j \sim Binomial(n=1,p=.30)</code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1, 2, 3, 4</code>
</p>

<p style="text-align: center;"><code class="reqn">e_l \sim Normal(\mu=0,\sigma=1.5)</code>
</p>

<p style="text-align: center;"><code class="reqn">l = 1, 2, 3</code>
</p>

<p style="text-align: center;"><code class="reqn">g = .2g_1 + .15g_2 - .3g_3 + .1g_4 + .05g_1g_3 + .2g_2g_3</code>
</p>

<p style="text-align: center;"><code class="reqn">e = -.45e_1 + .35e_2 + .2e_3</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = -1 + 2g + 3e + 4ge</code>
</p>


<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Normal(\mu=\mu,\sigma=\code{sigma})</code> if <code>logit</code>=FALSE </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Binomial(n=1,p=logit(\mu))</code> if <code>logit</code>=TRUE
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>example_2way(N, sigma = 1, logit = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_2way_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="example_2way_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the gaussian noise (if <code>logit</code>=FALSE).</p>
</td></tr>
<tr><td><code id="example_2way_+3A_logit">logit</code></td>
<td>
<p>If TRUE, the outcome is transformed to binary with a logit link.</p>
</td></tr>
<tr><td><code id="example_2way_+3A_seed">seed</code></td>
<td>
<p>RNG seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing, in the following order: data.frame with the observed outcome (with noise) and the true outcome (without noise), data.frame of the genetic variants (G), data.frame of the environments (E), vector of the true genetic coefficients, vector of the true environmental coefficients, vector of the true main model coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_2way(5,1,logit=FALSE)
example_2way(5,0,logit=TRUE)
</code></pre>

<hr>
<h2 id='example_2way_lme4'>Simulated example of a 3 way interaction GxExZ model</h2><span id='topic+example_2way_lme4'></span>

<h3>Description</h3>

<p>Simulated example of a 3 way interaction GxExZ model (where G, E and Z are latent variables). 
</p>
<p style="text-align: center;"><code class="reqn">g_j \sim Binomial(n=1,p=.30)</code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1, 2, 3, 4</code>
</p>

<p style="text-align: center;"><code class="reqn">e_k \sim Normal(\mu=0,\sigma=1.5)</code>
</p>

<p style="text-align: center;"><code class="reqn">k = 1, 2, 3</code>
</p>

<p style="text-align: center;"><code class="reqn">z_l \sim Normal(\mu=3,\sigma=1)</code>
</p>

<p style="text-align: center;"><code class="reqn">l = 1, 2, 3</code>
</p>

<p style="text-align: center;"><code class="reqn">g = .2g_1 + .15g_2 - .3g_3 + .1g_4 + .05g_1g_3 + .2g_2g_3</code>
</p>

<p style="text-align: center;"><code class="reqn">e = -.45e_1 + .35e_2 + .2e_3</code>
</p>

<p style="text-align: center;"><code class="reqn">z = .15z_1 + .60z_2 + .25z_3</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = -2 + 2g + 3e + z + 5ge - 1.5ez + 2gz + 2gez</code>
</p>


<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Normal(\mu=\mu,\sigma=\code{sigma})</code> if <code>logit</code>=FALSE </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Binomial(n=1,p=logit(\mu))</code> if <code>logit</code>=TRUE
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>example_2way_lme4(N, sigma = 1, logit = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_2way_lme4_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="example_2way_lme4_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the gaussian noise (if <code>logit</code>=FALSE).</p>
</td></tr>
<tr><td><code id="example_2way_lme4_+3A_logit">logit</code></td>
<td>
<p>If TRUE, the outcome is transformed to binary with a logit link.</p>
</td></tr>
<tr><td><code id="example_2way_lme4_+3A_seed">seed</code></td>
<td>
<p>RNG seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing, in the following order: data.frame with the observed outcome (with noise) and the true outcome (without noise), list containing the data.frame of the genetic variants (G), the data.frame of the <code class="reqn">e</code> environments (E) and the data.frame of the <code class="reqn">z</code> environments (Z), vector of the true genetic coefficients, vector of the true <code class="reqn">e</code> environmental coefficients, vector of the true <code class="reqn">z</code> environmental coefficients, vector of the true main model coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Doing only one iteration so its faster
train = example_2way_lme4(250, 1, seed=777)
D = train$data
G = train$G
E = train$E

F = y ~ G*E
fit = LEGIT(D, G, E, F, lme4=FALSE, maxiter=1)
summary(fit)
F = y ~ 1
fit_test = GxE_interaction_test(D, G, E, F, criterion="AIC", lme4=FALSE, maxiter=1)
fit_test
#fit_test = GxE_interaction_test(D, G, E, F, criterion="cv", lme4=FALSE, maxiter=1, cv_iter=1)
#fit_test

F = y ~ G*E + (1|subject)
fit = LEGIT(D, G, E, F, lme4=TRUE, maxiter=1)
summary(fit)
F = y ~ (1|subject)
fit_test = GxE_interaction_test(D, G, E, F, criterion="AIC", lme4=TRUE, maxiter=1)
fit_test
#fit_test = GxE_interaction_test(D, G, E, F, criterion="cv", lme4=TRUE, maxiter=1, cv_iter=1)
#fit_test
</code></pre>

<hr>
<h2 id='example_3way'>Simulated example of a 3 way interaction GxExz model</h2><span id='topic+example_3way'></span>

<h3>Description</h3>

<p>Simulated example of a 3 way interaction GxExz model (where G and E are latent variables). 
</p>
<p style="text-align: center;"><code class="reqn">g_j \sim Binomial(n=1,p=.30)</code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1, 2, 3, 4</code>
</p>

<p style="text-align: center;"><code class="reqn">e_l \sim Normal(\mu=0,\sigma=1.5)</code>
</p>

<p style="text-align: center;"><code class="reqn">l = 1, 2, 3</code>
</p>

<p style="text-align: center;"><code class="reqn">z \sim Normal(\mu=3,\sigma=1)</code>
</p>

<p style="text-align: center;"><code class="reqn">g = .2g_1 + .15g_2 - .3g_3 + .1g_4 + .05g_1g_3 + .2g_2g_3</code>
</p>

<p style="text-align: center;"><code class="reqn">e = -.45e_1 + .35e_2 + .2e_3</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = -2 + 2g + 3e + z + 5ge - 1.5ez + 2gz + 2gez</code>
</p>


<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Normal(\mu=\mu,\sigma=\code{sigma})</code> if <code>logit</code>=FALSE </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Binomial(n=1,p=logit(\mu))</code> if <code>logit</code>=TRUE
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>example_3way(N, sigma = 2.5, logit = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_3way_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="example_3way_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the gaussian noise (if <code>logit</code>=FALSE).</p>
</td></tr>
<tr><td><code id="example_3way_+3A_logit">logit</code></td>
<td>
<p>If TRUE, the outcome is transformed to binary with a logit link.</p>
</td></tr>
<tr><td><code id="example_3way_+3A_seed">seed</code></td>
<td>
<p>RNG seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing, in the following order: data.frame with the observed outcome (with noise), the true outcome (without noise) and <code class="reqn">z</code>, data.frame of the genetic variants (G), data.frame of the environments (E), vector of the true genetic coefficients, vector of the true environmental coefficients, vector of the true main model coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_3way(5,2.5,logit=FALSE)
example_3way(5,0,logit=TRUE)
</code></pre>

<hr>
<h2 id='example_3way_3latent'>Simulated example of a 3 way interaction GxExZ model</h2><span id='topic+example_3way_3latent'></span>

<h3>Description</h3>

<p>Simulated example of a 3 way interaction GxExZ model (where G, E and Z are latent variables). 
</p>
<p style="text-align: center;"><code class="reqn">g_j \sim Binomial(n=1,p=.30)</code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1, 2, 3, 4</code>
</p>

<p style="text-align: center;"><code class="reqn">e_k \sim Normal(\mu=0,\sigma=1.5)</code>
</p>

<p style="text-align: center;"><code class="reqn">k = 1, 2, 3</code>
</p>

<p style="text-align: center;"><code class="reqn">z_l \sim Normal(\mu=3,\sigma=1)</code>
</p>

<p style="text-align: center;"><code class="reqn">l = 1, 2, 3</code>
</p>

<p style="text-align: center;"><code class="reqn">g = .2g_1 + .15g_2 - .3g_3 + .1g_4 + .05g_1g_3 + .2g_2g_3</code>
</p>

<p style="text-align: center;"><code class="reqn">e = -.45e_1 + .35e_2 + .2e_3</code>
</p>

<p style="text-align: center;"><code class="reqn">z = .15z_1 + .60z_2 + .25z_3</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = -2 + 2g + 3e + z + 5ge - 1.5ez + 2gz + 2gez</code>
</p>


<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Normal(\mu=\mu,\sigma=\code{sigma})</code> if <code>logit</code>=FALSE </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Binomial(n=1,p=logit(\mu))</code> if <code>logit</code>=TRUE
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>example_3way_3latent(N, sigma = 1, logit = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_3way_3latent_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="example_3way_3latent_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the gaussian noise (if <code>logit</code>=FALSE).</p>
</td></tr>
<tr><td><code id="example_3way_3latent_+3A_logit">logit</code></td>
<td>
<p>If TRUE, the outcome is transformed to binary with a logit link.</p>
</td></tr>
<tr><td><code id="example_3way_3latent_+3A_seed">seed</code></td>
<td>
<p>RNG seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing, in the following order: data.frame with the observed outcome (with noise) and the true outcome (without noise), list containing the data.frame of the genetic variants (G), the data.frame of the <code class="reqn">e</code> environments (E) and the data.frame of the <code class="reqn">z</code> environments (Z), vector of the true genetic coefficients, vector of the true <code class="reqn">e</code> environmental coefficients, vector of the true <code class="reqn">z</code> environmental coefficients, vector of the true main model coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_3way_3latent(5,1,logit=FALSE)
example_3way_3latent(5,0,logit=TRUE)
</code></pre>

<hr>
<h2 id='example_with_crossover'>Simulated example of a 2 way interaction GxE model with crossover point.</h2><span id='topic+example_with_crossover'></span>

<h3>Description</h3>

<p>Simulated example of a 2 way interaction GxE model with crossover point (where G and E are latent variables). 
</p>
<p style="text-align: center;"><code class="reqn">g_j \sim Binomial(n=1,p=.30)</code>
</p>

<p style="text-align: center;"><code class="reqn">j = 1, 2, 3, 4</code>
</p>

<p style="text-align: center;"><code class="reqn">e_l \sim 10 Beta(\alpha,\beta))</code>
</p>

<p style="text-align: center;"><code class="reqn">l = 1, 2, 3</code>
</p>

<p style="text-align: center;"><code class="reqn">g = .30g_1 + .10g_2 + .20g_3 + .40g_4</code>
</p>

<p style="text-align: center;"><code class="reqn">e = .45e_1 + .35e_2 + .2e_3</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu = coef[1] + coef[2]e + coef[3]ge</code>
</p>


<table>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Normal(\mu=\mu,\sigma=\code{sigma})</code> if <code>logit</code>=FALSE </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">y \sim Binomial(n=1,p=logit(\mu))</code> if <code>logit</code>=TRUE
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>example_with_crossover(
  N,
  sigma = 1,
  c = 0,
  coef_main = c(0, 1, 2),
  coef_G = c(0.3, 0.1, 0.2, 0.4),
  coef_E = c(0.45, 0.35, 0.2),
  logit = FALSE,
  seed = NULL,
  beta_param = c(2, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_with_crossover_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the gaussian noise (if <code>logit</code>=FALSE).</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_c">c</code></td>
<td>
<p>crossover point</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_coef_main">coef_main</code></td>
<td>
<p>Coefficients of the main model, must be a vector of size 3 for intercept, E main effect and GxE effect (Default = c(0,1,2)).</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_coef_g">coef_G</code></td>
<td>
<p>Coefficients of the 4 genes, must be a vector of size 4 (Default = c(.30, .10, .20, .40)).</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_coef_e">coef_E</code></td>
<td>
<p>Coefficients of the 3 environments, must be a vector of size 3 (Default = c(.45, .35, .2)).</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_logit">logit</code></td>
<td>
<p>If TRUE, the outcome is transformed to binary with a logit link.</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_seed">seed</code></td>
<td>
<p>RNG seed.</p>
</td></tr>
<tr><td><code id="example_with_crossover_+3A_beta_param">beta_param</code></td>
<td>
<p>Vector of size two for the parameters of the beta distribution of the environmental variables (Default = c(2,2)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing, in the following order: data.frame with the observed outcome (with noise) and the true outcome (without noise), data.frame of the genetic variants (G), data.frame of the environments (E), vector of the true genetic coefficients, vector of the true environmental coefficients, vector of the true main model coefficients, the crossover point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples
# Diathesis Stress WEAK
ex_dia = example_with_crossover(250, c=10, coef_main = c(3,1,2), sigma=1)
# Diathesis Stress STRONG
ex_dia_s = example_with_crossover(250, c=10, coef_main = c(3,0,2), sigma=1)
# Differential Susceptibility WEAK
ex_ds = example_with_crossover(250, c=5, coef_main = c(3+5,1,2), sigma=1)
# Differential Susceptibility STRONG
ex_ds_s = example_with_crossover(250, c=5, coef_main = c(3+5,0,2), sigma=1)
</code></pre>

<hr>
<h2 id='forward_step'>Internal function that does the forward step for the stepwise function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</h2><span id='topic+forward_step'></span>

<h3>Description</h3>

<p>Internal function that does the forward step for the stepwise function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_step(
  empty_start_dataset,
  fit,
  data,
  formula,
  interactive_mode = FALSE,
  genes_current = NULL,
  env_current = NULL,
  genes_toadd = NULL,
  env_toadd = NULL,
  search = "genes",
  search_criterion = "AIC",
  p_threshold = 0.2,
  exclude_worse_AIC = TRUE,
  max_steps = 100,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_genes = NULL,
  start_env = NULL,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  print = TRUE,
  test_only = FALSE
)
</code></pre>


<h3>Value</h3>

<p>Returns fit, start_genes, start_env and genes_current, genes_toadd if search=&quot;genes&quot; or env_current and env_toadd if search=&quot;env&quot;.
</p>

<hr>
<h2 id='forward_step_IM'>Internal function that does the forward step for the stepwise function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.</h2><span id='topic+forward_step_IM'></span>

<h3>Description</h3>

<p>Internal function that does the forward step for the stepwise function.
#@param empty_start_dataset If TRUE, the initial dataset is empty.
#@param fit Current best fit.
#@param ... Same parameters as in the stepwise function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_step_IM(
  empty_start_dataset,
  fit,
  data,
  formula,
  interactive_mode = FALSE,
  latent_var_current = NULL,
  latent_var_toadd = NULL,
  search = NULL,
  search_criterion = "AIC",
  p_threshold = 0.2,
  exclude_worse_AIC = TRUE,
  max_steps = 100,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_latent_var = start_latent_var,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  print = TRUE,
  test_only = FALSE
)
</code></pre>


<h3>Value</h3>

<p>Returns fit, start_latent_var, latent_var_current and latent_var_toadd.
</p>

<hr>
<h2 id='genetic_var_select'>Parallel genetic algorithm variable selection (for IMLEGIT)</h2><span id='topic+genetic_var_select'></span>

<h3>Description</h3>

<p>[Very slow, recommended when the number of variables is large] Use a standard genetic algorithm with single-point crossover and a single mutation ran in parallel to find the best subset of variables. The percentage of times that each variable is included the final populations is also given. This is very computationally demanding but this finds much better solutions than either stepwise search or bootstrap variable selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genetic_var_select(
  data,
  formula,
  parallel_iter = 10,
  entropy_threshold = 0.1,
  popsize = 25,
  mutation_prob = 0.5,
  first_pop = NULL,
  latent_var = NULL,
  search_criterion = "AIC",
  maxgen = 100,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  progress = TRUE,
  n_cluster = 1,
  best_subsets = 5,
  cv_iter = 5,
  cv_folds = 5,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genetic_var_select_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_parallel_iter">parallel_iter</code></td>
<td>
<p>number of parallel genetic algorithms (Default = 10). I recommend using 2-4 times the number of CPU cores used.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_entropy_threshold">entropy_threshold</code></td>
<td>
<p>Entropy threshold for convergence of the population (Default = .10). Note that not reaching the entropy threshold just means that the population has some diversity, this is not necessarily a bad thing. Reaching the threshold is not necessary but if a population reach the threshold, we want it to stop reproducing (rather than continuing until <code>maxgen</code>) since the future generations won't change much.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_popsize">popsize</code></td>
<td>
<p>Size of the population (Default = 25). Between 25 and 100 is generally adequate.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_mutation_prob">mutation_prob</code></td>
<td>
<p>Probability of mutation (Default = .50). A single variable is selected for mutation and it is mutated with probability <code>mutation_prob</code>. If the mutation causes a latent variable to become empty, no mutation is done. Using a small value (close to .05) will lead to getting more stuck in suboptimal solutions but using a large value (close to 1) will greatly increase the computing time because it will have a hard time reaching the entropy threshold.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_first_pop">first_pop</code></td>
<td>
<p>optional Starting initial population which is used instead of a fully random one. Mutation is also done on the initial population to increase variability.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ...</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_search_criterion">search_criterion</code></td>
<td>
<p>Criterion used to determine which variable is the best to add or worst to drop. If <code>search_criterion="AIC"</code>, uses the AIC, if <code>search_criterion="AICc"</code>, uses the AICc, if <code>search_criterion="BIC"</code>, uses the BIC, if <code>search_criterion="cv"</code>, uses the cross-validation error, if <br /> <code>search_criterion="cv_AUC"</code>, uses the cross-validated AUC, if <code>search_criterion="cv_Huber"</code>, uses the Huber cross-validation error, if <code>search_criterion="cv_L1"</code>, uses the L1-norm cross-validation error (Default = &quot;AIC&quot;). The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers, the lower the values the better.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_maxgen">maxgen</code></td>
<td>
<p>Maximum number of generations (iterations) of the genetic algorithm (Default = 100). Between 50 and 200 generations is generally adequate.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results). Note that using .001 rather than .01 (default) can more than double or triple the computing time of genetic_var_select.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_seed">seed</code></td>
<td>
<p>Optional seed.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_progress">progress</code></td>
<td>
<p>If TRUE, shows the progress done (Default=TRUE).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of parallel clusters, I recommend using the number of CPU cores - 1 (Default = 1).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_best_subsets">best_subsets</code></td>
<td>
<p>If <code>best_subsets = k</code>, the output will show the k best subsets of variables (Default = 5)</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification and cross-validation (binary outcome).</p>
</td></tr>
<tr><td><code id="genetic_var_select_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors containing the percentage of times that each variable was included in the final populations, the criterion of the best k models, the starting points of the best k models (with the names of the best variables) and the entropy of the populations.
</p>


<h3>References</h3>

<p>Mu Zhu, &amp; Hugh Chipman. <em>Darwinian evolution in parallel universes: A parallel genetic algorithm for variable selection</em> (2006). Technometrics, 48(4), 491-502.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example
train = example_3way_3latent(250, 2, seed=777)
# Genetic algorithm based on BIC
# Normally you should use a lot more than 2 populations with 10 generations
ga = genetic_var_select(train$data, latent_var=train$latent_var,
formula=y ~ E*G*Z, search_criterion="AIC", parallel_iter=2, maxgen = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='GxE_interaction_RoS'>Regions of significance using Johnson-Neyman technique</h2><span id='topic+GxE_interaction_RoS'></span>

<h3>Description</h3>

<p>Constructs a LEGIT model and returns the regions of significance (RoS) with the predicted type of interaction (diathesis-stress, vantage-sensitivity, or differential susceptibility). RoS is not recommended due to poor accuracy with small samples and small effect sizes, GxE_interaction_test has much better accuracy overall. Only implemented for family=gaussian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GxE_interaction_RoS(
  data,
  genes,
  env,
  formula_noGxE,
  t_alpha = 0.05,
  start_genes = NULL,
  start_env = NULL,
  eps = 0.001,
  maxiter = 100,
  ylim = NULL,
  reverse_code = FALSE,
  rescale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GxE_interaction_RoS_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_genes">genes</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_env">env</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_formula_nogxe">formula_noGxE</code></td>
<td>
<p>formula WITHOUT <em>G</em> or <em>E</em> (y ~ covariates). <em>G</em> and <em>E</em> will automatically be added.</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_t_alpha">t_alpha</code></td>
<td>
<p>Alpha level of the student-t distribution for the regions of significance (Default = .05)</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_start_genes">start_genes</code></td>
<td>
<p>Optional starting points for genetic score (must be the same length as the number of columns of <code>genes</code>).</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_start_env">start_env</code></td>
<td>
<p>Optional starting points for environmental score (must be the same length as the number of columns of <code>env</code>).</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_reverse_code">reverse_code</code></td>
<td>
<p>If TRUE, after fitting the model, the genes with negative weights are reverse coded (ex: <code class="reqn">g_rev</code> = 1 - <code class="reqn">g</code>). It assumes that the original coding is in [0,1]. The purpose of this option is to prevent genes with negative weights which cause interpretation problems (ex: depression normally decreases attention but with a negative genetic score, it increases attention). Warning, using this option with GxG interactions could cause nonsensical results since GxG could be inverted. Also note that this may fail with certain models (Default=FALSE).</p>
</td></tr>
<tr><td><code id="GxE_interaction_RoS_+3A_rescale">rescale</code></td>
<td>
<p>If TRUE, the environmental variables are automatically rescaled to the range [-1,1]. This improves interpretability (Default=FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the RoS and the predicted type of interaction.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Jay Belsky, Eszter Szekely, Keith F. Widaman, Michael Pluess, Celia Greenwood and Ashley Wazana. <em>Distinguishing differential susceptibility, diathesis-stress and vantage sensitivity: beyond the single gene and environment model</em> (2017). https://osf.io/preprints/psyarxiv/27uw8. 10.17605/OSF.IO/27UW8.
</p>
<p>Daniel J. Bauer &amp; Patrick J. Curran. <em>Probing Interactions in Fixed and Multilevel Regression: Inferential and Graphical Techniques</em> (2005). Multivariate Behavioral Research, 40:3, 373-400, DOI: 10.1207/s15327906mbr4003_5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(500, 1, seed=777)
ros = GxE_interaction_RoS(train$data, train$G, train$E, y ~ 1)
ros
</code></pre>

<hr>
<h2 id='GxE_interaction_test'>Testing of the GxE interaction</h2><span id='topic+GxE_interaction_test'></span>

<h3>Description</h3>

<p>Testing of the GxE interaction using the competitive-confirmatory approach adapted from Belsky, Pluess et Widaman (2013). Reports the different hypotheses (diathesis-stress, vantage-sensitivity, or differential susceptibility), assuming or not assuming a main effect for <em>E</em> (WEAK vs STRONG) using the LEGIT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GxE_interaction_test(
  data,
  genes,
  env,
  formula_noGxE,
  crossover = c("min", "max"),
  include_noGxE_models = TRUE,
  reverse_code = FALSE,
  rescale = FALSE,
  boot = NULL,
  criterion = "BIC",
  start_genes = NULL,
  start_env = NULL,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  id = NULL,
  classification = FALSE,
  seed = NULL,
  test_only = FALSE,
  lme4 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GxE_interaction_test_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_genes">genes</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_env">env</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_formula_nogxe">formula_noGxE</code></td>
<td>
<p>formula WITHOUT <em>G</em> or <em>E</em> (y ~ covariates). <em>G</em> and <em>E</em> will automatically be added properly based on the hypotheses tested.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_crossover">crossover</code></td>
<td>
<p>A tuple containting the minimum and maximum of the environment used as crossover point of <em>E</em> used in the vantage sensitivity and diathesis-stress models. Instead of providing two number, you can also write c(&quot;min&quot;,&quot;max&quot;) to automatically choose the expected minimum or maximum of the environmental score which is calculated based on the min/max of the environments and the current weights.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_include_nogxe_models">include_noGxE_models</code></td>
<td>
<p>If True, we test for models with only G, only E, both G and E, neither G and E (four models without a GxE). This is to verify for false positives, if one of those models has the best fit, then it is possible that there is no GxE, thus no type of GxE. With a single gene and environment, simply looking at the p-value of the GxE is good enough to get around 5-10 percent false positive rate, but with multiple genes and environments, we need to compare model fits to get a low false positive rate. Use your own judgment when using this because if you have multiple genes and environments and small/moderate N, a model without GxE could have a lower BIC but still not be the actual best model. However, if you see little difference in BIC between all 4 GxE models and the non-GxE models have much lower BIC, than it is likely that there is no GxE. Note that this is only implemented for AIC, AICc and BIC. (Default = True)</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_reverse_code">reverse_code</code></td>
<td>
<p>If TRUE, after fitting the model, the genes with negative weights are reverse coded (ex: <code class="reqn">g_{rev}</code> = 1 - <code class="reqn">g</code>). It assumes that the original coding is in [0,1]. The purpose of this option is to prevent genes with negative weights which cause interpretation problems (ex: depression normally decreases attention but with a negative genetic score, it increases attention). Warning, using this option with GxG interactions could cause nonsensical results since GxG could be inverted. Also note that this may fail with certain models (Default=FALSE).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_rescale">rescale</code></td>
<td>
<p>If TRUE, the environmental variables are automatically rescaled to the range [-1,1]. This improves interpretability (Default=FALSE).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_boot">boot</code></td>
<td>
<p>Optional number of bootstrap samples. If not NULL, we use bootstrap to find the confidence interval of the crossover point. This provides more realistic confidence intervals. Make sure to use a bigger number (&gt;= 1000) to get good precision; also note that a too small number could return an error (&quot;estimated adjustment 'a' is NA&quot;).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_criterion">criterion</code></td>
<td>
<p>Criterion used to assess which model is the best. It can be set to &quot;AIC&quot;, &quot;AICc&quot;, &quot;BIC&quot;, &quot;cv&quot;, &quot;cv_AUC&quot;, &quot;cv_Huber&quot; (Default=&quot;BIC&quot;).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_start_genes">start_genes</code></td>
<td>
<p>Optional starting points for genetic score (must be the same length as the number of columns of <code>genes</code>).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_start_env">start_env</code></td>
<td>
<p>Optional starting points for environmental score (must be the same length as the number of columns of <code>env</code>).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_id">id</code></td>
<td>
<p>Optional id of observations, can be a vector or data.frame (only used when returning list of possible outliers).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification (binary outcome).</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_seed">seed</code></td>
<td>
<p>Seed for cross-validation folds.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
<tr><td><code id="GxE_interaction_test_+3A_lme4">lme4</code></td>
<td>
<p>If TRUE, uses lme4::lmer or lme4::glmer; Note that is an experimental feature, bugs may arise and certain functions may fail. Currently only summary(), plot(), GxE_interaction_test(), LEGIT(), LEGIT_cv() work. Also note that the AIC and certain elements ignore the existence of the genes and environment variables, thus the AIC may not be used for variable selection of the genes and the environment. However, the AIC can still be used to compare models with the same genes and environments. (Default=FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing 1) the six models ordered from best to worse (vantage sensitivity WEAK/STRONG, diathesis-stress WEAK/STRONG, differential susceptibility WEAK/STRONG) and 2) a data frame with the criterion, the crossover, 95% coverage of the crossover, whether the crossover 95% interval is within the observable range and the percentage of observations below the crossover point in order from best to worst based on the selected criterion. Models not within the observable range should be rejected even if the criterion is slightly better. An extremely low percentage of observations below the crossover point is also evidence toward diathesis-stress. Note that we assume that the environmental score is from bad to good but if this is not the case, then the models labelled as &quot;diathesis-stress&quot; could actually reflect vantage sensitivity and vice-versa. If outcome is Good-to-Bad: C=min(E) is diathesis-stress, C=max(E) is vantage sensitivity. If outcome is Bad-to-Good: C=max(E) is diathesis-stress, C=min(E) is vantage sensitivity.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Jay Belsky, Eszter Szekely, Keith F. Widaman, Michael Pluess, Celia Greenwood and Ashley Wazana. <em>Distinguishing differential susceptibility, diathesis-stress and vantage sensitivity: beyond the single gene and environment model</em> (2017). https://osf.io/preprints/psyarxiv/27uw8. 10.17605/OSF.IO/27UW8.
</p>
<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>
<p>Jay Belsky, Michael Pluess and Keith F. Widaman. <em>Confirmatory and competitive evaluation of alternative gene-environment interaction hypotheses</em> (2013). Journal of Child Psychology and Psychiatry, 54(10), 1135-1143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Examples where x is in [0, 10]
# Diathesis Stress WEAK
ex_dia = example_with_crossover(250, c=10, coef_main = c(3,1,2), sigma=1)
# Diathesis Stress STRONG
ex_dia_s = example_with_crossover(250, c=10, coef_main = c(3,0,2), sigma=1)
## Assuming there is a crossover point at x=5
# Differential Susceptibility WEAK
ex_ds = example_with_crossover(250, c=5, coef_main = c(3+5,1,2), sigma=1)
# Differential Susceptibility STRONG
ex_ds_s = example_with_crossover(250, c=5, coef_main = c(3+5,0,2), sigma=1)

## If true model is "Diathesis Stress WEAK"
GxE_test_BIC = GxE_interaction_test(ex_dia$data, ex_dia$G, ex_dia$E, 
formula_noGxE = y ~ 1, start_genes = ex_dia$coef_G, start_env = ex_dia$coef_E, 
criterion="BIC")
GxE_test_BIC$results

## If true model is "Diathesis Stress STRONG"
GxE_test_BIC = GxE_interaction_test(ex_dia_s$data, ex_dia_s$G, ex_dia_s$E, 
formula_noGxE = y ~ 1, start_genes = ex_dia_s$coef_G, start_env = ex_dia_s$coef_E, 
criterion="BIC")
GxE_test_BIC$results

## If true model is "Differential susceptibility WEAK"
GxE_test_BIC = GxE_interaction_test(ex_ds$data, ex_ds$G, ex_ds$E, 
formula_noGxE = y ~ 1, start_genes = ex_ds$coef_G, start_env = ex_ds$coef_E, 
criterion="BIC")
GxE_test_BIC$results

## If true model is "Differential susceptibility STRONG"
GxE_test_BIC = GxE_interaction_test(ex_ds_s$data, ex_ds_s$G, ex_ds_s$E, 
formula_noGxE = y ~ 1, start_genes = ex_ds_s$coef_G, start_env = ex_ds_s$coef_E,
criterion="BIC")
GxE_test_BIC$results

# Example of plots
plot(GxE_test_BIC$fits$diff_suscept_STRONG, xlim=c(0,10), ylim=c(3,13))
plot(GxE_test_BIC$fits$diff_suscept_WEAK, xlim=c(0,10), ylim=c(3,13))
plot(GxE_test_BIC$fits$diathesis_stress_STRONG, xlim=c(0,10), ylim=c(3,13))
plot(GxE_test_BIC$fits$diathesis_stress_WEAK, xlim=c(0,10), ylim=c(3,13))

## End(Not run)
</code></pre>

<hr>
<h2 id='IMLEGIT'>Independent Multiple Latent Environmental &amp; Genetic InTeraction (IMLEGIT) model</h2><span id='topic+IMLEGIT'></span>

<h3>Description</h3>

<p>Constructs a generalized linear model (glm) with latent variables using alternating optimization. This is an extension of the LEGIT model to accommodate more than 2 latent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMLEGIT(
  data,
  latent_var,
  formula,
  start_latent_var = NULL,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IMLEGIT_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ... (See examples below for more details)</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_start_latent_var">start_latent_var</code></td>
<td>
<p>Optional list of starting points for each latent variable (The list must have the same length as the number of latent variables and each element of the list must have the same length as the number of variables of the corresponding latent variable).</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="IMLEGIT_+3A_print">print</code></td>
<td>
<p>If FALSE, nothing except warnings will be printed. (Default = TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the class &quot;IMLEGIT&quot; which is list containing, in the following order: a glm fit of the main model, a list of the glm fits of the latent variables and a list of the true model parameters (AIC, BIC, rank, df.residual, null.deviance) for which the individual model parts (main, genetic, environmental) don't estimate properly.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(500, 1, seed=777)
fit_best = IMLEGIT(train$data, list(G=train$G, E=train$E), y ~ G*E, 
list(train$coef_G, train$coef_E))
fit_default = IMLEGIT(train$data, list(G=train$G, E=train$E), y ~ G*E)
summary(fit_default)
summary(fit_best)
train = example_3way_3latent(500, 1, seed=777)
fit_best = IMLEGIT(train$data, train$latent_var, y ~ G*E*Z, 
list(train$coef_G, train$coef_E, train$coef_Z))
fit_default = IMLEGIT(train$data, train$latent_var, y ~ G*E*Z)
summary(fit_default)
summary(fit_best)
</code></pre>

<hr>
<h2 id='IMLEGIT_cv'>Cross-validation for the IMLEGIT model</h2><span id='topic+IMLEGIT_cv'></span>

<h3>Description</h3>

<p>Uses cross-validation on the IMLEGIT model. Note that this is not a very fast implementation since it was written in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMLEGIT_cv(
  data,
  latent_var,
  formula,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_latent_var = NULL,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  id = NULL,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IMLEGIT_cv_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ...</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification (binary outcome).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_start_latent_var">start_latent_var</code></td>
<td>
<p>Optional list of starting points for each latent variable (The list must have the same length as the number of latent variables and each element of the list must have the same length as the number of variables of the corresponding latent variable).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_seed">seed</code></td>
<td>
<p>Seed for cross-validation folds.</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_id">id</code></td>
<td>
<p>Optional id of observations, can be a vector or data.frame (only used when returning list of possible outliers).</p>
</td></tr>
<tr><td><code id="IMLEGIT_cv_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>classification</code> = FALSE, returns a list containing, in the following order: a vector of the cross-validated <code class="reqn">R^2</code> at each iteration, a vector of the Huber cross-validation error at each iteration, a vector of the L1-norm cross-validation error at each iteration, a matrix of the possible outliers (standardized residuals &gt; 2.5 or &lt; -2.5) and their corresponding standardized residuals and standardized pearson residuals. If <code>classification</code> = TRUE, returns a list containing, in the following order: a vector of the cross-validated <code class="reqn">R^2</code> at each iteration, a vector of the Huber cross-validation error at each iteration, a vector of the L1-norm cross-validation error at each iteration, a vector of the AUC at each iteration, a matrix of the best choice of threshold (based on Youden index) and the corresponding specificity and sensitivity at each iteration, and a list of objects of class &quot;roc&quot; (to be able to make roc curve plots) at each iteration. The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers, the lower the values the better.
</p>


<h3>References</h3>

<p>Denis Heng-Yan Leung. <em>Cross-validation in nonparametric regression with outliers.</em> Annals of Statistics (2005): 2291-2310.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
train = example_3way_3latent(250, 1, seed=777)
# Cross-validation 4 times with 5 Folds
cv_5folds = IMLEGIT_cv(train$data, train$latent_var, y ~ G*E*Z, cv_iter=4, cv_folds=5)
cv_5folds
# Leave-one-out cross-validation (Note: very slow)
cv_loo = IMLEGIT_cv(train$data, train$latent_var, y ~ G*E*Z, cv_iter=1, cv_folds=250)
cv_loo
# Cross-validation 4 times with 5 Folds (binary outcome)
train_bin = example_2way(500, 2.5, logit=TRUE, seed=777)
cv_5folds_bin = IMLEGIT_cv(train_bin$data, list(G=train_bin$G, E=train_bin$E), y ~ G*E, 
cv_iter=4, cv_folds=5, classification=TRUE, family=binomial)
cv_5folds_bin
par(mfrow=c(2,2))
pROC::plot.roc(cv_5folds_bin$roc_curve[[1]])
pROC::plot.roc(cv_5folds_bin$roc_curve[[2]])
pROC::plot.roc(cv_5folds_bin$roc_curve[[3]])
pROC::plot.roc(cv_5folds_bin$roc_curve[[4]])

## End(Not run)
</code></pre>

<hr>
<h2 id='IMLEGIT_net'>Independent Multiple Latent Environmental &amp; Genetic InTeraction (IMLEGIT) model with Elastic Net on the latent variables. Do not use on it's own, use elastic_net_var_select instead.</h2><span id='topic+IMLEGIT_net'></span>

<h3>Description</h3>

<p>Constructs a generalized linear model (glm) with latent variables using alternating optimization. This is an extension of the LEGIT model to accommodate more than 2 latent variables. Note that, as opposed to LEGIT/IMLEGIT, the parameters of variables inside the latent variables are not L1-normalized; instead, its the main model parameters which are L1-normalized. This is needed to make elastic net works. It doesn't matter in the end, because we only care about which variables were removed and we only give the IMLEGIT models without elastic net penalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMLEGIT_net(
  data,
  latent_var,
  formula,
  latent_var_searched = NULL,
  cross_validation = FALSE,
  alpha = 1,
  lambda = 1e-04,
  start_latent_var = NULL,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  print = TRUE,
  warn = TRUE,
  family_string = NULL,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IMLEGIT_net_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ... (See examples below for more details)</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_latent_var_searched">latent_var_searched</code></td>
<td>
<p>Optional If not null, you must specify a vector containing all indexes of the latent variables you want to use elastic net on. Ex: If latent_var=list(G=genes, E=env), specifying latent_var_search=c(1,2) will use both, latent_var_search=1 will only do it for G, and latent_var_search=2 will only do it for E.</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_cross_validation">cross_validation</code></td>
<td>
<p>If TRUE, will return cross-validation criterion (slower)</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter (between 0 and 1). 1 leads to lasso, 0 leads to ridge. See glmnet package manual for more information. We recommend somewhere betwen .50 and 1.</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_lambda">lambda</code></td>
<td>
<p>Lambda (penalty term for elastic net, see glmnet package manual) (Default = .0001)</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_start_latent_var">start_latent_var</code></td>
<td>
<p>Optional list of starting points for each latent variable (The list must have the same length as the number of latent variables and each element of the list must have the same length as the number of variables of the corresponding latent variable).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification (binary outcome).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_print">print</code></td>
<td>
<p>If FALSE, nothing except warnings will be printed. (Default = TRUE).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_warn">warn</code></td>
<td>
<p>If FALSE, it will not show warnings when all variables inside a latent variable are removed. This serves to prevent lots of warning when running elastic_net_var_select (Default = TRUE).</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_family_string">family_string</code></td>
<td>
<p>Optional String version of the family (gaussian leads to &quot;gaussian&quot;). This is only needed when using elastic_net_var_select. Please ignore this.</p>
</td></tr>
<tr><td><code id="IMLEGIT_net_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing, in the following order: a IMLEGIT model, the coefficients of the variables in the latent variables from glmnet models, and the cross-validation results (if asked).
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>

<hr>
<h2 id='IMLEGIT_to_LEGIT'>IMLEGIT to LEGIT</h2><span id='topic+IMLEGIT_to_LEGIT'></span>

<h3>Description</h3>

<p>Transforms a IMLEGIT model into a LEGIT model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMLEGIT_to_LEGIT(
  fit,
  data,
  genes,
  env,
  formula,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_fit">fit</code></td>
<td>
<p>IMLEGIT model</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_genes">genes</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_env">env</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_formula">formula</code></td>
<td>
<p>Model formula. Use <em>E</em> for the environmental score and <em>G</em> for the genetic score. Do not manually code interactions, write them in the formula instead (ex: G*E*z or G:E:z).</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="IMLEGIT_to_LEGIT_+3A_print">print</code></td>
<td>
<p>If FALSE, nothing except warnings will be printed (Default = TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the class &quot;LEGIT&quot; which is list containing, in the following order: a glm fit of the main model, a glm fit of the genetic score, a glm fit of the environmental score, a list of the true model parameters (AIC, BIC, rank, df.residual, null.deviance) for which the individual model parts (main, genetic, environmental) don't estimate properly and the formula.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(500, 1, seed=777)
fit = LEGIT(train$data, train$G, train$E, y ~ G*E, train$coef_G, train$coef_E)
fit_IMLEGIT = LEGIT_to_IMLEGIT(fit,train$data, train$G, train$E, y ~ G*E)
fit_LEGIT = IMLEGIT_to_LEGIT(fit_IMLEGIT,train$data, train$G, train$E, y ~ G*E)
</code></pre>

<hr>
<h2 id='LEGIT'>Latent Environmental &amp; Genetic InTeraction (LEGIT) model</h2><span id='topic+LEGIT'></span>

<h3>Description</h3>

<p>Constructs a generalized linear model (glm) with a weighted latent environmental score and weighted latent genetic score using alternating optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LEGIT(
  data,
  genes,
  env,
  formula,
  start_genes = NULL,
  start_env = NULL,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  print = TRUE,
  print_steps = FALSE,
  crossover = NULL,
  crossover_fixed = FALSE,
  reverse_code = FALSE,
  rescale = FALSE,
  lme4 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LEGIT_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_genes">genes</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_env">env</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_formula">formula</code></td>
<td>
<p>Model formula. Use <em>E</em> for the environmental score and <em>G</em> for the genetic score. Do not manually code interactions, write them in the formula instead (ex: G*E*z or G:E:z).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_start_genes">start_genes</code></td>
<td>
<p>Optional starting points for genetic score (must be the same length as the number of columns of <code>genes</code>).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_start_env">start_env</code></td>
<td>
<p>Optional starting points for environmental score (must be the same length as the number of columns of <code>env</code>).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_print">print</code></td>
<td>
<p>If FALSE, nothing except warnings will be printed (Default = TRUE).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_print_steps">print_steps</code></td>
<td>
<p>If TRUE, print the parameters at all iterations, good for debugging (Default = FALSE).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_crossover">crossover</code></td>
<td>
<p>If not NULL, estimates the crossover point of <em>E</em> using the provided value as starting point (To test for diathesis-stress vs differential susceptibility).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_crossover_fixed">crossover_fixed</code></td>
<td>
<p>If TRUE, instead of estimating the crossover point of E, we force/fix it to the value of &quot;crossover&quot;. (Used when creating a diathes-stress model) (Default = FALSE).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_reverse_code">reverse_code</code></td>
<td>
<p>If TRUE, after fitting the model, the genes with negative weights are reverse coded (ex: <code class="reqn">g_rev</code> = 1 - <code class="reqn">g</code>). It assumes that the original coding is in [0,1]. The purpose of this option is to prevent genes with negative weights which cause interpretation problems (ex: depression normally decreases attention but with a negative genetic score, it increases attention). Warning, using this option with GxG interactions could cause nonsensical results since GxG could be inverted. Also note that this may fail with certain models (Default=FALSE).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_rescale">rescale</code></td>
<td>
<p>If TRUE, the environmental variables are automatically rescaled to the range [-1,1]. This improves interpretability (Default=FALSE).</p>
</td></tr>
<tr><td><code id="LEGIT_+3A_lme4">lme4</code></td>
<td>
<p>If TRUE, uses lme4::lmer or lme4::glmer; Note that is an experimental feature, bugs may arise and certain functions may fail. Currently only summary(), plot(), GxE_interaction_test(), LEGIT(), LEGIT_cv() work. Also note that the AIC and certain elements ignore the existence of the genes and environment variables, thus the AIC may not be used for variable selection of the genes and the environment. However, the AIC can still be used to compare models with the same genes and environments. (Default=FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the class &quot;LEGIT&quot; which is list containing, in the following order: a glm fit of the main model, a glm fit of the genetic score, a glm fit of the environmental score, a list of the true model parameters (AIC, BIC, rank, df.residual, null.deviance) for which the individual model parts (main, genetic, environmental) don't estimate properly and the formula.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(500, 1, seed=777)
fit_best = LEGIT(train$data, train$G, train$E, y ~ G*E, train$coef_G, train$coef_E)
fit_default = LEGIT(train$data, train$G, train$E, y ~ G*E)
summary(fit_default)
summary(fit_best)

train = example_3way(500, 2.5, seed=777)
fit_best = LEGIT(train$data, train$G, train$E, y ~ G*E*z, train$coef_G, train$coef_E)
fit_default = LEGIT(train$data, train$G, train$E, y ~ G*E*z)
summary(fit_default)
summary(fit_best)

</code></pre>

<hr>
<h2 id='LEGIT_cv'>Cross-validation for the LEGIT model</h2><span id='topic+LEGIT_cv'></span>

<h3>Description</h3>

<p>Uses cross-validation on the LEGIT model. Note that this is not a very fast implementation since it was written in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LEGIT_cv(
  data,
  genes,
  env,
  formula,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_genes = NULL,
  start_env = NULL,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  id = NULL,
  crossover = NULL,
  crossover_fixed = FALSE,
  lme4 = FALSE,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LEGIT_cv_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_genes">genes</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_env">env</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_formula">formula</code></td>
<td>
<p>Model formula. Use <em>E</em> for the environmental score and <em>G</em> for the genetic score. Do not manually code interactions, write them in the formula instead (ex: G*E*z or G:E:z).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification (binary outcome).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_start_genes">start_genes</code></td>
<td>
<p>Optional starting points for genetic score (must be the same length as the number of columns of <code>genes</code>).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_start_env">start_env</code></td>
<td>
<p>Optional starting points for environmental score (must be the same length as the number of columns of <code>env</code>).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_seed">seed</code></td>
<td>
<p>Seed for cross-validation folds.</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_id">id</code></td>
<td>
<p>Optional id of observations, can be a vector or data.frame (only used when returning list of possible outliers).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_crossover">crossover</code></td>
<td>
<p>If not NULL, estimates the crossover point of <em>E</em> using the provided value as starting point (To test for diathesis-stress vs differential susceptibility).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_crossover_fixed">crossover_fixed</code></td>
<td>
<p>If TRUE, instead of estimating the crossover point of E, we force/fix it to the value of &quot;crossover&quot;. (Used when creating a diathes-stress model) (Default = FALSE).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_lme4">lme4</code></td>
<td>
<p>If TRUE, uses lme4::lmer or lme4::glmer; Note that is an experimental feature, bugs may arise and certain functions may fail. Currently only summary(), plot(), GxE_interaction_test(), LEGIT(), LEGIT_cv() work. Also note that the AIC and certain elements ignore the existence of the genes and environment variables, thus the AIC may not be used for variable selection of the genes and the environment. However, the AIC can still be used to compare models with the same genes and environments. (Default=FALSE).</p>
</td></tr>
<tr><td><code id="LEGIT_cv_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>classification</code> = FALSE, returns a list containing, in the following order: a vector of the cross-validated <code class="reqn">R^2</code> at each iteration, a vector of the Huber cross-validation error at each iteration, a vector of the L1-norm cross-validation error at each iteration, a matrix of the possible outliers (standardized residuals &gt; 2.5 or &lt; -2.5) and their corresponding standardized residuals and standardized pearson residuals. If <code>classification</code> = TRUE, returns a list containing, in the following order: a vector of the cross-validated <code class="reqn">R^2</code> at each iteration, a vector of the Huber cross-validation error at each iteration, a vector of the L1-norm cross-validation error at each iteration, a vector of the AUC at each iteration, a matrix of the best choice of threshold (based on Youden index) and the corresponding specificity and sensitivity at each iteration, and a list of objects of class &quot;roc&quot; (to be able to make roc curve plots) at each iteration. The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers, the lower the values the better.
</p>


<h3>References</h3>

<p>Denis Heng-Yan Leung. <em>Cross-validation in nonparametric regression with outliers.</em> Annals of Statistics (2005): 2291-2310.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
train = example_3way(250, 2.5, seed=777)
# Cross-validation 4 times with 5 Folds
cv_5folds = LEGIT_cv(train$data, train$G, train$E, y ~ G*E*z, cv_iter=4, cv_folds=5)
cv_5folds
# Leave-one-out cross-validation (Note: very slow)
cv_loo = LEGIT_cv(train$data, train$G, train$E, y ~ G*E*z, cv_iter=1, cv_folds=250)
cv_loo
# Test set only
cv_test = LEGIT_cv(train$data, train$G, train$E, y ~ G*E*z, cv_iter=1, cv_folds=5, test_only=TRUE)
cv_test
# Cross-validation 4 times with 5 Folds (binary outcome)
train_bin = example_2way(500, 2.5, logit=TRUE, seed=777)
cv_5folds_bin = LEGIT_cv(train_bin$data, train_bin$G, train_bin$E, y ~ G*E, 
cv_iter=4, cv_folds=5, classification=TRUE, family=binomial)
cv_5folds_bin
par(mfrow=c(2,2))
pROC::plot.roc(cv_5folds_bin$roc_curve[[1]])
pROC::plot.roc(cv_5folds_bin$roc_curve[[2]])
pROC::plot.roc(cv_5folds_bin$roc_curve[[3]])
pROC::plot.roc(cv_5folds_bin$roc_curve[[4]])

## End(Not run)
</code></pre>

<hr>
<h2 id='LEGIT_to_IMLEGIT'>LEGIT to IMLEGIT</h2><span id='topic+LEGIT_to_IMLEGIT'></span>

<h3>Description</h3>

<p>Transforms a LEGIT model into a IMLEGIT model (Useful if you want to do plot() or GxE_interaction_test() with a model resulting from a variable selection method which gave a IMLEGIT model)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LEGIT_to_IMLEGIT(
  fit,
  data,
  genes,
  env,
  formula,
  eps = 0.001,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_fit">fit</code></td>
<td>
<p>LEGIT model</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_genes">genes</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_env">env</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_formula">formula</code></td>
<td>
<p>Model formula. Use <em>E</em> for the environmental score and <em>G</em> for the genetic score. Do not manually code interactions, write them in the formula instead (ex: G*E*z or G:E:z).</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="LEGIT_to_IMLEGIT_+3A_print">print</code></td>
<td>
<p>If FALSE, nothing except warnings will be printed (Default = TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the class &quot;IMLEGIT&quot; which is list containing, in the following order: a glm fit of the main model, a list of the glm fits of the latent variables and a list of the true model parameters (AIC, BIC, rank, df.residual, null.deviance) for which the individual model parts (main, genetic, environmental) don't estimate properly.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(500, 1, seed=777)
fit = LEGIT(train$data, train$G, train$E, y ~ G*E, train$coef_G, train$coef_E)
fit_IMLEGIT = LEGIT_to_IMLEGIT(fit,train$data, train$G, train$E, y ~ G*E)
fit_LEGIT = IMLEGIT_to_LEGIT(fit_IMLEGIT,train$data, train$G, train$E, y ~ G*E)
</code></pre>

<hr>
<h2 id='longitudinal_folds'>Longitudinal folds</h2><span id='topic+longitudinal_folds'></span>

<h3>Description</h3>

<p>Function to create folds adequately for longitudinal datasets by forcing every observation with the same id to be in the same fold. Can be used with LEGIT_cv to make sure that the cross-validation folds are appropriate when using longitudinal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longitudinal_folds(
  cv_iter = 1,
  cv_folds = 10,
  id,
  formula = NULL,
  data = NULL,
  data_needed = NULL,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longitudinal_folds_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 1).</p>
</td></tr>
<tr><td><code id="longitudinal_folds_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10).</p>
</td></tr>
<tr><td><code id="longitudinal_folds_+3A_id">id</code></td>
<td>
<p>Factor vector containing the id number of each observation.</p>
</td></tr>
<tr><td><code id="longitudinal_folds_+3A_formula">formula</code></td>
<td>
<p>Optional Model formula. If data and formula are provided, only the non-missing observations will be used when creating the folds (Put &quot;formula&quot; here if you have missing data).</p>
</td></tr>
<tr><td><code id="longitudinal_folds_+3A_data">data</code></td>
<td>
<p>Optional data.frame used for the formula. If data and formula are provided, only the non-missing observations will be used when creating the folds (Put &quot;data&quot; here if you have missing data).</p>
</td></tr>
<tr><td><code id="longitudinal_folds_+3A_data_needed">data_needed</code></td>
<td>
<p>Optional data.frame with variables that have to be included (Put &quot;cbind(genes,env)&quot;&quot; or &quot;latent_var&quot; here if you have missing data).</p>
</td></tr>
<tr><td><code id="longitudinal_folds_+3A_print">print</code></td>
<td>
<p>If FALSE, nothing except warnings will be printed. (Default = TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors containing the fold number for each observation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(500, 1, seed=777)
# Assuming it's longitudinal with 4 timepoints, even though it's not
id = factor(rep(1:125,each=4))
fit_cv = LEGIT_cv(train$data, train$G, train$E, y ~ G*E, folds=longitudinal_folds(1,10, id))
</code></pre>

<hr>
<h2 id='nes_var_select'>Parallel natural evolutionary variable selection assuming bernouilli distribution (for IMLEGIT)</h2><span id='topic+nes_var_select'></span>

<h3>Description</h3>

<p>[Slow, highly recommended when the number of variables is large] Use natural evolution strategy (nes) gradient descent ran in parallel to find the best subset of variables. It is often as good as genetic algorithms but much faster so it is the recommended variable selection function to use as default. Note that this approach assumes that the inclusion of a variable does not depends on whether other variables are included (i.e. it assumes independent bernouilli distributions); this is generally not true but this approach still converge well and running it in parallel increases the probability of reaching the global optimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nes_var_select(
  data,
  formula,
  parallel_iter = 3,
  alpha = c(1, 5, 10),
  entropy_threshold = 0.05,
  popsize = 25,
  lr = 0.2,
  prop_ignored = 0.5,
  latent_var = NULL,
  search_criterion = "AICc",
  n_cluster = 3,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  progress = TRUE,
  cv_iter = 5,
  cv_folds = 5,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  print = FALSE,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nes_var_select_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_parallel_iter">parallel_iter</code></td>
<td>
<p>number of parallel tries (Default = 3). For speed, I recommend using the number of CPU cores.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_alpha">alpha</code></td>
<td>
<p>vector of the parameter for the Dirichlet distribution of the starting points (Assuming a symmetric Dirichlet distribution with only one parameter). If the vector has size N and parralel_iter=K, we use alpha[1], ..., alpha[N], alpha[1], ... , alpha[N], ... for parallel_iter 1 to K respectively. We assume a dirichlet distribution for the starting points to get a bit more variability and make sure we are not missing on a great subset of variable that doesn't converge to the global optimum with the default starting points. Use bigger values for less variability and lower values for more variability (Default = c(1,5,10)).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_entropy_threshold">entropy_threshold</code></td>
<td>
<p>Entropy threshold for convergence of the population (Default = .10). The smaller the entropy is, the less diversity there is in the population, which means convergence.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_popsize">popsize</code></td>
<td>
<p>Size of the population, the number of subsets of variables sampled at each iteration (Default = 25). Between 25 and 100 is generally adequate.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_lr">lr</code></td>
<td>
<p>learning rate of the gradient descent, higher will converge faster but more likely to get stuck in local optium (Default = .2).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_prop_ignored">prop_ignored</code></td>
<td>
<p>The proportion of the population that are given a fixed fitness value, thus their importance is greatly reduce. The higher it is, the longer it takes to converge. Highers values makes the algorithm focus more on favorizing the good subsets of variables than penalizing the bad subsets (Default = .50).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ...</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_search_criterion">search_criterion</code></td>
<td>
<p>Criterion used to determine which variable subset is the best. If <code>search_criterion="AIC"</code>, uses the AIC, if <code>search_criterion="AICc"</code>, uses the AICc, if <code>search_criterion="BIC"</code>, uses the BIC, if <code>search_criterion="cv"</code>, uses the cross-validation error, if <br /> <code>search_criterion="cv_AUC"</code>, uses the cross-validated AUC, if <code>search_criterion="cv_Huber"</code>, uses the Huber cross-validation error, if <code>search_criterion="cv_L1"</code>, uses the L1-norm cross-validation error (Default = &quot;AIC&quot;). The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers, the lower the values the better.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of parallel clusters, I recommend using the number of CPU cores (Default = 1).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results). Note that using .001 rather than .01 (default) can more than double or triple the computing time of genetic_var_select.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_seed">seed</code></td>
<td>
<p>Optional seed.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_progress">progress</code></td>
<td>
<p>If TRUE, shows the progress done (Default=TRUE).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification and cross-validation (binary outcome).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_print">print</code></td>
<td>
<p>If TRUE, print the parameters of the search distribution and the entropy at each iteration. Note: Only works using Rterm.exe in Windows due to parallel clusters. (Default = FALSE).</p>
</td></tr>
<tr><td><code id="nes_var_select_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the best subset's fit, cross-validation output, latent variables and starting points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example
train = example_3way_3latent(250, 2, seed=777)
nes = nes_var_select(train$data, latent_var=train$latent_var,
formula=y ~ E*G*Z)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.elastic_net_var_select'>Plot function for the output of elastic_net_var_select</h2><span id='topic+plot.elastic_net_var_select'></span>

<h3>Description</h3>

<p>Plot of the coefficients of variables inside the latent variables with respect to the log(lambda). This is your typical elastic-net plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elastic_net_var_select'
plot(x, lwd = 2, start = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.elastic_net_var_select_+3A_x">x</code></td>
<td>
<p>An object of class &quot;elastic_net_var_select&quot;, usually, a result of a call to elastic_net_var_select.</p>
</td></tr>
<tr><td><code id="plot.elastic_net_var_select_+3A_lwd">lwd</code></td>
<td>
<p>Thickness of the lines (Default = 2)</p>
</td></tr>
<tr><td><code id="plot.elastic_net_var_select_+3A_start">start</code></td>
<td>
<p>At which lambda to start (from large lambda to small lambda). If start is not 1, we remove some of the large lambda, this can make plot easier to visualize (Default = 1).</p>
</td></tr>
<tr><td><code id="plot.elastic_net_var_select_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the plot of the coefficients of variables inside the latent variables with respect to the log(lambda).
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N = 1000
train = example_3way(N, sigma=1, logit=FALSE, seed=7)
g1_bad = rbinom(N,1,.30)
g2_bad = rbinom(N,1,.30)
g3_bad = rbinom(N,1,.30)
g4_bad = rbinom(N,1,.30)
g5_bad = rbinom(N,1,.30)
train$G = cbind(train$G, g1_bad, g2_bad, g3_bad, g4_bad, g5_bad)
lv = list(G=train$G, E=train$E)
fit = elastic_net_var_select(train$data, lv, y ~ G*E)
summary(fit)
best_model(fit, criterion="BIC")
 # Instead of taking the best, if you want the model with "Model index"=17 from summary, do
plot(fit)
# With Cross-validation
fit = elastic_net_var_select(train$data, lv, y ~ G*E, cross_validation=TRUE, cv_iter=1, cv_folds=5)
best_model(fit, criterion="cv_R2")
# Elastic net only applied on G
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(1))
# Elastic net only applied on E
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2))
# Most E variables not removed, use lambda_mult &gt; 1 to remove more
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2), lambda_mult=5)
# Lasso (only L1 regularization)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, alpha=1)
# Want more lambdas (useful if # of variables is large)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, n_lambda = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.LEGIT'>Plot</h2><span id='topic+plot.LEGIT'></span>

<h3>Description</h3>

<p>Plot of LEGIT models. By default, variables that are not in <em>G</em> or <em>E</em> are fixed to the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LEGIT'
plot(
  x,
  cov_values = NULL,
  gene_quant = c(0.025, 0.5, 0.975),
  env_quant = c(0.025, 0.5, 0.975),
  outcome_quant = c(0.025, 0.5, 0.975),
  cols = c("#3288BD", "#CAB176", "#D53E4F"),
  ylab = "Outcome",
  xlab = "Environment",
  legtitle = "Genetic score",
  leglab = NULL,
  xlim = NULL,
  ylim = NULL,
  x_at = NULL,
  y_at = NULL,
  cex.axis = 1.9,
  cex.lab = 2,
  cex.main = 2.2,
  cex.leg = 2.2,
  legend = "topleft",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.LEGIT_+3A_x">x</code></td>
<td>
<p>An object of class &quot;LEGIT&quot;, usually, a result of a call to LEGIT.</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_cov_values">cov_values</code></td>
<td>
<p>Vector of the values, for each covariate, that will be used in the plotting, if there are any covariates. It must contain the names of the variables. Covariates are the variables that are not <em>G</em> nor <em>E</em> but still are adjusted for in the model. By default, covariates are fixed to the mean.</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_gene_quant">gene_quant</code></td>
<td>
<p>Vector of the genes quantiles used to make the plot. We use quantiles instead of fixed values because genetic scores can vary widely depending on the weights, thus looking at quantiles make this simpler. (Default = c(.025,.50,.975))</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_env_quant">env_quant</code></td>
<td>
<p>Vector of the environments quantiles used to make the plot. We use quantiles instead of fixed values because environmental scores can vary widely depending on the weights, thus looking at quantiles make this simpler. (Default = c(.025,.50,.975))</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_outcome_quant">outcome_quant</code></td>
<td>
<p>Vector of the outcome quantiles used to make the plot. We use quantiles instead of fixed values because environmental scores can vary widely depending on the weights, thus looking at quantiles make this simpler. (Default = c(.025,.50,.975))</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_cols">cols</code></td>
<td>
<p>Colors for the slopes with different genetic score. Must be a vector same length as &quot;gene_range&quot;. (Default = c(&quot;#3288BD&quot;, &quot;#CAB176&quot;, #D53E4F&quot;))</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label (Default = &quot;Outcome&quot;)</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label (Default = &quot;Environment&quot;)</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_legtitle">legtitle</code></td>
<td>
<p>Title of the Legend for the genes slopes label (Default = &quot;Genetic score&quot;)</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_leglab">leglab</code></td>
<td>
<p>Optional vector of labels of the Legend for the genes slopes label</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_xlim">xlim</code></td>
<td>
<p>X-axis vector of size two with min and max (Default = NULL which leads to min=&quot;2.5 percentile&quot; and max=&quot;97.5 percentile&quot;).</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis vector of size two with min and max (Default = NULL which leads to min=&quot;2.5 percentile&quot; and max=&quot;97.5 percentile&quot;).</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_x_at">x_at</code></td>
<td>
<p>specific ticks for the X-axis, first and last will be min and max respectively (Default = NULL which leads to 2.5, 50 and 97.5 percentiles).</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_y_at">y_at</code></td>
<td>
<p>specific ticks for the Y-axis, first and last will be min and max respectively (Default = NULL which leads to 2.5, 50 and 97.5 percentiles).</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_cex.axis">cex.axis</code></td>
<td>
<p>relative scale of axis (Default = 1.9)</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_cex.lab">cex.lab</code></td>
<td>
<p>relative scale of labels (Default = 2)</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_cex.main">cex.main</code></td>
<td>
<p>relative scale overall (Default = 2.2)</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_cex.leg">cex.leg</code></td>
<td>
<p>relative scale of legend (Default = 2.2)</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_legend">legend</code></td>
<td>
<p>The location may of the legend be specified by setting legend to a single keyword from the list &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot; (Default = &quot;topleft&quot;).</p>
</td></tr>
<tr><td><code id="plot.LEGIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the different models (diathesis-stress, differential susceptibility and vantage sensitivity WEAK or STRONG) in order from best to worst for each selected criterion.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(500, 1, seed=777)
fit = LEGIT(train$data, train$G, train$E, y ~ G*E, train$coef_G, train$coef_E)
plot(fit)
</code></pre>

<hr>
<h2 id='predict.IMLEGIT'>Predictions of IMLEGIT fits</h2><span id='topic+predict.IMLEGIT'></span>

<h3>Description</h3>

<p>Predictions of IMLEGIT fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IMLEGIT'
predict(object, data, latent_var, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.IMLEGIT_+3A_object">object</code></td>
<td>
<p>An object of class &quot;IMLEGIT&quot;, usually, a result of a call to IMLEGIT.</p>
</td></tr>
<tr><td><code id="predict.IMLEGIT_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="predict.IMLEGIT_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ...</p>
</td></tr>
<tr><td><code id="predict.IMLEGIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(250, 1, seed=777)
test = example_2way(100, 1, seed=666)
fit = IMLEGIT(train$data, list(G=train$G, E=train$E), y ~ G*E)
ssres = sum((test$data$y - predict(fit, test$data, list(G=test$G, E=test$E)))^2)
sstotal = sum((test$data$y - mean(test$data$y))^2)
R2 = 1 - ssres/sstotal
R2
</code></pre>

<hr>
<h2 id='predict.LEGIT'>Predictions of LEGIT fits</h2><span id='topic+predict.LEGIT'></span>

<h3>Description</h3>

<p>Predictions of LEGIT fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LEGIT'
predict(object, data, genes, env, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.LEGIT_+3A_object">object</code></td>
<td>
<p>An object of class &quot;LEGIT&quot;, usually, a result of a call to LEGIT.</p>
</td></tr>
<tr><td><code id="predict.LEGIT_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="predict.LEGIT_+3A_genes">genes</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="predict.LEGIT_+3A_env">env</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="predict.LEGIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train = example_2way(250, 1, seed=777)
test = example_2way(100, 1, seed=666)
fit = LEGIT(train$data, train$G, train$E, y ~ G*E)
ssres = sum((test$data$y - predict(fit, test$data, test$G, test$E))^2)
sstotal = sum((test$data$y - mean(test$data$y))^2)
R2 = 1 - ssres/sstotal
</code></pre>

<hr>
<h2 id='r1nes_var_select'>Parallel natural evolutionary variable selection assuming multivariate normal search distribution with a simple covariance matrix parametrization (for IMLEGIT)</h2><span id='topic+r1nes_var_select'></span>

<h3>Description</h3>

<p>[Slow, highly recommended when the number of variables is large] Use natural evolution strategy (nes) gradient descent ran in parallel to find the best subset of variables. It is often as good as genetic algorithms but much faster so it is the recommended variable selection function to use as default. This is slower than nes_var_select but much less likely to get stuck into local optimum so the parallelization is not really needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r1nes_var_select(
  data,
  formula,
  parallel_iter = 3,
  alpha = c(1, 5, 10),
  entropy_threshold = 0.05,
  popsize = 25,
  lr = 0.2,
  prop_ignored = 0.5,
  latent_var = NULL,
  search_criterion = "AICc",
  n_cluster = 3,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  progress = TRUE,
  cv_iter = 5,
  cv_folds = 5,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  print = FALSE,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r1nes_var_select_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_parallel_iter">parallel_iter</code></td>
<td>
<p>number of parallel tries (Default = 3). For speed, I recommend using the number of CPU cores.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_alpha">alpha</code></td>
<td>
<p>vector of the parameter for the Dirichlet distribution of the starting points (Assuming a symmetric Dirichlet distribution with only one parameter). If the vector has size N and parralel_iter=K, we use alpha[1], ..., alpha[N], alpha[1], ... , alpha[N], ... for parallel_iter 1 to K respectively. We assume a dirichlet distribution for the starting points to get a bit more variability and make sure we are not missing on a great subset of variable that doesn't converge to the global optimum with the default starting points. Use bigger values for less variability and lower values for more variability (Default = c(1,5,10)).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_entropy_threshold">entropy_threshold</code></td>
<td>
<p>Entropy threshold for convergence of the population (Default = .10). The smaller the entropy is, the less diversity there is in the population, which means convergence.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_popsize">popsize</code></td>
<td>
<p>Size of the population, the number of subsets of variables sampled at each iteration (Default = 25). Between 25 and 100 is generally adequate.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_lr">lr</code></td>
<td>
<p>learning rate of the gradient descent, higher will converge faster but more likely to get stuck in local optium (Default = .2).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_prop_ignored">prop_ignored</code></td>
<td>
<p>The proportion of the population that are given a fixed fitness value, thus their importance is greatly reduce. The higher it is, the longer it takes to converge. Highers values makes the algorithm focus more on favorizing the good subsets of variables than penalizing the bad subsets (Default = .50).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ...</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_search_criterion">search_criterion</code></td>
<td>
<p>Criterion used to determine which variable subset is the best. If <code>search_criterion="AIC"</code>, uses the AIC, if <code>search_criterion="AICc"</code>, uses the AICc, if <code>search_criterion="BIC"</code>, uses the BIC, if <code>search_criterion="cv"</code>, uses the cross-validation error, if <br /> <code>search_criterion="cv_AUC"</code>, uses the cross-validated AUC, if <code>search_criterion="cv_Huber"</code>, uses the Huber cross-validation error, if <code>search_criterion="cv_L1"</code>, uses the L1-norm cross-validation error (Default = &quot;AIC&quot;). The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers, the lower the values the better.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Number of parallel clusters, I recommend using the number of CPU cores (Default = 1).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results). Note that using .001 rather than .01 (default) can more than double or triple the computing time of genetic_var_select.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_seed">seed</code></td>
<td>
<p>Optional seed.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_progress">progress</code></td>
<td>
<p>If TRUE, shows the progress done (Default=TRUE).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification and cross-validation (binary outcome).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_print">print</code></td>
<td>
<p>If TRUE, print the parameters of the search distribution and the entropy at each iteration. Note: Only works using Rterm.exe in Windows due to parallel clusters. (Default = FALSE).</p>
</td></tr>
<tr><td><code id="r1nes_var_select_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the best subset's fit, cross-validation output, latent variables and starting points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example
train = example_3way_3latent(250, 2, seed=777)
nes = r1nes_var_select(train$data, latent_var=train$latent_var,
formula=y ~ E*G*Z)

## End(Not run)
</code></pre>

<hr>
<h2 id='rGE'>Gene-Environment correlation estimation and testing</h2><span id='topic+rGE'></span>

<h3>Description</h3>

<p>Estimates the gene-environment correlation (rGE) and tests for a GxE using a residual environmental score. If there is an important correlation between G and E, the model is still valid prediction-wise but the interpretation is affected as the question becomes: is it really a GxE or a GxG since E is partially caused by G? To account for this, we remove the influence of G on E (If E = b0 + b1*G + e, we use E_resid = E - b1*G) and refit the model to see if the model parameters changed. The residual environmental score (E_resid) is uncorrelated with G. This does not account for passive rGE but only active rGE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rGE(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rGE_+3A_object">object</code></td>
<td>
<p>An object of class &quot;LEGIT&quot; or &quot;IMLEGIT&quot;.</p>
</td></tr>
<tr><td><code id="rGE_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='rGE.IMLEGIT'>Gene-Environment correlation estimation and testing of IMLEGIT models</h2><span id='topic+rGE.IMLEGIT'></span>

<h3>Description</h3>

<p>Estimates the gene-environment correlation (rGE) and tests for a GxE using a residual environmental score. If there is an important correlation between G and E, the model is still valid prediction-wise but the interpretation is affected as the question becomes: is it really a GxE or a GxG since E is partially caused by G? To account for this, we remove the influence of G on E (If E = b0 + b1*G + e, we use E_resid = E - b1*G) and refit the model to see if the model parameters changed. The residual environmental score (E_resid) is uncorrelated with G. This does not account for passive rGE but only active rGE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IMLEGIT'
rGE(object, formula, latent_var, index_E, index_G, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rGE.IMLEGIT_+3A_object">object</code></td>
<td>
<p>An object of class &quot;IMLEGIT&quot;, usually, a result of a call to IMLEGIT.</p>
</td></tr>
<tr><td><code id="rGE.IMLEGIT_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="rGE.IMLEGIT_+3A_latent_var">latent_var</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise the latent variables will be named L1, L2, ... (See examples below for more details)</p>
</td></tr>
<tr><td><code id="rGE.IMLEGIT_+3A_index_e">index_E</code></td>
<td>
<p>vector or scalar representing the index of each latent variable that is part of the &quot;environment&quot;</p>
</td></tr>
<tr><td><code id="rGE.IMLEGIT_+3A_index_g">index_G</code></td>
<td>
<p>scalar representing the index of the latent variable for the &quot;genetic&quot; part</p>
</td></tr>
<tr><td><code id="rGE.IMLEGIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the Pearson correlation and Kendall tau correlation of G and E and a glm fit of the main model part when removing the influence of G on E so that E and G are now uncorrelated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note: These examples don't have G and E correlation so the model fit doesn't change 
# but this shows how to use the rGE function
train = example_3way_3latent(500, 1, seed=777)
fit = IMLEGIT(train$data, train$latent_var, y ~ G*E*Z)
# If we assume Z not to be an "environment"
fit_rGE1 = rGE(fit, y ~ G*E, train$latent_var, 2, 1)
fit_rGE1
summary(fit_rGE1$fit_main_resid)
# If we assume Z to be an "environment"
fit_rGE2 = rGE(fit, y ~ G*E, train$latent_var, c(2,3), 1)
fit_rGE2
summary(fit_rGE2$fit_main_resid)
</code></pre>

<hr>
<h2 id='rGE.LEGIT'>Gene-Environment correlation estimation and testing of LEGIT models</h2><span id='topic+rGE.LEGIT'></span>

<h3>Description</h3>

<p>Estimates the gene-environment correlation (rGE) and tests for a GxE using a residual environmental score. If there is an important correlation between G and E, the model is still valid prediction-wise but the interpretation is affected as the question becomes: is it really a GxE or a GxG since E is partially caused by G? To account for this, we remove the influence of G on E (If E = b0 + b1*G + e, we use E_resid = E - b1*G) and refit the model to see if the model parameters changed. The residual environmental score (E_resid) is uncorrelated with G. This does not account for passive rGE but only active rGE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LEGIT'
rGE(object, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rGE.LEGIT_+3A_object">object</code></td>
<td>
<p>An object of class &quot;LEGIT&quot;, usually, a result of a call to LEGIT.</p>
</td></tr>
<tr><td><code id="rGE.LEGIT_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="rGE.LEGIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the Pearson correlation and Kendall tau correlation of G and E and a glm fit of the main model part when removing the influence of G on E so that E and G are now uncorrelated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note: These examples don't have G and E correlation so the model fit doesn't change
# but this shows how to use the rGE function
train = example_2way(500, 1, seed=777)
fit = LEGIT(train$data, train$G, train$E, y ~ G*E)
fit_rGE = rGE(fit, y ~ G*E)
fit_rGE
summary(fit_rGE$fit_main_resid)
</code></pre>

<hr>
<h2 id='stepwise_search'>Stepwise search for the best subset of genetic variants or environments with the LEGIT model</h2><span id='topic+stepwise_search'></span>

<h3>Description</h3>

<p>[Fast, recommended for small number of variables] Adds the best variable or drops the worst variable one at a time in the genetic (if <code>search="genes"</code>) or environmental score (if <code>search="env"</code>). You can select the desired search criterion (AIC, BIC, cross-validation error, cross-validation AUC) to determine which variable is the best/worst and should be added/dropped. Note that when the number of variables in <em>G</em> and <em>E</em> is large, this does not generally converge to the optimal subset, this function is only recommended when you have a small number of variables (e.g. 2 environments, 6 genetic variants). If using cross-validation (<code>search_criterion="cv"</code> or <code>search_criterion="cv_AUC"</code>), to prevent cross-validating with each variable (extremely slow), we recommend setting a p-value threshold (<code>p_threshold</code>) and forcing the algorithm not to look at models with bigger AIC (<code>exclude_worse_AIC=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise_search(
  data,
  formula,
  interactive_mode = FALSE,
  genes_original = NULL,
  env_original = NULL,
  genes_extra = NULL,
  env_extra = NULL,
  search_type = "bidirectional-forward",
  search = "both",
  search_criterion = "AIC",
  forward_exclude_p_bigger = 0.2,
  backward_exclude_p_smaller = 0.01,
  exclude_worse_AIC = TRUE,
  max_steps = 100,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_genes = NULL,
  start_env = NULL,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  print = TRUE,
  remove_miss = FALSE,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise_search_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_formula">formula</code></td>
<td>
<p>Model formula. Use <em>E</em> for the environmental score and <em>G</em> for the genetic score. Do not manually code interactions, write them in the formula instead (ex: G*E*z or G:E:z).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_interactive_mode">interactive_mode</code></td>
<td>
<p>If TRUE, uses interactive mode. In interactive mode, at each iteration, the user is shown the AIC, BIC, p-value and also the cross-validation <code class="reqn">R^2</code> if <code>search_criterion="cv"</code> and the cross-validation AUC if <code>search_criterion="cv_AUC"</code> for the best 5 variables. The user must then enter a number between 1 and 5 to select the variable to be added, entering anything else will stop the search.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_genes_original">genes_original</code></td>
<td>
<p>data.frame of the variables inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_env_original">env_original</code></td>
<td>
<p>data.frame of the variables inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_genes_extra">genes_extra</code></td>
<td>
<p>data.frame of the additionnal variables to try including inside the genetic score <em>G</em> (can be any sort of variable, doesn't even have to be genetic). Set to NULL if using a backward search.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_env_extra">env_extra</code></td>
<td>
<p>data.frame of the variables to try including inside the environmental score <em>E</em> (can be any sort of variable, doesn't even have to be environmental). Set to NULL if using a backward search.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_search_type">search_type</code></td>
<td>
<p>If <code>search_type="forward"</code>, uses a forward search. If <code>search_type="backward"</code>, uses backward search. If <code>search_type="bidirectional-forward"</code>, uses bidirectional search (that starts as a forward search). If <code>search_type="bidirectional-backward"</code>, uses bidirectional search (that starts as a backward search).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_search">search</code></td>
<td>
<p>If <code>search="genes"</code>, uses a stepwise search for the genetic score variables. If <code>search="env"</code>, uses a stepwise search for the environmental score variables. If <code>search="both"</code>, uses a stepwise search for both the gene and environmental score variables (Default = &quot;both&quot;).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_search_criterion">search_criterion</code></td>
<td>
<p>Criterion used to determine which variable is the best to add or worst to drop. If <code>search_criterion="AIC"</code>, uses the AIC, if <code>search_criterion="AICc"</code>, uses the AICc, if <code>search_criterion="BIC"</code>, uses the BIC, if <code>search_criterion="cv"</code>, uses the cross-validation error, if <br /> <code>search_criterion="cv_AUC"</code>, uses the cross-validated AUC, if <code>search_criterion="cv_Huber"</code>, uses the Huber cross-validation error, if <code>search_criterion="cv_L1"</code>, uses the L1-norm cross-validation error (Default = &quot;AIC&quot;). The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers, the lower the values the better.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_forward_exclude_p_bigger">forward_exclude_p_bigger</code></td>
<td>
<p>If p-value &gt; <code>forward_exclude_p_bigger</code>, we do not consider the variable for inclusion in the forward steps (Default = .20). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to 1 to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_backward_exclude_p_smaller">backward_exclude_p_smaller</code></td>
<td>
<p>If p-value &lt; <code>backward_exclude_p_smaller</code>, we do not consider the variable for removal in the backward steps (Default = .01). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to 0 to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_exclude_worse_aic">exclude_worse_AIC</code></td>
<td>
<p>If AIC with variable &gt; AIC without variable, we ignore the variable (Default = TRUE). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to FALSE to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_max_steps">max_steps</code></td>
<td>
<p>Maximum number of steps taken (Default = 50).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification (binary outcome).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_start_genes">start_genes</code></td>
<td>
<p>Optional starting points for genetic score (must be the same length as the number of columns of <code>genes</code>).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_start_env">start_env</code></td>
<td>
<p>Optional starting points for environmental score (must be the same length as the number of columns of <code>env</code>).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_seed">seed</code></td>
<td>
<p>Seed for cross-validation folds.</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_print">print</code></td>
<td>
<p>If TRUE, print all the steps and notes/warnings. Highly recommended unless you are batch running multiple stepwise searchs. (Default=TRUE).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_remove_miss">remove_miss</code></td>
<td>
<p>If TRUE, remove missing data completely, otherwise missing data is only removed when adding or dropping a variable (Default = FALSE).</p>
</td></tr>
<tr><td><code id="stepwise_search_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the class &quot;LEGIT&quot; which is list containing, in the following order: a glm fit of the main model, a glm fit of the genetic score, a glm fit of the environmental score, a list of the true model parameters (AIC, BIC, rank, df.residual, null.deviance) for which the individual model parts (main, genetic, environmental) don't estimate properly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Continuous example
train = example_3way(250, 2.5, seed=777)
# Forward search for genes based on BIC (in interactive mode)
forward_genes_BIC = stepwise_search(train$data, genes_extra=train$G, env_original=train$E,
formula=y ~ E*G*z,search_type="forward", search="genes", search_criterion="BIC",
interactive_mode=TRUE)
# Bidirectional-backward search for environments based on cross-validation error
bidir_backward_env_cv = stepwise_search(train$data, genes_original=train$G, env_original=train$E,
formula=y ~ E*G*z,search_type="bidirectional-backward", search="env", search_criterion="cv")
## Binary example
train_bin = example_2way(500, 2.5, logit=TRUE, seed=777)
# Forward search for genes based on cross-validated AUC (in interactive mode)
forward_genes_AUC = stepwise_search(train_bin$data, genes_extra=train_bin$G, 
env_original=train_bin$E, formula=y ~ E*G,search_type="forward", search="genes", 
search_criterion="cv_AUC", classification=TRUE, family=binomial, interactive_mode=TRUE)
# Forward search for genes based on AIC
bidir_forward_genes_AIC = stepwise_search(train_bin$data, genes_extra=train_bin$G, 
env_original=train_bin$E, formula=y ~ E*G,search_type="bidirectional-forward", search="genes", 
search_criterion="AIC", classification=TRUE, family=binomial)

## End(Not run)
</code></pre>

<hr>
<h2 id='stepwise_search_IM'>Stepwise search for the best subset of elements in the latent variables with the IMLEGIT model</h2><span id='topic+stepwise_search_IM'></span>

<h3>Description</h3>

<p>[Fast, recommended  when the number of variables is small] Adds the best variable or drops the worst variable one at a time in the latent variables. You can select the desired search criterion (AIC, BIC, cross-validation error, cross-validation AUC) to determine which variable is the best/worst and should be added/dropped. Note that when the number of variables in <em>G</em> and <em>E</em> is large, this does not generally converge to the optimal subset, this function is only recommended when you have a small number of variables (e.g. 2 environments, 6 genetic variants). If using cross-validation (<code>search_criterion="cv"</code> or <code>search_criterion="cv_AUC"</code>), to prevent cross-validating with each variable (extremely slow), we recommend setting a p-value threshold (<code>p_threshold</code>) and forcing the algorithm not to look at models with bigger AIC (<code>exclude_worse_AIC=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise_search_IM(
  data,
  formula,
  interactive_mode = FALSE,
  latent_var_original = NULL,
  latent_var_extra = NULL,
  search_type = "bidirectional-forward",
  search = 0,
  search_criterion = "AIC",
  forward_exclude_p_bigger = 0.2,
  backward_exclude_p_smaller = 0.01,
  exclude_worse_AIC = TRUE,
  max_steps = 100,
  cv_iter = 5,
  cv_folds = 10,
  folds = NULL,
  Huber_p = 1.345,
  classification = FALSE,
  start_latent_var = NULL,
  eps = 0.01,
  maxiter = 100,
  family = gaussian,
  ylim = NULL,
  seed = NULL,
  print = TRUE,
  remove_miss = FALSE,
  test_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise_search_IM_+3A_data">data</code></td>
<td>
<p>data.frame of the dataset to be used.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_formula">formula</code></td>
<td>
<p>Model formula. The names of <code>latent_var</code> can be used in the formula to represent the latent variables. If names(<code>latent_var</code>) is NULL, then L1, L2, ... can be used in the formula to represent the latent variables. Do not manually code interactions, write them in the formula instead (ex: G*E1*E2 or G:E1:E2).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_interactive_mode">interactive_mode</code></td>
<td>
<p>If TRUE, uses interactive mode. In interactive mode, at each iteration, the user is shown the AIC, BIC, p-value and also the cross-validation <code class="reqn">R^2</code> if <code>search_criterion="cv"</code> and the cross-validation AUC if <code>search_criterion="cv_AUC"</code> for the best 5 variables. The user must then enter a number between 1 and 5 to select the variable to be added, entering anything else will stop the search.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_latent_var_original">latent_var_original</code></td>
<td>
<p>list of data.frame. The elements of the list are the datasets used to construct each latent variable. For interpretability and proper convergence, not using the same variable in more than one latent variable is highly recommended. It is recommended to set names to the list elements to prevent confusion because otherwise, the latent variables will be named L1, L2, ...</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_latent_var_extra">latent_var_extra</code></td>
<td>
<p>list of data.frame (with the same structure as latent_var_original) containing the additionnal elements to try including inside the latent variables. Set to NULL if using a backward search.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_search_type">search_type</code></td>
<td>
<p>If <code>search_type="forward"</code>, uses a forward search. If <code>search_type="backward"</code>, uses backward search. If <code>search_type="bidirectional-forward"</code>, uses bidirectional search (that starts as a forward search). If <code>search_type="bidirectional-backward"</code>, uses bidirectional search (that starts as a backward search).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_search">search</code></td>
<td>
<p>If <code>search=0</code>, uses a stepwise search for all latent variables. Otherwise, if search = i, uses a stepwise search on the i-th latent variable (Default = 0).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_search_criterion">search_criterion</code></td>
<td>
<p>Criterion used to determine which variable is the best to add or worst to drop. If <code>search_criterion="AIC"</code>, uses the AIC, if <code>search_criterion="AICc"</code>, uses the AICc, if <code>search_criterion="BIC"</code>, uses the BIC, if <code>search_criterion="cv"</code>, uses the cross-validation error, if <br /> <code>search_criterion="cv_AUC"</code>, uses the cross-validated AUC, if <code>search_criterion="cv_Huber"</code>, uses the Huber cross-validation error, if <code>search_criterion="cv_L1"</code>, uses the L1-norm cross-validation error (Default = &quot;AIC&quot;). The Huber and L1-norm cross-validation errors are alternatives to the usual cross-validation L2-norm error (which the <code class="reqn">R^2</code> is based on) that are more resistant to outliers, the lower the values the better.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_forward_exclude_p_bigger">forward_exclude_p_bigger</code></td>
<td>
<p>If p-value &gt; <code>forward_exclude_p_bigger</code>, we do not consider the variable for inclusion in the forward steps (Default = .20). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to 1 to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_backward_exclude_p_smaller">backward_exclude_p_smaller</code></td>
<td>
<p>If p-value &lt; <code>backward_exclude_p_smaller</code>, we do not consider the variable for removal in the backward steps (Default = .01). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to 0 to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_exclude_worse_aic">exclude_worse_AIC</code></td>
<td>
<p>If AIC with variable &gt; AIC without variable, we ignore the variable (Default = TRUE). This is an exclusion option which purpose is skipping variables that are likely not worth looking to make the algorithm faster, especially with cross-validation. Set to FALSE to prevent any exclusion here.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_max_steps">max_steps</code></td>
<td>
<p>Maximum number of steps taken (Default = 50).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_cv_iter">cv_iter</code></td>
<td>
<p>Number of cross-validation iterations (Default = 5).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_cv_folds">cv_folds</code></td>
<td>
<p>Number of cross-validation folds (Default = 10). Using <code>cv_folds=NROW(data)</code> will lead to leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_folds">folds</code></td>
<td>
<p>Optional list of vectors containing the fold number for each observation. Bypass cv_iter and cv_folds. Setting your own folds could be important for certain data types like time series or longitudinal data.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_huber_p">Huber_p</code></td>
<td>
<p>Parameter controlling the Huber cross-validation error (Default = 1.345).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_classification">classification</code></td>
<td>
<p>Set to TRUE if you are doing classification (binary outcome).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_start_latent_var">start_latent_var</code></td>
<td>
<p>Optional list of starting points for each latent variable (The list must have the same length as the number of latent variables and each element of the list must have the same length as the number of variables of the corresponding latent variable).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_eps">eps</code></td>
<td>
<p>Threshold for convergence (.01 for quick batch simulations, .0001 for accurate results).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_family">family</code></td>
<td>
<p>Outcome distribution and link function (Default = gaussian).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_ylim">ylim</code></td>
<td>
<p>Optional vector containing the known min and max of the outcome variable. Even if your outcome is known to be in [a,b], if you assume a Gaussian distribution, predict() could return values outside this range. This parameter ensures that this never happens. This is not necessary with a distribution that already assumes the proper range (ex: [0,1] with binomial distribution).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_seed">seed</code></td>
<td>
<p>Seed for cross-validation folds.</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_print">print</code></td>
<td>
<p>If TRUE, print all the steps and notes/warnings. Highly recommended unless you are batch running multiple stepwise searchs. (Default=TRUE).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_remove_miss">remove_miss</code></td>
<td>
<p>If TRUE, remove missing data completely, otherwise missing data is only removed when adding or dropping a variable (Default = FALSE).</p>
</td></tr>
<tr><td><code id="stepwise_search_IM_+3A_test_only">test_only</code></td>
<td>
<p>If TRUE, only uses the first fold for training and predict the others folds; do not train on the other folds. So instead of cross-validation, this gives you train/test and you get the test R-squared as output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the class &quot;IMLEGIT&quot; which is list containing, in the following order: a glm fit of the main model, a list of the glm fits of the latent variables and a list of the true model parameters (AIC, BIC, rank, df.residual, null.deviance) for which the individual model parts (main, genetic, environmental) don't estimate properly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example
train = example_3way_3latent(250, 1, seed=777)
# Forward search for genes based on BIC (in interactive mode)
forward_genes_BIC = stepwise_search_IM(train$data, 
latent_var_original=list(G=NULL, E=train$latent_var$E, Z=train$latent_var$Z),
latent_var_extra=list(G=train$latent_var$G,E=NULL,Z=NULL), 
formula=y ~ E*G*Z,search_type="forward", search=1, search_criterion="BIC",
interactive_mode=TRUE)
# Bidirectional-backward search for everything based on AIC
bidir_backward_AIC = stepwise_search_IM(train$data, latent_var_extra=NULL, 
latent_var_original=train$latent_var,
formula=y ~ E*G*Z,search_type="bidirectional-backward", search=0, search_criterion="AIC")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.elastic_net_var_select'>Summary function for the output of elastic_net_var_select</h2><span id='topic+summary.elastic_net_var_select'></span>

<h3>Description</h3>

<p>Summary function for the output of elastic_net_var_select
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elastic_net_var_select'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.elastic_net_var_select_+3A_object">object</code></td>
<td>
<p>An object of class &quot;elastic_net_var_select&quot;, usually, a result of a call to elastic_net_var_select.</p>
</td></tr>
<tr><td><code id="summary.elastic_net_var_select_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the unique IMLEGIT models resulting from the glmnet path with associated information. Also gives the cross-validation information if asked.
</p>


<h3>References</h3>

<p>Alexia Jolicoeur-Martineau, Ashley Wazana, Eszter Szekely, Meir Steiner, Alison S. Fleming, James L. Kennedy, Michael J. Meaney, Celia M.T. Greenwood and the MAVAN team. <em>Alternating optimization for GxE modelling with weighted genetic and environmental scores: examples from the MAVAN study</em> (2017). arXiv:1703.08111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
N = 1000
train = example_3way(N, sigma=1, logit=FALSE, seed=7)
g1_bad = rbinom(N,1,.30)
g2_bad = rbinom(N,1,.30)
g3_bad = rbinom(N,1,.30)
g4_bad = rbinom(N,1,.30)
g5_bad = rbinom(N,1,.30)
train$G = cbind(train$G, g1_bad, g2_bad, g3_bad, g4_bad, g5_bad)
lv = list(G=train$G, E=train$E)
fit = elastic_net_var_select(train$data, lv, y ~ G*E)
summary(fit)
best_model(fit, criterion="BIC")
 # Instead of taking the best, if you want the model with "Model index"=17 from summary, do
plot(fit)
# With Cross-validation
fit = elastic_net_var_select(train$data, lv, y ~ G*E, cross_validation=TRUE, cv_iter=1, cv_folds=5)
best_model(fit, criterion="cv_R2")
# Elastic net only applied on G
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(1))
# Elastic net only applied on E
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2))
# Most E variables not removed, use lambda_mult &gt; 1 to remove more
fit = elastic_net_var_select(train$data, lv, y ~ G*E, c(2), lambda_mult=5)
# Lasso (only L1 regularization)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, alpha=1)
# Want more lambdas (useful if # of variables is large)
fit = elastic_net_var_select(train$data, lv, y ~ G*E, n_lambda = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.IMLEGIT'>Summarizing IMLEGIT fits</h2><span id='topic+summary.IMLEGIT'></span>

<h3>Description</h3>

<p>Shows the summary for all parts (main and latent variables) of the LEGIT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IMLEGIT'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.IMLEGIT_+3A_object">object</code></td>
<td>
<p>An object of class &quot;IMLEGIT&quot;, usually, a result of a call to IMLEGIT.</p>
</td></tr>
<tr><td><code id="summary.IMLEGIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of objects of class &quot;summary.glm&quot; containing the summary of each parts (main and latent variables) of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	train = example_2way(250, 1, seed=777)
fit_default = IMLEGIT(train$data, list(G=train$G, E=train$E), y ~ G*E)
summary(fit_default)
</code></pre>

<hr>
<h2 id='summary.LEGIT'>Summarizing LEGIT fits</h2><span id='topic+summary.LEGIT'></span>

<h3>Description</h3>

<p>Shows the summary for all parts (main, genetic, environmental) of the LEGIT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LEGIT'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.LEGIT_+3A_object">object</code></td>
<td>
<p>An object of class &quot;LEGIT&quot;, usually, a result of a call to LEGIT.</p>
</td></tr>
<tr><td><code id="summary.LEGIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of objects of class &quot;summary.glm&quot; containing the summary of each parts (main, genetic, environmental) of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	train = example_2way(250, 1, seed=777)
fit_default = LEGIT(train$data, train$G, train$E, y ~ G*E)
summary(fit_default)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
