<!DOCTYPE html><html><head><title>Help for package BoostMLR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BoostMLR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BoostMLR-package'>
<p>Boosting for Multivariate Longitudinal Response</p></a></li>
<li><a href='#BoostMLR'>
<p>Boosting for Multivariate Longitudinal Response</p></a></li>
<li><a href='#BoostMLR.news'><p>Show the NEWS file</p></a></li>
<li><a href='#Laboratory_Data'>
<p>Laboratory Data</p></a></li>
<li><a href='#partial.BoostMLR'><p>Partial plot analysis</p></a></li>
<li><a href='#plotBoostMLR'>
<p>Plotting results across across the boosting iterations.</p></a></li>
<li><a href='#plotVIMP'>
<p>Variable Importance (VIMP) plot</p></a></li>
<li><a href='#predictBoostMLR'>
<p>Prediction for the multivariate longitudinal response</p></a></li>
<li><a href='#simLong'><p>Simulate longitudinal data</p></a></li>
<li><a href='#updateBoostMLR'>
<p>Update boosting object with an additional boosting iterations</p></a></li>
<li><a href='#vimp.BoostMLR'><p>Variable Importance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Boosting for Multivariate Longitudinal Responses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Amol Pande, Hemant Ishwaran</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amol Pande &lt;amoljpande@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Jointly models the multivariate longitudinal responses and multiple covariates and time using gradient boosting approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18), stats, splines, nlme</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mlbench</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-23 18:26:20 UTC; pandea2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-25 16:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='BoostMLR-package'>
Boosting for Multivariate Longitudinal Response
</h2><span id='topic+BoostMLR-package'></span>

<h3>Description</h3>

<p>The primary feature of the package is to 
jointly model the multiple longitudinal responses (referred to as multivariate longitudinal response) and multiple covariates and time from a longitudinal study using gradient boosting approach (Pande et al., 2020). 
Covariates can be time-varying or time-invariant.
Special cases include modeling of univariate longitudinal
response from a longitudinal study, and univariate or multivariate 
response from a cross-sectional study.
In all cases, responses are assumed to be continuous.
The estimated coefficient can be a function of time (referred to as time-varying coefficient in case of a longitudinal study) or a function of pre-specified covariate (in case of a longitudinal or a cross-sectional study) or fixed.
</p>


<h3>Details</h3>

<p>This package allows joint modeling of a multivariate
longitudinal response, which is based on marginal model.
Estimation is performed using gradient boosting, a generic form
of boosting (Friedman J. H., 2001). The boosting approach use in this package is closely related to
component-wise L2 boosting with L1 penalization.
Package can handle high dimensionalilty of covariate and response
when some of the covariates and responses are pure noise.
</p>
<p>The package is designed to identify covariates that affect responses
differently as different time intervals. This idea is helpful
to dissect an overall effect of covariate into different time
intervals. For example, some covariates affect response at
the beginning of the follow-up whereas others at a later stage.
</p>


<h3>Package Overview</h3>

<p>This package contains many useful functions and users should read the
help file in its entirety for details.  However, we briefly mention
several key functions that may make it easier to navigate and
understand the layout of the package.
</p>

<ol>
<li> <p><code><a href="#topic+BoostMLR">BoostMLR</a></code>
</p>
<p>This is the main entry point to the package. The model is fit
using the gradient boosting approach for the user specified training data.
</p>
</li>
<li> <p><code><a href="#topic+updateBoostMLR">updateBoostMLR</a></code> (<code>updateBoostMLR</code>)
</p>
<p>This allows to update the model by specifying additional boosting iteration.
</p>
</li>
<li> <p><code><a href="#topic+predictBoostMLR">predictBoostMLR</a></code> (<code>predictBoostMLR</code>)
</p>
<p>Model performace can be obtained using the test set data. This function
also estimate variable importance (VIMP).
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>
<p>Maintainer: Amol Pande &lt;amoljpande@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pande A., Ishwaran H., Blackstone E.H. (2020).  Boosting for multivariate
longitudinal response.
</p>
<p>Friedman J.H. (2001). Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BoostMLR">BoostMLR</a></code>,
<code><a href="#topic+updateBoostMLR">updateBoostMLR</a></code>,
<code><a href="#topic+predictBoostMLR">predictBoostMLR</a></code>,
<code><a href="#topic+simLong">simLong</a></code>
</p>

<hr>
<h2 id='BoostMLR'>
Boosting for Multivariate Longitudinal Response
</h2><span id='topic+BoostMLR'></span>

<h3>Description</h3>

<p>Function jointly models the multiple longitudinal responses (referred to as multivariate longitudinal response) and multiple covariates and time from a longitudinal study using gradient boosting approach (Pande et al., 2020). 
Covariates can be time-varying or time-invariant.
Special cases include modeling of univariate longitudinal
response from a longitudinal study, and univariate or multivariate 
response from a cross-sectional study.
In all cases, responses are assumed to be continuous.
The estimated coefficient can be a function of time (referred to as time-varying coefficient in case of a longitudinal study) or a function of pre-specified covariate (in case of a longitudinal or a cross-sectional study) or fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BoostMLR(x,
           tm,
           id,
           y,
           Time_Varying = TRUE,
           BS_Time = TRUE,
           nknots_t = 10,
           d_t = 3,
           All_RawX = TRUE,
           RawX_Names,
           nknots_x = 7,
           d_x = 3,
           M = 200,
           nu = 0.05,
           Mod_Grad = TRUE,
           Shrink = FALSE,
           VarFlag = TRUE,
           lower_perc = 0.25,
           upper_perc = 0.75,
           NLambda = 100,
           Verbose = TRUE,
           Trace = FALSE,
           lambda = 0,
           setting_seed = FALSE,
           seed_value = 100L,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoostMLR_+3A_x">x</code></td>
<td>
<p>Data frame (or matrix) containing x-values (covariates).
The number of rows should match with number of rows of response <code>y</code>.
Covariates can be time-varying or time-invariant.
Missing values are allowed, and are ignored during estimation.
If unspecified, model will be fitted with time alone
(applicable in the situation when the interest is to
obtain an estimated mean response trajectory over time without the influence of any covariates).</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_tm">tm</code></td>
<td>
<p>Vector of time values, one entry for each row of the response <code>y</code>.
In case of a longitudinal study, the estimated coefficient will be a function
of <code>tm</code> when <code>Time_Varying</code> = TRUE.
If unspecified, data is assumed to be generated from a
cross-sectional study, and the relationship between
<code>y</code> and <code>x</code> can be obtained.
In case of a longitudinal or cross-sectional study, coefficient can be
a function of covariate <code>z</code> which is not a part of <code>x</code> by
using <code>z</code> in place of <code>tm</code> or it can be fixed when <code>Time_Varying</code> = FALSE.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_id">id</code></td>
<td>
<p>Vector of subject identifier with same length as the number of rows of <code>y</code>.
If <code>id</code> is unspecified along with <code>tm</code>, data is assumed to be generated from a cross-sectional study, and the relationship between
<code>y</code> and <code>x</code> can be obtained.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_y">y</code></td>
<td>
<p>Data frame (or matrix) containing the y-values (response) in case of multivariate
response or a vector of y-values in case of univariate response.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_time_varying">Time_Varying</code></td>
<td>
<p>Time-varying coefficient model or a fixed coefficient model?</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_bs_time">BS_Time</code></td>
<td>
<p>If <code>tm</code> is specified, should <code>tm</code> is mapped using B-spline or use original scale of <code>tm</code>? Default is TRUE, which allows mapping of <code>tm</code>
using B-spline.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_nknots_t">nknots_t</code></td>
<td>
<p>If <code>BS_Time</code> = TRUE, specify number of knots for B-spline of <code>tm</code>.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_d_t">d_t</code></td>
<td>
<p>If <code>BS_Time</code> = TRUE, specify degree of polynomial for B-spline of <code>tm</code>.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_all_rawx">All_RawX</code></td>
<td>
<p>Use original scale of <code>x</code> or map each covariate using
B-spline? Default is TRUE, which means original scale of <code>x</code> is used;
if FALSE, covariates measured on continuous scale will be mapped using B-splines.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_rawx_names">RawX_Names</code></td>
<td>
<p>If <code>All_RawX</code> = FALSE, specify names of the covariates,
measured on a continuous scale, that should be used as it is without mapping
using B-spline.
Note that, even if <code>All_RawX</code> = FALSE, covariates not measured on a
continuous scale, such as binary, nominal, and ordinal covariates will be
used without mapping.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_nknots_x">nknots_x</code></td>
<td>
<p>Specify number of knots for B-spline of <code>x</code>. This can be a vector of length equal to the number of covariates or a scalar. 
If scalar, same value will be used for all covariates.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_d_x">d_x</code></td>
<td>
<p>Specify degree of polynomial for B-spline of <code>x</code>. This can be a vector of length equal to the number of covariates or a scalar. 
If scalar, same value will be used for all covariates.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_m">M</code></td>
<td>
<p>Number of boosting iterations.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_nu">nu</code></td>
<td>
<p>Boosting regularization parameter.  A value from the interval (0,1].</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_mod_grad">Mod_Grad</code></td>
<td>
<p>Use a modified gradient? Modified gradient is a special type
of gradient that is independent of the correlation coefficient.
Pande A. (2017) observed that prediction performance increases
under modified gradient.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_shrink">Shrink</code></td>
<td>
<p>Allow estimated coefficient to shrink to zero using
L1 penalization?</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_varflag">VarFlag</code></td>
<td>
<p>Estimate the variance (scale parameter) and correlation parameter
for each <code>y</code>? Applicable for a longitudinal study. If <code>VarFlag</code> = FALSE,
a fixed value of scale parameter = 1 and correlation parameter = 0 is used.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_lower_perc">lower_perc</code></td>
<td>
<p>Lower percentile value is used to determine the lower cut-off for the distribution of parameter estimate. Applicable when <code>Shrink</code> = TRUE.
Refer to Pande et al. (2020) for details.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_upper_perc">upper_perc</code></td>
<td>
<p>Upper percentile value is used to determine the upper cut-off for the distribution of parameter estimate. Applicable when <code>Shrink</code> = TRUE.
Refer to Pande et al. (2020) for details.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_nlambda">NLambda</code></td>
<td>
<p>Number of replications for generating distribution of parameter estimates. Applicable when <code>Shrink</code> = TRUE. Refer to Pande et al. (2020) for details.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_verbose">Verbose</code></td>
<td>
<p>Print the current stage of boosting iteration?</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_trace">Trace</code></td>
<td>
<p>Print the current stage of execution? Useful for identifying location in case error occurs.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_lambda">lambda</code></td>
<td>
<p>Additional penaulty; not implemented at this time.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_setting_seed">setting_seed</code></td>
<td>
<p>Set <code>setting_seed</code> = TRUE if you intend to reproduce the result.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_seed_value">seed_value</code></td>
<td>
<p>Seed value.</p>
</td></tr>
<tr><td><code id="BoostMLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a non-parametric approach for joint modeling of a multivariate
longitudinal response, which is based on marginal model.
Estimation is performed using gradient boosting, a generic form
of boosting (Friedman J. H., 2001). Our boosting approach is closely related to
component-wise L2 boosting with L1 penalization.
Approach can handle high dimensionalilty of covariate and response
when some of the covariates and responses are pure noise.
</p>
<p>Approach is designed to identify covariates that affect responses
differently as different time intervals. This idea is helpful
to dissect an overall effect of covariate into different time
intervals. For example, some covariates affect response at
the beginning of the follow-up whereas others at a later stage.
</p>
<p>Shrinking allows for early termination of boosting to prevent overfitting. Also, it provides a parsimonious model by shrinking coefficient for non-informative covariate-response pair to zero.</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Matrix containing x-values.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Vector of subject identifier.</p>
</td></tr>
<tr><td><code>tm</code></td>
<td>
<p>Vector of time values.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Matrix containing y-values.</p>
</td></tr>
<tr><td><code>UseRaw</code></td>
<td>
<p>Logical vector indicating indexes of covariates which are used as it is
without B-spline mapping.</p>
</td></tr>
<tr><td><code>x_Names</code></td>
<td>
<p>Variable names of <code>x</code>.</p>
</td></tr>
<tr><td><code>y_Names</code></td>
<td>
<p>Variable names of <code>y</code>.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Number of boosting iterations. If boosting terminates before
a pre-specified <code>M</code>, this indicates the last boosting iteration 
before termination.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>Regularization parameter.</p>
</td></tr>
<tr><td><code>Tm_Beta</code></td>
<td>
<p>An estimate of the parameter beta. This consist of a list of
length equal to the number of multivariate response (denoted by L). If <code>Time_Varying</code> = TRUE, each element from the list represents a matrix with number of columns equal to the number of covariates and the number of rows equal to the length of <code>tm</code>. Each column of the matrix represents an estimate of time-varying coefficient for the given covariate. If <code>Time_Varying</code> = FALSE, in place of estimate of time-varying coefficient, a fixed estimate is provided similar to the estimate from a parametric model. 
The result is provided for covariates who are treated as it is (i.e., the original scale); for covariates who are mapped using B-spline, the estimates are difficult to interprete and therefore the output is NA.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Estimate of the conditional expectation of <code>y</code> corresponding to the M'th boosting iterations.</p>
</td></tr>
<tr><td><code>Error_Rate</code></td>
<td>
<p>Training error rate for each response across 
the boosting iterations.</p>
</td></tr>
<tr><td><code>Variable_Select</code></td>
<td>
<p>Indexes of important covariates that get picked-up across time and across boosting iterations. Result is shown as a matrix with M rows and H 
(number of overlapping time intervals) columns, where each element represents
index of covariate.</p>
</td></tr>
<tr><td><code>Response_Select</code></td>
<td>
<p>Indexes of important responses that get picked-up across time and across boosting iterations. Result is shown as a matrix with M rows and H
columns, where each element represents index of response variable.</p>
</td></tr>
<tr><td><code>VarFlag</code></td>
<td>
<p>Whether the variance (scale parameter) and correlation are estimated?</p>
</td></tr>
<tr><td><code>Time_Varying</code></td>
<td>
<p>Whether estimates are time-varying or fixed?</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>Matrix, having dimension M by L, representing an estimate of variance (scale parameter) for each response across the boosting iterations.</p>
</td></tr>
<tr><td><code>Rho</code></td>
<td>
<p>Matrix, having dimension M by L, represent an estimate of correlation for each response across the boosting iterations.</p>
</td></tr>
<tr><td><code>Lambda_List</code></td>
<td>
<p>Estimate of the lambda (the L1 penaulty parameter) for each boosting iterations. Useful for internal calculation.</p>
</td></tr>
<tr><td><code>Grow_Object</code></td>
<td>
<p>Useful for internal calculation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>References</h3>

<p>Pande A., Ishwaran H., Blackstone E.H. (2020).  Boosting for multivariate
longitudinal response.
</p>
<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305.
</p>
<p>Pande A. (2017).  <em>Boosting for longitudinal data</em>.  Ph.D. Dissertation,
Miller School of Medicine, University of Miami.
</p>
<p>Friedman J.H. (2001). Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updateBoostMLR">updateBoostMLR</a></code>,
<code><a href="#topic+predictBoostMLR">predictBoostMLR</a></code>,
<code><a href="#topic+simLong">simLong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##-----------------------------------------------------------------
## Multivariate Longitudinal Response
##-----------------------------------------------------------------

# Simulate data involves 3 response and 4 covariates

dta &lt;- simLong(n = 100, N = 5, rho =.80, model = 1, q_x = 0, 
                                  q_y = 0,type = "corCompSym")$dtaL

# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dta$features, tm = dta$time, id = dta$id, 
                            y = dta$y, M = 100, VarFlag = FALSE)

# Plot training error
plotBoostMLR(boost.grow$Error_Rate,xlab = "m",ylab = "Training Error")


##-----------------------------------------------------------------
## Laboratory data
##-----------------------------------------------------------------

data(Laboratory_Data, package = "BoostMLR")

Var_Names &lt;- colnames(Laboratory_Data)
x_Names &lt;- setdiff(Var_Names, c("id","time","tbili_po","creat_po"))

dta_id &lt;- Laboratory_Data[,"id"]
dta_time &lt;- Laboratory_Data[,"time"]
dta_x &lt;- Laboratory_Data[,x_Names]
dta_y &lt;- Laboratory_Data[,c("tbili_po","creat_po")]

boost.grow &lt;- BoostMLR(x = dta_x,tm = dta_time,id = dta_id,y = dta_y,
                           Time_Varying = TRUE,BS_Time = TRUE,
                           All_RawX = TRUE,M = 10, VarFlag = TRUE)

##-----------------------------------------------------------------
## Univariate Longitudinal Response
##-----------------------------------------------------------------

# Simulate data involves 1 response and 4 covariates

dta &lt;- simLong(n = 100, N = 5, rho =.80, model = 2, q_x = 0, 
                                  q_y = 0,type = "corCompSym")$dtaL

# Boosting call: B-spline for time and covariates, shrinkage, 
# estimate of rho and phi 

boost.grow &lt;- BoostMLR(x = dta$features, tm = dta$time, id = dta$id, 
                          y = dta$y, M = 100, BS_Time = TRUE,
                          All_RawX = FALSE, Shrink = TRUE,VarFlag = TRUE)

# Plot training error
plotBoostMLR(boost.grow$Error_Rate,xlab = "m",ylab = "Training Error")

# Plot phi
plotBoostMLR(boost.grow$Phi,xlab = "m",ylab = "phi")

# Plot rho
plotBoostMLR(boost.grow$Rho,xlab = "m",ylab = "rho")


##-----------------------------------------------------------------
## Multivariate Longitudinal Response
##-----------------------------------------------------------------

# Simulate data involves 3 response and 4 covariates

dta &lt;- simLong(n = 100, N = 5, rho =.80, model = 1, q_x = 0, 
                                  q_y = 0,type = "corCompSym")$dtaL

# Boosting call: Raw values of covariates, fixed parameter estimates
# instead of time varying, no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dta$features, tm = dta$time, id = dta$id, 
                       y = dta$y, M = 100,Time_Varying = FALSE,VarFlag = FALSE)

# Print parameter estimates
boost.grow$Tm_Beta

##-----------------------------------------------------------------
## Multivariate Response from Cross-sectional Data: Estimated 
## coefficient as a function of covariate
##-----------------------------------------------------------------

if (library("mlbench", logical.return = TRUE)) {
data("BostonHousing")

x &lt;- BostonHousing[,c(1:7,9:12)]
tm &lt;- BostonHousing[,8]
id &lt;- 1:nrow(BostonHousing)
y &lt;- BostonHousing[,13:14]

# Boosting call: Raw values of covariates, B-spline for covariate "dis", 
# no shrinkage

boost.grow &lt;- BoostMLR(x = x, tm = tm, id = id, y = y, M = 100,VarFlag = FALSE)

# Plot training error
plotBoostMLR(boost.grow$Error_Rate,xlab = "m",ylab = "Training Error",
                                              legend_fraction_x = 0.2)
}
##-----------------------------------------------------------------
## Univariate Response from Cross-sectional Data: Fixed estimated 
## coefficient
##-----------------------------------------------------------------

if (library("mlbench", logical.return = TRUE)) {
library(mlbench)
data("BostonHousing")

x &lt;- BostonHousing[,1:13]
y &lt;- BostonHousing[,14]

# Boosting call: Raw values of covariates

boost.grow &lt;- BoostMLR(x = x, y = y, M = 100)

# Plot training error
plotBoostMLR(boost.grow$Error_Rate,xlab = "m",ylab = "Training Error",
                                               legend_fraction_x = 0.2)
}

</code></pre>

<hr>
<h2 id='BoostMLR.news'>Show the NEWS file</h2><span id='topic+BoostMLR.news'></span>

<h3>Description</h3>

<p>Show the NEWS file of the BoostMLR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoostMLR.news(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoostMLR.news_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>

<hr>
<h2 id='Laboratory_Data'>
Laboratory Data
</h2><span id='topic+Laboratory_Data'></span>

<h3>Description</h3>

<p>The laboratory data is based on 459 patients who were listed
for heart transplant and were put on mechanical circulatory
system through device implantation from December 1991 to
July 2009 at Cleveland Clinic. These patients had periodic
measurements of their bilirubin and creatinine levels.
Data from 459 patients includes 18285 measurements
of bilirubin and creatinine with
an average of 39 measurements per patient.
</p>


<h3>Format</h3>

<p>Laboratory data has 4 parts:
</p>

<ol>
<li><p>  A total of 41 x-variables.
</p>
</li>
<li><p>  Time points (time).
</p>
</li>
<li><p>  Patient identifier (id).
</p>
</li>
<li><p>  Longitudinal responses (tbili_po and creat_po).
</p>
</li></ol>



<h3>References</h3>

<p>Rajeswaran J., Blackstone E.H. and Bernard J.
Evolution of association between renal and liver function
while awaiting for the heart transplant: An application using
bivariate multiphase nonlinear mixed effect model.
<em>Statistical methods in medical research</em> 27(7):2216&ndash;2230, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Laboratory_Data, package = "BoostMLR")</code></pre>

<hr>
<h2 id='partial.BoostMLR'>Partial plot analysis</h2><span id='topic+partial.BoostMLR'></span>

<h3>Description</h3>

<p>Partial dependence plot of x and time against adjusted predicted y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BoostMLR'
partial(Object,
        xvar.name,
        n.x = 10,
        n.tm = 10,
        x.unq = NULL,
        tm.unq = NULL,
        Mopt,
        plot.it = TRUE,
        path_saveplot = NULL,
        Verbose = TRUE,
        ...)
        </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial.BoostMLR_+3A_object">Object</code></td>
<td>
<p>A boosting object of class <code>(BoostMLR, grow)</code>.</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_xvar.name">xvar.name</code></td>
<td>
<p>Name of the x-variable to be used for partial plot.</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_n.x">n.x</code></td>
<td>
<p>Maximum number of unique points used for <code>xvar.name</code>. Reduce this value if
plotting is slow.</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_n.tm">n.tm</code></td>
<td>
<p>Maximum number of unique points used for <code>tm</code>. Reduce this value if
plotting is slow.</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_x.unq">x.unq</code></td>
<td>
<p>Unique values used for the partial plot for variable <code>xvar.name</code>. 
Default is NULL in which case
unique values are obtained uniformaly based on the range of variable.</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_tm.unq">tm.unq</code></td>
<td>
<p>Unique time points used for the partial plots of x against y.
Default is NULL in which case
unique values are obtained uniformaly based on the range of <code>tm</code>.
</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_mopt">Mopt</code></td>
<td>
<p>The optimal number of boosting iteration. If missing, the value from 
the <code>Object</code> will be used.</p>
</td></tr> 
<tr><td><code id="partial.BoostMLR_+3A_plot.it">plot.it</code></td>
<td>
<p>Should partial plot be displayed?</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_path_saveplot">path_saveplot</code></td>
<td>

<p>Provide the location where plot should be saved. By default the plot will be
saved at temporary folder.
</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_verbose">Verbose</code></td>
<td>

<p>Display the path where the plot is saved?
</p>
</td></tr>
<tr><td><code id="partial.BoostMLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partial dependence plot (Friedman, 2001) of x values specified by
<code>xvar.name</code> against the adjusted predicted y-values over a set
of time points specified by <code>tm.unq</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x.unq</code></td>
<td>
<p>Unique values used for the partial plot for variable <code>xvar.name</code></p>
</td></tr>
<tr><td><code>tm.unq</code></td>
<td>
<p>Unique time points used for the partial plots of x against y.</p>
</td></tr>
<tr><td><code>pList</code></td>
<td>
<p>List with number of elements equal to number of multivariate response.
Each element of the list is a matrix with number of rows equal to length of <code>x.unq</code>,
and number of columns equal to length of <code>tm.unq</code>. Values in the matrix represent
predicted partial values.</p>
</td></tr>
<tr><td><code>sList</code></td>
<td>
<p>List with number of elements equal to number of multivariate response.
Each element is a matrix with the same dimension as described in <code>pList</code>.
Values are calculated using the local smoother (loess) for <code>tm.unq</code> and the i'th row
of the matrix from <code>pList</code>. Users are encouraged to use <code>pList</code> to
genenrate their own <code>sList</code> so that they will have more control over the
different arguments of local smoother.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>References</h3>

<p>Friedman J.H. Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##------------------------------------------------------------
## Generate partial plot for covariate x1
##-------------------------------------------------------------

dta &lt;- simLong(n = 100, N = 5, rho =.80, model = 1, q_x = 0, 
                                  q_y = 0,type = "corCompSym")$dtaL

# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dta$features, tm = dta$time, id = dta$id, 
                            y = dta$y, M = 100, VarFlag = FALSE)

Partial_Plot_x1 &lt;- partial.BoostMLR(Object = boost.grow, xvar.name = "x1",plot.it = FALSE)


</code></pre>

<hr>
<h2 id='plotBoostMLR'>
Plotting results across across the boosting iterations.
</h2><span id='topic+plotBoostMLR'></span>

<h3>Description</h3>

<p>Plotting training and test error, and estimate of variance/correlation parameters
across the boosting iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBoostMLR(Result,
             xlab = "",
             ylab = "",
             legend_fraction_x = 0.10,
             legend_fraction_y = 0,
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBoostMLR_+3A_result">Result</code></td>
<td>

<p>Result in the matrix form either training or test error, or estimate of variance/correlation
parameters across the boosting iterations.
</p>
</td></tr>
<tr><td><code id="plotBoostMLR_+3A_xlab">xlab</code></td>
<td>

<p>Label for the x-axis.
</p>
</td></tr>
<tr><td><code id="plotBoostMLR_+3A_ylab">ylab</code></td>
<td>

<p>Label for the y-axis.
</p>
</td></tr>
<tr><td><code id="plotBoostMLR_+3A_legend_fraction_x">legend_fraction_x</code></td>
<td>

<p>Value use to expland the x-axis.  
</p>
</td></tr>
<tr><td><code id="plotBoostMLR_+3A_legend_fraction_y">legend_fraction_y</code></td>
<td>

<p>Value use to expland the y-axis.</p>
</td></tr>
<tr><td><code id="plotBoostMLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting training and test error, and estimate of variance/correlation parameters
across the boosting iterations.
</p>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##-----------------------------------------------------------------
## Multivariate Longitudinal Response
##-----------------------------------------------------------------

# Simulate data involves 3 response and 4 covariates

dta &lt;- simLong(n = 100, N = 5, rho =.80, model = 1, q_x = 0, 
                                  q_y = 0,type = "corCompSym")$dtaL

# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dta$features, tm = dta$time, id = dta$id, 
                            y = dta$y, M = 100, VarFlag = FALSE)

# Plot training error
plotBoostMLR(boost.grow$Error_Rate,xlab = "m",ylab = "Training Error")

</code></pre>

<hr>
<h2 id='plotVIMP'>
Variable Importance (VIMP) plot
</h2><span id='topic+plotVIMP'></span>

<h3>Description</h3>

<p>Barplot displaying variable importance for the main effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVIMP(vimp_Object,
         xvar.names = NULL,
         cex.xlab = NULL,
         ymaxlim = 0,
         yminlim = 0,
         main = "Variable Importance (%)",
         col = grey(0.8),
         cex.lab = 1.5,
         ylbl = NULL,
         legend_placement = NULL,
         plot.it = TRUE,
         path_saveplot = NULL,
         Verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVIMP_+3A_vimp_object">vimp_Object</code></td>
<td>

<p>List with number of elements equal to the number of response variables.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_xvar.names">xvar.names</code></td>
<td>

<p>Names of the covariates. If NULL, names will be pulled from <code>vimp_Object</code>.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_cex.xlab">cex.xlab</code></td>
<td>

<p>Magnification of the names of the covariates for the barplot.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_ymaxlim">ymaxlim</code></td>
<td>

<p>By default, we use the range of the vimp values for the barplot limit on the y-axis. If one wants to extend the limit, add the amount with which the limit will extend above the x-axis.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_yminlim">yminlim</code></td>
<td>

<p>Similar to <code>ymaxlim</code>, this will add the amount with which the limit will extend below the x-axis.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_main">main</code></td>
<td>

<p>Main title for the plot.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_col">col</code></td>
<td>

<p>Color of the plot.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_cex.lab">cex.lab</code></td>
<td>

<p>Magnification of the x and y lables.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_ylbl">ylbl</code></td>
<td>

<p>Label for the y-axis.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_legend_placement">legend_placement</code></td>
<td>

<p>Do you want name of the covariates on top of the each barplot? If so, use
default setting; else set value on the negative direction of y-axis
which arrange covariate name beneath the barplot.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_plot.it">plot.it</code></td>
<td>
<p>Should the VIMP plot be displayed?</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_path_saveplot">path_saveplot</code></td>
<td>

<p>Provide the location where plot should be saved. By default the plot will be
saved at temporary folder.
</p>
</td></tr>
<tr><td><code id="plotVIMP_+3A_verbose">Verbose</code></td>
<td>

<p>Display the path where the plot is saved?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Barplot displaying VIMP for each response. Barplot will be save as
pdf file in the working directory.
</p>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##-----------------------------------------------------------------
## VIMP plot for multivariate longitudinal response
##-----------------------------------------------------------------

# Simulate data involves 3 response and 4 covariates

dta &lt;- simLong(n = 100, ntest = 100 ,N = 5, rho =.80, model = 1, q_x = 0, 
                                  q_y = 0,type = "corCompSym")
dtaL &lt;- dta$dtaL
trn &lt;- dta$trn
# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dtaL$features[trn,], tm = dtaL$time[trn], 
                      id = dtaL$id[trn], y = dtaL$y[trn,], M = 100, VarFlag = FALSE)

boost.pred &lt;- predictBoostMLR(Object = boost.grow, x = dtaL$features[-trn,], 
                               tm = dtaL$time[-trn], id = dtaL$id[-trn], 
                               y = dtaL$y[-trn,], importance = TRUE)

# Plot VIMP
plotVIMP(vimp_Object = boost.pred$vimp,ymaxlim = 20,plot.it = FALSE)

</code></pre>

<hr>
<h2 id='predictBoostMLR'>
Prediction for the multivariate longitudinal response
</h2><span id='topic+predictBoostMLR'></span>

<h3>Description</h3>

<p>Function returns predicted values for the response. Also, if the response
is provided, function returns test set performance, optimal boosting
iteration, and variable importance (VIMP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictBoostMLR(Object,
                x,
                tm,
                id,
                y,
                M,
                importance = FALSE,
                eps = 1e-5,
                setting_seed = FALSE,
                seed_value = 100L,
                ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictBoostMLR_+3A_object">Object</code></td>
<td>
<p>A boosting object obtained using the function <code>BoostMLR</code>
on the training data.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_x">x</code></td>
<td>
<p>Data frame (or matrix) containing the test set x-values (covariates).   
Covariates can be time-varying or time-invariant.
If <code>x</code> is unspecified while growing the <code>Object</code>, it should be
unspecified here as well.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_tm">tm</code></td>
<td>
<p>Vector of test set time values.
If <code>tm</code> is unspecified while growing the <code>Object</code>, it should be
unspecified here as well.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_id">id</code></td>
<td>
<p>Vector of test set subject identifier.
If <code>id</code> is unspecified while growing the <code>Object</code>, it should be
unspecified here as well.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_y">y</code></td>
<td>
<p>Data frame (or matrix) containing the test set y-values 
(response) in case of multivariate response or a 
vector of y-values in case of univariate response.
If <code>y</code> is unspecified then predicted values corresponding to <code>x</code>
and <code>tm</code> can be obtained but no performance measure such as
test set error and VIMP.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_m">M</code></td>
<td>
<p>Number of boosting iterations. Value should be less than or equal
to the value specified in the <code>Object</code>. If unspecified, value from 
the <code>Object</code> will be used.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_importance">importance</code></td>
<td>
<p>Whether to calculate standardized variable importance (VIMP) for each covariate?</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_eps">eps</code></td>
<td>
<p>Tolerance value used for determining the optimal <code>M</code>.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_setting_seed">setting_seed</code></td>
<td>
<p>Set <code>setting_seed</code> = TRUE if you intend to reproduce the result.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_seed_value">seed_value</code></td>
<td>
<p>Seed value.</p>
</td></tr>
<tr><td><code id="predictBoostMLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predicted response and performance values are obtained for
the test data using the <code>Object</code> grown using function <code>BoostMLR</code> on
the training data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Data</code></td>
<td>
<p>A list with elements <code>x</code>, <code>tm</code>, <code>id</code> 
and <code>y</code>. Additionally, the list include mean and 
standard deviation of <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code>x_Names</code></td>
<td>
<p>Variable names of <code>x</code>.</p>
</td></tr>
<tr><td><code>y_Names</code></td>
<td>
<p>Variable names of <code>y</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Estimate of conditional expectation of <code>y</code> corresponding
to the last boosting iteration.</p>
</td></tr>
<tr><td><code>mu_Mopt</code></td>
<td>
<p>Estimate of conditional expectation of <code>y</code> corresponding
to the optimal boosting iteration.</p>
</td></tr>
<tr><td><code>Error_Rate</code></td>
<td>
<p>Test set error rate for each multivariate response across the boosting iterations.</p>
</td></tr>
<tr><td><code>Mopt</code></td>
<td>
<p>The optimal number of boosting iteration.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>Regularization parameter.</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>Test set standardized root mean square error (sRMSE) at the <code>Mopt</code>.</p>
</td></tr>
<tr><td><code>vimp</code></td>
<td>
<p>Standardized VIMP for each covariate. This consist of a list of
length equal to the number of multivariate response.
Each element from the list represents a matrix with number of rows equal to the number of covariates and the number of columns equal to the number of overlapping time intervals + 1 where the first column contains covariate main effects and all other columns contain covariate-time interaction effects.</p>
</td></tr>
<tr><td><code>Pred_Object</code></td>
<td>
<p>Useful for internal calculation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>References</h3>

<p>Pande A., Ishwaran H., Blackstone E.H. (2020).  Boosting for multivariate
longitudinal response.
</p>
<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305.
</p>
<p>Pande A. (2017).  <em>Boosting for longitudinal data</em>.  Ph.D. Dissertation,
Miller School of Medicine, University of Miami.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BoostMLR">BoostMLR</a></code>,
<code><a href="#topic+updateBoostMLR">updateBoostMLR</a></code>,
<code><a href="#topic+simLong">simLong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##-----------------------------------------------------------------
## Multivariate Longitudinal Response
##-----------------------------------------------------------------

# Simulate data involves 3 response and 4 covariates

dta &lt;- simLong(n = 100, ntest = 100 ,N = 5, rho =.80, model = 1, q_x = 0, 
                                  q_y = 0,type = "corCompSym")
dtaL &lt;- dta$dtaL
trn &lt;- dta$trn
# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dtaL$features[trn,], tm = dtaL$time[trn], 
                      id = dtaL$id[trn], y = dtaL$y[trn,], M = 100, VarFlag = FALSE)

boost.pred &lt;- predictBoostMLR(Object = boost.grow, x = dtaL$features[-trn,], 
                               tm = dtaL$time[-trn], id = dtaL$id[-trn], 
                               y = dtaL$y[-trn,], importance = TRUE)
# Plot test set error
plotBoostMLR(boost.pred$Error_Rate,xlab = "m",ylab = "Test Set Error",
                                              legend_fraction_x = 0.2)

</code></pre>

<hr>
<h2 id='simLong'>Simulate longitudinal data</h2><span id='topic+simLong'></span>

<h3>Description</h3>

<p>Simulates longitudinal data from multivariate and univariate longitudinal 
response model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simLong(n = 100,
        ntest = 0,
        N = 5,
        rho = 0.8,
        model = c(1, 2),
        phi = 1,
        q_x = 0,
        q_y = 0,
        type = c("corCompSym", "corAR1", "corSymm", "iid"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simLong_+3A_n">n</code></td>
<td>
<p>Requested training sample size.</p>
</td></tr>
<tr><td><code id="simLong_+3A_ntest">ntest</code></td>
<td>
<p>Requested test sample size.</p>
</td></tr>
<tr><td><code id="simLong_+3A_n">N</code></td>
<td>
<p>Parameter controlling number of time points per subject.</p>
</td></tr>
<tr><td><code id="simLong_+3A_rho">rho</code></td>
<td>
<p>Correlation parameter.</p>
</td></tr>
<tr><td><code id="simLong_+3A_model">model</code></td>
<td>
<p>Requested simulation model.</p>
</td></tr>
<tr><td><code id="simLong_+3A_phi">phi</code></td>
<td>
<p>Variance of measurement error.</p>
</td></tr>
<tr><td><code id="simLong_+3A_q_x">q_x</code></td>
<td>
<p>Number of noise covariates.</p>
</td></tr>
<tr><td><code id="simLong_+3A_q_y">q_y</code></td>
<td>
<p>Number of noise responses.</p>
</td></tr>
<tr><td><code id="simLong_+3A_type">type</code></td>
<td>
<p>Type of correlation matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates longitudinal data from multivariate and univariate longitudinal 
response model. We consider following 2 models:
</p>

<ol>
<li> <p><em><code>model=1</code>:</em> Simpler linear model consist of three
longitudinal responses, <code>y1</code>, <code>y2</code>, and <code>y3</code> and
four covariates <code>x1</code>, <code>x2</code>, <code>x3</code>, and <code>x4</code>. 
Response <code>y1</code> is associated with <code>x1</code> and <code>x4</code>.
Response <code>y2</code> is associated with <code>x2</code> and <code>x4</code>.
Response <code>y3</code> is associated with <code>x3</code> and <code>x4</code>.
</p>
</li>
<li> <p><em><code>model=2</code>:</em> Relatively complex model consist of
single longitudinal response and four covariates. Model includes
non-linear relationship between response and covariates and
covariate-time interaction.
</p>
</li></ol>



<h3>Value</h3>

<p>An invisible list with the following components:
</p>
<table>
<tr><td><code>dtaL</code></td>
<td>
<p>List containing the simulated data in the following order:
<code>features</code>, <code>time</code>, <code>id</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code>dta</code></td>
<td>
<p>Simulated data given as a data frame.</p>
</td></tr>
<tr><td><code>trn</code></td>
<td>
<p>Index of <code>id</code> values identifying the training data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>References</h3>

<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305. 
</p>

<hr>
<h2 id='updateBoostMLR'>
Update boosting object with an additional boosting iterations
</h2><span id='topic+updateBoostMLR'></span>

<h3>Description</h3>

<p>Function allows to update boosting object with an additional boosting iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateBoostMLR(Object,
               M_Add,
               Verbose = TRUE,
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateBoostMLR_+3A_object">Object</code></td>
<td>
<p>Boosting object. This object is previously obtained using <code>BoostMLR</code> function or using <code>update</code> function.</p>
</td></tr>
<tr><td><code id="updateBoostMLR_+3A_m_add">M_Add</code></td>
<td>
<p>Number of additional boosting iterations.</p>
</td></tr>
<tr><td><code id="updateBoostMLR_+3A_verbose">Verbose</code></td>
<td>
<p>Print the current stage of boosting iteration?</p>
</td></tr>
<tr><td><code id="updateBoostMLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In boosting, <code>Mopt</code>, the number of boosting iterations
required to achive optimal result, is unknown. 
Typically, <code>Mopt</code> is estimated by specifying a large value
of <code>M</code> and then search for an optimal value that is less 
than <code>M</code> using the test data. 
Function <code>update</code> allows user to start with a small value of <code>M</code>, and keep increamenting boosting iterations, each time running through the test data, until an optimal boosting iteration is found. This can significantly reduce unnecessary computations, particularly when <code>Mopt</code> &lt;&lt; <code>M</code>.
The procedure can be replicated multiple times using the boosting object (see example below).
Results from <code>update</code> can be treated the same way we treat results
from <code>BoostMLR</code>.
</p>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BoostMLR">BoostMLR</a></code>,
<code><a href="#topic+predictBoostMLR">predictBoostMLR</a></code>,
<code><a href="#topic+simLong">simLong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##-----------------------------------------------------------------
## Univariate Longitudinal Response
##-----------------------------------------------------------------

# Simulate data involves 1 response and 4 covariates

dta &lt;- simLong(n = 100, N = 5, rho =.80, model = 2, q_x = 0, 
                                  q_y = 0,type = "corCompSym")$dtaL

# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dta$features, tm = dta$time, id = dta$id, 
                          y = dta$y, M = 100, VarFlag = FALSE)
                          
# Update boosting object for the additional 100 iteration
boost.grow &lt;- updateBoostMLR(Object = boost.grow, M_Add = 100,Verbose = TRUE)

# Update boosting object for the additional 50 iteration
boost.grow &lt;- updateBoostMLR(Object = boost.grow, M_Add = 50,Verbose = TRUE)

</code></pre>

<hr>
<h2 id='vimp.BoostMLR'>Variable Importance</h2><span id='topic+vimp.BoostMLR'></span>

<h3>Description</h3>

<p>Calculate standardized variable importance (VIMP) for each covariate or a joint VIMP
of multiple covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BoostMLR'
vimp(Object,
     xvar.names = NULL,
     joint = FALSE,
     setting_seed = FALSE,
     seed_value = 100L)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vimp.BoostMLR_+3A_object">Object</code></td>
<td>
<p>A boosting object of class <code>(BoostMLR, predict)</code>.</p>
</td></tr>
<tr><td><code id="vimp.BoostMLR_+3A_xvar.names">xvar.names</code></td>
<td>
<p>Names of the x-variables for which VIMP is requested. If NULL, VIMP is calcuated for all the covariates.</p>
</td></tr>
<tr><td><code id="vimp.BoostMLR_+3A_joint">joint</code></td>
<td>
<p>Whether to estimate VIMP for each covariate from <code>xvar.names</code> or a joint VIMP for multiple covariates?</p>
</td></tr>
<tr><td><code id="vimp.BoostMLR_+3A_setting_seed">setting_seed</code></td>
<td>
<p>Set <code>setting_seed</code> = TRUE if you intend to reproduce the result.</p>
</td></tr>
<tr><td><code id="vimp.BoostMLR_+3A_seed_value">seed_value</code></td>
<td>
<p>Seed value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardized variable importance (VIMP) is calcuated for each covariate or a joint VIMP is calculated for all the covariates specified in <code>xvar.names</code>.
</p>


<h3>Value</h3>

<p>If <code>joint</code> = FALSE, a standardized VIMP for each covariate is obtained otherwisea joint VIMP for all the covariates is obtained. 
The result consists of a list of
length equal to the number of multivariate response.
Each element from the list represents a matrix with number of rows equal to the number of covariates (in case of joint VIMP, the matrix will have a single row) and the number of columns equal to the number of overlapping time intervals + 1 where the first column contains covariate main effects and all other columns contain covariate-time interaction effects.
</p>


<h3>Author(s)</h3>

<p>Amol Pande and Hemant Ishwaran
</p>


<h3>References</h3>

<p>Pande A., Ishwaran H., Blackstone E.H. (2020).  Boosting for multivariate
longitudinal response.
</p>
<p>Friedman J.H. Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##-----------------------------------------------------------------
## Calculate individual and joint VIMP
##-----------------------------------------------------------------

# Simulate data involves 3 response and 4 covariates

dta &lt;- simLong(n = 100, ntest = 100 ,N = 5, rho =.80, model = 1, q_x = 0, 
                                  q_y = 0,type = "corCompSym")
dtaL &lt;- dta$dtaL
trn &lt;- dta$trn
# Boosting call: Raw values of covariates, B-spline for time, 
# no shrinkage, no estimate of rho and phi

boost.grow &lt;- BoostMLR(x = dtaL$features[trn,], tm = dtaL$time[trn], 
                      id = dtaL$id[trn], y = dtaL$y[trn,], M = 100, VarFlag = FALSE)

boost.pred &lt;- predictBoostMLR(Object = boost.grow, x = dtaL$features[-trn,], 
                               tm = dtaL$time[-trn], id = dtaL$id[-trn], 
                               y = dtaL$y[-trn,], importance = FALSE)
# Individual VIMP                               
Ind_vimp &lt;- vimp.BoostMLR(boost.pred)

# Joint VIMP
Joint_vimp &lt;- vimp.BoostMLR(boost.pred,joint = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
