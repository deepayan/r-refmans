<!DOCTYPE html><html><head><title>Help for package float</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {float}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arithmetic'><p>arithmetic</p></a></li>
<li><a href='#backsolve'><p>backsolve</p></a></li>
<li><a href='#bind'><p>rbind</p></a></li>
<li><a href='#bracket'><p>Extract</p></a></li>
<li><a href='#c'><p>c</p></a></li>
<li><a href='#chol'><p>chol</p></a></li>
<li><a href='#chol2inv'><p>chol2inv</p></a></li>
<li><a href='#colsums'><p>colSums</p></a></li>
<li><a href='#comparison'><p>comparison</p></a></li>
<li><a href='#converters'><p>converters</p></a></li>
<li><a href='#crossprod'><p>crossprod</p></a></li>
<li><a href='#diag'><p>diag</p></a></li>
<li><a href='#dims'><p>dim</p></a></li>
<li><a href='#eigen'><p>eigen</p></a></li>
<li><a href='#extremes'><p>extremes</p></a></li>
<li><a href='#float'><p>float</p></a></li>
<li><a href='#float-package'><p>32-Bit Floats</p></a></li>
<li><a href='#float32'><p>float32</p></a></li>
<li><a href='#float32-class'><p>Class float32</p></a></li>
<li><a href='#hyperbolic'><p>Hyperbolic functions</p></a></li>
<li><a href='#is.float'><p>is.float</p></a></li>
<li><a href='#isSymmetric'><p>isSymmetric</p></a></li>
<li><a href='#log'><p>Logarithms and Exponentials</p></a></li>
<li><a href='#Machine_float'><p>Machine_float</p></a></li>
<li><a href='#mathis'><p>Finite, infinite, and NaNs</p></a></li>
<li><a href='#matmult'><p>matmult</p></a></li>
<li><a href='#miscmath'><p>Miscellaneous mathematical functions</p></a></li>
<li><a href='#na'><p>NA</p></a></li>
<li><a href='#NA_float_'><p>NA_float_</p></a></li>
<li><a href='#names'><p>names</p></a></li>
<li><a href='#NaNf'><p>NaNf</p></a></li>
<li><a href='#norm'><p>norm</p></a></li>
<li><a href='#print-float32'><p>print-float32</p></a></li>
<li><a href='#qr'><p>QR</p></a></li>
<li><a href='#rand'><p>Generators</p></a></li>
<li><a href='#rcond'><p>rcond</p></a></li>
<li><a href='#rep'><p>rep</p></a></li>
<li><a href='#round'><p>Round</p></a></li>
<li><a href='#scale'><p>scale</p></a></li>
<li><a href='#sign'><p>sign</p></a></li>
<li><a href='#solve'><p>solve</p></a></li>
<li><a href='#specialmath'><p>Special mathematical functions</p></a></li>
<li><a href='#sum'><p>sum</p></a></li>
<li><a href='#svd'><p>SVD</p></a></li>
<li><a href='#sweep'><p>sweep</p></a></li>
<li><a href='#trig'><p>Trigonometric functions</p></a></li>
<li><a href='#xpose'><p>xpose</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>32-Bit Floats</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-2</td>
</tr>
<tr>
<td>Description:</td>
<td>R comes with a suite of utilities for linear algebra with "numeric"
    (double precision) vectors/matrices. However, sometimes single precision (or
    less!) is more than enough for a particular task.  This package extends R's
    linear algebra facilities to include 32-bit float (single precision) data.
    Float vectors/matrices have half the precision of their "numeric"-type
    counterparts but are generally faster to numerically operate on, for a
    performance vs accuracy trade-off.  The internal representation is an S4
    class, which allows us to keep the syntax identical to that of base R's.
    Interaction between floats and base types for binary operators is generally
    possible; in these cases, type promotion always defaults to the higher
    precision.  The package ships with copies of the single precision 'BLAS' and
    'LAPACK', which are automatically built in the event they are not available
    on the system.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD 2-clause License</a> + file LICENSE</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The copyright for the single precision BLAS/LAPACK
distribution located in src/lapack is given in the file
src/lapack/LICENSE.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, tools</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>StagedInstall:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wrathematics/float">https://github.com/wrathematics/float</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wrathematics/float/issues">https://github.com/wrathematics/float/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Drew Schmidt &lt;wrathematics@gmail.com&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 21:16:16 UTC; mschmid3</td>
</tr>
<tr>
<td>Author:</td>
<td>Drew Schmidt [aut, cre, cph],
  Wei-Chen Chen [aut],
  Dmitriy Selivanov [ctb] (improvements in external package linking),
  ORNL [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 21:50:06 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:15:04 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='arithmetic'>arithmetic</h2><span id='topic+arithmetic'></span><span id='topic++2B+2Cfloat32+2Cfloat32-method'></span><span id='topic++2A+2Cfloat32+2Cfloat32-method'></span><span id='topic+-+2Cfloat32+2Cfloat32-method'></span><span id='topic++2F+2Cfloat32+2Cfloat32-method'></span><span id='topic++5E+2Cfloat32+2Cfloat32-method'></span><span id='topic++2B+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++2A+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic+-+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++2F+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++5E+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++2B+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++2A+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic+-+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++2F+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++5E+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++3C+2Cfloat32+2Cfloat32-method'></span><span id='topic++3C+3D+2Cfloat32+2Cfloat32-method'></span><span id='topic++3D+3D+2Cfloat32+2Cfloat32-method'></span><span id='topic++3E+2Cfloat32+2Cfloat32-method'></span><span id='topic++3E+3D+2Cfloat32+2Cfloat32-method'></span><span id='topic++3C+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++3C+3D+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++3D+3D+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++3E+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++3E+3D+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic++3C+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++3C+3D+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++3D+3D+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++3E+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic++3E+3D+2CBaseLinAlg+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Binary arithmetic numeric/float matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32,float32'
e1 + e2

## S4 method for signature 'float32,float32'
e1 * e2

## S4 method for signature 'float32,float32'
e1 - e2

## S4 method for signature 'float32,float32'
e1 / e2

## S4 method for signature 'float32,float32'
e1 ^ e2

## S4 method for signature 'float32,BaseLinAlg'
e1 + e2

## S4 method for signature 'float32,BaseLinAlg'
e1 * e2

## S4 method for signature 'float32,BaseLinAlg'
e1 - e2

## S4 method for signature 'float32,BaseLinAlg'
e1 / e2

## S4 method for signature 'float32,BaseLinAlg'
e1 ^ e2

## S4 method for signature 'BaseLinAlg,float32'
e1 + e2

## S4 method for signature 'BaseLinAlg,float32'
e1 * e2

## S4 method for signature 'BaseLinAlg,float32'
e1 - e2

## S4 method for signature 'BaseLinAlg,float32'
e1 / e2

## S4 method for signature 'BaseLinAlg,float32'
e1 ^ e2

## S4 method for signature 'float32,float32'
e1 &lt; e2

## S4 method for signature 'float32,float32'
e1 &lt;= e2

## S4 method for signature 'float32,float32'
e1 == e2

## S4 method for signature 'float32,float32'
e1 &gt; e2

## S4 method for signature 'float32,float32'
e1 &gt;= e2

## S4 method for signature 'float32,BaseLinAlg'
e1 &lt; e2

## S4 method for signature 'float32,BaseLinAlg'
e1 &lt;= e2

## S4 method for signature 'float32,BaseLinAlg'
e1 == e2

## S4 method for signature 'float32,BaseLinAlg'
e1 &gt; e2

## S4 method for signature 'float32,BaseLinAlg'
e1 &gt;= e2

## S4 method for signature 'BaseLinAlg,float32'
e1 &lt; e2

## S4 method for signature 'BaseLinAlg,float32'
e1 &lt;= e2

## S4 method for signature 'BaseLinAlg,float32'
e1 == e2

## S4 method for signature 'BaseLinAlg,float32'
e1 &gt; e2

## S4 method for signature 'BaseLinAlg,float32'
e1 &gt;= e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arithmetic_+3A_e1">e1</code>, <code id="arithmetic_+3A_e2">e2</code></td>
<td>
<p>Numeric/float vectors/matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same type as the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s1 = flrunif(5, 5)
s2 = flrunif(5, 5)
x = matrix(1:25, 5)

s1 + s2 # float

typeof(x) # integer
x + s2 # float

storage.mode(x) = "double"
x + s2 # double

</code></pre>

<hr>
<h2 id='backsolve'>backsolve</h2><span id='topic+backsolve'></span><span id='topic+backsolve+2Cfloat32+2Cfloat32-method'></span><span id='topic+backsolve+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic+backsolve+2CBaseLinAlg+2Cfloat32-method'></span><span id='topic+forwardsolve+2Cfloat32+2Cfloat32-method'></span><span id='topic+forwardsolve+2Cfloat32+2CBaseLinAlg-method'></span><span id='topic+forwardsolve+2CBaseLinAlg+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Solve a triangular system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32,float32'
backsolve(r, x, k = ncol(r), upper.tri = TRUE, transpose = FALSE)

## S4 method for signature 'float32,BaseLinAlg'
backsolve(r, x, k = ncol(r), upper.tri = TRUE, transpose = FALSE)

## S4 method for signature 'BaseLinAlg,float32'
backsolve(r, x, k = ncol(r), upper.tri = TRUE, transpose = FALSE)

## S4 method for signature 'float32,float32'
forwardsolve(l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE)

## S4 method for signature 'float32,BaseLinAlg'
forwardsolve(l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE)

## S4 method for signature 'BaseLinAlg,float32'
forwardsolve(l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backsolve_+3A_r">r</code>, <code id="backsolve_+3A_l">l</code></td>
<td>
<p>A triangular coefficients matrix.</p>
</td></tr>
<tr><td><code id="backsolve_+3A_x">x</code></td>
<td>
<p>The right hand sides.</p>
</td></tr>
<tr><td><code id="backsolve_+3A_k">k</code></td>
<td>
<p>The number of equations (columns of r + rows of x) to use.</p>
</td></tr>
<tr><td><code id="backsolve_+3A_upper.tri">upper.tri</code></td>
<td>
<p>Should the upper triangle be used? (if not the lower is)</p>
</td></tr>
<tr><td><code id="backsolve_+3A_transpose">transpose</code></td>
<td>
<p>Should the transposed coefficients matrix be used? More efficient than
manually transposing with <code>t()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
cp = crossprod(s)
y = fl(1:3)
backsolve(cp, y)

</code></pre>

<hr>
<h2 id='bind'>rbind</h2><span id='topic+bind'></span><span id='topic+rbind.float32'></span><span id='topic+cbind.float32'></span>

<h3>Description</h3>

<p><code>rbind()</code> and <code>cbind()</code> for floats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'float32'
rbind(..., deparse.level = 1)

## S3 method for class 'float32'
cbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>vectors or matrices (numeric or float)</p>
</td></tr>
<tr><td><code id="bind_+3A_deparse.level">deparse.level</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same type as the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)
x = fl(matrix(1:10, 5))

rbind(x, x)
cbind(x, x)

</code></pre>

<hr>
<h2 id='bracket'>Extract</h2><span id='topic+bracket'></span><span id='topic++5B+2Cfloat32-method'></span><span id='topic++5B+3C-+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Extract subsets of a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
x[i, j, drop = TRUE]

## S4 replacement method for signature 'float32'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bracket_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="bracket_+3A_i">i</code>, <code id="bracket_+3A_j">j</code>, <code id="bracket_+3A_...">...</code></td>
<td>
<p>The indices.  Most combinations of integer/double/logical values will be
treated the same as R does. One major difference is that <code>NA</code> values
will not be tolerated.</p>
</td></tr>
<tr><td><code id="bracket_+3A_drop">drop</code></td>
<td>
<p>Logical. If TRUE, single column matrices will be treated as one-dimensional
vectors.</p>
</td></tr>
<tr><td><code id="bracket_+3A_value">value</code></td>
<td>
<p>The replacement value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)

s = flrunif(10, 3)
s[, -1]
s[c(1, 3, 5, 7), 1:2]

## End(Not run)

</code></pre>

<hr>
<h2 id='c'>c</h2><span id='topic+c'></span><span id='topic+c+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Combine float/numeric vector(s)/matri[x|ces].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_x">x</code></td>
<td>
<p>A float matrix.</p>
</td></tr>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>Additional elements (numeric/float vectors/matrices) to sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same type as the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)
x = flrunif(10, 3)

c(x, NA, 1L)

</code></pre>

<hr>
<h2 id='chol'>chol</h2><span id='topic+chol'></span><span id='topic+chol+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Cholesky factorization for a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
chol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
cp = crossprod(s)
chol(cp)

</code></pre>

<hr>
<h2 id='chol2inv'>chol2inv</h2><span id='topic+chol2inv'></span><span id='topic+chol2inv+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Return the inverse of the original matrix using the Cholesky factorization of
a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
chol2inv(x, size = NCOL(x), LINPACK = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol2inv_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="chol2inv_+3A_size">size</code></td>
<td>
<p>The number of columns to use.</p>
</td></tr>
<tr><td><code id="chol2inv_+3A_linpack">LINPACK</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
cp = crossprod(s)
cp %*% chol2inv(chol(cp))

</code></pre>

<hr>
<h2 id='colsums'>colSums</h2><span id='topic+colsums'></span><span id='topic+colSums+2Cfloat32-method'></span><span id='topic+rowSums+2Cfloat32-method'></span><span id='topic+colMeans+2Cfloat32-method'></span><span id='topic+rowMeans+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Row and columns sums/means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
colSums(x, na.rm = FALSE, dims = 1)

## S4 method for signature 'float32'
rowSums(x, na.rm = FALSE, dims = 1)

## S4 method for signature 'float32'
colMeans(x, na.rm = FALSE, dims = 1)

## S4 method for signature 'float32'
rowMeans(x, na.rm = FALSE, dims = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colsums_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="colsums_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed?</p>
</td></tr>
<tr><td><code id="colsums_+3A_dims">dims</code></td>
<td>
<p>Ignored. Be honest, you've never even used this argument before, have you?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same type as the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(5, 3)

rowSums(s)
colSums(s)

</code></pre>

<hr>
<h2 id='comparison'>comparison</h2><span id='topic+comparison'></span>

<h3>Description</h3>

<p>Binary comparison operators for numeric/float matrices.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_+3A_e1">e1</code>, <code id="comparison_+3A_e2">e2</code></td>
<td>
<p>Numeric/float vectors/matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector/matrix of logicals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)
s = flrunif(5, 5)
x = matrix(1:25, 5)

s &gt; x
s &lt;= 0

## End(Not run)

</code></pre>

<hr>
<h2 id='converters'>converters</h2><span id='topic+converters'></span><span id='topic+fl'></span><span id='topic+dbl'></span><span id='topic+int'></span><span id='topic+as.float'></span><span id='topic+as.double.float32'></span><span id='topic+as.integer.float32'></span><span id='topic+as.numeric+2Cfloat32-method'></span><span id='topic+as.vector.float32'></span><span id='topic+as.matrix.float32'></span><span id='topic+as.data.frame.float32'></span><span id='topic+typeof+2Cfloat32-method'></span><span id='topic+storage.mode+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Convert between a numeric vector/matrix and a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fl(x, strict = FALSE)

dbl(x, strict = FALSE)

int(x, strict = FALSE)

as.float(x, strict = FALSE)

## S3 method for class 'float32'
as.double(x, ...)

## S3 method for class 'float32'
as.integer(x, ...)

## S4 method for signature 'float32'
as.numeric(x, ...)

## S3 method for class 'float32'
as.vector(x, mode = "any")

## S3 method for class 'float32'
as.matrix(x, ...)

## S3 method for class 'float32'
as.data.frame(x, ...)

## S4 method for signature 'float32'
typeof(x)

## S4 method for signature 'float32'
storage.mode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="converters_+3A_x">x</code></td>
<td>
<p>A numeric or float vector/matrix.</p>
</td></tr>
<tr><td><code id="converters_+3A_strict">strict</code></td>
<td>
<p>Should the function error if given the wrong kind of input? Otherwise it just
silently returns the input.</p>
</td></tr>
<tr><td><code id="converters_+3A_mode">mode</code>, <code id="converters_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fl()</code>, <code>int()</code>, and <code>dbl()</code> are shorthand for
<code>as.float()</code>, <code>as.integer()</code>, and <code>as.double()</code>, respectively.
</p>


<h3>Value</h3>

<p>The data stored in the type of whatever was asked for (the opposite of the
input).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

x = matrix(1:30, 10, 3)
s = fl(x)

y = dbl(s)

all.equal(x, y)

</code></pre>

<hr>
<h2 id='crossprod'>crossprod</h2><span id='topic+crossprod'></span><span id='topic+crossprod+2CMat-method'></span><span id='topic+tcrossprod+2CMat-method'></span>

<h3>Description</h3>

<p>Croddproducts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Mat'
crossprod(x, y = NULL)

## S4 method for signature 'Mat'
tcrossprod(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossprod_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="crossprod_+3A_y">y</code></td>
<td>
<p>Either <code>NULL</code>, or a numeric/float matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y</code> is a numeric matrix, then <code>x</code> will be promoted to a numeric
matrix, and the return will therefore be numeric (not float).
</p>


<h3>Value</h3>

<p>A float matrix (unless <code>y</code> is numeric; see details section).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
crossprod(s)
tcrossprod(s)

</code></pre>

<hr>
<h2 id='diag'>diag</h2><span id='topic+diag'></span><span id='topic+diag+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Methods for getting the diagonal of a float matrix, or constructing a float
matrix given a float vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
diag(x = 1, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_+3A_x">x</code></td>
<td>
<p>A float vector (create a diagonal matrix) or matrix (get its diagonal).</p>
</td></tr>
<tr><td><code id="diag_+3A_nrow">nrow</code>, <code id="diag_+3A_ncol">ncol</code></td>
<td>
<p>As in base R's <code>diag()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector or matrix, depending on the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
s
diag(s)
diag(diag(s))

</code></pre>

<hr>
<h2 id='dims'>dim</h2><span id='topic+dims'></span><span id='topic+nrow+2Cfloat32-method'></span><span id='topic+ncol+2Cfloat32-method'></span><span id='topic+NROW+2Cfloat32-method'></span><span id='topic+NCOL+2Cfloat32-method'></span><span id='topic+dim+2Cfloat32-method'></span><span id='topic+length+2Cfloat32-method'></span><span id='topic+dim+3C-+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Dimension information for a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
nrow(x)

## S4 method for signature 'float32'
ncol(x)

## S4 method for signature 'float32'
NROW(x)

## S4 method for signature 'float32'
NCOL(x)

## S4 method for signature 'float32'
dim(x)

## S4 method for signature 'float32'
length(x)

## S4 replacement method for signature 'float32'
dim(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dims_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="dims_+3A_value">value</code></td>
<td>
<p>The right hand side for the &quot;setter&quot; (<code>dim&lt;-</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The requested integer values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
dim(s)
nrow(s)
ncol(s)

</code></pre>

<hr>
<h2 id='eigen'>eigen</h2><span id='topic+eigen'></span><span id='topic+eigen+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Solve a system of equations or invert a float matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="eigen_+3A_symmetric">symmetric</code></td>
<td>
<p>Is the matrix symmetric? If not, it will be tested for symmetry with
<code>isSymmetric()</code>. Note that only symmetric matrices are supported at this
time.</p>
</td></tr>
<tr><td><code id="eigen_+3A_only.values">only.values</code></td>
<td>
<p>Should only the values (and not the vectors) be returned?</p>
</td></tr>
<tr><td><code id="eigen_+3A_eispack">EISPACK</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values and optionally vectors, each stored as floats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
cp = crossprod(s)

eigen(cp)

</code></pre>

<hr>
<h2 id='extremes'>extremes</h2><span id='topic+extremes'></span><span id='topic+min+2Cfloat32-method'></span><span id='topic+max+2Cfloat32-method'></span><span id='topic+which.min+2Cfloat32-method'></span><span id='topic+which.max+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Min/max values for any combination of float/numeric vector(s)/matri[x|ces].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
min(x, ..., na.rm = FALSE)

## S4 method for signature 'float32'
max(x, ..., na.rm = FALSE)

## S4 method for signature 'float32'
which.min(x)

## S4 method for signature 'float32'
which.max(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extremes_+3A_x">x</code></td>
<td>
<p>A float matrix.</p>
</td></tr>
<tr><td><code id="extremes_+3A_...">...</code></td>
<td>
<p>Additional elements (numeric/float vectors/matrices) to sum.</p>
</td></tr>
<tr><td><code id="extremes_+3A_na.rm">na.rm</code></td>
<td>
<p>should NA's be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are any elements in <code>...</code>, all elements in the list will first
be summed in their native precision, then converted to double precision so
they can be combined with <code>base::sum()</code>.  The final result will be cast
to single precision if <code>...</code> contains only integer and/or float objects.
Otherwise, the return will be double precision.
</p>


<h3>Value</h3>

<p>A single value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)
x = flrunif(10, 3)

min(x)
min(x, 1)

</code></pre>

<hr>
<h2 id='float'>float</h2><span id='topic+float'></span>

<h3>Description</h3>

<p>An analogue to <code>integer()</code> and <code>double()</code> for preallocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>float(length = 0, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="float_+3A_length">length</code></td>
<td>
<p>Input data of type integer.</p>
</td></tr>
<tr><td><code id="float_+3A_nrow">nrow</code>, <code id="float_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows/columns if a matrix return is desired. See details section for
more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both of <code>nrow</code> and <code>ncol</code> are specified, then <code>length</code> is
ignored, and the retor is a matrix. If one (but not the other) of <code>nrow</code>
or <code>ncol</code> is given, then the function errors. Otherwise, a vector of
length <code>length</code> is returned.
</p>


<h3>Value</h3>

<p>A float vector/matrix of 0's.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

float(10)
float(nrow=2, ncol=3)

</code></pre>

<hr>
<h2 id='float-package'>32-Bit Floats</h2><span id='topic+float-package'></span>

<h3>Description</h3>

<p>R comes with a suite of utilities for linear algebra with &quot;numeric&quot;
(double precision) vectors/matrices. However, sometimes single precision (or
less!) is more than enough for a particular task.  This package extends R's
linear algebra facilities to include 32-bit float (single precision) data.
Float vectors/matrices have half the precision of their &quot;numeric&quot;-type
counterparts but are generally faster to numerically operate on, for a
performance vs accuracy trade-off.  The internal representation is an S4
class, which allows us to keep the syntax identical to that of base R's.
Interaction between floats and base types for binary operators is generally
possible; in these cases, type promotion always defaults to the higher
precision.  The package ships with copies of the single precision 'BLAS' and
'LAPACK', which are automatically built in the event they are not available
on the system.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt
</p>

<hr>
<h2 id='float32'>float32</h2><span id='topic+float32'></span>

<h3>Description</h3>

<p>A <code>float32</code> class constructor. For developers only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>float32(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="float32_+3A_x">x</code></td>
<td>
<p>Input data of type integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wraps the integer-type data in the <code>float32</code> S4 class, so that the data
will be interpreted as 32-bit floats.
</p>
<p>If instead you merely want to convert numeric/double data to float type,
instead you should call <code>fl(x)</code>.
</p>


<h3>Value</h3>

<p>A <code>float32</code> class object.
</p>

<hr>
<h2 id='float32-class'>Class float32</h2><span id='topic+float32-class'></span>

<h3>Description</h3>

<p>An S4 container for 32-bit float vector/matrix objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Data</code></dt><dd><p>A vector or matrix of integers.</p>
</dd>
</dl>

<hr>
<h2 id='hyperbolic'>Hyperbolic functions</h2><span id='topic+hyperbolic'></span><span id='topic+sinh+2Cfloat32-method'></span><span id='topic+cosh+2Cfloat32-method'></span><span id='topic+tanh+2Cfloat32-method'></span><span id='topic+asinh+2Cfloat32-method'></span><span id='topic+acosh+2Cfloat32-method'></span><span id='topic+atanh+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Hyperbolic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
sinh(x)

## S4 method for signature 'float32'
cosh(x)

## S4 method for signature 'float32'
tanh(x)

## S4 method for signature 'float32'
asinh(x)

## S4 method for signature 'float32'
acosh(x)

## S4 method for signature 'float32'
atanh(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperbolic_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)

x = flrunif(10)
sinh(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='is.float'>is.float</h2><span id='topic+is.float'></span>

<h3>Description</h3>

<p>Tests if argument is a float matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.float(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.float_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.float()</code> and <code>is.float()</code> are different names for the same
function.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

x = matrix(0, 5, 5)
s = flrunif(10, 3)
is.float(x)
is.float(s)

</code></pre>

<hr>
<h2 id='isSymmetric'>isSymmetric</h2><span id='topic+isSymmetric'></span><span id='topic+isSymmetric+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Test if a float matrix is symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
isSymmetric(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSymmetric_+3A_object">object</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="isSymmetric_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
isSymmetric(s)

cp = crossprod(s)
isSymmetric(s)

</code></pre>

<hr>
<h2 id='log'>Logarithms and Exponentials</h2><span id='topic+log'></span><span id='topic+exp+2Cfloat32-method'></span><span id='topic+expm1+2Cfloat32-method'></span><span id='topic+log+2Cfloat32-method'></span><span id='topic+log10+2Cfloat32-method'></span><span id='topic+log2+2Cfloat32-method'></span>

<h3>Description</h3>

<p>exp/log functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
exp(x)

## S4 method for signature 'float32'
expm1(x)

## S4 method for signature 'float32'
log(x, base = exp(1))

## S4 method for signature 'float32'
log10(x)

## S4 method for signature 'float32'
log2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="log_+3A_base">base</code></td>
<td>
<p>The logarithm base.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)

x = flrunif(10)
log(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='Machine_float'>Machine_float</h2><span id='topic+Machine_float'></span>

<h3>Description</h3>

<p>Numerical characteristics of the machine for floats. Contains analogues of
much of the double precision details of <code>.Machine</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Machine_float
</code></pre>


<h3>Format</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>float.eps</code> epsilon
</p>
</li>
<li> <p><code>float.xmin</code> smallest non-zero float
</p>
</li>
<li> <p><code>float.xmax</code> largest non-inf float
</p>
</li>
<li> <p><code>float.base</code> radix
</p>
</li>
<li> <p><code>float.digits</code> the number of bits for the sign+significand
</p>
</li>
<li> <p><code>float.exponent</code> number of bits for the exponent
</p>
</li>
<li> <p><code>float.min.exp</code> &quot;largest negative&quot; (smallest) integer for the
exponent that generates a normalized floating-point number
</p>
</li>
<li> <p><code>float.max.exp</code> largest integer for the
exponent that generates a normalized floating-point number
</p>
</li></ul>



<h3>Details</h3>

<p>Values are taken directly from <code>float.h</code>.
</p>

<hr>
<h2 id='mathis'>Finite, infinite, and NaNs</h2><span id='topic+mathis'></span><span id='topic+is.finite+2Cfloat32-method'></span><span id='topic+is.infinite+2Cfloat32-method'></span><span id='topic+is.nan+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Finite, infinite, and NaNs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
is.finite(x)

## S4 method for signature 'float32'
is.infinite(x)

## S4 method for signature 'float32'
is.nan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mathis_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)

x = flrnorm(10)
is.nan(sqrt(x))

## End(Not run)

</code></pre>

<hr>
<h2 id='matmult'>matmult</h2><span id='topic+matmult'></span><span id='topic++25+2A+25+2Cfloat32+2Cfloat32-method'></span><span id='topic++25+2A+25+2Cfloat32+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Matrix multiplication for numeric/float matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32,float32'
x %*% y

## S4 method for signature 'float32,matrix'
x %*% y

## S4 method for signature 'matrix,float32'
x %*% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matmult_+3A_x">x</code>, <code id="matmult_+3A_y">y</code></td>
<td>
<p>Numeric/float matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a numeric matrix is multiplied against a float matrix, then if the
&quot;numeric&quot; matrix is integers, the integers are promoted to floats. Otherwise,
the float matrix is promoted to doubles.
</p>


<h3>Value</h3>

<p>A matrix of the same type as the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s1 = flrunif(5, 5)
s2 = flrunif(5, 2)
x = matrix(1:25, 5)

s1 %*% s2 # float

storage.mode(x) # integer
x %*% s2 # float

storage.mode(x) = "double"
x %*% s2 # double

</code></pre>

<hr>
<h2 id='miscmath'>Miscellaneous mathematical functions</h2><span id='topic+miscmath'></span><span id='topic+abs+2Cfloat32-method'></span><span id='topic+sqrt+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Miscellaneous mathematical functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
abs(x)

## S4 method for signature 'float32'
sqrt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miscmath_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)

x = flrunif(10)
sqrt(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='na'>NA</h2><span id='topic+na'></span><span id='topic+is.na+2Cfloat32-method'></span><span id='topic+na.omit+2Cfloat32-method'></span><span id='topic+na.exclude+2Cfloat32-method'></span>

<h3>Description</h3>

<p>NA utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
is.na(x)

## S4 method for signature 'float32'
na.omit(object, ...)

## S4 method for signature 'float32'
na.exclude(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_+3A_x">x</code>, <code id="na_+3A_object">object</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="na_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
is.na(s)

</code></pre>

<hr>
<h2 id='NA_float_'>NA_float_</h2><span id='topic+NA_float_'></span>

<h3>Description</h3>

<p>32-bit float <code>NA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NA_float_
</code></pre>


<h3>Format</h3>

<p>A 32-bit float.
</p>

<hr>
<h2 id='names'>names</h2><span id='topic+names'></span><span id='topic+names+2Cfloat32-method'></span><span id='topic+names+3C-+2Cfloat32-method'></span><span id='topic+rownames+2Cfloat32-method'></span><span id='topic+rownames+3C-+2Cfloat32-method'></span><span id='topic+colnames+2Cfloat32-method'></span><span id='topic+colnames+3C-+2Cfloat32-method'></span><span id='topic+dimnames+2Cfloat32-method'></span><span id='topic+dimnames+3C-+2Cfloat32-method'></span>

<h3>Description</h3>

<p>&quot;name&quot; setter/getters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
names(x)

## S4 replacement method for signature 'float32'
names(x) &lt;- value

## S4 method for signature 'float32'
rownames(x)

## S4 replacement method for signature 'float32'
rownames(x) &lt;- value

## S4 method for signature 'float32'
colnames(x)

## S4 replacement method for signature 'float32'
colnames(x) &lt;- value

## S4 method for signature 'float32'
dimnames(x)

## S4 replacement method for signature 'float32'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="names_+3A_value">value</code></td>
<td>
<p>Replacement value.</p>
</td></tr>
</table>

<hr>
<h2 id='NaNf'>NaNf</h2><span id='topic+NaNf'></span>

<h3>Description</h3>

<p>32-bit float <code>NaN</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NaNf
</code></pre>


<h3>Format</h3>

<p>A 32-bit float.
</p>

<hr>
<h2 id='norm'>norm</h2><span id='topic+norm'></span><span id='topic+norm+2Cfloat32+2CANY-method'></span>

<h3>Description</h3>

<p>Compute matrix norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32,ANY'
norm(x, type = c("O", "I", "F", "M", "2"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="norm_+3A_type">type</code></td>
<td>
<p>&quot;O&quot;-ne, &quot;I&quot;-nfinity, &quot;F&quot;-robenius, &quot;M&quot;-ax modulus, and &quot;2&quot; norms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single float.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
norm(s, type="O")

</code></pre>

<hr>
<h2 id='print-float32'>print-float32</h2><span id='topic+print-float32'></span><span id='topic+print+2Cfloat32-method'></span><span id='topic+show+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Print methods for float vector/matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
print(x, ...)

## S4 method for signature 'float32'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print-float32_+3A_x">x</code>, <code id="print-float32_+3A_object">object</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="print-float32_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>print()</code> (see details section for more
information).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The printer works by
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
print(s)
s

</code></pre>

<hr>
<h2 id='qr'>QR</h2><span id='topic+qr'></span><span id='topic+qr+2Cfloat32-method'></span><span id='topic+qr.Q+2CANY-method'></span><span id='topic+qr.R+2CANY-method'></span><span id='topic+qr.qy+2CANY-method'></span><span id='topic+qr.qty+2CANY-method'></span>

<h3>Description</h3>

<p>QR factorization and related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
qr(x, tol = 1e-07, ...)

## S4 method for signature 'ANY'
qr.Q(qr, complete = FALSE, Dvec)

## S4 method for signature 'ANY'
qr.R(qr, complete = FALSE)

## S4 method for signature 'ANY'
qr.qy(qr, y)

## S4 method for signature 'ANY'
qr.qty(qr, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qr_+3A_x">x</code></td>
<td>
<p>A float matrix.</p>
</td></tr>
<tr><td><code id="qr_+3A_tol">tol</code></td>
<td>
<p>The tolerance for determining numerical column rank.</p>
</td></tr>
<tr><td><code id="qr_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="qr_+3A_qr">qr</code></td>
<td>
<p>Output of <code>qr()</code>.</p>
</td></tr>
<tr><td><code id="qr_+3A_complete">complete</code></td>
<td>
<p>Should the complete or truncated factor be returned?</p>
</td></tr>
<tr><td><code id="qr_+3A_dvec">Dvec</code></td>
<td>
<p>Vector of diagonals to use when re-constructing Q (default is 1's).</p>
</td></tr>
<tr><td><code id="qr_+3A_y">y</code></td>
<td>
<p>A vector/matrix or right hand sides (int, float, or double).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorization is performed by the LAPACK routine <code>sgeqp3()</code>. This
should be similar to calling <code>qr()</code> on an ordinary R matrix with the
argument <code>LAPACK=TRUE</code>. Calling <code>qr(x, LAPACK=FALSE)</code> on a double
precision matrix 'x' (the default) will not be comparable in performance (it
is much slower) or numerics to calling <code>qr(s)</code> where 's' is single a
float matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

x = flrunif(10, 3)
qr(x)

</code></pre>

<hr>
<h2 id='rand'>Generators</h2><span id='topic+rand'></span><span id='topic+flrunif'></span><span id='topic+flrnorm'></span><span id='topic+flrand'></span>

<h3>Description</h3>

<p>Random float vector/matrix generators. <code>flrunif()</code> produces uniform
random values. <code>flrnorm()</code> produces random normal values.
<code>flrand()</code> will accept an arbitrary generator. See the details section
for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flrunif(m, n, min = 0, max = 1)

flrnorm(m, n, mean = 0, sd = 1)

flrand(generator, m, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_+3A_m">m</code>, <code id="rand_+3A_n">n</code></td>
<td>
<p>The dimensions of the matrix/vector. <code>m</code> must be specified.  If <code>n</code>
is not, then the return is a vector.</p>
</td></tr>
<tr><td><code id="rand_+3A_min">min</code>, <code id="rand_+3A_max">max</code></td>
<td>
<p>Minimum and maximum values for the uniform generator.</p>
</td></tr>
<tr><td><code id="rand_+3A_mean">mean</code>, <code id="rand_+3A_sd">sd</code></td>
<td>
<p>Mean and standard deviation values for the normal generator.</p>
</td></tr>
<tr><td><code id="rand_+3A_generator">generator</code></td>
<td>
<p>A generating function, such as <code>rnorm</code>, or even something custom
defined.</p>
</td></tr>
<tr><td><code id="rand_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the generator. For example, if <code>runif</code> is
passed as <code>generator</code>, then you might additionally pass <code>max=10</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>flrunif()</code> and <code>flrnorm()</code>, the data is produced without a
double precision copy.  That is, it is not (computationally) equivalent to
<code>fl(matrix(runif(...)))</code>, though the operations are conceptually the
same.  For these, To produce a vector instead of a matrix, leave argument
<code>n</code> blank. Setting <code>n=1</code> will produce an mx1 matrix.
</p>
<p>For <code>flrand()</code>, the data is generated in double precision in 4KiB
batches and copied over to a pre-allocated vector.  This will be slower than
generating all of the data up front and copying it, although it uses far less
memory most of the time.  So you can think of <code>flrunif()</code> and
<code>flrnorm()</code> as highly optimized versions of <code>flrand()</code> for uniform
and normal generators specifically.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

flrunif(10) # length 10 vector
flrunif(10, 1) # 10x1 matrix
flrunif(10, min=10, max=20)

flrand(runif, 10) # conceptually the same as flrunif(10)

mygen = function(n) sample(1:5, n, replace=TRUE)
flrand(mygen, 30)

</code></pre>

<hr>
<h2 id='rcond'>rcond</h2><span id='topic+rcond'></span><span id='topic+rcond+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Compute matrix norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
rcond(x, norm = c("O", "I", "1"), triangular = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcond_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="rcond_+3A_norm">norm</code></td>
<td>
<p>&quot;O&quot;-ne or &quot;I&quot;-nfinity norm.</p>
</td></tr>
<tr><td><code id="rcond_+3A_triangular">triangular</code></td>
<td>
<p>Should only the lower triangle be used?</p>
</td></tr>
<tr><td><code id="rcond_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single float.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
rcond(s)

</code></pre>

<hr>
<h2 id='rep'>rep</h2><span id='topic+rep'></span><span id='topic+rep.float32'></span>

<h3>Description</h3>

<p>Replicate elements of a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'float32'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_+3A_x">x</code></td>
<td>
<p>A float matrix.</p>
</td></tr>
<tr><td><code id="rep_+3A_...">...</code></td>
<td>
<p>Additional arguments (passed to <code>base::rep</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)
x = fl(matrix(1:6, 3, 2))

rep(x, 5)

</code></pre>

<hr>
<h2 id='round'>Round</h2><span id='topic+round'></span><span id='topic+ceiling+2Cfloat32-method'></span><span id='topic+floor+2Cfloat32-method'></span><span id='topic+trunc+2Cfloat32-method'></span><span id='topic+round+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Rounding functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
ceiling(x)

## S4 method for signature 'float32'
floor(x)

## S4 method for signature 'float32'
trunc(x, ...)

## S4 method for signature 'float32'
round(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="round_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="round_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use in rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

x = flrnorm(10)
floor(x)

</code></pre>

<hr>
<h2 id='scale'>scale</h2><span id='topic+scale'></span><span id='topic+scale+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Center/scale a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="scale_+3A_center">center</code>, <code id="scale_+3A_scale">scale</code></td>
<td>
<p>Logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only logical <code>center</code> and <code>scale</code> parameters are accepted at this
time.
</p>


<h3>Value</h3>

<p>A float matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
scale(s)

</code></pre>

<hr>
<h2 id='sign'>sign</h2><span id='topic+sign'></span><span id='topic+sign+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
sign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix.
</p>

<hr>
<h2 id='solve'>solve</h2><span id='topic+solve'></span><span id='topic+solve+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Solve a system of equations or invert a float matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_+3A_a">a</code>, <code id="solve_+3A_b">b</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="solve_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float matrix if inverting.  If solving a system, a float vector if given
one &quot;right hand side&quot;, and a float matrix otherwise (just like R).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
cp = crossprod(s)
solve(cp)

y = fl(1:3)
solve(cp, y)

</code></pre>

<hr>
<h2 id='specialmath'>Special mathematical functions</h2><span id='topic+specialmath'></span><span id='topic+gamma+2Cfloat32-method'></span><span id='topic+lgamma+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Special mathematical functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
gamma(x)

## S4 method for signature 'float32'
lgamma(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specialmath_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)

x = flrunif(10)
lgamma(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='sum'>sum</h2><span id='topic+sum'></span><span id='topic+sum+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Sums any combination of float/numeric vector(s)/matri[x|ces].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
sum(x, ..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_+3A_x">x</code></td>
<td>
<p>A float matrix.</p>
</td></tr>
<tr><td><code id="sum_+3A_...">...</code></td>
<td>
<p>Additional elements (numeric/float vectors/matrices) to sum.</p>
</td></tr>
<tr><td><code id="sum_+3A_na.rm">na.rm</code></td>
<td>
<p>should NA's be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are any elements in <code>...</code>, all elements in the list will first
be summed in their native precision, then converted to double precision so
they can be combined with <code>base::sum()</code>.  The final result will be cast
to single precision if <code>...</code> contains only integer and/or float objects.
Otherwise, the return will be double precision.
</p>


<h3>Value</h3>

<p>A single value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)
x = flrunif(10, 3)

sum(x)
sum(x, 1)

</code></pre>

<hr>
<h2 id='svd'>SVD</h2><span id='topic+svd'></span><span id='topic+La.svd+2Cfloat32-method'></span><span id='topic+svd+2Cfloat32-method'></span>

<h3>Description</h3>

<p>SVD factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
La.svd(x, nu = min(n, p), nv = min(n, p))

## S4 method for signature 'float32'
svd(x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svd_+3A_x">x</code></td>
<td>
<p>A float matrix.</p>
</td></tr>
<tr><td><code id="svd_+3A_nu">nu</code>, <code id="svd_+3A_nv">nv</code></td>
<td>
<p>The number of left/right singular vectors to return.</p>
</td></tr>
<tr><td><code id="svd_+3A_linpack">LINPACK</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorization is performed by the LAPACK routine <code>sgesdd()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

x = flrunif(10, 3)
svd(x)

</code></pre>

<hr>
<h2 id='sweep'>sweep</h2><span id='topic+sweep'></span><span id='topic+sweep+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Sweep a vector through a float matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sweep_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
<tr><td><code id="sweep_+3A_margin">MARGIN</code></td>
<td>
<p>1 (rows) or 2 (columns)</p>
</td></tr>
<tr><td><code id="sweep_+3A_stats">STATS</code></td>
<td>
<p>Vector to sweep out.</p>
</td></tr>
<tr><td><code id="sweep_+3A_fun">FUN</code></td>
<td>
<p>Sweeping function; must be one of <code>"+"</code>, <code>"-"</code>, <code>"*"</code>,  or
<code>"/"</code>.</p>
</td></tr>
<tr><td><code id="sweep_+3A_check.margin">check.margin</code></td>
<td>
<p>Should x/STATS margin lengths be checked?</p>
</td></tr>
<tr><td><code id="sweep_+3A_...">...</code></td>
<td>
<p>Theoretically these are additional arguments passed to an arbitrary function.
However, we only support basic arithmetic, so they are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if the length of <code>STATS</code> does not recycle exactly across
<code>MARGIN</code>, the results here will differ slightly from the results of
base R.
</p>


<h3>Value</h3>

<p>A matrix of the same type as the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
sweep(s, 2, fl(1))

</code></pre>

<hr>
<h2 id='trig'>Trigonometric functions</h2><span id='topic+trig'></span><span id='topic+sin+2Cfloat32-method'></span><span id='topic+cos+2Cfloat32-method'></span><span id='topic+tan+2Cfloat32-method'></span><span id='topic+asin+2Cfloat32-method'></span><span id='topic+acos+2Cfloat32-method'></span><span id='topic+atan+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Basic trig functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
sin(x)

## S4 method for signature 'float32'
cos(x)

## S4 method for signature 'float32'
tan(x)

## S4 method for signature 'float32'
asin(x)

## S4 method for signature 'float32'
acos(x)

## S4 method for signature 'float32'
atan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trig_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(float)

x = flrunif(10)
sin(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='xpose'>xpose</h2><span id='topic+xpose'></span><span id='topic+t+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Transpose a float vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'float32'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpose_+3A_x">x</code></td>
<td>
<p>A float vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float vector/matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(float)

s = flrunif(10, 3)
dim(s)
ts = t(s)
dim(ts)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
