<!DOCTYPE html><html lang="en"><head><title>Help for package seqinr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seqinr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#seqinr-package'>
<p>Biological Sequences Retrieval and Analysis</p></a></li>
<li><a href='#a'><p>Converts amino-acid three-letter code into the one-letter one</p></a></li>
<li><a href='#aaa'><p>Converts amino-acid one-letter code into the three-letter one</p></a></li>
<li><a href='#aacost'><p>Aerobic cost of amino-acids in Escherichia coli and G+C classes</p></a></li>
<li><a href='#aaindex'><p>List of 544 physicochemical and biological properties for the 20 amino-acids</p></a></li>
<li><a href='#AAstat'><p> To Get Some Protein Statistics</p></a></li>
<li><a href='#acnucopen'><p>open and close a remote access to an ACNUC database</p></a></li>
<li><a href='#al2bp'><p>To Convert a forensic microsatellite allele name into its length in base pairs</p></a></li>
<li><a href='#alllistranks'><p>To get the count of existing lists and all their ranks on server</p></a></li>
<li><a href='#amb'><p>Expansion of IUPAC nucleotide symbols</p></a></li>
<li><a href='#AnoukResult'><p>Expected numeric results for Ka and Ks computation</p></a></li>
<li><a href='#as.alignment'><p>Constructor for class alignment</p></a></li>
<li><a href='#as.matrix.alignment'><p>as.matrix.alignment</p></a></li>
<li><a href='#autosocket'><p>Returns a socket to the last opened database</p></a></li>
<li><a href='#baselineabif'><p>Estimation of baseline value</p></a></li>
<li><a href='#bma'><p>Computing an IUPAC nucleotide symbol</p></a></li>
<li><a href='#c2s'><p> conversion of a vector of chars into a string</p></a></li>
<li><a href='#cai'><p>Codon Adaptation Index</p></a></li>
<li><a href='#caitab'><p>Codon Adaptation Index (CAI) w tables</p></a></li>
<li><a href='#chargaff'><p>Base composition in ssDNA for 7 bacterial DNA</p></a></li>
<li><a href='#choosebank'><p>To select a database structured under ACNUC and located on the web</p></a></li>
<li><a href='#circle'><p>Draws a circle</p></a></li>
<li><a href='#closebank'><p> To close a remote ACNUC database</p></a></li>
<li><a href='#clustal'><p>Example of results obtained after a call to read.alignment</p></a></li>
<li><a href='#col2alpha'><p>To use a standard color with an alpha transparency chanel</p></a></li>
<li><a href='#comp'><p> complements a nucleic acid sequence</p></a></li>
<li><a href='#computePI'><p>To Compute the Theoretical Isoelectric Point</p></a></li>
<li><a href='#consensus'><p>Consensus and profiles for sequence alignments</p></a></li>
<li><a href='#count'><p>Composition of dimer/trimer/etc oligomers</p></a></li>
<li><a href='#countfreelists'><p>The number of free lists available and annotation lines in an ACNUC server</p></a></li>
<li><a href='#countsubseqs'><p>Number of subsequences in an ACNUC list</p></a></li>
<li><a href='#crelistfromclientdata'><p>To create on server an ACNUC list from data lines sent by client</p></a></li>
<li><a href='#dia.bactgensize'><p> Distribution of bacterial genome size from GOLD</p></a></li>
<li><a href='#dinucl'><p> Mean zscore on 242 complete bacterial chromosomes</p></a></li>
<li><a href='#dinucleotides'><p>Statistical over- and under- representation of dinucleotides in a</p>
sequence</a></li>
<li><a href='#dist.alignment'><p> Pairwise Distances from Aligned Protein or DNA/RNA Sequences</p></a></li>
<li><a href='#dotchart.uco'><p>Cleveland plot for codon usage tables</p></a></li>
<li><a href='#dotPlot'><p> Dot Plot Comparison of two sequences</p></a></li>
<li><a href='#draw.oriloc'><p>Graphical representation for nucleotide skews in</p>
prokaryotic chromosomes.</a></li>
<li><a href='#draw.rearranged.oriloc'><p>Graphical representation for rearranged nucleotide skews in</p>
prokaryotic chromosomes.</a></li>
<li><a href='#draw.recstat'><p>Graphical representation of a recstat analysis.</p></a></li>
<li><a href='#ec999'><p> 999 coding sequences from E. coli</p></a></li>
<li><a href='#ECH'><p>Forensic Genetic Profile Allelic Ladder Raw Data</p></a></li>
<li><a href='#EXP'><p>Vectors of coefficients to compute linear forms.</p></a></li>
<li><a href='#extract.breakpoints'><p>Extraction of breakpoint positions on the</p>
rearranged nucleotide skews.</a></li>
<li><a href='#extractseqs'><p>To extract the sequences information of a sequence or a list of sequence in different formats</p></a></li>
<li><a href='#fasta'><p>Example of results obtained after a call to read.alignment</p></a></li>
<li><a href='#fastacc'><p>Fast Allele in Common Count</p></a></li>
<li><a href='#G+2BC+20Content'><p>Calculates the fractional G+C content of nucleic acid sequences.</p></a></li>
<li><a href='#gb2fasta'><p>Conversion of GenBank file into fasta file</p></a></li>
<li><a href='#gbk2g2'><p> Conversion of a GenBank format file into a glimmer-like one</p></a></li>
<li><a href='#gbk2g2.euk'><p> Conversion of a GenBank format file into a glimmer-like</p>
one. Eukaryotic version.</a></li>
<li><a href='#gcO2'><p>GC content and aerobiosis in bacteria</p></a></li>
<li><a href='#gcT'><p>GC content and temperature in bacteria</p></a></li>
<li><a href='#get.db.growth'><p> Get the exponential growth of nucleic acid database content</p></a></li>
<li><a href='#getAnnot'><p>Generic Function to get sequence annotations</p></a></li>
<li><a href='#getFrag'><p>Generic function to extract sequence fragments</p></a></li>
<li><a href='#getKeyword'><p>Generic function to get keywords associated to sequences</p></a></li>
<li><a href='#getLength'><p>Generic function to get the length of sequences</p></a></li>
<li><a href='#getlistrank'><p>To get the rank of a list from its name</p></a></li>
<li><a href='#getliststate'><p>Asks for information about an ACNUC list of specified rank</p></a></li>
<li><a href='#getLocation'><p>Generic function to get the location of subsequences on the parent sequence</p></a></li>
<li><a href='#getName'><p>Generic function to get the names of sequences</p></a></li>
<li><a href='#getSequence'><p>Generic function to get sequence data</p></a></li>
<li><a href='#getTrans'><p>Generic function to translate coding sequences into proteins</p></a></li>
<li><a href='#getType'><p>To get available subsequence types in an opened ACNUC database</p></a></li>
<li><a href='#gfrag'><p>Extract sequence identified by name or by number from an ACNUC server</p></a></li>
<li><a href='#ghelp'><p>Get help from an ACNUC server</p></a></li>
<li><a href='#gs500liz'><p>GS500LIZ size standards</p></a></li>
<li><a href='#identifiler'><p>Identifiler allele names</p></a></li>
<li><a href='#isenum'><p>Get the ACNUC number of a sequence from its name or accession number</p></a></li>
<li><a href='#JLO'><p>Forensic Genetic Profile Raw Data</p></a></li>
<li><a href='#kaks'><p>Ka and Ks, also known as dn and ds, computation</p></a></li>
<li><a href='#kaksTorture'><p>Expected numeric results for Ka and Ks in extreme cases</p></a></li>
<li><a href='#knowndbs'><p>Description of databases known by an ACNUC server</p></a></li>
<li><a href='#lseqinr'><p> To see what's inside the package seqinr</p></a></li>
<li><a href='#m16j'><p>Fragment of the E. coli chromosome</p></a></li>
<li><a href='#mase'><p>Example of results obtained after a call to read.alignment</p></a></li>
<li><a href='#modifylist'><p>Modification of an ACNUC list</p></a></li>
<li><a href='#move'><p>Rename an R object</p></a></li>
<li><a href='#msf'><p>Example of results obtained after a call to read.alignment</p></a></li>
<li><a href='#n2s'><p> function to convert the numeric encoding of a DNA sequence</p>
into a vector of characters</a></li>
<li><a href='#oriloc'><p> Prediction of origin and terminus of replication in bacteria.</p></a></li>
<li><a href='#parser.socket'><p>Utility function to parse answers from an ACNUC server</p></a></li>
<li><a href='#peakabif'><p>Extraction of Peak locations, Heights and Surfaces from ABIF data</p></a></li>
<li><a href='#permutation'><p>Sequence permutation according to several different models</p></a></li>
<li><a href='#phylip'><p>Example of results obtained after a call to read.alignment</p></a></li>
<li><a href='#pK'><p>pK values for the side chain of charged amino acids from various sources</p></a></li>
<li><a href='#plot.SeqAcnucWeb'><p>To Plot Subsequences on the Parent Sequence</p></a></li>
<li><a href='#plotabif'><p>Electrophoregram plot for ABIF data</p></a></li>
<li><a href='#plotladder'><p>Simple plot of an allelic ladder from ABIF data</p></a></li>
<li><a href='#plotPanels'><p>Representation of Amplicon Size Ranges of a STR kit.</p></a></li>
<li><a href='#pmw'><p> Protein Molecular Weight</p></a></li>
<li><a href='#prepgetannots'><p>Select annotation lines in an ACNUC database</p></a></li>
<li><a href='#prettyseq'><p>Text representation of a sequence from an ACNUC server</p></a></li>
<li><a href='#print.qaw'><p>Print method for objects from class qaw</p></a></li>
<li><a href='#print.SeqAcnucWeb'><p>Print method for objects from class SeqAcnucWeb</p></a></li>
<li><a href='#prochlo'><p> Zscore on three strains of Prochlorococcus marinus</p></a></li>
<li><a href='#query'><p>To get a list of sequence names from an ACNUC data base located on the web</p></a></li>
<li><a href='#read.abif'><p>Read ABIF formatted files</p></a></li>
<li><a href='#read.alignment'><p>Read aligned sequence files in mase, clustal, phylip, fasta or msf format</p></a></li>
<li><a href='#read.fasta'><p> read FASTA formatted files</p></a></li>
<li><a href='#readBins'><p>Import GenMapper Bins configuration file</p></a></li>
<li><a href='#readfirstrec'><p>Low level function to get the record count of the specified ACNUC</p>
index file</a></li>
<li><a href='#readPanels'><p>Import GenMapper Panels configuration file</p></a></li>
<li><a href='#readsmj'><p>Low level function to read ACNUC SMJYT index files</p></a></li>
<li><a href='#rearranged.oriloc'><p>Detection of replication-associated effects on base composition asymmetry in</p>
prokaryotic chromosomes.</a></li>
<li><a href='#recstat'><p>Prediction of Coding DNA Sequences.</p></a></li>
<li><a href='#residuecount'><p>Total number of residues in an ACNUC list</p></a></li>
<li><a href='#revaligntest'><p> Three aligned nucleic acid sequences</p></a></li>
<li><a href='#reverse.align'><p> Reverse alignment - from protein sequence alignment to nucleic sequence alignment</p></a></li>
<li><a href='#rot13'><p>Ergheaf gur EBG-13 pvcurevat bs n fgevat</p></a></li>
<li><a href='#s2c'><p> conversion of a string into a vector of chars</p></a></li>
<li><a href='#s2n'><p> simple numerical encoding of a DNA sequence.</p></a></li>
<li><a href='#savelist'><p>Save sequence names or accession numbers into a file</p></a></li>
<li><a href='#SeqAcnucWeb'><p>Sequence coming from a remote ACNUC data base</p></a></li>
<li><a href='#SeqFastaAA'><p>AA sequence in Fasta Format</p></a></li>
<li><a href='#SeqFastadna'><p> Class for DNA sequence in Fasta Format</p></a></li>
<li><a href='#SeqFrag'><p>Class for sub-sequences</p></a></li>
<li><a href='#SEQINR.UTIL'><p>utility data for seqinr</p></a></li>
<li><a href='#setlistname'><p>Sets the name of an ACNUC list identified by its rank</p></a></li>
<li><a href='#splitseq'><p> split a sequence into sub-sequences</p></a></li>
<li><a href='#stresc'><p>Utility function to escape LaTeX special characters present in a string</p></a></li>
<li><a href='#stutterabif'><p>Stutter ratio estimation</p></a></li>
<li><a href='#swap'><p>Exchange two R objects</p></a></li>
<li><a href='#syncodons'><p>Synonymous codons</p></a></li>
<li><a href='#synsequence'><p>Random synonymous coding sequence generation</p></a></li>
<li><a href='#tablecode'><p> to plot genetic code as in textbooks</p></a></li>
<li><a href='#test.co.recstat'><p>Tests if regions located between Stop codons contain putative CDSs.</p></a></li>
<li><a href='#test.li.recstat'><p>Tests if regions located between Stop codons contain putative CDSs.</p></a></li>
<li><a href='#toyaa'><p>A toy example of amino-acid counts in three proteins</p></a></li>
<li><a href='#toycodon'><p>A toy example of codon counts in three coding sequences</p></a></li>
<li><a href='#translate'><p> Translate nucleic acid sequences into proteins</p></a></li>
<li><a href='#trimSpace'><p>Trim leading and/or trailing spaces in strings</p></a></li>
<li><a href='#uco'><p> Codon usage indices</p></a></li>
<li><a href='#ucoweight'><p>Weight of each synonymous codon</p></a></li>
<li><a href='#waterabs'><p>Light absorption by the water column</p></a></li>
<li><a href='#where.is.this.acc'><p>Scans databases for a given sequence accession number</p></a></li>
<li><a href='#words'><p> To get all words from an alphabet.</p></a></li>
<li><a href='#words.pos'><p> Positions of possibly degenerated motifs within sequences</p></a></li>
<li><a href='#write.fasta'><p> Write sequence(s) into a file in fasta format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Biological Sequences Retrieval and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2-36</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4,segmented</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Penel &lt;simon.penel@univ-lyon1.fr&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Description:</td>
<td>Exploratory data analysis and data visualization
  for biological sequence (DNA and protein) data. Seqinr includes
  utilities for sequence data management under the ACNUC system
  described in Gouy, M. et al. (1984) Nucleic Acids Res.
  12:121-127 &lt;<a href="https://doi.org/10.1093%2Fnar%2F12.1Part1.121">doi:10.1093/nar/12.1Part1.121</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://seqinr.r-forge.r-project.org/">https://seqinr.r-forge.r-project.org/</a>,
<a href="https://github.com/lbbe-software/seqinr">https://github.com/lbbe-software/seqinr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lbbe-software/seqinr/issues">https://github.com/lbbe-software/seqinr/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>zlib headers and library.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 12:38:47 UTC; simon</td>
</tr>
<tr>
<td>Author:</td>
<td>Delphine Charif [aut],
  Olivier Clerc [ctb],
  Carolin Frank [ctb],
  Jean R. Lobry [aut, cph],
  Anamaria Necşulea [ctb],
  Leonor Palmeira [ctb],
  Simon Penel [cre],
  Guy Perrière [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 14:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='seqinr-package'>
Biological Sequences Retrieval and Analysis
</h2><span id='topic+seqinr-package'></span><span id='topic+seqinr'></span>

<h3>Description</h3>

<p>Exploratory data analysis and data visualization for
biological sequence (DNA and protein) data. Include also
utilities for sequence data management under the ACNUC system.
</p>


<h3>Author(s)</h3>

<p>Delphine Charif [aut], Olivier Clerc [ctb], Carolin Frank [ctb], 
Jean R. Lobry [aut], Anamaria Necşulea [ctb], Leonor Palmeira [ctb], 
Simon Penel [cre], Guy Perrière [ctb]</p>


<h3>References</h3>

<p>citation('seqinr')
</p>

<hr>
<h2 id='a'>Converts amino-acid three-letter code into the one-letter one</h2><span id='topic+a'></span>

<h3>Description</h3>

<p>This is a vectorized function to convert three-letters amino-acid code
into the one-letter one, for instance &quot;Ala&quot; into &quot;A&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a(aa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a_+3A_aa">aa</code></td>
<td>
<p> A vector of string. All strings are 3 chars long.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allowed character values for <code>aa</code> are given by <code>aaa()</code>.
All other values will generate a warning and return NA.
Called without arguments, <code>a()</code> returns the list of all possible
output values.
</p>


<h3>Value</h3>

<p>A vector of single characters.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry </p>


<h3>References</h3>

<p>The IUPAC one-letter code for aminoacids is described at: 
<a href="https://www.bioinformatics.org/sms/iupac.html">https://www.bioinformatics.org/sms/iupac.html</a><br />
<code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aaa">aaa</a></code>, <code><a href="#topic+translate">translate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  #
  # Show all possible input values:
  #
  
  aaa()
  
  #
  # Convert them in one letter-code:
  #
  
  a(aaa())
  
  #
  # Check consistency of results:
  #
  
  stopifnot( aaa(a(aaa())) == aaa())
  
  #
  # Show what happens with non-allowed values:
  #
  
  a("SOS") # should be NA and a warning is generated
</code></pre>

<hr>
<h2 id='aaa'>Converts amino-acid one-letter code into the three-letter one</h2><span id='topic+aaa'></span>

<h3>Description</h3>

<p>This is a vectorized function to convert one-letter amino-acid code
into the three-letter one, for instance &quot;A&quot; into &quot;Ala&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>aaa(aa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aaa_+3A_aa">aa</code></td>
<td>
<p> A vector of single characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allowed character values for <code>aa</code> are given by <code>a()</code>.
All other values will generate a warning and return NA.
Called without arguments, <code>aaa()</code> returns the list of
all possible output values.</p>


<h3>Value</h3>

<p>A vector of char string. All strings are 3 chars long.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p>The IUPAC one-letter code for aminoacids is described at: 
<a href="https://www.bioinformatics.org/sms/iupac.html">https://www.bioinformatics.org/sms/iupac.html</a>
<code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+a">a</a></code>, <code><a href="#topic+translate">translate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  #
  # Show all possible input values:
  #
  
  a()
  
  #
  # Convert them in one letter-code:
  #
  
  aaa(a())
  
  #
  # Check consistency of results:
  #
  
  stopifnot(a(aaa(a())) == a())
  
  #
  # Show what happens with non-allowed values:
  #
  
  aaa("Z") # should be NA and a warning is generated
</code></pre>

<hr>
<h2 id='aacost'>Aerobic cost of amino-acids in Escherichia coli and G+C classes</h2><span id='topic+aacost'></span>

<h3>Description</h3>

<p>The metabolic cost of amino-acid biosynthesis in <em>E. coli</em> under aerobic conditions
from table 1 in Akashi and Gojobori (2002). The G+C classes are from Lobry (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aacost)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows for the amino-acids and the following 7 columns:
</p>

<dl>
<dt>aaa</dt><dd><p>amino-acid (three-letters code).</p>
</dd>
<dt>a</dt><dd><p>amino-acid (one-letter code).</p>
</dd>
<dt>prec</dt><dd><p>precursor metabolites (see details).</p>
</dd>
<dt>p</dt><dd><p>number of high-energy phosphate bonds contained in ATP and GTP molecules.</p>
</dd>
<dt>h</dt><dd><p>number of available hydrogen atoms carried in NADH, NADPH,
and FADH2 molcules.</p>
</dd>
<dt>tot</dt><dd><p>total metabolic cost assuming 2 high-energy phosphate bonds
per hydrogen atom.</p>
</dd>
<dt>gc</dt><dd><p>an ordered factor (l&lt;m&lt;h) for the G+C class of the amino-acid (see details)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Precursor metabolites are: penP, ribose 5-phosphate; PRPP,
5-phosphoribosyl pyrophosphate; eryP, erythrose 4-phosphate; 3pg,
3-phosphoglycerate; pep, phospho<em>enol</em>pyruvate; pyr, pyruvate;
acCoA, acetyl-CoA; akg, alpha-ketoglutarate; oaa, oxaloacetate. Negative
signs on precursor metabolites indicate chemicals <em>gained</em> through
biosynthetic pathways. Costs of precursors reflect averages for growth on
glucose, acetate, and malate (see Table 6 in the supporting information
from Akashi and Gojobori 2002).<br />
</p>
<p>The levels l&lt;m&lt;h for the <code>gc</code> ordered factor stand for Low G+C, Middle G+C,
High G+C amino-acid, respectively. The frequencies of Low G+C amino-acids
monotonously decrease with G+C content. The frequencies of High G+C amino-
acids monotonously increase with G+C content. The frequencies of Middle G+C
amino-acids first increase and then decrease with G+C content. These G+C classes 
are from Lobry (1997).<br />
</p>
<p><code>example(aacost)</code> reproduces figure 2 from Lobry (2004).
</p>
<p><img src="../help/figures/aka.pdf" width=400 alt="aka.pdf" />

</p>


<h3>Source</h3>

<p>Akashi, H, Gojobori, T. (2002) Metabolic efficiency and amino acid composition
in the proteomes of <em>Escherichia coli</em> and <em>Bacillus subtilis</em>.
<em>Proceedings of the National Academy of Sciences of the United States of America</em>, 
<b>99</b>:3695-3700.<br />
</p>
<p>Lobry, J.R. (1997) Influence of genomic G+C content on average amino-acid composition 
of proteins from 59 bacterial species. <em>Gene</em>, <b>205</b>:309-316.<br />
</p>
<p>Lobry, J.R. (2004) Life history traits and genome structure: aerobiosis and G+C content in bacteria. 
<em>Lecture Notes in Computer Sciences</em>, <b>3039</b>:679-686.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aacost)
levels(aacost$gc) &lt;- c("low G+C", "mid G+C", "high G+C")
stripchart(aacost$tot~aacost$gc, pch = 19, ylim = c(0.5,3.5),
     xlim = c(0, max(aacost$tot)),
     xlab = "Metabolic cost (high-energy phosphate bonds equivalent)",
     main = "Metabolic cost of the 20 amino-acids\nas function of their G+C class" )
boxplot(aacost$tot~aacost$gc, horizontal = TRUE, add = TRUE)   
</code></pre>

<hr>
<h2 id='aaindex'>List of 544 physicochemical and biological properties for the 20 amino-acids</h2><span id='topic+aaindex'></span>

<h3>Description</h3>

<p>Data were imported from release 9.1 (AUG 2006) of the aaindex1
database. See the reference section to cite this database in a publication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aaindex)</code></pre>


<h3>Format</h3>

<p>A named list with 544 elements having each the following components:
</p>

<dl>
<dt>H</dt><dd><p>String: Accession number in the aaindex database.</p>
</dd>
<dt>D</dt><dd><p>String: Data description.</p>
</dd>
<dt>R</dt><dd><p>String: LITDB entry number.</p>
</dd>
<dt>A</dt><dd><p>String: Author(s).</p>
</dd>
<dt>T</dt><dd><p>String: Title of the article.</p>
</dd>
<dt>J</dt><dd><p>String: Journal reference and comments.</p>
</dd>
<dt>C</dt><dd><p>String: Accession numbers of similar entries with the correlation
coefficients of 0.8 (-0.8) or more (less). Notice: The correlation
coefficient is calculated with zeros filled for missing values.</p>
</dd>
<dt>I</dt><dd><p>Numeric named vector: amino acid index data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>A short description of each entry is available under the D component:<br />
</p>
<p>alpha-CH chemical shifts (Andersen et al., 1992)<br />
Hydrophobicity index (Argos et al., 1982)<br />
Signal sequence helical potential (Argos et al., 1982)<br />
Membrane-buried preference parameters (Argos et al., 1982)<br />
Conformational parameter of inner helix (Beghin-Dirkx, 1975)<br />
Conformational parameter of beta-structure (Beghin-Dirkx, 1975)<br />
Conformational parameter of beta-turn (Beghin-Dirkx, 1975)<br />
Average flexibility indices (Bhaskaran-Ponnuswamy, 1988)<br />
Residue volume (Bigelow, 1967)<br />
Information value for accessibility; average fraction 35
Information value for accessibility; average fraction 23
Retention coefficient in TFA (Browne et al., 1982)<br />
Retention coefficient in HFBA (Browne et al., 1982)<br />
Transfer free energy to surface (Bull-Breese, 1974)<br />
Apparent partial specific volume (Bull-Breese, 1974)<br />
alpha-NH chemical shifts (Bundi-Wuthrich, 1979)<br />
alpha-CH chemical shifts (Bundi-Wuthrich, 1979)<br />
Spin-spin coupling constants 3JHalpha-NH (Bundi-Wuthrich, 1979)<br />
Normalized frequency of alpha-helix (Burgess et al., 1974)<br />
Normalized frequency of extended structure (Burgess et al., 1974)<br />
Steric parameter (Charton, 1981)<br />
Polarizability parameter (Charton-Charton, 1982)<br />
Free energy of solution in water, kcal/mole (Charton-Charton, 1982)<br />
The Chou-Fasman parameter of the coil conformation (Charton-Charton, 1983)<br />
A parameter defined from the residuals obtained from the best correlation of the Chou-Fasman parameter of beta-sheet (Charton-Charton, 1983)<br />
The number of atoms in the side chain labelled 1+1 (Charton-Charton, 1983)<br />
The number of atoms in the side chain labelled 2+1 (Charton-Charton, 1983)<br />
The number of atoms in the side chain labelled 3+1 (Charton-Charton, 1983)<br />
The number of bonds in the longest chain (Charton-Charton, 1983)<br />
A parameter of charge transfer capability (Charton-Charton, 1983)<br />
A parameter of charge transfer donor capability (Charton-Charton, 1983)<br />
Average volume of buried residue (Chothia, 1975)<br />
Residue accessible surface area in tripeptide (Chothia, 1976)<br />
Residue accessible surface area in folded protein (Chothia, 1976)<br />
Proportion of residues 95
Proportion of residues 100
Normalized frequency of beta-turn (Chou-Fasman, 1978a)<br />
Normalized frequency of alpha-helix (Chou-Fasman, 1978b)<br />
Normalized frequency of beta-sheet (Chou-Fasman, 1978b)<br />
Normalized frequency of beta-turn (Chou-Fasman, 1978b)<br />
Normalized frequency of N-terminal helix (Chou-Fasman, 1978b)<br />
Normalized frequency of C-terminal helix (Chou-Fasman, 1978b)<br />
Normalized frequency of N-terminal non helical region (Chou-Fasman, 1978b)<br />
Normalized frequency of C-terminal non helical region (Chou-Fasman, 1978b)<br />
Normalized frequency of N-terminal beta-sheet (Chou-Fasman, 1978b)<br />
Normalized frequency of C-terminal beta-sheet (Chou-Fasman, 1978b)<br />
Normalized frequency of N-terminal non beta region (Chou-Fasman, 1978b)<br />
Normalized frequency of C-terminal non beta region (Chou-Fasman, 1978b)<br />
Frequency of the 1st residue in turn (Chou-Fasman, 1978b)<br />
Frequency of the 2nd residue in turn (Chou-Fasman, 1978b)<br />
Frequency of the 3rd residue in turn (Chou-Fasman, 1978b)<br />
Frequency of the 4th residue in turn (Chou-Fasman, 1978b)<br />
Normalized frequency of the 2nd and 3rd residues in turn (Chou-Fasman, 1978b)<br />
Normalized hydrophobicity scales for alpha-proteins (Cid et al., 1992)<br />
Normalized hydrophobicity scales for beta-proteins (Cid et al., 1992)<br />
Normalized hydrophobicity scales for alpha+beta-proteins (Cid et al., 1992)<br />
Normalized hydrophobicity scales for alpha/beta-proteins (Cid et al., 1992)<br />
Normalized average hydrophobicity scales (Cid et al., 1992)<br />
Partial specific volume (Cohn-Edsall, 1943)<br />
Normalized frequency of middle helix (Crawford et al., 1973)<br />
Normalized frequency of beta-sheet (Crawford et al., 1973)<br />
Normalized frequency of turn (Crawford et al., 1973)<br />
Size (Dawson, 1972)<br />
Amino acid composition (Dayhoff et al., 1978a)<br />
Relative mutability (Dayhoff et al., 1978b)<br />
Membrane preference for cytochrome b: MPH89 (Degli Esposti et al., 1990)<br />
Average membrane preference: AMP07 (Degli Esposti et al., 1990)<br />
Consensus normalized hydrophobicity scale (Eisenberg, 1984)<br />
Solvation free energy (Eisenberg-McLachlan, 1986)<br />
Atom-based hydrophobic moment (Eisenberg-McLachlan, 1986)<br />
Direction of hydrophobic moment (Eisenberg-McLachlan, 1986)<br />
Molecular weight (Fasman, 1976)<br />
Melting point (Fasman, 1976)<br />
Optical rotation (Fasman, 1976)<br />
pK-N (Fasman, 1976)<br />
pK-C (Fasman, 1976)<br />
Hydrophobic parameter pi (Fauchere-Pliska, 1983)<br />
Graph shape index (Fauchere et al., 1988)<br />
Smoothed upsilon steric parameter (Fauchere et al., 1988)<br />
Normalized van der Waals volume (Fauchere et al., 1988)<br />
STERIMOL length of the side chain (Fauchere et al., 1988)<br />
STERIMOL minimum width of the side chain (Fauchere et al., 1988)<br />
STERIMOL maximum width of the side chain (Fauchere et al., 1988)<br />
N.m.r. chemical shift of alpha-carbon (Fauchere et al., 1988)<br />
Localized electrical effect (Fauchere et al., 1988)<br />
Number of hydrogen bond donors (Fauchere et al., 1988)<br />
Number of full nonbonding orbitals (Fauchere et al., 1988)<br />
Positive charge (Fauchere et al., 1988)<br />
Negative charge (Fauchere et al., 1988)<br />
pK-a(RCOOH) (Fauchere et al., 1988)<br />
Helix-coil equilibrium constant (Finkelstein-Ptitsyn, 1977)<br />
Helix initiation parameter at posision i-1 (Finkelstein et al., 1991)<br />
Helix initiation parameter at posision i,i+1,i+2 (Finkelstein et al., 1991)<br />
Helix termination parameter at posision j-2,j-1,j (Finkelstein et al., 1991)<br />
Helix termination parameter at posision j+1 (Finkelstein et al., 1991)<br />
Partition coefficient (Garel et al., 1973)<br />
Alpha-helix indices (Geisow-Roberts, 1980)<br />
Alpha-helix indices for alpha-proteins (Geisow-Roberts, 1980)<br />
Alpha-helix indices for beta-proteins (Geisow-Roberts, 1980)<br />
Alpha-helix indices for alpha/beta-proteins (Geisow-Roberts, 1980)<br />
Beta-strand indices (Geisow-Roberts, 1980)<br />
Beta-strand indices for beta-proteins (Geisow-Roberts, 1980)<br />
Beta-strand indices for alpha/beta-proteins (Geisow-Roberts, 1980)<br />
Aperiodic indices (Geisow-Roberts, 1980)<br />
Aperiodic indices for alpha-proteins (Geisow-Roberts, 1980)<br />
Aperiodic indices for beta-proteins (Geisow-Roberts, 1980)<br />
Aperiodic indices for alpha/beta-proteins (Geisow-Roberts, 1980)<br />
Hydrophobicity factor (Goldsack-Chalifoux, 1973)<br />
Residue volume (Goldsack-Chalifoux, 1973)<br />
Composition (Grantham, 1974)<br />
Polarity (Grantham, 1974)<br />
Volume (Grantham, 1974)<br />
Partition energy (Guy, 1985)<br />
Hydration number (Hopfinger, 1971), Cited by Charton-Charton (1982)<br />
Hydrophilicity value (Hopp-Woods, 1981)<br />
Heat capacity (Hutchens, 1970)<br />
Absolute entropy (Hutchens, 1970)<br />
Entropy of formation (Hutchens, 1970)<br />
Normalized relative frequency of alpha-helix (Isogai et al., 1980)<br />
Normalized relative frequency of extended structure (Isogai et al., 1980)<br />
Normalized relative frequency of bend (Isogai et al., 1980)<br />
Normalized relative frequency of bend R (Isogai et al., 1980)<br />
Normalized relative frequency of bend S (Isogai et al., 1980)<br />
Normalized relative frequency of helix end (Isogai et al., 1980)<br />
Normalized relative frequency of double bend (Isogai et al., 1980)<br />
Normalized relative frequency of coil (Isogai et al., 1980)<br />
Average accessible surface area (Janin et al., 1978)<br />
Percentage of buried residues (Janin et al., 1978)<br />
Percentage of exposed residues (Janin et al., 1978)<br />
Ratio of buried and accessible molar fractions (Janin, 1979)<br />
Transfer free energy (Janin, 1979)<br />
Hydrophobicity (Jones, 1975)<br />
pK (-COOH) (Jones, 1975)<br />
Relative frequency of occurrence (Jones et al., 1992)<br />
Relative mutability (Jones et al., 1992)<br />
Amino acid distribution (Jukes et al., 1975)<br />
Sequence frequency (Jungck, 1978)<br />
Average relative probability of helix (Kanehisa-Tsong, 1980)<br />
Average relative probability of beta-sheet (Kanehisa-Tsong, 1980)<br />
Average relative probability of inner helix (Kanehisa-Tsong, 1980)<br />
Average relative probability of inner beta-sheet (Kanehisa-Tsong, 1980)<br />
Flexibility parameter for no rigid neighbors (Karplus-Schulz, 1985)<br />
Flexibility parameter for one rigid neighbor (Karplus-Schulz, 1985)<br />
Flexibility parameter for two rigid neighbors (Karplus-Schulz, 1985)<br />
The Kerr-constant increments (Khanarian-Moore, 1980)<br />
Net charge (Klein et al., 1984)<br />
Side chain interaction parameter (Krigbaum-Rubin, 1971)<br />
Side chain interaction parameter (Krigbaum-Komoriya, 1979)<br />
Fraction of site occupied by water (Krigbaum-Komoriya, 1979)<br />
Side chain volume (Krigbaum-Komoriya, 1979)<br />
Hydropathy index (Kyte-Doolittle, 1982)<br />
Transfer free energy, CHP/water (Lawson et al., 1984)<br />
Hydrophobic parameter (Levitt, 1976)<br />
Distance between C-alpha and centroid of side chain (Levitt, 1976)<br />
Side chain angle theta(AAR) (Levitt, 1976)<br />
Side chain torsion angle phi(AAAR) (Levitt, 1976)<br />
Radius of gyration of side chain (Levitt, 1976)<br />
van der Waals parameter R0 (Levitt, 1976)<br />
van der Waals parameter epsilon (Levitt, 1976)<br />
Normalized frequency of alpha-helix, with weights (Levitt, 1978)<br />
Normalized frequency of beta-sheet, with weights (Levitt, 1978)<br />
Normalized frequency of reverse turn, with weights (Levitt, 1978)<br />
Normalized frequency of alpha-helix, unweighted (Levitt, 1978)<br />
Normalized frequency of beta-sheet, unweighted (Levitt, 1978)<br />
Normalized frequency of reverse turn, unweighted (Levitt, 1978)<br />
Frequency of occurrence in beta-bends (Lewis et al., 1971)<br />
Conformational preference for all beta-strands (Lifson-Sander, 1979)<br />
Conformational preference for parallel beta-strands (Lifson-Sander, 1979)<br />
Conformational preference for antiparallel beta-strands (Lifson-Sander, 1979)<br />
Average surrounding hydrophobicity (Manavalan-Ponnuswamy, 1978)<br />
Normalized frequency of alpha-helix (Maxfield-Scheraga, 1976)<br />
Normalized frequency of extended structure (Maxfield-Scheraga, 1976)<br />
Normalized frequency of zeta R (Maxfield-Scheraga, 1976)<br />
Normalized frequency of left-handed alpha-helix (Maxfield-Scheraga, 1976)<br />
Normalized frequency of zeta L (Maxfield-Scheraga, 1976)<br />
Normalized frequency of alpha region (Maxfield-Scheraga, 1976)<br />
Refractivity (McMeekin et al., 1964), Cited by Jones (1975)<br />
Retention coefficient in HPLC, pH7.4 (Meek, 1980)<br />
Retention coefficient in HPLC, pH2.1 (Meek, 1980)<br />
Retention coefficient in NaClO4 (Meek-Rossetti, 1981)<br />
Retention coefficient in NaH2PO4 (Meek-Rossetti, 1981)<br />
Average reduced distance for C-alpha (Meirovitch et al., 1980)<br />
Average reduced distance for side chain (Meirovitch et al., 1980)<br />
Average side chain orientation angle (Meirovitch et al., 1980)<br />
Effective partition energy (Miyazawa-Jernigan, 1985)<br />
Normalized frequency of alpha-helix (Nagano, 1973)<br />
Normalized frequency of bata-structure (Nagano, 1973)<br />
Normalized frequency of coil (Nagano, 1973)<br />
AA composition of total proteins (Nakashima et al., 1990)<br />
SD of AA composition of total proteins (Nakashima et al., 1990)<br />
AA composition of mt-proteins (Nakashima et al., 1990)<br />
Normalized composition of mt-proteins (Nakashima et al., 1990)<br />
AA composition of mt-proteins from animal (Nakashima et al., 1990)<br />
Normalized composition from animal (Nakashima et al., 1990)<br />
AA composition of mt-proteins from fungi and plant (Nakashima et al., 1990)<br />
Normalized composition from fungi and plant (Nakashima et al., 1990)<br />
AA composition of membrane proteins (Nakashima et al., 1990)<br />
Normalized composition of membrane proteins (Nakashima et al., 1990)<br />
Transmembrane regions of non-mt-proteins (Nakashima et al., 1990)<br />
Transmembrane regions of mt-proteins (Nakashima et al., 1990)<br />
Ratio of average and computed composition (Nakashima et al., 1990)<br />
AA composition of CYT of single-spanning proteins (Nakashima-Nishikawa, 1992)<br />
AA composition of CYT2 of single-spanning proteins (Nakashima-Nishikawa, 1992)<br />
AA composition of EXT of single-spanning proteins (Nakashima-Nishikawa, 1992)<br />
AA composition of EXT2 of single-spanning proteins (Nakashima-Nishikawa, 1992)<br />
AA composition of MEM of single-spanning proteins (Nakashima-Nishikawa, 1992)<br />
AA composition of CYT of multi-spanning proteins (Nakashima-Nishikawa, 1992)<br />
AA composition of EXT of multi-spanning proteins (Nakashima-Nishikawa, 1992)<br />
AA composition of MEM of multi-spanning proteins (Nakashima-Nishikawa, 1992)<br />
8 A contact number (Nishikawa-Ooi, 1980)<br />
14 A contact number (Nishikawa-Ooi, 1986)<br />
Transfer energy, organic solvent/water (Nozaki-Tanford, 1971)<br />
Average non-bonded energy per atom (Oobatake-Ooi, 1977)<br />
Short and medium range non-bonded energy per atom (Oobatake-Ooi, 1977)<br />
Long range non-bonded energy per atom (Oobatake-Ooi, 1977)<br />
Average non-bonded energy per residue (Oobatake-Ooi, 1977)<br />
Short and medium range non-bonded energy per residue (Oobatake-Ooi, 1977)<br />
Optimized beta-structure-coil equilibrium constant (Oobatake et al., 1985)<br />
Optimized propensity to form reverse turn (Oobatake et al., 1985)<br />
Optimized transfer energy parameter (Oobatake et al., 1985)<br />
Optimized average non-bonded energy per atom (Oobatake et al., 1985)<br />
Optimized side chain interaction parameter (Oobatake et al., 1985)<br />
Normalized frequency of alpha-helix from LG (Palau et al., 1981)<br />
Normalized frequency of alpha-helix from CF (Palau et al., 1981)<br />
Normalized frequency of beta-sheet from LG (Palau et al., 1981)<br />
Normalized frequency of beta-sheet from CF (Palau et al., 1981)<br />
Normalized frequency of turn from LG (Palau et al., 1981)<br />
Normalized frequency of turn from CF (Palau et al., 1981)<br />
Normalized frequency of alpha-helix in all-alpha class (Palau et al., 1981)<br />
Normalized frequency of alpha-helix in alpha+beta class (Palau et al., 1981)<br />
Normalized frequency of alpha-helix in alpha/beta class (Palau et al., 1981)<br />
Normalized frequency of beta-sheet in all-beta class (Palau et al., 1981)<br />
Normalized frequency of beta-sheet in alpha+beta class (Palau et al., 1981)<br />
Normalized frequency of beta-sheet in alpha/beta class (Palau et al., 1981)<br />
Normalized frequency of turn in all-alpha class (Palau et al., 1981)<br />
Normalized frequency of turn in all-beta class (Palau et al., 1981)<br />
Normalized frequency of turn in alpha+beta class (Palau et al., 1981)<br />
Normalized frequency of turn in alpha/beta class (Palau et al., 1981)<br />
HPLC parameter (Parker et al., 1986)<br />
Partition coefficient (Pliska et al., 1981)<br />
Surrounding hydrophobicity in folded form (Ponnuswamy et al., 1980)<br />
Average gain in surrounding hydrophobicity (Ponnuswamy et al., 1980)<br />
Average gain ratio in surrounding hydrophobicity (Ponnuswamy et al., 1980)<br />
Surrounding hydrophobicity in alpha-helix (Ponnuswamy et al., 1980)<br />
Surrounding hydrophobicity in beta-sheet (Ponnuswamy et al., 1980)<br />
Surrounding hydrophobicity in turn (Ponnuswamy et al., 1980)<br />
Accessibility reduction ratio (Ponnuswamy et al., 1980)<br />
Average number of surrounding residues (Ponnuswamy et al., 1980)<br />
Intercept in regression analysis (Prabhakaran-Ponnuswamy, 1982)<br />
Slope in regression analysis x 1.0E1 (Prabhakaran-Ponnuswamy, 1982)<br />
Correlation coefficient in regression analysis (Prabhakaran-Ponnuswamy, 1982)<br />
Hydrophobicity (Prabhakaran, 1990)<br />
Relative frequency in alpha-helix (Prabhakaran, 1990)<br />
Relative frequency in beta-sheet (Prabhakaran, 1990)<br />
Relative frequency in reverse-turn (Prabhakaran, 1990)<br />
Helix-coil equilibrium constant (Ptitsyn-Finkelstein, 1983)<br />
Beta-coil equilibrium constant (Ptitsyn-Finkelstein, 1983)<br />
Weights for alpha-helix at the window position of -6 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of -5 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of -4 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of -3 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of -2 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of -1 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of 0 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of 1 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of 2 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of 3 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of 4 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of 5 (Qian-Sejnowski, 1988)<br />
Weights for alpha-helix at the window position of 6 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of -6 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of -5 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of -4 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of -3 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of -2 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of -1 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of 0 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of 1 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of 2 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of 3 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of 4 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of 5 (Qian-Sejnowski, 1988)<br />
Weights for beta-sheet at the window position of 6 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of -6 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of -5 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of -4 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of -3 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of -2 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of -1 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of 0 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of 1 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of 2 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of 3 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of 4 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of 5 (Qian-Sejnowski, 1988)<br />
Weights for coil at the window position of 6 (Qian-Sejnowski, 1988)<br />
Average reduced distance for C-alpha (Rackovsky-Scheraga, 1977)<br />
Average reduced distance for side chain (Rackovsky-Scheraga, 1977)<br />
Side chain orientational preference (Rackovsky-Scheraga, 1977)<br />
Average relative fractional occurrence in A0(i) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in AR(i) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in AL(i) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in EL(i) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in E0(i) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in ER(i) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in A0(i-1) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in AR(i-1) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in AL(i-1) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in EL(i-1) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in E0(i-1) (Rackovsky-Scheraga, 1982)<br />
Average relative fractional occurrence in ER(i-1) (Rackovsky-Scheraga, 1982)<br />
Value of theta(i) (Rackovsky-Scheraga, 1982)<br />
Value of theta(i-1) (Rackovsky-Scheraga, 1982)<br />
Transfer free energy from chx to wat (Radzicka-Wolfenden, 1988)<br />
Transfer free energy from oct to wat (Radzicka-Wolfenden, 1988)<br />
Transfer free energy from vap to chx (Radzicka-Wolfenden, 1988)<br />
Transfer free energy from chx to oct (Radzicka-Wolfenden, 1988)<br />
Transfer free energy from vap to oct (Radzicka-Wolfenden, 1988)<br />
Accessible surface area (Radzicka-Wolfenden, 1988)<br />
Energy transfer from out to in(95
Mean polarity (Radzicka-Wolfenden, 1988)<br />
Relative preference value at N&quot; (Richardson-Richardson, 1988)<br />
Relative preference value at N' (Richardson-Richardson, 1988)<br />
Relative preference value at N-cap (Richardson-Richardson, 1988)<br />
Relative preference value at N1 (Richardson-Richardson, 1988)<br />
Relative preference value at N2 (Richardson-Richardson, 1988)<br />
Relative preference value at N3 (Richardson-Richardson, 1988)<br />
Relative preference value at N4 (Richardson-Richardson, 1988)<br />
Relative preference value at N5 (Richardson-Richardson, 1988)<br />
Relative preference value at Mid (Richardson-Richardson, 1988)<br />
Relative preference value at C5 (Richardson-Richardson, 1988)<br />
Relative preference value at C4 (Richardson-Richardson, 1988)<br />
Relative preference value at C3 (Richardson-Richardson, 1988)<br />
Relative preference value at C2 (Richardson-Richardson, 1988)<br />
Relative preference value at C1 (Richardson-Richardson, 1988)<br />
Relative preference value at C-cap (Richardson-Richardson, 1988)<br />
Relative preference value at C' (Richardson-Richardson, 1988)<br />
Relative preference value at C&quot; (Richardson-Richardson, 1988)<br />
Information measure for alpha-helix (Robson-Suzuki, 1976)<br />
Information measure for N-terminal helix (Robson-Suzuki, 1976)<br />
Information measure for middle helix (Robson-Suzuki, 1976)<br />
Information measure for C-terminal helix (Robson-Suzuki, 1976)<br />
Information measure for extended (Robson-Suzuki, 1976)<br />
Information measure for pleated-sheet (Robson-Suzuki, 1976)<br />
Information measure for extended without H-bond (Robson-Suzuki, 1976)<br />
Information measure for turn (Robson-Suzuki, 1976)<br />
Information measure for N-terminal turn (Robson-Suzuki, 1976)<br />
Information measure for middle turn (Robson-Suzuki, 1976)<br />
Information measure for C-terminal turn (Robson-Suzuki, 1976)<br />
Information measure for coil (Robson-Suzuki, 1976)<br />
Information measure for loop (Robson-Suzuki, 1976)<br />
Hydration free energy (Robson-Osguthorpe, 1979)<br />
Mean area buried on transfer (Rose et al., 1985)<br />
Mean fractional area loss (Rose et al., 1985)<br />
Side chain hydropathy, uncorrected for solvation (Roseman, 1988)<br />
Side chain hydropathy, corrected for solvation (Roseman, 1988)<br />
Loss of Side chain hydropathy by helix formation (Roseman, 1988)<br />
Transfer free energy (Simon, 1976), Cited by Charton-Charton (1982)<br />
Principal component I (Sneath, 1966)<br />
Principal component II (Sneath, 1966)<br />
Principal component III (Sneath, 1966)<br />
Principal component IV (Sneath, 1966)<br />
Zimm-Bragg parameter s at 20 C (Sueki et al., 1984)<br />
Zimm-Bragg parameter sigma x 1.0E4 (Sueki et al., 1984)<br />
Optimal matching hydrophobicity (Sweet-Eisenberg, 1983)<br />
Normalized frequency of alpha-helix (Tanaka-Scheraga, 1977)<br />
Normalized frequency of isolated helix (Tanaka-Scheraga, 1977)<br />
Normalized frequency of extended structure (Tanaka-Scheraga, 1977)<br />
Normalized frequency of chain reversal R (Tanaka-Scheraga, 1977)<br />
Normalized frequency of chain reversal S (Tanaka-Scheraga, 1977)<br />
Normalized frequency of chain reversal D (Tanaka-Scheraga, 1977)<br />
Normalized frequency of left-handed helix (Tanaka-Scheraga, 1977)<br />
Normalized frequency of zeta R (Tanaka-Scheraga, 1977)<br />
Normalized frequency of coil (Tanaka-Scheraga, 1977)<br />
Normalized frequency of chain reversal (Tanaka-Scheraga, 1977)<br />
Relative population of conformational state A (Vasquez et al., 1983)<br />
Relative population of conformational state C (Vasquez et al., 1983)<br />
Relative population of conformational state E (Vasquez et al., 1983)<br />
Electron-ion interaction potential (Veljkovic et al., 1985)<br />
Bitterness (Venanzi, 1984)<br />
Transfer free energy to lipophilic phase (von Heijne-Blomberg, 1979)<br />
Average interactions per side chain atom (Warme-Morgan, 1978)<br />
RF value in high salt chromatography (Weber-Lacey, 1978)<br />
Propensity to be buried inside (Wertz-Scheraga, 1978)<br />
Free energy change of epsilon(i) to epsilon(ex) (Wertz-Scheraga, 1978)<br />
Free energy change of alpha(Ri) to alpha(Rh) (Wertz-Scheraga, 1978)<br />
Free energy change of epsilon(i) to alpha(Rh) (Wertz-Scheraga, 1978)<br />
Polar requirement (Woese, 1973)<br />
Hydration potential (Wolfenden et al., 1981)<br />
Principal property value z1 (Wold et al., 1987)<br />
Principal property value z2 (Wold et al., 1987)<br />
Principal property value z3 (Wold et al., 1987)<br />
Unfolding Gibbs energy in water, pH7.0 (Yutani et al., 1987)<br />
Unfolding Gibbs energy in water, pH9.0 (Yutani et al., 1987)<br />
Activation Gibbs energy of unfolding, pH7.0 (Yutani et al., 1987)<br />
Activation Gibbs energy of unfolding, pH9.0 (Yutani et al., 1987)<br />
Dependence of partition coefficient on ionic strength (Zaslavsky et al., 1982)<br />
Hydrophobicity (Zimmerman et al., 1968)<br />
Bulkiness (Zimmerman et al., 1968)<br />
Polarity (Zimmerman et al., 1968)<br />
Isoelectric point (Zimmerman et al., 1968)<br />
RF rank (Zimmerman et al., 1968)<br />
Normalized positional residue frequency at helix termini N4'(Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N&quot;' (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N&quot; (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N'(Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini Nc (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N1 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N2 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N3 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N4 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini N5 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C5 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C4 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C3 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C2 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C1 (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini Cc (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C' (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C&quot; (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C&quot;' (Aurora-Rose, 1998)<br />
Normalized positional residue frequency at helix termini C4' (Aurora-Rose, 1998)<br />
Delta G values for the peptides extrapolated to 0 M urea (O'Neil-DeGrado, 1990)<br />
Helix formation parameters (delta delta G) (O'Neil-DeGrado, 1990)<br />
Normalized flexibility parameters (B-values), average (Vihinen et al., 1994)<br />
Normalized flexibility parameters (B-values) for each residue surrounded by none rigid neighbours (Vihinen et al., 1994)<br />
Normalized flexibility parameters (B-values) for each residue surrounded by one rigid neighbours (Vihinen et al., 1994)<br />
Normalized flexibility parameters (B-values) for each residue surrounded by two rigid neighbours (Vihinen et al., 1994)<br />
Free energy in alpha-helical conformation (Munoz-Serrano, 1994)<br />
Free energy in alpha-helical region (Munoz-Serrano, 1994)<br />
Free energy in beta-strand conformation (Munoz-Serrano, 1994)<br />
Free energy in beta-strand region (Munoz-Serrano, 1994)<br />
Free energy in beta-strand region (Munoz-Serrano, 1994)<br />
Free energies of transfer of AcWl-X-LL peptides from bilayer interface to water (Wimley-White, 1996)<br />
Thermodynamic beta sheet propensity (Kim-Berg, 1993)<br />
Turn propensity scale for transmembrane helices (Monne et al., 1999)<br />
Alpha helix propensity of position 44 in T4 lysozyme (Blaber et al., 1993)<br />
p-Values of mesophilic proteins based on the distributions of B values (Parthasarathy-Murthy, 2000)<br />
p-Values of thermophilic proteins based on the distributions of B values (Parthasarathy-Murthy, 2000)<br />
Distribution of amino acid residues in the 18 non-redundant families of thermophilic proteins (Kumar et al., 2000)<br />
Distribution of amino acid residues in the 18 non-redundant families of mesophilic proteins (Kumar et al., 2000)<br />
Distribution of amino acid residues in the alpha-helices in thermophilic proteins (Kumar et al., 2000)<br />
Distribution of amino acid residues in the alpha-helices in mesophilic proteins (Kumar et al., 2000)<br />
Side-chain contribution to protein stability (kJ/mol) (Takano-Yutani, 2001)<br />
Propensity of amino acids within pi-helices (Fodje-Al-Karadaghi, 2002)<br />
Hydropathy scale based on self-information values in the two-state model (5
Hydropathy scale based on self-information values in the two-state model (9
Hydropathy scale based on self-information values in the two-state model (16
Hydropathy scale based on self-information values in the two-state model (20
Hydropathy scale based on self-information values in the two-state model (25
Hydropathy scale based on self-information values in the two-state model (36
Hydropathy scale based on self-information values in the two-state model (50
Averaged turn propensities in a transmembrane helix (Monne et al., 1999)<br />
Alpha-helix propensity derived from designed sequences (Koehl-Levitt, 1999)<br />
Beta-sheet propensity derived from designed sequences (Koehl-Levitt, 1999)<br />
Composition of amino acids in extracellular proteins (percent) (Cedano et al., 1997)<br />
Composition of amino acids in anchored proteins (percent) (Cedano et al., 1997)<br />
Composition of amino acids in membrane proteins (percent) (Cedano et al., 1997)<br />
Composition of amino acids in intracellular proteins (percent) (Cedano et al., 1997)<br />
Composition of amino acids in nuclear proteins (percent) (Cedano et al., 1997)<br />
Surface composition of amino acids in intracellular proteins of thermophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Surface composition of amino acids in intracellular proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Surface composition of amino acids in extracellular proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Surface composition of amino acids in nuclear proteins (percent) (Fukuchi-Nishikawa, 2001)<br />
Interior composition of amino acids in intracellular proteins of thermophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Interior composition of amino acids in intracellular proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Interior composition of amino acids in extracellular proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Interior composition of amino acids in nuclear proteins (percent) (Fukuchi-Nishikawa, 2001)<br />
Entire chain composition of amino acids in intracellular proteins of thermophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Entire chain composition of amino acids in intracellular proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Entire chain composition of amino acids in extracellular proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)<br />
Entire chain compositino of amino acids in nuclear proteins (percent) (Fukuchi-Nishikawa, 2001)<br />
Screening coefficients gamma, local (Avbelj, 2000)<br />
Screening coefficients gamma, non-local (Avbelj, 2000)<br />
Slopes tripeptide, FDPB VFF neutral (Avbelj, 2000)<br />
Slopes tripeptides, LD VFF neutral (Avbelj, 2000)<br />
Slopes tripeptide, FDPB VFF noside (Avbelj, 2000)<br />
Slopes tripeptide FDPB VFF all (Avbelj, 2000)<br />
Slopes tripeptide FDPB PARSE neutral (Avbelj, 2000)<br />
Slopes dekapeptide, FDPB VFF neutral (Avbelj, 2000)<br />
Slopes proteins, FDPB VFF neutral (Avbelj, 2000)<br />
Side-chain conformation by gaussian evolutionary method (Yang et al., 2002)<br />
Amphiphilicity index (Mitaku et al., 2002)<br />
Volumes including the crystallographic waters using the ProtOr (Tsai et al., 1999)<br />
Volumes not including the crystallographic waters using the ProtOr (Tsai et al., 1999)<br />
Electron-ion interaction potential values (Cosic, 1994)<br />
Hydrophobicity scales (Ponnuswamy, 1993)<br />
Hydrophobicity coefficient in RP-HPLC, C18 with 0.1
Hydrophobicity coefficient in RP-HPLC, C8 with 0.1
Hydrophobicity coefficient in RP-HPLC, C4 with 0.1
Hydrophobicity coefficient in RP-HPLC, C18 with 0.1
Hydrophilicity scale (Kuhn et al., 1995)<br />
Retention coefficient at pH 2 (Guo et al., 1986)<br />
Modified Kyte-Doolittle hydrophobicity scale (Juretic et al., 1998)<br />
Interactivity scale obtained from the contact matrix (Bastolla et al., 2005)<br />
Interactivity scale obtained by maximizing the mean of correlation coefficient over single-domain globular proteins (Bastolla et al., 2005)<br />
Interactivity scale obtained by maximizing the mean of correlation coefficient over pairs of sequences sharing the TIM barrel fold (Bastolla et al., 2005)<br />
Linker propensity index (Suyama-Ohara, 2003)<br />
Knowledge-based membrane-propensity scale from 1D Helix in MPtopo databases (Punta-Maritan, 2003)<br />
Knowledge-based membrane-propensity scale from 3D Helix in MPtopo databases (Punta-Maritan, 2003)<br />
Linker propensity from all dataset (George-Heringa, 2003)<br />
Linker propensity from 1-linker dataset (George-Heringa, 2003)<br />
Linker propensity from 2-linker dataset (George-Heringa, 2003)<br />
Linker propensity from 3-linker dataset (George-Heringa, 2003)<br />
Linker propensity from small dataset (linker length is less than six residues) (George-Heringa, 2003)<br />
Linker propensity from medium dataset (linker length is between six and 14 residues) (George-Heringa, 2003)<br />
Linker propensity from long dataset (linker length is greater than 14 residues) (George-Heringa, 2003)<br />
Linker propensity from helical (annotated by DSSP) dataset (George-Heringa, 2003)<br />
Linker propensity from non-helical (annotated by DSSP) dataset (George-Heringa, 2003)<br />
The stability scale from the knowledge-based atom-atom potential (Zhou-Zhou, 2004)<br />
The relative stability scale extracted from mutation experiments (Zhou-Zhou, 2004)<br />
Buriability (Zhou-Zhou, 2004)<br />
Linker index (Bae et al., 2005)<br />
Mean volumes of residues buried in protein interiors (Harpaz et al., 1994)<br />
Average volumes of residues (Pontius et al., 1996)<br />
Hydrostatic pressure asymmetry index, PAI (Di Giulio, 2005)<br />
Hydrophobicity index (Wolfenden et al., 1979)<br />
Average internal preferences (Olsen, 1980)<br />
Hydrophobicity-related index (Kidera et al., 1985)<br />
Apparent partition energies calculated from Wertz-Scheraga index (Guy, 1985)<br />
Apparent partition energies calculated from Robson-Osguthorpe index (Guy, 1985)<br />
Apparent partition energies calculated from Janin index (Guy, 1985)<br />
Apparent partition energies calculated from Chothia index (Guy, 1985)<br />
Hydropathies of amino acid side chains, neutral form (Roseman, 1988)<br />
Hydropathies of amino acid side chains, pi-values in pH 7.0 (Roseman, 1988)<br />
Weights from the IFH scale (Jacobs-White, 1989)<br />
Hydrophobicity index, 3.0 pH (Cowan-Whittaker, 1990)<br />
Scaled side chain hydrophobicity values (Black-Mould, 1991)<br />
Hydrophobicity scale from native protein structures (Casari-Sippl, 1992)<br />
NNEIG index (Cornette et al., 1987)<br />
SWEIG index (Cornette et al., 1987)<br />
PRIFT index (Cornette et al., 1987)<br />
PRILS index (Cornette et al., 1987)<br />
ALTFT index (Cornette et al., 1987)<br />
ALTLS index (Cornette et al., 1987)<br />
TOTFT index (Cornette et al., 1987)<br />
TOTLS index (Cornette et al., 1987)<br />
Relative partition energies derived by the Bethe approximation (Miyazawa-Jernigan, 1999)<br />
Optimized relative partition energies - method A (Miyazawa-Jernigan, 1999)<br />
Optimized relative partition energies - method B (Miyazawa-Jernigan, 1999)<br />
Optimized relative partition energies - method C (Miyazawa-Jernigan, 1999)<br />
Optimized relative partition energies - method D (Miyazawa-Jernigan, 1999)<br />
Hydrophobicity index (Engelman et al., 1986)<br />
Hydrophobicity index (Fasman, 1989)
</p>


<h3>Source</h3>

<p><a href="https://www.genome.jp/aaindex/">https://www.genome.jp/aaindex/</a>
</p>


<h3>References</h3>

<p>From the original aaindex documentation:<br />
</p>
<p>Please cite the following references when making use of the database:
</p>
<p>Kawashima, S. and Kanehisa, M. (2000) AAindex: amino acid index
database. <em>Nucleic Acids Res.</em>, <b>28</b>:374.<br />
</p>
<p>Tomii, K. and Kanehisa, M. (1996) Analysis of amino acid indices and
mutation matrices for sequence comparison and structure
prediction of proteins. <em>Protein Eng.</em>, <b>9</b>:27-36.<br />
</p>
<p>Nakai, K., Kidera, A., and Kanehisa, M. (1988) Cluster analysis of
amino acid indices for prediction of protein structure and
function. <em>Protein Eng.</em> <b>2</b>:93-100.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Load data:
#

data(aaindex)

#
# Supose that we need the Kyte &amp; Doolittle Hydrophaty index. We first look
# at the entries with Kyte as author:
#

which(sapply(aaindex, function(x) length(grep("Kyte", x$A)) != 0))

#
# This should return that entry number 151 named KYTJ820101 is the only
# one that fit our request. We can access to it by position or by name,
# for instance:
#

aaindex[[151]]$I
aaindex[["KYTJ820101"]]$I
aaindex$KYTJ820101$I

</code></pre>

<hr>
<h2 id='AAstat'> To Get Some Protein Statistics </h2><span id='topic+AAstat'></span>

<h3>Description</h3>

<p>Returns simple protein sequence information including the number of residues,
the percentage physico-chemical classes and the theoretical isoelectric point.
The functions ignore ambiguous amino acids (e.g. &quot;B&quot;, &quot;Z&quot;, &quot;X&quot;, &quot;J&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AAstat(seq, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AAstat_+3A_seq">seq</code></td>
<td>
<p> a protein sequence as a vector of upper-case chars </p>
</td></tr>
<tr><td><code id="AAstat_+3A_plot">plot</code></td>
<td>
<p> if <code>TRUE</code>, plots the presence of residues splited by
physico-chemical classes along the sequence. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the three following components:
</p>
<table role = "presentation">
<tr><td><code>Compo</code></td>
<td>
<p>A factor giving the amino acid counts.</p>
</td></tr>
<tr><td><code>Prop</code></td>
<td>
<p>A list giving the percentage of each physico-chemical classes
(Tiny, Small, Aliphatic, Aromatic, Non-polar, Polar, Charged, Positive, Negative).</p>
</td></tr>
<tr><td><code>Pi</code></td>
<td>
<p>The theoretical isoelectric point</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+computePI">computePI</a></code>, <code><a href="#topic+SEQINR.UTIL">SEQINR.UTIL</a></code>, <code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  seqAA &lt;- read.fasta(file = system.file("sequences/seqAA.fasta", package = "seqinr"),
   seqtype = "AA")
  AAstat(seqAA[[1]])
</code></pre>

<hr>
<h2 id='acnucopen'>open and close a remote access to an ACNUC database</h2><span id='topic+acnucopen'></span><span id='topic+acnucclose'></span><span id='topic+clientid'></span><span id='topic+quitacnuc'></span>

<h3>Description</h3>

<p>These are low level functions to start and stop a remote access to an ACNUC database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acnucopen(db, socket, challenge = NA)
acnucclose(socket)
clientid(id = paste("seqinr_",
 packageDescription("seqinr")$Version, sep = ""),
 socket, verbose = FALSE)
quitacnuc(socket)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acnucopen_+3A_db">db</code></td>
<td>
<p>the remote ACNUC database name</p>
</td></tr>
<tr><td><code id="acnucopen_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to an ACNUC server</p>
</td></tr>
<tr><td><code id="acnucopen_+3A_challenge">challenge</code></td>
<td>
<p>unimplemented yet</p>
</td></tr>
<tr><td><code id="acnucopen_+3A_id">id</code></td>
<td>
<p>client ID definition defaulting to seqinr + package version number</p>
</td></tr>
<tr><td><code id="acnucopen_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE mode verbose is on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>these low level functions are usually not used directly by the user.
Use <code><a href="#topic+choosebank">choosebank</a></code> to open a remote ACNUC database
and <code><a href="#topic+closebank">closebank</a></code> to close it.
</p>


<h3>Value</h3>

<p>For <code>openacnuc</code> a list with the following
components: type : the type of database that was opened.
totseqs, totspec, totkey : total number of seqs, species, keywords in opened database.
ACC_LENGTH, L_MNEMO, WIDTH_KW, WIDTH_SP, WIDTH_SMJ, WIDTH_AUT,
WIDTH_BIB, lrtxt, SUBINLNG: max lengths of record keys in database.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+closebank">closebank</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: # Need internet connection
  mysocket &lt;- socketConnection( host = "pbil.univ-lyon1.fr",
    port = 5558, server = FALSE, blocking = TRUE)
  readLines(mysocket, n = 1) # OK acnuc socket started
  acnucopen("emblTP", socket = mysocket) -&gt; res
  expected &lt;- c("EMBL", "14138095", "236401", "1186228", "8",
    "16", "40", "40", "20", "20", "40", "60", "504")
  stopifnot(all(unlist(res) == expected))
  tryalreadyopen &lt;- try(acnucopen("emblTP", socket = mysocket))
  stopifnot(inherits(tryalreadyopen, "try-error"))
  # Need a fresh socket because acnucopen() close it if error:
  mysocket &lt;- socketConnection( host = "pbil.univ-lyon1.fr",
    port = 5558, server = FALSE, blocking = TRUE)
  tryoff &lt;-  try(acnucopen("off", socket = mysocket))
  stopifnot(inherits(tryoff, "try-error"))

  mysocket &lt;- socketConnection( host = "pbil.univ-lyon1.fr",
    port = 5558, server = FALSE, blocking = TRUE)
  tryinexistent &lt;-  try(acnucopen("tagadatagadatsointsoin", socket = mysocket))
  stopifnot(inherits(tryinexistent, "try-error"))

  mysocket &lt;- socketConnection( host = "pbil.univ-lyon1.fr",
    port = 5558, server = FALSE, blocking = TRUE)
  trycloseunopened &lt;- try(acnucclose(mysocket))
  stopifnot(inherits(trycloseunopened, "try-error"))

 
## End(Not run)
</code></pre>

<hr>
<h2 id='al2bp'>To Convert a forensic microsatellite allele name into its length in base pairs</h2><span id='topic+al2bp'></span>

<h3>Description</h3>

<p>Conventions used to name forensic microsatellite alleles (STR) are described
in Bar <em>et al.</em> (1994). The name &quot;9.3&quot; means for instance that there are
9 repetitions of the complete base oligomer and an incomplete repeat with 3 bp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>al2bp(allele.name, repeat.bp = 4, offLadderChars = "&gt;&lt;", split = "\\.")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="al2bp_+3A_allele.name">allele.name</code></td>
<td>
<p>The name of the allele, coerced to a string type.</p>
</td></tr>
<tr><td><code id="al2bp_+3A_repeat.bp">repeat.bp</code></td>
<td>
<p>The length in bp of the microsatellite base repeat, most of them
are tetranucleotides so that it defaults to 4. Do not forget to change this to 5
for loci based on pentanucleotides such as Penta D or Penta E.</p>
</td></tr>	
<tr><td><code id="al2bp_+3A_offladderchars">offLadderChars</code></td>
<td>
<p><code><a href="base.html#topic+NA">NA</a></code> is returned when at least one of 
these characters are found in the allele name. Off ladder alleles are typically
reported as &quot;&lt;8&quot; or &quot;&gt;19&quot; </p>
</td></tr>
<tr><td><code id="al2bp_+3A_split">split</code></td>
<td>
<p>The convention is to use a dot, as in &quot;9.3&quot;, between the number of repeats
and the number of bases in the incomplete repeat. On some locales where the
decimal separator is a comma this could be a source of problem, try to use
&quot;,&quot; instead for this argument which is forwarded to <code><a href="base.html#topic+strsplit">strsplit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warnings generated by faulty numeric conversions are suppressed here.
</p>


<h3>Value</h3>

<p>A single numeric value corresponding to the size in bp of the allele, or NA
when characters spoting off ladder alleles are encountedred or when numeric
conversion is impossible (<em>e.g.</em> with &quot;X&quot; or &quot;Y&quot; allele names at Amelogenin locus).
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p>Bar, W. and Brinkmann, B. and Lincoln, P. and Mayr, W.R. and Rossi, U. (1994)
DNA recommendations. 1994 report concerning further recommendations 
of the DNA Commission of the ISFH regarding PCR-based polymorphisms 
in STR (short tandem repeat) systems.
<em>Int. J. Leg. Med.</em>, <b>107</b>:159-160.
</p>
<p><code>citation("seqinR")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identifiler">identifiler</a></code> for forensic microsatellite allele name examples.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#   Quality check and examples:
#
stopifnot( al2bp("9") == 36 )   # 9 repeats of a tetranucleotide is 36 bp
stopifnot( al2bp(9) == 36 )      # also OK with numerical argument
stopifnot( al2bp(9, 5) == 45 )  # 9 repeats of a pentanucleotide is 45 bp
stopifnot( al2bp("9.3") == 39 ) # microvariant case
stopifnot( is.na(al2bp("&lt;8")) )   # off ladder case 
stopifnot( is.na(al2bp("&gt;19")) ) # off ladder case
stopifnot( is.na(al2bp("X")) )     # non STR case
#
# Application to the alleles names in the identifiler data set where all loci are 
# tetranucleotide repeats:
#
data(identifiler)
al.names &lt;- unlist(identifiler)
al.length &lt;- sapply(al.names, al2bp)
loc.names &lt;- unlist(lapply(identifiler, names))
loc.nall  &lt;-unlist(lapply(identifiler, function(x) lapply(x,length)))
loc.fac &lt;- factor(rep(loc.names, loc.nall))
par(lend = "butt", mar = c(5,6,4,1)+0.1)
boxplot(al.length~loc.fac, las = 1, col = "lightblue",
  horizontal = TRUE, main = "Range of allele lengths at forensic loci",
  xlab = "Length (bp)", ylim = c(0, max(al.length, na.rm = TRUE)))
</code></pre>

<hr>
<h2 id='alllistranks'>To get the count of existing lists and all their ranks on server</h2><span id='topic+alllistranks'></span><span id='topic+alr'></span>

<h3>Description</h3>

<p>This is a low level function to get the total number of list and all their
ranks in an opened database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alllistranks(socket = autosocket(), verbose = FALSE)
alr(socket = autosocket(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alllistranks_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="alllistranks_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, verbose mode is on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low level function is usually not used directly by the user.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table role = "presentation">
<tr><td><code>count</code></td>
<td>
<p>count of existing lists</p>
</td></tr>	
<tr><td><code>rank</code></td>
<td>
<p>their rank</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, 
<code><a href="#topic+query">query</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: # Need internet connection
 choosebank("emblTP")
 tmp1 &lt;- query("tmp1", "sp=Borrelia burgdorferi", virtual = TRUE)
 tmp2 &lt;- query("tmp2", "sp=Borrelia burgdorferi", virtual = TRUE)
 tmp3 &lt;- query("tmp3", "sp=Borrelia burgdorferi", virtual = TRUE)
 (result &lt;- alllistranks())
 stopifnot(result$count == 3)   # Three ACNUC lists
 stopifnot(result$ranks == 2:4) # Starting at rank 2
 #
 # Summay of current lists defined on the ACNUC server:
 #
 sapply(result$ranks, getliststate)
 closebank()
 
## End(Not run)
</code></pre>

<hr>
<h2 id='amb'>Expansion of IUPAC nucleotide symbols</h2><span id='topic+amb'></span>

<h3>Description</h3>

<p>This function returns the list of nucleotide matching a given IUPAC
nucleotide symbol, for instance <code>c("c", "g")</code> for <code>"s"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amb(base, forceToLower = TRUE, checkBase = TRUE,
IUPAC = s2c("acgturymkswbdhvn"), u2t = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amb_+3A_base">base</code></td>
<td>
<p>an IUPAC symbol for a nucleotide as a single character</p>
</td></tr>
<tr><td><code id="amb_+3A_forcetolower">forceToLower</code></td>
<td>
<p>if TRUE the base is forced to lower case</p>
</td></tr>
<tr><td><code id="amb_+3A_checkbase">checkBase</code></td>
<td>
<p>if TRUE the character is checked to belong to the allowed IUPAC symbol list</p>
</td></tr>
<tr><td><code id="amb_+3A_iupac">IUPAC</code></td>
<td>
<p>the list of allowed IUPAC symbols</p>
</td></tr>
<tr><td><code id="amb_+3A_u2t">u2t</code></td>
<td>
<p>if TRUE &quot;u&quot; for uracil in RNA are changed into &quot;t&quot; for thymine in DNA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non ambiguous bases are returned unchanged (except for &quot;u&quot; when u2t is TRUE).
</p>


<h3>Value</h3>

<p>When base is missing, the list of IUPAC symbols is returned, otherwise
a vector with expanded symbols.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p>The nomenclature for incompletely specified bases in nucleic acid sequences
at: <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC341218/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC341218/</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+bma">bma</a></code> for the reverse operation. 
Use <code><a href="base.html#topic+tolower">tolower</a></code> to change upper case letters into
lower case letters.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The list of IUPAC symbols:
#

amb()

#
# And their expansion:
#

sapply(amb(), amb)

</code></pre>

<hr>
<h2 id='AnoukResult'>Expected numeric results for Ka and Ks computation</h2><span id='topic+AnoukResult'></span>

<h3>Description</h3>

<p>This data set is what should be obtained when runing <code>kaks()</code>
on the test file Anouk.fasta in the sequences directory of the
seqinR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AnoukResult)</code></pre>


<h3>Format</h3>

<p>A list with 4 components of class dist.
</p>

<dl>
<dt>ka</dt><dd><p>Ka</p>
</dd>
<dt>ks</dt><dd><p>Ks</p>
</dd>
<dt>vka</dt><dd><p>variance for Ka</p>
</dd>
<dt>vks</dt><dd><p>variance for Ks</p>
</dd>
</dl>



<h3>Details</h3>

<p>See the example in <code><a href="#topic+kaks">kaks</a></code>.
</p>


<h3>Source</h3>

<p>The fasta test file was provided by Anamaria Necşulea.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>

<hr>
<h2 id='as.alignment'>Constructor for class alignment</h2><span id='topic+as.alignment'></span>

<h3>Description</h3>

<p>Returns an object of (S3) class alignment. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.alignment(nb = NULL, nam = NULL, seq = NULL, com = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.alignment_+3A_nb">nb</code></td>
<td>
<p>integer. The number of sequences in the alignment.</p>
</td></tr>
<tr><td><code id="as.alignment_+3A_nam">nam</code></td>
<td>
<p>vector of <code>nb</code> character strings. The sequence names. </p>
</td></tr>
<tr><td><code id="as.alignment_+3A_seq">seq</code></td>
<td>
<p>vector of <code>nb</code> character strings. The aligned sequences.</p>
</td></tr>
<tr><td><code id="as.alignment_+3A_com">com</code></td>
<td>
<p>vector of <code>nb</code> character strings. The comments about sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>alignment</code> which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>nb</code></td>
<td>
<p> the number of aligned sequences </p>
</td></tr>
<tr><td><code>nam</code></td>
<td>
<p> a vector of strings containing the names of the aligned sequences </p>
</td></tr> 
<tr><td><code>seq</code></td>
<td>
<p> a vector of strings containing the aligned sequences</p>
</td></tr> 
<tr><td><code>com</code></td>
<td>
<p> a vector of strings containing the commentaries for each sequence or <code>NA</code> if there are no comments </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.alignment">read.alignment</a></code>,
<code><a href="#topic+as.matrix.alignment">as.matrix.alignment</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>, 
<code><a href="#topic+write.fasta">write.fasta</a></code>, <code><a href="#topic+reverse.align">reverse.align</a></code>, <code><a href="#topic+dist.alignment">dist.alignment</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.alignment(nb = 2, nam = c("one", "two"), 
  seq = c("-ACGT", "GACG-"), com = c("un", "deux"))
</code></pre>

<hr>
<h2 id='as.matrix.alignment'>as.matrix.alignment</h2><span id='topic+as.matrix.alignment'></span>

<h3>Description</h3>

<p>Converts an alignment into a matrix of characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alignment'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.alignment_+3A_x">x</code></td>
<td>
<p> an object of the class alignment.</p>
</td></tr>
<tr><td><code id="as.matrix.alignment_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of characters.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.alignment">read.alignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  phylip &lt;- read.alignment(file = system.file("sequences/test.phylip",
   package = "seqinr"), format = "phylip")
  as.matrix(phylip)
</code></pre>

<hr>
<h2 id='autosocket'>Returns a socket to the last opened database</h2><span id='topic+autosocket'></span>

<h3>Description</h3>

<p>This is a low level function that is mainly used to select automatically
the last opened ACNUC database for functions using sockets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autosocket()
</code></pre>


<h3>Value</h3>

<p>An object of class sockconn.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="base.html#topic+connections">connections</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  #Need internet connection
  choosebank("emblTP")
  autosocket()
  closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='baselineabif'>Estimation of baseline value</h2><span id='topic+baselineabif'></span>

<h3>Description</h3>

<p>This function tries to estimate the baseline value for RFU data from
capillary electrophoresis whith the heuristic that the most common
value is the baseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baselineabif(rfu, maxrfu = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baselineabif_+3A_rfu">rfu</code></td>
<td>
<p>a numeric vector of signal value</p>
</td></tr>
<tr><td><code id="baselineabif_+3A_maxrfu">maxrfu</code></td>
<td>
<p>signal values greater or equal to maxrfu are forced to NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value for the estimated baseline.</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>See Also</h3>

<p><code><a href="#topic+JLO">JLO</a></code> for a dataset example, <code><a href="#topic+plotabif">plotabif</a></code> to plot this kind of data, 
<code><a href="#topic+peakabif">peakabif</a></code> to estimate peak parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JLO)
rfu &lt;- JLO$Data$DATA.1
bl &lt;- baselineabif(rfu)
plot(1:length(rfu), rfu, type = "l", 
  xlab = "Time [datapoint units]",
  ylab = "Signal [RFU]",
  main = "Example of baseline estimates")
abline(h = bl, col="red", lty = 2)
legend("topright", inset = 0.02, "Baseline estimate", lty = 2, col = "red")
</code></pre>

<hr>
<h2 id='bma'>Computing an IUPAC nucleotide symbol</h2><span id='topic+bma'></span>

<h3>Description</h3>

<p>This function returns the IUPAC symbol for a nucleotide sequence, for instance
<code>c("c", "c", "g")</code> is coded by <code>"s"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bma(nucl, warn.non.IUPAC = TRUE, type = c("DNA", "RNA"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bma_+3A_nucl">nucl</code></td>
<td>
<p>a nucleotide sequence as a vector of single chars</p>
</td></tr>
<tr><td><code id="bma_+3A_warn.non.iupac">warn.non.IUPAC</code></td>
<td>
<p>if TRUE warns when no IUPAC symbol is possible</p>
</td></tr>
<tr><td><code id="bma_+3A_type">type</code></td>
<td>
<p>whether this is a DNA or a RNA sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence is forced in lower case letters and ambiguous bases
are expanded before trying to find an IUPAC symbol.
</p>


<h3>Value</h3>

<p>A single IUPAC symbol in lower case, or NA when this is not possible.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p>The nomenclature for incompletely specified bases in nucleic acid sequences
at: <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC341218/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC341218/</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+amb">amb</a></code> for the reverse operation. 
Use <code><a href="base.html#topic+toupper">toupper</a></code> to change lower case letters into
upper case letters.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
stopifnot(bma(s2c("atatattttata")) == "w")
stopifnot(bma(s2c("gcggcgcgcggc")) == "s")
stopifnot(bma(s2c("ACGT")) == "n")
stopifnot(is.na(bma(s2c("atatttt---tatat")))) # a warning is issued
</code></pre>

<hr>
<h2 id='c2s'> conversion of a vector of chars into a string </h2><span id='topic+c2s'></span>

<h3>Description</h3>

<p>This is a simple utility function to convert a vector of chars
such as c(&quot;m&quot;, &quot;e&quot;, &quot;r&quot;, &quot;g&quot;, &quot;e&quot;, &quot;d&quot;) into a single string such
as &quot;merged&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2s(chars = c("m", "e", "r", "g", "e", "d"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c2s_+3A_chars">chars</code></td>
<td>
<p> a vector of chars </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+s2c">s2c</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>c2s( c("m","e","r","g","e","d") )
</code></pre>

<hr>
<h2 id='cai'>Codon Adaptation Index</h2><span id='topic+cai'></span>

<h3>Description</h3>

<p>The Codon Adaptation Index (Sharp and Li 1987) is the most popular
index of gene expressivity with about 1000 citations 20 years after its
publication. Its values range from 0 (low) to 1 (high). The implementation
here is intended to work exactly as in the program <code>codonW</code> written by
by John Peden during his PhD thesis under the supervision of P.M. Sharp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cai(seq, w, numcode = 1, zero.threshold = 0.0001, zero.to = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cai_+3A_seq">seq</code></td>
<td>
<p>a coding sequence as a vector of single characters</p>
</td></tr>
<tr><td><code id="cai_+3A_w">w</code></td>
<td>
<p>a vector for the relative adaptiveness of each codon</p>
</td></tr>
<tr><td><code id="cai_+3A_numcode">numcode</code></td>
<td>
<p>the genetic code number as in <code><a href="#topic+translate">translate</a></code></p>
</td></tr>
<tr><td><code id="cai_+3A_zero.threshold">zero.threshold</code></td>
<td>
<p>a value in <code>w</code> below this threshold is
considered as zero</p>
</td></tr>
<tr><td><code id="cai_+3A_zero.to">zero.to</code></td>
<td>
<p>a value considered as zero in <code>w</code> is forced to
this value. The default is from Bulmer (1988).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adapted from the documentation of the CAI function in the
program <code>codonW</code> writen by John Peden:
CAI is a measurement
of the relative adaptiveness of the codon usage of a gene towards the
codon usage of highly expressed genes. The relative adaptiveness (w) of
each codon is the ratio of the usage of each codon, to that of the most
abundant codon for the same amino acid. The CAI
index is defined as the geometric mean of these relative adaptiveness
values. Non-synonymous codons and termination codons (genetic code
dependent) are excluded. To aid computation, the CAI is calculated as
using a natural log summation, To prevent a codon having a relative
adaptiveness value of zero, which could result in a CAI of zero;
these codons have fitness of zero (&lt;.0001) are adjusted to 0.01.
</p>


<h3>Value</h3>

<p>A single numerical value for the CAI.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p>Sharp, P.M., Li, W.-H. (1987) The codon adaptation index - a
measure of directional synonymous codon usage bias, and its
potential applications.
<em>Nucleic Acids Research</em>, <b>15</b>:1281-1295.
</p>
<p>Bulmer, M. (1988).
Are codon usage patterns in unicellular organisms determined by
selection-mutation balance.
<em>Journal of Evolutionary Biology</em>, <b>1</b>:15-26.
</p>
<p>Peden, J.F. (1999)
Analysis of codon usage.
PhD Thesis, University of Nottingham, UK.
</p>
<p>The program <code>codonW</code> used here for comparison is available at
<a href="https://codonw.sourceforge.net/">https://codonw.sourceforge.net/</a> under a GPL licence.
</p>
<p><code>citation("seqinr")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caitab">caitab</a></code> for some <code>w</code> values from <code>codonW</code>.
<code><a href="#topic+uco">uco</a></code> for codon usage tabulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# How to reproduce the results obtained with the C program codonW
# version 1.4.4 writen by John Peden. We use here the "input.dat"
# test file from codonW (Saccharomyces cerevisiae).
#
  inputdatfile &lt;- system.file("sequences/input.dat", package = "seqinr")
  input &lt;- read.fasta(file = inputdatfile) # read the FASTA file
#
# Import results obtained with codonW
#
  scucofile &lt;- system.file("sequences/scuco.txt", package = "seqinr")
  scuco.res &lt;- read.table(scucofile, header = TRUE) # read codonW result file
#
# Use w for Saccharomyces cerevisiae
#
  data(caitab)
  w &lt;- caitab$sc
#
# Compute CAI and compare results:
#
  cai.res &lt;- sapply(input, cai, w = w)
  plot(cai.res, scuco.res$CAI,
    main = "Comparison of seqinR and codonW results",
    xlab = "CAI from seqinR",
    ylab = "CAI from codonW",
    las = 1)
  abline(c(0,1))
</code></pre>

<hr>
<h2 id='caitab'>Codon Adaptation Index (CAI) w tables</h2><span id='topic+caitab'></span>

<h3>Description</h3>

<p>Information about a preferred set of codons for highly expressed genes
in three species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(caitab)</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows for the codons and the following 3 columns:
</p>

<dl>
<dt>ec</dt><dd><p><em>Escherichia coli</em></p>
</dd>
<dt>bs</dt><dd><p><em>Bacillus subtilis</em></p>
</dd>
<dt>sc</dt><dd><p><em>Saccharomyces cerevisiae</em></p>
</dd>
</dl>



<h3>Details</h3>

<p>Codons are given by <code>row.names(caitab)</code>.
</p>


<h3>Source</h3>

<p>The data were hard-encoded in
the C program codonW version 1.4.4 writen by John Peden
available at <a href="https://codonw.sourceforge.net/">https://codonw.sourceforge.net/</a>. The data
are from the file <code>codonW.h</code>.
According to this source file, there were no reference for
<em>Escherichia coli</em> and <em>Bacillus subtilis</em> and the
reference for <em>Saccharomyces cerevisiae</em> was Sharp
and Cowe (1991).
</p>
<p>It turns out that the data for <em>Escherichia coli</em> and
<em>Saccharomyces cerevisiae</em> are identical to table 1
in Sharp and Li (1987) where the missing values for the stop
codons are represented here by zeros. All codons were documented
by at least one count in both datasets.
</p>
<p>The data for <em>Bacillus subtilis</em> are from table 2 in Shields
and Sharp (1987). Missing values for stops codons are represented
as previously by zeros, missing values for single-box amino-acids
are represented by 1 here. Note that some codons were undocumented
in this dataset and that a 0.5 value in absolute frequencies was
already forced to avoid zeros. It is therefore impossible to use
directly these data to obtain the exact expected CAI values as documented
in <code><a href="#topic+cai">cai</a></code> because of overlapping with documented codons.
</p>


<h3>References</h3>

<p>Sharp, P.M., Li, W.-H. (1987) The codon adaptation index - a
measure of directional synonymous codon usage bias, and its
potential applications.
<em>Nucleic Acids Research</em>, <b>15</b>:1281-1295.
</p>
<p>Shields, D.C., Sharp, P.M. (1987) Synonymous codon usage in <em>Bacillus subtilis</em>
reflects both traditional selection and mutational biases.
<em>Nucleic Acids Research</em>, <b>15</b>:8023-8040.
</p>
<p>Sharp, P. M., Cowe, E. (1991).
Synonymous codon usage in <em>Saccharomyces cerevisiae</em>.
<em>Yeast</em>, <b>7</b>:657-678.
</p>
<p>Peden, J.F. (1999)
Analysis of codon usage.
PhD Thesis, University of Nottingham, UK.
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cai">cai</a></code> for an example using this dataset to compute CAI values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(caitab)
</code></pre>

<hr>
<h2 id='chargaff'>Base composition in ssDNA for 7 bacterial DNA</h2><span id='topic+chargaff'></span>

<h3>Description</h3>

<p>Long before the genomic era, it was possible to get some data
for the global composition of single-stranded DNA chromosomes
by direct chemical analyses. These data are from Chargaff's lab
and give the base composition of the L (Ligth) strand for
7 bacterial chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chargaff)</code></pre>


<h3>Format</h3>

<p>A data frame with 7 observations on the following 4 variables.
</p>

<dl>
<dt>[A]</dt><dd><p>frequencies of A bases in percent</p>
</dd>
<dt>[G]</dt><dd><p>frequencies of G bases in percent</p>
</dd>
<dt>[C]</dt><dd><p>frequencies of C bases in percent</p>
</dd>
<dt>[T]</dt><dd><p>frequencies of T bases in percent</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are from Table 2 in Rudner <em>et al.</em> (1969) for the
L-strand. Data for <em>Bacillus subtilis</em> were taken from
a previous paper: Rudner <em>et al.</em> (1968). This is in
fact the average value observed for two different strains
of <em>B. subtilis</em>: strain W23 and strain Mu8u5u16.<br />
Denaturated chromosomes can be separated by a technique of
intermitent gradient elution from a column of methylated
albumin kieselguhr (MAK), into two fractions, designated,
by virtue of their buoyant densities, as L (light) and H
(heavy). The fractions can be hydrolyzed and subjected to
chromatography to determined their global base composition.<br />
The surprising result is that we have almost exactly A=T
and C=G in single stranded-DNAs. The second paragraph page
157 in Rudner <em>et al.</em> (1969) says: &quot;Our previous
work on the complementary strands of <em>B. subtilis</em> DNA
suggested an additional, entirely unexpected regularity,
namely, the equality in either strand of 6-amino and 6-keto
nucleotides ( A + C = G + T). This relationship, which
would normally have been regarded merely as the consequence
of base-pairing in DNA duplex and would not have been predicted
as a likely property of a single strand, is shown here to
apply to all strand specimens isolated from denaturated DNA
of the AT type (Table 2, preps. 1-4). It cannot yet be said
to be established for the DNA specimens from the equimolar
and GC types (nos. 5-7).&quot;
</p>
<p>Try <code>example(chargaff)</code> to mimic figure page 17 in Lobry
(2000) :
</p>
<p><img src="../help/figures/chargaff.png" width=400 alt="chargaff.png" />

</p>
<p>Note that <code>example(chargaff)</code> gives more details:
the red areas correspond to non-allowed values beause the sum
of the four bases frequencies cannot exceed 100%.
The white areas correspond to possible values (more exactly
to the projection from <code>R^4</code> to the corresponding <code>R^2</code> planes
of the region of allowed values).
The blue lines correspond to the very small subset of allowed
values for which we have in addition PR2 state, that is
<code>[A]=[T]</code> and <code>[C]=[G]</code>. Remember, these data are for ssDNA!
</p>


<h3>Source</h3>

<p>Rudner, R., Karkas, J.D., Chargaff, E. (1968) Separation of
<em>B. subtilis</em> DNA into complementary strands, III. Direct
Analysis. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, <b>60</b>:921-922.<br />
Rudner, R., Karkas, J.D., Chargaff, E. (1969) Separation of microbial deoxyribonucleic acids into complementary strands. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, <b>63</b>:152-159.<br />
</p>


<h3>References</h3>

<p>Lobry, J.R. (2000) The black hole of symmetric molecular evolution. Habilitation thesis, Université Claude Bernard - Lyon 1. <a href="https://pbil.univ-lyon1.fr/members/lobry/articles/HDR.pdf">https://pbil.univ-lyon1.fr/members/lobry/articles/HDR.pdf</a>.
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chargaff)
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(4,4), mai = rep(0,4), xaxs = "i", yaxs = "i")
xlim &lt;- ylim &lt;- c(0, 100)

for( i in 1:4 )
{
  for( j in 1:4 )
  {
    if( i == j )
    {
      plot(chargaff[,i], chargaff[,j],t = "n", xlim = xlim, ylim = ylim,
      xlab = "", ylab = "", xaxt = "n", yaxt = "n")
      polygon(x = c(0, 0, 100, 100), y = c(0, 100, 100, 0), col = "lightgrey")
      for( k in seq(from = 0, to = 100, by = 10) )
      {
        lseg &lt;- 3
        segments(k, 0, k, lseg)
        segments(k, 100 - lseg, k, 100)
        segments(0, k, lseg, k)
        segments(100 - lseg, k, 100, k)
      }
      string &lt;- paste(names(chargaff)[i],"\n\n",xlim[1],"% -",xlim[2],"%")
      text(x=mean(xlim),y=mean(ylim), string, cex = 1.5)
    }
    else
    {
      plot(chargaff[,i], chargaff[,j], pch = 1, xlim = xlim, ylim = ylim,
      xlab = "", ylab = "", xaxt = "n", yaxt = "n", cex = 2)
      iname &lt;- names(chargaff)[i]
      jname &lt;- names(chargaff)[j]
      direct &lt;- function() segments(0, 0, 50, 50, col="blue")
      invers &lt;- function() segments(0, 50, 50, 0, col="blue")
      PR2 &lt;- function()
      {
        if( iname == "[A]" &amp; jname == "[T]" ) { direct(); return() }
        if( iname == "[T]" &amp; jname == "[A]" ) { direct(); return() }
        if( iname == "[C]" &amp; jname == "[G]" ) { direct(); return() }
        if( iname == "[G]" &amp; jname == "[C]" ) { direct(); return() }
        invers()
      }
      PR2()
      polygon(x = c(0, 100, 100), y = c(100, 100, 0), col = "pink4")
      polygon(x = c(0, 0, 100), y = c(0, 100, 0))
    }
  }
}
# Clean up
par(op)
</code></pre>

<hr>
<h2 id='choosebank'>To select a database structured under ACNUC and located on the web</h2><span id='topic+choosebank'></span><span id='topic+.seqinrEnv'></span>

<h3>Description</h3>

<p>This function allows to select one of the databases structured under ACNUC and located on the web.
Called without arguments, <code>choosebank()</code>, will return the list of available databases.
Then, you can use <code><a href="#topic+query">query</a></code> to make your query and get a list of sequence names.
Remote access to ACNUC databases works by opening a socket connection on a port (for example
on port number 5558 at pbil.univ-lyon1.fr) and by communicating on this socket following the protocol
described in the section <code>references</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choosebank(bank = NA, host = "pbil.univ-lyon1.fr", port = 5558, server = FALSE,
                    blocking = TRUE, open = "a+", encoding = "", verbose = FALSE,
                    timeout = 5, infobank = FALSE, tagbank = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choosebank_+3A_bank">bank</code></td>
<td>
<p>string. The name of the bank. If NA, <code>choosebank</code> will return the names of all database known by the server.</p>
</td></tr>
<tr><td><code id="choosebank_+3A_host">host</code></td>
<td>
<p>string. Host name for port (see <code><a href="base.html#topic+socketConnection">socketConnection</a></code>)</p>
</td></tr>
<tr><td><code id="choosebank_+3A_port">port</code></td>
<td>
<p>integer. The TCP port number (see <code><a href="base.html#topic+socketConnection">socketConnection</a></code>)</p>
</td></tr>
<tr><td><code id="choosebank_+3A_server">server</code></td>
<td>
<p>logical. Should the socket be a client or a server? (see <code><a href="base.html#topic+socketConnection">socketConnection</a></code>)</p>
</td></tr>
<tr><td><code id="choosebank_+3A_blocking">blocking</code></td>
<td>
<p>logical. (see <code><a href="base.html#topic+socketConnection">socketConnection</a></code>)</p>
</td></tr>
<tr><td><code id="choosebank_+3A_open">open</code></td>
<td>
<p>string. A description of how to open the connection (see <code><a href="base.html#topic+socketConnection">socketConnection</a></code>)</p>
</td></tr>
<tr><td><code id="choosebank_+3A_encoding">encoding</code></td>
<td>
<p>string. The name of the encoding to be used. (see <code><a href="base.html#topic+socketConnection">socketConnection</a></code>)</p>
</td></tr>
<tr><td><code id="choosebank_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE, verbose mode is on</p>
</td></tr>
<tr><td><code id="choosebank_+3A_timeout">timeout</code></td>
<td>
<p>integer. The timeout in seconds for <code>socketConnection</code>. Default 5 seconds.</p>
</td></tr>
<tr><td><code id="choosebank_+3A_infobank">infobank</code></td>
<td>
<p>logical. If <code>infobank</code> is TRUE and <code>bank</code> is <code>NA</code>, a data.frame
with all database informations will be returned</p>
</td></tr>
<tr><td><code id="choosebank_+3A_tagbank">tagbank</code></td>
<td>
<p>string. If <code>bank</code> is <code>NA</code> and <code>tagbank</code> is documented, the names
of special purposes databases are returned. Current allowed values are TP
for frozen databases (TP is an acronym for &quot;travaux pratiques&quot; which means practicals
in french, these databases are useful mainly for teaching so as to have stable results),
TEST for test databases, and DEV for databases under development (unstable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called without arguments, <code>choosebank()</code> returns a list of all the databases names known
by the server, as a vector of string. When called with <code>choosebank(infobank = TRUE)</code>, a data.frame
with more information is returned.The environment <code>.seqinrEnv</code> is used to save several variables
such as socket and sequence list.
</p>


<h3>Value</h3>

<p>When called with a regular bank name, an (invisible) list with 6 components:
</p>
<table role = "presentation">
<tr><td><code>socket</code></td>
<td>
<p> an object of class <code>socket</code> </p>
</td></tr>
<tr><td><code>bankname</code></td>
<td>
<p> the name of the bank </p>
</td></tr>
<tr><td><code>banktype</code></td>
<td>
<p> the type of the bank (GENBANK, EMBL, SWISSPROT, NBRF)</p>
</td></tr>
<tr><td><code>totseqs</code></td>
<td>
<p> the total number of sequences present in the opened database </p>
</td></tr>
<tr><td><code>totspecs</code></td>
<td>
<p> the total number of species present in the opened database </p>
</td></tr>
<tr><td><code>totkeys</code></td>
<td>
<p> the total number of keywords present in the opened database </p>
</td></tr>
</table>
<p>When called with bank = NA:
</p>
<table role = "presentation">
<tr><td><code>names</code></td>
<td>
<p> A vector of all available bank names.</p>
</td></tr>
</table>
<p>When called with bank = NA and infobank = TRUE, a data.frame with three columns:
</p>
<table role = "presentation">
<tr><td><code>bank</code></td>
<td>
<p> The name of the bank. </p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p> The bank status (on/of). </p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p> Short description of bank with last release date. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The invisible list returned when a database is opened is stored in the variable
<code>banknameSocket</code> in the global environment.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p>For more information about the socket communication protocol with ACNUC please get at <a href="https://doua.prabi.fr/databases/acnuc/remote_acnuc.html">https://doua.prabi.fr/databases/acnuc/remote_acnuc.html</a>.<br />
Gouy, M., Milleret, F., Mugnier, C., Jacobzone, M., Gautier,C. (1984) ACNUC: a nucleic acid sequence data base and analysis system.
<em>Nucl. Acids Res.</em>, <b>12</b>:121-127.<br />
Gouy, M., Gautier, C., Attimonelli, M., Lanave, C., Di Paola, G. (1985)
ACNUC - a portable retrieval system for nucleic acid sequence databases:
logical and physical designs and usage.
<em>Comput. Appl. Biosci.</em>, <b>3</b>:167-172.<br />
Gouy, M., Gautier, C., Milleret, F. (1985) System analysis and nucleic acid sequence banks.
<em>Biochimie</em>, <b>67</b>:433-436.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+where.is.this.acc">where.is.this.acc</a></code> if you have a sequence accession number but you
don't know which database to open, <code><a href="#topic+query">query</a></code> to make a query when a database
is opened, <code><a href="base.html#topic+connection">connection</a></code>, <code><a href="base.html#topic+socketConnection">socketConnection</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: # Need internet connection
  # Show available databases:
  choosebank()
  # Show frozen databases:
  choosebank(tag = "TP")
  # Select a database:
  choosebank("emblTP", tag = "TP")
  # Do something with the database:
  myseq &lt;- gfrag("LMFLCHR36", start = 1, length = 30)
  stopifnot(myseq == "cgcgtgctggcggcaatgaagcgttcgatg")
  # Close the database:
  closebank()
## End(Not run)
</code></pre>

<hr>
<h2 id='circle'>Draws a circle</h2><span id='topic+circle'></span>

<h3>Description</h3>

<p>Draws a circle or an arc-circle on the current graphic device</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle(x = 0, y = 0, r = 1, theta = c(0, 360), n = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_+3A_x">x</code></td>
<td>
<p>x coordinate for the center of the circle</p>
</td></tr>
<tr><td><code id="circle_+3A_y">y</code></td>
<td>
<p>y coordinate for the center of the circle</p>
</td></tr>
<tr><td><code id="circle_+3A_r">r</code></td>
<td>
<p>radius of the circle</p>
</td></tr>
<tr><td><code id="circle_+3A_theta">theta</code></td>
<td>
<p>start and stop angle</p>
</td></tr>
<tr><td><code id="circle_+3A_n">n</code></td>
<td>
<p>number of points for polygon object</p>
</td></tr>
<tr><td><code id="circle_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>none</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+polygon">polygon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(2, 2), mar = c(0,0,2,0))
setup &lt;- function(){
  plot.new()
  plot.window(xlim = c(-1,1), ylim = c(-1,1), asp = 1)
}

setup()
circle(col = "lightblue")
title(main = "theta = c(0, 360)")

setup()
circle(col = "lightblue", theta = c(0, 270))
title(main = "theta = c(0, 270)")

setup()
circle(col = "lightblue", theta = c(-90, 180))
title(main = "theta = c(-90, 180)")

setup()
n &lt;- 20
for(i in seq(0, 360, length = n)){
  circle(col = "lightblue", theta = c(i, i+360/(2*n)))
}
title(main = "many thetas")
</code></pre>

<hr>
<h2 id='closebank'> To close a remote ACNUC database </h2><span id='topic+closebank'></span>

<h3>Description</h3>

<p>This function tries to close a remote ACNUC database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closebank(socket = autosocket(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closebank_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="closebank_+3A_verbose">verbose</code></td>
<td>
<p> Logical. If TRUE, verbose mode is on </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry </p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+choosebank">choosebank</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: # Need internet connection
   choosebank("emblTP")
   closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='clustal'>Example of results obtained after a call to read.alignment</h2><span id='topic+clustal'></span>

<h3>Description</h3>

<p>This data set gives an example of a protein alignment obtained after a call to the function read.alignment on an alignment file in &quot;clustal&quot; format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(clustal)</code></pre>


<h3>Format</h3>

<p>A List of class alignment</p>


<h3>Source</h3>

<p>http://www.clustal.org/</p>


<h3>References</h3>

<p>Thompson, J.D., Higgins D.G., Gibson T.J. (1994) <em>CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position specific gap penalties and weight matrix choice</em>.
Nucleic Acids Res. 22(22):4673-80.
</p>

<hr>
<h2 id='col2alpha'>To use a standard color with an alpha transparency chanel</h2><span id='topic+col2alpha'></span>

<h3>Description</h3>

<p>Takes as input a standard R color and an alpha value to return
its rgb coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2alpha(color, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col2alpha_+3A_color">color</code></td>
<td>
<p>A standard R color as in <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="col2alpha_+3A_alpha">alpha</code></td>
<td>
<p>An alpha transparency value in the interval [0,1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same as in <code><a href="grDevices.html#topic+rgb">rgb</a></code>.</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Need alpha transparency channel 
#
par(mar = c(0, 0, 2, 2)+0.1, oma = c(0, 0, 2, 0), mfrow = c(3,2))
for(testcol in c("blue", "red", "green", "yellow", "purple", "darkgreen")){
  plot(0,0, type="n", xlim=0:1, ylim = 0:1, axes = FALSE, xlab = "", ylab = "", main = testcol)
  n &lt;- 11
  for(i in seq(0, 1, length = n)){
    col &lt;- col2alpha(testcol, i)
    rect(i, 0, i + 1/n, 1, col = col, border = "black", xpd = NA)
    text(i+0.5/n, 0.5, round(i,2), xpd = NA)
  }
}
mtext("Effect of alpha on some colors\nNote: need alpha transparency channel",
 side = 3, outer = TRUE)
#
# The substractive color scheme:
#
par(mar = c(0,0,3,0))
plot.new()
plot.window(xlim = c(-1.5, 1.5), ylim = c(-1,1.75), asp = 1)
n &lt;- 10
alpha &lt;- 1/n
for(i in 1:(2*n)){
  circle(x = -0.5, y = 0, col = col2alpha("yellow", alpha))
  circle(x = 0.5, y = 0, col = col2alpha("cyan", alpha))
  circle(x = 0, y = 3/4, col = col2alpha("magenta", alpha))
}
title("Substractive color scheme\nNote: need alpha transparency channel")
</code></pre>

<hr>
<h2 id='comp'> complements a nucleic acid sequence </h2><span id='topic+comp'></span>

<h3>Description</h3>

<p>Complements a sequence, for instance if the sequence is 
<code>"a","c","g","t"</code> it returns <code>"t","g","c","a"</code>. 
This is not the reverse complementary strand. This function
can handle ambiguous bases if required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp(seq, forceToLower = TRUE, ambiguous = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_+3A_seq">seq</code></td>
<td>
<p> a DNA sequence as a vector of single chars </p>
</td></tr>
<tr><td><code id="comp_+3A_forcetolower">forceToLower</code></td>
<td>
<p> if TRUE characters in <code>seq</code> are forced to lower case</p>
</td></tr>
<tr><td><code id="comp_+3A_ambiguous">ambiguous</code></td>
<td>
<p> if TRUE ambiguous bases in <code>seq</code> are handled</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector of characters which is the complement of the sequence,
not the reverse complementary strand. Undefined values are
returned as NA.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p> Because ssDNA sequences are always written in the 5'-&gt;3'
direction, use rev(comp(seq)) to get the reverse complementary
strand (see <code><a href="base.html#topic+rev">rev</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Show that comp() does *not* return the reverve complementary strand:
##

c2s(comp(s2c("aaaattttggggcccc")))

##
## Show how to get the reverse complementary strand:
##

c2s(rev(comp(s2c("aaaattttggggcccc"))))

##
## Show what happens with non allowed values:
##

c2s(rev(comp(s2c("aaaaXttttYggggZcccc"))))

##
## Show what happens with ambiguous bases:
##

allbases &lt;- s2c("abcdghkmstvwn")
comp(allbases) # NA are produced
comp(allbases, ambiguous = TRUE) # No more NA

##
## Routine sanity checks:
##

stopifnot(identical(comp(allbases, ambiguous = TRUE), s2c("tvghcdmksabwn")))
stopifnot(identical(comp(c("A", "C", "G", "T"), forceToLower = FALSE), c("T", "G", "C", "A")))
</code></pre>

<hr>
<h2 id='computePI'>To Compute the Theoretical Isoelectric Point</h2><span id='topic+computePI'></span>

<h3>Description</h3>

<p>This function calculates the theoretical isoelectric point of a protein. Isoelectric point is the pH at which the protein has a neutral charge.
This estimate does not account for the post-translational modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePI(seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computePI_+3A_seq">seq</code></td>
<td>
<p> Protein sequence as a vector of single chars in upper case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The theoretical isoelectric point (pI) as a numerical vector of length one.
</p>


<h3>Note</h3>

 
<p>Protein pI is calculated using pK values of amino acids described in  Bjellqvist et al. See also <code>SEQINR.UTIL</code> for more details.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

 
<p>The algorithm is the same as the one which is implemented at the following url:  
<a href="https://web.expasy.org/compute_pi/pi_tool-doc.html">https://web.expasy.org/compute_pi/pi_tool-doc.html</a> but with many trials
in case of convergence failure of the non-linear regression procedure.
<code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SEQINR.UTIL">SEQINR.UTIL</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Simple sanity check with all 20 amino-acids in one-letter code alphabetical order:
#
prot &lt;- s2c("ACDEFGHIKLMNPQRSTVWY")
stopifnot(all.equal(computePI(prot), 6.78454))
#
# Read a protein sequence in a FASTA file and then compute its pI :
#
myProts &lt;- read.fasta(file = system.file("sequences/seqAA.fasta",
 package = "seqinr"), seqtype = "AA")
computePI(myProts[[1]]) # Should be 8.534902
</code></pre>

<hr>
<h2 id='consensus'>Consensus and profiles for sequence alignments</h2><span id='topic+consensus'></span><span id='topic+con'></span>

<h3>Description</h3>

<p>This function returns a consensus using variuous methods (see details)
or a profile from a sequence alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus(matali, method = c( "majority", "threshold", "IUPAC", "profile"), 
  threshold = 0.60, warn.non.IUPAC = FALSE, type = c("DNA", "RNA"))
con(matali, method = c( "majority", "threshold", "IUPAC", "profile"), 
  threshold = 0.60, warn.non.IUPAC = FALSE, type = c("DNA", "RNA"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensus_+3A_matali">matali</code></td>
<td>
<p>an object of class <code>alignment</code> as returned by 
<code><a href="#topic+read.alignment">read.alignment</a></code>, or a matrix of characters.</p>
</td></tr>
<tr><td><code id="consensus_+3A_method">method</code></td>
<td>
<p>select the method to use, see details.</p>
</td></tr>
<tr><td><code id="consensus_+3A_threshold">threshold</code></td>
<td>
<p>for the <code>threshold</code> method, a numeric value beteen 0 and 1
indicating the minimum relative frequency for a character to be returned
as the consensus character. If none, NA is returned.</p>
</td></tr>
<tr><td><code id="consensus_+3A_warn.non.iupac">warn.non.IUPAC</code></td>
<td>
<p>for the <code>IUPAC</code> method this argument is passed 
to <code><a href="#topic+bma">bma</a></code> with a default value set to FALSE to avoid warnings due 
to gap characters in the alignment.</p>
</td></tr>
<tr><td><code id="consensus_+3A_type">type</code></td>
<td>
<p>for the <code>IUPAC</code> method this argument is passed 
to <code><a href="#topic+bma">bma</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>&quot;majority&quot;</dt><dd><p>The character with the higher frequency is returned as the
consensus character.</p>
</dd>
<dt>&quot;threshold&quot;</dt><dd><p>As above but in addition the character relative frequency
must be higher than the value controled by the <code>threshold</code> argument.
If none, NA id returned.</p>
</dd>
<dt>&quot;IUPAC&quot;</dt><dd><p>Make sense only for nucleic acid sequences (DNA or RNA).
The consensus character is defined if possible by an IUPAC symbol by
function <code><a href="#topic+bma">bma</a></code>. If this is not possible, when there is a gap
character for instance, NA is returned.</p>
</dd>
<dt>&quot;profile&quot;</dt><dd><p>With this method a matrix with the count of each possible
character at each position is returned.</p>
</dd>
</dl>

<p><code>con</code> is a short form for <code>consensus</code>.
</p>


<h3>Value</h3>

<p>Either a vector of single characters with possible NA or a matrix with
the method <code>profile</code>.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+read.alignment">read.alignment</a></code> to import alignment from files.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Read 5 aligned DNA sequences at 42 sites:
#
  phylip &lt;- read.alignment(file = system.file("sequences/test.phylip", 
    package = "seqinr"), format = "phylip")
#
# Show data in a matrix form:
#
  (matali &lt;- as.matrix(phylip))
#
# With the majority rule:
#
  res &lt;- consensus(phylip)
  stopifnot(c2s(res) == "aaaccctggccgttcagggtaaaccgtggccgggcagggtat")
#
# With a threshold:
#
  res.thr &lt;- consensus(phylip, method = "threshold")
  res.thr[is.na(res.thr)] &lt;- "." # change NA into dots
# stopifnot(c2s(res.thr) == "aa.c..t.gc.gtt..g..t.a.cc..ggccg.......ta.")
  stopifnot(c2s(res.thr) == "aa.cc.tggccgttcagggtaaacc.tggccgg.cagggtat")
#
# With an IUPAC summary:
#
  res.iup &lt;- consensus(phylip, method = "IUPAC")
  stopifnot(c2s(res.iup) == "amvsbnkkgcmkkkmmgsktrmrssndkgcmrkdmmvskyaw")
  # replace 3 and 4-fold symbols by dots:
  res.iup[match(res.iup, s2c("bdhvn"), nomatch = 0) &gt; 0] &lt;- "."
  stopifnot(c2s(res.iup) == "am.s..kkgcmkkkmmgsktrmrss..kgcmrk.mm.skyaw")
#
# With a profile method:
#
  (res &lt;- consensus(phylip, method = "profile"))
#
# Show the connection between the profile and some consensus:
#
  bxc &lt;- barplot(res, col = c("green", "blue", "orange", "white", "red"), border = NA,
  space = 0, las = 2, ylab = "Base count",
  main = "Profile of a DNA sequence alignment",
  xlab = "sequence position", xaxs = "i")
  
  text(x = bxc, y = par("usr")[4],lab = res.thr, pos = 3, xpd = NA)
  text(x = bxc, y = par("usr")[1],lab = res.iup, pos = 1, xpd = NA)
</code></pre>

<hr>
<h2 id='count'>Composition of dimer/trimer/etc oligomers</h2><span id='topic+count'></span>

<h3>Description</h3>

<p>Counts the number of times dimer/trimer/etc oligomers occur in a
sequence. Note that the oligomers are overlapping by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(seq, wordsize, start = 0, by = 1,
 freq = FALSE, alphabet = s2c("acgt"), frame = start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_+3A_seq">seq</code></td>
<td>
<p>a vector of single characters.</p>
</td></tr>
<tr><td><code id="count_+3A_wordsize">wordsize</code></td>
<td>
<p>an integer giving the size of word (n-mer) to count.</p>
</td></tr>
<tr><td><code id="count_+3A_start">start</code></td>
<td>
<p>an integer (0, 1, 2,...) giving the starting
position to consider in the sequence. The default value 0 means that
we start at the first nucleotide in the sequence.</p>
</td></tr>
<tr><td><code id="count_+3A_by">by</code></td>
<td>
<p>an integer defaulting to 1 for the window step.</p>
</td></tr>
<tr><td><code id="count_+3A_freq">freq</code></td>
<td>
<p>if TRUE, word relative frequencies (summing to 1) are returned instead of counts</p>
</td></tr>
<tr><td><code id="count_+3A_alphabet">alphabet</code></td>
<td>
<p>a vector of single characters used to build the oligomer set.</p>
</td></tr>
<tr><td><code id="count_+3A_frame">frame</code></td>
<td>
<p>synonymous for start</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>count</code> counts the occurence of all words by moving a window of
length <code>word</code>. The window step is controlled by the argument <code>by</code>. 
<code>start</code> controls the starting position in the sequence for the count.
</p>


<h3>Value</h3>

<p>This function returns a <code><a href="base.html#topic+table">table</a></code> whose <code><a href="base.html#topic+dimnames">dimnames</a></code> are all the possible
oligomers. All oligomers are returned, even if absent from
the sequence.		
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry with suggestions from Gabriel Valiente, Stefanie Hartmann and Christian Gautier</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+table">table</a></code> for the class of the returned objet. See <code><a href="#topic+rho">rho</a></code> and
<code><a href="#topic+zscore">zscore</a></code> for dinucleotide statistics.</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- s2c("acgggtacggtcccatcgaa")
##
## To count dinucleotide occurrences in sequence a:
##
count(a, word = 2)
##
## To count trinucleotide occurrences in sequence a, with start = 2:
##
count(a, word = 3, start = 2)
##
## To count dinucleotide relative frequencies in sequence a:
##
count(a, word = 2, freq = TRUE)
##
## To count dinucleotides in codon positions III-I in a coding sequence:
##
alldinuclIIIpI &lt;- s2c("NNaaNatNttNtgNgtNtcNctNtaNagNggNgcNcgNgaNacNccNcaNN")
resIIIpI &lt;- count(alldinuclIIIpI, word = 2, start = 2, by = 3)
stopifnot(all( resIIIpI == 1))
##
## Simple sanity check:
##
#alldinucl &lt;- "aattgtctaggcgacca"
#stopifnot(all(count(s2c(alldinucl), 2) == 1))
#alldiaa &lt;- "aaxxzxbxvxyxwxtxsxpxfxmxkxlxixhxgxexqxcxdxnxrxazzbzvzyzwztzszpzfzmzkzlzizhzgzezqzczdznz
#rzabbvbybwbtbsbpbfbmbkblbibhbgbebqbcbdbnbrbavvyvwvtvsvpvfvmvkvlvivhvgvevqvcvdvnvrvayywytysypyfymyky
#lyiyhygyeyqycydynyryawwtwswpwfwmwkwlwiwhwgwewqwcwdwnwrwattstptftmtktltithtgtetqtctdtntrtasspsfsmsks
#lsishsgsesqscsdsnsrsappfpmpkplpiphpgpepqpcpdpnprpaffmfkflfifhfgfefqfcfdfnfrfammkmlmimhmgmemqmcmdmnm
#rmakklkikhkgkekqkckdknkrkallilhlglelqlcldlnlrlaiihigieiqicidiniriahhghehqhchdhnhrhaggegqgcgdgngrgae
#eqecedenereaqqcqdqnqrqaccdcncrcaddndrdannrnarra"
#stopifnot(all(count(s2c(alldiaa), 2, alphabet = s2c("arndcqeghilkmfpstwyvbzx")) == 1))
##
## Example with dinucleotide count in the complete Human mitochondrion genome:
##
humanMito &lt;- read.fasta(file = system.file("sequences/humanMito.fasta", package = "seqinr"))
##
## Get the dinucleotide count:
##
dinu &lt;- count(humanMito[[1]], 2)
##
## Put the results in a 4 X 4 array:
##
dinu2 &lt;- dinu
dim(dinu2) &lt;- c(4, 4)
nucl &lt;- s2c("ACGT")
dimnames(dinu2) &lt;- list(paste(nucl, "-3\'", sep = ""), paste("5\'-", nucl, sep = ""))
##
## Show that CpG and GpT dinucleotides are depleted:
##
mosaicplot(t(dinu2), shade = TRUE,
  main = "Dinucleotide XpY frequencies in the Human\nmitochondrion complete genome", 
  xlab = "First nucleotide: Xp", 
  ylab = "Second nucleotide: pY", las = 1, cex = 1)
mtext("Note the depletion in CpG and GpT dinucleotides", side = 1, line = 3)
</code></pre>

<hr>
<h2 id='countfreelists'>The number of free lists available and annotation lines in an ACNUC server</h2><span id='topic+countfreelists'></span><span id='topic+cfl'></span>

<h3>Description</h3>

<p>Returns the number of free lists available list of names of annotation lines in the
opened ACNUC database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countfreelists(socket = autosocket())
cfl(socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countfreelists_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following 2 components:
</p>
<table role = "presentation">
<tr><td><code>free</code></td>
<td>
<p>numeric. The number of free lists</p>
</td></tr>
<tr><td><code>annotlines</code></td>
<td>
<p>vector of strings. Names of annotation lines</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # Need internet connection
  choosebank("emblTP")
  (rescountfreelists &lt;- countfreelists())
  stopifnot(all(rescountfreelists$annotlines ==
   c("ALL", "AC",  "PR",  "DT",  "KW",  "OS",  "OC",
   "OG",  "RN",  "RC",  "RP",  "RX", "RG",  "RA",  "RT",  "RL",  "DR",
   "CC",  "AH",  "AS",  "FH",  "FT",  "CO",  "SQ", "SEQ")))
  closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='countsubseqs'>Number of subsequences in an ACNUC list</h2><span id='topic+countsubseqs'></span><span id='topic+css'></span>

<h3>Description</h3>

<p>Returns the number of subsequences in the ACNUC list of rank <code>lrank</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countsubseqs(lrank, socket = autosocket())
css(lrank, socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countsubseqs_+3A_lrank">lrank</code></td>
<td>
<p>the rank of the ACNUC list to consider.</p>
</td></tr>
<tr><td><code id="countsubseqs_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code>, <code><a href="#topic+glr">glr</a></code> to
get a list rank from its name.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # Need internet connection
  choosebank("emblTP")
  mylist&lt;-query("mylist", "N=@", virtual = TRUE) # select all (seqs + subseqs)
  mylist$nelem   # 14138094 seqs + subseqs
  stopifnot(mylist$nelem == 14138094)
  css(glr("mylist")) # 1604500 subsequences only
  stopifnot(css(glr("mylist")) == 1604500)
  closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='crelistfromclientdata'>To create on server an ACNUC list from data lines sent by client</h2><span id='topic+crelistfromclientdata'></span><span id='topic+clfcd'></span>

<h3>Description</h3>

<p>This function is usefull if you have a local file with sequence names
(sequence ID), or sequence accession numbers, or species names, or
keywords. This allows you to create on the server a list with the
corresponding items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crelistfromclientdata(listname, file, type,
 socket = autosocket(), invisible = TRUE,
 verbose = FALSE, virtual = FALSE)
clfcd(listname, file, type, socket = autosocket(),
 invisible = TRUE, verbose = FALSE, virtual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crelistfromclientdata_+3A_listname">listname</code></td>
<td>
<p>The name of the list as a quoted string of chars</p>
</td></tr>
<tr><td><code id="crelistfromclientdata_+3A_file">file</code></td>
<td>
<p>The local file name</p>
</td></tr>
<tr><td><code id="crelistfromclientdata_+3A_type">type</code></td>
<td>
<p>Could be one of &quot;SQ&quot;, &quot;AC&quot;, &quot;SP&quot;, &quot;KW&quot;, see examples</p>
</td></tr>
<tr><td><code id="crelistfromclientdata_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="crelistfromclientdata_+3A_invisible">invisible</code></td>
<td>
<p>if <code>FALSE</code>, the result is returned visibly.</p>
</td></tr>
<tr><td><code id="crelistfromclientdata_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, verbose mode is on</p>
</td></tr>
<tr><td><code id="crelistfromclientdata_+3A_virtual">virtual</code></td>
<td>
<p>if <code>TRUE</code>, no attempt is made to retrieve the information about
all the elements of the list. In this case, the <code>req</code> component of the list is set to 
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clfcd</code> is a shortcut for <code>crelistfromclientdata</code>.
</p>


<h3>Value</h3>

<p>The result is directly assigned to the object <code>listname</code> in the user workspace.
This is an objet of class <code>qaw</code>, a list with the following 6 components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the original call</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>the ACNUC list name</p>
</td></tr>
<tr><td><code>nelem</code></td>
<td>
<p>the number of elements (for instance sequences) in the ACNUC list</p>
</td></tr>
<tr><td><code>typelist</code></td>
<td>
<p>the type of the elements of the list. Could be SQ for a list of
sequence names, KW for a list of keywords, SP for a list of species names.</p>
</td></tr>
<tr><td><code>req</code></td>
<td>
<p>a list of sequence names that fit the required criteria or <code>NA</code> when
called with parameter <code>virtual</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code>socket</code></td>
<td>
<p>the socket connection that was used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, 
<code><a href="#topic+query">query</a></code>, <code><a href="#topic+savelist">savelist</a></code> for the reverse operation with
an ACNUC list of sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run:  # Need internet connection
 choosebank("emblTP")
 #
 # Example with a file that contains sequence names:
 #
 fileSQ &lt;- system.file("sequences/bb.mne", package = "seqinr")
 listSQ &lt;- crelistfromclientdata("listSQ", file = fileSQ, type = "SQ")
 sapply(listSQ$req, getName)
 #
 # Example with a file that contains sequence accession numbers:
 #
 fileAC &lt;- system.file("sequences/bb.acc", package = "seqinr")
 listAC &lt;- crelistfromclientdata("listAC", file = fileAC, type = "AC")
 sapply(listAC$req, getName) 
 #
 # Example with a file that contains species names:
 #
 fileSP &lt;- system.file("sequences/bb.sp", package = "seqinr")
 listSP &lt;- crelistfromclientdata("listSP", file = fileSP, type = "SP")
 sapply(listSP$req, getName) 
 #
 # Example with a file that contains keywords:
 #
 fileKW &lt;- system.file("sequences/bb.kwd", package = "seqinr")
 listKW &lt;- crelistfromclientdata("listKW", file = fileKW, type = "KW")
 sapply(listKW$req, getName)
 #
 # Summary of ACNUC lists:
 #
 sapply(alr()$rank, getliststate)
 closebank() 
 
## End(Not run)
</code></pre>

<hr>
<h2 id='dia.bactgensize'> Distribution of bacterial genome size from GOLD </h2><span id='topic+dia.bactgensize'></span>

<h3>Description</h3>

<p>This function tries to download the last update of the GOLD
(Genomes OnLine Database) to extract bacterial genomes sizes
when available. The histogram and the default density()
output is produced. Optionally, a maximum likelihood estimate
of a superposition of two or three normal distributions is
also represented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dia.bactgensize(fit = 2, p = 0.5, m1 = 2000, sd1 = 600, m2 = 4500,
       sd2 = 1000, p3 = 0.05, m3 = 9000, sd3 = 1000, maxgensize = 20000,
       source = c("https://pbil.univ-lyon1.fr/datasets/seqinr/data/goldtable15Dec07.txt"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dia.bactgensize_+3A_fit">fit</code></td>
<td>
<p> integer value. If <code>fit == O</code> no normal fit
is produced, if <code>fit == 2</code> try to fit a superposition of
two normal distributions, if <code>fit == 3</code> try to fit a
superposition of three normal distributions.
</p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_p">p</code></td>
<td>
<p> initial guess for the proportion of the first population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_m1">m1</code></td>
<td>
<p> initial guess for the mean of the first population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_sd1">sd1</code></td>
<td>
<p> initial guess for the standard deviation of the first population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_m2">m2</code></td>
<td>
<p> initial guess for the mean of the second population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_sd2">sd2</code></td>
<td>
<p>initial guess for the standard deviation of the second population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_p3">p3</code></td>
<td>
<p> initial guess for the proportion of the third population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_m3">m3</code></td>
<td>
<p> initial guess for the mean of the third population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_sd3">sd3</code></td>
<td>
<p>initial guess for the standard deviation of the third population. </p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_maxgensize">maxgensize</code></td>
<td>
<p>maximum admissive value in bp for a bacterial genome size:
only value less or equal to this threshold are considrered.</p>
</td></tr>
<tr><td><code id="dia.bactgensize_+3A_source">source</code></td>
<td>
<p> the file with raw data. By default a local (outdated) copy is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible dataframe with three components:
</p>
<table role = "presentation">
<tr><td><code>genus</code></td>
<td>
<p>genus name</p>
</td></tr>
<tr><td><code>species</code></td>
<td>
<p>species names</p>
</td></tr>
<tr><td><code>gs</code></td>
<td>
<p>genome size in Kb</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p>Please cite the following references when using data from GOLD:
</p>
<p>Kyrpides, N.C. (1999) Genomes OnLine Database (GOLD 1.0): a monitor
of complete and ongoing genome projects world-wide.
<em>Bioinformatics</em>, <b>15</b>:773-774.<br />
</p>
<p>Bernal, A., Ear, U., Kyrpides, N. (2001) Genomes OnLine Database (GOLD):
a monitor of genome projects world-wide.
<em>Nucleic Acids Research</em>, <b>29</b>:126-127.<br />
</p>
<p>Liolios, K., Tavernarakis, N., Hugenholtz, P., Kyrpides, N.C. (2006)
The Genomes On Line Database (GOLD) v.2: a monitor of genome
projects worldwide.
<em>Nucleic Acids Research</em>, <b>34</b>:D332-D334.<br />
</p>
<p>Liolios, K., Mavrommatis, K., Tavernarakis, N., Kyrpides, N.C. (2008)
The Genomes On Line Database (GOLD) in 2007: status of genomic
and metagenomic projects and their associated metadata.
<em>Nucleic Acids Research</em>,
<b>in press</b>:D000-D000.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+density">density</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: # Need internet connection
#
# With a local outdated copy from GOLD:
#
   dia.bactgensize()
#
# With last GOLD data:
#
  # The URL is no more accessible.
  # dia.bactgensize(source = "http://www.genomesonline.org/DBs/goldtable.txt")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dinucl'> Mean zscore on 242 complete bacterial chromosomes </h2><span id='topic+dinucl'></span>

<h3>Description</h3>

<p>This dataset contains the mean zscores as computed on all intergenic
sequences (intergenic) and on all CDS (coding) from 242
complete bacterial chromosomes (as retrieved from Genome Reviews database on
June 16, 2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dinucl)
</code></pre>


<h3>Format</h3>

<p>List of two dataframes of 242 chromosomes and 16 dinucleotides: one
for intergenic, one for coding sequences.
</p>

<dl>
<dt>intergenic</dt><dd><p>the mean of <code>zscore</code> computed with the <code>base</code>
model on each intergenic sequence</p>
</dd>
<dt>coding</dt><dd><p>the mean of <code>zscore</code> computed with the <code>codon</code>
model on each coding sequence</p>
</dd>
</dl>



<h3>References</h3>

<p>Palmeira, L., Guéguen, L. and Lobry JR. (2006) UV-targeted dinucleotides
are not depleted in light-exposed Prokaryotic genomes.
<em>Molecular Biology and Evolution</em>,
<b>23</b>:2214-2219.<br />
<a href="https://academic.oup.com/mbe/article/23/11/2214/1335460">https://academic.oup.com/mbe/article/23/11/2214/1335460</a><br /><br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+zscore">zscore</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dinucl)
par(mfrow = c(2, 2), mar = c(4,4,0.5,0.5)+0.1)
myplot &lt;- function(x){
  plot(dinucl$intergenic[, x], dinucl$coding[, x],
  xlab = "intergenic", ylab = "coding", 
  las = 1, ylim = c(-6, 4), 
  xlim = c(-3, 3), cex = 0)
  rect(-10,-10,-1.96,10,col="yellow", border = "yellow")
  rect(1.96,-10,10,10,col="yellow", border = "yellow")
  rect(-10,-10,10,-1.96,col="yellow", border = "yellow")
  rect(-10,1.96,10,10,col="yellow", border = "yellow")
  abline(v=0,lty=3)
  abline(h=0,lty=3)
  abline(h=-1.96,lty=2)
  abline(h=+1.96,lty=2)
  abline(v=-1.96,lty=2)
  abline(v=+1.96,lty=2)
  points(dinucl$intergenic[, x], dinucl$coding[, x], pch = 21,
  col = rgb(.1,.1,.1,.5), bg = rgb(.5,.5,.5,.5))
  legend("bottomright", inset = 0.02,
   legend = paste(substr(x,1,1), "p",
    substr(x,2,2), " bias", sep = ""), cex = 1.25, bg = "white")
  box()
}
myplot("CT")
myplot("TC")
myplot("CC")
myplot("TT")
</code></pre>

<hr>
<h2 id='dinucleotides'>Statistical over- and under- representation of dinucleotides in a
sequence</h2><span id='topic+rho'></span><span id='topic+zscore'></span>

<h3>Description</h3>

<p>These two functions compute two different types of statistics for the
measure of statistical dinculeotide over- and under-representation :
the rho statistic, and the z-score, each computed for all 16 dinucleotides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho(sequence, wordsize = 2, alphabet = s2c("acgt"))
zscore(sequence, simulations = NULL, modele, exact = FALSE, alphabet = s2c("acgt"), ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dinucleotides_+3A_sequence">sequence</code></td>
<td>
<p>a vector of single characters.</p>
</td></tr>
<tr><td><code id="dinucleotides_+3A_wordsize">wordsize</code></td>
<td>
<p>an integer giving the size of word (n-mer) to consider.</p>
</td></tr>
<tr><td><code id="dinucleotides_+3A_simulations">simulations</code></td>
<td>
<p> If <code>NULL</code>, analytical solution is computed
when available (models <code>base</code> and <code>codon</code>). Otherwise, it
should be the number of permutations for the z-score computation </p>
</td></tr>
<tr><td><code id="dinucleotides_+3A_modele">modele</code></td>
<td>
<p> A string of characters describing the model chosen for
the random generation </p>
</td></tr>
<tr><td><code id="dinucleotides_+3A_exact">exact</code></td>
<td>
<p> Whether exact analytical calculation or an
approximation should be used </p>
</td></tr>
<tr><td><code id="dinucleotides_+3A_alphabet">alphabet</code></td>
<td>
<p> A vector of single characters. </p>
</td></tr>
<tr><td><code id="dinucleotides_+3A_...">...</code></td>
<td>
<p> Optional parameters for specific model permutations are
passed on to <code><a href="#topic+permutation">permutation</a></code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rho</code> statistic, as presented in Karlin S., Cardon LR. (1994), can
be computed on each of the 16 dinucleotides. It is the frequence of
dinucleotide <em>xy</em> divided by the product of frequencies of
nucleotide <em>x</em> and nucleotide <em>y</em>. It is equal to 1.00 when
dinucleotide <em>xy</em> is formed by pure chance, and it is superior
(respectively inferior) to 1.00 when dinucleotide <em>xy</em> is over-
(respectively under-) represented. Note that if you want to reproduce
Karlin's results you have to compute the statistic from the sequence 
concatenated with its inverted complement that is with something 
like <code>rho(c(myseq, rev(comp(myseq))))</code>.
</p>
<p>The <code>zscore</code> statistic, as presented in Palmeira, L., Guéguen, L.
and Lobry JR. (2006). The statistic is the normalization of the
<code>rho</code> statistic by its expectation and variance according to a
given random sequence generation model, and follows the
standard normal distribution. This statistic can be computed
with several models (cf. <code><a href="#topic+permutation">permutation</a></code> for the description
of each of the models). We provide analytical calculus for two of
them: the <code>base</code> permutations model and the  <code>codon</code>
permutations model.
</p>
<p>The <code>base</code> model allows for random sequence generation by
shuffling (with/without replacement) of all bases in the sequence.
Analytical computations are available for this model: either as an 
approximation for large sequences (cf. Palmeira, L., Guéguen, L.
and Lobry JR. (2006)), either as the exact analytical formulae
(cf. Schbath, S. (1995)).
</p>
<p>The <code>position</code> model allows for random sequence generation
by shuffling (with/without replacement) of bases within their
position in the codon (bases in position I, II or III stay in
position I, II or III in the new sequence.
</p>
<p>The <code>codon</code> model allows for random sequence generation by
shuffling (with/without replacement) of codons. Analytical
computation is available for this model (Gautier, C., Gouy, M. and
Louail, S. (1985)).
</p>
<p>The <code>syncodon</code> model allows for random sequence generation
by shuffling (with/without replacement) of synonymous codons.
</p>


<h3>Value</h3>

<p>a table containing the computed statistic for each dinucleotide
</p>


<h3>Author(s)</h3>

<p>L. Palmeira, J.R. Lobry with suggestions from A. Coghlan.</p>


<h3>References</h3>

<p>Gautier, C., Gouy, M. and Louail, S. (1985) Non-parametric statistics
for nucleic acid sequence study. <em>Biochimie</em>, <b>67</b>:449-453.
</p>
<p>Karlin S. and Cardon LR. (1994) Computational DNA sequence analysis.
<em>Annu Rev Microbiol</em>, <b>48</b>:619-654.
</p>
<p>Schbath, S. (1995) Étude asymptotique du nombre d'occurrences d'un
mot dans une chaîne de Markov et application à la recherche de mots
de fréquence exceptionnelle dans les séquences d'ADN.
<em>Thèse de l'Université René Descartes, Paris V</em>
</p>
<p>Palmeira, L., Guéguen, L. and Lobry, J.R. (2006) UV-targeted dinucleotides
are not depleted in light-exposed Prokaryotic genomes.
<em>Molecular Biology and Evolution</em>,
<b>23</b>:2214-2219.
<a href="https://academic.oup.com/mbe/article/23/11/2214/1335460">https://academic.oup.com/mbe/article/23/11/2214/1335460</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+permutation">permutation</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sequence &lt;- sample(x = s2c("acgt"), size = 6000, replace = TRUE)
rho(sequence)
zscore(sequence, modele = "base")
zscore(sequence, modele = "base", exact = TRUE)
zscore(sequence, modele = "codon")
zscore(sequence, simulations = 1000, modele = "syncodon")

## End(Not run)
</code></pre>

<hr>
<h2 id='dist.alignment'> Pairwise Distances from Aligned Protein or DNA/RNA Sequences </h2><span id='topic+dist.alignment'></span>

<h3>Description</h3>

<p>These functions compute a matrix of pairwise distances from aligned sequences
using similarity (Fitch matrix, for protein sequences only) or identity matrix
(for protein and DNA sequences).
The resulting matrix contains the squared root of the pairwise distances.
For example, if identity between 2 sequences is 80
the squared root of (1.0 - 0.8) i.e. 0.4472136.
Note: seqinr::dist.alignment is the square root version of ape::dist.gene (and
not ape::dist.dna).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.alignment(x, matrix = c("identity", "similarity"),gap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.alignment_+3A_x">x</code></td>
<td>
<p>an object of class <code>alignment</code>, as returned by
<code>read.alignment</code> for instance</p>
</td></tr>
<tr><td><code id="dist.alignment_+3A_matrix">matrix</code></td>
<td>
<p>the matrix distance to be used, partial matching allowed </p>
</td></tr>
<tr><td><code id="dist.alignment_+3A_gap">gap</code></td>
<td>
<p>-optional- logical, with identity matrix, if set to <code>TRUE</code>, gaps will be counted in the identity measure </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance matrix, object of class <code>dist</code>, computed by using the
specified distance measure.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p>The reference for the similarity matrix is :<br />
Fitch, W.M. (1966) An improved method of testing for evolutionary homology.
<em>J. Mol. Biol.</em>, <b>16</b>:9-16.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+read.alignment">read.alignment</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> myseqs &lt;- read.alignment(file = system.file("sequences/test.mase",
 package = "seqinr"), format = "mase")
 dist.alignment(myseqs, matrix = "identity" )
 as.matrix(dist.alignment(myseqs, matrix = "identity" ))
</code></pre>

<hr>
<h2 id='dotchart.uco'>Cleveland plot for codon usage tables </h2><span id='topic+dotchart.uco'></span>

<h3>Description</h3>

<p>Draw a Cleveland dot plot for codon usage tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotchart.uco(x, numcode = 1, aa3 = TRUE, pt.cex = 0.7, alphabet =
                 s2c("tcag"), pch = 21, gpch = 20, bg = par("bg"), cex
                 = 0.7, color = "black", gcolor = "black", lcolor =
                 grey(0.9), xlim, offset = 0.4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dotchart.uco_+3A_x">x</code></td>
<td>
<p>table of codon usage as computed by <code>uco</code>. </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_numcode">numcode</code></td>
<td>
<p>the number of the code to be used by <code>translate</code>.</p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_aa3">aa3</code></td>
<td>
<p>logical. If TRUE use the three-letter code for amino-
acids. If FALSE use the one-letter code for amino-acids. </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_pt.cex">pt.cex</code></td>
<td>
<p>the character size to be used for points. </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_alphabet">alphabet</code></td>
<td>
<p>character for codons labels</p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_pch">pch</code></td>
<td>
<p>the plotting character or symbol to be used.</p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_gpch">gpch</code></td>
<td>
<p>the plotting character or symbol to be used for group values. </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_bg">bg</code></td>
<td>
<p>the background color to be used. </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_cex">cex</code></td>
<td>
<p>the character expansion size passed to <code><a href="graphics.html#topic+dotchart">dotchart</a></code>. </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_color">color</code></td>
<td>
<p>the color(s) to be used for points an labels. </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_gcolor">gcolor</code></td>
<td>
<p>the single color to be used for group labels and values.</p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_lcolor">lcolor</code></td>
<td>
<p>the color(s) to be used for the horizontal lines.</p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_xlim">xlim</code></td>
<td>
<p>horizontal range for the plot </p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_offset">offset</code></td>
<td>
<p>offset in inches of ylab and labels; was hardwired to 0.4 before R 4.0.0</p>
</td></tr>
<tr><td><code id="dotchart.uco_+3A_...">...</code></td>
<td>
<p>graphical parameters can also be specified as arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible list with components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>table of codon usage</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>codon names</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>amino acid factor</p>
</td></tr>
<tr><td><code>gdata</code></td>
<td>
<p>sums by amino acid</p>
</td></tr>
<tr><td><code>ypg</code></td>
<td>
<p>the y-axis coordinates for amino acids</p>
</td></tr>
<tr><td><code>ypi</code></td>
<td>
<p>the y-axis coordinates for codons</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p> Cleveland, W. S. (1985) The Elements of Graphing Data.
Monterey, CA: Wadsworth.
<code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+dotchart">dotchart</a></code>, <code><a href="#topic+uco">uco</a></code>, <code><a href="#topic+aaa">aaa</a></code>,
<code><a href="#topic+translate">translate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load dataset:
data(ec999)
# Compute codon usage for all coding sequences:
ec999.uco &lt;- lapply(ec999, uco, index="eff")
# Put it in a dataframe:
df &lt;- as.data.frame(lapply(ec999.uco, as.vector))
# Add codon names:
row.names(df) &lt;- names(ec999.uco[[1]])
# Compute global codon usage:
global &lt;- rowSums(df)
# Choose a title for the graph:
title &lt;- "Codon usage in 999 E. coli coding sequences"
# Plot data:
dotchart.uco(global, main = title)
</code></pre>

<hr>
<h2 id='dotPlot'> Dot Plot Comparison of two sequences </h2><span id='topic+dotPlot'></span>

<h3>Description</h3>

<p>Dot plots are most likely the oldest visual representation used to compare 
two sequences (see Maizel and Lenk 1981 and references therein). In its
simplest form, a dot is produced at position (i,j) iff character number
i in the first sequence is the same as character number j in the
second sequence. More eleborated forms use sliding windows and a threshold
value for two windows to be considered as matched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotPlot(seq1, seq2, wsize = 1, wstep = 1, nmatch = 1, shift = 0,
col = c("white", "black"), xlab = deparse(substitute(seq1)),
ylab = deparse(substitute(seq2)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dotPlot_+3A_seq1">seq1</code></td>
<td>
<p> the first sequence (x-axis) as a vector of single chars.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_seq2">seq2</code></td>
<td>
<p> the second sequence (y-axis) as a vector of single char.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_wsize">wsize</code></td>
<td>
<p> the size in chars of the moving window.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_wstep">wstep</code></td>
<td>
<p> the size in chars for the steps of the moving window.
Use <code>wstep == wsize</code> for non-overlapping windows.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_nmatch">nmatch</code></td>
<td>
<p> if the number of match per window is greater than or equal
to <code>nmatch</code> then a dot is produced.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_shift">shift</code></td>
<td>
<p> the number of chars to shift in seq2 when generating the moving window.</p>
</td></tr>   
<tr><td><code id="dotPlot_+3A_col">col</code></td>
<td>
<p> color of points passed to <code>image</code>.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_xlab">xlab</code></td>
<td>
<p> label of x-axis passed to <code>image</code>.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_ylab">ylab</code></td>
<td>
<p> label of y-axis passed to <code>image</code>.</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code>image</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. 
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p>Maizel, J.V. and Lenk, R.P. (1981) Enhanced Graphic Matrix Analysis of 
Nucleic Acid and Protein Sequences. 
<em>Proceedings of the National Academy of Science USA</em>,
<b>78</b>:7665-7669.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+image">image</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Identity is on the main diagonal:
#
dotPlot(letters, letters, main = "Direct repeat")
#
# Internal repeats are off the main diagonal:
#
dotPlot(rep(letters, 2), rep(letters, 2), main = "Internal repeats")
#
# Inversions are orthogonal to the main diagonal:
#
dotPlot(letters, rev(letters), main = "Inversion")
#
# Insertion in the second sequence yields a vertical jump:
#
dotPlot(letters, c(letters[1:10], s2c("insertion"), letters[11:26]), 
  main = "Insertion in the second sequence", asp = 1)
#
# Insertion in the first sequence yields an horizontal jump:
#
dotPlot(c(letters[1:10], s2c("insertion"), letters[11:26]), letters,
  main = "Insertion in the first sequence", asp = 1)
#
# Protein sequences have usually a good signal/noise ratio because there
# are 20 possible amino-acids:
#
aafile &lt;- system.file("sequences/seqAA.fasta", package = "seqinr")
protein &lt;- read.fasta(aafile)[[1]]
dotPlot(protein, protein, main = "Dot plot of a protein\nwsize = 1, wstep = 1, nmatch = 1")
#
# Nucleic acid sequences have usually a poor signal/noise ratio because
# there are only 4 different bases:
#
dnafile &lt;- system.file("sequences/malM.fasta", package = "seqinr")
dna &lt;- protein &lt;- read.fasta(dnafile)[[1]]
dotPlot(dna[1:200], dna[1:200],
 main = "Dot plot of a nucleic acid sequence\nwsize = 1, wstep = 1, nmatch = 1")
#
# Play with the wsize, wstep and nmatch arguments to increase the 
# signal/noise ratio:
#
dotPlot(dna[1:200], dna[1:200], wsize = 3, wstep = 3, nmatch = 3,
main = "Dot plot of a nucleic acid sequence\nwsize = 3, wstep = 3, nmatch = 3")
</code></pre>

<hr>
<h2 id='draw.oriloc'>Graphical representation for nucleotide skews in
prokaryotic chromosomes.</h2><span id='topic+draw.oriloc'></span>

<h3>Description</h3>

<p>Graphical representation for nucleotide skews in
prokaryotic chromosomes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.oriloc(ori, main = "Title",
  xlab = "Map position in Kb",
  ylab = "Cumulated combined skew in Kb", las = 1, las.right = 3,
  ta.mtext = "Cumul. T-A skew", ta.col = "pink", ta.lwd = 1,
  cg.mtext = "Cumul. C-G skew", cg.col = "lightblue", cg.lwd = 1,
  cds.mtext = "Cumul. CDS skew", cds.col = "lightgreen", cds.lwd = 1,
  sk.col = "black", sk.lwd = 2,
  add.grid = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.oriloc_+3A_ori">ori</code></td>
<td>
<p>A data frame obtained with the <code>oriloc</code> function.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis title.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis title.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_las">las</code></td>
<td>
<p>The style of axis labels for the bottom and left axes.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_las.right">las.right</code></td>
<td>
<p>The style of axis labels for the right axis.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_ta.mtext">ta.mtext</code></td>
<td>
<p>The marginal legend for the TA skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_ta.col">ta.col</code></td>
<td>
<p>The color for the TA skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_ta.lwd">ta.lwd</code></td>
<td>
<p>The line width for the TA skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_cg.mtext">cg.mtext</code></td>
<td>
<p>The marginal legend for the CG skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_cg.col">cg.col</code></td>
<td>
<p>The color for the CG skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_cg.lwd">cg.lwd</code></td>
<td>
<p>The line width for the CG skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_cds.mtext">cds.mtext</code></td>
<td>
<p>The marginal legend for the CDS skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_cds.col">cds.col</code></td>
<td>
<p>The color for the CDS skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_cds.lwd">cds.lwd</code></td>
<td>
<p>The line width for the CDS skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_sk.col">sk.col</code></td>
<td>
<p>The color for the cumulated combined skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_sk.lwd">sk.lwd</code></td>
<td>
<p>The line width for the cumulated combined skew.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_add.grid">add.grid</code></td>
<td>
<p>Logical, if <code>TRUE</code> a vertical grid is added to the plot.</p>
</td></tr>
<tr><td><code id="draw.oriloc_+3A_...">...</code></td>
<td>
<p>Further arguments are passed to the function <code>plot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+oriloc">oriloc</a></code>, <code><a href="#topic+rearranged.oriloc">rearranged.oriloc</a></code>,
<code><a href="#topic+extract.breakpoints">extract.breakpoints</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # need internet connection
#
# Example with Chlamydia trachomatis complete genome
#
  ori &lt;- oriloc()
  draw.oriloc(ori)
#
# The same, using more options from function draw.oriloc()
#
draw.oriloc(ori, 
  main = expression(italic(Chlamydia~~trachomatis)~~complete~~genome),
  ta.mtext = "TA skew", ta.col = "red",
  cg.mtext = "CG skew", cg.col = "blue",
  cds.mtext = "CDS skew", cds.col = "seagreen",
  add.grid = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='draw.rearranged.oriloc'>Graphical representation for rearranged nucleotide skews in
prokaryotic chromosomes.</h2><span id='topic+draw.rearranged.oriloc'></span>

<h3>Description</h3>

<p>Graphical representation for rearranged nucleotide skews in
prokaryotic chromosomes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.rearranged.oriloc(rearr.ori, breaks.gcfw = NA,
 breaks.gcrev = NA, breaks.atfw = NA, breaks.atrev = NA)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.rearranged.oriloc_+3A_rearr.ori">rearr.ori</code></td>
<td>
<p>A data frame obtained with the <code>rearranged.oriloc</code>
function. </p>
</td></tr>
<tr><td><code id="draw.rearranged.oriloc_+3A_breaks.gcfw">breaks.gcfw</code></td>
<td>
<p>The coordinates of the breakpoints in the GC-skew,
for forward transcribed protein coding sequences. These coordinates
can be obtained with the <code>extract.breakpoints</code> function. </p>
</td></tr>
<tr><td><code id="draw.rearranged.oriloc_+3A_breaks.gcrev">breaks.gcrev</code></td>
<td>
<p>The coordinates of the breakpoints in the GC-skew,
for reverse transcribed protein coding sequences. These coordinates
can be obtained with the <code>extract.breakpoints</code> function. </p>
</td></tr>
<tr><td><code id="draw.rearranged.oriloc_+3A_breaks.atfw">breaks.atfw</code></td>
<td>
<p>The coordinates of the breakpoints in the AT-skew,
for forward transcribed protein coding sequences. These coordinates
can be obtained with the <code>extract.breakpoints</code> function. </p>
</td></tr>
<tr><td><code id="draw.rearranged.oriloc_+3A_breaks.atrev">breaks.atrev</code></td>
<td>
<p>The coordinates of the breakpoints in the AT-skew,
for reverse transcribed protein coding sequences. These coordinates
can be obtained with the <code>extract.breakpoints</code> function. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry, A. Necşulea</p>


<h3>References</h3>

<p>Necşulea, A. and Lobry, J.R. (2007) A New Method for Assessing the 
Effect of Replication on DNA Base Composition Asymmetry.
<em>Molecular Biology and Evolution</em>, <b>24</b>:2169-2179.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rearranged.oriloc">rearranged.oriloc</a></code>,
<code><a href="#topic+extract.breakpoints">extract.breakpoints</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
### Example for Chlamydia trachomatis ####

### Rearrange the chromosome and compute the nucleotide skews ###

#r.ori &lt;- rearranged.oriloc(seq.fasta = system.file("sequences/ct.fasta.gz", package = "seqinr"),
#    g2.coord = system.file("sequences/ct.coord", package = "seqinr"))

r.ori &lt;- rearranged.oriloc(seq.fasta = system.file("sequences/ct.fasta.gz", package = "seqinr"),
    g2.coord = system.file("sequences/ct.coord", package = "seqinr"))



### Extract the breakpoints for the rearranged nucleotide skews ###

breaks &lt;- extract.breakpoints(r.ori, type = c("gcfw", "gcrev"),
 nbreaks = c(2, 2), gridsize = 50, it.max = 100)

### Draw the rearranged nucleotide skews and  ###
### place the position of the breakpoints on the graphics ###

draw.rearranged.oriloc(r.ori, breaks.gcfw = breaks$gcfw$breaks,
 breaks.gcrev = breaks$gcrev$breaks)
## End(Not run)
</code></pre>

<hr>
<h2 id='draw.recstat'>Graphical representation of a recstat analysis.</h2><span id='topic+draw.recstat'></span>

<h3>Description</h3>

<p>This function displays the results returned by <code>recstat</code> with two plots. The
first one shows the factor scores of a CA computed on the codon composition of a DNA sequence.
The second one shows the locations of all Start and Stop codons in this sequence.</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.recstat(rec, fac = 1, direct  = TRUE, xlim = c(1, seqsize),
    col = c("red", "blue", "purple"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw.recstat_+3A_rec">rec</code></td>
<td>
<p>list of elements returned by <code>recstat</code> function.</p>
</td></tr>
<tr><td><code id="draw.recstat_+3A_fac">fac</code></td>
<td>
<p>axis of the CA to use for display (4 <code class="reqn">\ge</code> <code>fac</code>
<code class="reqn">\ge</code> 1).</p>
</td></tr>
<tr><td><code id="draw.recstat_+3A_direct">direct</code></td>
<td>
<p>a logical for the choice of direct or reverse strand.</p>
</td></tr>
<tr><td><code id="draw.recstat_+3A_xlim">xlim</code></td>
<td>
<p>starting and ending positions in the sequence for the plot.</p>
</td></tr>
<tr><td><code id="draw.recstat_+3A_col">col</code></td>
<td>
<p>vector of colour codes for the three frames of the sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first plot shows the factor scores of the sliding windows, this for the three
possible frames of the strand selected by the user. The second shows the Start (filled grey
triangles pointing up) and Stop (solid black triangles pointing down) codons positions. Note
that the standard genetic code is used for that purpose. Visual detection of putative CDS is
performed through the simultaneous use of these two graphics. If a CDS is located within the
sequence, the factor scores for the windows located in the corresponding reading frame will be
significantly separated from the two others. Moreover, the region where this separation is seen
should be located between a Start and a Stop codon.</p>


<h3>Author(s)</h3>

<p>O. Clerc, G. Perrière</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.li.recstat">test.li.recstat</a></code>, <code><a href="#topic+test.co.recstat">test.co.recstat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- system.file("sequences/ECOUNC.fsa", package = "seqinr")
seq &lt;- read.fasta(ff)
rec &lt;- recstat(seq[[1]], seqname = getName(seq))
draw.recstat(rec)
</code></pre>

<hr>
<h2 id='ec999'> 999 coding sequences from E. coli </h2><span id='topic+ec999'></span>

<h3>Description</h3>

<p>This dataset contains 999 coding sequences from the Escherichia
coli chromosome</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ec999)</code></pre>


<h3>Format</h3>

<p> List of 999 vectors of characters, one for each coding
sequence.
</p>

<dl>
<dt>ECFOLE.FOLE    </dt><dd><p>chr [1:672] &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;C&quot; ...</p>
</dd>
<dt>ECMSBAG.MSBA   </dt><dd><p>chr [1:1749] &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;C&quot; ...</p>
</dd>
<dt>ECNARZYW-C.NARV</dt><dd><p>chr [1:681] &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; ...</p>
</dd>
<dt>...            </dt><dd><p> ... TRUNCATED ... </p>
</dd>
<dt>XYLEECOM.MALK  </dt><dd><p>chr [1:1116] &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;G&quot; ...</p>
</dd>
<dt>XYLEECOM.LAMB  </dt><dd><p>chr [1:1341] &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; ...</p>
</dd>
<dt>XYLEECOM.MALM  </dt><dd><p>chr [1:921] &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; ...</p>
</dd>
</dl>



<h3>References</h3>

<p>Lobry, J.R., Gautier, C. (1994) Hydrophobicity,
expressivity and aromaticity are the major trends of amino-acid usage in
999 <em>Escherichia coli</em> chromosome-encode genes. <em>Nucleic Acids
Research</em>,<b>22</b>:3174-3180.
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ec999)
#
# How to export sequences in a FASTA file:
#
fname &lt;- tempfile(pattern = "ecc999", tmpdir = tempdir(), fileext = "ffn")
tempdir(check = FALSE)
write.fasta(ec999, names(ec999), file = fname)
</code></pre>

<hr>
<h2 id='ECH'>Forensic Genetic Profile Allelic Ladder Raw Data</h2><span id='topic+ECH'></span>

<h3>Description</h3>

<p>This is an example of allelic ladder raw data for a human STR genetic profile at 16 loci
(<em>viz.</em> D8S1179, D21S11, D7S820, CSF1PO, D3S1358, TH01, D13S317, D16S539,
D2S1338, D19S433, vWA, TPOX, D18S51, Amelogenin, D5S818, FGA) which
are commonly used in forensic sciences for individual identifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ECH)</code></pre>


<h3>Format</h3>

<p>A list with 3 components as in <code><a href="#topic+JLO">JLO</a></code>
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>Source</h3>

<p>Data were kindly provided by the INPS (Institut National de Police Scientifique)
which is the national forensic sciences institute in France. Experiments
were done at the LPS (Laboratoire de Police Scientifique de Lyon) in 2008.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>
<p>Anonymous (2006) Applied Biosystem Genetic Analysis Data File Format.
Available at <a href="https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html">https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html</a>.
Last visited on 03-NOV-2008.
</p>


<h3>See Also</h3>

<p>function <code><a href="#topic+read.abif">read.abif</a></code> to import files in ABIF format,
data <code><a href="#topic+gs500liz">gs500liz</a></code> for internal size standards,
data <code><a href="#topic+identifiler">identifiler</a></code> for allele names in the allelic ladder,
data <code><a href="#topic+JLO">JLO</a></code> for an example of an individual sample file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JLO)
</code></pre>

<hr>
<h2 id='EXP'>Vectors of coefficients to compute linear forms.</h2><span id='topic+EXP'></span>

<h3>Description</h3>

<p>This dataset is used to compute linear forms on codon frequencies:
if <code>codfreq</code> is a vector of codon frequencies then
<code>drop(freq %*% EXP$CG3)</code> will return for instance the G+C content
in third codon positions. Base order is the lexical order: a,
c, g, t (or u).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EXP)</code></pre>


<h3>Format</h3>

<p>List of 24 vectors of coefficients
</p>

<dl>
<dt>A</dt><dd><p>num [1:4] 1 0 0 0</p>
</dd>
<dt>A3</dt><dd><p>num [1:64] 1 0 0 0 1 0 0 0 1 0 ...</p>
</dd>
<dt>AGZ</dt><dd><p>num [1:64] 0 0 0 0 0 0 0 0 1 0 ...</p>
</dd>
<dt>ARG</dt><dd><p>num [1:64] 0 0 0 0 0 0 0 0 1 0 ...</p>
</dd>
<dt>AU3</dt><dd><p>num [1:64] 1 0 0 1 1 0 0 1 1 0 ...</p>
</dd>
<dt>BC</dt><dd><p>num [1:64] 0 1 0 0 0 0 0 0 0 0 ...</p>
</dd>
<dt>C</dt><dd><p>num [1:4] 0 1 0 0</p>
</dd>
<dt>C3</dt><dd><p>num [1:64] 0 1 0 0 0 1 0 0 0 1 ...</p>
</dd>
<dt>CAI</dt><dd><p>num [1:64]  0.00  0.00 -1.37 -2.98 -2.58 ...</p>
</dd>
<dt>CG</dt><dd><p>num [1:4] 0 1 1 0</p>
</dd>
<dt>CG1</dt><dd><p>num [1:64] 0 0 0 0 0 0 0 0 0 0 ...</p>
</dd>
<dt>CG12</dt><dd><p>num [1:64] 0 0 0 0 0.5 0.5 0.5 0.5 0.5 0.5 ...</p>
</dd>
<dt>CG2</dt><dd><p>num [1:64] 0 0 0 0 1 1 1 1 1 1 ...</p>
</dd>
<dt>CG3</dt><dd><p>num [1:64] 0 1 1 0 0 1 1 0 0 1 ...</p>
</dd>
<dt>CGN</dt><dd><p>num [1:64] 0 0 0 0 0 0 0 0 0 0 ...</p>
</dd>
<dt>F1</dt><dd><p>num [1:64]  1.026  0.239  1.026  0.239 -0.097 ...</p>
</dd>
<dt>G</dt><dd><p>num [1:4] 0 0 1 0</p>
</dd>
<dt>G3</dt><dd><p>num [1:64] 0 0 1 0 0 0 1 0 0 0 ...</p>
</dd>
<dt>KD</dt><dd><p>num [1:64] -3.9 -3.5 -3.9 -3.5 -0.7 -0.7 -0.7 -0.7 -4.5 -0.8 ...</p>
</dd>
<dt>Q</dt><dd><p>num [1:64] 0 0 0 0 1 1 1 1 0 0 ...</p>
</dd>
<dt>QA3</dt><dd><p>num [1:64] 0 0 0 0 1 0 0 0 0 0 ...</p>
</dd>
<dt>QC3</dt><dd><p>num [1:64] 0 0 0 0 0 1 0 0 0 0 ...</p>
</dd>
<dt>U</dt><dd><p>num [1:4] 0 0 0 1</p>
</dd>
<dt>U3</dt><dd><p>num [1:64] 0 0 0 1 0 0 0 1 0 0 ...</p>
</dd>
</dl>



<h3>Details</h3>

<p>It's better to work directly at the amino-acid level
when computing linear forms on amino-acid frequencies so as to have
a single coefficient vector. For instance <code>EXP$KD</code> to compute the Kyte
and Doolittle hydrophaty index from codon frequencies is valid only
for the standard genetic code.<br />
<br />
An alternative for <code>drop(freq %*% EXP$CG3)</code> is <code>
sum( freq * EXP$CG3 )</code>, but this is less efficient in terms of CPU
time. The advantage of the latter, however, is that thanks to
recycling rules you can use either <code>sum( freq * EXP$A )</code>
or <code>sum( freq * EXP$A3 )</code>. To do the same with the %*%
operator you have to explicit the recycling rule as in <code>
drop( freq %*% rep(EXP$A, 16))</code>.
</p>


<h3>Source</h3>

<p>ANALSEQ EXPFILEs for command EXP.<br />
<a href="http://pbil.univ-lyon1.fr/software/doclogi/docanals/manuel.html">http://pbil.univ-lyon1.fr/software/doclogi/docanals/manuel.html</a>
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>

<dl>
<dt>A</dt><dd><p>content in A nucleotide</p>
</dd>
<dt>A3</dt><dd><p>content in A nucleotide in third position of codon</p>
</dd>	
<dt>AGZ</dt><dd><p>Arg content (aga and agg codons)</p>
</dd>
<dt>ARG</dt><dd><p>Arg content</p>
</dd>
<dt>AU3</dt><dd><p>content in A and U nucleotides in third position of codon</p>
</dd>
<dt>BC</dt><dd><p>Good choice (Bon choix). Gouy M., Gautier C. (1982)
codon usage in bacteria : Correlation with gene expressivity. <em>Nucleic Acids Research</em>,<b>10(22)</b>:7055-7074.</p>
</dd>
<dt>C</dt><dd><p>content in C nucleotides</p>
</dd>
<dt>C3</dt><dd><p>content in A nucleotides in third position of codon</p>
</dd>
<dt>CAI</dt><dd><p>Codon adaptation index for E. coli. Sharp, P.M., Li, W.-H. (1987) The codon adaptation index -
a measure of directionam synonymous codon usage bias, and its potential
applications. <em>Nucleic Acids Research</em>,<b>15</b>:1281-1295.</p>
</dd>
<dt>CG</dt><dd><p>content in G + C nucleotides</p>
</dd>
<dt>CG1</dt><dd><p>content in G + C nucleotides in first position of codon</p>
</dd>
<dt>CG12</dt><dd><p>content in G + C nucleotides in first and second position of codon</p>
</dd>
<dt>CG2</dt><dd><p>content in G + C nucleotides in second position of codon</p>
</dd>
<dt>CG3</dt><dd><p>content in G + C nucleotides in third position of codon</p>
</dd>
<dt>CGN</dt><dd><p>content in CGA + CGU + CGA + CGG</p>
</dd>
<dt>F1</dt><dd><p>From Table 2 in Lobry, J.R., Gautier, C. (1994) Hydrophobicity,
expressivity and aromaticity are the major trends of amino-acid usage in
999 <em>Escherichia coli</em> chromosome-encode genes. <em>Nucleic Acids
Research</em>,<b>22</b>:3174-3180.</p>
</dd>
<dt>G3</dt><dd><p>content in G nucleotides in third position of codon</p>
</dd>
<dt>KD</dt><dd><p>Kyte, J., Doolittle, R.F. (1982) A simple method for displaying
the hydropathic character of a protein. <em>J. Mol. Biol.</em>,<b>157</b>
:105-132.</p>
</dd>
<dt>Q</dt><dd><p>content in quartet</p>
</dd>
<dt>QA3</dt><dd><p>content in quartet with the A nucleotide in third position</p>
</dd>
<dt>QC3</dt><dd><p>content in quartet with the A nucleotide in third position</p>
</dd>
<dt>U</dt><dd><p>content in U nucleotide</p>
</dd>
<dt>U3</dt><dd><p>content in U nucleotides in third position of codon</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(EXP)
</code></pre>

<hr>
<h2 id='extract.breakpoints'>Extraction of breakpoint positions on the
rearranged nucleotide skews. </h2><span id='topic+extract.breakpoints'></span>

<h3>Description</h3>

<p>Extraction of breakpoint positions on the
rearranged nucleotide skews. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.breakpoints(rearr.ori,
type = c("atfw", "atrev", "gcfw", "gcrev"),
 nbreaks, gridsize = 100, it.max = 500)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.breakpoints_+3A_rearr.ori">rearr.ori</code></td>
<td>
<p>A data frame obtained with the <code>rearranged.oriloc</code>
function.  </p>
</td></tr>
<tr><td><code id="extract.breakpoints_+3A_type">type</code></td>
<td>
<p>The type of skew for which to extract the breakpoints; must
be a subset of <code>c("atfw","atrev","gcfw","gcrev")</code>.</p>
</td></tr>
<tr><td><code id="extract.breakpoints_+3A_nbreaks">nbreaks</code></td>
<td>
<p>The number of breakpoints to extract for each type of
skew. Provide a vector of the same length as <code>type</code>.</p>
</td></tr>
<tr><td><code id="extract.breakpoints_+3A_gridsize">gridsize</code></td>
<td>
<p>To make sure that the best breakpoints are found, and to
avoid finding only a local extremum of the likelihood and residual sum
of square functions, a grid search is performed. The search for
breakpoints is repeated <code>gridsize</code> times, with different starting
values for the breakpoints. </p>
</td></tr>
<tr><td><code id="extract.breakpoints_+3A_it.max">it.max</code></td>
<td>
<p>The maximum number of iterations to be performed when
searching for the breakpoints. This argument corresponds to the
<code>it.max</code> argument in <code>segmented</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method uses the <code>segmented</code> function in the <code>segmented</code>
package to extract the breakpoints positions in the rearranged
nucleotide skews obtained with the <code>rearranged.oriloc</code> function.
To make sure that the best breakpoints are found, and to
avoid finding only a local extremum of the likelihood and residual sum
of square functions, a grid search is performed. The search for
breakpoints is repeated <code>gridsize</code> times, with different starting
values for the breakpoints. 
</p>


<h3>Value</h3>

<p>This function returns a list, with as many elements as the <code>type</code>
argument (for example <code>$gcfw</code> will contain the results for the
rearranged GC-skew, for forward-encoded genes). Each element of this list is also a list, containing the
following information: in  <code>$breaks</code> the position of the breakpoints on the
rearranged chromosome; in  <code>$slopes.left</code> the slopes of the
segments on the left side of each breakpoint; in  <code>$slopes.right</code> the slopes of the
segments on the right side of each breakpoint; in <code>$real.coord</code>,
the coordinates of the breakpoints on the real chromosome (before rearrangement).
</p>


<h3>Author(s)</h3>

<p>A. Necşulea</p>


<h3>References</h3>

<p><code>citation("segmented")</code>
</p>
<p>Necşulea, A. and Lobry, J.R. (in prep) A novel method for assessing
the effect of replication on DNA base composition asymmetry.
<em>Molecular Biology and Evolution</em>,<b>24</b>:2169-2179.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+oriloc">oriloc</a></code>, <code><a href="#topic+draw.rearranged.oriloc">draw.rearranged.oriloc</a></code>,
<code><a href="#topic+rearranged.oriloc">rearranged.oriloc</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example for Chlamydia trachomatis ####

### Rearrange the chromosome and compute the nucleotide skews ###

## Not run: r.ori &lt;- rearranged.oriloc(seq.fasta = system.file("sequences/ct.fasta.gz", package = "seqinr"),
    g2.coord = system.file("sequences/ct.coord",package = "seqinr"))
## End(Not run)

### Extract the breakpoints for the rearranged nucleotide skews ###


## Not run: breaks &lt;- extract.breakpoints(r.ori,type = c("gcfw", "gcrev"),
 nbreaks = c(2, 2), gridsize = 50, it.max = 100)
## End(Not run)


### Draw the rearranged nucleotide skews and ###
### place the position of the breakpoints on the graphics ###

## Not run: draw.rearranged.oriloc(r.ori, breaks.gcfw = breaks$gcfw$breaks,
 breaks.gcrev = breaks$gcrev$breaks)
## End(Not run)
</code></pre>

<hr>
<h2 id='extractseqs'>To extract the sequences information of a sequence or a list of sequence in different formats</h2><span id='topic+extractseqs'></span><span id='topic+exseq'></span>

<h3>Description</h3>

<p>The function allows to extract large amount of data as whole genome sequences,using different output formats and types of extraction.
This function is not yet available for windows in zlib mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractseqs(listname,socket = autosocket(), format="fasta",
operation="simple",feature="xx", bounds="xx", minbounds="xx",
 verbose = FALSE, nzlines=1000, zlib = FALSE)
exseq(listname,socket = autosocket(),
 format="fasta",operation="simple", feature="xx",
 bounds="xx", minbounds="xx", verbose = FALSE,  nzlines=1000, zlib = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractseqs_+3A_listname">listname</code></td>
<td>
<p>the name of list on server (may be a virtual list) </p>
</td></tr>
<tr><td><code id="extractseqs_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="extractseqs_+3A_format">format</code></td>
<td>
<p>the format of output.Can be <code>acnuc</code>, <code>fasta</code>,<code>flat</code> or <code>coordinates</code> </p>
</td></tr>
<tr><td><code id="extractseqs_+3A_operation">operation</code></td>
<td>
<p>the type of extraction. Can be  <code>simple</code>, <code>translate</code>, <code>fragment</code>, <code>feature</code> or <code>region</code>  </p>
</td></tr>
<tr><td><code id="extractseqs_+3A_feature">feature</code></td>
<td>
<p>-optional- the feature to be extracted (for operations &quot;feature&quot; or &quot;region&quot;): a feature table item (CDS, mRNA,...)</p>
</td></tr>
<tr><td><code id="extractseqs_+3A_bounds">bounds</code></td>
<td>
<p>-optional- the bounds for extraction (for operations &quot;fragment&quot; or &quot;region&quot;) </p>
</td></tr>
<tr><td><code id="extractseqs_+3A_minbounds">minbounds</code></td>
<td>
<p>-optional- the minimal bounds for extraction (for operations &quot;fragment&quot; or &quot;region&quot;) </p>
</td></tr>
<tr><td><code id="extractseqs_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, verbose mode is on</p>
</td></tr>
<tr><td><code id="extractseqs_+3A_nzlines">nzlines</code></td>
<td>
<p>number of line in zlib mode</p>
</td></tr>
<tr><td><code id="extractseqs_+3A_zlib">zlib</code></td>
<td>
<p>logical. If TRUE sequences are download in zlib compress mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To extract a list of sequences (lrank argument) or a single sequence (seqnum argument)
using different output formats and types of extraction.
All formats except &quot;coordinates&quot; extract sequence data.
Format &quot;coordinates&quot; extract coordinate data; start &gt; end indicates the complementary strand.
</p>

<dl>
<dt><strong>listname</strong></dt><dd><p>sequence list name.</p>
</dd>
<dt><strong>socket</strong></dt><dd><p>a socket of class connection and sockconn returned by <code>choosebank</code>. 
Default value (auto) means that the socket will be set to to the socket component of the banknameSocket variable. </p>
</dd>
<dt><strong>format</strong></dt><dd><p><code>acnuc</code>, <code>fasta</code>, <code>flat</code> or <code>coordinates</code></p>
</dd>
<dt><strong>operation</strong></dt><dd><p><code>simple</code>, <code>translate</code>, <code>fragment</code>, <code>feature</code> or <code>region</code></p>
</dd>
<dt><strong>feature</strong></dt><dd><p>(for operations &quot;feature&quot; or &quot;region&quot;) a feature table item (CDS, mRNA,...).
</p>

<dl>
<dt><em>simple</em></dt><dd><p>each sequence or subsequence is extracted.</p>
</dd>
<dt><em>translate</em></dt><dd><p>meaningful only for protein-coding (sub)sequences that are extracted as protein sequences. Nothing is extracted for non-protein coding sequences.</p>
</dd>
<dt><em>fragment</em></dt><dd><p>Allows to extract any part of the sequence(s) in list.
Such part is specified by the bounds and minbounds arguments according to the syntax suggested by these examples:
</p>

<table>
<tr>
 <td style="text-align: left;">
			  </td><td style="text-align: left;"> 132,1600  </td><td style="text-align: left;"> to extract from nucl. 132 to nucl 1600 of the sequence. If applied to a subsequence, coordinates are in the parent seq relatively to the subsequence start point.</td>
</tr>
<tr>
 <td style="text-align: left;">
			  </td><td style="text-align: left;"> -10,10    </td><td style="text-align: left;"> to extract from 10 nucl. BEFORE the 5' end of the sequence to nucl. 10 of it. Useful only for subsequences, and produces a fragment extracted from its parent sequence.</td>
</tr>
<tr>
 <td style="text-align: left;">
			  </td><td style="text-align: left;"> e-20,e+10 </td><td style="text-align: left;"> to extract from 20 nucl. BEFORE the 3' end of the sequence to 10 nucl. AFTER its 3' end. Useful only for subsequences, and  produces a fragment extracted from its parent sequence.</td>
</tr>
<tr>
 <td style="text-align: left;">
			  </td><td style="text-align: left;"> -20,e+5   </td><td style="text-align: left;"> to extract from 20 nucl. BEFORE the 5' end of the sequence to 5 nucl. AFTER its 3' end.
			</td>
</tr>

</table>

</dd>
</dl>
</dd>
<dt><strong>bounds</strong></dt><dd><p>(for operations &quot;fragment&quot; or &quot;region&quot;) see syntax above.</p>
</dd>
<dt><strong>minbounds</strong></dt><dd><p>same syntax as bounds. When the sequence data is too short for this quantity
to be extracted, nothing is extracted. When the sequence data is between minbounds and bounds,
extracted sequence data is extended by N's to the desired length.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Sequence data.
</p>


<h3>Author(s)</h3>

<p>S. Penel</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, 
<code><a href="#topic+query">query</a></code>
<code><a href="#topic+getlistrank">getlistrank</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: # Need internet connection
 choosebank("emblTP")
 mylist &lt;- query("mylist", "k=globin", virtual = TRUE)
 mylist.fasta &lt;- exseq("mylist", verbose = TRUE)
 # 103 lines of FASTA 
 stopifnot(length(mylist.fasta) == 103)
 closebank()
 
## End(Not run)
</code></pre>

<hr>
<h2 id='fasta'>Example of results obtained after a call to read.alignment</h2><span id='topic+fasta'></span>

<h3>Description</h3>

<p>This data set gives an example of a amino acids alignment obtained after a call to the function read.alignment on an alignment file in &quot;fasta&quot; format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fasta)</code></pre>


<h3>Format</h3>

<p>A List of class alignment</p>


<h3>Source</h3>

<p>https://pbil.univ-lyon1.fr/help/formats.html/</p>


<h3>References</h3>

<p>Pearson W.R. and Lipman D.J. (1988) <em>Improved tools for biological sequence comparison.</em>.Proc Natl Acad Sci U S A. 85(8):2444-8.</p>

<hr>
<h2 id='fastacc'>Fast Allele in Common Count</h2><span id='topic+fastacc'></span>

<h3>Description</h3>

<p>The purpose of this function is to compute as fast as possible the number
of allele in common between a target (typically the genetic profile observed at a
crime scene, possibly a mixture with dropouts) and a database reference (typically
genetic profile of individuals). Both are assumed to be pre-encoded at the bit
level in a consistent way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastacc(target, database)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastacc_+3A_target">target</code></td>
<td>
<p>the <code><a href="base.html#topic+raw">raw</a></code> encoding of the target, typically 40 octets for a core-CODIS profile in 2009</p>
</td></tr>
<tr><td><code id="fastacc_+3A_database">database</code></td>
<td>
<p>the <code><a href="base.html#topic+raw">raw</a></code> encoding of the database. If there are n entries
in the database, then the database must n times longer than the target.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an RFC state. Comments are welcome.
</p>
<p>Genetic profiles are encoded at the bit level. One bit represents one allele.
Count is based on a logical AND at bit level. Bit count is encoded at C level
using the precomputed approach: one indirection with an auxiliary table
of size 256 called <code>bits_in_char</code> which is pre-computed at R level and
passed at C level.
</p>


<h3>Value</h3>

<p>A vector of <code><a href="base.html#topic+integer">integer</a></code> giving for each entry in the database how many
alleles are in common between the entry and the target.
</p>


<h3>Warning </h3>

<p>Experimental, first release schedulded for seqinr  2.0-6 by the end of 2009</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>FIXME
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# NOTE:
#
# This example section is a proof-of-concept stuff. Most code should be
# enbeded in documented functions to avoid verbosity. But at the RFC stage
# this is perhaps not a too bad idea to show how powerfull R is.
#

#
# Let's start from the 16 loci available in the AmpFLSTR kit:
#

path &lt;- system.file("abif/AmpFLSTR_Bins_v1.txt", package = "seqinr")
resbin &lt;- readBins(path)
codis &lt;- resbin[["Identifiler_CODIS_v1"]]
names(codis)

#
# We count how many different alleles are present per locus:
#

na &lt;- unlist(lapply(codis, function(x) length(x[[1]])))
na

#
# The number of octets required to encode a genetic for each locus is then:
#

ceiling(na/8)

#
# We need then a total of 40 octets to code these profiles:
#

sum(ceiling(na/8))

#
# Let's definene a function to encode a profile at a given locus, and vice versa :
#

prof2raw &lt;- function(profile, alleles) {
  if (!is.ordered(alleles)) stop("ordered factor expected for alleles")
  if (!is.character(profile)) stop("vector of character expected for profile")
  noctets &lt;- ceiling(length(alleles)/8)
  res.b &lt;- rawToBits(raw(noctets))
  for (i in 1:length(profile)) {
    res.b[which(profile[i] == alleles)] &lt;- as.raw(1)
  }
  return(packBits(res.b, type = "raw"))
}

raw2prof &lt;- function(rawdata, alleles) {
  if (!is.ordered(alleles)) stop("ordered factor expected for alleles")
  if (!is.raw(rawdata)) stop("vector of raw expected for rawdata")
  res &lt;- as.character(alleles)[as.logical(rawToBits(rawdata))]
  return(paste(res, collapse = ", "))
}

#
# Let now code all alleles present in codis as ordered factors:
#

allalleles &lt;- lapply(codis, function(x) factor(x[, 1], levels = x[, 1], ordered = TRUE))

#
# Let's play with our encoding/decoding utilities with first locus:
#

allalleles[[1]] #  &lt;8 8 9 10 11 12 13 14 15 16 17 18 19 &gt;19
res &lt;- prof2raw(c("8", "9", "13", "14", "&gt;19"), allalleles[[1]])
res # c6 20
rawToBits(res) # 00 01 01 00 00 00 01 01 00 00 00 00 00 01 00 00
raw2prof(res, allalleles[[1]]) #  "8, 9, 13, 14, &gt;19"

#
# Let define a profile with all possible alleles:
#

ladder &lt;- unlist(lapply(allalleles, function(x) prof2raw(as.character(x),x)))
names(ladder) &lt;- NULL
stopifnot(identical(as.integer(ladder), 
 c(255L, 63L, 255L, 255L, 255L, 63L, 255L, 63L, 255L, 31L, 255L, 
 63L, 255L, 255L, 7L, 255L, 3L, 255L, 63L, 255L, 255L, 255L, 255L, 
 15L, 255L, 127L, 255L, 3L, 255L, 255L, 255L, 255L, 3L, 3L, 255L, 
 15L, 255L, 255L, 255L, 7L))) # simple sanity check

#
# Let's make a simulated database. Here we use a random sampling
# with a uniform distribution between all possible profile possible
# at a given locus. A more realist sampling for an individual database
# would be to sample only two alleles at each locus according to
# observed frequencies in populations. 
#

n &lt;- 10^5 # the number of records in the database
DB &lt;- sapply(ladder, function(x) as.raw(sample(0:as.integer(x), size = n, replace = TRUE)))

#
# Now we make sure that the target is in the database:
#

target &lt;- DB[666, ]
DB &lt;- as.vector(t(DB)) # put DB as a flat database (is it usefull?) 

#
# Now we compute the number of alleles in common between the
# target and all the entries in the DB:
#

system.time(res &lt;- fastacc(target,DB)) # Fast, isn't it ?
stopifnot(which.max(res) == 666) # sanity check

#
# Don't run : too tedious for routine check. We check here that complexity is
# linear in time up to a 10 10^6 database size (roughly the size of individual
# profiles at the EU level)
#

## Not run: 
maxn &lt;- 10^7
DB &lt;- sapply(ladder, function(x) as.raw(sample(0:as.integer(x),
  size = maxn, replace = T)))
target &lt;- DB[666, ]
DB &lt;- as.vector(t(DB))

np &lt;- 10
nseq &lt;- seq(from = 10^5, to = maxn, length = np)
res &lt;- numeric(np)
i &lt;- 1
for (n in nseq) {
  print(i)
  res[i] &lt;- system.time(tmp &lt;- fastacc(target, DB[1:n]))[1]
  stopifnot(which.max(tmp) == 666)
  i &lt;- i + 1
}
dbse &lt;- data.frame(list(nseq = nseq, res = res))

x &lt;- dbse$nseq
y &lt;- dbse$res
plot(x, y, type = "b", xlab = "Number of entries in DB", ylab = "One query time [s]",
las = 1, xlim = c(0, maxn), ylim = c(0, max(y)), main = "Data base size effect on query time")
lm1 &lt;- lm(y ~ x - 1)
abline(lm1, col = "red")
legend("topleft", inset = 0.01, legend = paste("y =", formatC(lm1$coef[1],
digits = 3), "x"), col = "red", lty = 1)

#
# On my laptop the slope is 2.51e-08, that is a 1/4 of second to scan a database
# with 10 10^6 entries.
#

## End(Not run)

## end
</code></pre>

<hr>
<h2 id='G+2BC+20Content'>Calculates the fractional G+C content of nucleic acid sequences.</h2><span id='topic+GC'></span><span id='topic+GC1'></span><span id='topic+GC2'></span><span id='topic+GC3'></span><span id='topic+GCpos'></span>

<h3>Description</h3>

<p>Calculates the fraction of G+C bases of the input nucleic acid
sequence(s). It reads in nucleic acid sequences, sums the number of
'g' and 'c' bases and writes out the result as the fraction (in the
interval 0.0 to 1.0) to the total number of 'a', 'c', 'g' and 't' bases.
Global G+C content <code>GC</code>, G+C in the first position of the codon bases
<code>GC1</code>, G+C in the second position of the codon bases
<code>GC2</code>, and G+C in the third position of the codon bases
<code>GC3</code> can be computed. All functions can take ambiguous bases
into account when requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GC(seq, forceToLower = TRUE, exact = FALSE, NA.GC = NA, oldGC = FALSE,
alphabet = s2c("acgtswmkryvhdb"))
GC1(seq, frame = 0, ...)
GC2(seq, frame = 0, ...)
GC3(seq, frame = 0, ...)
GCpos(seq, pos, frame = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G+2B2BC+2B20Content_+3A_seq">seq</code></td>
<td>
<p>a nucleic acid sequence as a vector of single characters</p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_frame">frame</code></td>
<td>
<p>for coding sequences, an integer (0, 1, 2) giving the frame</p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_forcetolower">forceToLower</code></td>
<td>
<p>logical. if <code>TRUE</code>  force sequence
characters in lower-case. Turn this to <code>FALSE</code> to save time
if your sequence is already in lower-case (cpu time is approximately
divided by 3 when turned off)</p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_exact">exact</code></td>
<td>
<p>logical: if <code>TRUE</code> ambiguous bases are taken
into account when computing the G+C content (see details).
Turn this to <code>FALSE</code> to save time if your you can neglect
ambiguous bases in your sequence (cpu time is approximately
divided by 3 when turned off)
</p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_na.gc">NA.GC</code></td>
<td>
<p>what should be returned when the GC is impossible to
compute from data, for instance with NNNNNNN. This behaviour could
be different when argument <code>exact</code> is <code>TRUE</code>, for instance
the G+C content of WWSS is <code>NA</code> by default, but is 0.5 when
<code>exact</code> is set to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_...">...</code></td>
<td>
<p>arguments passed to the function <code>GC</code></p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_pos">pos</code></td>
<td>
<p>for coding sequences, the codon position (1, 2, 3) that should be
taken into account to compute the G+C content</p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_oldgc">oldGC</code></td>
<td>
<p>logical defaulting to <code>FALSE</code>: should the GC content computed
as in seqinR &lt;= 1.0-6, that is as the sum of 'g' and 'c' bases divided by
the length of the sequence. As from seqinR &gt;= 1.1-3, this argument is
deprecated and a warning is issued.</p>
</td></tr>
<tr><td><code id="G+2B2BC+2B20Content_+3A_alphabet">alphabet</code></td>
<td>
<p>alphabet used. This allows you to choose ambiguous bases used
during GC calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>exact</code> is set to <code>TRUE</code> the G+C content is estimated
with ambiguous bases taken into account. Note that this is time expensive.
A first pass is made on non-ambiguous bases to estimate the probabilities
of the four bases in the sequence. They are then used to weight the
contributions of ambiguous bases to the G+C content. Let note nx
the total number of base 'x' in the sequence. For instance
suppose that there are nb bases 'b'. 'b' stands for &quot;not a&quot;, that
is for 'c', 'g' or 't'. The contribution of 'b' bases to the GC base
count will be:
</p>
<p>nb*(nc + ng)/(nc + ng + nt)
</p>
<p>The contribution of 'b' bases to the AT base count will be:
</p>
<p>nb*nt/(nc + ng + nt)
</p>
<p>All ambiguous bases contributions to the AT and GC counts are weighted
is similar way and then the G+C content is computed as ngc/(nat + ngc).
</p>


<h3>Value</h3>

<p><code>GC</code> returns the fraction of G+C (in [0,1]) as a numeric vector of length one.
<code>GCpos</code> returns GC at position <code>pos</code>.
<code>GC1</code>, <code>GC2</code>, <code>GC3</code> are wrappers for <code>GCpos</code> with the
argument <code>pos</code> set to 1, 2, and 3, respectively.
<code>NA</code> is returned when <code>seq</code> is <code>NA</code>.
<code>NA.GC</code> defaulting to <code>NA</code> is returned when the G+C content
can not be computed from data.
</p>


<h3>Author(s)</h3>

<p>D. Charif, L. Palmeira, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>.
</p>
<p>The program codonW used here for comparison is available at
<a href="https://codonw.sourceforge.net/">https://codonw.sourceforge.net/</a>.
</p>


<h3>See Also</h3>

<p>You can use <code><a href="#topic+s2c">s2c</a></code> to convert a string into a vetor of single
character and <code><a href="base.html#topic+tolower">tolower</a></code> to convert upper-case characters into
lower-case characters. Do not confuse with <code><a href="base.html#topic+gc">gc</a></code> for garbage collection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   mysequence &lt;- s2c("agtctggggggccccttttaagtagatagatagctagtcgta")
   GC(mysequence)  # 0.4761905
   GC1(mysequence) # 0.6428571
   GC2(mysequence) # 0.3571429
   GC3(mysequence) # 0.4285714
#
# With upper-case characters:
#
  myUCsequence &lt;- s2c("GGGGGGGGGA")
  GC(myUCsequence) # 0.9
#
# With ambiguous bases:
#
  GC(s2c("acgt")) # 0.5
  GC(s2c("acgtssss")) # 0.5
  GC(s2c("acgtssss"), exact = TRUE) # 0.75
#
# Missing data:
#
  stopifnot(is.na(GC(s2c("NNNN"))))
  stopifnot(is.na(GC(s2c("NNNN"), exact = TRUE)))
  stopifnot(is.na(GC(s2c("WWSS"))))
  stopifnot(GC(s2c("WWSS"), exact = TRUE) == 0.5)
#
# Coding sequences tests:
#
  cdstest &lt;- s2c("ATGATG")
  stopifnot(GC3(cdstest) == 1)
  stopifnot(GC2(cdstest) == 0)
  stopifnot(GC1(cdstest) == 0)
#
# How to reproduce the results obtained with the C program codonW
# version 1.4.4 writen by John Peden. We use here the "input.dat"
# test file from codonW (there are no ambiguous base in these
# sequences).
#
  inputdatfile &lt;- system.file("sequences/input.dat", package = "seqinr")
  input &lt;- read.fasta(file = inputdatfile) # read the FASTA file
  inputoutfile &lt;- system.file("sequences/input.out", package = "seqinr")
  input.res &lt;- read.table(inputoutfile, header = TRUE) # read codonW result file
#
# remove stop codon before computing G+C content (as in codonW)
#
  GC.codonW &lt;- function(dnaseq, ...){
  	 GC(dnaseq[seq_len(length(dnaseq) - 3)], ...)
  }
  input.gc &lt;- sapply(input, GC.codonW, forceToLower = FALSE)
  max(abs(input.gc - input.res$GC)) # 0.0004946237

  plot(x = input.gc, y = input.res$GC, las = 1,
  xlab = "Results with GC()", ylab = "Results from codonW",
  main = "Comparison of G+C content results")
  abline(c(0, 1), col = "red")
  legend("topleft", inset = 0.01, legend = "y = x", lty = 1, col = "red")
## Not run: 
# Too long for routine check
# This is a benchmark to compare the effect of various parameter
# setting on computation time
n &lt;- 10
from &lt;-10^4
to &lt;- 10^5
size &lt;- seq(from = from, to = to, length = n)
res &lt;- data.frame(matrix(NA, nrow = n, ncol = 5))
colnames(res) &lt;- c("size", "FF", "FT", "TF", "TT")
res[, "size"] &lt;- size

for(i in seq_len(n)){
  myseq &lt;- sample(x = s2c("acgtws"), size = size[i], replace = TRUE)
  res[i, "FF"] &lt;- system.time(GC(myseq, forceToLower = FALSE, exact = FALSE))[3]
  res[i, "FT"] &lt;- system.time(GC(myseq, forceToLower = FALSE, exact = TRUE))[3]
  	res[i, "TF"] &lt;- system.time(GC(myseq, forceToLower = TRUE, exact = FALSE))[3]
  	res[i, "TT"] &lt;- system.time(GC(myseq, forceToLower = TRUE, exact = TRUE))[3]
}

par(oma = c(0,0,2.5,0), mar = c(4,5,0,2) + 0.1, mfrow = c(2, 1))
plot(res$size, res$TT, las = 1,
xlab = "Sequence size [bp]",
ylim = c(0, max(res$TT)), xlim = c(0, max(res$size)), ylab = "")
title(ylab = "Observed time [s]", line = 4)
abline(lm(res$TT~res$size))
points(res$size, res$FT, col = "red")
abline(lm(res$FT~res$size), col = "red", lty = 3)
points(res$size, res$TF, pch = 2)
abline(lm(res$TF~res$size))
points(res$size, res$FF, pch = 2, col = "red")
abline(lm(res$FF~res$size), lty = 3, col = "red")


legend("topleft", inset = 0.01,
 legend = c("forceToLower = TRUE", "forceToLower = FALSE"),
  col = c("black", "red"), lty = c(1,3))
legend("bottomright", inset = 0.01, legend = c("exact = TRUE", "exact = FALSE"),
pch = c(1,2))

mincpu &lt;- lm(res$FF~res$size)$coef[2]

barplot(
c(lm(res$FF~res$size)$coef[2]/mincpu,
  lm(res$TF~res$size)$coef[2]/mincpu,
  lm(res$FT~res$size)$coef[2]/mincpu,
  lm(res$TT~res$size)$coef[2]/mincpu),
horiz = TRUE, xlab = "Increase of CPU time",
col = c("red", "black", "red", "black"),
names.arg = c("(F,F)", "(T,F)", "(F,T)", "(T,T)"), las = 1)
title(ylab = "forceToLower,exact", line = 4)

mtext("CPU time as function of options", outer = TRUE, line = 1, cex = 1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='gb2fasta'>Conversion of GenBank file into fasta file</h2><span id='topic+gb2fasta'></span>

<h3>Description</h3>

<p>Converts a single entry in GenBank format into a fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gb2fasta(source.file, destination.file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gb2fasta_+3A_source.file">source.file</code></td>
<td>
<p> GenBank file </p>
</td></tr>
<tr><td><code id="gb2fasta_+3A_destination.file">destination.file</code></td>
<td>
<p> Fasta file </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple entries in GenBank file are not supported.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+oriloc">oriloc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  myGenBankFile &lt;- system.file("sequences/ct.gbk.gz", package = "seqinr")
  #myFastaFileName &lt;- "Acinetobacter_ADP1_uid61597.fasta"
  myFastaFileName &lt;-tempfile(pattern = "Acinetobacter_ADP1_uid61597", 
   tmpdir = tempdir(), fileext = "fasta")
  tempdir(check = FALSE)
  gb2fasta(myGenBankFile, myFastaFileName)
  readLines(myFastaFileName)[1:5]
  #
  # Should be :
  #
  # [1] "&gt;CHLTCG 1042519 bp"                                          
  # [2] "gcggccgcccgggaaattgctaaaagatgggagcaaagagttagagatctacaagataaa"
  # [3] "ggtgctgcacgaaaattattaaatgatcctttaggccgacgaacacctaattatcagagc"
  # [4] "aaaaatccaggtgagtatactgtagggaattccatgttttacgatggtcctcaggtagcg"
  # [5] "aatctccagaacgtcgacactggtttttggctggacatgagcaatctctcagacgttgta"
  #
</code></pre>

<hr>
<h2 id='gbk2g2'> Conversion of a GenBank format file into a glimmer-like one </h2><span id='topic+gbk2g2'></span>

<h3>Description</h3>

<p>This function reads a file in GenBank format and converts the features
corresponding to CDS (Coding Sequences) into a format similar to
glimmer program output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbk2g2(gbkfile =  "https://pbil.univ-lyon1.fr/datasets/seqinr/data/ct.gbk",
g2.coord = "g2.coord")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbk2g2_+3A_gbkfile">gbkfile</code></td>
<td>
<p> The name of the GenBank file </p>
</td></tr>
<tr><td><code id="gbk2g2_+3A_g2.coord">g2.coord</code></td>
<td>
<p> The name of the output file in glimmer-like format </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partial CDS (either 5' or 3') and join in features are discarded.
</p>


<h3>Value</h3>

<p>The input file is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+oriloc">oriloc</a></code> which uses glimmer-like files,
<code><a href="#topic+gbk2g2.euk">gbk2g2.euk</a></code> for eukaryotic sequences with introns.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run:  # need internet connection
  	suppressWarnings(gbk2g2(g2.coord = "gbk2g2.test"))
  	res &lt;- read.table("gbk2g2.test")
  	head(res)
  	stopifnot(nrow(res) == 892)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='gbk2g2.euk'> Conversion of a GenBank format file into a glimmer-like
one. Eukaryotic version.</h2><span id='topic+gbk2g2.euk'></span>

<h3>Description</h3>

<p>This function reads a file in GenBank format and converts the features
corresponding to CDS (Coding Sequences) into a format similar to
glimmer program output. This function is specifically made for
eukaryotic sequences, i.e. with introns. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbk2g2.euk(gbkfile = system.file("sequences/ame1.gbk", package ="seqinr"),
g2.coord = "g2.coord")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbk2g2.euk_+3A_gbkfile">gbkfile</code></td>
<td>
<p> The name of the GenBank file </p>
</td></tr>
<tr><td><code id="gbk2g2.euk_+3A_g2.coord">g2.coord</code></td>
<td>
<p> The name of the output file </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the coordinates of the exons annotated in the
GenBank format file. 
</p>


<h3>Value</h3>

<p>A data frame with three columns will be written to the <code>g2.coord</code>
file. The first column corresponds to the name of the gene, given in the
GenBank file through the <code>/gene</code> feature. The second and third
column contain the start and the stop position of the exon.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry, A. Necşulea</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+oriloc">oriloc</a></code>, <code><a href="#topic+gbk2g2">gbk2g2</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run:  gbk2g2.euk() 
</code></pre>

<hr>
<h2 id='gcO2'>GC content and aerobiosis in bacteria</h2><span id='topic+gcO2'></span>

<h3>Description</h3>

<p>This data set was used in Naya <em>et al.</em> (2002) to study the relationship between the genomic G+C content of bacteria and whether they are (stricly) aerobes or anaerobes.
</p>


<h3>Format</h3>

<p><code>gcO2</code> is a data frame.  
</p>


<h3>Source</h3>

<p>Naya, H., Romero, H., Zavala, A., Alvarez, B. and Musto, H. (2002) Aerobiosis increases the Genomic Guanine Plus Cytosine Content (GC
</p>
<p>Data imported into seqinr by J.R. Lobry on 09-OCT-2016. Original source location given in the article was <code>http://oeg.fcien.edu.uy/GCprok/</code> but is no more active. Data were copied at <a href="http://pbil.univ-lyon1.fr/R/donnees/gcO2.txt">http://pbil.univ-lyon1.fr/R/donnees/gcO2.txt</a> (<em>cf.</em> section 2.1 in Lobry, J.R (2004) Life history traits and genome structure: aerobiosis and G+C content in bacteria. <em>Lecture Notes in Computer Sciences</em>, <b>3039</b>:679-686). Import was from this last ressource. There are 130 aerobic genera in this data set while fig. 1 in Naya <em>et al.</em> (2002) gives 126. There is no way to track down the reason for this difference because the original data set was lost (Héctor Musto pers. comm.). The number of anaerobic genera (n = 69) is consistent between the present data set and fig. 1 in Naya <em>et al.</em> (2002).
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gcO2)
</code></pre>

<hr>
<h2 id='gcT'>GC content and temperature in bacteria</h2><span id='topic+gcT'></span>

<h3>Description</h3>

<p>This data set was used in Galtier and Lobry (1997) to study the relationship between the optimal growth temperature of bacteria and their G+C content at the genomic level and locally were selection is active to maintain secondary structures in the stems of RNAs.
</p>


<h3>Format</h3>

<p><code>gcT</code> is a list containing the 9 following components:  
</p>
	
<dl>
<dt>species</dt><dd><p>is a data frame containing the optimal growth temperature and genomic G+C content for 772 bacterial species. Detailled explanations for this table and the following are available in the <code>README</code> component.</p>
</dd>
<dt>genus</dt><dd><p>is a data frame containing the optimal growth temperature and genomic G+C content for 224 bacterial genus.</p>
</dd>
<dt>details</dt><dd><p>is a data frame with more information, see <code>README</code>.</p>
</dd>
<dt>gc16S</dt><dd><p>is a data frame containing the optimal growth temperature and stems G+C content for 16S RNA from 165 bacterial genus.</p>
</dd>
<dt>gctRNA</dt><dd><p>is a data frame containing the optimal growth temperature and stems G+C content for tRNA from 51 bacterial genus.</p>
</dd>
<dt>gc23S</dt><dd><p>is a data frame containing the optimal growth temperature and stems G+C content for 23S RNA from 38 bacterial genus.</p>
</dd>
<dt>gc5S</dt><dd><p>is a data frame containing the optimal growth temperature and stems G+C content for 5S RNA from 71 bacterial genus.</p>
</dd>
<dt>README</dt><dd><p>is the original README file from <code>ftp://biom3.univ-lyon1.fr/pub/datasets/JME97/</code> last updated 13-MAY-2002.</p>
</dd>
<dt>importgcT</dt><dd><p>is the R script used to import data.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Galtier, N. &amp; Lobry, J.R. (1997). Relationships between genomic G+C 
content, RNA secondary structures, and optimal growth temperature 
in prokaryotes. <em>Journal of Molecular Evolution</em> <b>44</b>:632-636.<br />
</p>
<p>Data imported into seqinr with the R script given in the last component of the dataset by J.R. Lobry on 09-OCT-2016. 
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gcT)
</code></pre>

<hr>
<h2 id='get.db.growth'> Get the exponential growth of nucleic acid database content </h2><span id='topic+get.db.growth'></span><span id='topic+dia.db.growth'></span>

<h3>Description</h3>

<p>Connects to the embl database to read the last release note about
the number of nucleotides in the DDBJ/EMBL/Genbank database content.
A log-linear fit is represented by dia.bd.gowth() with an estimate of
the doubling time in months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.db.growth(
where = "ftp://ftp.ebi.ac.uk/pub/databases/embl/doc/relnotes.txt")
dia.db.growth( get.db.growth.out = get.db.growth(), Moore = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.db.growth_+3A_where">where</code></td>
<td>
<p> the file containig the database growth table.</p>
</td></tr>
<tr><td><code id="get.db.growth_+3A_get.db.growth.out">get.db.growth.out</code></td>
<td>
<p> the output from get.db.growth() </p>
</td></tr>
<tr><td><code id="get.db.growth_+3A_moore">Moore</code></td>
<td>
<p> logical, if TRUE add lines corresponding to an
exponential growth rate with a doubling time of 18 months, that
is Moore's law.</p>
</td></tr>
<tr><td><code id="get.db.growth_+3A_...">...</code></td>
<td>
<p>further arguments to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a screenshot from fig. 1 in Lobry (2004):
</p>
<p><img src="../help/figures/lncs2004.pdf" width=400 alt="lncs2004.pdf" />

</p>
<p>At that time the doubling time was 16.9 months. This is an
update in 2016 from release 3.1-5 of the seqinr tutorial
<a href="https://seqinr.r-forge.r-project.org/seqinr_3_1-5.pdf">https://seqinr.r-forge.r-project.org/seqinr_3_1-5.pdf</a>:
</p>
<p><img src="../help/figures/introduction-dbg.pdf" width=400 alt="introduction-dbg.pdf" />

</p>
<p>The doubling time was 18.8 monts in this update. The fit to
Moore's law is still striking over such a long period.
</p>


<h3>Value</h3>

<p>A dataframe with the statistics from the embl site.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><a href="https://www.ebi.ac.uk/ena/browser/">https://www.ebi.ac.uk/ena/browser/</a>
</p>
<p>Lobry, J.R. (2004) Life History Traits and Genome Structure:
Aerobiosis and G+C Content in Bacteria. <em>Lectures Notes in Computer Sciences</em>,
<b>3039</b>:679-686.
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  data &lt;- get.db.growth()
  dia.db.growth(data)

## End(Not run)</code></pre>

<hr>
<h2 id='getAnnot'>Generic Function to get sequence annotations</h2><span id='topic+getAnnot'></span><span id='topic+getAnnot.default'></span><span id='topic+getAnnot.list'></span><span id='topic+getAnnot.SeqAcnucWeb'></span><span id='topic+getAnnot.SeqFastadna'></span><span id='topic+getAnnot.SeqFastaAA'></span><span id='topic+getAnnot.qaw'></span><span id='topic+getAnnot.logical'></span><span id='topic+readAnnots.socket'></span>

<h3>Description</h3>

<p>Annotations are taken from the <code>Annot</code> attribute for sequences
imported from a FASTA file and retrieved from an ACNUC server for
objects of the <code>SeqAcnucWeb</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnnot(object, ...)
## S3 method for class 'SeqAcnucWeb'
getAnnot(object, ..., nbl = 100, socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAnnot_+3A_object">object</code></td>
<td>
<p> an object of the class <code>SeqAcnucWeb</code>
or <code>SeqFastadna</code>, or <code>SeqFastaAA</code> or a list of these objects </p>
</td></tr>
<tr><td><code id="getAnnot_+3A_nbl">nbl</code></td>
<td>
<p> the maximum number of line of annotation to read. Reading of 
lines stops when nbl lines have been transmitted or at the last annotation 
line of the sequence (SQ or ORIGIN line). </p>
</td></tr>
<tr><td><code id="getAnnot_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="getAnnot_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getAnnot</code> returns a vector of string of characters containing the
annotations for the sequences.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+query">query</a></code>, <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, <code><a href="#topic+c2s">c2s</a></code>, <code><a href="#topic+translate">translate</a></code> and <code><a href="#topic+prepgetannots">prepgetannots</a></code> to select the annotation lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getAnnot generic function:
#
   methods(getAnnot)
#
# SeqAcnucWeb class example:
#
  ## Not run: 
  # Need internet connection
  choosebank("emblTP")
  fc&lt;-query("fc", "sp=felis catus et t=cds et O=mitochondrion et Y&gt;2001 et no k=partial")
  # get the first 5 lines annotating the first sequence:
  annots &lt;- getAnnot(fc$req[[1]], nbl = 5)
  cat(annots, sep = "\n")
  # or use the list method to get them all at once:
  annots &lt;- getAnnot(fc$req, nbl = 5)
  cat(annots, sep = "\n")
  closebank()
  
## End(Not run)
#
# SeqFastaAA class example:
#
   aafile &lt;- system.file("sequences/seqAA.fasta", package = "seqinr")
   sfaa &lt;- read.fasta(aafile, seqtype = "AA")
   getAnnot(sfaa[[1]])
#
# SeqFastadna class example:
#
   dnafile &lt;- system.file("sequences/malM.fasta", package = "seqinr")
   sfdna &lt;- read.fasta(file = dnafile)
   getAnnot(sfdna[[1]])
#
# Example with a FASTA file with multiple entries:
#
  ff &lt;- system.file("sequences/someORF.fsa", package = "seqinr")
  fs &lt;- read.fasta(ff)
  getAnnot(fs) # the list method is used here to get them all at once
#
# Default getAnnot method example. An error is produced because 
# there are no annotations by default:
#
   result &lt;- try(getAnnot(letters))
   stopifnot(!inherits("result", "try-error"))
</code></pre>

<hr>
<h2 id='getFrag'>Generic function to extract sequence fragments</h2><span id='topic+getFrag'></span><span id='topic+getFrag.default'></span><span id='topic+getFrag.list'></span><span id='topic+getFrag.character'></span><span id='topic+getFrag.SeqFrag'></span><span id='topic+getFrag.SeqAcnucWeb'></span><span id='topic+getFrag.SeqFastadna'></span><span id='topic+getFrag.SeqFastaAA'></span><span id='topic+getFrag.qaw'></span><span id='topic+getFrag.logical'></span>

<h3>Description</h3>

<p>getFrag is used to extract the sequence fragment starting at the <code>begin</code> position
and ending at the <code>end</code> position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFrag(object, begin, end, ...)
## S3 method for class 'SeqAcnucWeb'
getFrag(object, begin, end, ..., socket = autosocket(), name = getName(object))
## S3 method for class 'SeqFastadna'
getFrag(object, begin, end, ..., name = getName(object))
## S3 method for class 'SeqFastaAA'
getFrag(object, begin, end, ..., name = getName(object))
## S3 method for class 'SeqFrag'
getFrag(object, begin, end, ..., name = getName(object))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFrag_+3A_object">object</code></td>
<td>
<p> an object of the class <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>
or <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, or <code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code> or <code><a href="#topic+SeqFrag">SeqFrag</a></code> or a list of these objects </p>
</td></tr>
<tr><td><code id="getFrag_+3A_begin">begin</code></td>
<td>
<p> First position of the fragment to extract. This position is included. Numerotation starts at 1.</p>
</td></tr>
<tr><td><code id="getFrag_+3A_end">end</code></td>
<td>
<p> Last position of the fragment to extract. This position is included. </p>
</td></tr>
<tr><td><code id="getFrag_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database by <code><a href="#topic+choosebank">choosebank</a></code>).</p>
</td></tr>
<tr><td><code id="getFrag_+3A_name">name</code></td>
<td>
<p>the sequence name</p>
</td></tr>
<tr><td><code id="getFrag_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getFrag</code> returns an object of class <code><a href="#topic+SeqFrag">SeqFrag</a></code>.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, <code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code>, <code><a href="#topic+SeqFrag">SeqFrag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getFrag generic function:
#
   methods(getFrag)
#
# Example with a DNA sequence from a FASTA file:
#
  dnafile &lt;- system.file("sequences/malM.fasta", package = "seqinr")
  sfdna &lt;- read.fasta(file = dnafile)
  myfrag &lt;- getFrag(sfdna[[1]], begin = 1, end = 10)
  stopifnot(getSequence(myfrag, as.string = TRUE) == "atgaaaatga")
</code></pre>

<hr>
<h2 id='getKeyword'>Generic function to get keywords associated to sequences</h2><span id='topic+getKeyword'></span><span id='topic+getKeyword.default'></span><span id='topic+getKeyword.list'></span><span id='topic+getKeyword.SeqAcnucWeb'></span><span id='topic+getKeyword.qaw'></span><span id='topic+getKeyword.logical'></span>

<h3>Description</h3>

<p>Get keywords from an ACNUC server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKeyword(object, ...)
## S3 method for class 'SeqAcnucWeb'
getKeyword(object, ..., socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getKeyword_+3A_object">object</code></td>
<td>
<p> an object of the class <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, or
a list of them, or the object resulting from <code><a href="#topic+query">query</a></code></p>
</td></tr>
<tr><td><code id="getKeyword_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database by <code><a href="#topic+choosebank">choosebank</a></code>).</p>
</td></tr>
<tr><td><code id="getKeyword_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getKeyword</code> returns a vector of strings containing the keyword(s)
associated to a sequence.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getKeyword generic function:
#
   methods(getKeyword)
#
# Example of keyword extraction from an ACNUC server:
#
  ## Not run: 
  # Need internet connection
  choosebank("emblTP")
  fc&lt;-query("fc", "sp=felis catus et t=cds et o=mitochondrion")
  getKeyword(fc$req[[1]])
  # Should be: 
  # [1] "DIVISION ORG" "RELEASE 62"   "CYTOCHROME B" "SOURCE"       "CDS"
  closebank()  

## End(Not run)
</code></pre>

<hr>
<h2 id='getLength'>Generic function to get the length of sequences</h2><span id='topic+getLength'></span><span id='topic+getLength.default'></span><span id='topic+getLength.list'></span><span id='topic+getLength.character'></span><span id='topic+getLength.SeqFrag'></span><span id='topic+getLength.SeqAcnucWeb'></span><span id='topic+getLength.SeqFastadna'></span><span id='topic+getLength.SeqFastaAA'></span><span id='topic+getLength.qaw'></span><span id='topic+getLength.logical'></span>

<h3>Description</h3>

<p>getLength returns the total number of bases or amino-acids in a sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLength(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLength_+3A_object">object</code></td>
<td>
<p> an object of the class <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>
or <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, or <code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code> or <code><a href="#topic+SeqFrag">SeqFrag</a></code> or a list of these objects </p>
</td></tr>
<tr><td><code id="getLength_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getLength</code> returns a numeric vector giving the length of the
sequences.</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, 
<code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code>, <code><a href="#topic+SeqFrag">SeqFrag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getLength generic function:
#
   methods(getLength)
#
# Example with seven DNA sequences from a FASTA file:
#
  ff &lt;- system.file("sequences/someORF.fsa", package = "seqinr")
  fs &lt;- read.fasta(file = ff)
  stopifnot(all(getLength(fs) == c(5573, 5825, 2987, 3929, 2648, 2597, 2780)))
#
# Example with 49 sequences from an ACNUC server:
#
  ## Not run: 
  # Need internet connection
  choosebank("emblTP")
  fc &lt;- query("fc", "sp=felis catus et t=cds et o=mitochondrion")
  getLength(fc)
  closebank()  

## End(Not run)
</code></pre>

<hr>
<h2 id='getlistrank'>To get the rank of a list from its name</h2><span id='topic+getlistrank'></span><span id='topic+glr'></span>

<h3>Description</h3>

<p>This is a low level function to get the rank of a list on server from its name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getlistrank(listname, socket = autosocket(), verbose = FALSE)
glr(listname, socket = autosocket(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getlistrank_+3A_listname">listname</code></td>
<td>
<p>the name of list on server</p>
</td></tr>
<tr><td><code id="getlistrank_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="getlistrank_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, verbose mode is on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low level function is usually not used directly by the user.
</p>


<h3>Value</h3>

<p>The rank of list named <code>listname</code> on server, or 0 if no list with this name exists.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 # Need internet connection
 choosebank("emblTP")
 MyListName &lt;- query("MyListName", "sp=Borrelia burgdorferi", virtual = TRUE)
 (result &lt;- getlistrank("MyListName"))
 stopifnot(result == 2)
 closebank()
 
## End(Not run)
</code></pre>

<hr>
<h2 id='getliststate'>Asks for information about an ACNUC list of specified rank</h2><span id='topic+getliststate'></span><span id='topic+gls'></span><span id='topic+gln'></span>

<h3>Description</h3>

<p>Reply gives the type of list, its name, the number of elements it contains,
and, for sequence lists, says whether the list contains only parent seqs (locus=T).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getliststate(lrank, socket = autosocket())
gls(lrank, socket = autosocket())
gln(lrank, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getliststate_+3A_lrank">lrank</code></td>
<td>
<p>the name of the ACNUC list to modify</p>
</td></tr>
<tr><td><code id="getliststate_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="getliststate_+3A_...">...</code></td>
<td>
<p>arguments passed to getliststate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA in case of problem and an warning is issued. When there is no problem
a list with the following 4 components:
</p>
<table role = "presentation">
<tr><td><code>type</code></td>
<td>
<p>string. Type of ACNUC list (SQ, KW, SP)</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>string. ACNUC list name</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>numeric. Number of elements in ACNUC list</p>
</td></tr>
<tr><td><code>locus</code></td>
<td>
<p>logical. For ACNUC sequence lists TRUE means that the list
contains only parent sequences. NA otherwise.</p>
</td></tr>
</table>
<p><code>gln</code> is a shortcut for <code>getliststate(lrank, ...)$name</code>
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code>, <code><a href="#topic+alr">alr</a></code>,
<code><a href="#topic+glr">glr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "sp=felis catus et t=cds", virtual=TRUE)
  getliststate(glr("mylist")) # SQ, MYLIST, 603, FALSE
  gln(glr("mylist")) # MYLIST (upper case letters on server)
  closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='getLocation'>Generic function to get the location of subsequences on the parent sequence</h2><span id='topic+getLocation'></span><span id='topic+getLocation.default'></span><span id='topic+getLocation.list'></span><span id='topic+getLocation.SeqAcnucWeb'></span><span id='topic+getLocation.qaw'></span><span id='topic+getLocation.logical'></span>

<h3>Description</h3>

<p>This function works only with subsequences from an ACNUC server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocation(object, ...)
## S3 method for class 'SeqAcnucWeb'
getLocation(object, ..., socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLocation_+3A_object">object</code></td>
<td>
<p> an object of the class <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, or a list of them,
or an object created by <code><a href="#topic+query">query</a></code> </p>
</td></tr>
<tr><td><code id="getLocation_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database by <code><a href="#topic+choosebank">choosebank</a></code>).</p>
</td></tr>
<tr><td><code id="getLocation_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list giving the positions of the sequence
on the parent sequence. If the sequence is a subsequence (<em>e.g.</em> coding
sequence), the function returns the position of each exon on the
parent sequence. NA is returned for parent sequences and a warning
is isued.</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getLocation generic function:
#
   methods(getLocation)
#
# Example with a subsequence from an ACNUC server:
#
  ## Not run: 
  # Need internet connection
  choosebank("emblTP")
  fc &lt;- query("fc", "sp=felis catus et t=cds et o=mitochondrion")
  getLocation(fc$req[[5]])
  closebank()  

## End(Not run)
</code></pre>

<hr>
<h2 id='getName'>Generic function to get the names of sequences</h2><span id='topic+getName'></span><span id='topic+getName.default'></span><span id='topic+getName.list'></span><span id='topic+getName.SeqFrag'></span><span id='topic+getName.SeqAcnucWeb'></span><span id='topic+getName.SeqFastadna'></span><span id='topic+getName.SeqFastaAA'></span><span id='topic+getName.qaw'></span><span id='topic+getName.logical'></span>

<h3>Description</h3>

<p>GetName returns the sequence names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getName(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getName_+3A_object">object</code></td>
<td>
<p> an object of the class <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>
or <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, or <code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code> or <code><a href="#topic+SeqFrag">SeqFrag</a></code> or a list of these objects </p>
</td></tr>
<tr><td><code id="getName_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>character</code> containing the names of the sequences</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, 
<code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code>, <code><a href="#topic+SeqFrag">SeqFrag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getName generic function:
#
   methods(getName)
#
# Example with seven DNA sequences from a FASTA file:
#
  ff &lt;- system.file("sequences/someORF.fsa", package = "seqinr")
  fs &lt;- read.fasta(file = ff)
  stopifnot(all(getName(fs) == c("YAL001C", "YAL002W", "YAL003W",
    "YAL005C", "YAL007C", "YAL008W", "YAL009W")))
#
# Example with 49 sequences from an ACNUC server:
#
  ## Not run: 
  # Need internet connection
  choosebank("emblTP")
  fc &lt;- query("fc", "sp=felis catus et t=cds et o=mitochondrion")
  getName(fc)
  closebank()  

## End(Not run)
</code></pre>

<hr>
<h2 id='getSequence'>Generic function to get sequence data</h2><span id='topic+getSequence'></span><span id='topic+getSequence.default'></span><span id='topic+getSequence.list'></span><span id='topic+getSequence.character'></span><span id='topic+getSequence.SeqFrag'></span><span id='topic+getSequence.SeqAcnucWeb'></span><span id='topic+getSequence.SeqFastadna'></span><span id='topic+getSequence.SeqFastaAA'></span><span id='topic+getSequence.qaw'></span><span id='topic+getSequence.logical'></span>

<h3>Description</h3>

<p>getSequence returns the sequence either as vector of single chararacters
or as a single string of multiple characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSequence(object, as.string = FALSE, ...)
## S3 method for class 'SeqAcnucWeb'
getSequence(object, as.string = FALSE, ..., socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSequence_+3A_object">object</code></td>
<td>
<p> an object of the class <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>
or <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, or <code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code> or <code><a href="#topic+SeqFrag">SeqFrag</a></code> or a list of these objects, or an object of class <code>qaw</code> created by <code><a href="#topic+query">query</a></code> </p>
</td></tr>
<tr><td><code id="getSequence_+3A_as.string">as.string</code></td>
<td>
<p>if TRUE sequences are returned as strings of multiple characters
instead of a vector of single characters</p>
</td></tr>
<tr><td><code id="getSequence_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="getSequence_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a single sequence an object of class <code>character</code> containing the characters
of the sequence, either of length 1 when <code>as.string</code> is TRUE, or of the length
of the sequence when <code>as.string</code> is FALSE. For many sequences, a list of these.</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, 
<code><a href="#topic+SeqFastaAA">SeqFastaAA</a></code>, <code><a href="#topic+SeqFrag">SeqFrag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getSequence generic function:
#
   methods(getSequence)
#
# SeqAcnucWeb class example:
#
  ## Not run: # Need internet connection
  choosebank("emblTP")
  fc &lt;- query("fc", "sp=felis catus et t=cds et o=mitochondrion")
  getSequence(fc$req[[1]])
  getSequence(fc$req[[1]], as.string = TRUE)
  closebank()
  
## End(Not run)
#
# SeqFastaAA class example:
#
  aafile &lt;- system.file("sequences/seqAA.fasta", package = "seqinr")
  sfaa &lt;- read.fasta(aafile, seqtype = "AA")
  getSequence(sfaa[[1]])
  getSequence(sfaa[[1]], as.string = TRUE)
#
# SeqFastadna class example:
#
  dnafile &lt;- system.file("sequences/someORF.fsa", package = "seqinr")
  sfdna &lt;- read.fasta(file = dnafile)
  getSequence(sfdna[[1]])
  getSequence(sfdna[[1]], as.string = TRUE)
#
# SeqFrag class example:
#
  sfrag &lt;- getFrag(object = sfdna[[1]], begin = 1, end = 10)
  getSequence(sfrag)
  getSequence(sfrag, as.string = TRUE)
</code></pre>

<hr>
<h2 id='getTrans'>Generic function to translate coding sequences into proteins</h2><span id='topic+getTrans'></span><span id='topic+getTrans.default'></span><span id='topic+getTrans.list'></span><span id='topic+getTrans.character'></span><span id='topic+getTrans.SeqFrag'></span><span id='topic+getTrans.SeqAcnucWeb'></span><span id='topic+getTrans.SeqFastadna'></span><span id='topic+getTrans.qaw'></span><span id='topic+getTrans.logical'></span>

<h3>Description</h3>

<p>This function translates nucleic acid sequences into the corresponding peptide sequence. It can translate in any of the 3 forward or three reverse sense frames. In the case of reverse sense, the reverse-complement of the sequence is taken. It can translate using the standard (universal) genetic code and also with non-standard codes. Ambiguous bases can also be handled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrans(object, sens = "F", NAstring = "X", ambiguous = FALSE, ...)
## S3 method for class 'SeqAcnucWeb'
getTrans(object, sens = "F", NAstring = "X", ambiguous = FALSE, ...,
 frame = "auto", numcode = "auto")
## S3 method for class 'SeqFastadna'
getTrans(object, sens = "F", NAstring = "X", ambiguous = FALSE, ...,
 frame = 0, numcode = 1)
## S3 method for class 'SeqFrag'
getTrans(object, sens = "F", NAstring = "X", ambiguous = FALSE, ...,
 frame = 0, numcode = 1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTrans_+3A_object">object</code></td>
<td>
<p> an object of the class <code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>
or <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, or <code><a href="#topic+SeqFrag">SeqFrag</a></code> or a list of these objects, or an object of class <code>qaw</code> created by <code><a href="#topic+query">query</a></code> </p>
</td></tr>
<tr><td><code id="getTrans_+3A_numcode">numcode</code></td>
<td>
<p> The ncbi genetic code number for translation. By default the standard genetic code is used, and for sequences
coming from an ACNUC server the relevant genetic code is used by default. </p>
</td></tr>
<tr><td><code id="getTrans_+3A_nastring">NAstring</code></td>
<td>
<p> How to translate amino-acids when there are ambiguous bases in codons. </p>
</td></tr>
<tr><td><code id="getTrans_+3A_ambiguous">ambiguous</code></td>
<td>
<p> If TRUE, ambiguous bases are taken into account so that for instance
GGN is translated to Gly in the standard genetic code. </p>
</td></tr>
<tr><td><code id="getTrans_+3A_frame">frame</code></td>
<td>
<p> Frame(s) (0,1,2) to translate. By default the frame <code>0</code> is used. </p>
</td></tr>
<tr><td><code id="getTrans_+3A_sens">sens</code></td>
<td>
<p> Direction for translation: <code>F</code> for the direct strand e and <code>R</code> for the reverse complementary strand. </p>
</td></tr>
<tr><td><code id="getTrans_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following genetic codes are described here. The number preceding each code
corresponds to <code>numcode</code>.
</p>

<dl>
<dt>1</dt><dd><p> standard </p>
</dd>
<dt>2</dt><dd><p> vertebrate.mitochondrial </p>
</dd>
<dt>3</dt><dd><p> yeast.mitochondrial </p>
</dd>
<dt>4</dt><dd><p> protozoan.mitochondrial+mycoplasma </p>
</dd>
<dt>5</dt><dd><p> invertebrate.mitochondrial </p>
</dd>
<dt>6</dt><dd><p> ciliate+dasycladaceal </p>
</dd>
<dt>9</dt><dd><p> echinoderm+flatworm.mitochondrial </p>
</dd>
<dt>10</dt><dd><p> euplotid </p>
</dd>
<dt>11</dt><dd><p> bacterial+plantplastid </p>
</dd>
<dt>12</dt><dd><p> alternativeyeast </p>
</dd>
<dt>13</dt><dd><p> ascidian.mitochondrial </p>
</dd>
<dt>14</dt><dd><p> alternativeflatworm.mitochondrial </p>
</dd>
<dt>15</dt><dd><p> blepharism </p>
</dd>
<dt>16</dt><dd><p> chlorophycean.mitochondrial </p>
</dd>
<dt>21</dt><dd><p> trematode.mitochondrial </p>
</dd>
<dt>22</dt><dd><p> scenedesmus.mitochondrial </p>
</dd>
<dt>23</dt><dd><p> hraustochytrium.mitochondria </p>
</dd>
</dl>



<h3>Value</h3>

<p>For a single sequence an object of class <code>character</code> containing the characters
of the sequence, either of length 1 when <code>as.string</code> is TRUE, or of the length
of the sequence when <code>as.string</code> is FALSE. For many sequences, a list of these.</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqAcnucWeb">SeqAcnucWeb</a></code>, <code><a href="#topic+SeqFastadna">SeqFastadna</a></code>, <code><a href="#topic+SeqFrag">SeqFrag</a></code><br />
The genetic codes are given in the object <code><a href="#topic+SEQINR.UTIL">SEQINR.UTIL</a></code>, a more
human readable form is given by the function <code><a href="#topic+tablecode">tablecode</a></code>.
Use <code><a href="#topic+aaa">aaa</a></code> to get the three-letter code for amino-acids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# List all available methods for getTrans generic function:
#
   methods(getTrans)
#
# Toy CDS example invented by Leonor Palmeira:
#
  toycds &lt;- s2c("tctgagcaaataaatcgg")
  getTrans(toycds) # should be c("S", "E", "Q", "I", "N", "R")
#
# Toy CDS example with ambiguous bases:
#
  toycds2 &lt;- s2c("tcngarcarathaaycgn")
  getTrans(toycds2) # should be c("X", "X", "X", "X", "X", "X")
  getTrans(toycds2, ambiguous = TRUE) # should be c("S", "E", "Q", "I", "N", "R")
  getTrans(toycds2, ambiguous = TRUE, numcode = 2) # should be c("S", "E", "Q", "X", "N", "R")
#
# Real CDS example:
#
  realcds &lt;- read.fasta(file = system.file("sequences/malM.fasta", package ="seqinr"))[[1]]
  getTrans(realcds)
# Biologically correct, only one stop codon at the end
  getTrans(realcds, frame = 3, sens = "R", numcode = 6)
# Biologically meaningless, note the in-frame stop codons

# Read from an alignment as suggested by Dr. H. Suzuki
fasta.res    &lt;- read.alignment(file = system.file("sequences/Anouk.fasta", package = "seqinr"),
 format = "fasta")

AA1 &lt;- seqinr::getTrans(s2c(fasta.res$seq[[1]]))
AA2 &lt;- seqinr::translate(s2c(fasta.res$seq[[1]]))
identical(AA1, AA2)

AA1 &lt;- lapply(fasta.res$seq, function(x) seqinr::getTrans(s2c(x)))
AA2 &lt;- lapply(fasta.res$seq, function(x) seqinr::translate(s2c(x)))
identical(AA1, AA2)

#
# Complex transsplicing operations, the correct frame and the correct
# genetic code are automatically used for translation into protein for
# sequences coming from an ACNUC server:
#
## Not run: 
  # Need internet connection.
  # Translation of the following EMBL entry:
  #
  # FT   CDS             join(complement(153944..154157),complement(153727..153866),
  # FT                   complement(152185..153037),138523..138735,138795..138955)
  # FT                   /codon_start=1
  choosebank("emblTP")
  trans &lt;- query("trans", "N=AE003734.PE35")
  getTrans(trans$req[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='getType'>To get available subsequence types in an opened ACNUC database</h2><span id='topic+getType'></span>

<h3>Description</h3>

<p>This function returns all subsequence types (e.g. CDS, TRNA) present 
in an opened ACNUC database, using default database if no socket is
provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getType(socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getType_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a short description for each subsequence type.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Need internet connection
  choosebank("emblTP")
  getType()
## End(Not run)
</code></pre>

<hr>
<h2 id='gfrag'>Extract sequence identified by name or by number from an ACNUC server</h2><span id='topic+gfrag'></span>

<h3>Description</h3>

<p>Get <code>length</code> characters from sequence identified by name or by number
starting from position <code>start</code> (counted from 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfrag(what, start, length, idby = c("name", "number"), socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gfrag_+3A_what">what</code></td>
<td>
<p>A sequence name or number</p>
</td></tr>
<tr><td><code id="gfrag_+3A_start">start</code></td>
<td>
<p>Start position from 1</p>
</td></tr>
<tr><td><code id="gfrag_+3A_length">length</code></td>
<td>
<p>Number of requested characters (answer may be shorter)</p>
</td></tr>
<tr><td><code id="gfrag_+3A_idby">idby</code></td>
<td>
<p>Is the sequence identified by name or number? Default to name</p>
</td></tr>
<tr><td><code id="gfrag_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of characters with at most <code>length</code> characters (may be
shorter than asked for). NA is returned and a warning is issued in
case of problem (non existent sequence for instance).
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # Need internet connection
  choosebank("emblTP")
  gfrag("LMFLCHR36", start = 1, length = 3529852) -&gt; myseq
  stopifnot(nchar(myseq) == 3529852)
  closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='ghelp'>Get help from an ACNUC server</h2><span id='topic+ghelp'></span>

<h3>Description</h3>

<p>Reads one item of information in specified help file from an ACNUC server.
The are differences between ACNUC clients so that this help could be
confusing. However, the query language is common to all clients so that
the most recent documentation is most likely here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghelp(item = c("GENERAL", "SELECT", "SPECIES", "KEYWORD"),
 file = c("HELP", "HELP_WIN"), socket = autosocket(), catresult = TRUE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ghelp_+3A_item">item</code></td>
<td>
<p>the name of the desired help item</p>
</td></tr>
<tr><td><code id="ghelp_+3A_file">file</code></td>
<td>
<p>the name of the help file on server side.</p>
</td></tr>
<tr><td><code id="ghelp_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="ghelp_+3A_catresult">catresult</code></td>
<td>
<p>logical. If TRUE output is redirected to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of string which is returned invisibly and &quot;cated&quot; to the console
by default.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  ghelp()
  ghelp("SELECT")
  # To get info about current database:
  ghelp("CONT")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='gs500liz'>GS500LIZ size standards</h2><span id='topic+gs500liz'></span>

<h3>Description</h3>

<p>GS500LIZ is an internal size standard often used in capillary electrophoresis.
It contains 16 fragments ranging in size from 35 to 500 bp. Note that they are not
all used for calibration : fragments at 250 and 340 bp may migrate anomalously 
(most likey because of secondary structure formation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gs500liz)</code></pre>


<h3>Format</h3>

<p>A list with 3 components.
</p>

<dl>
<dt>liz</dt><dd><p>a vector of 16 values for the fragment sizes in bp.</p>
</dd>
<dt>mask1</dt><dd><p>a vector of 16 logicals to remove fragments whose
migration may be anomalous (250 and 340 bp).</p>
</dd>
<dt>mask2</dt><dd><p>a vector of 16 logicals to remove extreme fragments (35, 50,
490, 500 bp) so that the resulting fragments are in the 75-450 bp range.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(gs500liz)
op &lt;- par(no.readonly = TRUE)
par(lend = "butt", mar = c(5,0,4,0)+0.1)
x &lt;- gs500liz$liz
n &lt;- length(x)
y &lt;- rep(1, n)
plot(x, y, type = "h", yaxt = "n", xlab = "Fragment size [bp]",
  main = "GS500LIZ size standard", lwd = 2)
x1 &lt;- x[!gs500liz$mask1]
segments(x1, 0, x1, 1, col = "red", lwd = 2)
x2 &lt;- x[!gs500liz$mask2]
segments(x2, 0, x2, 1, col = "blue", lwd = 2)
col &lt;- rep("black", n)
col[!gs500liz$mask1] &lt;- "red"
col[!gs500liz$mask2] &lt;- "blue"
text(x,1.05,paste(x, "bp"), srt = 90, col = col)
legend("top", inset = 0.1, legend = c("regular", "imprecise (mask1)", "extreme (mask2)"),
  lwd = 2, col = c("black","red","blue"))
par(op)
</code></pre>

<hr>
<h2 id='identifiler'>Identifiler allele names</h2><span id='topic+identifiler'></span>

<h3>Description</h3>

<p>Names of the alleles in the Applied Biosystem identifiler allelic ladder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(identifiler)</code></pre>


<h3>Format</h3>

<p>A list with 4 components for the four fluorochromes.
</p>

<dl>
<dt>FAM</dt><dd><p>a list of 4 loci</p>
</dd>
<dt>VIC</dt><dd><p>a list of 5 loci</p>
</dd>
<dt>NED</dt><dd><p>a list of 4 loci</p>
</dd>
<dt>PET</dt><dd><p>a list of 3 loci</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(identifiler)
op &lt;- par(no.readonly = TRUE)
par(mar = c(3,8,4,2)+0.1)
allcount &lt;- unlist(lapply(identifiler, function(x) lapply(x, length)))
barplot(allcount[order(allcount)], horiz = TRUE, las = 1,
main = "Allele count per locus", col = "lightblue")
par(op)
</code></pre>

<hr>
<h2 id='isenum'>Get the ACNUC number of a sequence from its name or accession number</h2><span id='topic+isenum'></span><span id='topic+isn'></span><span id='topic+getNumber.socket'></span><span id='topic+getAttributsocket'></span>

<h3>Description</h3>

<p>Gives the ACNUC number of a sequence in the <code>number</code> element of the returned list.
More informations are returned for subsequences corresponding to coding sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isenum(what, idby = c("name", "access"), socket = autosocket())
isn(what, ...)
getNumber.socket(socket, name)
getAttributsocket(socket, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isenum_+3A_what">what</code></td>
<td>
<p>a sequence name or a sequence accession number</p>
</td></tr>
<tr><td><code id="isenum_+3A_idby">idby</code></td>
<td>
<p>is the sequence identified by name or by accession number? Default to name</p>
</td></tr>
<tr><td><code id="isenum_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="isenum_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>isenum</code>.</p>
</td></tr>
<tr><td><code id="isenum_+3A_name">name</code></td>
<td>
<p>a sequence name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whith the following 6 components:
</p>
<table role = "presentation">
<tr><td><code>number</code></td>
<td>
<p>numeric. The ACNUC number of the sequence.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>numeric. The length of the sequence.</p>
</td></tr>
<tr><td><code>frame</code></td>
<td>
<p>numeric. The reading frame (0, 1, or 2) of the sequence for CDS.</p>
</td></tr>
<tr><td><code>gencode</code></td>
<td>
<p>numeric. ACNUC's genetic code (0 means universal) of the sequence for CDS.</p>
</td></tr>
<tr><td><code>ncbigc</code></td>
<td>
<p>numeric. NCBI's genetic code (0 means universal) of the sequence for CDS.</p>
</td></tr>
<tr><td><code>otheraccessmatches</code></td>
<td>
<p>logical. If TRUE it means that several sequences are attached
to the given accession nunmber, and that only the ACNUC number of the first attached
sequence is returned in the <code>number</code> component of the list.</p>
</td></tr>
</table>
<p><code>isn(what, ...)</code> is a shortcut for <code>isenum(what, ...)$number</code>.<br />
</p>
<p>As from seqinR 1.1-3 <code>getNumber.socket</code> and
<code>getAttributsocket</code> are deprecated (a warning is issued).
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  isenum("LMFLCHR36")
  isn("LMFLCHR36")
  stopifnot(isn("LMFLCHR36") == 13682678)
  # Example with CDS:
  isenum("AB004237")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='JLO'>Forensic Genetic Profile Raw Data</h2><span id='topic+JLO'></span>

<h3>Description</h3>

<p>This is an example of raw data for a human STR genetic profile at 16 loci
(<em>viz.</em> D8S1179, D21S11, D7S820, CSF1PO, D3S1358, TH01, D13S317, D16S539,
D2S1338, D19S433, vWA, TPOX, D18S51, Amelogenin, D5S818, FGA) which
are commonly used in forensic sciences for individual identifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(JLO)</code></pre>


<h3>Format</h3>

<p>A list with 3 components.
</p>

<dl>
<dt>Header</dt><dd><p>a list corresponding to the header in the ABIF file</p>
</dd>
<dt>Directory</dt><dd><p>a data.frame corresponding to the Directory in the ABIF file</p>
</dd>
<dt>Data</dt><dd><p>a list with all raw data in the ABIF file.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset is the expected result when reading the file
<code>2_FAC321_0000205983_B02_004.fsa</code> with the
function <code><a href="#topic+read.abif">read.abif</a></code>. This dataset is used for
the quality check of this function.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>Source</h3>

<p>The DNA source is from the author so that there are no privacy concern.
Data were kindly provided by the INPS (Institut National de Police Scientifique)
which is the national forensic sciences institute in France. Experiments
were done at the LPS (Laboratoire de Police Scientifique de Lyon) in 2008.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>
<p>Anonymous (2006) Applied Biosystem Genetic Analysis Data File Format.
Available at <a href="https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html">https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html</a>.
Last visited on 03-NOV-2008.
</p>


<h3>See Also</h3>

<p>function <code><a href="#topic+read.abif">read.abif</a></code> to import files in ABIF format,
data <code><a href="#topic+gs500liz">gs500liz</a></code> for internal size standards,
data <code><a href="#topic+ECH">ECH</a></code> for the corresponding allelic ladder,
data <code><a href="#topic+identifiler">identifiler</a></code> for allele names in the allelic ladder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JLO)
</code></pre>

<hr>
<h2 id='kaks'>Ka and Ks, also known as dn and ds, computation</h2><span id='topic+kaks'></span>

<h3>Description</h3>

<p> Ks and Ka  are, respectively, the number of substitutions per synonymous site and per non-synonymous site between two protein-coding genes. They are also denoted as ds and dn in the literature. The ratio of nonsynonymous (Ka) to synonymous (Ks) nucleotide substitution rates is an indicator of selective pressures on genes. A ratio significantly greater than 1 indicates positive selective pressure. A ratio around 1 indicates either neutral evolution at the protein level or an averaging of sites under positive and negative selective pressures. A ratio less than 1 indicates pressures to conserve protein sequence (<em>i.e.</em> purifying selection). This function estimates the Ka and Ks values for a set of aligned sequences using the method published by Li (1993) and gives the associated variance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kaks(x, verbose = FALSE, debug = FALSE, forceUpperCase = TRUE, rmgap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kaks_+3A_x">x</code></td>
<td>
<p> An object of class <code>alignment</code>, obtained for instance by importing into R the data from an alignment file with the <code><a href="#topic+read.alignment">read.alignment</a></code> function. This is typically a set of coding sequences aligned at the protein level, see <code><a href="#topic+reverse.align">reverse.align</a></code>.</p>
</td></tr>
<tr><td><code id="kaks_+3A_verbose">verbose</code></td>
<td>
<p> If TRUE add to the results  the value of L0, L2, L4 (respectively the frequency of non-synonymous sites, of 2-fold synonymous sites, of 4-fold synonymous sites), A0, A2, A4 (respectively the number of transitional changes at non-synonymous, 2-fold, and 4-fold synonymous sites ) and B0, B2, B4 (respectively the number of transversional changes at non-synonymous, 2-fold, and 4-fold synonymous sites).</p>
</td></tr>
<tr><td><code id="kaks_+3A_debug">debug</code></td>
<td>
<p> If TRUE turns debug mode on.</p>
</td></tr>
<tr><td><code id="kaks_+3A_forceuppercase">forceUpperCase</code></td>
<td>
<p> If TRUE, the default value, all character in sequences are forced to the upper case
if at least one 'a', 'c', 'g', or 't' is found in the sequences.
Turning it to FALSE if the sequences are already in upper case will save time.</p>
</td></tr>
<tr><td><code id="kaks_+3A_rmgap">rmgap</code></td>
<td>
<p> If TRUE all positions with at least one gap are removed. If FALSE only positions with nothing else than gaps are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ks</code></td>
<td>
<p> matrix of Ks values </p>
</td></tr>
<tr><td><code>ka</code></td>
<td>
<p> matrix of Ka values </p>
</td></tr>
<tr><td><code>vks</code></td>
<td>
<p> variance matrix of Ks </p>
</td></tr>
<tr><td><code>vka</code></td>
<td>
<p> variance matrix of Ka </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Computing Ka and Ks makes sense for coding sequences that have been aligned at the amino-acid level before retro-translating the alignement at the nucleic acid level to ensure that sequences are compared on a codon-by-codon basis. Function <code><a href="#topic+reverse.align">reverse.align</a></code> may help for this.
</p>
<p>As from seqinR 2.0-3, when there is at least one non ACGT base in a codon, this codon is considered as a gap-codon (<code>---</code>). This makes the computation more robust with respect to alignments with out-of-frame gaps, see example section.
</p>
<p>Gap-codons (<code>---</code>) are not used for computations.
</p>
<p>When the alignment does not contain enough information (<em>i.e.</em> close to saturation), the Ka and Ks values are forced to 10 (more exactly to 9.999999).
</p>
<p>Negative values indicate that Ka and Ks can not be computed.
</p>
<p>According to Li (1993) and Pamilo and Bianchi (1993),
the rate of synonymous substitutions Ks is computed as:
Ks = (L2.A2 + L4.A4) / (L2 + L4)  +  B4
</p>
<p>and the rate of non-synonymous substitutions Ka is computed as:
Ka =  A0 + (L0.B0 + L2.B2) / (L0 + L2)
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p>Li, W.-H., Wu, C.-I., Luo, C.-C. (1985) A new method for estimating synonymous and nonsynonymous rates of nucleotide substitution considering the relative likelihood of nucleotide and codon changes. <em>Mol. Biol. Evol</em>, <b>2</b>:150-174<br />
</p>
<p>Li, W.-H. (1993) Unbiased estimation of the rates of synonymous and nonsynonymous substitution. <em>J. Mol. Evol.</em>, <b>36</b>:96-99.<br />
</p>
<p>Pamilo, P., Bianchi, N.O. (1993) Evolution of the <em>Zfx</em> and <em>Zfy</em> genes: Rates and interdependence between genes. <em>Mol. Biol. Evol</em>, <b>10</b>:271-281<br />
</p>
<p>Hurst, L.D. (2002) The Ka/Ks ratio: diagnosing the form of sequence evolution.
<em>Trends Genet.</em>, <b>18</b>:486-486.<br />
</p>
<p>The C programm implementing this method was provided by Manolo Gouy. More info is
needed here to trace back the original C source so as to credit correct source.
The original FORTRAN-77 code by Chung-I Wu modified by Ken Wolfe is available
here: <a href="http://wolfe.ucd.ie/lab/pub/li93/">http://wolfe.ucd.ie/lab/pub/li93/</a> (last visited 2023-12-08).<br />
</p>
<p>For a more recent discussion about the estimation of Ka and Ks see:<br />
</p>
<p>Tzeng, Y.H., Pan, R., Li, W.-H. (2004) Comparison of three methods for estimating
rates of synonymous and nonsynonymous nucleotide substitutions.
<em>Mol. Biol. Evol</em>, <b>21</b>:2290-2298.<br />
</p>
<p>The method implemented here is noted LWL85 in the above paper.<br />
</p>
<p>The cite this package in a publication, as any R package, try something as <code>citation("seqinr")</code>
at your R prompt.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.alignment">read.alignment</a></code> to import alignments from files, <code><a href="#topic+reverse.align">reverse.align</a></code> to align CDS at the aa level,
<code><a href="#topic+kaksTorture">kaksTorture</a></code> for test on one-codon CDS.</p>


<h3>Examples</h3>

<pre><code class='language-R'> #
 # Simple Toy example:
 #
 s &lt;- read.alignment(file = system.file("sequences/test.phylip", package = "seqinr"),
  format = "phylip")
 kaks(s)
 #
 # Check numeric results on an simple test example:
 #
 data(AnoukResult)
 Anouk &lt;- read.alignment(file = system.file("sequences/Anouk.fasta", package = "seqinr"),
  format = "fasta")
 if( ! all.equal(kaks(Anouk), AnoukResult) ) {
   warning("Poor numeric results with respect to AnoukResult standard")
 } else {
   print("Results are consistent with AnoukResult standard")
 }
#
# As from seqinR 2.0-3 the following alignment with out-of-frame gaps
# should return a zero Ka value.
#
# &gt;Reference
# ATGTGGTCGAGATATCGAAAGCTAGGGATATCGATTATATATAGCAAGATCGATAGAGGA
# TCGATGATCGATCGGGATCGACAGCTG
# &gt;With out-of-frame gaps
# AT-TGGTCCAGGTATCGTAAGCTAGGGATATCGATTATATATAGCAAGATCGATAGGGGA
# TCGATGATCGATCGGGA--GACAGCTG
#
# This test example provided by Darren Obbard is now used as a routine check:
#
 Darren &lt;- read.alignment(file = system.file("sequences/DarrenObbard.fasta", package = "seqinr"),
  format = "fasta")
 stopifnot( all.equal(kaks(Darren)$ka[1], 0) )
#
# As from seqinR 3.4-0, non-finite values should never be returned for
# Ka and Ks even for small sequences. The following test checks that this
# is true for an alignement of the 64 codons, so that we compute Ka and
# Ks for all possible pairs of codons.
#
wrd &lt;- as.alignment(nb = 64, nam = words(), seq = words())
res &lt;- kaks(wrd)
if(any(!is.finite(res$ka))) stop("Non finite value returned for Ka")
if(any(!is.finite(res$ks))) stop("Non finite value returned for Ks")

</code></pre>

<hr>
<h2 id='kaksTorture'>Expected numeric results for Ka and Ks in extreme cases</h2><span id='topic+kaksTorture'></span>

<h3>Description</h3>

<p>This data set is what should be obtained when runing <code>kaks()</code>
on the test file kaks-torture.fasta in the sequences directory of the
seqinR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kaksTorture)</code></pre>


<h3>Format</h3>

<p>A list with 4 components of class dist.
</p>

<dl>
<dt>ka</dt><dd><p>Ka</p>
</dd>
<dt>ks</dt><dd><p>Ks</p>
</dd>
<dt>vka</dt><dd><p>variance for Ka</p>
</dd>
<dt>vks</dt><dd><p>variance for Ks</p>
</dd>
</dl>



<h3>Source</h3>

<p>See comments in kaks-torture.fasta for R code used to produce it.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kaksTorture)
kaks.torture &lt;- read.alignment(file = system.file("sequences/kaks-torture.fasta", 
  package = "seqinr"), format = "fasta")
#
# Failed on windows :
#
# stopifnot(identical(kaksTorture, kaks(kaks.torture)))
# stopifnot(identical(kaksTorture, kaks(kaks.torture, rmgap = FALSE)))
</code></pre>

<hr>
<h2 id='knowndbs'>Description of databases known by an ACNUC server</h2><span id='topic+knowndbs'></span><span id='topic+kdb'></span>

<h3>Description</h3>

<p>Returns, for each database known by the server, its name (a valid value for the <code>bank</code>
argument of <code><a href="#topic+choosebank">choosebank</a></code>), availability (off means temporarily unavailable),
and description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knowndbs(tag = c(NA, "TP", "TEST", "DEV"), socket = autosocket())
kdb(tag = c(NA, "TP", "TEST", "DEV"), socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knowndbs_+3A_tag">tag</code></td>
<td>
<p>default to NA, see details</p>
</td></tr>
<tr><td><code id="knowndbs_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the optional <code>tag</code>  argument is used, only databases tagged with the given
string are listed;
when this argument is NA (by default), only untagged databases are listed.
The <code>tag</code> argument thus allows to identify series of special purpose (tagged) databases,
in addition to default (untagged) ones.
</p>


<h3>Value</h3>

<p>A dataframe with 3 columns:
</p>
<table role = "presentation">
<tr><td><code>bank</code></td>
<td>
<p>string. Valid bank values known by the ACNUC server</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>string. &quot;on&quot; means available, &quot;off&quot; means temporarily unavailable</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>string. short description of the database</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>
<p>The full list of untagged and tagged databases is here :
<a href="https://doua.prabi.fr/databases/acnuc/banques_raa.php">https://doua.prabi.fr/databases/acnuc/banques_raa.php</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code> when called without arguments. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  kdb()
  closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='lseqinr'> To see what's inside the package seqinr </h2><span id='topic+lseqinr'></span>

<h3>Description</h3>

<p>This is just a shortcut for ls(&quot;package:seqinr&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lseqinr()
</code></pre>


<h3>Value</h3>

<p>The list of objects in the package seqinr  
</p>


<h3>Note</h3>

 
<p>Use <code>library(help=seqinr)</code> to have a summary of the functionc available in the package.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lseqinr()
</code></pre>

<hr>
<h2 id='m16j'>Fragment of the E. coli chromosome</h2><span id='topic+m16j'></span>

<h3>Description</h3>

<p>A fragment of the <em>E. coli</em> chromosome that was used in Lobry (1996) to show the
change in GC skew at the origin of replication (<em>i.e.</em> the chirochore structure
of bacterial chromosomes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(m16j)</code></pre>


<h3>Format</h3>

<p>A string of 1,616,539 characters
</p>


<h3>Details</h3>

<p>The sequence used in Lobry (1996) was a 1,616,174 bp fragment obtained from the concatenation
of nine overlapping sequences (U18997, U00039, L10328, M87049, L19201, U00006, U14003,
D10483, D26562. Ambiguities have been resolved since then and its was
a chimeric sequence from K-12 strains MG1655 and W3110, the sequence used here is
from strain MG1655 only (Blattner <em>et al.</em> 1997).
</p>
<p>The chirochore structure of bacterial genomes is illustrated below by a screenshot
of a part of figure 1 from Lobry (1996). See the example section to reproduce this
figure.
</p>
<p><img src="../help/figures/gcskewmbe96.pdf" width=400 alt="gcskewmbe96.pdf" />

</p>


<h3>Source</h3>

<p><em>Escherichia coli</em> K-12 strain MG1655. Fragment from U00096 from the
EBI Genome Reviews. Acnuc Release 7. Last Updated: Feb 26, 2007.
XX
DT   18-FEB-2004 (Rel. .1, Created)
DT   09-JAN-2007 (Rel. 65, Last updated, Version 70)
XX
</p>


<h3>References</h3>

<p>Lobry, J.R. (1996) Asymmetric substitution patterns in the two DNA strands of
bacteria. <em>Molecular Biology and Evolution</em>, <b>13</b>:660-665.<br />
</p>
<p>F.R. Blattner, G. Plunkett III, C.A. Bloch, N.T. Perna, V. Burland, M. Rilley,
J. Collado-Vides, J.D. Glasner, C.K. Rode, G.F. Mayhew, J. Gregor,
N.W. Davis, H.A. Kirkpatrick, M.A. Goeden, D.J. Rose, B. Mau, and
Y. Shao. (1997) The complete genome sequence of <em>Escherichia coli</em> K-12. 
<em>Science</em>, <b>277</b>:1453-1462<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Load data:
#
data(m16j)
#
# Define a function to compute the GC skew:
#
gcskew &lt;- function(x) {
  if (!is.character(x) || length(x) &gt; 1)
  stop("single string expected")
  tmp &lt;- tolower(s2c(x))
  nC &lt;- sum(tmp == "c")
  nG &lt;- sum(tmp == "g")
  if (nC + nG == 0)
  return(NA)
  return(100 * (nC - nG)/(nC + nG))
}
#
# Moving window along the sequence:
#
step &lt;- 10000
wsize &lt;- 10000
starts &lt;- seq(from = 1, to = nchar(m16j), by = step)
starts &lt;- starts[-length(starts)]
n &lt;- length(starts)
result &lt;- numeric(n)
for (i in seq_len(n)) {
  result[i] &lt;- gcskew(substr(m16j, starts[i], starts[i] + wsize - 1))
}
#
# Plot the result:
#
xx &lt;- starts/1000
yy &lt;- result
n &lt;- length(result)
hline &lt;- 0
plot(yy ~ xx, type = "n", axes = FALSE, ann = FALSE, ylim = c(-10, 10))
polygon(c(xx[1], xx, xx[n]), c(min(yy), yy, min(yy)), col = "black", border = NA)
usr &lt;- par("usr")
rect(usr[1], usr[3], usr[2], hline, col = "white", border = NA)
lines(xx, yy)
abline(h = hline)
box()
axis(1, at = seq(0, 1600, by = 200))
axis(2, las = 1)
title(xlab = "position (Kbp)", ylab = "(C-G)/(C+G) [percent]",
 main = expression(paste("GC skew in ", italic(Escherichia~coli))))
arrows(860, 5.5, 720, 0.5, length = 0.1, lwd = 2)
text(860, 5.5, "origin of replication", pos = 4)
</code></pre>

<hr>
<h2 id='mase'>Example of results obtained after a call to read.alignment</h2><span id='topic+mase'></span>

<h3>Description</h3>

<p>This data set gives an example of a protein alignment obtained after a call to the function read.alignment on an alignment file in &quot;mase&quot; format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mase)</code></pre>


<h3>Format</h3>

<p>A List of class alignment</p>


<h3>Source</h3>

<p>http://www.clustal.org/</p>


<h3>References</h3>

<p>Faullcner.D.V. and Jurka,J. (1988) <em>Multiple sequences alignment editor(MASE).</em> Trends Biochem. Sa., 13, 321-322.</p>

<hr>
<h2 id='modifylist'>Modification of an ACNUC list</h2><span id='topic+modifylist'></span>

<h3>Description</h3>

<p>This function modifies a previously existing ACNUC list by selecting sequences
either by length, either by date, either for the presence of a given string in annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifylist(listname, modlistname = listname, operation,
 type = c("length", "date", "scan"), socket = autosocket(),
 virtual = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifylist_+3A_listname">listname</code></td>
<td>
<p>the name of the ACNUC list to modify</p>
</td></tr>
<tr><td><code id="modifylist_+3A_modlistname">modlistname</code></td>
<td>
<p>the name of the modified ACNUC list. Default is to use the
same list name so that previous list is lost.</p>
</td></tr>
<tr><td><code id="modifylist_+3A_operation">operation</code></td>
<td>
<p>a string of character describing the operation to be done, see details.</p>
</td></tr>
<tr><td><code id="modifylist_+3A_type">type</code></td>
<td>
<p>the type of operation, could be one of <code> "length", "date", "scan"</code>.
Default is <code>"length"</code></p>
</td></tr>
<tr><td><code id="modifylist_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="modifylist_+3A_virtual">virtual</code></td>
<td>
<p>if TRUE, no attempt is made to retrieve the information about all the elements of the list. In this case, the <code>req</code> component of the list is set to NA.</p>
</td></tr>
<tr><td><code id="modifylist_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE mode verbose is on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example of possible values for the argument <code>operation</code>:
</p>

<dl>
<dt>length</dt><dd><p>as in  &quot;&gt; 10000&quot;    or    &quot;&lt; 500&quot;</p>
</dd>
<dt>date</dt><dd><p>as in   &quot;&gt; 1/jul/2001&quot;   or   &quot;&lt; 30/AUG/98&quot;</p>
</dd>
<dt>scan</dt><dd><p>specify the string to be searched for</p>
</dd>
</dl>

<p>Character &lt; is to be understood as &lt;= and &gt; likewise.
</p>


<h3>Value</h3>

<p>The result is directly assigned to the object <code>modlistname</code> in the user workspace.
This is an objet of class <code>qaw</code>, a list with the following 6 components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the original call</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>the ACNUC list name</p>
</td></tr>
<tr><td><code>nelem</code></td>
<td>
<p>the number of elements (for instance sequences) in the ACNUC list</p>
</td></tr>
<tr><td><code>typelist</code></td>
<td>
<p>the type of the elements of the list. Could be SQ for a list of
sequence names, KW for a list of keywords, SP for a list of species names.</p>
</td></tr>
<tr><td><code>req</code></td>
<td>
<p>a list of sequence names that fit the required criteria or <code>NA</code> when
called with parameter <code>virtual</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code>socket</code></td>
<td>
<p>the socket connection that was used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> and
<code><a href="#topic+prepgetannots">prepgetannots</a></code> to select the annotation lines for scan.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "sp=felis catus et t=cds", virtual=TRUE)
  mylist$nelem # 603 sequences
  stopifnot(mylist$nelem == 603)

  # select sequences with at least 1000 bp:
  mylist &lt;- modifylist("mylist", operation = "&gt;1000", virtual = TRUE)
  mylist$nelem # now, only 132 sequences
  stopifnot(mylist$nelem == 132)

  # scan for "felis" in annotations:
  mylist &lt;- modifylist("mylist", op = "felis", type = "scan", virtual = TRUE)
  mylist$nelem # now, only 33 sequences
  stopifnot(mylist$nelem == 33)

  # modify by date:
  mylist &lt;-  modifylist("mylist", op = "&gt; 1/jul/2001", type = "date", virtual = TRUE)
  mylist$nelem # now, only 15 sequences
  stopifnot(mylist$nelem == 15)

  # Summary of current ACNUC lists, one list called MYLIST on sever:
  sapply(alr()$rank, getliststate)
  closebank()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='move'>Rename an R object</h2><span id='topic+move'></span><span id='topic+mv'></span>

<h3>Description</h3>

<p>Rename object <code>from</code> into <code>to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move(from, to)
mv(from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="move_+3A_from">from</code></td>
<td>
<p>an R object name</p>
</td></tr>
<tr><td><code id="move_+3A_to">to</code></td>
<td>
<p>the new R object name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swap">swap</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Example in a new empty environment:
#
local({
  zefplock &lt;- pi
  print(ls())
  print(zefplock)
  mv(zefplock, toto)
  print(ls())
  print(toto)
  stopifnot(identical(toto, pi)) # Sanity check
})
#
# Check that self-affectation is possible:
#
mv(mv, mv) # force self-affectation for the function itself
mv(mv, mv) # OK, function mv() still exists
</code></pre>

<hr>
<h2 id='msf'>Example of results obtained after a call to read.alignment</h2><span id='topic+msf'></span>

<h3>Description</h3>

<p>This data set gives an example of a protein alignment obtained after a call to the function read.alignment on an alignment file in &quot;msf&quot; format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(msf)</code></pre>


<h3>Format</h3>

<p>A List of class alignment</p>


<h3>Source</h3>

<p>http://www.ebi.ac.uk/2can/tutorials/formats.html#MSF/</p>

<hr>
<h2 id='n2s'> function to convert the numeric encoding of a DNA sequence
into a vector of characters </h2><span id='topic+n2s'></span>

<h3>Description</h3>

<p>By default, if no &lsquo;levels&rsquo; arguments is provided, this function
will just transform your vector of integer into a DNA sequence 
according to the lexical order: <code>0 -&gt; "a"</code>, <code>1 -&gt; "c"</code>, <code> 2 -&gt; "g"</code>,
<code>3 -&gt; "t"</code>, <code>others -&gt; NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2s(nseq, levels = c("a", "c", "g", "t"), base4 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n2s_+3A_nseq">nseq</code></td>
<td>
<p>A vector of integers </p>
</td></tr>
<tr><td><code id="n2s_+3A_levels">levels</code></td>
<td>
<p>the translation vector </p>
</td></tr>
<tr><td><code id="n2s_+3A_base4">base4</code></td>
<td>
<p>when this logical is true, the numerical encoding of
<code>levels</code> starts at 0, when it is false the numerical encoding of 
<code>levels</code> starts at 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of characters
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+s2n">s2n</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##example of the default behaviour:
nseq &lt;- sample(x = 0:3, size = 100, replace = TRUE)
n2s(nseq) 
# Show what happens with out-of-range and NA values:
nseq[1] &lt;- NA
nseq[2] &lt;- 777
n2s(nseq)[1:10]
# How to get an RNA instead:
n2s(nseq, levels = c("a", "c", "g", "u"))
</code></pre>

<hr>
<h2 id='oriloc'> Prediction of origin and terminus of replication in bacteria.</h2><span id='topic+oriloc'></span>

<h3>Description</h3>

<p>This program finds the putative origin and terminus of
replication in procaryotic genomes. The program discriminates
between codon positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oriloc(seq.fasta = system.file("sequences/ct.fasta.gz", package = "seqinr"),
 g2.coord = system.file("sequences/ct.predict", package = "seqinr"),
 glimmer.version = 3,
oldoriloc = FALSE, gbk = NULL, clean.tmp.files = TRUE, rot = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oriloc_+3A_seq.fasta">seq.fasta</code></td>
<td>
<p>Character: the name of a file which contains the DNA sequence
of a bacterial chromosome in fasta format. The default value,
<code>system.file("sequences/ct.fasta.gz", package ="seqinr")</code> is
the fasta file <code>ct.fasta.gz</code>. This is the file
for the complete genome sequence of <em>Chlamydia trachomatis</em>
that was used in Frank and Lobry (2000). You can replace
this by something like <code>seq.fasta = "myseq.fasta"</code> to work
with your own data if the file <code>myseq.fasta</code> is present in
the current working directory (see <code><a href="base.html#topic+getwd">getwd</a></code>), or give
a full path access to the sequence file (see <code><a href="base.html#topic+file.choose">file.choose</a></code>).</p>
</td></tr>
<tr><td><code id="oriloc_+3A_g2.coord">g2.coord</code></td>
<td>
<p>Character: the name of file which contains the output of
glimmer program (<code>*.predict</code> in glimmer version 3)</p>
</td></tr>
<tr><td><code id="oriloc_+3A_glimmer.version">glimmer.version</code></td>
<td>
<p>Numeric: glimmer version used, could be 2 or 3</p>
</td></tr>
<tr><td><code id="oriloc_+3A_oldoriloc">oldoriloc</code></td>
<td>
<p>Logical: to be set at TRUE to reproduce the
(deprecated) outputs of previous (publication date: 2000) version
of the oriloc program.</p>
</td></tr>
<tr><td><code id="oriloc_+3A_gbk">gbk</code></td>
<td>
<p>Character: the URL of a file in GenBank format. When provided
<code>oriloc</code> use as input a single GenBank file instead of the <code>seq.fasta</code>
and the <code>g2.coord</code>. A local temporary copy of the GenBank file is
made with <code><a href="utils.html#topic+download.file">download.file</a></code> if <code>gbk</code> starts with
<code>http://</code> or <code>ftp://</code> or <code>file://</code> and whith
<code><a href="base.html#topic+file.copy">file.copy</a></code> otherwise. The local copy is then used as
input for <code><a href="#topic+gb2fasta">gb2fasta</a></code> and <code><a href="#topic+gbk2g2">gbk2g2</a></code> to produce
a fasta file and a glimmer-like (version 2) file, respectively, to be used
by oriloc instead of <code>seq.fasta</code> and <code>g2.coord</code> .</p>
</td></tr>
<tr><td><code id="oriloc_+3A_clean.tmp.files">clean.tmp.files</code></td>
<td>
<p>Logical: if TRUE temporary files generated when
working with a GenBank file are removed.</p>
</td></tr>
<tr><td><code id="oriloc_+3A_rot">rot</code></td>
<td>
<p>Integer, with zero default value, used to permute circurlarly the genome. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method builds on the fact that there are compositional asymmetries between
the leading and the lagging strand for replication. The programs works only
with third codon positions so as to increase the signal/noise ratio.
To discriminate between codon positions, the program use as input either
an annotated genbank file, either a fasta file and a glimmer2.0 (or
glimmer3.0) output
file.
</p>


<h3>Value</h3>

<p>A data.frame with seven columns: <code>g2num</code> for the CDS number in
the <code>g2.coord</code> file, <code>start.kb</code> for the start position of CDS
expressed in Kb (this is the position of the first occurence of a
nucleotide in a CDS <em>regardless</em> of its orientation), <code>end.kb</code>
for the last position of a CDS, <code>CDS.excess</code> for the DNA walk for
gene orientation (+1 for a CDS in the direct strand, -1 for a CDS in
the reverse strand) cummulated over genes, <code>skew</code> for the cummulated
composite skew in third codon positions, <code>x</code> for the cummulated
T - A skew in third codon position, <code>y</code> for the cummulated C - G
skew in third codon positions.
</p>


<h3>Note</h3>

<p> The method works only for genomes having a single origin of replication
from which the replication is bidirectional. To detect the composition changes,
a DNA-walk is performed. In a 2-dimensional DNA walk, a C in the sequence
corresponds to the movement in the positive y-direction and G to a movement
in the negative y-direction. T and A are mapped by analogous steps along the
x-axis. When there is a strand asymmetry, this will form a trajectory that
turns at the origin and terminus of replication. Each step is the sum of
nucleotides in a gene in third codon positions. Then orthogonal regression is
used to find a line through this trajectory. Each point in the trajectory will
have a corresponding point on the line, and the coordinates of each are
calculated. Thereafter, the distances from each of these points to the origin
(of the plane), are calculated. These distances will represent a form of
cumulative skew. This permets us to make a plot with the gene position (gene
number, start or end position) on the x-axis and the cumulative skew (distance)
at the y-axis. Depending on where the sequence starts, such a plot will display
one or two peaks. Positive peak means origin, and negative means terminus.
In the case of only one peak, the sequence starts at the origin or terminus
site. </p>


<h3>Author(s)</h3>

<p>J.R. Lobry, A.C. Frank</p>


<h3>References</h3>

<p>More illustrated explanations to help understand oriloc outputs
are available there:
<a href="https://pbil.univ-lyon1.fr/software/Oriloc/howto.html">https://pbil.univ-lyon1.fr/software/Oriloc/howto.html</a>.<br />
</p>
<p>Examples of oriloc outputs on real sequence data are there:
<a href="https://pbil.univ-lyon1.fr/software/Oriloc/index.html">https://pbil.univ-lyon1.fr/software/Oriloc/index.html</a>.<br />
</p>
<p>The original paper for oriloc:<br />
Frank, A.C., Lobry, J.R. (2000) Oriloc: prediction of replication
boundaries in unannotated bacterial chromosomes. <em>Bioinformatics</em>,
<b>16</b>:566-567.<br />
<a href="https://doi.org/10.1093/bioinformatics/16.6.560">doi:10.1093/bioinformatics/16.6.560</a><br /><br />
</p>
<p>A simple informal introduction to DNA-walks:<br />
Lobry, J.R. (1999) Genomic landscapes. <em>Microbiology Today</em>,
<b>26</b>:164-165.<br />
<a href="https://seqinr.r-forge.r-project.org/MicrTod_1999_26_164.pdf">https://seqinr.r-forge.r-project.org/MicrTod_1999_26_164.pdf</a><br /><br />
</p>
<p>An early and somewhat historical application of DNA-walks:<br />
Lobry, J.R. (1996) A simple vectorial representation of DNA sequences
for the detection of replication origins in bacteria. <em>Biochimie</em>,
<b>78</b>:323-326.<br />
</p>
<p>Glimmer, a very efficient open source software for the prediction of CDS from scratch
in prokaryotic genome, is decribed at <a href="http://ccb.jhu.edu/software/glimmer/index.shtml">http://ccb.jhu.edu/software/glimmer/index.shtml</a>.<br />
For a description of Glimmer 1.0 and 2.0 see:<br />
</p>
<p>Delcher, A.L., Harmon, D., Kasif, S., White, O., Salzberg, S.L. (1999)
Improved microbial gene identification with GLIMMER,
<em>Nucleic Acids Research</em>, <b>27</b>:4636-4641.<br />
</p>
<p>Salzberg, S., Delcher, A., Kasif, S., White, O. (1998)
Microbial gene identification using interpolated Markov models,
<em>Nucleic Acids Research</em>, <b>26</b>:544-548.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+draw.oriloc">draw.oriloc</a></code>, <code><a href="#topic+rearranged.oriloc">rearranged.oriloc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#
# A little bit too long for routine checks because oriloc() is already
# called in draw.oriloc.Rd documentation file. Try example(draw.oriloc)
# instead, or copy/paste the following code:
#
out &lt;- oriloc()
plot(out$st, out$sk, type = "l", xlab = "Map position in Kb",
    ylab = "Cumulated composite skew",
    main = expression(italic(Chlamydia~~trachomatis)~~complete~~genome))
#
# Example with a single GenBank file:
#
out2 &lt;- oriloc(gbk="https://pbil.univ-lyon1.fr/datasets/seqinr/data/ct.gbk")
draw.oriloc(out2)
#
# (some warnings are generated because of join in features and a gene that
# wrap around the genome)
#

## End(Not run)
</code></pre>

<hr>
<h2 id='parser.socket'>Utility function to parse answers from an ACNUC server</h2><span id='topic+parser.socket'></span>

<h3>Description</h3>

<p>Answers from server looks like : &quot;code=0&amp;lrank=2&amp;count=150513&amp;type=SQ&amp;locus=F&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parser.socket(onelinefromserver, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parser.socket_+3A_onelinefromserver">onelinefromserver</code></td>
<td>
<p>a string</p>
</td></tr>
<tr><td><code id="parser.socket_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE mode verbose is on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mode character or NULL if <code>onelinefromserver</code> is NULL
or if its length is 0.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(all(parser.socket("code=0&amp;lrank=2&amp;count=150513&amp;type=SQ&amp;locus=F") 
                                     == c("0", "2", "150513", "SQ", "F")))
</code></pre>

<hr>
<h2 id='peakabif'>Extraction of Peak locations, Heights and Surfaces from ABIF data</h2><span id='topic+peakabif'></span>

<h3>Description</h3>

<p>Simple peak location for data imported with the <code><a href="#topic+read.abif">read.abif</a></code> function
using cubic spline interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peakabif(abifdata, 
  chanel, 
  npeak, 
  thres = 400/yscale, 
  fig = TRUE,
  chanel.names = c(1:4,105),
  DATA = paste("DATA", chanel.names[chanel], sep = "."),
  tmin = 1/tscale,
  tmax = abifdata$Data[["SCAN.1"]]/tscale,
  tscale = 1000, 
  yscale = 1000,
  irange = (tmin*tscale):(tmax*tscale),
  y = abifdata$Data[[DATA]][irange]/yscale,
  method = "monoH.FC",
  maxrfu = 1000,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peakabif_+3A_abifdata">abifdata</code></td>
<td>
<p>the result returned by <code><a href="#topic+read.abif">read.abif</a></code></p>
</td></tr>
<tr><td><code id="peakabif_+3A_chanel">chanel</code></td>
<td>
<p>the dye number</p>
</td></tr>
<tr><td><code id="peakabif_+3A_npeak">npeak</code></td>
<td>
<p>the expected number of peaks</p>
</td></tr>
<tr><td><code id="peakabif_+3A_thres">thres</code></td>
<td>
<p>scaled threshold value</p>
</td></tr>
<tr><td><code id="peakabif_+3A_fig">fig</code></td>
<td>
<p>logical: should localized peaks be plotted</p>
</td></tr>
<tr><td><code id="peakabif_+3A_chanel.names">chanel.names</code></td>
<td>
<p>numbers extensions used for the DATA</p>
</td></tr>
<tr><td><code id="peakabif_+3A_data">DATA</code></td>
<td>
<p>names of the DATA components</p>
</td></tr>
<tr><td><code id="peakabif_+3A_tmin">tmin</code></td>
<td>
<p>scaled starting time for the time axis</p>
</td></tr>
<tr><td><code id="peakabif_+3A_tmax">tmax</code></td>
<td>
<p>scaled ending time for the time axis</p>
</td></tr>
<tr><td><code id="peakabif_+3A_tscale">tscale</code></td>
<td>
<p>scale factor for the time axis</p>
</td></tr>
<tr><td><code id="peakabif_+3A_yscale">yscale</code></td>
<td>
<p>scale factor for the y-axis (RFU)</p>
</td></tr>
<tr><td><code id="peakabif_+3A_irange">irange</code></td>
<td>
<p>indices of data to be plotted</p>
</td></tr>
<tr><td><code id="peakabif_+3A_y">y</code></td>
<td>
<p>values used for the y-axis</p>
</td></tr>
<tr><td><code id="peakabif_+3A_method">method</code></td>
<td>
<p>method to be used by <code><a href="stats.html#topic+splinefun">splinefun</a></code></p>
</td></tr>
<tr><td><code id="peakabif_+3A_maxrfu">maxrfu</code></td>
<td>
<p>argument passed to <code><a href="#topic+baselineabif">baselineabif</a></code></p>
</td></tr>
<tr><td><code id="peakabif_+3A_...">...</code></td>
<td>
<p>arguments forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a list with the unscaled values for the locations of peaks,
heights of peaks and surfaces of peaks and baseline estimate. The peak
location are in datapoint units, that is an integer starting at 1 for the
first experimental point, 2 for the second experimental point, etc. 
However, due to interpolation between points
the estimated peak location is usually not an integer.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>function <code><a href="#topic+read.abif">read.abif</a></code> to import files in ABIF format, 
<code><a href="#topic+plotabif">plotabif</a></code> to plot them,
data <code><a href="#topic+gs500liz">gs500liz</a></code> for internal size standards,
data <code><a href="#topic+identifiler">identifiler</a></code> for allele names in the allelic ladder,
data <code><a href="#topic+JLO">JLO</a></code> for an example of an individual sample file,
data <code><a href="#topic+ECH">ECH</a></code> for an example of an allelic lader.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JLO)
JLO.maxis &lt;- peakabif(JLO, 5, npeak = 14, tmin = 2.7, thres = 0.1)$maxis
</code></pre>

<hr>
<h2 id='permutation'>Sequence permutation according to several different models</h2><span id='topic+permutation'></span>

<h3>Description</h3>

<p>Generates a random permutation of a given sequence, according to a
given model. Available models are : <code>base</code>, <code>position</code>,
<code>codon</code>, <code>syncodon</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation(sequence,modele='base',frame=0,
 replace=FALSE,prot=FALSE,numcode=1,ucoweight = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutation_+3A_sequence">sequence</code></td>
<td>
<p> A nucleic acids sequence </p>
</td></tr>
<tr><td><code id="permutation_+3A_modele">modele</code></td>
<td>
<p> A string of characters describing the model chosen for
the random generation </p>
</td></tr>
<tr><td><code id="permutation_+3A_frame">frame</code></td>
<td>
<p> Only active for the <code>position</code>, <code>codon</code>,
<code>syncodon</code> models: starting position of CDS as in <code>splitseq</code> </p>
</td></tr>
<tr><td><code id="permutation_+3A_replace">replace</code></td>
<td>
<p> This option is not active for the <code>syncodon</code>
model: if <code>TRUE</code>, sampling is done with replacement </p>
</td></tr>
<tr><td><code id="permutation_+3A_prot">prot</code></td>
<td>
<p> Only available for the <code>codon</code> model: if <code>TRUE</code>, the first and last codons are preserved, and only intern codons are shuffled </p>
</td></tr>
<tr><td><code id="permutation_+3A_numcode">numcode</code></td>
<td>
<p> Only available for the <code>syncodon</code> model: the
genetic code number as in <code>translate</code>. </p>
</td></tr>
<tr><td><code id="permutation_+3A_ucoweight">ucoweight</code></td>
<td>
<p> A list of weights containing the desired codon usage
bias as generated by <code>ucoweight</code>. If none is specified, the
codon usage of the given sequence is used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>base</code> model allows for random sequence generation by
shuffling (with/without replacement) of all bases in the sequence.
</p>
<p>The <code>position</code> model allows for random sequence generation
by shuffling (with/without replacement) of bases within their
position in the codon (bases in position I, II or III stay in
position I, II or III in the new sequence.
</p>
<p>The <code>codon</code> model allows for random sequence generation by
shuffling (with/without replacement) of codons.
</p>
<p>The <code>syncodon</code> model allows for random sequence generation
by shuffling (with/without replacement) of synonymous codons.
</p>


<h3>Value</h3>

<p>a sequence generated from the original one by a given model
</p>


<h3>Author(s)</h3>

<p>L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+synsequence">synsequence</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ec999)
  sequence=ec999[1][[1]]

  new=permutation(sequence,modele='base')
  identical(all.equal(count(new,1),count(sequence,1)),TRUE)

  new=permutation(sequence,modele='position')
  identical(all.equal(GC(new),GC(sequence)),TRUE)
  identical(all.equal(GC2(new),GC2(sequence)),TRUE)
  identical(all.equal(GC3(new),GC3(sequence)),TRUE)

  new=permutation(sequence,modele='codon')
  identical(all.equal(uco(new),uco(sequence)),TRUE)

  new=permutation(sequence,modele='syncodon',numcode=1)
  identical(all.equal(translate(new),translate(sequence)),TRUE)
</code></pre>

<hr>
<h2 id='phylip'>Example of results obtained after a call to read.alignment</h2><span id='topic+phylip'></span>

<h3>Description</h3>

<p>This data set gives an example of a amino acids alignment obtained after a call to the function read.alignment on an alignment file in &quot;phylip&quot; format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(phylip)</code></pre>


<h3>Format</h3>

<p>A List of class alignment</p>


<h3>Source</h3>

<p>http://evolution.genetics.washington.edu/phylip.html</p>


<h3>References</h3>

<p>http://evolution.genetics.washington.edu/phylip.html</p>

<hr>
<h2 id='pK'>pK values for the side chain of charged amino acids from various sources</h2><span id='topic+pK'></span>

<h3>Description</h3>

<p>This compilation of pK values is from Joanna Kiraga (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pK)</code></pre>


<h3>Format</h3>

<p>A data frame with the seven charged amino-acid in row and
six sources in column. The rownames are the one-letter code
for amino-acids.
</p>


<h3>Source</h3>

<p>Table 2 in Kiraga (2008).
</p>


<h3>References</h3>

<p>Kiraga, J. (2008) Analysis and computer simulations of variability of
isoelectric point of proteins in the proteomes. PhD thesis, University
of Wroclaw, Poland.
</p>
<p>Bjellqvist, B., Hughes, G.J., Pasquali, Ch., Paquet, N., Ravier, F., Sanchez,  J.Ch.,
Frutige,r S., Hochstrasser D. (1993) The focusing positions of polypeptides in
immobilized pH gradients can be predicted from their amino acid sequences.
<em>Electrophoresis</em>, <b>14</b>:1023-1031.
</p>
<p>EMBOSS data were from release 5.0 and were still the same in release 6.6
<a href="https://emboss.sourceforge.net/apps/release/6.6/emboss/apps/iep.html">https://emboss.sourceforge.net/apps/release/6.6/emboss/apps/iep.html</a>
last visited 2016-06-03.
</p>
<p>Murray, R.K., Granner, D.K., Rodwell, V.W. (2006)
<em>Harper's illustrated Biochemistry.</em>
27th edition. Published by The McGraw-Hill Companies.
</p>
<p>Sillero, A., Maldonado, A. (2006) Isoelectric point determination of proteins
and other macromolecules: oscillating method.
<em>Comput Biol Med.</em>, <b>36</b>:157-166.
</p>
<p>Solomon, T.W.G. (1998) <em>Fundamentals of Organic Chemistry</em>, 5th edition.
Published by Wiley.
</p>
<p>Stryer L. (1999) <em>Biochemia</em>. czwarta edycja. Wydawnictwo Naukowe PWN.
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pK)
data(SEQINR.UTIL) # for N and C terminal pK values
prot &lt;- s2c("ACDEFGHIKLMNPQRSTVWY")
compoAA &lt;- table(factor(prot, levels = LETTERS))
nTermR &lt;- which(LETTERS == prot[1])
cTermR &lt;- which(LETTERS == prot[length(seq)])

computeCharge &lt;- function(pH, compoAA, pK, nTermResidue, cTermResidue){
  cter &lt;- 10^(-SEQINR.UTIL$pk[cTermResidue,1]) /
     (10^(-SEQINR.UTIL$pk[cTermResidue,1]) + 10^(-pH))
  nter &lt;- 10^(-pH) / (10^(-SEQINR.UTIL$pk[nTermResidue,2]) + 10^(-pH))
  carg &lt;- as.vector(compoAA['R'] * 10^(-pH) / (10^(-pK['R']) + 10^(-pH)))
  chis &lt;- as.vector(compoAA['H'] * 10^(-pH) / (10^(-pK['H']) + 10^(-pH)))
  clys &lt;- as.vector(compoAA['K'] * 10^(-pH) / (10^(-pK['K']) + 10^(-pH)))
  casp &lt;- as.vector(compoAA['D'] * 10^(-pK['D']) /(10^(-pK['D']) + 10^(-pH)))
  cglu &lt;- as.vector(compoAA['E'] * 10^(-pK['E']) / (10^(-pK['E']) + 10^(-pH)))
  ccys &lt;- as.vector(compoAA['C'] * 10^(-pK['C']) / (10^(-pK['C']) + 10^(-pH)))
  ctyr &lt;- as.vector(compoAA['Y'] * 10^(-pK['Y']) / (10^(-pK['Y']) + 10^(-pH)))
  charge &lt;- carg + clys + chis + nter - (casp + cglu + ctyr + ccys + cter)
  return(charge)
}

pHseq &lt;- seq(from = 0, to = 14, by = 0.1)
Bje &lt;- pK$Bjellqvist
names(Bje) &lt;- rownames(pK)
res &lt;- computeCharge(pHseq, compoAA, Bje, nTermR, cTermR)
plot(pHseq, res, type = "l", ylab = "Charge", las = 1,
  main = paste("Charge of protein\n",c2s(prot)),
  xlab = "pH")
for(j in 2:ncol(pK)){
  src &lt;- pK[,j]
  names(src) &lt;- rownames(pK)
  res &lt;- computeCharge(pHseq, compoAA, src, nTermR, cTermR)
  lines(pHseq, res, lty = j, col = rainbow(5)[j])
}

abline(h=0)
abline(v=computePI(prot))
legend("bottomleft", inset = 0.01, colnames(pK), lty = 1:6, col = c("black", rainbow(5)))
</code></pre>

<hr>
<h2 id='plot.SeqAcnucWeb'>To Plot Subsequences on the Parent Sequence</h2><span id='topic+plot.SeqAcnucWeb'></span>

<h3>Description</h3>

<p>This function plots all the type of subsequences on a parent sequence. Subsequences are represented by colored rectangle on the parent sequence.  For example, types could be CDS, TRNA, RRNA .... In order to get all the types that are available for the selected database, use <code>getType</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SeqAcnucWeb'
plot(x, types = getType()$sname, socket = autosocket(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.SeqAcnucWeb_+3A_x">x</code></td>
<td>
<p>A sequence of class <code>SeqAcnucWeb</code></p>
</td></tr>
<tr><td><code id="plot.SeqAcnucWeb_+3A_types">types</code></td>
<td>
<p> The type of subsequences to plot. Default value is to consider
all possible subsequence types.</p>
</td></tr>
<tr><td><code id="plot.SeqAcnucWeb_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="plot.SeqAcnucWeb_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible list giving, for each subsequence, its position on the parent sequence.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getType">getType</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "AC=AB078009")
  plot(mylist$req[[1]])
  
## End(Not run)
</code></pre>

<hr>
<h2 id='plotabif'>Electrophoregram plot for ABIF data</h2><span id='topic+plotabif'></span>

<h3>Description</h3>

<p>Simple chromatogram plot for data imported with the <code><a href="#topic+read.abif">read.abif</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotabif(abifdata, 
  chanel = 1, 
  tmin = 1/tscale, 
  tmax = abifdata$Data[["SCAN.1"]]/tscale, 
  tscale = 1000, 
  yscale = 1000, type = "l", las = 1, 
  xlab = paste("Time", tscale, sep = "/"),
  ylab = paste("RFU", yscale, sep = "/"), 
  irange = (tmin*tscale):(tmax*tscale),
  x = irange/tscale,
  xlim = c(tmin, tmax),
  chanel.names = c(1:4,105),
  DATA = paste("DATA", chanel.names[chanel], sep = "."),
  y = abifdata$Data[[DATA]][irange]/yscale,
  ylim = c(min(y), max(y)),
  dyn = abifdata$Data[[paste("DyeN", chanel, sep = ".")]],
  main = paste(deparse(substitute(abifdata)), chanel, dyn, sep = " ; "),
  calibr = NULL,
  ladder.bp = NULL,
  allele.names = "identifiler",
  ladder.lab = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotabif_+3A_abifdata">abifdata</code></td>
<td>
<p>the result returned by <code><a href="#topic+read.abif">read.abif</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_chanel">chanel</code></td>
<td>
<p>the dye number</p>
</td></tr>
<tr><td><code id="plotabif_+3A_tmin">tmin</code></td>
<td>
<p>scaled starting time for the time axis</p>
</td></tr>
<tr><td><code id="plotabif_+3A_tmax">tmax</code></td>
<td>
<p>scaled ending time for the time axis</p>
</td></tr>
<tr><td><code id="plotabif_+3A_tscale">tscale</code></td>
<td>
<p>scale factor for the time axis</p>
</td></tr>
<tr><td><code id="plotabif_+3A_yscale">yscale</code></td>
<td>
<p>scale factor for the y-axis (RFU)</p>
</td></tr>
<tr><td><code id="plotabif_+3A_type">type</code></td>
<td>
<p>type of line drawing forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_las">las</code></td>
<td>
<p>orientation of axis labels forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_irange">irange</code></td>
<td>
<p>indices of data to be plotted</p>
</td></tr>
<tr><td><code id="plotabif_+3A_x">x</code></td>
<td>
<p>values used for the x-axis</p>
</td></tr>
<tr><td><code id="plotabif_+3A_xlim">xlim</code></td>
<td>
<p>limits for the x-axis forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_chanel.names">chanel.names</code></td>
<td>
<p>numbers extensions used for the DATA</p>
</td></tr>
<tr><td><code id="plotabif_+3A_data">DATA</code></td>
<td>
<p>names of the DATA components</p>
</td></tr>
<tr><td><code id="plotabif_+3A_y">y</code></td>
<td>
<p>values used for the y-axis</p>
</td></tr>
<tr><td><code id="plotabif_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y-axis forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_dyn">dyn</code></td>
<td>
<p>dye name</p>
</td></tr>
<tr><td><code id="plotabif_+3A_main">main</code></td>
<td>
<p>title for the plot forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plotabif_+3A_calibr">calibr</code></td>
<td>
<p>an optional calibration function to convert time into bp</p>
</td></tr>
<tr><td><code id="plotabif_+3A_ladder.bp">ladder.bp</code></td>
<td>
<p>an optional ladder scale in bp (calibr must be provided)</p>
</td></tr>
<tr><td><code id="plotabif_+3A_allele.names">allele.names</code></td>
<td>
<p>name of the dataset with allele names</p>
</td></tr>
<tr><td><code id="plotabif_+3A_ladder.lab">ladder.lab</code></td>
<td>
<p>logical: should allele names be added on plot</p>
</td></tr>
<tr><td><code id="plotabif_+3A_...">...</code></td>
<td>
<p>arguments forwarded to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly its local graphical parameter settings.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>function <code><a href="#topic+read.abif">read.abif</a></code> to import files in ABIF format, 
data <code><a href="#topic+gs500liz">gs500liz</a></code> for internal size standards,
data <code><a href="#topic+identifiler">identifiler</a></code> for allele names in the allelic ladder,
data <code><a href="#topic+JLO">JLO</a></code> for an example of an individual sample file,
data <code><a href="#topic+ECH">ECH</a></code> for an example of an allelic lader.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ECH)
plotabif(ECH,chanel = 1, tmin = 3.2, tmax = 6.1)
</code></pre>

<hr>
<h2 id='plotladder'>Simple plot of an allelic ladder from ABIF data</h2><span id='topic+plotladder'></span>

<h3>Description</h3>

<p>Simple representation of an observed allelic ladder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotladder(abifdata, chanel, calibr, allele.names = "identifiler", npeak = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotladder_+3A_abifdata">abifdata</code></td>
<td>
<p>the result returned by <code><a href="#topic+read.abif">read.abif</a></code></p>
</td></tr>
<tr><td><code id="plotladder_+3A_chanel">chanel</code></td>
<td>
<p>the dye number</p>
</td></tr>
<tr><td><code id="plotladder_+3A_calibr">calibr</code></td>
<td>
<p>a mandatory calibration function to convert time into bp</p>
</td></tr>
<tr><td><code id="plotladder_+3A_allele.names">allele.names</code></td>
<td>
<p>name of the dataset which contains allele names as in <code>link{identifiler}</code></p>
</td></tr>
<tr><td><code id="plotladder_+3A_npeak">npeak</code></td>
<td>
<p>expected number of peaks, deduced from <code>allele.names</code> by default</p>
</td></tr>
<tr><td><code id="plotladder_+3A_...">...</code></td>
<td>
<p>arguments forwarded to <code><a href="#topic+peakabif">peakabif</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly the location of peaks in bp.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>function <code><a href="#topic+read.abif">read.abif</a></code> to import files in ABIF format, 
<code><a href="#topic+plotabif">plotabif</a></code> to plot them,
data <code><a href="#topic+gs500liz">gs500liz</a></code> for internal size standards,
data <code><a href="#topic+identifiler">identifiler</a></code> for allele names in the allelic ladder,
data <code><a href="#topic+JLO">JLO</a></code> for an example of an individual sample file,
data <code><a href="#topic+ECH">ECH</a></code> for an example of an allelic lader.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #
  # load an example of allelic ladder results from an ABIF (*.fsa) file:
  #
data(ECH)
  #
  # Extract from internal size standard chanel number 5 the location 
  # of 14 peaks:
  #
ECH.maxis &lt;- peakabif(ECH, 5, npeak = 14, tmin = 2.7, thres = 0.1, fig = FALSE)$maxis
  #
  # Load data about the expected size of peaks in bp for calibration:
  #
data(gs500liz)
lizbp &lt;- gs500liz$liz # All peaks size in bp
lizbp[!gs500liz$mask1 | !gs500liz$mask2] &lt;- NA # Mark useless peaks
lizbp &lt;- lizbp[-c(1,2)] # The first two peaks are not extracted from ECH
ECH.calibr &lt;- splinefun(ECH.maxis[!is.na(lizbp)], lizbp[!is.na(lizbp)])
  #
  # Show the allelic ladder for the 4 dyes:
  #
plotladder(ECH, 1, ECH.calibr, tmin = 3.1, thres = 0.3, fig = FALSE)
plotladder(ECH, 2, ECH.calibr, tmin = 3.1, thres = 0.35, fig = FALSE)
plotladder(ECH, 3, ECH.calibr, tmin = 3.1, thres = 0.2, fig = FALSE)
plotladder(ECH, 4, ECH.calibr, tmin = 3.1, thres = 0.2, fig = FALSE)
</code></pre>

<hr>
<h2 id='plotPanels'>Representation of Amplicon Size Ranges of a STR kit.</h2><span id='topic+plotPanels'></span>

<h3>Description</h3>

<p>Plot amplicon size ranges grouped by dye color.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPanels(kitname, data, xlim = NULL, cex = 0.75, alpha = 0.5)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPanels_+3A_kitname">kitname</code></td>
<td>
<p>string of characters for the kit name.</p>
</td></tr>
<tr><td><code id="plotPanels_+3A_data">data</code></td>
<td>
<p>an output from the <code><a href="#topic+readPanels">readPanels</a></code> function.</p>
</td></tr>
<tr><td><code id="plotPanels_+3A_xlim">xlim</code></td>
<td>
<p>x-axis range.</p>
</td></tr>
<tr><td><code id="plotPanels_+3A_cex">cex</code></td>
<td>
<p>character expansion factor.</p>
</td></tr>
<tr><td><code id="plotPanels_+3A_alpha">alpha</code></td>
<td>
<p>alpha transparency chanel for colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>See Also</h3>

 <p><code><a href="#topic+readPanels">readPanels</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("abif/AmpFLSTR_Panels_v1.txt", package = "seqinr")
res1 &lt;- readPanels(path1)

par(mfrow = c(2,1))
plotPanels("Identifiler_v1", res1)
plotPanels("SEfiler_v1", res1)

</code></pre>

<hr>
<h2 id='pmw'> Protein Molecular Weight </h2><span id='topic+pmw'></span>

<h3>Description</h3>

<p>With default parameter values, returns the apparent molecular weight of one mole (6.0221415 e+23)
of the input protein expressed in gram at see level on Earth with terrestrial
isotopic composition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmw(seqaa, Ar = c(C = 12.0107, H = 1.00794, O = 15.9994,
N = 14.0067, P = 30.973762, S = 32.065), gravity = 9.81,
unit = "gram", checkseqaa = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmw_+3A_seqaa">seqaa</code></td>
<td>
<p> a protein sequence as a vector of single chars. Allowed values are
&quot;*ACDEFGHIKLMNPQRSTVWY&quot;, non allowed values are ignored. </p>
</td></tr>
<tr><td><code id="pmw_+3A_ar">Ar</code></td>
<td>
<p> a named vector for the mean relative atomic masses of CHONPS atoms. Defaults
values are from to the natural terrestrial sources according to the 43rd IUPAC 
General Assembly in Beijing, China in August 2005 (See 
<a href="https://iupac.org/category/recent-releases/">https://iupac.org/category/recent-releases/</a>
for updates).</p>
</td></tr>
<tr><td><code id="pmw_+3A_gravity">gravity</code></td>
<td>
<p> gravitational field constant in standard units. Defaults to 9.81 m/s2, that
is to the average value at see level on Earth. Negative values are not allowed. </p>
</td></tr>
<tr><td><code id="pmw_+3A_unit">unit</code></td>
<td>
<p> a string that could be &quot;gram&quot; to get the result in grams (1 g = 0.001 kg) 
or &quot;N&quot; to get the result in Newton units (1 N = 1 kg.m/s2). </p>
</td></tr>
<tr><td><code id="pmw_+3A_checkseqaa">checkseqaa</code></td>
<td>
<p> if TRUE <code>pmw()</code> warns if a non-allowed character in seqaa is found.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Algorithm</dt><dd><p>Computing the molecular mass of a protein is close to a linear form on
amino-acid frequencies, but not exactly since we have to remove n - 1 water 
molecules for peptidic bound formation.</p>
</dd>
<dt>Cysteine</dt><dd><p>All cysteines are supposed to be in reduced (-SH) form.</p>
</dd>
<dt>Methionine</dt><dd><p>All methionines are supposed to be not oxidized.</p>
</dd>
<dt>Modifications</dt><dd><p>No post-traductional modifications (such as phosphorylations) 
are taken into account.</p>
</dd>
<dt>Rare</dt><dd><p>Rare amino-acids (pyrolysine and selenocysteine) are not handled.</p>
</dd>
<dt>Warning</dt><dd><p>Do not use defaults values for Ar to compute the molecular mass
of alien's proteins: the isotopic composition for CHONPS atoms could be different
from terrestrial data in a xenobiotic context. Some aliens are easily offended, make
sure not to initiate one more galactic war by repporting wrong results. </p>
</dd>
</dl>



<h3>Value</h3>

<p>The protein molecular weight as a single numeric value. 
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+s2c">s2c</a></code>, <code><a href="#topic+c2s">c2s</a></code>, <code><a href="#topic+aaa">aaa</a></code>, <code><a href="#topic+a">a</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>allowed &lt;- s2c("*ACDEFGHIKLMNPQRSTVWY") # All allowed chars in a protein
pmw(allowed)
all.equal(pmw(allowed), 2395.71366) # Should be true on most platforms
#
# Compute the apparent molecular weight on Moon surface:
#
pmw(allowed, g = 1.6)
#
# Compute the apparent molecular weight in absence of gravity:
#
pmw(allowed, g = 0) # should be zero
#
# Reports results in Newton units:
#
pmw(allowed, unit = "N")
#
# Compute the mass in kg of one mol of this protein:
#
pmw(allowed)/10^3
#
# Compute the mass for all amino-acids:
#
sapply(allowed[-1], pmw) -&gt; aamw
names(aamw) &lt;- aaa(names(aamw))
aamw
</code></pre>

<hr>
<h2 id='prepgetannots'>Select annotation lines in an ACNUC database</h2><span id='topic+prepgetannots'></span><span id='topic+pga'></span>

<h3>Description</h3>

<p>This function is called before using <code><a href="#topic+getAnnot">getAnnot</a></code> or
<code><a href="#topic+modifylist">modifylist</a></code> with a <code>scan</code> type operation to
select the annotation lines to be returned or scanned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepgetannots(what = "all", setfor = c("scan", "getannots"),
                       socket = autosocket(), verbose = FALSE)
pga(what = "all", setfor = c("scan", "getannots"),
                       socket = autosocket(), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepgetannots_+3A_what">what</code></td>
<td>
<p>the default &quot;all&quot; means that all annotation lines are selected.
This can be more specific, see details.</p>
</td></tr>
<tr><td><code id="prepgetannots_+3A_setfor">setfor</code></td>
<td>
<p>this is used when <code>what</code> has its default &quot;all&quot; value.
The behaviour is different for <code><a href="#topic+getAnnot">getAnnot</a></code> and
<code><a href="#topic+modifylist">modifylist</a></code> with a <code>scan</code> type operation:
annotations but not sequences are scanned, but sequences can
be returned by <code><a href="#topic+getAnnot">getAnnot</a></code>. The default value is &quot;scan&quot;.</p>
</td></tr>
<tr><td><code id="prepgetannots_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to an ACNUC server</p>
</td></tr>
<tr><td><code id="prepgetannots_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE mode verbose is on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of annotation lines in the opened ACNUC database is
returned by <code><a href="#topic+countfreelists">countfreelists</a></code>, they are forced to upper
case letters by <code>prepgetannots</code> when supplied with the
<code>what</code> argument.
</p>
<p>For the EMBL/SWISSPROT format, keys are: ALL, AC, DT, KW, OS, OC, OG, OH, 
RN, RC, RP, RX, RA, RG, RT, RL, DR, AH, AS, CC, FH, FT, SQ, SEQ.
</p>
<p>For GenBank: ALL, ACCESSION, VERSION, KEYWORDS, SOURCE, ORGANISM, 
REFERENCE, AUTHORS, CONSRTM, TITLE, JOURNAL, PUBMED, REMARK, COMMENT, 
FEATURES, ORIGIN, SEQUENCE.
</p>
<p>For FT (embl, swissprot) and FEATURES (GenBank), one or more specific 
feature keys can be specified using lines with only uppercase and such as
</p>
<p>FEATURES|CDS
FT|TRNA
</p>
<p>Keys ALL and SEQ/SEQUENCE stand for all annotation and sequence lines, respectively.
For the scan operation, key ALL stand for the DE/DEFINITION lines, 
and SEQ/SEQUENCE cannot be used (annotations but not sequence are scanned).</p>


<h3>Value</h3>

<p>The function returns invisibly the annotation lines names.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAnnot">getAnnot</a></code>, <code><a href="#topic+modifylist">modifylist</a></code>, <code><a href="#topic+countfreelists">countfreelists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: # Need internet connection
  choosebank("genbank")
  mylist &lt;- query("mylist","n=AQF16SRRN")
  pga() # We want to scan all annotations, including FEATURES
  mylist &lt;- modifylist("mylist", operation = "strain", type = "scan")
  mylist$nelem # should be 1
 
## End(Not run)
</code></pre>

<hr>
<h2 id='prettyseq'>Text representation of a sequence from an ACNUC server</h2><span id='topic+prettyseq'></span>

<h3>Description</h3>

<p>To get a text representation of sequence of rank <code>num</code> and of its subsequences,
with <code>bpl</code> bases per line (default = 60), and with optional translation of
protein-coding subsequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettyseq(num, bpl = 60, translate = TRUE, socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prettyseq_+3A_num">num</code></td>
<td>
<p>rank of the sequence in the ACNUC database</p>
</td></tr>
<tr><td><code id="prettyseq_+3A_bpl">bpl</code></td>
<td>
<p>number of base per line</p>
</td></tr>
<tr><td><code id="prettyseq_+3A_translate">translate</code></td>
<td>
<p>should coding sequences be translated?</p>
</td></tr>
<tr><td><code id="prettyseq_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible vector of string. The output is redirected to the console.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  prettyseq(111)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.qaw'>Print method for objects from class qaw</h2><span id='topic+print.qaw'></span>

<h3>Description</h3>

<p>Print the number of elements, their type and the corresponding query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qaw'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.qaw_+3A_x">x</code></td>
<td>
<p>A objet of class <code>qaw</code></p>
</td></tr>
<tr><td><code id="print.qaw_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>	
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
  ### Need internet connection
  choosebank("emblTP")
  list1 &lt;- query("sp=felis catus")	
  list1
  # 4732 SQ for sp=felis catus
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.SeqAcnucWeb'>Print method for objects from class SeqAcnucWeb</h2><span id='topic+print.SeqAcnucWeb'></span>

<h3>Description</h3>

<p>Print the name, length, frame and genetic code number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SeqAcnucWeb'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.SeqAcnucWeb_+3A_x">x</code></td>
<td>
<p>A sequence of class <code>SeqAcnucWeb</code></p>
</td></tr>
<tr><td><code id="print.SeqAcnucWeb_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "sp=felis catus")
  mylist$req[[1]]
  #      name   length    frame   ncbigc 
  # "A06937"     "34"      "0"      "1"
  
## End(Not run)
</code></pre>

<hr>
<h2 id='prochlo'> Zscore on three strains of Prochlorococcus marinus </h2><span id='topic+prochlo'></span>

<h3>Description</h3>

<p>This dataset contains the zscores computed with the codon model on all
CDS from 3 strains of Procholorococcus marinus (as retrieved from Genome
Reviews database on June 16, 2005)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prochlo)
</code></pre>


<h3>Format</h3>

<p>List of three dataframes of the zscore of each of the 16 dinucleotides
on each CDS retrieved from the specific strain.
</p>

<dl>
<dt>BX548174</dt><dd><p>strain adapted to living at a depth of 5
meters (high levels of UV exposure)
<code>base</code> model on each intergenic sequence</p>
</dd>
<dt>AE017126</dt><dd><p>strain adapted to living at a depth of 120
meters (low levels of UV exposure)</p>
</dd>
<dt>BX548175</dt><dd><p>strain adapted to living at a depth of 135
meters (low levels of UV exposure)</p>
</dd>
</dl>



<h3>References</h3>

<p>Palmeira, L., Guéguen, L. and Lobry JR. (2006) UV-targeted dinucleotides
are not depleted in light-exposed Prokaryotic genomes.
<em>Molecular Biology and Evolution</em>,
<b>23</b>:2214-2219.<br />
<a href="https://academic.oup.com/mbe/article/23/11/2214/1335460">https://academic.oup.com/mbe/article/23/11/2214/1335460</a><br /><br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+zscore">zscore</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Show the four YpY for the three ecotypes:
#
data(prochlo)
oneplot &lt;- function(x){
  plot(density(prochlo$BX548174[, x]),
    ylim = c(0,0.4), xlim = c(-4,4), lty=3,
    main = paste(substr(x,1,1), "p", substr(x,2,2), " bias", sep = ""),
    xlab="",ylab="",las=1, type = "n")
  rect(-10,-1,-1.96,10, col = "yellow", border = "yellow")
  rect(1.96,-1,10,10, col = "yellow", border = "yellow")
  lines(density(prochlo$BX548174[, x]),lty=3)
  lines(density(prochlo$AE017126[, x]),lty=2)
  lines(density(prochlo$BX548175[, x]),lty=1)
  abline(v=c(-1.96,1.96),lty=5)
  box()
}
par(mfrow=c(2,2),mar=c(2,3,2,0.5) + 0.1)
oneplot("CT")
oneplot("TC")
oneplot("CC")
oneplot("TT")
#
# Show YpY biases with respect to light exposure
#
curdev &lt;- getOption("device")
OK &lt;- FALSE
devlist &lt;- c("X11", "windows", "quartz") # interactive with width and height in inches
for(i in devlist){
  if(exists(i) &amp;&amp; identical(get(i), curdev)){
    OK &lt;- TRUE
    break
  }
}
if(OK){
  curdev(width = 18, height = 11)
  par(oma = c(0, 0, 3, 0), mfrow = c(1, 2), mar = c(5, 4, 0, 0), cex = 1.5)
  example(waterabs, ask = FALSE) #left figure

  par(mar = c(5, 0, 0, 2))
  plot(seq(-5, 3, by = 1), seq(0, 150, length = 9), col = "white", 
    ann = FALSE, axes = FALSE, xaxs = "i", yaxs = "i")
  axis(1, at = c(-1.96, 0, 1.96), labels = c(-1.96, 0, 1.96))
  lines(rep(-1.96, 2),c(0, 150),lty=2)
  lines(rep(1.96, 2), c(0, 150),lty=2)
  title(xlab = "zscore distribution", cex = 1.5, adj = 0.65)

  selcol &lt;- c(6, 8, 14, 16)
  z5 &lt;- prochlo$BX548174[, selcol]
  z120 &lt;- prochlo$AE017126[, selcol]
  z135 &lt;- prochlo$BX548175[, selcol]

  todo &lt;- function(who, xx, col = "black", bottom, loupe){
  	dst &lt;- density(who[, xx])
  	sel &lt;- which(dst$x &gt;= -3)
    	lines(dst$x[sel], dst$y[sel]*loupe + (bottom), col = col)
  }
  todo2 &lt;- function(who, bottom, loupe){
    todo(who, "CC", "blue", bottom, loupe)
    todo(who, "CT", "red", bottom, loupe)
    todo(who, "TC", "green", bottom, loupe)
    todo(who, "TT", "black", bottom, loupe)
  }
  todo3 &lt;- function(bottom, who, leg, loupe = 90){
    lines(c(-5,-3), c(150 - leg, bottom + 20))
    rect(-3,bottom,3,bottom+40)
    text(-2.6,bottom+38, paste(leg, "m"))
    todo2(who, bottom, loupe)
  }

  todo3(bottom = 110, who = z5, leg = 5)
  todo3(bottom = 50, who = z120, leg = 120)
  todo3(bottom = 5, who = z135, leg = 135)

  legend(-4.5,110,c('CpC','CpT','TpC','TpT'),lty=1,pt.cex=cex,
    col=c('blue','red','green','black'))

  mtext(expression(paste("Dinucleotide composition for three ", 
    italic("Prochlorococcus marinus")," ecotypes")), outer = TRUE, cex = 2, line = 1)
  }
</code></pre>

<hr>
<h2 id='query'>To get a list of sequence names from an ACNUC data base located on the web</h2><span id='topic+query'></span>

<h3>Description</h3>

<p>This is a major command of the package. It executes all sequence retrievals using any selection criteria the data base allows.  The sequences are coming from ACNUC data base located on the web and they are transfered by socket. The command produces the list of all sequence names that fit the required criteria. The sequence names belong to the class of sequence <code>SeqAcnucWeb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query(listname, query, socket = autosocket(),
invisible = TRUE, verbose = FALSE, virtual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_+3A_listname">listname</code></td>
<td>
<p>The name of the list as a quoted string of chars</p>
</td></tr>
<tr><td><code id="query_+3A_query">query</code></td>
<td>
<p>A quoted string of chars containing the request with the syntax given in the details section</p>
</td></tr>
<tr><td><code id="query_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="query_+3A_invisible">invisible</code></td>
<td>
<p>if <code>FALSE</code>, the result is returned visibly.</p>
</td></tr>
<tr><td><code id="query_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, verbose mode is on</p>
</td></tr>
<tr><td><code id="query_+3A_virtual">virtual</code></td>
<td>
<p>if <code>TRUE</code>, no attempt is made to retrieve the information about
all the elements of the list. In this case, the <code>req</code> component of the list is set to
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The query language defines several selection criteria and operations between
lists of elements matching criteria. It creates mainly lists of sequences, but
also lists of species (or, more generally, taxa) and of keywords.
See <a href="https://doua.prabi.fr/databases/acnuc/cfonctions.html#QUERYLANGUAGE">https://doua.prabi.fr/databases/acnuc/cfonctions.html#QUERYLANGUAGE</a>
for the last update of the description of the query language.<br />
</p>
<p>Selection criteria (no space before the = sign) are:
</p>

<dl>
<dt>SP=taxon</dt><dd><p>seqs attached to taxon or any other below in tree; @ wildcard possible</p>
</dd>
<dt>TID=id</dt><dd><p>seqs attached to given numerical NCBI's taxon id</p>
</dd>
<dt>K=keyword</dt><dd><p>seqs attached to keyword or any other below in tree; @ wildcard possible</p>
</dd>
<dt>T=type</dt><dd><p>seqs of specified type</p>
</dd>
<dt>J=journalname</dt><dd><p>seqs published in journal specified using defined journal code</p>
</dd>
<dt>R=refcode</dt><dd><p>seqs from reference specified such as in jcode/volume/page (e.g., JMB/13/5432)</p>
</dd>
<dt>AU=name</dt><dd><p>seqs from references having specified author (only last name, no initial)</p>
</dd>
<dt>AC=accessionno</dt><dd><p>seqs attached to specified accession number</p>
</dd>
<dt>N=seqname</dt><dd><p>seqs of given name (ID or LOCUS); @ wildcard possible</p>
</dd>
<dt>Y=year</dt><dd><p>seqs published in specified year; &gt; and &lt; can be used instead of =</p>
</dd>
<dt>O=organelle</dt><dd><p>seqs from specified organelle named following defined code (e.g., chloroplast)</p>
</dd>
<dt>M=molecule</dt><dd><p>seqs from specified molecule as named in ID or LOCUS annotation records</p>
</dd>
<dt>ST=status</dt><dd><p>seqs from specified data class (EMBL) or review level (UniProt)</p>
</dd>
<dt>F=filename</dt><dd><p>seqs whose names are in given file, one name per line (unimplemented use <code><a href="#topic+clfcd">clfcd</a></code> instead)</p>
</dd>
<dt>FA=filename</dt><dd><p>seqs attached to accession numbers in given file, one number per line (unimplemented use <code><a href="#topic+clfcd">clfcd</a></code> instead)</p>
</dd>
<dt>FK=filename</dt><dd><p>produces the list of keywords named in given file, one keyword per line (unimplemented use <code><a href="#topic+clfcd">clfcd</a></code> instead)</p>
</dd>
<dt>FS=filename</dt><dd><p>produces the list of species named in given file, one species per line (unimplemented use <code><a href="#topic+clfcd">clfcd</a></code> instead)</p>
</dd>
<dt>listname</dt><dd><p>the named list that must have been previously constructed</p>
</dd>
</dl>

<p>Operators (always followed and preceded by blanks or parentheses) are:
</p>

<dl>
<dt>AND</dt><dd><p>intersection of the 2 list operands</p>
</dd>
<dt>OR</dt><dd><p>union of the 2 list operands</p>
</dd>
<dt>NOT</dt><dd><p>complementation of the single list operand</p>
</dd>
<dt>PAR</dt><dd><p>compute the list of parent seqs of members of the single list operand</p>
</dd>
<dt>SUB</dt><dd><p>add subsequences of members of the single list operand</p>
</dd>
<dt>PS</dt><dd><p>project to species: list of species attached to member sequences of the operand list</p>
</dd>
<dt>PK</dt><dd><p>project to keywords: list of keywords attached to member sequences of the operand list</p>
</dd>
<dt>UN</dt><dd><p>unproject: list of seqs attached to members of the species or keywords list operand</p>
</dd>
<dt>SD</dt><dd><p>compute the list of species placed in the tree below the members of the species list operand</p>
</dd>
<dt>KD</dt><dd><p>compute the list of keywords placed in the tree below the members of the keywords list operand</p>
</dd>
</dl>

<p>The query language is case insensitive.Three operators (AND, OR, NOT)
can be ambiguous because they can also occur within valid criterion values.
Such ambiguities can be solved by encapsulating elementary selection
criteria between escaped double quotes.
</p>


<h3>Value</h3>

<p>The result is directly assigned to the object <code>listname</code> in the user workspace.
This is an objet of class <code>qaw</code>, a list with the following 6 components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the original call</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>the ACNUC list name</p>
</td></tr>
<tr><td><code>nelem</code></td>
<td>
<p>the number of elements (for instance sequences) in the ACNUC list</p>
</td></tr>
<tr><td><code>typelist</code></td>
<td>
<p>the type of the elements of the list. Could be SQ for a list of
sequence names, KW for a list of keywords, SP for a list of species names.</p>
</td></tr>
<tr><td><code>req</code></td>
<td>
<p>a list of sequence names that fit the required criteria or <code>NA</code> when
called with parameter <code>virtual</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code>socket</code></td>
<td>
<p>the socket connection that was used</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Most of the documentation was imported from ACNUC help
files written by Manolo Gouy</p>


<h3>Author(s)</h3>

<p>J.R. Lobry, D. Charif</p>


<h3>References</h3>

<p>Gouy, M., Milleret, F., Mugnier, C., Jacobzone, M., Gautier,C. (1984) ACNUC: a nucleic acid sequence data base and analysis system.
<em>Nucl. Acids Res.</em>, <b>12</b>:121-127.<br />
Gouy, M., Gautier, C., Attimonelli, M., Lanave, C., Di Paola, G. (1985)
ACNUC - a portable retrieval system for nucleic acid sequence databases:
logical and physical designs and usage.
<em>Comput. Appl. Biosci.</em>, <b>3</b>:167-172.<br />
Gouy, M., Gautier, C., Milleret, F. (1985) System analysis and nucleic acid sequence banks.
<em>Biochimie</em>, <b>67</b>:433-436.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>,
<code><a href="#topic+getSequence">getSequence</a></code>,
<code><a href="#topic+getName">getName</a></code>,
<code><a href="#topic+crelistfromclientdata">crelistfromclientdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 # Need internet connection
 choosebank("genbank")
 bb &lt;- query("bb", "sp=Borrelia burgdorferi")
 # To get the names of the 4 first sequences:
 sapply(bb$req[1:4], getName)
 # To get the 4 first sequences:
 sapply(bb$req[1:4], getSequence, as.string = TRUE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='read.abif'>Read ABIF formatted files</h2><span id='topic+read.abif'></span>

<h3>Description</h3>

<p>ABIF stands for Applied Biosystem Inc. Format, a binary fromat modeled after TIFF format.
Corresponding files usually have an <code>*.ab1</code> or <code>*.fsa</code> extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.abif(filename, max.bytes.in.file = file.info(filename)$size,
 pied.de.pilote = 1.2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.abif_+3A_filename">filename</code></td>
<td>
<p>The name of the file.</p>
</td></tr>
<tr><td><code id="read.abif_+3A_max.bytes.in.file">max.bytes.in.file</code></td>
<td>
<p>The size in bytes of the file, defaulting to what is returned by <code><a href="base.html#topic+file.info">file.info</a></code></p>
</td></tr>
<tr><td><code id="read.abif_+3A_pied.de.pilote">pied.de.pilote</code></td>
<td>
<p>Safety factor: the argument <code>n</code> to <code><a href="base.html#topic+readBin">readBin</a></code> is set as <code>pied.de.pilote*max.bytes.in.file</code>.</p>
</td></tr>
<tr><td><code id="read.abif_+3A_verbose">verbose</code></td>
<td>
<p>logical [FALSE]. If TRUE verbose mode is on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All data are imported into memory, there is no attempt to read items on the fly.
</p>


<h3>Value</h3>

<p>A list with three components: <code>Header</code> which is a list that contains various low-level information,
among which <code>numelements</code> is the number of elements in the directory and <code>dataoffset</code>
the offset to find the location of the directory. <code>Directory</code> is a data.frame for the directory
of the file with the number of row being the number of elements in the directory and the 7
columns describing various low-level information about the elements. <code>Data</code> is a list
with the number of components equal to the number of elements in the directory.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinR")</code>
</p>
<p>Anonymous (2006) Applied Biosystem Genetic Analysis Data File Format.
Available at <a href="https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html">https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html</a>.
Last visited on 03-NOV-2008.
</p>
<p>The figure in the example section is an attempt to reproduce figure 1A from:
</p>
<p>Krawczyk, J.,  Goesmann, A., Nolte, R., Werber, M., Weisshaar, B. (2009)
Trace2PS and FSA2PS: two software toolkits for converting trace and fsa files to PostScript format.
<em>Source Code for Biology and Medicine</em>, <b>4</b>:4.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+readBin">readBin</a></code> which is used here to import the binary file and <code><a href="base.html#topic+file.info">file.info</a></code> to
get the size of the file. See <code><a href="#topic+JLO">JLO</a></code> for the files used in quality check.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Quality check:
#

data(JLO)
JLO.check &lt;- read.abif(system.file("abif/2_FAC321_0000205983_B02_004.fsa",
  package = "seqinr"))
stopifnot(identical(JLO, JLO.check))

#
# Try to reproduce figure 1A from Krawczyk et al. 2009:
#

Krawczyk &lt;- read.abif(system.file("abif/samplefsa2ps.fsa",
  package = "seqinr"))$Data
x &lt;- 1:length(Krawczyk[["DATA.1"]])
par(mar = c(2,4,2,0)+0.1, cex = 0.5)
plot(x, Krawczyk[["DATA.1"]], type = "l", col = "blue",
  ylab = "", xlab = "",
  ylim = c(-2000, 10000), cex = 0.5,
  main = "Figure 1A from Krawczyk et al. 2009",
  xaxs = "i", yaxs = "i",
  xaxt = "n", yaxt = "n")
axis(1, at = seq(2000, 24000, by = 2000))
axis(2, at = seq(-1000, 10000, by = 1000), las = 1)
lines(x, Krawczyk[["DATA.2"]], col = "green")
lines(x, Krawczyk[["DATA.3"]], col = "black")
lines(x, Krawczyk[["DATA.4"]], col = "red")

</code></pre>

<hr>
<h2 id='read.alignment'>Read aligned sequence files in mase, clustal, phylip, fasta or msf format</h2><span id='topic+read.alignment'></span>

<h3>Description</h3>

<p>Read a file in <code>mase</code>, <code>clustal</code>, <code>phylip</code>, <code>fasta</code> or <code>msf</code> format.
These formats are used to store nucleotide or protein multiple alignments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.alignment(file, format, forceToLower = TRUE, oldclustal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.alignment_+3A_file">file</code></td>
<td>
<p>the name of the file which the aligned sequences are to be read from.
If it does not contain an absolute or relative path, the file name is relative
to the current working directory, <code><a href="base.html#topic+getwd">getwd</a></code>. </p>
</td></tr>
<tr><td><code id="read.alignment_+3A_format">format</code></td>
<td>
<p>a character string specifying the format of the file : <code>mase</code>,
<code>clustal</code>, <code>phylip</code>, <code>fasta</code> or <code>msf</code> </p>
</td></tr>
<tr><td><code id="read.alignment_+3A_forcetolower">forceToLower</code></td>
<td>
<p>a logical defaulting to TRUE stating whether the returned
characters in the sequence should be in lower case (introduced in seqinR
release 1.1-3).</p>
</td></tr>
<tr><td><code id="read.alignment_+3A_oldclustal">oldclustal</code></td>
<td>
<p>a logical defaulting to FALSE wether to use the old C function to read a clustal file (which is faster but stricter concerning sequence line length.) </p>
</td></tr>
<tr><td><code id="read.alignment_+3A_...">...</code></td>
<td>
<p>For the <code>fasta</code> format, extra arguments are passed to the
<code><a href="#topic+read.fasta">read.fasta</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>&quot;mase&quot;</dt><dd><p>The mase format is used to store nucleotide or protein
multiple alignments. The beginning of the file must contain a header
containing at least one line (but the content of this header may be
empty). The header lines must begin by <code>;;</code>. The body of the
file has the following structure: First, each entry must begin by
one (or more) commentary line. Commentary lines begin by the character
<code>;</code>. Again, this commentary line may be empty. After the
commentaries, the name of the sequence is written on a separate
line. At last, the sequence itself is written on the following lines.
</p>
</dd>
<dt>&quot;clustal&quot;</dt><dd><p>The CLUSTAL format (*.aln) is the format of the
ClustalW multialignment tool output. It can be described as follows.
The word CLUSTAL is on the first line of the file. The alignment
is displayed in blocks of a fixed length, each line in the block
corresponding to one sequence. Each line of each block starts with
the sequence name (maximum of 10 characters), followed by at least
one space character. The sequence is then displayed in upper or
lower cases, '-' denotes gaps. The residue number may be displayed
at the end of the first line of each block.
</p>
</dd>
<dt>&quot;msf&quot;</dt><dd><p> MSF is the multiple sequence alignment format of the
GCG sequence analysis package. It begins with the line (all
uppercase) !!NA_MULTIPLE_ALIGNMENT 1.0 for nucleic acid sequences
or !!AA_MULTIPLE_ALIGNMENT 1.0 for amino acid sequences. Do
not edit or delete the file type if its present.(optional).
A description line which contains informative text describing what
is in the file. You can add this information to the top of the MSF
file using a text editor.(optional) A dividing line which contains
the number of bases or residues in the sequence, when the file was
created, and importantly, two dots (..) which act as a divider
between the descriptive information and the following sequence
information.(required) msf files contain some other information:
the Name/Weight, a Separating Line which must include two slashes
(//) to divide the name/weight information from the sequence
alignment.(required) and the multiple sequence alignment.
</p>
</dd>
<dt>&quot;phylip&quot;</dt><dd><p> PHYLIP is a tree construction program. The format
is as follows: the number of sequences and their length (in characters)
is on the first line of the file. The alignment is displayed in an
interleaved or sequential format. The sequence names are limited
to 10 characters and may contain blanks.
</p>
</dd>
<dt>&quot;fasta&quot;</dt><dd><p> Sequence in fasta format begins with a single-line
description (distinguished by a greater-than (&gt;) symbol), followed
by sequence data on the next line.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>alignment</code> which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>nb</code></td>
<td>
<p> the number of aligned sequences </p>
</td></tr>
<tr><td><code>nam</code></td>
<td>
<p> a vector of strings containing the names of the aligned sequences </p>
</td></tr>
<tr><td><code>seq</code></td>
<td>
<p> a vector of strings containing the aligned sequences</p>
</td></tr>
<tr><td><code>com</code></td>
<td>
<p> a vector of strings containing the commentaries for each sequence or <code>NA</code> if there are no comments </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>To read aligned sequences in NEXUS format, see the function
<code>read.nexus</code> that was available in the <code>CompPairWise</code> package
(not sure it is still maintained as of 09/09/09).
The NEXUS format was mainly used by the non-GPL commercial PAUP
software.
</p>
<p>Related functions: <code><a href="#topic+as.matrix.alignment">as.matrix.alignment</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>,
<code><a href="#topic+write.fasta">write.fasta</a></code>, <code><a href="#topic+reverse.align">reverse.align</a></code>, <code><a href="#topic+dist.alignment">dist.alignment</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mase.res   &lt;- read.alignment(file = system.file("sequences/test.mase", package = "seqinr"),
 format = "mase")
clustal.res &lt;- read.alignment(file = system.file("sequences/test.aln", package = "seqinr"),
 format="clustal")
phylip.res  &lt;- read.alignment(file = system.file("sequences/test.phylip", package = "seqinr"),
 format = "phylip")
msf.res      &lt;- read.alignment(file = system.file("sequences/test.msf", package = "seqinr"),
 format = "msf")
fasta.res    &lt;- read.alignment(file = system.file("sequences/Anouk.fasta", package = "seqinr"),
 format = "fasta")

#
# Quality control routine sanity checks:
#

data(mase); stopifnot(identical(mase, mase.res))
data(clustal); stopifnot(identical(clustal, clustal.res))
data(phylip); stopifnot(identical(phylip, phylip.res))
data(msf); stopifnot(identical(msf, msf.res))
data(fasta); stopifnot(identical(fasta, fasta.res))

#
# Example of using extra arguments from the read.fasta function, here to keep
# whole headers for sequences names.
#

whole.header.test &lt;-
 read.alignment(file = system.file("sequences/LTPs128_SSU_aligned_First_Two.fasta",
 package = "seqinr"), format = "fasta", whole.header = TRUE)
whole.header.test$nam

# Sould be:
#
# [1] "D50541\t1\t1411\t1411bp\trna\tAbiotrophia defectiva\tAerococcaceae"
# [2] "KP233895\t1\t1520\t1520bp\trna\tAbyssivirga alkaniphila\tLachnospiraceae"
#
</code></pre>

<hr>
<h2 id='read.fasta'> read FASTA formatted files </h2><span id='topic+read.fasta'></span><span id='topic+readfasta'></span><span id='topic+FASTA'></span>

<h3>Description</h3>

<p>Read nucleic or amino-acid sequences from a file in FASTA format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fasta(file = system.file("sequences/ct.fasta.gz", package = "seqinr"),
  seqtype = c("DNA", "AA"), as.string = FALSE, forceDNAtolower = TRUE,
  set.attributes = TRUE, legacy.mode = TRUE, seqonly = FALSE, strip.desc = FALSE,
  whole.header = FALSE,
  bfa = FALSE, sizeof.longlong = .Machine$sizeof.longlong,
  endian = .Platform$endian, apply.mask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.fasta_+3A_file">file</code></td>
<td>
<p> The name of the file which the sequences in fasta format are to be
read from. If it does not contain an absolute or relative path, the file name is relative
to the current working directory, <code><a href="base.html#topic+getwd">getwd</a></code>. The default here is to
read the <code>ct.fasta.gz</code> file which is present in the <code>sequences</code> folder
of the seqinR package.</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_seqtype">seqtype</code></td>
<td>
<p> the nature of the sequence: <code>DNA</code> or <code>AA</code>, defaulting
to <code>DNA</code> </p>
</td></tr>
<tr><td><code id="read.fasta_+3A_as.string">as.string</code></td>
<td>
<p> if TRUE sequences are returned as a string instead of a
vector of single characters</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_forcednatolower">forceDNAtolower</code></td>
<td>
<p> whether sequences with <code>seqtype == "DNA"</code> should be
returned as lower case letters </p>
</td></tr>
<tr><td><code id="read.fasta_+3A_set.attributes">set.attributes</code></td>
<td>
<p> whether sequence attributes should be set</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_legacy.mode">legacy.mode</code></td>
<td>
<p>if TRUE lines starting with a semicolon ';' are ignored</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_seqonly">seqonly</code></td>
<td>
<p>if TRUE, only sequences as returned without attempt to modify
them or to get their names and annotations (execution time is divided approximately
by a factor 3)</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_strip.desc">strip.desc</code></td>
<td>
<p>if TRUE the '&gt;' at the beginning of the description lines is removed
in the annotations of the sequences</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_whole.header">whole.header</code></td>
<td>
<p>if TRUE the whole header line, except the first '&gt;' character,
is kept for sequence name. If FALSE, the default, the name is truncated at the first
space (&quot; &quot;) character.</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_bfa">bfa</code></td>
<td>
<p>logical. If TRUE the fasta file is in MAQ binary format (see details).
Only for DNA sequences.</p>
</td></tr>
<tr><td><code id="read.fasta_+3A_sizeof.longlong">sizeof.longlong</code></td>
<td>
<p>the number of bytes in a C <code>long long</code> type.
Only relevant for <code>bfa = TRUE</code>. See <code><a href="base.html#topic+.Machine">.Machine</a></code></p>
</td></tr>
<tr><td><code id="read.fasta_+3A_endian">endian</code></td>
<td>
<p>character string, <code>"big"</code> or <code>"little"</code>, giving the
endianness of the processor in use. Only relevant for <code>bfa = TRUE</code>.
See <code><a href="base.html#topic+.Platform">.Platform</a></code></p>
</td></tr>
<tr><td><code id="read.fasta_+3A_apply.mask">apply.mask</code></td>
<td>
<p>logical defaulting to <code>TRUE</code>. Only relevant for
<code>bfa = TRUE</code>. When this flag is <code>TRUE</code> the mask in the MAQ
binary format is used to replace non acgt characters in the sequence
by the n character. For pure acgt sequences (without gaps or ambiguous
bases) turning this to <code>FALSE</code> will save time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FASTA is a widely used format in biology, some FASTA files are distributed
with the seqinr package, see the examples section below.
Sequence in FASTA format begins with a single-line
description (distinguished by a greater-than '&gt;' symbol), followed
by sequence data on the next lines. Lines starting by a semicolon ';'
are ignored, as in the original FASTA program (Pearson and Lipman 1988).
The sequence name is just after the '&gt;' up to the next space ' ' character,
trailling infos are ignored for the name but saved in the annotations.
</p>
<p>There is no standard file extension name for a FASTA file. Commonly
found values are .fasta, .fas, .fa and .seq for generic FASTA files.
More specific file extension names are also used for fasta sequence
alignement (.fsa), fasta nucleic acid (.fna), fasta functional
nucleotide (.ffn), fasta amino acid (.faa), multiple protein
fasta (.mpfa), fasta RNA non-coding (.frn).
</p>
<p>The MAQ fasta binary format was introduced in seqinR 1.1-7 and has not
been extensively tested. This format is used in the MAQ (Mapping and
Assembly with Qualities) software (<a href="https://maq.sourceforge.net/">https://maq.sourceforge.net/</a>).
In this format the four nucleotides are coded with two bits and the
sequence is stored as a vector of C <code>unsigned long long</code>. There
is in addition a mask to locate non-acgt characters.
</p>


<h3>Value</h3>

<p>By default <code>read.fasta</code> return a list of vector of chars. Each element
is a sequence object of the class <code>SeqFastadna</code> or <code>SeqFastaAA</code>.
</p>


<h3>Note</h3>

<p>The old argument <code>File</code> that was deprecated since seqinR &gt;= 1.1-3 is
no more valid since seqinR &gt;= 2.0-6. Just use <code>file</code> instead.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p>Pearson, W.R. and Lipman, D.J. (1988) Improved tools for biological
sequence comparison. <em>Proceedings of the National Academy
of Sciences of the United States of America</em>, <b>85</b>:2444-2448
</p>
<p>According to MAQ's FAQ page <a href="https://maq.sourceforge.net/faq.shtml">https://maq.sourceforge.net/faq.shtml</a>
last consulted 2016-06-07 the MAQ manuscript has not been published.
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.fasta">write.fasta</a></code> to write sequences in a FASTA file,
<code><a href="#topic+gb2fasta">gb2fasta</a></code> to convert a GenBank file into a FASTA file,
<code><a href="#topic+read.alignment">read.alignment</a></code> to read aligned sequences,
<code><a href="#topic+reverse.align">reverse.align</a></code> to get an alignment at the nucleic level from the
one at the amino-acid level </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Simple sanity check with a small FASTA file:
#
  smallFastaFile &lt;- system.file("sequences/smallAA.fasta", package = "seqinr")
  mySmallProtein &lt;- read.fasta(file = smallFastaFile, as.string = TRUE, seqtype = "AA")[[1]]
  stopifnot(mySmallProtein == "SEQINRSEQINRSEQINRSEQINR*")
#
# Simple sanity check with the gzipped version of the same small FASTA file:
#
  smallFastaFile &lt;- system.file("sequences/smallAA.fasta.gz", package = "seqinr")
  mySmallProtein &lt;- read.fasta(file = smallFastaFile, as.string = TRUE, seqtype = "AA")[[1]]
  stopifnot(mySmallProtein == "SEQINRSEQINRSEQINRSEQINR*")
#
# Example of a DNA file in FASTA format:
#
  dnafile &lt;- system.file("sequences/malM.fasta", package = "seqinr")
#
# Read with defaults arguments, looks like:
#
# $XYLEECOM.MALM
# [1] "a" "t" "g" "a" "a" "a" "a" "t" "g" "a" "a" "t" "a" "a" "a" "a" "g" "t"
# ...
  read.fasta(file = dnafile)
#
# The same but do not turn the sequence into a vector of single characters, looks like:
#
# $XYLEECOM.MALM
# [1] "atgaaaatgaataaaagtctcatcgtcctctgtttatcagcagggttactggcaagcgc
# ...
  read.fasta(file = dnafile, as.string = TRUE)
#
# The same but do not force lower case letters, looks like:
#
# $XYLEECOM.MALM
# [1] "ATGAAAATGAATAAAAGTCTCATCGTCCTCTGTTTATCAGCAGGGTTACTGGCAAGC
# ...
  read.fasta(file = dnafile, as.string = TRUE, forceDNAtolower = FALSE)
#
# Example of a protein file in FASTA format:
#
  aafile &lt;- system.file("sequences/seqAA.fasta", package = "seqinr")
#
# Read the protein sequence file, looks like:
#
# $A06852
# [1] "M" "P" "R" "L" "F" "S" "Y" "L" "L" "G" "V" "W" "L" "L" "L" "S" "Q" "L"
# ...
  read.fasta(aafile, seqtype = "AA")
#
# The same, but as string and without attributes, looks like:
#
# $A06852
# [1] "MPRLFSYLLGVWLLLSQLPREIPGQSTNDFIKACGRELVRLWVEICGSVSWGRTALSLEEP
# QLETGPPAETMPSSITKDAEILKMMLEFVPNLPQELKATLSERQPSLRELQQSASKDSNLNFEEFK
# KIILNRQNEAEDKSLLELKNLGLDKHSRKKRLFRMTLSEKCCQVGCIRKDIARLC*"
#
  read.fasta(aafile, seqtype = "AA", as.string = TRUE, set.attributes = FALSE)
#
# Example with a FASTA file that contains comment lines starting with
# a semicolon character ';'
#
  legacyfile &lt;- system.file("sequences/legacy.fasta", package = "seqinr")
  legacyseq &lt;- read.fasta(file = legacyfile, as.string = TRUE)
  stopifnot( nchar(legacyseq) == 921 )
#
# Example of a MAQ binary fasta file produced with maq fasta2bfa ct.fasta ct.bfa
# on a platform where .Platform$endian == "little" and .Machine$sizeof.longlong == 8
#
  fastafile &lt;- system.file("sequences/ct.fasta.gz", package = "seqinr")
  bfafile &lt;- system.file("sequences/ct.bfa", package = "seqinr")

  original &lt;- read.fasta(fastafile, as.string = TRUE, set.att = FALSE)
  bfavers &lt;- read.fasta(bfafile, as.string = TRUE, set.att = FALSE, bfa = TRUE,
    endian = "little", sizeof.longlong = 8)
  if(!identical(original, bfavers)){
     warning(paste("trouble reading bfa file on a platform with endian =",
     .Platform$endian, "and sizeof.longlong =", .Machine$sizeof.longlong))
  }
</code></pre>

<hr>
<h2 id='readBins'>Import GenMapper Bins configuration file</h2><span id='topic+readBins'></span>

<h3>Description</h3>

<p>In a Bins configuration file there is a description for a given identification
kit of the expected allele sizes for all the markers available in the kit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBins(file, 
  colnames = c("allele.name", "size.bp", "minus.bp", "plus.bp"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBins_+3A_file">file</code></td>
<td>
<p>The name of the Bins configuration file.</p>
</td></tr>
<tr><td><code id="readBins_+3A_colnames">colnames</code></td>
<td>
<p>The names to be used for the columns of the data.frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected allele sizes are typically plus or minus 0.5 bp.
</p>


<h3>Value</h3>

<p>A list whose first element is the file header info and following elements
are lists, one for each kit encountered in the file. For each kit we have
a list of data.frames, one per marker.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinR")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readPanels">readPanels</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Check that we can read the 2 exemple files in the seqinR package:
#
path1 &lt;- system.file("abif/AmpFLSTR_Bins_v1.txt", package = "seqinr")
resbin1 &lt;- readBins(path1)
path2 &lt;- system.file("abif/Promega_Bins_v1.txt", package = "seqinr")
resbin2 &lt;- readBins(path2)
#
# Show the kits described in resbin1:
#
names(resbin1)
#
# Show the markers in a given kit:
#
names(resbin1[["Identifiler_v1"]])
#
# Show alleles expected sizes for a given marker:
#
resbin1[["Identifiler_v1"]][["D8S1179"]]
#
# Simple quality check since seqinr 2.0-4 with a configuration file
# containing trailling tabulations:
#
path3 &lt;- system.file("abif/Prototype_PowerPlex_EP01_Bins.txt", package = "seqinr")
resbin3 &lt;- readBins(path3)
ncols &lt;- sapply(resbin3[[2]], ncol)
stopifnot(all(ncols == 4))
</code></pre>

<hr>
<h2 id='readfirstrec'>Low level function to get the record count of the specified ACNUC
index file</h2><span id='topic+readfirstrec'></span>

<h3>Description</h3>

<p>Called without arguments, the list of available values for argument type is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readfirstrec(socket = autosocket(), type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readfirstrec_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="readfirstrec_+3A_type">type</code></td>
<td>
<p>the ACNUC index file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available index files are:
</p>

<dl>
<dt>AUT</dt><dd><p>AUTHOR one record for each author name (last name only, no initials)</p>
</dd>
<dt>BIB</dt><dd><p>BIBLIO one record for each reference</p>
</dd>
<dt>ACC</dt><dd><p>ACCESS one record for each accession number</p>
</dd>
<dt>SMJ</dt><dd><p>SMJYT one record for each status, molecule, journal, year, type,
organelle, division, and db structure information</p>
</dd>
<dt>SUB</dt><dd><p>SUBSEQ one record for each parent or sub-sequence</p>
</dd>
<dt>LOC</dt><dd><p>LOCUS one record for each parent sequence</p>
</dd>
<dt>KEY</dt><dd><p>KEYWORDS one record for each keyword</p>
</dd>
<dt>SPEC</dt><dd><p>SPECIES one record for each taxon</p>
</dd>
<dt>SHRT</dt><dd><p>SHORTL mostly, one record for each element of a short list</p>
</dd>
<dt>LNG</dt><dd><p>LONGL one record for each group of SUBINLNG elements of a long list</p>
</dd>
<dt>EXT</dt><dd><p>EXTRACT (for nucleotide databases only) one record for each exon of each subsequence</p>
</dd>
<dt>TXT</dt><dd><p>TEXT one lrtxt-character record for each label of a species, keyword, or SMJYT</p>
</dd>
</dl>



<h3>Value</h3>

<p>The record count of ACNUC index file, or NA if missing (typically when
asking for type = EXT on a protein database).
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p>See ACNUC physical structure at
<a href="https://doua.prabi.fr/databases/acnuc/structure.html">https://doua.prabi.fr/databases/acnuc/structure.html</a>.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+choosebank">choosebank</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Need internet connection
  choosebank("genbank")
  allowedtype &lt;- readfirstrec()
  sapply(allowedtype, function(x) readfirstrec(type = x))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='readPanels'>Import GenMapper Panels configuration file</h2><span id='topic+readPanels'></span>

<h3>Description</h3>

<p>In a Panel configuration file there is a description for a given identification
kit of the marker names, their dye label color, expected size range,
expected positive control genotypes, number of bases in core repeat,
stutter percentages, and allele names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readPanels(file,
  colnames = c("marker", "dye.col", "min.bp", "max.bp", "exp.pcg", "repeat.bp",
    "stutter.pc", "uknw", "allele names"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readPanels_+3A_file">file</code></td>
<td>
<p>The name of the Panel configuration file.</p>
</td></tr>
<tr><td><code id="readPanels_+3A_colnames">colnames</code></td>
<td>
<p>The names to be used for the columns of the data.frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Number of bases in core repeat is set to 9 for Amelogenin locus.
</p>


<h3>Value</h3>

<p>A list whose first element is the file header info and following elements
data.frames, one for each kit encountered in the file.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinR")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readBins">readBins</a></code>, <code><a href="#topic+plotPanels">plotPanels</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Check that we can read the 2 exemple files in the seqinR package:
#
path1 &lt;- system.file("abif/AmpFLSTR_Panels_v1.txt", package = "seqinr")
res1 &lt;- readPanels(path1)
path2 &lt;- system.file("abif/Promega_Panels_v1.txt", package = "seqinr")
res2 &lt;- readPanels(path2)
#
# Show the kits described in res1:
#
names(res1)
#
# Show some data for a given kit:
#
res1[["Identifiler_v1"]][, 1:7]
#
# Plot a simple summary of two kits:
#
par(mfrow = c(2,1))
plotPanels("Identifiler_v1", res1)
plotPanels("PowerPlex_16_v1", res2)

#
# Simple quality check since seqinR 2.0-4 with a file which containing
# a non constant number of tabulations as separator:
#
path3 &lt;- system.file("abif/Prototype_PowerPlex_EP01_Pa.txt", package = "seqinr")
res3 &lt;- readPanels(path3)
</code></pre>

<hr>
<h2 id='readsmj'>Low level function to read ACNUC SMJYT index files</h2><span id='topic+readsmj'></span>

<h3>Description</h3>

<p>Extract informations from the SMJYT index file for status, molecule, journal,
year, type, organelle, division, and db structure information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readsmj(socket = autosocket(), num = 2, nl = 10, recnum.add = FALSE, nature.add = TRUE,
plong.add = FALSE, libel.add = FALSE, sname.add = FALSE, all.add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readsmj_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="readsmj_+3A_num">num</code></td>
<td>
<p>rank number of first record.</p>
</td></tr>
<tr><td><code id="readsmj_+3A_nl">nl</code></td>
<td>
<p>number of records to read.</p>
</td></tr>
<tr><td><code id="readsmj_+3A_recnum.add">recnum.add</code></td>
<td>
<p>to extract record numbers.</p>
</td></tr>
<tr><td><code id="readsmj_+3A_nature.add">nature.add</code></td>
<td>
<p>to extract as a factor with human understandable levels
the nature of the name. Unordered levels are: status, molecule, journal,
year, type, organelle, division and dbstrucinfo.</p>
</td></tr>
<tr><td><code id="readsmj_+3A_plong.add">plong.add</code></td>
<td>
<p>to extract the plong.</p>
</td></tr>
<tr><td><code id="readsmj_+3A_libel.add">libel.add</code></td>
<td>
<p>to extract the label of the name.</p>
</td></tr>
<tr><td><code id="readsmj_+3A_sname.add">sname.add</code></td>
<td>
<p>to extract the short version of the name, that is without
the first two characters.</p>
</td></tr>
<tr><td><code id="readsmj_+3A_all.add">all.add</code></td>
<td>
<p>to extract all (all flags set to TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with requested columns.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p>See ACNUC physical structure at:
<a href="https://doua.prabi.fr/databases/acnuc/structure.html">https://doua.prabi.fr/databases/acnuc/structure.html</a>.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+choosebank">choosebank</a></code> to start a session and
<code><a href="#topic+readfirstrec">readfirstrec</a></code> to get the total number of records.</p>

<hr>
<h2 id='rearranged.oriloc'>Detection of replication-associated effects on base composition asymmetry in
prokaryotic chromosomes.</h2><span id='topic+rearranged.oriloc'></span>

<h3>Description</h3>

<p>Detection of replication-associated effects on base composition asymmetry in
prokaryotic chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rearranged.oriloc(seq.fasta = system.file("sequences/ct.fasta.gz", package = "seqinr"),
  g2.coord = system.file("sequences/ct.predict", package = "seqinr"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rearranged.oriloc_+3A_seq.fasta">seq.fasta</code></td>
<td>
<p>The path of the file containing a FASTA-format
sequence. Default value: 
the FASTA sequence of the Chlamydia trachomatis chromosome. </p>
</td></tr>
<tr><td><code id="rearranged.oriloc_+3A_g2.coord">g2.coord</code></td>
<td>
<p>The path of the file containing the coordinates of the
protein coding genes found on this chromosome. This file can be
obtained using the function <code>gbk2g2</code>. The format of the file is
similar to the output of the Glimmer2 program. The first column
contains the index or the name of the gene, the second one contains
the start position and the third column contains the end position. For
reverse transcribed genes, the start position is greater than the end position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this method is to decouple replication-related
and coding sequence-related  effects on base composition asymmetry. In
order to do so, the analyzed chromosome is artificially rearranged to
obtain a perfect gene orientation bias - all forward transcribed genes
on the first half of the chromosome, and all reverse transcribed genes
on the other half.
This rearrangement conserves the relative order of genes within each of
the two groups  - both forward-encoded and reverse-encoded genes are
placed on the rearranged chromosome in increasing order of their
coordinates on the real chromosome.
If the replication mechanism has a significant effect on base
composition asymmetry, this should be seen as a change of slope in the
nucleotide skews computed on the rearranged chromosome; the change of
slope should take place at the origin or the terminus of replication.
Use <code>extract.breakpoints</code> to detect the position of the changes in
slope on the rearranged nucleotide skews.
</p>


<h3>Value</h3>

<p>A data.frame with six columns: <code>meancoord.rearr</code> contains the
gene index on the rearranged chromosome; <code>gcskew.rearr</code> contains
the normalized GC-skew ((G-C)/(G+C)) computed on the third codon positions of
protein coding genes, still on the rearranged chromosome;  <code>atskew.rearr</code> contains
the normalized AT-skew ((A-T)/(A+T)) computed on the third codon positions of
protein coding genes; <code>strand.rearr</code> contains the transcription
strand of the gene (either &quot;forward&quot; or &quot;reverse&quot;); <code>order</code>
contains the permutation that was used to obtain a perfect gene
orientation bias; <code>meancoord.real</code> contains the mid-coordinate of
the genes on the real chromosome (before the rearrangement).
</p>


<h3>Author(s)</h3>

<p>A. Necşulea</p>


<h3>References</h3>

<p>Necşulea, A. and Lobry, J.R. (2007) A New Method for Assessing the 
Effect of Replication on DNA Base Composition Asymmetry.
<em>Molecular Biology and Evolution</em>, <b>24</b>:2169-2179.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+oriloc">oriloc</a></code>, <code><a href="#topic+draw.rearranged.oriloc">draw.rearranged.oriloc</a></code>,
<code><a href="#topic+extract.breakpoints">extract.breakpoints</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example for Chlamydia trachomatis ####

### Rearrange the chromosome and compute the nucleotide skews ###

## Not run: r.ori &lt;- rearranged.oriloc(seq.fasta = 
   system.file("sequences/ct.fasta.gz", package = "seqinr"),
    g2.coord =  system.file("sequences/ct.predict", package = "seqinr"))
## End(Not run)

### Extract the breakpoints for the rearranged nucleotide skews ###



## Not run: breaks &lt;- extract.breakpoints(r.ori, type = c("gcfw", "gcrev"), 
 nbreaks =c(2, 2), gridsize = 50, it.max = 100)
## End(Not run)



### Draw the rearranged nucleotide skews and place the position of the breakpoints ### 
### on the graphics ###

## Not run: draw.rearranged.oriloc(r.ori, breaks.gcfw = breaks$gcfw$breaks,
 breaks.gcrev = breaks$gcrev$breaks)
## End(Not run)


</code></pre>

<hr>
<h2 id='recstat'>Prediction of Coding DNA Sequences.</h2><span id='topic+recstat'></span>

<h3>Description</h3>

<p>This function aims at predicting the position of Coding DNA Sequences (CDS) through
the use of a Correspondence Analysis (CA) computed on codon composition, this for the three
reading frames of a DNA strand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recstat(seq, sizewin = 90, shift = 30, seqname = "no name")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recstat_+3A_seq">seq</code></td>
<td>
<p>a nucleic acid sequence as a vector of characters</p>
</td></tr>
<tr><td><code id="recstat_+3A_sizewin">sizewin</code></td>
<td>
<p>an integer, multiple of 3,  giving the length of the sliding window</p>
</td></tr>
<tr><td><code id="recstat_+3A_shift">shift</code></td>
<td>
<p>an integer, multiple of 3, giving the length of the steps between two windows</p>
</td></tr>
<tr><td><code id="recstat_+3A_seqname">seqname</code></td>
<td>
<p>the name of the sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is built on the hypothesis that the codon composition of a CDS is biased
while it is not the case outside these regions. In order to detect such bias, a CA on codon
frequencies is computed on the six possible reading frames of a DNA sequence (three from the
direct strand and three from the reverse strand). When there is a CDS in one of the reading
frame, it is expected that the CA factor scores observed in this frame (fot both rows and
columns) will be significantly different from those in the two others.</p>


<h3>Value</h3>

<p>This function returns a list containing the following components:<br />
</p>
<table role = "presentation">
<tr><td><code>seq</code></td>
<td>
<p>a single DNA sequence as a vector of characters</p>
</td></tr>
<tr><td><code>sizewin</code></td>
<td>
<p>length of the sliding window</p>
</td></tr>
<tr><td><code>shift</code></td>
<td>
<p>length of the steps between windows</p>
</td></tr>
<tr><td><code>seqsize</code></td>
<td>
<p>length of the sequence</p>
</td></tr>
<tr><td><code>seqname</code></td>
<td>
<p>name of the sequence</p>
</td></tr>
<tr><td><code>vdep</code></td>
<td>
<p>a vector containing the positions of windows starts</p>
</td></tr>
<tr><td><code>vind</code></td>
<td>
<p>a vector containing the reading frame of each window</p>
</td></tr>
<tr><td><code>vstopd</code></td>
<td>
<p>a vector of stop codons positions in direct strand</p>
</td></tr>
<tr><td><code>vstopr</code></td>
<td>
<p>a vector of stop codons positions in reverse strand</p>
</td></tr>
<tr><td><code>vinitd</code></td>
<td>
<p>a vector of start codons positions in direct strand</p>
</td></tr>
<tr><td><code>vinitr</code></td>
<td>
<p>a vector of start codons positions in reverse strand</p>
</td></tr>
<tr><td><code>resd</code></td>
<td>
<p>a matrix containing codons frequencies for all the windows in the three frames
of the direct strand</p>
</td></tr>
<tr><td><code>resr</code></td>
<td>
<p>a matrix containing codons frequencies for all the windows in the three frames
of the reverse strand</p>
</td></tr>
<tr><td><code>resd.coa</code></td>
<td>
<p>list of class <code>coa</code> and <code>dudi</code> containing the result of the
CA computed on the codons frequencies in the direct strand</p>
</td></tr>
<tr><td><code>resr.coa</code></td>
<td>
<p>list of class <code>coa</code> and <code>dudi</code> containing the result of the
CA computed on the codons frequencies in the reverse strand</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This method works only with DNA sequences long enough to obtain a sufficient number
of windows. As the optimal windows length has been estimated to be 90 bp by Fichant and
Gautier (1987), the minimal sequence length is around 500 bp. The method can be used on
prokaryotic and eukaryotic sequences. Also, only the four first factors of the CA are kept.
Indeed, most of the time, only the first factor is relevant in order to detect CDS.
</p>


<h3>Author(s)</h3>

<p>O. Clerc, G. Perrière</p>


<h3>References</h3>

<p>The original paper describing recstat is:<br />
</p>
<p>Fichant, G., Gautier, C. (1987) Statistical method for predicting protein coding
regions in nucleic acid sequences. <em>Comput. Appl. Biosci.</em>, <b>3</b>, 287&ndash;295.<br />
<a href="https://academic.oup.com/bioinformatics/article-abstract/3/4/287/218186">https://academic.oup.com/bioinformatics/article-abstract/3/4/287/218186</a><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw.recstat">draw.recstat</a></code>, <code><a href="#topic+test.li.recstat">test.li.recstat</a></code>, <code><a href="#topic+test.co.recstat">test.co.recstat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- system.file("sequences/ECOUNC.fsa", package = "seqinr")
seq &lt;- read.fasta(ff)
rec &lt;- recstat(seq[[1]], seqname = getName(seq))
</code></pre>

<hr>
<h2 id='residuecount'>Total number of residues in an ACNUC list</h2><span id='topic+residuecount'></span>

<h3>Description</h3>

<p>Computes the total number of residues (nucleotides or aminoacids) in
all sequences of the list of specified rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuecount(lrank, socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuecount_+3A_lrank">lrank</code></td>
<td>
<p>the list rank on the ACNUC server</p>
</td></tr>
<tr><td><code id="residuecount_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value corresponding to  the total number of residues or
NA in case of problem.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code>, <code><a href="#topic+glr">glr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "t=CDS", virtual = TRUE)
  stopifnot(residuecount(glr("mylist")) == 1611439240)
  stopifnot(is.na(residuecount(glr("unknowlist")))) # A warning is issued
  
## End(Not run)
</code></pre>

<hr>
<h2 id='revaligntest'> Three aligned nucleic acid sequences </h2><span id='topic+revaligntest'></span>

<h3>Description</h3>

<p>This dataset is used as a sanity check in <code><a href="#topic+reverse.align">reverse.align</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(revaligntest)
</code></pre>


<h3>Format</h3>

<p>An object of class alignment with 3 sequences.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+reverse.align">reverse.align</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(revaligntest)
</code></pre>

<hr>
<h2 id='reverse.align'> Reverse alignment - from protein sequence alignment to nucleic sequence alignment </h2><span id='topic+reverse.align'></span>

<h3>Description</h3>

<p>This function produces an alignment of nucleic protein-coding sequences, using as a
guide the alignment of the corresponding protein sequences. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse.align(nucl.file, protaln.file, input.format = 'fasta', out.file,
  output.format = 'fasta', align.prot = FALSE, numcode = 1,
  clustal.path = NULL, forceDNAtolower = TRUE, forceAAtolower = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse.align_+3A_nucl.file">nucl.file</code></td>
<td>
<p> A character string specifying the name of the FASTA format file containing the nucleotide sequences. </p>
</td></tr>
<tr><td><code id="reverse.align_+3A_protaln.file">protaln.file</code></td>
<td>
<p>A character string specifying the name of the file containing the aligned
protein sequences. This argument must be provided if <code>align.prot</code> is
set to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="reverse.align_+3A_input.format">input.format</code></td>
<td>
<p> A character string specifying the format of the
protein alignment file : 'mase', 'clustal', 'phylip', 'fasta' or 'msf'.  </p>
</td></tr>
<tr><td><code id="reverse.align_+3A_out.file">out.file</code></td>
<td>
<p>A character string specifying the name of the output file. </p>
</td></tr>
<tr><td><code id="reverse.align_+3A_output.format">output.format</code></td>
<td>
<p> A character string specifying the format of the output file. Currently the only
implemented format is 'fasta'. </p>
</td></tr>
<tr><td><code id="reverse.align_+3A_align.prot">align.prot</code></td>
<td>
<p>Boolean. If TRUE, the nucleic sequences are
translated and then the protein sequences are aligned with the ClustalW program. The path
of the ClustalW binary must also be given (<code>clustal.path</code>) </p>
</td></tr>
<tr><td><code id="reverse.align_+3A_numcode">numcode</code></td>
<td>
<p>The NCBI genetic code number for the translation of the
nucleic sequences. By default the standard genetic code is used.</p>
</td></tr>
<tr><td><code id="reverse.align_+3A_clustal.path">clustal.path</code></td>
<td>
<p> The path of the ClustalW binary. This argument
only needs to be setif <code>align.prot</code> is TRUE. </p>
</td></tr>
<tr><td><code id="reverse.align_+3A_forcednatolower">forceDNAtolower</code></td>
<td>
<p>logical passed to <code><a href="#topic+read.fasta">read.fasta</a></code> for reading 
the nucleic acid file.</p>
</td></tr>
<tr><td><code id="reverse.align_+3A_forceaatolower">forceAAtolower</code></td>
<td>
<p>logical passed to <code><a href="#topic+read.alignment">read.alignment</a></code> for reading 
the aligned protein sequence file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function an alignment of nucleic protein-coding sequences using as a
guide the alignment of the corresponding protein sequences. The file containing
the nucleic sequences is given in the compulsory argument 'nucl.file';
this file must be written in the FASTA format.
</p>
<p>The alignment of the protein sequences can either be provided
directly, trough the 'protaln.file' parameter, or reconstructed with
ClustalW, if the parameter 'align.prot' is set to TRUE. In the latter
case, the pathway of the ClustalW binary must be given in the
'clustal.path' argument. 
</p>
<p>The protein and nucleic sequences must have the same name in the files
<code>nucl.file</code> and <code>protaln.file</code>.
</p>
<p>The reverse-aligned nucleotide sequences are written to the file
specified in the compulsory 'out.file' argument. For now, the only
output format implemented is FASTA.
</p>
<p>Warning: the 'align.prot=TRUE' option has only been tested on LINUX
operating systems. ClustalW must be installed on your system in order
for this to work.  
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>A. Necşulea</p>


<h3>References</h3>

<p><code>citation('seqinr')</code>
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+read.alignment">read.alignment</a></code>, <code><a href="#topic+read.fasta">read.fasta</a></code>, <code><a href="#topic+write.fasta">write.fasta</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Read example 'bordetella.fasta': a triplet of orthologous genes from
# three bacterial species (Bordetella pertussis, B. parapertussis and
# B. bronchiseptica):
#

nucl.file &lt;- system.file('sequences/bordetella.fasta', package = 'seqinr')
triplet &lt;- read.fasta(nucl.file)

# 
# For this example, 'bordetella.pep.aln' contains the aligned protein
# sequences, in the Clustal format:
#

protaln.file &lt;- system.file('sequences/bordetella.pep.aln', package = 'seqinr')
triplet.pep&lt;- read.alignment(protaln.file, format = 'clustal')

#
# Call reverse.align for this example:
#
myOutFileName &lt;-tempfile(pattern = "test", tmpdir = tempdir(), fileext = "revalign")
tempdir(check = FALSE)

#reverse.align(nucl.file = nucl.file, protaln.file = protaln.file,
#                     input.format = 'clustal', out.file = 'test.revalign')

reverse.align(nucl.file = nucl.file, protaln.file = protaln.file,
                     input.format = 'clustal', out.file = myOutFileName)

#
# Simple sanity check against expected result:
#

#res.new &lt;- read.alignment("test.revalign", format = "fasta")

res.new &lt;- read.alignment(myOutFileName, format = "fasta")
data(revaligntest)
stopifnot(identical(res.new, revaligntest))

#
# Alternatively, we can use ClustalW to align the translated nucleic
# sequences. Here the ClustalW program is accessible simply by the
# 'clustalw' name.
#

## Not run: 
reverse.align(nucl.file = nucl.file, out.file = 'test.revalign.clustal', 
  align.prot = TRUE, clustal.path = 'clustalw')
## End(Not run)
</code></pre>

<hr>
<h2 id='rot13'>Ergheaf gur EBG-13 pvcurevat bs n fgevat</h2><span id='topic+rot13'></span>

<h3>Description</h3>

<p>rot13 applied to the above title returns the string
&quot;Returns the ROT-13 ciphering of a string&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot13(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rot13_+3A_string">string</code></td>
<td>
<p>a string of characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string of characters.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chartr">chartr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Simple ciphering of a string:
##

message &lt;- "Hello, world!"
rot13(message) # "Uryyb, jbeyq!"

##
## Routine sanity check:
##

stopifnot(identical(rot13(rot13(message)), message))
</code></pre>

<hr>
<h2 id='s2c'> conversion of a string into a vector of chars </h2><span id='topic+s2c'></span>

<h3>Description</h3>

<p>This is a simple utility function to convert a single string such
as <code>"BigBang"</code> into a vector of chars such as
<code>c("B", "i", "g", "B", "a", "n", "g")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2c(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s2c_+3A_string">string</code></td>
<td>
<p> a string of chars </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of chars. If supplied argument is not a single string, a warning is
issued and NA returned.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+c2s">c2s</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(all(s2c("BigBang") == c("B", "i", "g", "B", "a", "n", "g")))
</code></pre>

<hr>
<h2 id='s2n'> simple numerical encoding of a DNA sequence.
</h2><span id='topic+s2n'></span>

<h3>Description</h3>

<p>By default, if no <code>levels</code> arguments is provided, this function will
just code your DNA sequence in integer values following the lexical
order <code>(a &gt; c &gt; g &gt; t)</code>, that is 0 for &quot;a&quot;, 1 for &quot;c&quot;, 2 for &quot;g&quot;, 3 for
&quot;t&quot; and NA for ambiguous bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2n(seq, levels = s2c("acgt"), base4 = TRUE, forceToLower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s2n_+3A_seq">seq</code></td>
<td>
<p> the sequence as a vector of single chars </p>
</td></tr>
<tr><td><code id="s2n_+3A_levels">levels</code></td>
<td>
<p> allowed char values, by default a, c, g and t </p>
</td></tr>
<tr><td><code id="s2n_+3A_base4">base4</code></td>
<td>
<p>if TRUE the numerical encoding will start at O, if
FALSE at 1</p>
</td></tr>
<tr><td><code id="s2n_+3A_forcetolower">forceToLower</code></td>
<td>
<p>if TRUE the sequence is forced to lower case caracters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of integers
</p>


<h3>Note</h3>

<p>The idea of starting numbering at 0 by default is that it enforces 
a kind of isomorphism between the paste operator on DNA chars and 
the + operator on integer coding for DNA chars. By this way, you can
work either in the char set, either in the integer set, depending
on what is more convenient for your purpose, and then switch from one 
set to the other one as you like.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry </p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+n2s">n2s</a></code>, <code><a href="base.html#topic+factor">factor</a></code>, <code><a href="base.html#topic+unclass">unclass</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Example of default behaviour:
##
urndna &lt;- s2c("acgt")
seq &lt;- sample( urndna, 100, replace = TRUE ) ; seq
s2n(seq)
##
## How to deal with RNA:
##
urnrna &lt;- s2c("acgt")
seq &lt;- sample( urnrna, 100, replace = TRUE ) ; seq
s2n(seq)
##
## what happens with unknown characters:
##
urnmess &lt;- c(urndna,"n")
seq &lt;- sample( urnmess, 100, replace = TRUE ) ; seq
s2n(seq)
##
## How to change the encoding for unknown characters:
##
tmp &lt;- s2n(seq) ; tmp[is.na(tmp)] &lt;- -1; tmp
##
## Simple sanity check:
##
stopifnot(all(s2n(s2c("acgt")) == 0:3))
</code></pre>

<hr>
<h2 id='savelist'>Save sequence names or accession numbers into a file</h2><span id='topic+savelist'></span>

<h3>Description</h3>

<p>This function retrieves all sequence names or all accession number from
an ACNUC list and saves them into a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>savelist(lrank, type = c("N", "A"),
                     filename = paste(gln(lrank), ifelse(type == "N", "mne", "acc"),
		     sep = "."),socket = autosocket(), warnme = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="savelist_+3A_lrank">lrank</code></td>
<td>
<p>the rank of the ACNUC list to consider.</p>
</td></tr>
<tr><td><code id="savelist_+3A_type">type</code></td>
<td>
<p>use &quot;N&quot; for sequence names (mnemonics) and &quot;A&quot; for accession numbers.
Default is &quot;N&quot;.</p>
</td></tr>
<tr><td><code id="savelist_+3A_filename">filename</code></td>
<td>
<p>a string of character giving the name of the file to save results.</p>
</td></tr>
<tr><td><code id="savelist_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
<tr><td><code id="savelist_+3A_warnme">warnme</code></td>
<td>
<p>if TRUE a message is issued on the console when complete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code>, <code><a href="#topic+glr">glr</a></code> to
get a list rank from its name, <code><a href="#topic+clfcd">clfcd</a></code> for the inverse operation
of <code>savelist</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "sp=felis catus et t=cds", virtual=TRUE)
  savelist(glr("mylist"))
  # 603 sequence mnemonics written into file: MYLIST.mne
  savelist(glr("mylist"), type = "A")
  # 603 sequence accession numbers written into file: MYLIST.acc
  
## End(Not run)
</code></pre>

<hr>
<h2 id='SeqAcnucWeb'>Sequence coming from a remote ACNUC data base</h2><span id='topic+SeqAcnucWeb'></span><span id='topic+as.SeqAcnucWeb'></span><span id='topic+is.SeqAcnucWeb'></span>

<h3>Description</h3>

<p><code>as.SeqAcnucWeb</code> is called by many functions, for instance by <code>query</code>, 
and should not be directly called by the user. It creates an object of class <code>SeqAcnucWeb</code>. 
<code>is.SeqAcnucWeb</code> returns TRUE if the object is of class <code>SeqAcnucWeb</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SeqAcnucWeb(object, length, frame, ncbigc)
is.SeqAcnucWeb(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SeqAcnucWeb_+3A_object">object</code></td>
<td>
<p> a string giving the name of a sequence present in the data base</p>
</td></tr>
<tr><td><code id="SeqAcnucWeb_+3A_length">length</code></td>
<td>
<p> a string giving the length of the sequence present in the data base</p>
</td></tr>
<tr><td><code id="SeqAcnucWeb_+3A_frame">frame</code></td>
<td>
<p> a string giving the frame of the sequence present in the data base</p>
</td></tr>
<tr><td><code id="SeqAcnucWeb_+3A_ncbigc">ncbigc</code></td>
<td>
<p> a string giving the ncbi genetic code of the sequence present in the data base</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.SeqAcnucWeb</code> returns an object sequence of class <code>SeqAcnucWeb</code>. Note
that as from seqinR 1.1-3 the slot socket has been deleted to save space for long lists.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: # Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "sp=felis catus et t=cds et o=mitochondrion")
  stopifnot(is.SeqAcnucWeb(mylist$req[[1]]))
  closebank()

## End(Not run)
</code></pre>

<hr>
<h2 id='SeqFastaAA'>AA sequence in Fasta Format</h2><span id='topic+SeqFastaAA'></span><span id='topic+is.SeqFastaAA'></span><span id='topic+as.SeqFastaAA'></span><span id='topic+summary.SeqFastaAA'></span>

<h3>Description</h3>

<p><code>as.SeqFastaAA</code> is called by the function as <code>read.fasta</code>. It creates an object of class <code>SeqFastaAA</code>. 
<code>is.SeqFastaAA</code> returns TRUE if the object is of class <code>SeqFastaAA</code>. 
<code>summary.SeqFastaAA</code> gives the AA composition of an object of class <code>SeqFastaAA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SeqFastaAA(object, name = NULL, Annot = NULL)
is.SeqFastaAA(object)
## S3 method for class 'SeqFastaAA'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SeqFastaAA_+3A_object">object</code></td>
<td>
<p> a vector of chars representing a biological sequence </p>
</td></tr>
<tr><td><code id="SeqFastaAA_+3A_name">name</code></td>
<td>
 <p><code>NULL</code> a character string specifying a name for the sequence </p>
</td></tr> 
<tr><td><code id="SeqFastaAA_+3A_annot">Annot</code></td>
<td>
 <p><code>NULL</code> a character string specifying some annotations for the sequence </p>
</td></tr>	
<tr><td><code id="SeqFastaAA_+3A_...">...</code></td>
<td>
<p> additional arguments affecting the summary produced </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.SeqFastaAA</code> returns an object sequence of class <code>SeqFastaAA</code>.
<code>summary.SeqFastaAA</code> returns a list which the following components:
</p>
<table role = "presentation">
<tr><td><code>composition</code></td>
<td>
<p> the AA counting of the sequence</p>
</td></tr> 
<tr><td><code>AA.Property</code></td>
<td>
<p> the percentage of each group of amino acid in the sequence. By example, the groups are small, tiny, aliphatic, aromatic ... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D. Charif</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  s &lt;- read.fasta(file = system.file("sequences/seqAA.fasta", package = "seqinr"), seqtype="AA")
  is.SeqFastaAA(s[[1]])
  summary(s[[1]])
  myseq &lt;- s2c("MSPTAYRRGSPAFLV*")
  as.SeqFastaAA(myseq, name = "myseq", Annot = "blablabla")
  myseq
</code></pre>

<hr>
<h2 id='SeqFastadna'> Class for DNA sequence in Fasta Format</h2><span id='topic+SeqFastadna'></span><span id='topic+is.SeqFastadna'></span><span id='topic+as.SeqFastadna'></span><span id='topic+summary.SeqFastadna'></span>

<h3>Description</h3>

<p><code>as.SeqFastadna</code> is called by many functions as <code>read.fasta</code>. It creates an object of class <code>SeqFastadna</code>. 
<code>is.SeqFastadna</code> returns TRUE if the object is of class <code>SeqFastadna</code>. 
<code>summary.SeqFastadna</code> gives the base composition of an object of class <code>SeqFastadna</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SeqFastadna(object, name = NULL, Annot = NULL)
is.SeqFastadna(object)
## S3 method for class 'SeqFastadna'
summary(object, alphabet = s2c("acgt"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SeqFastadna_+3A_object">object</code></td>
<td>
<p>a vector of chars representing a biological sequence</p>
</td></tr> 
<tr><td><code id="SeqFastadna_+3A_name">name</code></td>
<td>
 <p><code>NULL</code> a character string specifying a name for the sequence </p>
</td></tr> 
<tr><td><code id="SeqFastadna_+3A_annot">Annot</code></td>
<td>
 <p><code>NULL</code> a character string specifying some annotations for the sequence </p>
</td></tr>
<tr><td><code id="SeqFastadna_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced</p>
</td></tr>
<tr><td><code id="SeqFastadna_+3A_alphabet">alphabet</code></td>
<td>
<p>a vector of single characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.SeqFastadna</code> returns an object sequence of class <code>SeqFastadna</code>.
<code>summary.SeqFastadna</code> returns a list which the following components:
</p>
<table role = "presentation">
<tr><td><code>length</code></td>
<td>
<p> the legth of the sequence</p>
</td></tr>
<tr><td><code>compo</code></td>
<td>
<p>the base counting of the sequence</p>
</td></tr> 
<tr><td><code>GC</code></td>
<td>
<p>the percentage of G+C in the sequence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D. Charif</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> s &lt;- read.fasta(system.file("sequences/malM.fasta",package="seqinr"))
 is.SeqFastadna(s[[1]])
 summary(s[[1]])
 myseq &lt;- s2c("acgttgatgctagctagcatcgat")
 as.SeqFastadna(myseq, name = "myseq", Annot = "blablabla")
 myseq
</code></pre>

<hr>
<h2 id='SeqFrag'>Class for sub-sequences</h2><span id='topic+SeqFrag'></span><span id='topic+is.SeqFrag'></span><span id='topic+as.SeqFrag'></span>

<h3>Description</h3>

<p><code>as.SeqFrag</code> is called by all methods of <code><a href="#topic+getFrag">getFrag</a></code>, but not directly by the users. It creates an object sequence of class <code>SeqFrag</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> as.SeqFrag(object, begin, end, name)
 is.SeqFrag(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SeqFrag_+3A_object">object</code></td>
<td>
<p> an object sequence of class <code>seqFastadna</code>, <code>seqFastaAA</code>, <code>seqAcnucWeb</code> or <code>seqFrag</code> </p>
</td></tr>
<tr><td><code id="SeqFrag_+3A_begin">begin</code></td>
<td>
<p> the first base of the fragment to get </p>
</td></tr>
<tr><td><code id="SeqFrag_+3A_end">end</code></td>
<td>
<p> the last base of the fragment to get </p>
</td></tr>
<tr><td><code id="SeqFrag_+3A_name">name</code></td>
<td>
<p> the name of the sequence </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.SeqFrag</code> returns a biological sequence with the following attributes:
</p>
<table role = "presentation">
<tr><td><code>seqMother</code></td>
<td>
<p> the name of the sequence from which the sequence comes</p>
</td></tr>
<tr><td><code>begin</code></td>
<td>
<p> the position of the first base of the fragment on the mother sequence</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p> the position of the last base of the fragment on the mother sequence </p>
</td></tr>
<tr><td><code>class</code></td>
<td>
 <p><code>SeqFrag</code> which is the classfor sub-sequence </p>
</td></tr> 
</table>
<p><code>is.SeqFrag</code> returns TRUE if the object is of class Seqfrag. 
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getFrag">getFrag</a></code>, <code><a href="#topic+getLength">getLength</a></code>, <code><a href="#topic+getName">getName</a></code>,
<code><a href="#topic+getSequence">getSequence</a></code>, <code><a href="#topic+getTrans">getTrans</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> s &lt;- read.fasta(file = system.file("sequences/malM.fasta", package = "seqinr"))
 getFrag(s[[1]], 1, 10) 	
</code></pre>

<hr>
<h2 id='SEQINR.UTIL'>utility data for seqinr</h2><span id='topic+SEQINR.UTIL'></span>

<h3>Description</h3>

<p>This data set gives the genetics code, the name of each codon, the IUPAC one-letter code for amino acids and the physico-chemical class of amino acid and the pK values of amino acids described in Bjellqvist <em>et al.</em> (1993).
</p>


<h3>Format</h3>

<p><code>SEQINR.UTIL</code> is a list containing the 4 following objects:
</p>

<dl>
<dt>CODES.NCBI</dt><dd><p>is a data frame containing the genetics code : The standard ('Universal') genetic code with a selection of non-standard codes. </p>
</dd>
<dt>CODON.AA</dt><dd><p>is a three columns data frame. The first column is a factor containing the codon. The second column is a factor giving the aminoacids names for each codon. The last column is a factor giving the IUPAC one-letter code for aminoacids</p>
</dd>
<dt>AA.PROPERTY</dt><dd><p>is a list giving the physico-chemical class of amino acid. The differents classes are the following one : Tiny, Small, Aliphatic, Aromatic, Non.polar, Polar, Charged, Basic, Acidic </p>
</dd>
<dt>pK</dt><dd><p>is a data frame. It gives the pK values of amino acids described in  Bjellqvist <em>et al.</em> (1993) , which were defined by examining polypeptide migration between pH 4.5 to 7.3 in an immobilised pH gradient gel environment with 9.2M and 9.8M urea at 15 degree or 25 degree</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data prepared by D. Charif.<br /> The genetic codes have been taken from the ncbi  database: <a href="https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi">https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</a>. Last visited on 2016-10-05 corresponding to last update of the Genetic Codes: April 30, 2013.<br /> The IUPAC one-letter code for aminoacids is descibed at: <a href="https://www.bioinformatics.org/sms/iupac.html">https://www.bioinformatics.org/sms/iupac.html</a>.
pK values of amino acids were taken from Bjellqvist et al.<br />
Bjellqvist, B.,Hughes, G.J., Pasquali, Ch., Paquet, N., Ravier, F., Sanchez, J.-Ch., Frutiger, S. &amp; Hochstrasser, D.F.(1993)  The focusing positions of polypeptides in immobilized pH gradients can be predicted from their amino acid sequences.<em> Electrophoresis</em>, <b>14</b>, 1023-1031.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SEQINR.UTIL)
</code></pre>

<hr>
<h2 id='setlistname'>Sets the name of an ACNUC list identified by its rank</h2><span id='topic+setlistname'></span>

<h3>Description</h3>

<p>This is a low level function to set the name of a list from an ACNUC server.
It should not be used directly by end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setlistname(lrank, name = "list1", socket = autosocket())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setlistname_+3A_lrank">lrank</code></td>
<td>
<p>the list rank on the ACNUC server</p>
</td></tr>
<tr><td><code id="setlistname_+3A_name">name</code></td>
<td>
<p>the name to use for this list</p>
</td></tr>
<tr><td><code id="setlistname_+3A_socket">socket</code></td>
<td>
<p>an object of class <code>sockconn</code> connecting to a remote ACNUC
database (default is a socket to the last opened database).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value corresponding to:
</p>
<table role = "presentation">
<tr><td><code>NA</code></td>
<td>
<p>Empty answer from server.</p>
</td></tr>
<tr><td><code>0</code></td>
<td>
<p>OK.</p>
</td></tr>
<tr><td><code>3</code></td>
<td>
<p>if another list with that name already existed and was deleted.</p>
</td></tr>
<tr><td><code>4</code></td>
<td>
<p>no list of rank <code>lrank</code> exists.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 <p><a href="https://doua.prabi.fr/databases/acnuc.html">https://doua.prabi.fr/databases/acnuc.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code>, <code><a href="#topic+query">query</a></code>, <code><a href="#topic+glr">glr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ### Need internet connection
  choosebank("emblTP")
  mylist &lt;- query("mylist", "sp=felis catus et t=CDS", virtual = TRUE)
  # Change list name on server:
  setlistname(lrank = glr("mylist"), name = "feliscatus") # 0, OK.
  glr("mylist") # 0, list doesn't exist no more.
  glr("feliscatus") # 2, this list exists.
  # Note the danger here: the object mylist is still present in the user workspace
  # while the corresponding list was deleted from server.
  
## End(Not run)
</code></pre>

<hr>
<h2 id='splitseq'> split a sequence into sub-sequences </h2><span id='topic+splitseq'></span>

<h3>Description</h3>

<p>Split a sequence into sub-sequences of 3 (the default size) with no overlap between the sub-sequences. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitseq(seq, frame = 0, word = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitseq_+3A_seq">seq</code></td>
<td>
<p> a vector of chars </p>
</td></tr>
<tr><td><code id="splitseq_+3A_frame">frame</code></td>
<td>
<p> an integer (0, 1, 2) giving the starting position to split the sequence </p>
</td></tr>
<tr><td><code id="splitseq_+3A_word">word</code></td>
<td>
<p> an integer giving the size of the sub-sequences </p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector which contains the sub-sequences.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
<br />
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+split">split</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>cds &lt;- s2c("aacgttgcaggtcgctcgctacgtagctactgttt")
#
# To obtain the codon sequence in frame 0:
#
stopifnot(identical(splitseq(cds), 
  c("aac", "gtt", "gca", "ggt", "cgc", "tcg", "cta", "cgt", "agc", "tac", "tgt")))
#
# Show the effect of frame and word with a ten char sequence:
#
(tenchar &lt;- s2c("1234567890"))
splitseq(tenchar, frame = 0)
splitseq(tenchar, frame = 1)
splitseq(tenchar, frame = 2)
splitseq(tenchar, frame = 0, word = 2)
splitseq(tenchar, frame = 0, word = 1)
</code></pre>

<hr>
<h2 id='stresc'>Utility function to escape LaTeX special characters present in a string</h2><span id='topic+stresc'></span>

<h3>Description</h3>

<p>This function returns a vector of strings in which LaTeX special characters are
escaped, this was useful in conjunction with xtable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stresc(strings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stresc_+3A_strings">strings</code></td>
<td>
<p>A vector of strings to deal with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of strings with escaped characters within each string.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+s2c">s2c</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  stresc("MISC_RNA")
  stresc(c("BB_0001","BB_0002"))
</code></pre>

<hr>
<h2 id='stutterabif'>Stutter ratio estimation</h2><span id='topic+stutterabif'></span>

<h3>Description</h3>

<p>This function tries to estimate the stutter ratio, either in terms of peak heigth ratios or peak
surface ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stutterabif(abifdata, chanel, poswild, datapointbefore = 70,
 datapointafter = 20, datapointsigma = 3.5,
 chanel.names = c(1:4, 105), DATA = paste("DATA", chanel.names[chanel], sep = "."),
 maxrfu = 1000, method = "monoH.FC", pms = 6, fig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stutterabif_+3A_abifdata">abifdata</code></td>
<td>
<p>the result returned by <code><a href="#topic+read.abif">read.abif</a></code></p>
</td></tr>
<tr><td><code id="stutterabif_+3A_chanel">chanel</code></td>
<td>
<p>the dye number</p>
</td></tr>
<tr><td><code id="stutterabif_+3A_poswild">poswild</code></td>
<td>
<p>the position in datapoint units of the allele at 
the origin of the stutter product, typically obtained after a call to <code><a href="#topic+peakabif">peakabif</a></code></p>
</td></tr>
<tr><td><code id="stutterabif_+3A_datapointbefore">datapointbefore</code></td>
<td>
<p>how many datapoints before <code>poswild</code> to be include in analysis</p>
</td></tr>
<tr><td><code id="stutterabif_+3A_datapointafter">datapointafter</code></td>
<td>
<p>how many datapoints after <code>poswild</code> to be include in analysis</p>
</td></tr>
<tr><td><code id="stutterabif_+3A_datapointsigma">datapointsigma</code></td>
<td>
<p>initial guess for the standard deviation of a peak</p>
</td></tr>
<tr><td><code id="stutterabif_+3A_chanel.names">chanel.names</code></td>
<td>
<p>numbers extensions used for the DATA</p>
</td></tr>
<tr><td><code id="stutterabif_+3A_data">DATA</code></td>
<td>
<p>names of the DATA components</p>
</td></tr>
<tr><td><code id="stutterabif_+3A_maxrfu">maxrfu</code></td>
<td>
<p>argument passed to <code><a href="#topic+baselineabif">baselineabif</a></code></p>
</td></tr>
<tr><td><code id="stutterabif_+3A_method">method</code></td>
<td>
<p>method to be used by <code><a href="stats.html#topic+splinefun">splinefun</a></code></p>
</td></tr>
<tr><td><code id="stutterabif_+3A_pms">pms</code></td>
<td>
<p>how many standard deviations (after gaussian fit) before and after the mean 
peak values should be considered for spline function interpolation</p>
</td></tr>
<tr><td><code id="stutterabif_+3A_fig">fig</code></td>
<td>
<p>should a summary plot be produced?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FIXME, See R code for now</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>rh</code></td>
<td>
<p>Stutter ratio computed as the height of the stutter divided by 
the height of its corresponding allele</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>
<p>Stutter ratio computed as the surface of the stutter divided by
the surface of its corresponding allele</p>
</td></tr>
<tr><td><code>h1</code></td>
<td>
<p>The height of the stutter with baseline at 0</p>
</td></tr>
<tr><td><code>h2</code></td>
<td>
<p>The height of the allele with baseline at 0</p>
</td></tr>
<tr><td><code>s1</code></td>
<td>
<p>The surface of the stutter</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>The surface of the allele</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>A list of additional parameter that could be usesfull, see example</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>See Also</h3>

<p><code><a href="#topic+JLO">JLO</a></code> for a dataset example, 
<code><a href="#topic+peakabif">peakabif</a></code> to get an estimate of peak location.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #
  # Load pre-defined dataset, same as what would be obtained with read.abif:
  #

data(JLO)

  #
  # Get peak locations in the blue channel:
  #

maxis &lt;- peakabif(JLO, 1, npeak = 6, tmin = 3, fig = FALSE)$maxis

  #
  # Compute stutter ratio for first peak and ask for a figure:
  #

tmp &lt;- stutterabif(JLO, 1, maxis[1], fig = TRUE)

  #
  # Show in addition the normal approximation used at the stutter peak:
  #

xx &lt;- seq(tmp$p$mu1 - 6*tmp$p$sd1, tmp$p$mu1 + 6*tmp$p$sd1, le = 100)
lines(xx, tmp$p$p1*dnorm(xx, tmp$p$mu1, tmp$p$sd1), col = "darkgreen")

  #
  # Show in addition the normal approximation used at allele peak:
  #

xx &lt;- seq(tmp$p$mu2 - 6*tmp$p$sd2, tmp$p$mu2 + 6*tmp$p$sd2, le = 100)
lines(xx, tmp$p$p2*dnorm(xx, tmp$p$mu2, tmp$p$sd2), col = "darkgreen")
</code></pre>

<hr>
<h2 id='swap'>Exchange two R objects</h2><span id='topic+swap'></span>

<h3>Description</h3>

<p>Exchange object <code>x</code> with object <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swap_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="swap_+3A_y">y</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

 
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+move">move</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Example in a new empty environment:
#
local({
  x &lt;- 0:9
  y &lt;- 10:19
  print(x)
  print(y)
  swap(x[1], y[2])
  print(x)
  print(y)
})
#
# Sanity check with a bubble sort:
#
bubble.sort &lt;- function(tab, n = length(tab)){
  i &lt;- 1
  while(i &lt; n){
    if(tab[i + 1] &lt; tab[i]){
      swap(tab[i], tab[i+1])
      i &lt;- 1
    } else {
      i &lt;- i+1
    }
  }
  return(tab)
}
set.seed(1)
x &lt;- rnorm(10)
stopifnot(identical(sort(x), bubble.sort(x)))
</code></pre>

<hr>
<h2 id='syncodons'>Synonymous codons</h2><span id='topic+syncodons'></span>

<h3>Description</h3>

<p>Returns all synonymous codons for each codon given
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syncodons(codons, numcode = 1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="syncodons_+3A_codons">codons</code></td>
<td>
<p> A sequence of codons as generated by <code>splitseq</code> </p>
</td></tr>
<tr><td><code id="syncodons_+3A_numcode">numcode</code></td>
<td>
<p> The genetic code number as in <code>translate</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing, for each codon given (list tags), all synonymous
codons (including the original one)
</p>


<h3>Author(s)</h3>

<p>L. Palmeira, J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+synsequence">synsequence</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The four synonymous codons for Alanine in the standard genetic code:
#
syncodons("ggg")
#
# With a sequence:
#
toycds &lt;- s2c("tctgagcaaataaatcgg")
syncodons(splitseq(toycds))
#
# Sanity check with the standard genetic code:
#
stdgencode &lt;- structure(list(
  ttt = c("ttc", "ttt"), 
  ttc = c("ttc", "ttt"), 
  tta = c("cta", "ctc", "ctg", "ctt", "tta", "ttg"),
  ttg = c("cta", "ctc", "ctg", "ctt", "tta", "ttg"), 
  tct = c("agc", "agt", "tca", "tcc", "tcg", "tct"), 
  tcc = c("agc", "agt", "tca", "tcc", "tcg", "tct"), 
  tca = c("agc", "agt", "tca", "tcc", "tcg", "tct"), 
  tcg = c("agc", "agt", "tca", "tcc", "tcg", "tct"),
  tat = c("tac", "tat"), 
  tac = c("tac", "tat"), 
  taa = c("taa", "tag", "tga"),
  tag = c("taa", "tag", "tga"),
  tgt = c("tgc", "tgt"),
  tgc = c("tgc", "tgt"),
  tga = c("taa", "tag", "tga"), 
  tgg = "tgg", 
  ctt = c("cta", "ctc", "ctg", "ctt", "tta", "ttg"), 
  ctc = c("cta", "ctc", "ctg", "ctt", "tta", "ttg"), 
  cta = c("cta", "ctc", "ctg", "ctt", "tta", "ttg"),
  ctg = c("cta", "ctc", "ctg", "ctt", "tta", "ttg"), 
  cct = c("cca", "ccc", "ccg", "cct"), 
  ccc = c("cca", "ccc", "ccg", "cct"), 
  cca = c("cca", "ccc", "ccg", "cct"), 
  ccg = c("cca", "ccc", "ccg", "cct"), 
  cat = c("cac", "cat"), 
  cac = c("cac", "cat"), 
  caa = c("caa", "cag"),
  cag = c("caa", "cag"),
  cgt = c("aga", "agg", "cga", "cgc", "cgg", "cgt"),
  cgc = c("aga", "agg", "cga", "cgc", "cgg", "cgt"),
  cga = c("aga", "agg", "cga", "cgc", "cgg", "cgt"),
  cgg = c("aga", "agg", "cga", "cgc", "cgg", "cgt"), 
  att = c("ata", "atc", "att"),
  atc = c("ata", "atc", "att"),
  ata = c("ata", "atc", "att"),
  atg = "atg",
  act = c("aca", "acc", "acg", "act"), 
  acc = c("aca", "acc", "acg", "act"),
  aca = c("aca", "acc", "acg", "act"),
  acg = c("aca", "acc",  "acg", "act"), 
  aat = c("aac", "aat"), 
  aac = c("aac", "aat"), 
  aaa = c("aaa", "aag"),
  aag = c("aaa", "aag"),
  agt = c("agc", "agt", "tca", "tcc", "tcg", "tct"),
  agc = c("agc", "agt", "tca", "tcc", "tcg", "tct"),
  aga = c("aga", "agg", "cga", "cgc", "cgg", "cgt"),
  agg = c("aga", "agg", "cga", "cgc", "cgg", "cgt"),
  gtt = c("gta", "gtc", "gtg", "gtt"),
  gtc = c("gta", "gtc", "gtg", "gtt"),
  gta = c("gta", "gtc", "gtg", "gtt"), 
  gtg = c("gta", "gtc", "gtg", "gtt"),
  gct = c("gca", "gcc", "gcg", "gct"),
  gcc = c("gca", "gcc", "gcg", "gct"),
  gca = c("gca", "gcc", "gcg", "gct"),
  gcg = c("gca", "gcc", "gcg", "gct"), 
  gat = c("gac", "gat"),
  gac = c("gac", "gat"),
  gaa = c("gaa", "gag"),
  gag = c("gaa", "gag"),
  ggt = c("gga", "ggc", "ggg", "ggt"),
  ggc = c("gga", "ggc", "ggg", "ggt"),
  gga = c("gga", "ggc", "ggg", "ggt"),
  ggg = c("gga", "ggc", "ggg", "ggt")),

.Names = c("ttt", "ttc", "tta", "ttg", "tct", "tcc", "tca", "tcg", "tat", "tac", 
"taa", "tag", "tgt", "tgc", "tga", "tgg", "ctt", "ctc", "cta", 
"ctg", "cct", "ccc", "cca", "ccg", "cat", "cac", "caa", "cag", 
"cgt", "cgc", "cga", "cgg", "att", "atc", "ata", "atg", "act", 
"acc", "aca", "acg", "aat", "aac", "aaa", "aag", "agt", "agc", 
"aga", "agg", "gtt", "gtc", "gta", "gtg", "gct", "gcc", "gca", 
"gcg", "gat", "gac", "gaa", "gag", "ggt", "ggc", "gga", "ggg"))
#
# Now the check:
#
currentresult &lt;- syncodons(words(alphabet = s2c("tcag")))
stopifnot(identical(stdgencode, currentresult))
</code></pre>

<hr>
<h2 id='synsequence'>Random synonymous coding sequence generation</h2><span id='topic+synsequence'></span>

<h3>Description</h3>

<p>Generates a random synonymous coding sequence, according to a certain
codon usage bias
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synsequence(sequence, numcode = 1, ucoweight = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synsequence_+3A_sequence">sequence</code></td>
<td>
<p> A nucleic acids sequence </p>
</td></tr>
<tr><td><code id="synsequence_+3A_numcode">numcode</code></td>
<td>
<p> The genetic code number as in <code>translate</code> </p>
</td></tr>
<tr><td><code id="synsequence_+3A_ucoweight">ucoweight</code></td>
<td>
<p> A list of weights containing the desired codon usage
bias as generated by <code>ucoweight</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sequence translating to the same protein sequence as the original
one (cf. <code>translate</code>), but containing synonymous codons  
</p>


<h3>Author(s)</h3>

<p>L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ucoweight">ucoweight</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ec999)
  sequence=ec999[1][[1]]
  synsequence(sequence,1,ucoweight(sequence))
</code></pre>

<hr>
<h2 id='tablecode'> to plot genetic code as in textbooks </h2><span id='topic+tablecode'></span>

<h3>Description</h3>

<p>This function plots a genetic code table as in textbooks, that is
following the order <code>T &gt; C &gt; A &gt; G</code> so that synonymous codons
are almost always in the same boxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tablecode(numcode = 1, urn.rna = s2c("TCAG"), dia = FALSE, latexfile = NULL,
label = latexfile, size = "normalsize", caption = NULL,
preaa = rep("", 64), postaa = rep("", 64), 
precodon = preaa, postcodon = postaa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tablecode_+3A_numcode">numcode</code></td>
<td>
<p>The genetic code number as in <code>translate</code> </p>
</td></tr>
<tr><td><code id="tablecode_+3A_urn.rna">urn.rna</code></td>
<td>
<p>The letters to display codons, use s2c(&quot;UCAG&quot;)
if you want the code in terms of RNA sequence</p>
</td></tr>
<tr><td><code id="tablecode_+3A_latexfile">latexfile</code></td>
<td>
<p>The name of a LaTex file if you want to redirect the output</p>
</td></tr>
<tr><td><code id="tablecode_+3A_label">label</code></td>
<td>
<p>The label for the LaTeX table</p>
</td></tr>
<tr><td><code id="tablecode_+3A_size">size</code></td>
<td>
<p>The LaTex size of characters for the LaTeX table</p>
</td></tr>
<tr><td><code id="tablecode_+3A_preaa">preaa</code></td>
<td>
<p>A string to insert before the amino-acid in the LaTeX table</p>
</td></tr>
<tr><td><code id="tablecode_+3A_postaa">postaa</code></td>
<td>
<p>A string to insert after the amino-acid in the LaTeX table</p>
</td></tr>
<tr><td><code id="tablecode_+3A_precodon">precodon</code></td>
<td>
<p>A string to insert before the codon in the LaTeX table</p>
</td></tr>
<tr><td><code id="tablecode_+3A_postcodon">postcodon</code></td>
<td>
<p>A string to insert after the codon in the LaTeX table</p>
</td></tr>
<tr><td><code id="tablecode_+3A_caption">caption</code></td>
<td>
<p>The caption of the LaTeX table</p>
</td></tr>
<tr><td><code id="tablecode_+3A_dia">dia</code></td>
<td>
<p>to produce a yellow/blue plot for slides</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The codon order for <code>preaa</code>, <code>postaa</code>, <code>precodon</code>, and
<code>postcodon</code> should be the same as in
<code>paste(paste(rep(s2c("tcag"), each =16), s2c("tcag"), sep = ""), rep(s2c("tcag"), each = 4), sep = "")</code>
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+translate">translate</a></code>, <code><a href="#topic+syncodons">syncodons</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Show me the standard genetic code:
#

 tablecode()
</code></pre>

<hr>
<h2 id='test.co.recstat'>Tests if regions located between Stop codons contain putative CDSs.</h2><span id='topic+test.co.recstat'></span>

<h3>Description</h3>

<p>This test uses columns (codons) factor scores computed by <code>recstat</code> in order
to determine if the regions located between two Stop codons correspond to putative CDSs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.co.recstat(rec, fac = 1, length.min = 150, stop.max = 0.2, win.lim = 0.8,
    direct = TRUE, level = 0.01)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.co.recstat_+3A_rec">rec</code></td>
<td>
<p>list of elements returned by <code>recstat</code> function.</p>
</td></tr>
<tr><td><code id="test.co.recstat_+3A_fac">fac</code></td>
<td>
<p>axis of the CA to use for test (4 <code class="reqn">\ge</code> <code>fac</code>
<code class="reqn">\ge</code> 1).</p>
</td></tr>
<tr><td><code id="test.co.recstat_+3A_length.min">length.min</code></td>
<td>
<p>minimal length between two Stop codons.</p>
</td></tr>
<tr><td><code id="test.co.recstat_+3A_stop.max">stop.max</code></td>
<td>
<p>threshold for Stop codons relative position in a window to determine if this
window can be used for test computation.</p>
</td></tr>
<tr><td><code id="test.co.recstat_+3A_win.lim">win.lim</code></td>
<td>
<p>minimum proportion of windows inside a region showing a p-value below the
threshold for Kruskal-Wallis test.</p>
</td></tr>
<tr><td><code id="test.co.recstat_+3A_direct">direct</code></td>
<td>
<p>a logical for the choice of direct or reverse strand.</p>
</td></tr>
<tr><td><code id="test.co.recstat_+3A_level">level</code></td>
<td>
<p>p-value threshold for Kruskal-Wallis test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is computed for all windows located between two Stop codons separated by at least
<code>length.min</code> nucleotides. For each window inside a region considered, a Kruskal-Wallis test
is computed on the factor scores of the codons found in this window, this for the three possible
reading frames. If a proportion of at least <code>win.lim</code> windows in the region reject the null
hypothesis of means equality between the reading frames, then, there is a good probability that
a CDS is located in the region.<br />
</p>
<p>Inside the first and the last windows of a region submitted to the test, the relative position of
the two Stop codons is used to determine if those windows can be used in the analysis. If the
first Stop is located within the <code>stop.max</code> fraction of the 5' end of the window, then this
window is kept in the analysis. In the same way, if the second Stop is located within the
<code>stop.max</code> fraction of the 3' end of the window, this window is also kept in the analysis.
</p>


<h3>Value</h3>

<p>The result is returned as a list containing three matrices (one for each reading frame).
All matrices have the same structure, with rows corresponding to the regions between
two Stop codons. Columns <code>Start</code> and <code>End</code> give the location of starting and ending
positions of the region; and <code>CDS</code> is a binary indicator equal to 1 if a putative CDS is
predicted, and to 0 if not.
</p>


<h3>Author(s)</h3>

<p>O. Clerc, G. Perrière</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.li.recstat">test.li.recstat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # CPU time  is too long with windows
ff &lt;- system.file("sequences/ECOUNC.fsa", package = "seqinr")
seq &lt;- read.fasta(ff)
rec &lt;- recstat(seq[[1]], seqname = getName(seq))
test.co.recstat(rec)

## End(Not run)
</code></pre>

<hr>
<h2 id='test.li.recstat'>Tests if regions located between Stop codons contain putative CDSs.</h2><span id='topic+test.li.recstat'></span>

<h3>Description</h3>

<p>This test uses rows (windows) factor scores computed by <code>recstat</code> in order to
determine if the regions located between two Stop codons correspond to putative CDSs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.li.recstat(rec, fac = 1, length.min = 150, stop.max = 0.2,
    direct = TRUE, level = 0.05)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.li.recstat_+3A_rec">rec</code></td>
<td>
<p>list of elements returned by <code>recstat</code> function.</p>
</td></tr>
<tr><td><code id="test.li.recstat_+3A_fac">fac</code></td>
<td>
<p>axis of the CA to use for test (4 <code class="reqn">\ge</code> <code>fac</code>
<code class="reqn">\ge</code> 1).</p>
</td></tr>
<tr><td><code id="test.li.recstat_+3A_length.min">length.min</code></td>
<td>
<p>minimal length between two Stop codons.</p>
</td></tr>
<tr><td><code id="test.li.recstat_+3A_stop.max">stop.max</code></td>
<td>
<p>threshold for Stop codons relative position in a window to determine if this
window can be used for test computation.</p>
</td></tr>
<tr><td><code id="test.li.recstat_+3A_direct">direct</code></td>
<td>
<p>a logical for the choice of direct or reverse strand.</p>
</td></tr>
<tr><td><code id="test.li.recstat_+3A_level">level</code></td>
<td>
<p>p-value threshold for t-test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is computed for all regions between two Stop codons separated by at least
<code>length.min</code> nucleotides, this for the three possible reading frames of a DNA strand. For
each region considered, two t-tests are computed for comparing the mean of the factor scores of
the windows from the reading frame in which the region is located with the means of the factor
scores from the corresponding windows in the two other reading frames. If both t-tests reject
the null hypothesis of means equality, then there is a good probability that a CDS is located in
the region.<br />
</p>
<p>Inside the first and the last windows of a region submitted to the test, the relative position of
the two Stop codons is used to determine if those windows can be used in the analysis. If the
first Stop is located within the <code>stop.max</code> fraction of the 5' end of the window, then this
window is kept in the analysis. In the same way, if the second Stop is located within the
<code>stop.max</code> fraction of the 3' end of the window, this window is also kept in the analysis.
</p>


<h3>Value</h3>

<p>The result is returned as a list containing three matrices (one for each reading frame).
All matrices have the same structure, with rows corresponding to the regions between two Stop
codons. Columns <code>Start</code> and <code>End</code>  give the location of starting and ending positions
of the region; <code>Mean i</code> gives the mean of the factor scores for the windows located in the
region, this for reading frame <code>i</code>; <code>t(i,j)</code> gives the p-value of the t-test computed
between the means from reading frames <code>i</code> and <code>j</code>; and <code>CDS</code> is a binary
indicator equal to 1 if a putative CDS is predicted, and to 0 if not.
</p>


<h3>Author(s)</h3>

<p>O. Clerc, G. Perrière</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.co.recstat">test.co.recstat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- system.file("sequences/ECOUNC.fsa", package = "seqinr")
seq &lt;- read.fasta(ff)
rec &lt;- recstat(seq[[1]], seqname = getName(seq))
test.li.recstat(rec)
</code></pre>

<hr>
<h2 id='toyaa'>A toy example of amino-acid counts in three proteins</h2><span id='topic+toyaa'></span>

<h3>Description</h3>

<p>This is a toy data set to illustrate the importance of metric choice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toyaa)</code></pre>


<h3>Format</h3>

<p>A data frame with 3 observations on the following 3 variables:
</p>

<dl>
<dt>Ala</dt><dd><p>Alanine counts</p>
</dd>
<dt>Val</dt><dd><p>Valine counts</p>
</dd>
<dt>Cys</dt><dd><p>Cysteine counts</p>
</dd>
</dl>



<h3>Source</h3>

<p>This toy example was inspired by Gautier, C:
Analyses statistiques et évolution des séquences d'acides nucléiques.
PhD thesis (1987), Université Claude Bernard - Lyon I.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toyaa)
</code></pre>

<hr>
<h2 id='toycodon'>A toy example of codon counts in three coding sequences</h2><span id='topic+toycodon'></span>

<h3>Description</h3>

<p>This is a toy data set to illustrate synonymous and non-synonymous codon usage analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toyaa)</code></pre>


<h3>Format</h3>

<p>A data frame with 3 observations (coding sequences) for 10 codons.</p>


<h3>Source</h3>

<p>Created for release 1.0-4 of seqinr's vignette.
</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toycodon)
</code></pre>

<hr>
<h2 id='translate'> Translate nucleic acid sequences into proteins </h2><span id='topic+translate'></span>

<h3>Description</h3>

<p>This function translates nucleic acid sequences into the corresponding
peptide sequence. It can translate in any of the 3 forward or three
reverse sense frames. In the case of reverse sense, the reverse-complement
of the sequence is taken. It can translate using the standard (universal)
genetic code and also with non-standard codes. Ambiguous bases can also
be handled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(seq, frame = 0, sens = "F", numcode = 1, NAstring = "X", ambiguous = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_+3A_seq">seq</code></td>
<td>
<p> the sequence to translate as a vector of single characters in lower case letters. </p>
</td></tr>
<tr><td><code id="translate_+3A_frame">frame</code></td>
<td>
<p> Frame(s) (0,1,2) to translate. By default the frame <code>0</code> is used. </p>
</td></tr>
<tr><td><code id="translate_+3A_sens">sens</code></td>
<td>
<p> Sense to translate: <code>F</code> for forward sense and <code>R</code> for reverse sense. </p>
</td></tr>
<tr><td><code id="translate_+3A_numcode">numcode</code></td>
<td>
<p> The ncbi genetic code number for translation. By default the standard genetic code is used. </p>
</td></tr>
<tr><td><code id="translate_+3A_nastring">NAstring</code></td>
<td>
<p> How to translate amino-acids when there are ambiguous bases in codons. </p>
</td></tr>
<tr><td><code id="translate_+3A_ambiguous">ambiguous</code></td>
<td>
<p> If TRUE, ambiguous bases are taken into account so that for instance
GGN is translated to Gly in the standard genetic code. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following genetic codes are described here. The number preceding each code
corresponds to <code>numcode</code>.
</p>

<dl>
<dt>1</dt><dd><p> standard </p>
</dd>
<dt>2</dt><dd><p> vertebrate.mitochondrial </p>
</dd>
<dt>3</dt><dd><p> yeast.mitochondrial </p>
</dd>
<dt>4</dt><dd><p> protozoan.mitochondrial+mycoplasma </p>
</dd>
<dt>5</dt><dd><p> invertebrate.mitochondrial </p>
</dd>
<dt>6</dt><dd><p> ciliate+dasycladaceal </p>
</dd>
<dt>9</dt><dd><p> echinoderm+flatworm.mitochondrial </p>
</dd>
<dt>10</dt><dd><p> euplotid </p>
</dd>
<dt>11</dt><dd><p> bacterial+plantplastid </p>
</dd>
<dt>12</dt><dd><p> alternativeyeast </p>
</dd>
<dt>13</dt><dd><p> ascidian.mitochondrial </p>
</dd>
<dt>14</dt><dd><p> alternativeflatworm.mitochondrial </p>
</dd>
<dt>15</dt><dd><p> blepharism </p>
</dd>
<dt>16</dt><dd><p> chlorophycean.mitochondrial </p>
</dd>
<dt>21</dt><dd><p> trematode.mitochondrial </p>
</dd>
<dt>22</dt><dd><p> scenedesmus.mitochondrial </p>
</dd>
<dt>23</dt><dd><p> thraustochytrium.mitochondria </p>
</dd>
<dt>24</dt><dd><p>Pterobranchia.mitochondrial</p>
</dd>
<dt>25</dt><dd><p>CandidateDivision.SR1+Gracilibacteria</p>
</dd>
<dt>26</dt><dd><p>Pachysolen.tannophilus</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>translate</code> returns a vector of single characters containing the peptide sequence in
the standard one-letter IUPAC code. Termination (STOP) codons are translated by
the character '*'.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry</p>


<h3>References</h3>

<p>The genetic codes have been taken from the ncbi taxonomy database:
<a href="https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi">https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</a>.
Last update October 05, 2000.<br />
The IUPAC one-letter code for aminoacids is described at:
<a href="https://www.bioinformatics.org/sms/iupac.html">https://www.bioinformatics.org/sms/iupac.html</a>
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

<p>Use <code><a href="base.html#topic+tolower">tolower</a></code> to change upper case letters into lower case letters.
For coding sequences obtained from an ACNUC server with <code><a href="#topic+query">query</a></code> it's
better to use the function <code><a href="#topic+getTrans">getTrans</a></code> so that the relevant genetic
code and the relevant frame are automatically used.
The genetic codes are given in the object <code><a href="#topic+SEQINR.UTIL">SEQINR.UTIL</a></code>, a more
human readable form is given by the function <code><a href="#topic+tablecode">tablecode</a></code>.
Use <code><a href="#topic+aaa">aaa</a></code> to get the three-letter code for amino-acids.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Toy CDS example invented by Leonor Palmeira:
##
toycds &lt;- s2c("tctgagcaaataaatcgg")
translate(seq = toycds) # should be c("S", "E", "Q", "I", "N", "R")
##
## Toy CDS example with ambiguous bases:
##
toycds2 &lt;- s2c("tcngarcarathaaycgn")
translate(toycds2) # should be c("X", "X", "X", "X", "X", "X")
translate(toycds2, ambiguous = TRUE) # should be c("S", "E", "Q", "I", "N", "R")
translate(toycds2, ambiguous = TRUE, numcode = 2) # should be c("S", "E", "Q", "X", "N", "R")
##
## Real CDS example:
##
realcds &lt;- read.fasta(file = system.file("sequences/malM.fasta", package ="seqinr"))[[1]]
translate(seq = realcds)
# Biologically correct, only one stop codon at the end
translate(seq = realcds, frame = 3, sens = "R", numcode = 6)
# Biologically meaningless, note the in-frame stop codons

# Read from an alignment as suggested by Dr. H. Suzuki
fasta.res    &lt;- read.alignment(file = system.file("sequences/Anouk.fasta", package = "seqinr"),
 format = "fasta")

AA1 &lt;- seqinr::getTrans(s2c(fasta.res$seq[[1]]))
AA2 &lt;- seqinr::translate(s2c(fasta.res$seq[[1]]))
identical(AA1, AA2)

AA1 &lt;- lapply(fasta.res$seq, function(x) seqinr::getTrans(s2c(x)))
AA2 &lt;- lapply(fasta.res$seq, function(x) seqinr::translate(s2c(x)))
identical(AA1, AA2)

## Not run: 
## Need internet connection.
## Translation of the following EMBL entry:
##
## FT   CDS             join(complement(153944..154157),complement(153727..153866),
## FT                   complement(152185..153037),138523..138735,138795..138955)
## FT                   /codon_start=1
## FT                   /db_xref="FLYBASE:FBgn0002781"
## FT                   /db_xref="GOA:Q86B86"
## FT                   /db_xref="TrEMBL:Q86B86"
## FT                   /note="mod(mdg4) gene product from transcript CG32491-RZ;
## FT                   trans splicing"
## FT                   /gene="mod(mdg4)"
## FT                   /product="CG32491-PZ"
## FT                   /locus_tag="CG32491"
## FT                   /protein_id="AAO41581.1"
## FT                   /translation="MADDEQFSLCWNNFNTNLSAGFHESLCRGDLVDVSLAAEGQIVKA
## FT                   HRLVLSVCSPFFRKMFTQMPSNTHAIVFLNNVSHSALKDLIQFMYCGEVNVKQDALPAF
## FT                   ISTAESLQIKGLTDNDPAPQPPQESSPPPAAPHVQQQQIPAQRVQRQQPRASARYKIET
## FT                   VDDGLGDEKQSTTQIVIQTTAAPQATIVQQQQPQQAAQQIQSQQLQTGTTTTATLVSTN
## FT                   KRSAQRSSLTPASSSAGVKRSKTSTSANVMDPLDSTTETGATTTAQLVPQQITVQTSVV
## FT                   SAAEAKLHQQSPQQVRQEEAEYIDLPMELPTKSEPDYSEDHGDAAGDAEGTYVEDDTYG
## FT                   DMRYDDSYFTENEDAGNQTAANTSGGGVTATTSKAVVKQQSQNYSESSFVDTSGDQGNT
## FT                   EAQVTQHVRNCGPQMFLISRKGGTLLTINNFVYRSNLKFFGKSNNILYWECVQNRSVKC
## FT                   RSRLKTIGDDLYVTNDVHNHMGDNKRIEAAKAAGMLIHKKLSSLTAADKIQGSWKMDTE
## FT                   GNPDHLPKM"
choosebank("emblTP")
trans &lt;- query("trans", "N=AE003734.PE35")
trans1 &lt;- getTrans(trans$req[[1]])
## Complex transsplicing operations, the correct frame and the correct
## genetic code are automatically used for translation into protein.
seq &lt;- getSequence(trans$req[[1]])
identical(translate(seq),trans1)
#default frame and genetic code are correct
trans &lt;- query("trans", "N=AB004237")
trans1 &lt;- getTrans(trans$req[[1]])
## Complex transsplicing operations, the correct frame and the correct
## genetic code are automatically used for translation into protein.
seq &lt;- getSequence(trans$req[[1]])
identical(translate(seq),trans1)
#default  genetic code is not correct
identical(translate(seq,numcode=2),trans1)
#genetic code is 2

## End(Not run)
</code></pre>

<hr>
<h2 id='trimSpace'>Trim leading and/or trailing spaces in strings</h2><span id='topic+trimSpace'></span>

<h3>Description</h3>

<p>This function removes from a character vector the longest successive run
of space characters starting at the begining of the strings (leading space),
or the longest successive run of space characters at the end of the strings
(trailing space), or both (and this is the default behaviour).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimSpace(x, leading = TRUE, trailing = TRUE, space = "[:space:]")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimSpace_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="trimSpace_+3A_leading">leading</code></td>
<td>
<p>logical defaulting to <code>TRUE</code>: should leading spaces be trimed off?</p>
</td></tr>
<tr><td><code id="trimSpace_+3A_trailing">trailing</code></td>
<td>
<p>logical defaulting to <code>TRUE</code>: should trailing spaces be trimed off?</p>
</td></tr>
<tr><td><code id="trimSpace_+3A_space">space</code></td>
<td>
<p>an extended regular expression defining space characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value for the space character definition is large: in addition to the
usual space, other character such as the tabulation and newline character are
considered as space characters. See extended regular expression for a complete list.
</p>


<h3>Value</h3>

<p>a character vector with the same length as x.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>.
</p>


<h3>See Also</h3>

<p>Extended regular expressionsare described in <a href="base.html#topic+regular+20expression">regular expression</a> 
(aka <code><a href="base.html#topic+regexp">regexp</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #
  # Simple use:
  #
stopifnot( trimSpace("   seqinR   ") == "seqinR" )

  #
  # Basic use, remove space at both ends:
  #
testspace &lt;- c("   with leading space", "with trailing space   ", "   with both   ")
stopifnot(all( trimSpace(testspace) == c("with leading space", 
                                         "with trailing space", 
					 "with both")))

  #
  # Remove only leading space:
  #
stopifnot(all( trimSpace(testspace, trailing = FALSE) == c("with leading space",
                                                           "with trailing space   ",  
							   "with both   ")))

  #
  # Remove only trailing space:
  #
stopifnot(all( trimSpace(testspace, leading = FALSE) == c("   with leading space", 
                                                          "with trailing space",  
							  "   with both")))

  #
  # This should do nothing:
  #
stopifnot(all( trimSpace(testspace, leading = FALSE, trailing = FALSE) == testspace))

  #
  # How to use alternative space characters:
  #
allspaces &lt;- "\t\n\f\r seqinR \t\n\f\r"
stopifnot(trimSpace(allspaces) == "seqinR")
stopifnot(trimSpace(allspaces, space = "\t\n") == "\f\r seqinR \t\n\f\r")
</code></pre>

<hr>
<h2 id='uco'> Codon usage indices </h2><span id='topic+uco'></span><span id='topic+rscu'></span>

<h3>Description</h3>

<p><code>uco</code> calculates some codon usage indices: the codon counts <code>eff</code>, the relative frequencies <code>freq</code> or the Relative Synonymous Codon Usage <code>rscu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uco(seq, frame = 0, index = c("eff", "freq", "rscu"), as.data.frame = FALSE,
NA.rscu = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uco_+3A_seq">seq</code></td>
<td>
<p> a coding sequence as a vector of chars </p>
</td></tr>
<tr><td><code id="uco_+3A_frame">frame</code></td>
<td>
<p> an integer (0, 1, 2) giving the frame of the coding sequence </p>
</td></tr>
<tr><td><code id="uco_+3A_index">index</code></td>
<td>
<p> codon usage index choice, partial matching is allowed.
<code>eff</code> for codon counts,
<code>freq</code> for codon relative frequencies,
and <code>rscu</code> the RSCU index.<br />
</p>
<p>&quot;eff&quot;, &quot;freq&quot;, and &quot;rscu&quot; correspond to &quot;R0&quot;, &quot;R1&quot;, and &quot;R3&quot;, respectively, in Suzuki et al. (2005) &quot;2.2 Normalization of codon usage data&quot;.<br />
</p>
<p>&quot;eff&quot; and &quot;rscu&quot; correspond to &quot;AF&quot; and &quot;RSCU&quot;, respectively, in Suzuki et al. (2008) &quot;2.2. Definitions of codon usage data&quot;.
</p>
</td></tr>
<tr><td><code id="uco_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p> logical. If <code>TRUE</code>: all indices are returned into a data frame.</p>
</td></tr>
<tr><td><code id="uco_+3A_na.rscu">NA.rscu</code></td>
<td>
<p> when an amino-acid is missing, RSCU are no more defined and repported
as missing values (<code>NA</code>). You can force them to another value (typically 0 or
1) with this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Codons with ambiguous bases are ignored.<br />
</p>
<p>RSCU is a simple measure of non-uniform usage of synonymous codons in a coding sequence
(Sharp <em>et al.</em> 1986).
RSCU values are the number of times a particular codon is observed, relative to the number
of times that the codon would be observed for a uniform synonymous codon usage (i.e. all the
codons for a given amino-acid have the same probability).
In the absence of any codon usage bias, the RSCU values would be 1.00 (this is the case
for sequence <code>cds</code> in the exemple thereafter). A codon that is used
less frequently than expected will have an RSCU value of less than 1.00 and vice versa for a codon
that is used more frequently than expected.<br />
</p>
<p>Do not use correspondence analysis on RSCU tables as this is a source of artifacts
(Perrière and Thioulouse 2002, Suzuki <em>et al.</em> 2008). Within-aminoacid correspondence analysis is a
simple way to study synonymous codon usage (Charif <em>et al.</em> 2005). For an introduction
to correspondence analysis and within-aminoacid correspondence analysis see the
chapter titled <em>Multivariate analyses</em> in the seqinR manual that ships with the
seqinR package in the <b>doc</b> folder. You can also use internal correspondence
analysis if you want to analyze simultaneously a row-block structure such as the
within and between species variability (Lobry and Chessel 2003).<br />
</p>
<p>If <code>as.data.frame</code> is FALSE, <code>uco</code> returns one of these:
</p>

<dl>
<dt> eff </dt><dd><p> a table of codon counts </p>
</dd>
<dt> freq </dt><dd><p> a table of codon relative frequencies </p>
</dd>
<dt> rscu </dt><dd><p> a numeric vector of relative synonymous codon usage values</p>
</dd>
</dl>

<p>If <code>as.data.frame</code> is TRUE, <code>uco</code> returns a data frame with five columns:
</p>

<dl>
<dt> aa </dt><dd><p> a vector containing the name of amino-acid </p>
</dd>
<dt> codon </dt><dd><p> a vector containing the corresponding codon </p>
</dd>
<dt> eff </dt><dd><p> a numeric vector of codon counts </p>
</dd>
<dt> freq </dt><dd><p> a numeric vector of codon relative frequencies </p>
</dd>
<dt> rscu </dt><dd><p> a numeric vector of RSCU index </p>
</dd>
</dl>



<h3>Value</h3>

<p>If <code>as.data.frame</code> is FALSE, the default, a table for <code>eff</code> and <code>freq</code> and
a numeric vector for <code>rscu</code>. If <code>as.data.frame</code> is TRUE,
a data frame with all indices is returned.
</p>


<h3>Author(s)</h3>

<p>D. Charif, J.R. Lobry, G. Perrière</p>


<h3>References</h3>

<p><code>citation("seqinr")</code> <br />
</p>
<p>Sharp, P.M., Tuohy, T.M.F., Mosurski, K.R. (1986) Codon usage in yeast: cluster
analysis clearly differentiates highly and lowly expressed genes.
<em>Nucl. Acids. Res.</em>, <b>14</b>:5125-5143.<br />
</p>
<p>Perrière, G., Thioulouse, J. (2002) Use and misuse of correspondence analysis in
codon usage studies. <em>Nucl. Acids. Res.</em>, <b>30</b>:4548-4555.<br />
</p>
<p>Lobry, J.R., Chessel, D. (2003) Internal correspondence analysis of codon and
amino-acid usage in thermophilic bacteria.
<em>Journal of Applied Genetics</em>, <b>44</b>:235-261. <a href="http://jag.igr.poznan.pl/2003-Volume-44/2/pdf/2003_Volume_44_2-235-261.pdf">http://jag.igr.poznan.pl/2003-Volume-44/2/pdf/2003_Volume_44_2-235-261.pdf</a>.<br />
</p>
<p>Charif, D., Thioulouse, J., Lobry, J.R., Perrière, G. (2005) Online
Synonymous Codon Usage Analyses with the ade4 and seqinR packages.
<em>Bioinformatics</em>, <b>21</b>:545-547. <a href="https://pbil.univ-lyon1.fr/members/lobry/repro/bioinfo04/">https://pbil.univ-lyon1.fr/members/lobry/repro/bioinfo04/</a>.<br />
</p>
<p>Suzuki, H., Saito, R. Tomita, R. (2005)
A problem in multivariate analysis of codon usage data and a possible solution.
<em>FEBS Lett.</em>, <b>579</b>:6499-504. <a href="https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html">https://www.thermofisher.com/de/de/home/brands/applied-biosystems.html</a>.<br />
</p>
<p>Suzuki, H., Brown, C.J., Forney, L.J., Top, E. (2008)
Comparison of Correspondence Analysis Methods for Synonymous Codon Usage in Bacteria.
<em>DNA Research</em>, <b>15</b>:357-365. <a href="https://academic.oup.com/dnaresearch/article/15/6/357/513030">https://academic.oup.com/dnaresearch/article/15/6/357/513030</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Show all possible codons:
words()

## Make a coding sequence from this:
(cds &lt;- s2c(paste(words(), collapse = "")))

## Get codon counts:
uco(cds, index = "eff")

## Get codon relative frequencies:
uco(cds, index = "freq")

## Get RSCU values:
uco(cds, index = "rscu")

## Show what happens with ambiguous bases:
uco(s2c("aaannnttt"))

## Use a real coding sequence:
rcds &lt;- read.fasta(file = system.file("sequences/malM.fasta", package = "seqinr"))[[1]]
uco( rcds, index = "freq")
uco( rcds, index = "eff")
uco( rcds, index = "rscu")
uco( rcds, as.data.frame = TRUE)

## Show what happens with RSCU when an amino-acid is missing:
ecolicgpe5 &lt;- read.fasta(file = system.file("sequences/ecolicgpe5.fasta",package="seqinr"))[[1]]
uco(ecolicgpe5, index = "rscu")

## Force NA to zero:
uco(ecolicgpe5, index = "rscu", NA.rscu = 0)
</code></pre>

<hr>
<h2 id='ucoweight'>Weight of each synonymous codon</h2><span id='topic+ucoweight'></span>

<h3>Description</h3>

<p>Returns a list containing, for each of the 20 amino acids + STOP
codon, the codon usage bias of each of the synonymous codon according
to a given codon sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ucoweight(sequence, numcode = 1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ucoweight_+3A_sequence">sequence</code></td>
<td>
<p> A nucleic acids sequence </p>
</td></tr>
<tr><td><code id="ucoweight_+3A_numcode">numcode</code></td>
<td>
<p> The genetic code number as in <code>translate</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing, for each of the 20 amino acids and STOP
codon (list tags), the weight of each synonymous codon (including the
original one).
</p>


<h3>Author(s)</h3>

<p>L. Palmeira</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+synsequence">synsequence</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ec999)
  ucoweight(ec999[1][[1]])
</code></pre>

<hr>
<h2 id='waterabs'>Light absorption by the water column</h2><span id='topic+waterabs'></span>

<h3>Description</h3>

<p>The absorption of light by water is highly dependent on the wavelength, this
dataset gives the absorption coefficients from 200 to 700 nm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(waterabs)</code></pre>


<h3>Format</h3>

<p>A data.frame with 2 columns:
</p>

<dl>
<dt>lambda</dt><dd><p>wavelength in nm</p>
</dd>
<dt>abs</dt><dd><p>absorption coefficient in 1/cm</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data were compiled by Palmeira (2007) from the cited references.
</p>
<p>The example section allows to reproduce the left part of figure
2.7 from Palmeira (2007):
</p>
<p><img src="../help/figures/waterabs.jpg" width=400 alt="waterabs.jpg" />

</p>


<h3>References</h3>

<p>Palmeira, L. (2007) <em>Analyse et modélisation des dépendances entre
sites voisins dans l'évolution des séquences d'ADN</em>, PhD thesis,
Université Claude Bernard - Lyon I.<br />
</p>
<p>Litjens R. A., Quickenden T. I. and Freeman C. G. (1999). Visible and
near-ultraviolet absorption spectrum of liquid water. <em>Applied Optics</em>, 
<b>38</b>:1216-1223.<br />
</p>
<p>Quickenden T. I. &amp; Irvin J. A. (1980). The ultraviolet absorption spectrum
of liquid water. <em>The Journal of Chemical Physics</em>, <b>72</b>:4416-4428.<br />
</p>
<p><code>citation("seqinr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterabs)

d &lt;- 100*seq(from = 0, to = 150, by = 1) # depth in cm
lambda &lt;- waterabs$lambda                # wavelength in nm
abs &lt;- waterabs$absorption               # absorption coefficient cm-1
#
# Smooth signal with cubic splines
#
  tmp &lt;- spline(lambda, abs, n = 255)
  lambda &lt;- tmp$x
  abs &lt;- tmp$y

  zun &lt;- sapply(abs,function(x) 10^(-x*d))
  z &lt;- sapply(nrow(zun):1, function(x) zun[x,])
#
# Set up world coordinates:
#
  plot.new()
  plot.window(xlim = range(lambda), ylim = range(d), xaxs = "i",  yaxs = "i")
#
# Annotate:
#
  title(ylab = 'Depth under water surface (m)', xlab = "Wavelength (nm)",
  main = "Light absorption by the water column")
  axis(2 , at = seq(0, 15000, l = 7),
      labels = rev(c("0","25","50","75","100","125","150")), las = 1)
  axis(1,at=(3:6)*100,labels= TRUE)
#
# Show me rainbow colors:
#
  alpha &lt;- 1
  coul=c(rep(rgb(1,1,1, alpha = alpha), 181),
    rev(hsv(h=seq(0,5/6,l=320),alpha = alpha)))
  rect(seq(200,699), 0, seq(201,700), 15000 , col = coul, border = coul)
#
# Grey scale:
#
  ngris &lt;- 5
  image(x = lambda, y = d, z = z, col = rgb(1:ngris, 1:ngris, 1:ngris, alpha = 0.7*(ngris:1),
  max = ngris),
  axes = F, add = TRUE,
  breaks = seq(from = min(z), to = max(z), length = ngris + 1))

#
# Contour lines:
#
  contour(x = lambda, y = d, z = z, add = TRUE, drawlabels = TRUE,labcex= 0.75,
  col='black',
  levels = seq(from = min(z), to = max(z), length = ngris + 1))
  box()

</code></pre>

<hr>
<h2 id='where.is.this.acc'>Scans databases for a given sequence accession number</h2><span id='topic+where.is.this.acc'></span>

<h3>Description</h3>

<p>This function loops over all availabale ACNUC databases to look for
a given sequence accession number. This is useful when you have
a sequence accession number and you don't know in which database
it is present. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where.is.this.acc(acc,  stopAtFirst = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="where.is.this.acc_+3A_acc">acc</code></td>
<td>
<p>An accession number as a string of characters such as <code>"NC_001416"</code>.</p>
</td></tr>
<tr><td><code id="where.is.this.acc_+3A_stopatfirst">stopAtFirst</code></td>
<td>
<p>Logical. If TRUE, the default, the function stops at the first 
database where the accession number is found.</p>
</td></tr>
<tr><td><code id="where.is.this.acc_+3A_...">...</code></td>
<td>
<p>Arguments passed to the function <code><a href="#topic+choosebank">choosebank</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function resturns invisibly a vector of strings of characters for the names of the ACNUC 
databases in which the accession number was found.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code></p>


<h3>See Also</h3>

<p><code><a href="#topic+choosebank">choosebank</a></code> to open a given ACNUC database.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: # Need internet connection
  where.is.this.acc("NC_001416") # first found in phever2dna bank (2016-06-01)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='words'> To get all words from an alphabet.</h2><span id='topic+words'></span>

<h3>Description</h3>

<p>Generates a vectors of all the words from a given alphabet,
with right positions varying faster, for instance if the
<code>alphabet</code> is <code>(c("0","1")</code> and the <code>length</code>
is 2 you will obtain <code>c("00", "01", "10", "11")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>words(length = 3, alphabet = s2c("acgt"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="words_+3A_length">length</code></td>
<td>
<p> the number of characters in the words </p>
</td></tr>
<tr><td><code id="words_+3A_alphabet">alphabet</code></td>
<td>
<p> a vector of characters </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of string whith <code>length</code> characters. 
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+kronecker">kronecker</a></code>, <code><a href="base.html#topic+outer">outer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Get all 64 codons:
#
stopifnot(all(words() ==
c("aaa", "aac", "aag", "aat", "aca", "acc", "acg", "act", "aga", "agc", "agg", 
   "agt", "ata", "atc", "atg", "att","caa", "cac", "cag", "cat", "cca", "ccc", 
   "ccg", "cct", "cga", "cgc", "cgg", "cgt", "cta", "ctc", "ctg", "ctt", "gaa",
   "gac", "gag", "gat", "gca", "gcc", "gcg", "gct", "gga", "ggc", "ggg", "ggt", 
   "gta", "gtc", "gtg", "gtt", "taa", "tac", "tag", "tat", "tca", "tcc", "tcg", 
   "tct", "tga", "tgc", "tgg", "tgt", "tta", "ttc", "ttg", "ttt")))
#
# Get all codons with u c a g for bases:
#
words(alphabet = s2c("ucag"))
#
# Get all tetranucleotides:
#
words(length = 4)
#
# Get all dipeptides:
#
words(length = 2, alphabet = a()[-1])
</code></pre>

<hr>
<h2 id='words.pos'> Positions of possibly degenerated motifs within sequences </h2><span id='topic+words.pos'></span>

<h3>Description</h3>

<p><code>word.pos</code> searches all the occurences of the motif <code>pattern</code>
within the sequence <code>text</code> and returns their positions. This
function is based on <code>regexp</code> allowing thus for complex motif searches.
The main difference with <code><a href="base.html#topic+gregexpr">gregexpr</a></code> is that non disjoint matches
are reported here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>words.pos(pattern, text, ignore.case = FALSE,
                      perl = TRUE, fixed = FALSE, useBytes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="words.pos_+3A_pattern">pattern</code></td>
<td>
<p>character string containing a <a href="base.html#topic+regular+20expression">regular expression</a> (or character string for <code>fixed = TRUE</code>) to be matched in the given character vector.</p>
</td></tr>
<tr><td><code id="words.pos_+3A_text">text</code></td>
<td>
<p> a character vector where matches are sought. </p>
</td></tr>
<tr><td><code id="words.pos_+3A_ignore.case">ignore.case</code></td>
<td>
<p>if <code>FALSE</code>, the pattern matching is case sensitive and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
<tr><td><code id="words.pos_+3A_perl">perl</code></td>
<td>
<p>logical. Should perl-compatible regexps be used if available?
Has priority over <code>extended</code>.</p>
</td></tr>
<tr><td><code id="words.pos_+3A_fixed">fixed</code></td>
<td>
<p>logical. If <code>TRUE</code>, pattern is a string to be matched as is. Overrides all conflicting arguments.</p>
</td></tr>
<tr><td><code id="words.pos_+3A_usebytes">useBytes</code></td>
<td>
<p>logical. If <code>TRUE</code> the matching is done byte-by-byte rather than character-by-character.</p>
</td></tr>
<tr><td><code id="words.pos_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+regexpr">regexpr</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default parameter values have been tuned for speed when working biological sequences.
</p>


<h3>Value</h3>

<p>a vector of positions for which the motif <code>pattern</code> was
found in the sequence <code>text</code>.
</p>


<h3>Author(s)</h3>

<p>J.R. Lobry</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+regexpr">regexpr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>myseq &lt;- "tatagaga"
words.pos("t", myseq)   # Should be 1 3
words.pos("tag", myseq) # Should be 3
words.pos("ga", myseq)  # Should be 5 7
# How to specify ambiguous base ? Look for YpR motifs by
words.pos("[ct][ag]", myseq) # Should be 1 3
#
# Show the difference with gregexpr:
#
words.pos("toto", "totototo")           # 1 3 5 (three overlapping matches)
unlist(gregexpr("toto",  "totototo")) # 1 5    (two disjoint matches)
</code></pre>

<hr>
<h2 id='write.fasta'> Write sequence(s) into a file in fasta format </h2><span id='topic+write.fasta'></span>

<h3>Description</h3>

<p>Writes one or more sequences into a file in FASTA format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fasta(sequences, names, file.out, open = "w", nbchar = 60, as.string = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.fasta_+3A_sequences">sequences</code></td>
<td>
<p> A DNA or protein sequence (in the form of a
vector of single characters by default) or a list of such sequences. </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_as.string">as.string</code></td>
<td>
<p> FALSE. When set to TRUE sequences are in the
form of strings instead of vectors of single characters. </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_names">names</code></td>
<td>
<p> The name(s) of the sequences. </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_nbchar">nbchar</code></td>
<td>
<p> The number of characters per line (default: 60) </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_file.out">file.out</code></td>
<td>
<p> The name of the output file. </p>
</td></tr>
<tr><td><code id="write.fasta_+3A_open">open</code></td>
<td>
<p> Mode to open the output file, use &quot;w&quot; to write into
a new file, use &quot;a&quot; to append at the end of an already existing file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p>A. Necşulea</p>


<h3>References</h3>

<p><code>citation("seqinr")</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.fasta">read.fasta</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read 3 sequences from a FASTA file:
ortho &lt;- read.fasta(file = system.file("sequences/ortho.fasta", package =
"seqinr"))

## Select only third codon positions:
ortho3 &lt;- lapply(ortho, function(x) x[seq(from = 3, to = length(x), by = 3)])

## Write the 3 modified sequences to a file:
fname &lt;- tempfile(pattern = "ortho3", tmpdir = tempdir(), fileext = "fasta")
#write.fasta(sequences = ortho3, names = names(ortho3), nbchar = 80, file.out = "ortho3.fasta")
write.fasta(sequences = ortho3, names = names(ortho3), nbchar = 80, file.out = fname)

## Read them again from the same file and check that sequences are preserved:
ortho3bis &lt;- read.fasta(fname, set.attributes = FALSE)
stopifnot(identical(ortho3bis, ortho3))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
