<!DOCTYPE html><html><head><title>Help for package RND</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RND}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RND-package'>
<p>Risk Neutral Density Extraction Package</p></a></li>
<li><a href='#approximate.max'><p>Max Function Approximation</p></a></li>
<li><a href='#bsm.objective'><p>BSM Objective Function</p></a></li>
<li><a href='#compute.implied.volatility'><p>Compute Impied Volatility</p></a></li>
<li><a href='#dew'><p>Edgeworth Density</p></a></li>
<li><a href='#dgb'><p>Generalized Beta Density</p></a></li>
<li><a href='#dmln'><p>Density of Mixture Lognormal</p></a></li>
<li><a href='#dmln.am'><p>Density of Mixture Lognormal for American Options</p></a></li>
<li><a href='#dshimko'><p>Density Implied by Shimko Method</p></a></li>
<li><a href='#ew.objective'><p>Edgeworth Exapnsion Objective Function</p></a></li>
<li><a href='#extract.am.density'><p>Mixture of Lognormal Extraction for American Options</p></a></li>
<li><a href='#extract.bsm.density'><p>Extract Lognormal Density</p></a></li>
<li><a href='#extract.ew.density'><p>Extract Edgeworth Based Density</p></a></li>
<li><a href='#extract.gb.density'><p>Generalized Beta Extraction</p></a></li>
<li><a href='#extract.mln.density'><p>Extract Mixture of Lognormal Densities</p></a></li>
<li><a href='#extract.rates'><p>Extract Risk Free Rate and Dividend Yield</p></a></li>
<li><a href='#extract.shimko.density'><p>Extract Risk Neutral Density based on Shimko's Method</p></a></li>
<li><a href='#fit.implied.volatility.curve'><p>Fit Implied Quadratic Volatility Curve</p></a></li>
<li><a href='#gb.objective'><p>Generalized Beta Objective</p></a></li>
<li><a href='#get.point.estimate'><p>Point Estimation of the Density</p></a></li>
<li><a href='#mln.am.objective'><p>Objective function for the Mixture of Lognormal of American Options</p></a></li>
<li><a href='#mln.objective'><p>Objective function for the Mixture of Lognormal</p></a></li>
<li><a href='#MOE'><p>Mother of All Extractions</p></a></li>
<li><a href='#oil.2012.10.01'>
<p>West Texas Intermediate Crude Oil Options on 2013-10-01</p></a></li>
<li><a href='#pgb'><p>CDF of Generalized Beta</p></a></li>
<li><a href='#price.am.option'><p>Price American Options on Mixtures of Lognormals</p></a></li>
<li><a href='#price.bsm.option'><p>Price BSM Option</p></a></li>
<li><a href='#price.ew.option'><p>Price Options with Edgeworth Approximated Density</p></a></li>
<li><a href='#price.gb.option'><p>Generalized Beta Option Pricing</p></a></li>
<li><a href='#price.mln.option'><p>Price Options on Mixture of Lognormals</p></a></li>
<li><a href='#price.shimko.option'><p>Price Option based on Shimko's Method</p></a></li>
<li><a href='#sp500.2013.04.19'>
<p>S&amp;P 500 Index Options on 2013-04-19</p></a></li>
<li><a href='#sp500.2013.06.24'>
<p>S&amp;P 500 Index Options on 2013-06-24</p></a></li>
<li><a href='#vix.2013.06.25'>
<p>VIX Options on 2013-06-25</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Risk Neutral Density Extraction Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-01-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Kam Hamidieh &lt;khamidieh@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kam Hamidieh &lt;khamidieh@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extract the implied risk neutral density from options using various methods.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-10 18:31:18 UTC; proud</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-11 00:14:55</td>
</tr>
</table>
<hr>
<h2 id='RND-package'>
Risk Neutral Density Extraction Package
</h2><span id='topic+RND-package'></span><span id='topic+RND'></span>

<h3>Description</h3>

<p>This package is a collection of various functions to extract the implied risk neutral density from option.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RND</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-01-10</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Kam Hamidieh &lt;khamidieh@gmail.com&gt;
</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### You should see that all methods extract the same density!
###

r     = 0.05
te    = 60/365
s0    = 1000
sigma = 0.25
y     = 0.02

call.strikes.bsm   = seq(from = 500, to = 1500, by = 5)
market.calls.bsm   = price.bsm.option(r =r, te = te, s0 = s0, 
                     k = call.strikes.bsm, sigma = sigma, y = y)$call

put.strikes.bsm    = seq(from = 500, to = 1500, by = 5)
market.puts.bsm    = price.bsm.option(r =r, te = te, s0 = s0, 
                     k = put.strikes.bsm, sigma = sigma, y = y)$put

###
### See where your results will be outputted to...
###

getwd()


###
###  Running this may take a few minutes...
###
###  MOE(market.calls.bsm, call.strikes.bsm, market.puts.bsm, 
###  put.strikes.bsm, s0, r , te, y, "bsm2")
###
</code></pre>

<hr>
<h2 id='approximate.max'>Max Function Approximation</h2><span id='topic+approximate.max'></span>

<h3>Description</h3>

<p><code>approximate.max</code> gives a smooth approximation to the max function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>approximate.max(x, y, k = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approximate.max_+3A_x">x</code></td>
<td>
<p>the first argument for the max function</p>
</td></tr>
<tr><td><code id="approximate.max_+3A_y">y</code></td>
<td>
<p>the second argument fot the max function</p>
</td></tr>
<tr><td><code id="approximate.max_+3A_k">k</code></td>
<td>
<p>a tuning parameter.  The larger this value, the closer the function output to a true max function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>approximate.max</code> approximates the max of x, and y as follows: 
</p>
<p style="text-align: center;"><code class="reqn">
 g(x,y) = \frac{1}{1 + \exp(-k(x-y))}, \ \
 \max(x,y) \approx x g(x,y) + y(1 - g(x,y))
 </code>
</p>



<h3>Value</h3>

<p>approximate maximum of x and y</p>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>Melick, W. R. and Thomas, C.P. (1997)
Recovering an asset's implied pdf from option proces:
An application to crude oil during the gulf crisis.
<em>Journal of Financial and Quantitative Analysis</em>, 32(1), 91-115
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# To see how the max function compares with approximate.max,
# run the following code.
#

i = seq(from = 0, to = 10, by = 0.25)
y = i - 5
max.values = pmax(0,y)
approximate.max.values = approximate.max(0,y,k=5)
matplot(i, cbind(max.values, approximate.max.values), lty = 1, type = "l", 
 col=c("black","red"), main = "Max in Black, Approximate Max in Red")
</code></pre>

<hr>
<h2 id='bsm.objective'>BSM Objective Function</h2><span id='topic+bsm.objective'></span>

<h3>Description</h3>

<p><code>bsm.objective</code> is the objective function to be minimized in <code>extract.bsm.density</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsm.objective(s0, r, te, y, market.calls, call.strikes, call.weights = 1, 
  market.puts, put.strikes, put.weights = 1, lambda = 1, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsm.objective_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_put.strikes">put.strikes</code></td>
<td>
<p>strikes for the puts (smallest to largest)</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
<tr><td><code id="bsm.objective_+3A_theta">theta</code></td>
<td>
<p>initial values for the optimization.  This must be a vector
of length 2: first component is <code class="reqn">\mu</code>, the lognormal mean of
the underlying density, and the second component is <code class="reqn">\sqrt{t}\sigma</code> which is the
time scaled volatility parameter of the underlying density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the weighted squared differences between the market option values and
values predicted by the Black-Scholes-Merton option pricing formula.
</p>


<h3>Value</h3>

<p>Objective function evalued at a specific set of values.
</p>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r     = 0.05
te    = 60/365
s0    = 1000
sigma = 0.25
y     = 0.01

call.strikes   = seq(from = 500, to = 1500, by = 25)
market.calls   = price.bsm.option(r =r, te = te, s0 = s0, 
                 k = call.strikes, sigma = sigma, y = y)$call

put.strikes    = seq(from = 510, to = 1500, by = 25)
market.puts    = price.bsm.option(r =r, te = te, s0 = s0, 
                 k = put.strikes, sigma = sigma, y = y)$put

###
### perfect initial values under BSM framework
###

mu.0     = log(s0) + ( r - y - 0.5 * sigma^2) * te
zeta.0   = sigma * sqrt(te)
mu.0
zeta.0

###
### The objective function should be *very* small
###

bsm.obj.val = bsm.objective(theta=c(mu.0, zeta.0), r = r, y=y, te = te, s0 = s0, 
              market.calls = market.calls, call.strikes = call.strikes, 
              market.puts  = market.puts,  put.strikes = put.strikes, lambda = 1)
bsm.obj.val
</code></pre>

<hr>
<h2 id='compute.implied.volatility'>Compute Impied Volatility</h2><span id='topic+compute.implied.volatility'></span>

<h3>Description</h3>

<p><code>compute.implied.volatility</code> extracts the implied volatility for a call option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.implied.volatility(r, te, s0, k, y, call.price, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.implied.volatility_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="compute.implied.volatility_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="compute.implied.volatility_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="compute.implied.volatility_+3A_k">k</code></td>
<td>
<p>strike of the call option</p>
</td></tr>
<tr><td><code id="compute.implied.volatility_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="compute.implied.volatility_+3A_call.price">call.price</code></td>
<td>
<p>call price</p>
</td></tr>
<tr><td><code id="compute.implied.volatility_+3A_lower">lower</code></td>
<td>
<p>lower bound of the implied volatility to look for</p>
</td></tr>
<tr><td><code id="compute.implied.volatility_+3A_upper">upper</code></td>
<td>
<p>upper bound of the implied volatility to look for</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simple R <code>uniroot</code> function is used to extract the implied volatility.</p>


<h3>Value</h3>

<table>
<tr><td><code>sigma</code></td>
<td>
<p>extratced implied volatility</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>J. Hull (2011)
<em>Options, Futures, and Other Derivatives and DerivaGem Package</em>
Prentice Hall, Englewood Cliffs, New Jersey, 8th Edition
</p>
<p>R. L. McDonald (2013)
<em>Derivatives Markets</em>
Pearson, Upper Saddle River, New Jersey, 3rd Edition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create prices from BSM with various sigma's
#

r     =  0.05
y     =  0.02
te    =  60/365
s0    =  400

sigma.range = seq(from = 0.1, to = 0.8, by = 0.05)
k.range     = floor(seq(from = 300, to = 500, length.out = length(sigma.range)))
bsm.calls   = numeric(length(sigma.range))

for (i in 1:length(sigma.range))
{
  bsm.calls[i] = price.bsm.option(r = r, te = te, s0 = s0, k = k.range[i], 
                                  sigma = sigma.range[i], y = y)$call
}
bsm.calls
k.range

#
# Computed implied sigma's should be very close to sigma.range.
#

compute.implied.volatility(r = r, te = te, s0 = s0, k = k.range, y = y, 
                          call.price = bsm.calls, lower = 0.001, upper = 0.999)
sigma.range

</code></pre>

<hr>
<h2 id='dew'>Edgeworth Density</h2><span id='topic+dew'></span>

<h3>Description</h3>

  <p><code>dew</code> is the probability density function implied by the Edgeworth expansion method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dew(x, r, y, te, s0, sigma, skew, kurt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dew_+3A_x">x</code></td>
<td>
<p>value at which the denisty is to be evaluated</p>
</td></tr>
<tr><td><code id="dew_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="dew_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="dew_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="dew_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="dew_+3A_sigma">sigma</code></td>
<td>
<p>volatility</p>
</td></tr>
<tr><td><code id="dew_+3A_skew">skew</code></td>
<td>
<p>normalized skewness</p>
</td></tr>
<tr><td><code id="dew_+3A_kurt">kurt</code></td>
<td>
<p>normalized kurtosis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This density function attempts to capture deviations from lognormal density by using Edgeworth expansions.</p>


<h3>Value</h3>

<p>density value at x
</p>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>
<p>R. Jarrow and A. Rudd (1982)
Approximate valuation for arbitrary stochastic processes.
<em>Journal of Finanical Economics</em>, 10, 347-369
</p>
<p>C.J. Corrado and T. Su (1996)
S&amp;P 500 index option tests of Jarrow and Rudd's approximate option valuation formula.
<em>Journal of Futures Markets</em>, 6, 611-629
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Look at a true lognorma density &amp; related dew
#
r       = 0.05
y       = 0.03
s0      = 1000
sigma   = 0.25
te      = 100/365
strikes = seq(from=600, to = 1400, by = 1)
v       = sqrt(exp(sigma^2 * te) - 1)
ln.skew = 3 * v + v^3
ln.kurt = 16 * v^2 + 15 * v^4 + 6 * v^6 + v^8

skew.4 = ln.skew * 1.50
kurt.4 = ln.kurt * 1.50

skew.5 = ln.skew * 0.50
kurt.5 = ln.kurt * 2.00

ew.density.4   = dew(x=strikes, r=r, y=y, te=te, s0=s0, sigma=sigma, 
                     skew=skew.4, kurt=kurt.4)
ew.density.5   = dew(x=strikes, r=r, y=y, te=te, s0=s0, sigma=sigma, 
                     skew=skew.5, kurt=kurt.5)
bsm.density    = dlnorm(x = strikes, meanlog = log(s0) + (r - y - (sigma^2)/2)*te, 
                 sdlog = sigma*sqrt(te), log = FALSE)

matplot(strikes, cbind(bsm.density, ew.density.4, ew.density.5), type="l", 
        lty=c(1,1,1), col=c("black","red","blue"), 
        main="Black = BSM,  Red = EW 1.5 Times,  Blue = EW 0.50 &amp; 2")
</code></pre>

<hr>
<h2 id='dgb'>Generalized Beta Density</h2><span id='topic+dgb'></span>

<h3>Description</h3>

<p><code>dgb</code> is the probability density function of generalized beta distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgb(x, a, b, v, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgb_+3A_x">x</code></td>
<td>
<p>value at which the denisty is to be evaluated</p>
</td></tr>
<tr><td><code id="dgb_+3A_a">a</code></td>
<td>
<p>power parameter &gt; 0</p>
</td></tr>
<tr><td><code id="dgb_+3A_b">b</code></td>
<td>
<p>scale paramter &gt; 0</p>
</td></tr>
<tr><td><code id="dgb_+3A_v">v</code></td>
<td>
<p>first beta paramter &gt; 0</p>
</td></tr>
<tr><td><code id="dgb_+3A_w">w</code></td>
<td>
<p>second beta parameter &gt; 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let B be a beta random variable with parameters v and w, then <code class="reqn">Z = b(B/(1-B))^{1/a}</code> 
is a generalized beta with parameters (a,b,v,w).
</p>


<h3>Value</h3>

<p>density value at x</p>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>R.M. Bookstaber and J.B. McDonald (1987)
A general distribution for describing security price returns.
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>X. Liu and M.B. Shackleton and S.J. Taylor and X. Xu (2007)
Closed-form transformations from risk-neutral to real-world distributions
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Just simple plot of the density
#

x = seq(from = 500, to = 1500, length.out = 10000)
a = 10
b = 1000
v = 3
w = 3
dx = dgb(x = x, a = a, b = b, v = v, w = w)
plot(dx ~ x, type="l")

</code></pre>

<hr>
<h2 id='dmln'>Density of Mixture Lognormal</h2><span id='topic+dmln'></span>

<h3>Description</h3>

<p><code>mln</code> is the probability density function of a mixture of two lognormal densities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmln(x, alpha.1, meanlog.1, meanlog.2, sdlog.1, sdlog.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmln_+3A_x">x</code></td>
<td>
<p>value at which the denisty is to be evaluated</p>
</td></tr>
<tr><td><code id="dmln_+3A_alpha.1">alpha.1</code></td>
<td>
<p>proportion of the first lognormal.  Second one is 1 - <code>alpha.1</code></p>
</td></tr>
<tr><td><code id="dmln_+3A_meanlog.1">meanlog.1</code></td>
<td>
<p>mean of the log of the first lognormal</p>
</td></tr>
<tr><td><code id="dmln_+3A_meanlog.2">meanlog.2</code></td>
<td>
<p>mean of the log of the second lognormal</p>
</td></tr>
<tr><td><code id="dmln_+3A_sdlog.1">sdlog.1</code></td>
<td>
<p>standard deviation of the log of the first lognormal</p>
</td></tr>
<tr><td><code id="dmln_+3A_sdlog.2">sdlog.2</code></td>
<td>
<p>standard deviation of the log of the second lognormal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mln is the density f(x) = alpha.1 * g(x) + (1 - alpha.1) * h(x), where g and h are densities of two lognormals with
parameters (mean.log.1, sdlog.1) and (mean.log.2, sdlog.2) respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>density value at x</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>B. Bahra (1996):
Probability distribution of future asset prices implied by option prices.
<em>Bank of England Quarterly Bulletin</em>, August 1996, 299-311
</p>
<p>P. Soderlind and L.E.O. Svensson (1997)
New techniques to extract market expectations from financial instruments.
<em>Journal of Monetary Economics</em>, 40, 383-429
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# A bimodal risk neutral density!
#

mln.alpha.1   = 0.4
mln.meanlog.1 = 6.3
mln.meanlog.2 = 6.5
mln.sdlog.1   = 0.08
mln.sdlog.2   = 0.06

k  = 300:900
dx = dmln(x = k, alpha.1 = mln.alpha.1, meanlog.1 = mln.meanlog.1, 
         meanlog.2 = mln.meanlog.2, 
         sdlog.1 = mln.sdlog.1, sdlog.2 = mln.sdlog.2)
plot(dx ~ k, type="l")
</code></pre>

<hr>
<h2 id='dmln.am'>Density of Mixture Lognormal for American Options</h2><span id='topic+dmln.am'></span>

<h3>Description</h3>

<p><code>mln.am</code> is the probability density function of a mixture of three lognormal densities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmln.am(x, u.1, u.2, u.3, sigma.1, sigma.2, sigma.3, p.1, p.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmln.am_+3A_x">x</code></td>
<td>
<p>value at which the denisty is to be evaluated</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_u.1">u.1</code></td>
<td>
<p>log mean of the first lognormal</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_u.2">u.2</code></td>
<td>
<p>log mean of the second lognormal</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_u.3">u.3</code></td>
<td>
<p>log mean of the third lognormal</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_sigma.1">sigma.1</code></td>
<td>
<p>log standard deviation of the first lognormal</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_sigma.2">sigma.2</code></td>
<td>
<p>log standard deviation of the second lognormal</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_sigma.3">sigma.3</code></td>
<td>
<p>log standard deviation of the third lognormal</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_p.1">p.1</code></td>
<td>
<p>weight assigned to the first density</p>
</td></tr>
<tr><td><code id="dmln.am_+3A_p.2">p.2</code></td>
<td>
<p>weight assigned to the second density</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mln is density f(x) = p.1 * f1(x) + p.2 * f2(x) + (1 - p.1 - p.2) * f3(x), where
f1, f2, and f3 are lognormal densities with log means u.1,u.2, and u.3 and
standard deviations sigma.1, sigma.2, and sigma.3 respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>density value at x</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>Melick, W. R. and Thomas, C. P. (1997). Recovering an asset's implied pdf from option prices: An
application to crude oil during the gulf crisis. <em>Journal of Financial and Quantitative Analysis</em>,
32(1), 91-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
### Just look at a generic density and see if it integrates to 1.
###

u.1     = 4.2
u.2     = 4.5
u.3     = 4.8
sigma.1 = 0.30
sigma.2 = 0.20
sigma.3 = 0.15
p.1     = 0.25
p.2     = 0.45
x = seq(from = 0, to = 250, by = 0.01)
y = dmln.am(x = x, u.1 = u.1, u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
            sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)

plot(y ~ x, type="l")
sum(y * 0.01)

###
### Yes, the sum is near 1.
###
</code></pre>

<hr>
<h2 id='dshimko'>Density Implied by Shimko Method</h2><span id='topic+dshimko'></span>

<h3>Description</h3>

<p><code>dshimko</code> is the probability density function implied by the Shimko method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dshimko(r, te, s0, k, y, a0, a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dshimko_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="dshimko_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="dshimko_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="dshimko_+3A_k">k</code></td>
<td>
<p>strike at which volatility to be computed</p>
</td></tr>
<tr><td><code id="dshimko_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="dshimko_+3A_a0">a0</code></td>
<td>
<p>constant term in the quadratic polynomial</p>
</td></tr>
<tr><td><code id="dshimko_+3A_a1">a1</code></td>
<td>
<p>coefficient term of k in the quadratic polynomial</p>
</td></tr>
<tr><td><code id="dshimko_+3A_a2">a2</code></td>
<td>
<p>coefficient term of k squared in the quadratic polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implied volatility is modeled as: <code class="reqn">\sigma(k) = a_0 + a_1 k + a_2 k^2</code>
</p>


<h3>Value</h3>

<p>density value at x</p>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>D. Shimko (1993)
Bounds of probability.
<em>Risk</em>, 6, 33-47
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# a0, a1, a2 values come from Shimko's paper.
#

r     =  0.05
y     =  0.02
a0    =  0.892
a1    = -0.00387
a2    =  0.00000445
te    =  60/365
s0    =  400
k     =  seq(from = 250, to = 500, by = 1)
sigma =  0.15

#
# Does it look like a proper density and intergate to one?
#

dx = dshimko(r = r, te = te, s0 = s0, k = k, y = y, a0 = a0, a1 = a1, a2 = a2)
plot(dx ~ k, type="l")

#
# sum(dx) should be about 1 since dx is a density.
#

sum(dx)

</code></pre>

<hr>
<h2 id='ew.objective'>Edgeworth Exapnsion Objective Function</h2><span id='topic+ew.objective'></span>

<h3>Description</h3>

<p><code>ew.objective</code> is the objective function to be minimized in <code>ew.extraction</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ew.objective(theta, r, y, te, s0, market.calls, call.strikes, call.weights = 1, 
  lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ew.objective_+3A_theta">theta</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="ew.objective_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the weighted squared differences between the market option values and
values predicted by Edgworth based expansion of the risk neutral density.</p>


<h3>Value</h3>

<p>Objective function evalued at a specific set of values</p>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>
<p>R. Jarrow and A. Rudd (1982)
Approximate valuation for arbitrary stochastic processes.
<em>Journal of Finanical Economics</em>, 10, 347-369
</p>
<p>C.J. Corrado and T. Su (1996)
S&amp;P 500 index option tests of Jarrow and Rudd's approximate option valuation formula.
<em>Journal of Futures Markets</em>, 6, 611-629
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r       = 0.05
y       = 0.03
s0      = 1000
sigma   = 0.25
te      = 100/365
k       = seq(from=800, to = 1200, by = 50)
v       = sqrt(exp(sigma^2 * te) - 1)
ln.skew = 3 * v + v^3
ln.kurt = 16 * v^2 + 15 * v^4 + 6 * v^6 + v^8

#
# The objective function should be close to zero.  
# Also the weights are automatically set to 1.
#

market.calls.bsm = price.bsm.option(r = r, te = te, s0 = s0, k=k, 
                   sigma=sigma, y=y)$call
ew.objective(theta = c(sigma, ln.skew, ln.kurt), r = r, y = y, te = te, s0=s0, 
             market.calls = market.calls.bsm, call.strikes = k, lambda = 1)


</code></pre>

<hr>
<h2 id='extract.am.density'>Mixture of Lognormal Extraction for American Options</h2><span id='topic+extract.am.density'></span>

<h3>Description</h3>

<p><code>extract.am.density</code> extracts the mixture of three lognormals from American options.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.am.density(initial.values = rep(NA, 10), r, te, s0, market.calls, 
  call.weights = NA, market.puts, put.weights = NA, strikes, lambda = 1, 
  hessian.flag = F, cl = list(maxit = 10000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.am.density_+3A_initial.values">initial.values</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls.  Set to 1 by default.</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for puts.  Set to 1 by default.</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_strikes">strikes</code></td>
<td>
<p>strikes (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_hessian.flag">hessian.flag</code></td>
<td>
<p>If FALSE then no Hessian is produced</p>
</td></tr>
<tr><td><code id="extract.am.density_+3A_cl">cl</code></td>
<td>
<p>List of parameter values to be passed to the optimization function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extracted density is in the form of f(x) = p.1 * f1(x) + p.2 * f2(x) + (1 - p.1 - p.2) * f3(x), 
where f1, f2, and f3 are lognormal densities with log means u.1,u.2, and u.3 and
standard deviations sigma.1, sigma.2, and sigma.3 respectively.
</p>
<p>For the description of w.1 and w.2 see equations (7) &amp; (8) of Melick and Thomas paper below.
</p>


<h3>Value</h3>

<table>
<tr><td><code>w.1</code></td>
<td>
<p>First weight, a number between 0 and 1, to weigh the option price bounds</p>
</td></tr>
<tr><td><code>w.2</code></td>
<td>
<p>Second weight, a number between 0 and 1, to weigh the option price bounds</p>
</td></tr>
<tr><td><code>u.1</code></td>
<td>
<p>log mean of the first lognormal</p>
</td></tr>
<tr><td><code>u.2</code></td>
<td>
<p>log mean of the second lognormal</p>
</td></tr>
<tr><td><code>u.3</code></td>
<td>
<p>log mean of the third lognormal</p>
</td></tr>
<tr><td><code>sigma.1</code></td>
<td>
<p>log sd of the first lognormal</p>
</td></tr>
<tr><td><code>sigma.2</code></td>
<td>
<p>log sd of the second lognormal</p>
</td></tr>
<tr><td><code>sigma.3</code></td>
<td>
<p>log sd of the third lognormal</p>
</td></tr>
<tr><td><code>p.1</code></td>
<td>
<p>weight assigned to the first density</p>
</td></tr>
<tr><td><code>p.2</code></td>
<td>
<p>weight assigned to the second density</p>
</td></tr>
<tr><td><code>converge.result</code></td>
<td>
<p>Captures the convergence result</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Hessian Matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>Melick, W. R. and Thomas, C. P. (1997). Recovering an asset's implied pdf from option prices: An
application to crude oil during the gulf crisis. <em>Journal of Financial and Quantitative Analysis</em>,
32(1), 91-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### Try with synthetic data first.
###

r       = 0.01
te      = 60/365
w.1     = 0.4
w.2     = 0.25
u.1     = 4.2
u.2     = 4.5
u.3     = 4.8
sigma.1 = 0.30
sigma.2 = 0.20
sigma.3 = 0.15
p.1     = 0.25
p.2     = 0.45
theta   = c(w.1,w.2,u.1,u.2,u.3,sigma.1,sigma.2,sigma.3,p.1,p.2)
p.3     = 1 - p.1 - p.2

###
### Generate some synthetic American calls &amp; puts
###

expected.f0   =  sum(c(p.1, p.2, p.3) * exp(c(u.1,u.2,u.3) + 
                    (c(sigma.1, sigma.2, sigma.3)^2)/2) )
expected.f0  
 
strikes = 50:150

market.calls = numeric(length(strikes))
market.puts  = numeric(length(strikes))

for (i in 1:length(strikes))
{

  if ( strikes[i] &lt; expected.f0) {
    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
  }  else {

    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
     }

}


###
### ** IMPORTANT **:  The code that follows may take 1-2 minutes.
###                   Copy and paste onto R console the commands
###                   that follow the greater sign &gt;.
###
### Try the optimization with exact inital values.  
### They should be close the actual initials.
###
#
# &gt; s0      = expected.f0 * exp(-r * te)
# &gt; s0
#
# &gt; extract.am.density(initial.values = theta, r = r, te = te, s0 = s0, 
#                  market.calls = market.calls, market.puts = market.puts, strikes = strikes, 
#                  lambda = 1, hessian.flag = FALSE)
#
# &gt; theta
#
###
### Now try without our the correct initial values...
###
#
# &gt; optim.obj.no.init = extract.am.density( r = r, te = te, s0 = s0, 
#                   market.calls = market.calls, market.puts = market.puts, strikes = strikes, 
#                    lambda = 1, hessian.flag = FALSE)
#
# &gt; optim.obj.no.init
# &gt; theta
#
###
### We do get different values but how do the densities look like?
###
#
###
### plot the two densities side by side
###
#
# &gt; x = 10:190
#
# &gt; y.1 = dmln.am(x = x, p.1 = theta[9], p.2 = theta[10],
#           u.1 = theta[3], u.2 = theta[4], u.3 = theta[5], 
#          sigma.1 = theta[6], sigma.2 = theta[7], sigma.3 = theta[8] )
#
# &gt; o = optim.obj.no.init
#
# &gt; y.2 = dmln.am(x = x, p.1 = o$p.1, p.2 = o$p.2,
#           u.1 = o$u.1, u.2 = o$u.2, u.3 = o$u.3, 
#           sigma.1 = o$sigma.1, sigma.2 = o$sigma.2, sigma.3 = o$sigma.3 )
#
# &gt; matplot(x, cbind(y.1,y.2), main = "Exact = Black, Approx = Red", type="l", lty=1)
#
###
### Densities are close.
###


</code></pre>

<hr>
<h2 id='extract.bsm.density'>Extract Lognormal Density</h2><span id='topic+extract.bsm.density'></span>

<h3>Description</h3>

<p><code>bsm.extraction</code> extracts the parameters of the lognormal density as implied by the BSM model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.bsm.density(initial.values = c(NA, NA), r, y, te, s0, market.calls, 
  call.strikes, call.weights = 1, market.puts, put.strikes, put.weights = 1, 
  lambda = 1, hessian.flag = F, cl = list(maxit = 10000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.bsm.density_+3A_initial.values">initial.values</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_put.strikes">put.strikes</code></td>
<td>
<p>strikes for the puts (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for puts</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_hessian.flag">hessian.flag</code></td>
<td>
<p>if F, no hessian is produced</p>
</td></tr>
<tr><td><code id="extract.bsm.density_+3A_cl">cl</code></td>
<td>
<p>list of parameter values to be passed to the optimization function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>initial.values</code> are not specified then the function will attempt to pick them
automatically.  <code>cl</code> is a list that can be used to pass parameters to the <code>optim</code>
function.
</p>


<h3>Value</h3>

<p>Let S_T with the lognormal random variable of the risk neutral density.
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>mean of log(S_T)</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>sd of log(S_T)</p>
</td></tr>
<tr><td><code>converge.result</code></td>
<td>
<p>Did the result converge?</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> Hessian matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>
<p>J. Hull (2011)
<em>Options, Futures, and Other Derivatives and DerivaGem Package</em>
Prentice Hall, Englewood Cliffs, New Jersey, 8th Edition
</p>
<p>R. L. McDonald (2013)
<em>Derivatives Markets</em>
Pearson, Upper Saddle River, New Jersey, 3rd Edition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create some BSM Based options
#

r     = 0.05
te    = 60/365
s0    = 1000
sigma = 0.25
y     = 0.01

call.strikes   = seq(from = 500, to = 1500, by = 25)
market.calls   = price.bsm.option(r =r, te = te, s0 = s0, 
                 k = call.strikes, sigma = sigma, y = y)$call

put.strikes    = seq(from = 510, to = 1500, by = 25)
market.puts    = price.bsm.option(r =r, te = te, s0 = s0, 
                 k = put.strikes, sigma = sigma, y = y)$put

#
#  Get extract the parameter of the density
#

extract.bsm.density(r = r, y = y, te = te, s0 = s0, market.calls = market.calls, 
               call.strikes = call.strikes,  market.puts = market.puts, 
               put.strikes = put.strikes, lambda = 1, hessian.flag = FALSE)

#
# The extracted parameters should be close to these actual values:
#
actual.mu     = log(s0) + ( r - y - 0.5 * sigma^2) * te
actual.zeta   = sigma * sqrt(te)
actual.mu 
actual.zeta
</code></pre>

<hr>
<h2 id='extract.ew.density'>Extract Edgeworth Based Density</h2><span id='topic+extract.ew.density'></span>

<h3>Description</h3>

<p><code>ew.extraction</code> extracts the parameters for the density approximated by the Edgeworth expansion method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.ew.density(initial.values = c(NA, NA, NA), r, y, te, s0, market.calls, 
  call.strikes, call.weights = 1, lambda = 1, hessian.flag = F, 
  cl = list(maxit = 10000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.ew.density_+3A_initial.values">initial.values</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_hessian.flag">hessian.flag</code></td>
<td>
<p>if F, no hessian is produced</p>
</td></tr>
<tr><td><code id="extract.ew.density_+3A_cl">cl</code></td>
<td>
<p>list of parameter values to be passed to the optimization function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>initial.values</code> are not specified then the function will attempt to pick them
automatically.  <code>cl</code> in form of a list can be used to pass parameters to the <code>optim</code>
function.</p>


<h3>Value</h3>

<table>
<tr><td><code>sigma</code></td>
<td>
<p>volatility of the underlying lognormal</p>
</td></tr>
<tr><td><code>skew</code></td>
<td>
<p>normalized skewness</p>
</td></tr>
<tr><td><code>kurt</code></td>
<td>
<p>normalized kurtosis</p>
</td></tr>
<tr><td><code>converge.result</code></td>
<td>
<p>Did the result converge?</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> Hessian matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>
<p>R. Jarrow and A. Rudd (1982)
Approximate valuation for arbitrary stochastic processes.
<em>Journal of Finanical Economics</em>, 10, 347-369
</p>
<p>C.J. Corrado and T. Su (1996)
S&amp;P 500 index option tests of Jarrow and Rudd's approximate option valuation formula.
<em>Journal of Futures Markets</em>, 6, 611-629
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
#  ln.skew &amp; ln.kurt are the normalized skewness and kurtosis of a true lognormal.
#

r       = 0.05
y       = 0.03
s0      = 1000
sigma   = 0.25
te      = 100/365
strikes = seq(from=600, to = 1400, by = 1)
v       = sqrt(exp(sigma^2 * te) - 1)
ln.skew = 3 * v + v^3
ln.kurt = 16 * v^2 + 15 * v^4 + 6 * v^6 + v^8

#
# Now "perturb" the lognormal
#

new.skew = ln.skew * 1.50
new.kurt = ln.kurt * 1.50

#
# new.skew &amp; new.kurt should not be extracted.
# Note that weights are automatically set to 1.
#

market.calls      =  price.ew.option(r = r, te = te, s0 = s0, k=strikes, sigma=sigma, 
                     y=y, skew = new.skew, kurt = new.kurt)$call
ew.extracted.obj  =  extract.ew.density(r = r, y = y, te = te, s0 = s0, 
                     market.calls = market.calls, call.strikes = strikes, 
                     lambda = 1, hessian.flag = FALSE)
ew.extracted.obj
</code></pre>

<hr>
<h2 id='extract.gb.density'>Generalized Beta Extraction</h2><span id='topic+extract.gb.density'></span>

<h3>Description</h3>

<p><code>extract.gb.density</code> extracts the generalized beta density from market options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.gb.density(initial.values = c(NA, NA, NA, NA), r, te, y, s0, market.calls, 
  call.strikes, call.weights = 1, market.puts, put.strikes, put.weights = 1, 
  lambda = 1, hessian.flag = F, cl = list(maxit = 10000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.gb.density_+3A_initial.values">initial.values</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_put.strikes">put.strikes</code></td>
<td>
<p>strikes for the puts (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for puts</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_hessian.flag">hessian.flag</code></td>
<td>
<p>if F, no hessian is produced</p>
</td></tr>
<tr><td><code id="extract.gb.density_+3A_cl">cl</code></td>
<td>
<p>list of parameter values to be passed to the optimization function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the generalized beta density implied by the options.
</p>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>extracted power parameter</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>extracted scale paramter</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>extracted first beta paramter</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>extracted second beta parameter</p>
</td></tr>
<tr><td><code>converge.result</code></td>
<td>
<p>Did the result converge?</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> Hessian matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>R.M. Bookstaber and J.B. McDonald (1987)
A general distribution for describing security price returns.
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>X. Liu and M.B. Shackleton and S.J. Taylor and X. Xu (2007)
Closed-form transformations from risk-neutral to real-world distributions
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# create some GB based calls and puts
#

r  = 0.03
te = 50/365
k  = seq(from = 800, to = 1200, by = 10)
a  = 10
b  = 1000
v  = 2.85
w  = 2.85
y  = 0.01
s0 = exp((y-r)*te) * b * beta(v + 1/a, w - 1/a)/beta(v,w) 
s0

call.strikes = seq(from = 800, to = 1200, by = 10)
market.calls = price.gb.option(r = r, te = te, y = y, s0 = s0, 
                               k = call.strikes, a = a, b = s0, v = v, w = w)$call

put.strikes  = seq(from = 805, to = 1200, by = 10)
market.puts  = price.gb.option(r = r, te = te, y = y, s0 = s0, 
                               k = put.strikes, a = a, b = s0, v = v, w = w)$put


#
# Extraction...should match the a,b,v,w above. You will also get warning messages.
# Weigths are automatically set to 1.
#

extract.gb.density(r=r, te=te, y = y, s0=s0, market.calls = market.calls, 
              call.strikes = call.strikes, market.puts = market.puts, 
              put.strikes = put.strikes, lambda = 1, hessian.flag = FALSE)

</code></pre>

<hr>
<h2 id='extract.mln.density'>Extract Mixture of Lognormal Densities</h2><span id='topic+extract.mln.density'></span>

<h3>Description</h3>

<p><code>mln.extraction</code> extracts the parameters of the mixture of two lognormals densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.mln.density(initial.values = c(NA, NA, NA, NA, NA), r, y, te, s0, 
  market.calls, call.strikes, call.weights = 1, market.puts, put.strikes, 
  put.weights = 1, lambda = 1, hessian.flag = F, cl = list(maxit = 10000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.mln.density_+3A_initial.values">initial.values</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_put.strikes">put.strikes</code></td>
<td>
<p>strikes for the puts (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for puts</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_hessian.flag">hessian.flag</code></td>
<td>
<p>if F, no hessian is produced</p>
</td></tr>
<tr><td><code id="extract.mln.density_+3A_cl">cl</code></td>
<td>
<p>list of parameter values to be passed to the optimization function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mln is the density f(x) = alpha.1 * g(x) + (1 - alpha.1) * h(x), where g and h are densities of two lognormals with
parameters (mean.log.1, sdlog.1) and (mean.log.2, sdlog.2) respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>alpha.1</code></td>
<td>
<p>extracted proportion of the first lognormal.  Second one is 1 - <code>alpha.1</code></p>
</td></tr>
<tr><td><code>meanlog.1</code></td>
<td>
<p>extracted mean of the log of the first lognormal</p>
</td></tr>
<tr><td><code>meanlog.2</code></td>
<td>
<p>extracted mean of the log of the second lognormal</p>
</td></tr>
<tr><td><code>sdlog.1</code></td>
<td>
<p>extracted standard deviation of the log of the first lognormal</p>
</td></tr>
<tr><td><code>sdlog.2</code></td>
<td>
<p>extracted standard deviation of the log of the second lognormal</p>
</td></tr>
<tr><td><code>converge.result</code></td>
<td>
<p>Did the result converge?</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> Hessian matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>F. Gianluca and A. Roncoroni (2008)
<em>Implementing Models in Quantitative Finance: Methods and Cases</em>
</p>
<p>B. Bahra (1996):
Probability distribution of future asset prices implied by option prices.
<em>Bank of England Quarterly Bulletin</em>, August 1996, 299-311
</p>
<p>P. Soderlind and L.E.O. Svensson (1997)
New techniques to extract market expectations from financial instruments.
<em>Journal of Monetary Economics</em>, 40, 383-4
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Create some calls and puts based on mln and 
# see if we can extract the correct values.
#


r         = 0.05
y         = 0.02
te        = 60/365
meanlog.1 = 6.8
meanlog.2 = 6.95
sdlog.1   = 0.065
sdlog.2   = 0.055
alpha.1   = 0.4


call.strikes = seq(from = 800, to = 1200, by = 10)
market.calls = price.mln.option(r = r, y = y, te = te, k = call.strikes, 
               alpha.1 = alpha.1, meanlog.1 = meanlog.1, meanlog.2 = meanlog.2, 
                                sdlog.1 = sdlog.1, sdlog.2 = sdlog.2)$call

s0 = price.mln.option(r = r, y = y, te = te, k = call.strikes, alpha.1 = alpha.1, 
                      meanlog.1 = meanlog.1, meanlog.2 = meanlog.2, 
                      sdlog.1 = sdlog.1, sdlog.2 = sdlog.2)$s0
s0
put.strikes  = seq(from = 805, to = 1200, by = 10)
market.puts  = price.mln.option(r = r, y = y, te = te, k = put.strikes, 
                                alpha.1 = alpha.1, meanlog.1 = meanlog.1, 
                                meanlog.2 = meanlog.2, sdlog.1 = sdlog.1, 
                                sdlog.2 = sdlog.2)$put

###
### The extracted values should be close to the actual values.
###

extract.mln.density(r = r, y = y, te = te, s0 = s0, market.calls = market.calls, 
               call.strikes = call.strikes, market.puts = market.puts, 
               put.strikes = put.strikes, lambda = 1, hessian.flag = FALSE)


</code></pre>

<hr>
<h2 id='extract.rates'>Extract Risk Free Rate and Dividend Yield</h2><span id='topic+extract.rates'></span>

<h3>Description</h3>

<p><code>extract.rates</code> extracts the risk free rate and the dividend yield from European options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.rates(calls, puts, s0, k, te)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.rates_+3A_calls">calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="extract.rates_+3A_puts">puts</code></td>
<td>
<p>market puts (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="extract.rates_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="extract.rates_+3A_k">k</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.rates_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extraction is based on the put-call parity of the European options.  Shimko (1993) 
- see below - shows that the slope and intercept of the regression of 
the calls minus puts onto the strikes contains the risk free and the dividend
rates.
</p>


<h3>Value</h3>

<table>
<tr><td><code>risk.free.rate</code></td>
<td>
<p>extracted risk free rate</p>
</td></tr>
<tr><td><code>dividend.yield</code></td>
<td>
<p>extracted dividend rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>D. Shimko (1993)
Bounds of probability.
<em>Risk</em>, 6, 33-47
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Create calls and puts based on BSM
#

r     = 0.05
te    = 60/365
s0    = 1000
k     = seq(from = 900, to = 1100, by = 25)
sigma = 0.25
y     = 0.01

bsm.obj = price.bsm.option(r =r, te = te, s0 = s0, k = k, sigma = sigma, y = y)

calls = bsm.obj$call
puts  = bsm.obj$put

#
# Extract rates should give the values of r and y above:
#

rates = extract.rates(calls = calls, puts = puts, k = k, s0 = s0, te = te)
rates

</code></pre>

<hr>
<h2 id='extract.shimko.density'>Extract Risk Neutral Density based on Shimko's Method</h2><span id='topic+extract.shimko.density'></span>

<h3>Description</h3>

<p><code>shimko.extraction</code> extracts the implied risk neutral density
based on modeling the volatility as a quadratic function of the strikes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.shimko.density(market.calls, call.strikes, r, y, te, s0, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.shimko.density_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="extract.shimko.density_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="extract.shimko.density_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="extract.shimko.density_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="extract.shimko.density_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="extract.shimko.density_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="extract.shimko.density_+3A_lower">lower</code></td>
<td>
<p>lower bound for the search of implied volatility</p>
</td></tr>
<tr><td><code id="extract.shimko.density_+3A_upper">upper</code></td>
<td>
<p>upper bound for the search of implied volatility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correct values for range of search must be specified.</p>


<h3>Value</h3>

<table>
<tr><td><code>implied.curve.obj</code></td>
<td>
<p>variable that holds a0, a1, and a2 which are the constant terms of the quadratic polynomial</p>
</td></tr>
<tr><td><code>shimko.density</code></td>
<td>
<p>density evaluated at the strikes</p>
</td></tr>
<tr><td><code>implied.volatilities</code></td>
<td>
<p>implied volatilities at each <code>call.strike</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>D. Shimko (1993)
Bounds of probability.
<em>Risk</em>, 6, 33-47
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
#  Test the function shimko.extraction.  If BSM holds then a1 = a2 = 0. 
#

r       =  0.05
y       =  0.02
te      =  60/365
s0      =  1000
k       =  seq(from = 800, to = 1200, by = 5)
sigma   =  0.25

bsm.calls = price.bsm.option(r = r, te = te, s0 = s0, k = k, 
                             sigma = sigma, y = y)$call
extract.shimko.density(market.calls = bsm.calls, call.strikes = k, r = r, y = y, te = te, 
                  s0 = s0, lower = -10, upper = 10)

#
# Note: a0 is about equal to sigma, and a1 and a2 are close to zero.
#

</code></pre>

<hr>
<h2 id='fit.implied.volatility.curve'>Fit Implied Quadratic Volatility Curve</h2><span id='topic+fit.implied.volatility.curve'></span>

<h3>Description</h3>

<p><code>fit.implied.volatility.curve</code> estimates the coefficients of the quadratic equation for the implied volatilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.implied.volatility.curve(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.implied.volatility.curve_+3A_x">x</code></td>
<td>
<p>a set of implied volatilities</p>
</td></tr>
<tr><td><code id="fit.implied.volatility.curve_+3A_k">k</code></td>
<td>
<p>range of strikes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates volatility <code class="reqn">\sigma</code> as a quadratic function of strike <code class="reqn">k</code> with 
the coefficents <code class="reqn">a_0, a_1, a_2</code>: <code class="reqn">\sigma(k) = a_0 + a_1 k + a_2 k^2</code>  </p>


<h3>Value</h3>

<table>
<tr><td><code>a0</code></td>
<td>
<p>constant term in the quadratic ploynomial</p>
</td></tr>
<tr><td><code>a1</code></td>
<td>
<p>coefficient term of k in the quadratic ploynomial</p>
</td></tr>
<tr><td><code>a2</code></td>
<td>
<p>coefficient term of k squared in the quadratic polynomial</p>
</td></tr>
<tr><td><code>summary.obj</code></td>
<td>
<p>statistical summary of the fit</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>D. Shimko (1993)
Bounds of probability.
<em>Risk</em>, 6, 33-47
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Suppose we see the following implied volatilities and strikes:
#

implied.sigma = c(0.11, 0.08, 0.065, 0.06, 0.05)  
strikes       = c(340, 360, 380, 400, 410)
tmp           = fit.implied.volatility.curve(x = implied.sigma, k = strikes)
tmp

strike.range = 340:410
plot(implied.sigma ~ strikes)
lines(strike.range, tmp$a0 + tmp$a1 * strike.range + tmp$a2 * strike.range^2)

</code></pre>

<hr>
<h2 id='gb.objective'>Generalized Beta Objective</h2><span id='topic+gb.objective'></span>

<h3>Description</h3>

<p><code>gb.objective</code> is the objective function to be minimized in <code>extract.gb.density</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gb.objective(theta, r, te, y, s0, market.calls, call.strikes, call.weights = 1, 
  market.puts, put.strikes, put.weights = 1, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gb.objective_+3A_theta">theta</code></td>
<td>
<p>initial values for optimization</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_put.strikes">put.strikes</code></td>
<td>
<p>strikes for the puts (smallest to largest)</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for puts</p>
</td></tr>
<tr><td><code id="gb.objective_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the function minimized by <code>extract.gb.desnity</code> function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>obj</code></td>
<td>
<p>value of the objective function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>R.M. Bookstaber and J.B. McDonald (1987)
A general distribution for describing security price returns.
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>X. Liu and M.B. Shackleton and S.J. Taylor and X. Xu (2007)
Closed-form transformations from risk-neutral to real-world distributions
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# The objective should be very small!
# Note the weights are automatically
# set to 1.
#

r  = 0.03
te = 50/365
k  = seq(from = 800, to = 1200, by = 10)
a  = 10
b  = 1000
v  = 2.85
w  = 2.85
y  = 0.01
s0 = exp((y-r)*te) * b * beta(v + 1/a, w - 1/a)/beta(v,w) 
s0

call.strikes = seq(from = 800, to = 1200, by = 10)
market.calls = price.gb.option(r = r, te = te, s0 = s0, y = y, 
                        k = call.strikes, a = a, b = b, v = v, w = w)$call

put.strikes = seq(from = 805, to = 1200, by = 10)
market.puts = price.gb.option(r = r, te = te, s0 = s0, y = y, 
                        k = put.strikes, a = a, b = b, v = v, w = w)$put

gb.objective(theta=c(a,b,v,w),r = r, te = te, y = y, s0 = s0, 
             market.calls = market.calls, call.strikes = call.strikes,  
             market.puts = market.puts, put.strikes = put.strikes, lambda = 1)


</code></pre>

<hr>
<h2 id='get.point.estimate'>Point Estimation of the Density</h2><span id='topic+get.point.estimate'></span>

<h3>Description</h3>

<p><code>get.point.estimate</code> estimates the risk neutral density by center differentiation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.point.estimate(market.calls, call.strikes, r, te)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.point.estimate_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="get.point.estimate_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="get.point.estimate_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="get.point.estimate_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a non-parametric estimate of the risk neutral density.  Due to center differentiation, 
the density values are not estimated at the highest and lowest strikes.</p>


<h3>Value</h3>

<table>
<tr><td><code>point.estimates</code></td>
<td>
<p>values of the estimated density at each strike</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>J. Hull (2011)
<em>Options, Futures, and Other Derivatives and DerivaGem Package</em>
Prentice Hall, Englewood Cliffs, New Jersey, 8th Edition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### Recover the lognormal density based on BSM
###

r     = 0.05
te    = 60/365
s0    = 1000
k     = seq(from = 500, to = 1500, by = 1)
sigma = 0.25
y     = 0.01


bsm.calls = price.bsm.option(r =r, te = te, s0 = s0, k = k, sigma = sigma, y = y)$call
density.est = get.point.estimate(market.calls = bsm.calls, 
              call.strikes = k, r = r , te = te)

len = length(k)-1
### Note, estimates at two data points (smallest and largest strikes) are lost
plot(density.est ~ k[2:len], type = "l")  

</code></pre>

<hr>
<h2 id='mln.am.objective'>Objective function for the Mixture of Lognormal of American Options</h2><span id='topic+mln.am.objective'></span>

<h3>Description</h3>

<p><code>mln.am.objective</code> is the objective function to be minimized in <code>extract.am.density</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mln.am.objective(theta, s0, r, te, market.calls, call.weights = NA, market.puts, 
  put.weights = NA, strikes, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mln.am.objective_+3A_theta">theta</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_strikes">strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="mln.am.objective_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mln is density f(x) = p.1 * f1(x) + p.2 * f2(x) + (1 - p.1 - p.2) * f3(x), where
f1, f2, and f3 are lognormal densities with log means u.1,u.2, and u.3 and
standard deviations sigma.1, sigma.2, and sigma.3 respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>obj</code></td>
<td>
<p>Value of the objective function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>Melick, W. R. and Thomas, C. P. (1997). Recovering an asset's implied pdf from option prices: An
application to crude oil during the gulf crisis. <em>Journal of Financial and Quantitative Analysis</em>,
32(1), 91-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r       = 0.01
te      = 60/365
w.1     = 0.4
w.2     = 0.25
u.1     = 4.2
u.2     = 4.5
u.3     = 4.8
sigma.1 = 0.30
sigma.2 = 0.20
sigma.3 = 0.15
p.1     = 0.25
p.2     = 0.45
theta   = c(w.1,w.2,u.1,u.2,u.3,sigma.1,sigma.2,sigma.3,p.1,p.2)

p.3 = 1 - p.1 - p.2
p.3
expected.f0   =  sum(c(p.1, p.2, p.3) * exp(c(u.1,u.2,u.3) + 
                    (c(sigma.1, sigma.2, sigma.3)^2)/2) )
expected.f0  
 
strikes = 30:170

market.calls = numeric(length(strikes))
market.puts  = numeric(length(strikes))

for (i in 1:length(strikes))
{

  if ( strikes[i] &lt; expected.f0) {
    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
  }  else {

    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
     }

}

###
### Quickly look at the option values...
###

par(mfrow=c(1,2))
plot(market.calls ~ strikes, type="l")
plot(market.puts  ~ strikes, type="l")
par(mfrow=c(1,1))

###
### ** IMPORTANT **:  The code that follows may take a few seconds.
###                   Copy and paste onto R console the commands
###                   that follow the greater sign &gt;.
###
###
### Next try the objective function.  It should be zero.
### Note: Let weights be the defaults values of 1.
###
#
# &gt; s0      = expected.f0 * exp(-r * te)
# &gt; s0
#
# &gt; mln.am.objective(theta, s0 =s0, r = r, te = te, market.calls = market.calls,  
#                 market.puts = market.puts, strikes = strikes, lambda = 1)
#
###
### Now directly try the optimization with perfect initial values.
###
#
#
# &gt; optim.obj.with.synthetic.data = optim(theta, mln.am.objective, s0 = s0, r=r, te=te, 
#                 market.calls = market.calls, market.puts = market.puts, strikes = strikes, 
#                 lambda = 1, hessian = FALSE , control=list(maxit=10000) )
#
# &gt; optim.obj.with.synthetic.data
#
# &gt; theta
#
###
### It does take a few seconds but the optim converges to exact theta values.
###
</code></pre>

<hr>
<h2 id='mln.objective'>Objective function for the Mixture of Lognormal</h2><span id='topic+mln.objective'></span>

<h3>Description</h3>

<p><code>mln.objective</code> is the objective function to be minimized in <code>extract.mln.density</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mln.objective(theta, r, y, te, s0, market.calls, call.strikes, call.weights, 
  market.puts, put.strikes, put.weights, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mln.objective_+3A_theta">theta</code></td>
<td>
<p>initial values for the optimization</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_call.weights">call.weights</code></td>
<td>
<p>weights to be used for calls</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_put.strikes">put.strikes</code></td>
<td>
<p>strikes for the puts (smallest to largest)</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_put.weights">put.weights</code></td>
<td>
<p>weights to be used for puts</p>
</td></tr>
<tr><td><code id="mln.objective_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mln is the density f(x) = alpha.1 * g(x) + (1 - alpha.1) * h(x), where g and h are densities of two lognormals with
parameters (mean.log.1, sdlog.1) and (mean.log.2, sdlog.2) respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>obj</code></td>
<td>
<p>value of the objective function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>F. Gianluca and A. Roncoroni (2008)
<em>Implementing Models in Quantitative Finance: Methods and Cases</em>
</p>
<p>B. Bahra (1996):
Probability distribution of future asset prices implied by option prices.
<em>Bank of England Quarterly Bulletin</em>, August 1996, 299-311
</p>
<p>P. Soderlind and L.E.O. Svensson (1997)
New techniques to extract market expectations from financial instruments.
<em>Journal of Monetary Economics</em>, 40, 383-429
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The mln objective function should be close to zero.
# The weights are automatically set to 1.
#

r  = 0.05
te = 60/365
y  = 0.02
   
meanlog.1 = 6.8
meanlog.2 = 6.95
sdlog.1   = 0.065
sdlog.2   = 0.055
alpha.1   = 0.4

# This is the current price implied by parameter values:
s0 = 981.8815 

call.strikes = seq(from = 800, to = 1200, by = 10)
market.calls = price.mln.option(r=r, y = y, te = te, k = call.strikes, 
               alpha.1 = alpha.1, meanlog.1 = meanlog.1, meanlog.2 = meanlog.2, 
               sdlog.1 = sdlog.1, sdlog.2 = sdlog.2)$call

put.strikes  = seq(from = 805, to = 1200, by = 10)
market.puts  = price.mln.option(r = r, y = y, te = te, k = put.strikes, 
               alpha.1 = alpha.1, meanlog.1 = meanlog.1, meanlog.2 = meanlog.2, 
               sdlog.1 = sdlog.1, sdlog.2 = sdlog.2)$put

mln.objective(theta=c(alpha.1,meanlog.1, meanlog.2 , sdlog.1, sdlog.2), 
               r = r, y = y, te = te, s0 = s0, 
               market.calls = market.calls, call.strikes = call.strikes, 
               market.puts = market.puts, put.strikes = put.strikes, lambda = 1)
</code></pre>

<hr>
<h2 id='MOE'>Mother of All Extractions</h2><span id='topic+MOE'></span>

<h3>Description</h3>

  <p><code>MOE</code> function extracts the risk neutral density based on all models and summarizes the results.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOE(market.calls, call.strikes, market.puts, put.strikes, call.weights = 1, 
  put.weights = 1, lambda = 1, s0, r, te, y, file.name = "myfile")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOE_+3A_market.calls">market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td></tr>
<tr><td><code id="MOE_+3A_call.strikes">call.strikes</code></td>
<td>
<p>strikes for the calls (smallest to largest)</p>
</td></tr>
<tr><td><code id="MOE_+3A_market.puts">market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td></tr>
<tr><td><code id="MOE_+3A_put.strikes">put.strikes</code></td>
<td>
<p>strikes for the puts (smallest to largest)</p>
</td></tr>
<tr><td><code id="MOE_+3A_call.weights">call.weights</code></td>
<td>
<p>Weights for the calls (must be in the same order of calls)</p>
</td></tr>
<tr><td><code id="MOE_+3A_put.weights">put.weights</code></td>
<td>
<p>Weights for the puts (must be in the same order of puts)</p>
</td></tr>
<tr><td><code id="MOE_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td></tr>
<tr><td><code id="MOE_+3A_s0">s0</code></td>
<td>
<p>Current asset value</p>
</td></tr>
<tr><td><code id="MOE_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="MOE_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="MOE_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="MOE_+3A_file.name">file.name</code></td>
<td>
<p>File names where analysis is to be saved.  SEE DETAILS!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MOE function in a few key strokes extracts the risk neutral density
via various methods and summarizes the results.
</p>
<p>This function should only be used for European options.
</p>
<p>NOTE:  Three files will be produced: 
filename will have the pdf version of the results.
file.namecalls.csv will have the predicted call values.
file.nameputs.csv will have the predicted put values.
</p>


<h3>Value</h3>

<table>
<tr><td><code>bsm.mu</code></td>
<td>
<p>mean of log(S(T)), when S(T) is lognormal</p>
</td></tr>
<tr><td><code>bsm.sigma</code></td>
<td>
<p>SD of log(S(T)), when S(T) is lognormal</p>
</td></tr>
<tr><td><code>gb.a</code></td>
<td>
<p>extracted power parameter, when S(T) is assumed to be a GB rv</p>
</td></tr>
<tr><td><code>gb.b</code></td>
<td>
<p>extracted scale paramter, when S(T) is assumed to be a GB rv</p>
</td></tr>
<tr><td><code>gb.v</code></td>
<td>
<p>extracted first beta paramter, when S(T) is assumed to be a GB rv</p>
</td></tr>
<tr><td><code>gb.w</code></td>
<td>
<p>extracted second beta parameter, when S(T) is assumed to be a GB rv</p>
</td></tr>
<tr><td><code>mln.alpha.1</code></td>
<td>
<p>extracted proportion of the first lognormal.  Second one is 1 - <code>alpha.1</code> in mixture of lognormals</p>
</td></tr>
<tr><td><code>mln.meanlog.1</code></td>
<td>
<p>extracted mean of the log of the first lognormal in mixture of lognormals</p>
</td></tr>
<tr><td><code>mln.meanlog.2</code></td>
<td>
<p>extracted mean of the log of the second lognormal in mixture of lognormals</p>
</td></tr>
<tr><td><code>mln.sdlog.1</code></td>
<td>
<p>extracted standard deviation of the log of the first lognormal in mixture of lognormals</p>
</td></tr>
<tr><td><code>mln.sdlog.2</code></td>
<td>
<p>extracted standard deviation of the log of the second lognormal in mixture of lognormals</p>
</td></tr>
<tr><td><code>ew.sigma</code></td>
<td>
<p>volatility when using the Edgeworth expansions</p>
</td></tr>
<tr><td><code>ew.skew</code></td>
<td>
<p>normalized skewness when using the Edgeworth expansions</p>
</td></tr>
<tr><td><code>ew.kurt</code></td>
<td>
<p>normalized kurtosis when using the Edgeworth expansions</p>
</td></tr>
<tr><td><code>a0</code></td>
<td>
<p>extracted constant term in the quadratic polynomial of Shimko method</p>
</td></tr>
<tr><td><code>a1</code></td>
<td>
<p>extracted coefficient term of k in the quadratic polynomial of Shimko method</p>
</td></tr>
<tr><td><code>a2</code></td>
<td>
<p>extracted coefficient term of k squared in the quadratic polynomial of Shimko method</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
### You should see that all methods extract the same density!
###

r     = 0.05
te    = 60/365
s0    = 1000
sigma = 0.25
y     = 0.02

strikes     = seq(from = 500, to = 1500, by = 5)
bsm.prices  = price.bsm.option(r =r, te = te, s0 = s0, 
              k = strikes, sigma = sigma, y = y)

calls   = bsm.prices$call
puts    = bsm.prices$put

###
### See where your results will go...
###

getwd()


###
###  Running this may take 1-2 minutes...
###
### MOE(market.calls = calls, call.strikes = strikes, market.puts = puts, 
###    put.strikes = strikes, call.weights = 1, put.weights = 1, 
###    lambda = 1, s0 = s0, r = r, te = te, y = y, file.name = "myfile")
###
### You may get some warning messages.  This happens because the
###    automatic initial value selection sometimes picks values
###    that produce NaNs in the generalized beta density estimation.
###    These messages are often inconsequential.
###
</code></pre>

<hr>
<h2 id='oil.2012.10.01'>
West Texas Intermediate Crude Oil Options on 2013-10-01
</h2><span id='topic+oil.2012.10.01'></span>

<h3>Description</h3>

<p>This dataset contains West Texas Intermediate (WTI) crude oil options with 43 days to expiration at the end of 
the business day October 1, 2012.  On October 1, 2012, WTI closed at 92.44.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oil.2012.10.01)</code></pre>


<h3>Format</h3>

<p>A data frame with 332 observations on the following 7 variables.
</p>

<dl>
<dt><code>type</code></dt><dd><p>a factor with levels <code>C</code> for call option <code>P</code> for put option</p>
</dd>
<dt><code>strike</code></dt><dd><p>option strike</p>
</dd>
<dt><code>settlement</code></dt><dd><p>option settlement price</p>
</dd>
<dt><code>openint</code></dt><dd><p>option open interest</p>
</dd>
<dt><code>volume</code></dt><dd><p>trading volume</p>
</dd>
<dt><code>delta</code></dt><dd><p>option delta</p>
</dd>
<dt><code>impliedvolatility</code></dt><dd><p>option implied volatility</p>
</dd>
</dl>



<h3>Source</h3>

<p>CME posts sample data at:
http://www.cmegroup.com/market-data/datamine-historical-data/endofday.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oil.2012.10.01)
</code></pre>

<hr>
<h2 id='pgb'>CDF of Generalized Beta</h2><span id='topic+pgb'></span>

<h3>Description</h3>

<p><code>pgb</code> is the cumulative distribution function (CDF) of a genaralized beta random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgb(x, a, b, v, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgb_+3A_x">x</code></td>
<td>
<p>value at which the CDF is to be evaluated</p>
</td></tr>
<tr><td><code id="pgb_+3A_a">a</code></td>
<td>
<p>power parameter &gt; 0</p>
</td></tr>
<tr><td><code id="pgb_+3A_b">b</code></td>
<td>
<p>scale paramter &gt; 0</p>
</td></tr>
<tr><td><code id="pgb_+3A_v">v</code></td>
<td>
<p>first beta paramter &gt; 0</p>
</td></tr>
<tr><td><code id="pgb_+3A_w">w</code></td>
<td>
<p>second beta parameter &gt; 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let B be a beta random variable with parameters v and w.  Then Z = b *(B/(1-B))^(1/a) is a generalized
beta random variable with parameters (a,b,v,w).
</p>


<h3>Value</h3>

<table>
<tr><td><code>out</code></td>
<td>
<p>CDF value at x</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>R.M. Bookstaber and J.B. McDonald (1987)
A general distribution for describing security price returns.
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>X. Liu and M.B. Shackleton and S.J. Taylor and X. Xu (2007)
Closed-form transformations from risk-neutral to real-world distributions
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# What does the cdf of a GB look like?
#

a  = 1
b  = 10
v  = 2
w  = 2

x = seq(from = 0, to = 500, by = 0.01)
y = pgb(x = x, a = a, b = b, v = v, w = w)
plot(y ~ x, type = "l")
abline(h=c(0,1), lty=2) 

</code></pre>

<hr>
<h2 id='price.am.option'>Price American Options on Mixtures of Lognormals</h2><span id='topic+price.am.option'></span>

<h3>Description</h3>

  <p><code>price.am.option</code> gives the price of a call and a put option 
at a set strike when the risk neutral density is a mixture of three lognormals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price.am.option(k, r, te, w, u.1, u.2, u.3, sigma.1, sigma.2, sigma.3, p.1, p.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price.am.option_+3A_k">k</code></td>
<td>
<p>Strike</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_w">w</code></td>
<td>
<p>Weight, a number between 0 and 1, to weigh the option price bounds</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_u.1">u.1</code></td>
<td>
<p>log mean of the first lognormal</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_u.2">u.2</code></td>
<td>
<p>log mean of the second lognoral</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_u.3">u.3</code></td>
<td>
<p>log mean of the second lognoral</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_sigma.1">sigma.1</code></td>
<td>
<p>log sd of the first lognormal</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_sigma.2">sigma.2</code></td>
<td>
<p>log mean of the second lognormal</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_sigma.3">sigma.3</code></td>
<td>
<p>log mean of the third lognormal</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_p.1">p.1</code></td>
<td>
<p>weight assigned to the first density</p>
</td></tr>
<tr><td><code id="price.am.option_+3A_p.2">p.2</code></td>
<td>
<p>weight assigned to the second density</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mln is density f(x) = p.1 * f1(x) + p.2 * f2(x) + (1 - p.1 - p.2) * f3(x), where
f1, f2, and f3 are lognormal densities with log means u.1,u.2, and u.3 and
standard deviations sigma.1, sigma.2, and sigma.3 respectively.
</p>
<p>Note: Different weight values, w, need to be assigned to whether the call or put
is in the money or not.  See equations (7) &amp; (8) of Melick and Thomas paper below.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call.value</code></td>
<td>
<p>American call value</p>
</td></tr>
<tr><td><code>put.value</code></td>
<td>
<p>American put value</p>
</td></tr>
<tr><td><code>expected.f0</code></td>
<td>
<p>Expected mean value of asset at expiration</p>
</td></tr>
<tr><td><code>prob.f0.gr.k</code></td>
<td>
<p>Probability asset values is greater than strike</p>
</td></tr>
<tr><td><code>prob.f0.ls.k</code></td>
<td>
<p>Probability asset value is less than strike</p>
</td></tr>
<tr><td><code>expected.f0.f0.gr.k</code></td>
<td>
<p>Expected value of asset given asset exceeds strike</p>
</td></tr>
<tr><td><code>expected.f0.f0.ls.k</code></td>
<td>
<p>Expected value of asset given asset is less than strike</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>Melick, W. R. and Thomas, C. P. (1997). Recovering an asset's implied pdf from option prices: An
application to crude oil during the gulf crisis. <em>Journal of Financial and Quantitative Analysis</em>,
32(1), 91-115.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###
###  Set a few parameters and create some
###  American options.  
###

r       = 0.01
te      = 60/365
w.1     = 0.4
w.2     = 0.25
u.1     = 4.2
u.2     = 4.5
u.3     = 4.8
sigma.1 = 0.30
sigma.2 = 0.20
sigma.3 = 0.15
p.1     = 0.25
p.2     = 0.45
theta   = c(w.1,w.2,u.1,u.2,u.3,sigma.1,sigma.2,sigma.3,p.1,p.2)

p.3 = 1 - p.1 - p.2
p.3
expected.f0   =  sum(c(p.1, p.2, p.3) * exp(c(u.1,u.2,u.3) + 
                    (c(sigma.1, sigma.2, sigma.3)^2)/2) )
expected.f0  
 
strikes = 30:170

market.calls = numeric(length(strikes))
market.puts  = numeric(length(strikes))

for (i in 1:length(strikes))
{

  if ( strikes[i] &lt; expected.f0) {
    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
  }  else {

    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
     }

}

###
### Quickly look at the option values...
###

par(mfrow=c(1,2))
plot(market.calls ~ strikes, type="l")
plot(market.puts  ~ strikes, type="l")
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='price.bsm.option'>Price BSM Option</h2><span id='topic+price.bsm.option'></span>

<h3>Description</h3>

<p><code>bsm.option.price</code> computes the BSM European option prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price.bsm.option(s0, k, r, te, sigma, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price.bsm.option_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="price.bsm.option_+3A_k">k</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code id="price.bsm.option_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="price.bsm.option_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="price.bsm.option_+3A_sigma">sigma</code></td>
<td>
<p>volatility</p>
</td></tr>
<tr><td><code id="price.bsm.option_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the classic Black-Scholes-Merton option pricing model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>d1</code></td>
<td>
<p>value of <code>(log(s0/k) + (r - y + (sigma^2)/2) * te)/(sigma * sqrt(te))</code></p>
</td></tr>
<tr><td><code>d2</code></td>
<td>
<p>value of <code>d1 - sigma * sqrt(te)</code></p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call price</p>
</td></tr>
<tr><td><code>put</code></td>
<td>
<p>put price</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>
<p>J. Hull (2011)
<em>Options, Futures, and Other Derivatives and DerivaGem Package</em>
Prentice Hall, Englewood Cliffs, New Jersey, 8th Edition
</p>
<p>R. L. McDonald (2013)
<em>Derivatives Markets</em>
Pearson, Upper Saddle River, New Jersey, 3rd Edition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# call should be 4.76, put should be 0.81, from Hull 8th, page 315, 316
#

r     = 0.10
te    = 0.50
s0    = 42
k     = 40
sigma = 0.20
y     = 0

bsm.option = price.bsm.option(r =r, te = te, s0 = s0, k = k, sigma = sigma, y = y)
bsm.option

#
# Make sure put-call parity holds, Hull 8th, page 351
#

(bsm.option$call - bsm.option$put) - (s0 * exp(-y*te) - k * exp(-r*te))

</code></pre>

<hr>
<h2 id='price.ew.option'>Price Options with Edgeworth Approximated Density</h2><span id='topic+price.ew.option'></span>

<h3>Description</h3>

<p><code>price.ew.option</code> computes the option prices based on Edgeworth approximated densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price.ew.option(r, te, s0, k, sigma, y, skew, kurt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price.ew.option_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="price.ew.option_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="price.ew.option_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="price.ew.option_+3A_k">k</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code id="price.ew.option_+3A_sigma">sigma</code></td>
<td>
<p>volatility</p>
</td></tr>
<tr><td><code id="price.ew.option_+3A_y">y</code></td>
<td>
<p>dividend rate</p>
</td></tr>
<tr><td><code id="price.ew.option_+3A_skew">skew</code></td>
<td>
<p>normalized skewness</p>
</td></tr>
<tr><td><code id="price.ew.option_+3A_kurt">kurt</code></td>
<td>
<p>normalized kurtosis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function may produce negative prices if <code>skew</code> and <code>kurt</code> are
not well estimated from the data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>Edgeworth based call</p>
</td></tr>
<tr><td><code>put</code></td>
<td>
<p>Edgeworth based put</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>
<p>R. Jarrow and A. Rudd (1982)
Approximate valuation for arbitrary stochastic processes.
<em>Journal of Finanical Economics</em>, 10, 347-369
</p>
<p>C.J. Corrado and T. Su (1996)
S&amp;P 500 index option tests of Jarrow and Rudd's approximate option valuation formula.
<em>Journal of Futures Markets</em>, 6, 611-629
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Here, the prices must match EXACTLY the BSM prices:
#

r       = 0.05
y       = 0.03
s0      = 1000
sigma   = 0.25
te      = 100/365
k       = seq(from=800, to = 1200, by = 50)
v       = sqrt(exp(sigma^2 * te) - 1)
ln.skew = 3 * v + v^3
ln.kurt = 16 * v^2 + 15 * v^4 + 6 * v^6 + v^8

ew.option.prices  =  price.ew.option(r = r, te = te, s0 = s0, k=k, sigma=sigma, 
                                     y=y, skew = ln.skew, kurt = ln.kurt)
bsm.option.prices =  price.bsm.option(r = r, te = te, s0 = s0, k=k, sigma=sigma, y=y)

ew.option.prices
bsm.option.prices

###
### Now ew prices should be different as we increase the skewness and kurtosis:
###

new.skew = ln.skew * 1.10
new.kurt = ln.kurt * 1.10

new.ew.option.prices  =  price.ew.option(r = r, te = te, s0 = s0, k=k, sigma=sigma, 
                                         y=y, skew = new.skew, kurt = new.kurt)
new.ew.option.prices
bsm.option.prices

</code></pre>

<hr>
<h2 id='price.gb.option'>Generalized Beta Option Pricing</h2><span id='topic+price.gb.option'></span>

<h3>Description</h3>

<p><code>price.gb.option</code> computes the price of options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price.gb.option(r, te, s0, k, y, a, b, v, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price.gb.option_+3A_r">r</code></td>
<td>
<p>risk free interest rate</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_k">k</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_a">a</code></td>
<td>
<p>power parameter &gt; 0</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_b">b</code></td>
<td>
<p>scale paramter &gt; 0</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_v">v</code></td>
<td>
<p>first beta paramter &gt; 0</p>
</td></tr>
<tr><td><code id="price.gb.option_+3A_w">w</code></td>
<td>
<p>second beta parameter &gt; 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to compute European option prices when the underlying 
has a generalized beta (GB) distribution.    Let B be a beta random variable with parameters v and w.  
Then Z = b *(B/(1-B))^(1/a) is a generalized beta random variable with parameters with (a,b,v,w).
</p>


<h3>Value</h3>

<table>
<tr><td><code>prob.1</code></td>
<td>
<p>Probability that a GB random variable with parameters (a,b,v+1/a,w-1/a) will be above the strike</p>
</td></tr>
<tr><td><code>prob.2</code></td>
<td>
<p>Probability that a GB random variable with parameters (a,b,v,w) will be above the strike</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call price</p>
</td></tr>
<tr><td><code>put</code></td>
<td>
<p>put price</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>R.M. Bookstaber and J.B. McDonald (1987)
A general distribution for describing security price returns.
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>X. Liu and M.B. Shackleton and S.J. Taylor and X. Xu (2007)
Closed-form transformations from risk-neutral to real-world distributions
<em>Journal of Business</em>, 60, 401-424 
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em>
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# A basic GB option pricing....
#

r  = 0.03
te = 50/365
s0 = 1000.086
k  = seq(from = 800, to = 1200, by = 10)
y  = 0.01
a  = 10
b  = 1000
v  = 2.85
w  = 2.85

price.gb.option(r = r, te = te, s0 = s0, k = k, y = y, a = a, b = b, v = v, w = w)

</code></pre>

<hr>
<h2 id='price.mln.option'>Price Options on Mixture of Lognormals</h2><span id='topic+price.mln.option'></span>

<h3>Description</h3>

<p><code>mln.option.price</code> gives the price of a call and a put option at a strike when the risk neutral density is a mixture of two lognormals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price.mln.option(r, te, y, k, alpha.1, meanlog.1, meanlog.2, sdlog.1, sdlog.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price.mln.option_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_k">k</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_alpha.1">alpha.1</code></td>
<td>
<p>proportion of the first lognormal.  Second one is 1 - <code>alpha.1</code></p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_meanlog.1">meanlog.1</code></td>
<td>
<p>mean of the log of the first lognormal</p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_meanlog.2">meanlog.2</code></td>
<td>
<p>mean of the log of the second lognormal</p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_sdlog.1">sdlog.1</code></td>
<td>
<p>standard deviation of the log of the first lognormal</p>
</td></tr>
<tr><td><code id="price.mln.option_+3A_sdlog.2">sdlog.2</code></td>
<td>
<p>standard deviation of the log of the second lognormal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mln is the density f(x) = alpha.1 * g(x) + (1 - alpha.1) * h(x), where g and h are densities of two lognormals with
parameters (mean.log.1, sdlog.1) and (mean.log.2, sdlog.2) respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>call price</p>
</td></tr>
<tr><td><code>put</code></td>
<td>
<p>put price</p>
</td></tr>
<tr><td><code>s0</code></td>
<td>
<p>current value of the asset as implied by the mixture distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>F. Gianluca and A. Roncoroni (2008)
<em>Implementing Models in Quantitative Finance: Methods and Cases</em>
</p>
<p>B. Bahra (1996):
Probability distribution of future asset prices implied by option prices.
<em>Bank of England Quarterly Bulletin</em>, August 1996, 299-311
</p>
<p>P. Soderlind and L.E.O. Svensson (1997)
New techniques to extract market expectations from financial instruments.
<em>Journal of Monetary Economics</em>, 40, 383-429
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em>
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Try out a range of options
#

r  = 0.05
te = 60/365
k  = 700:1300
y  = 0.02
meanlog.1 = 6.80
meanlog.2 = 6.95
sdlog.1   = 0.065
sdlog.2   = 0.055
alpha.1   = 0.4


mln.prices = price.mln.option(r = r, y = y, te = te, k = k, alpha.1 = alpha.1, 
  meanlog.1 = meanlog.1, meanlog.2 = meanlog.2, sdlog.1 = sdlog.1, sdlog.2 = sdlog.2)

par(mfrow=c(1,2))
plot(mln.prices$call ~ k)
plot(mln.prices$put  ~ k)
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='price.shimko.option'>Price Option based on Shimko's Method</h2><span id='topic+price.shimko.option'></span>

<h3>Description</h3>

<p><code>price.shimko.option</code> prices a European option based on the extracted Shimko volatility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price.shimko.option(r, te, s0, k, y, a0, a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price.shimko.option_+3A_r">r</code></td>
<td>
<p>risk free rate</p>
</td></tr>
<tr><td><code id="price.shimko.option_+3A_te">te</code></td>
<td>
<p>time to expiration</p>
</td></tr>
<tr><td><code id="price.shimko.option_+3A_s0">s0</code></td>
<td>
<p>current asset value</p>
</td></tr>
<tr><td><code id="price.shimko.option_+3A_k">k</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code id="price.shimko.option_+3A_y">y</code></td>
<td>
<p>dividend yield</p>
</td></tr>
<tr><td><code id="price.shimko.option_+3A_a0">a0</code></td>
<td>
<p>constant term in the quadratic polyynomial</p>
</td></tr>
<tr><td><code id="price.shimko.option_+3A_a1">a1</code></td>
<td>
<p>coefficient term of k in the quadratic polynomial</p>
</td></tr>
<tr><td><code id="price.shimko.option_+3A_a2">a2</code></td>
<td>
<p>coefficient term of k squared in the quadratic polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may produce negative option values when nonsensical
values are used for a0, a1, and a2.</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>call price</p>
</td></tr>
<tr><td><code>put</code></td>
<td>
<p>put price</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>D. Shimko (1993)
Bounds of probability.
<em>Risk</em>, 6, 33-47
</p>
<p>E. Jondeau and S. Poon and M. Rockinger (2007):
<em>Financial Modeling Under Non-Gaussian Distributions</em> 
Springer-Verlag, London
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r       =  0.05
y       =  0.02
te      =  60/365
s0      =  1000
k       =  950
sigma   =  0.25
a0      =  0.30
a1      =  -0.00387
a2      =  0.00000445

#
#  Note how Shimko price is the same when a0 = sigma, a1=a2=0 but substantially 
#  more when a0, a1, a2 are changed so the implied volatilies are very high!
#

price.bsm.option(r = r, te = te, s0 = s0, k = k, sigma = sigma, y = y)$call
price.shimko.option(r = r, te = te, s0 = s0, k = k, y = y, 
                    a0 = sigma, a1 = 0, a2 = 0)$call
price.shimko.option(r = r, te = te, s0 = s0, k = k, y = y, 
                    a0 = a0, a1 = a1, a2 = a2)$call
</code></pre>

<hr>
<h2 id='sp500.2013.04.19'>
S&amp;P 500 Index Options on 2013-04-19
</h2><span id='topic+sp500.2013.04.19'></span>

<h3>Description</h3>

<p>This dataset contains S&amp;P 500 options with 62 days to expiration at the end of the business day April 19, 2013.  
On April 19, 2013, S&amp;P 500 closed at 1555.25.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sp500.2013.04.19)</code></pre>


<h3>Format</h3>

<p>A data frame with 171 observations on the following 19 variables.
</p>

<dl>
<dt><code>bidsize.c</code></dt><dd><p>call bid size</p>
</dd>
<dt><code>bid.c</code></dt><dd><p>call bid price</p>
</dd>
<dt><code>ask.c</code></dt><dd><p>call ask price</p>
</dd>
<dt><code>asksize.c</code></dt><dd><p>call ask size</p>
</dd>
<dt><code>chg.c</code></dt><dd><p>change in call price</p>
</dd>
<dt><code>impvol.c</code></dt><dd><p>call implied volatility</p>
</dd>
<dt><code>vol.c</code></dt><dd><p>call volume</p>
</dd>
<dt><code>openint.c</code></dt><dd><p>call open interest</p>
</dd>
<dt><code>delta.c</code></dt><dd><p>call delta</p>
</dd>
<dt><code>strike</code></dt><dd><p>option strike</p>
</dd>
<dt><code>bidsize.p</code></dt><dd><p>put bid size</p>
</dd>
<dt><code>bid.p</code></dt><dd><p>put bid price</p>
</dd>
<dt><code>ask.p</code></dt><dd><p>put ask price</p>
</dd>
<dt><code>asksize.p</code></dt><dd><p>put ask size</p>
</dd>
<dt><code>chg.p</code></dt><dd><p>change in put price</p>
</dd>
<dt><code>impvol.p</code></dt><dd><p>put implied volatility</p>
</dd>
<dt><code>vol.p</code></dt><dd><p>put volume</p>
</dd>
<dt><code>openint.p</code></dt><dd><p>put open interest</p>
</dd>
<dt><code>delta.p</code></dt><dd><p>put delta</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.cboe.com/DelayedQuote/QuoteTableDownload.aspx
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sp500.2013.04.19)
</code></pre>

<hr>
<h2 id='sp500.2013.06.24'>
S&amp;P 500 Index Options on 2013-06-24
</h2><span id='topic+sp500.2013.06.24'></span>

<h3>Description</h3>

<p>This dataset contains S&amp;P 500 options with 53 days to expiration at the end of the business day June 24, 2013.
On June 24, 2013, S&amp;P 500 closed at 1573.09.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sp500.2013.06.24)</code></pre>


<h3>Format</h3>

<p>A data frame with 173 observations on the following 9 variables.
</p>

<dl>
<dt><code>bid.c</code></dt><dd><p>call bid price</p>
</dd>
<dt><code>ask.c</code></dt><dd><p>call ask price</p>
</dd>
<dt><code>vol.c</code></dt><dd><p>call volume</p>
</dd>
<dt><code>openint.c</code></dt><dd><p>call open interest</p>
</dd>
<dt><code>strike</code></dt><dd><p>option strike</p>
</dd>
<dt><code>bid.p</code></dt><dd><p>put bid price</p>
</dd>
<dt><code>ask.p</code></dt><dd><p>put ask price</p>
</dd>
<dt><code>vol.p</code></dt><dd><p>put volume</p>
</dd>
<dt><code>openint.p</code></dt><dd><p>put open interest</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.cboe.com/DelayedQuote/QuoteTableDownload.aspx
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sp500.2013.06.24)
</code></pre>

<hr>
<h2 id='vix.2013.06.25'>
VIX Options on 2013-06-25
</h2><span id='topic+vix.2013.06.25'></span>

<h3>Description</h3>

<p>This dataset contains VIX options with 57 days to expiration at the end of the business day June 25, 2013.
On June 25, 2013, VIX closed at 18.21.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vix.2013.06.25)</code></pre>


<h3>Format</h3>

<p>A data frame with 35 observations on the following 13 variables.
</p>

<dl>
<dt><code>last.c</code></dt><dd><p>closing call price</p>
</dd>
<dt><code>change.c</code></dt><dd><p>change in call price from previous day</p>
</dd>
<dt><code>bid.c</code></dt><dd><p>call bid price</p>
</dd>
<dt><code>ask.c</code></dt><dd><p>call ask price</p>
</dd>
<dt><code>vol.c</code></dt><dd><p>call volume</p>
</dd>
<dt><code>openint.c</code></dt><dd><p>call open interest</p>
</dd>
<dt><code>strike</code></dt><dd><p>option strike</p>
</dd>
<dt><code>last.p</code></dt><dd><p>closing put price</p>
</dd>
<dt><code>change.p</code></dt><dd><p>change in put price from previous day</p>
</dd>
<dt><code>bid.p</code></dt><dd><p>put bid price</p>
</dd>
<dt><code>ask.p</code></dt><dd><p>put ask price</p>
</dd>
<dt><code>vol.p</code></dt><dd><p>put volume</p>
</dd>
<dt><code>openint.p</code></dt><dd><p>put open interest</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.cboe.com/DelayedQuote/QuoteTableDownload.aspx
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vix.2013.06.25)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
