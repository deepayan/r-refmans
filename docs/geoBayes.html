<!DOCTYPE html><html><head><title>Help for package geoBayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geoBayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geoBayes'><p>The <code>geoBayes</code> package</p></a></li>
<li><a href='#alik_cutoff'><p>Approximate log-likelihood calculation</p></a></li>
<li><a href='#alik_inla'><p>Log-likelihood approximation</p></a></li>
<li><a href='#alik_optim'><p>Log-likelihood maximisation</p></a></li>
<li><a href='#bf1skel'><p>Computation of Bayes factors at the skeleton points</p></a></li>
<li><a href='#bf2new'><p>Compute the Bayes factors at new points</p></a></li>
<li><a href='#bf2optim'><p>Empirical Bayes estimator</p></a></li>
<li><a href='#bf2se'><p>Empirical Bayes standard errors</p></a></li>
<li><a href='#bmbfse'><p>Batch means, Bayes factors standard errors</p></a></li>
<li><a href='#geoBayes_correlation'><p>Spatial correlation used in the geoBayes package</p></a></li>
<li><a href='#geoBayes_models'><p>Models used in the geoBayes package</p></a></li>
<li><a href='#linkfcn'><p>Calculate the link function for exponential families</p></a></li>
<li><a href='#mcmcmake'><p>Convert to an <code>mcmc</code> object</p></a></li>
<li><a href='#mcsglmm'><p>MCMC samples from the Spatial GLMM</p></a></li>
<li><a href='#mcsglmm_mala'><p>MCMC samples from the Spatial GLMM</p></a></li>
<li><a href='#mcstrga'><p>MCMC samples from the transformed Gaussian model</p></a></li>
<li><a href='#mcstrga_mala'><p>MCMC samples from the transformed Gaussian model</p></a></li>
<li><a href='#mkpredgrid2d'><p>Make prediction grid</p></a></li>
<li><a href='#plotbf2'><p>Plot the estimated Bayes factors</p></a></li>
<li><a href='#revlogreg'><p>Reverse logistic regression estimation</p></a></li>
<li><a href='#rhizoctonia'><p>Rhizoctonia root rot infections</p></a></li>
<li><a href='#rsglmm'><p>Simulation from a spatial model</p></a></li>
<li><a href='#select_proposals'><p>Selection of multiple importance sampling distributions</p></a></li>
<li><a href='#spcovariance'><p>Spatial variance-covariance matrix</p></a></li>
<li><a href='#sploglik'><p>Spatial log likelihood</p></a></li>
<li><a href='#sploglik_cross'><p>Spatial log likelihood</p></a></li>
<li><a href='#stackdata'><p>Combine <code>data.frame</code>s</p></a></li>
<li><a href='#subset.geomcmc'><p>Subset MCMC chain</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Geostatistical Data using Bayes and Empirical Bayes
Methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to fit geostatistical data. The data can be
        continuous, binary or count data and the models implemented are
        flexible. Conjugate priors are assumed on some parameters while
        inference on the other parameters can be done through a full
        Bayesian analysis of by empirical Bayes methods.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Evangelos Evangelou &lt;e.evangelou@maths.bath.ac.uk&gt;, Vivekananda
        Roy &lt;vroy@iastate.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evangelos Evangelou &lt;e.evangelou@maths.bath.ac.uk&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, graphics, sp, stats, optimx</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Classification/ACM:</td>
<td>86A32, 62M30, 62F15</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 07:47:35 UTC; ee224</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 08:12:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='geoBayes'>The <code>geoBayes</code> package</h2><span id='topic+geoBayes'></span><span id='topic+geoBayes-package'></span>

<h3>Description</h3>

<p>Analysis of geostatistical data using Bayes and Empirical Bayes
methods.
</p>


<h3>Details</h3>

<p>This package provides functions to fit geostatistical data. The
data can be continuous, binary or count data and the models
implemented are flexible. Conjugate priors are assumed on some
parameters while inference on the other parameters can be done
through a full Bayesian analysis of by empirical Bayes methods.
</p>
<p>Some demonstration examples are provided. Type <code>demo(package
= "geoBayes")</code> to examine them.
</p>


<h3>Author(s)</h3>

<p>Evangelos Evangelou &lt;e.evangelou@maths.bath.ac.uk&gt; and
Vivekananda Roy &lt;vroy@iastate.edu&gt;
</p>


<h3>References</h3>

<p>Roy, V., Evangelou, E. and Zhu, Z. (2014). Empirical
Bayes methods for the transformed Gaussian random fields model
with additive measurement errors. In Upadhyay, S. K., Singh, U.,
Dey, D. K., and Loganathan, A., editors, <em>Current Trends in
Bayesian Methodology with Applications</em>, Boca Raton, FL, USA, CRC
Press.
</p>
<p>Roy, V., Evangelou, E., and Zhu, Z. (2015). Efficient estimation
and prediction for the Bayesian spatial generalized linear mixed
model with flexible link functions. <em>Biometrics</em>, 72(1),
289-298.
</p>
<p>Evangelou, E., &amp; Roy, V. (2019). Estimation and prediction for
spatial generalized linear mixed models with parametric links
via reparameterized importance sampling. <em>Spatial Statistics</em>, 29,
289-315.
</p>
<p>Roy, V., &amp; Evangelou, E. (2022). Selection of proposal
distributions for multiple importance sampling.
<em>Statistica Sinica</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo(package = "geoBayes")
demo(rhizoctonia1, package = "geoBayes")
demo(rhizoctonia1, package = "geoBayes")

## End(Not run)
</code></pre>

<hr>
<h2 id='alik_cutoff'>Approximate log-likelihood calculation</h2><span id='topic+alik_cutoff'></span><span id='topic+alik_plot'></span>

<h3>Description</h3>

<p>Calculate the likelihood approximation at different parameter
values. This function is useful for choosing the skeleton set.
</p>
<p>Plot likelihood approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alik_cutoff(likopt, par_vals, likthreshold)

alik_plot(alikobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alik_cutoff_+3A_likopt">likopt</code></td>
<td>
<p>Output from the function <code><a href="#topic+alik_optim">alik_optim</a></code>.</p>
</td></tr>
<tr><td><code id="alik_cutoff_+3A_par_vals">par_vals</code></td>
<td>
<p>A named list with some of the components &quot;linkp&quot;,
&quot;phi&quot;, &quot;omg&quot;, &quot;kappa&quot;.</p>
</td></tr>
<tr><td><code id="alik_cutoff_+3A_likthreshold">likthreshold</code></td>
<td>
<p>A threshold value proportion to calculate the
cutoff. The cutoff will be calculated as that proportion
relative to the maximum value of the log-likelihood.</p>
</td></tr>
<tr><td><code id="alik_cutoff_+3A_alikobj">alikobj</code></td>
<td>
<p>Output from <code><a href="#topic+alik_cutoff">alik_cutoff</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>par_vals</code> is meant to contain vector of parameter
values for each parameter. For each element in <code>par_vals</code>,
the other parameters are set equal to the maximisers given in
<code>likopt</code> and the approximate likelihood is computed. The
cuttoff is calculated using linear interpolation provided by
<code><a href="stats.html#topic+approx">approx</a></code>.
</p>
<p>The plot can be used to visualise the Laplace approximation to the
likelihood provided by the function <code><a href="#topic+alik_cutoff">alik_cutoff</a></code>.
</p>


<h3>Value</h3>

<p>A list with the log-likelihood approximation and cutoff values.
</p>
<p>Draws a plot.
</p>


<h3>References</h3>

<p>Evangelou, E., &amp; Roy, V. (2019). Estimation and prediction for
spatial generalized linear mixed models with parametric links
via reparameterized importance sampling. Spatial Statistics, 29,
289-315.
</p>

<hr>
<h2 id='alik_inla'>Log-likelihood approximation</h2><span id='topic+alik_inla'></span>

<h3>Description</h3>

<p>Log-likelihood approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alik_inla(
  par_vals,
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  np,
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  tsqdf,
  tsqsc,
  dispersion = 1,
  longlat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alik_inla_+3A_par_vals">par_vals</code></td>
<td>
<p>A data frame with the components &quot;linkp&quot;, &quot;phi&quot;,
&quot;omg&quot;, &quot;kappa&quot;. The approximation will be computed at each row
of the data frame.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_family">family</code></td>
<td>
<p>The distribution of the response. Can be one of the
options in <code><a href="#topic+.geoBayes_models">.geoBayes_models</a></code> or
<code>"transformed.gaussian"</code>.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples for Gaussian and gamma, number of trials for binomial,
time length for Poisson.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_atsample">atsample</code></td>
<td>
<p>A formula in the form <code>~ x1 + x2 + ... + xd</code>
with the coordinates of the sampled locations.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_corrfcn">corrfcn</code></td>
<td>
<p>Spatial correlation function. Can be one of the
choices in <code><a href="#topic+.geoBayes_corrfcn">.geoBayes_corrfcn</a></code>.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_np">np</code></td>
<td>
<p>The number of integration points for the spatial
variance parameter sigma^2. The total number of points will be
<code>2*np + 1</code>.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_betm0">betm0</code></td>
<td>
<p>Prior mean for beta (a vector or scalar).</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_betq0">betQ0</code></td>
<td>
<p>Prior standardised precision (inverse variance)
matrix. Can be a scalar, vector or matrix. The first two imply a
diagonal with those elements. Set this to 0 to indicate a flat
improper prior.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_ssqdf">ssqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the partial sill parameter.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_ssqsc">ssqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
partial sill parameter.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_tsqdf">tsqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the measurement error parameter.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_tsqsc">tsqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
measurement error parameter.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_dispersion">dispersion</code></td>
<td>
<p>The fixed dispersion parameter.</p>
</td></tr>
<tr><td><code id="alik_inla_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes and approximation to the log-likelihood for the given
parameters using integrated nested Laplace approximations.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>par_vals</code> A data frame of the parameter values.
</p>
</li>
<li> <p><code>aloglik</code> The approximate log-likelihood at thos
parameter values.
</p>
</li></ul>



<h3>References</h3>

<p>Evangelou, E., &amp; Roy, V. (2019). Estimation and prediction for
spatial generalized linear mixed models with parametric links
via reparameterized importance sampling. Spatial Statistics, 29,
289-315.
</p>

<hr>
<h2 id='alik_optim'>Log-likelihood maximisation</h2><span id='topic+alik_optim'></span>

<h3>Description</h3>

<p>Approximate log-likelihood maximisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alik_optim(
  paroptim,
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  np,
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  dispersion = 1,
  longlat = FALSE,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alik_optim_+3A_paroptim">paroptim</code></td>
<td>
<p>A named list with the components &quot;linkp&quot;, &quot;phi&quot;,
&quot;omg&quot;, &quot;kappa&quot;. Each component must be numeric with length 1, 2,
or 3 with elements in increasing order. If the compontent's
length is 1, then the corresponding parameter is considered to
be fixed at that value. If 2, then the two numbers denote the
lower and upper bounds for the optimisation of that parameter
(infinities are allowed). If 3, these correspond to lower bound,
starting value, upper bound for the estimation of that
parameter.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_family">family</code></td>
<td>
<p>The distribution of the response.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples for Gaussian and gamma, number of trials for binomial,
time length for Poisson.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_atsample">atsample</code></td>
<td>
<p>A formula in the form <code>~ x1 + x2 + ... + xd</code>
with the coordinates of the sampled locations.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_corrfcn">corrfcn</code></td>
<td>
<p>Spatial correlation function. See
<code><a href="#topic+geoBayes_correlation">geoBayes_correlation</a></code> for details.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_np">np</code></td>
<td>
<p>The number of integration points for the spatial
variance parameter sigma^2. The total number of points will be
<code>2*np + 1</code>.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_betm0">betm0</code></td>
<td>
<p>Prior mean for beta (a vector or scalar).</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_betq0">betQ0</code></td>
<td>
<p>Prior standardised precision (inverse variance)
matrix. Can be a scalar, vector or matrix. The first two imply a
diagonal with those elements. Set this to 0 to indicate a flat
improper prior.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_ssqdf">ssqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the partial sill parameter.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_ssqsc">ssqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
partial sill parameter.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_dispersion">dispersion</code></td>
<td>
<p>The fixed dispersion parameter.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="alik_optim_+3A_control">control</code></td>
<td>
<p>A list of control parameters for the optimisation.
See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the &quot;L-BFGS-B&quot; method of the function
<code><a href="stats.html#topic+optim">optim</a></code> to maximise the log-likelihood for the
parameters <code>linkp</code>, <code>phi</code>, <code>omg</code>, <code>kappa</code>.
</p>


<h3>Value</h3>

<p>The output from the function <code><a href="stats.html#topic+optim">optim</a></code>.
The <code>"value"</code> element is the log-likelihood, not the
negative log-likelihood.
</p>


<h3>References</h3>

<p>Evangelou, E., &amp; Roy, V. (2019). Estimation and prediction for
spatial generalized linear mixed models with parametric links
via reparameterized importance sampling. Spatial Statistics, 29,
289-315.
</p>

<hr>
<h2 id='bf1skel'>Computation of Bayes factors at the skeleton points</h2><span id='topic+bf1skel'></span>

<h3>Description</h3>

<p>Function to compute the Bayes factors from MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bf1skel(
  runs,
  bfsize1 = 0.8,
  method = c("RL", "MW"),
  reference = 1,
  transf = c("no", "mu", "wo")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bf1skel_+3A_runs">runs</code></td>
<td>
<p>A list with outputs from the function
<code><a href="#topic+mcsglmm">mcsglmm</a></code> or <code><a href="#topic+mcstrga">mcstrga</a></code>.</p>
</td></tr>
<tr><td><code id="bf1skel_+3A_bfsize1">bfsize1</code></td>
<td>
<p>A scalar or vector of the same length as
<code>runs</code> with all integer values or all values in (0, 1]. How
many samples (or what proportion of the sample) to use for
estimating the Bayes factors at the first stage. The remaining
sample will be used for estimating the Bayes factors in the
second stage. Setting it to 1 will perform only the first stage.</p>
</td></tr>
<tr><td><code id="bf1skel_+3A_method">method</code></td>
<td>
<p>Which method to use to calculate the Bayes factors:
Reverse logistic or Meng-Wong.</p>
</td></tr>
<tr><td><code id="bf1skel_+3A_reference">reference</code></td>
<td>
<p>Which model goes in the denominator.</p>
</td></tr>
<tr><td><code id="bf1skel_+3A_transf">transf</code></td>
<td>
<p>Whether to use a transformed sample for the
computations. If <code>"no"</code> or <code>FALSE</code>, it doesn't. If
<code>"mu"</code> or <code>TRUE</code>, it uses the samples for the mean. If
<code>"wo"</code> it uses an alternative transformation. The latter
can be used only for the families indicated by
<code>.geoBayes_models$haswo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Bayes factors using <code>method</code> with respect to
<code>reference</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>logbf</code> A vector containing logarithm of the Bayes factors.
</p>
</li>
<li> <p><code>logLik1</code> <code>logLik2</code> Matrices with the values of
the log-likelihood computed from the samples for each model at the
first and second stages.
</p>
</li>
<li> <p><code>isweights</code> A vector with the importance sampling
weights for computing the Bayes factors at new points that will be
used at the second stage. Used internally in
<code><a href="#topic+bf2new">bf2new</a></code> and <code><a href="#topic+bf2optim">bf2optim</a></code>.
</p>
</li>
<li> <p><code>controlvar</code> A matrix with the control variates
computed at the samples that will be used in the second stage.
</p>
</li>
<li> <p><code>sample2</code> The MCMC sample for mu or z that will be
used in the second stage. Used internally in
<code><a href="#topic+bf2new">bf2new</a></code> and <code><a href="#topic+bf2optim">bf2optim</a></code>.
</p>
</li>
<li> <p><code>N1</code>, <code>N2</code> Vectors containing the sample sizes
used in the first and second stages.
</p>
</li>
<li> <p><code>distmat</code> Matrix of distances between locations.
</p>
</li>
<li> <p><code>betm0</code>, <code>betQ0</code>, <code>ssqdf</code>, <code>ssqsc</code>,
<code>tsqdf</code>, <code>tsqsc</code>, <code>dispersion</code>, <code>response</code>,
<code>weights</code>, <code>modelmatrix</code>, <code>locations</code>,
<code>family</code>, <code>corrfcn</code>, <code>transf</code> Model parameters used
internally in.
<code><a href="#topic+bf2new">bf2new</a></code> and <code><a href="#topic+bf2optim">bf2optim</a></code>.
</p>
</li>
<li> <p><code>pnts</code> A list containing the skeleton points. Used
internally in <code><a href="#topic+bf2new">bf2new</a></code> and <code><a href="#topic+bf2optim">bf2optim</a></code>.
</p>
</li></ul>



<h3>References</h3>

<p>Geyer, C. J. (1994). Estimating normalizing constants
and reweighting mixtures. Technical report, University of
Minnesota.
</p>
<p>Meng, X. L., &amp; Wong, W. H. (1996). Simulating ratios of
normalizing constants via a simple identity: A theoretical
exploration. <em>Statistica Sinica</em>, 6, 831-860.
</p>
<p>Roy, V., Evangelou, E., and Zhu, Z. (2015). Efficient estimation
and prediction for the Bayesian spatial generalized linear mixed
model with flexible link functions. <em>Biometrics</em>, 72(1), 289-298.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)
### Define the model
corrf &lt;- "spherical"
kappa &lt;- 0
ssqdf &lt;- 1
ssqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- .01
family &lt;- "binomial.probit"
### Skeleton points
philist &lt;- c(100, 140, 180)
omglist &lt;- c(.5, 1)
parlist &lt;- expand.grid(linkp=0, phi=philist, omg=omglist, kappa = kappa)
### MCMC sizes
Nout &lt;- 100
Nthin &lt;- 1
Nbi &lt;- 0
### Take MCMC samples
runs &lt;- list()
for (i in 1:NROW(parlist)) {
  runs[[i]] &lt;- mcsglmm(Infected ~ 1, family, rhizoctonia, weights = Total,
                       atsample = ~ Xcoord + Ycoord,
                       Nout = Nout, Nthin = Nthin, Nbi = Nbi,
                       betm0 = betm0, betQ0 = betQ0,
                       ssqdf = ssqdf, ssqsc = ssqsc,
                       phi = parlist$phi[i], omg = parlist$omg[i],
                       linkp = parlist$linkp[i], kappa = parlist$kappa[i],
                       corrfcn = corrf,
                       corrtuning=list(phi = 0, omg = 0, kappa = 0))
}
bf &lt;- bf1skel(runs)
bf$logbf

## End(Not run)
</code></pre>

<hr>
<h2 id='bf2new'>Compute the Bayes factors at new points</h2><span id='topic+bf2new'></span>

<h3>Description</h3>

<p>Compute the Bayes factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bf2new(bf1obj, linkp, phi, omg, kappa, useCV = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bf2new_+3A_bf1obj">bf1obj</code></td>
<td>
<p>Output from the function <code><a href="#topic+bf1skel">bf1skel</a></code> which
contains the Bayes factors and importance sampling weights.</p>
</td></tr>
<tr><td><code id="bf2new_+3A_linkp">linkp</code>, <code id="bf2new_+3A_phi">phi</code>, <code id="bf2new_+3A_omg">omg</code>, <code id="bf2new_+3A_kappa">kappa</code></td>
<td>
<p>Optional scalar or vector or
<code>NULL</code>. If scalar or vector, the Bayes factors are calculated
at those values with respect to the reference model used in
<code><a href="#topic+bf1skel">bf1skel</a></code>. If missing or <code>NULL</code> then the unique
values from the MCMC chains that were inputted in
<code><a href="#topic+bf1skel">bf1skel</a></code> will be used.</p>
</td></tr>
<tr><td><code id="bf2new_+3A_usecv">useCV</code></td>
<td>
<p>Whether to use control variates for finer
corrections.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Bayes factors using the importance weights at the new
points. The new points are taken from the grid derived by
expanding the parameter values inputted. The arguments
<code>linkp</code> <code>phi</code> <code>omg</code> <code>kappa</code> correspond to the
link function, spatial range, relative nugget, and correlation
function parameters respectively.
</p>


<h3>Value</h3>

<p>An array of size <code>length(linkp) * length(phi) *
length(omg) * length(kappa)</code> containing the Bayes factors for each
combination of the parameters.
</p>


<h3>References</h3>

<p>Doss, H. (2010). Estimation of large families of Bayes
factors from Markov chain output. <em>Statistica Sinica</em>, 20(2),
537.
</p>
<p>Roy, V., Evangelou, E., and Zhu, Z. (2015). Efficient estimation
and prediction for the Bayesian spatial generalized linear mixed
model with flexible link functions. <em>Biometrics</em>, 72(1),
289-298.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)
### Define the model
corrf &lt;- "spherical"
kappa &lt;- 0
ssqdf &lt;- 1
ssqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- .01
family &lt;- "binomial.probit"
### Skeleton points
philist &lt;- c(100, 140, 180)
omglist &lt;- c(.5, 1)
parlist &lt;- expand.grid(linkp=0, phi=philist, omg=omglist, kappa = kappa)
### MCMC sizes
Nout &lt;- 100
Nthin &lt;- 1
Nbi &lt;- 0
### Take MCMC samples
runs &lt;- list()
for (i in 1:NROW(parlist)) {
  runs[[i]] &lt;- mcsglmm(Infected ~ 1, family, rhizoctonia, weights = Total,
                       atsample = ~ Xcoord + Ycoord,
                       Nout = Nout, Nthin = Nthin, Nbi = Nbi,
                       betm0 = betm0, betQ0 = betQ0,
                       ssqdf = ssqdf, ssqsc = ssqsc,
                       phi = parlist$phi[i], omg = parlist$omg[i],
                       linkp = parlist$linkp[i], kappa = parlist$kappa[i],
                       corrfcn = corrf,
                       corrtuning=list(phi = 0, omg = 0, kappa = 0))
}
bf &lt;- bf1skel(runs)
bfall &lt;- bf2new(bf, phi = seq(100, 200, 10), omg = seq(0, 2, .2))
plotbf2(bfall, c("phi", "omg"))

## End(Not run)
</code></pre>

<hr>
<h2 id='bf2optim'>Empirical Bayes estimator</h2><span id='topic+bf2optim'></span>

<h3>Description</h3>

<p>Estimation by empirical Bayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bf2optim(bf1obj, paroptim, useCV = TRUE, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bf2optim_+3A_bf1obj">bf1obj</code></td>
<td>
<p>Output from the function <code><a href="#topic+bf1skel">bf1skel</a></code> which
contains the Bayes factors and importance sampling weights.</p>
</td></tr>
<tr><td><code id="bf2optim_+3A_paroptim">paroptim</code></td>
<td>
<p>A named list with the components &quot;linkp&quot;, &quot;phi&quot;,
&quot;omg&quot;, &quot;kappa&quot;. Each component must be numeric with length 1, 2,
or 3 with elements in increasing order but for the binomial family
linkp is also allowed to be the character &quot;logit&quot; and &quot;probit&quot;. If
the compontent's length is 1, then the corresponding parameter is
considered to be fixed at that value. If 2, then the two numbers
denote the lower and upper bounds for the optimisation of that
parameter (infinities are allowed). If 3, these correspond to
lower bound, starting value, upper bound for the estimation of
that parameter.</p>
</td></tr>
<tr><td><code id="bf2optim_+3A_usecv">useCV</code></td>
<td>
<p>Whether to use control variates for finer
corrections.</p>
</td></tr>
<tr><td><code id="bf2optim_+3A_control">control</code></td>
<td>
<p>A list of control parameters for the optimisation.
See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrap around <code><a href="#topic+bf2new">bf2new</a></code> using the
&quot;L-BFGS-B&quot; method of the function <code><a href="stats.html#topic+optim">optim</a></code> to
estimate the parameters.
</p>


<h3>Value</h3>

<p>The output from the function <code><a href="stats.html#topic+optim">optim</a></code>.
The <code>"value"</code> element is the log-Bayes factor, not the
negative log-Bayes factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)
### Define the model
corrf &lt;- "spherical"
kappa &lt;- 0
ssqdf &lt;- 1
ssqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- .01
family &lt;- "binomial.probit"
### Skeleton points
philist &lt;- c(100, 140, 180)
omglist &lt;- c(.5, 1)
parlist &lt;- expand.grid(linkp=0, phi=philist, omg=omglist, kappa = kappa)
### MCMC sizes
Nout &lt;- 100
Nthin &lt;- 1
Nbi &lt;- 0
### Take MCMC samples
runs &lt;- list()
for (i in 1:NROW(parlist)) {
  runs[[i]] &lt;- mcsglmm(Infected ~ 1, family, rhizoctonia, weights = Total,
                       atsample = ~ Xcoord + Ycoord,
                       Nout = Nout*c(.8,.2), Nthin = Nthin, Nbi = Nbi,
                       betm0 = betm0, betQ0 = betQ0,
                       ssqdf = ssqdf, ssqsc = ssqsc,
                       phi = parlist$phi[i], omg = parlist$omg[i],
                       linkp = parlist$linkp[i], kappa = parlist$kappa[i],
                       corrfcn = corrf,
                       corrtuning=list(phi = 0, omg = 0, kappa = 0))
}
bf &lt;- bf1skel(runs)
est &lt;- bf2optim(bf, list(phi = c(100, 200), omg = c(0, 2)))
est

## End(Not run)
</code></pre>

<hr>
<h2 id='bf2se'>Empirical Bayes standard errors</h2><span id='topic+bf2se'></span>

<h3>Description</h3>

<p>Standard errors for the empirical Bayes estimates of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bf2se(mcrun, transf = c("no", "mu", "wo"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bf2se_+3A_mcrun">mcrun</code></td>
<td>
<p>The output from the function <code>mcsglmm</code> where the
parameters linkp, phi, omg, kappa are set at their empirical
Bayes estimates (output of <code><a href="#topic+bf2optim">bf2optim</a></code>).</p>
</td></tr>
<tr><td><code id="bf2se_+3A_transf">transf</code></td>
<td>
<p>The type of transformation to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The precision (inverse covariance) matrix.
</p>


<h3>References</h3>

<p>Casella, G. (2001). Empirical Bayes Gibbs sampling.
Biostatistics, 2(4), 485-500.
</p>
<p>Evangelou, E., &amp; Roy, V. (2019). Estimation and prediction for
spatial generalized linear mixed models with parametric links
via reparameterized importance sampling. Spatial Statistics, 29,
289-315.
</p>

<hr>
<h2 id='bmbfse'>Batch means, Bayes factors standard errors</h2><span id='topic+bmbfse'></span>

<h3>Description</h3>

<p>Compute the standard errors for the Bayes factors estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmbfse(
  pargrid,
  runs,
  bfsize1 = 0.8,
  nbatch1 = 0.5,
  nbatch2 = 0.5,
  S1method = c("RL", "MW"),
  bvmethod = c("Standard", "TukeyHanning", "Bartlett"),
  reference = 1,
  transf = c("no", "mu", "wo")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmbfse_+3A_pargrid">pargrid</code></td>
<td>
<p>A data frame with components &quot;linkp&quot;, &quot;phi&quot;, &quot;omg&quot;,
&quot;kappa&quot;. Each row gives a combination of the parameters to
compute the new standard errors.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_runs">runs</code></td>
<td>
<p>A list with outputs from the function
<code><a href="#topic+mcsglmm">mcsglmm</a></code> or <code><a href="#topic+mcstrga">mcstrga</a></code>.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_bfsize1">bfsize1</code></td>
<td>
<p>A scalar or vector of the same length as
<code>runs</code> with all integer values or all values in (0, 1]. How
many samples (or what proportion of the sample) to use for
estimating the Bayes factors at the first stage. The remaining
sample will be used for estimating the standard errors in the
second stage. Setting it to 1 will perform only the first stage.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_nbatch1">nbatch1</code></td>
<td>
<p>A scalar or vector of the same length as
<code>runs</code>. All values must be integers or less than 1. This is
used for calculating how many batches to split each of the
sample in runs for the calculation of the Bayes factors standard
errors for the parameters corresponding to <code>runs</code>.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_nbatch2">nbatch2</code></td>
<td>
<p>A scalar or vector of the same length as
<code>runs</code>. All values must be integers or less than 1. This is
used for calculating how many batches to split each of the
sample in runs for the calculation of the Bayes factors standard
errors for the parameters corresponding to <code>pargrid</code>.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_s1method">S1method</code></td>
<td>
<p>Which method to use to calculate the Bayes factors
in stage 1: Reverse logistic or Meng-Wong.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_bvmethod">bvmethod</code></td>
<td>
<p>Which method to use for the calculation of the
batch variance. The standard method splits to disjoint batches.
The second and third method use the spectral variance method
with different lag windows.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_reference">reference</code></td>
<td>
<p>Which model goes in the denominator.</p>
</td></tr>
<tr><td><code id="bmbfse_+3A_transf">transf</code></td>
<td>
<p>Whether to use a transformed sample for the
computations. If <code>"no"</code> or <code>FALSE</code>, it doesn't. If
<code>"mu"</code> or <code>TRUE</code>, it uses the samples for the mean. If
<code>"wo"</code> it uses an alternative transformation. The latter
can be used only for the families indicated by
<code>.geoBayes_models$haswo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the batch means method to compute the standard errors for
Bayes factors.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>pargrid</code> The inputted pargrid augmented with the
computed log Bayes factors and standard errors.
</p>
</li>
<li> <p><code>bfEstimate</code> The estimates of the Bayes factors
</p>
</li>
<li> <p><code>bfSigma</code> The covariance matrix for the Bayes factors
estimates.
</p>
</li></ul>



<h3>References</h3>

<p>Roy, V., Tan, A. and Flegal, J. (2018). Estimating
standard errors for importance sampling estimators with multiple
Markov chains, Statistica Sinica, 28 1079-1101.
</p>
<p>Roy, V., &amp; Evangelou, E. (2018). Selection of proposal
distributions for generalized importance sampling estimators.
arXiv preprint arXiv:1805.00829.
</p>

<hr>
<h2 id='geoBayes_correlation'>Spatial correlation used in the geoBayes package</h2><span id='topic+geoBayes_correlation'></span><span id='topic+.geoBayes_corrfcn'></span>

<h3>Description</h3>

<p>This hidden variable contains a choice of correlation functions
that can be fit with this package. The function can be chosen in
the <code>corrfcn</code> input of the relevant function. This variable
cannot be overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.geoBayes_corrfcn
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 5 rows and 4 columns.
</p>

<hr>
<h2 id='geoBayes_models'>Models used in the geoBayes package</h2><span id='topic+geoBayes_models'></span><span id='topic+.geoBayes_models'></span>

<h3>Description</h3>

<p>This hidden variable contains a choice of models that can be fit
with this package. The model can be chosen in the <code>family</code>
input of the relevant function. This variable cannot be
overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.geoBayes_models
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 12 rows and 7 columns.
</p>

<hr>
<h2 id='linkfcn'>Calculate the link function for exponential families</h2><span id='topic+linkfcn'></span><span id='topic+linkinv'></span>

<h3>Description</h3>

<p>Link function for the exponential family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkfcn(mu, linkp, family = "gaussian")

linkinv(z, linkp, family = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkfcn_+3A_mu">mu</code></td>
<td>
<p>Numeric. The mean of the response variable.</p>
</td></tr>
<tr><td><code id="linkfcn_+3A_linkp">linkp</code></td>
<td>
<p>The link function parameter. A scalar.</p>
</td></tr>
<tr><td><code id="linkfcn_+3A_family">family</code></td>
<td>
<p>The distribution of the response variable from
<code><a href="#topic+.geoBayes_models">.geoBayes_models</a></code>. Either an integer or the
family name.</p>
</td></tr>
<tr><td><code id="linkfcn_+3A_z">z</code></td>
<td>
<p>Numeric. The linear predictor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>linkfcn</code> maps the mean of the response variable <code>mu</code> to
the linear predictor <code>z</code>. <code>linkinv</code> is its inverse.
</p>
<p>For the Gaussian family, if the link parameter is positive, then
the extended link is used, defined by </p>
<p style="text-align: center;"><code class="reqn">z =
\frac{sign(\mu)|\mu|^\nu - 1}{\nu}</code>
</p>
<p> In the other case, the usual Box-Cox link is used.
</p>
<p>For the Poisson and gamma families, if the link parameter is
positive, then the link is defined by </p>
<p style="text-align: center;"><code class="reqn">z = \frac{sign(w)
(e^{\nu |w|}-1)}{\nu}</code>
</p>
<p> where
<code class="reqn">w = \log(\mu)</code>. In the other case, the usual
Box-Cox link is used.
</p>
<p>For the GEV binomial family, the link function is defined by
</p>
<p style="text-align: center;"><code class="reqn">\mu = 1 - \exp\{-\max(0, 1 + \nu z)^{\frac{1}{\nu}}\}</code>
</p>
<p> for any real <code class="reqn">\nu</code>. At
<code class="reqn">\nu = 0</code> it reduces to the complementary log-log
link.
</p>
<p>The Wallace binomial family is a fast approximation to the robit
family. It is defined as </p>
<p style="text-align: center;"><code class="reqn">\mu =
\Phi(\mbox{sign}(z) c(\nu) \sqrt{\nu \log(1 + z^2/\nu)})</code>
</p>

<p>where <code class="reqn">c(\nu) = (8\nu+1)/(8\nu+3)</code>
</p>


<h3>Value</h3>

<p>A numeric array of the same dimension as the function's
first argument.
</p>


<h3>References</h3>

<p>Evangelou, E., &amp; Roy, V. (2019). Estimation and prediction for
spatial generalized linear mixed models with parametric links
via reparameterized importance sampling. Spatial Statistics, 29,
289-315.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mu &lt;- seq(0.1, 0.9, 0.1)
linkfcn(mu, 7, "binomial")       # robit(7) link function
linkfcn(mu, , "binomial.logit")  # logit link function

mu &lt;- seq(-3, 3, 1)
linkfcn(mu, 0.5, "gaussian")     # sqrt transformation
linkinv(linkfcn(mu, 0.5, "gaussian"), 0.5, "gaussian")
curve(linkfcn(x, 0.5, "gaussian"), -3, 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmcmake'>Convert to an <code><a href="coda.html#topic+mcmc">mcmc</a></code> object</h2><span id='topic+mcmcmake'></span>

<h3>Description</h3>

<p>Convert to an <code><a href="coda.html#topic+mcmc">mcmc</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcmake(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcmake_+3A_...">...</code></td>
<td>
<p>Output(s) from the functions mentioned in the Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes as input the one or more output(s) from
function <code><a href="#topic+mcsglmm">mcsglmm</a></code> or <code><a href="#topic+mcstrga">mcstrga</a></code> and
returns an <code><a href="coda.html#topic+mcmc">mcmc</a></code> object or an
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object for coda. The function
requires the <code>coda</code> package to be installed.
</p>
<p>The spatial random field components are assigned the names
<code>z_*</code> where <code>*</code> is a number beginning at 1. Similarly,
the regressor coefficients are assigned the names <code>beta_*</code> if
not unique, or simply <code>beta</code> if there is only one regressor.
The names <code>ssq</code>, <code>tsq</code>, <code>phi</code>, <code>omg</code>
correspond to the partial sill, measurement error variance,
spatial range, and relative nugget parameters respectively.
</p>


<h3>Value</h3>

<p>An mcmc object.
</p>


<h3>See Also</h3>

<p>Functions such as <code><a href="coda.html#topic+plot.mcmc">plot.mcmc</a></code> and
<code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code> in the <code>coda</code> package. The
function <code><a href="base.html#topic+do.call">do.call</a></code> can be used to pass arguments
stored in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 ### Load the data
data(rhizoctonia)
rhiz &lt;- na.omit(rhizoctonia)
rhiz$IR &lt;- rhiz$Infected/rhiz$Total # Incidence rate of the
                              # rhizoctonia disease
 ### Define the model
corrf &lt;- "spherical"
ssqdf &lt;- 1
ssqsc &lt;- 1
tsqdf &lt;- 1
tsqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- diag(.01, 2, 2)
phiprior &lt;- c(200, 1, 1000, 100) # U(100, 300)
phisc &lt;- 1
omgprior &lt;- c(3, 1, 1000, 0) # U(0, 3)
omgsc &lt;- 1.3
linkp &lt;- 1
## MCMC parameters
Nout &lt;- 100
Nbi &lt;- 0
Nthin &lt;- 1
 ### Run MCMC
sample &lt;- mcstrga(Yield ~ IR, data = rhiz,
                  atsample = ~ Xcoord + Ycoord, corrf = corrf,
                  Nout = Nout, Nthin = Nthin,
                  Nbi = Nbi, betm0 = betm0, betQ0 = betQ0,
                  ssqdf = ssqdf, ssqsc = ssqsc,
                  tsqdf = tsqdf, tsqsc = tsqsc,
                  linkp = linkp,
                  corrprior = list(phi = phiprior, omg = omgprior), 
                  corrtuning = list(phi = phisc, omg = omgsc, kappa = 0),
                  test = FALSE)
mcsample &lt;- mcmcmake(sample)
plot(mcsample[, c("phi", "omg", "beta_1", "beta_2", "ssq", "tsq")],
     density = FALSE)
summary(mcsample[, c("phi", "omg", "beta_1", "beta_2", "ssq", "tsq")])

## End(Not run)
</code></pre>

<hr>
<h2 id='mcsglmm'>MCMC samples from the Spatial GLMM</h2><span id='topic+mcsglmm'></span>

<h3>Description</h3>

<p>Draw MCMC samples from the Spatial GLMM with known link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcsglmm(
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  linkp,
  phi,
  omg,
  kappa,
  Nout,
  Nthin = 1,
  Nbi = 0,
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  corrpriors,
  corrtuning,
  dispersion = 1,
  longlat = FALSE,
  test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcsglmm_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>. The response must be set to <code>NA</code>'s
at the prediction locations (see the examples on how to do this
using the function <code><a href="#topic+stackdata">stackdata</a></code>). At the observed
locations the response is assumed to be a total of replicated
measurements. The number of replications is inputted using the
argument <code>weights</code>.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_family">family</code></td>
<td>
<p>The distribution of the data. The
<code>"GEVbinomial"</code> family is the binomial family with link the
GEV link (see Details).</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples for Gaussian and gamma, number of trials for binomial,
time length for Poisson.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_atsample">atsample</code></td>
<td>
<p>A formula in the form <code>~ x1 + x2 + ... + xd</code>
with the coordinates of the sampled locations.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_corrfcn">corrfcn</code></td>
<td>
<p>Spatial correlation function. See
<code><a href="#topic+geoBayes_correlation">geoBayes_correlation</a></code> for details.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_linkp">linkp</code></td>
<td>
<p>Parameter of the link function. A scalar value.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_phi">phi</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial range parameter <code>phi</code>. Defaults to the mean of its
prior. If <code>corrtuning[["phi"]]</code> is 0, then this argument is required and
it corresponds to the fixed value of <code>phi</code>. This can be a
vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_omg">omg</code></td>
<td>
<p>Optional starting value for the MCMC for the
relative nugget parameter <code>omg</code>. Defaults to the mean of
its prior. If <code>corrtuning[["omg"]]</code> is 0, then this argument is required
and it corresponds to the fixed value of <code>omg</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_kappa">kappa</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial correlation parameter <code>kappa</code> (Matern smoothness or
exponential power). Defaults to the mean of
its prior. If <code>corrtuning[["kappa"]]</code> is 0 and it is needed for
the chosen correlation function, then this argument is required
and it corresponds to the fixed value of <code>kappa</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_nout">Nout</code></td>
<td>
<p>Number of MCMC samples to return. This can be a vector
for running independent chains. 0 elements are dropped.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_nthin">Nthin</code></td>
<td>
<p>The thinning of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_nbi">Nbi</code></td>
<td>
<p>The burn-in of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_betm0">betm0</code></td>
<td>
<p>Prior mean for beta (a vector or scalar).</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_betq0">betQ0</code></td>
<td>
<p>Prior standardised precision (inverse variance)
matrix. Can be a scalar, vector or matrix. The first two imply a
diagonal with those elements. Set this to 0 to indicate a flat
improper prior.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_ssqdf">ssqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_ssqsc">ssqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_corrpriors">corrpriors</code></td>
<td>
<p>A list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
prior distribution parameters. For <code>phi</code> and <code>omg</code> it
must be a vector of length 4. The generalized inverse gamma
prior is assumed and the input corresponds to the parameters
scale, shape, exponent, location in that order (see Details).
For <code>kappa</code> it must be a vector of length 2. A uniform
prior is assumed and the input corresponds to the lower and
upper bounds in that order.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_corrtuning">corrtuning</code></td>
<td>
<p>A vector or list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
random walk parameter for the Metropolis-Hastings step. Smaller values
increase the acceptance ratio. Set this to 0 for fixed
parameter value.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_dispersion">dispersion</code></td>
<td>
<p>The fixed dispersion parameter.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="mcsglmm_+3A_test">test</code></td>
<td>
<p>Whether this is a trial run to monitor the acceptance
ratio of the random walk for <code>phi</code> and <code>omg</code>. If set
to <code>TRUE</code>, the acceptance ratio will be printed on the
screen every 100 iterations of the MCMC. Tune the <code>phisc</code>
and <code>omgsc</code> parameters in order to achive 20 to 30%
acceptance. Set this to a positive number to change the default
100. No thinning or burn-in are done when testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four-parameter prior for <code>phi</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">\propto (\phi - \theta_4)^{\theta_2 -1} \exp\{-(\frac{\phi -
\theta_4}{\theta_1})^{\theta_3}\}</code>
</p>
<p> for <code class="reqn">\phi &gt;
\theta_4</code>. The prior for <code>omg</code> is similar.
The prior parameters correspond to scale, shape, exponent, and
location. See <code>arXiv:1005.3274</code> for details of this
distribution.
</p>
<p>The GEV (Generalised Extreme Value) link is defined by </p>
<p style="text-align: center;"><code class="reqn">\mu =
1 - \exp\{-\max(0, 1 + \nu x)^{\frac{1}{\nu}}\}</code>
</p>
<p> for any real <code class="reqn">\nu</code>. At
<code class="reqn">\nu = 0</code> it reduces to the complementary log-log
link.
</p>


<h3>Value</h3>

<p>A list containing the objects <code>MODEL</code>, <code>DATA</code>,
<code>FIXED</code>, <code>MCMC</code> and <code>call</code>. The MCMC samples are
stored in the object <code>MCMC</code> as follows:
</p>

<ul>
<li> <p><code>z</code> A matrix containing the MCMC samples for the
spatial random field. Each column is one sample.
</p>
</li>
<li> <p><code>mu</code> A matrix containing the MCMC samples for the
mean response (a transformation of z). Each column is one sample.
</p>
</li>
<li> <p><code>beta</code> A matrix containing the MCMC samples for the
regressor coefficients. Each column is one sample.
</p>
</li>
<li> <p><code>ssq</code> A vector with the MCMC samples for the partial
</p>
</li>
<li> <p><code>phi</code> A vector with the MCMC samples for the spatial
range parameter, if sampled.
</p>
</li>
<li> <p><code>omg</code> A vector with the MCMC samples for the relative
nugget parameter, if sampled.
</p>
</li>
<li> <p><code>logLik</code> A vector containing the value of the
log-likelihood evaluated at each sample.
</p>
</li>
<li> <p><code>acc_ratio</code> The acceptance ratio for the joint update
of the parameters <code>phi</code> and <code>omg</code>, if sampled.
</p>
</li>
<li> <p><code>sys_time</code> The total computing time for the MCMC sampling.
</p>
</li>
<li> <p><code>Nout</code>, <code>Nbi</code>,  <code>Nthin</code> As in input. Used
internally in other functions.
</p>
</li></ul>

<p>The other objects contain input variables. The object <code>call</code>
contains the function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)

### Create prediction grid
predgrid &lt;- mkpredgrid2d(rhizoctonia[c("Xcoord", "Ycoord")],
                         par.x = 100, chull = TRUE, exf = 1.2)

### Combine observed and prediction locations
rhizdata &lt;- stackdata(rhizoctonia, predgrid$grid)
##'
### Define the model
corrf &lt;- "spherical"
family &lt;- "binomial.probit"
kappa &lt;- 0
ssqdf &lt;- 1
ssqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- .01
phiprior &lt;- c(100, 1, 1000, 100) # U(100, 200)
phisc &lt;- 3
omgprior &lt;- c(2, 1, 1, 0)        # Exp(mean = 2)
omgsc &lt;- .1
##'
### MCMC sizes
Nout &lt;- 100
Nthin &lt;- 1
Nbi &lt;- 0

### Trial run
emt &lt;- mcsglmm(Infected ~ 1, family, rhizdata, weights = Total,
               atsample = ~ Xcoord + Ycoord,
               Nout = Nout, Nthin = Nthin, Nbi = Nbi,
               betm0 = betm0, betQ0 = betQ0, ssqdf = ssqdf, ssqsc = ssqsc,
               corrpriors = list(phi = phiprior, omg = omgprior), 
               corrfcn = corrf, kappa = kappa,
               corrtuning = list(phi = phisc, omg = omgsc, kappa = 0),
               dispersion = 1, test = 10)

### Full run
emc &lt;- update(emt, test = FALSE)

emcmc &lt;- mcmcmake(emc)
summary(emcmc[, c("phi", "omg", "beta", "ssq")])
plot(emcmc[, c("phi", "omg", "beta", "ssq")])

## End(Not run)
</code></pre>

<hr>
<h2 id='mcsglmm_mala'>MCMC samples from the Spatial GLMM</h2><span id='topic+mcsglmm_mala'></span>

<h3>Description</h3>

<p>Draw MCMC samples from the Spatial GLMM with known link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcsglmm_mala(
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  linkp,
  phi,
  omg,
  kappa,
  Nout,
  Nthin = 1,
  Nbi = 0,
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  corrpriors,
  corrtuning,
  malatuning,
  dispersion = 1,
  longlat = FALSE,
  test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcsglmm_mala_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>. The response must be set to <code>NA</code>'s
at the prediction locations (see the examples on how to do this
using the function <code><a href="#topic+stackdata">stackdata</a></code>). At the observed
locations the response is assumed to be a total of replicated
measurements. The number of replications is inputted using the
argument <code>weights</code>.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_family">family</code></td>
<td>
<p>The distribution of the data. The
<code>"GEVbinomial"</code> family is the binomial family with link the
GEV link (see Details).</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples for Gaussian and gamma, number of trials for binomial,
time length for Poisson.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_atsample">atsample</code></td>
<td>
<p>A formula in the form <code>~ x1 + x2 + ... + xd</code>
with the coordinates of the sampled locations.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_corrfcn">corrfcn</code></td>
<td>
<p>Spatial correlation function. See
<code><a href="#topic+geoBayes_correlation">geoBayes_correlation</a></code> for details.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_linkp">linkp</code></td>
<td>
<p>Parameter of the link function. A scalar value.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_phi">phi</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial range parameter <code>phi</code>. Defaults to the mean of its
prior. If <code>corrtuning[["phi"]]</code> is 0, then this argument is required and
it corresponds to the fixed value of <code>phi</code>. This can be a
vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_omg">omg</code></td>
<td>
<p>Optional starting value for the MCMC for the
relative nugget parameter <code>omg</code>. Defaults to the mean of
its prior. If <code>corrtuning[["omg"]]</code> is 0, then this argument is required
and it corresponds to the fixed value of <code>omg</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_kappa">kappa</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial correlation parameter <code>kappa</code> (Matern smoothness or
exponential power). Defaults to the mean of
its prior. If <code>corrtuning[["kappa"]]</code> is 0 and it is needed for
the chosen correlation function, then this argument is required
and it corresponds to the fixed value of <code>kappa</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_nout">Nout</code></td>
<td>
<p>Number of MCMC samples to return. This can be a vector
for running independent chains.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_nthin">Nthin</code></td>
<td>
<p>The thinning of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_nbi">Nbi</code></td>
<td>
<p>The burn-in of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_betm0">betm0</code></td>
<td>
<p>Prior mean for beta (a vector or scalar).</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_betq0">betQ0</code></td>
<td>
<p>Prior standardised precision (inverse variance)
matrix. Can be a scalar, vector or matrix. The first two imply a
diagonal with those elements. Set this to 0 to indicate a flat
improper prior.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_ssqdf">ssqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_ssqsc">ssqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_corrpriors">corrpriors</code></td>
<td>
<p>A list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
prior distribution parameters. For <code>phi</code> and <code>omg</code> it
must be a vector of length 4. The generalized inverse gamma
prior is assumed and the input corresponds to the parameters
scale, shape, exponent, location in that order (see Details).
For <code>kappa</code> it must be a vector of length 2. A uniform
prior is assumed and the input corresponds to the lower and
upper bounds in that order.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_corrtuning">corrtuning</code></td>
<td>
<p>A vector or list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
random walk parameter for the Metropolis-Hastings step. Smaller values
increase the acceptance ratio. Set this to 0 for fixed
parameter value.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_malatuning">malatuning</code></td>
<td>
<p>Tuning parameter for the MALA updates.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_dispersion">dispersion</code></td>
<td>
<p>The fixed dispersion parameter.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="mcsglmm_mala_+3A_test">test</code></td>
<td>
<p>Whether this is a trial run to monitor the acceptance
ratio of the random walk for <code>phi</code> and <code>omg</code>. If set
to <code>TRUE</code>, the acceptance ratio will be printed on the
screen every 100 iterations of the MCMC. Tune the <code>phisc</code>
and <code>omgsc</code> parameters in order to achive 20 to 30%
acceptance. Set this to a positive number to change the default
100. No thinning or burn-in are done when testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The four-parameter prior for <code>phi</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">\propto (\phi - \theta_4)^{\theta_2 -1} \exp\{-(\frac{\phi -
\theta_4}{\theta_1})^{\theta_3}\}</code>
</p>
<p> for <code class="reqn">\phi &gt;
\theta_4</code>. The prior for <code>omg</code> is similar.
The prior parameters correspond to scale, shape, exponent, and
location. See <code>arXiv:1005.3274</code> for details of this
distribution.
</p>
<p>The GEV (Generalised Extreme Value) link is defined by </p>
<p style="text-align: center;"><code class="reqn">\mu =
1 - \exp\{-\max(0, 1 + \nu x)^{\frac{1}{\nu}}\}</code>
</p>
<p> for any real <code class="reqn">\nu</code>. At
<code class="reqn">\nu = 0</code> it reduces to the complementary log-log
link.
</p>


<h3>Value</h3>

<p>A list containing the objects <code>MODEL</code>, <code>DATA</code>,
<code>FIXED</code>, <code>MCMC</code> and <code>call</code>. The MCMC samples are
stored in the object <code>MCMC</code> as follows:
</p>

<ul>
<li> <p><code>z</code> A matrix containing the MCMC samples for the
spatial random field. Each column is one sample.
</p>
</li>
<li> <p><code>mu</code> A matrix containing the MCMC samples for the
mean response (a transformation of z). Each column is one sample.
</p>
</li>
<li> <p><code>beta</code> A matrix containing the MCMC samples for the
regressor coefficients. Each column is one sample.
</p>
</li>
<li> <p><code>ssq</code> A vector with the MCMC samples for the partial
</p>
</li>
<li> <p><code>phi</code> A vector with the MCMC samples for the spatial
range parameter, if sampled.
</p>
</li>
<li> <p><code>omg</code> A vector with the MCMC samples for the relative
nugget parameter, if sampled.
</p>
</li>
<li> <p><code>logLik</code> A vector containing the value of the
log-likelihood evaluated at each sample.
</p>
</li>
<li> <p><code>acc_ratio</code> The acceptance ratio for the joint update
of the parameters <code>phi</code> and <code>omg</code>, if sampled.
</p>
</li>
<li> <p><code>sys_time</code> The total computing time for the MCMC sampling.
</p>
</li>
<li> <p><code>Nout</code>, <code>Nbi</code>,  <code>Nthin</code> As in input. Used
internally in other functions.
</p>
</li></ul>

<p>The other objects contain input variables. The object <code>call</code>
contains the function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)

### Create prediction grid
predgrid &lt;- mkpredgrid2d(rhizoctonia[c("Xcoord", "Ycoord")],
                         par.x = 100, chull = TRUE, exf = 1.2)

### Combine observed and prediction locations
rhizdata &lt;- stackdata(rhizoctonia, predgrid$grid)
##'
### Define the model
corrf &lt;- "spherical"
family &lt;- "binomial.probit"
kappa &lt;- 0
ssqdf &lt;- 1
ssqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- .01
phiprior &lt;- c(100, 1, 1000, 100) # U(100, 200)
phisc &lt;- 3
omgprior &lt;- c(2, 1, 1, 0)        # Exp(mean = 2)
omgsc &lt;- .1
##'
### MCMC sizes
Nout &lt;- 100
Nthin &lt;- 1
Nbi &lt;- 0

### Trial run
emt &lt;- mcsglmm_mala(Infected ~ 1, family, rhizdata, weights = Total,
               atsample = ~ Xcoord + Ycoord,
               Nout = Nout, Nthin = Nthin, Nbi = Nbi,
               betm0 = betm0, betQ0 = betQ0, ssqdf = ssqdf, ssqsc = ssqsc,
               corrpriors = list(phi = phiprior, omg = omgprior), 
               corrfcn = corrf, kappa = kappa,
               corrtuning = list(phi = phisc, omg = omgsc, kappa = 0),
               malatuning = .003, dispersion = 1, test = 10)

### Full run
emc &lt;- update(emt, test = FALSE)

emcmc &lt;- mcmcmake(emc)
summary(emcmc[, c("phi", "omg", "beta", "ssq")])
plot(emcmc[, c("phi", "omg", "beta", "ssq")])

## End(Not run)
</code></pre>

<hr>
<h2 id='mcstrga'>MCMC samples from the transformed Gaussian model</h2><span id='topic+mcstrga'></span>

<h3>Description</h3>

<p>Draw MCMC samples from the transformed Gaussian model with known
link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcstrga(
  formula,
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  linkp,
  phi,
  omg,
  kappa,
  Nout,
  Nthin = 1,
  Nbi = 0,
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  tsqdf,
  tsqsc,
  corrpriors,
  corrtuning,
  longlat = FALSE,
  test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcstrga_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>. The response must be set to <code>NA</code>'s
at the prediction locations (see the example in
<code><a href="#topic+mcsglmm">mcsglmm</a></code> for how to do this using
<code><a href="#topic+stackdata">stackdata</a></code>). At the observed locations the response
is assumed to be a total of replicated measurements. The number of
replications is inputted using the argument <code>weights</code>.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_atsample">atsample</code></td>
<td>
<p>A formula in the form <code>~ x1 + x2 + ... + xd</code>
with the coordinates of the sampled locations.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_corrfcn">corrfcn</code></td>
<td>
<p>Spatial correlation function. See
<code><a href="#topic+geoBayes_correlation">geoBayes_correlation</a></code> for details.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_linkp">linkp</code></td>
<td>
<p>Parameter of the link function. A scalar value.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_phi">phi</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial range parameter <code>phi</code>. Defaults to the mean of its
prior. If <code>corrtuning[["phi"]]</code> is 0, then this argument is required and
it corresponds to the fixed value of <code>phi</code>. This can be a
vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_omg">omg</code></td>
<td>
<p>Optional starting value for the MCMC for the
relative nugget parameter <code>omg</code>. Defaults to the mean of
its prior. If <code>corrtuning[["omg"]]</code> is 0, then this argument is required
and it corresponds to the fixed value of <code>omg</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_kappa">kappa</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial correlation parameter <code>kappa</code> (Matern smoothness or
exponential power). Defaults to the mean of
its prior. If <code>corrtuning[["kappa"]]</code> is 0 and it is needed for
the chosen correlation function, then this argument is required
and it corresponds to the fixed value of <code>kappa</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_nout">Nout</code></td>
<td>
<p>Number of MCMC samples to return. This can be a vector
for running independent chains.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_nthin">Nthin</code></td>
<td>
<p>The thinning of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_nbi">Nbi</code></td>
<td>
<p>The burn-in of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_betm0">betm0</code></td>
<td>
<p>Prior mean for beta (a vector or scalar).</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_betq0">betQ0</code></td>
<td>
<p>Prior standardised precision (inverse variance)
matrix. Can be a scalar, vector or matrix. The first two imply a
diagonal with those elements. Set this to 0 to indicate a flat
improper prior.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_ssqdf">ssqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_ssqsc">ssqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_tsqdf">tsqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the measurement error parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_tsqsc">tsqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
measurement error parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_corrpriors">corrpriors</code></td>
<td>
<p>A list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
prior distribution parameters. For <code>phi</code> and <code>omg</code> it
must be a vector of length 4. The generalized inverse gamma
prior is assumed and the input corresponds to the parameters
scale, shape, exponent, location in that order (see Details).
For <code>kappa</code> it must be a vector of length 2. A uniform
prior is assumed and the input corresponds to the lower and
upper bounds in that order.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_corrtuning">corrtuning</code></td>
<td>
<p>A vector or list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
random walk parameter for the Metropolis-Hastings step. Smaller values
increase the acceptance ratio. Set this to 0 for fixed
parameter value.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="mcstrga_+3A_test">test</code></td>
<td>
<p>Whether this is a trial run to monitor the acceptance
ratio of the random walk for <code>phi</code> and <code>omg</code>. If set to
<code>TRUE</code>, the acceptance ratio will be printed on the screen
every 100 iterations of the MCMC. Tune the <code>phisc</code> and
<code>omgsc</code> parameters in order to achive 20 to 30% acceptance.
Set this to a positive number to change the default 100. No
thinning or burn-in are done when testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates from the posterior distribution of this model.
</p>


<h3>Value</h3>

<p>A list containing the objects <code>MODEL</code>, <code>DATA</code>,
<code>FIXED</code>, <code>MCMC</code> and <code>call</code>. The MCMC samples are
stored in the object <code>MCMC</code> as follows:
</p>

<ul>
<li> <p><code>z</code> A matrix containing the MCMC samples for the
spatial random field. Each column is one sample.
</p>
</li>
<li> <p><code>mu</code> A matrix containing the MCMC samples for the
mean response (a transformation of z). Each column is one sample.
</p>
</li>
<li> <p><code>beta</code> A matrix containing the MCMC samples for the
regressor coefficients. Each column is one sample.
</p>
</li>
<li> <p><code>ssq</code> A vector with the MCMC samples for the partial
</p>
</li>
<li> <p><code>tsq</code> A vector with the MCMC samples for the
measurement error variance.
</p>
</li>
<li> <p><code>phi</code> A vector with the MCMC samples for the spatial
range parameter, if sampled.
</p>
</li>
<li> <p><code>omg</code> A vector with the MCMC samples for the relative
nugget parameter, if sampled.
</p>
</li>
<li> <p><code>logLik</code> A vector containing the value of the
log-likelihood evaluated at each sample.
</p>
</li>
<li> <p><code>acc_ratio</code> The acceptance ratio for the joint update
of the parameters <code>phi</code> and <code>omg</code>, if sampled.
</p>
</li>
<li> <p><code>sys_time</code> The total computing time for the MCMC sampling.
</p>
</li>
<li> <p><code>Nout</code>, <code>Nbi</code>,  <code>Nthin</code> As in input. Used
internally in other functions.
</p>
</li></ul>

<p>The other objects contain input variables. The object <code>call</code>
contains the function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Load the data
data(rhizoctonia)
rhiz &lt;- na.omit(rhizoctonia)
rhiz$IR &lt;- rhiz$Infected/rhiz$Total # Incidence rate of the
                              # rhizoctonia disease

### Define the model
corrf &lt;- "spherical"
ssqdf &lt;- 1
ssqsc &lt;- 1
tsqdf &lt;- 1
tsqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- diag(.01, 2, 2)
phiprior &lt;- c(200, 1, 1000, 100) # U(100, 300)
phisc &lt;- 1
omgprior &lt;- c(3, 1, 1000, 0) # U(0, 3)
omgsc &lt;- 1
linkp &lt;- 1

## MCMC parameters
Nout &lt;- 100
Nbi &lt;- 0
Nthin &lt;- 1

samplt &lt;- mcstrga(Yield ~ IR, data = rhiz,
                  atsample = ~ Xcoord + Ycoord, corrf = corrf,
                  Nout = Nout, Nthin = Nthin,
                  Nbi = Nbi, betm0 = betm0, betQ0 = betQ0,
                  ssqdf = ssqdf, ssqsc = ssqsc,
                  tsqdf = tsqdf, tsqsc = tsqsc,
                  corrprior = list(phi = phiprior, omg = omgprior),
                  linkp = linkp,
                  corrtuning = list(phi = phisc, omg = omgsc, kappa = 0),
                  test=10)

sample &lt;- update(samplt, test = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcstrga_mala'>MCMC samples from the transformed Gaussian model</h2><span id='topic+mcstrga_mala'></span>

<h3>Description</h3>

<p>Draw MCMC samples from the transformed Gaussian model with known
link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcstrga_mala(
  formula,
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  linkp,
  phi,
  omg,
  kappa,
  Nout,
  Nthin = 1,
  Nbi = 0,
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  tsqdf,
  tsqsc,
  corrpriors,
  corrtuning,
  malatuning,
  longlat = FALSE,
  test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcstrga_mala_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>. The response must be set to <code>NA</code>'s
at the prediction locations (see the example in
<code><a href="#topic+mcsglmm">mcsglmm</a></code> for how to do this using
<code><a href="#topic+stackdata">stackdata</a></code>). At the observed locations the response
is assumed to be a total of replicated measurements. The number of
replications is inputted using the argument <code>weights</code>.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_atsample">atsample</code></td>
<td>
<p>A formula in the form <code>~ x1 + x2 + ... + xd</code>
with the coordinates of the sampled locations.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_corrfcn">corrfcn</code></td>
<td>
<p>Spatial correlation function. See
<code><a href="#topic+geoBayes_correlation">geoBayes_correlation</a></code> for details.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_linkp">linkp</code></td>
<td>
<p>Parameter of the link function. A scalar value.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_phi">phi</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial range parameter <code>phi</code>. Defaults to the mean of its
prior. If <code>corrtuning[["phi"]]</code> is 0, then this argument is required and
it corresponds to the fixed value of <code>phi</code>. This can be a
vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_omg">omg</code></td>
<td>
<p>Optional starting value for the MCMC for the
relative nugget parameter <code>omg</code>. Defaults to the mean of
its prior. If <code>corrtuning[["omg"]]</code> is 0, then this argument is required
and it corresponds to the fixed value of <code>omg</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_kappa">kappa</code></td>
<td>
<p>Optional starting value for the MCMC for the
spatial correlation parameter <code>kappa</code> (Matern smoothness or
exponential power). Defaults to the mean of
its prior. If <code>corrtuning[["kappa"]]</code> is 0 and it is needed for
the chosen correlation function, then this argument is required
and it corresponds to the fixed value of <code>kappa</code>. This can be
a vector of the same length as Nout.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_nout">Nout</code></td>
<td>
<p>Number of MCMC samples to return. This can be a vector
for running independent chains.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_nthin">Nthin</code></td>
<td>
<p>The thinning of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_nbi">Nbi</code></td>
<td>
<p>The burn-in of the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_betm0">betm0</code></td>
<td>
<p>Prior mean for beta (a vector or scalar).</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_betq0">betQ0</code></td>
<td>
<p>Prior standardised precision (inverse variance)
matrix. Can be a scalar, vector or matrix. The first two imply a
diagonal with those elements. Set this to 0 to indicate a flat
improper prior.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_ssqdf">ssqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_ssqsc">ssqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
partial sill parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_tsqdf">tsqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the measurement error parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_tsqsc">tsqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
measurement error parameter.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_corrpriors">corrpriors</code></td>
<td>
<p>A list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
prior distribution parameters. For <code>phi</code> and <code>omg</code> it
must be a vector of length 4. The generalized inverse gamma
prior is assumed and the input corresponds to the parameters
scale, shape, exponent, location in that order (see Details).
For <code>kappa</code> it must be a vector of length 2. A uniform
prior is assumed and the input corresponds to the lower and
upper bounds in that order.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_corrtuning">corrtuning</code></td>
<td>
<p>A vector or list with the components <code>phi</code>,
<code>omg</code> and <code>kappa</code> as needed. These correspond to the
random walk parameter for the Metropolis-Hastings step. Smaller values
increase the acceptance ratio. Set this to 0 for fixed
parameter value.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_malatuning">malatuning</code></td>
<td>
<p>Tuning parameter for the MALA updates.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="mcstrga_mala_+3A_test">test</code></td>
<td>
<p>Whether this is a trial run to monitor the acceptance
ratio of the random walk for <code>phi</code> and <code>omg</code>. If set to
<code>TRUE</code>, the acceptance ratio will be printed on the screen
every 100 iterations of the MCMC. Tune the <code>phisc</code> and
<code>omgsc</code> parameters in order to achive 20 to 30% acceptance.
Set this to a positive number to change the default 100. No
thinning or burn-in are done when testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates from the posterior distribution of this model.
</p>


<h3>Value</h3>

<p>A list containing the objects <code>MODEL</code>, <code>DATA</code>,
<code>FIXED</code>, <code>MCMC</code> and <code>call</code>. The MCMC samples are
stored in the object <code>MCMC</code> as follows:
</p>

<ul>
<li> <p><code>z</code> A matrix containing the MCMC samples for the
spatial random field. Each column is one sample.
</p>
</li>
<li> <p><code>mu</code> A matrix containing the MCMC samples for the
mean response (a transformation of z). Each column is one sample.
</p>
</li>
<li> <p><code>beta</code> A matrix containing the MCMC samples for the
regressor coefficients. Each column is one sample.
</p>
</li>
<li> <p><code>ssq</code> A vector with the MCMC samples for the partial
</p>
</li>
<li> <p><code>tsq</code> A vector with the MCMC samples for the
measurement error variance.
</p>
</li>
<li> <p><code>phi</code> A vector with the MCMC samples for the spatial
range parameter, if sampled.
</p>
</li>
<li> <p><code>omg</code> A vector with the MCMC samples for the relative
nugget parameter, if sampled.
</p>
</li>
<li> <p><code>logLik</code> A vector containing the value of the
log-likelihood evaluated at each sample.
</p>
</li>
<li> <p><code>acc_ratio</code> The acceptance ratio for the joint update
of the parameters <code>phi</code> and <code>omg</code>, if sampled.
</p>
</li>
<li> <p><code>sys_time</code> The total computing time for the MCMC sampling.
</p>
</li>
<li> <p><code>Nout</code>, <code>Nbi</code>,  <code>Nthin</code> As in input. Used
internally in other functions.
</p>
</li></ul>

<p>The other objects contain input variables. The object <code>call</code>
contains the function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Load the data
data(rhizoctonia)
rhiz &lt;- na.omit(rhizoctonia)
rhiz$IR &lt;- rhiz$Infected/rhiz$Total # Incidence rate of the
                              # rhizoctonia disease

### Define the model
corrf &lt;- "spherical"
ssqdf &lt;- 1
ssqsc &lt;- 1
tsqdf &lt;- 1
tsqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- diag(.01, 2, 2)
phiprior &lt;- c(200, 1, 1000, 100) # U(100, 300)
phisc &lt;- 1
omgprior &lt;- c(3, 1, 1000, 0) # U(0, 3)
omgsc &lt;- 1
linkp &lt;- 1

## MCMC parameters
Nout &lt;- 100
Nbi &lt;- 0
Nthin &lt;- 1

samplt &lt;- mcstrga_mala(Yield ~ IR, data = rhiz,
                  atsample = ~ Xcoord + Ycoord, corrf = corrf,
                  Nout = Nout, Nthin = Nthin,
                  Nbi = Nbi, betm0 = betm0, betQ0 = betQ0,
                  ssqdf = ssqdf, ssqsc = ssqsc,
                  tsqdf = tsqdf, tsqsc = tsqsc,
                  corrprior = list(phi = phiprior, omg = omgprior),
                  linkp = linkp,
                  corrtuning = list(phi = phisc, omg = omgsc, kappa = 0),
                  malatuning = .0002, test=10)

sample &lt;- update(samplt, test = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkpredgrid2d'>Make prediction grid</h2><span id='topic+mkpredgrid2d'></span>

<h3>Description</h3>

<p>This function creates a grid for prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkpredgrid2d(
  pnts.x,
  pnts.y,
  par.x,
  par.y,
  isby = FALSE,
  chull = FALSE,
  exf = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkpredgrid2d_+3A_pnts.x">pnts.x</code></td>
<td>
<p>x coordinate of the domain. Could also be a
two-column matrix containing the x and y coordinates</p>
</td></tr>
<tr><td><code id="mkpredgrid2d_+3A_pnts.y">pnts.y</code></td>
<td>
<p>y coordinate of the domain. Should be
omitted or set to <code>NULL</code> if the argument <code>pnts.x</code> is a
two-column matrix.</p>
</td></tr>
<tr><td><code id="mkpredgrid2d_+3A_par.x">par.x</code></td>
<td>
<p>A scalar parameter for the x component of the new
grid. This parameter corresponds to either the <code>by</code> or the
<code>length.out</code> arguments of the function
<code><a href="base.html#topic+seq">seq</a></code>. Could also be a vector of two elements
containing the parameter for x and y.</p>
</td></tr>
<tr><td><code id="mkpredgrid2d_+3A_par.y">par.y</code></td>
<td>
<p>As in <code>par.x</code> for the y component of the new
grid. Should be omitted or set to <code>NULL</code> if the argument
<code>par.x</code> is a two-dimensional vector.</p>
</td></tr>
<tr><td><code id="mkpredgrid2d_+3A_isby">isby</code></td>
<td>
<p>If <code>TRUE</code>, the arguments <code>par.x</code> and
<code>par.y</code> correspond to the <code>by</code> argument of the function
<code><a href="base.html#topic+seq">seq</a></code>, otherwise they correspond to
<code>length.out</code>.</p>
</td></tr>
<tr><td><code id="mkpredgrid2d_+3A_chull">chull</code></td>
<td>
<p>Whether to calculate the convex hull of the points.
Set this to <code>TRUE</code> if <code>pnts.x</code> and <code>pnts.y</code> denote
the sampled locations. If they correspond to the borders of the
domain, it is recommended to set this to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mkpredgrid2d_+3A_exf">exf</code></td>
<td>
<p>An expansion factor of the convex hull of
<code>cbind(pnts.x, pnts.y)</code>. Must be positive. If larger or
smaller than 1, the convex hull is respectively expanded or
contracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>chull</code> this function first calculates the convex hull of
the points. If <code>exf</code> is not 1 the borders are expanded. Then
the function calls <code><a href="sp.html#topic+point.in.polygon">point.in.polygon</a></code> to select
points that fall inside the borders.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>grid</code> A two-column matrix with the prediction grid.
</p>
</li>
<li> <p><code>xycoord</code> A list with components &quot;x&quot; and &quot;y&quot;
containing the sequence of points used to create the grid.
</p>
</li>
<li> <p><code>xygrid</code> A matrix with the full square grid derived
from <code>xycoord</code>.
</p>
</li>
<li> <p><code>borders</code> The (expanded) borders of the domain.
</p>
</li>
<li> <p><code>inxygrid</code> A logical vector indicating which rows of
<code>xycoord</code> fall inside <code>borders</code>, and therefore
correspond to the <code>grid</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)
predgrid &lt;- mkpredgrid2d(rhizoctonia[c("Xcoord", "Ycoord")],
                         par.x = 100, chull = TRUE, exf = 1.2)
plot(predgrid$borders, type = "l")         # Domain for prediction
points(predgrid$grid, pch = 20, cex = .3)  # Prediction locations
points(rhizoctonia[c("Xcoord", "Ycoord")]) # Observed locations

## End(Not run)
</code></pre>

<hr>
<h2 id='plotbf2'>Plot the estimated Bayes factors</h2><span id='topic+plotbf2'></span>

<h3>Description</h3>

<p>This function plots the estimated logarithm Bayes factors from the
function <code><a href="#topic+bf2new">bf2new</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbf2(
  bf2obj,
  pars = c("linkp", "phi", "omg", "kappa"),
  profile = length(pars) &gt; 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotbf2_+3A_bf2obj">bf2obj</code></td>
<td>
<p>Output from the function <code><a href="#topic+bf2new">bf2new</a></code>.</p>
</td></tr>
<tr><td><code id="plotbf2_+3A_pars">pars</code></td>
<td>
<p>A vector with the names of the parameters to plot.</p>
</td></tr>
<tr><td><code id="plotbf2_+3A_profile">profile</code></td>
<td>
<p>Whether it should produce a profile plot or a
contour plot if the length of pars is 2.</p>
</td></tr>
<tr><td><code id="plotbf2_+3A_...">...</code></td>
<td>
<p>Other input to be passed to either <code>plot</code> or
<code>contour</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on whether <code>pars</code> has length 1 or 2, this function
creates a line or a contour plot of the estimated Bayes factors.
If its length is 3 or 4, then it produces multiple profile plots.
In this case the variable is fixed at different values and the
maximum Bayes factor corresponding to the fixed value is plotted
against that value.
</p>


<h3>Value</h3>

<p>This function returns nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)
### Define the model
corrf &lt;- "spherical"
kappa &lt;- 0
ssqdf &lt;- 1
ssqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- .01
family &lt;- "binomial.probit"
### Skeleton points
philist &lt;- c(100, 140, 180)
omglist &lt;- c(.5, 1)
parlist &lt;- expand.grid(linkp=0, phi=philist, omg=omglist, kappa = kappa)
### MCMC sizes
Nout &lt;- 100
Nthin &lt;- 1
Nbi &lt;- 0
### Take MCMC samples
runs &lt;- list()
for (i in 1:NROW(parlist)) {
  runs[[i]] &lt;- mcsglmm(Infected ~ 1, family, rhizoctonia, weights = Total,
                       atsample = ~ Xcoord + Ycoord,
                       Nout = Nout, Nthin = Nthin, Nbi = Nbi,
                       betm0 = betm0, betQ0 = betQ0,
                       ssqdf = ssqdf, ssqsc = ssqsc,
                       phi = parlist$phi[i], omg = parlist$omg[i],
                       linkp = parlist$linkp[i], kappa = parlist$kappa[i],
                       corrfcn = corrf,
                       corrtuning=list(phi = 0, omg = 0, kappa = 0))
}
bf &lt;- bf1skel(runs)
bfall &lt;- bf2new(bf, phi = seq(100, 200, 10), omg = seq(0, 2, .2))
plotbf2(bfall, c("phi", "omg"))
plotbf2(bfall, c("phi", "omg"), profile = TRUE, type = "b", ylab="log(BF)")

## End(Not run)
</code></pre>

<hr>
<h2 id='revlogreg'>Reverse logistic regression estimation</h2><span id='topic+revlogreg'></span>

<h3>Description</h3>

<p>Perform the reverse logistic regression estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revlogreg(lglk, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revlogreg_+3A_lglk">lglk</code></td>
<td>
<p>The value of the loglikelihood at different samples and
different parameters. This should be entered as a matrix where the
rows are the values of the samples and the columns correspond to
the parameters. The
[i,j] element of the matrix is the value of the loglikelihood at
the ith sample when all samples are put together evaluated
at the jth parameter value.</p>
</td></tr>
<tr><td><code id="revlogreg_+3A_n">N</code></td>
<td>
<p>A vector of length ncol(lglk) or a scalar corresponding to
the sample sizes from each model. Must sum(N) == nrow(lglk). The
first N[1] samples come from model corresponding to the first set
of parameters, then (N[1]+1):N[2] are from the model corresponding
to the second set of parameters, and so on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation is done by maximising the reverse logistic log likelihood.
</p>


<h3>Value</h3>

<p>A vector containing the reverse logistic regression estimates
of the logarithm of the Bayes factors.
The first set of parameters is taken as the reference model so its
estimate is always 0.
</p>


<h3>References</h3>

<p>Geyer, C. J. (1994). Estimating normalizing constants
and reweighting mixtures in Markov chain Monte Carlo. Technical
Report 568, School of Statistics, University of Minnesota.
</p>

<hr>
<h2 id='rhizoctonia'>Rhizoctonia root rot infections</h2><span id='topic+rhizoctonia'></span>

<h3>Description</h3>

<p>Rhizoctonia root rot infections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rhizoctonia)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 5 variables.
</p>


<h3>Details</h3>

<p>A dataset containing the number of infected roots and the sample
coordinate. The data were collected by Dr Jim Cook at Washington
State University. 
</p>

<ul>
<li><p> Xcoord Longitude of the sampling location.
</p>
</li>
<li><p> Ycoord Latitude of the sampling location.
</p>
</li>
<li><p> Total Total number of roots sampled at that location.
</p>
</li>
<li><p> Infected Number of infected roots found at that location.
</p>
</li>
<li><p> Yield Barley yield at that location. These data were
obtained by hand-harvesting a 4-square-meter area in the sampling
location. One observation is missing.
</p>
</li></ul>



<h3>Note</h3>

<p>We acknowledge Hao Zhang for providing these data.
</p>


<h3>Source</h3>

<p><a href="http://www.biometrics.tibs.org/datasets/010434.txt">http://www.biometrics.tibs.org/datasets/010434.txt</a>
</p>


<h3>References</h3>

<p>Zhang, H. (2002). On estimation and prediction for
spatial generalized linear mixed models. <em>Biometrics</em>, 58(1),
129-136.
</p>

<hr>
<h2 id='rsglmm'>Simulation from a spatial model</h2><span id='topic+rsglmm'></span><span id='topic+rstrga'></span><span id='topic+rsgrf'></span>

<h3>Description</h3>

<p>Simulate from a variety of spatial models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsglmm(
  n,
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  beta,
  linkp,
  phi,
  omg,
  kappa,
  ssq,
  corrfcn = "matern",
  longlat = FALSE,
  dispersion = 1,
  returnGRF = FALSE,
  warndisp = TRUE
)

rstrga(
  n,
  formula,
  data,
  weights,
  subset,
  offset,
  atsample,
  beta,
  linkp,
  phi,
  omg,
  kappa,
  ssq,
  corrfcn = "matern",
  longlat = FALSE,
  dispersion = 1,
  returnGRF = FALSE
)

rsgrf(
  n,
  formula,
  data,
  subset,
  offset,
  atsample,
  beta,
  phi,
  omg,
  kappa,
  ssq,
  corrfcn = "matern",
  longlat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsglmm_+3A_n">n</code></td>
<td>
<p>The number of instances to simulate</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>. The LHS can be omitted. If the LHS
exists, it can be of the form <code>y</code>, <code>y|z</code>, or sums of
terms at either side of the <code>|</code> to specify the names of the
variables to include in the data frame.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_family">family</code></td>
<td>
<p>The distribution of the data to simulate from.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples for Gaussian and gamma, number of trials for binomial,
time length for Poisson.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_subset">subset</code></td>
<td>
<p>An optional set of indices. Simulations will be
provided for those locations only.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_atsample">atsample</code></td>
<td>
<p>A formula of the form <code>~ Xcoord + Ycoord</code>
specifying the sampled locations.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_beta">beta</code></td>
<td>
<p>A vector of the regressor coefficents to use.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_linkp">linkp</code></td>
<td>
<p>The link function parameter.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_phi">phi</code></td>
<td>
<p>The spatial range parameter.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_omg">omg</code></td>
<td>
<p>The relative nugget parameter.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_kappa">kappa</code></td>
<td>
<p>The spatial smoothness parameter.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_ssq">ssq</code></td>
<td>
<p>The partial sill parameter.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_corrfcn">corrfcn</code></td>
<td>
<p>The correlation function to use.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_dispersion">dispersion</code></td>
<td>
<p>The fixed dispersion parameter. When this is not
1 and the sample is from a binomial or a Poisson distribution,
no such distribution exists so an approximate sample is
returned. Use with caution.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_returngrf">returnGRF</code></td>
<td>
<p>Whether to return the simulate Gaussian random
field as well.</p>
</td></tr>
<tr><td><code id="rsglmm_+3A_warndisp">warndisp</code></td>
<td>
<p>Whether to warn when sampling from a quasi
distribution. This is the case for binomial and Poisson when the
dispersion is not one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial Gaussian random field is simulated using the Cholesky
decomposition of the covariance matrix.
</p>
<p>The sample from a quasi distribution uses a hack which matches the
mean and the variance of the distribution. See the source code for
details.
</p>


<h3>Value</h3>

<p>A data frame containing the predictors, sampling
locations, optional weights, and samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n &lt;- 100
beta &lt;- c(-2, 1)
phi &lt;- .2
omg &lt;- .3
linkp &lt;- 0
ssq &lt;- 1
l &lt;- rep(10, n)
corrf &lt;- "matern"
kappa &lt;- .5
family &lt;- "poisson"
Xcoord &lt;- runif(n)
Ycoord &lt;- runif(n)
f &lt;- Xcoord + Ycoord
formula &lt;- y|z ~ f
mydata &lt;- rsglmm(1, formula, family, weights = l,
                 atsample = ~ Xcoord + Ycoord, beta = beta, linkp = linkp,
                 phi = phi, omg = omg, kappa = kappa, ssq = ssq,
                 corrfcn = corrf, returnGRF = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='select_proposals'>Selection of multiple importance sampling distributions</h2><span id='topic+select_proposals'></span><span id='topic+select_proposals_SEQ'></span><span id='topic+select_proposals_MNX'></span><span id='topic+select_proposals_ENT'></span>

<h3>Description</h3>

<p>Selection of multiple importance sampling distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_proposals_SEQ(
  pargrid,
  K,
  istart,
  relativeSE = FALSE,
  N1,
  N2,
  Nthin,
  Nbi,
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  dispersion = 1,
  longlat = FALSE,
  nbatch1 = 0.5,
  nbatch2 = 0.5,
  S1method = c("RL", "MW"),
  bvmethod = c("Standard", "TukeyHanning", "Bartlett"),
  transf = c("no", "mu", "wo")
)

select_proposals_MNX(
  pargrid,
  istart,
  nfix,
  relativeSE = FALSE,
  N1,
  N2,
  Nthin,
  Nbi,
  cooling,
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  dispersion = 1,
  longlat = FALSE,
  nbatch1 = 0.5,
  nbatch2 = 0.5,
  S1method = c("RL", "MW"),
  bvmethod = c("Standard", "TukeyHanning", "Bartlett"),
  transf = c("no", "mu", "wo"),
  verbose = FALSE
)

select_proposals_ENT(
  pargrid,
  istart,
  nfix,
  relativeSE = FALSE,
  N1,
  Nthin,
  Nbi,
  cooling,
  formula,
  family = "gaussian",
  data,
  weights,
  subset,
  offset,
  atsample,
  corrfcn = "matern",
  betm0,
  betQ0,
  ssqdf,
  ssqsc,
  dispersion = 1,
  longlat = FALSE,
  nbatch1 = 0.5,
  nbatch2 = 0.5,
  S1method = c("RL", "MW"),
  bvmethod = c("Standard", "TukeyHanning", "Bartlett"),
  transf = c("no", "mu", "wo"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_proposals_+3A_pargrid">pargrid</code></td>
<td>
<p>A data frame with components &quot;linkp&quot;, &quot;phi&quot;, &quot;omg&quot;,
&quot;kappa&quot;. Each row gives a combination of the parameters to
compute the new standard errors.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_k">K</code></td>
<td>
<p>How many proposal densities in total to choose among the
rows of <code>pargrid</code>. Needed for SEQ only. For MNX and ENT
this is determined by the length of <code>istart</code>.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_istart">istart</code></td>
<td>
<p>Start with these rows of <code>pargrid</code>. A vector of
indices.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_relativese">relativeSE</code></td>
<td>
<p>Logical. Whether the choice is based on the
standard error (FALSE), or relative standard error (TRUE).</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_n1">N1</code></td>
<td>
<p>The sample size for stage 1.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_n2">N2</code></td>
<td>
<p>The sample sie for stage 2.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_nthin">Nthin</code></td>
<td>
<p>Thinning</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_nbi">Nbi</code></td>
<td>
<p>Burn-in</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_formula">formula</code></td>
<td>
<p>A representation of the model in the form
<code>response ~ terms</code>. The response must be set to <code>NA</code>'s
at the prediction locations (see the examples on how to do this
using the function <code><a href="#topic+stackdata">stackdata</a></code>). At the observed
locations the response is assumed to be a total of replicated
measurements. The number of replications is inputted using the
argument <code>weights</code>.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_family">family</code></td>
<td>
<p>The distribution of the data. The
<code>"GEVbinomial"</code> family is the binomial family with link the
GEV link (see Details).</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights. Number of replicated
samples for Gaussian and gamma, number of trials for binomial,
time length for Poisson.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_offset">offset</code></td>
<td>
<p>See <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_atsample">atsample</code></td>
<td>
<p>A formula in the form <code>~ x1 + x2 + ... + xd</code>
with the coordinates of the sampled locations.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_corrfcn">corrfcn</code></td>
<td>
<p>Spatial correlation function. See
<code><a href="#topic+geoBayes_correlation">geoBayes_correlation</a></code> for details.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_betm0">betm0</code></td>
<td>
<p>Prior mean for beta (a vector or scalar).</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_betq0">betQ0</code></td>
<td>
<p>Prior standardised precision (inverse variance)
matrix. Can be a scalar, vector or matrix. The first two imply a
diagonal with those elements. Set this to 0 to indicate a flat
improper prior.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_ssqdf">ssqdf</code></td>
<td>
<p>Degrees of freedom for the scaled inverse chi-square
prior for the partial sill parameter.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_ssqsc">ssqsc</code></td>
<td>
<p>Scale for the scaled inverse chi-square prior for the
partial sill parameter.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_dispersion">dispersion</code></td>
<td>
<p>The fixed dispersion parameter.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_nbatch1">nbatch1</code></td>
<td>
<p>A scalar or vector of the same length as
<code>runs</code>. All values must be integers or less than 1. This is
used for calculating how many batches to split each of the
sample in runs for the calculation of the Bayes factors standard
errors for the parameters corresponding to <code>runs</code>.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_nbatch2">nbatch2</code></td>
<td>
<p>A scalar or vector of the same length as
<code>runs</code>. All values must be integers or less than 1. This is
used for calculating how many batches to split each of the
sample in runs for the calculation of the Bayes factors standard
errors for the parameters corresponding to <code>pargrid</code>.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_s1method">S1method</code></td>
<td>
<p>Which method to use to calculate the Bayes
factors: Reverse logistic or Meng-Wong.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_bvmethod">bvmethod</code></td>
<td>
<p>Which method to use for the calculation of the
batch variance. The standard method splits to disjoint batches.
The second and third method use the spectral variance method
with different lag windows.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_transf">transf</code></td>
<td>
<p>Whether to use a transformed sample for the
computations. If <code>"no"</code> or <code>FALSE</code>, it doesn't. If
<code>"mu"</code> or <code>TRUE</code>, it uses the samples for the mean. If
<code>"wo"</code> it uses an alternative transformation. The latter
can be used only for the families indicated by
<code>.geoBayes_models$haswo</code>.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_nfix">nfix</code></td>
<td>
<p>In the case of MNX and ENT, the first <code>nfix</code>
elements of <code>istart</code> will always be included.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_cooling">cooling</code></td>
<td>
<p>A decreasing sequence of temperature values for the
simulated annealing. All elements must be positive. A suggested
value is <code>Tinit / log(((0:N) %/% Tstp)*Tstp + exp(1))</code> for
<code>N+1</code> iterations, where <code>Tinit</code> is the initial
temperature and <code>Tstp</code> is the number of iterations before
the temperature is reduced.</p>
</td></tr>
<tr><td><code id="select_proposals_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Prints information about the simulated
annealing.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>SEQ</dt><dd><p>is a sequential method starting with <code>istart</code> and
additng to it until <code>K</code> proposals have been selected. At each
iteration, the point with the highest (relative?) standard error
is added</p>
</dd> 
<dt>MNX</dt><dd><p>is the minimax method. The chosen proposal corresponds
to the lowest maximum (relative?) standard error.</p>
</dd>
<dt>ENT</dt><dd><p>is the entropy method. The chosen proposal corresponds
to the highest determinant of the (relative?) covariance matrix at
the first stage.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt>selected</dt><dd><p>The rows of <code>pargrid</code> selected.</p>
</dd>
<dt>isel</dt><dd><p>The indices of the rows of <code>pargrid</code> selected.</p>
</dd>
<dt>se</dt><dd><p>The standard error corresponding to the selected
parameters.</p>
</dd>
<dt>samples</dt><dd><p>A list containing the samples from the selected
parameters.</p>
</dd> 
</dl>



<h3>References</h3>

<p>Roy, V., &amp; Evangelou, E. (2018). Selection of proposal
distributions for generalized importance sampling estimators.
arXiv preprint arXiv:1805.00829.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rhizoctonia)
### Define the model
corrf &lt;- "spherical"
kappa &lt;- 0
ssqdf &lt;- 1
ssqsc &lt;- 1
betm0 &lt;- 0
betQ0 &lt;- .01
family &lt;- "binomial.probit"
formula &lt;- Infected ~ 1
atsample &lt;- ~ Xcoord + Ycoord
### Skeleton points
philist &lt;- seq(100, 200, 10)
omglist &lt;- 0
parlist &lt;- expand.grid(linkp=0, phi=philist, omg=omglist, kappa = kappa)
### MCMC sizes
Nout &lt;- 100
Nthin &lt;- 1
Nbi &lt;- 10
## Select proposals
K &lt;- 3                        # Choose 3 proposals
istart_SEQ &lt;- 6               # Start with middle
istart_MNX &lt;- istart_ENT &lt;- c(6, 2, 10)
cooling_MNX &lt;- .05/log((0:24 %/% 5)*5 + exp(1))
cooling_ENT &lt;- .3/log((0:49 %/% 10)*10 + exp(1))
prop_SEQ &lt;- select_proposals_SEQ(pargrid = parlist, K = K,
                                 istart = istart_SEQ,
                                 relativeSE = TRUE, 
                                 N1 = Nout, N2 = Nout,
                                 Nthin = Nthin, Nbi = Nbi,
                                 formula = formula, family = family,
                                 data = rhizoctonia, weights = Total, 
                                 atsample = atsample, corrfcn = corrf,
                                 betm0 = betm0, betQ0 = betQ0,
                                 ssqdf = ssqdf, ssqsc = ssqsc,
                                 dispersion = 1, longlat = FALSE,
                                 nbatch1 = 0.5, nbatch2 = 0.5,
                                 bvmethod = "TukeyHanning",
                                 transf = "mu")
prop_MNX &lt;- select_proposals_MNX(pargrid = parlist,
                                 istart = istart_MNX, nfix = 1L,
                                 cooling = cooling_MNX, 
                                 relativeSE = TRUE, 
                                 N1 = Nout, N2 = Nout,
                                 Nthin = Nthin, Nbi = Nbi,
                                 formula = formula, family = family,
                                 data = rhizoctonia, weights = Total, 
                                 atsample = atsample, corrfcn = corrf,
                                 betm0 = betm0, betQ0 = betQ0,
                                 ssqdf = ssqdf, ssqsc = ssqsc,
                                 dispersion = 1, longlat = FALSE,
                                 nbatch1 = 0.5, nbatch2 = 0.5,
                                 bvmethod = "TukeyHanning",
                                 transf = "mu",
                                 verbose = TRUE)
prop_ENT &lt;- select_proposals_ENT(pargrid = parlist,
                                 istart = istart_ENT, nfix = 1L,
                                 cooling = cooling_ENT, 
                                 relativeSE = TRUE, 
                                 N1 = Nout, 
                                 Nthin = Nthin, Nbi = Nbi,
                                 formula = formula, family = family,
                                 data = rhizoctonia, weights = Total, 
                                 atsample = atsample, corrfcn = corrf,
                                 betm0 = betm0, betQ0 = betQ0,
                                 ssqdf = ssqdf, ssqsc = ssqsc,
                                 dispersion = 1, longlat = FALSE,
                                 nbatch1 = 0.5, nbatch2 = 0.5,
                                 bvmethod = "TukeyHanning",
                                 transf = "mu",
                                 verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='spcovariance'>Spatial variance-covariance matrix</h2><span id='topic+spcovariance'></span><span id='topic+spcovariance.formula'></span><span id='topic+spcovariance.numeric'></span><span id='topic+spcovariance.dist'></span>

<h3>Description</h3>

<p>Calculates the spatial variance-covariance matrix for a selection
of correlation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcovariance(...)

## S3 method for class 'formula'
spcovariance(
  formula,
  data,
  subset,
  corrfcn,
  ssq,
  phi,
  omg,
  kappa,
  longlat = FALSE,
  ...
)

## S3 method for class 'numeric'
spcovariance(x, corrfcn, ssq, phi, omg, kappa, ...)

## S3 method for class 'dist'
spcovariance(x, corrfcn, ssq, phi, omg, kappa, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcovariance_+3A_...">...</code></td>
<td>
<p>Further arguments. Not currently in use.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>~ Xcoord + Ycoord</code>
specifying the sampled locations.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_subset">subset</code></td>
<td>
<p>An optional set of indices. The covariance will be
calculated for those coordinates only.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_corrfcn">corrfcn</code></td>
<td>
<p>The correlation function to use.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_ssq">ssq</code></td>
<td>
<p>The partial sill parameter.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_phi">phi</code></td>
<td>
<p>The spatial range parameter.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_omg">omg</code></td>
<td>
<p>The relative nugget parameter.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_kappa">kappa</code></td>
<td>
<p>The spatial smoothness parameter.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_longlat">longlat</code></td>
<td>
<p>How to compute the distance between locations. If
<code>FALSE</code>, Euclidean distance, if <code>TRUE</code> Great Circle
distance. See <code><a href="sp.html#topic+spDists">spDists</a></code>.</p>
</td></tr>
<tr><td><code id="spcovariance_+3A_x">x</code></td>
<td>
<p>A numerical object of distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a formula input, a variance-covariance matrix. For a
numeric input, an object of the the same dimensions as its first
input.
</p>

<hr>
<h2 id='sploglik'>Spatial log likelihood</h2><span id='topic+sploglik'></span>

<h3>Description</h3>

<p>Spatial joint log likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sploglik(pargrid, runs, transf = c("no", "mu", "wo"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sploglik_+3A_pargrid">pargrid</code></td>
<td>
<p>A data frame with components &quot;linkp&quot;, &quot;phi&quot;, &quot;omg&quot;,
&quot;kappa&quot;. Each row gives a combination of the parameters to compute
the log-likelihood.</p>
</td></tr>
<tr><td><code id="sploglik_+3A_runs">runs</code></td>
<td>
<p>A list with outputs from the function
<code><a href="#topic+mcsglmm">mcsglmm</a></code> or <code><a href="#topic+mcstrga">mcstrga</a></code>.</p>
</td></tr>
<tr><td><code id="sploglik_+3A_transf">transf</code></td>
<td>
<p>Whether to use a transformed sample for the
computations. If <code>"no"</code> or <code>FALSE</code>, it doesn't. If
<code>"mu"</code> or <code>TRUE</code>, it uses the samples for the mean. If
<code>"wo"</code> it uses an alternative transformation. The latter
can be used only for the families indicated by
<code>.geoBayes_models$haswo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the joint log likelihood log f(y,T(z)|parameters) where
T(z) is the transformation, for each (y,z) in runs and for parameters
in pargrid up to a constant which does not depend on the
parameters. The parameters beta and sigma^2 are integrated out.
</p>


<h3>Value</h3>

<p>A matrix with number of rows the total number of samples
in runs and number of columns the number of rows in pargrid. The
[i,j] element of the matrix is the value of the loglikelihood at
the ith sample when all samples in runs are put together evaluated
at the jth parameter value.
</p>

<hr>
<h2 id='sploglik_cross'>Spatial log likelihood</h2><span id='topic+sploglik_cross'></span>

<h3>Description</h3>

<p>Spatial joint log likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sploglik_cross(runs, transf = c("no", "mu", "wo"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sploglik_cross_+3A_runs">runs</code></td>
<td>
<p>A list with outputs from the function
<code><a href="#topic+mcsglmm">mcsglmm</a></code> or <code><a href="#topic+mcstrga">mcstrga</a></code>.</p>
</td></tr>
<tr><td><code id="sploglik_cross_+3A_transf">transf</code></td>
<td>
<p>Whether to use a transformed sample for the
computations. If <code>"no"</code> or <code>FALSE</code>, it doesn't. If
<code>"mu"</code> or <code>TRUE</code>, it uses the samples for the mean. If
<code>"wo"</code> it uses an alternative transformation. The latter
can be used only for the families indicated by
<code>.geoBayes_models$haswo</code>. The input can also be a vector
(of the same length as <code>runs</code> to allow for different
transformation to be used when evaluating each likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the joint log likelihood log f(y,T(z)|parameters) where
T(z) is the transformation, for each (y,z) in runs and for parameters
in runs up to a constant which does not depend on the parameters.
The parameters beta and sigma^2 are integrated out.
</p>


<h3>Value</h3>

<p>A matrix with number of rows the total number of samples
in runs and number of columns the length of <code>runs</code>. The
[i,j] element of the matrix is the value of the loglikelihood at
the ith sample when all samples in <code>runs</code> are put together evaluated
at the jth parameter value.
</p>

<hr>
<h2 id='stackdata'>Combine <code>data.frame</code>s</h2><span id='topic+stackdata'></span>

<h3>Description</h3>

<p>Combine <code>data.frame</code>s
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackdata(..., fillwith = NA, keepclass = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackdata_+3A_...">...</code></td>
<td>
<p><code>data.frame</code>s or objects that can be coerced to
<code>data.frame</code>s</p>
</td></tr>
<tr><td><code id="stackdata_+3A_fillwith">fillwith</code></td>
<td>
<p>Which value to use for missing variables. This
could be a scalar, a named vector, or a named list with one value
in each component; see Details.</p>
</td></tr>
<tr><td><code id="stackdata_+3A_keepclass">keepclass</code></td>
<td>
<p>Whether to preserve the <code><a href="base.html#topic+class">class</a></code>
of each variable. The elements in <code>fillwith</code> are coerced to
the corresponding variable's class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines <code>data.frame</code>s by filling in missing
variables. This is useful for combining data from
sampled locations with prediction locations.
</p>
<p>If <code>fillwith</code> is a named object, its names must correspond to
the names of variables in the data frames. If a variable is
missing, then it is filled with the corresponding value in
<code>fillwith</code>. <code>fillwith</code> can contain only one unnamed
component which corresponds to the default filling.
</p>


<h3>Value</h3>

<p>A stacked <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d1 &lt;- data.frame(w = 1:3, z = 4:6 + 0.1)
d2 &lt;- data.frame(w = 3:7, x = 1:5, y = 6:10)
(d12a &lt;- stackdata(d1, d2))
lapply(d12a, class)
(d12b &lt;- stackdata(d1, d2, fillwith = c(x = NA, y = 0, z = -99)))
lapply(d12b, class)
(d12c &lt;- stackdata(d1, d2, fillwith = c(x = NA, y = 0, z = -99),
                   keepclass = TRUE))
lapply(d12c, class)
(d12d &lt;- stackdata(d1, d2, fillwith = c(x = NA, 0)))

data(rhizoctonia)
predgrid &lt;- mkpredgrid2d(rhizoctonia[c("Xcoord", "Ycoord")],
                         par.x = 100, chull = TRUE, exf = 1.2)
rhizdata &lt;- stackdata(rhizoctonia, predgrid$grid)

## End(Not run)
</code></pre>

<hr>
<h2 id='subset.geomcmc'>Subset MCMC chain</h2><span id='topic+subset.geomcmc'></span>

<h3>Description</h3>

<p>Return subset of MCMC chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geomcmc'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.geomcmc_+3A_x">x</code></td>
<td>
<p>Output from the functions <code><a href="#topic+mcsglmm">mcsglmm</a></code> or
<code><a href="#topic+mcstrga">mcstrga</a></code>.</p>
</td></tr>
<tr><td><code id="subset.geomcmc_+3A_subset">subset</code></td>
<td>
<p>Logical or integer vector.</p>
</td></tr>
<tr><td><code id="subset.geomcmc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A similar object as <code>x</code> with the subsetted chain.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
