<!DOCTYPE html><html lang="en"><head><title>Help for package kazaam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kazaam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kazaam-package'><p>Tall Matrices</p></a></li>
<li><a href='#arithmetic'><p>Arithmetic Operators</p></a></li>
<li><a href='#bracket'><p>subsetting</p></a></li>
<li><a href='#cbind.shaq'><p>cbind</p></a></li>
<li><a href='#col_ops'><p>Column Operations</p></a></li>
<li><a href='#collapse'><p>collapse</p></a></li>
<li><a href='#cov'><p>Covariance and Correlation</p></a></li>
<li><a href='#crossprod'><p>Matrix Multiplication</p></a></li>
<li><a href='#expand'><p>expand</p></a></li>
<li><a href='#getters'><p>getters</p></a></li>
<li><a href='#glms'><p>Generalized Linear Model Fitters</p></a></li>
<li><a href='#is.shaq'><p>is.shaq</p></a></li>
<li><a href='#lm_coefs'><p>Linear Model Coefficients</p></a></li>
<li><a href='#matmult'><p>Matrix Multiplication</p></a></li>
<li><a href='#norm'><p>norm</p></a></li>
<li><a href='#prcomp'><p>Principal Components Analysis</p></a></li>
<li><a href='#print'><p>print</p></a></li>
<li><a href='#qr'><p>QR Decomposition Methods</p></a></li>
<li><a href='#ranshaq'><p>ranshaq</p></a></li>
<li><a href='#scale'><p>Scale</p></a></li>
<li><a href='#setters'><p>setters</p></a></li>
<li><a href='#shaq'><p>shaq</p></a></li>
<li><a href='#shaq-class'><p>Class shaq</p></a></li>
<li><a href='#svd'><p>svd</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Tall Distributed Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-0</td>
</tr>
<tr>
<td>Description:</td>
<td>Many data science problems reduce to operations on very tall,
    skinny matrices.  However, sometimes these matrices can be so tall that they
    are difficult to work with, or do not even fit into main memory.  One
    strategy to deal with such objects is to distribute their rows across
    several processors.  To this end, we offer an 'S4' class for tall, skinny,
    distributed matrices, called the 'shaq'.  We also provide many useful
    numerical methods and statistics operations for operating on these
    distributed objects.  The naming is a bit "tongue-in-cheek", with the class
    a play on the fact that 'Shaquille' 'ONeal' ('Shaq') is very tall, and he
    starred in the film 'Kazaam'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD 2-clause License</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), pbdMPI (&ge; 0.3-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://r-pbd.org/">http://r-pbd.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://group.r-pbd.org/">http://group.r-pbd.org/</a></td>
</tr>
<tr>
<td>MailingList:</td>
<td>Please send questions and comments regarding pbdR to
RBigData@gmail.com</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Drew Schmidt &lt;wrathematics@gmail.com&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-06-26 17:12:17 UTC; mschmid3</td>
</tr>
<tr>
<td>Author:</td>
<td>Drew Schmidt [aut, cre],
  Wei-Chen Chen [aut],
  Mike Matheson [aut],
  George Ostrouchov [aut],
  ORNL [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-06-29 13:19:58 UTC</td>
</tr>
</table>
<hr>
<h2 id='kazaam-package'>Tall Matrices</h2><span id='topic+kazaam-package'></span>

<h3>Description</h3>

<p>Many data science problems reduce to operations on very tall,
skinny matrices.  However, sometimes these matrices can be so tall that they
are difficult to work with, or do not even fit into main memory.  One
strategy to deal with such objects is to distribute their rows across
several processors.  To this end, we offer an 'S4' class for tall, skinny,
distributed matrices, called the 'shaq'.  We also provide many useful
numerical methods and statistics operations for operating on these
distributed objects.  The naming is a bit &quot;tongue-in-cheek&quot;, with the class
a play on the fact that 'Shaquille' 'ONeal' ('Shaq') is very tall, and he
starred in the film 'Kazaam'.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt <a href="mailto:wrathematics@gmail.com">wrathematics@gmail.com</a>, Wei-Chen Chen, Mike Matheson, and George Ostrouchov.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website: <a href="http://r-pbd.org/">http://r-pbd.org/</a>
</p>

<hr>
<h2 id='arithmetic'>Arithmetic Operators</h2><span id='topic+arithmetic'></span><span id='topic++2B+2Cshaq+2Cshaq-method'></span><span id='topic++2B+2Cshaq+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2Cshaq-method'></span><span id='topic+-+2Cshaq+2Cshaq-method'></span><span id='topic+-+2Cshaq+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2Cshaq-method'></span><span id='topic++2A+2Cshaq+2Cshaq-method'></span><span id='topic++2A+2Cshaq+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2Cshaq-method'></span><span id='topic++2F+2Cshaq+2Cshaq-method'></span><span id='topic++2F+2Cshaq+2Cnumeric-method'></span><span id='topic++2F+2Cnumeric+2Cshaq-method'></span>

<h3>Description</h3>

<p>Some binary arithmetic operations for shaqs.  All operations are
vector-shaq or shaq-vector, but not shaq-shaq.  See details section for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq,shaq'
e1 + e2

## S4 method for signature 'shaq,numeric'
e1 + e2

## S4 method for signature 'numeric,shaq'
e1 + e2

## S4 method for signature 'shaq,shaq'
e1 - e2

## S4 method for signature 'shaq,numeric'
e1 - e2

## S4 method for signature 'numeric,shaq'
e1 - e2

## S4 method for signature 'shaq,shaq'
e1 * e2

## S4 method for signature 'shaq,numeric'
e1 * e2

## S4 method for signature 'numeric,shaq'
e1 * e2

## S4 method for signature 'shaq,shaq'
e1 / e2

## S4 method for signature 'shaq,numeric'
e1 / e2

## S4 method for signature 'numeric,shaq'
e1 / e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arithmetic_+3A_e1">e1</code>, <code id="arithmetic_+3A_e2">e2</code></td>
<td>
<p>A shaq or a numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For binary operations involving two shaqs, they must be distributed
<em>identically</em>.
</p>


<h3>Value</h3>

<p>A shaq.
</p>


<h3>Communication</h3>

<p>Each operation is completely local.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)
y = ranshaq(runif, 10, 3)

x + y
x / 2
y + 1

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='bracket'>subsetting</h2><span id='topic+bracket'></span><span id='topic++5B+2Cshaq-method'></span><span id='topic++5B+3C-+2Cshaq-method'></span>

<h3>Description</h3>

<p>Subsetting via <code>`[`</code> for shaq objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq'
x[i, j]

## S4 replacement method for signature 'shaq'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bracket_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="bracket_+3A_i">i</code>, <code id="bracket_+3A_j">j</code></td>
<td>
<p>Indices.  NOTE currently only implemented for <code>j</code> values.</p>
</td></tr>
<tr><td><code id="bracket_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="bracket_+3A_value">value</code></td>
<td>
<p>Replacement value(s) for the <code>[&lt;-</code> method.  This can either be an
appropriately sized numeric value or a shaq.  See the details section for
more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shaq.
</p>


<h3>Communication</h3>

<p>Each operation is completely local.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)
y = x[, -1]
y

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='cbind.shaq'>cbind</h2><span id='topic+cbind.shaq'></span>

<h3>Description</h3>

<p>Column binding for shaqs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'shaq'
cbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind.shaq_+3A_...">...</code></td>
<td>
<p>A collection of shaqs.</p>
</td></tr>
<tr><td><code id="cbind.shaq_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All shaqs should have the same number of rows.  Additionally, all shaqs
should be distributed in identical fashion.
</p>


<h3>Value</h3>

<p>A shaq.
</p>


<h3>Communication</h3>

<p>The operation is completely local.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)
y = ranshaq(runif, 10, 1)

cbind(x, y)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='col_ops'>Column Operations</h2><span id='topic+col_ops'></span><span id='topic+colSums+2Cshaq-method'></span><span id='topic+colMeans+2Cshaq-method'></span>

<h3>Description</h3>

<p>Column operations (currently sums/means) for shaq objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq'
colSums(x, na.rm = FALSE, dims = 1L)

## S4 method for signature 'shaq'
colMeans(x, na.rm = FALSE, dims = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col_ops_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="col_ops_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code>'s be removed?</p>
</td></tr>
<tr><td><code id="col_ops_+3A_dims">dims</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A regular vector.
</p>


<h3>Communication</h3>

<p>The operation consists of a local column sum operation, followed by an
<code>allreduce()</code> call, quadratic on the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)
cs = colSums(x)
comm.print(cs)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='collapse'>collapse</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>Collapse a shaq into a regular matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only rank 0 will own the matrix on return.
</p>


<h3>Value</h3>

<p>A regular matrix (rank 0) or <code>NULL</code> (everyone else).
</p>


<h3>Communication</h3>

<p>Short answer: quite a bit.  Each local submatrix has to be sent to rank 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
dx = ranshaq(runif, 10, 3)

x = collapse(dx)
comm.print(x)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='cov'>Covariance and Correlation</h2><span id='topic+cov'></span><span id='topic+cov+2Cshaq-method'></span><span id='topic+cor+2Cshaq-method'></span>

<h3>Description</h3>

<p>Covariance and (pearson) correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq'
cov(x, y = NULL, use = "everything", method = "pearson")

## S4 method for signature 'shaq'
cor(x, y = NULL, use = "everything", method = "pearson")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="cov_+3A_y">y</code></td>
<td>
<p>At this time, this must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cov_+3A_use">use</code></td>
<td>
<p>NA handling rules, as with R's cov/cor functions.  At this time, only
&quot;everything&quot; is supported.</p>
</td></tr>
<tr><td><code id="cov_+3A_method">method</code></td>
<td>
<p>The cov/cor method. Currently only &quot;pearson&quot; is available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A regular matrix.
</p>


<h3>Communication</h3>

<p>The operation is completely local except for forming the crossproduct, which
is an <code>allreduce()</code> call, quadratic on the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)

cov(x)
cor(x)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='crossprod'>Matrix Multiplication</h2><span id='topic+crossprod'></span><span id='topic+crossprod+2Cshaq-method'></span>

<h3>Description</h3>

<p>Conceptually, this computes <code>t(x) %*% x</code> for a shaq <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq'
crossprod(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossprod_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="crossprod_+3A_y">y</code></td>
<td>
<p>Must be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A regular matrix.
</p>


<h3>Communication</h3>

<p>The operation consists of a local crossproduct, followed by an
<code>allreduce()</code> call, quadratic on the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)

cp = crossprod(x)
comm.print(cp)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='expand'>expand</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>Expand a regular matrix owned on MPI rank 0 into a shaq.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_+3A_x">x</code></td>
<td>
<p>A regular matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shaq.
</p>


<h3>Communication</h3>

<p>Short answer: quite a bit.  Each local submatrix has to be received from rank
0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
if (comm.rank() == 0){
  x = matrix(runif(30), 10, 3)
} else {
  x = NULL
}

dx = expand(x)
dx

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='getters'>getters</h2><span id='topic+getters'></span><span id='topic+nrow+2Cshaq-method'></span><span id='topic+NROW+2Cshaq-method'></span><span id='topic+nrow.local'></span><span id='topic+nrow.local+2Cshaq-method'></span><span id='topic+ncol+2Cshaq-method'></span><span id='topic+NCOL+2Cshaq-method'></span><span id='topic+ncol.local'></span><span id='topic+ncol.local+2Cshaq-method'></span><span id='topic+length+2Cshaq-method'></span><span id='topic+Data'></span><span id='topic+Data+2Cshaq-method'></span>

<h3>Description</h3>

<p>Getters for shaq objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq'
nrow(x)

## S4 method for signature 'shaq'
NROW(x)

nrow.local(x)

## S4 method for signature 'shaq'
nrow.local(x)

## S4 method for signature 'shaq'
ncol(x)

## S4 method for signature 'shaq'
NCOL(x)

ncol.local(x)

## S4 method for signature 'shaq'
ncol.local(x)

## S4 method for signature 'shaq'
length(x)

Data(x)

## S4 method for signature 'shaq'
Data(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getters_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to return the number of rows (<code>nrow()</code> and <code>NROW()</code>),
the number of columns (<code>ncol()</code> and <code>NCOL()</code>), the length - or
product of the number of rows and cols - (<code>length()</code>), and the local
submatrix (<code>Data()</code>).
</p>


<h3>Communication</h3>

<p>Each operation is completely local.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setters">setters</a></code>
</p>

<hr>
<h2 id='glms'>Generalized Linear Model Fitters</h2><span id='topic+glms'></span><span id='topic+reg.fit'></span><span id='topic+logistic.fit'></span><span id='topic+poisson.fit'></span>

<h3>Description</h3>

<p>Linear regression (Gaussian GLM), logistic regression, and poisson
regression model fitters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg.fit(x, y, maxiter = 100)

logistic.fit(x, y, maxiter = 100)

poisson.fit(x, y, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glms_+3A_x">x</code>, <code id="glms_+3A_y">y</code></td>
<td>
<p>The input data <code>x</code> and response <code>y</code>.  Each must be a shaq, and
each must be distributed in an identical fashion.  See the details section
for more information.</p>
</td></tr>
<tr><td><code id="glms_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each function is implemented with gradient descent using the conjugate
gradients method (&quot;CG&quot;) of the <code>optim()</code> function.
</p>
<p>Both of <code>x</code> and <code>y</code> must be distributed in an identical fashion.
This means that the number of rows owned by each MPI rank should match, and
the data rows <code>x</code> and response rows <code>y</code> should be aligned.
Additionally, each MPI rank should own at least one row.  Ideally they should
be load balanced, so that each MPI rank owns roughly the same amount of data.
</p>


<h3>Value</h3>

<p>The return is the output of an <code>optim()</code> call.
</p>


<h3>Communication</h3>

<p>The communication consists of an allreduce of 1 double (the local
cost/objective function value) at each iteration of the optimization.
</p>


<h3>References</h3>

<p>McCullagh, P. and Nelder, J.A., 1989. Generalized Linear Models, no. 37 in
Monograph on Statistics and Applied Probability.
</p>
<p>Duda, R.O., Hart, P.E. and Stork, D.G., 1973. Pattern classification (pp.
526-528). Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm_coefs">lm_coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
comm.set.seed(1234, diff=TRUE)

x = ranshaq(rnorm, 10, 3)
y = ranshaq(function(i) sample(0:1, size=i, replace=TRUE), 10)

fit = logistic.fit(x, y)
comm.print(fit)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='is.shaq'>is.shaq</h2><span id='topic+is.shaq'></span>

<h3>Description</h3>

<p>Test if an object is a shaq.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.shaq(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.shaq_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value, indicating whether or not the input is a shaq.
</p>


<h3>Communication</h3>

<p>The operation is completely local.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)

comm.print(is.shaq(x))

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='lm_coefs'>Linear Model Coefficients</h2><span id='topic+lm_coefs'></span>

<h3>Description</h3>

<p>Coefficients of the linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_coefs(x, y, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm_coefs_+3A_x">x</code>, <code id="lm_coefs_+3A_y">y</code></td>
<td>
<p>The input data <code>x</code> and response <code>y</code>.  Each must be a shaq, and
each must be distributed in an identical fashion.  See the details section
for more information.</p>
</td></tr>
<tr><td><code id="lm_coefs_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance for deciding rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fit using a QR factorization of the input <code>x</code>. At this
time, that means 
</p>
<p>Both of <code>x</code> and <code>y</code> must be distributed in an identical fashion.
This means that the number of rows owned by each MPI rank should match, and
the data rows <code>x</code> and labels <code>y</code> should be aligned.  Additionally,
each MPI rank should own at least one row.  Ideally they should be load
balanced, so that each MPI rank owns roughly the same amount of data.
</p>


<h3>Value</h3>

<p>A regular vector.
</p>


<h3>Communication</h3>

<p>The operation has the same communication as
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glms">glms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
comm.set.seed(1234, diff=TRUE)

x = ranshaq(rnorm, 10, 3)
y = ranshaq(runif, 10)

fit = lm_coefs(x, y)
comm.print(fit)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='matmult'>Matrix Multiplication</h2><span id='topic+matmult'></span><span id='topic++25+2A+25+2Cshaq+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Multiplies two distributed matrices, if they are conformable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq,matrix'
x %*% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matmult_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="matmult_+3A_y">y</code></td>
<td>
<p>A regular matrix, globally ownd on all ranks.  Since the number of columns
of a shaq should be small, this matrix should be small as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two shaqs must be distributed <em>identically</em>.
</p>


<h3>Value</h3>

<p>A shaq.
</p>


<h3>Communication</h3>

<p>The operation is completely local.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)
y = matrix(1:9, 3, 3)

x %*% y

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='norm'>norm</h2><span id='topic+norm'></span><span id='topic+norm+2Cshaq+2CANY-method'></span>

<h3>Description</h3>

<p>Implementation of R's <code>norm()</code> function for shaq objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq,ANY'
norm(x, type = c("O", "I", "F", "M", "2"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_+3A_x">x</code></td>
<td>
<p>A shaq</p>
</td></tr>
<tr><td><code id="norm_+3A_type">type</code></td>
<td>
<p>The type of norm: one, infinity, frobenius, max-modulus, and spectral.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type == "O"</code> then the norm is calculated as the maximum of the
column sums.
</p>
<p>If <code>type == "I"</code> then the norm is calculated as the maximum absolute
value of the row sums.
</p>
<p>If <code>type == "F"</code> then the norm is calculated as the square root of the
sum of the square of the values of the matrix.
</p>
<p>If <code>type == "M"</code> then the norm is calculated as the max of the absolute
value of the values of the matrix.
</p>
<p>If <code>type == "2"</code> then the norm is calculated as the largest singular
value.
</p>


<h3>Value</h3>

<p>A number (length 1 regular vector).
</p>


<h3>Communication</h3>

<p>If <code>type == "O"</code> then the communication consists of an allreduce,
quadratic on the number of columns.
</p>
<p>If <code>type == "I"</code> then the communication conists of an allgather.
</p>
<p>If <code>type == "F"</code> then the communication is an allreduce, quadratic on
the number of columns.
</p>
<p>If <code>type == "M"</code> then the communication consists of an allgather.
</p>
<p>If <code>type == "2"</code> then the communication consists of the same as that of
an <code>svd()</code> call:  an allreduce, quadratic on the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)

nm = norm(x)
comm.print(nm)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='prcomp'>Principal Components Analysis</h2><span id='topic+prcomp'></span><span id='topic+prcomp.shaq'></span>

<h3>Description</h3>

<p>Performs the principal components analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'shaq'
prcomp(x, retx = TRUE, center = TRUE, scale. = FALSE,
  tol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prcomp_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="prcomp_+3A_retx">retx</code></td>
<td>
<p>Should the rotated variables be returned?</p>
</td></tr>
<tr><td><code id="prcomp_+3A_center">center</code></td>
<td>
<p>Should columns are zero centered?</p>
</td></tr>
<tr><td><code id="prcomp_+3A_scale.">scale.</code></td>
<td>
<p>Should columns are rescaled to unit variance?</p>
</td></tr>
<tr><td><code id="prcomp_+3A_tol">tol</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="prcomp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prcomp()</code> performs the principal components analysis on the data
matrix by taking the SVD. Sometimes core R and kazaam will disagree
slightly in what the rotated variables are because of how the SVD is
caluclated.
</p>


<h3>Value</h3>

<p>A list of elements <code>sdev</code>, <code>rotation</code>, <code>center</code>, <code>scale</code>,
and <code>x</code>, as with R's own <code>prcomp()</code>.  The elements are,
respectively, a regular vector, a regular matrix, a regular vector, a regular
vector, and a shaq.
</p>


<h3>Communication</h3>

<p>The communication is an <code>allreduce()</code> call, quadratic on the number of
columns.  Most of the run time should be dominated by relatively expensive
local operations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)
pca = prcomp(x)

comm.print(pca)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='print'>print</h2><span id='topic+print'></span><span id='topic+print+2Cshaq-method'></span><span id='topic+show+2Cshaq-method'></span>

<h3>Description</h3>

<p>Print method for a shaq.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq'
print(x, ...)

## S4 method for signature 'shaq'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code>, <code id="print_+3A_object">object</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Communication</h3>

<p>The operation is completely local.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = shaq(1, 10, 3)

x # same as print(x) or comm.print(x)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='qr'>QR Decomposition Methods</h2><span id='topic+qr'></span><span id='topic+qr_R'></span><span id='topic+qr_Q'></span>

<h3>Description</h3>

<p>QR factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qr_R(x)

qr_Q(x, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qr_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="qr_+3A_r">R</code></td>
<td>
<p>A regular matrix. This argument is optional, in that if it is not supplied
explicitly, then it will be computed in the background.  But if have already
computed R, supplying it here will improve performance (by avoiding
needlessly recomputing it).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">R</code> is formed by first forming the crossproduct <code class="reqn">X^T X</code> and taking
its Cholesky factorization.  But then <code class="reqn">Q = X R^{-1}</code>.  Inverting <code class="reqn">R</code>
is handled by an efficient triangular inverse routine.
</p>


<h3>Value</h3>

<p>Q (a shaq) or R (a regular matrix).
</p>


<h3>Communication</h3>

<p>The operation is completely local except for forming the crossproduct, which
is an <code>allreduce()</code> call, quadratic on the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)

R = qr_R(x)
comm.print(R)

Q = qr_Q(x, R)
Q

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='ranshaq'>ranshaq</h2><span id='topic+ranshaq'></span>

<h3>Description</h3>

<p>Generate a random shaq object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranshaq(generator, nrows, ncols, local = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranshaq_+3A_generator">generator</code></td>
<td>
<p>A function, such as <code>runif()</code> or <code>rnorm()</code> (passed without parens).
See examples for a demonstration of usage.</p>
</td></tr>
<tr><td><code id="ranshaq_+3A_nrows">nrows</code>, <code id="ranshaq_+3A_ncols">ncols</code></td>
<td>
<p>The number of rows</p>
</td></tr>
<tr><td><code id="ranshaq_+3A_local">local</code></td>
<td>
<p>Is the problem size <code>nrows*ncols</code> specifying the local or global problem
size?</p>
</td></tr>
<tr><td><code id="ranshaq_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shaq.
</p>


<h3>Communication</h3>

<p>The operation is entirely local.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)

# a 10x3 shaq with random uniform data
x = ranshaq(runif, 10, 3)
x

# a (comm.size() * 10)x3 shaq with random normal data
y = ranshaq(rnorm, 10, 3, local=TRUE)
y

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='scale'>Scale</h2><span id='topic+scale'></span><span id='topic+scale+2Cshaq+2Clogical+2Clogical-method'></span>

<h3>Description</h3>

<p>Centers and/or scales the columns of a distributed matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale(x, center = TRUE, scale = TRUE)

## S4 method for signature 'shaq,logical,logical'
scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="scale_+3A_center">center</code></td>
<td>
<p>logical value, determines whether or not columns are zero centered</p>
</td></tr>
<tr><td><code id="scale_+3A_scale">scale</code></td>
<td>
<p>logical value, determines whether or not columns are rescaled to unit variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shaq.
</p>


<h3>Communication</h3>

<p>The communication consists of two allreduce calls, each quadratic on the
number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(rnorm, 10, 3, mean=30, sd=10)

x
scale(x)

finalize()

## End(Not run)

</code></pre>

<hr>
<h2 id='setters'>setters</h2><span id='topic+setters'></span><span id='topic+Data+3C-'></span><span id='topic+Data+3C-+2Cshaq-method'></span><span id='topic+DATA+3C-'></span><span id='topic+DATA+3C-+2Cshaq-method'></span>

<h3>Description</h3>

<p>Setter functions for shaq objects.  Generally not recommended unless you are
sure you know what you're doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Data(x) &lt;- value

## S4 replacement method for signature 'shaq'
Data(x) &lt;- value

DATA(x) &lt;- value

## S4 replacement method for signature 'shaq'
DATA(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setters_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="setters_+3A_value">value</code></td>
<td>
<p>The new data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Data&lt;-</code> will perform checks on the inserted data and ensure that the
number of columns match across processors (requiring communication).  It will
also udpate the number of rows as necessary.
</p>
<p><code>DATA&lt;-</code> will perform no checks, so use only if you're really sure that
you know what you're doing.
</p>


<h3>Communication</h3>

<p>With <code>Data&lt;-</code>, a check on the global number of rows is performed.  This
amounts to an allgather operation on a logical value (the local dimension
check).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getters">getters</a></code>, <code><a href="#topic+bracket">bracket</a></code>
</p>

<hr>
<h2 id='shaq'>shaq</h2><span id='topic+shaq'></span><span id='topic+shaq.matrix'></span><span id='topic+shaq.numeric'></span>

<h3>Description</h3>

<p>Constructor for shaq objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shaq(Data, nrows, ncols, checks = TRUE)

## S3 method for class 'matrix'
shaq(Data, nrows, ncols, checks = TRUE)

## S3 method for class 'numeric'
shaq(Data, nrows, ncols, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shaq_+3A_data">Data</code></td>
<td>
<p>The local submatrix.</p>
</td></tr>
<tr><td><code id="shaq_+3A_nrows">nrows</code>, <code id="shaq_+3A_ncols">ncols</code></td>
<td>
<p>The GLOBAL number of rows and columns.</p>
</td></tr>
<tr><td><code id="shaq_+3A_checks">checks</code></td>
<td>
<p>Logical. Should some basic dimension checks be performed?  Note that these
require communication, and with many MPI ranks, could be expensive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nrows</code> and/or <code>ncols</code> is missing, then it will be imputed.
This means one must be especially careful to manually provide <code>ncols</code>
if some of ranks have &quot;placeholder data&quot; (a 0x0 matrix), which is typical
when reading from a subset of processors and then broadcasting out to the
remainder.
</p>


<h3>Communication</h3>

<p>If <code>checks=TRUE</code>, a check on the global number of rows is performed.
This amounts to an allgather operation on a logical value (the local
dimension check).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shaq-class">shaq-class</a></code>
</p>

<hr>
<h2 id='shaq-class'>Class shaq</h2><span id='topic+shaq-class'></span>

<h3>Description</h3>

<p>An S4 container for a distributed tall/skinny matrix.
</p>


<h3>Details</h3>

<p>The (conceptual) global (non-distributed) matrix should be distributed by
row, meaning that each submatrix should own all of the columns of the global
matrix.  Most methods assume no other real structure, however for best
performance (and for the methods which require it), one should try to
organize their distributed data in a particular way.
</p>
<p>First, adjacent MPI ranks should hold adjacent rows.  So if the last row that
rank <code>k</code> owns is <code>i</code>, then the first row that rank <code>k+1</code> owns 
should be row <code>i+1</code>.  Additionally, any method that operates on two (or
more) shaq objects, the two shaqs should be distributed identically.  By this
we mean that if the number of rows shaq <code>A</code> owns on rank <code>k</code> is
<code>k_i</code>, then the number of rows shaq <code>B</code> owns on rank <code>k</code>
should also be <code>k_i</code>.
</p>
<p>Finally, for best performance, one should generally try to keep the number of
rows &quot;balanced&quot; (roughly equal) across processes, with perhaps the last &quot;few&quot;
having one less row than the others.
</p>


<h3>Slots</h3>


<dl>
<dt><code>DATA</code></dt><dd><p>The local submatrix.</p>
</dd>
<dt><code>nrows,</code></dt><dd><p>ncols
The global matrix dimension.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+shaq">shaq</a></code>
</p>

<hr>
<h2 id='svd'>svd</h2><span id='topic+svd'></span><span id='topic+svd+2Cshaq-method'></span>

<h3>Description</h3>

<p>Singular value decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'shaq'
svd(x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svd_+3A_x">x</code></td>
<td>
<p>A shaq.</p>
</td></tr>
<tr><td><code id="svd_+3A_nu">nu</code></td>
<td>
<p>number of left singular vectors to return.</p>
</td></tr>
<tr><td><code id="svd_+3A_nv">nv</code></td>
<td>
<p>number of right singular vectors to return.</p>
</td></tr>
<tr><td><code id="svd_+3A_linpack">LINPACK</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorization works by first forming the crossproduct <code class="reqn">X^T X</code>
and then taking its eigenvalue decomposition.  In this case, the square root
of the eigenvalues are the singular values.  If the left/right singular
vectors <code class="reqn">U</code> or <code class="reqn">V</code> are desired, then in either case, <code class="reqn">V</code> is
computed (the eigenvectors).  From these, <code class="reqn">U</code> can be reconstructed, since
if <code class="reqn">X = U\Sigma V^T</code>, then <code class="reqn">U = XV\Sigma^{-1}</code>.
</p>


<h3>Value</h3>

<p>A list of elements <code>d</code>, <code>u</code>, and <code>v</code>, as with R's own
<code>svd()</code>.  The elements are, respectively, a regular vector, a shaq, and
a regular matrix.
</p>


<h3>Communication</h3>

<p>The operation is completely local except for forming the crossproduct, which
is an <code>allreduce()</code> call, quadratic on the number of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(kazaam)
x = ranshaq(runif, 10, 3)

svd = svd(x)
comm.print(svd$d) # a globally owned vector
svd$u # a shaq
comm.print(svd$v) # a globally owned matrix

finalize()

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
