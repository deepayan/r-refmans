<!DOCTYPE html><html><head><title>Help for package netcmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netcmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netcmc-package'>
<p>An R Package for Bayesian Social Network Modelling</p></a></li>
<li><a href='#getAdjacencyMatrix'>
<p>A function that extracts valuable properties from a raw social network.</p></a></li>
<li><a href='#getMembershipMatrix'>
<p>A function that generates a data.frame that is the membership matrix of the network.</p></a></li>
<li><a href='#getTotalAltersByStatus'>
<p>A function that generates a data.frame that stores the number of alters with a given level of a factor an individual has.</p></a></li>
<li><a href='#multiNet'>
<p>A function that generates samples for a multivariate fixed effects and network</p>
model.</a></li>
<li><a href='#multiNetLeroux'>
<p>A function that generates samples for a multivariate fixed effects, spatial,</p>
and network model.</a></li>
<li><a href='#multiNetRand'>
<p>A function that generates samples for a multivariate fixed effects, grouping,</p>
and network model.</a></li>
<li><a href='#plot.netcmc'>
<p>A function that plots visual MCMC diagnostics of the fitted model.</p></a></li>
<li><a href='#print.netcmc'>
<p>A function that gets a summary of the fitted model.</p></a></li>
<li><a href='#summary.netcmc'>
<p>A function that gets a summary of the fitted model.</p></a></li>
<li><a href='#uni'>
<p>A function that generates samples for a univariate fixed effects model.</p></a></li>
<li><a href='#uniNet'>
<p>A function that generates samples for a univariate network model.</p></a></li>
<li><a href='#uniNetLeroux'>
<p>A function that generates samples for a univariate network Leroux model.</p></a></li>
<li><a href='#uniNetRand'>
<p>A function that generates samples for a univariate network group model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatio-Network Generalised Linear Mixed Models for Areal Unit
and Network Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-07</td>
</tr>
<tr>
<td>Author:</td>
<td>George Gerogiannis, Mark Tranmer, Duncan Lee</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Gerogiannis &lt;g.gerogiannis.1@research.gla.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a class of univariate and multivariate spatio-network generalised linear mixed models for areal unit and network data, with inference in a Bayesian setting using Markov chain Monte Carlo (MCMC) simulation. The response variable can be binomial, Gaussian, or Poisson. Spatial autocorrelation is modelled by a set of random effects that are assigned a conditional autoregressive (CAR) prior distribution following the Leroux model (Leroux et al. (2000) &lt;<a href="https://doi.org/10.1007%2F978-1-4612-1284-3_4">doi:10.1007/978-1-4612-1284-3_4</a>&gt;). Network structures are modelled by a set of random effects that reflect a multiple membership structure (Browne et al. (2001) &lt;<a href="https://doi.org/10.1177%2F1471082X0100100202">doi:10.1177/1471082X0100100202</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), MCMCpack</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.4), coda, ggplot2, mvtnorm, MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, igraph, magic</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-08 20:35:53 UTC; georg</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-08 22:30:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='netcmc-package'>
An R Package for Bayesian Social Network Modelling
</h2><span id='topic+netcmc-package'></span><span id='topic+netcmc'></span>

<h3>Description</h3>

<p>Implements a class of univariate and multivariate spatio-network generalised linear mixed 
models, with inference in a Bayesian setting using Markov chain 
Monte Carlo (MCMC) simulation. The response variable can be binomial, Gaussian, and Poisson.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> netcmc</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-01-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>George Gerogiannis &lt;g.gerogiannis.1@research.gla.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## See the examples in the function specific help files.
</code></pre>

<hr>
<h2 id='getAdjacencyMatrix'>
A function that extracts valuable properties from a raw social network.
</h2><span id='topic+getAdjacencyMatrix'></span>

<h3>Description</h3>

<p>This function transforms a network, which is a data.frame type in a specified format, in to a resultant <code class="reqn">n</code> by <code class="reqn">n</code> adjacency matrix, where <code class="reqn">a_{ij}</code> = 0 if vertex <code class="reqn">i</code> and <code class="reqn">j</code> (<code class="reqn">i \neq j</code>) are not adjacent i.e. vertex <code class="reqn">i</code> and <code class="reqn">j</code> are not the head/tail of an edge <code class="reqn">e</code> and <code class="reqn">a_{ij}</code> = 1 if vertex <code class="reqn">i</code> and <code class="reqn">j</code> (<code class="reqn">i \neq j</code>) are adjacent i.e. vertex <code class="reqn">i</code> and <code class="reqn">j</code> are the head/tail of an edge <code class="reqn">e</code>. <code class="reqn">a_{ij}</code> = 0 when <code class="reqn">i = j</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAdjacencyMatrix(rawNetwork)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAdjacencyMatrix_+3A_rawnetwork">rawNetwork</code></td>
<td>

<p>The data.frame which encodes information about the network. The dimensions of the matrix are <code class="reqn">n</code> by <code class="reqn">(l+1)</code>.The data.frame contains one column corresponding to the labels for each of the <code class="reqn">n</code> vertices in the network, the column name for this should be &lsquo;labels&rsquo;. The other <code class="reqn">l</code> columns corresponds to the corresponds to the vertices which are adjacent to each of the <code class="reqn">n</code> vertices in the network. It is important to note that the label of a vertex should not be 0. The <code class="reqn">n</code>th vertex can be adjacent to a maximum of <code class="reqn">l</code> other vertices.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>adjacencyMatrix</code></td>
<td>
<p>The resultant adjaceny matrix for the rawNetwork data.frame.</p>
</td></tr>
<tr><td><code>nonnominators</code></td>
<td>
<p>The individuals in the social network who are nominees of at least one other individual but were not in the set of individuals who did the nominating.</p>
</td></tr>
<tr><td><code>vertexNoOutdegrees</code></td>
<td>
<p>The individuals in the social network that have an outdegree of 0.</p>
</td></tr> 
<tr><td><code>vertexNoIndegrees</code></td>
<td>
<p>The individuals in the social network that have an indegree of 0.</p>
</td></tr> 
<tr><td><code>vertexIsolates</code></td>
<td>
<p>The individuals in the social network that have an outdegree and indegree of 0.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rawNetwork = matrix(NA, 4, 3)
rawNetwork = as.data.frame(rawNetwork)
colnames(rawNetwork)[1] = "labels"
rawNetwork[, 1] = c("A", "B", "C", "D")
rawNetwork[, 2] = c(0, "C", "D", 0)
rawNetwork[, 3] = c("B", 0, "A", "C")
getAdjacencyMatrix(rawNetwork)

rawNetwork = matrix(NA, 4, 3)
rawNetwork = as.data.frame(rawNetwork)
colnames(rawNetwork)[2] = "labels"
rawNetwork[, 1] = c(NA, "Charlie", "David", 0)
rawNetwork[, 2] = c("Alistar", "Bob", "Charlie", "David")
rawNetwork[, 3] = c("Bob", NA, "Alistar", "Charlie")
getAdjacencyMatrix(rawNetwork)

rawNetwork = matrix(NA, 4, 3)
rawNetwork = as.data.frame(rawNetwork)
colnames(rawNetwork)[1] = "labels"
rawNetwork[, 1] = c(245, 344, 234, 104)
rawNetwork[, 2] = c(NA, 234, 104, NA)
rawNetwork[, 3] = c(344, 0, 245, 234)
getAdjacencyMatrix(rawNetwork)

rawNetwork = matrix(NA, 4, 3)
rawNetwork = as.data.frame(rawNetwork)
colnames(rawNetwork)[1] = "labels"
rawNetwork[, 1] = c(245, 344, 234, 104)
rawNetwork[, 2] = c(32, 234, 104, 0)
rawNetwork[, 3] = c(344, 20, 245, 234)
getAdjacencyMatrix(rawNetwork)

rawNetwork = matrix(NA, 4, 3)
rawNetwork = as.data.frame(rawNetwork)
colnames(rawNetwork)[1] = "labels"
rawNetwork[, 1] = c("Alistar", "Bob", "Charlie", "David")
rawNetwork[, 2] = c(NA, "Charlie", "David", 0)
rawNetwork[, 3] = c("Bob", "Blaine", "Alistar", "Charlie")
getAdjacencyMatrix(rawNetwork)

rawNetwork = matrix(NA, 4, 3)
rawNetwork = as.data.frame(rawNetwork)
colnames(rawNetwork)[1] = "labels"
rawNetwork[, 1] = c("Alistar", "Bob", "Charlie", "David")
rawNetwork[, 2] = c(0, "Charlie", 0, 0)
rawNetwork[, 3] = c("Bob", "Blaine", "Alistar", 0)
getAdjacencyMatrix(rawNetwork)

rawNetwork = matrix(NA, 4, 3)
rawNetwork = as.data.frame(rawNetwork)
colnames(rawNetwork)[1] = "labels"
rawNetwork[, 1] = c(245, 344, 234, 104)
rawNetwork[, 2] = c(32, 0, 104, 0)
rawNetwork[, 3] = c(34, 0, 245, 234)
getAdjacencyMatrix(rawNetwork)
</code></pre>

<hr>
<h2 id='getMembershipMatrix'>
A function that generates a data.frame that is the membership matrix of the network.
</h2><span id='topic+getMembershipMatrix'></span>

<h3>Description</h3>

<p>A function that generates a data.frame that is the membership matrix of the network given individual IDs and the alters that they have nominated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getMembershipMatrix(individualID, alters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMembershipMatrix_+3A_individualid">individualID</code></td>
<td>

<p>A data.frame which stores the IDs of the individuals that nominate alters.
</p>
</td></tr>
<tr><td><code id="getMembershipMatrix_+3A_alters">alters</code></td>
<td>

<p>A data.frame which stores the alters of a given individual.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>membershipMatrix</code></td>
<td>
<p>The resultant data.frame.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  individualID = data.frame(c(1, 2, 3))
  alters = data.frame(c(5, 3, 2), c(5, 6, 1))
  getMembershipMatrix(individualID, alters)
  
  individualID = data.frame(c(1, 2, 3))
  alters = data.frame(c(NA, 3, 2), c(NA, NA, 1))
  getMembershipMatrix(individualID, alters)
  
  individualID = data.frame(c(1, 2, 3))
  alters = data.frame(c(NA, 3, NA), c(NA, NA, 1))
  getMembershipMatrix(individualID, alters)
  
  individualID = data.frame(c(1, 2, 3))
  alters = data.frame(c(NA, 3, NA), c(6, NA, 1))
  getMembershipMatrix(individualID, alters)
  
</code></pre>

<hr>
<h2 id='getTotalAltersByStatus'>
A function that generates a data.frame that stores the number of alters with a given level of a factor an individual has.
</h2><span id='topic+getTotalAltersByStatus'></span>

<h3>Description</h3>

<p>This is a function that can be used to generates a data.frame that stores the number of alters with a given level of a factor an individual has.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTotalAltersByStatus(individualID, status, alters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTotalAltersByStatus_+3A_individualid">individualID</code></td>
<td>

<p>A data.frame which stores the IDs of the individuals that nominate alters.
</p>
</td></tr>
<tr><td><code id="getTotalAltersByStatus_+3A_status">status</code></td>
<td>

<p>A data.frame which stores the levels of a variable.
</p>
</td></tr>
<tr><td><code id="getTotalAltersByStatus_+3A_alters">alters</code></td>
<td>

<p>A data.frame which stores the alters of a given individual.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>totalAltersByStatus</code></td>
<td>
<p>The resultant data.frame.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>individualID = data.frame(c(1, 2, 3, 4))
status = data.frame(c(10, 20, 30, 20))
alters = data.frame(c(4, 3, 2, 1), c(3, 4, 1, 2), c(2, 1, 4, 3))
totalAltersByStatus = getTotalAltersByStatus(individualID, status, alters)

individualID = data.frame(c(1, 2, 3, 4))
status = data.frame(c("RegularSmoke", "Nonsmoker", "CasualSmoker", "Nonsmoker"))
alters = data.frame(c(4, 3, 2, 1), c(3, 4, 1, 2), c(5, 1, 5, 3))
totalAltersByStatus = getTotalAltersByStatus(individualID, status, alters)

individualID = data.frame(c(1, 2, 3, 4))
status = data.frame(c(NA, "Nonsmoker", "CasualSmoker", "Nonsmoker"))
alters = data.frame(c(4, 3, 2, 1), c(3, 4, 1, 2), c(5, 1, 5, 3))
totalAltersByStatus = getTotalAltersByStatus(individualID, status, alters)

individualID = data.frame(c(10, 20))
status = data.frame(c(NA, "Nonsmoker"))
alters = data.frame(c(NA, 10), c(20, NA))
totalAltersByStatus = getTotalAltersByStatus(individualID, status, alters)

individualID = data.frame(c(NA, 20))
status = data.frame(c("Smoker", "Nonsmoker"))
alters = data.frame(c(NA, 10), c(20, NA))
totalAltersByStatus = getTotalAltersByStatus(individualID, status, alters)
</code></pre>

<hr>
<h2 id='multiNet'>
A function that generates samples for a multivariate fixed effects and network
model.
</h2><span id='topic+multiNet'></span>

<h3>Description</h3>

<p>This function that generates samples for a multivariate fixed effects and network
model, which is given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{i_sr}|\mu_{i_sr} \sim f(y_{i_sr}| \mu_{i_sr}, \sigma_{er}^{2}) ~~~ i=1,\ldots, N_{s},~s=1,\ldots,S ,~r=1,\ldots,R,</code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_{i_sr}) = \boldsymbol{x}^\top_{i_s} \boldsymbol{\beta}_{r} + \sum_{j\in \textrm{net}(i_s)}w_{i_sj}u_{jr}+ w^{*}_{i_s}u^{*}_{r},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta}_{r} \sim \textrm{N}(\boldsymbol{0}, \alpha\boldsymbol{I})</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{u}_{j} = (u_{1j},\ldots, u_{Rj}) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{u}^{*} = (u_{1}^*,\ldots, u_{R}^*) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}} \sim \textrm{Inverse-Wishart}(\xi_{\boldsymbol{u}}, \boldsymbol{\Omega}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{er}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{3}, \xi_{3}).</code>
</p>

<p>The covariates for the <code class="reqn">i</code>th individual in the <code class="reqn">s</code>th spatial unit or other grouping are included in a <code class="reqn">p \times 1</code> vector <code class="reqn">\boldsymbol{x}_{i_s}</code>. The corresponding <code class="reqn">p \times 1</code> vector of fixed effect parameters relating to the <code class="reqn">r</code>th response are denoted by <code class="reqn">\boldsymbol{\beta}_{r}</code>, which has an assumed multivariate Gaussian prior with mean <code class="reqn">\boldsymbol{0}</code> and diagonal covariance matrix <code class="reqn">\alpha\boldsymbol{I}</code> that can be chosen by the user. A conjugate Inverse-Gamma prior is specified for <code class="reqn">\sigma_{er}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{3}</code>, <code class="reqn">\xi_{3}</code>) can be chosen by the user.
</p>
<p>The <code class="reqn">R \times 1</code> vector of random effects for the <code class="reqn">j</code>th alter is denoted by <code class="reqn">\boldsymbol{u}_{j} = (u_{j1}, \ldots, u_{jR})_{R \times 1}</code>, while the <code class="reqn">R \times 1</code> vector of isolation effects for all <code class="reqn">R</code> outcomes is  denoted by <code class="reqn">\boldsymbol{u}^{*} = (u_{1}^*,\ldots, u_{R}^*)</code>, and both are assigned multivariate Gaussian prior distributions. The unstructured covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code> captures the covariance between the <code class="reqn">R</code> outcomes at the network level, and a conjugate Inverse-Wishart prior is specified for this covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code>. The corresponding hyperparamaterers (<code class="reqn">\xi_{\boldsymbol{u}}</code>, <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{u}}</code>) can be chosen by the user.
</p>
<p>The exact specification of each of the likelihoods (binomial, Gaussian, and Poisson) are given below:
</p>
<p style="text-align: center;"><code class="reqn">\textrm{Binomial:} ~ Y_{i_sr} \sim \textrm{Binomial}(n_{i_sr}, \theta_{i_sr}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \textrm{ln}(\theta_{i_sr} / (1 - \theta_{i_sr})),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Gaussian:} ~ Y_{i_sr} \sim \textrm{N}(\mu_{i_sr}, \sigma_{er}^{2}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \mu_{i_sr},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Poisson:} ~ Y_{i_sr} \sim \textrm{Poisson}(\mu_{i_sr}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \textrm{ln}(\mu_{i_sr}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>multiNet(formula, data, trials, family, W, numberOfSamples = 10, burnin = 0, 
thin = 1, seed = 1, trueBeta = NULL, trueURandomEffects = NULL, 
trueVarianceCovarianceU = NULL, trueSigmaSquaredE = NULL, 
covarianceBetaPrior = 10^5, xi, omega, a3 = 0.001, b3 = 0.001, 
centerURandomEffects = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiNet_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using a similar 
syntax to that used in the lm() function.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the variables in the formula.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
<code class="reqn">n_{i_sr}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_family">family</code></td>
<td>

<p>The data likelihood model that must be &ldquo;gaussian&quot;, &ldquo;poisson&quot; or 
&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_w">W</code></td>
<td>

<p>A matrix <code class="reqn">\boldsymbol{W}</code> that encodes the social network structure and whose rows sum to 1.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_numberofsamples">numberOfSamples</code></td>
<td>

<p>The number of samples to generate pre-thin.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_thin">thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_seed">seed</code></td>
<td>

<p>A seed for the MCMC algorithm.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_truebeta">trueBeta</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\beta}_{1}, \ldots, \boldsymbol{\beta}_{R}</code>.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_trueurandomeffects">trueURandomEffects</code></td>
<td>

<p>If available, the true values of <code class="reqn">\boldsymbol{u}_{1}, \ldots, \boldsymbol{u}_{J}, \boldsymbol{u}^{*}</code>.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_truevariancecovarianceu">trueVarianceCovarianceU</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code>.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_truesigmasquarede">trueSigmaSquaredE</code></td>
<td>

<p>If available, the true value of <code class="reqn">\sigma_{e1}^{2}</code>, <code class="reqn">\ldots</code>,  <code class="reqn">\sigma_{eR}^{2}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_covariancebetaprior">covarianceBetaPrior</code></td>
<td>

<p>A scalar prior <code class="reqn">\alpha</code> for the covariance parameter of the 
beta prior, such that the covariance is <code class="reqn">\alpha\boldsymbol{I}</code>.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_xi">xi</code></td>
<td>

<p>The degrees of freedom parameter for the Inverse-Wishart
distribution relating to the network random effects <code class="reqn">\xi_{\boldsymbol{u}}</code>. 
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_omega">omega</code></td>
<td>

<p>The scale parameter for the Inverse-Wishart distribution 
relating to the network random effects <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{u}}</code>.  
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_a3">a3</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\alpha_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_b3">b3</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\xi_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNet_+3A_centerurandomeffects">centerURandomEffects</code></td>
<td>

<p>A choice to center the network random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>

<p>The matched call.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The response used.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>The design matrix used.
</p>
</td></tr>
<tr><td><code>standardizedX</code></td>
<td>

<p>The standardized design matrix used.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>The network matrix used.
</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>

<p>The matrix of simulated samples from the posterior
distribution of each parameter in the model (excluding random effects).
</p>
</td></tr>
<tr><td><code>betaSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\beta}_{1}, \ldots, \boldsymbol{\beta}_{R}</code> parameters in the model.
</p>
</td></tr>
<tr><td><code>varianceCovarianceUSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code> in the model.
</p>
</td></tr>
<tr><td><code>uRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of network random effects <code class="reqn">\boldsymbol{u}_{1}, \ldots, \boldsymbol{u}_{J}, \boldsymbol{u}^{*}</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredESamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{e1}^{2}</code>, <code class="reqn">\ldots</code>,  <code class="reqn">\sigma_{eR}^{2}</code> in the model. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code>acceptanceRates</code></td>
<td>

<p>The acceptance rates of parameters in the model from the MCMC 
sampling scheme .
</p>
</td></tr>
<tr><td><code>uRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of network random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>timeTaken</code></td>
<td>

<p>The time taken for the model to run.
</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code>DBar</code></td>
<td>

<p>DBar for the model.
</p>
</td></tr>
<tr><td><code>posteriorDeviance</code></td>
<td>

<p>The posterior deviance for the model.
</p>
</td></tr>
<tr><td><code>posteriorLogLikelihood</code></td>
<td>

<p>The posterior log likelihood for the model.
</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>

<p>The number of effective parameters in the model.
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>The DIC for the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>

<hr>
<h2 id='multiNetLeroux'>
A function that generates samples for a multivariate fixed effects, spatial,
and network model.
</h2><span id='topic+multiNetLeroux'></span>

<h3>Description</h3>

<p>This function that generates samples for a multivariate fixed effects, spatial,
and network model, which is given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{i_sr}|\mu_{i_sr} \sim f(y_{i_sr}| \mu_{i_sr}, \sigma_{er}^{2}) ~~~ i=1,\ldots, N_{s},~s=1,\ldots,S ,~r=1,\ldots,R,</code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_{i_sr}) = \boldsymbol{x}^\top_{i_s} \boldsymbol{\beta}_{r} + \phi_{sr} + \sum_{j\in \textrm{net}(i_s)}w_{i_sj}u_{jr}+ w^{*}_{i_s}u^{*}_{r},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta}_{r} \sim \textrm{N}(\boldsymbol{0}, \alpha\boldsymbol{I})</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\phi}_{r} = (\phi_{1r},\ldots, \phi_{Sr}) \sim \textrm{N}(\boldsymbol{0}, \tau_{r}^{2}(\rho_{r}(\textrm{diag}(\boldsymbol{A1})-\boldsymbol{A})+(1-\rho_{r})\boldsymbol{I})^{-1}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{u}_{j} = (u_{1j},\ldots, u_{Rj}) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{u}^{*} = (u_{1}^*,\ldots, u_{R}^*) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_{r}^{2} \sim \textrm{Inverse-Gamma}(a_{1}, b_{1}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\rho_{r} \sim \textrm{Uniform}(0, 1),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}} \sim \textrm{Inverse-Wishart}(\xi_{\boldsymbol{u}}, \boldsymbol{\Omega}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{er}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{3}, \xi_{3}).</code>
</p>

<p>The covariates for the <code class="reqn">i</code>th individual in the <code class="reqn">s</code>th spatial unit or other grouping are included in a <code class="reqn">p \times 1</code> vector <code class="reqn">\boldsymbol{x}_{i_s}</code>. The corresponding <code class="reqn">p \times 1</code> vector of fixed effect parameters relating to the <code class="reqn">r</code>th response are denoted by <code class="reqn">\boldsymbol{\beta}_{r}</code>, which has an assumed multivariate Gaussian prior with mean <code class="reqn">\boldsymbol{0}</code> and diagonal covariance matrix <code class="reqn">\alpha\boldsymbol{I}</code> that can be chosen by the user. A conjugate Inverse-Gamma prior is specified for <code class="reqn">\sigma_{er}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{3}</code>, <code class="reqn">\xi_{3}</code>) can be chosen by the user.
</p>
<p>Spatial correlation in these areal unit level random effects is most often modelled by a conditional autoregressive (CAR) prior distribution. Using this model 
spatial correlation is induced into the random effects via a non-negative spatial adjacency matrix <code class="reqn">\boldsymbol{A} = (a_{sl})_{S \times S}</code>, which defines how spatially close the <code class="reqn">S</code> areal units are to each other. The elements of <code class="reqn">\boldsymbol{A}_{S \times S}</code> can be binary or non-binary, and the most common specification is that <code class="reqn">a_{sl} = 1</code> if a pair of areal units (<code class="reqn">\mathcal{G}_{s}</code>, <code class="reqn">\mathcal{G}_{l}</code>) share a common border or are considered neighbours by some other measure, and <code class="reqn">a_{sl} = 0</code> otherwise. Note, <code class="reqn">a_{ss} = 0</code> for all <code class="reqn">s</code>. <code class="reqn">\tau^{2}_{r}</code> measures the variance  of these random effects for the  <code class="reqn">r</code>th response, where a conjugate Inverse-Gamma prior is specified for <code class="reqn">\tau^{2}_{r}</code> and the corresponding hyperparamaterers (<code class="reqn">a_{1}</code>, <code class="reqn">b_{1}</code>) can be chosen by the user. <code class="reqn">\rho_{r}</code> controls the level of spatial autocorrelation. A non-conjugate uniform prior is specified for <code class="reqn">\rho_{r}</code>.
</p>
<p>The <code class="reqn">R \times 1</code> vector of random effects for the <code class="reqn">j</code>th alter is denoted by <code class="reqn">\boldsymbol{u}_{j} = (u_{j1}, \ldots, u_{jR})_{R \times 1}</code>, while the <code class="reqn">R \times 1</code> vector of isolation effects for all <code class="reqn">R</code> outcomes is  denoted by <code class="reqn">\boldsymbol{u}^{*} = (u_{1}^*,\ldots, u_{R}^*)</code>, and both are assigned multivariate Gaussian prior distributions. The unstructured covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code> captures the covariance between the <code class="reqn">R</code> outcomes at the network level, and a conjugate Inverse-Wishart prior is specified for this covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code>. The corresponding hyperparamaterers (<code class="reqn">\xi_{\boldsymbol{u}}</code>, <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{u}}</code>) can be chosen by the user.
</p>
<p>The exact specification of each of the likelihoods (binomial, Gaussian, and Poisson) are given below:
</p>
<p style="text-align: center;"><code class="reqn">\textrm{Binomial:} ~ Y_{i_sr} \sim \textrm{Binomial}(n_{i_sr}, \theta_{i_sr}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \textrm{ln}(\theta_{i_sr} / (1 - \theta_{i_sr})),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Gaussian:} ~ Y_{i_sr} \sim \textrm{N}(\mu_{i_sr}, \sigma_{er}^{2}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \mu_{i_sr},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Poisson:} ~ Y_{i_sr} \sim \textrm{Poisson}(\mu_{i_sr}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \textrm{ln}(\mu_{i_sr}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>multiNetLeroux(formula, data, trials, family, squareSpatialNeighbourhoodMatrix,
spatialAssignment, W, numberOfSamples = 10, burnin = 0, thin = 1, seed = 1,
trueBeta = NULL, trueSpatialRandomEffects = NULL, trueURandomEffects = NULL, 
trueSpatialTauSquared = NULL, trueSpatialRho = NULL, 
trueVarianceCovarianceU = NULL, trueSigmaSquaredE = NULL, 
covarianceBetaPrior = 10^5, a1 = 0.001, b1 = 0.001, xi, omega, a3 = 0.001, 
b3 = 0.001, centerSpatialRandomEffects = TRUE, centerURandomEffects = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiNetLeroux_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using a similar 
syntax to that used in the lm() function.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the variables in the formula.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
<code class="reqn">n_{i_sr}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_family">family</code></td>
<td>

<p>The data likelihood model that must be &ldquo;gaussian&quot;, &ldquo;poisson&quot; or 
&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_squarespatialneighbourhoodmatrix">squareSpatialNeighbourhoodMatrix</code></td>
<td>

<p>An <code class="reqn">S \times S</code> symmetric and non-negative neighbourhood 
matrix <code class="reqn">\boldsymbol{A} = (a_{sl})_{S \times S}</code>. 
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_w">W</code></td>
<td>

<p>A matrix <code class="reqn">\boldsymbol{W}</code> that encodes the social network structure and whose rows sum to 1.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_spatialassignment">spatialAssignment</code></td>
<td>

<p>The binary matrix of individual's assignment to spatial area used in the model fitting process.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_numberofsamples">numberOfSamples</code></td>
<td>

<p>The number of samples to generate pre-thin.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_thin">thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_seed">seed</code></td>
<td>

<p>A seed for the MCMC algorithm.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_truebeta">trueBeta</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\beta}_{1}, \ldots, \boldsymbol{\beta}_{R}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_truespatialrandomeffects">trueSpatialRandomEffects</code></td>
<td>

<p>If available, the true values of <code class="reqn">\boldsymbol{\phi}_{1}, \ldots, \boldsymbol{\phi}_{R}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_trueurandomeffects">trueURandomEffects</code></td>
<td>

<p>If available, the true values of <code class="reqn">\boldsymbol{u}_{1}, \ldots, \boldsymbol{u}_{J}, \boldsymbol{u}^{*}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_truespatialtausquared">trueSpatialTauSquared</code></td>
<td>

<p>If available, the true values of <code class="reqn">\tau^{2}_{1}, \ldots, \tau^{2}_{R}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_truespatialrho">trueSpatialRho</code></td>
<td>

<p>If available, the true value of <code class="reqn">\rho_{1}, \ldots, \rho_{R}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_truevariancecovarianceu">trueVarianceCovarianceU</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_truesigmasquarede">trueSigmaSquaredE</code></td>
<td>

<p>If available, the true value of <code class="reqn">\sigma_{e1}^{2}</code>, <code class="reqn">\ldots</code>,  <code class="reqn">\sigma_{eR}^{2}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_covariancebetaprior">covarianceBetaPrior</code></td>
<td>

<p>A scalar prior <code class="reqn">\alpha</code> for the covariance parameter of the 
beta prior, such that the covariance is <code class="reqn">\alpha\boldsymbol{I}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_a1">a1</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the spatial random effects <code class="reqn">\alpha_{1}</code>. 
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_b1">b1</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the spatial random effects <code class="reqn">\xi_{1}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_xi">xi</code></td>
<td>

<p>The degrees of freedom parameter for the Inverse-Wishart
distribution relating to the network random effects <code class="reqn">\xi_{\boldsymbol{u}}</code>. 
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_omega">omega</code></td>
<td>

<p>The scale parameter for the Inverse-Wishart distribution 
relating to the network random effects <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{u}}</code>.  
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_a3">a3</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\alpha_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_b3">b3</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\xi_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_centerspatialrandomeffects">centerSpatialRandomEffects</code></td>
<td>

<p>A choice to center the spatial random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
<tr><td><code id="multiNetLeroux_+3A_centerurandomeffects">centerURandomEffects</code></td>
<td>

<p>A choice to center the network random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>

<p>The matched call.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The response used.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>The design matrix used.
</p>
</td></tr>
<tr><td><code>standardizedX</code></td>
<td>

<p>The standardized design matrix used.
</p>
</td></tr>
<tr><td><code>squareSpatialNeighbourhoodMatrix</code></td>
<td>

<p>The spatial neighbourhood matrix used.
</p>
</td></tr>
<tr><td><code>spatialAssignment</code></td>
<td>

<p>The spatial assignment matrix used.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>The network matrix used.
</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>

<p>The matrix of simulated samples from the posterior
distribution of each parameter in the model (excluding random effects).
</p>
</td></tr>
<tr><td><code>betaSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\beta}_{1}, \ldots, \boldsymbol{\beta}_{R}</code> parameters in the model.
</p>
</td></tr>
<tr><td><code>spatialTauSquaredSamples</code></td>
<td>

<p>Type: matrix. The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\tau^{2}_{1}, \ldots, \tau^{2}_{R}</code> in the model.
</p>
</td></tr>
<tr><td><code>spatialRhoSamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\rho_{1}, \ldots, \rho_{R}</code> in the model.
</p>
</td></tr>
<tr><td><code>varianceCovarianceUSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code> in the model.
</p>
</td></tr>
<tr><td><code>spatialRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of spatial random effects <code class="reqn">\boldsymbol{\phi}_{1}, \ldots, \boldsymbol{\phi}_{R}</code> in the model.
</p>
</td></tr>
<tr><td><code>uRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of network random effects <code class="reqn">\boldsymbol{u}_{1}, \ldots, \boldsymbol{u}_{J}, \boldsymbol{u}^{*}</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredESamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{e1}^{2}</code>, <code class="reqn">\ldots</code>,  <code class="reqn">\sigma_{eR}^{2}</code> in the model. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code>acceptanceRates</code></td>
<td>

<p>The acceptance rates of parameters in the model from the MCMC 
sampling scheme .
</p>
</td></tr>
<tr><td><code>spatialRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of spatial random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>uRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of network random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>timeTaken</code></td>
<td>

<p>The time taken for the model to run.
</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code>DBar</code></td>
<td>

<p>DBar for the model.
</p>
</td></tr>
<tr><td><code>posteriorDeviance</code></td>
<td>

<p>The posterior deviance for the model.
</p>
</td></tr>
<tr><td><code>posteriorLogLikelihood</code></td>
<td>

<p>The posterior log likelihood for the model.
</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>

<p>The number of effective parameters in the model.
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>The DIC for the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>

<hr>
<h2 id='multiNetRand'>
A function that generates samples for a multivariate fixed effects, grouping,
and network model.
</h2><span id='topic+multiNetRand'></span>

<h3>Description</h3>

<p>This function that generates samples for a multivariate fixed effects, 
grouping, and network model, which is given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{i_sr}|\mu_{i_sr} \sim f(y_{i_sr}| \mu_{i_sr}, \sigma_{er}^{2}) ~~~ i=1,\ldots, N_{s},~s=1,\ldots,S ,~r=1,\ldots,R,</code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_{i_sr}) = \boldsymbol{x}^\top_{i_s} \boldsymbol{\beta}_{r} v_{sr} + \sum_{j\in \textrm{net}(i_s)}w_{i_sj}u_{jr}+ w^{*}_{i_s}u^{*}_{r},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta}_{r} \sim \textrm{N}(\boldsymbol{0}, \alpha\boldsymbol{I})</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{v}_{s} = (v_{s1},\ldots, v_{sR}) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{v}})\boldsymbol{v}_{s} = (v_{s1},\ldots, v_{sR}) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{v}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{u}_{j} = (u_{1j},\ldots, u_{Rj}) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{u}^{*} = (u_{1}^*,\ldots, u_{R}^*) \sim \textrm{N}(\boldsymbol{0}, \boldsymbol{\Sigma}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{v}} \sim \textrm{Inverse-Wishart}(\xi_{\boldsymbol{v}}, \boldsymbol{\Omega}_{\boldsymbol{v}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}} \sim \textrm{Inverse-Wishart}(\xi_{\boldsymbol{u}}, \boldsymbol{\Omega}_{\boldsymbol{u}}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{er}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{3}, \xi_{3}).</code>
</p>

<p>The covariates for the <code class="reqn">i</code>th individual in the <code class="reqn">s</code>th spatial unit or other grouping are included in a <code class="reqn">p \times 1</code> vector <code class="reqn">\boldsymbol{x}_{i_s}</code>. The corresponding <code class="reqn">p \times 1</code> vector of fixed effect parameters relating to the <code class="reqn">r</code>th response are denoted by <code class="reqn">\boldsymbol{\beta}_{r}</code>, which has an assumed multivariate Gaussian prior with mean <code class="reqn">\boldsymbol{0}</code> and diagonal covariance matrix <code class="reqn">\alpha\boldsymbol{I}</code> that can be chosen by the user. A conjugate Inverse-Gamma prior is specified for <code class="reqn">\sigma_{er}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{3}</code>, <code class="reqn">\xi_{3}</code>) can be chosen by the user.
</p>
<p>The <code class="reqn">R \times 1</code> vector of random effects for the $s$th group is denoted by <code class="reqn">\boldsymbol{v}_{s} = (v_{s1}, \ldots, v_{sR})_{R \times 1}</code>, which is assigned a joint Gaussian prior distribution with an unstructured covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{v}}</code> that captures the covariance between the <code class="reqn">R</code> outcomes. A conjugate Inverse-Wishart prior is specified for the random effects covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{v}}</code>. The corresponding hyperparamaterers (<code class="reqn">\xi_{\boldsymbol{v}}</code>, <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{v}}</code>) can be chosen by the user.
</p>
<p>The <code class="reqn">R \times 1</code> vector of random effects for the <code class="reqn">j</code>th alter is denoted by <code class="reqn">\boldsymbol{u}_{j} = (u_{j1}, \ldots, u_{jR})_{R \times 1}</code>, while the <code class="reqn">R \times 1</code> vector of isolation effects for all <code class="reqn">R</code> outcomes is  denoted by <code class="reqn">\boldsymbol{u}^{*} = (u_{1}^*,\ldots, u_{R}^*)</code>, and both are assigned multivariate Gaussian prior distributions. The unstructured covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code> captures the covariance between the <code class="reqn">R</code> outcomes at the network level, and a conjugate Inverse-Wishart prior is specified for this covariance matrix <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code>. The corresponding hyperparamaterers (<code class="reqn">\xi_{\boldsymbol{u}}</code>, <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{u}}</code>) can be chosen by the user.
</p>
<p>The exact specification of each of the likelihoods (binomial, Gaussian, and Poisson) are given below:
</p>
<p style="text-align: center;"><code class="reqn">\textrm{Binomial:} ~ Y_{i_sr} \sim \textrm{Binomial}(n_{i_sr}, \theta_{i_sr}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \textrm{ln}(\theta_{i_sr} / (1 - \theta_{i_sr})),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Gaussian:} ~ Y_{i_sr} \sim \textrm{N}(\mu_{i_sr}, \sigma_{er}^{2}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \mu_{i_sr},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Poisson:} ~ Y_{i_sr} \sim \textrm{Poisson}(\mu_{i_sr}) ~ \textrm{and} ~ g(\mu_{i_sr}) = \textrm{ln}(\mu_{i_sr}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>multiNetRand(formula, data, trials, family, V, W, numberOfSamples = 10, burnin = 0, 
thin = 1, seed = 1, trueBeta = NULL, trueVRandomEffects = NULL, 
trueURandomEffects = NULL, trueVarianceCovarianceV = NULL, 
trueVarianceCovarianceU = NULL, trueSigmaSquaredE = NULL, 
covarianceBetaPrior = 10^5, xiV, omegaV, xi, omega, a3 = 0.001, 
b3 = 0.001, centerVRandomEffects = TRUE, centerURandomEffects = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiNetRand_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using a similar 
syntax to that used in the lm() function.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the variables in the formula.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
<code class="reqn">n_{i_sr}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_family">family</code></td>
<td>

<p>The data likelihood model that must be &ldquo;gaussian&quot;, &ldquo;poisson&quot; or &ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_v">V</code></td>
<td>

<p>The binary matrix of individual's assignment to groups used in the model fitting process.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_w">W</code></td>
<td>

<p>A matrix <code class="reqn">\boldsymbol{W}</code> that encodes the social network structure and whose rows sum to 1.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_numberofsamples">numberOfSamples</code></td>
<td>

<p>The number of samples to generate pre-thin.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_thin">thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_seed">seed</code></td>
<td>

<p>A seed for the MCMC algorithm.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_truebeta">trueBeta</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\beta}_{1}, \ldots, \boldsymbol{\beta}_{R}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_truevrandomeffects">trueVRandomEffects</code></td>
<td>

<p>If available, the true values of <code class="reqn">\boldsymbol{v}_{1}, \ldots, \boldsymbol{v}_{S}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_trueurandomeffects">trueURandomEffects</code></td>
<td>

<p>If available, the true values of <code class="reqn">\boldsymbol{u}_{1}, \ldots, \boldsymbol{u}_{J}, \boldsymbol{u}^{*}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_truevariancecovariancev">trueVarianceCovarianceV</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{v}}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_truevariancecovarianceu">trueVarianceCovarianceU</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_truesigmasquarede">trueSigmaSquaredE</code></td>
<td>

<p>If available, the true value of <code class="reqn">\sigma_{e1}^{2}</code>, <code class="reqn">\ldots</code>,  <code class="reqn">\sigma_{eR}^{2}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_covariancebetaprior">covarianceBetaPrior</code></td>
<td>

<p>A scalar prior <code class="reqn">\alpha</code> for the covariance parameter of the 
beta prior, such that the covariance is <code class="reqn">\alpha\boldsymbol{I}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_xiv">xiV</code></td>
<td>

<p>The degrees of freedom parameter for the Inverse-Wishart
distribution relating to the grouping random effects <code class="reqn">\xi_{\boldsymbol{v}}</code>. 
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_omegav">omegaV</code></td>
<td>

<p>The scale parameter for the Inverse-Wishart distribution 
relating to the grouping random effects <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{v}}</code>.  
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_xi">xi</code></td>
<td>

<p>The degrees of freedom parameter for the Inverse-Wishart
distribution relating to the network random effects <code class="reqn">\xi_{\boldsymbol{u}}</code>.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_omega">omega</code></td>
<td>

<p>The scale parameter for the Inverse-Wishart distribution 
relating to the network random effects <code class="reqn">\boldsymbol{\Omega}_{\boldsymbol{u}}</code>.  
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_a3">a3</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\alpha_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_b3">b3</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\xi_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_centervrandomeffects">centerVRandomEffects</code></td>
<td>

<p>A choice to center the spatial random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
<tr><td><code id="multiNetRand_+3A_centerurandomeffects">centerURandomEffects</code></td>
<td>

<p>A choice to center the network random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>

<p>The matched call.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The response used.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>The design matrix used.
</p>
</td></tr>
<tr><td><code>standardizedX</code></td>
<td>

<p>The standardized design matrix used.
</p>
</td></tr>
<tr><td><code>V</code></td>
<td>

<p>The grouping assignment matrix used.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>The network matrix used.
</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>

<p>The matrix of simulated samples from the posterior
distribution of each parameter in the model (excluding random effects).
</p>
</td></tr>
<tr><td><code>betaSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\beta}_{1}, \ldots, \boldsymbol{\beta}_{R}</code> parameters in the model.
</p>
</td></tr>
<tr><td><code>varianceCovarianceVSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{v}}</code> in the model.
</p>
</td></tr>
<tr><td><code>varianceCovarianceUSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\Sigma}_{\boldsymbol{u}}</code> in the model.
</p>
</td></tr>
<tr><td><code>vRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of spatial random effects <code class="reqn">\boldsymbol{v}_{1}, \ldots, \boldsymbol{v}_{S}</code> in the model.
</p>
</td></tr>
<tr><td><code>uRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of network random effects <code class="reqn">\boldsymbol{u}_{1}, \ldots, \boldsymbol{u}_{J}, \boldsymbol{u}^{*}</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredESamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{e1}^{2}</code>, <code class="reqn">\ldots</code>,  <code class="reqn">\sigma_{eR}^{2}</code> in the model. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code>acceptanceRates</code></td>
<td>

<p>The acceptance rates of parameters in the model from the MCMC 
sampling scheme.
</p>
</td></tr>
<tr><td><code>vRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of grouping random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>uRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of network random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>timeTaken</code></td>
<td>

<p>The time taken for the model to run.
</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code>DBar</code></td>
<td>

<p>DBar for the model.
</p>
</td></tr>
<tr><td><code>posteriorDeviance</code></td>
<td>

<p>The posterior deviance for the model.
</p>
</td></tr>
<tr><td><code>posteriorLogLikelihood</code></td>
<td>

<p>The posterior log likelihood for the model.
</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>

<p>The number of effective parameters in the model.
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>The DIC for the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>

<hr>
<h2 id='plot.netcmc'>
A function that plots visual MCMC diagnostics of the fitted model.
</h2><span id='topic+plot.netcmc'></span>

<h3>Description</h3>

<p>This function takes a netcmc object of samples from the posterior 
distribution of a parameter(s) and returns a visual convergence diaagnostics in 
the form of a density plot, trace plot, and ACF plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'netcmc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.netcmc_+3A_x">x</code></td>
<td>

<p>A netcmc object of samples from the posterior 
distribution of a parameter(s).
</p>
</td></tr>
<tr><td><code id="plot.netcmc_+3A_...">...</code></td>
<td>

<p>Ignored.s
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a trace plot, density plot and ACF plot for the posterior 
distribution of a parameter(s) in a netcmc object.</p>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>

<hr>
<h2 id='print.netcmc'>
A function that gets a summary of the fitted model.
</h2><span id='topic+print.netcmc'></span>

<h3>Description</h3>

<p>This function takes a netcmc object and returns a summary of the fitted model.
The summary includes, for selected parameters, posterior medians and 95 percent 
credible intervals, the effective number of independent samples and the Geweke 
convergence diagnostic in the form of a Z-score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'netcmc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netcmc_+3A_x">x</code></td>
<td>

<p>A netcmc fitted model object.
</p>
</td></tr>
<tr><td><code id="print.netcmc_+3A_...">...</code></td>
<td>

<p>Ignored.s
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a model summary for a netcmc object.</p>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>

<hr>
<h2 id='summary.netcmc'>
A function that gets a summary of the fitted model.
</h2><span id='topic+summary.netcmc'></span>

<h3>Description</h3>

<p>This function takes a netcmc object and returns a summary of the fitted model.
The summary includes, for selected parameters, posterior medians and 95 percent 
credible intervals, the effective number of independent samples and the Geweke 
convergence diagnostic in the form of a Z-score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'netcmc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.netcmc_+3A_object">object</code></td>
<td>

<p>A netcmc fitted model object.
</p>
</td></tr>
<tr><td><code id="summary.netcmc_+3A_...">...</code></td>
<td>

<p>Ignored.s
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a model summary for a netcmc object.</p>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>

<hr>
<h2 id='uni'>
A function that generates samples for a univariate fixed effects model.
</h2><span id='topic+uni'></span>

<h3>Description</h3>

<p>This function generates samples for a univariate fixed effects model, which is
given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{i_s}|\mu_{i_s} \sim f(y_{i_s}| \mu_{i_s}, \sigma_{e}^{2}) ~~~ i=1,\ldots, N_{s},~s=1,\ldots,S ,</code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_{i_s}) = \boldsymbol{x}^\top_{i_s} \boldsymbol{\beta},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta} \sim \textrm{N}(\boldsymbol{0}, \alpha\boldsymbol{I}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{e}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{3}, \xi_{3}).</code>
</p>

<p>The covariates for the <code class="reqn">i</code>th individual in the <code class="reqn">s</code>th spatial unit or other grouping are included in a <code class="reqn">p \times 1</code> vector <code class="reqn">\boldsymbol{x}_{i_s}</code>. The corresponding <code class="reqn">p \times 1</code> vector of fixed effect parameters are denoted by <code class="reqn">\boldsymbol{\beta}</code>, which has an assumed multivariate Gaussian prior with mean <code class="reqn">\boldsymbol{0}</code> and diagonal covariance matrix <code class="reqn">\alpha\boldsymbol{I}</code> that can be chosen by the user. A conjugate Inverse-Gamma prior is specified for <code class="reqn">\sigma_{e}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{3}</code>, <code class="reqn">\xi_{3}</code>) can be chosen by the user.
</p>
<p>The exact specification of each of the likelihoods (binomial, Gaussian, and Poisson) are given below:
</p>
<p style="text-align: center;"><code class="reqn">\textrm{Binomial:} ~ Y_{i_s} \sim \textrm{Binomial}(n_{i_s}, \theta_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\theta_{i_s} / (1 - \theta_{i_s})),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Gaussian:} ~ Y_{i_s} \sim \textrm{N}(\mu_{i_s}, \sigma_{e}^{2}) ~ \textrm{and} ~ g(\mu_{i_s}) = \mu_{i_s},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Poisson:} ~ Y_{i_s} \sim \textrm{Poisson}(\mu_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\mu_{i_s}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>uni(formula, data, trials, family, numberOfSamples = 10, burnin = 0, thin = 1, seed = 1,
trueBeta = NULL, trueSigmaSquaredE = NULL, covarianceBetaPrior = 10^5, 
a3 = 0.001, b3 = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uni_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using a similar 
syntax to that used in the lm() function.
</p>
</td></tr>
<tr><td><code id="uni_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="uni_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
<code class="reqn">n_{i_s}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uni_+3A_family">family</code></td>
<td>

<p>The data likelihood model that must be &ldquo;gaussian&quot;
, &ldquo;poisson&quot; or &ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uni_+3A_numberofsamples">numberOfSamples</code></td>
<td>

<p>The number of samples to generate pre-thin.
</p>
</td></tr>
<tr><td><code id="uni_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code id="uni_+3A_thin">thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code id="uni_+3A_seed">seed</code></td>
<td>

<p>A seed for the MCMC algorithm.
</p>
</td></tr>
<tr><td><code id="uni_+3A_truebeta">trueBeta</code></td>
<td>

<p>If available, the true values of the <code class="reqn">\boldsymbol{\beta}</code>.
</p>
</td></tr>
<tr><td><code id="uni_+3A_truesigmasquarede">trueSigmaSquaredE</code></td>
<td>

<p>If available, the true value of <code class="reqn">\sigma_{e}^{2}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uni_+3A_covariancebetaprior">covarianceBetaPrior</code></td>
<td>

<p>A scalar prior <code class="reqn">\alpha</code> for the covariance parameter of the 
beta prior, such that the covariance is <code class="reqn">\alpha\boldsymbol{I}</code>.
</p>
</td></tr>
<tr><td><code id="uni_+3A_a3">a3</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
<code class="reqn">\alpha_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uni_+3A_b3">b3</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
<code class="reqn">\xi_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>

<p>The matched call.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The response used.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>The design matrix used.
</p>
</td></tr>
<tr><td><code>standardizedX</code></td>
<td>

<p>The standardized design matrix used.
</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>

<p>The matrix of simulated samples from the posterior
distribution of each parameter in the model (excluding random effects).
</p>
</td></tr>
<tr><td><code>betaSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\beta}</code> parameters in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredESamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{e}^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>acceptanceRates</code></td>
<td>

<p>The acceptance rates of parameters in the model from the MCMC 
sampling scheme.
</p>
</td></tr>
<tr><td><code>timeTaken</code></td>
<td>

<p>The time taken for the model to run.
</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code>DBar</code></td>
<td>

<p>DBar for the model.
</p>
</td></tr>
<tr><td><code>posteriorDeviance</code></td>
<td>

<p>The posterior deviance for the model.
</p>
</td></tr>
<tr><td><code>posteriorLogLikelihood</code></td>
<td>

<p>The posterior log likelihood for the model.
</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>

<p>The number of effective parameters in the model.
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>The DIC for the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #################################################
  #### Run the model on simulated data
  #################################################
  
  #### Generate the covariates and response data
  observations &lt;- 100
  X &lt;- matrix(rnorm(2 * observations), ncol = 2)
  colnames(X) &lt;- c("x1", "x2")
  beta &lt;- c(2, -2, 2)
  logit &lt;- cbind(rep(1, observations), X) %*% beta
  prob &lt;- exp(logit) / (1 + exp(logit))
  trials &lt;- rep(50, observations)
  Y &lt;- rbinom(n = observations, size = trials, prob = prob)
  data &lt;- data.frame(cbind(Y, X))
  
  #### Run the model
  formula &lt;- Y ~ x1 + x2
  ## Not run: model &lt;- uni(formula = formula, data = data, family="binomial", 
                        trials = trials, numberOfSamples = 10000, 
                        burnin = 10000, thin = 10, seed = 1)
## End(Not run)
                        
</code></pre>

<hr>
<h2 id='uniNet'>
A function that generates samples for a univariate network model.
</h2><span id='topic+uniNet'></span>

<h3>Description</h3>

<p>This function generates samples for a univariate network model, which is
given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{i_s}|\mu_{i_s} \sim f(y_{i_s}| \mu_{i_s}, \sigma_{e}^{2}) ~~~ i=1,\ldots, N_{s},~s=1,\ldots,S ,</code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_{i_s}) = \boldsymbol{x}^\top_{i_s} \boldsymbol{\beta} + \sum_{j\in \textrm{net}(i_s)}w_{i_sj}u_{j} + w^{*}_{i_s}u^{*},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta} \sim \textrm{N}(\boldsymbol{0}, \alpha\boldsymbol{I}),</code>
</p>

<p style="text-align: center;"><code class="reqn">u_{j} \sim \textrm{N}(0, \sigma_{u}^{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">u^{*} \sim \textrm{N}(0, \sigma_{u}^{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{u}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{2}, \xi_{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{e}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{3}, \xi_{3}).</code>
</p>

<p>The covariates for the <code class="reqn">i</code>th individual in the <code class="reqn">s</code>th spatial unit or other grouping are included in a <code class="reqn">p \times 1</code> vector <code class="reqn">\boldsymbol{x}_{i_s}</code>. The corresponding <code class="reqn">p \times 1</code> vector of fixed effect parameters are denoted by <code class="reqn">\boldsymbol{\beta}</code>, which has an assumed multivariate Gaussian prior with mean <code class="reqn">\boldsymbol{0}</code> and diagonal covariance matrix <code class="reqn">\alpha\boldsymbol{I}</code> that can be chosen by the user. A conjugate Inverse-Gamma prior is specified for <code class="reqn">\sigma_{e}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{3}</code>, <code class="reqn">\xi_{3}</code>) can be chosen by the user.
</p>
<p>The <code class="reqn">J \times 1</code> vector of alter random effects are denoted by <code class="reqn">\boldsymbol{u} = (u_{1}, \ldots, u_{J})_{J \times 1}</code> and modelled as independently Gaussian with mean zero and a constant variance, and due to the row standardised nature of <code class="reqn">\boldsymbol{W}</code>, <code class="reqn">\sum_{j \in \textrm{net}(i_s)} w_{i_sj} u_{j}</code> represents the average (mean) effect that the peers of individual <code class="reqn">i</code> in spatial unit or group <code class="reqn">s</code> have on that individual. <code class="reqn">w^{*}_{i_s}u^{*}</code> is an <em>isolation effect</em>, which is an effect for individuals who don't nominate any friends. This is achieved by setting <code class="reqn">w^{*}_{i_s}=1</code> if individual <code class="reqn">i_s</code> nominates no peers and <code class="reqn">w^{*}_{i_s}=0</code> otherwise, and if  <code class="reqn">w^{*}_{i_s}=1</code> then clearly <code class="reqn">\sum_{j\in \textrm{net}(i_{s})}w_{i_{s}j}u_{jr}=0</code> as <code class="reqn">\textrm{net}(i_{s})</code> is the empty set. A conjugate Inverse-Gamma prior is specified for the random effects variance <code class="reqn">\sigma_{u}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{2}</code>, <code class="reqn">\xi_{2}</code>) can be chosen by the user.
</p>
<p>The exact specification of each of the likelihoods (binomial, Gaussian, and Poisson) are given below:
</p>
<p style="text-align: center;"><code class="reqn">\textrm{Binomial:} ~ Y_{i_s} \sim \textrm{Binomial}(n_{i_s}, \theta_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\theta_{i_s} / (1 - \theta_{i_s})),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Gaussian:} ~ Y_{i_s} \sim \textrm{N}(\mu_{i_s}, \sigma_{e}^{2}) ~ \textrm{and} ~ g(\mu_{i_s}) = \mu_{i_s},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Poisson:} ~ Y_{i_s} \sim \textrm{Poisson}(\mu_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\mu_{i_s}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>uniNet(formula, data, trials, family, W, numberOfSamples = 10, burnin = 0, thin = 1, 
seed = 1, trueBeta = NULL, trueURandomEffects = NULL, trueSigmaSquaredU = NULL,
trueSigmaSquaredE = NULL, covarianceBetaPrior = 10^5, a2 = 0.001, b2 = 0.001, 
a3 = 0.001, b3 = 0.001, centerURandomEffects = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniNet_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using a similar 
syntax to that used in the lm() function.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the variables in the formula.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
<code class="reqn">n_{i_s}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_family">family</code></td>
<td>

<p>The data likelihood model that must be &ldquo;gaussian&quot;, &ldquo;poisson&quot; or 
&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_w">W</code></td>
<td>

<p>A matrix <code class="reqn">\boldsymbol{W}</code> that encodes the social network structure and whose rows sum to 1.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_numberofsamples">numberOfSamples</code></td>
<td>

<p>The number of samples to generate pre-thin.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_thin">thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_seed">seed</code></td>
<td>

<p>A seed for the MCMC algorithm.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_truebeta">trueBeta</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\beta}</code>.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_trueurandomeffects">trueURandomEffects</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{u}</code>.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_truesigmasquaredu">trueSigmaSquaredU</code></td>
<td>

<p>If available, the true value <code class="reqn">\sigma_{u}^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_truesigmasquarede">trueSigmaSquaredE</code></td>
<td>

<p>If available, the true value <code class="reqn">\sigma_{e}^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_covariancebetaprior">covarianceBetaPrior</code></td>
<td>

<p>A scalar prior <code class="reqn">\alpha</code> for the covariance parameter of the 
beta prior, such that the covariance is <code class="reqn">\alpha\boldsymbol{I}</code>.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_a2">a2</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the network random effects <code class="reqn">\alpha_{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_b2">b2</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the network random effects <code class="reqn">\xi_{2}</code>. 
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_a3">a3</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\alpha_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_b3">b3</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\xi_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uniNet_+3A_centerurandomeffects">centerURandomEffects</code></td>
<td>

<p>A choice to center the network random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>

<p>The matched call.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The response used.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>The design matrix used.
</p>
</td></tr>
<tr><td><code>standardizedX</code></td>
<td>

<p>The standardized design matrix used.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>The network matrix used.
</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>

<p>The matrix of simulated samples from the posterior
distribution of each parameter in the model (excluding random effects).
</p>
</td></tr>
<tr><td><code>betaSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\beta}</code> parameters in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredUSamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{u}^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredESamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{e}^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>uRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of network random effects <code class="reqn">\boldsymbol{u}</code> in the model.
</p>
</td></tr>
<tr><td><code>acceptanceRates</code></td>
<td>

<p>The acceptance rates of parameters in the model (excluding 
random effects) from the MCMC sampling scheme .
</p>
</td></tr>
<tr><td><code>uRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of network random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>timeTaken</code></td>
<td>

<p>The time taken for the model to run.
</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code>DBar</code></td>
<td>

<p>DBar for the model.
</p>
</td></tr>
<tr><td><code>posteriorDeviance</code></td>
<td>

<p>The posterior deviance for the model.
</p>
</td></tr>
<tr><td><code>posteriorLogLikelihood</code></td>
<td>

<p>The posterior log likelihood for the model.
</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>

<p>The number of effective parameters in the model.
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>The DIC for the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #################################################
  #### Run the model on simulated data
  #################################################
  #### Load other libraries required
  library(MCMCpack)
  
  #### Set up a network
  observations &lt;- 200
  numberOfMultipleClassifications &lt;- 50
  W &lt;- matrix(rbinom(observations * numberOfMultipleClassifications, 1, 0.05), 
              ncol = numberOfMultipleClassifications)
  numberOfActorsWithNoPeers &lt;- sum(apply(W, 1, function(x) { sum(x) == 0 }))
  peers &lt;- sample(1:numberOfMultipleClassifications, numberOfActorsWithNoPeers,
                  TRUE)
  actorsWithNoPeers &lt;- which(apply(W, 1, function(x) { sum(x) == 0 }))
  for(i in 1:numberOfActorsWithNoPeers) {
    W[actorsWithNoPeers[i], peers[i]] &lt;- 1
  }
  W &lt;- t(apply(W, 1, function(x) { x / sum(x) }))
  
  #### Generate the covariates and response data
  X &lt;- matrix(rnorm(2 * observations), ncol = 2)
  colnames(X) &lt;- c("x1", "x2")
  beta &lt;- c(1, -0.5, 0.5)
  sigmaSquaredU &lt;- 1
  uRandomEffects &lt;- rnorm(numberOfMultipleClassifications, mean = 0, 
                          sd = sqrt(sigmaSquaredU))

  logTheta &lt;- cbind(rep(1, observations), X) %*% beta + W %*% uRandomEffects
  Y &lt;- rpois(n = observations, lambda = exp(logTheta))
  data &lt;- data.frame(cbind(Y, X))
  
  #### Run the model
  formula &lt;- Y ~ x1 + x2
  ## Not run: model &lt;- uniNet(formula = formula, data = data, family="poisson",
                           W = W, numberOfSamples = 10000, burnin = 10000, 
                           thin = 10, seed = 1)
## End(Not run)

</code></pre>

<hr>
<h2 id='uniNetLeroux'>
A function that generates samples for a univariate network Leroux model.
</h2><span id='topic+uniNetLeroux'></span>

<h3>Description</h3>

<p>This function generates samples for a univariate network Leroux model, which is
given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{i_s}|\mu_{i_s} \sim f(y_{i_s}| \mu_{i_s}, \sigma_{e}^{2}) ~~~ i=1,\ldots, N_{s},~s=1,\ldots,S ,</code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_{i_s}) = \boldsymbol{x}^\top_{i_s} \boldsymbol{\beta} + \phi_{s} + \sum_{j\in \textrm{net}(i_s)}w_{i_sj}u_{j} + w^{*}_{i_s}u^{*},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta} \sim \textrm{N}(\boldsymbol{0}, \alpha\boldsymbol{I}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_{s} | \boldsymbol{\phi}_{-s} \sim \textrm{N}\bigg(\frac{ \rho \sum_{l = 1}^{S} a_{sl} \phi_{l} }{ \rho \sum_{l = 1}^{S} a_{sl}  + 1 - \rho }, \frac{ \tau^{2} }{ \rho \sum_{l = 1}^{S} a_{sl}  + 1 - \rho } \bigg),</code>
</p>

<p style="text-align: center;"><code class="reqn">u_{j} \sim \textrm{N}(0, \sigma_{u}^{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">u^{*} \sim \textrm{N}(0, \sigma_{u}^{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau^{2} \sim \textrm{Inverse-Gamma}(\alpha_{1}, \xi_{1}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\rho \sim \textrm{Uniform}(0, 1),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{u}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{2}, \xi_{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{e}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{3}, \xi_{3}).</code>
</p>

<p>The covariates for the <code class="reqn">i</code>th individual in the <code class="reqn">s</code>th spatial unit or other grouping are included in a <code class="reqn">p \times 1</code> vector <code class="reqn">\boldsymbol{x}_{i_s}</code>. The corresponding <code class="reqn">p \times 1</code> vector of fixed effect parameters are denoted by <code class="reqn">\boldsymbol{\beta}</code>, which has an assumed multivariate Gaussian prior with mean <code class="reqn">\boldsymbol{0}</code> and diagonal covariance matrix <code class="reqn">\alpha\boldsymbol{I}</code> that can be chosen by the user. A conjugate Inverse-Gamma prior is specified for <code class="reqn">\sigma_{e}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{3}</code>, <code class="reqn">\xi_{3}</code>) can be chosen by the user.
</p>
<p>Spatial correlation in these areal unit level random effects is most often modelled by a conditional autoregressive (CAR) prior distribution. Using this model 
spatial correlation is induced into the random effects via a non-negative spatial adjacency matrix <code class="reqn">\boldsymbol{A} = (a_{sl})_{S \times S}</code>, which defines how spatially close the <code class="reqn">S</code> areal units are to each other. The elements of <code class="reqn">\boldsymbol{A}_{S \times S}</code> can be binary or non-binary, and the most common specification is that <code class="reqn">a_{sl} = 1</code> if a pair of areal units (<code class="reqn">\mathcal{G}_{s}</code>, <code class="reqn">\mathcal{G}_{l}</code>) share a common border or are considered neighbours by some other measure, and <code class="reqn">a_{sl} = 0</code> otherwise. Note, <code class="reqn">a_{ss} = 0</code> for all <code class="reqn">s</code>. <code class="reqn">\boldsymbol{\phi}_{-s}=(\phi_1,\ldots,\phi_{s-1}, \phi_{s+1},\ldots,\phi_{S})</code>. Here  <code class="reqn">\tau^{2}</code> is a measure of the variance relating to the spatial random effects <code class="reqn">\boldsymbol{\phi}</code>, while <code class="reqn">\rho</code> controls the level of spatial autocorrelation, with values close to one and zero representing strong autocorrelation and independence respectively. A non-conjugate uniform prior on the unit interval is specified for the single level of spatial autocorrelation <code class="reqn">\rho</code>. In contrast, a conjugate Inverse-Gamma prior is specified for the random effects variance <code class="reqn">\tau^{2}</code>, and corresponding hyperparamaterers (<code class="reqn">\alpha_{1}</code>, <code class="reqn">\xi_{1}</code>) can be chosen by the user.
</p>
<p>The <code class="reqn">J \times 1</code> vector of alter random effects are denoted by <code class="reqn">\boldsymbol{u} = (u_{1}, \ldots, u_{J})_{J \times 1}</code> and modelled as independently Gaussian with mean zero and a constant variance, and due to the row standardised nature of <code class="reqn">\boldsymbol{W}</code>, <code class="reqn">\sum_{j \in \textrm{net}(i_s)} w_{i_sj} u_{j}</code> represents the average (mean) effect that the peers of individual <code class="reqn">i</code> in spatial unit or group <code class="reqn">s</code> have on that individual. <code class="reqn">w^{*}_{i_s}u^{*}</code> is an <em>isolation effect</em>, which is an effect for individuals who don't nominate any friends. This is achieved by setting <code class="reqn">w^{*}_{i_s}=1</code> if individual <code class="reqn">i_s</code> nominates no peers and <code class="reqn">w^{*}_{i_s}=0</code> otherwise, and if  <code class="reqn">w^{*}_{i_s}=1</code> then clearly <code class="reqn">\sum_{j\in \textrm{net}(i_{s})}w_{i_{s}j}u_{jr}=0</code> as <code class="reqn">\textrm{net}(i_{s})</code> is the empty set. A conjugate Inverse-Gamma prior is specified for the random effects variance <code class="reqn">\sigma_{u}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{2}</code>, <code class="reqn">\xi_{2}</code>) can be chosen by the user.
</p>
<p>The exact specification of each of the likelihoods (binomial, Gaussian, and Poisson) are given below:
</p>
<p style="text-align: center;"><code class="reqn">\textrm{Binomial:} ~ Y_{i_s} \sim \textrm{Binomial}(n_{i_s}, \theta_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\theta_{i_s} / (1 - \theta_{i_s})),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Gaussian:} ~ Y_{i_s} \sim \textrm{N}(\mu_{i_s}, \sigma_{e}^{2}) ~ \textrm{and} ~ g(\mu_{i_s}) = \mu_{i_s},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Poisson:} ~ Y_{i_s} \sim \textrm{Poisson}(\mu_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\mu_{i_s}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>uniNetLeroux(formula, data, trials, family,
squareSpatialNeighbourhoodMatrix, spatialAssignment, W, numberOfSamples = 10, 
burnin = 0, thin = 1, seed = 1, trueBeta = NULL, 
trueSpatialRandomEffects = NULL, trueURandomEffects = NULL, 
trueSpatialTauSquared = NULL, trueSpatialRho = NULL, trueSigmaSquaredU = NULL,
trueSigmaSquaredE = NULL, covarianceBetaPrior = 10^5, a1 = 0.001, b1 = 0.001, 
a2 = 0.001, b2 = 0.001, a3 = 0.001, b3 = 0.001, 
centerSpatialRandomEffects = TRUE, centerURandomEffects = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniNetLeroux_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using a similar 
syntax to that used in the lm() function.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the variables in the formula.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
<code class="reqn">n_{i_s}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_family">family</code></td>
<td>

<p>The data likelihood model that must be &ldquo;gaussian&quot;, &ldquo;poisson&quot; or 
&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_squarespatialneighbourhoodmatrix">squareSpatialNeighbourhoodMatrix</code></td>
<td>

<p>An <code class="reqn">S \times S</code> symmetric and non-negative neighbourhood 
matrix <code class="reqn">\boldsymbol{A} = (a_{sl})_{S \times S}</code>. 
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_w">W</code></td>
<td>

<p>A matrix <code class="reqn">\boldsymbol{W}</code> that encodes the social network structure and whose rows sum to 1.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_spatialassignment">spatialAssignment</code></td>
<td>

<p>The binary matrix of individual's assignment to spatial area used in the model fitting process.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_numberofsamples">numberOfSamples</code></td>
<td>

<p>The number of samples to generate pre-thin.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_thin">thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_seed">seed</code></td>
<td>

<p>A seed for the MCMC algorithm.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_truebeta">trueBeta</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\beta}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_truespatialrandomeffects">trueSpatialRandomEffects</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\phi}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_trueurandomeffects">trueURandomEffects</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{u}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_truespatialtausquared">trueSpatialTauSquared</code></td>
<td>

<p>If available, the true value of <code class="reqn">\tau^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_truespatialrho">trueSpatialRho</code></td>
<td>

<p>If available, the true value of<code class="reqn">\rho</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_truesigmasquaredu">trueSigmaSquaredU</code></td>
<td>

<p>If available, the true value of <code class="reqn">\sigma_{u}^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_truesigmasquarede">trueSigmaSquaredE</code></td>
<td>

<p>If available, the true value of <code class="reqn">\sigma_{e}^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_covariancebetaprior">covarianceBetaPrior</code></td>
<td>

<p>A scalar prior <code class="reqn">\alpha</code> for the covariance parameter of the 
beta prior, such that the covariance is <code class="reqn">\alpha\boldsymbol{I}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_a1">a1</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the spatial random effects <code class="reqn">\alpha_{1}</code>. 
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_b1">b1</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the spatial random effects <code class="reqn">\xi_{1}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_a2">a2</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the network random effects <code class="reqn">\alpha_{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_b2">b2</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the network random effects <code class="reqn">\xi_{2}</code>. 
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_a3">a3</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\alpha_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_b3">b3</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\xi_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_centerspatialrandomeffects">centerSpatialRandomEffects</code></td>
<td>

<p>A choice to center the spatial random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
<tr><td><code id="uniNetLeroux_+3A_centerurandomeffects">centerURandomEffects</code></td>
<td>

<p>A choice to center the network random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>

<p>The matched call.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The response used.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>The design matrix used.
</p>
</td></tr>
<tr><td><code>standardizedX</code></td>
<td>

<p>The standardized design matrix used.
</p>
</td></tr>
<tr><td><code>squareSpatialNeighbourhoodMatrix</code></td>
<td>

<p>The spatial neighbourhood matrix used.
</p>
</td></tr>
<tr><td><code>spatialAssignment</code></td>
<td>

<p>The spatial assignment matrix used.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>The network matrix used.
</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>

<p>The matrix of simulated samples from the posterior
distribution of each parameter in the model (excluding random effects).
</p>
</td></tr>
<tr><td><code>betaSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\beta}</code> parameters in the model.
</p>
</td></tr>
<tr><td><code>spatialTauSquaredSamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\tau^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>spatialRhoSamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\rho</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredUSamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{u}^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredESamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{e}^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>spatialRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of spatial/grouping random effects <code class="reqn">\boldsymbol{\phi}</code> in the model.
</p>
</td></tr>
<tr><td><code>uRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of network random effects <code class="reqn">\boldsymbol{u}</code> in the model.
</p>
</td></tr>
<tr><td><code>acceptanceRates</code></td>
<td>

<p>The acceptance rates of parameters in the model (excluding 
random effects) from the MCMC sampling scheme .
</p>
</td></tr>
<tr><td><code>spatialRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of spatial/grouping random effects in the
model from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>uRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of network random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>timeTaken</code></td>
<td>

<p>The time taken for the model to run.
</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code>DBar</code></td>
<td>

<p>DBar for the model.
</p>
</td></tr>
<tr><td><code>posteriorDeviance</code></td>
<td>

<p>The posterior deviance for the model.
</p>
</td></tr>
<tr><td><code>posteriorLogLikelihood</code></td>
<td>

<p>The posterior log likelihood for the model.
</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>

<p>The number of effective parameters in the model.
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>The DIC for the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #################################################
  #### Run the model on simulated data
  #################################################
  #### Load other libraries required
  library(MCMCpack)
  
  #### Set up a network
  observations &lt;- 200
  numberOfMultipleClassifications &lt;- 50
  W &lt;- matrix(rbinom(observations * numberOfMultipleClassifications, 1, 0.05), 
              ncol = numberOfMultipleClassifications)
  numberOfActorsWithNoPeers &lt;- sum(apply(W, 1, function(x) { sum(x) == 0 }))
  peers &lt;- sample(1:numberOfMultipleClassifications, numberOfActorsWithNoPeers,
  TRUE)
  actorsWithNoPeers &lt;- which(apply(W, 1, function(x) { sum(x) == 0 }))
  for(i in 1:numberOfActorsWithNoPeers) {
    W[actorsWithNoPeers[i], peers[i]] &lt;- 1
  }
  W &lt;- t(apply(W, 1, function(x) { x / sum(x) }))
  
  #### Set up a spatial structure
  numberOfSpatialAreas &lt;- 100
  factor = sample(1:numberOfSpatialAreas, observations, TRUE)
  spatialAssignment = matrix(NA, ncol = numberOfSpatialAreas, 
                             nrow = observations)
  for(i in 1:length(factor)){
    for(j in 1:numberOfSpatialAreas){
      if(factor[i] == j){
        spatialAssignment[i, j] = 1
      } else {
        spatialAssignment[i, j] = 0
      }
    }
  }
  
  gridAxis = sqrt(numberOfSpatialAreas)
  easting = 1:gridAxis
  northing = 1:gridAxis
  grid = expand.grid(easting, northing)
  numberOfRowsInGrid = nrow(grid)
  distance = as.matrix(dist(grid))
  squareSpatialNeighbourhoodMatrix = array(0, c(numberOfRowsInGrid, 
                                                numberOfRowsInGrid))
  squareSpatialNeighbourhoodMatrix[distance==1] = 1

  #### Generate the covariates and response data
  X &lt;- matrix(rnorm(2 * observations), ncol = 2)
  colnames(X) &lt;- c("x1", "x2")
  beta &lt;- c(2, -2, 2)
  
  spatialRho &lt;- 0.5
  spatialTauSquared &lt;- 2
  spatialPrecisionMatrix = spatialRho * 
    (diag(apply(squareSpatialNeighbourhoodMatrix, 1, sum)) -
     squareSpatialNeighbourhoodMatrix) + (1 - spatialRho) * 
     diag(rep(1, numberOfSpatialAreas))
  spatialCovarianceMatrix = solve(spatialPrecisionMatrix)
  spatialPhi = mvrnorm(n = 1, mu = rep(0, numberOfSpatialAreas), 
                       Sigma = (spatialTauSquared * spatialCovarianceMatrix))
  
  sigmaSquaredU &lt;- 2
  uRandomEffects &lt;- rnorm(numberOfMultipleClassifications, mean = 0, 
                          sd = sqrt(sigmaSquaredU))
  
  logit &lt;- cbind(rep(1, observations), X) %*% beta + 
    spatialAssignment %*% spatialPhi + W %*% uRandomEffects
  prob &lt;- exp(logit) / (1 + exp(logit))
  trials &lt;- rep(50, observations)
  Y &lt;- rbinom(n = observations, size = trials, prob = prob)
  data &lt;- data.frame(cbind(Y, X))
  
  #### Run the model
  formula &lt;- Y ~ x1 + x2
  ## Not run: model &lt;- uniNetLeroux(formula = formula, data = data, 
    family="binomial",  W = W,
    spatialAssignment = spatialAssignment, 
    squareSpatialNeighbourhoodMatrix = squareSpatialNeighbourhoodMatrix,
    trials = trials, numberOfSamples = 10000, 
    burnin = 10000, thin = 10, seed = 1)
## End(Not run)
</code></pre>

<hr>
<h2 id='uniNetRand'>
A function that generates samples for a univariate network group model.
</h2><span id='topic+uniNetRand'></span>

<h3>Description</h3>

<p>This function generates samples for a univariate network group model, which is
given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{i_s}|\mu_{i_s} \sim f(y_{i_s}| \mu_{i_s}, \sigma_{e}^{2}) ~~~ i=1,\ldots, N_{s},~s=1,\ldots,S ,</code>
</p>

<p style="text-align: center;"><code class="reqn">g(\mu_{i_s}) = \boldsymbol{x}^\top_{i_s} \boldsymbol{\beta} + v_{s} + \sum_{j\in \textrm{net}(i_s)}w_{i_sj}u_{j} + w^{*}_{i_s}u^{*},</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta} \sim \textrm{N}(\boldsymbol{0}, \alpha\boldsymbol{I}),</code>
</p>

<p style="text-align: center;"><code class="reqn">v_{s} \sim \textrm{N}(0, \tau^{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">u_{j} \sim \textrm{N}(0, \sigma_{u}^{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">u^{*} \sim \textrm{N}(0, \sigma_{u}^{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau^{2} \sim \textrm{Inverse-Gamma}(\alpha_{1}, \xi_{1}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{u}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{2}, \xi_{2}),</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma_{e}^{2} \sim \textrm{Inverse-Gamma}(\alpha_{3}, \xi_{3}).</code>
</p>

<p>The covariates for the <code class="reqn">i</code>th individual in the <code class="reqn">s</code>th spatial unit or other grouping are included in a <code class="reqn">p \times 1</code> vector <code class="reqn">\boldsymbol{x}_{i_s}</code>. The corresponding <code class="reqn">p \times 1</code> vector of fixed effect parameters are denoted by <code class="reqn">\boldsymbol{\beta}</code>, which has an assumed multivariate Gaussian prior with mean <code class="reqn">\boldsymbol{0}</code> and diagonal covariance matrix <code class="reqn">\alpha\boldsymbol{I}</code> that can be chosen by the user. A conjugate Inverse-Gamma prior is specified for <code class="reqn">\sigma_{e}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{3}</code>, <code class="reqn">\xi_{3}</code>) can be chosen by the user.
</p>
<p>The <code class="reqn">S \times 1</code> vector of random effects for the groups are collectively denoted by  <code class="reqn">\boldsymbol{v} = (v_{1}, \ldots, v_{S})_{S \times 1}</code>, and each element is assigned an independent zero-mean Gaussian prior distribution with a constant variance <code class="reqn">\tau^{2}</code>.  A conjugate Inverse-Gamma prior is specified for <code class="reqn">\tau^{2}</code>. The corresponding hyperparamaterers (<code class="reqn">\alpha_{1}</code>, <code class="reqn">\xi_{1}</code>) can be chosen by the user.
</p>
<p>The <code class="reqn">J \times 1</code> vector of alter random effects are denoted by <code class="reqn">\boldsymbol{u} = (u_{1}, \ldots, u_{J})_{J \times 1}</code> and modelled as independently Gaussian with mean zero and a constant variance, and due to the row standardised nature of <code class="reqn">\boldsymbol{W}</code>, <code class="reqn">\sum_{j \in \textrm{net}(i_s)} w_{i_sj} u_{j}</code> represents the average (mean) effect that the peers of individual <code class="reqn">i</code> in spatial unit or group <code class="reqn">s</code> have on that individual. <code class="reqn">w^{*}_{i_s}u^{*}</code> is an <em>isolation effect</em>, which is an effect for individuals who don't nominate any friends. This is achieved by setting <code class="reqn">w^{*}_{i_s}=1</code> if individual <code class="reqn">i_s</code> nominates no peers and <code class="reqn">w^{*}_{i_s}=0</code> otherwise, and if  <code class="reqn">w^{*}_{i_s}=1</code> then clearly <code class="reqn">\sum_{j\in \textrm{net}(i_{s})}w_{i_{s}j}u_{jr}=0</code> as <code class="reqn">\textrm{net}(i_{s})</code> is the empty set. A conjugate Inverse-Gamma prior is specified for the random effects variance <code class="reqn">\sigma_{u}^{2}</code>, and the corresponding hyperparamaterers (<code class="reqn">\alpha_{2}</code>, <code class="reqn">\xi_{2}</code>) can be chosen by the user.
</p>
<p>The exact specification of each of the likelihoods (binomial, Gaussian, and Poisson) are given below:
</p>
<p style="text-align: center;"><code class="reqn">\textrm{Binomial:} ~ Y_{i_s} \sim \textrm{Binomial}(n_{i_s}, \theta_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\theta_{i_s} / (1 - \theta_{i_s})),</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Gaussian:} ~ Y_{i_s} \sim \textrm{N}(\mu_{i_s}, \sigma_{e}^{2}) ~ \textrm{and} ~ g(\mu_{i_s}) = \mu_{i_s},</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{Poisson:} ~ Y_{i_s} \sim \textrm{Poisson}(\mu_{i_s}) ~ \textrm{and} ~ g(\mu_{i_s}) = \textrm{ln}(\mu_{i_s}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>uniNetRand(formula, data, trials, family, groupAssignment, W, numberOfSamples = 10, 
burnin = 0, thin = 1, seed = 1, trueBeta = NULL, 
trueGroupRandomEffects = NULL, trueURandomEffects = NULL, 
trueTauSquared = NULL, trueSigmaSquaredU = NULL, 
trueSigmaSquaredE = NULL, covarianceBetaPrior = 10^5, a1 = 0.001, b1 = 0.001, 
a2 = 0.001, b2 = 0.001, a3 = 0.001, b3 = 0.001, 
centerGroupRandomEffects = TRUE, centerURandomEffects = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniNetRand_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using a similar 
syntax to that used in the lm() function.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the variables in the formula.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
<code class="reqn">n_{i_s}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_family">family</code></td>
<td>

<p>The data likelihood model that must be &ldquo;gaussian&quot;, &ldquo;poisson&quot; or &ldquo;binomial&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_w">W</code></td>
<td>

<p>A matrix <code class="reqn">\boldsymbol{W}</code> that encodes the social network structure and whose rows sum to 1.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_groupassignment">groupAssignment</code></td>
<td>

<p>The binary matrix of individual's assignment to groups used in the model fitting process.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_numberofsamples">numberOfSamples</code></td>
<td>

<p>The number of samples to generate pre-thin.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_thin">thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_seed">seed</code></td>
<td>

<p>A seed for the MCMC algorithm.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_truebeta">trueBeta</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{\beta}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_truegrouprandomeffects">trueGroupRandomEffects</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{v}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_trueurandomeffects">trueURandomEffects</code></td>
<td>

<p>If available, the true value of <code class="reqn">\boldsymbol{u}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_truetausquared">trueTauSquared</code></td>
<td>

<p>If available, the true value <code class="reqn">\tau^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_truesigmasquaredu">trueSigmaSquaredU</code></td>
<td>

<p>If available, the true value <code class="reqn">\sigma_{u}^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_truesigmasquarede">trueSigmaSquaredE</code></td>
<td>

<p>If available, the true value <code class="reqn">\sigma_{e}^{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_covariancebetaprior">covarianceBetaPrior</code></td>
<td>

<p>A scalar prior <code class="reqn">\alpha</code> for the covariance parameter of the 
beta prior, such that the covariance is <code class="reqn">\alpha\boldsymbol{I}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_a1">a1</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the group random effects <code class="reqn">\alpha_{1}</code>. 
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_b1">b1</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the group random effects <code class="reqn">\xi_{1}</code>. 
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_a2">a2</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the network random effects <code class="reqn">\alpha_{2}</code>.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_b2">b2</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the network random effects <code class="reqn">\xi_{2}</code>. 
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_a3">a3</code></td>
<td>

<p>The shape parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\alpha_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_b3">b3</code></td>
<td>

<p>The scale parameter for the Inverse-Gamma distribution 
relating to the error terms <code class="reqn">\xi_{3}</code>. Only used if <code class="reqn">\texttt{family}</code>=&ldquo;gaussian&quot;.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_centergrouprandomeffects">centerGroupRandomEffects</code></td>
<td>

<p>A choice to center the group random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
<tr><td><code id="uniNetRand_+3A_centerurandomeffects">centerURandomEffects</code></td>
<td>

<p>A choice to center the network random effects after each 
iteration of the MCMC sampler.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>

<p>The matched call.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The response used.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>

<p>The design matrix used.
</p>
</td></tr>
<tr><td><code>standardizedX</code></td>
<td>

<p>The standardized design matrix used.
</p>
</td></tr>
<tr><td><code>groupAssignment</code></td>
<td>

<p>The group assignment matrix used.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>The network matrix used.
</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>

<p>The matrix of simulated samples from the posterior
distribution of each parameter in the model (excluding random effects).
</p>
</td></tr>
<tr><td><code>betaSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of <code class="reqn">\boldsymbol{\beta}</code> parameters in the model.
</p>
</td></tr>
<tr><td><code>tauSquaredSamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\tau^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredUSamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{u}^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>sigmaSquaredESamples</code></td>
<td>

<p>The vector of simulated samples from the posterior 
distribution of <code class="reqn">\sigma_{e}^{2}</code> in the model.
</p>
</td></tr>
<tr><td><code>groupRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of spatial/grouping random effects <code class="reqn">\boldsymbol{v}</code> in the model.
</p>
</td></tr>
<tr><td><code>uRandomEffectsSamples</code></td>
<td>

<p>The matrix of simulated samples from the posterior 
distribution of network random effects <code class="reqn">\boldsymbol{u}</code> in the model.
</p>
</td></tr>
<tr><td><code>acceptanceRates</code></td>
<td>

<p>The acceptance rates of parameters in the model (excluding 
random effects) from the MCMC sampling scheme .
</p>
</td></tr>
<tr><td><code>groupRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of spatial/grouping random effects in the
model from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>uRandomEffectsAcceptanceRate</code></td>
<td>

<p>The acceptance rates of network random effects in the model 
from the MCMC sampling scheme.
</p>
</td></tr>
<tr><td><code>timeTaken</code></td>
<td>

<p>The time taken for the model to run.
</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period.
</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>

<p>The value by which to thin <code class="reqn">\texttt{numberOfSamples}</code>.
</p>
</td></tr>
<tr><td><code>DBar</code></td>
<td>

<p>DBar for the model.
</p>
</td></tr>
<tr><td><code>posteriorDeviance</code></td>
<td>

<p>The posterior deviance for the model.
</p>
</td></tr>
<tr><td><code>posteriorLogLikelihood</code></td>
<td>

<p>The posterior log likelihood for the model.
</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>

<p>The number of effective parameters in the model.
</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>

<p>The DIC for the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Gerogiannis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #################################################
  #### Run the model on simulated data
  #################################################
  #### Load other libraries required
  library(MCMCpack)
  
  #### Set up a network
  observations &lt;- 200
  numberOfMultipleClassifications &lt;- 50
  W &lt;- matrix(rbinom(observations * numberOfMultipleClassifications, 1, 0.05), 
              ncol = numberOfMultipleClassifications)
  numberOfActorsWithNoPeers &lt;- sum(apply(W, 1, function(x) { sum(x) == 0 }))
  peers &lt;- sample(1:numberOfMultipleClassifications, numberOfActorsWithNoPeers, 
                  TRUE)
  actorsWithNoPeers &lt;- which(apply(W, 1, function(x) { sum(x) == 0 }))
  for(i in 1:numberOfActorsWithNoPeers) {
    W[actorsWithNoPeers[i], peers[i]] &lt;- 1
  }
  W &lt;- t(apply(W, 1, function(x) { x / sum(x) }))
  
  #### Set up a single level classification
  numberOfSingleClassifications &lt;- 20
  factor = sample(1:numberOfSingleClassifications, observations, TRUE)
  V = matrix(NA, ncol = numberOfSingleClassifications, nrow = observations)
  for(i in 1:length(factor)){
    for(j in 1:numberOfSingleClassifications){
      if(factor[i] == j){
        V[i, j] = 1
      } else {
        V[i, j] = 0
      }
    }
  }
  
  #### Generate the covariates and response data
  X &lt;- matrix(rnorm(2 * observations), ncol = 2)
  colnames(X) &lt;- c("x1", "x2")
  beta &lt;- c(1, -0.5, 0.5)
  tauSquared &lt;- 0.5
  vRandomEffects &lt;- rnorm(numberOfSingleClassifications, mean = 0, 
                          sd = sqrt(tauSquared))
  sigmaSquaredU &lt;- 1
  uRandomEffects &lt;- rnorm(numberOfMultipleClassifications, mean = 0, 
                          sd = sqrt(sigmaSquaredU))

  logTheta &lt;- cbind(rep(1, observations), X) %*% beta + V %*% vRandomEffects 
            + W %*% uRandomEffects
  Y &lt;- rpois(n = observations, lambda = exp(logTheta))
  data &lt;- data.frame(cbind(Y, X))
  
  #### Run the model
  formula &lt;- Y ~ x1 + x2
  ## Not run: model &lt;- uniNetRand(formula = formula, data = data, family="poisson", 
                               W = W, groupAssignment = V, 
                               numberOfSamples = 10000, burnin = 10000,
                               thin = 10, seed = 1)
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
