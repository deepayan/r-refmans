<!DOCTYPE html><html><head><title>Help for package qfratio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qfratio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a1_pk'><p>Recursion for a_{p,k}</p></a></li>
<li><a href='#d1_i'><p>Coefficients in polynomial expansion of generating function&mdash;single matrix</p></a></li>
<li><a href='#d2_ij'><p>Coefficients in polynomial expansion of generating function&mdash;for</p>
ratios with two matrices</a></li>
<li><a href='#d3_ijk'><p>Coefficients in polynomial expansion of generating function&mdash;for</p>
ratios with three matrices</a></li>
<li><a href='#dqfr'><p>Probability distribution of ratio of quadratic forms</p></a></li>
<li><a href='#dtil2_pq'><p>Coefficients in polynomial expansion of generating function&mdash;for products</p></a></li>
<li><a href='#hgs'><p>Calculate hypergeometric series</p></a></li>
<li><a href='#hyperg_1F1_vec_b'><p>Internal C++ wrappers for GSL</p></a></li>
<li><a href='#is_diagonal'><p>Is this matrix diagonal?</p></a></li>
<li><a href='#iseq'><p>Are these vectors equal?</p></a></li>
<li><a href='#KiK'><p>Matrix square root and generalized inverse</p></a></li>
<li><a href='#new_qfrm'><p>Construct qfrm object</p></a></li>
<li><a href='#p_A1B1_Ed'><p>Internal C++ functions</p></a></li>
<li><a href='#print.qfrm'><p>Methods for qfrm and qfpm objects</p></a></li>
<li><a href='#qfmrm'><p>Moment of multiple ratio of quadratic forms in normal variables</p></a></li>
<li><a href='#qfpm'><p>Moment of (product of) quadratic forms in normal variables</p></a></li>
<li><a href='#qfratio-package'><p>qfratio: Moments and Distributions of Ratios of Quadratic Forms</p></a></li>
<li><a href='#qfrm'><p>Moment of ratio of quadratic forms in normal variables</p></a></li>
<li><a href='#range_qfr'><p>Get range of ratio of quadratic forms</p></a></li>
<li><a href='#rqfr'><p>Monte Carlo sampling of ratio/product of quadratic forms</p></a></li>
<li><a href='#S_fromUL'><p>Make covariance matrix from eigenstructure</p></a></li>
<li><a href='#sum_counterdiag'><p>Summing up counter-diagonal elements</p></a></li>
<li><a href='#tr'><p>Matrix trace function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Moments and Distributions of Ratios of Quadratic Forms Using
Recursion</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluates moments of ratios (and products) of quadratic forms
    in normal variables, specifically using recursive algorithms developed by
    Bao and Kan (2013) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2013.03.002">doi:10.1016/j.jmva.2013.03.002</a>&gt; and Hillier et al.
    (2014) &lt;<a href="https://doi.org/10.1017%2FS0266466613000364">doi:10.1017/S0266466613000364</a>&gt;. Also provides distribution,
    quantile, and probability density functions of simple ratios of quadratic
    forms in normal variables with several algorithms. Originally developed as
    a supplement to Watanabe (2023) &lt;<a href="https://doi.org/10.1007%2Fs00285-023-01930-8">doi:10.1007/s00285-023-01930-8</a>&gt; for
    evaluating average evolvability measures in evolutionary quantitative
    genetics, but can be used for a broader class of statistics. Generating 
    functions for these moments are also closely related to the top-order zonal
    and invariant polynomials of matrix arguments.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/watanabe-j/qfratio">https://github.com/watanabe-j/qfratio</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/watanabe-j/qfratio/issues">https://github.com/watanabe-j/qfratio/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, MASS, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, CompQuadForm, graphics, testthat (&ge; 3.0.0), knitr,
rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 11:26:43 UTC; jw</td>
</tr>
<tr>
<td>Author:</td>
<td>Junya Watanabe <a href="https://orcid.org/0000-0002-9810-5286"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Patrick Alken [cph] (Author of bundled C codes from GSL),
  Brian Gough [cph] (Author of bundled C codes from GSL),
  Pavel Holoborodko [cph] (Author of bundled C codes from GSL),
  Gerard Jungman [cph] (Author of bundled C codes from GSL),
  Reid Priedhorsky [cph] (Author of bundled C codes from GSL),
  Free Software Foundation, Inc. [cph] (Copyright holder of some bundled
    scripts)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Junya Watanabe &lt;Junya.Watanabe@uab.cat&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 00:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='a1_pk'>Recursion for a_{p,k}</h2><span id='topic+a1_pk'></span>

<h3>Description</h3>

<p><code>a1_pk()</code> is an internal function to calculate <code class="reqn">a_{p,k}</code>
(<code class="reqn">a_{r,l}</code> in Hillier et al. 2014; eq. 24), which is used in the
calculation of the moment of such a ratio of quadratic forms in normal
variables where the denominator matrix is identity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a1_pk(L, mu = rep.int(0, n), m = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a1_pk_+3A_l">L</code></td>
<td>
<p>Eigenvalues of the argument matrix; vector of <code class="reqn">\lambda_i</code></p>
</td></tr>
<tr><td><code id="a1_pk_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="a1_pk_+3A_m">m</code></td>
<td>
<p>Scalar to specify the desired order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the super-short recursion described in
Hillier et al. (2014  eqs. 31&ndash;32).  Note that
<code class="reqn">w_{r,i}</code> there should be understood as <code class="reqn">w_{r,l,i}</code> with
the index <code class="reqn">l</code> fixed for each <code class="reqn">a_{r,l}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfrm_ApIq_int">qfrm_ApIq_int</a>()</code>, in which this function is used
(for noncentral cases only)
</p>

<hr>
<h2 id='d1_i'>Coefficients in polynomial expansion of generating function&mdash;single matrix</h2><span id='topic+d1_i'></span><span id='topic+dtil1_i'></span><span id='topic+dtil1_i_v'></span><span id='topic+dtil1_i_m'></span>

<h3>Description</h3>

<p>These are internal functions to calculate the coefficients
in polynomial expansion of generating functions for quadratic forms
in multivariate normal variables.
</p>
<p><code>d1_i()</code> is for standard multivariate normal variables,
<code class="reqn">\mathbf{x} \sim N_n(\mathbf{0}_n, \mathbf{I}_n)</code>.
</p>
<p><code>dtil1_i_v()</code> is for noncentral multivariate normal variables,
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{I}_n)</code>.
</p>
<p><code>dtil1_i_m()</code> is a wrapper for <code>dtil1_i_v()</code>
and takes the argument matrix rather than its eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d1_i(L, m = 100L, thr_margin = 100)

dtil1_i_v(L, mu = rep.int(0, n), m = 100L, thr_margin = 100)

dtil1_i_m(A, mu = rep.int(0, n), m = 100L, thr_margin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d1_i_+3A_l">L</code></td>
<td>
<p>Vector of eigenvalues of the argument matrix</p>
</td></tr>
<tr><td><code id="d1_i_+3A_m">m</code></td>
<td>
<p>Integer-alike to specify the order of polynomials</p>
</td></tr>
<tr><td><code id="d1_i_+3A_thr_margin">thr_margin</code></td>
<td>
<p>Optional argument to adjust the threshold for scaling
(see &ldquo;Details&rdquo;)</p>
</td></tr>
<tr><td><code id="d1_i_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="d1_i_+3A_a">A</code></td>
<td>
<p>Argument matrix.  Assumed to be symmetric in these functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>d1_i()</code> calculates <code class="reqn">d_k(\mathbf{A})</code>, and
<code>dtil1_i_v()</code> and <code>dtil1_i_m()</code> calculate
<code class="reqn">\tilde{d}_k(\mathbf{A})</code> in
Hillier et al. (2009, 2014) and Bao and Kan (2013).  The former is
related to the top-order zonal polynomial
<code class="reqn">C_{[k]}(\mathbf{A})</code> in the following way:
<code class="reqn"> d_k(\mathbf{A}) = \frac{1}{k!} \left( \frac{1}{2} \right)_k
     C_{[k]}(\mathbf{A}) </code>,
where <code class="reqn">(x)_k = x (x + 1) \dots (x + k - 1)</code>.
</p>
<p>These functions calculate the coefficients based on the super-short
recursion algorithm described in Hillier et al. (2014: 3.2, eqs. 28&ndash;30).
</p>


<h4>Scaling</h4>

<p>The coefficients described herein (and in <code><a href="#topic+d2_ij">d2_ij</a></code> and
<code><a href="#topic+d3_ijk">d3_ijk</a></code>) can become very large for higher-order terms,
so there is a practical risk of numerical overflow when applied to
large matrices or matrices with many large eigenvalues
(note that the latter typically arises from those with many small
eigenvalues for the front-end <code>qfrm()</code> functions).  To avoid
numerical overflow, these functions automatically scale
coefficients (and temporary objects used to calculate them) by a large number
(<code>1e10</code> at present) when any value in the temporary objects exceeds
a threshold, <code>.Machine$double.xmax / thr_margin / n</code>, where <code>n</code>
is the number of variables.  This default value empirically seems to work well
in most conditions, but use a large <code>thr_margin</code> (e.g., <code>1e5</code>)
if you encounter numerical overflow.  (The C++ functions use
an equivalent expression,
<code>std::numeric_limits&lt;Scalar&gt;::max() / thr_margin / Scalar(n)</code>, with
<code>Scalar</code> being <code>double</code> or <code>long double</code>.)
</p>
<p>In these <span class="rlang"><b>R</b></span> functions, the scaling happens order-wise;
i.e., it influences all the coefficients of the same order in
multidimensional coefficients (in <code><a href="#topic+d2_ij">d2_ij</a></code> and
<code><a href="#topic+d3_ijk">d3_ijk</a></code>) and the coefficients of the subsequent orders.
</p>
<p>These scaling factors are recorded in the attribute <code>"logscale"</code> of the
return value, which is a vector/matrix/array whose size is identical to the
return value, so that <code>value / exp(attr(value, "logscale"))</code> equals
the original quantities to be obtained (if there were no overflow).
</p>
<p>The <code>qfrm</code> and <code>qfmrm</code> functions handle return values of these
functions by first multiplying them with hypergeometric coefficients
(which are typically <code class="reqn">\ll 1</code>) and then scaling the products back
to the original scale using the recorded scaling factors.  (To be precise,
this typically happens within <code><a href="#topic+hgs">hgs</a></code> functions.)  The
C++ functions handle the problem similarly (but by using
separate objects rather than attributes).
</p>
<p>However, this procedure does not always mitigate the problem in
multiple series; when there are very large and very small
coefficients in the same order, smaller ones can diminish/underflow to
the numerical <code>0</code> after repeated scaling.  (The <code>qfrm</code> and
<code>qfmrm</code> functions try to detect and warn against
this by examining whether any of the highest-order terms is <code>0</code>.)
The present version of this package has implemented two methods to mitigate
this problem, but only through C++ functions.  One is to use the
<code>long double</code> variable type, and the other is to use coefficient-wise
scaling (see <code><a href="#topic+qfrm">qfrm</a></code> and <code><a href="#topic+qfmrm">qfmrm</a></code>).
</p>



<h3>Value</h3>

<p>Vector of length <code>m + 1</code>, corresponding to
the 0th, 1st, ..., and mth order terms.  Hence, the <code>[m + 1]</code>-th
element should be extracted when the coefficient for the <code class="reqn">m</code>th order
term is required.
</p>
<p>Has the attribute <code>"logscale"</code> as described in &ldquo;Scaling&rdquo; above.
</p>


<h3>References</h3>

<p>Bao, Y. and Kan, R. (2013) On the moments of ratios of quadratic forms in
normal random variables. <em>Journal of Multivariate Analysis</em>, <strong>117</strong>,
229&ndash;245.
<a href="https://doi.org/10.1016/j.jmva.2013.03.002">doi:10.1016/j.jmva.2013.03.002</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2009) Computationally efficient recursions
for top-order invariant polynomials with applications.
<em>Econometric Theory</em>, <strong>25</strong>, 211&ndash;242.
<a href="https://doi.org/10.1017/S0266466608090075">doi:10.1017/S0266466608090075</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2014) Generating functions and
short recursions, with applications to the moments of quadratic forms
in noncentral normal vectors. <em>Econometric Theory</em>, <strong>30</strong>, 436&ndash;473.
<a href="https://doi.org/10.1017/S0266466613000364">doi:10.1017/S0266466613000364</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfpm">qfpm</a></code>, <code><a href="#topic+qfrm">qfrm</a></code>, and <code><a href="#topic+qfmrm">qfmrm</a></code> are
major front-end functions that utilize these functions
</p>
<p><code><a href="#topic+dtil2_pq">dtil2_pq</a></code> for <code class="reqn">\tilde{d}</code>
used for moments of a product of quadratic forms
</p>
<p><code><a href="#topic+d2_ij">d2_ij</a></code> and <code><a href="#topic+d3_ijk">d3_ijk</a></code> for <code class="reqn">d</code>, <code class="reqn">h</code>,
<code class="reqn">\tilde{h}</code>, and <code class="reqn">\hat{h}</code> used for moments of ratios
of quadratic forms
</p>

<hr>
<h2 id='d2_ij'>Coefficients in polynomial expansion of generating function&mdash;for
ratios with two matrices</h2><span id='topic+d2_ij'></span><span id='topic+d2_pj'></span><span id='topic+h2_ij'></span><span id='topic+htil2_pj'></span><span id='topic+hhat2_pj'></span><span id='topic+d2_1j'></span><span id='topic+htil2_1j'></span><span id='topic+hhat2_1j'></span><span id='topic+d2_ij_m'></span><span id='topic+d2_ij_v'></span><span id='topic+d2_pj_m'></span><span id='topic+d2_1j_m'></span><span id='topic+d2_pj_v'></span><span id='topic+d2_1j_v'></span><span id='topic+h2_ij_m'></span><span id='topic+h2_ij_v'></span><span id='topic+htil2_pj_m'></span><span id='topic+htil2_1j_m'></span><span id='topic+htil2_pj_v'></span><span id='topic+htil2_1j_v'></span><span id='topic+hhat2_pj_m'></span><span id='topic+hhat2_1j_m'></span><span id='topic+hhat2_pj_v'></span><span id='topic+hhat2_1j_v'></span>

<h3>Description</h3>

<p>These are internal functions to calculate the coefficients
in polynomial expansion of joint generating functions for two
quadratic forms in potentially noncentral multivariate normal variables,
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{I}_n)</code>.  They
are primarily used in calculations around moments of a ratio
involving two or three quadratic forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2_ij_m(
  A1,
  A2,
  m = 100L,
  p = m,
  q = m,
  thr_margin = 100,
  fill_all = !missing(p) || !missing(q)
)

d2_ij_v(
  L1,
  L2,
  m = 100L,
  p = m,
  q = m,
  thr_margin = 100,
  fill_all = !missing(p) || !missing(q)
)

d2_pj_m(A1, A2, m = 100L, p = 1L, thr_margin = 100)

d2_1j_m(A1, A2, m = 100L, thr_margin = 100)

d2_pj_v(L1, L2, m = 100L, p = 1L, thr_margin = 100)

d2_1j_v(L1, L2, m = 100L, thr_margin = 100)

h2_ij_m(
  A1,
  A2,
  mu = rep.int(0, n),
  m = 100L,
  p = m,
  q = m,
  thr_margin = 100,
  fill_all = !missing(p) || !missing(q)
)

h2_ij_v(
  L1,
  L2,
  mu = rep.int(0, n),
  m = 100L,
  p = m,
  q = m,
  thr_margin = 100,
  fill_all = !missing(p) || !missing(q)
)

htil2_pj_m(A1, A2, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)

htil2_1j_m(A1, A2, mu = rep.int(0, n), m = 100L, thr_margin = 100)

htil2_pj_v(L1, L2, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)

htil2_1j_v(L1, L2, mu = rep.int(0, n), m = 100L, thr_margin = 100)

hhat2_pj_m(A1, A2, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)

hhat2_1j_m(A1, A2, mu = rep.int(0, n), m = 100L, thr_margin = 100)

hhat2_pj_v(L1, L2, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)

hhat2_1j_v(L1, L2, mu = rep.int(0, n), m = 100L, thr_margin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d2_ij_+3A_a1">A1</code>, <code id="d2_ij_+3A_a2">A2</code></td>
<td>
<p>Argument matrices.  Assumed to be symmetric and of the same order.</p>
</td></tr>
<tr><td><code id="d2_ij_+3A_m">m</code></td>
<td>
<p>Integer-alike to specify the desired order along <code>A2</code>/<code>L2</code></p>
</td></tr>
<tr><td><code id="d2_ij_+3A_p">p</code>, <code id="d2_ij_+3A_q">q</code></td>
<td>
<p>Integer-alikes to specify the desired orders along
<code>A1</code>/<code>L1</code> and <code>A2</code>/<code>L2</code>, respectively.</p>
</td></tr>
<tr><td><code id="d2_ij_+3A_thr_margin">thr_margin</code></td>
<td>
<p>Optional argument to adjust the threshold for scaling (see &ldquo;Scaling&rdquo;
in <code><a href="#topic+d1_i">d1_i</a></code>)</p>
</td></tr>
<tr><td><code id="d2_ij_+3A_fill_all">fill_all</code></td>
<td>
<p>Logical to specify whether all the output matrix should be filled.  See
&ldquo;Details&rdquo;.</p>
</td></tr>
<tr><td><code id="d2_ij_+3A_l1">L1</code>, <code id="d2_ij_+3A_l2">L2</code></td>
<td>
<p>Eigenvalues of the argument matrices</p>
</td></tr>
<tr><td><code id="d2_ij_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>d2_**_*()</code> functions calculate
<code class="reqn">d_{i,j}(\mathbf{A}_1, \mathbf{A}_2)</code> in
Hillier et al. (2009, 2014) and Bao and Kan (2013).  These are also related to
the top-order invariant polynomials
<code class="reqn">C_{[k_1],[k_2]}(\mathbf{A}_1, \mathbf{A}_2)</code>
in the following way:
<code class="reqn"> d_{i,j}(\mathbf{A}_1, \mathbf{A}_2) =
     \frac{1}{k_1! k_2!} \left( \frac{1}{2} \right)_{k_1 + k_2}
     C_{[k_1],[k_2]}(\mathbf{A}_1, \mathbf{A}_2) </code>,
where <code class="reqn">(x)_k = x (x + 1) \dots (x + k - 1)</code>
(Chikuse 1987; Hillier et al. 2009).
</p>
<p><code>h2_ij_*()</code> and <code>htil2_pj_*()</code> functions calculate
<code class="reqn">h_{i,j}(\mathbf{A}_1, \mathbf{A}_2)</code> and
<code class="reqn">\tilde{h}_{i,j}(\mathbf{A}_1; \mathbf{A}_2)</code>,
respectively, in Bao and Kan (2013).  Note that the latter is denoted by the
symbol <code class="reqn">h_{i,j}</code> in Hillier et al. (2014).  <code>hhat2_pj_*()</code>
functions are for
<code class="reqn">\hat{h}_{i,j}(\mathbf{A}_1; \mathbf{A}_2)</code>
in Hillier et al. (2014), used to calculate an error bound for
truncated sum for moments of a ratio of quadratic forms.  The
mean vector <code class="reqn">\bm{\mu}</code> is a parameter in all these.
</p>
<p>There are two different situations in which these coefficients are used
in calculation of moments of ratios of quadratic forms:
<strong>1</strong>) within an infinite series for one of the subscripts, with the
other subscript fixed (when the exponent <code class="reqn">p</code> of the numerator
is integer); <strong>2</strong>) within a double infinite series for both subscripts
(when <code class="reqn">p</code> is non-integer) (see Bao and Kan 2013).  In this package,
the situation <strong>1</strong> is handled by the <code>*_pj_*</code> (and <code>*_1j_*</code>)
functions, and <strong>2</strong> is by the <code>*_ij_*</code> functions.
</p>
<p>In particular, the <code>*_pj_*</code> functions always return a
<code>(p + 1) * (m + 1)</code> matrix where all elements are filled with
the relevant coefficients (e.g., <code class="reqn">d_{i,j}</code>, <code class="reqn">\tilde{h}_{i,j}</code>),
from which, typically, the <code>[p + 1, ]</code>-th row is used for
subsequent calculations.  (Those with <code>*_1q_*</code> are simply fast versions
for the commonly used case where <code class="reqn">p = 1</code>.)
On the other hand, the <code>*_ij_*</code> functions by default return a
<code>(m + 1) * (m + 1)</code> matrix whose upper-left triangular part
(including the diagonals) is filled with the coefficients
(<code class="reqn">d_{i,j}</code> or <code class="reqn">h_{i,j}</code>), the rest being 0, and all the coefficients
are used in subsequent calculations.
</p>
<p>(At present, the <code>*_ij_*</code> functions also have the functionality to
fill all coefficients of a potentially non-square output matrix,
but this is less efficient than <code>*_pj_*</code> functions so may
be omitted in the future development.)
</p>
<p>Those ending with <code>_m</code> take matrices as arguments, whereas
those with <code>_v</code> take eigenvalues.  The latter can be used only when
the argument matrices share the same eigenvectors, to which the eigenvalues
correspond in the orders given, but is substantially faster.
</p>
<p>This package also involves C++ equivalents for most of these functions
(which are suffixed by <code>E</code> for <code>Eigen</code>),
but these are exclusively for internal use and not exposed to the user.
</p>


<h3>Value</h3>

<p><code>(p + 1) * (m + 1)</code> matrix for the <code>*_pj_*</code> functions.
</p>
<p><code>(m + 1) * (m + 1)</code> matrix for the <code>*_ij_*</code> functions.
</p>
<p>The rows and columns correspond to increasing orders for
<code class="reqn">\mathbf{A}_1</code> and <code class="reqn">\mathbf{A}_2</code>, respectively.  And
the 1st row/column of each dimension corresponds
to the 0th order (hence <code>[p + 1, q + 1]</code> for the <code class="reqn">(p,q)</code>-th order).
</p>
<p>Has the attribute <code>"logscale"</code> as described in the
&ldquo;Scaling&rdquo; section in <code><a href="#topic+d1_i">d1_i</a></code>.  This is
a matrix of the same size as the return itself.
</p>


<h3>References</h3>

<p>Bao, Y. and Kan, R. (2013) On the moments of ratios of quadratic forms in
normal random variables. <em>Journal of Multivariate Analysis</em>, <strong>117</strong>,
229&ndash;245.
<a href="https://doi.org/10.1016/j.jmva.2013.03.002">doi:10.1016/j.jmva.2013.03.002</a>.
</p>
<p>Chikuse, Y. (1987) Methods for constructing top order invariant polynomials.
<em>Econometric Theory</em>, <strong>3</strong>, 195&ndash;207.
<a href="https://doi.org/10.1017/S026646660001029X">doi:10.1017/S026646660001029X</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2009) Computationally efficient recursions
for top-order invariant polynomials with applications.
<em>Econometric Theory</em>, <strong>25</strong>, 211&ndash;242.
<a href="https://doi.org/10.1017/S0266466608090075">doi:10.1017/S0266466608090075</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2014) Generating functions and
short recursions, with applications to the moments of quadratic forms
in noncentral normal vectors. <em>Econometric Theory</em>, <strong>30</strong>, 436&ndash;473.
<a href="https://doi.org/10.1017/S0266466613000364">doi:10.1017/S0266466613000364</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfrm">qfrm</a></code> and <code><a href="#topic+qfmrm">qfmrm</a></code> are
major front-end functions that utilize these functions
</p>
<p><code><a href="#topic+dtil2_pq">dtil2_pq</a></code> for <code class="reqn">\tilde{d}</code>
used for moments of a product of quadratic forms
</p>
<p><code><a href="#topic+d3_ijk">d3_ijk</a></code> for equivalents for three matrices
</p>

<hr>
<h2 id='d3_ijk'>Coefficients in polynomial expansion of generating function&mdash;for
ratios with three matrices</h2><span id='topic+d3_ijk'></span><span id='topic+d3_pjk'></span><span id='topic+h3_ijk'></span><span id='topic+htil3_pjk'></span><span id='topic+hhat3_pjk'></span><span id='topic+d3_ijk_m'></span><span id='topic+d3_ijk_v'></span><span id='topic+d3_pjk_m'></span><span id='topic+d3_pjk_v'></span><span id='topic+h3_ijk_m'></span><span id='topic+h3_ijk_v'></span><span id='topic+htil3_pjk_m'></span><span id='topic+htil3_pjk_v'></span><span id='topic+hhat3_pjk_m'></span><span id='topic+hhat3_pjk_v'></span>

<h3>Description</h3>

<p>These are internal functions to calculate the coefficients
in polynomial expansion of joint generating functions for three
quadratic forms in potentially noncentral multivariate normal variables,
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{I}_n)</code>.  They
are primarily used in calculations around moments of a ratio
involving three quadratic forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d3_ijk_m(
  A1,
  A2,
  A3,
  m = 100L,
  p = m,
  q = m,
  r = m,
  thr_margin = 100,
  fill_across = c(!missing(p), !missing(q), !missing(r))
)

d3_ijk_v(
  L1,
  L2,
  L3,
  m = 100L,
  p = m,
  q = m,
  r = m,
  thr_margin = 100,
  fill_across = c(!missing(p), !missing(q), !missing(r))
)

d3_pjk_m(A1, A2, A3, m = 100L, p = 1L, thr_margin = 100)

d3_pjk_v(L1, L2, L3, m = 100L, p = 1L, thr_margin = 100)

h3_ijk_m(
  A1,
  A2,
  A3,
  mu = rep.int(0, n),
  m = 100L,
  p = m,
  q = m,
  r = m,
  thr_margin = 100,
  fill_across = c(!missing(p), !missing(q), !missing(r))
)

h3_ijk_v(
  L1,
  L2,
  L3,
  mu = rep.int(0, n),
  m = 100L,
  p = m,
  q = m,
  r = m,
  thr_margin = 100,
  fill_across = c(!missing(p), !missing(q), !missing(r))
)

htil3_pjk_m(A1, A2, A3, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)

htil3_pjk_v(L1, L2, L3, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)

hhat3_pjk_m(A1, A2, A3, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)

hhat3_pjk_v(L1, L2, L3, mu = rep.int(0, n), m = 100L, p = 1L, thr_margin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d3_ijk_+3A_a1">A1</code>, <code id="d3_ijk_+3A_a2">A2</code>, <code id="d3_ijk_+3A_a3">A3</code></td>
<td>
<p>Argument matrices.  Assumed to be symmetric and of the same order.</p>
</td></tr>
<tr><td><code id="d3_ijk_+3A_m">m</code></td>
<td>
<p>Integer-alike to specify the desired order along <code>A2</code>/<code>L2</code>
and <code>A3</code>/<code>L3</code></p>
</td></tr>
<tr><td><code id="d3_ijk_+3A_p">p</code>, <code id="d3_ijk_+3A_q">q</code>, <code id="d3_ijk_+3A_r">r</code></td>
<td>
<p>Integer-alikes to specify the desired orders along
<code>A1</code>/<code>L1</code>, <code>A2</code>/<code>L2</code>, and <code>A3</code>/<code>L3</code>,
respectively.</p>
</td></tr>
<tr><td><code id="d3_ijk_+3A_thr_margin">thr_margin</code></td>
<td>
<p>Optional argument to adjust the threshold for scaling (see &ldquo;Scaling&rdquo;
in <code><a href="#topic+d1_i">d1_i</a></code>)</p>
</td></tr>
<tr><td><code id="d3_ijk_+3A_fill_across">fill_across</code></td>
<td>
<p>Logical vector of length 3, to specify whether each dimension of
the output matrix should be filled.</p>
</td></tr>
<tr><td><code id="d3_ijk_+3A_l1">L1</code>, <code id="d3_ijk_+3A_l2">L2</code>, <code id="d3_ijk_+3A_l3">L3</code></td>
<td>
<p>Eigenvalues of the argument matrices</p>
</td></tr>
<tr><td><code id="d3_ijk_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these functions have equivalents for two-matrix cases
(<code><a href="#topic+d2_ij">d2_ij</a></code>), to which the user is referred for
documentations.  The primary difference of these functions from the latter is
the addition of arguments for the third matrix <code>A3</code>/<code>L3</code>.
</p>
<p><code>d3_*jk_*()</code> functions calculate
<code class="reqn">d_{i,j,k}(\mathbf{A}_1, \mathbf{A}_2, \mathbf{A}_3)
     </code> in
Hillier et al. (2009, 2014) and Bao and Kan (2013).  These are
also related to the top-order invariant polynomials as described
in <code><a href="#topic+d2_ij">d2_ij</a></code>.
</p>
<p><code>h3_ijk_*()</code>, <code>htil3_pjk_*()</code>, and <code>hhat3_pjk_*()</code> functions
calculate <code class="reqn">h_{i,j,k}(\mathbf{A}_1, \mathbf{A}_2, \mathbf{A}_3)
               </code>,
<code class="reqn">\tilde{h}_{i;j,k}(\mathbf{A}_1; \mathbf{A}_2, \mathbf{A}_3)
     </code>, and
<code class="reqn">\hat{h}_{i;j,k}(\mathbf{A}_1; \mathbf{A}_2, \mathbf{A}_3)
     </code>,
respectively, as described in the package vignette.  These are equivalent
to similar coefficients described in Bao and Kan (2013) and
Hillier et al. (2014).
</p>
<p>The difference between the <code>*_pjk_*</code> and <code>*_ijk_*</code> functions
is as described for <code>*_pj_*</code> and <code>*_ij_*</code>
(see &ldquo;Details&rdquo; in <code><a href="#topic+d2_ij">d2_ij</a></code>).  The only difference is
that these functions return a 3D array.  In the <code>*_pjk_*</code> functions,
all the slices along the first dimension (i.e., <code>[i, , ]</code>) are
an upper-left triangular matrix like what the <code>*_ij_*</code> functions return
in the 2D case; in other words, the return has the coefficients for the terms
that satisfy <code class="reqn">j + k \le m</code> for all <code class="reqn">i = 0, 1, \dots, p</code>.  Typically,
the <code>[p + 1, , ]</code>-th slice is used for subsequent calculations.  In the
return of the <code>*_ijk_*</code> functions, only the triangular prism
close to the <code>[1, 1, 1]</code> is filled with coefficients, which
correspond to the terms satisfying <code class="reqn">i + j + k \le m</code>.
</p>


<h3>Value</h3>

<p><code>(p + 1) * (m + 1) * (m + 1)</code> array for the <code>*_pjk_*</code> functions
</p>
<p><code>(m + 1) * (m + 1) * (m + 1)</code> array for the <code>*_ijk_*</code> functions
(by default; see &ldquo;Details&rdquo;).
</p>
<p>The 1st, 2nd, and 3rd dimensions correspond to increasing orders for
<code class="reqn">\mathbf{A}_1</code>, <code class="reqn">\mathbf{A}_2</code>, and
<code class="reqn">\mathbf{A}_3</code>, respectively.  And the 1st row/column of
each dimension corresponds to the 0th order (hence
<code>[p + 1, q + 1, r + 1]</code> for the <code class="reqn">(p,q,r)</code>-th order).
</p>
<p>Has the attribute <code>"logscale"</code> as described in the &ldquo;Scaling&rdquo;
section in <code><a href="#topic+d1_i">d1_i</a></code>.  This is an array of the same size
as the return itself.
</p>


<h3>References</h3>

<p>Bao, Y. and Kan, R. (2013) On the moments of ratios of quadratic forms in
normal random variables. <em>Journal of Multivariate Analysis</em>, <strong>117</strong>,
229&ndash;245.
<a href="https://doi.org/10.1016/j.jmva.2013.03.002">doi:10.1016/j.jmva.2013.03.002</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2014) Generating functions and
short recursions, with applications to the moments of quadratic forms
in noncentral normal vectors. <em>Econometric Theory</em>, <strong>30</strong>, 436&ndash;473.
<a href="https://doi.org/10.1017/S0266466613000364">doi:10.1017/S0266466613000364</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfmrm">qfmrm</a></code> is a
major front-end function that utilizes these functions
</p>
<p><code><a href="#topic+dtil2_pq">dtil2_pq</a></code> for <code class="reqn">\tilde{d}</code>
used for moments of a product of quadratic forms
</p>
<p><code><a href="#topic+d2_ij">d2_ij</a></code> for equivalents for two matrices
</p>

<hr>
<h2 id='dqfr'>Probability distribution of ratio of quadratic forms</h2><span id='topic+dqfr'></span><span id='topic+pqfr'></span><span id='topic+qqfr'></span><span id='topic+dqfr_A1I1'></span><span id='topic+dqfr_broda'></span><span id='topic+dqfr_butler'></span><span id='topic+pqfr_A1B1'></span><span id='topic+pqfr_imhof'></span><span id='topic+pqfr_davies'></span><span id='topic+pqfr_butler'></span>

<h3>Description</h3>

<p><code>dqfr()</code>: Density of the (power of) ratio of quadratic forms,
<code class="reqn">\left( \frac{ \mathbf{x^{\mathit{T}} A x} }{
                   \mathbf{x^{\mathit{T}} B x} } \right) ^ p
</code>, where
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{\Sigma})</code>.
</p>
<p><code>pqfr()</code>: Distribution function of the same.
</p>
<p><code>qqfr()</code>: Quantile function of the same.
</p>
<p><code>dqfr_A1I1()</code>: internal for <code>dqfr()</code>,
exact series expression of Hillier (2001).  Only accommodates
the simple case where <code class="reqn">\mathbf{B} = \mathbf{I}_n</code> and
<code class="reqn">\bm{\mu} = \mathbf{0}_n</code>.
</p>
<p><code>dqfr_broda()</code>: internal for <code>dqfr()</code>,
exact numerical inversion algorithm of Broda &amp; Paolella (2009).
</p>
<p><code>dqfr_butler()</code>: internal for <code>dqfr()</code>,
saddlepoint approximation of Butler &amp; Paolella (2007, 2008).
</p>
<p><code>pqfr_A1B1()</code>: internal for <code>pqfr()</code>,
exact series expression of Forchini (2002, 2005).
</p>
<p><code>pqfr_imhof()</code>: internal for <code>pqfr()</code>,
exact numerical inversion algorithm of Imhof (1961).
</p>
<p><code>pqfr_davies()</code>: internal for <code>pqfr()</code>,
exact numerical inversion algorithm of Davies (1973, 1980).
This is <strong>experimental</strong> and may be removed in the future.
</p>
<p><code>pqfr_butler()</code>: internal for <code>pqfr()</code>,
saddlepoint approximation of Butler &amp; Paolella (2007, 2008).
</p>
<p>The user is supposed to use the exported functions <code>dqfr()</code>,
<code>pqfr()</code>, and <code>qqfr()</code>, which are (pseudo-)vectorized with respect
to <code>quantile</code> or <code>probability</code>.  The actual calculations are done
by one of the internal functions, which only accommodate a length-one
<code>quantile</code>.  The internal functions skip most checks on argument
structures and do not accommodate <code>Sigma</code>
to reduce execution time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dqfr(
  quantile,
  A,
  B,
  p = 1,
  mu = rep.int(0, n),
  Sigma = diag(n),
  log = FALSE,
  method = c("broda", "hillier", "butler"),
  trim_values = TRUE,
  normalize_spa = FALSE,
  return_abserr_attr = FALSE,
  m = 100L,
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  ...
)

pqfr(
  quantile,
  A,
  B,
  p = 1,
  mu = rep.int(0, n),
  Sigma = diag(n),
  lower.tail = TRUE,
  log.p = FALSE,
  method = c("imhof", "davies", "forchini", "butler"),
  trim_values = TRUE,
  return_abserr_attr = FALSE,
  m = 100L,
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  ...
)

qqfr(
  probability,
  A,
  B,
  p = 1,
  mu = rep.int(0, n),
  Sigma = diag(n),
  lower.tail = TRUE,
  log.p = FALSE,
  trim_values = FALSE,
  return_abserr_attr = FALSE,
  stop_on_error = FALSE,
  m = 100L,
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  epsabs_q = .Machine$double.eps^(1/2),
  maxiter_q = 5000,
  ...
)

dqfr_A1I1(
  quantile,
  LA,
  m = 100L,
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  tol_conv = .Machine$double.eps^(1/4),
  thr_margin = 100
)

dqfr_broda(
  quantile,
  A,
  B,
  mu = rep.int(0, n),
  autoscale_args = 1,
  stop_on_error = TRUE,
  use_cpp = TRUE,
  tol_zero = .Machine$double.eps * 100,
  epsabs = epsrel,
  epsrel = 1e-06,
  limit = 10000
)

dqfr_butler(
  quantile,
  A,
  B,
  mu = rep.int(0, n),
  order_spa = 2,
  stop_on_error = FALSE,
  use_cpp = TRUE,
  tol_zero = .Machine$double.eps * 100,
  epsabs = .Machine$double.eps^(1/2),
  epsrel = 0,
  maxiter = 5000
)

pqfr_A1B1(
  quantile,
  A,
  B,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  stop_on_error = FALSE,
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  thr_margin = 100
)

pqfr_imhof(
  quantile,
  A,
  B,
  mu = rep.int(0, n),
  autoscale_args = 1,
  stop_on_error = TRUE,
  use_cpp = TRUE,
  tol_zero = .Machine$double.eps * 100,
  epsabs = epsrel,
  epsrel = 1e-06,
  limit = 10000
)

pqfr_davies(
  quantile,
  A,
  B,
  mu = rep.int(0, n),
  autoscale_args = 1,
  stop_on_error = NULL,
  tol_zero = .Machine$double.eps * 100,
  ...
)

pqfr_butler(
  quantile,
  A,
  B,
  mu = rep.int(0, n),
  order_spa = 2,
  stop_on_error = FALSE,
  use_cpp = TRUE,
  tol_zero = .Machine$double.eps * 100,
  epsabs = .Machine$double.eps^(1/2),
  epsrel = 0,
  maxiter = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dqfr_+3A_quantile">quantile</code></td>
<td>
<p>Numeric vector of quantiles <code class="reqn">q</code></p>
</td></tr>
<tr><td><code id="dqfr_+3A_a">A</code>, <code id="dqfr_+3A_b">B</code></td>
<td>
<p>Argument matrices.  Should be square.  <code>B</code> should be nonnegative
definite.  Will be automatically symmetrized in <code>dqfr()</code> and
<code>pqfr()</code>.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_p">p</code></td>
<td>
<p>Positive exponent of the ratio, default <code>1</code>.  Unlike in
<code><a href="#topic+qfrm">qfrm</a>()</code>, the numerator and denominator cannot have
different exponents.  When <code>p</code> is non-integer, <code>A</code> must be
nonnegative definite.  For details, see vignette
<code>vignette("qfratio_distr")</code>.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="dqfr_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix <code class="reqn">\mathbf{\Sigma}</code> for
<code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="dqfr_+3A_log">log</code>, <code id="dqfr_+3A_lower.tail">lower.tail</code>, <code id="dqfr_+3A_log.p">log.p</code></td>
<td>
<p>Logical; as in regular probability distribution functions.  But these are
for convenience only, and not meant for accuracy.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_method">method</code></td>
<td>
<p>Method to specify an internal function (see &ldquo;Details&rdquo;).  In
<code>dqfr()</code>, options are:
</p>

<dl>
<dt><code>"broda"</code></dt><dd><p>default; uses <code>dqfr_broda()</code>, numerical
inversion of Broda &amp; Paolella (2009)</p>
</dd>
<dt><code>"hillier"</code></dt><dd><p>uses <code>dqfr_A1I1()</code>, series expression
of Hillier (2001)</p>
</dd>
<dt><code>"butler"</code></dt><dd><p>uses <code>dqfr_butler()</code>, saddlepoint
approximation of Butler &amp; Paolella (2007, 2008)</p>
</dd>
</dl>

<p>In <code>pqfr()</code>, options are:
</p>

<dl>
<dt><code>"imhof"</code></dt><dd><p>default; uses <code>pqfr_imhof()</code>, numerical
inversion of Imhof (1961)</p>
</dd>
<dt><code>"davies"</code></dt><dd><p>uses <code>pqfr_davies()</code>, numerical inversion
of Davies (1973, 1980)</p>
</dd>
<dt><code>"forchini"</code></dt><dd><p>uses <code>pqfr_A1B1()</code>, series expression
of Forchini (2002, 2005)</p>
</dd>
<dt><code>"butler"</code></dt><dd><p>uses <code>pqfr_butler()</code>, saddlepoint
approximation of Butler &amp; Paolella (2007, 2008)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dqfr_+3A_trim_values">trim_values</code></td>
<td>
<p>If <code>TRUE</code> (default), numerical values outside the mathematically
permissible support are trimmed in (see &ldquo;Details&rdquo;)</p>
</td></tr>
<tr><td><code id="dqfr_+3A_normalize_spa">normalize_spa</code></td>
<td>
<p>If <code>TRUE</code> and <code>method == "butler"</code>, result is normalized so that
the density integrates to unity (see &ldquo;Details&rdquo;)</p>
</td></tr>
<tr><td><code id="dqfr_+3A_return_abserr_attr">return_abserr_attr</code></td>
<td>
<p>If <code>TRUE</code>, absolute error of numerical evaluation is returned
as an attribute <code>"abserr"</code> (see &ldquo;Value&rdquo;)</p>
</td></tr>
<tr><td><code id="dqfr_+3A_m">m</code></td>
<td>
<p>Order of polynomials at which the series expression is truncated.  <code class="reqn">M</code>
in Hillier et al. (2009, 2014).</p>
</td></tr>
<tr><td><code id="dqfr_+3A_tol_zero">tol_zero</code></td>
<td>
<p>Tolerance against which numerical zero is determined.  Used to determine,
e.g., whether <code>mu</code> is a zero vector, <code>A</code> or <code>B</code> equals
the identity matrix, etc.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_tol_sing">tol_sing</code></td>
<td>
<p>Tolerance against which matrix singularity and rank are determined.  The
eigenvalues smaller than this are considered zero.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to internal functions.  In <code>qqfr()</code>,
these are passed to <code>pqfr()</code>.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_probability">probability</code></td>
<td>
<p>Numeric vector of probabilities</p>
</td></tr>
<tr><td><code id="dqfr_+3A_stop_on_error">stop_on_error</code></td>
<td>
<p>If <code>TRUE</code>, execution is stopped upon an error (including
non-convergence) in evaluation of hypergeometric function,
numerical integration, or root finding.  If
<code>FALSE</code>, further execution is attempted regardless.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_la">LA</code></td>
<td>
<p>Eigenvalues of <code class="reqn">\mathbf{A}</code></p>
</td></tr>
<tr><td><code id="dqfr_+3A_check_convergence">check_convergence</code></td>
<td>
<p>Specifies how numerical convergence is checked for series expression (see
<code><a href="#topic+qfrm">qfrm</a></code>)</p>
</td></tr>
<tr><td><code id="dqfr_+3A_use_cpp">use_cpp</code></td>
<td>
<p>Logical to specify whether the calculation is done with C++
functions via <code>Rcpp</code>.  <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_tol_conv">tol_conv</code></td>
<td>
<p>Tolerance against which numerical convergence of series is checked.  Used
with <code>check_convergence</code>.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_thr_margin">thr_margin</code></td>
<td>
<p>Optional argument to adjust the threshold for scaling (see &ldquo;Scaling&rdquo;
in <code><a href="#topic+d1_i">d1_i</a></code>).  Passed to internal functions (<code><a href="#topic+d1_i">d1_i</a></code>,
<code><a href="#topic+d2_ij">d2_ij</a></code>, <code><a href="#topic+d3_ijk">d3_ijk</a></code>) or their C++ equivalents.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_autoscale_args">autoscale_args</code></td>
<td>
<p>Numeric; if <code>&gt; 0</code> (default), arguments are scaled to avoid failure in
numerical integration (see <code>vignette("qfratio_distr")</code>).  If
<code>&lt;= 0</code>, the scaling is skipped.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_epsabs">epsabs</code>, <code id="dqfr_+3A_epsrel">epsrel</code>, <code id="dqfr_+3A_limit">limit</code>, <code id="dqfr_+3A_maxiter">maxiter</code>, <code id="dqfr_+3A_epsabs_q">epsabs_q</code>, <code id="dqfr_+3A_maxiter_q">maxiter_q</code></td>
<td>
<p>Optional arguments used in numerical integration or root-finding
algorithm (see vignette:
<code>vignette("qfratio_distr")</code>).  In <code>qqfr()</code>, <code>epsabs_q</code>
and <code>maxiter_q</code> are used in root-finding for quantiles whereas
<code>epsabs</code> and <code>maxiter</code> are passed to <code>pqfr()</code> internally.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_order_spa">order_spa</code></td>
<td>
<p>Numeric to determine order of saddlepoint approximation.  More accurate
second-order approximation is used for any <code>order &gt; 1</code> (default);
otherwise, (very slightly) faster first-order approximation is used.</p>
</td></tr>
<tr><td><code id="dqfr_+3A_cpp_method">cpp_method</code></td>
<td>
<p>Method used in C++ calculations to avoid numerical
overflow/underflow (see &ldquo;Details&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>)</p>
</td></tr>
<tr><td><code id="dqfr_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads used in OpenMP-enabled C++
functions (see &ldquo;Multithreading&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qqfr()</code> is based on numerical root-finding with <code>pqfr()</code> using
<code><a href="stats.html#topic+uniroot">uniroot</a>()</code>, so its result can be affected by the
numerical errors in both the algorithm used in <code>pqfr()</code> and
root-finding.
</p>
<p><code>dqfr_A1I1()</code> and <code>pqfr_A1B1()</code> evaluate the probability density
and (cumulative) distribution function, respectively,
as a partial sum of infinite series involving top-order zonal or
invariant polynomials (Hillier 2001; Forchini 2002, 2005).  As in other
functions of this package, these are evaluated with the recursive algorithm
<code><a href="#topic+d1_i">d1_i</a></code>.
</p>
<p><code>pqfr_imhof()</code> and <code>pqfr_davies()</code> evaluate the distribution
function by numerical inversion of the characteristic function based on
Imhof (1961) or Davies (1973, 1980), respectively.  The latter calls
<code><a href="CompQuadForm.html#topic+davies">davies</a>()</code>, and the former with
<code>use_cpp = FALSE</code> calls <code><a href="CompQuadForm.html#topic+imhof">imhof</a>()</code>,
from the package <span class="pkg">CompQuadForm</span>.  Additional arguments for
<code><a href="CompQuadForm.html#topic+davies">davies</a>()</code> can be passed via <code>...</code>,
except for <code>sigma</code>, which is not applicable.
</p>
<p><code>dqfr_broda()</code> evaluates the probability density by numerical inversion
of the characteristic function using Geary's formula based on
Broda &amp; Paolella (2009).  Parameters for numerical integration
can be controlled via the arguments <code>epsabs</code>, <code>epsrel</code>, and
<code>limit</code> (see vignette: <code>vignette("qfratio_distr")</code>).
</p>
<p><code>dqfr_butler()</code> and <code>pqfr_butler()</code> evaluate saddlepoint
approximations of the density and distribution function, respectively,
based on Butler &amp; Paolella (2007, 2008).  These are fast but not exact.  They
conduct numerical root-finding for the saddlepoint by the Brent method,
parameters for which can be controlled by the arguments
<code>epsabs</code>, <code>epsrel</code>, and <code>maxiter</code>
(see vignette: <code>vignette("qfratio_distr")</code>).  The saddlepoint
approximation density does not integrate to unity, but can be normalized by
<code>dqfr(..., method = "butler", normalize_spa = TRUE)</code>.  Note that
this is usually slower than <code>dqfr(..., method = "broda")</code> for
a small number of quantiles.
</p>
<p>The density is undefined, and the distribution function has points of
nonanalyticity, at the eigenvalues of
<code class="reqn">\mathbf{B}^{-1} \mathbf{A}</code> (assuming nonsingular
<code class="reqn">\mathbf{B}</code>).  Around these points,
the series expressions tends to fail.  Avoid using the series expression
methods for these cases.
</p>
<p>Algorithms based on numerical integration can yield spurious results
that are outside the mathematically permissible support; e.g.,
<code class="reqn">[0, 1]</code> for <code>pqfr()</code>.  By default, <code>dqfr()</code> and <code>pqfr()</code>
trim those values into the permissible range with a warning; e.g.,
negative p-values are
replaced by ~<code>2.2e-14</code> (default <code>tol_zero</code>).  Turn
<code>trim_values = FALSE</code> to skip these trimming and warning, although
<code>pqfr_imhof()</code> and <code>pqfr_davies()</code> can still throw a warning
from <span class="pkg">CompQuadForm</span> functions.  Note that, on the other hand,
all these functions try to return exact <code>0</code> or <code>1</code>
when <code class="reqn">q</code> is outside the possible range of the statistic.
</p>


<h3>Value</h3>

<p><code>dqfr()</code> and <code>pqfr()</code> give the density and distribution
(or <code class="reqn">p</code>-values) functions, respectively, corresponding to
<code>quantile</code>, whereas <code>qqfr()</code> gives the quantile function
corresponding to <code>probability</code>.
</p>
<p>When <code>return_abserr_attr = TRUE</code>, an absolute
error bound of numerical evaluation is returned as an attribute; this
feature is currently available with <code>dqfr(..., method = "broda")</code>,
<code>pqfr(..., method = "imhof")</code>, and <code>qqfr(..., method = "imhof")</code>
(all default) only.  This error bound is automatically transformed when
trimming happens with <code>trim_values</code> (above) or when
<code>log</code>/<code>log.p = TRUE</code>.  See vignette for details
(<code>vignette("qfratio_distr")</code>).
</p>
<p>The internal functions return a list containing <code>$d</code> or <code>$p</code>
(for density and lower <code class="reqn">p</code>-value, respectively), and only this is passed
to the external function by default.  Other components may be inspected
for debugging purposes:
</p>

<dl>
<dt><code>dqfr_A1I1()</code> and <code>pqfr_A1B1()</code></dt><dd><p>have <code>$terms</code>,
a vector of <code class="reqn">0</code>th to <code class="reqn">m</code>th order terms.</p>
</dd>
<dt><code>pqfr_imhof()</code> and <code>dqfr_broda()</code></dt><dd><p>have <code>$abserr</code>,
absolute error of numerical integration; the one returned from
<code>CompQuadForm::<a href="CompQuadForm.html#topic+imhof">imhof</a>()</code> is divided by
<code>pi</code>, as the integration result itself is (internally).  This is
passed to the external functions when <code>return_abserr_attr = TRUE</code>
(above).</p>
</dd>
<dt><code>pqfr_davies()</code></dt><dd><p>has the same components as
<code>CompQuadForm::<a href="CompQuadForm.html#topic+davies">davies</a>()</code> apart from <code>Qq</code>
which is replaced by <code>p = 1 - Qq</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Broda, S. and Paolella, M. S. (2009) Evaluating the density of ratios of
noncentral quadratic forms in normal variables.
<em>Computational Statistics and Data Analysis</em>, <strong>53</strong>, 1264&ndash;1270.
<a href="https://doi.org/10.1016/j.csda.2008.10.035">doi:10.1016/j.csda.2008.10.035</a>
</p>
<p>Butler, R. W. and Paolella, M. S. (2007) Uniform saddlepoint approximations
for ratios of quadratic forms. Technical Reports, Department of Statistical
Science, Southern Methodist University, no. <strong>351</strong>.
[Available on <em>arXiv</em> as a preprint.]
<a href="https://doi.org/10.48550/arXiv.0803.2132">doi:10.48550/arXiv.0803.2132</a>
</p>
<p>Butler, R. W. and Paolella, M. S. (2008) Uniform saddlepoint approximations
for ratios of quadratic forms. <em>Bernoulli</em>, <strong>14</strong>, 140&ndash;154.
<a href="https://doi.org/10.3150/07-BEJ6169">doi:10.3150/07-BEJ6169</a>
</p>
<p>Davis, R. B. (1973) Numerical inversion of a characteristic function.
<em>Biometrika</em>, <strong>60</strong>, 415&ndash;417.
<a href="https://doi.org/10.1093/biomet/60.2.415">doi:10.1093/biomet/60.2.415</a>.
</p>
<p>Davis, R. B. (1980) Algorithm AS 155: The distribution of a linear
combination of <code class="reqn">\chi^2</code> random variables.
<em>Journal of the Royal Statistical Society, Series C&mdash;Applied Statistics</em>,
<strong>29</strong>, 323&ndash;333.
<a href="https://doi.org/10.2307/2346911">doi:10.2307/2346911</a>.
</p>
<p>Forchini, G. (2002) The exact cumulative distribution function of
a ratio of quadratic forms in normal variables, with application to
the AR(1) model. <em>Econometric Theory</em>, <strong>18</strong>, 823&ndash;852.
<a href="https://doi.org/10.1017/S0266466602184015">doi:10.1017/S0266466602184015</a>.
</p>
<p>Forchini, G. (2005) The distribution of a ratio of quadratic forms in
noncentral normal variables.
<em>Communications in Statistics&mdash;Theory and Methods</em>, <strong>34</strong>, 999&ndash;1008.
<a href="https://doi.org/10.1081/STA-200056855">doi:10.1081/STA-200056855</a>.
</p>
<p>Hillier, G. (2001) The density of quadratic form in a vector uniformly
distributed on the <code class="reqn">n</code>-sphere.
<em>Econometric Theory</em>, <strong>17</strong>, 1&ndash;28.
<a href="https://doi.org/10.1017/S026646660117101X">doi:10.1017/S026646660117101X</a>.
</p>
<p>Imhof, J. P. (1961) Computing the distribution of quadratic forms in normal
variables.
<em>Biometrika</em>, <strong>48</strong>, 419&ndash;426.
<a href="https://doi.org/10.1093/biomet/48.3-4.419">doi:10.1093/biomet/48.3-4.419</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rqfr">rqfr</a></code>, a Monte Carlo random number generator
</p>
<p><code>vignette("qfratio_distr")</code> for theoretical details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some symmetric matrices and parameters
nv &lt;- 4
A &lt;- diag(nv:1)
B &lt;- diag(sqrt(1:nv))
mu &lt;- 0.2 * nv:1
Sigma &lt;- matrix(0.5, nv, nv)
diag(Sigma) &lt;- 1

## density and p-value for (x^T A x) / (x^T x) where x ~ N(0, I)
dqfr(1.5, A)
pqfr(1.5, A)

## 95 percentile for the same
qqfr(0.95, A)
qqfr(0.05, A, lower.tail = FALSE) # same

## P{ (x^T A x) / (x^T B x) &lt;= 1.5} where x ~ N(mu, Sigma)
pqfr(1.5, A, B, mu = mu, Sigma = Sigma)

## These are (pseudo-)vectorized
qs &lt;- 0:nv + 0.5
dqfr(qs, A, B, mu = mu)
(pres &lt;- pqfr(qs, A, B, mu = mu))

## Quantiles for above p-values
## Results equal qs, except that those for prob = 0 and 1
## are replaced by mininum and maximum of the ratio
qqfr(pres, A, B, mu = mu) # = qs

## Various methods for density
dqfr(qs, A, method = "broda")   # default
dqfr(qs, A, method = "hillier") # series; B, mu, Sigma not permitted
## Saddlepoint approximations (fast but inexact):
dqfr(qs, A, method = "butler")  # 2nd order by default
dqfr(qs, A, method = "butler", normalize_spa = TRUE) # normalized
dqfr(qs, A, method = "butler", normalize_spa = TRUE,
     order_spa = 1) # 1st order, normalized

## Various methods for distribution function
pqfr(qs, A, method = "imhof")    # default
pqfr(qs, A, method = "davies")   # very similar
pqfr(qs, A, method = "forchini") # series expression
pqfr(qs, A, method = "butler")   # saddlepoint approximation (2nd order)
pqfr(qs, A, method = "butler", order_spa = 1) # 1st order

## To see error bounds
dqfr(qs, A, return_abserr_attr = TRUE)
pqfr(qs, A, return_abserr_attr = TRUE)
qqfr(pres, A, return_abserr_attr = TRUE)

</code></pre>

<hr>
<h2 id='dtil2_pq'>Coefficients in polynomial expansion of generating function&mdash;for products</h2><span id='topic+dtil2_pq'></span><span id='topic+dtil3_pqr'></span><span id='topic+dtil2_pq_m'></span><span id='topic+dtil2_1q_m'></span><span id='topic+dtil2_pq_v'></span><span id='topic+dtil2_1q_v'></span><span id='topic+dtil3_pqr_m'></span><span id='topic+dtil3_pqr_v'></span>

<h3>Description</h3>

<p>These are internal functions to calculate the coefficients
in polynomial expansion of joint generating functions for two or three
quadratic forms in potentially noncentral multivariate normal variables,
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{I}_n)</code>.  They
are primarily used to calculate moments of a product of two or
three quadratic forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtil2_pq_m(A1, A2, mu = rep.int(0, n), p = 1L, q = 1L)

dtil2_1q_m(A1, A2, mu = rep.int(0, n), q = 1L)

dtil2_pq_v(L1, L2, mu = rep.int(0, n), p = 1L, q = 1L)

dtil2_1q_v(L1, L2, mu = rep.int(0, n), q = 1L)

dtil3_pqr_m(A1, A2, A3, mu = rep.int(0, n), p = 1L, q = 1L, r = 1L)

dtil3_pqr_v(L1, L2, L3, mu = rep.int(0, n), p = 1L, q = 1L, r = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtil2_pq_+3A_a1">A1</code>, <code id="dtil2_pq_+3A_a2">A2</code>, <code id="dtil2_pq_+3A_a3">A3</code></td>
<td>
<p>Argument matrices.  Assumed to be symmetric and of the same order.</p>
</td></tr>
<tr><td><code id="dtil2_pq_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="dtil2_pq_+3A_p">p</code>, <code id="dtil2_pq_+3A_q">q</code>, <code id="dtil2_pq_+3A_r">r</code></td>
<td>
<p>Integer-alikes to specify the order along the three argument matrices</p>
</td></tr>
<tr><td><code id="dtil2_pq_+3A_l1">L1</code>, <code id="dtil2_pq_+3A_l2">L2</code>, <code id="dtil2_pq_+3A_l3">L3</code></td>
<td>
<p>Eigenvalues of the argument matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dtil2_pq_m()</code> and <code>dtil2_pq_v()</code> calculate
<code class="reqn">\tilde{d}_{p,q}(\mathbf{A}_1, \mathbf{A}_2)</code>
in Hillier et al. (2014).  <code>dtil2_1q_m()</code> and <code>dtil2_1q_v()</code> are
fast versions for the commonly used case where <code class="reqn">p = 1</code>.  Similarly,
<code>dtil3_pqr_m()</code> and <code>dtil3_pqr_v()</code> are for
<code class="reqn">\tilde{d}_{p,q,r}(\mathbf{A}_1, \mathbf{A}_2, \mathbf{A}_3)
     </code>.
</p>
<p>Those ending with <code>_m</code> take matrices as arguments, whereas
those with <code>_v</code> take eigenvalues.  The latter can be used only when
the argument matrices share the same eigenvectors, to which the eigenvalues
correspond in the orders given, but is substantially faster.
</p>
<p>These functions calculate the coefficients based on the super-short
recursion algorithm described in Hillier et al. (2014: sec. 4.2).
</p>


<h3>Value</h3>

<p>A <code>(p + 1) * (q + 1)</code> matrix for the 2D functions,
or a <code>(p + 1) * (q + 1) * (r + 1)</code> array for the 3D functions.
</p>
<p>The 1st, 2nd, and 3rd dimensions correspond to increasing orders for
<code class="reqn">\mathbf{A}_1</code>, <code class="reqn">\mathbf{A}_2</code>, and
<code class="reqn">\mathbf{A}_3</code>, respectively.  And the 1st row/column of each
dimension corresponds to the 0th order (hence <code>[p + 1, q + 1]</code> for
the <code class="reqn">(p,q)</code>-th moment).
</p>


<h3>References</h3>

<p>Hillier, G., Kan, R. and Wang, X. (2014) Generating functions and
short recursions, with applications to the moments of quadratic forms
in noncentral normal vectors. <em>Econometric Theory</em>, <strong>30</strong>, 436&ndash;473.
<a href="https://doi.org/10.1017/S0266466613000364">doi:10.1017/S0266466613000364</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfpm">qfpm</a></code> is a front-end functions that utilizes these functions
</p>
<p><code><a href="#topic+d1_i">d1_i</a></code> for a single-matrix equivalent of <code class="reqn">\tilde{d}</code>
</p>

<hr>
<h2 id='hgs'>Calculate hypergeometric series</h2><span id='topic+hgs'></span><span id='topic+hgs_1d'></span><span id='topic+hgs_2d'></span><span id='topic+hgs_3d'></span>

<h3>Description</h3>

<p>These internal functions calculate (summands of) hypergeometric series.
</p>
<p><code>hgs_1d()</code> calculates the hypergeometric series
<code class="reqn">c \frac{(a_1)_i}{(b)_i} d_{i}</code>
</p>
<p><code>hgs_2d()</code> calculates the hypergeometric series
<code class="reqn">c \frac{(a_1)_i (a_2)_j}{(b)_{i+j}} d_{i, j}</code>
</p>
<p><code>hgs_3d()</code> calculates the hypergeometric series
<code class="reqn">c \frac{(a_1)_i (a_2)_j (a_3)_k}{(b)_{i+j+k}} d_{i, j, k}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgs_1d(dks, a1, b, lconst = 0)

hgs_2d(dks, a1, a2, b, lconst = 0)

hgs_3d(dks, a1, a2, a3, b, lconst = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hgs_+3A_dks">dks</code></td>
<td>
<p><code>(m + 1)</code> vector for <code class="reqn">d_{i}</code>,
<code>(m + 1) * (m + 1)</code> square matrix for <code class="reqn">d_{i,j}</code>, or
<code>(m + 1) * (m + 1) * (m + 1)</code> array for <code class="reqn">d_{i,j,k}</code>
(<code class="reqn">i, j, k = 0, 1, \dots m</code>)</p>
</td></tr>
<tr><td><code id="hgs_+3A_a1">a1</code>, <code id="hgs_+3A_a2">a2</code>, <code id="hgs_+3A_a3">a3</code></td>
<td>
<p>Numerator parameters</p>
</td></tr>
<tr><td><code id="hgs_+3A_b">b</code></td>
<td>
<p>Denominator parameter</p>
</td></tr>
<tr><td><code id="hgs_+3A_lconst">lconst</code></td>
<td>
<p>Scalar <code class="reqn">\log c</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The denominator parameter <code>b</code> is assumed positive,
whereas the numerator parameters can be positive or negative.  The signs
of the latter will be reflected in the result.
</p>


<h3>Value</h3>

<p>Numeric with the same dimension with <code>dks</code>
</p>

<hr>
<h2 id='hyperg_1F1_vec_b'>Internal C++ wrappers for GSL</h2><span id='topic+hyperg_1F1_vec_b'></span><span id='topic+hyperg_2F1_mat_a_vec_c'></span><span id='topic+gsl_wrap'></span>

<h3>Description</h3>

<p>These are internal C++ functions which wrap hypergeometric
functions from GSL with vectorization.  These are for
particular use cases in this package, and direct access by the user is
<strong>not</strong> assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperg_1F1_vec_b(a, bvec, x)

hyperg_2F1_mat_a_vec_c(Amat, b, cvec, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperg_1F1_vec_b_+3A_a">a</code>, <code id="hyperg_1F1_vec_b_+3A_b">b</code></td>
<td>
<p>Parameters of hypergeometric functions; passed as <code>double</code></p>
</td></tr>
<tr><td><code id="hyperg_1F1_vec_b_+3A_bvec">bvec</code>, <code id="hyperg_1F1_vec_b_+3A_cvec">cvec</code></td>
<td>
<p>Parameters of hypergeometric functions; passed as
<code>Rcpp::NumericVector</code></p>
</td></tr>
<tr><td><code id="hyperg_1F1_vec_b_+3A_x">x</code></td>
<td>
<p>Argument of hypergeometric functions; passed as <code>double</code></p>
</td></tr>
<tr><td><code id="hyperg_1F1_vec_b_+3A_amat">Amat</code></td>
<td>
<p>Parameter of hypergeometric functions; passed as
<code>Rcpp::NumericMatrix</code>.  Dimension must be square of the length of
<code>cvec</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list via <code>Rcpp::List</code> of the following:
</p>

<dl>
<dt><code>$val</code></dt><dd><p>Evaluation result, numeric</p>
</dd>
<dt><code>$err</code></dt><dd><p>Absolute error, numeric</p>
</dd>
<dt><code>$status</code></dt><dd><p>Error code, integer</p>
</dd>
</dl>

<p>In <code>hyperg_1F1_vec_b</code>, these are vectors from
<code>Rcpp::NumericVector</code> and <code>Rcpp::IntegerVector</code>, whereas in
<code>hyperg_2F1_mat_a_vec_c</code>, they are matrices
from <code>Rcpp::NumericMatrix</code> and <code>Rcpp::IntegerMatrix</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>hyperg_1F1_vec_b()</code>: wrapper of <code>gsl_hyperg_1F1_e()</code>, looping along <code>bvec</code>
</p>
</li>
<li> <p><code>hyperg_2F1_mat_a_vec_c()</code>: wrapper of <code>gsl_hyperg_2F1_e()</code>, looping along <code>Amat</code> and
recycling <code>cvec</code>
</p>
</li></ul>

<hr>
<h2 id='is_diagonal'>Is this matrix diagonal?</h2><span id='topic+is_diagonal'></span>

<h3>Description</h3>

<p>This internal function is used to determine whether a square matrix
is diagonal (within a specified tolerance).  Returns <code>TRUE</code>
when the absolute values of all off-diagonal elements
are below <code>tol</code>, using <code>all.equal()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_diagonal(A, tol = .Machine$double.eps * 100, symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_diagonal_+3A_a">A</code></td>
<td>
<p>Square matrix.  No check is done.</p>
</td></tr>
<tr><td><code id="is_diagonal_+3A_tol">tol</code></td>
<td>
<p>Numeric to specify <code>tolerance</code> in <code>all.equal()</code></p>
</td></tr>
<tr><td><code id="is_diagonal_+3A_symmetric">symmetric</code></td>
<td>
<p>If <code>FALSE</code> (default), sum of absolute values of the corresponding
lower and upper triangular elements are examined with a doubled
<code>tol</code>.  If <code>TRUE</code>, only the lower triangular elements are
examined assuming symmetry.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code>
</p>

<hr>
<h2 id='iseq'>Are these vectors equal?</h2><span id='topic+iseq'></span>

<h3>Description</h3>

<p>This internal function is used to determine whether two vectors/matrices have
the same elements (or, a vector/matrix is all equal to 0)
using <code>all.equal()</code>.  Attributes and dimensions are ignored as
they are passed as vectors using <code>c()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iseq(x, y = rep.int(0, length(x)), tol = .Machine$double.eps * 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iseq_+3A_x">x</code></td>
<td>
<p>Main <code>target</code> vector/matrix in <code>all.equal()</code></p>
</td></tr>
<tr><td><code id="iseq_+3A_y">y</code></td>
<td>
<p><code>current</code> in <code>all.equal()</code>.  Default zero vector.</p>
</td></tr>
<tr><td><code id="iseq_+3A_tol">tol</code></td>
<td>
<p>Numeric to specify <code>tolerance</code> in <code>all.equal()</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code>
</p>

<hr>
<h2 id='KiK'>Matrix square root and generalized inverse</h2><span id='topic+KiK'></span>

<h3>Description</h3>

<p>This internal function calculates the decomposition
<code class="reqn">\mathbf{S} = \mathbf{K} \mathbf{K}^T</code> for an
<code class="reqn">n \times n</code> covariance matrix <code class="reqn">\mathbf{S}</code>, so that
<code class="reqn">\mathbf{K}</code> is an <code class="reqn">n \times m</code> matrix with <code class="reqn">m</code> being
the rank of <code class="reqn">\mathbf{S}</code>.  Returns this
<code class="reqn">\mathbf{K}</code> and its generalized inverse,
<code class="reqn">\mathbf{K}^-</code>, in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KiK(S, tol = .Machine$double.eps * 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KiK_+3A_s">S</code></td>
<td>
<p>Covariance matrix.  Symmetry and positive (semi-)definiteness are checked.</p>
</td></tr>
<tr><td><code id="KiK_+3A_tol">tol</code></td>
<td>
<p>Tolerance to determine the rank of <code class="reqn">\mathbf{S}</code>.  Eigenvalues
smaller than this value are considered zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At present, this utilizes <code>svd()</code>,
although there may be better alternatives.
</p>


<h3>Value</h3>

<p>List with <code>K</code> and <code>iK</code>, with the latter being
<code class="reqn">\mathbf{K}^-</code>
</p>

<hr>
<h2 id='new_qfrm'>Construct qfrm object</h2><span id='topic+new_qfrm'></span><span id='topic+new_qfpm'></span>

<h3>Description</h3>

<p>These are internal &ldquo;constructor&rdquo; functions used to make <code>qfrm</code>
and <code>qfpm</code> objects, which are used as a return value from the
<code><a href="#topic+qfrm">qfrm</a></code>, <code><a href="#topic+qfmrm">qfmrm</a></code>, and <code><a href="#topic+qfpm">qfpm</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_qfrm(
  statistic,
  error_bound = NULL,
  terms = statistic,
  seq_error = NULL,
  exact = FALSE,
  twosided = FALSE,
  alphaout = FALSE,
  singular_arg = FALSE,
  diminished = FALSE,
  ...,
  class = character()
)

new_qfpm(statistic, exact = TRUE, ..., class = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_qfrm_+3A_statistic">statistic</code></td>
<td>
<p>Terminal value (partial sum) for the moment.  When missing,
obtained as <code>sum(terms)</code>.</p>
</td></tr>
<tr><td><code id="new_qfrm_+3A_error_bound">error_bound</code></td>
<td>
<p>Terminal error bound.  When missing,
obtained as <code>seq_error[length(seq_error)]</code>.</p>
</td></tr>
<tr><td><code id="new_qfrm_+3A_terms">terms</code></td>
<td>
<p>Terms in series expression for the moment along varying polynomial degrees</p>
</td></tr>
<tr><td><code id="new_qfrm_+3A_seq_error">seq_error</code></td>
<td>
<p>Vector of error bounds corresponding to <code>cumsum(terms)</code></p>
</td></tr>
<tr><td><code id="new_qfrm_+3A_exact">exact</code>, <code id="new_qfrm_+3A_twosided">twosided</code>, <code id="new_qfrm_+3A_alphaout">alphaout</code>, <code id="new_qfrm_+3A_singular_arg">singular_arg</code></td>
<td>
<p>Logicals used to append attributes to the resultant error bound
(see &ldquo;Value&rdquo;)</p>
</td></tr>
<tr><td><code id="new_qfrm_+3A_diminished">diminished</code></td>
<td>
<p>Logical used to append attribute to the resultant statistic and terms
(see &ldquo;Value&rdquo;)</p>
</td></tr>
<tr><td><code id="new_qfrm_+3A_...">...</code></td>
<td>
<p>Additional arguments for accommodating subclasses</p>
</td></tr>
<tr><td><code id="new_qfrm_+3A_class">class</code></td>
<td>
<p>Character vector to (pre-)append classes to the return value</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>new_qfrm()</code> and <code>new_qfpm()</code> return a list of class <code>qfrm</code>
and <code>c(qfpm, qfrm)</code>, respectively.  These classes are defined for
the <code>print</code> and <code>plot</code> methods.
</p>
<p>The return object is a list of 4 elements which are intended to be:
</p>

<dl>
<dt><code>$statistic</code></dt><dd><p>evaluation result (<code>sum(terms)</code>)</p>
</dd>
<dt><code>$terms</code></dt><dd><p>vector of <code class="reqn">0</code>th to <code class="reqn">m</code>th order terms</p>
</dd>
<dt><code>$error_bound</code></dt><dd><p>error bound of <code>statistic</code></p>
</dd>
<dt><code>$seq_error</code></dt><dd><p>vector of error bounds corresponding to
partial sums (<code>cumsum(terms)</code>)</p>
</dd>
</dl>

<p>When the result is exact, <code>$terms</code> can be of length 1 and equal to
<code>$statistic</code>.  This is always the case for the <code>qfpm</code> class.
</p>
<p>When the relevant flags are provided in the constructor, <code>$error_bound</code>
and <code>$seq_error</code> have the following attributes which control behaviors
of the <code>print</code> and <code>plot</code> methods:
</p>

<dl>
<dt><code>"exact"</code></dt><dd><p>indicates whether the moment is exact</p>
</dd>
<dt><code>"twosided"</code></dt><dd><p>indicates whether the error bounds are
two-sided</p>
</dd>
<dt><code>"alphaout"</code></dt><dd><p>indicates whether any of the scaling factors
(<code>alphaA</code>, <code>alphaB</code>, <code>alphaD</code>) is outside
<code class="reqn">(0, 1]</code>, when error bound does not strictly hold</p>
</dd>
<dt><code>"singular"</code></dt><dd><p>indicates whether the relevant argument matrix
is (numerically) singular, in which case the error bound is
invalid</p>
</dd>
</dl>

<p>Similarly, when <code>diminished = TRUE</code>, <code>$statistic</code> and <code>$terms</code>
have the attribute <code>"diminished"</code> being <code>TRUE</code>, which indicates
that numerical underflow/diminishing happened during scaling
(see &ldquo;Scaling&rdquo; in <code><a href="#topic+d1_i">d1_i</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfrm">qfrm</a></code>, <code><a href="#topic+qfmrm">qfmrm</a></code>, <code><a href="#topic+qfpm">qfpm</a></code>: functions
that return objects of these classes
</p>
<p><code><a href="#topic+methods.qfrm">methods.qfrm</a></code>: the <code>print</code> and <code>plot</code> methods
</p>

<hr>
<h2 id='p_A1B1_Ed'>Internal C++ functions</h2><span id='topic+p_A1B1_Ed'></span><span id='topic+p_A1B1_El'></span><span id='topic+p_A1B1_Ec'></span><span id='topic+d_A1I1_Ed'></span><span id='topic+p_imhof_Ed'></span><span id='topic+d_broda_Ed'></span><span id='topic+d_butler_Ed'></span><span id='topic+p_butler_Ed'></span><span id='topic+Ap_int_E'></span><span id='topic+ABpq_int_E'></span><span id='topic+ABDpqr_int_E'></span><span id='topic+ApIq_int_cE'></span><span id='topic+ApIq_int_nE'></span><span id='topic+ApIq_npi_cE'></span><span id='topic+ApIq_npi_nEd'></span><span id='topic+ApBq_int_E'></span><span id='topic+ApBq_npi_Ed'></span><span id='topic+ApBIqr_int_cEd'></span><span id='topic+ApBIqr_int_nEd'></span><span id='topic+ApBIqr_npi_Ed'></span><span id='topic+IpBDqr_gen_Ed'></span><span id='topic+ApBDqr_int_Ed'></span><span id='topic+ApBDqr_npi_Ed'></span><span id='topic+ApIq_npi_nEc'></span><span id='topic+ApBq_npi_Ec'></span><span id='topic+ApBIqr_int_nEc'></span><span id='topic+ApBIqr_npi_Ec'></span><span id='topic+IpBDqr_gen_Ec'></span><span id='topic+ApBDqr_int_Ec'></span><span id='topic+ApBDqr_npi_Ec'></span><span id='topic+ApIq_npi_nEl'></span><span id='topic+ApBq_npi_El'></span><span id='topic+ApBIqr_int_nEl'></span><span id='topic+ApBIqr_npi_El'></span><span id='topic+IpBDqr_gen_El'></span><span id='topic+ApBDqr_int_El'></span><span id='topic+ApBDqr_npi_El'></span><span id='topic+rqfpE'></span><span id='topic+qfrm_cpp'></span>

<h3>Description</h3>

<p>These are internal C++ functions called from corresponding <span class="rlang"><b>R</b></span>
functions when <code>use_cpp = TRUE</code>.  Direct access by the user is <strong>not</strong>
assumed.  All parameters are assumed to be appropriately structured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_A1B1_Ed(
  quantile,
  A,
  B,
  mu,
  m,
  stop_on_error,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

p_A1B1_El(
  quantile,
  A,
  B,
  mu,
  m,
  stop_on_error,
  thr_margin = 100L,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

p_A1B1_Ec(
  quantile,
  A,
  B,
  mu,
  m,
  stop_on_error,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

d_A1I1_Ed(quantile, LA, m, thr_margin = 100)

p_imhof_Ed(
  quantile,
  A,
  B,
  mu,
  autoscale_args,
  stop_on_error,
  tol_zero,
  epsabs,
  epsrel,
  limit
)

d_broda_Ed(
  quantile,
  A,
  B,
  mu,
  autoscale_args,
  stop_on_error,
  tol_zero,
  epsabs,
  epsrel,
  limit
)

d_butler_Ed(
  quantile,
  A,
  B,
  mu,
  order_spa,
  stop_on_error,
  tol_zero,
  epsabs,
  epsrel,
  maxiter
)

p_butler_Ed(
  quantile,
  A,
  B,
  mu,
  order_spa,
  stop_on_error,
  tol_zero,
  epsabs,
  epsrel,
  maxiter
)

Ap_int_E(A, mu, p_ = 1, thr_margin = 100, tol_zero = 2.2e-14)

ABpq_int_E(A, LB, mu, p_ = 1, q_ = 1, thr_margin = 100, tol_zero = 2.2e-14)

ABDpqr_int_E(
  A,
  LB,
  D,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  thr_margin = 100,
  tol_zero = 2.2e-14
)

ApIq_int_cE(A, p_ = 1, q_ = 1, thr_margin = 100)

ApIq_int_nE(A, mu, p_ = 1, q_ = 1, thr_margin = 100)

ApIq_npi_cE(
  LA,
  bA,
  p_ = 1,
  q_ = 1,
  m = 100L,
  error_bound = TRUE,
  thr_margin = 100
)

ApIq_npi_nEd(
  LA,
  bA,
  mu,
  p_ = 1,
  q_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 1L
)

ApBq_int_E(
  A,
  LB,
  bB,
  mu,
  p_ = 1,
  q_ = 1,
  m = 100L,
  error_bound = TRUE,
  thr_margin = 100,
  tol_zero = 2.2e-14
)

ApBq_npi_Ed(
  A,
  LB,
  bA,
  bB,
  mu,
  p_ = 1,
  q_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBIqr_int_cEd(
  A,
  LB,
  bB,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  error_bound = TRUE,
  thr_margin = 100,
  tol_zero = 2.2e-14
)

ApBIqr_int_nEd(
  A,
  LB,
  bB,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  error_bound = TRUE,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBIqr_npi_Ed(
  A,
  LB,
  bA,
  bB,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

IpBDqr_gen_Ed(
  LB,
  D,
  bB,
  bD,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBDqr_int_Ed(
  A,
  LB,
  D,
  bB,
  bD,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBDqr_npi_Ed(
  A,
  LB,
  D,
  bA,
  bB,
  bD,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApIq_npi_nEc(
  LA,
  bA,
  mu,
  p_ = 1,
  q_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 1L
)

ApBq_npi_Ec(
  A,
  LB,
  bA,
  bB,
  mu,
  p_ = 1,
  q_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBIqr_int_nEc(
  A,
  LB,
  bB,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  error_bound = TRUE,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBIqr_npi_Ec(
  A,
  LB,
  bA,
  bB,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

IpBDqr_gen_Ec(
  LB,
  D,
  bB,
  bD,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBDqr_int_Ec(
  A,
  LB,
  D,
  bB,
  bD,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBDqr_npi_Ec(
  A,
  LB,
  D,
  bA,
  bB,
  bD,
  mu,
  p_ = 1,
  q_ = 1,
  r_ = 1,
  m = 100L,
  thr_margin = 100,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApIq_npi_nEl(
  LA,
  bA,
  mu,
  p_ = 1L,
  q_ = 1L,
  m = 100L,
  thr_margin = 100L,
  nthreads = 1L
)

ApBq_npi_El(
  A,
  LB,
  bA,
  bB,
  mu,
  p_ = 1L,
  q_ = 1L,
  m = 100L,
  thr_margin = 100L,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBIqr_int_nEl(
  A,
  LB,
  bB,
  mu,
  p_ = 1L,
  q_ = 1L,
  r_ = 1L,
  m = 100L,
  error_bound = TRUE,
  thr_margin = 100L,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBIqr_npi_El(
  A,
  LB,
  bA,
  bB,
  mu,
  p_ = 1L,
  q_ = 1L,
  r_ = 1L,
  m = 100L,
  thr_margin = 100L,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

IpBDqr_gen_El(
  LB,
  D,
  bB,
  bD,
  mu,
  p_ = 1L,
  q_ = 1L,
  r_ = 1L,
  m = 100L,
  thr_margin = 100L,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBDqr_int_El(
  A,
  LB,
  D,
  bB,
  bD,
  mu,
  p_ = 1L,
  q_ = 1L,
  r_ = 1L,
  m = 100L,
  thr_margin = 100L,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

ApBDqr_npi_El(
  A,
  LB,
  D,
  bA,
  bB,
  bD,
  mu,
  p_ = 1L,
  q_ = 1L,
  r_ = 1L,
  m = 100L,
  thr_margin = 100L,
  nthreads = 0L,
  tol_zero = 2.2e-14
)

rqfpE(nit, A, B, D, p_, q_, r_, mu, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_A1B1_Ed_+3A_quantile">quantile</code></td>
<td>
<p>Scalar of quantile <code class="reqn">q</code>, passed as <code>double</code></p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_a">A</code>, <code id="p_A1B1_Ed_+3A_b">B</code>, <code id="p_A1B1_Ed_+3A_d">D</code></td>
<td>
<p>Argument matrices passed as <code>Eigen::Matrix</code>.
Symmetry is assumed.</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code>
passed as <code>Eigen::Array</code>.  For <code>d_broda_Ed()</code>,
assumed to be rotated by the eigenvectors of
<code class="reqn">\mathbf{A} - q \mathbf{B}</code></p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_m">m</code></td>
<td>
<p>Integer to specify the order of polynomials at which the series
expression is truncated.  Passed as <code>Eigen::Index</code>
(aka <code>std::ptrdiff_t</code> or <code>long long int</code>)</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_stop_on_error">stop_on_error</code></td>
<td>
<p><code>bool</code> to specify whether execution is stopped upon error in
numerical integration or root finding</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_thr_margin">thr_margin</code></td>
<td>
<p>Optional argument to adjust the threshold for scaling.  See
&ldquo;Scaling&rdquo; in <code><a href="#topic+d1_i">d1_i</a></code>.</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_nthreads">nthreads</code></td>
<td>
<p><code>int</code> to specify the number of threads in OpenMP-enabled
functions.  See &ldquo;Multithreading&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>.</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_tol_zero">tol_zero</code></td>
<td>
<p>Tolerance against which numerical zero is determined</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_la">LA</code>, <code id="p_A1B1_Ed_+3A_lb">LB</code></td>
<td>
<p>Eigenvalues of the argument matrices passed as <code>Eigen::Array</code></p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_autoscale_args">autoscale_args</code></td>
<td>
<p>Factor to which the largest absolute eigenvalue of
<code class="reqn">\mathbf{A} - q \mathbf{B}</code> is scaled, passed as <code>double</code></p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_epsrel">epsrel</code>, <code id="p_A1B1_Ed_+3A_epsabs">epsabs</code>, <code id="p_A1B1_Ed_+3A_limit">limit</code>, <code id="p_A1B1_Ed_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional arguments passed to <code>gsl_integration_qagi()</code> or
<code>gsl_root_test_delta()</code></p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_order_spa">order_spa</code></td>
<td>
<p><code>int</code> to specify order of saddlepoint approximation</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_p_">p_</code>, <code id="p_A1B1_Ed_+3A_q_">q_</code>, <code id="p_A1B1_Ed_+3A_r_">r_</code></td>
<td>
<p>Exponents for <code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, and
<code class="reqn">\mathbf{D}</code>.
Passed as <code>double</code> or <code>long double</code>.</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_ba">bA</code>, <code id="p_A1B1_Ed_+3A_bb">bB</code>, <code id="p_A1B1_Ed_+3A_bd">bD</code></td>
<td>
<p>Scaling coefficients for <code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>,
and <code class="reqn">\mathbf{D}</code>.  Passed as <code>double</code> or <code>long double</code>.</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_error_bound">error_bound</code></td>
<td>
<p><code>bool</code> to specify whether the error bound is returned</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_nit">nit</code></td>
<td>
<p><code>int</code> to specify the number of iteration or sample size</p>
</td></tr>
<tr><td><code id="p_A1B1_Ed_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix <code class="reqn">\mathbf{\Sigma}</code> for <code class="reqn">\mathbf{x}</code>.
Passed as <code>Eigen::Matrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ApIq_int_nmE()</code> calls the C function
<code>gsl_sf_hyperg_1F1()</code> from GSL via <span class="pkg">RcppGSL</span>.
</p>


<h3>Value</h3>

<p>All return a list via <code>Rcpp::List</code> of the following (as appropriate):
</p>

<dl>
<dt><code>$ans</code></dt><dd><p>Exact moment, from <code>double</code> or
<code>long double</code></p>
</dd>
<dt><code>$ansseq</code></dt><dd><p>Series for the moment, from
<code>Eigen::Array</code></p>
</dd>
<dt><code>$errseq</code></dt><dd><p>Series of errors, from <code>Eigen::Array</code></p>
</dd>
<dt><code>$twosided</code></dt><dd><p>Logical, from <code>bool</code></p>
</dd>
<dt><code>$dimnished</code></dt><dd><p>Logical, from <code>bool</code></p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>p_A1B1_Ed()</code>: <code>pqfm_A1B1()</code>, double
</p>
</li>
<li> <p><code>p_A1B1_El()</code>: <code>pqfm_A1B1()</code>, long double
</p>
</li>
<li> <p><code>p_A1B1_Ec()</code>: <code>pqfm_A1B1()</code>, coefficient-wise scaling
</p>
</li>
<li> <p><code>d_A1I1_Ed()</code>: <code>dqfm_A1I1()</code>
</p>
</li>
<li> <p><code>p_imhof_Ed()</code>: <code>pqfm_imhof()</code>
</p>
</li>
<li> <p><code>d_broda_Ed()</code>: <code>dqfm_broda()</code>
</p>
</li>
<li> <p><code>d_butler_Ed()</code>: <code>dqfm_butler()</code>
</p>
</li>
<li> <p><code>p_butler_Ed()</code>: <code>pqfm_butler()</code>
</p>
</li>
<li> <p><code>Ap_int_E()</code>: <code>qfm_Ap_int()</code>
</p>
</li>
<li> <p><code>ABpq_int_E()</code>: <code>qfpm_ABpq_int()</code>
</p>
</li>
<li> <p><code>ABDpqr_int_E()</code>: <code>qfpm_ABDpqr_int()</code>
</p>
</li>
<li> <p><code>ApIq_int_cE()</code>: <code>qfrm_ApIq_int()</code>, central
</p>
</li>
<li> <p><code>ApIq_int_nE()</code>: <code>qfrm_ApIq_int()</code>, noncentral
</p>
</li>
<li> <p><code>ApIq_npi_cE()</code>: <code>qfrm_ApIq_npi()</code>, central
</p>
</li>
<li> <p><code>ApIq_npi_nEd()</code>: <code>qfrm_ApIq_npi()</code>, noncentral, double
</p>
</li>
<li> <p><code>ApBq_int_E()</code>: <code>qfrm_ApBq_int()</code>
</p>
</li>
<li> <p><code>ApBq_npi_Ed()</code>: <code>qfrm_ApBq_npi()</code>, double
</p>
</li>
<li> <p><code>ApBIqr_int_cEd()</code>: <code>qfmrm_ApBIqr_int()</code>, central
</p>
</li>
<li> <p><code>ApBIqr_int_nEd()</code>: <code>qfmrm_ApBIqr_int()</code>, noncentral, double
</p>
</li>
<li> <p><code>ApBIqr_npi_Ed()</code>: <code>qfmrm_ApBIqr_npi()</code>, double
</p>
</li>
<li> <p><code>IpBDqr_gen_Ed()</code>: <code>qfmrm_IpBDqr_gen()</code>, double
</p>
</li>
<li> <p><code>ApBDqr_int_Ed()</code>: <code>qfmrm_ApBDqr_int()</code>, double
</p>
</li>
<li> <p><code>ApBDqr_npi_Ed()</code>: <code>qfmrm_ApBDqr_npi()</code>, double
</p>
</li>
<li> <p><code>ApIq_npi_nEc()</code>: <code>qfrm_ApIq_npi()</code>, noncentral, coefficient-wise scaling
</p>
</li>
<li> <p><code>ApBq_npi_Ec()</code>: <code>qfrm_ApBq_npi()</code>, coefficient-wise scaling
</p>
</li>
<li> <p><code>ApBIqr_int_nEc()</code>: <code>qfmrm_ApBIqr_int()</code>, noncentral, coefficient-wise scaling
</p>
</li>
<li> <p><code>ApBIqr_npi_Ec()</code>: <code>qfmrm_ApBIqr_npi()</code>, coefficient-wise scaling
</p>
</li>
<li> <p><code>IpBDqr_gen_Ec()</code>: <code>qfmrm_IpBDqr_gen()</code>, double
</p>
</li>
<li> <p><code>ApBDqr_int_Ec()</code>: <code>qfmrm_ApBDqr_int()</code>, coefficient-wise scaling
</p>
</li>
<li> <p><code>ApBDqr_npi_Ec()</code>: <code>qfmrm_ApBDqr_npi()</code>, coefficient-wise scaling
</p>
</li>
<li> <p><code>ApIq_npi_nEl()</code>: <code>qfrm_ApIq_npi()</code>, noncentral, long double
</p>
</li>
<li> <p><code>ApBq_npi_El()</code>: <code>qfrm_ApBq_npi()</code>, long double
</p>
</li>
<li> <p><code>ApBIqr_int_nEl()</code>: <code>qfmrm_ApBIqr_int()</code>, noncentral, long double
</p>
</li>
<li> <p><code>ApBIqr_npi_El()</code>: <code>qfmrm_ApBIqr_npi()</code>, long double
</p>
</li>
<li> <p><code>IpBDqr_gen_El()</code>: <code>qfmrm_IpBDqr_gen()</code>, long double
</p>
</li>
<li> <p><code>ApBDqr_int_El()</code>: <code>qfmrm_ApBDqr_int()</code>, long double
</p>
</li>
<li> <p><code>ApBDqr_npi_El()</code>: <code>qfmrm_ApBDqr_npi()</code>, long double
</p>
</li>
<li> <p><code>rqfpE()</code>: <code>rqfp()</code>
</p>
</li></ul>

<hr>
<h2 id='print.qfrm'>Methods for qfrm and qfpm objects</h2><span id='topic+print.qfrm'></span><span id='topic+print.qfpm'></span><span id='topic+plot.qfrm'></span><span id='topic+methods.qfrm'></span>

<h3>Description</h3>

<p>Straightforward <code>print</code> and <code>plot</code> methods are defined
for <code>qfrm</code> and <code>qfpm</code> objects which result from the
<code><a href="#topic+qfrm">qfrm</a></code>, <code><a href="#topic+qfmrm">qfmrm</a></code>, and <code><a href="#topic+qfpm">qfpm</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qfrm'
print(
  x,
  digits = getOption("digits"),
  show_range = !is.null(x$error_bound),
  ...
)

## S3 method for class 'qfpm'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'qfrm'
plot(
  x,
  add_error = length(x$seq_error) &gt; 0,
  add_legend = add_error,
  ylim = x$statistic * ylim_f,
  ylim_f = c(0.9, 1.1),
  xlab = "Order of evaluation",
  ylab = "Moment of ratio",
  col_m = "royalblue4",
  col_e = "tomato",
  lwd_m = 1,
  lwd_e = 1,
  lty_m = 1,
  lty_e = 2,
  pos_leg = "topright",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.qfrm_+3A_x">x</code></td>
<td>
<p><code>qfrm</code> or <code>qfpm</code> object</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to be printed.</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_show_range">show_range</code></td>
<td>
<p>Logical to specify whether the possible range for the moment
is printed (when available).  Default <code>TRUE</code> when available.</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_...">...</code></td>
<td>
<p>In the <code>plot</code> methods, passed to
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.  In the <code>print</code> methods,
ignored (retained for the compatibility with the generic method).</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_add_error">add_error</code></td>
<td>
<p>Logical to specify whether the sequence of error bounds is plotted
(when available).  Default <code>TRUE</code> when available.</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_add_legend">add_legend</code></td>
<td>
<p>Logical to specify whether a legend is added.  Turned on by default
when <code>add_error = TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_ylim">ylim</code>, <code id="print.qfrm_+3A_ylim_f">ylim_f</code></td>
<td>
<p><code>ylim</code> is passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.  By default,
this is automatically set to <code>ylim_f</code> times the terminal value of
the series expression (<code>x$statistic</code>).  <code>ylim_f</code> is
by default <code>c(0.9, 1.1)</code>.</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_xlab">xlab</code>, <code id="print.qfrm_+3A_ylab">ylab</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_col_m">col_m</code>, <code id="print.qfrm_+3A_col_e">col_e</code>, <code id="print.qfrm_+3A_lwd_m">lwd_m</code>, <code id="print.qfrm_+3A_lwd_e">lwd_e</code>, <code id="print.qfrm_+3A_lty_m">lty_m</code>, <code id="print.qfrm_+3A_lty_e">lty_e</code></td>
<td>
<p><code>col</code>, <code>lwd</code>, and <code>lty</code> to plot the sequences of
the moment (<code>***_m</code>) and its error bound (<code>***_e</code>)</p>
</td></tr>
<tr><td><code id="print.qfrm_+3A_pos_leg">pos_leg</code></td>
<td>
<p>Position of the legend, e.g., <code>"topright"</code>, <code>"bottomright"</code>,
passed as the first argument for <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> methods simply display the moment <code>x$statistic</code>
(typically a partial sum), its error bound <code>x$error_bound</code>
(when available), and the possible range of the moment
(<code>x$statistic</code> to <code>x$statistic + x$error_bound</code> in case of
one-sided error bound; <code>x$statistic - x$error_bound</code> to
<code>x$statistic + x$error_bound</code> in case of two-sided).
</p>
<p>The <code>plot</code> method is designed for quick inspection of the profile of
the partial sum of the series along varying orders
<code>cumsum(x$terms)</code>.  When the object has a sequence for error bounds
<code>x$seq_error</code>, this is also shown with a broken line (by default).  When
the object has an exact moment (i.e., resulting from
<code><a href="#topic+qfrm_ApIq_int">qfrm_ApIq_int</a>()</code> or the <code><a href="#topic+qfpm">qfpm</a></code> functions), a message
is thrown to tell inspection of the plot will not be required in this case.
</p>


<h3>Value</h3>

<p>The <code>print</code> method invisibly returns the input.
</p>
<p>The <code>plot</code> method is used for the side effect (and invisibly returns
<code>NULL</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_qfrm">new_qfrm</a></code>: descriptions of the classes and their
&ldquo;constructors&rdquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nv &lt;- 4
A &lt;- diag(nv:1)
B &lt;- diag(1:nv)
mu &lt;- rep.int(1, nv)

res1 &lt;- qfrm(A, B, p = 3, mu = mu)
print(res1)
print(res1, digits = 5)
print(res1, digits = 10)

## Default plot: ylim too narrow to see the error bound at this m
plot(res1)

## With extended ylim
plot(res1, ylim_f = c(0.8, 1.2), pos_leg = "topleft")

## In this case, it is easy to increase m
(res2 &lt;- qfrm(A, B, p = 3, mu = mu, m = 200))
plot(res2)

</code></pre>

<hr>
<h2 id='qfmrm'>Moment of multiple ratio of quadratic forms in normal variables</h2><span id='topic+qfmrm'></span><span id='topic+qfmrm_ApBIqr_int'></span><span id='topic+qfmrm_ApBIqr_npi'></span><span id='topic+qfmrm_IpBDqr_gen'></span><span id='topic+qfmrm_ApBDqr_int'></span><span id='topic+qfmrm_ApBDqr_npi'></span>

<h3>Description</h3>

<p><code>qfmrm()</code> is a front-end function to obtain the (compound) moment
of a multiple ratio of quadratic forms in normal variables in the following
special form:
<code class="reqn"> \mathrm{E} \left(
  \frac{(\mathbf{x^\mathit{T} A x})^p }
       {(\mathbf{x^\mathit{T} B x})^q (\mathbf{x^\mathit{T} D x})^r}
  \right) </code>, where
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{\Sigma})</code>.  Like <code>qfrm()</code>, this function calls one of
the following &ldquo;internal&rdquo; functions for actual calculation,
as appropriate.
</p>
<p><code>qfmrm_ApBIqr_int()</code>: For <code class="reqn">\mathbf{D} = \mathbf{I}_n</code> and
positive-integral <code class="reqn">p</code>
</p>
<p><code>qfmrm_ApBIqr_npi()</code>: For <code class="reqn">\mathbf{D} = \mathbf{I}_n</code> and
non-integral <code class="reqn">p</code>
</p>
<p><code>qfmrm_IpBDqr_gen()</code>: For <code class="reqn">\mathbf{A} = \mathbf{I}_n</code>
</p>
<p><code>qfmrm_ApBDqr_int()</code>: For general <code class="reqn">\mathbf{A}</code>,
<code class="reqn">\mathbf{B}</code>, and <code class="reqn">\mathbf{D}</code>, and positive-integral <code class="reqn">p</code>
</p>
<p><code>qfmrm_ApBDqr_npi()</code>: For general <code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>,
and <code class="reqn">\mathbf{D}</code>, and non-integral <code class="reqn">p</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfmrm(
  A,
  B,
  D,
  p = 1,
  q = p/2,
  r = q,
  m = 100L,
  mu = rep.int(0, n),
  Sigma = diag(n),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  ...
)

qfmrm_ApBIqr_int(
  A,
  B,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  error_bound = TRUE,
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaB = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)

qfmrm_ApBIqr_npi(
  A,
  B,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaA = 1,
  alphaB = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)

qfmrm_IpBDqr_gen(
  B,
  D,
  p = 1,
  q = 1,
  r = 1,
  mu = rep.int(0, n),
  m = 100L,
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaB = 1,
  alphaD = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)

qfmrm_ApBDqr_int(
  A,
  B,
  D,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaB = 1,
  alphaD = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)

qfmrm_ApBDqr_npi(
  A,
  B,
  D,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaA = 1,
  alphaB = 1,
  alphaD = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfmrm_+3A_a">A</code>, <code id="qfmrm_+3A_b">B</code>, <code id="qfmrm_+3A_d">D</code></td>
<td>
<p>Argument matrices.  Should be square.  Will be automatically symmetrized.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_p">p</code>, <code id="qfmrm_+3A_q">q</code>, <code id="qfmrm_+3A_r">r</code></td>
<td>
<p>Exponents for <code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, and
<code class="reqn">\mathbf{D}</code>, respectively.  By default, <code>q</code> equals <code>p/2</code>
and <code>r</code> equals <code>q</code>.  If unsure, specify all explicitly.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_m">m</code></td>
<td>
<p>Order of polynomials at which the series expression is truncated.  <code class="reqn">M</code>
in Hillier et al. (2009, 2014).</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="qfmrm_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix <code class="reqn">\mathbf{\Sigma}</code> for
<code class="reqn">\mathbf{x}</code>.  Accommodated only by the front-end
<code>qfmrm()</code>.  See &ldquo;Details&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_tol_zero">tol_zero</code></td>
<td>
<p>Tolerance against which numerical zero is determined.  Used to determine,
e.g., whether <code>mu</code> is a zero vector, <code>A</code> or <code>B</code> equals
the identity matrix, etc.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_tol_sing">tol_sing</code></td>
<td>
<p>Tolerance against which matrix singularity and rank are determined.  The
eigenvalues smaller than this are considered zero.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_...">...</code></td>
<td>
<p>Additional arguments in the front-end <code>qfmrm()</code> will be passed to
the appropriate &ldquo;internal&rdquo; function.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_error_bound">error_bound</code></td>
<td>
<p>Logical to specify whether an error bound is returned (if available).</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_check_convergence">check_convergence</code></td>
<td>
<p>Specifies how numerical convergence is checked (see &ldquo;Details&rdquo;).
Options:
</p>

<dl>
<dt><code>"relative"</code></dt><dd><p>default; magnitude of the last term of
the series relative to the sum is compared with <code>tol_conv</code></p>
</dd>
<dt><code>"strict_relative"</code> or <code>TRUE</code></dt><dd><p>same, but stricter than
default by setting <code>tol_conv = .Machine$double.eps</code>
(unless a smaller value is specified by the user)</p>
</dd>
<dt><code>"absolute"</code></dt><dd><p>absolute magnitude of the last term is
compared with <code>tol_conv</code></p>
</dd>
<dt><code>"none"</code> or <code>FALSE</code></dt><dd><p>skips convergence check</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="qfmrm_+3A_use_cpp">use_cpp</code></td>
<td>
<p>Logical to specify whether the calculation is done with C++
functions via <code>Rcpp</code>.  <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_cpp_method">cpp_method</code></td>
<td>
<p>Method used in C++ calculations to avoid numerical
overflow/underflow (see &ldquo;Details&rdquo;).  Options:
</p>

<dl>
<dt><code>"double"</code></dt><dd><p>default; fastest but prone to underflow in
some conditions</p>
</dd>
<dt><code>"long_double"</code></dt><dd><p>same algorithm but using the
<code>long double</code> variable type; robust but slow and
memory-inefficient</p>
</dd>
<dt><code>"coef_wise"</code></dt><dd><p>coefficient-wise scaling algorithm;
most robust but variably slow</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="qfmrm_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads used in OpenMP-enabled C++ functions.  See
&ldquo;Multithreading&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_tol_conv">tol_conv</code></td>
<td>
<p>Tolerance against which numerical convergence of series is checked.  Used
with <code>check_convergence</code>.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_thr_margin">thr_margin</code></td>
<td>
<p>Optional argument to adjust the threshold for scaling (see &ldquo;Scaling&rdquo;
in <code><a href="#topic+d1_i">d1_i</a></code>).  Passed to internal functions (<code><a href="#topic+d1_i">d1_i</a></code>,
<code><a href="#topic+d2_ij">d2_ij</a></code>, <code><a href="#topic+d3_ijk">d3_ijk</a></code>) or their C++ equivalents.</p>
</td></tr>
<tr><td><code id="qfmrm_+3A_alphaa">alphaA</code>, <code id="qfmrm_+3A_alphab">alphaB</code>, <code id="qfmrm_+3A_alphad">alphaD</code></td>
<td>
<p>Factors for the scaling constants for <code class="reqn">\mathbf{A}</code>,
<code class="reqn">\mathbf{B}</code>, and <code class="reqn">\mathbf{D}</code>, respectively.  See
&ldquo;Details&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usage of these functions is similar to <code><a href="#topic+qfrm">qfrm</a></code>, to which
the user is referred for documentation.  It is assumed that
<code class="reqn">\mathbf{B} \neq \mathbf{D}</code>
(otherwise, the problem reduces to a simple ratio).
</p>
<p>When <code>B</code> is identity or missing, this and its exponent <code>q</code> will
be swapped with <code>D</code> and <code>r</code>, respectively, before
<code>qfmrm_ApBIqr_***()</code> is called.
</p>
<p>The existence conditions for the moments of this multiple ratio can be
reduced to those for a simple ratio, provided that one of the null spaces
of <code class="reqn">\mathbf{B}</code> and <code class="reqn">\mathbf{D}</code> is a subspace of the other
(including the case they are null).  The conditions of Bao and Kan
(2013: proposition 1) can then be
applied by replacing <code class="reqn">q</code> and <code class="reqn">m</code> there by <code class="reqn">q + r</code> and
<code class="reqn">\min{( \mathrm{rank}(\mathbf{B}), \mathrm{rank}(\mathbf{D}) )}
     </code>,
respectively (see also Smith 1989: p. 258 for
nonsingular <code class="reqn">\mathbf{B}</code>, <code class="reqn">\mathbf{D}</code>).  An error is
thrown if these conditions are not met in this case.  Otherwise
(i.e., <code class="reqn">\mathbf{B}</code> and <code class="reqn">\mathbf{D}</code> are both
singular and neither of their null spaces is a subspace of the other), it
seems difficult to define general moment existence conditions.  A sufficient
condition can be obtained by applying the same proposition with a new
denominator matrix whose null space is union of those of <code class="reqn">\mathbf{B}</code>
and <code class="reqn">\mathbf{D}</code> (Watanabe, 2023).  A warning is thrown if that
condition is not met in this case.
</p>
<p>Most of these functions, excepting <code>qfmrm_ApBIqr_int()</code> with zero
<code>mu</code>, involve evaluation of multiple series, which can suffer
from numerical overflow and underflow (see &ldquo;Scaling&rdquo; in
<code><a href="#topic+d1_i">d1_i</a></code> and &ldquo;Details&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>).  To avoid
this, <code>cpp_method = "long_double"</code> or <code>"coef_wise"</code> options can be
used (see &ldquo;Details&rdquo; in <code><a href="#topic+qfrm">qfrm</a></code>).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+new_qfrm">qfrm</a></code> object, as in <code><a href="#topic+qfrm">qfrm</a>()</code> functions.
</p>


<h3>References</h3>

<p>Bao, Y. and Kan, R. (2013) On the moments of ratios of quadratic forms in
normal random variables. <em>Journal of Multivariate Analysis</em>, <strong>117</strong>,
229&ndash;245.
<a href="https://doi.org/10.1016/j.jmva.2013.03.002">doi:10.1016/j.jmva.2013.03.002</a>.
</p>
<p>Smith, M. D. (1989). On the expectation of a ratio of quadratic forms
in normal variables. <em>Journal of Multivariate Analysis</em>, <strong>31</strong>, 244&ndash;257.
<a href="https://doi.org/10.1016/0047-259X%2889%2990065-1">doi:10.1016/0047-259X(89)90065-1</a>.
</p>
<p>Watanabe, J. (2023) Exact expressions and numerical evaluation of average
evolvability measures for characterizing and comparing <strong>G</strong> matrices.
<em>Journal of Mathematical Biology</em>, <strong>86</strong>, 95.
<a href="https://doi.org/10.1007/s00285-023-01930-8">doi:10.1007/s00285-023-01930-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfrm">qfrm</a></code> for simple ratio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some symmetric matrices and parameters
nv &lt;- 4
A &lt;- diag(nv:1)
B &lt;- diag(sqrt(1:nv))
D &lt;- diag((1:nv)^2 / nv)
mu &lt;- nv:1 / nv
Sigma &lt;- matrix(0.5, nv, nv)
diag(Sigma) &lt;- 1

## Expectation of (x^T A x)^2 / (x^T B x) (x^T x) where x ~ N(0, I)
(res1 &lt;- qfmrm(A, B, p = 2, q = 1, r = 1))
plot(res1)

# The above internally calls the following:
qfmrm_ApBIqr_int(A, B, p = 2, q = 1, r = 1) ## The same

# Similar result with different expression
# This is a suboptimal option and throws a warning
qfmrm_ApBIqr_npi(A, B, p = 2, q = 1, r = 1)

## Expectation of (x^T A x) / (x^T B x)^(1/2) (x^T D x)^(1/2) where x ~ N(0, I)
(res2 &lt;- qfmrm(A, B, D, p = 1, q = 1/2, r = 1/2))
plot(res2)

# The above internally calls the following:
qfmrm_ApBDqr_int(A, B, D, p = 1, q = 1/2, r = 1/2) ## The same

## Average response correlation between A and B
(res3 &lt;- qfmrm(crossprod(A, B), crossprod(A), crossprod(B),
               p = 1, q = 1/2, r = 1/2))
plot(res3)

## Same, but with x ~ N(mu, Sigma)
(res4 &lt;- qfmrm(crossprod(A, B), crossprod(A), crossprod(B),
               p = 1, q = 1/2, r = 1/2, mu = mu, Sigma = Sigma))
plot(res4)

## Average autonomy of D
(res5 &lt;- qfmrm(B = D, D = solve(D), p = 2, q = 1, r = 1))
plot(res5)

</code></pre>

<hr>
<h2 id='qfpm'>Moment of (product of) quadratic forms in normal variables</h2><span id='topic+qfpm'></span><span id='topic+qfm_Ap_int'></span><span id='topic+qfpm_ABpq_int'></span><span id='topic+qfpm_ABDpqr_int'></span>

<h3>Description</h3>

<p>Functions to obtain (compound) moments
of a product of quadratic forms in normal variables, i.e.,
<code class="reqn"> \mathrm{E} \left(
  (\mathbf{x^\mathit{T} A x})^p (\mathbf{x^\mathit{T} B x})^q
  (\mathbf{x^\mathit{T} D x})^r \right)
     </code>, where
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{\Sigma})</code>.
</p>
<p><code>qfm_Ap_int()</code> is for <code class="reqn">q = r = 0</code> (simple moment)
</p>
<p><code>qfpm_ABpq_int()</code> is for <code class="reqn">r = 0</code>
</p>
<p><code>qfpm_ABDpqr_int()</code> is for the product of all three powers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfm_Ap_int(
  A,
  p = 1,
  mu = rep.int(0, n),
  Sigma = diag(n),
  use_cpp = TRUE,
  cpp_method = "double",
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero
)

qfpm_ABpq_int(
  A,
  B,
  p = 1,
  q = 1,
  mu = rep.int(0, n),
  Sigma = diag(n),
  use_cpp = TRUE,
  cpp_method = "double",
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero
)

qfpm_ABDpqr_int(
  A,
  B,
  D,
  p = 1,
  q = 1,
  r = 1,
  mu = rep.int(0, n),
  Sigma = diag(n),
  use_cpp = TRUE,
  cpp_method = "double",
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfpm_+3A_a">A</code>, <code id="qfpm_+3A_b">B</code>, <code id="qfpm_+3A_d">D</code></td>
<td>
<p>Argument matrices.  Should be square.  Will be automatically symmetrized.</p>
</td></tr>
<tr><td><code id="qfpm_+3A_p">p</code>, <code id="qfpm_+3A_q">q</code>, <code id="qfpm_+3A_r">r</code></td>
<td>
<p>Exponents for <code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, and
<code class="reqn">\mathbf{D}</code>, respectively.  By default, these are set to the same
value.  If unsure, specify all explicitly.</p>
</td></tr>
<tr><td><code id="qfpm_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="qfpm_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix <code class="reqn">\mathbf{\Sigma}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="qfpm_+3A_use_cpp">use_cpp</code></td>
<td>
<p>Logical to specify whether the calculation is done with C++
functions via <code>Rcpp</code>.  <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="qfpm_+3A_cpp_method">cpp_method</code></td>
<td>
<p>Variable type used in C++ calculations.
In these functions this is ignored.</p>
</td></tr>
<tr><td><code id="qfpm_+3A_tol_zero">tol_zero</code></td>
<td>
<p>Tolerance against which numerical zero is determined.  Used to determine,
e.g., whether <code>mu</code> is a zero vector, <code>A</code> or <code>B</code> equals
the identity matrix, etc.</p>
</td></tr>
<tr><td><code id="qfpm_+3A_tol_sing">tol_sing</code></td>
<td>
<p>Tolerance against which matrix singularity and rank are determined.  The
eigenvalues smaller than this are considered zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement the super-short recursion algorithms described in
Hillier et al. (2014: sec. 3.1&ndash;3.2 and 4).  At present,
only positive integers are accepted as exponents
(negative exponents yield ratios, of course).  All these yield exact results.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+new_qfrm">qfpm</a></code> object which has the same elements as those
returned by the <code><a href="#topic+qfrm">qfrm</a></code> functions.  Use
<code>$statistic</code> to access the value of the moment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfrm">qfrm</a></code> and <code><a href="#topic+qfmrm">qfmrm</a></code> for moments of ratios
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some symmetric matrices and parameters
nv &lt;- 4
A &lt;- diag(nv:1)
B &lt;- diag(sqrt(1:nv))
D &lt;- diag((1:nv)^2 / nv)
mu &lt;- nv:1 / nv
Sigma &lt;- matrix(0.5, nv, nv)
diag(Sigma) &lt;- 1

## Expectation of (x^T A x)^2 where x ~ N(0, I)
qfm_Ap_int(A, 2)

## This is the same but obviously less efficient
qfpm_ABpq_int(A, p = 2, q = 0)

## Expectation of (x^T A x) (x^T B x) (x^T D x) where x ~ N(0, I)
qfpm_ABDpqr_int(A, B, D, 1, 1, 1)

## Expectation of (x^T A x) (x^T B x) (x^T D x) where x ~ N(mu, Sigma)
qfpm_ABDpqr_int(A, B, D, 1, 1, 1, mu = mu, Sigma = Sigma)

## Expectations of (x^T x)^2 where x ~ N(0, I) and x ~ N(mu, I)
## i.e., roundabout way to obtain moments of
## central and noncentral chi-square variables
qfm_Ap_int(diag(nv), 2)
qfm_Ap_int(diag(nv), 2, mu = mu)

</code></pre>

<hr>
<h2 id='qfratio-package'>qfratio: Moments and Distributions of Ratios of Quadratic Forms</h2><span id='topic+qfratio-package'></span>

<h3>Description</h3>

<p>This package is for evaluating moments of ratios (and products) of quadratic
forms in normal variables, specifically using recursive algorithms developed
by Bao et al. (2013) and Hillier et al. (2014) (see also Smith, 1989, 1993;
Hillier et al., 2009).  It also provides some functions to evaluate
distribution, quantile, and probability density functions of simple ratios
of quadratic forms in normal variables using several algorithms.  It was
originally developed as a supplement to Watanabe (2023) for evaluating
average evolvability measures in evolutionary quantitative genetics,
but can be used for a broader class of statistics.
</p>


<h3>Details</h3>

<p>The primary front-end functions of this package are
<code><a href="#topic+qfrm">qfrm</a>()</code> and <code><a href="#topic+qfmrm">qfmrm</a>()</code> for evaluating moments of
ratios of quadratic forms.  These pass arguments to one of the several
&ldquo;internal&rdquo; (though exported) functions which do actual calculations,
depending on the argument matrices and exponents.  In addition, there are
a few functions to calculate moments of products
of quadratic forms (integer exponents only; <code><a href="#topic+qfpm">qfpm</a></code>).
</p>
<p>There are many internal functions for calculating coefficients in
power-series expansion of generating functions for these moments
(<code><a href="#topic+d1_i">d1_i</a></code>, <code><a href="#topic+d2_ij">d2_ij</a></code>, <code><a href="#topic+d3_ijk">d3_ijk</a></code>,
<code><a href="#topic+dtil2_pq">dtil2_pq</a></code>) using &ldquo;super-short&rdquo; recursions
(Bao and Kan, 2013; Hillier et al. 2014).  Some of these coefficients are
related to the top-order zonal and invariant
polynomials of matrix arguments.
</p>
<p>The package also has some functions to evaluate distribution, quantile, and
density functions of simple ratios of quadratic forms: <code><a href="#topic+pqfr">pqfr</a>()</code>,
<code><a href="#topic+qqfr">qqfr</a>()</code>, and <code><a href="#topic+dqfr">dqfr</a>()</code>.
</p>
<p>See package vignettes (<code>vignette("qfratio")</code> and
<code>vignette("qfratio_distr")</code>) for more details.
</p>
<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qfratio</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Moments and Distributions of Ratios of Quadratic Forms Using Recursion</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-08</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Junya", "Watanabe", email = "Junya.Watanabe@uab.cat",
                    role = c("aut", "cre", "cph"),
                    comment = c(ORCID = "0000-0002-9810-5286")),
             person("Patrick", "Alken", role = "cph",
                    comment = "Author of bundled C codes from GSL"),
             person("Brian", "Gough", role = "cph",
                    comment = "Author of bundled C codes from GSL"),
             person("Pavel", "Holoborodko", role = "cph",
                    comment = "Author of bundled C codes from GSL"),
             person("Gerard", "Jungman", role = "cph",
                    comment = "Author of bundled C codes from GSL"),
             person("Reid", "Priedhorsky", role = "cph",
                    comment = "Author of bundled C codes from GSL"),
             person("Free Software Foundation, Inc.", role = "cph",
                    comment = "Copyright holder of some bundled scripts"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Evaluates moments of ratios (and products) of quadratic forms
    in normal variables, specifically using recursive algorithms developed by
    Bao and Kan (2013) &lt;doi:10.1016/j.jmva.2013.03.002&gt; and Hillier et al.
    (2014) &lt;doi:10.1017/S0266466613000364&gt;. Also provides distribution,
    quantile, and probability density functions of simple ratios of quadratic
    forms in normal variables with several algorithms. Originally developed as
    a supplement to Watanabe (2023) &lt;doi:10.1007/s00285-023-01930-8&gt; for
    evaluating average evolvability measures in evolutionary quantitative
    genetics, but can be used for a broader class of statistics. Generating 
    functions for these moments are also closely related to the top-order zonal
    and invariant polynomials of matrix arguments.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/watanabe-j/qfratio</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/watanabe-j/qfratio/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp, MASS, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppEigen</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> mvtnorm, CompQuadForm, graphics, testthat (&gt;= 3.0.0),
knitr, rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Roxygen: </td><td style="text-align: left;"> list(markdown = TRUE)</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Config/testthat/edition: </td><td style="text-align: left;"> 3</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr, rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Junya Watanabe [aut, cre, cph]
    (&lt;https://orcid.org/0000-0002-9810-5286&gt;),
  Patrick Alken [cph] (Author of bundled C codes from GSL),
  Brian Gough [cph] (Author of bundled C codes from GSL),
  Pavel Holoborodko [cph] (Author of bundled C codes from GSL),
  Gerard Jungman [cph] (Author of bundled C codes from GSL),
  Reid Priedhorsky [cph] (Author of bundled C codes from GSL),
  Free Software Foundation, Inc. [cph] (Copyright holder of some bundled
    scripts)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Junya Watanabe &lt;Junya.Watanabe@uab.cat&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
KiK                     Matrix square root and generalized inverse
S_fromUL                Make covariance matrix from eigenstructure
a1_pk                   Recursion for a_{p,k}
d1_i                    Coefficients in polynomial expansion of
                        generating function-single matrix
d2_ij                   Coefficients in polynomial expansion of
                        generating function-for ratios with two
                        matrices
d3_ijk                  Coefficients in polynomial expansion of
                        generating function-for ratios with three
                        matrices
dqfr                    Probability distribution of ratio of quadratic
                        forms
dtil2_pq                Coefficients in polynomial expansion of
                        generating function-for products
hgs                     Calculate hypergeometric series
hyperg_1F1_vec_b        Internal C++ wrappers for GSL
is_diagonal             Is this matrix diagonal?
iseq                    Are these vectors equal?
new_qfrm                Construct qfrm object
p_A1B1_Ed               Internal C++ functions
print.qfrm              Methods for qfrm and qfpm objects
qfmrm                   Moment of multiple ratio of quadratic forms in
                        normal variables
qfpm                    Moment of (product of) quadratic forms in
                        normal variables
qfratio-package         qfratio: Moments and Distributions of Ratios of
                        Quadratic Forms
qfrm                    Moment of ratio of quadratic forms in normal
                        variables
range_qfr               Get range of ratio of quadratic forms
rqfr                    Monte Carlo sampling of ratio/product of
                        quadratic forms
sum_counterdiag         Summing up counter-diagonal elements
tr                      Matrix trace function
</pre>


<h3>Author/Maintainer</h3>

<p>Junya Watanabe <a href="mailto:Junya.Watanabe@uab.cat">Junya.Watanabe@uab.cat</a>
</p>


<h3>References</h3>

<p>Bao, Y. and Kan, R. (2013) On the moments of ratios of quadratic forms in
normal random variables. <em>Journal of Multivariate Analysis</em>, <strong>117</strong>,
229&ndash;245.
<a href="https://doi.org/10.1016/j.jmva.2013.03.002">doi:10.1016/j.jmva.2013.03.002</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2009) Computationally efficient recursions
for top-order invariant polynomials with applications.
<em>Econometric Theory</em>, <strong>25</strong>, 211&ndash;242.
<a href="https://doi.org/10.1017/S0266466608090075">doi:10.1017/S0266466608090075</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2014) Generating functions and
short recursions, with applications to the moments of quadratic forms
in noncentral normal vectors. <em>Econometric Theory</em>, <strong>30</strong>, 436&ndash;473.
<a href="https://doi.org/10.1017/S0266466613000364">doi:10.1017/S0266466613000364</a>.
</p>
<p>Smith, M. D. (1989) On the expectation of a ratio of quadratic forms
in normal variables. <em>Journal of Multivariate Analysis</em>, <strong>31</strong>, 244&ndash;257.
<a href="https://doi.org/10.1016/0047-259X%2889%2990065-1">doi:10.1016/0047-259X(89)90065-1</a>.
</p>
<p>Smith, M. D. (1993) Expectations of ratios of quadratic forms in normal
variables: evaluating some top-order invariant polynomials.
<em>Australian Journal of Statistics</em>, <strong>35</strong>, 271&ndash;282.
<a href="https://doi.org/10.1111/j.1467-842X.1993.tb01335.x">doi:10.1111/j.1467-842X.1993.tb01335.x</a>.
</p>
<p>Watanabe, J. (2023) Exact expressions and numerical evaluation of average
evolvability measures for characterizing and comparing <strong>G</strong> matrices.
<em>Journal of Mathematical Biology</em>, <strong>86</strong>, 95.
<a href="https://doi.org/10.1007/s00285-023-01930-8">doi:10.1007/s00285-023-01930-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfrm">qfrm</a></code>: Moment of simple ratio of quadratic forms
</p>
<p><code><a href="#topic+qfmrm">qfmrm</a></code>: Moment of multiple ratio of quadratic forms
</p>
<p><code><a href="#topic+qfpm">qfpm</a></code>: Moment of product of quadratic forms
</p>
<p><code><a href="#topic+rqfr">rqfr</a></code>: Monte Carlo sampling of ratio/product of
quadratic forms
</p>
<p><code><a href="#topic+dqfr">dqfr</a></code>: Probability distribution of simple ratio of
quadratic forms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Symmetric matrices
nv &lt;- 4
A &lt;- diag(nv:1)
B &lt;- diag(sqrt(1:nv))
D &lt;- diag((1:nv)^2 / nv)
mu &lt;- nv:1 / nv
Sigma &lt;- matrix(0.5, nv, nv)
diag(Sigma) &lt;- 1

## Expectation of (x^T A x)^2 / (x^T x)^2 where x ~ N(0, I)
qfrm(A, p = 2)
## And a Monte Carlo mean of the same
mean(rqfr(1000, A = A, p = 2))

## Expectation of (x^T A x)^1/2 / (x^T x)^1/2 where x ~ N(0, I)
(res1 &lt;- qfrm(A, p = 1/2))
plot(res1)
## A Monte Carlo mean
mean(rqfr(1000, A = A, p = 1/2))

## (x^T A x)^2 / (x^T B x)^3 where x ~ N(mu, Sigma)
(res2 &lt;- qfrm(A, B, p = 2, q = 3, mu = mu, Sigma = Sigma))
plot(res2)
## A Monte Carlo mean
mean(rqfr(1000, A = A, B = B, p = 2, q = 3, mu = mu, Sigma = Sigma))

## Expectation of (x^T A x)^2 / (x^T B x) (x^T x) where x ~ N(0, I)
(res3 &lt;- qfmrm(A, B, p = 2, q = 1, r = 1))
plot(res3)
## A Monte Carlo mean
mean(rqfmr(1000, A = A, B = B, p = 2, q = 1, r = 1))

## Expectation of (x^T A x)^2 where x ~ N(0, I)
qfm_Ap_int(A, 2)
## A Monte Carlo mean
mean(rqfp(1000, A = A, p = 2, q = 0, r = 0))

## Expectation of (x^T A x) (x^T B x) (x^T D x) where x ~ N(mu, I)
qfpm_ABDpqr_int(A, B, D, 1, 1, 1, mu = mu)
## A Monte Carlo mean
mean(rqfp(1000, A = A, B = B, D = D, p = 1, q = 1, r = 1, mu = mu))

## Distribution and quantile functions,
## and density of (x^T A x) / (x^T B x)
quantiles &lt;- 0:nv + 0.5
(probs &lt;- pqfr(quantiles, A, B))
qqfr(probs, A, B)     # p = 1 yields maximum of ratio
dqfr(quantiles, A, B)

</code></pre>

<hr>
<h2 id='qfrm'>Moment of ratio of quadratic forms in normal variables</h2><span id='topic+qfrm'></span><span id='topic+qfrm_ApIq_int'></span><span id='topic+qfrm_ApIq_npi'></span><span id='topic+qfrm_ApBq_int'></span><span id='topic+qfrm_ApBq_npi'></span>

<h3>Description</h3>

<p><code>qfrm()</code> is a front-end function to obtain the (compound) moment
of a ratio of quadratic forms in normal variables, i.e.,
<code class="reqn"> \mathrm{E} \left(
  \frac{(\mathbf{x^\mathit{T} A x})^p }{(\mathbf{x^\mathit{T} B x})^q}
  \right) </code>, where
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{\Sigma})</code>.  Internally, <code>qfrm()</code> calls one of
the following functions which does the actual calculation, depending on
<code class="reqn">\mathbf{A}</code>, <code class="reqn">\mathbf{B}</code>, and <code class="reqn">p</code>.  Usually
the best one is automatically selected.
</p>
<p><code>qfrm_ApIq_int()</code>: For <code class="reqn">\mathbf{B} = \mathbf{I}_n</code> and
positive-integral <code class="reqn">p</code>.
</p>
<p><code>qfrm_ApIq_npi()</code>: For <code class="reqn">\mathbf{B} = \mathbf{I}_n</code> and
non-positive-integral <code class="reqn">p</code> (fraction or negative).
</p>
<p><code>qfrm_ApBq_int()</code>: For general <code class="reqn">\mathbf{B}</code> and
positive-integral <code class="reqn">p</code>.
</p>
<p><code>qfrm_ApBq_npi()</code>: For general <code class="reqn">\mathbf{B}</code> and
non-integral <code class="reqn">p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfrm(
  A,
  B,
  p = 1,
  q = p,
  m = 100L,
  mu = rep.int(0, n),
  Sigma = diag(n),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  ...
)

qfrm_ApIq_int(
  A,
  p = 1,
  q = p,
  m = 100L,
  mu = rep.int(0, n),
  use_cpp = TRUE,
  exact_method = TRUE,
  cpp_method = "double",
  nthreads = 1,
  tol_zero = .Machine$double.eps * 100,
  thr_margin = 100
)

qfrm_ApIq_npi(
  A,
  p = 1,
  q = p,
  m = 100L,
  mu = rep.int(0, n),
  error_bound = TRUE,
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 1,
  alphaA = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)

qfrm_ApBq_int(
  A,
  B,
  p = 1,
  q = p,
  m = 100L,
  mu = rep.int(0, n),
  error_bound = TRUE,
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = "double",
  nthreads = 1,
  alphaB = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)

qfrm_ApBq_npi(
  A,
  B,
  p = 1,
  q = p,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaA = 1,
  alphaB = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = tol_zero,
  thr_margin = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfrm_+3A_a">A</code>, <code id="qfrm_+3A_b">B</code></td>
<td>
<p>Argument matrices.  Should be square.  Will be automatically symmetrized.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_p">p</code>, <code id="qfrm_+3A_q">q</code></td>
<td>
<p>Exponents corresponding to <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code>,
respectively.  When only one is provided, the other is set to the same
value.  Should be length-one numeric (see &ldquo;Details&rdquo; for further
conditions).</p>
</td></tr>
<tr><td><code id="qfrm_+3A_m">m</code></td>
<td>
<p>Order of polynomials at which the series expression is truncated.  <code class="reqn">M</code>
in Hillier et al. (2009, 2014).</p>
</td></tr>
<tr><td><code id="qfrm_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code></p>
</td></tr>
<tr><td><code id="qfrm_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix <code class="reqn">\mathbf{\Sigma}</code> for
<code class="reqn">\mathbf{x}</code>.  Accommodated only by the front-end
<code>qfrm()</code>.  See &ldquo;Details&rdquo;.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_tol_zero">tol_zero</code></td>
<td>
<p>Tolerance against which numerical zero is determined.  Used to determine,
e.g., whether <code>mu</code> is a zero vector, <code>A</code> or <code>B</code> equals
the identity matrix, etc.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_tol_sing">tol_sing</code></td>
<td>
<p>Tolerance against which matrix singularity and rank are determined.  The
eigenvalues smaller than this are considered zero.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_...">...</code></td>
<td>
<p>Additional arguments in the front-end <code>qfrm()</code> will be passed to
the appropriate &ldquo;internal&rdquo; function.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_use_cpp">use_cpp</code></td>
<td>
<p>Logical to specify whether the calculation is done with C++
functions via <code>Rcpp</code>.  <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_exact_method">exact_method</code></td>
<td>
<p>Logical to specify whether the exact method is used in
<code>qfrm_ApIq_int()</code> (see &ldquo;Details&rdquo;).</p>
</td></tr>
<tr><td><code id="qfrm_+3A_cpp_method">cpp_method</code></td>
<td>
<p>Method used in C++ calculations to avoid numerical
overflow/underflow (see &ldquo;Details&rdquo;).  Options:
</p>

<dl>
<dt><code>"double"</code></dt><dd><p>default; fastest but prone to underflow in
some conditions</p>
</dd>
<dt><code>"long_double"</code></dt><dd><p>same algorithm but using the
<code>long double</code> variable type; robust but slow and
memory-inefficient</p>
</dd>
<dt><code>"coef_wise"</code></dt><dd><p>coefficient-wise scaling algorithm;
most robust but variably slow</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="qfrm_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads used in OpenMP-enabled C++
functions.  <code>0</code> or any negative value is special and means one-half of
the number of processors detected.  See &ldquo;Multithreading&rdquo; in
&ldquo;Details&rdquo;.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_thr_margin">thr_margin</code></td>
<td>
<p>Optional argument to adjust the threshold for scaling (see &ldquo;Scaling&rdquo;
in <code><a href="#topic+d1_i">d1_i</a></code>).  Passed to internal functions (<code><a href="#topic+d1_i">d1_i</a></code>,
<code><a href="#topic+d2_ij">d2_ij</a></code>, <code><a href="#topic+d3_ijk">d3_ijk</a></code>) or their C++ equivalents.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_error_bound">error_bound</code></td>
<td>
<p>Logical to specify whether an error bound is returned (if available).</p>
</td></tr>
<tr><td><code id="qfrm_+3A_check_convergence">check_convergence</code></td>
<td>
<p>Specifies how numerical convergence is checked (see &ldquo;Details&rdquo;).
Options:
</p>

<dl>
<dt><code>"relative"</code></dt><dd><p>default; magnitude of the last term of
the series relative to the sum is compared with <code>tol_conv</code></p>
</dd>
<dt><code>"strict_relative"</code> or <code>TRUE</code></dt><dd><p>same, but stricter than
default by setting <code>tol_conv = .Machine$double.eps</code>
(unless a smaller value is specified by the user)</p>
</dd>
<dt><code>"absolute"</code></dt><dd><p>absolute magnitude of the last term is
compared with <code>tol_conv</code></p>
</dd>
<dt><code>"none"</code> or <code>FALSE</code></dt><dd><p>skips convergence check</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="qfrm_+3A_alphaa">alphaA</code>, <code id="qfrm_+3A_alphab">alphaB</code></td>
<td>
<p>Factors for the scaling constants for <code class="reqn">\mathbf{A}</code> and
<code class="reqn">\mathbf{B}</code>, respectively.  See &ldquo;Details&rdquo;.</p>
</td></tr>
<tr><td><code id="qfrm_+3A_tol_conv">tol_conv</code></td>
<td>
<p>Tolerance against which numerical convergence of series is checked.  Used
with <code>check_convergence</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use infinite series expressions based on the joint
moment-generating function (with the top-order zonal/invariant polynomials)
(see Smith 1989, Hillier et al. 2009, 2014; Bao and Kan 2013), and the
results are typically partial (truncated) sums from these infinite series,
which necessarily involve truncation errors.  (An exception is when
<code class="reqn">\mathbf{B} = \mathbf{I}_n</code> and <code class="reqn">p</code> is
a positive integer, the case handled by <code>qfrm_ApIq_int()</code>.)
</p>
<p>The returned value is a list consisting of the truncated sequence
up to the order specified by <code>m</code>, its sum,
and error bounds corresponding to these (see &ldquo;Values&rdquo;).  The
<code>print</code> method only displays the terminal partial sum and its
error bound (when available).  Use <code>plot()</code> for visual inspection,
or the ordinary list element access as required.
</p>
<p>In most cases, <code>p</code> and <code>q</code> must be nonnegative
(in addition, <code>p</code> must be an integer in
<code>qfrm_ApIq_int()</code> and <code>qfrm_ApBq_int()</code> when used directly),
and an error is thrown otherwise.  The only exception is
<code>qfrm_ApIq_npi()</code> which accepts negative exponents to accommodate
<code class="reqn">\frac{(\mathbf{x^\mathit{T} x})^q }{(\mathbf{x^\mathit{T} A x})^p}
     </code>.  Even in the latter case,
the exponents must have the same sign.  (Technically, not all of
these conditions are necessary for the mathematical
results to hold, but they are enforced for simplicity).
</p>
<p>When <code>error_bound = TRUE</code> (default), <code>qfrm_ApBq_int()</code> evaluates
a truncation error bound following Hillier et al. (2009: theorem 6) or
Hillier et al. (2014: theorem 7) (for zero and nonzero means,
respectively).  <code>qfrm_ApIq_npi()</code> implements similar error bounds.  No
error bound is known for <code>qfrm_ApBq_npi()</code> to the
author's knowledge.
</p>
<p>For situations when the error bound is unavailable, a <em>very rough</em> check of
numerical convergence is also conducted; a warning is thrown if
the magnitude of the last term does not look small enough.  By default,
its relative magnitude to the sum is compared with
the tolerance controlled by <code>tol_conv</code>, whose default is
<code>.Machine$double.eps^(1/4)</code> (= ~<code>1.2e-04</code>)
(see <code>check_convergence</code>).
</p>
<p>When <code>Sigma</code> is provided, the quadratic forms are transformed into
a canonical form; that is, using the decomposition
<code class="reqn">\mathbf{\Sigma} = \mathbf{K} \mathbf{K}^T</code>, where the
number of columns <code class="reqn">m</code> of <code class="reqn">\mathbf{K}</code> equals the rank of
<code class="reqn">\mathbf{\Sigma}</code>,
<code class="reqn">\mathbf{A}_\mathrm{new} = \mathbf{K^\mathit{T} A K}</code>,
<code class="reqn">\mathbf{B}_\mathrm{new} = \mathbf{K^\mathit{T} B K}</code>,
and <code class="reqn">\mathbf{x}_\mathrm{new} = \mathbf{K}^{-} \mathbf{x}
         \sim N_m(\mathbf{K}^{-} \bm{\mu}, \mathbf{I}_m)
         </code>.  <code>qfrm()</code> handles this
by transforming <code>A</code>, <code>B</code>, and <code>mu</code> and calling itself
recursively with these new arguments.  Note that the &ldquo;internal&rdquo;
functions do not accommodate <code>Sigma</code> (the error for unused arguments
will happen).  For singular <code class="reqn">\mathbf{\Sigma}</code>, one of the
following conditions must be met for the above transformation to be valid:
<strong>1</strong>) <code class="reqn">\bm{\mu}</code> is in the range of <code class="reqn">\mathbf{\Sigma}</code>;
<strong>2</strong>) <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code> are in the range of
<code class="reqn">\mathbf{\Sigma}</code>; or
<strong>3</strong>) <code class="reqn">\mathbf{A} \bm{\mu} = \mathbf{B} \bm{\mu} = \mathbf{0}_n
            </code>.  An error is thrown
if none is met with a singular <code>Sigma</code>.
</p>
<p>The existence of the moment is assessed by the eigenstructures of
<code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code>, <code class="reqn">p</code>, and <code class="reqn">q</code>, according
to Bao and Kan (2013: proposition 1).  An error will result if the conditions
are not met.
</p>
<p>Straightforward implementation of the original recursive algorithms can
suffer from numerical overflow when the problem is large.  Internal
functions (<code><a href="#topic+d1_i">d1_i</a></code>, <code><a href="#topic+d2_ij">d2_ij</a></code>, <code><a href="#topic+d3_ijk">d3_ijk</a></code>)
are designed to avoid overflow by order-wise scaling.  However,
when evaluation of multiple series is required
(<code>qfrm_ApIq_npi()</code> with nonzero <code>mu</code> and <code>qfrm_ApBq_npi()</code>),
the scaling occasionally yields underflow/diminishing of some terms to
numerical <code>0</code>, causing inaccuracy.  A warning is
thrown in this case.  (See also &ldquo;Scaling&rdquo; in <code><a href="#topic+d1_i">d1_i</a></code>.)
To avoid this problem, the C++ versions of these functions have two
workarounds, as controlled by <code>cpp_method</code>.  <strong>1</strong>)
The <code>"long_double"</code> option uses the <code>long double</code> variable
type instead of the regular <code>double</code>.  This is generally slow and
most memory-inefficient.  <strong>2</strong>) The <code>"coef_wise"</code> option uses
a coefficient-wise scaling algorithm with the <code>double</code>
variable type.  This is generally robust against
underflow issues.  Computational time varies a lot with conditions;
generally only modestly slower than the <code>"double"</code> option, but can be
the slowest in some extreme conditions.
</p>
<p>For the sake of completeness (only), the scaling parameters <code class="reqn">\beta</code>
(see the package vignette) can be modified via
the arguments <code>alphaA</code> and <code>alphaB</code>.  These are the factors for
the inverses of the largest eigenvalues of <code class="reqn">\mathbf{A}</code> and
<code class="reqn">\mathbf{B}</code>, respectively, and must be between 0 and 2.  The
default is 1, which should suffice for most purposes.  Values larger than 1
often yield faster convergence, but are <em>not</em>
recommended as the error bound will not strictly hold
(see Hillier et al. 2009, 2014).
</p>


<h4>Multithreading</h4>

<p>All these functions use C++ versions to speed up computation
by default.  Furthermore, some of the C++ functions, in particular
those using more than one matrix arguments, are parallelized with
OpenMP (when available).  Use the argument <code>nthreads</code> to
control the number of OpenMP threads.  By default
(<code>nthreads = 0</code>), one-half of the processors detected with
<code>omp_get_num_procs()</code> are used.  This is except when all the
argument matrices share the same eigenvectors and hence the calculation
only involves element-wise operations of eigenvalues.  In that case,
the calculation is typically fast without
parallelization, so <code>nthreads</code> is automatically set to <code>1</code>
unless explicitly specified otherwise; the user can still specify
a larger value or <code>0</code> for (typically marginal) speed gains in large
problems.
</p>



<h4>Exact method for <code>qfrm_ApIq_int()</code></h4>

<p>An exact expression of the moment is available when
<code class="reqn">p</code> is integer and <code class="reqn">\mathbf{B} = \mathbf{I}_n</code>
(handled by <code>qfrm_ApIq_int()</code>), whose expression involves
a confluent hypergeometric function when <code class="reqn">\bm{\mu}</code> is nonzero
(Hillier et al. 2014: theorem 4).  There is an option
(<code>exact_method = FALSE</code>) to use the ordinary infinite series expression
(Hillier et al. 2009), which is less accurate and slow.
</p>



<h3>Value</h3>

<p>A <code><a href="#topic+new_qfrm">qfrm</a></code> object consisting of the following:
</p>

<dl>
<dt><code>$statistic</code></dt><dd><p>evaluation result (<code>sum(terms)</code>)</p>
</dd>
<dt><code>$terms</code></dt><dd><p>vector of <code class="reqn">0</code>th to <code class="reqn">m</code>th order terms</p>
</dd>
<dt><code>$error_bound</code></dt><dd><p>error bound of <code>statistic</code></p>
</dd>
<dt><code>$seq_error</code></dt><dd><p>vector of error bounds corresponding to
partial sums (<code>cumsum(terms)</code>)</p>
</dd>
</dl>



<h3>References</h3>

<p>Bao, Y. and Kan, R. (2013) On the moments of ratios of quadratic forms in
normal random variables. <em>Journal of Multivariate Analysis</em>, <strong>117</strong>,
229&ndash;245.
<a href="https://doi.org/10.1016/j.jmva.2013.03.002">doi:10.1016/j.jmva.2013.03.002</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2009) Computationally efficient recursions
for top-order invariant polynomials with applications.
<em>Econometric Theory</em>, <strong>25</strong>, 211&ndash;242.
<a href="https://doi.org/10.1017/S0266466608090075">doi:10.1017/S0266466608090075</a>.
</p>
<p>Hillier, G., Kan, R. and Wang, X. (2014) Generating functions and
short recursions, with applications to the moments of quadratic forms
in noncentral normal vectors. <em>Econometric Theory</em>, <strong>30</strong>, 436&ndash;473.
<a href="https://doi.org/10.1017/S0266466613000364">doi:10.1017/S0266466613000364</a>.
</p>
<p>Smith, M. D. (1989) On the expectation of a ratio of quadratic forms
in normal variables. <em>Journal of Multivariate Analysis</em>, <strong>31</strong>, 244&ndash;257.
<a href="https://doi.org/10.1016/0047-259X%2889%2990065-1">doi:10.1016/0047-259X(89)90065-1</a>.
</p>
<p>Smith, M. D. (1993) Expectations of ratios of quadratic forms in normal
variables: evaluating some top-order invariant polynomials.
<em>Australian Journal of Statistics</em>, <strong>35</strong>, 271&ndash;282.
<a href="https://doi.org/10.1111/j.1467-842X.1993.tb01335.x">doi:10.1111/j.1467-842X.1993.tb01335.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfmrm">qfmrm</a></code> for multiple ratio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some symmetric matrices and parameters
nv &lt;- 4
A &lt;- diag(nv:1)
B &lt;- diag(sqrt(1:nv))
mu &lt;- nv:1 / nv
Sigma &lt;- matrix(0.5, nv, nv)
diag(Sigma) &lt;- 1

## Expectation of (x^T A x)^2 / (x^T x)^2 where x ~ N(0, I)
## An exact expression is available
(res1 &lt;- qfrm(A, p = 2))

# The above internally calls the following:
qfrm_ApIq_int(A, p = 2) ## The same

# Similar result with different expression
# This is a suboptimal option and throws a warning
qfrm_ApIq_npi(A, p = 2)

## Expectation of (x^T A x)^1/2 / (x^T x)^1/2 where x ~ N(0, I)
## Note how quickly the series converges in this case
(res2 &lt;- qfrm(A, p = 1/2))
plot(res2)

# The above calls:
qfrm_ApIq_npi(A, p = 0.5)

# This is not allowed (throws an error):
try(qfrm_ApIq_int(A, p = 0.5))

## (x^T A x)^2 / (x^T B x)^3 where x ~ N(0, I)
(res3 &lt;- qfrm(A, B, 2, 3))
plot(res3)

## (x^T A x)^2 / (x^T B x)^2 where x ~ N(mu, I)
## Note the two-sided error bound
(res4 &lt;- qfrm(A, B, 2, 2, mu = mu))
plot(res4)

## (x^T A x)^2 / (x^T B x)^2 where x ~ N(mu, Sigma)
(res5 &lt;- qfrm(A, B, p = 2, q = 2, mu = mu, Sigma = Sigma))
plot(res5)

# Sigma is not allowed in the "internal" functions:
try(qfrm_ApBq_int(A, B, p = 2, q = 2, Sigma = Sigma))

# In res5 above, the error bound didn't converge
# Use larger m to evaluate higher-order terms
plot(print(qfrm(A, B, p = 2, q = 2, mu = mu, Sigma = Sigma, m = 300)))

</code></pre>

<hr>
<h2 id='range_qfr'>Get range of ratio of quadratic forms</h2><span id='topic+range_qfr'></span><span id='topic+gen_eig'></span>

<h3>Description</h3>

<p><code>range_qfr()</code>: internal function to obtain the possible range of
a ratio of quadratic forms,
<code class="reqn">\frac{ \mathbf{x^{\mathit{T}} A x} }{ \mathbf{x^{\mathit{T}} B x} }
</code>.
</p>
<p><code>gen_eig()</code> is an internal function to obtain generalized eigenvalues,
i.e., roots of
<code class="reqn">\det{\mathbf{A} - \lambda \mathbf{B}} = 0</code>,
which are the eigenvalues of <code class="reqn">\mathbf{B}^{-1} \mathbf{A}</code> if
<code class="reqn">\mathbf{B}</code> is nonsingular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_qfr(
  A,
  B,
  eigB = eigen(B, symmetric = TRUE),
  tol = .Machine$double.eps * 100,
  t = 0.001
)

gen_eig(
  A,
  B,
  eigB = eigen(B, symmetric = TRUE),
  Ad = with(eigB, crossprod(crossprod(A, vectors), vectors)),
  tol = .Machine$double.eps * 100,
  t = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_qfr_+3A_a">A</code>, <code id="range_qfr_+3A_b">B</code></td>
<td>
<p>Symmetric matrices.  No check is done.</p>
</td></tr>
<tr><td><code id="range_qfr_+3A_eigb">eigB</code></td>
<td>
<p>Result of <code>eigen(B)</code> can be passed when already computed</p>
</td></tr>
<tr><td><code id="range_qfr_+3A_tol">tol</code></td>
<td>
<p>Tolerance to determine numerical zero</p>
</td></tr>
<tr><td><code id="range_qfr_+3A_t">t</code></td>
<td>
<p>Tolerance used to determine whether estimates are numerically stable;
<code class="reqn">t</code> in Jennings et al. (1978).</p>
</td></tr>
<tr><td><code id="range_qfr_+3A_ad">Ad</code></td>
<td>
<p><code>A</code> rotated with eigenvectors of <code>B</code> can be passed
when already computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gen_eig()</code> solves the generalized eigenvalue problem with
Jennings et al.'s (1978) algorithm.  The sign of infinite eigenvalue
(when present) cannot be determined from this algorithm, so is deduced
as follows: (1) <code class="reqn">\mathbf{A}</code> and <code class="reqn">\mathbf{B}</code> are rotated by
the eigenvectors of <code class="reqn">\mathbf{B}</code>; (2) the submatrix of rotated
<code class="reqn">\mathbf{A}</code> corresponding to the null space of <code class="reqn">\mathbf{B}</code>
is examined; (3) if this is nonnegative (nonpositive) definite, the result
must have positive (negative, resp.) infinity; if this is indefinite,
the result must have both positive and negative infinities;
if this is (numerically) zero, the result must have <code>NaN</code>.  The last
case is expeted to happen very rarely, as in this case Jennings algorithm
would fail.  This is where the null space of <code class="reqn">\mathbf{B}</code> is
a subspace of that of <code class="reqn">\mathbf{A}</code>, so that the range of ratio of
quadratic forms can be well-behaved.  <code>range_qfr()</code> tries to detect
this case and handle the range accordingly, but if that is infeasible
it returns <code>c(-Inf, Inf)</code>.
</p>


<h3>References</h3>

<p>Jennings, A., Halliday, J. and Cole, M. J. (1978) Solution of linear
generalized eigenvalue problems containing singular matrices.
<em>Journal of the Institute of Mathematics and Its Applications</em>, <strong>22</strong>,
401&ndash;410.
<a href="https://doi.org/10.1093/imamat/22.4.401">doi:10.1093/imamat/22.4.401</a>.
</p>

<hr>
<h2 id='rqfr'>Monte Carlo sampling of ratio/product of quadratic forms</h2><span id='topic+rqfr'></span><span id='topic+rqfmr'></span><span id='topic+rqfp'></span>

<h3>Description</h3>

<p><code>rqfr()</code>, <code>rqfmr()</code>, and <code>rqfp()</code> calculate a random sample of
a simple ratio, multiple ratio (of special form), and product, respectively,
of quadratic forms in normal variables of specified mean and covariance
(standard multivariate normal by default).  These functions are primarily for
empirical verification of the analytic results provided in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqfr(nit = 1000L, A, B, p = 1, q = p, mu, Sigma, use_cpp = TRUE)

rqfmr(nit = 1000L, A, B, D, p = 1, q = p/2, r = q, mu, Sigma, use_cpp = TRUE)

rqfp(nit = 1000L, A, B, D, p = 1, q = 1, r = 1, mu, Sigma, use_cpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rqfr_+3A_nit">nit</code></td>
<td>
<p>Number of iteration or sample size.  Should be an integer-alike of
length 1.</p>
</td></tr>
<tr><td><code id="rqfr_+3A_a">A</code>, <code id="rqfr_+3A_b">B</code>, <code id="rqfr_+3A_d">D</code></td>
<td>
<p>Argument matrices (see &ldquo;Details&rdquo;).  Assumed to be square matrices of
the same order.  When missing, set to the identity matrix.  At least
one of these must be specified.</p>
</td></tr>
<tr><td><code id="rqfr_+3A_p">p</code>, <code id="rqfr_+3A_q">q</code>, <code id="rqfr_+3A_r">r</code></td>
<td>
<p>Exponents for A, B, D, respectively (see &ldquo;Details&rdquo;).  Assumed to be
numeric of length 1 each.  See &ldquo;Details&rdquo; for default values.</p>
</td></tr>
<tr><td><code id="rqfr_+3A_mu">mu</code></td>
<td>
<p>Mean vector <code class="reqn">\bm{\mu}</code> for <code class="reqn">\mathbf{x}</code>.  Default
zero vector.</p>
</td></tr>
<tr><td><code id="rqfr_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix <code class="reqn">\mathbf{\Sigma}</code> for
<code class="reqn">\mathbf{x}</code>.  Default identity matrix.  <code>mu</code> and
<code>Sigma</code> are assumed to be of the same order as the argument matrices.</p>
</td></tr>
<tr><td><code id="rqfr_+3A_use_cpp">use_cpp</code></td>
<td>
<p>Logical to specify whether an C++ version is called or
not.  <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions generate a random sample of
<code class="reqn"> \frac{(\mathbf{x^\mathit{T} A x})^p}{(\mathbf{x^\mathit{T} B x})^q}
     </code>
(<code>rqfr()</code>),
<code class="reqn"> \frac{(\mathbf{x^\mathit{T} A x})^p}
           {(\mathbf{x^\mathit{T} B x})^q (\mathbf{x^\mathit{T} Dx})^r}
     </code>
(<code>rqfmr()</code>), and
<code class="reqn"> (\mathbf{x^\mathit{T} A x})^p (\mathbf{x^\mathit{T} B x})^q
      (\mathbf{x^\mathit{T} D x})^r </code>
(<code>rqfp()</code>), where
<code class="reqn">\mathbf{x} \sim N_n(\bm{\mu}, \mathbf{\Sigma})
     </code>.  (Internally, <code>rqfr()</code> and <code>rqfmr()</code>
just call <code>rqfp()</code> with negative exponents.)
</p>
<p>When only one of <code>p</code> and <code>q</code> is provided in <code>rqfr()</code>,
the other (missing) one is set to the same value.
</p>
<p>In <code>rqfmr()</code>, <code>q</code> and <code>r</code> are set to <code>p/2</code>
when both missing, and set to the same value when only one is missing.  When
<code>p</code> is missing, this is set to be <code>q + r</code>.  If unsure,
specify all these explicitly.
</p>
<p>In <code>rqfp()</code>, <code>p</code>, <code>q</code> and <code>r</code> are <code>1</code> by default,
provided that the corresponding argument matrices are given.  If both
an argument matrix and its exponent (e.g., <code>D</code> and <code>r</code>)
are missing, the exponent is set to <code>0</code> so that the factor be unity.
</p>


<h3>Value</h3>

<p>Numeric vector of length <code>nit</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qfrm">qfrm</a></code> and <code><a href="#topic+qfpm">qfpm</a></code> for analytic moments
</p>
<p><code><a href="#topic+dqfr">dqfr</a></code> for analytic distribution-related functions for
simple ratios
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 4
A &lt;- diag(1:p)
B &lt;- diag(p:1)
D &lt;- diag(sqrt(1:p))

## By default B = I, p = q = 1;
## i.e., (x^T A x) / (x^T x), x ~ N(0, I)
rqfr(5, A)

## (x^T A x) / ((x^T B x)(x^T D x))^(1/2), x ~ N(0, I)
rqfmr(5, A, B, D, 1, 1/2, 1/2)

## (x^T A x), x ~ N(0, I)
rqfp(5, A)

## (x^T A x) (x^T B x), x ~ N(0, I)
rqfp(5, A, B)

## (x^T A x) (x^T B x) (x^T D x), x ~ N(0, I)
rqfp(5, A, B, D)

## Example with non-standard normal
mu &lt;- 1:p / p
Sigma &lt;- matrix(0.5, p, p)
diag(Sigma) &lt;- 1
rqfr(5, A, mu = 1:p / p, Sigma = Sigma)

## Compare Monte Carlo sample and analytic expression
set.seed(3)
mcres &lt;- rqfr(1000, A, p = 2)
mean(mcres)
(anres &lt;- qfrm(A, p = 2))
stats::t.test(mcres, mu = anres$statistic)

</code></pre>

<hr>
<h2 id='S_fromUL'>Make covariance matrix from eigenstructure</h2><span id='topic+S_fromUL'></span>

<h3>Description</h3>

<p>This is an internal utility function to make covariance matrix from
eigenvectors and eigenvalues.  Symmetry is assumed for the original matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S_fromUL(evec, evalues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_fromUL_+3A_evec">evec</code></td>
<td>
<p>Matrix whose columns are eigenvectors</p>
</td></tr>
<tr><td><code id="S_fromUL_+3A_evalues">evalues</code></td>
<td>
<p>Vector of eigenvalues</p>
</td></tr>
</table>

<hr>
<h2 id='sum_counterdiag'>Summing up counter-diagonal elements</h2><span id='topic+sum_counterdiag'></span><span id='topic+sum_counterdiag3D'></span>

<h3>Description</h3>

<p><code>sum_counterdiag()</code> sums up counter-diagonal elements of
a square matrix from the upper-left; i.e.,
<code>c(X[1, 1], X[1, 2] + X[2, 1], X[1, 3] + X[2, 2] + X[3, 1], ...)</code>
(or a sequence of <code class="reqn">\sum_{i=1}^k x_{i, k - i + 1}</code> for
<code class="reqn">k = 1, 2, ...</code>).  <code>sum_counterdiag3D()</code> does a comparable in
a 3D cubic array.  No check is done on the structure of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_counterdiag(X)

sum_counterdiag3D(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_counterdiag_+3A_x">X</code></td>
<td>
<p>Square matrix or cubic array</p>
</td></tr>
</table>

<hr>
<h2 id='tr'>Matrix trace function</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>This is an internal function.  No check is done on the structure of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_x">X</code></td>
<td>
<p>Square matrix whose trace is to be calculated</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
