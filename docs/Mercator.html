<!DOCTYPE html><html><head><title>Help for package Mercator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Mercator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binaryDistance'>
<p>Binary Distance Definitions Across Methods</p></a></li>
<li><a href='#BinaryMatrix-class'><p>Class <code>"BinaryMatrix"</code></p></a></li>
<li><a href='#downsample'>
<p>Downsampling a Distance Visualization to Facilitate iGraph</p></a></li>
<li><a href='#Mercator-class'>
<p>The <code>Mercator</code> Distance Visualization Object</p></a></li>
<li><a href='#mercator-data'><p>CML Cytogenetic Data</p></a></li>
<li><a href='#removeDuplicates'>
<p>Remove Duplicate Features or Samples from a Binary Matrix Object</p></a></li>
<li><a href='#setClusters'>
<p>Changing Cluster and Color Assignments in Mercator</p></a></li>
<li><a href='#threshLGF'>
<p>Threshing and Reaping the <code>BinaryMatrix</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering and Visualizing Distance Matrices</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes, Caitlin E. Coombes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines the classes used to explore, cluster and
  visualize distance matrices, especially those arising from binary
  data. See Abrams and colleagues, 2021, &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtab037">doi:10.1093/bioinformatics/btab037</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), Thresher (&ge; 1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, graphics, grDevices, KernSmooth,
cluster, Rtsne, ClassDiscovery, Polychrome, dendextend, igraph,
flexmix, umap, kohonen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>biocViews:</td>
<td>Clustering</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-30 15:29:16 UTC; KRC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-30 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binaryDistance'>
Binary Distance Definitions Across Methods
</h2><span id='topic+binaryDistance'></span><span id='topic+jaccardSimilarity'></span><span id='topic+jaccardDistance'></span><span id='topic+sokalMichenerSimilarity'></span><span id='topic+sokalMichenerDistance'></span><span id='topic+hammingDistance'></span><span id='topic+russellRaoSimilarity'></span><span id='topic+russelRaoDistance'></span><span id='topic+pearsonSimilarity'></span><span id='topic+pearsonDistance'></span><span id='topic+goodmanKruskalSimilarity'></span><span id='topic+goodmanKruskalDistance'></span>

<h3>Description</h3>

<p>The <code>binaryDistance</code> function defines various similarity or distance
measures between binary vectors, which represent the first step in the 
algorithm underlying the <code>Mercator</code> visualizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryDistance(X, metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binaryDistance_+3A_x">X</code></td>
<td>
<p>An object of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="binaryDistance_+3A_metric">metric</code></td>
<td>
<p>An object of class <code>character</code> limited to the names of 
10 selected distance metrics: <code>jaccard</code>, <code>sokalMichener</code>, <code>hamming</code>,
<code>russellRao</code>, <code>pearson</code>, <code>goodmanKruskal</code>, <code>manhattan</code>,
<code>canberra</code>, <code>binary</code>, or <code>euclid</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similarity or difference between binary vectors can be calculated using a
variety of distance measures. In the main reference (below), Choi and colleagues
reviewed 76 different measures of similarity of distance between binary vectors.
They also produced a hierarchical clustering of these measures, based on the 
correlation between their distance values on multiple simulated data sets. For
metrics that are highly similar, we chose a single representative.
</p>
<p>Cluster 1, represented by the <code>jaccard</code> distance, contains Dice &amp; Sorenson, Ochiai, 
Kulcyznski, Bray &amp; Curtis, Baroni-Urbani &amp; Buser, and Jaccard.
</p>
<p>Cluster 2, represented by the <code>sokalMichener</code> distance, contains Sokal &amp; Sneath, 
Gilbert &amp; Wells, Gower &amp; Legendre, Pearson &amp; Heron, Hamming, and Sokal &amp; Michener. 
Also within this cluster are 4 distances represented independently within this function: 
<code>hamming</code>, <code>manhattan</code>, <code>canberra</code>, and <code>euclidean</code> distances
</p>
<p>Cluster 3, represented by the <code>russellRao</code> distance, contains Driver &amp; Kroeber,
Forbes, Fossum, and Russell &amp; Rao.
</p>
<p>The remaining metrics are more isolated, without strong clustering. We considered a few 
examples, including the Pearson distance (<code>pearson</code>) and the Goodman &amp; Kruskal distance 
(<code>goodmanKruskal</code>). The <code>binary</code> distance is also included.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="stats.html#topic+dist">dist</a></code> corresponding to the distance
<code>metric</code> provided.
</p>


<h3>Note</h3>

<p>Although the distance metrics provided in the <code>binaryDistance</code> function
are explicitly offered for use on matrices of binary vectors, some metrics may 
return useful distances when applied to non-binary matrices.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Caitlin E. Coombes</p>


<h3>References</h3>

<p>Choi SS, Cha SH, Tappert CC, A Survey of Binary Similarity and Distance Measures. 
Systemics, Cybernetics, and Informatics. 2010; 8(1):43-48.
</p>


<h3>See Also</h3>

<p>This set includes all of the  metrics from the <code><a href="stats.html#topic+dist">dist</a></code> function. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.matrix &lt;- matrix(rbinom(50*100, 1, 0.15), ncol=50)
my.dist &lt;- binaryDistance(my.matrix, "jaccard")
</code></pre>

<hr>
<h2 id='BinaryMatrix-class'>Class <code>"BinaryMatrix"</code></h2><span id='topic+BinaryMatrix'></span><span id='topic+BinaryMatrix-class'></span><span id='topic++5B+2CBinaryMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic+t+2CBinaryMatrix-method'></span><span id='topic+dim+2CBinaryMatrix-method'></span><span id='topic+hist+2CBinaryMatrix-method'></span><span id='topic+show+2CBinaryMatrix-method'></span><span id='topic+print+2CBinaryMatrix-method'></span><span id='topic+summary+2CBinaryMatrix-method'></span><span id='topic+validBinaryMatrix'></span>

<h3>Description</h3>

<p>The <code>BinaryMatrix</code> object class underlies the <code>threshLGF</code> and <code>Mercator</code> 
methods and visualizations of the <code>Mercator</code> package. The <code>BinaryMatrix</code> function
returns a new object of <code>BinaryMatrix</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryMatrix(binmat, columnInfo, rowInfo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinaryMatrix-class_+3A_binmat">binmat</code></td>
<td>
<p>A binary <code>matrix</code> of class <code>numeric</code> or <code>integer</code>
with values 0 and 1.</p>
</td></tr>
<tr><td><code id="BinaryMatrix-class_+3A_columninfo">columnInfo</code></td>
<td>
<p>A <code>data.frame</code> of at least one column containing column
names. If no <code>colnames</code> are specified, the column names associated with
the <code>data</code> matrix will be used.</p>
</td></tr>
<tr><td><code id="BinaryMatrix-class_+3A_rowinfo">rowInfo</code></td>
<td>
<p>A <code>dataframe</code> of at least one column containing row
names. If no <code>rownames</code> are specified, the row names associated with
the <code>data</code> matrix will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>BinaryMatrix</code> function returns a new object of <code>binaryMatrix</code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects should be defined using the <code>BinaryMatrix</code> constructor. In
the simplest case, you simply pass in the binary data matrix that you
want to visualize, and the <code>BinaryMatrix</code> is constructed using the matrix's
existing column and row names.
</p>


<h3>Slots</h3>


<dl>
<dt><code>binmat</code>:</dt><dd><p>Object of class <code>matrix</code>; the binary data 
used for visualization.</p>
</dd>
<dt><code>columnInfo</code>:</dt><dd><p>Object of class <code>data.frame</code>; names and
definitions of columns.</p>
</dd>
<dt><code>rowInfo</code>:</dt><dd><p>Object of class <code>data.frame</code>; names and
definitions of rows.</p>
</dd>
<dt><code>info</code>:</dt><dd><p>Object of class <code>list</code>; identifies <code>$notUsed</code>
and <code>$redundant</code> features.</p>
</dd>
<dt><code>history</code>:</dt><dd><p>Object of class <code>"character"</code>; returns a 
history of manipulations by <code>Mercator</code> functions to the <code>BinaryMatrix</code> 
object, including &quot;Newly created,&quot; &quot;Subsetted,&quot; &quot;Transposed,&quot; &quot;Duplicate 
features removed,&quot; and &quot;Threshed.&quot;</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>[]</code>:</dt><dd><p>Subsetting by <code>[]</code> returns a subsetted binary matrix, 
including subsetted row and column names. Calling <code>@history</code> will 
return the history &quot;Subsetted.&quot;</p>
</dd>
<dt><code><a href="base.html#topic+dim">dim</a></code>:</dt><dd><p>returns the dimensions of the <code>@binmat</code> component 
of the <code>binaryMatrix</code> object.</p>
</dd>
<dt><code><a href="base.html#topic+print">print</a></code>:</dt><dd><p>Shows the first ten rows and columns
of the <code>@binmat</code> component.</p>
</dd>
<dt><code><a href="methods.html#topic+show">show</a></code>:</dt><dd><p>Shows the first ten rows and columns
of the <code>@binmat</code> component.</p>
</dd>
<dt><code><a href="base.html#topic+summary">summary</a></code>:</dt><dd><p>For a given <code>BinaryMatrix</code>, returns object class,
dimensions of the <code>@binmat</code> component, and <code>@history</code>.</p>
</dd>
<dt><code><a href="base.html#topic+t">t</a></code>:</dt><dd><p>Transposes the <code>@binmat</code> and its associated <code>rowInfo</code>
and <code>columnInfo</code>. Calling <code>@history</code> will return the history 
&quot;Subsetted.&quot;</p>
</dd>
</dl>



<h3>Note</h3>

<p>Attempting to construct or manipulate a <code>BinaryMatrix</code> containing NAs, missing values, 
or columns containing exclusively 0 values may introduce error.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Caitlin E. Coombes</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+removeDuplicateFeatures">removeDuplicateFeatures</a></code> function can be used to remove
duplicate columns from the binaryMatrix class before threshing or visualization. 
The <code><a href="#topic+threshLGF">threshLGF</a></code> can be used to identify and remove uninformative features
before visualization or further analysis.</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.matrix &lt;- matrix(rbinom(50*100, 1, 0.15), ncol=50)
my.rows &lt;- as.data.frame(paste("R", 1:100, sep=""))
my.cols &lt;- as.data.frame(paste("C", 1:50, sep=""))
my.binmat &lt;- BinaryMatrix(my.matrix, my.cols, my.rows)
summary(my.binmat)
my.binmat &lt;- my.binmat[1:50, 1:30]
my.binmat &lt;- t(my.binmat)
dim(my.binmat)
my.binmat@history
my.binmat
</code></pre>

<hr>
<h2 id='downsample'>
Downsampling a Distance Visualization to Facilitate iGraph
</h2><span id='topic+downsample'></span>

<h3>Description</h3>

<p>The <code>downsample</code> function implements a structured reduction 
of data points with a parent <code>Mercator</code> distance visualization to 
improve visualization and computational time, especially for the 
implementation of the iGraph visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample(target, distanceMat, cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_+3A_target">target</code></td>
<td>
<p>An <code>integer</code> number of points to which the user wishes to 
reduce the parent <code>Mercator</code> object.
</p>
</td></tr>
<tr><td><code id="downsample_+3A_distancemat">distanceMat</code></td>
<td>
<p>An object of class <code>matrix</code> containing the 
distance matrix component of the parent <code>Mercator</code> object.
</p>
</td></tr>
<tr><td><code id="downsample_+3A_cutoff">cutoff</code></td>
<td>
<p>An inclusion cutoff for selected points based on the 
local density within the parent data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mercator can be used to visualize complex networks using 
iGraph. To improve clarity of the visualization and computational 
time, we implement the <code>downsample</code> function to reduce the 
number of data points to be linked and visualized. The conceptual 
grounding for <code>downsample</code> draws on Peng Qiu's implementation of the
SPADE clustering algorithm for mass cytometry data. The
<code>downsample</code> function 
under-samples the densest regions of the data space to make it more 
likely that rarer clusters will still be adequately sampled.
</p>


<h3>Value</h3>

<p><code>downsample</code> returns an object of class <code>Mercator</code> containing 
a structured subset of items from the parent <code>Mercator</code> object.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Caitlin E. Coombes</p>


<h3>References</h3>

<p>Qiu, P., et. al. (2011). Extracting a cellular hierarchy from high-dimensional cytometry data with SPADE. Nature biotechnology, 29(10), 886.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Form a BinaryMatrix
data("iris")
my.data &lt;- as.matrix(iris[,c(1:4)])
my.rows &lt;- as.data.frame(c(1:length(my.data[,1])))
my.binmat &lt;- BinaryMatrix(my.data, , my.rows)
my.binmat &lt;- t(my.binmat)
summary(my.binmat)

# Form and plot Mercator object
# Set K to the known number of species in the dataset
my.vis &lt;- Mercator(my.binmat, "euclid", "tsne", K=3)
summary(my.vis)
plot(my.vis, view = "tsne", main="t-SNE plot of all data points")

#Downsample the Mercator object
M &lt;- as.matrix(my.vis@distance)
set.seed(21340)
DS &lt;- downsample(50, M, 0.1)
red.vis &lt;- my.vis[DS]

#Visualize the down sampled t-SNE plot
plot(red.vis, view = "tsne", main="Down sampled t-SNE Plot")
</code></pre>

<hr>
<h2 id='Mercator-class'>
The <code>Mercator</code> Distance Visualization Object
</h2><span id='topic+Mercator-class'></span><span id='topic+Mercator'></span><span id='topic++5B+2CMercator+2CANY+2CANY+2CANY-method'></span><span id='topic+dim+2CMercator-method'></span><span id='topic+hist+2CMercator-method'></span><span id='topic+summary+2CMercator-method'></span><span id='topic+barplot+2CMercator-method'></span><span id='topic+plot+2CMercator+2Cmissing-method'></span><span id='topic+scatter+2CMercator-method'></span><span id='topic+addVisualization'></span><span id='topic+getClusters'></span>

<h3>Description</h3>

<p>The <code>Mercator</code> object represents a distance matrix together with
clustering assignments and a set of visualizations. It implements four
visualizations for clusters of large-scale, multi-dimensional data:
hierarchical clustering, multi-dimensional scaling, t-Stochastic
Neighbor Embedding (t-SNE), and iGraph. The default
<code>Mercator</code> constructor applies one of ten metrics of
<code><a href="#topic+binaryDistance">binaryDistance</a></code> to an object of the
<code><a href="#topic+BinaryMatrix">BinaryMatrix</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mercator(X, metric, method, K, ...)
addVisualization(DV, method, ...)
getClusters(DV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mercator-class_+3A_x">X</code></td>
<td>
<p>Either a <code><a href="#topic+BinaryMatrix">BinaryMatrix</a></code> or a <code><a href="stats.html#topic+dist">dist</a></code> object.</p>
</td></tr>
<tr><td><code id="Mercator-class_+3A_metric">metric</code></td>
<td>
<p>A <code><a href="#topic+binaryDistance">binaryDistance</a></code> currently limited to the
names of 10 selected distance metrics: <code>jaccard</code>,
<code>sokalMichener</code>, <code>hamming</code>,
<code>russellRao</code>, <code>pearson</code>, <code>goodmanKruskal</code>,
<code>manhattan</code>,
<code>canberra</code>, <code>binary</code>, or <code>euclid</code>.</p>
</td></tr>
<tr><td><code id="Mercator-class_+3A_method">method</code></td>
<td>
<p>A visualization method, currently limited to
<code>hclust</code>, <code>mds</code>, <code>tsne</code>, <code>graph</code>,
<code>umap</code>, and <code>som</code>.</p>
</td></tr>
<tr><td><code id="Mercator-class_+3A_k">K</code></td>
<td>
<p>An <code>integer</code> specifying the number of desired clusters.</p>
</td></tr>
<tr><td><code id="Mercator-class_+3A_dv">DV</code></td>
<td>
<p>A distance visualization produced as the output of the 
<code>Mercator</code> function.</p>
</td></tr>
<tr><td><code id="Mercator-class_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the functions that
implement different methods for <code>addVisualization</code> (possibly
passed here through the <code>Mercator</code> function). These include
</p>

<dl>
<dt><code>any</code></dt><dd><p>Any arguments to the <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> function for an
<code>mds</code> visualization. Most commonly, this is likely to
include <code>k</code>, the number of dimensions to compute.</p>
</dd>
<dt><code>any</code></dt><dd><p>Any arguments to the <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code> function for a
<code>tsne</code> visualization. Common examples include <code>dims</code>
and <code>perplexity</code>.</p>
</dd>
<dt><code>any</code></dt><dd><p>Any arguments to the <code><a href="kohonen.html#topic+som">som</a></code> function
to construct or view a self-organizing map. Most commonly, this is likely to
include <code>somgrid</code>, to specify the size and layout of the
grid, or <code>type</code> to specify which data to show in the plot.</p>
</dd>
<dt><code>Q</code></dt><dd><p>A quantile cutoff for the creation of the IGraph visualization.
By default, the value is set at the 10th percentile.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Mercator</code> function constructs and returns a distance
visualization object of the
<code>Mercator</code> class, including a distance matrix calculated on a 
given metric and given visualizations. It is also possible (though not
advisable) to construct a <code>Mercator</code> object directly using the
<code>new</code> function. Default clustering in <code>Mercator</code> is now
performed on the distance matrix using hierarchical clustering
(hclust) with the <code>wardD2</code> linkage method.
</p>
<p>The <code>addVisualizations</code> function can be used to add additional 
visualizations to an existing <code>Mercator</code> object.
</p>
<p>The <code>getClusters</code> function returns a vector of cluster assignments.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metric</code>:</dt><dd><p>Object of class <code>"character"</code>; the name 
of the <code><a href="#topic+binaryDistance">binaryDistance</a></code> applied to create this object. </p>
</dd>
<dt><code>distance</code>:</dt><dd><p>Object of class <code>"dist"</code>; the distance 
matrix used and represented by this object.</p>
</dd>
<dt><code>view</code>:</dt><dd><p>Object of class <code>"list"</code>; contains the
results of calculations to generate each visualize the object.</p>
</dd>
<dt><code>clusters</code>:</dt><dd><p>A numeric vector of cluster assignments.</p>
</dd>
<dt><code>symbols</code>:</dt><dd><p>A numeric vector of valid plotting
characters, as used by <code>par(pch)</code>.</p>
</dd>
<dt><code>palette</code>:</dt><dd><p>A character vector of color names.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot(x, view = NULL, ask = NULL, ...):</dt><dd>
<p>Produce a plot of one or more visualizations within a 
Mercator object. The default <code>view</code>, when omitted, is the
first one contained in the object. You can request multiple views
at once; if the current plot layout doesn't have enough space in
an interactive session, the <code>ask</code> parameters detemines whether
the system will ask you before advancing to the next plot. When
plotting a graph view, you can use an optional <code>layout</code>
parameter to select a specific layout by name.
</p>
</dd>
<dt>barplotheight, main = &rdquo;, sub = NULL, border = NA, space =
0, ...</dt><dd>
<p>Produce a (colored) barplot of the silhouette widths for elements
clustered in this class. Arguments are as described in te base
function <code><a href="graphics.html#topic+barplot">barplot</a></code>. 
</p>
</dd>
<dt>scatter(object, view = NULL, ask = NULL, colramp = NULL, ...):</dt><dd>
<p>Produce a smooth scatter plot of one or more visualizations within a 
Mercator object. The default <code>view</code>, when omitted, is the
first one contained in the object. You can request multiple views
at once; if the current plot layout doesn't have enough space in
an interactive session, the <code>ask</code> parameters detemines whether
the system will ask you before advancing to the next plot. When
plotting a graph view, you can use an optional <code>layout</code>
parameter to select a specific layout by name. Arguments are
otherwise the same as the <code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code> function,
execpt that the default color ramp is <code>topo.colors</code>.
</p>
</dd>
<dt>hist:</dt><dd><p><code>signature(object = "Mercator")</code></p>
</dd></dl>

<p>Produce a histogram of distances calculated in the dissimilarity 
matrix generated in the <code>Mercator</code> object.

</p>
<dl>
<dt>summary:</dt><dd><p><code>signature(object = "Mercator")</code></p>
</dd></dl>

<p>Returns the chosen distance metric, dimensions of the distance 
matrix, and available, calculated visualizations in this object.

</p>
<dl>
<dt>dim:</dt><dd><p><code>signature(object = "Mercator")</code></p>
</dd></dl>

<p>Returns the dimensions of the distance matrix of this object.

</p>
<dl>
<dt>[:</dt><dd><p><code>signature(object = "Mercator")</code></p>
</dd></dl>

<p>Subsets the distance matrix of this object.


</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Caitlin E. Coombes</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+silhouette">silhouette</a></code>, <code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code>,
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, <code><a href="kohonen.html#topic+som">som</a></code>,
<code><a href="umap.html#topic+umap">umap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Form a BinaryMatrix
data("iris")
my.data &lt;- as.matrix(iris[,c(1:4)])
my.rows &lt;- as.data.frame(c(1:length(my.data[,1])))
my.binmat &lt;- BinaryMatrix(my.data, , my.rows)
my.binmat &lt;- t(my.binmat)
summary(my.binmat)

# Form a Mercator object
# Set K to the known number of species in the dataset
my.vis &lt;- Mercator(my.binmat, "euclid", "hclust", K=3) 
summary(my.vis)
hist(my.vis)
barplot(my.vis)
my.vis &lt;- addVisualization(my.vis, "mds")
plot(my.vis, view = "hclust")
plot(my.vis, view = "mds")

scatter(my.vis, view ="mds")

# change the color palette
slot(my.vis, "palette") &lt;- c("purple", "red", "orange", "green")
scatter(my.vis, view ="mds")

# Recover cluster identities
# What species comprise cluster 1?
my.clust &lt;- getClusters(my.vis)
my.species &lt;- iris$Species[my.clust == 1]
my.species
</code></pre>

<hr>
<h2 id='mercator-data'>CML Cytogenetic Data</h2><span id='topic+mercator-data'></span><span id='topic+CML500'></span><span id='topic+CML1000'></span><span id='topic+lgfFeatures'></span><span id='topic+fakedata'></span><span id='topic+fakeclin'></span>

<h3>Description</h3>

<p>These data sets contain binary versions of subsets of cytogenetic
karyotype data from patients with chronic myelogenous leukemia (CML). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lgfFeatures")
data("CML500")
data("CML1000")
data("fakedata") # includes "fakeclin"
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>lgfFeatures</code></dt><dd><p>A data matrix with 2748 rows and 6 columns
listing the cytogentic bands produced as output of the CytoGPS
algorithm that converts text-based karyotypes into a binary
Loss-Gain-Fusion (LGF) model. The columns include the <code>Label</code>
(the Type and Band, joined by an underscore),
<code>Type</code> (Loss, Gain, or Fusion), <code>Band</code> (standard name of
the cytogenetic band), <code>Chr</code> (chromosome), <code>Arm</code> (the
chromsome arm, of the form #p or #q), and <code>Index</code> (an integer
that can be used for sorting or indexing).
</p>
</dd>
<dt><code>CML500</code></dt><dd><p>A <code><a href="#topic+BinaryMatrix">BinaryMatrix</a></code> object with 770
rows (subset of LGF features) and 511 columns (patients). The
patients were selected using the <code><a href="#topic+downsample">downsample</a></code> function
from the full set of more than 3000 CML karyotypes. The rows were
selected by removing redundant and non-informative features when
considering the full data set.</p>
</dd>
<dt><code>CML1000</code></dt><dd><p>A <code><a href="#topic+BinaryMatrix">BinaryMatrix</a></code> object with 770
rows (subset of LGF features) and 1057 columns (patients). The
patients were selected using the <code><a href="#topic+downsample">downsample</a></code> function
from the full set of more than 3000 CML karyotypes. The rows were
selected by removing redundant and non-informative features when
considering the full data set.</p>
</dd>
<dt><code>fakedata</code></dt><dd><p>A matrix with 776 rows (&quot;features&quot;) and 300
columns (&quot;samples&quot;) containng synthetic continuos data.</p>
</dd>
<dt><code>fakeclin</code></dt><dd><p>A data frame with 300 rows (&quot;samples&quot;) and  4
columns of synthetic clincal data related to the <code>fakedata</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Caitlin E. Coombes
</p>


<h3>Source</h3>

<p>The cytogenetic data were obtained from the public Mitelman Database
of Chromosomal Aberrations and Gene Fusions in Cancer on 4 April
2019. The database is currently located at
https://cgap.nci.nih.gov/Chromosomes/Mitelman as part of hte
Cancer Genome Anatomy Project (CGAP). The CGAP web site is expected to
close on 1 October 2019 at which point the Mitelman database will
move to an as-yet-undisclosed location. The data were then converted
from text-based karyotrypes into binary vectors using CytoGPS
<a href="http://cytogps.org/">http://cytogps.org/</a>.
</p>


<h3>References</h3>

<p>Abrams ZB, Zhang L, Abruzzo LV, Heerema NA, Li S, Dillon T, Rodriguez
R, Coombes KR, Payne PRO. CytoGPS: A Web-Enabled Karyotype Analysis
Tool for Cytogenetics. Bioinformatics. 2019 Jul 2. pii: btz520.  doi:
10.1093/bioinformatics/btz520. [Epub ahead of print]
</p>

<hr>
<h2 id='removeDuplicates'>
Remove Duplicate Features or Samples from a Binary Matrix Object
</h2><span id='topic+removeDuplicates'></span><span id='topic+removeDuplicateFeatures'></span>

<h3>Description</h3>

<p>The <code>removeDuplicates</code> function removes duplicate columns from 
a <code>binaryMatrix</code> object in the <code>Mercator</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeDuplicates(object)
removeDuplicateFeatures(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeDuplicates_+3A_object">object</code></td>
<td>
<p>An object of class <code>binaryMatrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some analyses, it may be desirable to remove duplicate features to collapse 
a group of identical, related events to a single feature, to prevent overweighting 
when clustering. Historically, this funciton was called
<code>removeDuplicateFeatures</code>. That name is still retained for
backwards compatibility, but it may be deprecated in future versions in
favor of <code>removeDuplicates</code>.
In the same way, for some clustering applications,
it may be usedful to remove duplicate samples, or those that have an
identical feature set. 
</p>
<p>Removal of duplicates is not required for performance of the 
<code>binaryMatrix</code> or <code>Mercator</code> objects and associated functions.
</p>
<p>The <code>history</code> slot of the <code>binaryMatrix</code> object documents the removal of 
duplicates.
</p>
<p>Future versions of this package may include functionality to store the identities 
of any duplicates that were removed.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>binaryMatrix</code> with duplicate columns removed.
</p>


<h3>Note</h3>

<p>Transposing the <code>binaryMatrix</code> can allow the <code>removeDuplicates</code> 
function to be applied to both features and observations, if desired.
</p>
<p>Features containing exclusively 0s or 1s may interfere with performance of 
<code>removeDuplicates</code>.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Caitlin E. Coombes</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.matrix &lt;- matrix(rbinom(50*100, 1, 0.15), ncol=50)
my.matrix &lt;- cbind(my.matrix, my.matrix[, 1:5]) # add duplicates
dimnames(my.matrix) &lt;- list(paste("R", 1:100, sep=''),
                            paste("C", 1:55, sep=''))
my.binmat &lt;- BinaryMatrix(my.matrix)
dim(my.binmat)
my.binmat &lt;- removeDuplicates(my.binmat)
dim(my.binmat)
</code></pre>

<hr>
<h2 id='setClusters'>
Changing Cluster and Color Assignments in Mercator
</h2><span id='topic+setClusters'></span><span id='topic+recolor'></span><span id='topic+remapColors'></span><span id='topic+recluster'></span>

<h3>Description</h3>

<p>Cluster assignments from unsupervised analyses typically assign
arbitrary integers to the classes. When comparing the results of
different algorithms or different distance metrics, it is helpful to
match the integers in order to use colors and symbols that are as
consistent as possible. These functions help achieve that goal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setClusters(DV, clusters)
recolor(DV, clusters)
remapColors(fix, vary)
recluster(DV, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setClusters_+3A_dv">DV</code></td>
<td>
<p>An object of the <code>Mercator</code> class.</p>
</td></tr>
<tr><td><code id="setClusters_+3A_clusters">clusters</code></td>
<td>
<p>An integer vector specifiny the cluster membership of
each element.</p>
</td></tr>
<tr><td><code id="setClusters_+3A_fix">fix</code></td>
<td>
<p>An object of the <code>Mercator</code> class, used as the source
of color and cluster assignments.</p>
</td></tr>
<tr><td><code id="setClusters_+3A_vary">vary</code></td>
<td>
<p>An object of the <code>Mercator</code> class, used as the target
of color and cluster assignments.</p>
</td></tr>
<tr><td><code id="setClusters_+3A_k">K</code></td>
<td>
<p>An integer, the number of clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the most general sense, clustering can be viewed as a function from
the space of &quot;objects&quot; of interest into a space of &quot;class labels&quot;.  In
less mathematical terms, this simply means that each object gets
assigned an (arbitrary) class label. This is all well-and-good until
you try to compare the results of running two different clustering
algorithms that use different labels (or even worse, use the same
labels &ndash; typically the integers <code class="reqn">1, 2, \dots, K</code> &ndash; with
different meanings).  When that happens, you need a way to decide
which labels from the different sets are closest to meaning the
&quot;same thing&quot;.
</p>
<p>The functions <code>setClusters</code> and <code>remapColors</code> solve this problem
in the context of <code>Mercator</code> objects. They accaomplish this task
using the greedy algorithm implemented and described in the
<code><a href="Thresher.html#topic+remap">remap</a></code> function in the <code><a href="Thresher.html#topic+Thresher">Thresher</a></code> package.
</p>


<h3>Value</h3>

<p>Both <code>setClusters</code> and <code>remapColors</code> return an object of class
<code>Mercator</code> in which only the cluster labels and associated color
and symbol representations (but not the distance metric used, the number
of clusters, the cluster assignments, nor the views) have been updated.
</p>
<p>The <code>recolor</code> function is currently an alias for
<code>setClusters</code>. However, using <code>recolor</code> is deprecated, and the
alias will likely be removed in the next version of the package.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

 <p><code><a href="Thresher.html#topic+remap">remap</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#Form a BinaryMatrix
data("iris")
my.data &lt;- t(as.matrix(iris[,c(1:4)]))
colnames(my.data) &lt;- 1:ncol(my.data)
my.binmat &lt;- BinaryMatrix(my.data)

# Form a Mercator object; Set K to the number of known species
my.vis &lt;- Mercator(my.binmat, "euclid", "tsne", K=3)
table(getClusters(my.vis), iris$Species)
summary(my.vis)

# Recolor the Mercator object with known species
DS &lt;- recolor(my.vis, as.numeric(iris$Species))
table(getClusters(DS), iris$Species)

# Use a different metric
my.vis2 &lt;- Mercator(my.binmat, "manhattan", "tsne", K=3)
table(getClusters(my.vis2), iris$Species)
table(Pearson = getClusters(my.vis2), Euclid = getClusters(my.vis))

# remap colors so the two methods match as well as possible
my.vis2 &lt;- remapColors(my.vis, my.vis2)
table(Pearson = getClusters(my.vis2), Euclid = getClusters(my.vis))

# recluster with K=4
my.vis3 &lt;- recluster(my.vis, K = 4)

# view the results
opar &lt;- par(mfrow=c(1,2))
plot(my.vis, view = "tsne", main="t-SNE plot, Euclid")
plot(my.vis2, view = "tsne",  main="t-SNE plot, Pearson")
par(opar)
</code></pre>

<hr>
<h2 id='threshLGF'>
Threshing and Reaping the <code>BinaryMatrix</code>
</h2><span id='topic+threshLGF'></span><span id='topic+ThreshedBinaryMatrix'></span><span id='topic+ThreshedBinaryMatrix-class'></span>

<h3>Description</h3>

<p>The <code>threshLGF</code> function produces an object of class 
<code>ThreshedBinaryMatrix</code> from threshing on an object of class 
<code><a href="#topic+BinaryMatrix">BinaryMatrix</a></code>. 
</p>
<p>The function <code><a href="#topic+threshLGF">threshLGF</a></code> and the <code><a href="#topic+ThreshedBinaryMatrix">ThreshedBinaryMatrix</a></code> 
object can be used to access the functionality of the <code><a href="Thresher.html#topic+Thresher">Thresher</a></code> 
R-package within Mercator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshLGF(object, cutoff = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshLGF_+3A_object">object</code></td>
<td>
<p>An object of class BinaryMatrix
</p>
</td></tr>
<tr><td><code id="threshLGF_+3A_cutoff">cutoff</code></td>
<td>
<p>The value of <code>delta</code> set to demarcate an 
uninformative feature. Features with a value greater than the 
cutoff will be kept.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="Thresher.html#topic+Thresher">Thresher</a></code> R-package provides a variety of functionalities
for data filtering and the identification of and reduction to &quot;informative&quot; features.
It performs clustering using a combination of outlier detection, principal
component analysis, and von Mises Fisher mixture models. By identifying 
significant features, Thresher performs feature reduction through the 
identification and removal of noninformative features and the nonbiased 
calculation of the number of groups (K) for down-stream use.
</p>


<h3>Value</h3>

<p><code>threshLGF</code> returns an object of class <code>ThreshedBinaryMatrix</code>.
The <code>ThreshedBinaryMatrix</code> object retains all the functionality, 
slots, and methods of the <code><a href="#topic+BinaryMatrix">BinaryMatrix</a></code> object class with added 
features. After threshing, the <code>ThreshedBinaryMatrix</code> records the 
<code>history</code>, &quot;Threshed.&quot;
</p>


<h3>Additional Slots</h3>


<dl>
<dt><code>thresher</code>:  </dt><dd><p>Returns the functions of the <code>Thresher</code> 
object class of the <code><a href="Thresher.html#topic+Thresher">Thresher</a></code> R-package.
</p>
</dd>
<dt><code>reaper</code>: </dt><dd><p>Returns the functions of the <code>Reaper</code> 
object class of the <code><a href="Thresher.html#topic+Thresher">Thresher</a></code> R-package.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code><a href="Thresher.html#topic+Thresher">Thresher</a></code> R-package applies the Auer-Gervini statistic 
for principal component analysis, outlier detection, and identification 
of uninformative features on a <code>matrix</code> of class <code>integer</code> or 
<code>numeric</code>.
</p>
<p>An initial <code>delta</code> of 0.3 is recommended.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;, Caitlin E. Coombes</p>


<h3>References</h3>

<p>Wang, M., Abrams, Z. B., Kornblau, S. M., &amp; Coombes, K. R. (2018). Thresher: 
determining the number of clusters while removing outliers. BMC bioinformatics, 
19(1), 9.
</p>


<h3>See Also</h3>

<p>The <code>threshLGF</code> function creates a new object of class 
<code>ThreshedBinaryMatrix</code> from an object of class <code>BinaryMatrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a BinaryMatrix
set.seed(52134)
my.matrix &lt;- matrix(rbinom(50*100, 1, 0.15), ncol=50)
my.rows &lt;- as.data.frame(paste("R", 1:100, sep=""))
my.cols &lt;- as.data.frame(paste("C", 1:50, sep=""))
my.binmat &lt;- BinaryMatrix(my.matrix, my.cols, my.rows)
summary(my.binmat)

#Identify delta cutoff and thresh
my.binmat &lt;- threshLGF(my.binmat)
Delta &lt;- my.binmat@thresher@delta
sort(Delta)
hist(Delta, breaks=15, main="", xlab="Weight")
abline(v=0.3, col='red')
my.binmat &lt;- threshLGF(my.binmat, cutoff = 0.3)
summary(my.binmat)

#Principal Component Analysis
my.binmat@reaper@pcdim
my.binmat@reaper@nGroups
plot(my.binmat@reaper@ag)
abline(h=1, col="red")
screeplot(my.binmat@reaper)
abline(v=6, col="forestgreen", lwd=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
