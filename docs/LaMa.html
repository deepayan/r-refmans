<!DOCTYPE html><html lang="en"><head><title>Help for package LaMa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LaMa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LaMa-package'><p>LaMa: Fast Numerical Maximum Likelihood Estimation for Latent Markov Models</p></a></li>
<li><a href='#buildSmoothDens'><p>Build the design and penalty matrices for smooth density estimation</p></a></li>
<li><a href='#calc_trackInd'><p>Calculate the index of the first observation of each track based on an ID variable</p></a></li>
<li><a href='#dgmrf2'><p>Reparametrised multivariate Gaussian distribution</p></a></li>
<li><a href='#dirichlet'><p>Dirichlet distribution</p></a></li>
<li><a href='#forward'><p><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> with homogeneous transition probability matrix</p></a></li>
<li><a href='#forward_g'><p>General <a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">forward algorithm</a> with time-varying transition probability matrix</p></a></li>
<li><a href='#forward_hsmm'><p><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for homogeneous hidden semi-Markov models</p></a></li>
<li><a href='#forward_ihsmm'><p><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with inhomogeneous state durations and/ or conditional transition probabilities</p></a></li>
<li><a href='#forward_p'><p><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> with for periodically varying transition probability matrices</p></a></li>
<li><a href='#forward_phsmm'><p><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with periodically inhomogeneous state durations and/ or conditional transition probabilities</p></a></li>
<li><a href='#forward_s'><p><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with homogeneous transition probability matrix</p></a></li>
<li><a href='#forward_sp'><p><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with periodically varying transition probability matrices</p></a></li>
<li><a href='#gamma2'><p>Reparametrised gamma distribution</p></a></li>
<li><a href='#gdeterminant'><p>Computes generalised determinant</p></a></li>
<li><a href='#generator'><p>Build the generator matrix of a continuous-time Markov chain</p></a></li>
<li><a href='#make_matrices'><p>Build the design matrix and the penalty matrix for models involving penalised splines based on a formula and a data set</p></a></li>
<li><a href='#make_matrices_dens'><p>Build a standardised P-Spline design matrix and the associated P-Spline penalty matrix</p></a></li>
<li><a href='#nessi'><p>Loch Ness Monster Acceleration Data</p></a></li>
<li><a href='#penalty'><p>Computes penalty based on quadratic form</p></a></li>
<li><a href='#pred_matrix'><p>Build the prediction design matrix based on new data and model_matrices object created by <code>make_matrices</code></p></a></li>
<li><a href='#pseudo_res'><p>Calculate pseudo-residuals</p></a></li>
<li><a href='#pseudo_res_discrete'><p>Calculate pseudo-residuals for discrete-valued observations</p></a></li>
<li><a href='#qreml'><p>Quasi restricted maximum likelihood (qREML) algorithm for models with penalised splines or simple i.i.d. random effects</p></a></li>
<li><a href='#sdreportMC'><p>Monte Carlo version of <code>sdreport</code></p></a></li>
<li><a href='#skewnorm'><p>Skew normal distribution</p></a></li>
<li><a href='#stateprobs'><p>Calculate conditional local state probabilities for homogeneous HMMs</p></a></li>
<li><a href='#stateprobs_g'><p>Calculate conditional local state probabilities for inhomogeneous HMMs</p></a></li>
<li><a href='#stateprobs_p'><p>Calculate conditional local state probabilities for periodically inhomogeneous HMMs</p></a></li>
<li><a href='#stationary'><p>Compute the stationary distribution of a homogeneous Markov chain</p></a></li>
<li><a href='#stationary_cont'><p>Compute the stationary distribution of a continuous-time Markov chain</p></a></li>
<li><a href='#stationary_p'><p>Compute the periodically stationary distribution of a periodically inhomogeneous Markov chain</p></a></li>
<li><a href='#stationary_p_sparse'><p>Sparse version of <code>stationary_p</code></p></a></li>
<li><a href='#stationary_sparse'><p>Sparse version of <code>stationary</code></p></a></li>
<li><a href='#tpm'><p>Build the transition probability matrix from unconstrained parameter vector</p></a></li>
<li><a href='#tpm_cont'><p>Calculate continuous time transition probabilities</p></a></li>
<li><a href='#tpm_emb'><p>Build the embedded transition probability matrix of an HSMM from unconstrained parameter vector</p></a></li>
<li><a href='#tpm_emb_g'><p>Build all embedded transition probability matrices of an inhomogeneous HSMM</p></a></li>
<li><a href='#tpm_g'><p>Build all transition probability matrices of an inhomogeneous HMM</p></a></li>
<li><a href='#tpm_hsmm'><p>Builds the transition probability matrix of an HSMM-approximating HMM</p></a></li>
<li><a href='#tpm_hsmm2'><p>Build the transition probability matrix of an HSMM-approximating HMM</p></a></li>
<li><a href='#tpm_ihsmm'><p>Builds all transition probability matrices of an inhomogeneous-HSMM-approximating HMM</p></a></li>
<li><a href='#tpm_p'><p>Build all transition probability matrices of a periodically inhomogeneous HMM</p></a></li>
<li><a href='#tpm_phsmm'><p>Builds all transition probability matrices of an periodic-HSMM-approximating HMM</p></a></li>
<li><a href='#tpm_phsmm2'><p>Build all transition probability matrices of an periodic-HSMM-approximating HMM</p></a></li>
<li><a href='#tpm_thinned'><p>Compute the transition probability matrix of a thinned periodically inhomogeneous Markov chain.</p></a></li>
<li><a href='#trex'><p>T-Rex Movement Data</p></a></li>
<li><a href='#trigBasisExp'><p>Compute the design matrix for a trigonometric basis expansion</p></a></li>
<li><a href='#viterbi'><p>Viterbi algorithm for state decoding in homogeneous HMMs</p></a></li>
<li><a href='#viterbi_g'><p>Viterbi algorithm for state decoding in inhomogeneous HMMs</p></a></li>
<li><a href='#viterbi_p'><p>Viterbi algorithm for state decoding in periodically inhomogeneous HMMs</p></a></li>
<li><a href='#vm'><p>von Mises distribution</p></a></li>
<li><a href='#wrpcauchy'><p>wrapped Cauchy distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Numerical Maximum Likelihood Estimation for Latent Markov
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>
  A variety of latent Markov models, including hidden Markov models, hidden semi-Markov models, 
  state-space models and continuous-time variants can be formulated and estimated within the same framework via directly maximising the likelihood function using the so-called forward algorithm. 
  Applied researchers often need custom models that standard software does not easily support. 
  Writing tailored 'R' code offers flexibility but suffers from slow estimation speeds. 
  We address these issues by providing easy-to-use functions (written in 'C++' for speed) for common tasks like the forward algorithm. 
  These functions can be combined into custom models in a Lego-type approach, offering up to 10-20 times faster estimation via standard numerical optimisers. 
  To aid in building fully custom likelihood functions, several vignettes are included that show how to simulate data from and estimate all the above model classes.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://janoleko.github.io/LaMa/">https://janoleko.github.io/LaMa/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, mgcv, Matrix, stats, utils, MASS, mvtnorm, splines,
methods, CircStats, circular, sn</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), RTMB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), PHSMM, MSwM, scales</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-29 10:06:34 UTC; jan-ole</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan-Ole Koslik <a href="https://orcid.org/0009-0004-1556-9053"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan-Ole Koslik &lt;jan-ole.koslik@uni-bielefeld.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-29 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='LaMa-package'>LaMa: Fast Numerical Maximum Likelihood Estimation for Latent Markov Models</h2><span id='topic+LaMa'></span><span id='topic+LaMa-package'></span>

<h3>Description</h3>

<p>A variety of latent Markov models, including hidden Markov models, hidden semi-Markov models, state-space models and continuous-time variants can be formulated and estimated within the same framework via directly maximising the likelihood function using the so-called forward algorithm. Applied researchers often need custom models that standard software does not easily support. Writing tailored 'R' code offers flexibility but suffers from slow estimation speeds. We address these issues by providing easy-to-use functions (written in 'C++' for speed) for common tasks like the forward algorithm. These functions can be combined into custom models in a Lego-type approach, offering up to 10-20 times faster estimation via standard numerical optimisers. To aid in building fully custom likelihood functions, several vignettes are included that show how to simulate data from and estimate all the above model classes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jan-Ole Koslik <a href="mailto:jan-ole.koslik@uni-bielefeld.de">jan-ole.koslik@uni-bielefeld.de</a> (<a href="https://orcid.org/0009-0004-1556-9053">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://janoleko.github.io/LaMa/">https://janoleko.github.io/LaMa/</a>
</p>
</li></ul>


<hr>
<h2 id='buildSmoothDens'>Build the design and penalty matrices for smooth density estimation</h2><span id='topic+buildSmoothDens'></span>

<h3>Description</h3>

<p>This high-level function can be used to prepare objects needed to estimate mixture models of smooth densities using P-Splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildSmoothDens(data, type = "real", par, k = 20, degree = 3, diff_order = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildSmoothDens_+3A_data">data</code></td>
<td>
<p>named data frame of different data streams</p>
</td></tr>
<tr><td><code id="buildSmoothDens_+3A_type">type</code></td>
<td>
<p>type of each data stream, either <code>"real"</code> for data on the reals, <code>"positive"</code> for data on the positive reals or <code>"circular"</code> for angular data. Needs to be a vector corresponding to the number of data streams in <code>data</code>.</p>
</td></tr>
<tr><td><code id="buildSmoothDens_+3A_par">par</code></td>
<td>
<p>nested named list of initial means and sds/concentrations for each data stream</p>
</td></tr>
<tr><td><code id="buildSmoothDens_+3A_k">k</code></td>
<td>
<p>number of basis functions for each data stream</p>
</td></tr>
<tr><td><code id="buildSmoothDens_+3A_degree">degree</code></td>
<td>
<p>degree of the B-spline basis functions for each data stream, defaults to cubic B-splines</p>
</td></tr>
<tr><td><code id="buildSmoothDens_+3A_diff_order">diff_order</code></td>
<td>
<p>order of differencing used for the P-Spline penalty matrix for each data stream. Defaults to second-order differences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the hood, <code><a href="#topic+make_matrices_dens">make_matrices_dens</a></code> is used for the actual construction of the design and penalty matrices.
</p>
<p>You can provide one or multiple data streams of different types (real, positive, circular) and specify initial means and standard deviations/ concentrations for each data stream. This information is then converted into suitable spline coefficients.
<code>buildSmoothDens</code> then constructs the design and penalty matrices for standardised B-splines basis functions (integrating to one) for each data stream.
For types <code>"real"</code> and <code>"circular"</code> the knots are placed equidistant in the range of the data, for type <code>"positive"</code> the knots are placed using polynomial spacing.
</p>


<h3>Value</h3>

<p>a nested list containing the design matrices <code>Z</code>, the penalty matrices <code>S</code>, the initial coefficients <code>coef</code> the prediction design matrices <code>Z_predict</code>, the prediction grids <code>xseq</code>, and details for the basis expansion for each data stream.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 3 data streams, each with one distribution
# normal data with mean 0 and sd 1
x1 = rnorm(100, mean = 0, sd = 1)
# gamma data with mean 5 and sd 3
x2 = rgamma2(100, mean = 5, sd = 3)
# circular data
x3 = rvm(100, mu = 0, kappa = 2)

data = data.frame(x1 = x1, x2 = x2, x3 = x3)

par = list(x1 = list(mean = 0, sd = 1),
           x2 = list(mean = 5, sd = 3),
           x3 = list(mean = 0, concentration = 2))

SmoothDens = buildSmoothDens(data, 
                             type = c("real", "positive", "circular"),
                             par)
                             
# extracting objects for x1
Z1 = SmoothDens$Z$x1
S1 = SmoothDens$S$x1
coefs1 = SmoothDens$coef$x1

## one data stream, but mixture of two distributions
# normal data with mean 0 and sd 1
x = rnorm(100, mean = 0, sd = 1)
data = data.frame(x = x)

# now parameters for mixture of two normals
par = list(x = list(mean = c(0, 5), sd = c(1,1)))

SmoothDens = buildSmoothDens(data, par = par)

# extracting objects 
Z = SmoothDens$Z$x
S = SmoothDens$S$x
coefs = SmoothDens$coef$x
</code></pre>

<hr>
<h2 id='calc_trackInd'>Calculate the index of the first observation of each track based on an ID variable</h2><span id='topic+calc_trackInd'></span>

<h3>Description</h3>

<p>Function to conveniently calculate the trackInd variable that is needed internally when fitting a model to longitudinal data with multiple tracks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_trackInd(ID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_trackInd_+3A_id">ID</code></td>
<td>
<p>ID variable of track IDs that is of the same length as the data to be analysed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices of the first observation of each track which can be passed to the forward and forward_g to sum likelihood contributions of each track
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uniqueID = c("Animal1", "Animal2", "Animal3")
ID = rep(uniqueID, c(100, 200, 300))
trackInd = calc_trackInd(ID)
</code></pre>

<hr>
<h2 id='dgmrf2'>Reparametrised multivariate Gaussian distribution</h2><span id='topic+dgmrf2'></span>

<h3>Description</h3>

<p>Density function of the multivariate Gaussian distribution reparametrised in terms of its precision matrix (inverse variance).
This implementation is particularly useful for defining the <strong>joint log-likelihood</strong> with penalised splines or i.i.d. random effects that have a multivariate Gaussian distribution with fixed precision/ penalty matrix <code class="reqn">\lambda S</code>.
As <code class="reqn">S</code> is fixed and only scaled by <code class="reqn">\lambda</code>, it is more efficient to precompute the determinant of <code class="reqn">S</code> (for the normalisation constant) and only scale the quadratic form by <code class="reqn">\lambda</code>
when multiple spline parameters/ random effects with different <code class="reqn">\lambda</code>'s but the same penalty matrix <code class="reqn">S</code> are evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgmrf2(x, mu = 0, S, lambda, logdetS = NULL, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgmrf2_+3A_x">x</code></td>
<td>
<p>density evaluation point, either a vector or a matrix</p>
</td></tr>
<tr><td><code id="dgmrf2_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Either scalar or vector</p>
</td></tr>
<tr><td><code id="dgmrf2_+3A_s">S</code></td>
<td>
<p>unscaled precision matrix</p>
</td></tr>
<tr><td><code id="dgmrf2_+3A_lambda">lambda</code></td>
<td>
<p>precision scaling parameter
</p>
<p>Can be a vector if <code>x</code> is a matrix. Then each row of <code>x</code> is evaluated with the corresponding <code>lambda</code>.
This is benefitial from an efficiency perspective because the determinant of <code>S</code> is only computed once.</p>
</td></tr>
<tr><td><code id="dgmrf2_+3A_logdets">logdetS</code></td>
<td>
<p>Optional precomputed log determinant of the precision matrix <code>S</code>. If the precision matrix does not depend on parameters, it can be precomputed and passed to the function.</p>
</td></tr>
<tr><td><code id="dgmrf2_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, densities are returned on the log scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation allows for automatic differentiation with <code>RTMB</code>.
</p>


<h3>Value</h3>

<p>vector of density values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = matrix(runif(30), nrow = 3)

# iid random effects
S = diag(10)
sigma = c(1, 2, 3) # random effect standard deviations
lambda = 1 / sigma^2
d = dgmrf2(x, 0, S, lambda)

# P-splines
L = diff(diag(10), diff = 2) # second-order difference matrix
S = t(L) %*% L
lambda = c(1,2,3)
d = dgmrf2(x, 0, S, lambda, log = TRUE)
</code></pre>

<hr>
<h2 id='dirichlet'>Dirichlet distribution</h2><span id='topic+dirichlet'></span><span id='topic+ddirichlet'></span>

<h3>Description</h3>

<p>Density of the Dirichlet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(x, alpha, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dirichlet_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>vector or matrix of shape parameters</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, densities <code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of <code>ddirichlet</code> allows for automatic differentiation with <code>RTMB</code>.
</p>


<h3>Value</h3>

<p><code>ddirichlet</code> gives the density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddirichlet(c(0.2, 0.3, 0.5), c(1, 2, 3))
</code></pre>

<hr>
<h2 id='forward'><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> with homogeneous transition probability matrix</h2><span id='topic+forward'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of a sequence of observations under a homogeneous hidden Markov model using the <strong>forward algorithm</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward(delta, Gamma, allprobs, trackID = NULL, ad = NULL, report = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="forward_+3A_gamma">Gamma</code></td>
<td>
<p>transition probability matrix of dimension c(N,N), or array of k transition probability matrices of dimension c(N,N,k), if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="forward_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="forward_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of length n containing IDs
</p>
<p>If provided, the total log-likelihood will be the sum of each track's likelihood contribution.
In this case, <code>Gamma</code> can be a matrix, leading to the same transition probabilities for each track, or an array of dimension c(N,N,k), with one (homogeneous) transition probability matrix for each track.
Furthermore, instead of a single vector <code>delta</code> corresponding to the initial distribution, a <code>delta</code> matrix of initial distributions, of dimension c(k,N), can be provided, such that each track starts with it's own initial distribution.</p>
</td></tr>
<tr><td><code id="forward_+3A_ad">ad</code></td>
<td>
<p>optional logical, indicating whether automatic differentiation with <code>RTMB</code> should be used. By default, the function determines this itself.</p>
</td></tr>
<tr><td><code id="forward_+3A_report">report</code></td>
<td>
<p>logical, indicating whether <code>delta</code>, <code>Gamma</code> and <code>allprobs</code> should be reported from the fitted model. Defaults to <code>TRUE</code>, but only works if <code>ad = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>See Also</h3>

<p>Other forward algorithms: 
<code><a href="#topic+forward_g">forward_g</a>()</code>,
<code><a href="#topic+forward_hsmm">forward_hsmm</a>()</code>,
<code><a href="#topic+forward_ihsmm">forward_ihsmm</a>()</code>,
<code><a href="#topic+forward_p">forward_p</a>()</code>,
<code><a href="#topic+forward_phsmm">forward_phsmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## negative log likelihood function
nll = function(par, step) {
 # parameter transformations for unconstrained optimisation
 Gamma = tpm(par[1:2]) # multinomial logit link
 delta = stationary(Gamma) # stationary HMM
 mu = exp(par[3:4])
 sigma = exp(par[5:6])
 # calculate all state-dependent probabilities
 allprobs = matrix(1, length(step), 2)
 ind = which(!is.na(step))
 for(j in 1:2) allprobs[ind,j] = dgamma2(step[ind], mu[j], sigma[j])
 # simple forward algorithm to calculate log-likelihood
 -forward(delta, Gamma, allprobs)
}

## fitting an HMM to the trex data
par = c(-2,-2,            # initial tpm params (logit-scale)
        log(c(0.3, 2.5)), # initial means for step length (log-transformed)
        log(c(0.2, 1.5))) # initial sds for step length (log-transformed)
mod = nlm(nll, par, step = trex$step[1:1000])
</code></pre>

<hr>
<h2 id='forward_g'>General <a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">forward algorithm</a> with time-varying transition probability matrix</h2><span id='topic+forward_g'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of a sequence of observations under a hidden Markov model with time-varying transition probabilities using the <strong>forward algorithm</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_g(delta, Gamma, allprobs, trackID = NULL, ad = NULL, report = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_g_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="forward_g_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices of dimension c(N,N,n-1), as in a time series of length n, there are only n-1 transitions. 
</p>
<p>If an array of dimension c(N,N,n) for a single track is provided, the first slice will be ignored.
</p>
<p>If the elements of <code class="reqn">\Gamma^{(t)}</code> depend on covariate values at t or covariates t+1 is your choice in the calculation of the array, prior to using this function.
When conducting the calculation by using tpm_g(), the choice comes down to including the covariate matrix Z[-1,] oder Z[-n,].
</p>
<p>If trackInd is provided, Gamma needs to be an array of dimension c(N,N,n), matching the number of rows of allprobs. For each track, the transition matrix at the beginning will be ignored.
If the parameters for Gamma are pooled across tracks or not, depends on your calculation of Gamma. If pooled, you can use tpm_g(Z, beta) to calculate the entire array of transition matrices when Z is of dimension c(n,p). <br />
</p>
<p>This function can also be used to fit continuous-time HMMs, where each array entry is the Markov semigroup <code class="reqn">\Gamma(\Delta t) = \exp(Q \Delta t)</code> and <code class="reqn">Q</code> is the generator of the continuous-time Markov chain.</p>
</td></tr>
<tr><td><code id="forward_g_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="forward_g_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of length n containing IDs
</p>
<p>If provided, the total log-likelihood will be the sum of each track's likelihood contribution.
In this case, <code>Gamma</code> needs to be an array of dimension c(N,N,n), matching the number of rows of allprobs. For each track, the transition matrix at the beginning of the track will be ignored (as there is no transition between tracks).
Furthermore, instead of a single vector <code>delta</code> corresponding to the initial distribution, a <code>delta</code> matrix of initial distributions, of dimension c(k,N), can be provided, such that each track starts with it's own initial distribution.</p>
</td></tr>
<tr><td><code id="forward_g_+3A_ad">ad</code></td>
<td>
<p>optional logical, indicating whether automatic differentiation with <code>RTMB</code> should be used. By default, the function determines this itself.</p>
</td></tr>
<tr><td><code id="forward_g_+3A_report">report</code></td>
<td>
<p>logical, indicating whether <code>delta</code>, <code>Gamma</code> and <code>allprobs</code> should be reported from the fitted model. Defaults to <code>TRUE</code>, but only works if <code>ad = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>See Also</h3>

<p>Other forward algorithms: 
<code><a href="#topic+forward">forward</a>()</code>,
<code><a href="#topic+forward_hsmm">forward_hsmm</a>()</code>,
<code><a href="#topic+forward_ihsmm">forward_ihsmm</a>()</code>,
<code><a href="#topic+forward_p">forward_p</a>()</code>,
<code><a href="#topic+forward_phsmm">forward_phsmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple usage
Gamma = array(c(0.9, 0.2, 0.1, 0.8), dim = c(2,2,10))
delta = c(0.5, 0.5)
allprobs = matrix(0.5, 10, 2)
forward_g(delta, Gamma, allprobs)


## Full model fitting example
## negative log likelihood function
nll = function(par, step, Z) {
 # parameter transformations for unconstrained optimisation
 beta = matrix(par[1:6], nrow = 2)
 Gamma = tpm_g(Z, beta) # multinomial logit link for each time point
 delta = stationary(Gamma[,,1]) # stationary HMM
 mu = exp(par[7:8])
 sigma = exp(par[9:10])
 # calculate all state-dependent probabilities
 allprobs = matrix(1, length(step), 2)
 ind = which(!is.na(step))
 for(j in 1:2) allprobs[ind,j] = dgamma2(step[ind], mu[j], sigma[j])
 # simple forward algorithm to calculate log-likelihood
 -forward_g(delta, Gamma, allprobs)
}

## fitting an HMM to the trex data
par = c(-1.5,-1.5,        # initial tpm intercepts (logit-scale)
        rep(0, 4),        # initial tpm slopes
        log(c(0.3, 2.5)), # initial means for step length (log-transformed)
        log(c(0.2, 1.5))) # initial sds for step length (log-transformed)
mod = nlm(nll, par, step = trex$step[1:500], Z = trigBasisExp(trex$tod[1:500]))

</code></pre>

<hr>
<h2 id='forward_hsmm'><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for homogeneous hidden semi-Markov models</h2><span id='topic+forward_hsmm'></span>

<h3>Description</h3>

<p>Calculates the (approximate) log-likelihood of a sequence of observations under a homogeneous hidden semi-Markov model using a modified <strong>forward algorithm</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_hsmm(
  dm,
  omega,
  allprobs,
  trackID = NULL,
  delta = NULL,
  eps = 1e-10,
  report = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_hsmm_+3A_dm">dm</code></td>
<td>
<p>list of length N containing vectors of dwell-time probability mass functions (PMFs) for each state. The vector lengths correspond to the approximating state aggregate sizes, hence there should be little probablity mass not covered by these.</p>
</td></tr>
<tr><td><code id="forward_hsmm_+3A_omega">omega</code></td>
<td>
<p>matrix of dimension c(N,N) of conditional transition probabilites, also called embedded transition probability matrix. 
</p>
<p>Contains the transition probabilities given that the current state is left. Hence, the diagonal elements need to be zero and the rows need to sum to one. Can be constructed using <code><a href="#topic+tpm_emb">tpm_emb</a></code>.</p>
</td></tr>
<tr><td><code id="forward_hsmm_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N) which will automatically be converted to the appropriate dimension.</p>
</td></tr>
<tr><td><code id="forward_hsmm_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of length n containing IDs
</p>
<p>If provided, the total log-likelihood will be the sum of each track's likelihood contribution.
In this case, <code>dm</code> can be a nested list, where the top layer contains k <code>dm</code> lists as described above. <code>omega</code> can then also be an array of dimension c(N,N,k) with one conditional transition probability matrix for each track.
Furthermore, instead of a single vector <code>delta</code> corresponding to the initial distribution, a <code>delta</code> matrix of initial distributions, of dimension c(k,N), can be provided, such that each track starts with it's own initial distribution.</p>
</td></tr>
<tr><td><code id="forward_hsmm_+3A_delta">delta</code></td>
<td>
<p>optional vector of initial state probabilities of length N
</p>
<p>By default, the stationary distribution is computed (which is typically recommended).</p>
</td></tr>
<tr><td><code id="forward_hsmm_+3A_eps">eps</code></td>
<td>
<p>small value to avoid numerical issues in the approximating transition matrix construction. Usually, this should not be changed.</p>
</td></tr>
<tr><td><code id="forward_hsmm_+3A_report">report</code></td>
<td>
<p>logical, indicating whether initial distribution, approximating transition probability matrix and <code>allprobs</code> matrix should be reported from the fitted model. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs, where the state duration distribution is explicitly modelled by a distribution on the positive integers.
For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
</p>
<p>This function is designed to be used with automatic differentiation based on the <code>R</code> package <code>RTMB</code>. It will be very slow without it!
</p>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>See Also</h3>

<p>Other forward algorithms: 
<code><a href="#topic+forward">forward</a>()</code>,
<code><a href="#topic+forward_g">forward_g</a>()</code>,
<code><a href="#topic+forward_ihsmm">forward_ihsmm</a>()</code>,
<code><a href="#topic+forward_p">forward_p</a>()</code>,
<code><a href="#topic+forward_phsmm">forward_phsmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># currently no examples
</code></pre>

<hr>
<h2 id='forward_ihsmm'><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with inhomogeneous state durations and/ or conditional transition probabilities</h2><span id='topic+forward_ihsmm'></span>

<h3>Description</h3>

<p>Calculates the (approximate) log-likelihood of a sequence of observations under an inhomogeneous hidden semi-Markov model using a modified <strong>forward algorithm</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_ihsmm(
  dm,
  omega,
  allprobs,
  trackID = NULL,
  delta = NULL,
  startInd = NULL,
  eps = 1e-10,
  report = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_ihsmm_+3A_dm">dm</code></td>
<td>
<p>list of length N containing matrices (or vectors) of dwell-time probability mass functions (PMFs) for each state.
</p>
<p>If the dwell-time PMFs are constant, the vectors are the PMF of the dwell-time distribution fixed in time. The vector lengths correspond to the approximating state aggregate sizes, hence there should be little probablity mass not covered by these.
</p>
<p>If the dwell-time PMFs are inhomogeneous, the matrices need to have n rows, where n is the number of observations. The number of columns again correponds to the size of the approximating state aggregates.
</p>
<p>In the latter case, the first <code>max(sapply(dm, ncol)) - 1</code> observations will not be used because the first approximating transition probability matrix needs to be computed based on the first <code>max(sapply(dm, ncol))</code> covariate values (represented by <code>dm</code>).</p>
</td></tr>
<tr><td><code id="forward_ihsmm_+3A_omega">omega</code></td>
<td>
<p>matrix of dimension c(N,N) or array of dimension c(N,N,n) of conditional transition probabilites, also called embedded transition probability matrix.
</p>
<p>It contains the transition probabilities given the current state is left. Hence, the diagonal elements need to be zero and the rows need to sum to one. Such a matrix can be constructed using <code><a href="#topic+tpm_emb">tpm_emb</a></code> and an array using <code><a href="#topic+tpm_emb_g">tpm_emb_g</a></code>.</p>
</td></tr>
<tr><td><code id="forward_ihsmm_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="forward_ihsmm_+3A_trackid">trackID</code></td>
<td>
<p>trackID optional vector of length n containing IDs
</p>
<p>If provided, the total log-likelihood will be the sum of each track's likelihood contribution.
Instead of a single vector <code>delta</code> corresponding to the initial distribution, a <code>delta</code> matrix of initial distributions, of dimension c(k,N), can be provided, such that each track starts with it's own initial distribution.</p>
</td></tr>
<tr><td><code id="forward_ihsmm_+3A_delta">delta</code></td>
<td>
<p>optional vector of initial state probabilities of length N
</p>
<p>By default, instead of this, the stationary distribution is computed corresponding to the first approximating transition probability matrix of each track is computed. Contrary to the homogeneous case, this is not theoretically motivated but just for convenience.</p>
</td></tr>
<tr><td><code id="forward_ihsmm_+3A_startind">startInd</code></td>
<td>
<p>optional integer index at which the forward algorithm starts. 
</p>
<p>When approximating inhomogeneous HSMMs by inhomogeneous HMMs, the first transition probability matrix that can be constructed is at time <code>max(sapply(dm, ncol))</code> (as it depends on the previous covariate values).
Hence, when not provided, <code>startInd</code> is chosen to be <code>max(sapply(dm, ncol))</code>. Fixing <code>startInd</code> at a value <strong>larger</strong> than max(aggregate sizes) is useful when models with different aggregate sizes are fitted to the same data and are supposed to be compared. In that case it is important that all models use the same number of observations.</p>
</td></tr>
<tr><td><code id="forward_ihsmm_+3A_eps">eps</code></td>
<td>
<p>small value to avoid numerical issues in the approximating transition matrix construction. Usually, this should not be changed.</p>
</td></tr>
<tr><td><code id="forward_ihsmm_+3A_report">report</code></td>
<td>
<p>logical, indicating whether initial distribution, approximating transition probability matrix and <code>allprobs</code> matrix should be reported from the fitted model. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs, where the state duration distribution is explicitly modelled by a distribution on the positive integers. This function can be used to fit HSMMs where the state-duration distribution and/ or the conditional transition probabilities vary with covariates.
For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
</p>
<p>This function is designed to be used with automatic differentiation based on the <code>R</code> package <code>RTMB</code>. It will be very slow without it!
</p>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>See Also</h3>

<p>Other forward algorithms: 
<code><a href="#topic+forward">forward</a>()</code>,
<code><a href="#topic+forward_g">forward_g</a>()</code>,
<code><a href="#topic+forward_hsmm">forward_hsmm</a>()</code>,
<code><a href="#topic+forward_p">forward_p</a>()</code>,
<code><a href="#topic+forward_phsmm">forward_phsmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># currently no examples
</code></pre>

<hr>
<h2 id='forward_p'><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> with for periodically varying transition probability matrices</h2><span id='topic+forward_p'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of a sequence of observations under a hidden Markov model with periodically varying transition probabilities using the <strong>forward algorithm</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_p(
  delta,
  Gamma,
  allprobs,
  tod,
  trackID = NULL,
  ad = NULL,
  report = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_p_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="forward_p_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices of dimension c(N,N,L).
</p>
<p>Here we use the definition <code class="reqn">\Pr(S_t=j \mid S_{t-1}=i) = \gamma_{ij}^{(t)}</code> such that the transition probabilities between time point <code class="reqn">t-1</code> and <code class="reqn">t</code> are an element of <code class="reqn">\Gamma^{(t)}</code>.</p>
</td></tr>
<tr><td><code id="forward_p_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="forward_p_+3A_tod">tod</code></td>
<td>
<p>(Integer valued) variable for cycle indexing in 1, ..., L, mapping the data index to a generalised time of day (length n)
</p>
<p>For half-hourly data L = 48. It could, however, also be day of year for daily data and L = 365.</p>
</td></tr>
<tr><td><code id="forward_p_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of length n containing IDs
</p>
<p>If provided, the total log-likelihood will be the sum of each track's likelihood contribution.
Instead of a single vector <code>delta</code> corresponding to the initial distribution, a <code>delta</code> matrix of initial distributions of dimension c(k,N), can be provided, such that each track starts with it's own initial distribution.</p>
</td></tr>
<tr><td><code id="forward_p_+3A_ad">ad</code></td>
<td>
<p>optional logical, indicating whether automatic differentiation with <code>RTMB</code> should be used. By default, the function determines this itself.</p>
</td></tr>
<tr><td><code id="forward_p_+3A_report">report</code></td>
<td>
<p>logical, indicating whether <code>delta</code>, <code>Gamma</code> and <code>allprobs</code> should be reported from the fitted model. Defaults to <code>TRUE</code>, but only works if <code>ad = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the transition probability matrix only varies periodically (e.g. as a function of time of day), there are only <code class="reqn">L</code> unique matrices if <code class="reqn">L</code> is the period length (e.g. <code class="reqn">L=24</code> for hourly data and time-of-day variation).
Thus, it is much more efficient to only calculate these <code class="reqn">L</code> matrices and index them by a time variable (e.g. time of day or day of year) instead of calculating such a matrix for each index in the data set (which would be redundant).
This function allows for that by only expecting a transition probability matrix for each time point in a period and an integer valued (<code class="reqn">1, \dots, L</code>) time variable that maps the data index to the according time.
</p>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>See Also</h3>

<p>Other forward algorithms: 
<code><a href="#topic+forward">forward</a>()</code>,
<code><a href="#topic+forward_g">forward_g</a>()</code>,
<code><a href="#topic+forward_hsmm">forward_hsmm</a>()</code>,
<code><a href="#topic+forward_ihsmm">forward_ihsmm</a>()</code>,
<code><a href="#topic+forward_phsmm">forward_phsmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## negative log likelihood function
nll = function(par, step, tod) {
 # parameter transformations for unconstrained optimisation
 beta = matrix(par[1:6], nrow = 2)
 Gamma = tpm_p(1:24, beta = beta) # multinomial logit link for each time point
 delta = stationary_p(Gamma, tod[1]) # stationary HMM
 mu = exp(par[7:8])
 sigma = exp(par[9:10])
 # calculate all state-dependent probabilities
 allprobs = matrix(1, length(step), 2)
 ind = which(!is.na(step))
 for(j in 1:2) allprobs[ind,j] = dgamma2(step[ind], mu[j], sigma[j])
 # simple forward algorithm to calculate log-likelihood
 -forward_p(delta, Gamma, allprobs, tod)
}

## fitting an HMM to the nessi data
par = c(-2,-2,            # initial tpm intercepts (logit-scale)
        rep(0, 4),        # initial tpm slopes
        log(c(0.3, 2.5)), # initial means for step length (log-transformed)
        log(c(0.2, 1.5))) # initial sds for step length (log-transformed)
mod = nlm(nll, par, step = trex$step[1:500], tod = trex$tod[1:500])
</code></pre>

<hr>
<h2 id='forward_phsmm'><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with periodically inhomogeneous state durations and/ or conditional transition probabilities</h2><span id='topic+forward_phsmm'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs, where the state duration distribution is explicitly modelled by a distribution on the positive integers. This function can be used to fit HSMMs where the state-duration distribution and/ or the conditional transition probabilities vary with covariates.
For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
</p>
<p>This function can be used to fit HSMMs where the state-duration distribution and/ or the conditional transition probabilities vary periodically.
In the special case of periodic variation (as compared to arbitrary covariate influence), this version is to be preferred over <code><a href="#topic+forward_ihsmm">forward_ihsmm</a></code> because it computes the <strong>correct periodically stationary distribution</strong> and no observations are lost for the approximation.
</p>
<p>This function is designed to be used with automatic differentiation based on the <code>R</code> package <code>RTMB</code>. It will be very slow without it!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_phsmm(
  dm,
  omega,
  allprobs,
  tod,
  trackID = NULL,
  delta = NULL,
  eps = 1e-10,
  report = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_phsmm_+3A_dm">dm</code></td>
<td>
<p>list of length N containing matrices (or vectors) of dwell-time probability mass functions (PMFs) for each state.
</p>
<p>If the dwell-time PMFs are constant, the vectors are the PMF of the dwell-time distribution fixed in time. The vector lengths correspond to the approximating state aggregate sizes, hence there should be little probablity mass not covered by these.
</p>
<p>If the dwell-time PMFs are inhomogeneous, the matrices need to have L rows, where L is the cycle length. The number of columns again correpond to the size of the approximating state aggregates.</p>
</td></tr>
<tr><td><code id="forward_phsmm_+3A_omega">omega</code></td>
<td>
<p>matrix of dimension c(N,N) or array of dimension c(N,N,L) of conditional transition probabilites, also called embedded transition probability matrix
</p>
<p>It contains the transition probabilities given the current state is left. Hence, the diagonal elements need to be zero and the rows need to sum to one. Such a matrix can be constructed using <code><a href="#topic+tpm_emb">tpm_emb</a></code> and an array using <code><a href="#topic+tpm_emb_g">tpm_emb_g</a></code>.</p>
</td></tr>
<tr><td><code id="forward_phsmm_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="forward_phsmm_+3A_tod">tod</code></td>
<td>
<p>(Integer valued) variable for cycle indexing in 1, ..., L, mapping the data index to a generalised time of day (length n).
For half-hourly data L = 48. It could, however, also be day of year for daily data and L = 365.</p>
</td></tr>
<tr><td><code id="forward_phsmm_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of length n containing IDs
</p>
<p>If provided, the total log-likelihood will be the sum of each track's likelihood contribution.
Instead of a single vector <code>delta</code> corresponding to the initial distribution, a <code>delta</code> matrix of initial distributions, of dimension c(k,N), can be provided, such that each track starts with it's own initial distribution.</p>
</td></tr>
<tr><td><code id="forward_phsmm_+3A_delta">delta</code></td>
<td>
<p>Optional vector of initial state probabilities of length N. By default, instead of this, the stationary distribution is computed corresponding to the first approximating t.p.m. of each track is computed. Contrary to the homogeneous case, this is not theoretically motivated but just for convenience.</p>
</td></tr>
<tr><td><code id="forward_phsmm_+3A_eps">eps</code></td>
<td>
<p>small value to avoid numerical issues in the approximating transition matrix construction. Usually, this should not be changed.</p>
</td></tr>
<tr><td><code id="forward_phsmm_+3A_report">report</code></td>
<td>
<p>logical, indicating whether initial distribution, approximating transition probability matrix and <code>allprobs</code> matrix should be reported from the fitted model. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the (approximate) log-likelihood of a sequence of observations under a periodically inhomogeneous hidden semi-Markov model using a modified <strong>forward algorithm</strong>.
</p>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>See Also</h3>

<p>Other forward algorithms: 
<code><a href="#topic+forward">forward</a>()</code>,
<code><a href="#topic+forward_g">forward_g</a>()</code>,
<code><a href="#topic+forward_hsmm">forward_hsmm</a>()</code>,
<code><a href="#topic+forward_ihsmm">forward_ihsmm</a>()</code>,
<code><a href="#topic+forward_p">forward_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># currently no examples
</code></pre>

<hr>
<h2 id='forward_s'><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with homogeneous transition probability matrix</h2><span id='topic+forward_s'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs that can be approximated by HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_s(delta, Gamma, allprobs, sizes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_s_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="forward_s_+3A_gamma">Gamma</code></td>
<td>
<p>transition probability matrix of dimension c(M,M)</p>
</td></tr>
<tr><td><code id="forward_s_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N) which will automatically be converted to the appropriate dimension.</p>
</td></tr>
<tr><td><code id="forward_s_+3A_sizes">sizes</code></td>
<td>
<p>state aggregate sizes that are used for the approximation of the semi-Markov chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generating data from homogeneous 2-state HSMM
mu = c(0, 6)
lambda = c(6, 12)
omega = matrix(c(0,1,1,0), nrow = 2, byrow = TRUE)
# simulation
# for a 2-state HSMM the embedded chain always alternates between 1 and 2
s = rep(1:2, 100)
C = x = numeric(0)
for(t in 1:100){
  dt = rpois(1, lambda[s[t]])+1 # shifted Poisson
  C = c(C, rep(s[t], dt))
  x = c(x, rnorm(dt, mu[s[t]], 1.5)) # fixed sd 2 for both states
}

## negative log likelihood function
mllk = function(theta.star, x, sizes){
  # parameter transformations for unconstraint optimization
  omega = matrix(c(0,1,1,0), nrow = 2, byrow = TRUE) # omega fixed (2-states)
  lambda = exp(theta.star[1:2]) # dwell time means
  dm = list(dpois(1:sizes[1]-1, lambda[1]), dpois(1:sizes[2]-1, lambda[2]))
  Gamma = tpm_hsmm2(omega, dm)
  delta = stationary(Gamma) # stationary
  mu = theta.star[3:4]
  sigma = exp(theta.star[5:6])
  # calculate all state-dependent probabilities
  allprobs = matrix(1, length(x), 2)
  for(j in 1:2){ allprobs[,j] = dnorm(x, mu[j], sigma[j]) }
  # return negative for minimization
  -forward_s(delta, Gamma, allprobs, sizes)
}

## fitting an HSMM to the data
theta.star = c(log(5), log(10), 1, 4, log(2), log(2))
mod = nlm(mllk, theta.star, x = x, sizes = c(20, 30), stepmax = 5)
</code></pre>

<hr>
<h2 id='forward_sp'><a href="https://www.taylorfrancis.com/books/mono/10.1201/b20790/hidden-markov-models-time-series-walter-zucchini-iain-macdonald-roland-langrock">Forward algorithm</a> for hidden semi-Markov models with periodically varying transition probability matrices</h2><span id='topic+forward_sp'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs that can be approximated by HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
Recently, this inference procedure has been generalised to allow either the dwell-time distributions or the conditional transition probabilities to depend on external covariates such as the time of day. This special case is implemented here.
This function allows for that, by expecting a transition probability matrix for each time point in a period, and an integer valued (<code class="reqn">1, \dots, L</code>) time variable that maps the data index to the according time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_sp(delta, Gamma, allprobs, sizes, tod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward_sp_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="forward_sp_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices of dimension c(M,M,L).
</p>
<p>Here we use the definition <code class="reqn">\Pr(S_t=j \mid S_{t-1}=i) = \gamma_{ij}^{(t)}</code> such that the transition probabilities between time point <code class="reqn">t-1</code> and <code class="reqn">t</code> are an element of <code class="reqn">\Gamma^{(t)}</code>.</p>
</td></tr>
<tr><td><code id="forward_sp_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N) which will automatically be converted to the appropriate dimension.</p>
</td></tr>
<tr><td><code id="forward_sp_+3A_sizes">sizes</code></td>
<td>
<p>state aggregate sizes that are used for the approximation of the semi-Markov chain.</p>
</td></tr>
<tr><td><code id="forward_sp_+3A_tod">tod</code></td>
<td>
<p>(Integer valued) variable for cycle indexing in 1, ..., L, mapping the data index to a generalised time of day (length n).
For half-hourly data L = 48. It could, however, also be day of year for daily data and L = 365.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood for given data and parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generating data from homogeneous 2-state HSMM
mu = c(0, 6)
beta = matrix(c(log(4),log(6),-0.2,0.2,-0.1,0.4), nrow=2)
# time varying mean dwell time
Lambda = exp(cbind(1, trigBasisExp(1:24, 24, 1))%*%t(beta))
omega = matrix(c(0,1,1,0), nrow = 2, byrow = TRUE)
# simulation
# for a 2-state HSMM the embedded chain always alternates between 1 and 2
s = rep(1:2, 100)
C = x = numeric(0)
tod = rep(1:24, 50) # time of day variable
time = 1
for(t in 1:100){
  dt = rpois(1, Lambda[tod[time], s[t]])+1 # dwell time depending on time of day
  time = time + dt
  C = c(C, rep(s[t], dt))
  x = c(x, rnorm(dt, mu[s[t]], 1.5)) # fixed sd 2 for both states
}
tod = tod[1:length(x)]

## negative log likelihood function
mllk = function(theta.star, x, sizes, tod){
  # parameter transformations for unconstraint optimization
  omega = matrix(c(0,1,1,0), nrow = 2, byrow = TRUE) # omega fixed (2-states)
  mu = theta.star[1:2]
  sigma = exp(theta.star[3:4])
  beta = matrix(theta.star[5:10], nrow=2)
  # time varying mean dwell time
  Lambda = exp(cbind(1, trigBasisExp(1:24, 24, 1))%*%t(beta))
  dm = list()
  for(j in 1:2){
    dm[[j]] = sapply(1:sizes[j]-1, dpois, lambda = Lambda[,j])
  }
  Gamma = tpm_phsmm2(omega, dm)
  delta = stationary_p(Gamma, tod[1])
  # calculate all state-dependent probabilities
  allprobs = matrix(1, length(x), 2)
  for(j in 1:2){ allprobs[,j] = dnorm(x, mu[j], sigma[j]) }
  # return negative for minimization
  -forward_sp(delta, Gamma, allprobs, sizes, tod)
}

## fitting an HSMM to the data
theta.star = c(1, 4, log(2), log(2), # state-dependent parameters
                 log(4), log(6), rep(0,4)) # state process parameters dm
# mod = nlm(mllk, theta.star, x = x, sizes = c(10, 15), tod = tod, stepmax = 5)
</code></pre>

<hr>
<h2 id='gamma2'>Reparametrised gamma distribution</h2><span id='topic+gamma2'></span><span id='topic+dgamma2'></span><span id='topic+pgamma2'></span><span id='topic+qgamma2'></span><span id='topic+rgamma2'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
the gamma distribution reparametrised in terms of mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgamma2(x, mean = 1, sd = 1, log = FALSE)

pgamma2(q, mean = 1, sd = 1, lower.tail = TRUE, log.p = FALSE)

qgamma2(p, mean = 1, sd = 1, lower.tail = TRUE, log.p = FALSE)

rgamma2(n, mean = 1, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamma2_+3A_x">x</code>, <code id="gamma2_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="gamma2_+3A_mean">mean</code></td>
<td>
<p>mean parameter, must be positive scalar.</p>
</td></tr>
<tr><td><code id="gamma2_+3A_sd">sd</code></td>
<td>
<p>standard deviation parameter, must be positive scalar.</p>
</td></tr>
<tr><td><code id="gamma2_+3A_log">log</code>, <code id="gamma2_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/ densities <code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="gamma2_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities are <code class="reqn">P[X &lt;= x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="gamma2_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="gamma2_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation allows for automatic differentiation with <code>RTMB</code>.
</p>


<h3>Value</h3>

<p><code>dgamma2</code> gives the density, <code>pgamma2</code> gives the distribution function, <code>qgamma2</code> gives the quantile function, and <code>rgamma2</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = rgamma2(1)
d = dgamma2(x)
p = pgamma2(x)
q = qgamma2(p)
</code></pre>

<hr>
<h2 id='gdeterminant'>Computes generalised determinant</h2><span id='topic+gdeterminant'></span>

<h3>Description</h3>

<p>Computes generalised determinant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdeterminant(x, eps = 1e-10, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdeterminant_+3A_x">x</code></td>
<td>
<p>square matrix</p>
</td></tr>
<tr><td><code id="gdeterminant_+3A_eps">eps</code></td>
<td>
<p>eigenvalues smaller than this will be treated as zero</p>
</td></tr>
<tr><td><code id="gdeterminant_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, the log-determinant is returned. If <code>FALSE</code>, the determinant is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generalised log-determinant of <code>x</code>
</p>

<hr>
<h2 id='generator'>Build the generator matrix of a continuous-time Markov chain</h2><span id='topic+generator'></span>

<h3>Description</h3>

<p>This function builds the <strong>infinitesimal generator matrix</strong> for a <strong>continuous-time Markov chain</strong> from an unconstrained parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generator(param, byrow = FALSE, report = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generator_+3A_param">param</code></td>
<td>
<p>unconstrained parameter vector of length N*(N-1) where N is the number of states of the Markov chain</p>
</td></tr>
<tr><td><code id="generator_+3A_byrow">byrow</code></td>
<td>
<p>logical indicating if the transition probability matrix should be filled by row</p>
</td></tr>
<tr><td><code id="generator_+3A_report">report</code></td>
<td>
<p>logical, indicating whether the generator matrix Q should be reported from the fitted model. Defaults to <code>TRUE</code>, but only works if when automatic differentiation with <code>RTMB</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>infinitesimal generator matrix of dimension c(N,N)
</p>


<h3>See Also</h3>

<p>Other transition probability matrix functions: 
<code><a href="#topic+tpm">tpm</a>()</code>,
<code><a href="#topic+tpm_cont">tpm_cont</a>()</code>,
<code><a href="#topic+tpm_emb">tpm_emb</a>()</code>,
<code><a href="#topic+tpm_emb_g">tpm_emb_g</a>()</code>,
<code><a href="#topic+tpm_g">tpm_g</a>()</code>,
<code><a href="#topic+tpm_p">tpm_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 states: 2 free off-diagonal elements
generator(rep(-1, 2))
# 3 states: 6 free off-diagonal elements
generator(rep(-2, 6))
</code></pre>

<hr>
<h2 id='make_matrices'>Build the design matrix and the penalty matrix for models involving penalised splines based on a formula and a data set</h2><span id='topic+make_matrices'></span>

<h3>Description</h3>

<p>Build the design matrix and the penalty matrix for models involving penalised splines based on a formula and a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_matrices(formula, data, knots = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_matrices_+3A_formula">formula</code></td>
<td>
<p>right side of a formula as used in <code>mgcv</code></p>
</td></tr>
<tr><td><code id="make_matrices_+3A_data">data</code></td>
<td>
<p>data frame containing the variables in the formula</p>
</td></tr>
<tr><td><code id="make_matrices_+3A_knots">knots</code></td>
<td>
<p>optional list containing user specified knot values to be used for basis construction
</p>
<p>For most bases the user simply supplies the knots to be used, which must match up with the k value supplied (note that the number of knots is not always just k).
See <code>mgcv</code> documentation for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the design matrix <code>Z</code>, the penalty matrix <code>S</code>, the <code>formula</code>, the <code>data</code> and the <code>knots</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modmat = make_matrices(~ s(x), data.frame(x = 1:10))
</code></pre>

<hr>
<h2 id='make_matrices_dens'>Build a standardised P-Spline design matrix and the associated P-Spline penalty matrix</h2><span id='topic+make_matrices_dens'></span>

<h3>Description</h3>

<p>This function builds the B-spline design matrix for a given data vector. 
Importantly, the B-spline basis functions are normalised such that the integral of each basis function is 1, hence this basis can be used for spline-based density estimation, when the basis functions are weighted by non-negative weights summing to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_matrices_dens(
  x,
  k,
  type = "real",
  degree = 3,
  npoints = 10000,
  diff_order = 2,
  pow = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_matrices_dens_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="make_matrices_dens_+3A_k">k</code></td>
<td>
<p>number of basis functions</p>
</td></tr>
<tr><td><code id="make_matrices_dens_+3A_type">type</code></td>
<td>
<p>type of the data, either <code>"real"</code> for data on the reals, <code>"positive"</code> for data on the positive reals or <code>"circular"</code> for circular data like angles.</p>
</td></tr>
<tr><td><code id="make_matrices_dens_+3A_degree">degree</code></td>
<td>
<p>degree of the B-spline basis functions, defaults to cubic B-splines</p>
</td></tr>
<tr><td><code id="make_matrices_dens_+3A_npoints">npoints</code></td>
<td>
<p>number of points used in the numerical integration for normalizing the B-spline basis functions</p>
</td></tr>
<tr><td><code id="make_matrices_dens_+3A_diff_order">diff_order</code></td>
<td>
<p>order of differencing used for the P-Spline penalty matrix for each data stream. Defaults to second-order differences.</p>
</td></tr>
<tr><td><code id="make_matrices_dens_+3A_pow">pow</code></td>
<td>
<p>power for polynomial knot spacing
</p>
<p>Such non-equidistant knot spacing is only used for <code>type = "positive"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the design matrix <code>Z</code>, the penalty matrix <code>S</code>, the prediction design matrix <code>Z_predict</code>, the prediction grid <code>xseq</code>, and details for the basis expansion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modmat = make_matrices_dens(x = (-50):50, k = 20)
modmat = make_matrices_dens(x = 1:100, k = 20, type = "positive")
modmat = make_matrices_dens(x = seq(-pi,pi), k = 20, type = "circular")
</code></pre>

<hr>
<h2 id='nessi'>Loch Ness Monster Acceleration Data</h2><span id='topic+nessi'></span>

<h3>Description</h3>

<p>A small group of researchers managed to put an accelerometer on the Loch Ness Monster and collected data for a few days. 
Now we have a data set of the overall dynamic body acceleration (ODBA) of the creature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nessi
</code></pre>


<h3>Format</h3>

<p>A data frame with 5.000 rows and 3 variables:
</p>

<dl>
<dt>ODBA</dt><dd><p>overall dynamci body acceleration</p>
</dd>
<dt>logODBA</dt><dd><p>logarithm of overall dynamic body acceleration</p>
</dd>
<dt>state</dt><dd><p>hidden state variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>Generated for example purposes.
</p>

<hr>
<h2 id='penalty'>Computes penalty based on quadratic form</h2><span id='topic+penalty'></span>

<h3>Description</h3>

<p>This function computes quadratic penalties of the form
</p>
<p style="text-align: center;"><code class="reqn">0.5 \sum_{i} \lambda_i b_i^T S_i b_i,</code>
</p>

<p>with smoothing parameters <code class="reqn">\lambda_i</code>, coefficient vectors <code class="reqn">b_i</code>, and fixed penalty matrices <code class="reqn">S_i</code>.
</p>
<p>It is intended to be used inside the <strong>penalised negative log-likelihood function</strong> when fitting models with penalised splines or simple random effects via <strong>quasi restricted maximum likelihood</strong> (qREML) with the <code><a href="#topic+qreml">qreml</a></code> function.
For <code><a href="#topic+qreml">qreml</a></code> to work, the likelihood function needs to be compatible with the <code>RTMB</code> R package to enable automatic differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty(re_coef, S, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="penalty_+3A_re_coef">re_coef</code></td>
<td>
<p>coefficient vector/ matrix or list of coefficient vectors/ matrices
</p>
<p>Each list entry corresponds to a different smooth/ random effect with its own associated penalty matrix in <code>S</code>.
When several smooths/ random effects of the same kind are present, it is convenient to pass them as a matrix, where each row corresponds to one smooth/ random effect. 
This way all rows can use the same penalty matrix.</p>
</td></tr>
<tr><td><code id="penalty_+3A_s">S</code></td>
<td>
<p>fixed penalty matrix or list of penalty matrices matching the structure of <code>re_coef</code> and also the dimension of the individuals smooths/ random effects</p>
</td></tr>
<tr><td><code id="penalty_+3A_lambda">lambda</code></td>
<td>
<p>penalty strength parameter vector that has a length corresponding to the <strong>total number</strong> of random effects/ spline coefficients in <code>re_coef</code>
</p>
<p>E.g. if <code>re_coef</code> contains one vector and one matrix with 4 rows, then <code>lambda</code> needs to be of length 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Caution:</strong> The formatting of <code>re_coef</code> needs to match the structure of the parameter list in your penalised negative log-likelihood function, 
i.e. you cannot have two random effect vectors of different names (different list elements in the parameter list), combine them into a matrix inside your likelihood and pass the matrix to <code>penalty</code>.
If these are seperate random effects, each with its own name, they need to be passed as a list to <code>penalty</code>. Moreover, the ordering of <code>re_coef</code> needs to match the character vector <code>random</code> specified in <code><a href="#topic+qreml">qreml</a></code>.
</p>


<h3>Value</h3>

<p>returns the penalty value and reports to <code><a href="#topic+qreml">qreml</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qreml">qreml</a></code> for the <strong>qREML</strong> algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with a single random effect
re = rep(0, 5)
S = diag(5)
lambda = 1
penalty(re, S, lambda)

# Example with two random effects, 
# where one element contains two random effects of similar structure
re = list(matrix(0, 2, 5), rep(0, 4))
S = list(diag(5), diag(4))
lambda = c(1,1,2) # length = total number of random effects
penalty(re, S, lambda)

# Full model-fitting example
data = trex[1:1000,] # subset

# initial parameter list
par = list(logmu = log(c(0.3, 1)), # step mean
           logsigma = log(c(0.2, 0.7)), # step sd
           beta0 = c(-2,-2), # state process intercept
           betaspline = matrix(rep(0, 18), nrow = 2)) # state process spline coefs
          
# data object with initial penalty strength lambda
dat = list(step = data$step, # step length
           tod = data$tod, # time of day covariate
           N = 2, # number of states
           lambda = rep(10,2)) # initial penalty strength

# building model matrices
modmat = make_matrices(~ s(tod, bs = "cp"), 
                       data = data.frame(tod = 1:24), 
                       knots = list(tod = c(0,24))) # wrapping points
dat$Z = modmat$Z # spline design matrix
dat$S = modmat$S # penalty matrix

# penalised negative log-likelihood function
pnll = function(par) {
  getAll(par, dat) # makes everything contained available without $
  Gamma = tpm_g(Z, cbind(beta0, betaspline)) # transition probabilities
  delta = stationary_p(Gamma, t = 1) # initial distribution
  mu = exp(logmu) # step mean
  sigma = exp(logsigma) # step sd
  # calculating all state-dependent densities
  allprobs = matrix(1, nrow = length(step), ncol = N)
  ind = which(!is.na(step)) # only for non-NA obs.
  for(j in 1:N) allprobs[ind,j] = dgamma2(step[ind],mu[j],sigma[j])
  -forward_g(delta, Gamma[,,tod], allprobs) +
      penalty(betaspline, S, lambda) # this does all the penalization work
}

# model fitting
mod = qreml(pnll, par, dat, random = "betaspline")
</code></pre>

<hr>
<h2 id='pred_matrix'>Build the prediction design matrix based on new data and model_matrices object created by <code><a href="#topic+make_matrices">make_matrices</a></code></h2><span id='topic+pred_matrix'></span>

<h3>Description</h3>

<p>Build the prediction design matrix based on new data and model_matrices object created by <code><a href="#topic+make_matrices">make_matrices</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_matrix(model_matrices, newdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred_matrix_+3A_model_matrices">model_matrices</code></td>
<td>
<p>model_matrices object as returned from <code><a href="#topic+make_matrices">make_matrices</a></code></p>
</td></tr>
<tr><td><code id="pred_matrix_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the variables in the formula and new data for which to evaluate the basis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prediction design matrix for <code>newdata</code> with the same basis as used for <code>model_matrices</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modmat = make_matrices(~ s(x), data.frame(x = 1:10))
Z_predict = pred_matrix(modmat, data.frame(x = 1:10 - 0.5))
</code></pre>

<hr>
<h2 id='pseudo_res'>Calculate pseudo-residuals</h2><span id='topic+pseudo_res'></span>

<h3>Description</h3>

<p>For HMMs, pseudo-residuals are used to assess the goodness-of-fit of the model. 
These are based on the cumulative distribution function (CDF)
</p>
<p style="text-align: center;"><code class="reqn">F_{X_t}(x_t) = F(x_t \mid x_1, \dots, x_{t-1}, x_{t+1}, \dots, x_T)</code>
</p>

<p>and can be used to quantify whether an observation is extreme relative to its model-implied distribution.
</p>
<p>This function calculates such residuals via probability integral transform, based on the local state probabilities obtained by <code><a href="#topic+stateprobs">stateprobs</a></code> or <code><a href="#topic+stateprobs_g">stateprobs_g</a></code> and the respective parametric family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_res(
  obs,
  dist,
  par,
  stateprobs = NULL,
  mod = NULL,
  normal = TRUE,
  discrete = NULL,
  randomise = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo_res_+3A_obs">obs</code></td>
<td>
<p>vector of continuous-valued observations (of length n)</p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_dist">dist</code></td>
<td>
<p>character string specifying which parametric CDF to use (e.g., <code>"norm"</code> for normal or <code>"pois"</code> for Poisson)</p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_par">par</code></td>
<td>
<p>named parameter list for the parametric CDF
</p>
<p>Names need to correspond to the parameter names in the specified distribution (e.g. <code>list(mean = c(1,2), sd = c(1,1))</code> for a normal distribution and 2 states).
This argument is as flexible as the parametric distribution allows. For example you can have a matrix of parameters with one row for each observation and one column for each state.</p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_stateprobs">stateprobs</code></td>
<td>
<p>matrix of local state probabilities for each observation (of dimension c(n,N), where N is the number of states) as computed by <code><a href="#topic+stateprobs">stateprobs</a></code>, <code><a href="#topic+stateprobs_g">stateprobs_g</a></code> or <code><a href="#topic+stateprobs_p">stateprobs_p</a></code></p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_mod">mod</code></td>
<td>
<p>optional model object containing initial distribution <code>delta</code>, transition probability matrix <code>Gamma</code>, matrix of state-dependent probabilities <code>allprobs</code>, and potentially a <code>trackID</code> variable
</p>
<p>If you are using automatic differentiation either with <code>RTMB::MakeADFun</code> or <code><a href="#topic+qreml">qreml</a></code> and include <code><a href="#topic+forward">forward</a></code>, <code><a href="#topic+forward_g">forward_g</a></code> or <code><a href="#topic+forward_p">forward_p</a></code> in your likelihood function, the objects needed for state decoding are automatically reported after model fitting.
Hence, you can pass the model object obtained from running <code>RTMB::report()</code> or from <code><a href="#topic+qreml">qreml</a></code> directly to this function and avoid calculating local state proabilities manually.
In this case, a call should look like <code>pseudo_res(obs, "norm", par, mod = mod)</code>.</p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_normal">normal</code></td>
<td>
<p>logical, if <code>TRUE</code>, returns Gaussian pseudo residuals
</p>
<p>These will be approximately standard normally distributed if the model is correct.</p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_discrete">discrete</code></td>
<td>
<p>logical, if <code>TRUE</code>, computes discrete pseudo residuals (which slightly differ in their definition)
</p>
<p>By default, will be determined using <code>dist</code> argument, but only works for standard discrete distributions.
When used with a special discrete distribution, set to <code>TRUE</code> manually. See <code><a href="#topic+pseudo_res_discrete">pseudo_res_discrete</a></code> for details.</p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_randomise">randomise</code></td>
<td>
<p>for discrete pseudo residuals only. Logical, if <code>TRUE</code>, return randomised pseudo residuals. Recommended for discrete observations.</p>
</td></tr>
<tr><td><code id="pseudo_res_+3A_seed">seed</code></td>
<td>
<p>for discrete pseudo residuals only. Integer, seed for random number generation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used for discrete pseudo-residuals, this function is just a wrapper for <code><a href="#topic+pseudo_res_discrete">pseudo_res_discrete</a></code>.
</p>


<h3>Value</h3>

<p>vector of pseudo residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## continuous-valued observations
obs = rnorm(100)
stateprobs = matrix(0.5, nrow = 100, ncol = 2)
par = list(mean = c(1,2), sd = c(1,1))
pres = pseudo_res(obs, "norm", par, stateprobs)

## discrete-valued observations
obs = rpois(100, lambda = 1)
stateprobs = matrix(0.5, nrow = 100, ncol = 2)
par = list(lambda = c(1,2))
pres = pseudo_res(obs, "pois", par, stateprobs)
</code></pre>

<hr>
<h2 id='pseudo_res_discrete'>Calculate pseudo-residuals for discrete-valued observations</h2><span id='topic+pseudo_res_discrete'></span>

<h3>Description</h3>

<p>For HMMs, pseudo-residuals are used to assess the goodness-of-fit of the model. 
These are based on the cumulative distribution function (CDF)
</p>
<p style="text-align: center;"><code class="reqn">F_{X_t}(x_t) = F(x_t \mid x_1, \dots, x_{t-1}, x_{t+1}, \dots, x_T)</code>
</p>

<p>and can be used to quantify whether an observation is extreme relative to its model-implied distribution.
</p>
<p>This function calculates such residuals for <strong>discrete-valued</strong> observations, based on the local state probabilities obtained by <code><a href="#topic+stateprobs">stateprobs</a></code> or <code><a href="#topic+stateprobs_g">stateprobs_g</a></code> and the respective parametric family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_res_discrete(
  obs,
  dist,
  par,
  stateprobs,
  normal = TRUE,
  randomise = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo_res_discrete_+3A_obs">obs</code></td>
<td>
<p>vector of discrete-valued observations (of length n)</p>
</td></tr>
<tr><td><code id="pseudo_res_discrete_+3A_dist">dist</code></td>
<td>
<p>character string specifying which parametric CDF to use (e.g., <code>"norm"</code> for normal or <code>"pois"</code> for Poisson)</p>
</td></tr>
<tr><td><code id="pseudo_res_discrete_+3A_par">par</code></td>
<td>
<p>named parameter list for the parametric CDF
</p>
<p>Names need to correspond to the parameter names in the specified distribution (e.g. <code>list(mean = c(1,2), sd = c(1,1))</code> for a normal distribution and 2 states).
This argument is as flexible as the parametric distribution allows. For example you can have a matrix of parameters with one row for each observation and one column for each state.</p>
</td></tr>
<tr><td><code id="pseudo_res_discrete_+3A_stateprobs">stateprobs</code></td>
<td>
<p>matrix of local state probabilities for each observation (of dimension c(n,N), where N is the number of states)</p>
</td></tr>
<tr><td><code id="pseudo_res_discrete_+3A_normal">normal</code></td>
<td>
<p>logical, if <code>TRUE</code>, returns Gaussian pseudo residuals
</p>
<p>These will be approximately standard normally distributed if the model is correct.</p>
</td></tr>
<tr><td><code id="pseudo_res_discrete_+3A_randomise">randomise</code></td>
<td>
<p>logical, if <code>TRUE</code>, return randomised pseudo residuals. Recommended for discrete observations.</p>
</td></tr>
<tr><td><code id="pseudo_res_discrete_+3A_seed">seed</code></td>
<td>
<p>integer, seed for random number generation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For discrete observations, calculating pseudo residuals is slightly more involved, as the CDF is a step function.
Therefore, one can calculate the lower and upper CDF values for each observation. 
By default, this function does exactly that and then randomly samples the interval in between to give approximately Gaussian psuedo-residuals.
If <code>randomise</code> is set to <code>FALSE</code>, the lower, upper and mean pseudo-residuasl are returned.
</p>


<h3>Value</h3>

<p>vector of pseudo residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs = rpois(100, lambda = 1)
stateprobs = matrix(0.5, nrow = 100, ncol = 2)
par = list(lambda = c(1,2))
pres = pseudo_res_discrete(obs, "pois", par, stateprobs)
</code></pre>

<hr>
<h2 id='qreml'>Quasi restricted maximum likelihood (qREML) algorithm for models with penalised splines or simple i.i.d. random effects</h2><span id='topic+qreml'></span>

<h3>Description</h3>

<p>This algorithm can be used very flexibly to fit statistical models that involve <strong>penalised splines</strong> or simple <strong>i.i.d. random effects</strong>, i.e. that have penalties of the form
</p>
<p style="text-align: center;"><code class="reqn">0.5 \sum_{i} \lambda_i b_i^T S_i b_i,</code>
</p>

<p>with smoothing parameters <code class="reqn">\lambda_i</code>, coefficient vectors <code class="reqn">b_i</code>, and fixed penalty matrices <code class="reqn">S_i</code>.
</p>
<p>The <strong>qREML</strong> algorithm is typically much faster than REML or marginal ML using the full Laplace approximation method, but may be slightly less accurate regarding the estimation of the penalty strength parameters.
</p>
<p>Under the hood, <code>qreml</code> uses the R package <code>RTMB</code> for automatic differentiation in the inner optimisation.
The user has to specify the <strong>penalised negative log-likelihood function</strong> <code>pnll</code> structured as dictated by <code>RTMB</code> and use the <code><a href="#topic+penalty">penalty</a></code> function to compute the quadratic-form penalty inside the likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qreml(
  pnll,
  par,
  dat,
  random,
  map = NULL,
  psname = "lambda",
  alpha = 0.15,
  smoothing = 1,
  maxiter = 100,
  tol = 1e-04,
  control = list(reltol = 1e-10, maxit = 1000),
  silent = 1,
  joint_unc = TRUE,
  saveall = FALSE,
  epsilon = c(0.01, 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qreml_+3A_pnll">pnll</code></td>
<td>
<p>penalised negative log-likelihood function that is structured as dictated by <code>RTMB</code> and uses the <code><a href="#topic+penalty">penalty</a></code> function from <code>LaMa</code> to compute the penalty
</p>
<p>Needs to be a function of the named list of initial parameters <code>par</code> only.</p>
</td></tr>
<tr><td><code id="qreml_+3A_par">par</code></td>
<td>
<p>named list of initial parameters
</p>
<p>The random effects/ spline coefficients can be vectors or matrices, the latter summarising several random effects of the same structure, each one being a row in the matrix.</p>
</td></tr>
<tr><td><code id="qreml_+3A_dat">dat</code></td>
<td>
<p>initial data list that contains the data used in the likelihood function, hyperparameters, and the <strong>initial penalty strength</strong> vector
</p>
<p>If the initial penalty strength vector is <strong>not</strong> called <code>lambda</code>, the name it has in <code>dat</code> needs to be specified using the <code>psname</code> argument below.
Its length needs to match the to the total number of random effects.</p>
</td></tr>
<tr><td><code id="qreml_+3A_random">random</code></td>
<td>
<p>vector of names of the random effects/ penalised parameters in <code>par</code>
</p>
<p><strong>Caution:</strong> The ordering of <code>random</code> needs to match the order of the random effects passed to <code><a href="#topic+penalty">penalty</a></code> inside the likelihood function.</p>
</td></tr>
<tr><td><code id="qreml_+3A_map">map</code></td>
<td>
<p>optional map for fixed effects in the likelihood function</p>
</td></tr>
<tr><td><code id="qreml_+3A_psname">psname</code></td>
<td>
<p>optional name given to the penalty strength parameter in <code>dat</code>. Defaults to <code>"lambda"</code>.</p>
</td></tr>
<tr><td><code id="qreml_+3A_alpha">alpha</code></td>
<td>
<p>optional hyperparamater for exponential smoothing of the penalty strengths.
</p>
<p>For larger values smoother convergence is to be expected but the algorithm may need more iterations.</p>
</td></tr>
<tr><td><code id="qreml_+3A_smoothing">smoothing</code></td>
<td>
<p>optional scaling factor for the final penalty strength parameters
</p>
<p>Increasing this beyond one will lead to a smoother final model. Can be an integer or a vector of length equal to the length of the penalty strength parameter.</p>
</td></tr>
<tr><td><code id="qreml_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations in the outer optimisation over the penalty strength parameters.</p>
</td></tr>
<tr><td><code id="qreml_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance for the penalty strength parameters.</p>
</td></tr>
<tr><td><code id="qreml_+3A_control">control</code></td>
<td>
<p>list of control parameters for <code><a href="stats.html#topic+optim">optim</a></code> to use in the inner optimisation. Here, <code>optim</code> uses the <code>BFGS</code> method which cannot be changed.
</p>
<p>We advise against changing the default values of <code>reltol</code> and <code>maxit</code> as this can decrease the accuracy of the Laplace approximation.</p>
</td></tr>
<tr><td><code id="qreml_+3A_silent">silent</code></td>
<td>
<p>integer silencing level: 0 corresponds to full printing of inner and outer iterations, 1 to printing of outer iterations only, and 2 to no printing.</p>
</td></tr>
<tr><td><code id="qreml_+3A_joint_unc">joint_unc</code></td>
<td>
<p>logical, if <code>TRUE</code>, joint <code>RTMB</code> object is returned allowing for joint uncertainty quantification</p>
</td></tr>
<tr><td><code id="qreml_+3A_saveall">saveall</code></td>
<td>
<p>logical, if <code>TRUE</code>, then all model objects from each iteration are saved in the final model object.</p>
</td></tr>
<tr><td><code id="qreml_+3A_epsilon">epsilon</code></td>
<td>
<p>vector of two values specifying the cycling detection parameters. If the relative change of the new penalty strength to the previous one is larger than <code>epsilon[1]</code> but the change to the one before is smaller than <code>epsilon[2]</code>, the algorithm will average the two last values to prevent cycling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a model list influenced by the users report statements in <code>pnll</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penalty">penalty</a></code> to compute the penalty inside the likelihood function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = trex[1:1000,] # subset

# initial parameter list
par = list(logmu = log(c(0.3, 1)), # step mean
           logsigma = log(c(0.2, 0.7)), # step sd
           beta0 = c(-2,-2), # state process intercept
           betaspline = matrix(rep(0, 18), nrow = 2)) # state process spline coefs
          
# data object with initial penalty strength lambda
dat = list(step = data$step, # step length
           tod = data$tod, # time of day covariate
           N = 2, # number of states
           lambda = rep(10,2)) # initial penalty strength

# building model matrices
modmat = make_matrices(~ s(tod, bs = "cp"), 
                       data = data.frame(tod = 1:24), 
                       knots = list(tod = c(0,24))) # wrapping points
dat$Z = modmat$Z # spline design matrix
dat$S = modmat$S # penalty matrix

# penalised negative log-likelihood function
pnll = function(par) {
  getAll(par, dat) # makes everything contained available without $
  Gamma = tpm_g(Z, cbind(beta0, betaspline), ad = TRUE) # transition probabilities
  delta = stationary_p(Gamma, t = 1, ad = TRUE) # initial distribution
  mu = exp(logmu) # step mean
  sigma = exp(logsigma) # step sd
  # calculating all state-dependent densities
  allprobs = matrix(1, nrow = length(step), ncol = N)
  ind = which(!is.na(step)) # only for non-NA obs.
  for(j in 1:N) allprobs[ind,j] = dgamma2(step[ind],mu[j],sigma[j])
  -forward_g(delta, Gamma[,,tod], allprobs) +
      penalty(betaspline, S, lambda) # this does all the penalization work
}

# model fitting
mod = qreml(pnll, par, dat, random = "betaspline")
</code></pre>

<hr>
<h2 id='sdreportMC'>Monte Carlo version of <code>sdreport</code></h2><span id='topic+sdreportMC'></span>

<h3>Description</h3>

<p>After optimisation of an AD model, <code>sdreportMC</code> can be used to calculate samples of confidence intervals of all model parameters and <code>REPORT()</code>ed quantities
including nonlinear functions of random effects and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdreportMC(
  obj,
  what,
  Hessian = NULL,
  CI = FALSE,
  n = 1000,
  probs = c(0.025, 0.975)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdreportMC_+3A_obj">obj</code></td>
<td>
<p>object returned by <code>MakeADFun()</code> after optimisation</p>
</td></tr>
<tr><td><code id="sdreportMC_+3A_what">what</code></td>
<td>
<p>vector of strings with names of parameters and <code>REPORT()</code>ed quantities to be reported</p>
</td></tr>
<tr><td><code id="sdreportMC_+3A_hessian">Hessian</code></td>
<td>
<p>optional Hessian matrix. If not provided, it will be computed from the object</p>
</td></tr>
<tr><td><code id="sdreportMC_+3A_ci">CI</code></td>
<td>
<p>logical. If <code>TRUE</code>, only confidence intervals instead of samples will be returned</p>
</td></tr>
<tr><td><code id="sdreportMC_+3A_n">n</code></td>
<td>
<p>number of samples to draw from the multivariate normal distribution of the MLE</p>
</td></tr>
<tr><td><code id="sdreportMC_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities for the confidence intervals (ignored if no CIs are computed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Caution:</strong> Currently does not work for models with fixed parameters (i.e. that use the <code>map</code> argument of <code>MakeADFun</code>.)
</p>


<h3>Value</h3>

<p>named list corresponding to the elements of <code>what</code>. Each element has the structure of the corresponding quantity with an additional dimension added for the samples.
For example, if a quantity is a vector, the list contains a matrix. If a quantity is a matrix, the list contains an array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fitting an HMM to the trex data and running sdreportMC
## negative log-likelihood function
nll = function(par) {
  getAll(par, dat) # makes everything contained available without $
  Gamma = tpm(eta) # computes transition probability matrix from unconstrained eta
  delta = stationary(Gamma) # computes stationary distribution
  # exponentiating because all parameters strictly positive
  mu = exp(logmu)
  sigma = exp(logsigma)
  kappa = exp(logkappa)
  # reporting statements for sdreportMC
  REPORT(mu)
  REPORT(sigma)
  REPORT(kappa)
  # calculating all state-dependent densities
  allprobs = matrix(1, nrow = length(step), ncol = N)
  ind = which(!is.na(step) &amp; !is.na(angle)) # only for non-NA obs.
  for(j in 1:N){
    allprobs[ind,j] = dgamma2(step[ind],mu[j],sigma[j])*dvm(angle[ind],0,kappa[j])
  }
  -forward(delta, Gamma, allprobs) # simple forward algorithm
}

## initial parameter list
par = list(
 logmu = log(c(0.3, 1)),       # initial means for step length (log-transformed)
  logsigma = log(c(0.2, 0.7)), # initial sds for step length (log-transformed)
  logkappa = log(c(0.2, 0.7)), # initial concentration for turning angle (log-transformed)
  eta = rep(-2, 2)             # initial t.p.m. parameters (on logit scale)
)   
## data and hyperparameters
dat = list(
  step = trex$step[1:500],   # hourly step lengths
  angle = trex$angle[1:500], # hourly turning angles
  N = 2
)

## creating AD function
obj = MakeADFun(nll, par, silent = TRUE) # creating the objective function

## optimising
opt = nlminb(obj$par, obj$fn, obj$gr) # optimization

## running sdreportMC
# `mu` has report statement, `delta` is automatically reported by `forward()`
sdrMC = sdreportMC(obj, 
                   what = c("mu", "delta"), 
                   n = 50)
dim(sdrMC$delta)
# now a matrix with 50 samples (rows)
</code></pre>

<hr>
<h2 id='skewnorm'>Skew normal distribution</h2><span id='topic+skewnorm'></span><span id='topic+dskewnorm'></span><span id='topic+pskewnorm'></span><span id='topic+qskewnorm'></span><span id='topic+rskewnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
the skew normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dskewnorm(x, xi = 0, omega = 1, alpha = 0, log = FALSE)

pskewnorm(q, xi = 0, omega = 1, alpha = 0, ...)

qskewnorm(p, xi = 0, omega = 1, alpha = 0, ...)

rskewnorm(n, xi = 0, omega = 1, alpha = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewnorm_+3A_x">x</code>, <code id="skewnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="skewnorm_+3A_xi">xi</code></td>
<td>
<p>location parameter</p>
</td></tr>
<tr><td><code id="skewnorm_+3A_omega">omega</code></td>
<td>
<p>scale parameter, must be positive.</p>
</td></tr>
<tr><td><code id="skewnorm_+3A_alpha">alpha</code></td>
<td>
<p>skewness parameter, +/- <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="skewnorm_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities/ densities <code class="reqn">p</code> are returned as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="skewnorm_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the <code>sn</code> package functions for <code>pskewnorm</code> and <code>qskewnorm</code>.</p>
</td></tr>
<tr><td><code id="skewnorm_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="skewnorm_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of <code>dskewnorm</code> allows for automatic differentiation with <code>RTMB</code> while the other functions are imported from the <code>sn</code> package.
</p>


<h3>Value</h3>

<p><code>dskewnorm</code> gives the density, <code>pskewnorm</code> gives the distribution function, <code>qskewnorm</code> gives the quantile function, and <code>rskewnorm</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = rskewnorm(1)
d = dskewnorm(x)
p = pskewnorm(x)
q = qskewnorm(p)
</code></pre>

<hr>
<h2 id='stateprobs'>Calculate conditional local state probabilities for homogeneous HMMs</h2><span id='topic+stateprobs'></span>

<h3>Description</h3>

<p>Computes
</p>
<p style="text-align: center;"><code class="reqn">\Pr(S_t = j \mid X_1, ..., X_T)</code>
</p>

<p>for homogeneous HMMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateprobs(delta, Gamma, allprobs, trackID = NULL, mod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stateprobs_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="stateprobs_+3A_gamma">Gamma</code></td>
<td>
<p>transition probability matrix of dimension c(N,N), or array of k transition probability matrices of dimension c(N,N,k), if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="stateprobs_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="stateprobs_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of length n containing IDs
</p>
<p>If provided, the total log-likelihood will be the sum of each track's likelihood contribution.
In this case, <code>Gamma</code> can be a matrix, leading to the same transition probabilities for each track, or an array of dimension c(N,N,k), with one (homogeneous) transition probability matrix for each track.
Furthermore, instead of a single vector <code>delta</code> corresponding to the initial distribution, a <code>delta</code> matrix of initial distributions, of dimension c(k,N), can be provided, such that each track starts with it's own initial distribution.</p>
</td></tr>
<tr><td><code id="stateprobs_+3A_mod">mod</code></td>
<td>
<p>optional model object containing initial distribution <code>delta</code>, transition probability matrix <code>Gamma</code>, matrix of state-dependent probabilities <code>allprobs</code>, and potentially a <code>trackID</code> variable
</p>
<p>If you are using automatic differentiation either with <code>RTMB::MakeADFun</code> or <code><a href="#topic+qreml">qreml</a></code> and include <code><a href="#topic+forward">forward</a></code> in your likelihood function, the objects needed for state decoding are automatically reported after model fitting.
Hence, you can pass the model object obtained from running <code>RTMB::report()</code> or from <code><a href="#topic+qreml">qreml</a></code> directly to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of conditional state probabilities of dimension c(n,N)
</p>


<h3>See Also</h3>

<p>Other decoding functions: 
<code><a href="#topic+stateprobs_g">stateprobs_g</a>()</code>,
<code><a href="#topic+stateprobs_p">stateprobs_p</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code>,
<code><a href="#topic+viterbi_g">viterbi_g</a>()</code>,
<code><a href="#topic+viterbi_p">viterbi_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gamma = tpm(c(-1,-2))
delta = stationary(Gamma)
allprobs = matrix(runif(200), nrow = 100, ncol = 2)

probs = stateprobs(delta, Gamma, allprobs)
</code></pre>

<hr>
<h2 id='stateprobs_g'>Calculate conditional local state probabilities for inhomogeneous HMMs</h2><span id='topic+stateprobs_g'></span>

<h3>Description</h3>

<p>Computes
</p>
<p style="text-align: center;"><code class="reqn">\Pr(S_t = j \mid X_1, ..., X_T)</code>
</p>

<p>for inhomogeneous HMMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateprobs_g(delta, Gamma, allprobs, trackID = NULL, mod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stateprobs_g_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="stateprobs_g_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices of dimension c(N,N,n-1), as in a time series of length n, there are only n-1 transitions
</p>
<p>If an array of dimension c(N,N,n) for a single track is provided, the first slice will be ignored.
</p>
<p>If <code>trackID</code> is provided, <code>Gamma</code> needs to be an array of dimension c(N,N,n), where n is the number of rows in <code>allprobs</code>. Then for each track the first transition matrix will be ignored.</p>
</td></tr>
<tr><td><code id="stateprobs_g_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="stateprobs_g_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of k track IDs, if multiple tracks need to be decoded separately</p>
</td></tr>
<tr><td><code id="stateprobs_g_+3A_mod">mod</code></td>
<td>
<p>optional model object containing initial distribution <code>delta</code>, transition probability matrix <code>Gamma</code>, matrix of state-dependent probabilities <code>allprobs</code>, and potentially a <code>trackID</code> variable
</p>
<p>If you are using automatic differentiation either with <code>RTMB::MakeADFun</code> or <code><a href="#topic+qreml">qreml</a></code> and include <code><a href="#topic+forward_g">forward_g</a></code> in your likelihood function, the objects needed for state decoding are automatically reported after model fitting.
Hence, you can pass the model object obtained from running <code>RTMB::report()</code> or from <code><a href="#topic+qreml">qreml</a></code> directly to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of conditional state probabilities of dimension c(n,N)
</p>


<h3>See Also</h3>

<p>Other decoding functions: 
<code><a href="#topic+stateprobs">stateprobs</a>()</code>,
<code><a href="#topic+stateprobs_p">stateprobs_p</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code>,
<code><a href="#topic+viterbi_g">viterbi_g</a>()</code>,
<code><a href="#topic+viterbi_p">viterbi_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gamma = tpm_g(runif(99), matrix(c(-1,-1,1,-2), nrow = 2, byrow = TRUE))
delta = c(0.5, 0.5)
allprobs = matrix(runif(200), nrow = 100, ncol = 2)

probs = stateprobs_g(delta, Gamma, allprobs)
</code></pre>

<hr>
<h2 id='stateprobs_p'>Calculate conditional local state probabilities for periodically inhomogeneous HMMs</h2><span id='topic+stateprobs_p'></span>

<h3>Description</h3>

<p>Computes
</p>
<p style="text-align: center;"><code class="reqn">\Pr(S_t = j \mid X_1, ..., X_T)</code>
</p>

<p>for periodically inhomogeneous HMMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateprobs_p(delta, Gamma, allprobs, tod, trackID = NULL, mod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stateprobs_p_+3A_delta">delta</code></td>
<td>
<p>initial or stationary distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided
</p>
<p>This could e.g. be the periodically stationary distribution (for each track) as computed by <code><a href="#topic+stationary_p">stationary_p</a></code>.</p>
</td></tr>
<tr><td><code id="stateprobs_p_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices for each time point in the cycle of dimension c(N,N,L), where L is the length of the cycle.</p>
</td></tr>
<tr><td><code id="stateprobs_p_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="stateprobs_p_+3A_tod">tod</code></td>
<td>
<p>(Integer valued) variable for cycle indexing in 1, ..., L, mapping the data index to a generalised time of day (length n).
For half-hourly data L = 48. It could, however, also be day of year for daily data and L = 365.</p>
</td></tr>
<tr><td><code id="stateprobs_p_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of k track IDs, if multiple tracks need to be decoded separately</p>
</td></tr>
<tr><td><code id="stateprobs_p_+3A_mod">mod</code></td>
<td>
<p>optional model object containing initial distribution <code>delta</code>, transition probability matrix <code>Gamma</code>, matrix of state-dependent probabilities <code>allprobs</code>, and potentially a <code>trackID</code> variable
</p>
<p>If you are using automatic differentiation either with <code>RTMB::MakeADFun</code> or <code><a href="#topic+qreml">qreml</a></code> and include <code><a href="#topic+forward_p">forward_p</a></code> in your likelihood function, the objects needed for state decoding are automatically reported after model fitting.
Hence, you can pass the model object obtained from running <code>RTMB::report()</code> or from <code><a href="#topic+qreml">qreml</a></code> directly to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of conditional state probabilities of dimension c(n,N)
</p>


<h3>See Also</h3>

<p>Other decoding functions: 
<code><a href="#topic+stateprobs">stateprobs</a>()</code>,
<code><a href="#topic+stateprobs_g">stateprobs_g</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code>,
<code><a href="#topic+viterbi_g">viterbi_g</a>()</code>,
<code><a href="#topic+viterbi_p">viterbi_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L = 24
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma = tpm_p(1:L, L, beta, degree = 1)
delta = stationary_p(Gamma, 1)
allprobs = matrix(runif(200), nrow = 100, ncol = 2)
tod = rep(1:24, 5)[1:100]

probs = stateprobs_p(delta, Gamma, allprobs, tod)
</code></pre>

<hr>
<h2 id='stationary'>Compute the stationary distribution of a homogeneous Markov chain</h2><span id='topic+stationary'></span>

<h3>Description</h3>

<p>A homogeneous, finite state Markov chain that is irreducible and aperiodic converges to a unique stationary distribution, here called <code class="reqn">\delta</code>.
As it is stationary, this distribution satisfies
</p>
<p style="text-align: center;"><code class="reqn">\delta \Gamma = \delta,</code>
</p>
<p> subject to <code class="reqn">\sum_{j=1}^N \delta_j = 1</code>,
where <code class="reqn">\Gamma</code> is the transition probability matrix. 
This function solves the linear system of equations above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary(Gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_+3A_gamma">Gamma</code></td>
<td>
<p>transition probability matrix of dimension c(N,N)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stationary distribution of the Markov chain with the given transition probability matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpm">tpm</a></code> to create a transition probabilty matrix using the multinomial logistic link (softmax)
</p>
<p>Other stationary distribution functions: 
<code><a href="#topic+stationary_cont">stationary_cont</a>()</code>,
<code><a href="#topic+stationary_p">stationary_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gamma = tpm(c(rep(-2,3), rep(-3,3)))
delta = stationary(Gamma)
</code></pre>

<hr>
<h2 id='stationary_cont'>Compute the stationary distribution of a continuous-time Markov chain</h2><span id='topic+stationary_cont'></span>

<h3>Description</h3>

<p>A well-behaved continuous-time Markov chain converges to a unique stationary distribution, here called <code class="reqn">\pi</code>.
This distribution satisfies
</p>
<p style="text-align: center;"><code class="reqn">\pi Q = 0,</code>
</p>
<p> subject to <code class="reqn">\sum_{j=1}^N \pi_j = 1</code>,
where <code class="reqn">Q</code> is the infinitesimal generator of the Markov chain.
This function solves the linear system of equations above for a given generator matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary_cont(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_cont_+3A_q">Q</code></td>
<td>
<p>infinitesimal generator matrix of dimension c(N,N)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stationary distribution of the continuous-time Markov chain with given generator matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generator">generator</a></code> to create a generator matrix
</p>
<p>Other stationary distribution functions: 
<code><a href="#topic+stationary">stationary</a>()</code>,
<code><a href="#topic+stationary_p">stationary_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q = generator(c(-2,-2))
Pi = stationary_cont(Q)
</code></pre>

<hr>
<h2 id='stationary_p'>Compute the periodically stationary distribution of a periodically inhomogeneous Markov chain</h2><span id='topic+stationary_p'></span>

<h3>Description</h3>

<p>If the transition probability matrix of an inhomogeneous Markov chain varies only periodically (with period length <code class="reqn">L</code>), it converges to a so-called periodically stationary distribution. 
This happens, because the thinned Markov chain, which has a full cycle as each time step, has homogeneous transition probability matrix
</p>
<p style="text-align: center;"><code class="reqn">\Gamma_t = \Gamma^{(t)} \Gamma^{(t+1)} \dots \Gamma^{(t+L-1)}</code>
</p>
<p> for all <code class="reqn">t = 1, \dots, L.</code>
The stationary distribution for time <code class="reqn">t</code> satifies <code class="reqn">\delta^{(t)} \Gamma_t = \delta^{(t)}</code>.
</p>
<p>This function calculates said periodically stationary distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary_p(Gamma, t = NULL, ad = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_p_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices of dimension c(N,N,L)</p>
</td></tr>
<tr><td><code id="stationary_p_+3A_t">t</code></td>
<td>
<p>integer index of the time point in the cycle, for which to calculate the stationary distribution
</p>
<p>If <code>t</code> is not provided, the function calculates all stationary distributions for each time point in the cycle.</p>
</td></tr>
<tr><td><code id="stationary_p_+3A_ad">ad</code></td>
<td>
<p>optional logical, indicating whether automatic differentiation with <code>RTMB</code> should be used. By default, the function determines this itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either the periodically stationary distribution at time t or all periodically stationary distributions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tpm_p">tpm_p</a></code> and <code><a href="#topic+tpm_g">tpm_g</a></code> to create multiple transition matrices based on a cyclic variable or design matrix
</p>
<p>Other stationary distribution functions: 
<code><a href="#topic+stationary">stationary</a>()</code>,
<code><a href="#topic+stationary_cont">stationary_cont</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting parameters for trigonometric link
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma = tpm_p(beta = beta, degree = 1)
# periodically stationary distribution for specific time point
delta = stationary_p(Gamma, 4)

# all periodically stationary distributions
Delta = stationary_p(Gamma)
</code></pre>

<hr>
<h2 id='stationary_p_sparse'>Sparse version of <code><a href="#topic+stationary_p">stationary_p</a></code></h2><span id='topic+stationary_p_sparse'></span>

<h3>Description</h3>

<p>This is function computes the periodically stationary distribution of a Markov chain given a list of L <strong>sparse</strong> transition probability matrices.
Compatible with automatic differentiation by <code>RTMB</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary_p_sparse(Gamma, t = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_p_sparse_+3A_gamma">Gamma</code></td>
<td>
<p>sist of length L containing sparse transition probability matrices for one cycle.</p>
</td></tr>
<tr><td><code id="stationary_p_sparse_+3A_t">t</code></td>
<td>
<p>integer index of the time point in the cycle, for which to calculate the stationary distribution
If t is not provided, the function calculates all stationary distributions for each time point in the cycle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either the periodically stationary distribution at time t or all periodically stationary distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## periodic HSMM example (here the approximating tpm is sparse)
N = 2 # number of states
L = 24 # cycle length
# time-varying mean dwell times
Z = trigBasisExp(1:L) # trigonometric basis functions design matrix
beta = matrix(c(2, 2, 0.1, -0.1, -0.2, 0.2), nrow = 2)
Lambda = exp(cbind(1, Z) %*% t(beta))
sizes = c(20, 20) # approximating chain with 40 states
# state dwell-time distributions
dm = lapply(1:N, function(i) sapply(1:sizes[i]-1, dpois, lambda = Lambda[,i]))
omega = matrix(c(0,1,1,0), nrow = N, byrow = TRUE) # embedded t.p.m.

# calculating extended-state-space t.p.m.s
Gamma = tpm_phsmm(omega, dm)
# Periodically stationary distribution for specific time point
delta = stationary_p_sparse(Gamma, 4)

# All periodically stationary distributions
Delta = stationary_p_sparse(Gamma)
</code></pre>

<hr>
<h2 id='stationary_sparse'>Sparse version of <code><a href="#topic+stationary">stationary</a></code></h2><span id='topic+stationary_sparse'></span>

<h3>Description</h3>

<p>This is function computes the stationary distribution of a Markov chain with a given <strong>sparse</strong> transition probability matrix.
Compatible with automatic differentiation by <code>RTMB</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary_sparse(Gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_sparse_+3A_gamma">Gamma</code></td>
<td>
<p>sparse transition probability matrix of dimension c(N,N)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stationary distribution of the Markov chain with the given transition probability matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## HSMM example (here the approximating tpm is sparse)
# building the t.p.m. of the embedded Markov chain
omega = matrix(c(0,1,1,0), nrow = 2, byrow = TRUE)
# defining state aggregate sizes
sizes = c(20, 30)
# defining state dwell-time distributions
lambda = c(5, 11)
dm = list(dpois(1:sizes[1]-1, lambda[1]), dpois(1:sizes[2]-1, lambda[2]))
# calculating extended-state-space t.p.m.
Gamma = tpm_hsmm(omega, dm)
delta = stationary_sparse(Gamma)
</code></pre>

<hr>
<h2 id='tpm'>Build the transition probability matrix from unconstrained parameter vector</h2><span id='topic+tpm'></span>

<h3>Description</h3>

<p>Markov chains are parametrised in terms of a transition probability matrix <code class="reqn">\Gamma</code>, for which each row contains a conditional probability distribution of the next state given the current state.
Hence, each row has entries between 0 and 1 that need to sum to one. 
</p>
<p>For numerical optimisation, we parametrise in terms of unconstrained parameters, thus this function computes said matrix from an unconstrained parameter vector via the inverse multinomial logistic link (also known as softmax) applied to each row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm(param, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_+3A_param">param</code></td>
<td>
<p>unconstrained parameter vector of length N*(N-1) where N is the number of states of the Markov chain</p>
</td></tr>
<tr><td><code id="tpm_+3A_byrow">byrow</code></td>
<td>
<p>logical indicating if the transition probability matrix should be filled by row
</p>
<p>Defaults to <code>FALSE</code>, but should be set to <code>TRUE</code> if one wants to work with a matrix of beta parameters returned by popular HMM packages like <code>moveHMM</code>, <code>momentuHMM</code>, or <code>hmmTMB</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transition probability matrix of dimension c(N,N)
</p>


<h3>See Also</h3>

<p>Other transition probability matrix functions: 
<code><a href="#topic+generator">generator</a>()</code>,
<code><a href="#topic+tpm_cont">tpm_cont</a>()</code>,
<code><a href="#topic+tpm_emb">tpm_emb</a>()</code>,
<code><a href="#topic+tpm_emb_g">tpm_emb_g</a>()</code>,
<code><a href="#topic+tpm_g">tpm_g</a>()</code>,
<code><a href="#topic+tpm_p">tpm_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 states: 2 free off-diagonal elements
par1 = rep(-1, 2)
Gamma1 = tpm(par1)

# 3 states: 6 free off-diagonal elements
par2 = rep(-2, 6)
Gamma2 = tpm(par2)
</code></pre>

<hr>
<h2 id='tpm_cont'>Calculate continuous time transition probabilities</h2><span id='topic+tpm_cont'></span>

<h3>Description</h3>

<p>A continuous-time Markov chain is described by an infinitesimal generator matrix <code class="reqn">Q</code>. 
When observing data at time points <code class="reqn">t_1, \dots, t_n</code> the transition probabilites between <code class="reqn">t_i</code> and <code class="reqn">t_{i+1}</code> are caluclated as
</p>
<p style="text-align: center;"><code class="reqn">\Gamma(\Delta t_i) = \exp(Q \Delta t_i),</code>
</p>

<p>where <code class="reqn">\exp()</code> is the matrix exponential. The mapping <code class="reqn">\Gamma(\Delta t)</code> is also called the <strong>Markov semigroup</strong>.
This function calculates all transition matrices based on a given generator and time differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_cont(Q, timediff, ad = NULL, report = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_cont_+3A_q">Q</code></td>
<td>
<p>infinitesimal generator matrix of the continuous-time Markov chain of dimension c(N,N)</p>
</td></tr>
<tr><td><code id="tpm_cont_+3A_timediff">timediff</code></td>
<td>
<p>time differences between observations of length n-1 when based on n observations</p>
</td></tr>
<tr><td><code id="tpm_cont_+3A_ad">ad</code></td>
<td>
<p>optional logical, indicating whether automatic differentiation with <code>RTMB</code> should be used. By default, the function determines this itself.</p>
</td></tr>
<tr><td><code id="tpm_cont_+3A_report">report</code></td>
<td>
<p>logical, indicating whether <code>Q</code> should be reported from the fitted model. Defaults to <code>TRUE</code>, but only works if <code>ad = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of continuous-time transition matrices of dimension c(N,N,n-1)
</p>


<h3>See Also</h3>

<p>Other transition probability matrix functions: 
<code><a href="#topic+generator">generator</a>()</code>,
<code><a href="#topic+tpm">tpm</a>()</code>,
<code><a href="#topic+tpm_emb">tpm_emb</a>()</code>,
<code><a href="#topic+tpm_emb_g">tpm_emb_g</a>()</code>,
<code><a href="#topic+tpm_g">tpm_g</a>()</code>,
<code><a href="#topic+tpm_p">tpm_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># building a Q matrix for a 3-state cont.-time Markov chain
Q = generator(rep(-2, 6))

# draw random time differences
timediff = rexp(100, 10)

# compute all transition matrices
Gamma = tpm_cont(Q, timediff)
</code></pre>

<hr>
<h2 id='tpm_emb'>Build the embedded transition probability matrix of an HSMM from unconstrained parameter vector</h2><span id='topic+tpm_emb'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models are defined in terms of state durations and an <strong>embedded</strong> transition probability matrix that contains the conditional transition probabilities given that the <strong>current state is left</strong>. This matrix necessarily has diagonal entries all equal to zero as self-transitions are impossible.
</p>
<p>This function builds such an embedded/ conditional transition probability matrix from an unconstrained parameter vector. 
For each row of the matrix, the inverse multinomial logistic link is applied.
</p>
<p>For a matrix of dimension c(N,N), the number of free off-diagonal elements is N*(N-2), hence also the length of <code>param</code>.
This means, for 2 states, the function needs to be called without any arguments, for 3-states with a vector of length 3, for 4 states with a vector of length 8, etc.
</p>
<p>Compatible with automatic differentiation by <code>RTMB</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_emb(param = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_emb_+3A_param">param</code></td>
<td>
<p>unconstrained parameter vector of length N*(N-2) where N is the number of states of the Markov chain
</p>
<p>If the function is called without <code>param</code>, it will return the conditional transition probability matrix for a 2-state HSMM, which is fixed with 0 diagonal entries and off-diagonal entries equal to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>embedded/ conditional transition probability matrix of dimension c(N,N)
</p>


<h3>See Also</h3>

<p>Other transition probability matrix functions: 
<code><a href="#topic+generator">generator</a>()</code>,
<code><a href="#topic+tpm">tpm</a>()</code>,
<code><a href="#topic+tpm_cont">tpm_cont</a>()</code>,
<code><a href="#topic+tpm_emb_g">tpm_emb_g</a>()</code>,
<code><a href="#topic+tpm_g">tpm_g</a>()</code>,
<code><a href="#topic+tpm_p">tpm_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 states: no free off-diagonal elements
omega = tpm_emb()

# 3 states: 3 free off-diagonal elements
param = rep(0, 3)
omega = tpm_emb(param)

# 4 states: 8 free off-diagonal elements
param = rep(0, 8)
omega = tpm_emb(param)
</code></pre>

<hr>
<h2 id='tpm_emb_g'>Build all embedded transition probability matrices of an inhomogeneous HSMM</h2><span id='topic+tpm_emb_g'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models are defined in terms of state durations and an <strong>embedded</strong> transition probability matrix that contains the conditional transition probabilities given that the <strong>current state is left</strong>. This matrix necessarily has diagonal entries all equal to zero as self-transitions are impossible.
We can allow this matrix to vary with covariates, which is the purpose of this function.
</p>
<p>It builds all embedded/ conditional transition probability matrices based on a design and parameter matrix.
For each row of the matrix, the inverse multinomial logistic link is applied.
</p>
<p>For a matrix of dimension c(N,N), the number of free off-diagonal elements is N*(N-2) which determines the number of rows of the parameter matrix.
</p>
<p>Compatible with automatic differentiation by <code>RTMB</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_emb_g(Z, beta, report = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_emb_g_+3A_z">Z</code></td>
<td>
<p>covariate design matrix with or without intercept column, i.e. of dimension c(n, p) or c(n, p+1)
</p>
<p>If <code>Z</code> has only p columns, an intercept column of ones will be added automatically.</p>
</td></tr>
<tr><td><code id="tpm_emb_g_+3A_beta">beta</code></td>
<td>
<p>matrix of coefficients for the off-diagonal elements of the embedded transition probability matrix
</p>
<p>Needs to be of dimension c(N*(N-2), p+1), where the first column contains the intercepts.
p can be 0, in which case the model is homogeneous.</p>
</td></tr>
<tr><td><code id="tpm_emb_g_+3A_report">report</code></td>
<td>
<p>logical, indicating whether the coefficient matrix beta should be reported from the fitted model. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of embedded/ conditional transition probability matrices of dimension c(N,N,n)
</p>


<h3>See Also</h3>

<p>Other transition probability matrix functions: 
<code><a href="#topic+generator">generator</a>()</code>,
<code><a href="#topic+tpm">tpm</a>()</code>,
<code><a href="#topic+tpm_cont">tpm_cont</a>()</code>,
<code><a href="#topic+tpm_emb">tpm_emb</a>()</code>,
<code><a href="#topic+tpm_g">tpm_g</a>()</code>,
<code><a href="#topic+tpm_p">tpm_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## parameter matrix for 3-state HSMM
beta = matrix(c(rep(0, 3), -0.2, 0.2, 0.1), nrow = 3)
# no intercept
Z = rnorm(100)
omega = tpm_emb_g(Z, beta)
# intercept
Z = cbind(1, Z)
omega = tpm_emb_g(Z, beta)
</code></pre>

<hr>
<h2 id='tpm_g'>Build all transition probability matrices of an inhomogeneous HMM</h2><span id='topic+tpm_g'></span>

<h3>Description</h3>

<p>In an HMM, we often model the influence of covariates on the state process by linking them to the transition probabiltiy matrix. 
Most commonly, this is done by specifying a linear predictor
</p>
<p style="text-align: center;"><code class="reqn"> \eta_{ij}^{(t)} = \beta^{(ij)}_0 + \beta^{(ij)}_1 z_{t1} + \dots + \beta^{(ij)}_p z_{tp} </code>
</p>

<p>for each off-diagonal element (<code class="reqn">i \neq j</code>) of the transition probability matrix and then applying the inverse multinomial logistic link (also known as softmax) to each row.
This function efficiently calculates all transition probabilty matrices for a given design matrix <code>Z</code> and parameter matrix <code>beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_g(Z, beta, byrow = FALSE, ad = NULL, report = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_g_+3A_z">Z</code></td>
<td>
<p>covariate design matrix with or without intercept column, i.e. of dimension c(n, p) or c(n, p+1)
</p>
<p>If <code>Z</code> has only p columns, an intercept column of ones will be added automatically.</p>
</td></tr>
<tr><td><code id="tpm_g_+3A_beta">beta</code></td>
<td>
<p>matrix of coefficients for the off-diagonal elements of the transition probability matrix
</p>
<p>Needs to be of dimension c(N*(N-1), p+1), where the first column contains the intercepts.</p>
</td></tr>
<tr><td><code id="tpm_g_+3A_byrow">byrow</code></td>
<td>
<p>logical indicating if each transition probability matrix should be filled by row
</p>
<p>Defaults to <code>FALSE</code>, but should be set to <code>TRUE</code> if one wants to work with a matrix of beta parameters returned by popular HMM packages like <code>moveHMM</code>, <code>momentuHMM</code>, or <code>hmmTMB</code>.</p>
</td></tr>
<tr><td><code id="tpm_g_+3A_ad">ad</code></td>
<td>
<p>optional logical, indicating whether automatic differentiation with <code>RTMB</code> should be used. By default, the function determines this itself.</p>
</td></tr>
<tr><td><code id="tpm_g_+3A_report">report</code></td>
<td>
<p>logical, indicating whether the coefficient matrix <code>beta</code> should be reported from the fitted model. Defaults to <code>TRUE</code>, but only works if <code>ad = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of transition probability matrices of dimension c(N,N,n)
</p>


<h3>See Also</h3>

<p>Other transition probability matrix functions: 
<code><a href="#topic+generator">generator</a>()</code>,
<code><a href="#topic+tpm">tpm</a>()</code>,
<code><a href="#topic+tpm_cont">tpm_cont</a>()</code>,
<code><a href="#topic+tpm_emb">tpm_emb</a>()</code>,
<code><a href="#topic+tpm_emb_g">tpm_emb_g</a>()</code>,
<code><a href="#topic+tpm_p">tpm_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z = matrix(runif(200), ncol = 2)
beta = matrix(c(-1, 1, 2, -2, 1, -2), nrow = 2, byrow = TRUE)
Gamma = tpm_g(Z, beta)
</code></pre>

<hr>
<h2 id='tpm_hsmm'>Builds the transition probability matrix of an HSMM-approximating HMM</h2><span id='topic+tpm_hsmm'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs, where the state duration distribution is explicitly modelled.
For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
</p>
<p>This function computes the transition matrix to approximate a given HSMM by an HMM with a larger state space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_hsmm(omega, dm, Fm = NULL, sparse = TRUE, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_hsmm_+3A_omega">omega</code></td>
<td>
<p>embedded transition probability matrix of dimension c(N,N) as computed by <code><a href="#topic+tpm_emb">tpm_emb</a></code>.</p>
</td></tr>
<tr><td><code id="tpm_hsmm_+3A_dm">dm</code></td>
<td>
<p>state dwell-time distributions arranged in a list of length(N). Each list element needs to be a vector of length N_i, where N_i is the state aggregate size.</p>
</td></tr>
<tr><td><code id="tpm_hsmm_+3A_fm">Fm</code></td>
<td>
<p>optional list of length N containing the cumulative distribution functions of the dwell-time distributions.</p>
</td></tr>
<tr><td><code id="tpm_hsmm_+3A_sparse">sparse</code></td>
<td>
<p>logical, indicating whether the output should be a <strong>sparse</strong> matrix. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tpm_hsmm_+3A_eps">eps</code></td>
<td>
<p>rounding value: If an entry of the transition probabily matrix is smaller, than it is rounded to zero. Usually, this should not be changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extended-state-space transition probability matrix of the approximating HMM
</p>


<h3>Examples</h3>

<pre><code class='language-R'># building the t.p.m. of the embedded Markov chain
omega = matrix(c(0,1,1,0), nrow = 2, byrow = TRUE)
# defining state aggregate sizes
sizes = c(20, 30)
# defining state dwell-time distributions
lambda = c(5, 11)
dm = list(dpois(1:sizes[1]-1, lambda[1]), dpois(1:sizes[2]-1, lambda[2]))
# calculating extended-state-space t.p.m.
Gamma = tpm_hsmm(omega, dm)
</code></pre>

<hr>
<h2 id='tpm_hsmm2'>Build the transition probability matrix of an HSMM-approximating HMM</h2><span id='topic+tpm_hsmm2'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs. 
For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
This function computes the transition matrix of an HSMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_hsmm2(omega, dm, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_hsmm2_+3A_omega">omega</code></td>
<td>
<p>embedded transition probability matrix of dimension c(N,N)</p>
</td></tr>
<tr><td><code id="tpm_hsmm2_+3A_dm">dm</code></td>
<td>
<p>state dwell-time distributions arranged in a list of length(N). Each list element needs to be a vector of length N_i, where N_i is the state aggregate size.</p>
</td></tr>
<tr><td><code id="tpm_hsmm2_+3A_eps">eps</code></td>
<td>
<p>rounding value: If an entry of the transition probabily matrix is smaller, than it is rounded to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extended-state-space transition probability matrix of the approximating HMM
</p>


<h3>Examples</h3>

<pre><code class='language-R'># building the t.p.m. of the embedded Markov chain
omega = matrix(c(0,1,1,0), nrow = 2, byrow = TRUE)
# defining state aggregate sizes
sizes = c(20, 30)
# defining state dwell-time distributions
lambda = c(5, 11)
dm = list(dpois(1:sizes[1]-1, lambda[1]), dpois(1:sizes[2]-1, lambda[2]))
# calculating extended-state-space t.p.m.
Gamma = tpm_hsmm(omega, dm)
</code></pre>

<hr>
<h2 id='tpm_ihsmm'>Builds all transition probability matrices of an inhomogeneous-HSMM-approximating HMM</h2><span id='topic+tpm_ihsmm'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs. For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
</p>
<p>This function computes the transition matrices of a periodically inhomogeneos HSMMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_ihsmm(omega, dm, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_ihsmm_+3A_omega">omega</code></td>
<td>
<p>embedded transition probability matrix
</p>
<p>Either a matrix of dimension c(N,N) for homogeneous conditional transition probabilities (as computed by <code><a href="#topic+tpm_emb">tpm_emb</a></code>), or an array of dimension c(N,N,n) for inhomogeneous conditional transition probabilities (as computed by <code><a href="#topic+tpm_emb_g">tpm_emb_g</a></code>).</p>
</td></tr>
<tr><td><code id="tpm_ihsmm_+3A_dm">dm</code></td>
<td>
<p>state dwell-time distributions arranged in a list of length N
</p>
<p>Each list element needs to be a matrix of dimension c(n, N_i), where each row t is the (approximate) probability mass function of state i at time t.</p>
</td></tr>
<tr><td><code id="tpm_ihsmm_+3A_eps">eps</code></td>
<td>
<p>rounding value: If an entry of the transition probabily matrix is smaller, than it is rounded to zero. Usually, this should not be changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of dimension length <code>n - max(sapply(dm, ncol))</code>, containing sparse extended-state-space transition probability matrices for each time point (except the first <code>max(sapply(dm, ncol)) - 1</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 2
# time-varying mean dwell times
n = 100
z = runif(n)
beta = matrix(c(2, 2, 0.1, -0.1), nrow = 2)
Lambda = exp(cbind(1, z) %*% t(beta))
sizes = c(15, 15) # approximating chain with 30 states
# state dwell-time distributions
dm = lapply(1:N, function(i) sapply(1:sizes[i]-1, dpois, lambda = Lambda[,i]))

## homogeneous conditional transition probabilites
# diagonal elements are zero, rowsums are one
omega = matrix(c(0,1,1,0), nrow = N, byrow = TRUE)

# calculating extended-state-space t.p.m.s
Gamma = tpm_ihsmm(omega, dm)

## inhomogeneous conditional transition probabilites
# omega can be an array
omega = array(omega, dim = c(N,N,n))

# calculating extended-state-space t.p.m.s
Gamma = tpm_ihsmm(omega, dm)
</code></pre>

<hr>
<h2 id='tpm_p'>Build all transition probability matrices of a periodically inhomogeneous HMM</h2><span id='topic+tpm_p'></span>

<h3>Description</h3>

<p>Given a periodically varying variable such as time of day or day of year and the associated cycle length, 
this function calculates the transition probability matrices by applying the inverse multinomial logistic link (also known as softmax) to linear predictors of the form
</p>
<p style="text-align: center;"><code class="reqn"> 
 \eta^{(t)}_{ij} = \beta_0^{(ij)} + \sum_{k=1}^K \bigl( \beta_{1k}^{(ij)} \sin(\frac{2 \pi k t}{L}) + \beta_{2k}^{(ij)} \cos(\frac{2 \pi k t}{L}) \bigr) </code>
</p>

<p>for the off-diagonal elements (<code class="reqn">i \neq j</code>) of the transition probability matrix.
This is relevant for modeling e.g. diurnal variation and the flexibility can be increased by adding smaller frequencies (i.e. increasing <code class="reqn">K</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_p(
  tod = 1:24,
  L = 24,
  beta,
  degree = 1,
  Z = NULL,
  byrow = FALSE,
  ad = NULL,
  report = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_p_+3A_tod">tod</code></td>
<td>
<p>equidistant sequence of a cyclic variable
</p>
<p>For time of day and e.g. half-hourly data, this could be 1, ..., L and L = 48, or 0.5, 1, 1.5, ..., 24 and L = 24.</p>
</td></tr>
<tr><td><code id="tpm_p_+3A_l">L</code></td>
<td>
<p>length of one full cycle, on the scale of tod</p>
</td></tr>
<tr><td><code id="tpm_p_+3A_beta">beta</code></td>
<td>
<p>matrix of coefficients for the off-diagonal elements of the transition probability matrix
</p>
<p>Needs to be of dimension c(N *(N-1), 2*degree+1), where the first column contains the intercepts.</p>
</td></tr>
<tr><td><code id="tpm_p_+3A_degree">degree</code></td>
<td>
<p>degree of the trigonometric link function
</p>
<p>For each additional degree, one sine and one cosine frequency are added.</p>
</td></tr>
<tr><td><code id="tpm_p_+3A_z">Z</code></td>
<td>
<p>pre-calculated design matrix (excluding intercept column)
</p>
<p>Defaults to <code>NULL</code> if trigonometric link should be calculated. 
From an efficiency perspective, <code>Z</code> should be pre-calculated within the likelihood function, as the basis expansion should not be redundantly calculated. This can be done by using <code><a href="#topic+trigBasisExp">trigBasisExp</a></code>.</p>
</td></tr>
<tr><td><code id="tpm_p_+3A_byrow">byrow</code></td>
<td>
<p>logical indicating if each transition probability matrix should be filled by row
</p>
<p>Defaults to <code>FALSE</code>, but should be set to <code>TRUE</code> if one wants to work with a matrix of <code>beta</code> parameters returned by popular HMM packages like <code>moveHMM</code>, <code>momentuHMM</code>, or <code>hmmTMB</code>.</p>
</td></tr>
<tr><td><code id="tpm_p_+3A_ad">ad</code></td>
<td>
<p>optional logical, indicating whether automatic differentiation with RTMB should be used. By default, the function determines this itself.</p>
</td></tr>
<tr><td><code id="tpm_p_+3A_report">report</code></td>
<td>
<p>logical, indicating whether the coefficient matrix <code>beta</code> should be reported from the fitted model. Defaults to <code>TRUE</code>, but only works if <code>ad = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that using this function inside the negative log-likelihood function is convenient, but it performs the basis expansion into sine and cosine terms each time it is called. 
As these do not change during the optimisation, using <code><a href="#topic+tpm_g">tpm_g</a></code> with a pre-calculated (by <code><a href="#topic+trigBasisExp">trigBasisExp</a></code>) design matrix would be more efficient.
</p>


<h3>Value</h3>

<p>array of transition probability matrices of dimension c(N,N,length(tod))
</p>


<h3>See Also</h3>

<p>Other transition probability matrix functions: 
<code><a href="#topic+generator">generator</a>()</code>,
<code><a href="#topic+tpm">tpm</a>()</code>,
<code><a href="#topic+tpm_cont">tpm_cont</a>()</code>,
<code><a href="#topic+tpm_emb">tpm_emb</a>()</code>,
<code><a href="#topic+tpm_emb_g">tpm_emb_g</a>()</code>,
<code><a href="#topic+tpm_g">tpm_g</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># hourly data 
tod = seq(1, 24, by = 1)
L = 24
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma = tpm_p(tod, L, beta, degree = 1)

# half-hourly data
## integer tod sequence
tod = seq(1, 48, by = 1)
L = 48
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma1 = tpm_p(tod, L, beta, degree = 1)

## equivalent specification
tod = seq(0.5, 24, by = 0.5)
L = 24
beta = matrix(c(-1, 2, -1, -2, 1, -1), nrow = 2, byrow = TRUE)
Gamma2 = tpm_p(tod, L, beta, degree = 1)

all(Gamma1 == Gamma2) # same result
</code></pre>

<hr>
<h2 id='tpm_phsmm'>Builds all transition probability matrices of an periodic-HSMM-approximating HMM</h2><span id='topic+tpm_phsmm'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs. For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
</p>
<p>This function computes the transition matrices of a periodically inhomogeneos HSMMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_phsmm(omega, dm, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_phsmm_+3A_omega">omega</code></td>
<td>
<p>embedded transition probability matrix
</p>
<p>Either a matrix of dimension c(N,N) for homogeneous conditional transition probabilities (as computed by <code><a href="#topic+tpm_emb">tpm_emb</a></code>), or an array of dimension c(N,N,L) for inhomogeneous conditional transition probabilities (as computed by <code><a href="#topic+tpm_emb_g">tpm_emb_g</a></code>).</p>
</td></tr>
<tr><td><code id="tpm_phsmm_+3A_dm">dm</code></td>
<td>
<p>state dwell-time distributions arranged in a list of length N
</p>
<p>Each list element needs to be a matrix of dimension c(L, N_i), where each row t is the (approximate) probability mass function of state i at time t.</p>
</td></tr>
<tr><td><code id="tpm_phsmm_+3A_eps">eps</code></td>
<td>
<p>rounding value: If an entry of the transition probabily matrix is smaller, than it is rounded to zero. Usually, this should not be changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of dimension length L, containing sparse extended-state-space transition probability matrices of the approximating HMM for each time point of the cycle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 2 # number of states
L = 24 # cycle length
# time-varying mean dwell times
Z = trigBasisExp(1:L) # trigonometric basis functions design matrix
beta = matrix(c(2, 2, 0.1, -0.1, -0.2, 0.2), nrow = 2)
Lambda = exp(cbind(1, Z) %*% t(beta))
sizes = c(20, 20) # approximating chain with 40 states
# state dwell-time distributions
dm = lapply(1:N, function(i) sapply(1:sizes[i]-1, dpois, lambda = Lambda[,i]))

## homogeneous conditional transition probabilites
# diagonal elements are zero, rowsums are one
omega = matrix(c(0,1,1,0), nrow = N, byrow = TRUE)

# calculating extended-state-space t.p.m.s
Gamma = tpm_phsmm(omega, dm)

## inhomogeneous conditional transition probabilites
# omega can be an array
omega = array(omega, dim = c(N,N,L))

# calculating extended-state-space t.p.m.s
Gamma = tpm_phsmm(omega, dm)
</code></pre>

<hr>
<h2 id='tpm_phsmm2'>Build all transition probability matrices of an periodic-HSMM-approximating HMM</h2><span id='topic+tpm_phsmm2'></span>

<h3>Description</h3>

<p>Hidden semi-Markov models (HSMMs) are a flexible extension of HMMs. For direct numerical maximum likelhood estimation, HSMMs can be represented as HMMs on an enlarged state space (of size <code class="reqn">M</code>) and with structured transition probabilities.
This function computes the transition matrices of a periodically inhomogeneos HSMMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_phsmm2(omega, dm, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_phsmm2_+3A_omega">omega</code></td>
<td>
<p>embedded transition probability matrix
</p>
<p>Either a matrix of dimension c(N,N) for homogeneous conditional transition probabilities, or an array of dimension c(N,N,L) for inhomogeneous conditional transition probabilities.</p>
</td></tr>
<tr><td><code id="tpm_phsmm2_+3A_dm">dm</code></td>
<td>
<p>state dwell-time distributions arranged in a list of length(N)
</p>
<p>Each list element needs to be a matrix of dimension c(L, N_i), where each row t is the (approximate) probability mass function of state i at time t.</p>
</td></tr>
<tr><td><code id="tpm_phsmm2_+3A_eps">eps</code></td>
<td>
<p>rounding value: If an entry of the transition probabily matrix is smaller, than it is rounded to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of dimension c(N,N,L), containing the extended-state-space transition probability matrices of the approximating HMM for each time point of the cycle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 3
L = 24
# time-varying mean dwell times
Lambda = exp(matrix(rnorm(L*N, 2, 0.5), nrow = L))
sizes = c(25, 25, 25) # approximating chain with 75 states
# state dwell-time distributions
dm = list()
for(i in 1:3){
  dmi = matrix(nrow = L, ncol = sizes[i])
  for(t in 1:L){
    dmi[t,] = dpois(1:sizes[i]-1, Lambda[t,i])
  }
  dm[[i]] = dmi
}

## homogeneous conditional transition probabilites
# diagonal elements are zero, rowsums are one
omega = matrix(c(0,0.5,0.5,0.2,0,0.8,0.7,0.3,0), nrow = N, byrow = TRUE)

# calculating extended-state-space t.p.m.s
Gamma = tpm_phsmm(omega, dm)

## inhomogeneous conditional transition probabilites
# omega can be an array
omega = array(rep(omega,L), dim = c(N,N,L))
omega[1,,4] = c(0, 0.2, 0.8) # small change for inhomogeneity

# calculating extended-state-space t.p.m.s
Gamma = tpm_phsmm(omega, dm)
</code></pre>

<hr>
<h2 id='tpm_thinned'>Compute the transition probability matrix of a thinned periodically inhomogeneous Markov chain.</h2><span id='topic+tpm_thinned'></span>

<h3>Description</h3>

<p>If the transition probability matrix of an inhomogeneous Markov chain varies only periodically (with period length <code class="reqn">L</code>), it converges to a so-called periodically stationary distribution. 
This happens, because the thinned Markov chain, which has a full cycle as each time step, has homogeneous transition probability matrix
</p>
<p style="text-align: center;"><code class="reqn">\Gamma_t = \Gamma^{(t)} \Gamma^{(t+1)} \dots \Gamma^{(t+L-1)}</code>
</p>
<p> for all <code class="reqn">t = 1, \dots, L.</code>
This function calculates the matrix above efficiently as a preliminery step to calculating the periodically stationary distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm_thinned(Gamma, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpm_thinned_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices of dimension c(N,N,L).</p>
</td></tr>
<tr><td><code id="tpm_thinned_+3A_t">t</code></td>
<td>
<p>integer index of the time point in the cycle, for which to calculate the thinned transition probility matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>thinned transition probabilty matrix of dimension c(N,N)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting parameters for trigonometric link
beta = matrix(c(-1, -2, 2, -1, 2, -4), nrow = 2, byrow = TRUE)
# calculating periodically varying t.p.m. array (of length 24 here)
Gamma = tpm_p(beta = beta)
# calculating t.p.m. of thinned Markov chain
tpm_thinned(Gamma, 4)
</code></pre>

<hr>
<h2 id='trex'>T-Rex Movement Data</h2><span id='topic+trex'></span>

<h3>Description</h3>

<p>Hourly step lengths and turning angles of a Tyrannosaurus rex, living 66 million years ago.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trex
</code></pre>


<h3>Format</h3>

<p>A data frame with 10.000 rows and 4 variables:
</p>

<dl>
<dt>tod</dt><dd><p>time of day variable ranging from 1 to 24</p>
</dd>
<dt>step</dt><dd><p>hourly step lengths in kilometres</p>
</dd>
<dt>angle</dt><dd><p>hourly turning angles in radians</p>
</dd>
<dt>state</dt><dd><p>hidden state variable</p>
</dd>
</dl>



<h3>Source</h3>

<p>Generated for example purposes.
</p>

<hr>
<h2 id='trigBasisExp'>Compute the design matrix for a trigonometric basis expansion</h2><span id='topic+trigBasisExp'></span>

<h3>Description</h3>

<p>Given a periodically varying variable such as time of day or day of year and the associated cycle length, this function performs a basis expansion to efficiently calculate a linear predictor of the form
</p>
<p style="text-align: center;"><code class="reqn"> 
 \eta^{(t)} = \beta_0 + \sum_{k=1}^K \bigl( \beta_{1k} \sin(\frac{2 \pi k t}{L}) + \beta_{2k} \cos(\frac{2 \pi k t}{L}) \bigr). 
 </code>
</p>

<p>This is relevant for modeling e.g. diurnal variation and the flexibility can be increased by adding smaller frequencies (i.e. increasing <code class="reqn">K</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trigBasisExp(tod, L = 24, degree = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trigBasisExp_+3A_tod">tod</code></td>
<td>
<p>equidistant sequence of a cyclic variable
</p>
<p>For time of day and e.g. half-hourly data, this could be 1, ..., L and L = 48, or 0.5, 1, 1.5, ..., 24 and L = 24.</p>
</td></tr>
<tr><td><code id="trigBasisExp_+3A_l">L</code></td>
<td>
<p>length of one cycle on the scale of the time variable. For time of day, this would be 24.</p>
</td></tr>
<tr><td><code id="trigBasisExp_+3A_degree">degree</code></td>
<td>
<p>degree K of the trigonometric link above. Increasing K increases the flexibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>design matrix (without intercept column), ordered as sin1, cos1, sin2, cos2, ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## hourly data
tod = rep(1:24, 10)
Z = trigBasisExp(tod, L = 24, degree = 2)

## half-hourly data
tod = rep(1:48/2, 10) # in [0,24] -&gt; L = 24
Z1 = trigBasisExp(tod, L = 24, degree = 3)

tod = rep(1:48, 10) # in [1,48] -&gt; L = 48
Z2 = trigBasisExp(tod, L = 48, degree = 3)

all(Z1 == Z2)
# The latter two are equivalent specifications!
</code></pre>

<hr>
<h2 id='viterbi'>Viterbi algorithm for state decoding in homogeneous HMMs</h2><span id='topic+viterbi'></span>

<h3>Description</h3>

<p>The Viterbi algorithm allows one to decode the most probable state sequence of an HMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi(delta, Gamma, allprobs, trackID = NULL, mod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viterbi_+3A_delta">delta</code></td>
<td>
<p>initial distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="viterbi_+3A_gamma">Gamma</code></td>
<td>
<p>transition probability matrix of dimension c(N,N) or array of transition probability matrices of dimension c(N,N,k) if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="viterbi_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="viterbi_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of k track IDs, if multiple tracks need to be decoded separately</p>
</td></tr>
<tr><td><code id="viterbi_+3A_mod">mod</code></td>
<td>
<p>optional model object containing initial distribution <code>delta</code>, transition probability matrix <code>Gamma</code>, matrix of state-dependent probabilities <code>allprobs</code>, and potentially a <code>trackID</code> variable
</p>
<p>If you are using automatic differentiation either with <code>RTMB::MakeADFun</code> or <code><a href="#topic+qreml">qreml</a></code> and include <code><a href="#topic+forward">forward</a></code> in your likelihood function, the objects needed for state decoding are automatically reported after model fitting.
Hence, you can pass the model object obtained from running <code>RTMB::report()</code> or from <code><a href="#topic+qreml">qreml</a></code> directly to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of decoded states of length n
</p>


<h3>See Also</h3>

<p>Other decoding functions: 
<code><a href="#topic+stateprobs">stateprobs</a>()</code>,
<code><a href="#topic+stateprobs_g">stateprobs_g</a>()</code>,
<code><a href="#topic+stateprobs_p">stateprobs_p</a>()</code>,
<code><a href="#topic+viterbi_g">viterbi_g</a>()</code>,
<code><a href="#topic+viterbi_p">viterbi_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta = c(0.5, 0.5)
Gamma = matrix(c(0.9, 0.1, 0.2, 0.8), nrow = 2, byrow = TRUE)
allprobs = matrix(runif(200), nrow = 100, ncol = 2)
states = viterbi(delta, Gamma, allprobs)
</code></pre>

<hr>
<h2 id='viterbi_g'>Viterbi algorithm for state decoding in inhomogeneous HMMs</h2><span id='topic+viterbi_g'></span>

<h3>Description</h3>

<p>The Viterbi algorithm allows one to decode the most probable state sequence of an HMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi_g(delta, Gamma, allprobs, trackID = NULL, mod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viterbi_g_+3A_delta">delta</code></td>
<td>
<p>initial distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided</p>
</td></tr>
<tr><td><code id="viterbi_g_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices of dimension c(N,N,n-1), as in a time series of length n, there are only n-1 transitions
</p>
<p>If an array of dimension c(N,N,n) is provided for a single track, the first slice will be ignored.
</p>
<p>If <code>trackID</code> is provided, <code>Gamma</code> needs to be an array of dimension c(N,N,n), where n is the number of rows in <code>allprobs</code>. Then for each track the first transition matrix will be ignored.</p>
</td></tr>
<tr><td><code id="viterbi_g_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="viterbi_g_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of k track IDs, if multiple tracks need to be decoded separately</p>
</td></tr>
<tr><td><code id="viterbi_g_+3A_mod">mod</code></td>
<td>
<p>optional model object containing initial distribution <code>delta</code>, transition probability matrix <code>Gamma</code>, matrix of state-dependent probabilities <code>allprobs</code>, and potentially a <code>trackID</code> variable
</p>
<p>If you are using automatic differentiation either with <code>RTMB::MakeADFun</code> or <code><a href="#topic+qreml">qreml</a></code> and include <code><a href="#topic+forward_g">forward_g</a></code> in your likelihood function, the objects needed for state decoding are automatically reported after model fitting.
Hence, you can pass the model object obtained from running <code>RTMB::report()</code> or from <code><a href="#topic+qreml">qreml</a></code> directly to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of decoded states of length n
</p>


<h3>See Also</h3>

<p>Other decoding functions: 
<code><a href="#topic+stateprobs">stateprobs</a>()</code>,
<code><a href="#topic+stateprobs_g">stateprobs_g</a>()</code>,
<code><a href="#topic+stateprobs_p">stateprobs_p</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code>,
<code><a href="#topic+viterbi_p">viterbi_p</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta = c(0.5, 0.5)
Gamma = array(dim = c(2,2,99))
for(t in 1:99){
  gammas = rbeta(2, shape1 = 0.4, shape2 = 1)
  Gamma[,,t] = matrix(c(1-gammas[1], gammas[1], 
                      gammas[2], 1-gammas[2]), nrow = 2, byrow = TRUE)
}
allprobs = matrix(runif(200), nrow = 100, ncol = 2)
states = viterbi_g(delta, Gamma, allprobs)
</code></pre>

<hr>
<h2 id='viterbi_p'>Viterbi algorithm for state decoding in periodically inhomogeneous HMMs</h2><span id='topic+viterbi_p'></span>

<h3>Description</h3>

<p>The Viterbi algorithm allows one to decode the most probable state sequence of an HMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi_p(delta, Gamma, allprobs, tod, trackID = NULL, mod = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viterbi_p_+3A_delta">delta</code></td>
<td>
<p>initial distribution of length N, or matrix of dimension c(k,N) for k independent tracks, if <code>trackID</code> is provided
</p>
<p>This could e.g. be the periodically stationary distribution (for each track).</p>
</td></tr>
<tr><td><code id="viterbi_p_+3A_gamma">Gamma</code></td>
<td>
<p>array of transition probability matrices for each time point in the cycle of dimension c(N,N,L), where L is the length of the cycle</p>
</td></tr>
<tr><td><code id="viterbi_p_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix of state-dependent probabilities/ density values of dimension c(n, N)</p>
</td></tr>
<tr><td><code id="viterbi_p_+3A_tod">tod</code></td>
<td>
<p>(Integer valued) variable for cycle indexing in 1, ..., L, mapping the data index to a generalised time of day (length n)
</p>
<p>For half-hourly data L = 48. It could, however, also be day of year for daily data and L = 365.</p>
</td></tr>
<tr><td><code id="viterbi_p_+3A_trackid">trackID</code></td>
<td>
<p>optional vector of k track IDs, if multiple tracks need to be decoded separately</p>
</td></tr>
<tr><td><code id="viterbi_p_+3A_mod">mod</code></td>
<td>
<p>optional model object containing initial distribution <code>delta</code>, transition probability matrix <code>Gamma</code>, matrix of state-dependent probabilities <code>allprobs</code>, and potentially a <code>trackID</code> variable
</p>
<p>If you are using automatic differentiation either with <code>RTMB::MakeADFun</code> or <code><a href="#topic+qreml">qreml</a></code> and include <code><a href="#topic+forward_p">forward_p</a></code> in your likelihood function, the objects needed for state decoding are automatically reported after model fitting.
Hence, you can pass the model object obtained from running <code>RTMB::report()</code> or from <code><a href="#topic+qreml">qreml</a></code> directly to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of decoded states of length n
</p>


<h3>See Also</h3>

<p>Other decoding functions: 
<code><a href="#topic+stateprobs">stateprobs</a>()</code>,
<code><a href="#topic+stateprobs_g">stateprobs_g</a>()</code>,
<code><a href="#topic+stateprobs_p">stateprobs_p</a>()</code>,
<code><a href="#topic+viterbi">viterbi</a>()</code>,
<code><a href="#topic+viterbi_g">viterbi_g</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta = c(0.5, 0.5)
beta = matrix(c(-2, 1, -1,
                -2, -1, 1), nrow = 2, byrow = TRUE)
Gamma = tpm_p(1:24, 24, beta)

tod = rep(1:24, 10)
n = length(tod)

allprobs = matrix(runif(2*n), nrow = n, ncol = 2)
states = viterbi_p(delta, Gamma, allprobs, tod)
</code></pre>

<hr>
<h2 id='vm'>von Mises distribution</h2><span id='topic+vm'></span><span id='topic+dvm'></span><span id='topic+pvm'></span><span id='topic+rvm'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the von Mises distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvm(x, mu = 0, kappa = 1, log = FALSE)

pvm(q, mu = 0, kappa = 1, from = NULL, tol = 1e-20)

rvm(n, mu = 0, kappa = 1, wrap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vm_+3A_x">x</code>, <code id="vm_+3A_q">q</code></td>
<td>
<p>vector of angles measured in radians at which to evaluate the density function.</p>
</td></tr>
<tr><td><code id="vm_+3A_mu">mu</code></td>
<td>
<p>mean direction of the distribution measured in radians.</p>
</td></tr>
<tr><td><code id="vm_+3A_kappa">kappa</code></td>
<td>
<p>non-negative numeric value for the concentration parameter of the distribution.</p>
</td></tr>
<tr><td><code id="vm_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, densities are returned on the log scale.</p>
</td></tr>
<tr><td><code id="vm_+3A_from">from</code></td>
<td>
<p>value from which the integration for CDF starts. If <code>NULL</code>, is set to <code>mu - pi</code>.</p>
</td></tr>
<tr><td><code id="vm_+3A_tol">tol</code></td>
<td>
<p>the precision in evaluating the distribution function</p>
</td></tr>
<tr><td><code id="vm_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="vm_+3A_wrap">wrap</code></td>
<td>
<p>logical; if <code>TRUE</code>, generated angles are wrapped to the interval [-pi, pi].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of <code>dvm</code> allows for automatic differentiation with <code>RTMB</code>. 
<code>rvm</code> and <code>pvm</code> are imported from <code>CircStats</code> and <code>circular</code> respectively.
</p>


<h3>Value</h3>

<p><code>dvm</code> gives the density, <code>pvm</code> gives the distribution function, and <code>rvm</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = rvm(10, 0, 1)
d = dvm(x, 0, 1)
p = pvm(x, 0, 1)
</code></pre>

<hr>
<h2 id='wrpcauchy'>wrapped Cauchy distribution</h2><span id='topic+wrpcauchy'></span><span id='topic+dwrpcauchy'></span><span id='topic+rwrpcauchy'></span>

<h3>Description</h3>

<p>Density and random generation for the wrapped Cauchy distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwrpcauchy(x, mu = 0, rho, log = FALSE)

rwrpcauchy(n, mu = 0, rho, wrap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrpcauchy_+3A_x">x</code></td>
<td>
<p>vector of angles measured in radians at which to evaluate the density function.</p>
</td></tr>
<tr><td><code id="wrpcauchy_+3A_mu">mu</code></td>
<td>
<p>mean direction of the distribution measured in radians.</p>
</td></tr>
<tr><td><code id="wrpcauchy_+3A_rho">rho</code></td>
<td>
<p>concentration parameter of the distribution, must be in the interval from 0 to 1.</p>
</td></tr>
<tr><td><code id="wrpcauchy_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, densities are returned on the log scale.</p>
</td></tr>
<tr><td><code id="wrpcauchy_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="wrpcauchy_+3A_wrap">wrap</code></td>
<td>
<p>logical; if <code>TRUE</code>, generated angles are wrapped to the interval [-pi, pi].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation of <code>dwrpcauchy</code> allows for automatic differentiation with <code>RTMB</code>. 
<code>rwrpcauchy</code> is imported from <code>CircStats</code>.
</p>


<h3>Value</h3>

<p><code>dwrpcauchy</code> gives the density and <code>rwrpcauchy</code> generates random deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = rwrpcauchy(10, 0, 1)
d = dwrpcauchy(x, 0, 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
