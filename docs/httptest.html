<!DOCTYPE html><html><head><title>Help for package httptest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {httptest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.mockPaths'><p>Set an alternate directory for mock API fixtures</p></a></li>
<li><a href='#as.redactor'><p>Wrap a redacting expression as a proper function</p></a></li>
<li><a href='#block_requests'><p>Block HTTP requests</p></a></li>
<li><a href='#build_mock_url'><p>Convert a request to a mock file path</p></a></li>
<li><a href='#capture_requests'><p>Record API responses as mock files</p></a></li>
<li><a href='#change_state'><p>Handle a change of server state</p></a></li>
<li><a href='#expect_header'><p>Test that an HTTP request is made with a header</p></a></li>
<li><a href='#expect_json_equivalent'><p>Test that objects would generate equivalent JSON</p></a></li>
<li><a href='#expect_verb'><p>Expectations for mocked HTTP requests</p></a></li>
<li><a href='#fake_response'><p>Return something that looks like a 'response'</p></a></li>
<li><a href='#find_mock_file'><p>Go through mock paths to find the local mock file location</p></a></li>
<li><a href='#get_current_redactor'><p>Fetch the active redacting function</p></a></li>
<li><a href='#get_current_requester'><p>Fetch the active requesting function</p></a></li>
<li><a href='#gsub_response'><p>Find and replace within a 'response' or 'request'</p></a></li>
<li><a href='#httptest'><p><code>httptest</code>: A Test Environment for HTTP Requests</p></a></li>
<li><a href='#public'><p>Test that functions are exported</p></a></li>
<li><a href='#redact_cookies'><p>Remove sensitive content from HTTP responses</p></a></li>
<li><a href='#save_response'><p>Write out a captured response</p></a></li>
<li><a href='#set_redactor'><p>Set a response redactor</p></a></li>
<li><a href='#set_requester'><p>Set a request preprocessor</p></a></li>
<li><a href='#skip_if_disconnected'><p>Skip tests that need an internet connection if you don't have one</p></a></li>
<li><a href='#start_vignette'><p>Set mocking/capturing state for a vignette</p></a></li>
<li><a href='#stop_mocking'><p>Turn off request mocking</p></a></li>
<li><a href='#use_httptest'><p>Use 'httptest' in your tests</p></a></li>
<li><a href='#use_mock_api'><p>Turn on API mocking</p></a></li>
<li><a href='#with_fake_http'><p>Make all HTTP requests return a fake response</p></a></li>
<li><a href='#with_mock_api'><p>Serve a mock API from files</p></a></li>
<li><a href='#with_mock_dir'><p>Use or create mock files depending on their existence</p></a></li>
<li><a href='#with_trace'><p>Wrapper around 'trace' to untrace when finished</p></a></li>
<li><a href='#without_internet'><p>Make all HTTP requests raise an error</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Test Environment for HTTP Requests</td>
</tr>
<tr>
<td>Description:</td>
<td>Testing and documenting code that communicates with remote servers
    can be painful. Dealing with authentication, server state,
    and other complications can make testing seem too costly to
    bother with. But it doesn't need to be that hard. This package enables one
    to test all of the logic on the R sides of the API in your package without
    requiring access to the remote service. Importantly, it provides three
    contexts that mock the network connection in different ways, as well as
    testing functions to assert that HTTP requests were&mdash;or were
    not&mdash;made. It also allows one to safely record real API responses to use as
    test fixtures. The ability to save responses and load them offline also
    enables one to write vignettes and other dynamic documents that can be
    distributed without access to a live server.</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://enpiar.com/r/httptest/">https://enpiar.com/r/httptest/</a>,
<a href="https://github.com/nealrichardson/httptest">https://github.com/nealrichardson/httptest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nealrichardson/httptest/issues">https://github.com/nealrichardson/httptest/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, digest, httr, jsonlite, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, pkgload, rmarkdown, spelling, xml2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 17:39:43 UTC; npr</td>
</tr>
<tr>
<td>Author:</td>
<td>Neal Richardson <a href="https://orcid.org/0009-0002-7992-3520"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jonathan Keane [ctb],
  MaÃ«lle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Neal Richardson &lt;neal.p.richardson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.mockPaths'>Set an alternate directory for mock API fixtures</h2><span id='topic+.mockPaths'></span>

<h3>Description</h3>

<p>By default, <code>with_mock_api</code> will look for mocks relative to the current
working directory (the test directory). If you want to look in other places,
you can call <code>.mockPaths</code> to add directories to the search path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mockPaths(new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".mockPaths_+3A_new">new</code></td>
<td>
<p>Either a character vector of path(s) to add, or <code>NULL</code> to reset
to the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It works like <code><a href="base.html#topic+libPaths">base::.libPaths()</a></code>: any directories you specify will be added
to the list and searched first. The default directory will be searched last.
Only unique values are kept: if you provide a path that is already found in
<code>.mockPaths</code>, the result effectively moves that path to the first position.
</p>
<p>For finer-grained control, or to completely override the default behavior
of searching in the current working directory, you can set the option
&quot;httptest.mock.paths&quot; directly.
</p>


<h3>Value</h3>

<p>If <code>new</code> is omitted, the function returns the current search paths, a
a character vector. If <code>new</code> is provided, the updated value will be returned
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>identical(.mockPaths(), ".")
.mockPaths("/var/somewhere/else")
identical(.mockPaths(), c("/var/somewhere/else", "."))
.mockPaths(NULL)
identical(.mockPaths(), ".")
</code></pre>

<hr>
<h2 id='as.redactor'>Wrap a redacting expression as a proper function</h2><span id='topic+as.redactor'></span>

<h3>Description</h3>

<p>Redactors take a <code>response</code> as their first argument, and some take additional
arguments: <code>redact_headers()</code>, for example, requires that you specify
<code>headers</code>. This function allows you to take a simplified expression via a
formula, similar to what <code>purrr</code> does, so that you can provide the function
to <code>capture_requests()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.redactor(fmla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.redactor_+3A_fmla">fmla</code></td>
<td>
<p>Partial expression (a <code>formula</code>) to turn into a function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, <code>as.redactor(~ redact_headers(., "X-Custom-Header"))</code> is equivalent
to <code>function (response) redact_headers(response, "X-Custom-Header")</code>. This
allows you to do
<code>set_redactor(~ redact_headers(., "X-Custom-Header"))</code>.
</p>


<h3>Value</h3>

<p>A <code>function</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capture_requests">capture_requests()</a></code>
</p>

<hr>
<h2 id='block_requests'>Block HTTP requests</h2><span id='topic+block_requests'></span>

<h3>Description</h3>

<p>This function intercepts HTTP requests made through <code>httr</code> and raises an
informative error instead. It is what <code><a href="#topic+without_internet">without_internet()</a></code> does, minus the
automatic disabling of mocking when the context finishes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_requests()
</code></pre>


<h3>Details</h3>

<p>Note that you in order to resume normal request behavior, you will need to
call <code><a href="#topic+stop_mocking">stop_mocking()</a></code> yourself&mdash;this function does not clean up after itself
as 'without_internet' does.
</p>


<h3>Value</h3>

<p>Nothing; called for its side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+without_internet">without_internet()</a></code> <code><a href="#topic+stop_mocking">stop_mocking()</a></code> <code><a href="#topic+use_mock_api">use_mock_api()</a></code>
</p>

<hr>
<h2 id='build_mock_url'>Convert a request to a mock file path</h2><span id='topic+build_mock_url'></span>

<h3>Description</h3>

<p>Requests are translated to mock file paths according to several rules that
incorporate the request method, URL, query parameters, and body.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_mock_url(req, method = "GET")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_mock_url_+3A_req">req</code></td>
<td>
<p>A <code>request</code> object, or a character &quot;URL&quot; to convert</p>
</td></tr>
<tr><td><code id="build_mock_url_+3A_method">method</code></td>
<td>
<p>character HTTP method. If <code>req</code> is a 'request' object,
its request method will override this argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the request protocol, such as &quot;https://&quot;, is removed from the URL.
Second, if the request URL contains a query string, it will be popped off,
hashed by <code><a href="digest.html#topic+digest">digest::digest()</a></code>, and the first six characters appended to the
file being read. Third, request bodies are similarly hashed and
appended. Finally, if a request method other than GET is used it will be
appended to the end of the end of the file name.
</p>
<p>Mock file paths also have a file extension appended, based on the
<code>Content-Type</code> of the response, though this function, which is only concerned
with the request, does not add the extension. In an
HTTP API, a &quot;directory&quot; itself is a resource,
so the extension allows distinguishing directories and files in the file
system. That is, a mocked <code>GET("http://example.com/api/")</code> may read a
&quot;example.com/api.json&quot; file, while
<code>GET("http://example.com/api/object1/")</code> reads &quot;example.com/api/object1.json&quot;.
</p>
<p>Other examples:
</p>

<ul>
<li> <p><code>GET("http://example.com/api/object1/?a=1")</code> may read
&quot;example.com/api/object1-b64371.xml&quot;.
</p>
</li>
<li> <p><code>POST("http://example.com/api/object1/?a=1")</code> may read
&quot;example.com/api/object1-b64371-POST.json&quot;.
</p>
</li></ul>

<p>This function is exported so that other packages can construct similar mock
behaviors or override specific requests at a higher level than
<code>with_mock_api</code> mocks.
</p>
<p>Note that if you are trying to guess the mock file paths corresponding to a
test for which you intend to create a mock file manually,
instead of trying to build the URL, you should run the test
with <code>with_mock_api</code> as the error message will contain the mock file path.
</p>


<h3>Value</h3>

<p>A file path and name, without an extension. The file, or a file with
some extension appended, may or may not
exist: existence is not a concern of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with_mock_api">with_mock_api()</a></code> <code><a href="#topic+capture_requests">capture_requests()</a></code>
</p>

<hr>
<h2 id='capture_requests'>Record API responses as mock files</h2><span id='topic+capture_requests'></span><span id='topic+start_capturing'></span><span id='topic+stop_capturing'></span>

<h3>Description</h3>

<p><code>capture_requests</code> is a context that collects the responses from requests
you make and stores them as mock files. This enables you to perform a series
of requests against a live server once and then build your test suite using
those mocks, running your tests in <code><a href="#topic+with_mock_api">with_mock_api()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_requests(expr, path, ...)

start_capturing(path = NULL, simplify = TRUE)

stop_capturing()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture_requests_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the context</p>
</td></tr>
<tr><td><code id="capture_requests_+3A_path">path</code></td>
<td>
<p>Where to save the mock files. Default is the first directory in
<code><a href="#topic+.mockPaths">.mockPaths()</a></code>, which if not otherwise specified is the current working
directory. It is generally better to call <code>.mockPaths()</code> directly if you
want to write to a different path, rather than using the <code>path</code> argument.</p>
</td></tr>
<tr><td><code id="capture_requests_+3A_...">...</code></td>
<td>
<p>Arguments passed through <code>capture_requests</code> to <code>start_capturing</code></p>
</td></tr>
<tr><td><code id="capture_requests_+3A_simplify">simplify</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), JSON responses with status 200
will be written as just the text of the response body. In all other cases,
and when <code>simplify</code> is <code>FALSE</code>, the &quot;response&quot; object will be written out to
a .R file using <code><a href="base.html#topic+dput">base::dput()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>start_capturing</code> and <code>stop_capturing</code> allow you to turn on/off request
recording for more convenient use in an interactive session.
</p>
<p>Recorded responses are written out as plain-text files. By storing fixtures
as plain-text files, you can
more easily confirm that your mocks look correct, and you can more easily
maintain them without having to re-record them. If the API changes subtly,
such as when adding an additional attribute to an object, you can just touch
up the mocks.
</p>
<p>If the response has status <code style="white-space: pre;">&#8288;200 OK&#8288;</code> and the <code>Content-Type</code>
maps to a supported file extension&mdash;currently <code>.json</code>,
<code>.html</code>, <code>.xml</code>, <code>.txt</code>, <code>.csv</code>, and <code>.tsv</code>&mdash;just the response body will be
written out, using the appropriate extension. <code style="white-space: pre;">&#8288;204 No Content&#8288;</code> status
responses will be stored as an empty file with extension <code>.204</code>. Otherwise,
the response will be written as a <code>.R</code> file containing syntax that, when
executed, recreates the
<code>httr</code> &quot;response&quot; object.
</p>
<p>If you have trouble when recording responses, or are unsure where the files
are being written, set <code>options(httptest.verbose=TRUE)</code> to print a message
for every file that is written containing the absolute path of the file.
</p>


<h3>Value</h3>

<p><code>capture_requests</code> returns the result of <code>expr</code>. <code>start_capturing</code>
invisibly returns the <code>path</code> it is given. <code>stop_capturing</code> returns nothing;
it is called for its side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_mock_url">build_mock_url()</a></code> for how requests are translated to file paths.
And see <code>vignette("redacting")</code> for details on how to prune sensitive
content from responses when recording.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
capture_requests({
  GET("http://httpbin.org/get")
  GET("http://httpbin.org")
  GET("http://httpbin.org/response-headers",
    query = list(`Content-Type` = "application/json")
  )
})
# Or:
start_capturing()
GET("http://httpbin.org/get")
GET("http://httpbin.org")
GET("http://httpbin.org/response-headers",
  query = list(`Content-Type` = "application/json")
)
stop_capturing()

## End(Not run)
</code></pre>

<hr>
<h2 id='change_state'>Handle a change of server state</h2><span id='topic+change_state'></span>

<h3>Description</h3>

<p>In a vignette, put a call to <code>change_state()</code> before any code block that
makes a change on
the server, or rather, before any code block that might repeat the same
request previously done and expect a different result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_state()
</code></pre>


<h3>Details</h3>

<p><code>change_state()</code> works by layering a new directory on top of the existing
<code><a href="#topic+.mockPaths">.mockPaths()</a></code>, so fixtures are recorded/loaded there, masking rather than
overwriting previously recorded responses for the same request. In
vignettes, these mock layers are subdirectories with integer names.
</p>


<h3>Value</h3>

<p>Invisibly, the return of <code>.mockPaths()</code> with the new path added.
</p>

<hr>
<h2 id='expect_header'>Test that an HTTP request is made with a header</h2><span id='topic+expect_header'></span>

<h3>Description</h3>

<p>This expectation checks that a HTTP header (and potentially header value)
is present in a request. It works by inspecting the request object and
raising warnings that are caught by <code><a href="testthat.html#topic+expect_error">testthat::expect_warning()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_header(..., ignore.case = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_header_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>expect_warning</code></p>
</td></tr>
<tr><td><code id="expect_header_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical: if <code>FALSE</code>, the pattern matching is <em>case
sensitive</em> and if <code>TRUE</code>, case is ignored during matching. Default is <code>TRUE</code>;
note that this is the opposite of <code>expect_warning</code> but is appropriate here
because HTTP header names are case insensitive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>expect_header</code> works both in the mock HTTP contexts and on &quot;live&quot; HTTP
requests.
</p>


<h3>Value</h3>

<p><code>NULL</code>, according to <code>expect_warning</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(httr)
with_fake_http({
  expect_header(
    GET("http://example.com", config = add_headers(Accept = "image/png")),
    "Accept: image/png"
  )
})
</code></pre>

<hr>
<h2 id='expect_json_equivalent'>Test that objects would generate equivalent JSON</h2><span id='topic+expect_json_equivalent'></span>

<h3>Description</h3>

<p>Named lists in R are ordered, but they translate to unordered objects in
JSON. This test expectation loosens the equality check of two objects to
ignore the order of elements in a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_json_equivalent(
  object,
  expected,
  info = NULL,
  label = "object",
  expected.label = "expected"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_json_equivalent_+3A_object">object</code></td>
<td>
<p>object to test</p>
</td></tr>
<tr><td><code id="expect_json_equivalent_+3A_expected">expected</code></td>
<td>
<p>expected value</p>
</td></tr>
<tr><td><code id="expect_json_equivalent_+3A_info">info</code></td>
<td>
<p>extra information to be included in the message</p>
</td></tr>
<tr><td><code id="expect_json_equivalent_+3A_label">label</code></td>
<td>
<p>character name by which to refer to <code>object</code> in the test
result. Because the tools for deparsing object names that 'testthat' uses
aren't exported from that package, the default here is just &quot;object&quot;.</p>
</td></tr>
<tr><td><code id="expect_json_equivalent_+3A_expected.label">expected.label</code></td>
<td>
<p>character same as <code>label</code> but for <code>expected</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, returns <code>object</code> for optionally passing to other
expectations.
</p>


<h3>See Also</h3>

<p><code><a href="testthat.html#topic+expect_equivalent">testthat::expect_equivalent()</a></code>
</p>

<hr>
<h2 id='expect_verb'>Expectations for mocked HTTP requests</h2><span id='topic+expect_verb'></span><span id='topic+expect_GET'></span><span id='topic+expect_POST'></span><span id='topic+expect_PUT'></span><span id='topic+expect_PATCH'></span><span id='topic+expect_DELETE'></span><span id='topic+expect_no_request'></span>

<h3>Description</h3>

<p>The mock contexts in <code>httptest</code> can raise errors or messages when requests
are made, and those (error) messages have three
elements, separated by space: (1) the request
method (e.g. &quot;GET&quot;); (2) the request URL; and
(3) the request body, if present.
These verb-expectation functions look for this message shape. <code>expect_PUT</code>,
for instance, looks for a request message that starts with &quot;PUT&quot;.
</p>
<p>This means that <code>expect_verb</code> functions won't work outside of mock context,
as no error would be raised while making a request. Thus, any <code>expect_verb</code>
function should be wrapped inside a mocking function like
<code><a href="#topic+without_internet">without_internet()</a></code>, as shown in the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_GET(object, url = "", ...)

expect_POST(object, url = "", ...)

expect_PATCH(object, url = "", ...)

expect_PUT(object, url = "", ...)

expect_DELETE(object, url = "", ...)

expect_no_request(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_verb_+3A_object">object</code></td>
<td>
<p>Code to execute that may cause an HTTP request</p>
</td></tr>
<tr><td><code id="expect_verb_+3A_url">url</code></td>
<td>
<p>character: the URL you expect a request to be made to. Default is
an empty string, meaning that you can just assert that a request is made with
a certain method without asserting anything further.</p>
</td></tr>
<tr><td><code id="expect_verb_+3A_...">...</code></td>
<td>
<p>character segments of a request payload you expect to be included
in the request body, to be joined together by <code>paste0</code>. You may also pass
any of the following named logical arguments, which will be passed to
<code><a href="base.html#topic+grep">base::grepl()</a></code>:
</p>

<ul>
<li> <p><code>fixed</code>: Should matching take the pattern as is or treat it as a regular
expression. Default: <code>TRUE</code>, and note that this default is the opposite of
the default in <code>grepl</code>. (The rest of the arguments follow its defaults.)
</p>
</li>
<li> <p><code>ignore.case</code>: Should matching be done case insensitively? Default:
<code>FALSE</code>, meaning matches are case sensitive.
</p>
</li>
<li> <p><code>perl</code>: Should Perl-compatible regular expressions be used? Default: <code>FALSE</code>
</p>
</li>
<li> <p><code>useBytes</code>: Should matching be done byte-by-byte rather than
character-by-character? Default: <code>FALSE</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>testthat</code> 'expectation'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(httr)
# without_internet provides required mock context for expectations
without_internet({
  expect_GET(
    GET("http://httpbin.org/get"),
    "http://httpbin.org/get"
  )
  expect_GET(GET("http://httpbin.org/get"),
    "http://httpbin.org/[a-z]+",
    fixed = FALSE
  ) # For regular expression matching
  expect_PUT(
    PUT("http://httpbin.org/put", body = '{"a":1}'),
    "http://httpbin.org/put",
    '{"a":1}'
  )
  expect_PUT(PUT("http://httpbin.org/put", body = '{"a":1}'))
  expect_no_request(rnorm(5))
})
</code></pre>

<hr>
<h2 id='fake_response'>Return something that looks like a 'response'</h2><span id='topic+fake_response'></span>

<h3>Description</h3>

<p>These functions allow mocking of HTTP requests without requiring an internet
connection or server to run against. Their return shape is a 'httr'
&quot;response&quot; class object that should behave like a real response generated
by a real request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fake_response(
  request,
  verb = "GET",
  status_code = 200,
  headers = list(),
  content = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fake_response_+3A_request">request</code></td>
<td>
<p>An 'httr' <code>request</code>-class object. A character URL is also
accepted, for which a fake request object will be created, using the <code>verb</code>
argument as well.</p>
</td></tr>
<tr><td><code id="fake_response_+3A_verb">verb</code></td>
<td>
<p>Character name for the HTTP verb, if <code>request</code> is a URL. Default
is &quot;GET&quot;.</p>
</td></tr>
<tr><td><code id="fake_response_+3A_status_code">status_code</code></td>
<td>
<p>Integer HTTP response status</p>
</td></tr>
<tr><td><code id="fake_response_+3A_headers">headers</code></td>
<td>
<p>Optional list of additional response headers to return</p>
</td></tr>
<tr><td><code id="fake_response_+3A_content">content</code></td>
<td>
<p>If supplied, a JSON-serializable list that will be returned
as response content with Content-Type: application/json. If no <code>content</code>
is provided, and if the <code>status_code</code> is not 204 No Content, the
<code>url</code> will be set as the response content with Content-Type: text/plain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'httr' response class object.
</p>

<hr>
<h2 id='find_mock_file'>Go through mock paths to find the local mock file location</h2><span id='topic+find_mock_file'></span>

<h3>Description</h3>

<p>Go through mock paths to find the local mock file location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_mock_file(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_mock_file_+3A_file">file</code></td>
<td>
<p>A file path, as generated by <code><a href="#topic+build_mock_url">build_mock_url()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A path to a file that exists, or <code>NULL</code> if none found.
</p>

<hr>
<h2 id='get_current_redactor'>Fetch the active redacting function</h2><span id='topic+get_current_redactor'></span>

<h3>Description</h3>

<p>Called inside <code><a href="#topic+capture_requests">capture_requests()</a></code>. If using the default redactor, it checks
each time it is called to see if any new packages have been attached, in case
there are package redactors in them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_current_redactor()
</code></pre>


<h3>Value</h3>

<p>A redacting function.
</p>

<hr>
<h2 id='get_current_requester'>Fetch the active requesting function</h2><span id='topic+get_current_requester'></span>

<h3>Description</h3>

<p>Called inside <code><a href="#topic+capture_requests">capture_requests()</a></code>. If using the default requester, it checks
each time it is called to see if any new packages have been attached, in case
there are package requesters in them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_current_requester()
</code></pre>


<h3>Value</h3>

<p>A requesting function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_current_redactor">get_current_redactor()</a></code>
</p>

<hr>
<h2 id='gsub_response'>Find and replace within a 'response' or 'request'</h2><span id='topic+gsub_response'></span><span id='topic+gsub_request'></span>

<h3>Description</h3>

<p>These functions pass their arguments to <code><a href="base.html#topic+grep">base::gsub()</a></code> in order to find and
replace string patterns (regular expressions) within <code>request</code> or <code>response</code>
objects. <code>gsub_request()</code> replaces in the request URL and any request body
fields; <code>gsub_response()</code> replaces in the response URL, the response body,
and it calls <code>gsub_request()</code> on the <code>request</code> object found within the
<code>response</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsub_response(response, pattern, replacement, ...)

gsub_request(request, pattern, replacement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsub_response_+3A_response">response</code></td>
<td>
<p>An 'httr' <code>response</code> object to sanitize.</p>
</td></tr>
<tr><td><code id="gsub_response_+3A_pattern">pattern</code></td>
<td>
<p>From <code><a href="base.html#topic+grep">base::gsub()</a></code>: &quot;character string containing a regular
expression (or character string for <code>fixed = TRUE</code>) to be matched in the
given character vector.&quot; Passed to <code>gsub()</code>. See the docs for <code>gsub()</code> for
further details.</p>
</td></tr>
<tr><td><code id="gsub_response_+3A_replacement">replacement</code></td>
<td>
<p>A replacement for the matched pattern, possibly including
regular expression backreferences. Passed to <code>gsub()</code>. See the docs for
<code>gsub()</code> for further details.</p>
</td></tr>
<tr><td><code id="gsub_response_+3A_...">...</code></td>
<td>
<p>Additional logical arguments passed to <code>gsub()</code>: <code>ignore.case</code>,
<code>perl</code>, <code>fixed</code>, and <code>useBytes</code> are the possible options.</p>
</td></tr>
<tr><td><code id="gsub_response_+3A_request">request</code></td>
<td>
<p>An 'httr' <code>request</code> object to sanitize.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, unlike <code>gsub()</code>, the first argument of the function is <code>request</code>
or <code>response</code>,
not <code>pattern</code>, while the equivalent argument in <code>gsub()</code>, &quot;<code>x</code>&quot;, is placed
third. This difference is to maintain consistency with the other redactor
functions in <code>httptest</code>, which all take <code>response</code> as the first argument.
</p>


<h3>Value</h3>

<p>A <code>request</code> or <code>response</code> object, same as was passed in, with the
pattern replaced in the URLs and bodies.
</p>

<hr>
<h2 id='httptest'><code>httptest</code>: A Test Environment for HTTP Requests</h2><span id='topic+httptest'></span><span id='topic+httptest-package'></span>

<h3>Description</h3>

<p>If <span class="pkg">httr</span> makes HTTP easy and <span class="pkg">testthat</span> makes testing fun,
<span class="pkg">httptest</span> makes testing your code that uses HTTP a simple pleasure.
</p>


<h3>Details</h3>

<p>The <code>httptest</code> package lets you test R code that wraps an API without
requiring access to the remote service. It provides three test <strong>contexts</strong>
that mock the network connection in different ways. <code><a href="#topic+with_mock_api">with_mock_api()</a></code> lets
you provide custom fixtures as responses to requests, stored as plain-text
files in your test directory. <code><a href="#topic+without_internet">without_internet()</a></code> converts HTTP requests
into errors that print the request method, URL, and body payload, if
provided, allowing you to assert that a function call would make a
correctly-formed HTTP request or assert that a function does not make a
request (because if it did, it would raise an error in this context).
<code><a href="#topic+with_fake_http">with_fake_http()</a></code> raises a &quot;message&quot; instead of an &quot;error&quot;, and HTTP
requests return a &quot;response&quot;-class object. Like <code>without_internet</code>, it allows
you to assert that the correct requests were (or were not) made, but it
doesn't cause the code to exit with an error.
</p>
<p><code>httptest</code> offers additional <strong>expectations</strong> to assert that HTTP requests
were&mdash;or were not&mdash;made. <code><a href="#topic+expect_GET">expect_GET()</a></code>, <code><a href="#topic+expect_PUT">expect_PUT()</a></code>, <code><a href="#topic+expect_PATCH">expect_PATCH()</a></code>,
<code><a href="#topic+expect_POST">expect_POST()</a></code>, and <code><a href="#topic+expect_DELETE">expect_DELETE()</a></code> assert that the specified HTTP request
is made within one of the test contexts. They catch the error or message
raised by the mocked HTTP service and check that the request URL and optional
body match the expectation. <code><a href="#topic+expect_no_request">expect_no_request()</a></code> is the inverse of those: it
asserts that no error or message from a mocked HTTP service is raised.
<code><a href="#topic+expect_header">expect_header()</a></code> asserts that an HTTP request, mocked or not, contains a
request header. <code><a href="#topic+expect_json_equivalent">expect_json_equivalent()</a></code> checks that two R objects would
generate equivalent JSON, taking into account how JSON objects are unordered
whereas R named lists are ordered.
</p>
<p>For an overview of testing with <code>httptest</code>, see <code>vignette("httptest")</code>.
</p>
<p>The package also includes <code><a href="#topic+capture_requests">capture_requests()</a></code>, a context that collects the
responses from requests you make and stores them as mock files. This enables
you to perform a series of requests against a live server once and then build
your test suite using those mocks, running your tests in <code>with_mock_api</code>.
</p>
<p>When recording requests, by default <code>httptest</code> looks for and redacts the
standard ways that auth credentials are passed in requests. This prevents you
from accidentally publishing your personal tokens. The redacting behavior is
fully customizable, either by providing a <code>function (response) {...}</code> to
<code>set_redactor()</code>, or by placing a function in your package's
<code>inst/httptest/redact.R</code> that will be used automatically any time you record
requests with your package loaded. See <code>vignette("redacting")</code> for details.
</p>
<p><code>httptest</code> also enables you to write package vignettes and other R Markdown
documents that communicate with a remote API. By adding as little as
<code><a href="#topic+start_vignette">start_vignette()</a></code> to the beginning of your vignette, you can safely record
API responses from a live session, using your secret credentials. These API
responses are scrubbed of sensitive personal information and stored in a
subfolder in your <code>vignettes</code> directory. Subsequent vignette builds,
including on continuous-integration services, CRAN, and your package users'
computers, use these recorded responses, allowing the document to regenerate
without a network connection or API credentials. To record fresh API
responses, delete the subfolder of cached responses and re-run. See
<code>vignette("vignettes")</code> for more discussion and links to examples.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Neal Richardson <a href="mailto:neal.p.richardson@gmail.com">neal.p.richardson@gmail.com</a> (<a href="https://orcid.org/0009-0002-7992-3520">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jonathan Keane <a href="mailto:jkeane@gmail.com">jkeane@gmail.com</a> [contributor]
</p>
</li>
<li><p> MaÃ«lle Salmon <a href="mailto:maelle.salmon@yahoo.se">maelle.salmon@yahoo.se</a> (<a href="https://orcid.org/0000-0002-2815-0399">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://enpiar.com/r/httptest/">https://enpiar.com/r/httptest/</a>
</p>
</li>
<li> <p><a href="https://github.com/nealrichardson/httptest">https://github.com/nealrichardson/httptest</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nealrichardson/httptest/issues">https://github.com/nealrichardson/httptest/issues</a>
</p>
</li></ul>


<hr>
<h2 id='public'>Test that functions are exported</h2><span id='topic+public'></span>

<h3>Description</h3>

<p>It's easy to forget to document and export a new function. Using <code>testthat</code>
for your test suite makes it even easier to forget because it evaluates your
test code inside the package's namespace, so internal, non-exported functions
can be accessed. So you might write a new function, get passing tests, and
then tell your package users about the function, but when they try to run it,
they get <code style="white-space: pre;">&#8288;Error: object 'coolNewFunction' not found&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>public(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="public_+3A_...">...</code></td>
<td>
<p>Code to evaluate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrap <code>public()</code> around test blocks to assert that the functions they call
are exported (and thus fail if you haven't documented them with <code style="white-space: pre;">&#8288;@export&#8288;</code>
or otherwise added them to your package NAMESPACE file).
</p>
<p>An alternative way to test that your functions are exported from the package
namespace is with examples in the documentation, which <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> runs
in the global namespace and would thus fail if the functions aren't exported.
However, code that calls remote APIs, potentially requiring specific server
state and authentication, may not be viable to run in examples in
<code style="white-space: pre;">&#8288;R CMD check&#8288;</code>. <code>public()</code> provides a solution that works for these cases
because you can test your namespace exports in the same place where you are
testing the code with API mocks or other safe testing contexts.
</p>


<h3>Value</h3>

<p>The result of <code>...</code> evaluated in the global environment (and not
the package environment).
</p>

<hr>
<h2 id='redact_cookies'>Remove sensitive content from HTTP responses</h2><span id='topic+redact_cookies'></span><span id='topic+redact_headers'></span><span id='topic+within_body_text'></span><span id='topic+redact'></span><span id='topic+redact_auth'></span>

<h3>Description</h3>

<p>When recording requests for use as test fixtures, you don't want to include
secrets like authentication tokens and personal ids. These functions provide
a means for redacting this kind of content, or anything you want, from
responses that <code><a href="#topic+capture_requests">capture_requests()</a></code> saves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redact_cookies(response)

redact_headers(response, headers = c())

within_body_text(response, FUN)

redact_auth(response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redact_cookies_+3A_response">response</code></td>
<td>
<p>An 'httr' <code>response</code> object to sanitize.</p>
</td></tr>
<tr><td><code id="redact_cookies_+3A_headers">headers</code></td>
<td>
<p>For <code>redact_headers()</code>, a character vector of header names to
sanitize. Note that <code>redact_headers()</code> itself does not do redacting but
returns a function that when called does the redacting.</p>
</td></tr>
<tr><td><code id="redact_cookies_+3A_fun">FUN</code></td>
<td>
<p>For <code>within_body_text()</code>, a function that takes as its argument a
character vector and returns a modified version of that. This function will
be applied to the text of the response's &quot;content&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>redact_cookies()</code> removes cookies from 'httr' <code>response</code> objects.
<code>redact_headers()</code> lets you target selected request and response headers for
redaction. <code>redact_auth()</code> is a convenience wrapper around
them for a useful default redactor in <code>capture_requests()</code>.
</p>
<p><code>within_body_text()</code> lets you manipulate the text of the response body
and manages the parsing of the raw (binary) data in the 'response' object.
</p>


<h3>Value</h3>

<p>All redacting functions return a well-formed 'httr' <code>response</code>
object.
</p>


<h3>See Also</h3>

<p><code>vignette("redacting", package="httptest")</code> for a detailed discussion of what these functions do and how to customize them. <code><a href="#topic+gsub_response">gsub_response()</a></code> is another redactor.
</p>

<hr>
<h2 id='save_response'>Write out a captured response</h2><span id='topic+save_response'></span>

<h3>Description</h3>

<p>Write out a captured response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_response(response, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_response_+3A_response">response</code></td>
<td>
<p>An 'httr' <code>response</code> object</p>
</td></tr>
<tr><td><code id="save_response_+3A_simplify">simplify</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), JSON responses with status 200
and a supported <code>Content-Type</code>
will be written as just the text of the response body. In all other cases,
and when <code>simplify</code> is <code>FALSE</code>, the &quot;response&quot; object will be written out to
a .R file using <code><a href="base.html#topic+dput">base::dput()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The character file name that was written out
</p>

<hr>
<h2 id='set_redactor'>Set a response redactor</h2><span id='topic+set_redactor'></span>

<h3>Description</h3>

<p>A redactor is a function that alters the response content being written
out in the <code><a href="#topic+capture_requests">capture_requests()</a></code> context, allowing you to remove sensitive
values, such as authentication tokens,
as well as any other modification or truncation of the response body. By
default, the <code><a href="#topic+redact_auth">redact_auth()</a></code> function will be used to purge standard
auth methods, but <code>set_redactor()</code> allows you to provide a different one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_redactor(FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_redactor_+3A_fun">FUN</code></td>
<td>
<p>A function or expression that modifies <code>response</code> objects.
Specifically, a valid input is one of:
</p>

<ul>
<li><p> A function taking a single argument, the <code>response</code>, and returning a valid
<code>response</code> object.
</p>
</li>
<li><p> A formula as shorthand for an anonymous function with <code>.</code> as the
&quot;response&quot; argument, as in the <code>purrr</code> package. That is, instead of
<code>function (response) redact_headers(response, "X-Custom-Header")</code>, you can
use <code>~ redact_headers(., "X-Custom-Header")</code>
</p>
</li>
<li><p> A list of redacting functions/formulas, which will be executed
in sequence on the response
</p>
</li>
<li> <p><code>NULL</code>, to override the default <code>redact_auth()</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternatively, you can put a redacting function in <code>inst/httptest/redact.R</code>
in your package, and
any time your package is loaded (as in when running tests or building
vignettes), the function will be used automatically.
</p>
<p>For further details on how to redact responses, see <code>vignette("redacting")</code>.
</p>


<h3>Value</h3>

<p>Invisibly, the redacting function, validated and perhaps modified.
Formulas and function lists are turned into proper functions. <code>NULL</code> as input
returns the <code>force()</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_requester">set_requester()</a></code>
</p>

<hr>
<h2 id='set_requester'>Set a request preprocessor</h2><span id='topic+set_requester'></span>

<h3>Description</h3>

<p>Set a request preprocessor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_requester(FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_requester_+3A_fun">FUN</code></td>
<td>
<p>A function or expression that modifies <code>request</code> objects.
Specifically, a valid input is one of:
</p>

<ul>
<li><p> A function taking a single argument, the <code>request</code>, and returning a valid
<code>request</code> object.
</p>
</li>
<li><p> A formula as shorthand for an anonymous function with <code>.</code> as the
&quot;request&quot; argument, as in the <code>purrr</code> package.
</p>
</li>
<li><p> A list of functions/formulas, which will be executed
in sequence on the request.
</p>
</li>
<li> <p><code>NULL</code>, to override the default <code>redact_auth()</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, <code>FUN</code>, validated and perhaps modified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_redactor">set_redactor()</a></code>
</p>

<hr>
<h2 id='skip_if_disconnected'>Skip tests that need an internet connection if you don't have one</h2><span id='topic+skip_if_disconnected'></span>

<h3>Description</h3>

<p>Temporary connection trouble shouldn't fail your build.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skip_if_disconnected(
  message = paste("Offline: cannot reach", url),
  url = "http://httpbin.org/"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skip_if_disconnected_+3A_message">message</code></td>
<td>
<p>character message to be printed, passed to
<code><a href="testthat.html#topic+skip">testthat::skip()</a></code></p>
</td></tr>
<tr><td><code id="skip_if_disconnected_+3A_url">url</code></td>
<td>
<p>character URL to ping to check for a working connection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if you call this from inside one of the mock contexts, it will
follow the mock's behavior. That is, inside <code><a href="#topic+with_fake_http">with_fake_http()</a></code>,
the check will pass and the following tests will run, but inside
<code><a href="#topic+without_internet">without_internet()</a></code>, the following tests will be skipped.
</p>


<h3>Value</h3>

<p>If offline, a test skip; else invisibly returns TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="testthat.html#topic+skip">testthat::skip()</a></code>
</p>

<hr>
<h2 id='start_vignette'>Set mocking/capturing state for a vignette</h2><span id='topic+start_vignette'></span><span id='topic+end_vignette'></span>

<h3>Description</h3>

<p>Use <code>start_vignette()</code> to either use previously recorded responses, if they
exist, or capture real responses for future use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_vignette(path, ...)

end_vignette()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_vignette_+3A_path">path</code></td>
<td>
<p>Root file path for the mocks for this vignette. A good idea is
to use the file name of the vignette itself.</p>
</td></tr>
<tr><td><code id="start_vignette_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>start_capturing()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a vignette or other R Markdown or Sweave document, place
<code>start_vignette()</code> in an R code block at the beginning,
before the first API request is made, and put
<code>end_vignette()</code> in a R code chunk at the end. You may
want to make those R code chunks have <code>echo=FALSE</code> in order to hide the fact
that you're calling them.
</p>
<p>The behavior changes based on the existence of the <code>path</code> directory. The
first time you build the vignette, the directory won't exist yet, so it will
make real requests and record them inside of <code>path</code>. On subsequent runs, the
mocks will be used. To record fresh responses from the server, delete the
<code>path</code> directory, and the responses will be recorded again the next time the
vignette runs.
</p>
<p>If you have additional setup code that you'd like available across all of
your package's vignettes, put it in <code>inst/httptest/start-vignette.R</code> in your
package, and it will be called in <code>start_vignette()</code> before the mock/record
context is set. Similarly, teardown code can go in
<code>inst/httptest/end-vignette.R</code>, evaluated in <code>end_vignette()</code> after mocking
is stopped.
</p>


<h3>Value</h3>

<p>Nothing; called for its side effect of starting/ending
response recording or mocking.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_capturing">start_capturing()</a></code> for how requests are recorded; <code><a href="#topic+use_mock_api">use_mock_api()</a></code>
for how previously recorded requests are loaded; <code><a href="#topic+change_state">change_state()</a></code> for how to
handle recorded requests when the server state is changing;
<code>vignette("vignettes", package="httptest")</code> for an overview of all
</p>

<hr>
<h2 id='stop_mocking'>Turn off request mocking</h2><span id='topic+stop_mocking'></span>

<h3>Description</h3>

<p>This function &quot;untraces&quot; the <code>httr</code> request functions so that normal, real
requesting behavior can be resumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_mocking()
</code></pre>


<h3>Value</h3>

<p>Nothing; called for its side effects
</p>

<hr>
<h2 id='use_httptest'>Use 'httptest' in your tests</h2><span id='topic+use_httptest'></span>

<h3>Description</h3>

<p>This function adds <code>httptest</code> to Suggests in the package DESCRIPTION and
loads it in <code>tests/testthat/setup.R</code>. Call it once when you're setting up
a new package test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_httptest(path = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_httptest_+3A_path">path</code></td>
<td>
<p>character path to the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is idempotent: if <code>httptest</code> is already added to these files, no
additional changes will be made.
</p>


<h3>Value</h3>

<p>Nothing: called for file system side effects.
</p>

<hr>
<h2 id='use_mock_api'>Turn on API mocking</h2><span id='topic+use_mock_api'></span>

<h3>Description</h3>

<p>This function intercepts HTTP requests made through <code>httr</code> and serves mock
file responses instead. It is what <code><a href="#topic+with_mock_api">with_mock_api()</a></code> does, minus the
automatic disabling of mocking when the context finishes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_mock_api()
</code></pre>


<h3>Details</h3>

<p>Note that you in order to resume normal request behavior, you will need to
call <code><a href="#topic+stop_mocking">stop_mocking()</a></code> yourself&mdash;this function does not clean up after itself
as <code>with_mock_api</code> does.
</p>


<h3>Value</h3>

<p>Nothing; called for its side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with_mock_api">with_mock_api()</a></code> <code><a href="#topic+stop_mocking">stop_mocking()</a></code> <code><a href="#topic+block_requests">block_requests()</a></code>
</p>

<hr>
<h2 id='with_fake_http'>Make all HTTP requests return a fake response</h2><span id='topic+with_fake_http'></span>

<h3>Description</h3>

<p>In this context, HTTP verb functions raise a 'message' so that test code can
assert that the requests are made. As in <code><a href="#topic+without_internet">without_internet()</a></code>, the message
raised has a well-defined shape, made of three
elements, separated by space: (1) the request
method (e.g. &quot;GET&quot; or &quot;POST&quot;); (2) the request URL; and
(3) the request body, if present. The verb-expectation functions,
such as <code>expect_GET</code> and <code>expect_POST</code>, look for this shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_fake_http(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_fake_http_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the fake context</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code>without_internet</code>,
the HTTP functions do not error and halt execution, instead returning a
<code>response</code>-class object so that code calling the HTTP functions can
proceed with its response handling logic and itself be tested. The response
it returns echoes back most of the request itself, similar to how some
endpoints on <a href="http://httpbin.org">http://httpbin.org</a> do.
</p>


<h3>Value</h3>

<p>The result of <code>expr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with_fake_http({
  expect_GET(req1 &lt;- httr::GET("http://example.com"), "http://example.com")
  req1$url
  expect_POST(
    req2 &lt;- httr::POST("http://example.com", body = '{"a":1}'),
    "http://example.com"
  )
  httr::content(req2)
})
</code></pre>

<hr>
<h2 id='with_mock_api'>Serve a mock API from files</h2><span id='topic+with_mock_api'></span>

<h3>Description</h3>

<p>In this context, HTTP requests attempt to load API response fixtures from
files. This allows test code to proceed evaluating code that expects
HTTP requests to return meaningful responses. Requests that do not have a
corresponding fixture file raise errors, like how <code><a href="#topic+without_internet">without_internet()</a></code>
does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mock_api(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_mock_api_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the fake context</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requests are translated to mock file paths according to several rules that
incorporate the request method, URL, query parameters, and body. See
<code><a href="#topic+build_mock_url">build_mock_url()</a></code> for details.
</p>
<p>File paths for API fixture files may be relative to the 'tests/testthat'
directory, i.e. relative to the .R test files themselves. This is the default
location for storing and retrieving mocks, but you can put them anywhere you
want as long as you set the appropriate location with <code><a href="#topic+.mockPaths">.mockPaths()</a></code>.
</p>


<h3>Value</h3>

<p>The result of <code>expr</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use_mock_api">use_mock_api()</a></code> to enable mocking on its own (not in a context); <code><a href="#topic+build_mock_url">build_mock_url()</a></code>; <code><a href="#topic+.mockPaths">.mockPaths()</a></code>
</p>

<hr>
<h2 id='with_mock_dir'>Use or create mock files depending on their existence</h2><span id='topic+with_mock_dir'></span>

<h3>Description</h3>

<p>This context will switch the <code><a href="#topic+.mockPaths">.mockPaths()</a></code> to <code>tests/testthat/dir</code>
(and then resets it to what it was before).
If the <code>tests/testthat/dir</code> folder doesn't exist, <code><a href="#topic+capture_requests">capture_requests()</a></code> will
be run to create mocks.
If it exists, <code><a href="#topic+with_mock_api">with_mock_api()</a></code> will be run.
To re-record mock files, simply delete <code>tests/testthat/dir</code> and run the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mock_dir(dir, expr, simplify = TRUE, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_mock_dir_+3A_dir">dir</code></td>
<td>
<p>character string, unique folder name that will be used or created
under <code style="white-space: pre;">&#8288;tests/testthat/&#8288;</code></p>
</td></tr>
<tr><td><code id="with_mock_dir_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the fake context</p>
</td></tr>
<tr><td><code id="with_mock_dir_+3A_simplify">simplify</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), JSON responses with status 200
will be written as just the text of the response body. In all other cases,
and when <code>simplify</code> is <code>FALSE</code>, the &quot;response&quot; object will be written out to
a .R file using <code><a href="base.html#topic+dput">base::dput()</a></code>.</p>
</td></tr>
<tr><td><code id="with_mock_dir_+3A_replace">replace</code></td>
<td>
<p>Logical: should the mock directory replace current mock
directories? Default is <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='with_trace'>Wrapper around 'trace' to untrace when finished</h2><span id='topic+with_trace'></span>

<h3>Description</h3>

<p>Wrapper around 'trace' to untrace when finished
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_trace(
  x,
  where = topenv(parent.frame()),
  print = getOption("httptest.debug", FALSE),
  ...,
  expr
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_trace_+3A_x">x</code></td>
<td>
<p>Name of function to trace. See <code><a href="base.html#topic+trace">base::trace()</a></code>.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_where">where</code></td>
<td>
<p>where to look for the function to be traced.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_print">print</code></td>
<td>
<p>Logical: print a message every time the traced function is hit?
Default is <code>FALSE</code>; note that in <code>trace</code>, the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>trace</code>. At minimum, must include
either <code>tracer</code> or <code>exit</code>.</p>
</td></tr>
<tr><td><code id="with_trace_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the context</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of <code>expr</code>
</p>

<hr>
<h2 id='without_internet'>Make all HTTP requests raise an error</h2><span id='topic+without_internet'></span>

<h3>Description</h3>

<p><code>without_internet</code> simulates the situation when any network request will
fail, as in when you are without an internet connection. Any HTTP request
through the verb functions in <code>httr</code> will raise an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>without_internet(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="without_internet_+3A_expr">expr</code></td>
<td>
<p>Code to run inside the mock context</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The error message raised has a well-defined shape, made of three
elements, separated by space: (1) the request
method (e.g. &quot;GET&quot;); (2) the request URL; and
(3) the request body, if present. The verb-expectation functions,
such as <code><a href="#topic+expect_GET">expect_GET()</a></code> and <code><a href="#topic+expect_POST">expect_POST()</a></code>, look for this shape.
</p>


<h3>Value</h3>

<p>The result of <code>expr</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+block_requests">block_requests()</a></code> to enable mocking on its own (not in a context)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>without_internet({
  expect_error(
    httr::GET("http://httpbin.org/get"),
    "GET http://httpbin.org/get"
  )
  expect_error(httr::PUT("http://httpbin.org/put",
    body = '{"a":1}'
  ),
  'PUT http://httpbin.org/put {"a":1}',
  fixed = TRUE
  )
})
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
