<!DOCTYPE html><html><head><title>Help for package demu</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {demu}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#demu-package'>
<p><code>demu</code> is an open-source R package implementing a Gaussian process optimal design emulator based on Determinantal point processes.</p></a></li>
<li><a href='#generalized.wendland'><p>Calculate the correlation matrix according to the generalized Wendland model.</p></a></li>
<li><a href='#getranges'><p>Get variable ranges from a design matrix.</p></a></li>
<li><a href='#makedistlist'><p>Make list of distance matrices for calculating GP correlation matrices.</p></a></li>
<li><a href='#matern32'><p>Calculate the correlation matrix according to the Matern model with <code class="reqn">\nu=3/2</code>.</p></a></li>
<li><a href='#matern52'><p>Calculate the correlation matrix according to the Matern model with <code class="reqn">\nu=5/2</code>.</p></a></li>
<li><a href='#remove.projections'><p>Identify candidate points making up all marginal subprojections of an existing design.</p></a></li>
<li><a href='#rhomat'><p>Calculate the correlation matrix according to the squared exponential family of models.</p></a></li>
<li><a href='#scaledesign'><p>Rescale a design matrix to the [0,1] hypercube.</p></a></li>
<li><a href='#sim.dpp.modal'><p>Draw samples from the conditional DPP design emulator.</p></a></li>
<li><a href='#sim.dpp.modal.fast'><p>Draw samples from the conditional DPP design emulator.</p></a></li>
<li><a href='#sim.dpp.modal.fast.seq'><p>Draw sequential samples from the conditional DPP given previously sampled points already in the design.</p></a></li>
<li><a href='#sim.dpp.modal.np'><p>Draw samples from the conditional DPP design emulator using a kmeans-based Nystrom approximation.</p></a></li>
<li><a href='#sim.dpp.modal.nystrom'><p>Draw samples from the conditional DPP design emulator using grid-based Nystrom approximation.</p></a></li>
<li><a href='#sim.dpp.modal.nystrom.kmeans'><p>Subsample an observational dataset using the conditional DPP design emulator with a kmeans-based Nystrom approximation.</p></a></li>
<li><a href='#sim.dpp.modal.seq'><p>Draw sequential samples from the conditional DPP given previously sampled points already in the design.</p></a></li>
<li><a href='#unscalemat'><p>Unscale a matrix back to its original ranges.</p></a></li>
<li><a href='#wendland1'><p>Calculate the correlation matrix according to the Wendland1 model.</p></a></li>
<li><a href='#wendland2'><p>Calculate the correlation matrix according to the Wendland2 model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Design Emulators via Point Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew T. Pratola &lt;mpratola@stat.osu.edu&gt; [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew T. Pratola &lt;mpratola@stat.osu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Determinantal point process (DPP) based optimal design
    emulator described in Pratola, Lin and Craigmile (2018) &lt;<a href="https://arxiv.org/abs/1804.02089">arXiv:1804.02089</a>&gt; for
    Gaussian process regression models.  See <a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>
    for more information and examples.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12), stats, fields, spam, Matrix, ClusterR</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-11 02:56:06 UTC; mpratola</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-13 09:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='demu-package'>
<code>demu</code> is an open-source R package implementing a Gaussian process optimal design emulator based on Determinantal point processes.
</h2><span id='topic+demu-package'></span>

<h3>Description</h3>

<p><code>demu</code> implements a determinantal point process emulator for probabilistically sampling optimal designs for Gaussian process (GP) regression models. Currently, <code>demu</code> is a proof of concept implementation that implements basic DPP sampling, conditional DPP sampling for drawing designs of fixed size <code>n</code>, sequential DPP sampling to build designs iteratively and a faster C++ implementation of the conditional DPP sampler using sparse matrices.  The package supports popular stationary correlation functions commonly used in GP regression models, including the Gaussian and Wendland correlation functions.
</p>


<h3>Details</h3>

<p>The main model fitting functions in the package include <code>sim.dpp.modal()</code> for dense correlation matrices and <code>sim.dpp.modal.fast()</code> for sparse correlation matrices. These functions use a grid-based approximation to sample from the relevant DPP model.
</p>


<h3>Author(s)</h3>

<p>Matthew T. Pratola &lt;mpratola@stat.osu.edu&gt; [aut, cre, cph]
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.dpp.modal">sim.dpp.modal</a>,<a href="#topic+sim.dpp.modal.fast">sim.dpp.modal.fast</a>,<a href="#topic+sim.dpp.modal.seq">sim.dpp.modal.seq</a>,<a href="#topic+sim.dpp.modal.fast.seq">sim.dpp.modal.fast.seq</a></code>
</p>

<hr>
<h2 id='generalized.wendland'>Calculate the correlation matrix according to the generalized Wendland model.</h2><span id='topic+generalized.wendland'></span>

<h3>Description</h3>

<p><code>generalized.wendland()</code> is a helper function that constructs a correlation matrix according to the generalized Wendland model with lengthscales given by the parameter vector <code>theta</code>.  When <code>kap=0</code> the correlation model corresponds to the Askey correlation model.  The design must have been already formated in distlist format using the function <code>makedistlist()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generalized.wendland(l.d,theta, kap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalized.wendland_+3A_l.d">l.d</code></td>
<td>
<p>Current design distance matrices in distlist format</p>
</td></tr>
<tr><td><code id="generalized.wendland_+3A_theta">theta</code></td>
<td>
<p>A vector of range parameters</p>
</td></tr>
<tr><td><code id="generalized.wendland_+3A_kap">kap</code></td>
<td>
<p>A non-negative scalar parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the constructed correlation matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+rhomat">rhomat</a></code>
<code><a href="#topic+matern32">matern32</a></code>
<code><a href="#topic+matern52">matern52</a></code>
<code><a href="#topic+wendland1">wendland1</a></code>
<code><a href="#topic+wendland2">wendland2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,0,1),ncol=2,nrow=5)
theta=0.3
kap=3
l.d=makedistlist(design)
R=generalized.wendland(l.d,theta,kap)$R
R
</code></pre>

<hr>
<h2 id='getranges'>Get variable ranges from a design matrix.</h2><span id='topic+getranges'></span>

<h3>Description</h3>

<p><code>getranges()</code> is a helper function to get the lower/upper bounds of variables in a design matrix, used for rescaling the inputs to the <code class="reqn">[0,1]</code> hypercube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getranges(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getranges_+3A_design">design</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of input settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">p \times 2</code> matrix with the lower and upper bounds (rounded to nearest integer value) of all <code class="reqn">p</code> variables in the design matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
getranges(design)
</code></pre>

<hr>
<h2 id='makedistlist'>Make list of distance matrices for calculating GP correlation matrices.</h2><span id='topic+makedistlist'></span>

<h3>Description</h3>

<p><code>makedistlist()</code> is a helper function used to setup the difference matrices that are used by the DPP models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makedistlist(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makedistlist_+3A_design">design</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of input settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code class="reqn">p</code> matrices, each of dimension <code class="reqn">n \times n</code> that contain the outer subtractions of each variable in the design matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getranges">getranges</a></code>
<code><a href="#topic+scaledesign">scaledesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
r=getranges(design)
design=scaledesign(design,r)
l.v=makedistlist(design)
</code></pre>

<hr>
<h2 id='matern32'>Calculate the correlation matrix according to the Matern model with <code class="reqn">\nu=3/2</code>.</h2><span id='topic+matern32'></span>

<h3>Description</h3>

<p><code>matern32()</code> is a helper function that constructs a correlation matrix according to the Matern model with parameter <code class="reqn">\nu=3/2</code> and lengthscales given by the parameter vector <code>theta</code>.  The design must have been already formated in distlist format using the function <code>makedistlist()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern32(l.d,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern32_+3A_l.d">l.d</code></td>
<td>
<p>Current design distance matrices in distlist format</p>
</td></tr>
<tr><td><code id="matern32_+3A_theta">theta</code></td>
<td>
<p>A vector of range parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the constructed correlation matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+rhomat">rhomat</a></code>
<code><a href="#topic+matern52">matern52</a></code>
<code><a href="#topic+wendland1">wendland1</a></code>
<code><a href="#topic+wendland2">wendland2</a></code>
<code><a href="#topic+generalized.wendland">generalized.wendland</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,0,1),ncol=2,nrow=5)
theta=rep(0.2,2)
l.d=makedistlist(design)
R=matern32(l.d,theta)$R
R
</code></pre>

<hr>
<h2 id='matern52'>Calculate the correlation matrix according to the Matern model with <code class="reqn">\nu=5/2</code>.</h2><span id='topic+matern52'></span>

<h3>Description</h3>

<p><code>matern52()</code> is a helper function that constructs a correlation matrix according to the Matern model with parameter <code class="reqn">\nu=5/2</code> and lengthscales given by the parameter vector <code>theta</code>.  The design must have been already formated in distlist format using the function <code>makedistlist()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern52(l.d,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern52_+3A_l.d">l.d</code></td>
<td>
<p>Current design distance matrices in distlist format</p>
</td></tr>
<tr><td><code id="matern52_+3A_theta">theta</code></td>
<td>
<p>A vector of range parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the constructed correlation matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+rhomat">rhomat</a></code>
<code><a href="#topic+matern32">matern32</a></code>
<code><a href="#topic+wendland1">wendland1</a></code>
<code><a href="#topic+wendland2">wendland2</a></code>
<code><a href="#topic+generalized.wendland">generalized.wendland</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,0,1),ncol=2,nrow=5)
theta=rep(0.2,2)
l.d=makedistlist(design)
R=matern52(l.d,theta)$R
R
</code></pre>

<hr>
<h2 id='remove.projections'>Identify candidate points making up all marginal subprojections of an existing design.</h2><span id='topic+remove.projections'></span>

<h3>Description</h3>

<p><code>remove.projections()</code> is a helper function to identify all lower-dimensional marginal projection points of the existing design points indexed by <code>curpts</code>.  This function can be used to remove a subset of points from the <em>candidate set</em> in order to enforce non-collapsingness of when sequentially adding design points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.projections(curpts,X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.projections_+3A_curpts">curpts</code></td>
<td>
<p>Indices of points currently in the design</p>
</td></tr>
<tr><td><code id="remove.projections_+3A_x">X</code></td>
<td>
<p>An <code>n x p</code> matrix of all candidate points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the vector <code>curpts</code>, the vector <code>projpts</code> which contains the identified projection points of the current design, and <code>allpts</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal.seq">sim.dpp.modal.seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

n1=3
n2=3
n3=3
rho=rep(1e-10,2)
ngrid=10

x=seq(0,1,length=ngrid)
X=as.matrix(expand.grid(x,x))
l.d=makedistlist(X)

# Initial design
R=rhomat(l.d,rho)$R
pts.1=sim.dpp.modal(R,n1)
pts.1.proj=remove.projections(pts.1,X)

# Plot - design points in black, design+projection points in grey.
#plot(X,xlim=c(0,1),ylim=c(0,1))
#points(X[pts.1.proj$projpts,],pch=20,cex=2,col="grey")
#points(X[pts.1,],pch=20,cex=2)
</code></pre>

<hr>
<h2 id='rhomat'>Calculate the correlation matrix according to the squared exponential family of models.</h2><span id='topic+rhomat'></span>

<h3>Description</h3>

<p><code>rhomat()</code> is a helper function that constructs a correlation matrix according to the squared exponential model with parameterized by correlation parameters <code>rho</code> taking values in [0,1) and the exponent parameter <code>alpha</code>.  The default of <code>alpha=2</code> results in the Gaussian correlation while selecting <code>alpha=1</code> corresponds to the Exponential correlation model.  The design must have been already formated in distlist format using the function <code>makedistlist()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhomat(l.d,rho,alpha=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhomat_+3A_l.d">l.d</code></td>
<td>
<p>Current design distance matrices in distlist format</p>
</td></tr>
<tr><td><code id="rhomat_+3A_rho">rho</code></td>
<td>
<p>A vector of correlation parameters taking on values in [0,1)</p>
</td></tr>
<tr><td><code id="rhomat_+3A_alpha">alpha</code></td>
<td>
<p>Exponent parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the constructed correlation matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+matern52">matern52</a></code>
<code><a href="#topic+wendland1">wendland1</a></code>
<code><a href="#topic+wendland2">wendland2</a></code>
<code><a href="#topic+generalized.wendland">generalized.wendland</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,0,1),ncol=2,nrow=5)
rho=rep(0.01,2)
l.d=makedistlist(design)
R=rhomat(l.d,rho)$R
R
</code></pre>

<hr>
<h2 id='scaledesign'>Rescale a design matrix to the [0,1] hypercube.</h2><span id='topic+scaledesign'></span>

<h3>Description</h3>

<p><code>scaledesign()</code> is a helper function to rescale a design to the <code class="reqn">[0,1]</code> hypercube using variable ranges previously extracted by a call to <code>getranges()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaledesign(design,r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaledesign_+3A_design">design</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of input settings</p>
</td></tr>
<tr><td><code id="scaledesign_+3A_r">r</code></td>
<td>
<p>An <code class="reqn">p \times 2</code> matrix of variable ranges extracted from <code>getranges()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n \times p</code> design matrix rescaled to the <code class="reqn">[0,1]</code> hypercube.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unscalemat">unscalemat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
r=getranges(design)
scaledesign(design,r)

</code></pre>

<hr>
<h2 id='sim.dpp.modal'>Draw samples from the conditional DPP design emulator.</h2><span id='topic+sim.dpp.modal'></span>

<h3>Description</h3>

<p><code>sim.dpp.modal()</code> uses the DPP-based design emulator of Pratola et al. (2018)
to draw a sample of the <code>n</code>-run optimal design for a Gaussian process
regression model with stationary correlation function <code class="reqn">r(x,x^\prime)</code>, where the
entries of <code>R</code> are formed by evaluating <code class="reqn">r(x,x^\prime)</code> over a grid of candidate 
locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dpp.modal(R,n=0,eigs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.dpp.modal_+3A_r">R</code></td>
<td>
<p>A correlation matrix evaluated over a grid of candidate design sites.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal_+3A_n">n</code></td>
<td>
<p>Size of the design to sample.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal_+3A_eigs">eigs</code></td>
<td>
<p>One can alternatively pass the pre-computed eigendecomposition of the correlation matrix instead of <code>R</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the method, see Pratola et al. (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A vector of indices to the sampled design sites.
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal.fast">sim.dpp.modal.fast</a></code>
<code><a href="#topic+sim.dpp.modal.seq">sim.dpp.modal.seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

# candidate grid
ngrid=20
x=seq(0,1,length=ngrid)
X=as.matrix(expand.grid(x,x))
l.d=makedistlist(X)

# draw design from DPP mode
n=21
rho=0.01
R=rhomat(l.d,rep(rho,2))$R
pts=sim.dpp.modal(R,n)

# Could plot the result:
# plot(X,xlim=c(0,1),ylim=c(0,1))
# points(X[pts,],pch=20)
</code></pre>

<hr>
<h2 id='sim.dpp.modal.fast'>Draw samples from the conditional DPP design emulator.</h2><span id='topic+sim.dpp.modal.fast'></span>

<h3>Description</h3>

<p><code>sim.dpp.modal.fast()</code> is similar to <code>sim.dpp.modal</code> but is a C++ codepath that makes use of
SPAM's sparse matrices to enable faster computation.  It implements the DPP-based design 
emulator of Pratola et al. (2018) to draw a sample of the <code>n</code>-run optimal design for a Gaussian 
process regression model with compact correlation function <code class="reqn">r(x,x^\prime)</code>, where the entries 
of <code>R</code> are formed by evaluating <code class="reqn">r(x,x^\prime)</code> over a grid of candidate locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dpp.modal.fast(R,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.dpp.modal.fast_+3A_r">R</code></td>
<td>
<p>A sparse correlation matrix evaluated over a grid of candidate design sites.  The sparse matrix should be of type <code>dgCMatrix</code> (see package spam).</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.fast_+3A_n">n</code></td>
<td>
<p>Size of the design to sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the method, see Pratola et al. (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A vector of indices to the sampled design sites.
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal">sim.dpp.modal</a></code>
<code><a href="#topic+sim.dpp.modal.seq">sim.dpp.modal.seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)
library(fields)
library(spam)
library(Matrix)
library(Rcpp)

# candidate grid
ngrid=20
x=seq(0,1,length=ngrid)
X=as.matrix(expand.grid(x,x))

# draw design from DPP mode
n=21
theta=0.39
R.spam=wendland.cov(X,X,theta=theta,k=3) 
R=as.dgCMatrix.spam(R.spam)
rm(R.spam)
pts=sim.dpp.modal.fast(R,n)

# Could plot the result:
# plot(X,xlim=c(0,1),ylim=c(0,1))
# points(X[pts,],pch=20)
</code></pre>

<hr>
<h2 id='sim.dpp.modal.fast.seq'>Draw sequential samples from the conditional DPP given previously sampled points already in the design.</h2><span id='topic+sim.dpp.modal.fast.seq'></span>

<h3>Description</h3>

<p><code>sim.dpp.modal.fast.seq()</code> is similar to <code>sim.dpp.modal.fast</code> but sequentially selects <code>n</code> additional points to 
add to the design given that the points in <code>curpts</code> are alread in the design from previous sequential 
iterations.  
It uses the C++ codepath that makes use of
SPAM's sparse matrices to enable faster computation.  It implements the DPP-based design 
emulator of Pratola et al. (2018) to draw a sequential sample of the <code>n</code>-run additional optimal design points for a Gaussian 
process regression model with compact correlation function <code class="reqn">r(x,x^\prime)</code>, where the entries 
of <code>R</code> are formed by evaluating <code class="reqn">r(x,x^\prime)</code> over a grid of candidate locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dpp.modal.fast.seq(curpts, R,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.dpp.modal.fast.seq_+3A_curpts">curpts</code></td>
<td>
<p>A vector of indices to the candidate points that already appear in the design.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.fast.seq_+3A_r">R</code></td>
<td>
<p>A sparse correlation matrix evaluated over a grid of candidate design sites.  The sparse matrix should be of type <code>dgCMatrix</code> (see package spam).</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.fast.seq_+3A_n">n</code></td>
<td>
<p>Size of the design to sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the method, see Pratola et al. (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A vector of indices to the sampled design sites.
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal.fast">sim.dpp.modal.fast</a></code>
<code><a href="#topic+sim.dpp.modal">sim.dpp.modal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)
library(fields)
library(spam)
library(Matrix)

n1=3
n2=3
n3=3
rho=0.2
ngrid=10

x=seq(0,1,length=ngrid)
X=as.matrix(expand.grid(x,x))
l.d=makedistlist(X)

# Initial design
R.spam=wendland.cov(X,X,theta=rho,k=3)
R=as.dgCMatrix.spam(R.spam)
pts.1=sim.dpp.modal.fast(R,n1)
pts.1.proj=remove.projections(pts.1,X)

# Next sequential step, removing projections
pts.2=sim.dpp.modal.fast.seq(pts.1.proj$allpts,R,n2)
design=c(pts.1,pts.2$pts.new)
pts.2.proj=remove.projections(design,X)

# Next sequential step, removing projections
pts.3=sim.dpp.modal.fast.seq(pts.2.proj$allpts,R,n3)
design=c(design,pts.3$pts.new)


# Or, starting with the initial design, don't remove projections
pts.2=sim.dpp.modal.fast.seq(pts.1,R,n2)
designB=c(pts.1,pts.2$pts.new)

pts.3=sim.dpp.modal.fast.seq(designB,R,n3)
designB=c(designB,pts.3$pts.new)


# Plot the result:
#par(mfrow=c(1,3))
#plot(X,xlim=c(0,1),ylim=c(0,1),main="Initial Design")
#points(X[pts.1,],pch=20,cex=2)
#
#plot(X,xlim=c(0,1),ylim=c(0,1),main="+3x2 remove projections")
#points(X[design,],pch=20,cex=2)
#
#plot(X,xlim=c(0,1),ylim=c(0,1),main="+3x2 not removing projections")
#points(X[designB,],pch=20,cex=2)
</code></pre>

<hr>
<h2 id='sim.dpp.modal.np'>Draw samples from the conditional DPP design emulator using a kmeans-based Nystrom approximation.</h2><span id='topic+sim.dpp.modal.np'></span>

<h3>Description</h3>

<p><code>sim.dpp.modal.np()</code> uses <code>sim.dpp.modal.nystrom.kmeans()</code> to draw a design of <code>n</code> points in <code>p</code> dimensions using the kmeans-based Nystrom approximation of Zhang and Kwok (2010) and the DPP-based design emulator of Pratola et al. (2018).  The design constructed assumes a Gaussian process
regression model with stationary correlation function <code class="reqn">r(x,x^\prime)</code>, where the
entries of <code>R</code> are formed by evaluating <code class="reqn">r(x,x^\prime)</code> over a set of landmarks chosen by the kmeans algorithm, and the resulting eigenvectors are projected into the higher dimensional space using the Nystrom approximation.  Additional options for <code>sim.dpp.modal.nystrom.kmeans()</code> can be passed to alter the construction of the landmark set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dpp.modal.np(n,p,N,rho,m=max(ceiling(N*0.1),n),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.dpp.modal.np_+3A_n">n</code></td>
<td>
<p>Size of the desired design.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.np_+3A_p">p</code></td>
<td>
<p>Dimension of the desired design.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.np_+3A_n">N</code></td>
<td>
<p>Number of kernel approximation points drawn uniformly from the <code>p</code>-dimensional design space.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.np_+3A_rho">rho</code></td>
<td>
<p>The <code class="reqn">p\times 1</code> parameter vector for the Gaussian correlation model.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.np_+3A_m">m</code></td>
<td>
<p>Number of landmark points to use in constructing the kmeans-based Nystrom approximation.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.np_+3A_...">...</code></td>
<td>
<p>Additional options to pass to <code>sim.dpp.modal.nystrom.kmeans()</code> for drawing the design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the method, see Pratola et al. (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A list containing a matrix which is the union of the <code class="reqn">N\times p</code> uniformly sampled kernel approximation points and the <code>m</code> selected landmark sites, and the indices into this matrix of the selected design sites.
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>
<p>Zhang, Kai and Kwok, James T. (2010)
Clustered Nystrom method for large scale manifold learning and dimension reduction.
<em>IEEE Transactions on Neural Networks</em>, <b>21.10</b>, 1576&ndash;1587.
doi: <a href="https://doi.org/10.1109/TNN.2010.2064786">10.1109/TNN.2010.2064786</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal">sim.dpp.modal</a></code>
<code><a href="#topic+sim.dpp.modal.nystrom.kmeans">sim.dpp.modal.nystrom.kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

n=50
p=5
N=500
rho=rep(0.01,5)
samp=sim.dpp.modal.np(n,p,N,rho)

# Could plot the result:
# pchvec=rep(1,nrow(samp$X))
# pchvec[samp$pts]=20
# cexvec=rep(0.1,nrow(samp$X))
# cexvec[samp$pts]=1
# colvec=rep("black",nrow(samp$X))
# colvec[samp$pts]="red"
# pairs(samp$X,pch=pchvec,cex=cexvec,col=colvec,xlim=c(0,1),ylim=c(0,1))
</code></pre>

<hr>
<h2 id='sim.dpp.modal.nystrom'>Draw samples from the conditional DPP design emulator using grid-based Nystrom approximation.</h2><span id='topic+sim.dpp.modal.nystrom'></span>

<h3>Description</h3>

<p><code>sim.dpp.modal.nystrom()</code> uses the DPP-based design emulator of Pratola et al. (2018)
to draw a sample of the <code>n</code>-run optimal design for a Gaussian process
regression model with stationary correlation function <code class="reqn">r(x,x^\prime)</code>, where the
entries of <code>R</code> are formed by evaluating <code class="reqn">r(x,x^\prime)</code> over a grid of candidate 
locations.  This function uses a grid-based Nystrom approximation based on the passed matrix <code>X</code> to avoid constructing a large correlation matrix if dimension <code>ngrid^p</code> and its subsequent eigendecomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dpp.modal.nystrom(Xin,rho,n=0,ngrid=NULL,method="Nystrom")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.dpp.modal.nystrom_+3A_xin">Xin</code></td>
<td>
<p>A initial <code class="reqn">n\times p</code> matrix of points.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom_+3A_rho">rho</code></td>
<td>
<p>The <code class="reqn">p\times 1</code> parameter vector for the Gaussian correlation model.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom_+3A_n">n</code></td>
<td>
<p>Size of the design to sample from the candidate grid.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom_+3A_ngrid">ngrid</code></td>
<td>
<p>Size of the candidate grid will be <code>ngrid^p</code>.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom_+3A_method">method</code></td>
<td>
<p>Type of approximation to use.  Currently only supports &ldquo;Nystrom&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the method, see Pratola et al. (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A list containing the candidate points constructed and the points selected as the design sites from this candidate set as well as their indices.
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal">sim.dpp.modal</a></code>
<code><a href="#topic+sim.dpp.modal.nystrom.kmeans">sim.dpp.modal.nystrom.kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

# Starting design
X=matrix(runif(10*2),ncol=2)
rho=rep(0.01,2)
n=10
ngrid=11
samp=sim.dpp.modal.nystrom(X,rho,n,ngrid)
samp$design

# Could plot the result:
# plot(samp$X,xlim=c(0,1),ylim=c(0,1))
# points(samp$X[samp$pts,],pch=20)
</code></pre>

<hr>
<h2 id='sim.dpp.modal.nystrom.kmeans'>Subsample an observational dataset using the conditional DPP design emulator with a kmeans-based Nystrom approximation.</h2><span id='topic+sim.dpp.modal.nystrom.kmeans'></span>

<h3>Description</h3>

<p><code>sim.dpp.modal.nystrom.kmeans()</code> uses the kmeans-based Nystrom approximation of Zhang and Kwok (2010) to select <code>n</code> design sites from the observational dataset <code>Xin</code> using the DPP-based design emulator of Pratola et al. (2018).  The design constructed assumes a Gaussian process
regression model with stationary correlation function <code class="reqn">r(x,x^\prime)</code>, where the
entries of <code>R</code> are formed by evaluating <code class="reqn">r(x,x^\prime)</code> over a set of landmarks chosen by the kmeans algorithm, and the resulting eigenvectors are projected into the higher dimensional space using the Nystrom approximation.  Additional options for the <code>MiniBatchKmeans()</code> algorithm from package <code>ClusterR</code> can be passed to alter the construction of the landmark set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dpp.modal.nystrom.kmeans(Xin,rho=rep(0.01,ncol(Xin)),
  n,m=max(ceiling(nrow(Xin)*0.1),n),method="KmeansNystrom",
  initializer="kmeans++",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.dpp.modal.nystrom.kmeans_+3A_xin">Xin</code></td>
<td>
<p>An <code class="reqn">n\times p</code> dataset of observations from which we want to draw subsamples.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom.kmeans_+3A_n">n</code></td>
<td>
<p>Size of the designed subsample to draw from <code>Xall</code>.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom.kmeans_+3A_rho">rho</code></td>
<td>
<p>The <code class="reqn">p\times 1</code> parameter vector for the Gaussian correlation model.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom.kmeans_+3A_m">m</code></td>
<td>
<p>Number of landmark points to use in constructing the kmeans-based Nystrom approximation.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom.kmeans_+3A_method">method</code></td>
<td>
<p>Type of approximation to use.  Currently only supports &ldquo;KmeansNystrom&rdquo;.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom.kmeans_+3A_initializer">initializer</code></td>
<td>
<p>Initialization to use in the Kmeans algorithm, default is &ldquo;kmeans++&rdquo;.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.nystrom.kmeans_+3A_...">...</code></td>
<td>
<p>Additional options to pass to <code>MiniBatchKmeans()</code> for selecting the landmark points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the method, see Pratola et al. (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A list containing a matrix which is the union of the observation matrix <code>Xin</code> and selected landmark sites, the indices into this matrix of the selected design sites as well as matrix of the design sites.
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>
<p>Zhang, Kai and Kwok, James T. (2010)
Clustered Nystrom method for large scale manifold learning and dimension reduction.
<em>IEEE Transactions on Neural Networks</em>, <b>21.10</b>, 1576&ndash;1587.
doi: <a href="https://doi.org/10.1109/TNN.2010.2064786">10.1109/TNN.2010.2064786</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal">sim.dpp.modal</a></code>
<code><a href="#topic+sim.dpp.modal.nystrom">sim.dpp.modal.nystrom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

# Fake dataset in 5 dimensions
X=matrix(runif(500*5),ncol=5)
rho=rep(0.01,5)
n=50
samp=sim.dpp.modal.nystrom.kmeans(X,rho,n)
samp$design

# Could plot the result:
# pchvec=rep(1,nrow(samp$X))
# pchvec[samp$pts]=20
# cexvec=rep(0.1,nrow(samp$X))
# cexvec[samp$pts]=1
# colvec=rep("black",nrow(samp$X))
# colvec[samp$pts]="red"
# pairs(samp$X,pch=pchvec,cex=cexvec,col=colvec,xlim=c(0,1),ylim=c(0,1))
</code></pre>

<hr>
<h2 id='sim.dpp.modal.seq'>Draw sequential samples from the conditional DPP given previously sampled points already in the design.</h2><span id='topic+sim.dpp.modal.seq'></span>

<h3>Description</h3>

<p><code>sim.dpp.modal.seq()</code> is similar to <code>sim.dpp.modal</code> but sequentially selects <code>n</code> additional points to 
add to the design given that the points in <code>curpts</code> are alread in the design from previous sequential 
iterations.  It implements the DPP-based design emulator of Pratola et al. (2018) to draw a sequential 
sample of <code>n</code>-run additional optimal design points for a Gaussian process
regression model 
with correlation function <code class="reqn">r(x,x^\prime)</code>, where the entries of <code>R</code> are formed by evaluating
<code class="reqn">r(x,x^\prime)</code> over a grid of candidate locations.  As is typical, <code>R</code> is formed based on 
<em>all</em> of the candidate grid points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dpp.modal.seq(curpts, R, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.dpp.modal.seq_+3A_curpts">curpts</code></td>
<td>
<p>A vector of indices to the candidate points that already appear in the design.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.seq_+3A_r">R</code></td>
<td>
<p>A correlation matrix evaluated over a grid of candidate design sites.</p>
</td></tr>
<tr><td><code id="sim.dpp.modal.seq_+3A_n">n</code></td>
<td>
<p>Size of the design to sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details on the method, see Pratola et al. (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A vector of indices to add to the existing design sites.
</p>


<h3>References</h3>

<p>Pratola, Matthew T., Lin, C. Devon, and Craigmile, Peter. (2018)
Optimal Design Emulators: A Point Process Approach. 
<em>arXiv:1804.02089</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+sim.dpp.modal">sim.dpp.modal</a></code>
<code><a href="#topic+sim.dpp.modal.fast">sim.dpp.modal.fast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

n1=3
n2=3
n3=3
rho=rep(1e-10,2)
ngrid=10

x=seq(0,1,length=ngrid)
X=as.matrix(expand.grid(x,x))
l.d=makedistlist(X)

# Initial design
R=rhomat(l.d,rho)$R
pts.1=sim.dpp.modal(R,n1)
pts.1.proj=remove.projections(pts.1,X)

# Next sequential step, removing projections
pts.2=sim.dpp.modal.seq(pts.1.proj$allpts,R,n2)
design=c(pts.1,pts.2$pts.new)
pts.2.proj=remove.projections(design,X)

# Next sequential step, removing projections
pts.3=sim.dpp.modal.seq(pts.2.proj$allpts,R,n3)
design=c(design,pts.3$pts.new)


# Or, starting with the initial design, don't remove projections
pts.2=sim.dpp.modal.seq(pts.1,R,n2)
designB=c(pts.1,pts.2$pts.new)

pts.3=sim.dpp.modal.seq(designB,R,n3)
designB=c(designB,pts.3$pts.new)


# Plot the result:
#par(mfrow=c(1,3))
#plot(X,xlim=c(0,1),ylim=c(0,1),main="Initial Design")
#points(X[pts.1,],pch=20,cex=2)
#
#plot(X,xlim=c(0,1),ylim=c(0,1),main="+3x2 remove projections")
#points(X[design,],pch=20,cex=2)
#
#plot(X,xlim=c(0,1),ylim=c(0,1),main="+3x2 not removing projections")
#points(X[designB,],pch=20,cex=2)
</code></pre>

<hr>
<h2 id='unscalemat'>Unscale a matrix back to its original ranges.</h2><span id='topic+unscalemat'></span>

<h3>Description</h3>

<p><code>unscalemat()</code> is a helper function to rescale a matrix back to its original ranges.  Typically this is used to rescale the posterior samples of the parameters back to their original scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unscalemat(mat,r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unscalemat_+3A_mat">mat</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of numbers scaled to the <code class="reqn">[0,1]</code> hypercube</p>
</td></tr>
<tr><td><code id="unscalemat_+3A_r">r</code></td>
<td>
<p>An <code class="reqn">p \times 2</code> matrix of the original ranges of the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n \times p</code> matrix with variables rescaled back to their original ranges, as specified by <code>ranges</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getranges">getranges</a></code>
<code><a href="#topic+scaledesign">scaledesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
r=getranges(design)
design=scaledesign(design,r)
unscalemat(design,r)

</code></pre>

<hr>
<h2 id='wendland1'>Calculate the correlation matrix according to the Wendland1 model.</h2><span id='topic+wendland1'></span>

<h3>Description</h3>

<p><code>wendland1()</code> is a helper function that constructs a correlation matrix according to the Wendland 1 model with lengthscales given by the parameter vector <code>theta</code>.  The design must have been already formated in distlist format using the function <code>makedistlist()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wendland1(l.d,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wendland1_+3A_l.d">l.d</code></td>
<td>
<p>Current design distance matrices in distlist format</p>
</td></tr>
<tr><td><code id="wendland1_+3A_theta">theta</code></td>
<td>
<p>A vector of range parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the constructed correlation matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+rhomat">rhomat</a></code>
<code><a href="#topic+matern32">matern32</a></code>
<code><a href="#topic+matern52">matern52</a></code>
<code><a href="#topic+wendland2">wendland2</a></code>
<code><a href="#topic+generalized.wendland">generalized.wendland</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,0,1),ncol=2,nrow=5)
theta=rep(0.3,2)
l.d=makedistlist(design)
R=wendland1(l.d,theta)$R
R
</code></pre>

<hr>
<h2 id='wendland2'>Calculate the correlation matrix according to the Wendland2 model.</h2><span id='topic+wendland2'></span>

<h3>Description</h3>

<p><code>wendland2()</code> is a helper function that constructs a correlation matrix according to the Wendland 2 model with lengthscales given by the parameter vector <code>theta</code>.  The design must have been already formated in distlist format using the function <code>makedistlist()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wendland2(l.d,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wendland2_+3A_l.d">l.d</code></td>
<td>
<p>Current design distance matrices in distlist format</p>
</td></tr>
<tr><td><code id="wendland2_+3A_theta">theta</code></td>
<td>
<p>A vector of range parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the constructed correlation matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demu-package">demu-package</a></code>
<code><a href="#topic+rhomat">rhomat</a></code>
<code><a href="#topic+matern32">matern32</a></code>
<code><a href="#topic+matern52">matern52</a></code>
<code><a href="#topic+wendland1">wendland1</a></code>
<code><a href="#topic+generalized.wendland">generalized.wendland</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(demu)

design=matrix(runif(10,0,1),ncol=2,nrow=5)
theta=rep(0.3,2)
l.d=makedistlist(design)
R=wendland2(l.d,theta)$R
R
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
