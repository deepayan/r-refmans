<!DOCTYPE html><html><head><title>Help for package PoDBAY</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PoDBAY}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assignPoD'><p>Assign probability of disease (PoD)</p></a></li>
<li><a href='#BlindSampling'><p>Immunogenicity subset: vaccinated, control, non-diseased</p></a></li>
<li><a href='#ClinicalTrial'><p>Clinical trial: estimation of case-count efficacy</p></a></li>
<li><a href='#ClinicalTrialCoverage'><p>Clinical trial function expanded for usage in simulations when the calculation of coverage probability is needed for three confidence intervals: 80%, 90%, and user-defined</p></a></li>
<li><a href='#control'><p>Dataset containing the information for control subjects</p></a></li>
<li><a href='#cppMLE'><p>Maximum likelihood estimation: cpp</p></a></li>
<li><a href='#cppPoD'><p>Probability of disease calculation</p></a></li>
<li><a href='#diseased'><p>Dataset containing the information for diseased subjects</p></a></li>
<li><a href='#EfficacyCI'><p>PoDBAY efficacy summary: mean, median, confidence intervals</p></a></li>
<li><a href='#EfficacyCICoverage'><p>PoDBAY efficacy summary at three confidence levels</p></a></li>
<li><a href='#efficacyComputation'><p>PoDBAY efficacy equation</p></a></li>
<li><a href='#efficacySet'><p>Estimated PoDBAY efficacies</p></a></li>
<li><a href='#efficacySquaredError'><p>Optimization objective function: efficacy squared error</p></a></li>
<li><a href='#estimatedParameters'><p>Estimated PoD curve parameters</p></a></li>
<li><a href='#ExpectedPoD'><p>Expected probability of disease</p></a></li>
<li><a href='#ExtractDiseased'><p>Diseased subjects extraction</p></a></li>
<li><a href='#ExtractNondiseased'><p>Non-diseased subjects extraction</p></a></li>
<li><a href='#fitPoD'><p>PoD curve: fitting function</p></a></li>
<li><a href='#GenerateNondiseased'><p>Generation of upsampled non-diseased subjects titers</p></a></li>
<li><a href='#generatePopulation'><p>Population class object generation</p></a></li>
<li><a href='#getDiseasedCount'><p>Diseased count</p></a></li>
<li><a href='#getDiseasedTiters'><p>Diseased titers</p></a></li>
<li><a href='#getNondiseasedCount'><p>Non-diseased count</p></a></li>
<li><a href='#getNondiseasedTiters'><p>Non-diseased titers</p></a></li>
<li><a href='#getTiters'><p>Subject level titers</p></a></li>
<li><a href='#getUnknown'><p>Generate unknown</p></a></li>
<li><a href='#ImmunogenicitySubset'><p>Immunogenicity subset</p></a></li>
<li><a href='#incorrectInput'><p>Error message</p></a></li>
<li><a href='#incorrectPopulationInput'><p>Population class error message</p></a></li>
<li><a href='#JitterMean'><p>Population mean jittering</p></a></li>
<li><a href='#MLE'><p>Maximum Likelihood estimation</p></a></li>
<li><a href='#nondiseased'><p>Dataset containing the information for non-diseased subjects</p></a></li>
<li><a href='#numToBool'><p>Numeric to boolean</p></a></li>
<li><a href='#PmaxEstimation'><p>PoD curve paramater, pmax,  estimation</p></a></li>
<li><a href='#PoD'><p>Probability of disease calculation</p></a></li>
<li><a href='#PoDBAY'><p>PoDBAY</p></a></li>
<li><a href='#PoDBAYEfficacy'><p>PoDBAY efficacy estimation</p></a></li>
<li><a href='#PoDCI'><p>PoD curve confidence ribbon</p></a></li>
<li><a href='#PoDCurvePlot'><p>PoD curve: plot</p></a></li>
<li><a href='#PoDEfficacySquaredError'><p>Optimization function: finds PoD curve paramaters (et50, slope)</p></a></li>
<li><a href='#PoDMLE'><p>Setup for the maximum likelihood estimation (MLE)</p></a></li>
<li><a href='#PoDParamEstimation'><p>PoD curve parameters estimation</p></a></li>
<li><a href='#PoDParamPointEstimation'><p>PoD curve point estimate</p></a></li>
<li><a href='#PoDParams'><p>PoD curve parameters</p></a></li>
<li><a href='#PoDParamsCI'><p>Confidence intervals of PoD curve parameters</p></a></li>
<li><a href='#PoDParamsCICoverage'><p>Confidence intervals of PoD curve parameters at three confidence levels</p></a></li>
<li><a href='#popFun'><p>Population function</p></a></li>
<li><a href='#Population-class'><p>Population class</p></a></li>
<li><a href='#popX'><p>Add noise to population titers</p></a></li>
<li><a href='#vaccinated'><p>Dataset containing the information for vaccinated subjects</p></a></li>
<li><a href='#waldCI'><p>Wald confidence interval estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vaccine Efficacy Estimation Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julie Dudasova (MSD) &lt;julie.dudasova@merck.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions that implement the PoDBAY method, described in the publication 'A method to estimate probability of disease and vaccine efficacy from clinical trial immunogenicity data' by Julie Dudasova, Regina Laube, Chandni Valiathan, Matthew C. Wiener, Ferdous Gheyas, Pavel Fiser, Justina Ivanauskaite, Frank Liu and Jeffrey R. Sachs (NPJ Vaccines, 2021), &lt;<a href="https://doi.org/10.1038%2Fs41541-021-00377-6">doi:10.1038/s41541-021-00377-6</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>2021 Merck Sharp &amp; Dohme Corp. a subsidiary of Merck &amp; Co.,
Inc., Kenilworth, NJ, USA</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), ggplot2 (&ge; 3.1.0), dplyr (&ge; 0.8.0.1),
methods (&ge; 3.5.2), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-20 07:38:33 UTC; vavrycuk</td>
</tr>
<tr>
<td>Author:</td>
<td>Pavel Fiser (MSD) [aut],
  Tomas Bartonek (MSD) [aut],
  Julie Dudasova (MSD) [aut, cre],
  Regina Laube (MSD) [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-21 13:10:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='assignPoD'>Assign probability of disease (PoD)</h2><span id='topic+assignPoD'></span>

<h3>Description</h3>

<p>Function assigns subject-level probability of disease based on PoD curve and subject level titer.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignPoD_+3A_x">x</code></td>
<td>
<p>numeric vector - vector of estimated PoD values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input into the function is either calculated using <code>PoD</code> function or if the PoD curve is unknown the same arbitrary PoD can be assigned to the whole population.
</p>


<h3>Value</h3>

<p>Subject level probability of disease for the population
</p>

<hr>
<h2 id='BlindSampling'>Immunogenicity subset: vaccinated, control, non-diseased</h2><span id='topic+BlindSampling'></span>

<h3>Description</h3>

<p>Function creates non-diseased immunogenicity subset, and vaccinated and control immunogenicity subsets based on chosen method. The immunogenicity subsets are provided in the form of population class objects (see the <code>Population-class</code> function for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlindSampling(diseased, 
              nondiseased,  
              method = list(name = "Full", value = NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BlindSampling_+3A_diseased">diseased</code></td>
<td>
<p><code>Population-class</code> object: diseased subjects, created using <code>ExtractDiseased</code> function</p>
</td></tr>
<tr><td><code id="BlindSampling_+3A_nondiseased">nondiseased</code></td>
<td>
<p><code>Population-class</code> object: non-diseased subjects, created using <code>ExtractNondiseased</code> function</p>
</td></tr>
<tr><td><code id="BlindSampling_+3A_method">method</code></td>
<td>
<p>named list: &quot;name&quot; possible inputs &quot;Full&quot;, &quot;Ratio&quot;, &quot;Fixed&quot;;
</p>
<p>&quot;value&quot; = numeric value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the method parameter see <code>ImmunogenicitySubset</code> function.
</p>


<h3>Value</h3>


<ul>
<li><p> ImmunogenicityVaccinated: vaccinated subjects in the immunogenicity subset, <code>Population-class</code> object (N, mean, stdDev, titers)
</p>
</li>
<li><p> ImmunogenicityControl: control subjects in the immunogenicity subset, <code>Population-class</code> object (N, mean, stdDev, titers)
</p>
</li>
<li><p> ImmunogenicityNondiseased: non-diseased subjects in the immunogenicity subset, <code>Population-class</code> object (N, mean, stdDev, titers)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
data(diseased)
data(nondiseased)

## Example 1
# Creating immunogenicity subset, method = "Full"
ImmunogenicitySubsetFull &lt;- 
    BlindSampling(diseased, 
                  nondiseased, 
                  method = list(name = "Full", 
                                value = NA))

## Example 2
# Creating of immunogenicity subset, method = "Ratio"
ImmunogenicitySubsetRatio &lt;- 
    BlindSampling(diseased, 
                  nondiseased, 
                  method = list(name = "Ratio", 
                                value = 4))

## Example 3
# Creating of immunogenicity subset, method = "Fixed"
ImmunogenicitySubsetFixed &lt;- 
    BlindSampling(diseased, 
                  nondiseased, 
                  method = list(name = "Fixed", 
                                value = 100))

</code></pre>

<hr>
<h2 id='ClinicalTrial'>Clinical trial: estimation of case-count efficacy</h2><span id='topic+ClinicalTrial'></span>

<h3>Description</h3>

<p>Function assigns disease status (DS) to vaccinated and control groups and based on that calculates the case-count efficacy. Vaccinated and control groups are provided in the form of population class objects (see the <code>Population-class</code> function for more details).
</p>
<p>Input populations need to contain information about Probability of disease (PoD) for each subject - calculated using <code>population$assignPoD(PoD(x))</code>. See <code>PoD</code> function for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClinicalTrial(vaccinated, control, CI = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClinicalTrial_+3A_vaccinated">vaccinated</code></td>
<td>
<p><code>Population-class</code> object: vaccinated subjects with assigned PoD</p>
</td></tr>
<tr><td><code id="ClinicalTrial_+3A_control">control</code></td>
<td>
<p><code>Population-class</code> object: control subjects with assigned PoD</p>
</td></tr>
<tr><td><code id="ClinicalTrial_+3A_ci">CI</code></td>
<td>
<p>numeric: value from (0, 1) interval, confidence level of interest</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> vaccinated: vaccinated subjects with assigned DS, <code>Population-class</code> object
</p>
</li>
<li><p> control: control subjects with assigned DS, <code>Population-class</code> object
</p>
</li>
<li><p> efficacy: case-count efficacy
</p>
</li>
<li><p> confidenceInterval: case-count efficacy confidence interval calculated with <code>waldCI()</code> function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Loading vaccinated, control population data with PoD information
data(vaccinated)
data(control)

# Estimating the disease status and case-count efficacy with 95\% confidence interval
CT &lt;- ClinicalTrial(vaccinated, control, CI = 0.95)

CT$efficacy
CT$confidenceInterval

CT$vaccinated

</code></pre>

<hr>
<h2 id='ClinicalTrialCoverage'>Clinical trial function expanded for usage in simulations when the calculation of coverage probability is needed for three confidence intervals: 80%, 90%, and user-defined</h2><span id='topic+ClinicalTrialCoverage'></span>

<h3>Description</h3>

<p>Function works the same way as <code>ClinicalTrial</code> function but it also calculates 80% and 90% confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClinicalTrialCoverage(vaccinated, control, CI = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClinicalTrialCoverage_+3A_vaccinated">vaccinated</code></td>
<td>
<p><code>Population-class</code> object: vaccinated subjects with assigned PoD</p>
</td></tr>
<tr><td><code id="ClinicalTrialCoverage_+3A_control">control</code></td>
<td>
<p><code>Population-class</code> object: control subjects with assigned PoD</p>
</td></tr>
<tr><td><code id="ClinicalTrialCoverage_+3A_ci">CI</code></td>
<td>
<p>numeric: value from (0, 1) interval, confidence level of interest</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> vaccinated: vaccinated subjects with assigned DS, <code>Population-class</code> object
</p>
</li>
<li><p> control: control subjects with assigned DS, <code>Population-class</code> object
</p>
</li>
<li><p> efficacy: case-count efficacy
</p>
</li>
<li><p> confidenceInterval: confidence interval calculated with <code>waldCI</code> function
</p>
</li>
<li><p> confidenceInterval90: 90% confidence interval calculated with <code>waldCI</code> function
</p>
</li>
<li><p> confidenceInterval80: 80% confidence interval calculated with <code>waldCI</code> function
</p>
</li></ul>


<hr>
<h2 id='control'>Dataset containing the information for control subjects</h2><span id='topic+control'></span>

<h3>Description</h3>

<p>A dataset containing the N, mean, stdDev, titers of control subjects. The dataset is provided in the form of population class object (see the <code>Population-class</code> function for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control
</code></pre>


<h3>Format</h3>

<p>Population class object:
</p>

<dl>
<dt>N</dt><dd><p>number of subjects</p>
</dd>
<dt>mean</dt><dd><p>mean of titers</p>
</dd>
<dt>stdDev</dt><dd><p>standard deviation of titers</p>
</dd>
<dt>titers</dt><dd><p>subject level titers</p>
</dd>
</dl>


<hr>
<h2 id='cppMLE'>Maximum likelihood estimation: cpp</h2><span id='topic+cppMLE'></span>

<h3>Description</h3>

<p>Function calculates the log likelihood value which is used after the initial guesses of the parameters are set in the <code>PoDMLE</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppMLE(params,
       nondiseasedTiters,
       diseasedTiters,
       adjustTiters = FALSE,
       adjustFrom = log2(10),
       adjustTo = log2(5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cppMLE_+3A_params">params</code></td>
<td>
<p>named numeric vector: PoD curve parameters (&quot;et50&quot;, &quot;slope&quot;, &quot;pmax&quot;)</p>
</td></tr>
<tr><td><code id="cppMLE_+3A_nondiseasedtiters">nondiseasedTiters</code></td>
<td>
<p>numeric vector: non-diseased subjects titers</p>
</td></tr>
<tr><td><code id="cppMLE_+3A_diseasedtiters">diseasedTiters</code></td>
<td>
<p>numeric vector: diseased subjects titers</p>
</td></tr>
<tr><td><code id="cppMLE_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="cppMLE_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="cppMLE_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cppMLE function is used inside of PoDMLE function and estimates the PoD curve paramers.
</p>
<p>Based on the provided titers for diseased and non-diseased groups the PoD curve parameters which maximize the log likelihood are chosen as optimal.
</p>
<p>Difference between MLE and cppMLE is only that cppMLE use cppPoD function instead of PoD. This step significantly improves the computation speed and provides the same results.
</p>


<h3>Value</h3>

<p>log likelihood, numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
data(diseased)
data(nondiseased)
data(PoDParams)

# MLE calculation
cppMLE(PoDParams, nondiseased$titers, diseased$titers)

</code></pre>

<hr>
<h2 id='cppPoD'>Probability of disease calculation</h2><span id='topic+cppPoD'></span>

<h3>Description</h3>

<p>Function calculates probability of disease (PoD) for given titers according to a PoD curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppPoD(titer, pmax, et50, slope, adjustTiters = FALSE, adjustFrom = 0, adjustTo = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cppPoD_+3A_titer">titer</code></td>
<td>
<p>numeric vector: vector of subject level titers</p>
</td></tr>
<tr><td><code id="cppPoD_+3A_pmax">pmax</code></td>
<td>
<p>numeric: maximum PoD</p>
</td></tr>
<tr><td><code id="cppPoD_+3A_et50">et50</code></td>
<td>
<p>numeric: titer value corresponding to pmax/2 value, PoD(et50) = pmax/2</p>
</td></tr>
<tr><td><code id="cppPoD_+3A_slope">slope</code></td>
<td>
<p>numeric: slope of the PoD curve</p>
</td></tr>
<tr><td><code id="cppPoD_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="cppPoD_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="cppPoD_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>PoD</code> function for more details. These two functions are equivalent. Usage of cppPoD significantly improves the computation speed over the <code>PoD</code> function.
</p>


<h3>Value</h3>

<p>vector of PoDs
</p>

<hr>
<h2 id='diseased'>Dataset containing the information for diseased subjects</h2><span id='topic+diseased'></span>

<h3>Description</h3>

<p>A dataset containing the N, mean, stdDev, titers of diseased subjects. The dataset is provided in the form of population class object (see the <code>Population-class</code> function for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diseased
</code></pre>


<h3>Format</h3>

<p>Population class object:
</p>

<dl>
<dt>N</dt><dd><p>number of subjects</p>
</dd>
<dt>mean</dt><dd><p>mean of titers</p>
</dd>
<dt>stdDev</dt><dd><p>standard deviation of titers</p>
</dd>
<dt>titers</dt><dd><p>subject level titers</p>
</dd>
</dl>


<hr>
<h2 id='EfficacyCI'>PoDBAY efficacy summary: mean, median, confidence intervals</h2><span id='topic+EfficacyCI'></span>

<h3>Description</h3>

<p>Function summarizes PoDBAY efficacy statistics (mean, median, confidence intervals) based on the set of estimated efficacies and chosen condfidence level. (Set of efficacies is a vector obtained by number of replications specified by repeatCount. These replications are performed for calculation of a confidence interval. For more details, see the supplementary material of the article).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EfficacyCI(efficacySet, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EfficacyCI_+3A_efficacyset">efficacySet</code></td>
<td>
<p>numeric vector: estimated PoDBAY efficacies from <code>PoDBAYEfficacy</code> function.</p>
</td></tr>
<tr><td><code id="EfficacyCI_+3A_ci">ci</code></td>
<td>
<p>numeric: required confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence intervals are calculated using quantiles of estimated efficacies.
</p>


<h3>Value</h3>

<p>named list: mean, median, CILow, CIHigh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(efficacySet)

## Example 1
EfficacyCI(efficacySet, ci = 0.95)

</code></pre>

<hr>
<h2 id='EfficacyCICoverage'>PoDBAY efficacy summary at three confidence levels</h2><span id='topic+EfficacyCICoverage'></span>

<h3>Description</h3>

<p>Function summarizes PoDBAY efficacy statistics (mean, median, confidence intervals) at 80%, 90% and user-defined confidence levels, based on the set of estimated efficacies. (Set of efficacies is a vector obtained by number of replications specified by repeatCount. These replications are performed for calculation of a confidence interval. For more details, see the supplementary material of the article).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EfficacyCICoverage(efficacySet, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EfficacyCICoverage_+3A_efficacyset">efficacySet</code></td>
<td>
<p>numeric vector: estimated PoDBAY efficacies from <code>PoDBAYEfficacy</code> function.</p>
</td></tr>
<tr><td><code id="EfficacyCICoverage_+3A_ci">ci</code></td>
<td>
<p>numeric: value from (0, 1) interval, confidence level of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence intervals are calculated using quantiles of estimated efficacies.
</p>


<h3>Value</h3>

<p>named list: mean, median, CILow, CIHigh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(efficacySet)

## Example 1
EfficacyCICoverage(efficacySet, ci = 0.95)

</code></pre>

<hr>
<h2 id='efficacyComputation'>PoDBAY efficacy equation</h2><span id='topic+efficacyComputation'></span>

<h3>Description</h3>

<p>Function calculates the PoDBAY efficacy based on the PoD curve parameters and titer distribution parameters (mean, sd) for vaccinated and control groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficacyComputation(PoDParameters, 
                    means = NA, 
                    standardDeviations = NA,
                    adjustTiters = FALSE,
                    adjustFrom = NA,
                    adjustTo = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficacyComputation_+3A_podparameters">PoDParameters</code></td>
<td>
<p>named data frame (&quot;pmax&quot;, &quot;slope&quot;, &quot;et50&quot;): PoD curve parameters</p>
</td></tr>
<tr><td><code id="efficacyComputation_+3A_means">means</code></td>
<td>
<p>named list (&quot;vaccinated&quot;, &quot;control&quot;): mean values of vaccinated and control subjects titers</p>
</td></tr>
<tr><td><code id="efficacyComputation_+3A_standarddeviations">standardDeviations</code></td>
<td>
<p>named list (&quot;vaccinated&quot;, &quot;control&quot;): standard deviations of vaccinated and control subjects titers</p>
</td></tr>
<tr><td><code id="efficacyComputation_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="efficacyComputation_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="efficacyComputation_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">Efficacy = 1 - \frac{E[PoD_{vaccinated}]}{{E[PoD_{control}]} } </code>
</p>
<p>.
</p>
<p>E[PoD] for each group is calculated as integral from -Inf to Inf of (titer density function) * (PoD Curve); for further details see Example2 and<code>ExpectedPoD</code> function.
</p>


<h3>Value</h3>

<p>efficacy: numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(vaccinated)
data(control)
data(PoDParams)

## Example 1
means &lt;- list(vaccinated = vaccinated$mean, control = control$mean)

standardDeviations &lt;- list(vaccinated = vaccinated$stdDev, control = control$stdDev)

efficacyComputation(PoDParams, means, standardDeviations)


</code></pre>

<hr>
<h2 id='efficacySet'>Estimated PoDBAY efficacies</h2><span id='topic+efficacySet'></span>

<h3>Description</h3>

<p>A dataset containing estimated set of PoDBAY efficacies. (Set of efficacies is a vector obtained by number of replications specified by repeatCount. These replications are performed for calculation of a confidence interval. For more details, see the supplementary material of the article).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficacySet
</code></pre>


<h3>Format</h3>

<p>vector
</p>

<dl>
<dt>numeric vector</dt><dd><p>PoDBAY efficacies</p>
</dd>
</dl>


<hr>
<h2 id='efficacySquaredError'>Optimization objective function: efficacy squared error</h2><span id='topic+efficacySquaredError'></span>

<h3>Description</h3>

<p>Function calculates squared difference between input (reference value, or for example true in the simulation setup) efficacy and
efficacy calculated based on input parameters of PoD curve and input titer 
distributions of vaccinated and control groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficacySquaredError(params, 
                     TrueEfficacy, 
                     titerFun,
                     adjustTiters = FALSE,
                     adjustFrom = 0,
                     adjustTo = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficacySquaredError_+3A_params">params</code></td>
<td>
<p>numeric vector: vector of et50 and slope; efficacy calculation is independent of Pmax and thus Pmax is excluded</p>
</td></tr>
<tr><td><code id="efficacySquaredError_+3A_trueefficacy">TrueEfficacy</code></td>
<td>
<p>numeric value: input efficacy value</p>
</td></tr>
<tr><td><code id="efficacySquaredError_+3A_titerfun">titerFun</code></td>
<td>
<p>list: list of probability density functions for vaccinated and control groups</p>
</td></tr>
<tr><td><code id="efficacySquaredError_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="efficacySquaredError_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="efficacySquaredError_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is used inside the <code>PoDEfficacySquaredError</code> function for calculation of the PoD parameters.
</p>


<h3>Value</h3>

<p>Squared difference between calculated and reference efficacy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
data(vaccinated)
data(control)
data(PoDParams)

# Choosing et50 and slope as the inputs
params &lt;- list("et50" = 4, "slope" = 6)

# Using probability density function from the populations

titerFun &lt;- 
  list(
      function(x) {dnorm(x, mean = vaccinated$mean, sd = vaccinated$stdDev)},
      function(x) {dnorm(x, mean = control$mean, sd = control$stdDev)}
      )

# Assigning true efficacy
TrueEfficacy &lt;- 0.53

# Sqaured difference between true and calcuated efficacy
efficacySquaredError(params, TrueEfficacy, titerFun)

</code></pre>

<hr>
<h2 id='estimatedParameters'>Estimated PoD curve parameters</h2><span id='topic+estimatedParameters'></span>

<h3>Description</h3>

<p>A dataset containing estimated set of PoD curve parameters. (Set of PoD curve parameters is a vector obtained by number of replications specified by repeatCount. These replications are performed for calculation of a confidence interval. For more details, see the supplementary material of the article).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatedParameters
</code></pre>


<h3>Format</h3>

<p>data frame
</p>

<dl>
<dt>pmax</dt><dd><p>pmax: maximum PoD</p>
</dd>
<dt>et50</dt><dd><p>et50: titer value corresponding to the pmax/2</p>
</dd>
<dt>slope</dt><dd><p>slope: slope of the PoD curve</p>
</dd>
</dl>


<hr>
<h2 id='ExpectedPoD'>Expected probability of disease</h2><span id='topic+ExpectedPoD'></span>

<h3>Description</h3>

<p>Function calculates the integral of multiplication of two functions: PoD curve and titer probability density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectedPoD(f.pod, f.titer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpectedPoD_+3A_f.pod">f.pod</code></td>
<td>
<p>function(x):  PoD curve, estimated sigmoid function relating titers to a probability of disease</p>
</td></tr>
<tr><td><code id="ExpectedPoD_+3A_f.titer">f.titer</code></td>
<td>
<p>function(x): titer probability density function, distribution of titer values in a group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function calculates integral from -Inf to +Inf of titer probability density function multiplied by the PoD curve.
</p>
<p>It is used mainly in the PoDBAY efficacy calculation <code>efficacyComputation</code>.
</p>


<h3>Value</h3>

<p>Value of the integral of the multiplication of the two functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 
data(vaccinated)
data(control)
data(PoDParams)

# Defining the PoD curve
funPoD &lt;- function(x) PoD(x, pmax = PoDParams$pmax, et50 = PoDParams$et50, slope = PoDParams$slope)

# Defining the titer distribution for vaccinated and control groups
funVaccinated &lt;- function(x) dnorm(x, mean = vaccinated$mean, sd = vaccinated$stdDev)
funControl &lt;- function(x) dnorm(x, mean = control$mean, sd = control$stdDev)

# Calculating the expected probability of disease 
aucVaccinated &lt;- ExpectedPoD(funPoD, funVaccinated)
aucControl &lt;- ExpectedPoD(funPoD, funControl)

# PoDBAY efficacy estimation
efficacy &lt;- 1 - aucVaccinated/aucControl

</code></pre>

<hr>
<h2 id='ExtractDiseased'>Diseased subjects extraction</h2><span id='topic+ExtractDiseased'></span>

<h3>Description</h3>

<p>Function extracts diseased subjects from vaccinated and control groups if the data have assigned disease status (for example using <code>ClinicalTrial</code> function). The vaccinated and control data are provided in the form of population class objects (see the <code>Population-class</code> function for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractDiseased(vaccinated, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractDiseased_+3A_vaccinated">vaccinated</code></td>
<td>
<p><code>Population-class</code> object: vaccinated subjects with assigned disease status</p>
</td></tr>
<tr><td><code id="ExtractDiseased_+3A_control">control</code></td>
<td>
<p><code>Population-class</code> object: control subjects with assigned disease status</p>
</td></tr>
</table>


<h3>Value</h3>

<p>diseased subjects, <code>Population-class</code> object: a subset of control and vaccinated subjects with disease status = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
# Data preparation
data(vaccinated)
data(control)

# Estimating the disease status and case-count efficacy with CI
ClinicalTrial(vaccinated, control, CI = 0.95)

# Extracting the disease cases
ExtractDiseased(vaccinated, control)

</code></pre>

<hr>
<h2 id='ExtractNondiseased'>Non-diseased subjects extraction</h2><span id='topic+ExtractNondiseased'></span>

<h3>Description</h3>

<p>Function extracts non-diseased subjects from vaccinated and control groups if the data have assigned disease status (for example using <code>ClinicalTrial</code> function). The vaccinated and control data are provided in the form of population class objects (see the <code>Population-class</code> function for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractNondiseased(vaccinated, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractNondiseased_+3A_vaccinated">vaccinated</code></td>
<td>
<p><code>Population-class</code> object: vaccinated subjects with assigned disease status</p>
</td></tr>
<tr><td><code id="ExtractNondiseased_+3A_control">control</code></td>
<td>
<p><code>Population-class</code> object: control subjects with assigned disease status</p>
</td></tr>
</table>


<h3>Value</h3>

<p>non-diseased subjects, <code>Population-class</code> object: a subset of control and vaccinated subjects with disease status = FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
# Data preparation
data(vaccinated)
data(control)

# Estimating the disease status and case-count efficacy with CI
ClinicalTrial(vaccinated, control, CI = 0.95)

# Extracting the non-diseased subjects
ExtractNondiseased(vaccinated, control)

</code></pre>

<hr>
<h2 id='fitPoD'>PoD curve: fitting function</h2><span id='topic+fitPoD'></span>

<h3>Description</h3>

<p>Function calculates the root mean squared error (RMSE) between provided PoD values and calculated PoD values. The latter are calculated using for provided titers and provided PoD curve parameters.
</p>
<p>By using the input titers <code>PoDParamPointEstimation</code> function and median of the estimated set of PoD curve parameters (output of <code>PoDParamEstimation</code> function), the point estimate of PoD curve can be obtained (for details see <code>PoDParamPointEstimation</code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitPoD(params, TitersInput, CurveTitersMedian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitPoD_+3A_params">params</code></td>
<td>
<p>named data frame (&quot;pmax&quot;, &quot;slope&quot;, &quot;et50&quot;): provided PoD curve parameters</p>
</td></tr>
<tr><td><code id="fitPoD_+3A_titersinput">TitersInput</code></td>
<td>
<p>numeric vector: provided titers</p>
</td></tr>
<tr><td><code id="fitPoD_+3A_curvetitersmedian">CurveTitersMedian</code></td>
<td>
<p>numeric vector: provided PoD values</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">RMSE = \sqrt{\frac{\sum_{i}^{N} (PoD_{median}(titers) - PoD_{optimized}(titers))^2}{N}}</code>
</p>



<h3>Value</h3>

<p>negative RMSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(estimatedParameters)
data(PoDParams)

## Example 1

# grid of titers
TitersInput &lt;- seq(from = 0, to = 20, by = 0.01)

# for each estimated PoD curve calculate functional values
functionValues &lt;- 
  matrix(NA, 
         nrow = nrow(estimatedParameters$resultsPriorReset), 
         ncol = length(TitersInput))

for (i in 1:nrow(estimatedParameters$resultsPriorReset)) { 
  functionValues[i,] &lt;- PoD(TitersInput,
  pmax = estimatedParameters$resultsPriorReset[i,1], 
  et50 = estimatedParameters$resultsPriorReset[i,3], 
  slope = estimatedParameters$resultsPriorReset[i,2], adjustTiters = FALSE)
}

# functional values corresponding to the median of the estimated PoD curve parameters
CurveTitersMedian &lt;- apply(functionValues, 2, median)

# squared error of CurveTitersMedian and functional values of "params" curve
fitPoD(PoDParams, TitersInput, CurveTitersMedian)

</code></pre>

<hr>
<h2 id='GenerateNondiseased'>Generation of upsampled non-diseased subjects titers</h2><span id='topic+GenerateNondiseased'></span>

<h3>Description</h3>

<p>Function upsamples (by random sampling with replacement) titers from the immunogenicity subset to the required size.
</p>
<p>If the size of the immunogenicity subset matches the required size, nothing happens and the original titers from the immunogenicity subset are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateNondiseased(blindNondiseasedTiters, nondiseasedCount)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateNondiseased_+3A_blindnondiseasedtiters">blindNondiseasedTiters</code></td>
<td>
<p>numeric vector: vector of non-diseased subjects titer values</p>
</td></tr>
<tr><td><code id="GenerateNondiseased_+3A_nondiseasedcount">nondiseasedCount</code></td>
<td>
<p>numeric: total number of non-diseased subjects, required size of the non-diseased population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs should come from immunogenicity subset. &quot;nondiseasedCount&quot; represents number of all non-diseased patients in the clinical trial.
</p>
<p>Immunogenicity subset populations are obtained from function <code>BlindSampling</code>. Immunogenicity subset represents a sample from the non-diseased population.
</p>
<p>In this function, sampling with replacement to the required &quot;nondiseasedCount&quot; of the immunogenecitry subset is performed. The function is used inside <code>PoDParamEstimation</code> function.
</p>


<h3>Value</h3>

<p>nondiseasedTiters: numeric vector of all non-diseased subjects titers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(nondiseased)

## Example 1
# Creating imunogenicity subset, method = "Full"
NondiseasedImmunogenicitySubset &lt;- 
    ImmunogenicitySubset(diseased, 
                         nondiseased, 
                         method = list(name = "Full", 
                                       value = "NA"))

# Number of all non-diseased subjects in the clinical trial
nondiseasedGenerationCount &lt;- nondiseased$N

# Upsampling of non-diseased titers
GenerateNondiseased(NondiseasedImmunogenicitySubset$titers, nondiseasedGenerationCount)

</code></pre>

<hr>
<h2 id='generatePopulation'>Population class object generation</h2><span id='topic+generatePopulation'></span>

<h3>Description</h3>

<p>Function generates the population class object using provided summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePopulation(N, mean, stdDev, unknownDistribution = FALSE, UDFunction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePopulation_+3A_n">N</code></td>
<td>
<p>numeric: number of subjects in the population</p>
</td></tr>
<tr><td><code id="generatePopulation_+3A_mean">mean</code></td>
<td>
<p>numeric: mean of titers</p>
</td></tr>
<tr><td><code id="generatePopulation_+3A_stddev">stdDev</code></td>
<td>
<p>numeric: standard deviation of titers</p>
</td></tr>
<tr><td><code id="generatePopulation_+3A_unknowndistribution">unknownDistribution</code></td>
<td>
<p>logical: TRUE if there is an unknown factor affacting the shape of titer distribution</p>
</td></tr>
<tr><td><code id="generatePopulation_+3A_udfunction">UDFunction</code></td>
<td>
<p>function: function defining the unknown factor affecting the shape of titer distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generated population class object with all its characteristics defined in the input parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: empty population
population0 &lt;- generatePopulation()

# Example 2
population1 &lt;- generatePopulation(N = 100,
                                  mean = 5,
                                  stdDev = 2)

</code></pre>

<hr>
<h2 id='getDiseasedCount'>Diseased count</h2><span id='topic+getDiseasedCount'></span>

<h3>Description</h3>

<p>Function calculates the number of diseased subjects (disease status = TRUE) in the <code>Population-class</code> object.
</p>


<h3>Details</h3>

<p>Input into the function, &quot;diseaseStatus&quot;, is taken from the <code>Population-class</code> object attribute. Information about disease status is written into the <code>Population-class</code> object by the <code>ClinicalTrial()</code> function.
</p>


<h3>Value</h3>

<p>numeric: number of the diseased subjects in the <code>Population-class</code> object
</p>

<hr>
<h2 id='getDiseasedTiters'>Diseased titers</h2><span id='topic+getDiseasedTiters'></span>

<h3>Description</h3>

<p>Function returns titers of diseased subjects (disease status = TRUE) in the <code>Population-class</code> object.
</p>


<h3>Details</h3>

<p>Input into the function, &quot;diseaseStatus&quot;, is taken from the <code>Population-class</code> object attribute. Information about disease status is written into the <code>Population-class</code> object by the <code>ClinicalTrial()</code> function.
</p>


<h3>Value</h3>

<p>numeric vector: titers of diseased subjects in the <code>Population-class</code> object
</p>

<hr>
<h2 id='getNondiseasedCount'>Non-diseased count</h2><span id='topic+getNondiseasedCount'></span>

<h3>Description</h3>

<p>Function calculates the number of non-diseased subjects (disease status = FALSE) in the <code>Population-class</code> object.
</p>


<h3>Details</h3>

<p>Input into the function, &quot;diseaseStatus&quot;, is taken from the <code>Population-class</code> object attribute. Information about disease status is written into the <code>Population-class</code> object by the <code>ClinicalTrial()</code> function.
</p>


<h3>Value</h3>

<p>numeric: number of the non-diseased subjects in the <code>Population-class</code> object
</p>

<hr>
<h2 id='getNondiseasedTiters'>Non-diseased titers</h2><span id='topic+getNondiseasedTiters'></span>

<h3>Description</h3>

<p>Function returns titers of non-diseased subjects (disease status = FALSE) in the <code>Population-class</code> object.
</p>


<h3>Details</h3>

<p>Input into the function, &quot;diseaseStatus&quot;, is taken from the <code>Population-class</code> object attribute. Information about disease status is written into the <code>Population-class</code> object by the <code>ClinicalTrial()</code> function.
</p>


<h3>Value</h3>

<p>numeric vector: titers of non-diseased subjects in the <code>Population-class</code> object
</p>

<hr>
<h2 id='getTiters'>Subject level titers</h2><span id='topic+getTiters'></span>

<h3>Description</h3>

<p>Returns subject level titers. If titers are not yet generated, the function generates them based on <code>Population-class</code> object attributes: N, mean, stdDev.
</p>


<h3>Details</h3>

<p>Inputs into the function (N, mean, stdDev) are taken from the <code>Population-class</code> object attributes.
</p>


<h3>Value</h3>

<p>Subject level titers
</p>

<hr>
<h2 id='getUnknown'>Generate unknown</h2><span id='topic+getUnknown'></span>

<h3>Description</h3>

<p>Function generates unknown part of the titers which is eventually added to the original titers in <code>popX</code> and to the original titer distribution in <code>popFun</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUnknown_+3A_n">n</code></td>
<td>
<p>numeric: number of subjects in the population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input into the function: UDFunction is taken from the <code>Population-class</code> object. UDFunction is used for generating the unknown part of the titer distribution.
</p>


<h3>Value</h3>

<p>unknown part of the titers
</p>

<hr>
<h2 id='ImmunogenicitySubset'>Immunogenicity subset</h2><span id='topic+ImmunogenicitySubset'></span>

<h3>Description</h3>

<p>Function creates the immunogenicity subset based on the chosen method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImmunogenicitySubset(diseased, 
                     nondiseased, 
                     method = list(name = "Full", value = NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImmunogenicitySubset_+3A_diseased">diseased</code></td>
<td>
<p><code>Population-class</code> object: diseased subjects with assigned vaccination status</p>
</td></tr>
<tr><td><code id="ImmunogenicitySubset_+3A_nondiseased">nondiseased</code></td>
<td>
<p><code>Population-class</code> object: non-diseased subjects with assigned vacination status</p>
</td></tr>
<tr><td><code id="ImmunogenicitySubset_+3A_method">method</code></td>
<td>
<p>named list: a selected method for creating the immunogenicity subset
</p>
<p>method$name
</p>

<ul>
<li><p> Full: subject level titer information is available for all diseased and all non-diseased subjects, i.e. immunogenicity subset is the full clinical trial
</p>
</li>
<li><p> Ratio: subject level titer information is available for all diseased and some non-diseased subjects.
</p>
</li>
<li><p> Fixed: subject level titer information is available for all diseased and some non-diseased subjects.
</p>
</li></ul>

<p>method$value
</p>

<ul>
<li><p> Full: value = NA; immunogenicity sample is the full clinical trial (non-diseased subset contains all non-diseased in the trial; diseased subset contains all disease cases in the trial)
</p>
</li>
<li><p> Ratio: value = number of non-diseased divided by number of diseased subjects; ratio of diseased vs. non-diseased subjects in the immunogenicity subset (non-diseased subset contains only non-diseased subjects, as the selection is done in the end of the study, when the disease status is known; diseased subset contains all disease cases in the trial)
</p>
</li>
<li><p> Fixed: value = size of the immunogenicity subset, pre-defined number of subjects assayed for titers independently of their future disease status (non-diseased subset could rarely contain some diseased subjects, as the selection is done at the enrollment and prior the knowledge of future disease status; diseased subset contains all disease cases in the trial)
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The total immunogenicity subset consists of the diseased immunogenicity subset and non-diseased immunogenicity subset. 
For all three methods implemented, we assume that the diseased immunogenicity subset contains all disease cases in the trial.
Based on the chosen method, the the size of the non-diseaded immunogenicity subset can be derived as follows:
</p>
<p>Size = number of subjects in the non-diseased immunogenicity subset
</p>
<p>Titers = values of titers from which we want to sample in order to simulate the non-diseased immunogenicity subset
</p>
<p>#Diseased = total number of diseased in the clinical trial
</p>
<p>#Nondiseased = total number of non-diseased in the clinical trial
</p>

<ul>
<li><p> method$name = &quot;Full&quot;
</p>
<p>Size = #Nondiseased
</p>
<p>Titers = Nondiseased Titers 
</p>
</li>
<li><p> method$name = &quot;Ratio&quot;
</p>
<p>Size =  method$value * #Diseased
</p>
<p>Titers = Nondiseased Titers
</p>
</li>
<li><p> method$name = &quot;Fixed&quot;
</p>
<p>Size = method$value
</p>
<p>Titers = Nondiseased Titers + Diseased Titers
</p>
</li></ul>



<h3>Value</h3>

<p>Immunogenicity subset with subject level information about vaccination status and disease status, provided in the form of <code>Population-class</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
# Data preparation
data(diseased)
data(nondiseased)

ImmunogenicitySubset(diseased,
                     nondiseased,
                     method = list(name = "Ratio",
                                   value = 4))

</code></pre>

<hr>
<h2 id='incorrectInput'>Error message</h2><span id='topic+incorrectInput'></span>

<h3>Description</h3>

<p>Error meassage: the input value for &quot;name&quot; is incorrent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incorrectInput(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incorrectInput_+3A_name">name</code></td>
<td>
<p>name of the input value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>error message: &quot;the input value for &quot;name&quot; is incorrect&quot;
</p>

<hr>
<h2 id='incorrectPopulationInput'>Population class error message</h2><span id='topic+incorrectPopulationInput'></span>

<h3>Description</h3>

<p>Error meassage: the input value for &quot;name&quot; is incorrect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incorrectPopulationInput(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incorrectPopulationInput_+3A_name">name</code></td>
<td>
<p>name of the input value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>error message: &quot;The input value for &quot;name&quot; is incorrect. Input needs to be a population class object.&quot;
</p>

<hr>
<h2 id='JitterMean'>Population mean jittering</h2><span id='topic+JitterMean'></span>

<h3>Description</h3>

<p>Function jitters the mean of the population.
</p>
<p>Jittering is adding noise to the mean. The jittered mean is sampled from the distribution with the population mean and population standard deviation divided by the number of subjects in the population. The input population is provided in the form of population class objects (see the <code>Population-class</code> function for more details).
</p>
<p style="text-align: center;"><code class="reqn">Mean_{jitter} \sim N(mean, \frac{sd}{N} )</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>JitterMean(blindPopulation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JitterMean_+3A_blindpopulation">blindPopulation</code></td>
<td>
<p><code>Population-class</code> object with N, mean, stdDev attributes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jittered mean, numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(vaccinated)

## Example 1
vaccinated$mean
JitterMean(vaccinated)

</code></pre>

<hr>
<h2 id='MLE'>Maximum Likelihood estimation</h2><span id='topic+MLE'></span>

<h3>Description</h3>

<p>Function calculates the log likelihood value which is used after the initial guesses of the parameters are set in the <code>PoDMLE</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLE(params,
    nondiseasedTiters,
    diseasedTiters,
    adjustTiters = FALSE,
    adjustFrom = log2(10),
    adjustTo = log2(5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE_+3A_params">params</code></td>
<td>
<p>named numeric vector: PoD curve parameters (et50, slope, pmax)</p>
</td></tr>
<tr><td><code id="MLE_+3A_nondiseasedtiters">nondiseasedTiters</code></td>
<td>
<p>numeric vector: non-diseased subjects titers</p>
</td></tr>
<tr><td><code id="MLE_+3A_diseasedtiters">diseasedTiters</code></td>
<td>
<p>numeric vector: diseased subjects titers</p>
</td></tr>
<tr><td><code id="MLE_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="MLE_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="MLE_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MLE function is used inside of PoDMLE function and esimates the PoD curve parameters.
</p>
<p>Based on the provided titers for diseased and non-diseased subjects the PoD curve parameters which maximize the log likelihood are chosen as optimal estimates of parameters.
</p>


<h3>Value</h3>

<p>log likelihood, numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
data(diseased)
data(nondiseased)
data(PoDParams)

# MLE calculation
MLE(PoDParams, nondiseased$titers, diseased$titers)

</code></pre>

<hr>
<h2 id='nondiseased'>Dataset containing the information for non-diseased subjects</h2><span id='topic+nondiseased'></span>

<h3>Description</h3>

<p>A dataset containing the N, mean, stdDev, titers of non-diseased subjects. The dataset is provided in the form of population class object (see the <code>Population-class</code> function for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nondiseased
</code></pre>


<h3>Format</h3>

<p>Population class object:
</p>

<dl>
<dt>N</dt><dd><p>number of subjects</p>
</dd>
<dt>mean</dt><dd><p>mean of titers</p>
</dd>
<dt>stdDev</dt><dd><p>standard deviation of titers</p>
</dd>
<dt>titers</dt><dd><p>subject level titers</p>
</dd>
</dl>


<hr>
<h2 id='numToBool'>Numeric to boolean</h2><span id='topic+numToBool'></span>

<h3>Description</h3>

<p>Converts numeric format to boolean format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numToBool(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numToBool_+3A_x">x</code></td>
<td>
<p>numeric value (0, 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the function is supposed to be used on a vector, the form <code>sapply("vector", numToBool)</code> needs to be applied.
</p>


<h3>Value</h3>

<p>boolean value (T, F)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dStatus &lt;- c(0,0,1,1,0,1)
sapply(dStatus, numToBool)

</code></pre>

<hr>
<h2 id='PmaxEstimation'>PoD curve paramater, pmax,  estimation</h2><span id='topic+PmaxEstimation'></span>

<h3>Description</h3>

<p>Function finds the pmax parameter of the PoD curve using control subjects summary statistics (mean, sd), observed incidence rate and previsouly estimated et50 and slope by <code>PoDEfficacySquaredError</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PmaxEstimation(IncidenceRate,
               params, 
               control,
               adjustTiters = FALSE, 
               adjustFrom = NA, 
               adjustTo = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PmaxEstimation_+3A_incidencerate">IncidenceRate</code></td>
<td>
<p>numeric: observed incidence rate in overall (control) subjects</p>
</td></tr>
<tr><td><code id="PmaxEstimation_+3A_params">params</code></td>
<td>
<p>numeric vector: et50 and slope</p>
</td></tr>
<tr><td><code id="PmaxEstimation_+3A_control">control</code></td>
<td>
<p><code>Population-class</code> object: control subjects (mean, sd)</p>
</td></tr>
<tr><td><code id="PmaxEstimation_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="PmaxEstimation_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="PmaxEstimation_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PoD curve parameter pmax
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
data(vaccinated)
data(control)

# Assigning true efficacy 
TrueEfficacy &lt;- 0.53

# PoD curve parameters (et50, slope) estimation
params &lt;- PoDEfficacySquaredError(TrueEfficacy, vaccinated, control)

# Assigning incidence rate (observed incidence rate)
IncidenceRate &lt;- 0.2

# pmax estimation
pmax &lt;- PmaxEstimation(IncidenceRate, params, control)

# combining PoD curve parameters
PoDParams &lt;- unlist(c(params, pmax))

</code></pre>

<hr>
<h2 id='PoD'>Probability of disease calculation</h2><span id='topic+PoD'></span>

<h3>Description</h3>

<p>Function calculates probability of disease (PoD) corresponding to given titers according to a sigmoid PoD curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoD(titer, pmax, et50, slope, adjustTiters = FALSE, adjustFrom = 0, adjustTo = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoD_+3A_titer">titer</code></td>
<td>
<p>numeric vector: subject level titers</p>
</td></tr>
<tr><td><code id="PoD_+3A_pmax">pmax</code></td>
<td>
<p>numeric: maximum PoD</p>
</td></tr>
<tr><td><code id="PoD_+3A_et50">et50</code></td>
<td>
<p>numeric: titer values corresponding to pmax/2 value, PoD(et50) = pmax/2</p>
</td></tr>
<tr><td><code id="PoD_+3A_slope">slope</code></td>
<td>
<p>numeric: slope of the PoD curve</p>
</td></tr>
<tr><td><code id="PoD_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="PoD_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="PoD_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PoD is calculated as: </p>
<p style="text-align: center;"><code class="reqn"> PoD = p_{max} \frac{ (\frac{et50}{titer})^{\gamma} }{ 1 + (\frac{et50}{titer})^{\gamma}}, \ for \ titers \ &gt; 0</code>
</p>
<p> and 
</p>
<p style="text-align: center;"><code class="reqn"> PoD = pmax, \ for \ titers \ &lt;= 0</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>vector of PoDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vaccinated)
data(PoDParams)

PoD(vaccinated$titers, pmax = PoDParams$pmax, et50 = PoDParams$et50, slope = PoDParams$slope)

</code></pre>

<hr>
<h2 id='PoDBAY'>PoDBAY</h2><span id='topic+PoDBAY'></span>

<h3>Description</h3>

<p>PoDBAY package accompanies the article 'A method to estimate probability
of disease and vaccine efficacy 
from clinical trial immunogenicity data'. 
It helps to setup the workflow for vaccine efficacy estimation and clinical 
trial simulation using the PoDBAY method.
</p>


<h3>Details</h3>

<p>It has two main applications:
</p>

<ul>
<li><p> Estimation of vaccine efficacy using subject level immunogenicity data
</p>
</li>
<li><p> Simulation of clinical trial 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Pavel Fiser, Tomas Bartonek, Julie Dudasova
</p>

<hr>
<h2 id='PoDBAYEfficacy'>PoDBAY efficacy estimation</h2><span id='topic+PoDBAYEfficacy'></span>

<h3>Description</h3>

<p>Function calculates the PoDBAY efficacy based on the set of PoD curve parameters calculated in <code>PoDParamEstimation</code> function, vaccinated and control immunogenicity subset means and standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDBAYEfficacy(estimatedParameters,
              blindVaccinated,
              blindControl,
              adjustTiters = FALSE,
              adjustFrom = log2(10),
              adjustTo = log2(5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDBAYEfficacy_+3A_estimatedparameters">estimatedParameters</code></td>
<td>
<p>named data frame (&quot;pmax&quot;, &quot;slope&quot;, &quot;et50&quot;): set of estimated PoD curve parameters</p>
</td></tr>
<tr><td><code id="PoDBAYEfficacy_+3A_blindvaccinated">blindVaccinated</code></td>
<td>
<p><code>Population-class</code> object: vaccinated subjects from immunogenicity subset, containing N, mean, standard deviation information</p>
</td></tr>
<tr><td><code id="PoDBAYEfficacy_+3A_blindcontrol">blindControl</code></td>
<td>
<p><code>Population-class</code> object: control subjects from immunogenicity subset, containing N, mean, standard deviation information</p>
</td></tr>
<tr><td><code id="PoDBAYEfficacy_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="PoDBAYEfficacy_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="PoDBAYEfficacy_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Application of <code>efficacyComputation</code> function to the all PoD curves (each characterized by three PoD parameters) estimated by <code>PoDParamEstimation</code> function.
</p>
<p>Inputs into the <code>efficacyComputation</code> are:
</p>

<ul>
<li><p> PoDParameters: i'th estimated PoD parameters from <code>PoDParamEstimation</code>. i = 1, ..., N, where N = number of estimations in which MLE converges. See <code>PoDMLE</code> for details.
</p>
</li>
<li><p> means: jittered means of immunogenicity subset. See <code>JitterMeans</code> for details.
</p>
</li>
<li><p> standardDeviations: standard deviations of the vaccinated and control subjects from the immunogenicity subset.
</p>
</li></ul>



<h3>Value</h3>

<p>efficacySet, set of PoDBAY effficacies corresponding to estimated set of PoD curve parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(diseased)
data(nondiseased)
data(estimatedParameters)

## Example 1
# Creating imunogenicity subset, method = "Ratio", value = 4
ImmunogenicitySubset &lt;- 
  BlindSampling(diseased, 
                nondiseased, 
                method = list(name = "Ratio", 
                              value = 4))
                              
# Estimating PoD curve parameters
nondiseasedGenerationCount &lt;- nondiseased$N

estimatedParameters &lt;- PoDParamEstimation(diseased$titers,
                       ImmunogenicitySubset$ImmunogenicityNondiseased$titers,
                       nondiseasedGenerationCount,
                       repeatCount = 10)
                       
# Estimating PoDBAY efficacy  
PoDBAYEfficacy(estimatedParameters$results,
              ImmunogenicitySubset$ImmunogenicityVaccinated,
              ImmunogenicitySubset$ImmunogenicityControl)

</code></pre>

<hr>
<h2 id='PoDCI'>PoD curve confidence ribbon</h2><span id='topic+PoDCI'></span>

<h3>Description</h3>

<p>Supplementary function for <code>PoDCurvePlot</code> function. Function calculates the confidence ribbon around the PoD curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDCI(data, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDCI_+3A_data">data</code></td>
<td>
<p>numeric vector for which we the confidence intervals should be calculated</p>
</td></tr>
<tr><td><code id="PoDCI_+3A_ci">ci</code></td>
<td>
<p>numeric: required confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lower bound of CI
median value
upper bound of CI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data &lt;- 0:100

## Example 1
PoDCI(data,
      ci = 0.95)

</code></pre>

<hr>
<h2 id='PoDCurvePlot'>PoD curve: plot</h2><span id='topic+PoDCurvePlot'></span>

<h3>Description</h3>

<p>Supplementary function for plotting the PoD curve with the confidence ribbon (of a required level). Input values are related to PoDBAY package structure. 
See <code>vignette("EfficacyEstimation", package = "PoDBAY")</code> for an example of application of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDCurvePlot(titers,
             estimatedParameters,
             ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDCurvePlot_+3A_titers">titers</code></td>
<td>
<p>numeric vector: grid of titers at which the confidence ribbon should be calculated</p>
</td></tr>
<tr><td><code id="PoDCurvePlot_+3A_estimatedparameters">estimatedParameters</code></td>
<td>
<p>estimatedParameters named data frame (pmax, slope, et50): set of estimated PoD curve parameters, output of <code>PoDParamEstimation</code> function.</p>
</td></tr>
<tr><td><code id="PoDCurvePlot_+3A_ci">ci</code></td>
<td>
<p>numeric, required confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PoD curve plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
library(ggplot2)
data(PoDParams)
data(estimatedParameters)

## Example 1
# titers for which we want calculate the confidence intervals
titers &lt;- seq(from = 0, to = 15, by = 0.01)

# squared error of CurveTitersMedian and functional values of "params" curve
PoDCurvePlot(titers,
             estimatedParameters,
             ci = 0.95)

</code></pre>

<hr>
<h2 id='PoDEfficacySquaredError'>Optimization function: finds PoD curve paramaters (et50, slope)</h2><span id='topic+PoDEfficacySquaredError'></span>

<h3>Description</h3>

<p>Function finds PoD curve parameters (et50, slope) using population summary statistics (mean, sd) and input (reference value, or for example true in the simulation setup) efficacy. 
Efficacy is independent of pmax parameter thus pmax is estimated separately using <code>PmaxEstimation</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDEfficacySquaredError(TrueEfficacy, 
                        vaccinated, 
                        control,
                        initialSlope = 6,
                        adjustTiters = FALSE, 
                        adjustFrom = NA, 
                        adjustTo = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDEfficacySquaredError_+3A_trueefficacy">TrueEfficacy</code></td>
<td>
<p>numeric: input reference efficacy</p>
</td></tr>
<tr><td><code id="PoDEfficacySquaredError_+3A_vaccinated">vaccinated</code></td>
<td>
<p><code>Population-class</code> object: vaccinated group (mean, sd)</p>
</td></tr>
<tr><td><code id="PoDEfficacySquaredError_+3A_control">control</code></td>
<td>
<p><code>Population-class</code> object: control group (mean, sd)</p>
</td></tr>
<tr><td><code id="PoDEfficacySquaredError_+3A_initialslope">initialSlope</code></td>
<td>
<p>numeric: initial slope parameter for the optimization function</p>
</td></tr>
<tr><td><code id="PoDEfficacySquaredError_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="PoDEfficacySquaredError_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="PoDEfficacySquaredError_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function returns et50 and slope PoD curve parameters obtained using <code>efficacySquaredError</code> 
i.e. the opimal (output) parameters et50 and slope correspond to the minimal squared difference between input reference efficacy and calculated efficacy. 
</p>
<p>Pmax parameter is not obtained as efficacy is independent on pmax. 
</p>
<p>The <code>optim</code> function is used for optimization with method = &quot;L-BFGS-B&quot;, 1000 maximum itiretations, (0.1,Inf) boundaries for et50 and (-slopeBoundary, slopeBoundary) boundaries for slope.
</p>
<p>NOTE: The reason for slope boundary settings is because from certain value of slope parameter the shape of the PoD curve and the corresponding PoD values for given titers are almost identical. 
This parameter is supposed to limit the resulting slope value and help MLE to converge to optimal parameters.
The value of &quot;slopeBoundaries&quot; is calculated from data according to Dunning, 2015 (https://doi.org/10.1186/s12874-015-0096-9).
</p>


<h3>Value</h3>

<p>PoD curve parameters (et50, slope)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
data(vaccinated)
data(control)

# Assigning reference efficacy 
TrueEfficacy &lt;- 0.53

# PoD curve parameter estimation
PoDEfficacySquaredError(TrueEfficacy, vaccinated, control)

</code></pre>

<hr>
<h2 id='PoDMLE'>Setup for the maximum likelihood estimation (MLE)</h2><span id='topic+PoDMLE'></span>

<h3>Description</h3>

<p>Function estimates the optimal PoD curve parameters (pmax, et50, slope) using diseased and non-diseased titers. Initial guess of the slope parameter needs to be provided as an input to the optimization, as well as the lowTiterPercent parameter, which is needed for initial guess of the pmax parameter calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDMLE(nondiseasedTiters,
              diseasedTiters,
              adjustTiters = FALSE,
              adjustFrom = log2(10),
              adjustTo = log2(5),
              initialSlope = 6,
              lowTiterPercent = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDMLE_+3A_nondiseasedtiters">nondiseasedTiters</code></td>
<td>
<p>numeric vector: non-diseased subjects titers</p>
</td></tr>
<tr><td><code id="PoDMLE_+3A_diseasedtiters">diseasedTiters</code></td>
<td>
<p>numeric vector: diseased subjects titers</p>
</td></tr>
<tr><td><code id="PoDMLE_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="PoDMLE_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="PoDMLE_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
<tr><td><code id="PoDMLE_+3A_initialslope">initialSlope</code></td>
<td>
<p>numeric: initial guess of the slope parameter for the optimization function</p>
</td></tr>
<tr><td><code id="PoDMLE_+3A_lowtiterpercent">lowTiterPercent</code></td>
<td>
<p>numeric: value in the interval (0,1) - it represents a fraction of bottom titer values of the whole clinical trial used for calculation of inital guess of the pmax parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initial guess of pmax = (number of diseased in the bottom titers + 0.5) / (number of non-diseased and diseased in the bottom titers + 0.5),
Initial et50 = intersection point of distributions of non-diseased and diseased groups. If L-BFGS-B optimization fails to converge, a new et50 initial guess is set to median value of all titers.
</p>
<p>PoDMLE function estimates the PoD curve parameters by maximizing the likelihood value (see <code>MLE</code> function for details) based on the provided titers for diseased and non-diseased groups.
</p>
<p>The <code>optim</code> function is used for optimization with method = &quot;L-BFGS-B&quot;, 500 maximum iterations, (0.1,Inf) boundaries for et50, (1e-6,1) boundaries for pmax and (-slopeBoundary, slopeBoundary) boundaries for slope.
</p>
<p>NOTE: The reason for slope boundary settings is because from certain value of slope parameter the shape of the PoD curve and the corresponding PoD values for given titers are almost identical. This parameter is expected to limit the resulting slope value and help MLE to converge to optimal parameters.
The value of &quot;slopeBoundaries&quot; is calculated as described by Dunning, 2015 (https://doi.org/10.1186/s12874-015-0096-9).
</p>


<h3>Value</h3>

<p>list(&quot;et50&quot;, &quot;slope&quot;, &quot;pmax&quot;), named list of PoD paraters: if MLE converges.
</p>
<p>Null: if MLE does not converge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## EXAMPLE 1:
# Data preparation
data(diseased)
data(nondiseased)

# PoD curve parameter estimation
PoDMLE(nondiseased$titers,
       diseased$titers)

## EXAMPLE 2:
## initialSlope and lowTiterPercent variables are adjusted.
PoDMLE(nondiseased$titers,
       diseased$titers,
       initialSlope = 5,
       lowTiterPercent = 0.3)

</code></pre>

<hr>
<h2 id='PoDParamEstimation'>PoD curve parameters estimation</h2><span id='topic+PoDParamEstimation'></span>

<h3>Description</h3>

<p>Function estimates the PoD curve parameters (pmax, slope, et50) using <code>PoDMLE</code> function. Number of PoD curves estimated equals to the repeatCount input parameter.
</p>
<p>The estimation is performed using provided diseased and non-diseased subject level data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDParamEstimation(diseasedTiters,
                   nondiseasedTiters,
                   nondiseasedGenerationCount,
                   repeatCount = 500,
                   adjustTiters = FALSE,
                   adjustFrom = log2(10),
                   adjustTo = log2(5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDParamEstimation_+3A_diseasedtiters">diseasedTiters</code></td>
<td>
<p>numeric vector: all diseased titers, subject level data</p>
</td></tr>
<tr><td><code id="PoDParamEstimation_+3A_nondiseasedtiters">nondiseasedTiters</code></td>
<td>
<p>numeric vector: non-diseased titers from immunogenicity subset, subject level data</p>
</td></tr>
<tr><td><code id="PoDParamEstimation_+3A_nondiseasedgenerationcount">nondiseasedGenerationCount</code></td>
<td>
<p>numeric: total number of non-diseased subjects in the clinical trial</p>
</td></tr>
<tr><td><code id="PoDParamEstimation_+3A_repeatcount">repeatCount</code></td>
<td>
<p>numeric: how many times is the dataset bootstrapped and the PoD curve parameter estimation performed</p>
</td></tr>
<tr><td><code id="PoDParamEstimation_+3A_adjusttiters">adjustTiters</code></td>
<td>
<p>boolean: set to TRUE if titer values should be adjusted, for details see <code>PoD</code> function</p>
</td></tr>
<tr><td><code id="PoDParamEstimation_+3A_adjustfrom">adjustFrom</code></td>
<td>
<p>numeric: value specifying the detection limit, all values below the detection limit will be adjusted to adjustTo value</p>
</td></tr>
<tr><td><code id="PoDParamEstimation_+3A_adjustto">adjustTo</code></td>
<td>
<p>numeric: value to which titers below the detection limit will be adjusted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>diseasedTiters: subject level titers of all diseased in the clinical trial
</p>
<p>nondiseasedTiters: subject level titers of non-diseased subjects in the immunogenicity subset
</p>
<p>There are two possible scenarios
</p>

<ul>
<li><p> Full: Full information about non-diseased titers is available, i.e subject level data for all non-diseased subjects from the clinical trial (nondiseasedGenerationCount = number of all non-diseased subjects in the clinical trial).
</p>
</li>
<li><p> Ratio or Fixed: Information about non-diseased titers is available only for the immunogenicity subset. In order to compensate for these missing titers we upsampling of this subset to the total number of non-diseased (nondiseasedGenerationCount) in the trial is needed. 
</p>
</li></ul>

<p>nondiseasedGenerationCount: number of all non-diseased subjects in the clinical trial
</p>
<p>NOTE: Number of estimated parameters can be lower than repeatCount as MLE does not necessary converge in all estimations; failcount (number of iterations in which MLE failed to converge) is also returned; for details see <code>MLE</code> function.
</p>
<p>Function steps
</p>

<ul>
<li><p> Upsample non-diseased if needed (needed for methods Ratio and Fixed) - from immunogenicity subset size (N = NondiseasedImmunogenicitySubset$N) to the whole trial size (N = nondiseasedGenerationCount). For details see <code>GenerateNondiseased</code> function.
</p>
</li>
<li><p> Estimate PoD curve: resultsPriorReset
</p>
</li>
<li><p> Reset disease status: the purpose is to estimate the confidence intervals of the PoD curve and its parameters
</p>
<p>Part of the reset disease status procedure is the non-parametric bootstrap: titers of diseased and non-diseased subjects are pooled, and associated PoDs are calculated using their titer values and estimated PoD curve. Based on the subject level probabilities (PoDs), the disease status is reestimated.
</p>
</li>
<li><p> Re-estimate PoD curve: new diseased and non-diseased titers are used to reestimate the PoD curve
</p>
</li></ul>



<h3>Value</h3>

<p>results: PoD curve parameters after resetting the disease status, named data.frame of estimated PoD curve parameters (pmax, slope, et50); see details for more information
</p>
<p>resultsPriorReset: PoD curve parameters prior to resetting the status, named data.frame of estimated PoD curve parameters (pmax, slope, et50); see details for more information
</p>
<p>failcount: number of iterations in which MLE failed to converge; see details for more information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(diseased)
data(nondiseased)

## Example 1
# Creating imunogenicity subset, method = "Full"
NondiseasedImmunogenicitySubset &lt;- 
    ImmunogenicitySubset(diseased, 
                         nondiseased, 
                         method = list(name = "Full", 
                                       value = "NA"))

# Number of all non-diseased subjects in the clinical trial
nondiseasedGenerationCount &lt;- nondiseased$N

PoDParamEstimation(diseased$titers,
                   NondiseasedImmunogenicitySubset$titers,
                   nondiseasedGenerationCount,
                   repeatCount = 10)

## Example 2
# Creating imunogenicity subset, method = "Ratio", value = 4
NondiseasedImmunogenicitySubset &lt;- 
    ImmunogenicitySubset(diseased, 
                         nondiseased, 
                         method = list(name = "Ratio", 
                                       value = 4))
                                       
# Number of all non-diseased subjects in the clinical trial
nondiseasedGenerationCount &lt;- nondiseased$N

PoDParamEstimation(diseased$titers,
                   NondiseasedImmunogenicitySubset$titers,
                   nondiseasedGenerationCount,
                   repeatCount = 10)

</code></pre>

<hr>
<h2 id='PoDParamPointEstimation'>PoD curve point estimate</h2><span id='topic+PoDParamPointEstimation'></span>

<h3>Description</h3>

<p>Function returns PoD curve parameters corresponding to the point estimate of PoD curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDParamPointEstimation(resultsPriorReset, 
                        titers = seq(from = 0, to = 20, by = 0.01), 
                        optim_titers = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDParamPointEstimation_+3A_resultspriorreset">resultsPriorReset</code></td>
<td>
<p>named data frame (&quot;pmax&quot;, &quot;slope&quot;, &quot;et50&quot;): set of estimated PoD curve parameters before resetting the disease status; for further details see <code>PoDParamEstimation</code> function.</p>
</td></tr>
<tr><td><code id="PoDParamPointEstimation_+3A_titers">titers</code></td>
<td>
<p>numeric vector: a grid of titers for PoD curve point estimate calculation</p>
</td></tr>
<tr><td><code id="PoDParamPointEstimation_+3A_optim_titers">optim_titers</code></td>
<td>
<p>logical: TRUE for a predefined sequence of titers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of estimated PoD curves in resultsPriorReset, the function values (probabilities of disease, PoD) for provided grid of titers are calculated.
</p>
<p>Median of function values (PoDs) at each provided titer is calculated.
</p>
<p>Subsequently, the PoD curve model is fitted to the median datapoins using <code>fitPoD</code> function, in order to get PoD curve parameters close to this median curve.
</p>


<h3>Value</h3>

<p>paramsPointEstimate: named data frame of PoD curve parameters corresponding to the PoD curve point estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data preparation
data(estimatedParameters)

## Example 1
# titers for which we want to optimize the functional values
titers &lt;- seq(from = 0, to = 20, by = 0.01)

# Point estimate of PoD curve
PoDParamPointEstimation(estimatedParameters$resultsPriorReset, titers)

</code></pre>

<hr>
<h2 id='PoDParams'>PoD curve parameters</h2><span id='topic+PoDParams'></span>

<h3>Description</h3>

<p>A dataset containing PoD curve parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDParams
</code></pre>


<h3>Format</h3>

<p>data frame
</p>

<dl>
<dt>pmax</dt><dd><p>pmax: maximum PoD</p>
</dd>
<dt>et50</dt><dd><p>et50: titer value corresponding to the pmax/2</p>
</dd>
<dt>slope</dt><dd><p>slope: slope of the PoD curve</p>
</dd>
</dl>


<hr>
<h2 id='PoDParamsCI'>Confidence intervals of PoD curve parameters</h2><span id='topic+PoDParamsCI'></span>

<h3>Description</h3>

<p>Function calculates confidence intervals of the PoD curve parameters (pmax, et50, slope) at user-defined confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDParamsCI(estimatedParameters, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDParamsCI_+3A_estimatedparameters">estimatedParameters</code></td>
<td>
<p>output of <code>PoDParamEstimation</code> function</p>
</td></tr>
<tr><td><code id="PoDParamsCI_+3A_ci">ci</code></td>
<td>
<p>numeric: value from (0, 1) interval, confidence level of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CI of all PoD curve parameters
</p>

<hr>
<h2 id='PoDParamsCICoverage'>Confidence intervals of PoD curve parameters at three confidence levels</h2><span id='topic+PoDParamsCICoverage'></span>

<h3>Description</h3>

<p>Function calculates confidence intervals (80%, 90% and user-defined) of the PoD curve parameters (pmax, et50, slope).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoDParamsCICoverage(estimatedParameters, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoDParamsCICoverage_+3A_estimatedparameters">estimatedParameters</code></td>
<td>
<p>output of <code>PoDParamEstimation</code> function</p>
</td></tr>
<tr><td><code id="PoDParamsCICoverage_+3A_ci">ci</code></td>
<td>
<p>numeric: value from (0, 1) interval, confidence level of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CI of all PoD curve parameters
</p>

<hr>
<h2 id='popFun'>Population function</h2><span id='topic+popFun'></span>

<h3>Description</h3>

<p>Function describing the titer distribution of the population: mean, standard deviation and an additional unknown factor affecting the shape of the distribution (e.g. mixture of two normals or other shapes defined by user).
</p>


<h3>Details</h3>

<p>Inputs into the function (mean, stdDev, Unknowndistribution) and getUnknown method are taken from the <code>Population-class</code> object.
</p>


<h3>Value</h3>

<p>Titer distribution function
</p>

<hr>
<h2 id='Population-class'>Population class</h2><span id='topic+Population-class'></span><span id='topic+population'></span>

<h3>Description</h3>

<p>Population reference class which provides summary and subject level information about the population
</p>


<h3>Fields</h3>


<dl>
<dt><code>N</code></dt><dd><p>numeric: number of subjects in the population</p>
</dd>
<dt><code>mean</code></dt><dd><p>numeric: mean value of titers</p>
</dd>
<dt><code>stdDev</code></dt><dd><p>numeric: standard deviation of titers</p>
</dd>
<dt><code>unknownDistribution</code></dt><dd><p>logical: TRUE if titer distribution is not normally /log-normally distributed; titer disrtibution function needs to be defined by user</p>
</dd>
<dt><code>UDFunction</code></dt><dd><p>function: user-defined titer distribution</p>
</dd>
<dt><code>titers</code></dt><dd><p>numeric: subject level titers, generated with <code>getTiters</code> method</p>
</dd>
<dt><code>PoDs</code></dt><dd><p>numeric: subject level probability of disease (PoD), generated with <code>assginPoD</code> method</p>
</dd>
<dt><code>diseaseStatus</code></dt><dd><p>logical: subject level disease status (TRUE if diseased), generated with <code>ClinicilaTrial</code> function</p>
</dd>
</dl>

<hr>
<h2 id='popX'>Add noise to population titers</h2><span id='topic+popX'></span>

<h3>Description</h3>

<p>Function adds noise to population titers accounting for an unknown factor affecting the titer distibution.
</p>


<h3>Details</h3>

<p>Inputs into the function: N, unknownDistribution and getUnknown() method are taken from the <code>Population-class</code> object.
</p>


<h3>Value</h3>

<p>subject level titers
</p>

<hr>
<h2 id='vaccinated'>Dataset containing the information for vaccinated subjects</h2><span id='topic+vaccinated'></span>

<h3>Description</h3>

<p>A dataset containing the N, mean, stdDev, titers of vaccinated subjects. The dataset is provided in the form of population class object (see the <code>Population-class</code> function for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vaccinated
</code></pre>


<h3>Format</h3>

<p>Population class object:
</p>

<dl>
<dt>N</dt><dd><p>number of subjects</p>
</dd>
<dt>mean</dt><dd><p>mean of titers</p>
</dd>
<dt>stdDev</dt><dd><p>standard deviation of titers</p>
</dd>
<dt>titers</dt><dd><p>subject level titers</p>
</dd>
</dl>


<hr>
<h2 id='waldCI'>Wald confidence interval estimation</h2><span id='topic+waldCI'></span>

<h3>Description</h3>

<p>Function calculates and returns case-count efficacy confidence intervals estimated using Wald's method.
</p>
<p>Input data need to contain information about disease status on individual level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waldCI(vaccinated, control, confLevel = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waldCI_+3A_vaccinated">vaccinated</code></td>
<td>
<p><code>Population-class</code> object: vaccinated subjects, containing information about disease status</p>
</td></tr>
<tr><td><code id="waldCI_+3A_control">control</code></td>
<td>
<p><code>Population-class</code> object: control subjects, containing information about disease status</p>
</td></tr>
<tr><td><code id="waldCI_+3A_conflevel">confLevel</code></td>
<td>
<p>numeric: value from (0, 1) interval, confidence level of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence interval of the relative risk is calculated using the Wald method. (Wald, A. Tests of statistical hypotheses concerning several parameters when the number of observations is large. Transactions of the American Mathematical Society 54, 426-482 (1943)).
</p>


<h3>Value</h3>

<p>Named list of lower and upper confidence interval bound
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading vaccinated and control populations data with PoD information
data(vaccinated)
data(control)

# Estimating the disease status and case-count efficacy with 95\% confidence interval
set.seed(1)
CT &lt;- ClinicalTrial(vaccinated, control, CI = 0.95)

waldCI(vaccinated, control)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
