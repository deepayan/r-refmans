<!DOCTYPE html><html><head><title>Help for package RankAggreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RankAggreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BruteAggreg'><p>Weighted Rank Aggregation via brute force algorithm</p></a></li>
<li><a href='#geneLists'><p>Ordered Gene Lists from 5 microarray studies</p></a></li>
<li><a href='#plot.raggr'><p>Plot function for raggr object returned by RankAggreg or BruteAggreg</p></a></li>
<li><a href='#RankAggreg'><p>Weighted Rank Aggregation of partial ordered lists</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted Rank Aggregation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-05-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Vasyl Pihur &lt;vpihur@gmail.com&gt;, Somnath Datta
        &lt;somnath.datta@louisville.edu&gt;, Susmita Datta
        &lt;susmita.datta@louisville.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vasyl Pihur &lt;vpihur@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable, kohonen, mclust, clValid</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs aggregation of ordered lists based
        on the ranks using several different algorithms:
        Cross-Entropy Monte Carlo algorithm, Genetic algorithm, and a
        brute force algorithm (for small problems).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-09 19:44:16 UTC; vpihur</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-09 20:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='BruteAggreg'>Weighted Rank Aggregation via brute force algorithm</h2><span id='topic+BruteAggreg'></span>

<h3>Description</h3>

<p>Weighted rank aggregation of ordered lists is performed using the brute force approach, i.e. 
generating all possible ordered lists and finding the list with the minimum value of the objective
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BruteAggreg(x, k, weights = NULL, distance = c("Spearman", "Kendall"),
            importance=rep(1,nrow(x)), standardizeWeights = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BruteAggreg_+3A_x">x</code></td>
<td>
<p>a matrix of ordered lists to be combined (lists must be in rows)</p>
</td></tr>
<tr><td><code id="BruteAggreg_+3A_k">k</code></td>
<td>
<p>size of the top-k list</p>
</td></tr>
<tr><td><code id="BruteAggreg_+3A_weights">weights</code></td>
<td>
<p>scores (weights) to be used in the aggregation process</p>
</td></tr>
<tr><td><code id="BruteAggreg_+3A_distance">distance</code></td>
<td>
<p>distance which &quot;measures&quot; the similarity between the ordered lists</p>
</td></tr>
<tr><td><code id="BruteAggreg_+3A_importance">importance</code></td>
<td>
<p>a vector of weights indicating the importance of each ordered list in x</p>
</td></tr>
<tr><td><code id="BruteAggreg_+3A_standardizeweights">standardizeWeights</code></td>
<td>
<p>boolean, default is true which standardizes weights to [0,1]</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The function performs rank aggregation using the old-fashion brute force approach. This approach
works for small problems only and should not be attempted if k is relatively large (k &gt; 10). To 
generate all possible ordered lists, the permutation function from the gtools package is used. Both
weighted and unweighted rank aggregation can be performed. Please refer to the documentation for 
RankAggreg function as the same constraints on x and index.weights apply to both functions.
</p>


<h3>Value</h3>

<table>
<tr><td><code>top.list</code></td>
<td>
<p>Top-k aggregated list</p>
</td></tr>
<tr><td><code>optimal.value</code></td>
<td>
<p>the minimum value of the objective function corresponding to the top-k list</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>distance used by the algorithm</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>method used: BruteForce</p>
</td></tr>
<tr><td><code>importance</code></td>
<td>
<p>importance vector used</p>
</td></tr>
<tr><td><code>lists</code></td>
<td>
<p>original lists to be combined</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>scaled weights used in aggregation</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>objective function values</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p>number of all possible solutions</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>contains minimum and median values of sample</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vasyl Pihur, Somnath Datta, Susmita Datta</p>


<h3>References</h3>

<p>Pihur, V., Datta, S., and Datta, S. (2007) &quot;Weighted rank aggregation of cluster validation 
measures: a Monte Carlo cross-entropy approach&quot; Bioinformatics, 23(13):1607-1615 </p>


<h3>See Also</h3>

<p><code><a href="#topic+RankAggreg">RankAggreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(gtools)

# rank aggregation without weights
x &lt;- matrix(c("A", "B", "C", "D", "E",
        "B", "D", "A", "E", "C",
        "B", "A", "E", "C", "D",
        "A", "D", "B", "C", "E"), byrow=TRUE, ncol=5)

(toplist &lt;- BruteAggreg(x, 5))

# weighted rank aggregation
set.seed(100)
w &lt;- matrix(rnorm(20), ncol=5)
w &lt;- t(apply(w, 1, sort))

(toplist &lt;- BruteAggreg(x,5,w,"Spearman")) # using the Spearman distance
(toplist &lt;- BruteAggreg(x,5,w,"Kendall")) #using the Kendall distance
plot(toplist)
</code></pre>

<hr>
<h2 id='geneLists'>Ordered Gene Lists from 5 microarray studies</h2><span id='topic+geneLists'></span>

<h3>Description</h3>

<p>This dataset contains five lists of genes, each of size 25, from five independent
microarray studies on prostate cancer. The lists are given in Table 4 in the 
manuscript by DeConde et al. Lists form the rows of the dataset with columns corresponding to the ranks of 
genes in each individual study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geneLists)</code></pre>


<h3>Format</h3>

<p>A matrix of size 5 by 25 containing 5 lists of genes.
</p>


<h3>Source</h3>

<p>R. DeConde, S. Hawley, S. Falcon, N. Clegg, B. Knudsen, and R. Etzioni. 
Combining results of microarray experiments: a rank aggregation approach. Stat Appl
Genet Mol Biol, 5(1):Article15, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneLists)
topList &lt;- RankAggreg(geneLists, 5, N=700, seed=100, convIn=3)
plot(topList)
</code></pre>

<hr>
<h2 id='plot.raggr'>Plot function for raggr object returned by RankAggreg or BruteAggreg</h2><span id='topic+plot.raggr'></span>

<h3>Description</h3>

<p>Plots individual ordered lists with the corresponding solution. Optionally,
naive average rank aggregation can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'raggr'
plot(x, show.average = TRUE, show.legend = TRUE, colR="red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.raggr_+3A_x">x</code></td>
<td>
<p>raggr object returned by RankAggreg</p>
</td></tr>
<tr><td><code id="plot.raggr_+3A_show.average">show.average</code></td>
<td>
<p>boolean if average aggregation to be plotted</p>
</td></tr>
<tr><td><code id="plot.raggr_+3A_show.legend">show.legend</code></td>
<td>
<p>boolean if the legend is to be displayed</p>
</td></tr>
<tr><td><code id="plot.raggr_+3A_colr">colR</code></td>
<td>
<p>specifies the color for the resulting list</p>
</td></tr>
<tr><td><code id="plot.raggr_+3A_...">...</code></td>
<td>
<p>additional plotting parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots individual lists and the solution using ranks only (weights are
not used at any time). Optional average rank aggregation can be performed and visualized.
Average rank aggregation is a simple aggregation procedure which computes the average ranks
for each unique element accross and orders them from the smallest to the largest value.
</p>


<h3>Value</h3>

<p>Nothing is returned
</p>


<h3>Author(s)</h3>

<p>Vasyl Pihur, Somnath Datta, Susmita Datta</p>


<h3>References</h3>

<p>Pihur, V., Datta, S., and Datta, S. (2007) &quot;Weighted rank aggregation of cluster validation 
measures: a Monte Carlo cross-entropy approach&quot; Bioinformatics, 23(13):1607-1615 </p>


<h3>See Also</h3>

<p><code><a href="#topic+RankAggreg">RankAggreg</a></code>, <code><a href="#topic+BruteAggreg">BruteAggreg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># rank aggregation without weights
x &lt;- matrix(c("A", "B", "C", "D", "E",
        "B", "D", "A", "E", "C",
        "B", "A", "E", "C", "D",
        "A", "D", "B", "C", "E"), byrow=TRUE, ncol=5)

(CES &lt;- RankAggreg(x, 5, method="CE", distance="Spearman", rho=.1, verbose=FALSE))
plot(CES)
</code></pre>

<hr>
<h2 id='RankAggreg'>Weighted Rank Aggregation of partial ordered lists</h2><span id='topic+RankAggreg'></span>

<h3>Description</h3>

<p>Performs aggregation of ordered lists based on the ranks (optionally with additional
weights) via the Cross-Entropy Monte Carlo algorithm or the Genetic Algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RankAggreg(x, k, weights=NULL, method=c("CE", "GA"),
distance=c("Spearman", "Kendall"), seed=NULL, maxIter = 1000,
convIn=ifelse(method=="CE", 7, 30), importance=rep(1,nrow(x)),
rho=.1, weight=.25, N=10*k^2, v1=NULL,
popSize=100, CP=.4, MP=.01, verbose=TRUE, standardizeWeights = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RankAggreg_+3A_x">x</code></td>
<td>
<p>a matrix of ordered lists to be combined (lists must be in rows)</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_k">k</code></td>
<td>
<p>size of the top-k list</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_weights">weights</code></td>
<td>
<p>a matrix of scores (weights) to be used in the aggregation process. Weights in 
each row must be ordered either in decreasing or increasing order and must correspond to the elements
in x</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_method">method</code></td>
<td>
<p>method to be used to perform rank aggregation: Cross Entropy Monte Carlo (CE) or Genetic Algorithm (GA)</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_distance">distance</code></td>
<td>
<p>distance to be used which &quot;measures&quot; the similarity of ordered lists</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_seed">seed</code></td>
<td>
<p>a random seed specified for reproducability; default: NULL</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_maxiter">maxIter</code></td>
<td>
<p>the maximum number of iterations allowed; default: 1000</p>
</td></tr>  
<tr><td><code id="RankAggreg_+3A_convin">convIn</code></td>
<td>
<p>stopping criteria for both CE and GA algorithms. If the best solution
does not change in convIn iterations, the algorithm converged; default: 7 for CE, 30 for GA</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_importance">importance</code></td>
<td>
<p>vector of weights indicating the importance of each list in x; default: a vector of 1's (
equal weights are given to all lists</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_rho">rho</code></td>
<td>
<p>(rho*N) is the &quot;quantile&quot; of candidate lists sorted by the function values. Used only by the Cross-Entropy algorithm</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_weight">weight</code></td>
<td>
<p>a learning factor used in the probability update procedure of the CE algorithm</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_n">N</code></td>
<td>
<p>a number of samples to be generated by the MCMC; default: 10nk, where n is the number of 
unique elements in x. Used only by the Cross-Entropy algorithm</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_v1">v1</code></td>
<td>
<p>optional, can be used to specify the initial probability matrix; if v1=NULL,
the initial probability matrix is set to 1/n, where n is the number of unique elements in x</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_popsize">popSize</code></td>
<td>
<p>population size in each generation of Genetic Algorithm; default: 100</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_cp">CP</code></td>
<td>
<p>Cross-over probability for the GA; the default value is .4</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_mp">MP</code></td>
<td>
<p>Mutation probability for the GA. This value should be small and the number of mutations in the population of size popSize
and the number of features k is computed as popSize*k*MP.</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_verbose">verbose</code></td>
<td>
<p>boolean, if console output is to be displayed at each iteration</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_standardizeweights">standardizeWeights</code></td>
<td>
<p>boolean, default is true which standardizes weights to [0,1]</p>
</td></tr>
<tr><td><code id="RankAggreg_+3A_...">...</code></td>
<td>
<p>additional arguments can be passed to the internal procedures:
</p>
<p>&ndash; p - penalty for the Kendall's tau distance; default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs rank aggregation via the Cross-Entropy Monte Carlo algorithm or the Genetic Algorithm. Both approaches can and 
should be used when k is relatively large (k &gt; 10). If k is small, one can enumerate all possible
candidate lists and find the minimum directly using the BruteAggreg function available in this package.
</p>
<p>The Cross-Entropy Monte Carlo algorithm is an iterative procedure for solving difficult combinatorial 
problems in which it is computationally not feasable to find the solution directly. In the context of 
rank aggregation, the algorithm searches for the &quot;super&quot;-list which is as close as possible to the
ordered lists in x. We use either the Spearman footrule distance or the Kendall's tau to measure the &quot;closeness&quot; of any two
ordered lists (or modified by us the weighted versions of these distances). Please refer to the paper 
in the references for further details.
</p>
<p>The Genetic Algorithm requires setting CP and MP parameters which effect the rate of &quot;evolution&quot; in the population. If both
CP and MP are small, the algorithms is very conservative and may take a long time to search the solution space of all ordered candidate
lists. On the other hand, setting CP and MP (especially MP) large will introduce a large number of mutations in the population which
can result in a local optima. 
</p>
<p>The convergence criteria used by both algorithms is the repetition of the same minimum value
of the objective function in <em>convIn</em> consecutive iterations.</p>


<h3>Value</h3>

<table>
<tr><td><code>top.list</code></td>
<td>
<p>Top-k aggregated list</p>
</td></tr>
<tr><td><code>optimal.value</code></td>
<td>
<p>the minimum value of the objective function corresponding to the top-k list</p>
</td></tr>
<tr><td><code>sample.size</code></td>
<td>
<p>the number of samples generated by the MCMC at each iteration</p>
</td></tr>
<tr><td><code>num.iter</code></td>
<td>
<p>the number of iterations until convergence</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>which algorithm was used</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>which distance was used</p>
</td></tr>
<tr><td><code>importance</code></td>
<td>
<p>an importance vector used</p>
</td></tr>
<tr><td><code>lists</code></td>
<td>
<p>the original ordered lists</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>scaled weights if specified</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>objective function scores from the last iteration</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>matrix containing minimum and median objective function scores for each iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vasyl Pihur, Somnath Datta, Susmita Datta</p>


<h3>References</h3>

<p>Pihur, V., Datta, S., and Datta, S. (2007) &quot;Weighted rank aggregation of cluster validation 
measures: a Monte Carlo cross-entropy approach&quot; Bioinformatics, 23(13):1607-1615 </p>


<h3>See Also</h3>

<p><code><a href="#topic+BruteAggreg">BruteAggreg</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># rank aggregation without weights
x &lt;- matrix(c("A", "B", "C", "D", "E",
        "B", "D", "A", "E", "C",
        "B", "A", "E", "C", "D",
        "A", "D", "B", "C", "E"), byrow=TRUE, ncol=5)

(CESnoweights &lt;- RankAggreg(x, 5, method="CE", distance="Spearman", N=100, convIn=5, rho=.1))

# weighted rank aggregation
set.seed(100)
w &lt;- matrix(rnorm(20), ncol=5)
w &lt;- t(apply(w, 1, sort))

# using the Cross-Entropy Monte-Carlo algorithm
(CES &lt;- RankAggreg(x, 5, w, "CE", "Spearman", rho=.1, N=100, convIn=5))
plot(CES)
(CEK &lt;- RankAggreg(x, 5, w, "CE", "Kendall", rho=.1, N=100, convIn=5))

# using the Genetic algorithm
(GAS &lt;- RankAggreg(x, 5, w, "GA", "Spearman"))
plot(GAS)
(GAK &lt;- RankAggreg(x, 5, w, "GA", "Kendall"))

# more complex example (to get a better solution, increase maxIter)
data(geneLists)
topGenes &lt;- RankAggreg(geneLists, 25, method="GA", maxIter=100)
plot(topGenes)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
