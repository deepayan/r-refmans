<!DOCTYPE html><html><head><title>Help for package bayesPop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesPop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#age.specific.migration'>
<p>Generate Sex- and Age-specific Migration</p></a></li>
<li><a href='#bayesPop-internal'>
<p>Internal Functions and datasets of bayesPop</p></a></li>
<li><a href='#bayesPop-package'>
<p>Probabilistic Population Projection</p></a></li>
<li><a href='#get.countries.table'>
<p>Accessing Country Information</p></a></li>
<li><a href='#get.pop.prediction'>
<p>Accessing Prediction Object</p></a></li>
<li><a href='#LifeTableMx'>
<p>Life Table Functions</p></a></li>
<li><a href='#mac.expression'>
<p>Expression Generator</p></a></li>
<li><a href='#MLTbx'>
<p>Dataset on Lee-Carter bx for Modeled Countries</p></a></li>
<li><a href='#pop.aggregate'>
<p>Aggregation of Population Projections</p></a></li>
<li><a href='#pop.cohorts.plot'>
<p>Extracting and Plotting Cohort Data</p></a></li>
<li><a href='#pop.expressions'><p>Expressions as used in Population Output Functions</p></a></li>
<li><a href='#pop.map'>
<p>World Map of Population Measures</p></a></li>
<li><a href='#pop.predict'>
<p>Probabilistic Population Projection</p></a></li>
<li><a href='#pop.predict.subnat'>
<p>Subnational Probabilistic Population Projection</p></a></li>
<li><a href='#pop.pyramid'>
<p>Probabilistic Population Pyramid</p></a></li>
<li><a href='#pop.trajectories'>
<p>Accessing Trajectories</p></a></li>
<li><a href='#pop.trajectories.plot'>
<p>Output of Probabilistic Population Projection</p></a></li>
<li><a href='#project.pasfr'>
<p>Projections of Percent Age-Specific Fertily Rate</p></a></li>
<li><a href='#summary.bayesPop.prediction'>
<p>Summary of Probabilistic Population Projection</p></a></li>
<li><a href='#vwBaseYear'>
<p>Datasets on Migration Base Year and Type, and Mortality and Fertility Age Patterns</p></a></li>
<li><a href='#write.pop.projection.summary'>
<p>Writing Projection Summary and Trajectory Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probabilistic Population Projection</td>
</tr>
<tr>
<td>Version:</td>
<td>10.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Hana Sevcikova, Adrian Raftery, Thomas Buettner</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hana Sevcikova &lt;hanas@uw.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), bayesTFR (&ge; 7.1-0), bayesLife (&ge; 5.0-0),
MortCast (&ge; 2.6-1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>wpp2017, wpp2015, wpp2010</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, abind, data.table, wpp2019, wpp2012, graphics,
grDevices, stats, utils, rworldmap, fields, googleVis,
reshape2, plyr</td>
</tr>
<tr>
<td>Description:</td>
<td>Generating population projections for all countries of the world using several probabilistic components, such as total fertility rate and life expectancy (Raftery et al., 2012 &lt;<a href="https://doi.org/10.1073%2Fpnas.1211452109">doi:10.1073/pnas.1211452109</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bayespop.csss.washington.edu">https://bayespop.csss.washington.edu</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-09 22:01:50 UTC; hana</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-09 22:30:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='age.specific.migration'>
Generate Sex- and Age-specific Migration
</h2><span id='topic+age.specific.migration'></span><span id='topic+migration.totals2age'></span><span id='topic+rcastro.schedule'></span>

<h3>Description</h3>

<p>Creates sex- and age-specific net migration datasets out of the total net migration using either a residual method or given age schedules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age.specific.migration(wpp.year = 2019, years = seq(1955, 2100, by = 5), 
    countries = NULL, smooth = TRUE, rescale = TRUE, ages.to.zero = 18:21,
    write.to.disk = FALSE, directory = getwd(), file.prefix = "migration", 
    depratio = wpp.year == 2015, verbose = TRUE)
    
migration.totals2age(df, ages = NULL, annual = FALSE, time.periods = NULL, 
    schedule = NULL, scale = 1, method = "auto", sex = "M",
    id.col = "country_code", country_code = NULL, mig.is.rate = FALSE, 
    alt.schedule.file = NULL, ...)
    
rcastro.schedule(annual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age.specific.migration_+3A_wpp.year">wpp.year</code></td>
<td>
<p>Integer determining which <span class="pkg">wpp</span> package should be used to get the necessary data from. That package is required to have a dataset on total net migration (called <code><a href="wpp2019.html#topic+migration">migration</a></code>). Currently, only packages <code>wpp2015</code>, <code>wpp2017</code> and <code><a href="wpp2019.html#topic+wpp2019">wpp2019</a></code> contain it (see Details).</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_years">years</code></td>
<td>
<p>Array of years that the reconstruction should be made for. This should be a subset of years for which the total net migration is available.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_countries">countries</code></td>
<td>
<p>Numerical country codes to do the reconstruction for. By default it is performed on all countries included in the <code><a href="wpp2019.html#topic+migration">migration</a></code> dataset where aggregations are excluded.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_smooth">smooth</code></td>
<td>
<p>Logical controlling if smoothing of the reconstructed curves is required. Due to rounding issues the residual method often yields unrealistic zig-zags on migration curves by age. Smoothing usually improves their look.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_rescale">rescale</code></td>
<td>
<p>Logical controlling if the resulting migration should be rescaled to match the total migration.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_ages.to.zero">ages.to.zero</code></td>
<td>
<p>Indices of age groups where migration should be set to zero. Default is 85 and older.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_write.to.disk">write.to.disk</code></td>
<td>
<p>If <code>TRUE</code> results are written to disk.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_directory">directory</code></td>
<td>
<p>Directory where to write the results if <code>write.to.disk</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_file.prefix">file.prefix</code></td>
<td>
<p>If <code>write.to.disk</code> is <code>TRUE</code> results are written into two text files with this prefix, a letter &ldquo;M&rdquo; and &ldquo;F&rdquo; determining the sex, and concluded by the &ldquo;.txt&rdquo; suffix. By default &ldquo;migrationM.txt&rdquo; and &ldquo;migrationF.txt&rdquo;.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_depratio">depratio</code></td>
<td>
<p>If it is <code>TRUE</code> it will use an internal dataset on migration dependency ratios to adjust the first three age groups. It can also be a name of a binary file containing such dataset.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the amount of output messages.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_df">df</code></td>
<td>
<p>data.frame, marix or data.table containing total migration counts or rates. Columns correspond to time, rows correspond to locations. Column &ldquo;country_code&rdquo; (or column identified by <code>id.col</code>) contains identifiers of the locations. Names of the time columns should be either single years if <code>annual</code> is <code>TRUE</code>, e.g. &ldquo;2018&rdquo;, &ldquo;2019&rdquo; etc.,  or five year time periods if <code>annual</code> is <code>FALSE</code>, e.g. &ldquo;2010-2015&rdquo;, &ldquo;2015-2020&rdquo; etc.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_ages">ages</code></td>
<td>
<p>Labels of age groups into which the total migration is to be disaggregated. If it is missing, default age groups are determined depending on the argument <code>annual</code>.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_annual">annual</code></td>
<td>
<p>Logical determining if the age groups are 5-year age groups (<code>FALSE</code>) or 1-year ages (<code>TRUE</code>) on which the choice of the default schedule is dependent, if <code>schedule</code> is missing. It also determines the expected syntax of the names of time columns in <code>df</code>.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_time.periods">time.periods</code></td>
<td>
<p>Character vector determining which columns should be considered in the <code>df</code> dataset. It should be a subset of column names in <code>df</code>. By default, all time columns in <code>df</code> are considered.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_schedule">schedule</code></td>
<td>
<p>Numeric vector used for distributing total migration across ages. It should have the same length as <code>ages</code>. If not given, the argument <code>method</code> determines how the totals are distributed.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_scale">scale</code></td>
<td>
<p>The migration schedule is multiplied by this number. It can be used for example, if total migration needs to be distributed between sexes.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_method">method</code></td>
<td>
<p>Method to use for the distribution of totals into age groups. The &ldquo;un&rdquo; method, available only for <span class="pkg">wpp2022</span> and only for projected migration, uses the UN migration schedules. The &ldquo;rc&rdquo; method uses a simple Rogers-Castro disaggregation via the function <code>rcastro.schedule</code>. The &ldquo;user&rdquo; method allows to provide expernal schedules in a file given in the argument <code>alt.schedule.file</code>. The &ldquo;auto&rdquo; method tries to apply the &ldquo;un&rdquo; method first and for countries or time periods where there is no match, it applies the &ldquo;rc&rdquo; method.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_sex">sex</code></td>
<td>
<p>&ldquo;M&rdquo; or &ldquo;F&rdquo; determining the sex of this schedule. It is used for matching to the UN schedules, i.e. if the &ldquo;auto&rdquo; or &ldquo;un&rdquo; method is used.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_id.col">id.col</code></td>
<td>
<p>Name of the unique identifier of the locations.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_country_code">country_code</code></td>
<td>
<p>Code of the country if the data belongs to only country only. It is used for matching to the UN schedules, i.e. if the &ldquo;auto&rdquo; or &ldquo;un&rdquo; method is used.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_mig.is.rate">mig.is.rate</code></td>
<td>
<p>Logical indicating if the data in <code>df</code> should be interpreted as rates. If <code>FALSE</code>, <code>df</code> represent counts.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_alt.schedule.file">alt.schedule.file</code></td>
<td>
<p>If <code>method</code> is &ldquo;user&rdquo;, alternative migration age schedules can be provided in this binary file. It has the same structure as the internal package objects <code>mig1.schedule</code> (annual) or <code>mig5.schedule</code> (5-year). If there are different schedules for positive and negative totals, the negative schedules are in <code>mig1.neg.schedule</code> or <code>mig5.neg.schedule</code> objects.</p>
</td></tr>
<tr><td><code id="age.specific.migration_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Function <code>age.specific.migration</code></h4>

<p>Unlike in <code><a href="wpp2012.html#topic+wpp2012">wpp2012</a></code>, for the three latest releases of the WPP, the <span class="pkg">wpp2015</span>, <span class="pkg">wpp2017</span>, and <span class="pkg"><a href="wpp2019.html#topic+wpp2019">wpp2019</a></span>, the UN Population Division did not publish the sex- and age-specific net migration counts, only the totals. However, since the sex- and age-schedules are needed for population projections, the <code>age.specific.migration</code> function attempts to reconstruct those missing datasets. It uses the published population projections by age and sex, fertility and mortality projections from the <span class="pkg">wpp</span> package. It computes the population projection without migration and sets the residual to the published population projection as the net migration. By default such numbers are then scaled so that the sum over sexes and ages corresponds to the total migration count. 
</p>
<p>If <code>smooth</code> is <code>TRUE</code> a smoothing procedure is performed over ages where necessary. Also, for simplicity, we set migration of old ages to zero (default is 85+). Both is done before the scaling. If it is desired to obtain raw residuals without any additional processing, set <code>smooth=FALSE</code>, <code>rescale=FALSE</code>, <code>ages.to.zero=c()</code>. 
</p>



<h4>Function <code>migration.totals2age</code></h4>

<p>This function should be used when working with <span class="pkg">wpp2022</span> data. It allows users to disagregate total migration counts or rates (for multiple time periods and multiple locations) into age-specific ones by either the UN schedule used in WPP2022 (<code>method = "un"</code>), a Rogers-Castro (<code>method = "rc"</code>), a user-defined schedule (<code>method = "user"</code>) or a combination of the first two (<code>method = "auto"</code>). In the latter case, the UN schedule is used for records that match in terms of country code and time periods. For the remaining records, a Rogers-Castro schedule is used. The latter schedule can be accessed via the function <code>rcastro.schedule</code> where the <code>annual</code> argument specifies if it is for 1-year or 5-year age groups. 
</p>



<h3>Value</h3>

<p>Function <code>age.specific.migration</code> returns a list of two data frames (<code>male</code> and <code>female</code>), each having the same structure as  <code><a href="wpp2012.html#topic+migrationM">migrationM</a></code>.
</p>
<p>Function <code>migration.totals2age</code> returns a data.table with the disaggregated counts. 
</p>
<p>Function <code>rcastro.schedule</code> returns a vector of proportions for each age group.
</p>


<h3>Warning</h3>

<p>Due to rounding issues and slight differences in the methodology, the <code>age.specific.migration</code> function does not reproduce the unpublished UN datasets exactly. It is only an approximation! Especially, the first age groups might be more off than other ages.
</p>


<h3>Note</h3>

<p>The <code>age.specific.migration</code> function is called automatically from <code><a href="#topic+pop.predict">pop.predict</a></code> if no migration input is given. Similarly, if migration is given as totals, i.e. via the entries <code>mig</code>, <code>migMt</code>, or <code>migFt</code>, the function <code>migration.totals2age</code> is called using either the UN schedules or the default Rogers-Castro schedule. 
Thus, only users that need sex- and age-specific migration for other purposes, or modify the defaults, will need to call these functions explicitly.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.predict">pop.predict</a></code>, <code><a href="wpp2019.html#topic+migration">migration</a></code> <code><a href="wpp2012.html#topic+migrationM">migrationM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
asmig &lt;- age.specific.migration()
head(asmig$male)
head(asmig$female)
## End(Not run)

# simple disaggregation for one location
totmig &lt;- c(30, -50, -100)
names(totmig) &lt;- 2018:2020
asmig.simple &lt;- migration.totals2age(totmig, annual = TRUE, method = "rc")
head(asmig.simple)

## Not run: 
# disaggregate WPP 2019 migration for all countries, one sex
data(migration, package = "wpp2019")
# assuming equal sex migration ratio
asmig.all &lt;- migration.totals2age(migration, scale = 0.5, method = "rc") 
# plot result for the US in 2095-2100
mig1sex.us &lt;- subset(asmig.all, country_code == 840)[["2095-2100"]]
plot(ts(mig1sex.us))
# check that the sum is half of the original total
sum(mig1sex.us) == subset(migration, country_code == 840)[["2095-2100"]]/2
## End(Not run)
</code></pre>

<hr>
<h2 id='bayesPop-internal'>
Internal Functions and datasets of bayesPop
</h2><span id='topic+KannistoAxBx'></span><span id='topic+StoPopProj'></span><span id='topic+do.pop.trajectories.plot'></span><span id='topic+get.age.labels'></span><span id='topic+get.country.inputs'></span><span id='topic+get.pop.traj.quantiles'></span><span id='topic+get.pop.trajectories'></span><span id='topic+get.pop.trajectories.multiple.age'></span><span id='topic+get.prediction.year.index'></span><span id='topic+get.traj.index'></span><span id='topic+is.saved.pi'></span><span id='topic+load.inputs'></span><span id='topic+modifiedLC'></span><span id='topic+read.bayesPop.file'></span><span id='topic+read.pop.file'></span><span id='topic+runKannisto'></span><span id='topic+migdepratio'></span><span id='topic+depratioM'></span><span id='topic+depratioF'></span><span id='topic+pasfr.glob.norms'></span>

<h3>Description</h3>

<p>These functions and datasets are not to be used directly by the user.
</p>

<hr>
<h2 id='bayesPop-package'>
Probabilistic Population Projection
</h2><span id='topic+bayesPop-package'></span><span id='topic+bayesPop'></span>

<h3>Description</h3>

<p>The package allows to generate population projections for all countries of the world using several probabilistic components, such as total fertility rate (TFR) and life expectancy. Generating subnational projections is also supported. 
</p>


<h3>Details</h3>

<p>The main function is called <code><a href="#topic+pop.predict">pop.predict</a></code>. It uses trajectories of TFR from the <span class="pkg">bayesTFR</span> package and life expectancy from the <span class="pkg">bayesLife</span> package and for each trajectory it computes a population projection using the cohort component method. It results in probabilistic age and sex specific projections. Various plotting functions are available for results visualization (<code><a href="#topic+pop.trajectories.plot">pop.trajectories.plot</a></code>, <code><a href="#topic+pop.pyramid">pop.pyramid</a></code>, <code><a href="#topic+pop.trajectories.pyramid">pop.trajectories.pyramid</a></code>, <code><a href="#topic+pop.map">pop.map</a></code>), as well as a <a href="#topic+summary.bayesPop.prediction">summary function</a>. Aggregations can be derived using <code><a href="#topic+pop.aggregate">pop.aggregate</a></code>. An <a href="#topic+pop.expressions">expression language</a> is available to obtain the distribution of various population quantities. 
</p>
<p>Subnational projections can be generated using <code><a href="#topic+pop.predict.subnat">pop.predict.subnat</a></code>. Function <code><a href="#topic+pop.aggregate.subnat">pop.aggregate.subnat</a></code> aggregates such projections.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery, Thomas Buettner
</p>
<p>Maintainer: Hana Sevcikova &lt;hanas@uw.edu&gt;
</p>


<h3>References</h3>

<p>H. Sevcikova, A. E. Raftery (2016). bayesPop: Probabilistic
Population Projections. Journal of Statistical Software, 75(5), 1-29.
<a href="https://doi.org/10.18637/jss.v075.i05">doi:10.18637/jss.v075.i05</a>
</p>
<p>A. E. Raftery,  N. Li, H. Sevcikova, P. Gerland, G. K. Heilig (2012). Bayesian probabilistic population projections for all countries. Proceedings of the National Academy of Sciences 109:13915-13921. <a href="https://doi.org/10.1073/pnas.1211452109">doi:10.1073/pnas.1211452109</a>
</p>
<p>P. Gerland, A. E. Raftery, H. Sevcikova, N. Li, D. Gu, T. Spoorenberg, L. Alkema, B. K. Fosdick, J. L. Chunn, N. Lalic, G. Bay, T. Buettner, G. K. Heilig,  J. Wilmoth (2014). World Population Stabilization Unlikely This Century. Science 346:234-237.
</p>
<p>H. Sevcikova, N. Li, V. Kantorova, P. Gerland and A. E. Raftery (2015). Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. arXiv:1503.05215. <a href="https://arxiv.org/abs/1503.05215">https://arxiv.org/abs/1503.05215</a>

</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+bayesTFR-package">bayesTFR</a></code>, <code><a href="bayesLife.html#topic+bayesLife-package">bayesLife</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
# Generates population projection for one country
country &lt;- "Netherlands"
pred &lt;- pop.predict(countries=country, output.dir=sim.dir)
summary(pred, country)
pop.trajectories.plot(pred, country)
dev.off()
pop.trajectories.plot(pred, country, sum.over.ages=TRUE)
pop.pyramid(pred, country)
pop.pyramid(pred, country, year=2100, age=1:26)
unlink(sim.dir, recursive=TRUE)

## End(Not run)

# Here are commands needed to run probabilistic projections
# from scratch, i.e. including TFR and life expectancy.
# Note that running the first four commands 
# (i.e. predicting TFR and life expectancy) can take 
# LONG time (up to several days; see below for possible speed-up). 
# For a toy simulation, set the number of iterations (iter) 
# to a small number.
## Not run: 
sim.dir.tfr &lt;- "directory/for/TFR"
sim.dir.e0 &lt;-  "directory/for/e0"
sim.dir.pop &lt;- "directory/for/pop"

# Estimate TFR parameters (speed-up by including parallel=TRUE)
run.tfr.mcmc(iter="auto", output.dir=sim.dir.tfr, seed=1)

# Predict TFR (if iter above &lt; 4000, reduce burnin and nr.traj accordingly)
tfr.predict(sim.dir=sim.dir.tfr, nr.traj=2000, burnin=2000)

# Estimate e0 parameters (females) (speed-up by including parallel=TRUE)
# Can be run independently of the two commands above
run.e0.mcmc(sex="F", iter="auto", output.dir=sim.dir.e0, seed=1)

# Predict female and male e0	
# (if iter above &lt; 22000, reduce burnin and nr.traj accordingly)
e0.predict(sim.dir=sim.dir.e0, nr.traj=2000, burnin=20000)

# Population prediction
pred &lt;- pop.predict(output.dir=sim.dir.pop, verbose=TRUE, 
    inputs = list(tfr.sim.dir=sim.dir.tfr, 
                  e0F.sim.dir=sim.dir.e0, e0M.sim.dir="joint_"))
pop.trajectories.plot(pred, "Madagascar", nr.traj=50, sum.over.ages=TRUE)
pop.trajectories.table(pred, "Madagascar")

## End(Not run)
</code></pre>

<hr>
<h2 id='get.countries.table'>
Accessing Country Information
</h2><span id='topic+get.countries.table'></span><span id='topic+get.countries.table.bayesPop.prediction'></span>

<h3>Description</h3>

<p>The function returns a data frame containing codes and names of all countries used in the prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesPop.prediction'
get.countries.table(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.countries.table_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="get.countries.table_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns <code>code</code> and <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>

<hr>
<h2 id='get.pop.prediction'>
Accessing Prediction Object
</h2><span id='topic+get.pop.prediction'></span><span id='topic+has.pop.prediction'></span><span id='topic+pop.cleanup.cache'></span>

<h3>Description</h3>

<p>Function <code>get.pop.prediction</code> retrieves results of a prediction from disk and creates an object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>. Function <code>has.pop.prediction</code> checks an existence of such results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pop.prediction(sim.dir, aggregation = NULL, write.to.cache = TRUE)

has.pop.prediction(sim.dir)

pop.cleanup.cache(pop.pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pop.prediction_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory where the prediction is stored. It should correspond to the value of the <code>output.dir</code> argument used in the <code><a href="#topic+pop.predict">pop.predict</a></code> function.</p>
</td></tr>
<tr><td><code id="get.pop.prediction_+3A_aggregation">aggregation</code></td>
<td>
<p>If given, the prediction object is considered to be an aggregation and both arguments are passed to <code><a href="#topic+get.pop.aggregation">get.pop.aggregation</a></code>.</p>
</td></tr>
<tr><td><code id="get.pop.prediction_+3A_write.to.cache">write.to.cache</code></td>
<td>
<p>Logical controlling if other functions are allowed to write the cache of this prediction object (see Details).</p>
</td></tr>
<tr><td><code id="get.pop.prediction_+3A_pop.pred">pop.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+pop.predict">pop.predict</a></code> function stores resulting trajectories into a directory called <code>output.dir</code>/prediction. Here the argument <code>sim.dir</code> should correspond to <code>output.dir</code> (i.e. without the &ldquo;prediction&rdquo; part).
</p>
<p>In addition to retrieving prediction results, the <code>get.pop.prediction</code> function also looks for a file called &lsquo;<span class="file">cache.rda</span>&rsquo; and loads it into an environment called <code>cache</code>. If it does not exist, it creates an empty <code>cache</code> environment. See <code><a href="#topic+pop.map">pop.map</a></code> - Section Performance and Caching. The environment can be cleaned up using the <code>pop.cleanup.cache</code> function which also deletes the &lsquo;<span class="file">cache.rda</span>&rsquo; file on disk. If <code>write.to.cache</code> is <code>FALSE</code>, other functions are not allowed to manipulate the &lsquo;<span class="file">cache.rda</span>&rsquo; file.
</p>


<h3>Value</h3>

<p>Function <code>has.pop.prediction</code> returns a logical indicating if a prediction exists. 
</p>
<p>Function <code>get.pop.prediction</code> returns an
object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>, <code><a href="#topic+get.pop.aggregation">get.pop.aggregation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir)
summary(pred)
</code></pre>

<hr>
<h2 id='LifeTableMx'>
Life Table Functions
</h2><span id='topic+LifeTableMx'></span><span id='topic+LifeTableMxCol'></span>

<h3>Description</h3>

<p>Functions for obtaining life table quantities. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LifeTableMx(mx, sex = c("Male", "Female", "Total"), include01 = TRUE,
	abridged = TRUE, radix = 1, open.age = 130)

LifeTableMxCol(mx, colname = c("Lx", "lx", "qx", "mx", "dx", "Tx", "sx", "ex", "ax"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LifeTableMx_+3A_mx">mx</code></td>
<td>
<p>Vector of age-specific mortality rates nmx. If <code>abridged</code> is <code>TRUE</code>, the elements correspond to 1m0, 4m1, 5m5, 5m10, ..., otherwise they corresppond single year age groups.  In the abridged case teh vector can have no more than 28 elements which corresponds to age up to 130. In the <code>LifeTableMxCol</code> function, this argument can be a two-dimensional matrix with first dimension being the age.</p>
</td></tr>
<tr><td><code id="LifeTableMx_+3A_sex">sex</code></td>
<td>
<p>For which sex is the life table.</p>
</td></tr>
<tr><td><code id="LifeTableMx_+3A_include01">include01</code></td>
<td>
<p>Logical. If it is <code>FALSE</code> the first two age groups (0-1 and 1-4) are collapsed to one age group (0-4). Only considered if <code>abridged</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LifeTableMx_+3A_abridged">abridged</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) the life table and the <code>mx</code> argument is assumed for 5-year age groups. Otherwise 1-year age groups are assumed.</p>
</td></tr>
<tr><td><code id="LifeTableMx_+3A_radix">radix</code></td>
<td>
<p>Base of the life table.</p>
</td></tr>
<tr><td><code id="LifeTableMx_+3A_open.age">open.age</code></td>
<td>
<p>Open age group. If smaller than the last age group of <code>mxm</code>, the life table is truncated.</p>
</td></tr>
<tr><td><code id="LifeTableMx_+3A_colname">colname</code></td>
<td>
<p>Name of the column of the life table that should be returned.</p>
</td></tr>
<tr><td><code id="LifeTableMx_+3A_...">...</code></td>
<td>
<p>Arguments passed to underlying functions, e.g. <code>abridged</code>. In addition for abridged life table only, argument <code>age05</code> is a logical vector of size three, specifying if the age groups 0-1, 1-4 and 0-5 should be included. Default value of <code>c(FALSE, FALSE, TRUE)</code> includes the 0-5 age group only. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>LifeTableMx</code> returns a life table for one set of mortality rates. Function <code>LifeTableMxCol</code> returns one column of the life table for (possibly) multiple sets of mortality rates. The underlying workhorse here is the <code><a href="MortCast.html#topic+life.table">life.table</a></code> function from the MortCast package. These functions only collapse the first age groups if needed for an abridged life table (<code>LifeTableMx</code>) or/and combine results for multiple time periods into one object (<code>LifeTableMxCol</code>).  
</p>


<h3>Value</h3>

<p>Function <code>LifeTableMx</code> returns a data frame with the following elements:
</p>
<table>
<tr><td><code>age</code></td>
<td>
<p>Age groups</p>
</td></tr>
<tr><td><code>mx</code></td>
<td>
<p>mx, the input vector of mortality rates.</p>
</td></tr>
<tr><td><code>qx</code></td>
<td>
<p>nqx, probability of dying between ages x ad x+n.</p>
</td></tr>
<tr><td><code>lx</code></td>
<td>
<p>lx, number left alive at age x.</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>ndx, cohort deaths between ages x ad x+n.</p>
</td></tr>
<tr><td><code>Lx</code></td>
<td>
<p>nLx, person-years lived between ages x and x+n.</p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p>sx, survival rate at age x.</p>
</td></tr>
<tr><td><code>Tx</code></td>
<td>
<p>Tx, person-years lived above age x.</p>
</td></tr>
<tr><td><code>ex</code></td>
<td>
<p>e0x, expectation of life at age x.</p>
</td></tr>
<tr><td><code>ax</code></td>
<td>
<p>nax, average person-years lived in the interval by those dying in the interval.</p>
</td></tr>
</table>
<p>Function <code>LifeTableMxCol</code> returns one given column of the life table, possibly as a matrix (if <code>mx</code> is a matrix).
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Thomas Buettner, Nan Li, Patrick Gerland
</p>


<h3>References</h3>

<p>Preston, P., Heuveline, P., Guillot, M. (2001): Demography. Blackwell Publishing Ltd.
</p>


<h3>See Also</h3>

<p><code><a href="MortCast.html#topic+life.table">life.table</a></code>, <code><a href="#topic+pop.expressions">pop.expressions</a></code> for examples on retrieving some life table quantities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
pred &lt;- pop.predict(countries="Ecuador", output.dir=sim.dir, wpp.year=2015,
    present.year=2015, keep.vital.events=TRUE, fixed.mx=TRUE, fixed.pasfr=TRUE)
# get male mortality rates from 2020 for age groups 0-1, 1-4, 5-9, ...
mxm &lt;- pop.byage.table(pred, expression="MEC_M{age.index01(27)}", year=2020)[,1]
print(LifeTableMx(mxm), digits=3)
# female LT with first two age categories collapsed 
mxf &lt;- pop.byage.table(pred, expression="MEC_F{age.index01(27)}", year=2020)[,1]
print(LifeTableMx(mxf, sex="Female", include01=FALSE), digits=3)
unlink(sim.dir, recursive=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='mac.expression'>
Expression Generator
</h2><span id='topic+mac.expression'></span><span id='topic+mac.expression1'></span><span id='topic+mac.expression5'></span>

<h3>Description</h3>

<p>Help functions to easily generate commonly used expressions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mac.expression(country)
mac.expression1(country)
mac.expression5(country)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mac.expression_+3A_country">country</code></td>
<td>
<p>Country code as defined for <code><a href="#topic+pop.expressions">expressions</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mac.expression</code> and <code>mac.expression1</code> generate expressions for the mean age of childbearing of the given country, for 5-year age groups and 1-year age groups, respectively. <code>mac.expression5</code> is a synonym for <code>mac.expression</code>.
Note that <code><a href="#topic+pop.predict">pop.predict</a></code> has to be run with <code>keep.vital.events=TRUE</code> for this to work.
</p>


<h3>Value</h3>

<p><code>mac.expression</code> returns a character string corresponding to the formula
<code class="reqn">(17.5*R_c(15-19) + 22.5*R_c(20-24) + ... + 47.5*R_c(45-49))/100</code>
where <code class="reqn">R_c(x)</code> denotes the country-specific percent age-specific fertility for the age group <code class="reqn">x</code>. 
</p>
<p><code>mac.expression1</code> returns a character string corresponding to the formula
<code class="reqn">(10.5*R_c(10-11) + 11.5*R_c(11-12) + ... + 54.5*R_c(54-55))/100</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.expressions">pop.expressions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
# Run pop.predict with storing vital events
pred &lt;- pop.predict(countries=c("Germany", "France"), nr.traj=3, 
           keep.vital.events=TRUE, output.dir=sim.dir)
# plot the mean age of childbearing 
pop.trajectories.plot(pred, expression=mac.expression("FR"), cex.main = 0.7)
unlink(sim.dir, recursive=TRUE)
## End(Not run)</code></pre>

<hr>
<h2 id='MLTbx'>
Dataset on Lee-Carter bx for Modeled Countries
</h2><span id='topic+MLTbx'></span>

<h3>Description</h3>

<p>Dataset with values of the Lee-Carter bx parameter for countries where mortality was obtained using model life tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    data(MLTbx)
</code></pre>


<h3>Format</h3>

<p>A data frame with nine rows and 28 columns. Each row corresponds to one mortality age pattern as defined in the <code><a href="#topic+vwBaseYear">vwBaseYear</a></code> dataset. Each column corresponds to an age group, starting with 0-1, 1-4, 5-9, 10-14, ... up to 125-129, 130+.</p>


<h3>Details</h3>

<p>These values are used for countries for which the column <code>AgeMortalityType</code> in <code><a href="#topic+vwBaseYear">vwBaseYear</a></code> is equal to &ldquo;Model life tables&rdquo;. In such a case a row is selected that corresponds to the corresponding value of the column <code>AgeMortalityPattern</code> (also in  <code><a href="#topic+vwBaseYear">vwBaseYear</a></code>). These values are then used instead of estimating the Lee-Carter <code class="reqn">b_x</code> from the country's historical data.
</p>


<h3>Source</h3>

<p>Data provided by the United Nations Population Division.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vwBaseYear">vwBaseYear</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MLTbx)
str(MLTbx)
</code></pre>

<hr>
<h2 id='pop.aggregate'>
Aggregation of Population Projections
</h2><span id='topic+pop.aggregate'></span><span id='topic+get.pop.aggregation'></span><span id='topic+pop.aggregate.subnat'></span>

<h3>Description</h3>

<p>Aggregation of existing countries' population projections into projections of given regions, and accessing such aggregations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.aggregate(pop.pred, regions, 
    input.type = c("country", "region"), name = input.type,
    inputs = list(e0F.sim.dir = NULL, e0M.sim.dir = "joint_", tfr.sim.dir = NULL),
    my.location.file = NULL, verbose = FALSE, ...)
    
get.pop.aggregation(sim.dir = NULL, pop.pred = NULL, name = NULL, 
    write.to.cache = TRUE)
    
pop.aggregate.subnat(pop.pred, regions, locations, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.aggregate_+3A_pop.pred">pop.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code> containing country-specific population projections.</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_regions">regions</code></td>
<td>
<p>Vector of numerical codes of regions. It should correspond to values in the column &ldquo;country_code&rdquo; in the <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> dataset or in <code>my.location.file</code> (see below). For <code>pop.aggregate.subnat</code> it is a numerical code of a country over which subregions are aggregated.</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_input.type">input.type</code></td>
<td>
<p>There are two methods for aggregating projections depending on the type of inputs, &ldquo;country&rdquo;- and &ldquo;region&rdquo;-based, see Details. </p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_name">name</code></td>
<td>
<p>Name of the aggregation. It becomes a part of a directory name where aggregation results are stored.</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_inputs">inputs</code></td>
<td>
<p>This argument is only used when the &ldquo;region&rdquo;-based method is selected. It is a list of inputs of probabilistic components of the projection:
</p>

<dl>
<dt>e0F.sim.dir</dt><dd><p>Simulation directory with projections of female life expectancy (generated using <span class="pkg"><a href="bayesLife.html#topic+bayesLife">bayesLife</a></span>). It must contain projections for the given regions (see functions <code><a href="bayesLife.html#topic+run.e0.mcmc.extra">run.e0.mcmc.extra</a></code>, <code><a href="bayesLife.html#topic+e0.predict.extra">e0.predict.extra</a></code>). If it is not given, the same e0 directory is taken which was used for generating the <code>pop.pred</code> object, in which case the e0 projections  are re-loaded from disk.</p>
</dd>
<dt>e0M.sim.dir</dt><dd><p>Simulation directory with projections of male life expectancy. By default (value <code>NULL</code> or &ldquo;joint_&rdquo;) the function assumes a joint female-male projections of life expectancy and thus tries to load the male projections from the female projection object created using the <code>e0F.sim.dir</code> argument.</p>
</dd>
<dt>tfr.sim.dir</dt><dd><p>Simulation directory with projections of total fertility rate (generated using <span class="pkg"><a href="bayesTFR.html#topic+bayesTFR">bayesTFR</a></span>). It must contain projections for the given regions (see functions <code><a href="bayesTFR.html#topic+run.tfr.mcmc.extra">run.tfr.mcmc.extra</a></code>, <code><a href="bayesTFR.html#topic+tfr.predict.extra">tfr.predict.extra</a></code>). If it is not given, the same TFR directory is taken which was used for generating the <code>pop.pred</code> object, in which case the TFR projections  are re-loaded from disk.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_my.location.file">my.location.file</code></td>
<td>
<p>User-defined location file that can contain other agreggation groups than the default UN location file. It should have the same structure as the <code><a href="wpp2012.html#topic+UNlocations">UNlocations</a></code> dataset, see below.</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory where aggregation is stored. It is the same directory used for creating the <code>pop.pred</code> object. Alternatively, <code>pop.pred</code> can be used. Either <code>sim.dir</code> or <code>pop.pred</code> must be given.</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_write.to.cache">write.to.cache</code></td>
<td>
<p>Logical controlling if functions operating on this object are allowed to write into its cache (see Details of <code><a href="#topic+get.pop.prediction">get.pop.prediction</a></code>).</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_locations">locations</code></td>
<td>
<p>Name of a tab-delimited file that contains definitions of the sub-regions. It should be the same file as used for the <code>locations</code> argument in <code><a href="#topic+pop.predict.subnat">pop.predict.subnat</a></code>.</p>
</td></tr>
<tr><td><code id="pop.aggregate_+3A_...">...</code></td>
<td>
<p>Additional arguments. For a country-type aggregation, it can be logical <code>use.kannisto</code> which determines if the Kannisto method should be used for old ages when aggregating mortality rates. A logical argument <code>keep.vital.events</code> determines if vital events should be computed for aggregations. Argument <code>adjust</code> determines if country-level population numbers should be adjusted to the WPP values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>pop.aggregate</code> triggers an aggregations over countries while function <code>pop.aggregate.subnat</code> is used for aggregation over sub-regions to a country. The following details refer to the use of <code>pop.aggregate</code>. For sub-national aggregation see Example in <code><a href="#topic+pop.predict.subnat">pop.predict.subnat</a></code>. 
</p>
<p>The dataset <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> or <code>my.location.file</code> is used to determine countries to be aggregated, in particular the field &ldquo;location_type&rdquo; of the entries with &ldquo;country_code&rdquo; given in the <code>regions</code> argument. One can aggregate over the following location types: Type 0 means aggregating all countries of the world (or in the file), type 2 is aggregating over continents, type 3 is aggregating over regions within continents, and any other integer (except 4) correponds to user-defined aggregations. Note that type 4 is reserved as a location type of countries and thus, all aggregations are performed over entries of this type. For type 2, countries are matched using the &ldquo;area_code&rdquo; column; for type 3 the matching is done using the &ldquo;reg_code&rdquo; column of the <code><a href="wpp2012.html#topic+UNlocations">UNlocations</a></code> dataset. E.g., if <code>regions=908</code> (Europe) which has location type 2 in the default <code><a href="wpp2012.html#topic+UNlocations">UNlocations</a></code> dataset, all countries are aggregated for which values of 908 are found in the &ldquo;area_code&rdquo; column. If the location type is other than 0, 2, 3 and 4, there must be a column in the file called &ldquo;agcode_<code class="reqn">x</code>&rdquo; with <code class="reqn">x</code> being the location type. This column is then used to match the countries to be aggregated. 
</p>
<p>Consider the following example. Say we want to pair four countries (Germany [DE], France [FR], Netherlands [NL], Italy [IT]) in two different ways, so we have two overlapping groupings, each of which has two groups (A,B): 
</p>

<ol>
<li><p>group A = (DE, FR), group B = (NL, IT)
</p>
</li>
<li><p>group A = (DE, NL), group B = (FR, IT)
</p>
</li></ol>

<p>Then,  <code>my.location.file</code> should have the following entries:
</p>

<table>
<tr>
 <td style="text-align: right;">
	country_code </td><td style="text-align: left;"> name </td><td style="text-align: right;"> location_type </td><td style="text-align: right;"> agcode_98 </td><td style="text-align: right;"> agcode_99 </td>
</tr>
<tr>
 <td style="text-align: right;">
	1001  </td><td style="text-align: left;">		grouping1_groupA </td><td style="text-align: right;">	98	</td><td style="text-align: right;">	-1 </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: right;">			
	1002	  </td><td style="text-align: left;">		grouping1_groupB </td><td style="text-align: right;">	98	</td><td style="text-align: right;">	-1 </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: right;">
	1003	  </td><td style="text-align: left;">		grouping2_groupA </td><td style="text-align: right;">	99  </td><td style="text-align: right;">	-1 </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: right;">
	1004	 </td><td style="text-align: left;">		grouping2_groupB </td><td style="text-align: right;">	99 </td><td style="text-align: right;">	-1 </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: right;">
	276	</td><td style="text-align: left;">	Germany	</td><td style="text-align: right;">		4		</td><td style="text-align: right;">	1001	 </td><td style="text-align: right;"> 1003 </td>
</tr>
<tr>
 <td style="text-align: right;">
	250	</td><td style="text-align: left;">	France	</td><td style="text-align: right;">		4	</td><td style="text-align: right;">		1001	</td><td style="text-align: right;"> 1004 </td>
</tr>
<tr>
 <td style="text-align: right;">
	258	</td><td style="text-align: left;">	Netherlands	 </td><td style="text-align: right;">	4	</td><td style="text-align: right;">	1002		</td><td style="text-align: right;">	1003 </td>
</tr>
<tr>
 <td style="text-align: right;">
	380	</td><td style="text-align: left;">	Italy		</td><td style="text-align: right;">		4	</td><td style="text-align: right;">		1002	 </td><td style="text-align: right;"> 1004 </td>
</tr>
<tr>
 <td style="text-align: right;">
	1005 </td><td style="text-align: left;">		all </td><td style="text-align: right;"> 0 </td><td style="text-align: right;">	-1 </td><td style="text-align: right;"> -1 
</td>
</tr>

</table>

<p>The &ldquo;country_code&rdquo; of the groups is user-specific, but it must be unique within the file. Values of &ldquo;country_code&rdquo; for countries must match those in the prediction object. To run the aggregation for the four groups above we set <code>regions=1001:1004</code>. Having &ldquo;location_type&rdquo; being 98 and 99, it is expected the file to have columns  &ldquo;agcode_98&rdquo; and &ldquo;agcode_99&rdquo; containing assignements to each of the two groupings. Values in this columns corresponding to groups are not used and thus can have any value. For aggregating over all four countries, set <code>regions=1005</code> which has &ldquo;location_type&rdquo; equal 0 and thus, it is aggregated over all entries with &ldquo;location_type&rdquo; equals 4.
</p>
<p>There are two methods available for generating aggregations of population projection:
</p>

<dl>
<dt>Country-based Method</dt><dd>
<p>Aggregations are created by summing trajectories over countries of the given region.
</p>
</dd>
<dt>Region-based Method</dt><dd>
<p>The aggregation is generated using the same algorithm as population projections for single countries (function <code><a href="#topic+pop.predict">pop.predict</a></code>), but it operates on aggregated input components. These are created as follows. Here <code class="reqn">c</code> denotes countries over which we aggregate a region <code class="reqn">R</code>, <code class="reqn">s \in \{m, f\}</code>, <code class="reqn">a</code>, and <code class="reqn">t</code> denote sex, age category and time, respectively. <code class="reqn">t=P</code> denotes the present year of the prediction. <code class="reqn">N_{s,a,t}^c</code> and <code class="reqn">M_{s,a,t}^c</code>, respectively, denotes the historical population count and the Bayesian predictive median of population, respectively, of sex <code class="reqn">s</code>, in age category <code class="reqn">a</code> at time <code class="reqn">t</code> for country <code class="reqn">c</code> (refer to the links in parentheses for description of the data):
</p>

<dl>
<dt>Initial sex and age-specific population (<a href="wpp2012.html#topic+popM">popM, popF</a>):</dt><dd><p><code class="reqn">N_{s,a,t=P}^R = \sum_c N_{s,a,t=P}^c</code></p>
</dd>
<dt>Sex and age-specific death rates (<a href="wpp2012.html#topic+mxM">mxM, mxF</a>):</dt><dd><p><code class="reqn">mx_{s,a,t}^R = \frac{\sum_c(mx_{s,a,t}^c \cdot N_{s,a,t})}{\sum_c N_{s,a,t}}</code></p>
</dd>
<dt>Sex ratio at birth (<a href="wpp2012.html#topic+sexRatio">srb</a>):</dt><dd><p><code class="reqn">SRB_t^R = \frac{\sum_c M_{s=m,a=1,t}^c}{\sum_c M_{s=f,a=1,t}^c}</code></p>
</dd>
<dt>Percentage age-specific fertility rate (<a href="wpp2012.html#topic+percentASFR">pasfr</a>):</dt><dd><p><code class="reqn">PASFR_{a,t}^R = \frac{\sum_c(PASFR_{a,t}^c \cdot M_{s=f,a,t})}{\sum_c M_{s=f,a,t}}</code></p>
</dd>
<dt>Migration code and start year (<a href="#topic+vwBaseYear">mig.type</a>):</dt><dd><p>Aggregated migration code is the code of maximum counts over aggregated countries weighted by <code class="reqn">N_{t=P}^c</code>. Migration start year is the maximum of start years over aggregated countries.</p>
</dd>
<dt>Sex and age-specific migration (<a href="wpp2012.html#topic+migrationM">migM, migF</a>):</dt><dd><p><code class="reqn">mig_{s,a,t}^R = \sum_c mig_{s,a,t}^c</code></p>
</dd>
<dt>Probabilistic projection of life expectancy:</dt><dd><p>We assume an aggregation of life expectancy for the given regions was generated prior to this call, using the <code><a href="bayesLife.html#topic+run.e0.mcmc.extra">run.e0.mcmc.extra</a></code> and <code><a href="bayesLife.html#topic+e0.predict.extra">e0.predict.extra</a></code> functions of the <span class="pkg"><a href="bayesLife.html#topic+bayesLife">bayesLife</a></span> package.</p>
</dd>
<dt>Probabilistic projection of total fertility rate:</dt><dd><p>We assume an aggregation of total fertility for the given regions was generated prior to this call, using the <code><a href="bayesTFR.html#topic+run.tfr.mcmc.extra">run.tfr.mcmc.extra</a></code> and <code><a href="bayesTFR.html#topic+tfr.predict.extra">tfr.predict.extra</a></code> functions of the <span class="pkg"><a href="bayesTFR.html#topic+bayesTFR">bayesTFR</a></span> package.</p>
</dd>	
</dl>
</dd>
</dl>

<p>Results of the aggregations are stored in the same top directory as the <code>pop.pred</code> object, in a sudirectory called &lsquo;<code>aggregations_</code><em>name</em>&rsquo;. They can be accessed using the function <code>get.pop.aggregation</code>. Note that multiple runs of this function with the same name will overwrite previous aggregations results of the same name.
</p>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code> containing the aggregated results. In addition it contains elements <code>aggregation.method</code> giving the <code>input.type</code> used, and <code>aggregated.countries</code> which is a list of countries aggregated for each region. 
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>References</h3>

<p>H. Sevcikova, A. E. Raftery (2016). bayesPop: Probabilistic
Population Projections. Journal of Statistical Software, 75(5), 1-29.
doi:10.18637/jss.v075.i05
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.predict">pop.predict</a></code>, <code><a href="bayesTFR.html#topic+tfr.predict.extra">tfr.predict.extra</a></code>, <code><a href="bayesLife.html#topic+e0.predict.extra">e0.predict.extra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
pred &lt;- pop.predict(countries=c(528,218,450), output.dir=sim.dir)
aggr &lt;- pop.aggregate(pred, 900) # aggregating World (i.e. all countries available in pred)
pop.trajectories.plot(aggr, 900, sum.over.ages=TRUE)
# countries over which we aggregated:
subset(UNlocations, country_code %in% aggr$aggregated.countries[["900"]])
unlink(sim.dir, recursive=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='pop.cohorts.plot'>
Extracting and Plotting Cohort Data 
</h2><span id='topic+pop.cohorts.plot'></span><span id='topic+cohorts'></span>

<h3>Description</h3>

<p>Extracts and plots population counts or results of expressions by cohorts. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohorts(pop.pred, country = NULL, expression = NULL, pi = c(80, 95))
	
pop.cohorts.plot(pop.pred, country = NULL, expression = NULL, cohorts = NULL, 
    cohort.data = NULL, pi = c(80, 95), dev.ncol = 5, show.legend = TRUE, 
    legend.pos = "bottomleft", ann = par("ann"), add = FALSE, xlab = "", ylab = "",  
    main = NULL, xlim = NULL, ylim = NULL, col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.cohorts.plot_+3A_pop.pred">pop.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. If it is not given, <code>expression</code> must be specified.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_expression">expression</code></td>
<td>
<p>Expression defining the population measure to be plotted. For syntax see <code><a href="#topic+pop.expressions">pop.expressions</a></code>. It must be country-specific, i.e. &ldquo;XXX&rdquo; is not allowed, and it must contain curly braces, i.e. be age specific.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_cohorts">cohorts</code></td>
<td>
<p>Years of the cohorts to be plotted. By default, 10 future cohorts (starting from the last observed one) are used. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_cohort.data">cohort.data</code></td>
<td>
<p>List with the cohort data obtained via the <code>cohorts</code> function. If it is not given, function <code>cohorts</code> is called internally, but by passing this argument the processing is faster.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of column for the graphics device.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling whether the legend should be drawn.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Position of the legend passed to the <code><a href="graphics.html#topic+legend">legend</a></code> function.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_ann">ann</code>, <code id="pop.cohorts.plot_+3A_xlab">xlab</code>, <code id="pop.cohorts.plot_+3A_ylab">ylab</code>, <code id="pop.cohorts.plot_+3A_main">main</code>, <code id="pop.cohorts.plot_+3A_xlim">xlim</code>, <code id="pop.cohorts.plot_+3A_ylim">ylim</code>, <code id="pop.cohorts.plot_+3A_col">col</code>, <code id="pop.cohorts.plot_+3A_...">...</code></td>
<td>
<p>Graphical parameters passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="pop.cohorts.plot_+3A_add">add</code></td>
<td>
<p>Logical specifying if the plot should be added to an existing graphics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pop.cohorts.plot</code> plots all cohorts passed in the <code>cohorts</code> argument on the same scale of the <code class="reqn">y</code>-axis. 
</p>


<h3>Value</h3>

<p>Function <code>cohorts</code> returns a list where each element corresponds to one cohort. Each cohort element is a matrix with columns corresponding to years and rows corresponding to the median (first row) and quantiles of the given probability intervals.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.trajectories.plot">pop.trajectories.plot</a></code>, <code><a href="#topic+pop.byage.plot">pop.byage.plot</a></code>, <code><a href="#topic+pop.expressions">pop.expressions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
    pred &lt;- get.pop.prediction(sim.dir)
    # Population cohorts
    pop.cohorts.plot(pred, "Netherlands")
    # plot specific cohorts using expression (must contain {})
    pop.cohorts.plot(pred, expression="P528{}", cohorts=c(1960, 1980, 2000, 2020))
    # the same as
    cohort.data &lt;- cohorts(pred, expression="P528{}")
    pop.cohorts.plot(pred, cohort.data=cohort.data, cohorts=c(1960, 1980, 2000, 2020))
</code></pre>

<hr>
<h2 id='pop.expressions'>Expressions as used in Population Output Functions</h2><span id='topic+pop.expressions'></span>

<h3>Description</h3>

<p>Documentation of expressions supported by functions <code><a href="#topic+pop.trajectories.plot">pop.trajectories.plot</a></code>, <code><a href="#topic+pop.trajectories.plotAll">pop.trajectories.plotAll</a></code>, <code><a href="#topic+pop.trajectories.table">pop.trajectories.table</a></code>, <code><a href="#topic+pop.byage.plot">pop.byage.plot</a></code>, <code><a href="#topic+pop.byage.table">pop.byage.table</a></code>, <code><a href="#topic+cohorts">cohorts</a></code>, <code><a href="#topic+pop.cohorts.plot">pop.cohorts.plot</a></code>, <code><a href="#topic+pop.map">pop.map</a></code>, <code><a href="#topic+pop.map.gvis">pop.map.gvis</a></code>, <code><a href="#topic+write.pop.projection.summary">write.pop.projection.summary</a></code>, <code><a href="#topic+get.pop.ex">get.pop.ex</a></code>, <code><a href="#topic+get.pop.exba">get.pop.exba</a></code>.
</p>


<h3>Details</h3>

<p>The functions above accept an argument <code>expression</code> which should define a population measure, i.e. a quantity that can be computed from population projections, observed population data or vital events. Such an expression is a collection of <em>basic components</em> connected via usual arithmetic operators, such as <code>+</code>,  <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>, and combined using parentheses. In addition, standard R functions or predefined functions (see below) can be used within expressions.
</p>
<p>A <b>basic component</b> is a character string constituted of four parts, two of which are optional. They must be in the following order:
</p>

<ol>
<li><p> Measure identification. One of the folowing upper-case characters:
</p>

<ul>
<li> <p>&lsquo;P&rsquo; - population, 
</p>
</li>
<li> <p>&lsquo;D&rsquo; - deaths, 
</p>
</li>
<li> <p>&lsquo;B&rsquo; - births, 
</p>
</li>
<li> <p>&lsquo;S&rsquo; - survival ratio,
</p>
</li>
<li> <p>&lsquo;F&rsquo; - fertility rate,
</p>
</li>
<li> <p>&lsquo;R&rsquo; - percent age-specific fertility,
</p>
</li>
<li> <p>&lsquo;M&rsquo; - mortality rate, 
</p>
</li>
<li> <p>&lsquo;Q&rsquo; - probability of dying,
</p>
</li>
<li> <p>&lsquo;E&rsquo; - life expectancy,
</p>
</li>
<li> <p>&lsquo;G&rsquo; - net migration,
</p>
</li>
<li> <p>&lsquo;A&rsquo; - a_x column of the life table.
</p>
</li></ul>

<p>All but the &lsquo;P&rsquo; and &lsquo;G&rsquo; indicators are available only if the <code><a href="#topic+pop.predict">pop.predict</a></code> function was run with <code>keep.vital.events=TRUE</code>.
</p>
</li>
<li><p> Country part. One of the following:
</p>

<ul>
<li><p> Numerical country code (as used in <code><a href="wpp2012.html#topic+UNlocations">UNlocations</a></code>, see <a href="https://en.wikipedia.org/wiki/ISO_3166-1_numeric">https://en.wikipedia.org/wiki/ISO_3166-1_numeric</a>), 
</p>
</li>
<li><p> two- or three-character ISO 3166 code, see <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2</a>, <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3</a>, 
</p>
</li>
<li><p> characters &ldquo;XXX&rdquo; which serves as a wildcard for a country code.
</p>
</li></ul>

</li>
<li><p> Sex part (optional): The country part can be followed by either &ldquo;_F&rdquo; (for female) or &ldquo;_M&rdquo; (for male).
</p>
</li>
<li><p> Age part (optional): If used, the basic component is concluded by an age index given as an array. Such array is embraced by either brackets (&ldquo;[&rdquo; and &ldquo;]&rdquo;) or curly braces (&ldquo;{&rdquo; and &ldquo;}&rdquo;). The former invokes a summation of counts over given ages, the latter is used when no summation is desired. Note that if this part is missing, counts are automatically summed over all ages. To use all ages without summing, empty curly braces can be used. 
</p>

<ul>
<li><p> For 5x5 predictions, the age index 1 corresponds to age 0-4, index 2 corresponds to age 5-9 etc. Indicators &lsquo;S&rsquo;, &lsquo;M&rsquo;, &lsquo;Q&rsquo; and &lsquo;E&rsquo; allow an index -1 which corresponds to age 0-1 and an index 0 which corresponds to age 1-4. Use the pre-defined functions <code>age.index01(...)</code> and <code>age.index05(...)</code> (see below) to define the right indices.
</p>
</li>
<li><p> For 1x1 predictions, the age index starts with 0 for all indicators and matches exactly the age. I.e., indices 0,1,2,... correspond to ages 0,1,2,....
</p>
</li></ul>

</li></ol>

<p>Not all combinations of the four parts above make sense. For example, &lsquo;F&rsquo; and &lsquo;R&rsquo; can be only combined with female sex, &lsquo;B&rsquo;, &lsquo;F&rsquo; and &lsquo;R&rsquo; can be only combined with a subset of the age groups, namely child-bearing ages (indices 4 to 10 in 5x5, or 11 to 55 in 1x1). Or, there is no point in summing the life table based indicators (M, Q, E, S, A) over multiple age groups, i.e. using brackets, or over sexes. Thus, if the sex part is omitted for the life table indicators, the life table is correctly aggregated over sexes, instead of a simple summation.
</p>
<p>Examples of basic components are &ldquo;P276&rdquo;, &ldquo;D50_F[4:10]&rdquo;, &ldquo;PXXX{14:27}&rdquo;, &ldquo;SCZE_M{}&rdquo;, &ldquo;QIE_M[-1]&rdquo;.
</p>
<p>When the expression is evaluated on a prediction object, each basic component is substituted by an array of four dimensions (using the <code><a href="#topic+get.pop">get.pop</a></code> function):
</p>

<ol>
<li><p> Country dimension: Equals to one if a specific country code is given, or it equals the number of countries in the prediction object if a wildcard is used.
</p>
</li>
<li><p> Age dimension: Equals to one if the third component above is missing or the age is defined within square brackets. If the age is defined within curly braces, this dimension corresponds to the length of the age array.
</p>
</li>
<li><p> Time dimension: Depending on the time context of the expression, this dimension corresponds to either the number of projection periods or the number of observation periods.
</p>
</li>
<li><p> Trajectory dimension: Corresponds to the number of trajectories in the prediction object, or one if the component is evaluated on observed data.
</p>
</li></ol>

<p>Depending on the context from which the expression is called, the trajectory dimension of the result of the expression can be reduced by computing given quantiles, and if only one country is evaluated, the first dimension is removed. In addition, with an exception of functions <code><a href="#topic+pop.byage.plot">pop.byage.plot</a></code>, <code><a href="#topic+pop.byage.table">pop.byage.table</a></code>,  <code><a href="#topic+cohorts">cohorts</a></code>, and <code><a href="#topic+pop.cohorts.plot">pop.cohorts.plot</a></code>, the expression should be constructed in a way that the age dimension is eliminated. This can be done for example by using brackets to define age, by using the <code>apply</code> function or one of the pre-defined functions described below. When using within <code><a href="#topic+pop.byage.plot">pop.byage.plot</a></code>, <code><a href="#topic+pop.byage.table">pop.byage.table</a></code>, <code><a href="#topic+cohorts">cohorts</a></code>, or <code><a href="#topic+pop.cohorts.plot">pop.cohorts.plot</a></code>, the expression MUST include curly braces.
</p>
<p>While <code><a href="#topic+get.pop">get.pop</a></code> can be used to obtain results of a basic component, functions <code><a href="#topic+get.pop.ex">get.pop.ex</a></code> and <code><a href="#topic+get.pop.exba">get.pop.exba</a></code> evaluate whole expressions. 
</p>


<h3>Pre-defined functions</h3>

<p>The following functions can be used within an expression:
</p>

<ul>
<li> <p><code>gmedian(f, cat)</code> <br />
It gives a median for grouped data with frequencies <code>f</code> and categories <code>cat</code>. This function is to be used in combination with <code>apply</code> or <code>pop.apply</code> (see below) along the age dimension. For example, <br />
&ldquo;apply(P380{}, c(1,3,4), gmedian, cats=seq(0, by=5, length=28))&rdquo; <br />
is an expression for median age in Italy. (See <code>pop.apply</code> below for a simplified version.) 
</p>
</li>
<li> <p><code>gmean(f, cat)</code> <br />
Works like <code>gmedian</code> but gives the grouped mean.
</p>
</li>
<li> <p><code>age.func(data, fun="*")</code> <br />
This function applies <code>fun</code> to <code>data</code> and the corresponding age (the middle point of each age category). The default case would multiply data by the corresponding age. As <code>gmedian</code>, it is to be used in combination with <code>apply</code> or <code>pop.apply</code>.
</p>
</li>
<li> <p><code>drop.age(data)</code> <br />
Drops the age dimension of the data. For example, if two basic components are combined where one is used within the <code>apply</code> function, the other will need to change its dimension in order to have conformable arrays. For example, <br />
&ldquo;apply(age.func(P752{}), c(1,3,4), sum) / drop.age(P752)&rdquo; <br />
is an expression for the average age in Sweden. (See <code>pop.apply</code> below for a simplified version.)
</p>
</li>
<li> <p><code>pop.apply(data, fun, ..., split.along=c("None", "age", "traj", "country"))</code> <br />
By default applies function <code>fun</code> to the age dimension of <code>data</code> and converts the result into the same format as returned by a basic component. This allows combining the <code>apply</code> function with other basic components without having to modify their dimensions. For example, <br />
&ldquo;pop.apply(age.func(P752{}), fun=sum) / P752&rdquo; gives the average age in Sweden, or <br />
&ldquo;pop.apply(P380{}, gmedian, cats=seq(0, by=5, length=28))&rdquo; gives the median age of Italy.
If <code>slice.along</code> is not &lsquo;None&rsquo;, it can be used as an <code>apply</code> function where the data is sliced along one axis. 
</p>
</li>
<li> <p><code>pop.combine(data1, data2, fun, ..., split.along=c("age", "traj", "country"))</code> <br />
Can be used if two basic components should be combined that result in different shapes. It tries to put data into the right format and calls <code>pop.apply</code>. For example, <br />
&ldquo;pop.combine(PIND{}, PIND, '/')&rdquo; give population by age per total population in India, or <br />
&ldquo;pop.combine(BFR - DFR, GFR, '+', split.along='traj')&rdquo; gives births minus deaths plus net migration in France. Here, <code>pop.combine</code> is necessary, because &lsquo;GFR&rsquo; is a deterministic component and thus, has only one trajectory, whereas births and deaths are probabilistic.
</p>
</li>
<li> <p><code>age.index01(end)</code> <br />
Can be used with indicators &lsquo;S&rsquo;, &lsquo;M&rsquo;, &lsquo;Q&rsquo; and &lsquo;E&rsquo; only. It returns an array of age group indices that include ages 0-1 and 1-4 and exclude 0-4. The last age index is <code>end</code>.
</p>
</li>
<li> <p><code>age.index05(end)</code> <br />
Returns an array of age group indices starting with group 0-4, 5-9 until the age group corresponding to index <code>end</code>.
</p>
</li></ul>

<p>There is also a help function available that generates an expression for the mean age of childbearing, see <code><a href="#topic+mac.expression">mac.expression</a></code>.
</p>


<h3>Note</h3>

<p>The expression parser is simple and far from being perfect. We recommend to leave spaces around the basic components.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery</p>


<h3>References</h3>

<p>H. Sevcikova, A. E. Raftery (2016). bayesPop: Probabilistic
Population Projections. Journal of Statistical Software, 75(5), 1-29.
doi:10.18637/jss.v075.i05
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mac.expression">mac.expression</a></code>, <code><a href="#topic+get.pop">get.pop</a></code>, <code><a href="#topic+pop.trajectories.plot">pop.trajectories.plot</a></code>, <code><a href="#topic+pop.map">pop.map</a></code>, <code><a href="#topic+write.pop.projection.summary">write.pop.projection.summary</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir, write.to.cache=FALSE)

# median age of women in child-bearing ages in Netherlands and all countries - trajectories
pop.trajectories.plot(pred, nr.traj=0,
    expression="pop.apply(P528_F{4:10}, gmedian, cats= seq(15, by=5, length=8))")
## Not run: 
pop.trajectories.plotAll(pred, nr.traj=0, 
    expression="pop.apply(PXXX_F{4:10}, gmedian, cats= seq(15, by=5, length=8))")

## End(Not run)
# mean age of women in child-bearing ages in Netherlands - table
pop.trajectories.table(pred, 
    expression="pop.apply(age.func(P528_F{4:10}), fun=sum) / P528_F[4:10]")
# - gives the same results as with "pop.apply(P528_F{4:10}, gmean, cats=seq(15, by=5, length=8))"
# - for the mean age of childbearing, see ?mac.expression

# migration per capita by age
pop.byage.plot(pred, expression="GNL{} / PNL{}", year=2000)

## Not run: 
# potential support ratio - map (with the two countries
#       contained in pred object)
pop.map(pred, expression="PXXX[5:13] / PXXX[14:27]")
## End(Not run)

# proportion of 0-4 years old to whole population - export to an ASCII file
dir &lt;- tempfile()
write.pop.projection.summary(pred, expression="PXXX[1] / PXXX", output.dir=dir)
unlink(dir)

## Not run: 
# These are vital events only available if keep.vital.events=TRUE in pop.predict, e.g.
# sim.dir.tmp &lt;- tempfile()
# pred &lt;- pop.predict(countries="Netherlands", nr.traj=3, 
#           				keep.vital.events=TRUE, output.dir=sim.dir.tmp)
# log female mortality rate by age for Netherlands in 2050, including 0-1 and 1-4 age groups
pop.byage.plot(pred, expression="log(MNL_F{age.index01(27)})", year=2050)

# trajectories of male 1q0 and table of 5q0 for Netherlands
pop.trajectories.plot(pred, expression="QNLD_M[-1]")
pop.trajectories.table(pred, expression="QNLD_M[1]")
# unlink(sim.dir.tmp)
## End(Not run)
</code></pre>

<hr>
<h2 id='pop.map'>
World Map of Population Measures
</h2><span id='topic+pop.map'></span><span id='topic+get.pop.map.parameters'></span><span id='topic+pop.map.gvis'></span><span id='topic+pop.ggmap'></span>

<h3>Description</h3>

<p>Generates a world map of various population measures for a given quantile and a projection or observed period, using different techniques: <code>pop.map</code> use <span class="pkg">rworldmap</span>, <code>pop.ggmap</code> uses <span class="pkg">ggplot2</span>, and <code>pop.map.gvis</code> creates an interactive map via <span class="pkg">GoogleVis</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.map(pred, sex = c("both", "male", "female"), age = "all", expression = NULL, ...)

pop.ggmap(pred, sex=c('both', 'male', 'female'), age='all', expression=NULL, ...)

get.pop.map.parameters(pred, expression = NULL, sex = c("both", "male", "female"), 
    age = "all", range = NULL, nr.cats = 50, same.scale = TRUE, quantile = 0.5, ...)
    
pop.map.gvis(pred, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.map_+3A_pred">pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_sex">sex</code></td>
<td>
<p>One of &ldquo;both&rdquo;  (default), &ldquo;male&rdquo; or &ldquo;female&rdquo;. By default the male and female counts are summed up. This argument is only used if <code>expression</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_age">age</code></td>
<td>
<p>Either a character string &ldquo;all&rdquo; (default) or an integer vector of age indices. Value 1 corresponds to age 0-4, value 2 corresponds to age 5-9 etc. Last age goup <code class="reqn">130+</code> corresponds to index 27. This argument is only used if <code>expression</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_expression">expression</code></td>
<td>
<p>Expression defining the population measure to be plotted. For syntax see <code><a href="#topic+pop.expressions">pop.expressions</a></code>. The country components of the expression should be given as &ldquo;XXX&rdquo;.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_range">range</code></td>
<td>
<p>Range of the population measure to be displayed. It is of the form <code>c(</code><var>min</var>, <var>max</var><code>)</code>.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_nr.cats">nr.cats</code></td>
<td>
<p>Number of color categories.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical controlling if maps for all years of this prediction object should be on the same color scale.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_quantile">quantile</code></td>
<td>
<p>Quantile for which the map should be generated. It must be equal to one of the values in <code>dimnames(pred$quantiles[[2]])</code>, i.e. 0, 0.025, 0.05, 0.1, 0.2, 0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.75, 0.8, 0.9, 0.95, 0.975, 1. Value 0.5 corresponds to the median.</p>
</td></tr>
<tr><td><code id="pop.map_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions. In <code>pop.map</code>, these are <code>quantile</code>, <code>year</code>, <code>projection.index</code>, <code>device</code>, <code>main</code>, and <code>device.args</code> (see <code><a href="bayesTFR.html#topic+tfr.map">tfr.map</a></code>). For <code>pop.ggmap</code>, these are arguments that can be passed to <code><a href="bayesTFR.html#topic+tfr.ggmap">tfr.ggmap</a></code>. For <code>pop.map.gvis</code>, these are all arguments that can be passed to <code><a href="bayesTFR.html#topic+tfr.map.gvis">tfr.map.gvis</a></code>. In addition, <code>pop.map</code> and <code>get.pop.map.parameters</code> accept arguments passed to the <code><a href="rworldmap.html#topic+mapCountryData">mapCountryData</a></code> function of the <span class="pkg">rworldmap</span> package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pop.map</code> creates a single map for the given time period and quantile. If the package <span class="pkg">fields</span> is installed, a color bar legend at the botom of the map is created.
</p>
<p>Function <code>get.pop.map.parameters</code> can be used in combination with <code>pop.map</code>. It sets breakpoints for the color scheme.
</p>
<p>Function <code>pop.ggmap</code> is similar to <code>pop.map</code>, but uses the <span class="pkg">ggplot2</span> package in combination with the <code>geom_sf</code> function.
</p>
<p>Function <code>pop.map.gvis</code> creates an interactive map using the <span class="pkg">googleVis</span> package and opens it in an internet browser. It also generates a table of the mapped values that can be sorted by columns interactively in the browser. 
</p>


<h3>Value</h3>

<p><code>get.pop.map.parameters</code> returns a list with elements:
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>The object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code> used in the function.</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>Value of the argument <code>quantile</code>.</p>
</td></tr>
<tr><td><code>catMethod</code></td>
<td>
<p>If the argument <code>same.scale</code> is <code>TRUE</code>, this element contains breakpoints for categorization. Otherwise, it is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>numCats</code></td>
<td>
<p>Number of categories.</p>
</td></tr>
<tr><td><code>coulourPalette</code></td>
<td>
<p>Subset of the rainbow palette, starting from dark blue and ending at red.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Performance and Caching</h3>

<p>If the <code>expression</code> argument or a non-standard combination of sex and age is used, quantiles are computed on the fly. In such a case, trajectory files for all countries have to be loaded from disk, which can be quite time expensive. Therefore a simple caching mechanism was added to the prediction object which allows re-using data from previously used expressions. The prediction object points to an environment called <code>cache</code> which is a collection of data arrays that are results of evaluating expressions. The space-trimmed expressions are the names of the <code>cache</code> entries. Every time a map function is called, it is checked if the corresponding expression is contained in the <code>cache</code>. If it is not the case, the quantiles are computed on the fly, otherwise the existing values are taken. 
</p>
<p>When computing on the fly, the function tries to process it in parallel if possible, using the package <span class="pkg">parallel</span>. In such a case, the computation is split into <code class="reqn">n</code> nodes where <code class="reqn">n</code> is either the number of cores detected automatically (default), or the value of <code>getOption("cl.cores")</code>. Use <code>options(cl.cores=n)</code> to modify the default. If a sequential processing is desired, set <code>cl.cores</code> to 1. 
</p>
<p>The cache data are also stored on disk, namely in the simulation directory of the prediction object. By default, every update of the cache in memory is also updated on the disk. Thus, data expression results can be re-used in multiple R sessions. Function <code><a href="#topic+pop.cleanup.cache">pop.cleanup.cache</a></code> deletes the content of the cache. This behaviour can be turned off by setting the argument <code>write.to.cache=FALSE</code> in the <code><a href="#topic+get.pop.prediction">get.pop.prediction</a></code> function. We use this settings in the examples throughout this manual whenever the example data from the installation directory is used, in order to prevent writing into the installation directory.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+tfr.map">tfr.map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##########################
# This example only makes sense if there is a simulation 
# for all countries. Below, only two countries are included,
# so the map is useless.
##########################
sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir=sim.dir, write.to.cache=FALSE)

# Using ggplot2
pop.ggmap(pred)
pop.ggmap(pred, year = 2100)

# Using rworldmap
# Uses heat colors with seven categories by default
pop.map(pred, sex="female", age=4:10)
# Female population in child-bearing age as a proportion of totals
pop.map(pred, expression="PXXX_F[4:10] / PXXX")
# The same with more colors
params &lt;- get.pop.map.parameters(pred, expression="PXXX_F[4:10] / PXXX")
do.call("pop.map", params)
# Another projection year on the same color scale
do.call("pop.map", c(list(year=2043), params))

# Interactive map of potential support ratio (requires Flash)
pop.map.gvis(pred, expression="PXXX[5:13] / PXXX[14:27]")
## End(Not run)	
</code></pre>

<hr>
<h2 id='pop.predict'>
Probabilistic Population Projection
</h2><span id='topic+pop.predict'></span><span id='topic+bayesPop.prediction'></span>

<h3>Description</h3>

<p>The function generates trajectories of probabilistic population projection for all countries for which input data is available, or any subset of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.predict(end.year = 2100, start.year = 1950, present.year = 2020, 
    wpp.year = 2019, countries = NULL, 
    output.dir = file.path(getwd(), "bayesPop.output"),
    annual = FALSE,
    inputs = list(popM=NULL, popF=NULL, mxM=NULL, mxF=NULL, srb=NULL,
        pasfr=NULL, patterns=NULL, 
        migM=NULL, migF=NULL, migMt=NULL, migFt=NULL, mig=NULL,
        e0F.file=NULL, e0M.file=NULL, tfr.file=NULL,
        e0F.sim.dir=NULL, e0M.sim.dir=NULL, tfr.sim.dir=NULL,
        migMtraj = NULL, migFtraj = NULL, migtraj = NULL,
        GQpopM = NULL, GQpopF = NULL, average.annual = NULL), 
    nr.traj = 1000, keep.vital.events = FALSE, 
    fixed.mx = FALSE, fixed.pasfr = FALSE,
    lc.for.hiv = TRUE, lc.for.all = TRUE, mig.is.rate = FALSE,
    mig.age.method  = c("auto", "un", "rc", "user"), my.locations.file = NULL, 
    replace.output = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.predict_+3A_end.year">end.year</code></td>
<td>
<p>End year of the projection.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_start.year">start.year</code></td>
<td>
<p>First year of the historical data.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_present.year">present.year</code></td>
<td>
<p>Year for which initial population data is to be used.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_wpp.year">wpp.year</code></td>
<td>
<p>Year for which WPP data is used. The functions loads a package called <span class="pkg">wpp</span><code class="reqn">x</code> where <code class="reqn">x</code> is the <code>wpp.year</code> and uses the various datasets as default if the corresponding <code>inputs</code> element is missing (see below).</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_countries">countries</code></td>
<td>
<p>Array of country codes or country names for which a projection is generated. If it is <code>NULL</code>, all available countries are used. If it is <code>NA</code> and there is an existing projection in <code>output.dir</code> and <code>replace.output=FALSE</code>, then a projection is performed for all countries that are not included in the existing projection. Names of countries are matched to those in the <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> dataset (or in the dataset loaded from <code>my.locations.file</code> if used).</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_output.dir">output.dir</code></td>
<td>
<p>Output directory of the projection. If there is an existing projection in <code>output.dir</code> and <code>replace.output=TRUE</code>, everything in the directory will be deleted.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_annual">annual</code></td>
<td>
<p>Logical. If <code>TRUE</code> it is assumed that this is 1x1 simulation, i.e. one year age groups and one year time periods. Note that this is still an experimental feature!</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_inputs">inputs</code></td>
<td>
<p>A list of file names where input data is stored. It contains the following elements (Unless otherwise noted, these are tab delimited ASCII files; Names of default datasets from the corresponding <span class="pkg">wpp</span> package which are used if the corresponding element is <code>NULL</code> are shown in brackets):
</p>

<dl>
<dt>popM, popF</dt><dd><p>Initial male/female age-specific population (at time <code>present.year</code>) [<code><a href="wpp2019.html#topic+popM">popM</a></code>, <code><a href="wpp2019.html#topic+popF">popF</a></code>].</p>
</dd>
<dt>mxM, mxF</dt><dd><p>Historical data and (optionally) projections of male/female age-specific death rates [<code><a href="wpp2019.html#topic+mxM">mxM</a></code>, <code><a href="wpp2019.html#topic+mxF">mxF</a></code>] (see also argument <code>fixed.mx</code>).</p>
</dd>
<dt>srb</dt><dd><p>Projection of sex ratio at birth. [<code><a href="wpp2019.html#topic+sexRatio">sexRatio</a></code>]</p>
</dd>
<dt>pasfr</dt><dd><p>Historical data and (optionally) projections of percentage age-specific fertility rate [<code><a href="wpp2019.html#topic+percentASFR">percentASFR</a></code>] (see also argument <code>fixed.pasfr</code>).</p>
</dd>
<dt>patterns, mig.type</dt><dd><p>Migration type and base year of the migration. In addition, this dataset gives information on country's specifics regarding mortality and fertility age patterns as defined in [<code><a href="#topic+vwBaseYear">vwBaseYear</a></code>]. <code>patterns</code> and <code>mig.type</code> have the same meaning and can be used interchangeably.</p>
</dd>
<dt>migM, migF, migMt, migFt, mig</dt><dd><p>Projection and (optionally) historical data of net migration on the same scale as the initital population. There are three ways of defining this quantity, here in order of priority: 1. via <code>migM</code> and <code>migF</code> which should give male and female age-specific migration [<code><a href="wpp2012.html#topic+migrationM">migrationM</a></code>, <code><a href="wpp2012.html#topic+migrationF">migrationF</a></code>]; 2. via <code>migMt</code> and <code>migFt</code> which should give male and female total net migration; 3. via <code>mig</code> which should give the total net migration. For 2. and 3., the totals are disagregated into age-specific migration by applying a Rogers-Castro schedule. For 3., the totals are equally split between sexes. If all of these input items are missing, the migration schedules are reconstructed from total migration counts derived from <code><a href="wpp2019.html#topic+migration">migration</a></code> using the <code><a href="#topic+age.specific.migration">age.specific.migration</a></code> function.</p>
</dd>
<dt>e0F.file</dt><dd><p>Comma-delimited CSV file with results of female life expectancy (generated using <span class="pkg"><a href="bayesLife.html#topic+bayesLife">bayesLife</a></span>, function <code><a href="bayesLife.html#topic+convert.e0.trajectories">convert.e0.trajectories</a></code>, file &ldquo;ascii_trajectories.csv&rdquo;). Required columns are &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo;, and &ldquo;e0&rdquo;. If this element is not <code>NULL</code>, the argument <code>e0F.sim.dir</code> is ignored. If both <code>e0F.file</code> and <code>e0F.sim.dir</code> are <code>NULL</code>, data from the corresponding <span class="pkg">wpp</span> package is taken, namely the median projections as one trajectory and the low and high variants (if available) as second and third trajectory.</p>
</dd>
<dt>e0M.file</dt><dd><p>Comma-delimited CSV file containing results of male life expectancy (generated using <span class="pkg"><a href="bayesLife.html#topic+bayesLife">bayesLife</a></span>, function <code><a href="bayesLife.html#topic+convert.e0.trajectories">convert.e0.trajectories</a></code>, file &ldquo;ascii_trajectories.csv&rdquo;). Required columns are &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo;, and &ldquo;e0&rdquo;. If this element is not <code>NULL</code>, the argument <code>e0M.sim.dir</code> is ignored. As in the female case, if both <code>e0M.file</code> and <code>e0M.sim.dir</code> are <code>NULL</code>, data from the corresponding <span class="pkg">wpp</span> package is taken.</p>
</dd>
<dt>tfr.file</dt><dd><p>Comma-delimited CSV file with results of total fertility rate (generated using <span class="pkg"><a href="bayesTFR.html#topic+bayesTFR">bayesTFR</a></span>, function <code><a href="bayesTFR.html#topic+convert.tfr.trajectories">convert.tfr.trajectories</a></code>, file &ldquo;ascii_trajectories.csv&rdquo;). Required columns are &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo;, and &ldquo;TF&rdquo;. If this element is not <code>NULL</code>, the argument <code>tfr.sim.dir</code> is ignored. If both <code>tfr.file</code> and <code>tfr.sim.dir</code> are <code>NULL</code>, data from the corresponding <span class="pkg">wpp</span> package is taken (median and the low and high variants as three trajectories). Alternatively, this argument can be the keyword &ldquo;median_&rdquo; in which case only the wpp median is taken.</p>
</dd>
<dt>e0F.sim.dir</dt><dd><p>Simulation directory with results of female life expectancy (generated using <span class="pkg"><a href="bayesLife.html#topic+bayesLife">bayesLife</a></span>). It is only used if <code>e0F.file</code> is <code>NULL</code>.</p>
</dd>
<dt>e0M.sim.dir</dt><dd><p>Simulation directory with results of male life expectancy (generated using <span class="pkg"><a href="bayesLife.html#topic+bayesLife">bayesLife</a></span>). Alternatively, it can be the string &ldquo;joint_&rdquo;, in which case it is assumed that the male life expectancy was projected jointly from the female life expectancy (see <a href="bayesLife.html#topic+joint.male.predict">joint.male.predict</a>) and thus contained in the <code>e0F.sim.dir</code> directory. The argument is only used if <code>e0M.file</code> is <code>NULL</code>.</p>
</dd>
<dt>tfr.sim.dir</dt><dd><p>Simulation directory with results of total fertility rate (generated using <span class="pkg"><a href="bayesTFR.html#topic+bayesTFR">bayesTFR</a></span>). It is only used if <code>tfr.file</code> is <code>NULL</code>.</p>
</dd>
<dt>migMtraj, migFtraj, migtraj</dt><dd><p>Comma-delimited CSV file with male/female age-specific migration trajectories, or total migration trajectories (<code>migtraj</code>). If present, it replaces deterministic projections given by the <code>mig*</code> items. It has a similar format as e.g. <code>e0M.file</code> with columns &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo;, &ldquo;Age&rdquo; (except for <code>migtraj</code>) and &ldquo;Migration&rdquo;. For a five-year simulation, the &ldquo;Age&rdquo; column must have values &ldquo;0-4&rdquo;, &ldquo;5-9&rdquo;, &ldquo;10-14&rdquo;, ..., &ldquo;95-99&rdquo;, &ldquo;100+&rdquo;. In an annual simulation, age is given by a single number between 0 and 100.</p>
</dd>
<dt>GQpopM, GQpopF</dt><dd><p>Age-specific population counts (male and female) that should be excluded from application of the cohort component method (CCM). It can be used for defining group quarters. These counts are removed from population before the CCM projection and added back afterwards. It is not used when computing vital events on observed data. The datasets should have columns &ldquo;country_code&rdquo;, &ldquo;age&rdquo; and &ldquo;gq&rdquo;. For a five-year simulation, the &ldquo;age&rdquo; column should include values &ldquo;0-4&rdquo;, &ldquo;5-9&rdquo;, &ldquo;10-14&rdquo;, ..., &ldquo;95-99&rdquo;, &ldquo;100+&rdquo;. However, rows with zeros do not need to be included. In an annual simulation, age is given by a single number between 0 and 100.</p>
</dd>
<dt>average.annual</dt><dd><p>Character string with values &ldquo;TFR&rdquo;, &ldquo;e0M&rdquo;, &ldquo;e0F&rdquo;. If this is a 5-year simulation, but the inputs of TFR or/and e0 comes from an annual simulation, including the corresponding string here will cause that the TFR or/and e0 trajectories are converted into 5-year averages.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="pop.predict_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be generated. If this number is smaller than the number of available trajectories of the probabilistic components (TFR, life expectancy and migration), the trajectories are equidistantly thinned. 
If all of those components contain less trajectories than <code>nr.traj</code>, the value is adjusted to the maximum of available trajectories of the components. For those that have less trajectories than the adjusted number, the available trajectories are re-sampled, so that all components have the same number of trajectories.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_keep.vital.events">keep.vital.events</code></td>
<td>
<p>Logical. If <code>TRUE</code> age- and sex-specific vital events of births and deaths as well as other objects are stored in the prediction object, see Details.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_fixed.mx">fixed.mx</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it is assumed the dataset of death rates (mxM and mxF) include data for projection years and they are then used instead of the life expectancy.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_fixed.pasfr">fixed.pasfr</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it is assumed the dataset on percent age-specific fertility rate (percentASFR) include data for projection years and they are then used instead of computing it on the fly.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_lc.for.hiv">lc.for.hiv</code></td>
<td>
<p>Logical controlling if the modified Lee-Carter method should be used 
for projection of mortality rates for countries with HIV epidemics. If <code>FALSE</code>, the function <code>hiv.mortmod</code> from the HIV.LifeTables package is used.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_lc.for.all">lc.for.all</code></td>
<td>
<p>Logical controlling if the modified Lee-Carter method should be used 
for projection of mortality rates for all countries. If <code>FALSE</code>, the corresponding method is determined by the columns &ldquo;AgeMortProjMethod1&rdquo; and &ldquo;AgeMortProjMethod2&rdquo; of the <code><a href="#topic+vwBaseYear">vwBaseYear</a></code> dataset.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_mig.is.rate">mig.is.rate</code></td>
<td>
<p>Logical determining if migration data are to be interpreted as net migration rates (<code>TRUE</code>) or counts (<code>FALSE</code>, default). It can also be a vector of two logicals, where the first element refers to observed data and the second element refers to predictions. A value of <code>c(FALSE, TRUE)</code> could for example be used if observed data in <code>inputs$migration</code> are counts, and migration trajectories in <code>inputs$migtraj</code> are rates.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_mig.age.method">mig.age.method</code></td>
<td>
<p>If migration is given as totals, this argument determines a method to disaggregate into age-specific migration. 
The &ldquo;un&rdquo; method, available only for <span class="pkg">wpp2022</span> and only for projected migration, uses the UN migration schedules. The &ldquo;rc&rdquo; method uses a simple Rogers-Castro disaggregation. The &ldquo;auto&rdquo; method (default) uses &ldquo;un&rdquo; if <code>wpp.year</code> is 2022; if not and if it is a 5-year simulation, it uses a residual method, otherwise a Rogers-Castro. For the &ldquo;un&rdquo; method, Rogers-Castro is used for observed data. Value &ldquo;user&rdquo; can be used 
for this argument if user-specific schedules are provided in a binary file, given in the item &ldquo;mig.alt.age.schedule&rdquo; of the <code>inputs</code> argument. It has the same structure as the internal package objects <code>mig1.schedule</code> (annual) or <code>mig5.schedule</code> (5-year). If there are different schedules for positive and negative totals, the negative schedules are in <code>mig1.neg.schedule</code> or <code>mig5.neg.schedule</code> objects.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_my.locations.file">my.locations.file</code></td>
<td>
<p>Name of a tab-delimited ascii file with a set of all locations for which a projection is generated. Use this argument if you are projecting for a country/region that is not included in the standard <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> dataset. It must have the same structure.</p>
</td></tr>
<tr><td><code id="pop.predict_+3A_replace.output">replace.output</code></td>
<td>
<p>Logical. If <code>TRUE</code>, everything in the directory <code>output.dir</code> is deleted prior to the prediction.</p>
</td></tr> 
<tr><td><code id="pop.predict_+3A_verbose">verbose</code></td>
<td>
<p>Logical controlling the amount of output messages.</p>
</td></tr> 
<tr><td><code id="pop.predict_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying function. These can be <code>parallel</code> and <code>nr.nodes</code> for parallel processing and the number of nodes, respectively, as well as further arguments passed for creating a parallel cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The population projection is computed using the cohort component method and is based on an algorithm used by the United Nation Population Division (see also  Sevcikova et al (2015) in the References below). For each country, one projection is calculated for each trajectory of male and female life expectancy, TFR and possibly migration. This results in a set of trajectories of population projection which forms its posterior distribution. The trajectories of life expectancy and TFR can be given either in its binary form generated by the packages <span class="pkg"><a href="bayesLife.html#topic+bayesLife">bayesLife</a></span> and <span class="pkg"><a href="bayesTFR.html#topic+bayesTFR">bayesTFR</a></span>, respectively (as directories <code>e0M.sim.dir</code>, <code>e0F.sim.dir</code>, <code>tfr.sim.dir</code> of the <code>inputs</code> argument), or they can be given as ASCII tables in csv format, see above. The number of trajectories for male and female life expectancy must match, as does for male and female migration.
</p>
<p>The projection is generated sequentially country by country. Results are stored in a sub-directory of <code>output.dir</code> called &lsquo;<span class="file">prediction</span>&rsquo;. There is one binary file per country, called &lsquo;<span class="file">totpop_country<code class="reqn">x</code>.rda</span>&rsquo;, where <code class="reqn">x</code> is the country code. It contains six objects: <code>totp</code>, <code>totpf</code>, <code>totpm</code> (trajectories of total population, age-specific female and age-specific male, respectively),  <code>totp.hch</code>, <code>totpf.hch</code>, <code>totpm.hch</code> (the UN half-child variant for total population, age-specific female and age-specific male, respectively). Optionally, if <code>keep.vital.events</code> is <code>TRUE</code>, there is an additional file per country, called &lsquo;<span class="file">vital_events_country<code class="reqn">x</code>.rda</span>&rsquo;, containing the following objects: <code>btm</code>, <code>btf</code> (trajectories for births by age of mothers for male and female child, respectively), <code>deathsm</code>, <code>deathsf</code> (trajectories for age-specific male and female deaths, respectively), <code>asfert</code> (trajectories of age-specific fertility), <code>mxm</code>, <code>mxf</code> (trajectories of male and female age-specific mortality rates), <code>migm</code>, <code>migf</code> (if used, these are trajectories of male and female age-specific migration), <code>btm.hch</code>, <code>btf.hch</code>, <code>deathsm.hch</code>, <code>deathsf.hch</code>, <code>asfert.hch</code>, <code>mxm.hch</code>, <code>mxf.hch</code> (the UN half-child variant for age- and sex-specific births, deaths, fertility rates and mortality rates).  An object of class <code>bayesPop.prediction</code> is stored in the same directory in a file &lsquo;<span class="file">prediction.rda</span>&rsquo;. It is updated every time a country projection is finished.
</p>
<p>See <code><a href="#topic+pop.trajectories">pop.trajectories</a></code> for extracting trajectories.
</p>
<p>To access a previously stored prediction object, use <code><a href="#topic+get.pop.prediction">get.pop.prediction</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>bayesPop.prediction</code> with the following elements:
</p>
<table>
<tr><td><code>base.directory</code></td>
<td>
<p>Full path to the base directory <code>output.dir</code>.</p>
</td></tr>
<tr><td><code>output.directory</code></td>
<td>
<p>Sub-directory relative to <code>base.directory</code> with the projections.</p>
</td></tr>
<tr><td><code>nr.traj</code></td>
<td>
<p>The actual number of trajectories of the projections.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Three-dimensional array of projection quantiles (countries x number of quantiles x projection periods). The second dimension corresponds to the following quantiles: <code class="reqn">0.025,0.05,0.1,0.25,0.5,0.75,0.9,0.95,0.975</code>.</p>
</td></tr>
<tr><td><code>traj.mean.sd</code></td>
<td>
<p>Three-dimensional array of projection mean and standard deviation (countries x 2 x projection periods). First and second matrix of the second dimension, respectively, is the mean and standard deviation, respectively.</p>
</td></tr>
<tr><td><code>quantilesM</code>, <code>quantilesF</code></td>
<td>
<p>Quantiles of male and female projection, respectively. Same structure as <code>quantiles</code>.</p>
</td></tr>
<tr><td><code>traj.mean.sdM</code>, <code>traj.mean.sdF</code></td>
<td>
<p>Same as <code>traj.mean.sd</code> corresponding to male and female projection, respectively.</p>
</td></tr>
<tr><td><code>quantilesMage</code>, <code>quantilesFage</code></td>
<td>
<p>Four-dimensional array of age-specific quantiles of male and female projection, respectively (countries x age groups x number of quantiles x projection periods). The same quantiles are used as in <code>quantiles</code>.</p>
</td></tr>
<tr><td><code>quantilesPropMage</code>, <code>quantilesPropFage</code></td>
<td>
<p>Array of age-specific quantiles of male and female projection, respectively, divided by the total population. The dimensions are the same as in <code>quantilesMage</code>.</p>
</td></tr>
<tr><td><code>estim.years</code></td>
<td>
<p>Vector of time for which historical data was used in the projections.</p>
</td></tr>
<tr><td><code>proj.years</code></td>
<td>
<p>Vector of projection time periods starting with the present period.</p>
</td></tr>
<tr><td><code>wpp.year</code></td>
<td>
<p>The wpp year used.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>List of input data used for the projection.</p>
</td></tr>
<tr><td><code>function.inputs</code></td>
<td>
<p>Content of the <code>inputs</code> argument passed to the function.</p>
</td></tr>
<tr><td><code>countries</code></td>
<td>
<p>Matrix of countries for which projection exists. It contains two columns: <code>code</code>, <code>name</code>.</p>
</td></tr>
<tr><td><code>ages</code></td>
<td>
<p>Vector of age groups.</p>
</td></tr>
<tr><td><code>annual</code></td>
<td>
<p>If <code>TRUE</code>, this object corresponds to a 1x1 prediction, otherwise 5x5.</p>
</td></tr>
<tr><td><code>cache</code></td>
<td>
<p>This component is added by <code><a href="#topic+get.pop.prediction">get.pop.prediction</a></code> and modified and used by <code><a href="#topic+pop.map">pop.map</a></code> and <code><a href="#topic+write.pop.projection.summary">write.pop.projection.summary</a></code>. It is an environment for caching and re-using results of expressions.</p>
</td></tr>
<tr><td><code>write.to.cache</code></td>
<td>
<p>Logical determining if <code>cache</code> should be modified.</p>
</td></tr>
<tr><td><code>is.aggregation</code></td>
<td>
<p>Logical determining if this object is a result of <code>pop.predict</code> or <code><a href="#topic+pop.aggregate">pop.aggregate</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Thomas Buettner, based on code of Nan Li and helpful comments from Patrick Gerland
</p>


<h3>References</h3>

<p>H. Sevcikova, A. E. Raftery (2016). bayesPop: Probabilistic
Population Projections. Journal of Statistical Software, 75(5), 1-29.
doi:10.18637/jss.v075.i05
</p>
<p>A. E. Raftery,  N. Li, H. Sevcikova , P. Gerland, G. K. Heilig (2012). Bayesian probabilistic population projections for all countries. Proceedings of the National Academy of Sciences 109:13915-13921.
</p>
<p>P. Gerland, A. E. Raftery, H. Sevcikova, N. Li, D. Gu, T. Spoorenberg, L. Alkema, B. K. Fosdick, J. L. Chunn, N. Lalic, G. Bay, T. Buettner, G. K. Heilig,  J. Wilmoth (2014). World Population Stabilization Unlikely This Century. Science 346:234-237.
</p>
<p>H. Sevcikova, N. Li, V. Kantorova, P. Gerland and A. E. Raftery (2015). Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. arXiv:1503.05215. <a href="https://arxiv.org/abs/1503.05215">https://arxiv.org/abs/1503.05215</a>

</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.trajectories.plot">pop.trajectories.plot</a></code>, <code><a href="#topic+pop.pyramid">pop.pyramid</a></code>, <code><a href="#topic+pop.trajectories">pop.trajectories</a></code>, <code><a href="#topic+get.pop.prediction">get.pop.prediction</a></code>, <code><a href="#topic+age.specific.migration">age.specific.migration</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
# Countries can be given as a combination of numerical codes and names
pred &lt;- pop.predict(countries=c("Netherlands", 218, "Madagascar"), nr.traj=3, 
           output.dir=sim.dir)
pop.trajectories.plot(pred, "Ecuador", sum.over.ages=TRUE)
unlink(sim.dir, recursive=TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='pop.predict.subnat'>
Subnational Probabilistic Population Projection
</h2><span id='topic+pop.predict.subnat'></span>

<h3>Description</h3>

<p>Generates trajectories of probabilistic population projection for subregions of a given country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.predict.subnat(end.year = 2060, start.year = 1950, present.year = 2020, 
        wpp.year = 2019, output.dir = file.path(getwd(), "bayesPop.output"), 
        locations = NULL, default.country = NULL, annual = FALSE,
        inputs = list(
            popM = NULL, popF = NULL, 
            mxM = NULL, mxF = NULL, srb = NULL, 
            pasfr = NULL, patterns = NULL, 
            migM = NULL, migF = NULL, 
            migMt = NULL, migFt = NULL, mig = NULL,
            e0F.file = NULL, e0M.file = NULL, tfr.file = NULL, 
            e0F.sim.dir = NULL, e0M.sim.dir = NULL, tfr.sim.dir = NULL, 
            migMtraj = NULL, migFtraj = NULL, migtraj = NULL,
            GQpopM = NULL, GQpopF = NULL, average.annual = NULL
        ), 
        nr.traj = 1000, keep.vital.events = FALSE, 
        fixed.mx = FALSE, fixed.pasfr = FALSE, lc.for.all = TRUE,
         mig.is.rate = FALSE, replace.output = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.predict.subnat_+3A_end.year">end.year</code></td>
<td>
<p>End year of the projection.</p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_start.year">start.year</code></td>
<td>
<p>First year of the historical data on mortality rates. It determines the length of the historical time series used in the Lee-Carter estimation.</p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_present.year">present.year</code></td>
<td>
<p>Year for which initial population data is to be used.</p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_wpp.year">wpp.year</code></td>
<td>
<p>Year for which WPP data is used. The function loads a package called <span class="pkg">wpp</span><code class="reqn">x</code> where <code class="reqn">x</code> is the <code>wpp.year</code> and uses its data (corresponding to the <code>default.country</code>) as default datasets if region-specific alternatives are not given (see more details below).</p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_output.dir">output.dir</code></td>
<td>
<p>Output directory of the projection.</p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_locations">locations</code></td>
<td>
<p>Name of a tab-delimited file that contains definitions of the subregions. It has a similar structure as <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code>, with mandatory columns <code>reg_code</code> (unique identifier of the subregions) and <code>name</code> (name of the subregions). Optionally, <code>location_type</code> should be set to 4 for subregions to be processed. Column <code>country_code</code> can be included with the numerical code of the corresponding country. A row with <code>location_type</code> of 0 determines the country that the subregions belong to and is used for extracting default &quot;national&quot; datasets if the argument <code>default.country</code> is missing. In such a case, the code of the default country is taken from its column <code>country_code</code>. This is a mandatory argument. </p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_default.country">default.country</code></td>
<td>
<p>Numerical code of a country to which the subregions belong to. It is used for extracting default datasets from the  <span class="pkg">wpp</span> package if some region-specific input datasets are missing. Alternatively, it can be also included in the <code>locations</code> file, see above. In either case, the code must exists in the <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> dataset.</p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_annual">annual</code></td>
<td>
<p>Logical. If <code>TRUE</code> it is assumed that this is 1x1 simulation, i.e. one year age groups and one year time periods.</p>
</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_inputs">inputs</code></td>
<td>
<p>A list of file names where input data is stored. Unless otherwise noted, these are tab delimited ASCII files with a mandatory column <code>reg_code</code> giving the numerical identifier of the subregions. If an element of this list is <code>NULL</code>, usually a default dataset corresponding to <code>default.country</code> is extracted from the <span class="pkg">wpp</span> package. Names of these default datasets are shown in brackets. This list contains the following elements:
</p>

<dl>
<dt>popM, popF</dt><dd><p>Initial male/female age-specific population (at time <code>present.year</code>). Mandatory items, no defaults. Must contain columns <code>reg_code</code> and <code>age</code> and be of the same structure as <code><a href="wpp2019.html#topic+popM">popM</a></code> from <span class="pkg">wpp</span>.</p>
</dd>
<dt>mxM, mxF</dt><dd><p>Historical data and (optionally) projections of male/female age-specific death rates [<code><a href="wpp2019.html#topic+mxM">mxM</a></code>, <code><a href="wpp2019.html#topic+mxF">mxF</a></code>] (see also argument <code>fixed.mx</code>).</p>
</dd>
<dt>srb</dt><dd><p>Projection of sex ratio at birth. [<code><a href="wpp2019.html#topic+sexRatio">sexRatio</a></code>]</p>
</dd>
<dt>pasfr</dt><dd><p>Historical data and (optionally) projections of percentage age-specific fertility rate [<code><a href="wpp2019.html#topic+percentASFR">percentASFR</a></code>] (see also argument <code>fixed.pasfr</code>).</p>
</dd>
<dt>patterns</dt><dd><p>Information on region's specifics regarding migration type, base year of the migration, mortality and fertility age patterns as defined in [<code><a href="#topic+vwBaseYear">vwBaseYear</a></code>]. In addition, it can contain columns defining migration shares between the subregions, see Details below.</p>
</dd>
<dt>migM, migF, migMt, migFt, mig</dt><dd><p>Projection and (optionally) historical data of net migration on the same scale as the initital population. There are three ways of defining this quantity, here in order of priority: 1. via <code>migM</code> and <code>migF</code> which should give male and female age-specific migration [<code><a href="wpp2012.html#topic+migrationM">migrationM</a></code>, <code><a href="wpp2012.html#topic+migrationF">migrationF</a></code>]; 2. via <code>migMt</code> and <code>migFt</code> which should give male and female total net migration; 3. via <code>mig</code> which should give the total net migration. For 2. and 3., the totals are disagregated into age-specific migration by applying a Rogers-Castro schedule. For 3., the totals are equally split between sexes. If all of these input items are missing, the migration schedules are constructed from total migration counts of the <code>default.country</code> derived from <code><a href="wpp2019.html#topic+migration">migration</a></code> using Rogers Castro for age distribution. Migration shares between subregions (including sex-specific shares) can be given in the <code>patterns</code> file, see above and Details below. If no shares are given, it is distributed by population shares.</p>
</dd>
<dt>e0F.file</dt><dd><p>Comma-delimited CSV file with projected female life expectancy. It has the same structure as the file &ldquo;ascii_trajectories.csv&rdquo; generated using <code>bayesLife::<a href="bayesLife.html#topic+convert.e0.trajectories">convert.e0.trajectories</a></code> (which currently works for country-level results only). Required columns are &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo;, and &ldquo;e0&rdquo;. If <code>e0F.file</code> is <code>NULL</code>, data from the corresponding <span class="pkg">wpp</span> package (for <code>default.country</code>) is taken, namely the median projections as one trajectory and the low and high variants (if available) as second and third trajectory. Alternatively, this element can be the keyword &ldquo;median_&rdquo; in which case only the median is taken.</p>
</dd>
<dt>e0M.file</dt><dd><p>Comma-delimited CSV file containing projections of male life expectancy of the same format as <code>e0F.file</code>. As in the female case, if <code>e0M.file</code> is <code>NULL</code>, data for <code>default.country</code> from the corresponding <span class="pkg">wpp</span> package is taken.</p>
</dd>
<dt>tfr.file</dt><dd><p>Comma-delimited CSV file with results of total fertility rate (generated using <span class="pkg"><a href="bayesTFR.html#topic+bayesTFR">bayesTFR</a></span>, function <code><a href="bayesTFR.html#topic+convert.tfr.trajectories">convert.tfr.trajectories</a></code>, file &ldquo;ascii_trajectories.csv&rdquo;). Required columns are &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo;, and &ldquo;TF&rdquo;. If this element is not <code>NULL</code>, the argument <code>tfr.sim.dir</code> is ignored. If both <code>tfr.file</code> and <code>tfr.sim.dir</code> are <code>NULL</code>, data for <code>default.country</code> from the corresponding <span class="pkg">wpp</span> package is taken (median and the low and high variants as three trajectories). Alternatively, this argument can be the keyword &ldquo;median_&rdquo; in which case only the wpp median is taken.</p>
</dd>
<dt>e0F.sim.dir</dt><dd><p>Simulation directory with results of female life expectancy, generated using <code>bayesLife::<a href="bayesLife.html#topic+e0.predict.subnat">e0.predict.subnat</a></code>. It is only used if <code>e0F.file</code> is <code>NULL</code>. Alternatively, it can be set to the keyword &ldquo;median_&rdquo; which has the same effect as when <code>e0F.file</code> is &ldquo;median_&rdquo;.</p>
</dd>
<dt>e0M.sim.dir</dt><dd><p>This is analogous to <code>e0F.sim.dir</code>, here for male life expectancy. Use <code>e0M.file</code> instead of this item.</p>
</dd>
<dt>tfr.sim.dir</dt><dd><p>Simulation directory with projections of total fertility rate (generated using <code>bayesTFR::<a href="bayesTFR.html#topic+tfr.predict.subnat">tfr.predict.subnat</a></code>). It is only used if <code>tfr.file</code> is <code>NULL</code>.</p>
</dd>
<dt>migMtraj, migFtraj, migtraj</dt><dd><p>Comma-delimited CSV file with male/female age-specific migration trajectories, or total migration trajectories (<code>migtraj</code>). If present, it replaces deterministic projections given by the <code>mig*</code> items. It has a similar format as e.g. <code>e0M.file</code> with columns &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo;, &ldquo;Age&rdquo; (except for <code>migtraj</code>) and &ldquo;Migration&rdquo;. For a five-year simulation, the &ldquo;Age&rdquo; column must have values &ldquo;0-4&rdquo;, &ldquo;5-9&rdquo;, &ldquo;10-14&rdquo;, ..., &ldquo;95-99&rdquo;, &ldquo;100+&rdquo;. In an annual simulation, age is given by a single number between 0 and 100.</p>
</dd>
<dt>GQpopM, GQpopF</dt><dd><p>Age-specific population counts (male and female) that should be excluded from application of the cohort-component method (CCM). It can be used for defining group quarters. These counts are removed from population before the CCM projection and added back afterwards. It is not used when computing vital events on observed data. The datasets should have columns &ldquo;reg_code&rdquo;, &ldquo;age&rdquo; and &ldquo;gq&rdquo;. For a five-year simulation, the &ldquo;age&rdquo; column should include values &ldquo;0-4&rdquo;, &ldquo;5-9&rdquo;, &ldquo;10-14&rdquo;, ..., &ldquo;95-99&rdquo;, &ldquo;100+&rdquo;. However, rows with zeros do not need to be included. In an annual simulation, age is given by a single number between 0 and 100.</p>
</dd>
<dt>average.annual</dt><dd><p>Character string with values &ldquo;TFR&rdquo;, &ldquo;e0M&rdquo;, &ldquo;e0F&rdquo;. If this is a 5-year simulation, but the inputs of TFR or/and e0 comes from an annual simulation, including the corresponding string here will cause that the TFR or/and e0 trajectories are converted into 5-year averages.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="pop.predict.subnat_+3A_nr.traj">nr.traj</code>, <code id="pop.predict.subnat_+3A_keep.vital.events">keep.vital.events</code>, <code id="pop.predict.subnat_+3A_fixed.mx">fixed.mx</code>, <code id="pop.predict.subnat_+3A_fixed.pasfr">fixed.pasfr</code>, <code id="pop.predict.subnat_+3A_lc.for.all">lc.for.all</code>, <code id="pop.predict.subnat_+3A_mig.is.rate">mig.is.rate</code>, <code id="pop.predict.subnat_+3A_replace.output">replace.output</code>, <code id="pop.predict.subnat_+3A_verbose">verbose</code></td>
<td>
<p>These arguments have the same meaning as in <code><a href="#topic+pop.predict">pop.predict</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Population projection for subnational units (regions) is performed by applying the cohort component method to subnational datasets on projected fertility (TFR), mortality and net migration, starting from given sex- and age-specific population counts. The only required inputs are the initial sex- and age-specific population counts in each region (<code>popM</code> and <code>popF</code> elements of the <code>inputs</code> argument) and a file with a set of locations (argument <code>locations</code>). If no other input datasets are given, those datasets are replaced by the corresponding &quot;national&quot; values, taken from the corresponding <span class="pkg">wpp</span> package. The argument <code>default.country</code> determines the country for those default &quot;national&quot; values. The default country can be also included in the <code>locations</code> file as a record with <code>location.type</code> being set to 0.
</p>
<p>The TFR component can be given as a set of trajectories generated using the <code><a href="bayesTFR.html#topic+tfr.predict.subnat">tfr.predict.subnat</a></code> function of the <span class="pkg">bayesTFR</span> package (<code>tfr.sim.dir</code> element). Alternatively, trajectories can be given in an ASCII file (<code>tfr.file</code>). 
</p>
<p>Similarly, the $e_0$ component can be given as a set of trajectories using the <code><a href="bayesLife.html#topic+e0.predict.subnat">e0.predict.subnat</a></code> function of the <span class="pkg">bayesLife</span> package (<code>e0F.sim.dir</code> element). If male projections are generated jointly (i.e. <code>predict.jmale = TRUE</code>), set <code>e0M.sim.dir = "joint_"</code>. Alternatively, trajectories can be given in an ASCII files (<code>e0F.file</code>, <code>e0M.file</code>).
</p>
<p>Having a set of subnational TFR and $e_0$ trajectories, the cohort component method is applied to each of them to yield a distribution of future subnational population.
</p>
<p>Projection of net migration can either be given as disaggregated sex- and age-specific datasets (<code>migM</code> and <code>migF</code>), or as sex totals (<code>migMt</code> and <code>migFt</code>), or as totals (<code>mig</code>), or as sex- and age-specific trajectories (<code>migMtraj</code> and <code>migFtraj</code>), or as total trajectories (<code>migtraj</code>). Alternatively, it can be given as shares between regions as columns in the <code>patterns</code> dataset. These are: <code>inmigrationM_share</code>, <code>inmigrationF_share</code>, <code>outmigrationM_share</code>, <code>outmigrationF_share</code>. The sex specification and/or direction specification (in/out) can be omitted, e.g. it can be simply <code>migration_share</code>. The function extracts the values of net migration projection on the national level and distributes it to regions according to the given shares. For positive (national) values, it uses the in-migration shares; for negative values it uses the out-migration shares. If the in/out prefix is omitted in the column names, the given migartion shares are used for both, positive and negative net migration projection. By default, if no migration datasets neither region-specific shares are given, the distribution between regions is proportional to the size of population. The age-specific schedules follow by default the Rogers-Castro age schedules. Note that when handling migration using shares as described here, it only affects the distribution of international migration into regions. It does not take into account between-region migration.
</p>
<p>The package contains example datasets for Canada. Use these as templates for your own data. See Example below.
</p>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code> containing the subnational projections. Note that this object can be used in the various <span class="pkg">bayesPop</span> functions exactly the same way as an object with national projections. However, the meaning of the argument <code>country</code> in many of these functions (e.g. in <code><a href="#topic+pop.trajectories.plot">pop.trajectories.plot</a></code>) changes to an identification of the region (either as a numerical code or name as defined in the <code>locations</code> file).
</p>


<h3>Acknowledgment</h3>

<p>We are greatful to Patrice Dion from Statistics Canada for providing us with example data. Note that the example datasets included in the package are not official STATCAN data - they only serve the purpose of illustration and templates. Data for the time period 2015-2020 has been imputed by the author.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.predict">pop.predict</a></code>, <code><a href="bayesTFR.html#topic+tfr.predict.subnat">tfr.predict.subnat</a></code>, <code><a href="#topic+pop.aggregate.subnat">pop.aggregate.subnat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Subnational projections for Canada
#########
data.dir &lt;- file.path(find.package("bayesPop"), "extdata")

# Use national data for tfr and e0
###
sim.dir &lt;- tempfile()
pred &lt;- pop.predict.subnat(output.dir = sim.dir,
            locations = file.path(data.dir, "CANlocations.txt"),
            inputs = list(popM = file.path(data.dir, "CANpopM.txt"),
                          popF = file.path(data.dir, "CANpopF.txt"),
                          tfr.file = "median_"
                        ),
            verbose = TRUE)
pop.trajectories.plot(pred, "Alberta", sum.over.ages = TRUE)
unlink(sim.dir, recursive=TRUE)

# Use subnational probabilistic TFR simulation
###
# Subnational TFR projections for Canada (from ?tfr.predict.subnat)
my.subtfr.file &lt;- file.path(find.package("bayesTFR"), 'extdata', 'subnational_tfr_template.txt')
tfr.nat.dir &lt;- file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output")
tfr.reg.dir &lt;- tempfile()
tfr.preds &lt;- tfr.predict.subnat(124, my.tfr.file = my.subtfr.file,
    sim.dir = tfr.nat.dir, output.dir = tfr.reg.dir, start.year = 2013)
 
# Use subnational probabilistic e0
### 
# Subnational e0 projections for Canada (from ?e0.predict.subnat)
# (here using the same female and male data, just for illustration)
my.sube0.file &lt;- file.path(find.package("bayesLife"), 'extdata', 'subnational_e0_template.txt')
e0.nat.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
e0.reg.dir &lt;- tempfile()
e0.preds &lt;- e0.predict.subnat(124, my.e0.file = my.sube0.file,
    sim.dir = e0.nat.dir, output.dir = e0.reg.dir, start.year = 2018,
    predict.jmale = TRUE, my.e0M.file = my.sube0.file)
 
# Population projections
sim.dir &lt;- tempfile()
pred &lt;- pop.predict.subnat(output.dir = sim.dir,
            locations = file.path(data.dir, "CANlocations.txt"),
            inputs = list(popM = file.path(data.dir, "CANpopM.txt"),
                          popF = file.path(data.dir, "CANpopF.txt"),
                          patterns = file.path(data.dir, "CANpatterns.txt"),
                          tfr.sim.dir = file.path(tfr.reg.dir, "subnat", "c124"),
                          e0F.sim.dir = file.path(e0.reg.dir, "subnat_ar1", "c124"),
                          e0M.sim.dir = "joint_"
                        ),
            verbose = TRUE)
pop.trajectories.plot(pred, "Alberta", sum.over.ages = TRUE)
pop.pyramid(pred, "Manitoba", year = 2050)
get.countries.table(pred)

# Aggregate to country level
aggr &lt;- pop.aggregate.subnat(pred, regions = 124, 
            locations = file.path(data.dir, "CANlocations.txt"))
pop.trajectories.plot(aggr, "Canada", sum.over.ages = TRUE)

unlink(sim.dir, recursive = TRUE)
unlink(tfr.reg.dir, recursive = TRUE)
unlink(e0.reg.dir, recursive = TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='pop.pyramid'>
Probabilistic Population Pyramid
</h2><span id='topic+pop.pyramid'></span><span id='topic+pop.pyramidAll'></span><span id='topic+pop.pyramid.bayesPop.prediction'></span><span id='topic+pop.pyramid.bayesPop.pyramid'></span><span id='topic+pop.trajectories.pyramid'></span><span id='topic+pop.trajectories.pyramidAll'></span><span id='topic+pop.trajectories.pyramid.bayesPop.prediction'></span><span id='topic+pop.trajectories.pyramid.bayesPop.pyramid'></span><span id='topic+plot.bayesPop.pyramid'></span><span id='topic+bayesPop.pyramid'></span><span id='topic+get.bPop.pyramid'></span><span id='topic+get.bPop.pyramid.bayesPop.prediction'></span><span id='topic+get.bPop.pyramid.data.frame'></span><span id='topic+get.bPop.pyramid.matrix'></span><span id='topic+get.bPop.pyramid.list'></span>

<h3>Description</h3>

<p>Functions for plotting probabilistic population pyramid. <code>pop.pyramid</code> creates a classic pyramid using rectangles; <code>pop.trajectories.pyramid</code> creates one or more pyramids using vertical lines (possibly derived from population trajectories). They can be used to view a prediction object created with this package, or any user-defined sex- and age-specific dataset. For the latter, function <code>get.bPop.pyramid</code> should be used to translate user-defined data into a <code>bayesPop.pyramid</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesPop.prediction'
pop.pyramid(pop.object, country, year = NULL, 
    indicator = c("P", "B", "D"), pi = c(80, 95), 
    proportion = FALSE, age = NULL, plot = TRUE, pop.max = NULL, ...)
    
## S3 method for class 'bayesPop.pyramid'
pop.pyramid(pop.object, main = NULL, show.legend = TRUE, 
    pyr1.par = list(border="black", col=NA, density=NULL, height=0.9),
    pyr2.par = list(density = -1, height = 0.3), 
    show.birth.year = FALSE,
    col.pi = NULL, ann = par("ann"), axes = TRUE, grid = TRUE, 
    cex.main = 0.9, cex.sub = 0.9, cex = 0.8, cex.axis = 0.8, ...)
    
pop.pyramidAll(pop.pred, year = NULL,
    output.dir = file.path(getwd(), "pop.pyramid"),
    output.type = "png", one.file = FALSE, verbose = FALSE, ...)
	
## S3 method for class 'bayesPop.prediction'
pop.trajectories.pyramid(pop.object, country, year = NULL, 
    indicator = c("P", "B", "D"), pi = c(80, 95), nr.traj = NULL, 
    proportion = FALSE, age = NULL, plot = TRUE, pop.max = NULL, ...)
    
## S3 method for class 'bayesPop.pyramid'
pop.trajectories.pyramid(pop.object, main = NULL, show.legend = TRUE, 
    show.birth.year = FALSE, col = rainbow, col.traj = "#00000020", 
    omit.page.pars = FALSE, lwd = 2, ann = par("ann"), axes = TRUE, grid = TRUE, 
    cex.main = 0.9, cex.sub = 0.9, cex = 0.8, cex.axis = 0.8, ...)
    
pop.trajectories.pyramidAll(pop.pred, year = NULL,
    output.dir = file.path(getwd(), "pop.traj.pyramid"),
    output.type = "png", one.file = FALSE, verbose = FALSE, ...)
	
## S3 method for class 'bayesPop.pyramid'
plot(x, ...)

## S3 method for class 'bayesPop.prediction'
get.bPop.pyramid(data, country, year = NULL, 
    indicator = c("P", "B", "D"), pi = c(80, 95), 
    proportion = FALSE, age = NULL, nr.traj = 0, sort.pi=TRUE, pop.max = NULL, ...)
    
## S3 method for class 'data.frame'
get.bPop.pyramid(data, main.label = NULL, legend = "observed", 
    is.proportion = FALSE, ages = NULL, pop.max = NULL, 
    LRmain = c("Male", "Female"), LRcolnames = c("male", "female"), CI = NULL, ...)
    
## S3 method for class 'matrix'
get.bPop.pyramid(data, ...)

## S3 method for class 'list'
get.bPop.pyramid(data, main.label = NULL, legend = NULL, CI = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.pyramid_+3A_pop.object">pop.object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code> or <code>bayesPop.pyramid</code> (see Value section).</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_pop.pred">pop.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_x">x</code></td>
<td>
<p>Object of class <code>bayesPop.pyramid</code>.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_data">data</code></td>
<td>
<p>Data frame, matrix, list or object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>. For data frame and matrix, it must have columns defined by <code>LRcolnames</code> (&ldquo;male&rdquo; and &ldquo;female&rdquo; by default). The row names will determine the age labels. For lists, it can be a collection of such data frames. The names of the list elements are used for legend, unless <code>legend</code> is given.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_year">year</code></td>
<td>
<p>Year within the projection or estimation period to be plotted. Default is the start year of the prediction. It can also be a vector of years. <code>pop.pyramid</code> draws the first two, <code>pop.trajectories.pyramid</code> draws all of them.
In the functions <code>pop.pyramidAll</code> and <code>pop.trajectories.pyramidAll</code>, the <code>year</code> argument can be a list of years, in which case the pyramids are created for all elements in the list.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_indicator">indicator</code></td>
<td>
<p>One of the characters &ldquo;P&rdquo; (population), &ldquo;B&rdquo; (births), &ldquo;D&rdquo; (deaths) determining the pyramid indicator.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_proportion">proportion</code></td>
<td>
<p>Logical. If <code>TRUE</code> the pyramid contains the distribution of rates of age-specific counts and population totals.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_age">age</code></td>
<td>
<p>Integer vector of age indices. In a 5-year simulation, value 1 corresponds to age 0-4, value 2 corresponds to age 5-9 etc. In a 1x1 simulation, values 1, 2, 3 correpond to ages 0, 1, 2. Last available age goup is 130+ which corresponds to index 27 in a 5-year simulation and index 131 in an annual simulation. The purpose of this argument here is mainly to control the height of the pyramid.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, nothing is plotted. It can be used to retrieve the pyramid object without drawing it.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_main">main</code></td>
<td>
<p>Titel of the plot. By default it is the country name and projection year if known.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling if the plot legend is drawn.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_pyr1.par">pyr1.par</code>, <code id="pop.pyramid_+3A_pyr2.par">pyr2.par</code></td>
<td>
<p>List of graphical parameters (color, border, density and height) for drawing the pyramid rectangles, for the first and second pyramid, respectively (see Details). The <code>height</code> component should be a number between 0 (corresponds to a line) and 1 (for non-overelapping rectangles). If <code>density</code> is <code>NULL</code>, the rectangles are transparent, see the argument <code>density</code> in <code><a href="graphics.html#topic+rect">rect</a></code>.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_show.birth.year">show.birth.year</code></td>
<td>
<p>Logical. If <code>TRUE</code> the corresponding birth years are shown on the right vertical axis.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_col.pi">col.pi</code></td>
<td>
<p>Vector of colors for drawing the probability boxes. If it is given, it must be of the same length as <code>pi</code>.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_ann">ann</code></td>
<td>
<p>Logical controlling if any annotation (main and legend) is plotted.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_axes">axes</code></td>
<td>
<p>Logical controlling if axes are plotted.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_grid">grid</code></td>
<td>
<p>Logical controlling if grid lines are plotted.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_cex.main">cex.main</code>, <code id="pop.pyramid_+3A_cex.sub">cex.sub</code>, <code id="pop.pyramid_+3A_cex">cex</code>, <code id="pop.pyramid_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Magnification to be used for the title, secondary titles on the right and left panels, legend and axes, respectively.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_one.file">one.file</code></td>
<td>
<p>Logical. If <code>TRUE</code> the output is put into one single file, by default a PDF.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be plotted. If <code>NULL</code>, all trajectories are plotted, otherwise they are thinned evenly.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_col">col</code></td>
<td>
<p>Colors generating function. It is called with an argument giving the number of pyramids to be plotted. Each color is then used for one pyramid, including its confidence intervals.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_col.traj">col.traj</code></td>
<td>
<p>Color used for trajectories. If more than one pyramid is drawn with its trajectories, this can be a vector of the size of number of pyramids.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_omit.page.pars">omit.page.pars</code></td>
<td>
<p>Logical. If <code>TRUE</code>, no page parameters are set. Can be used if multiple pyramids are to be put on one page.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_lwd">lwd</code></td>
<td>
<p>Line width for the pyramids.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_sort.pi">sort.pi</code></td>
<td>
<p>Logical controlling if the probability intervals are sorted in decreasing order. This has an effect on the order in which they are plotted and thus on overlapping of pyramid boxes. By default the largest intervals are plotted first.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_main.label">main.label</code></td>
<td>
<p>Optional argument for the main title.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_legend">legend</code></td>
<td>
<p>Legend to be used. In case of multiple pyramids, this can be a vector for each of them. If not given and <code>data</code> is a list, names of the list elements are taken as legend.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_is.proportion">is.proportion</code></td>
<td>
<p>Either logical, indicating if the values in <code>data</code> are proportions, or <code>NA</code> in which case the proportions are computed.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_ages">ages</code></td>
<td>
<p>Vector of age labels. It must be of the same length as the number of rows of <code>data</code>. If it is not given, the age labels are considered to be the row names of <code>data</code>.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_pop.max">pop.max</code></td>
<td>
<p>Maximum value to be drawn in the pyramid. If it is not given, <code>max(data)</code> is taken.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_lrmain">LRmain</code></td>
<td>
<p>Vector of character strings giving the secondary titles for the left and right panel, respectively.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_lrcolnames">LRcolnames</code></td>
<td>
<p>Vector of character strings giving the column names of data to be used for the left and right panel of the pyramid, respectively.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_ci">CI</code></td>
<td>
<p>Confidence intervals. It should be of the same format as the <code>bayesPop.pyramid$CI</code> object, see below.</p>
</td></tr>
<tr><td><code id="pop.pyramid_+3A_...">...</code></td>
<td>
<p>Arguments passed to the underlying functions. For <code>get.bPop.pyramid</code>, these can be additional items to be added to the resulting object, e.g. <code>pyr.year</code> and <code>is.annual</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pop.pyramid</code> function generates one or two population pyramids in one plot. The first (main) one is usually the median of a future year prediction, but it can also be the current year or any population estimates. The second one serves the purpose of comparing two pyramids with one another and is drawn on top of the main pyramid. For example, one can use it to compare a future prediction with the present, or two different time points in the past, or two different geographies. The main pyramid can have confidence intervals associated with it, which are also plotted. If <code>pop.pyramid</code> is called on a <code>bayesPop.prediction</code> object, the main and secondary pyramid, respectively, is generated from data of a time period given by the first and second element, respectively, of the <code>year</code> argument. In such a case, confidence intervals only of the first year are shown. Thus, it makes sense to set the first year to be a prediction year and the second year to an observed time period. If <code>pop.pyramid</code> is called on a <code>bayesPop.pyramid</code> object, data in the first and second element, respectively, of the <code>bayesPop.pyramid$pyramid</code> list are used, and only the first element of <code>bayesPop.pyramid$CI</code> is used.
</p>
<p>Pyramids generated via the <code>pop.trajectories.pyramid</code> function have different appearance and therefore more than two pyramids can be put into one figure. Furthermore, confidence intervals of more than one pyramid can be shown. Thus, all elements of <code>bayesPop.pyramid$pyramid</code> and <code>bayesPop.pyramid$CI</code> are plotted. In addition, single trajectories given in <code>bayesPop.pyramid$trajectories</code> can be shown by setting the argument <code>nr.traj</code> larger than 0. 
</p>
<p>Both, <code>pop.pyramid</code> and <code>pop.trajectories.pyramid</code> (if called with a <code>bayesPop.prediction</code> object) use data from one country. 
Functions <code>pop.pyramidAll</code> and <code>pop.trajectories.pyramidAll</code> create such pyramids for all countries for which a projection is available and for all years given by the <code>year</code> argument which should be a list. In this case, one pyramid figure (possibly containing multiple pyramids) is created for each country and each element of the <code>year</code> list.
</p>
<p>The core of these functions operates on a <code>bayesPop.pyramid</code> object which is automatically created when called with a <code>bayesPop.prediction</code> object. If used with a user-defined data set, one has to convert such data into <code>bayesPop.pyramid</code> using the function <code>get.bPop.pyramid</code> (see an example below). In such a case, one can simply use the <code>plot</code> function which then calls <code>pop.pyramid</code>.
</p>


<h3>Value</h3>

<p><code>pop.pyramid</code>, <code>pop.trajectories.pyramid</code> and <code>get.bPop.pyramid</code> return an object of class <code>bayesPop.pyramid</code> which is a list with the following components:
</p>
<table>
<tr><td><code>label</code></td>
<td>
<p>Label used for the main titel.</p>
</td></tr>
<tr><td><code>pyramid</code></td>
<td>
<p>List of pyramid data, one element per pyramid. Each component is a data frame with at least two columns, containing data for the left and right panels of the pyramid. Their names must correspond to <code>LRcolnames</code> (see below). There is one row per age group and the row names are used for labeling the y-axis. Names of the list elements are used in the legend.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>List of lists of confidence intervals with one element per pyramid. The order corresponds to the order in the <code>pyramid</code> component and it is <code>NULL</code> if the corresponding pyramid does not have confidence intervals. Each element is a list with one element per probability interval whose names are the values of the intervals. Each element is again a list with components <code>low</code> and <code>high</code> which have the same structure as <code>pyramid</code> and contain the lower and upper bounds of the corresponding interval.</p>
</td></tr>
<tr><td><code>trajectories</code></td>
<td>
<p>List of lists of trajectories with one element per pyramid. As in the case of <code>CI</code>, it is ordered the same way as the <code>pyramid</code> component and is <code>NULL</code> if the corresponding pyramid does not have any trajectories to be shown. Each element is again a list with two components, one for the left part and one for the right part of the pyramid. Their names correspond to <code>LRcolnames</code> and each of them is a matrix of size number of age categories x number of trajectories. This is only used by the <code>pop.trajectories.pyramid</code> function.</p>
</td></tr>
<tr><td><code>is.proportion</code></td>
<td>
<p>Logical indicating if values in the various data frames in this object are proportions or raw values.</p>
</td></tr>
<tr><td><code>is.annual</code></td>
<td>
<p>Logical indicating if the data correspond to 1-year age groups. If <code>FALSE</code>, the ages are considered to be 5-year age groups.</p>
</td></tr>
<tr><td><code>pyr.year</code></td>
<td>
<p>Year of the main pyramid. It is used as the base year when <code>show.birth.year</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>pop.max</code></td>
<td>
<p>Maximum value for the x-axis.</p>
</td></tr>
<tr><td><code>LRmain</code></td>
<td>
<p>Vector of character strings determining the titles for the left and right panels, respectively.</p>
</td></tr>
<tr><td><code>LRcolnames</code></td>
<td>
<p>Vector of character strings determining the column names in <code>pyramid</code>, <code>CI</code> and <code>trajectories</code> used to plot data into the left and right panel, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery, using feedback from Sam Clark and the bayesPop group at the University of Washington.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.trajectories.plot">pop.trajectories.plot</a></code>, <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>, <code><a href="#topic+summary.bayesPop.prediction">summary.bayesPop.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pyramids for bayesPop prediction objects
##########################################
sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir)
pop.pyramid(pred, "Netherlands", c(2045, 2010))
dev.new()
pop.trajectories.pyramid(pred, "NL", c(2045, 2010, 1960), age=1:25, proportion=TRUE)
# using manual manipulation of the data: e.g. show only the prob. intervals 
pred.pyr &lt;- get.bPop.pyramid(pred, country="Ecuador", year=2090, age=1:27)
pred.pyr$pyramid &lt;- NULL
plot(pred.pyr, show.birth.year = TRUE)

# pyramids for user-defined data
################################
# this example dataset contains population estimates for the Washington state and King county 
# (Seattle area) in 2011
data &lt;- read.table(file.path(find.package("bayesPop"), "ex-data", "popestimates_WAKing.txt"), 
    header=TRUE, row.names=1)
# extract data for two pyramids and put it into the right format
head(data)
WA &lt;- data[,c("WA.male", "WA.female")]; colnames(WA) &lt;- c("male", "female")
King &lt;- data[,c("King.male", "King.female")]; colnames(King) &lt;- c("male", "female")
# create and plot a bayesPop.pyramid object
pyramid &lt;- get.bPop.pyramid(list(WA, King), legend=c("Washington", "King"))
plot(pyramid, main="Population in 2011", pyr2.par=list(height=0.7, col="violet", border="violet"))
# show data as proportions and include birth year
pyramid.prop &lt;- get.bPop.pyramid(list(WA, King), is.proportion=NA, 
    legend=c("Washington", "King"), pyr.year = 2011)
pop.pyramid(pyramid.prop, main="Population in 2011 (proportions)",
    pyr1.par=list(col="lightgreen", border="lightgreen", density=2), 
    pyr2.par=list(col="darkred", border="darkred"),
    show.birth.year = TRUE)
</code></pre>

<hr>
<h2 id='pop.trajectories'>
Accessing Trajectories
</h2><span id='topic+get.pop'></span><span id='topic+get.pop.ex'></span><span id='topic+get.pop.exba'></span><span id='topic+pop.trajectories'></span><span id='topic+get.trajectory.indices'></span><span id='topic+extract.trajectories.eq'></span><span id='topic+extract.trajectories.ge'></span><span id='topic+extract.trajectories.le'></span>

<h3>Description</h3>

<p>Obtain projection trajectories of population and vital events/rates. <code>get.pop</code> allows to access trajectories using a basic component of an expression. <code>get.pop.ex</code> and <code>get.pop.exba</code> returns results of an expression defined &ldquo;by time&rdquo; and &ldquo;by age&rdquo;, respectively. <code>get.trajectory.indices</code> creates a link to the probabilistic components of the projection by providing indices to the trajectories of TFR, e0 and migration. <code>extract.trajectories.eq</code> returns trajectories (of population or expression) and their indices that are closest to given values or a quantile. Similarly, functions <code>extract.trajectories.ge</code> and <code>extract.trajectories.le</code> return trajectories and their indices that are greater equal and less equal, respectively, to the given values or a quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.trajectories(pop.pred, country, sex = c("both", "male", "female"), 
    age = "all", ...)

get.pop(object, pop.pred, aggregation = NULL, observed = FALSE, ...)

get.pop.ex(expression, pop.pred, observed = FALSE, as.dt = FALSE, ...)

get.pop.exba(expression, pop.pred, observed = FALSE, as.dt = FALSE, ...)

get.trajectory.indices(pop.pred, country, 
    what = c("TFR", "e0M", "e0F", "migM", "migF"))

extract.trajectories.eq(pop.pred, country = NULL, expression = NULL, 
    quant = 0.5, values = NULL, nr.traj = 1, ...)
    
extract.trajectories.ge(pop.pred, country = NULL, expression = NULL, 
    quant = 0.5, values = NULL, all = TRUE, ...)
    
extract.trajectories.le(pop.pred, country = NULL, expression = NULL, 
    quant = 0.5, values = NULL, all = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.trajectories_+3A_pop.pred">pop.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_sex">sex</code></td>
<td>
<p>One of &ldquo;both&rdquo;  (default), &ldquo;male&rdquo; or &ldquo;female&rdquo;. By default the male and female projections are summed up.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_age">age</code></td>
<td>
<p>Either a character string &ldquo;all&rdquo; (default) or an integer vector of age indices. In a 5x5 simulation, value 1 corresponds to age 0-4, value 2 corresponds to age 5-9 etc. Last age goup <code class="reqn">130+</code> corresponds to index 27. In a 1x1 simulation, value 1 corresponds to age 0, value 2 to age 1 etc, up to 131 corresponding to the last age group. Results is summed over the given age categories.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_object">object</code></td>
<td>
<p>Character string giving a basic component of an expression (see <a href="#topic+pop.expressions">pop.expressions</a>).</p>
</td></tr>  
<tr><td><code id="pop.trajectories_+3A_aggregation">aggregation</code></td>
<td>
<p>If the basic component is to be evaluated on an aggregated prediction object, this argument gives the name of the aggregation (corresponds argument <code>name</code> in <code><a href="#topic+pop.aggregate">pop.aggregate</a></code>). By default, the function searches for available aggregations and gives priority to the one called &ldquo;country&rdquo;.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_observed">observed</code></td>
<td>
<p>Logical. Determines if the evaluation uses observed data (<code>TRUE</code>) or predictions (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_expression">expression</code></td>
<td>
<p>Expression defining the trajectories measure. For syntax see <code><a href="#topic+pop.expressions">pop.expressions</a></code>. It must be define by age (i.e. contain curly braces) if used in <code>get.pop.exba</code>, and the opposite applies to <code>get.pop.ex</code>.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_as.dt">as.dt</code></td>
<td>
<p>Logical indicating if the result should be returned as a <code>data.table</code> object in long format. This can be useful especially if results for all countries are requested.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_what">what</code></td>
<td>
<p>A character string that defines to which component should the indices link to. Allowable options are &ldquo;TFR&rdquo;, &ldquo;e0M&rdquo; (male life expectancy), &ldquo;e0F&rdquo; (female life expectancy), &ldquo;migM&rdquo; (male migration), &ldquo;migF&rdquo; (female migration).</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_quant">quant</code></td>
<td>
<p>Quantile used to select the closest trajectories to.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_values">values</code></td>
<td>
<p>Vector of values used to select the closest trajectories to. If it is not of length 1, it has to be of the same length as the number of projected time periods. If it is not given, <code>quant</code> is used.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to return. This argument can be passed to any of the functions that contains ....</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_all">all</code></td>
<td>
<p>Logical indicating if the corresponding condition should apply to all time periods of a trajectory. If it is <code>FALSE</code>, a trajectory is extracted if the condition is fulfilled in at least one time period.</p>
</td></tr>
<tr><td><code id="pop.trajectories_+3A_...">...</code></td>
<td>
<p>Additional argument passed to the underlying functions. In case of <code>get.pop</code>, <code>get.pop.ex</code> and  <code>get.pop.exba</code>, this is only used for <code>observed=FALSE</code>. It can be either <code>nr.traj</code> giving the number of trajectories or logical <code>typical.trajectory</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>pop.trajectories</code> returns an array of population trajectories for given sex and age. 
</p>
<p>Function <code>get.pop</code> evaluates a basic component of an expression and results in a four-dimensional array. Internally, this function is used for evaluation after an expression is decomposed into basic components. It can be useful for example for debugging purposes, to obtain results from parts of an expression. In addition, while  <code>pop.trajectories</code> works only for population counts, <code>get.pop</code> can be used for obtaining trajectories of vital events and rates. Note that the wildcard &ldquo;XXX&rdquo; in the expression cannot be used in <code>get.pop</code>; use <code>get.pop.ex</code> or <code>get.pop.exba</code> instead.
</p>
<p>Functions <code>get.pop.ex</code> and <code>get.pop.exba</code> evaluate a whole expression and the dimensions of the resulting array is collapsed depending on the specific expression. Use <code>get.pop.ex</code> if the expected result of the expression does not contain the age dimension, i.e. it uses no brackets or square brackets. If it is not the case, i.e. the expression is defined using curly braces in order to include the age dimension, the  <code>get.pop.exba</code> function is to be used. Argument <code>nr.traj</code> can be used to restrict the number of trajectories returned. Use one of those functions if results for all countries (i.e. if using &ldquo;XXX&rdquo;) is desired. 
</p>
<p>Function <code>get.trajectory.indices</code> returns an array of indices that link back to the given probabilistic component. It is of the same length as number of trajectories in the prediction object. For example, an array of <code>c(10, 15, 20)</code> (for a prediction with three trajectories) obtained with <code>what="TFR"</code> means that the 1st, 2nd and 3rd population trajectory, respectively, were generated with the 10th, 15th and 20th TFR trajectory, respectively. If the input TFR and e0 were generated using <code><a href="bayesTFR.html#topic+bayesTFR-package">bayesTFR</a></code> and <code><a href="bayesLife.html#topic+bayesLife-package">bayesLife</a></code>, functions <code><a href="bayesTFR.html#topic+get.tfr.trajectories">get.tfr.trajectories</a></code> and <code><a href="bayesLife.html#topic+get.e0.trajectories">get.e0.trajectories</a></code> can be used to extract the corresponding TFR and e0 trajectories.
</p>
<p>Function <code>extract.trajectories.eq</code> can be used to select a given number of trajectories of any population quantity, including vital events, that are close to either specific values or to a given quantile. For example the default seting with <code>quant=0.5</code> and <code>nr.traj=1</code> returns the one trajectory that is &ldquo;closest&rdquo; to the median projection. As a measure of &ldquo;closeness&rdquo; the sum of absolute differences (across all time periods) is used. 
</p>
<p>Similarly, function <code>extract.trajectories.ge</code> (<code>extract.trajectories.le</code>) selects all trajectories that are greater (less) equal to the specific values or a given quantile. The argument <code>all</code> specifies, if the greater/less condition should be valid for all time periods of the selected trajectories or at least one time period. 
</p>


<h3>Value</h3>

<p>Function <code>pop.trajectories</code> returns a two-dimensional array (time x trajectory).
</p>
<p>Function <code>get.pop</code> returns an array of four dimensions (country x age x time x trajectory). See <a href="#topic+pop.expressions">pop.expressions</a> for more details.
</p>
<p>Functions <code>get.pop.ex</code> and <code>get.pop.exba</code> return an array of trajectories. Its dimensions depend on the expression and whether it is evaluated on observed data or projections. If <code>as.dt</code> is <code>TRUE</code> these functions return <code>data.table</code> objects in long format.
</p>
<p>Function <code>get.trajectory.indices</code> returns a 1-d array of indices. If the given component is deterministic, it returns <code>NULL</code>. 
</p>
<p>Functions <code>extract.trajectories.eq</code>, <code>extract.trajectories.ge</code>, <code>extract.trajectories.le</code> return a list with two components. <code>trajectories</code>: 2-d array of trajectories; <code>index</code>: indices of the selected trajectories relative to the whole set of available trajectories.  
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><a href="#topic+pop.expressions">pop.expressions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir, write.to.cache=FALSE)

# observed female of Netherlands by age; 1x21x15x1 array
popFNL &lt;- get.pop("PNL_F{}", pred, observed=TRUE)

# observed population for all countries in the prediction object,
# here 2 countries; 2x1x15x1 array
popAll &lt;- get.pop("PXXX", pred, observed=TRUE)

# future migration for all countries in the prediction object,
# here 2 countries; 2x17 array
migAll &lt;- get.pop.ex("GXXX", pred)

# projection population for Ecuador with 3 trajectories; 
# 1x1x17x3 array
popEcu &lt;- get.pop("P218", pred, observed=FALSE)

# the above is equivalent to 
popEcu2 &lt;- pop.trajectories(pred, "Ecuador")

# Expression "PNL_F{} / PNL_M{}" evaluated on projections
# is internally replaced by
FtoM &lt;- get.pop("PNL_F{}", pred) / get.pop("PNL_M{}", pred)
# should return the same result as
FtoMa &lt;- get.pop.exba("PNL_F{} / PNL_M{}", pred)

# the same expression by time (summed over ages) 
FtoMt &lt;- get.pop.ex("PNL_F / PNL_M", pred)

# the example simulation was generated with 3 TFR trajectories ...
get.trajectory.indices(pred, "Netherlands", what="TFR")
# ... and 1 e0 trajectory 
get.trajectory.indices(pred, "Netherlands", what="e0M")

# The three trajectories of the population ratio of Ecuador to Netherlands
get.pop.ex("PEC/PNL", pred)
# Returns the trajectory closest to the upper 80% bound, including the corresponding index
extract.trajectories.eq(pred, expression="PEC/PNL", quant=0.9)
# Returns the median trajectory and the high variant, including the corresponding index
extract.trajectories.ge(pred, expression="PEC/PNL", quant=0.45)
</code></pre>

<hr>
<h2 id='pop.trajectories.plot'>
Output of Probabilistic Population Projection
</h2><span id='topic+pop.trajectories.plot'></span><span id='topic+pop.trajectories.plotAll'></span><span id='topic+pop.trajectories.table'></span><span id='topic+pop.byage.plot'></span><span id='topic+pop.byage.plotAll'></span><span id='topic+pop.byage.table'></span>

<h3>Description</h3>

<p>The functions plot and tabulate the distribution of population projection for a given country, or for all countries, including the median and given probability intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.trajectories.plot(pop.pred, country = NULL, expression = NULL, pi = c(80, 95), 
    sex = c("both", "male", "female"), age = "all", sum.over.ages = TRUE, 
    half.child.variant = FALSE, nr.traj = NULL, typical.trajectory = FALSE,
    main = NULL, dev.ncol = 5, lwd = c(2, 2, 2, 2, 1), 
    col = c("black", "red", "red", "blue", "#00000020"), show.legend = TRUE, 
    ann = par("ann"), xshift = 0, ...)
    
pop.trajectories.plotAll(pop.pred, 
    output.dir=file.path(getwd(), "pop.trajectories"),
    output.type="png", expression = NULL, verbose=FALSE, ...)
    
pop.trajectories.table(pop.pred, country = NULL, expression = NULL, pi = c(80, 95), 
    sex = c("both", "male", "female"), age = "all", half.child.variant = FALSE,  
    xshift = 0, ...)
    
pop.byage.plot(pop.pred, country = NULL, year = NULL, expression = NULL, 
    pi = c(80, 95), sex = c("both", "male", "female"), 
    half.child.variant = FALSE, nr.traj = NULL, typical.trajectory=FALSE,
    xlim = NULL, ylim = NULL, xlab = "", ylab = "Population projection", 
    main = NULL, lwd = c(2,2,2,1), col = c("red", "red", "blue", "#00000020"),
    show.legend = TRUE, add = FALSE, ann = par("ann"), type = "l", pch = NA, 
    pt.cex = 1, ...)
    
pop.byage.plotAll(pop.pred, 
    output.dir=file.path(getwd(), "pop.byage"),
    output.type="png", expression = NULL, verbose=FALSE, ...)

pop.byage.table(pop.pred, country = NULL, year = NULL, expression = NULL, 
    pi = c(80, 95), sex = c("both", "male", "female"), 
    half.child.variant = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.trajectories.plot_+3A_pop.pred">pop.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_expression">expression</code></td>
<td>
<p>Expression defining the population measure to be plotted. For syntax see <code><a href="#topic+pop.expressions">pop.expressions</a></code>. For <code>pop.trajectories.plot</code>, <code>pop.trajectories.table</code>, <code>pop.byage.plot</code> and <code>pop.byage.table</code> the basic components of the expression must be country-specific. For <code>pop.trajectories.plotAll</code> and <code>pop.byage.plotAll</code> the country part should be given as &ldquo;XXX&rdquo;. In addition, expressions passed into <code>pop.byage.plot</code> and <code>pop.byage.table</code> must contain curly braces (i.e. be age specific).</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_sex">sex</code></td>
<td>
<p>One of &ldquo;both&rdquo;  (default), &ldquo;male&rdquo; or &ldquo;female&rdquo;. By default the male and female projections are summed up.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_age">age</code></td>
<td>
<p>Either a character string &ldquo;all&rdquo; (default) or an integer vector of age indices. In a five year simulation, value 1 corresponds to age 0-4, value 2 corresponds to age 5-9 etc. Last age goup <code class="reqn">130+</code> corresponds to index 27. In an annual simulation, the age indices 1, 2, 3, ..., 131 corrrespond to ages 0, 1, 2, ..., <code class="reqn">130+</code>.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_sum.over.ages">sum.over.ages</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the values are summed up over given age groups. Otherwise there is a separate plot for each age group.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_half.child.variant">half.child.variant</code></td>
<td>
<p>Logical. If TRUE the United Nations &ldquo;+/-0.5 child&rdquo; variant computed with fertility <code class="reqn">+/- 0.5*</code> TFR median and the median of life expectancy is shown.
</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be plotted. If <code>NULL</code>, all trajectories are plotted, otherwise they are thinned evenly.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_typical.trajectory">typical.trajectory</code></td>
<td>
<p>Logical. If <code>TRUE</code> one trajectory is shown that has the smallest distance to the median.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_xlim">xlim</code>, <code id="pop.trajectories.plot_+3A_ylim">ylim</code>, <code id="pop.trajectories.plot_+3A_xlab">xlab</code>, <code id="pop.trajectories.plot_+3A_ylab">ylab</code>, <code id="pop.trajectories.plot_+3A_main">main</code>, <code id="pop.trajectories.plot_+3A_ann">ann</code>, <code id="pop.trajectories.plot_+3A_pt.cex">pt.cex</code></td>
<td>
<p>Graphical parameters passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_xshift">xshift</code></td>
<td>
<p>Constant added to the x-axis (year).</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of column for the graphics device if <code>sum.over.ages</code> is <code>FALSE</code>. If the number of age groups is smaller than <code>dev.ncol</code>, the number of columns is automatically decreased.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_lwd">lwd</code>, <code id="pop.trajectories.plot_+3A_col">col</code></td>
<td>
<p>For the first three functions it is a vector of five elements giving the line width and color for: 1. observed data, 2. median, 3. quantiles, 4. half-child variant, 5. trajectories. For functions that show results by age it is a vector of four elements - as above without the first item (observed data).</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_type">type</code>, <code id="pop.trajectories.plot_+3A_pch">pch</code></td>
<td>
<p>Currently works for plotting by age only. It is a vector of four elements giving the plot type and point type for: 1. median, 2. quantiles, 3. half-child variant, 4. trajectories. The last element of the array is recycled.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling whether the legend should be drawn.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments. Functions <code>pop.trajectories.plotAll</code> and <code>pop.byage.plotAll</code> accept also any arguments of <code>pop.trajectories.plot</code> and <code>pop.byage.plot</code>, respectively, except <code>country</code>.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_year">year</code></td>
<td>
<p>Any year within the time period to be outputted.</p>
</td></tr>
<tr><td><code id="pop.trajectories.plot_+3A_add">add</code></td>
<td>
<p>Logical specifying if the plot should be added to an existing graphics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pop.trajectories.plot</code> plots trajectories of population projection by time for a given country. <br /> <code>pop.trajectories.table</code> gives the same output as a table. <code>pop.trajectories.plotAll</code> creates a set of graphs (one per country) that are stored in <code>output.dir</code>. The projections can be visualized separately for each sex and age groups, or summed up over both sexes and/or given age groups. This is controlled by the arguments <code>sex</code>, <code>age</code> and <code>sum.over.ages</code>.
</p>
<p><code>pop.byage.plot</code> and <code>pop.byage.table</code> plots/tabulate the posterior distribution by age for a given country and time period. <code>pop.byage.plotAll</code> creates such plots for all countries. 
</p>
<p>The median and given probability intervals are computed using all available trajectories. Thus, <code>nr.traj</code> does not influence those values - it is used only to control the number of trajectories plotted.
</p>
<p>If plotting results of an expression and the function fails, to debug obtain values of that expression using the functions <code><a href="#topic+get.pop.ex">get.pop.ex</a></code> (for <code>pop.trajectories.plot</code>) and <code><a href="#topic+get.pop.exba">get.pop.exba</a></code> (for <code>pop.byage.plot</code>).
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>, <code><a href="#topic+summary.bayesPop.prediction">summary.bayesPop.prediction</a></code>, <code><a href="#topic+pop.pyramid">pop.pyramid</a></code>, <code><a href="#topic+pop.expressions">pop.expressions</a></code>, <code><a href="#topic+get.pop">get.pop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir)
pop.trajectories.plot(pred, country="Ecuador", pi=c(80, 95))
pop.trajectories.table(pred, country="ECU", pi=c(80, 95))
# female population of Ecuador in child bearing ages (by time)
pop.trajectories.plot(pred, expression="PEC_F[4:10]") 
# Population by age in Netherands for two different years 
pop.byage.plot(pred, country="Netherlands", year=2050)
pop.byage.plot(pred, expression="PNL{}", year=2000)
</code></pre>

<hr>
<h2 id='project.pasfr'>
Projections of Percent Age-Specific Fertily Rate
</h2><span id='topic+project.pasfr'></span><span id='topic+project.pasfr.traj'></span>

<h3>Description</h3>

<p>The projections of percent age-specific fertility rate (PASFR) is normally computed within the <code><a href="#topic+pop.predict">pop.predict</a></code> function for each trajectory. This function allows to project PASFR outside of population projections for the median total fertility rate (TFR) or user-provided TFR, and export it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project.pasfr(inputs = NULL, present.year = 2020, end.year = 2100, 
    wpp.year = 2019, annual = FALSE, nr.est.points = if(annual) 15 else 3,
    digits = 2, out.file.name = "percentASFR.txt", verbose = FALSE)
    
project.pasfr.traj(inputs = NULL, countries = NULL, nr.traj = NULL, 
    present.year = 2020, end.year = 2100, wpp.year = 2019, 
    annual = FALSE, nr.est.points = if(annual) 15 else 3,
    digits = 2, out.file.name = "percentASFRtraj.txt", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project.pasfr_+3A_inputs">inputs</code></td>
<td>
<p>List of input data (file names) with the same meaning as in <code><a href="#topic+pop.predict">pop.predict</a></code>. The relevant items here are: either <code>tfr.file</code> or <code>tfr.sim.dir</code> (TFR estimates and projections), <code>pasfr</code> (PASFR for observed time periods), and <code>patterns</code> (PASFR patterns). All entries are optional. By default the data is taken from the corresponding wpp package. See Details below.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_present.year">present.year</code></td>
<td>
<p>Year of the last observed data point.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_end.year">end.year</code></td>
<td>
<p>End year of the projection.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_wpp.year">wpp.year</code></td>
<td>
<p>Year for which WPP data is used if one of the <code>inputs</code> components is left out.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_annual">annual</code></td>
<td>
<p>Logical that should be <code>TRUE</code> if the provided data on TFR and PASFR are annual-based data.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_nr.est.points">nr.est.points</code></td>
<td>
<p>Number of time points to be used for estimating the continuation of the observed PASFR trend. By default it is 15 years, corresponding to three time points for 5-year data.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places in the results.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_out.file.name">out.file.name</code></td>
<td>
<p>Name of the resulting file. If <code>NULL</code> nothing is written.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching verbose messages on and off.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_countries">countries</code></td>
<td>
<p>Vector of numerical country codes. By default the function is applied to all countries.</p>
</td></tr>
<tr><td><code id="project.pasfr_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories on which the function should be applied. By default all trajectories are taken. Otherwise they are thinned appropriately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input TFR is given as an ASCII file (in <code>inputs$tfr.file</code>), it can be either a csv (comma-separated) file in long format, with columns &ldquo;LocID&rdquo;, &ldquo;Year&rdquo;, &ldquo;Trajectory&rdquo; and &ldquo;TF&rdquo;. Or, it can be a tab-separated (wide format) file with column &ldquo;country_code&rdquo; and each year or time period as a separate column (see <code><a href="wpp2019.html#topic+tfr">tfr</a></code>). In the latter case, an additional <code>inputs</code> entry <code>tfr.file.type = "w"</code> must be provided to specify the file is in the wide format, which is a case whe there is only one trajectory. Note that the TFR input should cover all projection time period as well as observed TFR as the function assesses the start of Phase III, which could be in the past.
</p>
<p>If observed PASFR is given (in <code>inputs$pasfr</code>), it is a tab-separated file in wide format as in <code><a href="wpp2019.html#topic+percentASFR">percentASFR</a></code>. Fertility age patterns can be controlled by country via the <code>inputs$patterns</code> entry, which is a dataset in the same format and meaning as <code><a href="#topic+vwBaseYear">vwBaseYear</a></code>. 
</p>
<p>In addition, if the present year differs by country, the <code>inputs</code> list accepts the entry <code>last.observed</code>, which is a tab-separated file with columns &ldquo;country_code&rdquo; and &ldquo;last.observed&rdquo;. It can contain the year of the last observed time period for each country. 
</p>
<p>In the <code>project.pasfr</code> function, if the TFR input (given either as a long file or as a simulation directory), contains more than one trajectory, the median is derived over the trajectories for each time period. Then, PASFR corresponding to this median is projected using the method from Sevcikova et al (2015).
</p>
<p>For <code>project.pasfr.traj</code>, the PASFR is projected for single trajectories of TFR.
</p>


<h3>Value</h3>

<p>Returns invisible data frame with the projected PASFR. 
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Igor Ribeiro
</p>


<h3>References</h3>

<p>H. Sevcikova, N. Li, V. Kantorova, P. Gerland and A. E. Raftery (2016). Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. In: Dynamic Demographic Analysis, ed. Schoen R. (Springer), pp. 285-310. Earlier version: <a href="https://arxiv.org/abs/1503.05215">https://arxiv.org/abs/1503.05215</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.predict">pop.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using TFR in simulation directory
inputs &lt;- list(tfr.sim.dir=file.path(find.package("bayesTFR"), "ex-data", "bayesTFR.output"))
pasfr &lt;- project.pasfr(inputs, out.file.name = NULL)
head(pasfr)

## Not run: 
pasfr.traj &lt;- project.pasfr.traj(inputs, out.file.name = NULL)
head(pasfr.traj)
## End(Not run)

# using TFR in wide-format file
inputs2 &lt;- list(tfr.file = file.path(find.package("wpp2019"), "data", "tfrprojMed.txt"),
    tfr.file.type = "w")
pasfr2 &lt;- project.pasfr(inputs2, out.file.name = NULL)
head(pasfr2)
</code></pre>

<hr>
<h2 id='summary.bayesPop.prediction'>
Summary of Probabilistic Population Projection
</h2><span id='topic+summary.bayesPop.prediction'></span><span id='topic+print.summary.bayesPop.prediction'></span>

<h3>Description</h3>

<p>Summary of an object <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code> created using the <code><a href="#topic+pop.predict">pop.predict</a></code> function. The summary contains the mean, standard deviation and several commonly used quantiles of the simulated trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesPop.prediction'
summary(object, country = NULL, 
    sex = c("both", "male", "female"), compact = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bayesPop.prediction_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesPop.prediction_+3A_country">country</code></td>
<td>
<p>Country name or code. It can also be given as ISO-2 or ISO-3 characters. If it is <code>NULL</code>, only meta information included.</p>
</td></tr>
<tr><td><code id="summary.bayesPop.prediction_+3A_sex">sex</code></td>
<td>
<p>One of &ldquo;both&rdquo; (default), &ldquo;male&rdquo;, or &ldquo;female&rdquo;. If it is not &ldquo;both&rdquo;, the summary is given for sex-specific trajectories.</p>
</td></tr>
<tr><td><code id="summary.bayesPop.prediction_+3A_compact">compact</code></td>
<td>
<p>Logical switching between a smaller and larger number of displayed quantiles.</p>
</td></tr>
<tr><td><code id="summary.bayesPop.prediction_+3A_...">...</code></td>
<td>
<p>A list of further arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir)
summary(pred, "Netherlands")
</code></pre>

<hr>
<h2 id='vwBaseYear'>
Datasets on Migration Base Year and Type, and Mortality and Fertility Age Patterns
</h2><span id='topic+vwBaseYear'></span><span id='topic+vwBaseYear2010'></span><span id='topic+vwBaseYear2012'></span><span id='topic+vwBaseYear2015'></span><span id='topic+vwBaseYear2017'></span><span id='topic+vwBaseYear2019'></span><span id='topic+vwBaseYear2022'></span>

<h3>Description</h3>

<p>Datasets giving information on the baseyear and type of migration for each country. The 2012, 2015, 2017 and 2019 datasets also give information on country's specifics regarding mortality and fertility age patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    data(vwBaseYear2022)
    data(vwBaseYear2019)
    data(vwBaseYear2017)
    data(vwBaseYear2015)
    data(vwBaseYear2012) 
    data(vwBaseYear2010)  
</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt><code>country_code</code></dt><dd><p>Numerical Location Code (3-digit codes following ISO 3166-1 numeric standard) - see <a href="https://en.wikipedia.org/wiki/ISO_3166-1_numeric">https://en.wikipedia.org/wiki/ISO_3166-1_numeric</a>.</p>
</dd>
<dt><code>country</code></dt><dd><p>Country name. Not used by the package.</p>
</dd>
<dt><code>isSmall</code></dt><dd><p>UN internal code. Not used by the package.</p>
</dd>
<dt><code>ProjFirstYear</code></dt><dd><p>The base year of migration.</p>
</dd>
<dt><code>MigCode</code></dt><dd><p>Type of migration. Zero means migration is evenly distributed over each time interval. Code 9 means migration is captured at the end of each interval.</p>
</dd>
<dt><code>WPPAIDS</code></dt><dd><p>Dummy indicating if the country has generalized HIV/AIDS epidemics.</p>
</dd>
<dt><code>AgeMortalityType</code></dt><dd><p>Type of mortality age pattern. Only relevant for countries with the entry &ldquo;Model life tables&rdquo;. In such a case, the <code class="reqn">b_x</code> Lee-Carter parameter is not estimated from historical data. Instead is taken from the dataset <code><a href="#topic+MLTbx">MLTbx</a></code> using a pattern given in the <code>AgeMortalityPattern</code> column.</p>
</dd>
<dt><code>AgeMortalityPattern</code></dt><dd><p>If <code>AgeMortalityType</code> is equal to &ldquo;Model life tables&rdquo;, this value determines which <code class="reqn">b_x</code> is selected from the <code><a href="#topic+MLTbx">MLTbx</a></code> dataset. It must sorrespond to one of the rownames of <code><a href="#topic+MLTbx">MLTbx</a></code>, e.g. &ldquo;CD East&rdquo;, &ldquo;CD West&rdquo;, &ldquo;UN Latin American&rdquo;.</p>
</dd>
<dt><code>AgeMortProjMethod1</code></dt><dd><p>Method for projecting age-specific mortality rates. It is one of &ldquo;LC&rdquo; (modified Lee-Carter, uses function <code><a href="MortCast.html#topic+mortcast">mortcast</a></code>), &ldquo;PMD&rdquo; (pattern mortality decline, uses function <code><a href="MortCast.html#topic+copmd">copmd</a></code>), &ldquo;modPMD&rdquo; (modified pattern mortality decline, uses function <code><a href="MortCast.html#topic+copmd">copmd</a>(... use.modpmd = TRUE)</code>), &ldquo;MLT&rdquo; (model life tables, uses function <code><a href="MortCast.html#topic+mlt">mlt</a></code>), &ldquo;LogQuad&rdquo; (log quadratic method, uses function <code><a href="MortCast.html#topic+logquad">logquad</a></code>), or &ldquo;HIVmortmod&rdquo; (HIV model life tables as implemented in the <span class="pkg">HIV.LifeTables</span> package which can be installed from the <a href="https://github.com/PPgP/HIV.LifeTables">PPgP/HIV.LifeTables</a> GitHub repo).</p>
</dd>
<dt><code>AgeMortProjMethod2</code></dt><dd><p>If the mortality rates are to be projected via a blend of two methods (see <code><a href="MortCast.html#topic+mortcast.blend">mortcast.blend</a></code>), this column determines the second method. The options are the same as in the column <code>AgeMortProjMethod1</code>.</p>
</dd>
<dt><code>AgeMortProjPattern</code></dt><dd><p>If one of the <code>AgeMortProjMethodX</code> colums contains the &ldquo;MLT&rdquo; method, this column determines the type of the life table (see the argument <code>type</code> in the <code><a href="MortCast.html#topic+mlt">mlt</a></code> function).</p>
</dd>
<dt><code>AgeMortProjMethodWeights</code></dt><dd><p>If the mortality rates are to be projected via a blend of two methods, this column determines the weights in the first and the last year of the projection, respectively. It should be given as an R vector, e.g. &ldquo;c(1, 0.5)&rdquo; (see the argument <code>weights</code> in <code><a href="MortCast.html#topic+mortcast.blend">mortcast.blend</a></code>).</p>
</dd>
<dt><code>AgeMortProjAdjSR</code></dt><dd><p>Code determining how the &ldquo;PMD&rdquo; method should be adjusted if it's used. 0 means no adjustment, 1 means the argument <code>sexratio.adjust</code> in <code><a href="MortCast.html#topic+copmd">copmd</a></code> is set to <code>TRUE</code>, and code 3 means that the argument <code>adjust.sr.if.needed</code> in <code><a href="MortCast.html#topic+copmd">copmd</a></code> is set to <code>TRUE</code>.</p>
</dd>
<dt><code>LatestAgeMortalityPattern</code>, <code>LatestAgeMortalityPattern1</code></dt><dd><p>Indicator <code class="reqn">n</code> for how many latest time periods should be used to compute  the <code class="reqn">a_x</code> Lee-Carter and modPMD parameter. If <code class="reqn">n</code> is zero, all time periods are used. If <code class="reqn">n</code> is one, only the latest time period is used. If <code class="reqn">n</code> is negative, the latest <code class="reqn">n</code> time periods are excluded. This can have also a form of vector of size 2, where the first element (must be negative) determines how many latest time periods should be excluded, while the second element (must be positive) determines how many latest time periods to include after the exclusion. E.g. &ldquo;c(-2, 3)&rdquo; would mean exclude 2 time periods and use the following 3 time points. If the <code>LatestAgeMortalityPattern1</code> column is present, it should contain values related to an annual simulation (1x1) while the <code>LatestAgeMortalityPattern</code> column relates to a 5x5 simulation.</p>
</dd>
<dt><code>SmoothLatestAgeMortalityPattern</code></dt><dd><p>If <code>LatestAgeMortalityPattern</code> is 1, this column indicates if the <code class="reqn">a_x</code> should be smoothed.</p>
</dd>
<dt><code>SmoothDFLatestAgeMortalityPattern</code>, <code>SmoothDFLatestAgeMortalityPattern1</code></dt><dd><p>Degree of freedom for smoothing <code class="reqn">a_x</code>. By default (value 0) a half of the number of age groups is taken. If the <code>SmoothDFLatestAgeMortalityPattern1</code> column is present, it should contain values related to a 1x1 simulation while the <code>SmoothDFLatestAgeMortalityPattern</code> column relates to a 5x5 simulation.</p>
</dd>
<dt><code>PasfrNorm</code></dt><dd><p>Type of norm for computing age-specific fertility pattern to which the country belongs to. Currently only &ldquo;GlobalNorm&rdquo; is used.</p>
</dd>
<dt><code>PasfrGlobalNorm, PasfrFarEastAsianNorm, PasfrSouthAsianNorm</code></dt><dd><p>Dummies indicating which country to include to compute the specific norms.</p>
</dd>
</dl>



<h3>Details</h3>

<p>There is one record for each country. See Sevcikova et al (2015) on how information from the various columns is used for projections.
</p>


<h3>Source</h3>

<p>Data provided by the United Nations Population Division.
</p>


<h3>References</h3>

<p>H. Sevcikova, N. Li, V. Kantorova, P. Gerland and A. E. Raftery (2015). Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. arXiv:1503.05215. <a href="https://arxiv.org/abs/1503.05215">https://arxiv.org/abs/1503.05215</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vwBaseYear2019)
str(vwBaseYear2019)
</code></pre>

<hr>
<h2 id='write.pop.projection.summary'>
Writing Projection Summary and Trajectory Files
</h2><span id='topic+write.pop.projection.summary'></span><span id='topic+write.pop.trajectories'></span>

<h3>Description</h3>

<p>Functions for creating ASCII files containing projection summaries, such as the median, the lower and upper bound of the 80 and 95% probability intervals, respectively, as well as containing individual trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pop.projection.summary(pop.pred, what = NULL, expression = NULL, 
    output.dir = NULL, ...)
    
write.pop.trajectories(pop.pred, expression = "PXXX", 
    output.file = "pop_trajectories.csv", byage = FALSE, 
    observed = FALSE,  wide = FALSE, digits = NULL,
    include.name = FALSE, sep = ",", na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pop.projection.summary_+3A_pop.pred">pop.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesPop.prediction">bayesPop.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_what">what</code></td>
<td>
<p>A character vector specifying what kind of projection to write. Total population is specified by &ldquo;pop&rdquo;. Vital events are specified by &ldquo;births&rdquo;, &ldquo;deaths&rdquo;, &ldquo;sr&rdquo; (survival rate), &ldquo;fertility&rdquo; and &ldquo;pfertility&rdquo; (percent fertility). Each of these strings can (some must) have a suffix &ldquo;sex&rdquo; and/or &ldquo;age&rdquo; if sex- and/or age-specific measure is desired. For example, &ldquo;popage&rdquo;, &ldquo;birthssexage&rdquo;, &ldquo;deaths&rdquo;, &ldquo;deathssex&rdquo;, are all valid values. Note that for survival, only &ldquo;srsexage&rdquo; is allowed. For percent fertility, only &ldquo;pfertilityage&rdquo; is allowed. Suffix &ldquo;sex&rdquo; cannot be used in combination with &ldquo;fertility&rdquo;. Moreover, &ldquo;fertility&rdquo; (without age) corresponds to the total fertility rate. If the argument is <code>NULL</code>, all valid combinations are used.  The argument is not used if <code>expression</code> is given. Note that vital events can be only used if the prediction object contains vital events, i.e. if it was generated with the <code>keep.vital.events</code> argument being <code>TRUE</code> (see <code><a href="#topic+pop.predict">pop.predict</a></code>).</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_expression">expression</code></td>
<td>
<p>Expression defining the measure to be written. If it is not <code>NULL</code>, argument <code>what</code> is ignored. For expression syntax see <code><a href="#topic+pop.expressions">pop.expressions</a></code>. The country components of the expression should be given as &ldquo;XXX&rdquo;.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory in which the resulting files will be stored. If <code>NULL</code> <code>pop.pred$output.directory</code> is used.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_output.file">output.file</code></td>
<td>
<p>File name to write the trajectories into.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_byage">byage</code></td>
<td>
<p>Logical indicating if the expression is defined by age, i.e. if it includes curly braces (<code>TRUE</code>), of if it is defined by time (<code>FALSE</code>), see <code><a href="#topic+pop.expressions">pop.expressions</a></code> for more detail on the expression syntax.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_observed">observed</code></td>
<td>
<p>Logical indicating if observed data should be written (<code>TRUE</code>) or projected trajectories (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_wide">wide</code></td>
<td>
<p>Logical indicating if the data format should be wide. By default, trajectories are written in long format.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_digits">digits</code></td>
<td>
<p>To how many decimal digits should the indicator be rounded. By default no rounding takes place.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_include.name">include.name</code></td>
<td>
<p>Logical indicating if country names should be included in the dataset.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_sep">sep</code></td>
<td>
<p>The field separator string.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating if records with <code>NA</code> values should be included in the dataset.</p>
</td></tr>
<tr><td><code id="write.pop.projection.summary_+3A_...">...</code></td>
<td>
<p>For <code>write.pop.projection.summary</code>, these are:
</p>

<ul>
<li><p> if <code>expression</code> is given, then one can use here <code>file.suffix</code> (defines the file suffix) and/or <code>expression.label</code> which defaults to the actual expression and is put as the first line in the resulting file;
</p>
</li>
<li><p> logical <code>include.observed</code> determines if observed data should be included;
</p>
</li>
<li><p> integer <code>digits</code> defines the number of decimal places in the resulting file;
</p>
</li>
<li><p> for 5-year projections, logical <code>end.time.only</code> determines if the time columns should be in form of time periods (as XXXX-YYYY) or just the end years (YYYY);
</p>
</li>
<li><p> logical <code>adjust</code> determines if the numbers should be adjusted; in such a case, <code>adj.to.file</code> and <code>allow.negative.adj</code> give the file name to which to adjust and a switch if negatives are allowed for the adjustments, respectively.
</p>
</li></ul>

<p>For <code>write.pop.trajectories</code>, these are arguments passed to <code><a href="#topic+get.pop.ex">get.pop.ex</a></code> (if <code>byage</code> is <code>FALSE</code>) or <code><a href="#topic+get.pop.exba">get.pop.exba</a></code> (if <code>byage</code> is <code>TRUE</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>write.pop.projection.summary</code> function creates one file per value of <code>what</code>, or <code>expression</code>, called &lsquo;<span class="file">projection_summary_</span>&rsquo;<em>suffix</em>&lsquo;<span class="file">.csv</span>&rsquo;, where <em>suffix</em> is either <code>what</code> or, if an expression is given, the value of <code>file.suffix</code>. It is a comma-separated table with the following columns:
</p>

<ul>
<li> <p>&ldquo;country_name&rdquo;: country name 
</p>
</li>
<li> <p>&ldquo;country_code&rdquo;: country code 
</p>
</li>
<li> <p>&ldquo;variant&rdquo;: name of the variant, such as &ldquo;median&rdquo;, &ldquo;lower 80&rdquo;, &ldquo;upper 80&rdquo;, &ldquo;lower 95&rdquo;, &ldquo;upper 95&rdquo;
</p>
</li>
<li><p> period1: e.g. &ldquo;2005-2010&rdquo;, or &ldquo;2010&rdquo;: Given population measure for the first time period
</p>
</li>
<li><p> period2: e.g. &ldquo;2010-2015&rdquo;, or &ldquo;2015&rdquo;: Given population measure for the second time period
</p>
</li>
<li> <p>... further time period columns	
</p>
</li></ul>

<p>If  <code>expression</code> is given, <code>expression.label</code> (by default the full expression) is written as the first line of the file starting with #. The file contains one line per country, and possibly sex and age.
</p>
<p>Function <code>write.pop.trajectories</code> writes out all trajectories, either in long format (default) or, if <code>wide = TRUE</code> in wide format (years become columns).
</p>


<h3>Note</h3>

<p>If the <code>expression</code> argument is used, the same applies as for <code><a href="#topic+pop.map">pop.map</a></code> in terms of Performance and Caching.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop.predict">pop.predict</a></code>, <code><a href="#topic+pop.map">pop.map</a></code>, <code><a href="#topic+pop.expressions">pop.expressions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>outdir &lt;- tempfile()
dir.create(outdir)
sim.dir &lt;- file.path(find.package("bayesPop"), "ex-data", "Pop")
pred &lt;- get.pop.prediction(sim.dir=sim.dir, write.to.cache=FALSE)

# proportion of 65+ years old to the whole population
write.pop.projection.summary(pred, expression="PXXX[14:27] / PXXX", file.suffix="age65plus", 
    output.dir=outdir, include.observed=TRUE, digits=2)
    
# various measures
write.pop.projection.summary(pred, what=c("pop", "popsexage", "popsex"),
    output.dir=outdir)

unlink(outdir, recursive=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
