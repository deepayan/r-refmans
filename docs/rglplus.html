<!DOCTYPE html><html><head><title>Help for package rglplus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rglplus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rglplus-package'><p>Extension of the 'rgl' 3D Visualization Package</p></a></li>
<li><a href='#rgl.ball'><p>Plot high-resolution sphere or globe</p></a></li>
<li><a href='#rgl.camera'><p>Place observer</p></a></li>
<li><a href='#rgl.close.all'><p>Close all open rgl windows</p></a></li>
<li><a href='#rgl.draw'><p>Continue drawing on screen</p></a></li>
<li><a href='#rgl.hold'><p>Stop drawing on screen</p></a></li>
<li><a href='#rgl.makemovie'><p>Produce a movie from and 3d rgl scene</p></a></li>
<li><a href='#rgl.new'><p>Open and initialize new 3D plot</p></a></li>
<li><a href='#rgl.orthoview'><p>Display orthogonal projection</p></a></li>
<li><a href='#rgl.test.scene'><p>Plot 3D test image</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extension of the 'rgl' 3D Visualization Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Danail Obreschkow</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Danail Obreschkow &lt;danail.obreschkow@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides 3D plotting routines that facilitate the use of the 'rgl' package and extend its functionality. For example, the routines allow the user to directly control the camera position &amp; orientation, as well as to generate 3D movies with a moving observer.</td>
</tr>
<tr>
<td>Imports:</td>
<td>rgl, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 07:47:35 UTC; 00077389</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 08:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='rglplus-package'>Extension of the 'rgl' 3D Visualization Package</h2><span id='topic+rglplus'></span><span id='topic+rglplus-package'></span>

<h3>Description</h3>

<p>Provides 3D plotting routines that facilitate the use of the 'rgl' package and extend its functionality. For example, the routines allow the user to directly control the camera position &amp; orientation, as well as to generate 3D movies with a moving observer.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='rgl.ball'>Plot high-resolution sphere or globe</h2><span id='topic+rgl.ball'></span>

<h3>Description</h3>

<p>Draws a sphere in custom resolution with custom surface image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.ball(
  x = 0,
  y = 0,
  z = 0,
  radius = 1,
  depth = 5,
  png = NULL,
  rotation = NULL,
  normals = "standard",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.ball_+3A_x">x</code></td>
<td>
<p>x-coordinate of the center of the sphere</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_y">y</code></td>
<td>
<p>y-coordinate of the center of the sphere</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_z">z</code></td>
<td>
<p>z-coordinate of the center of the sphere</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_radius">radius</code></td>
<td>
<p>radius of the sphere</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_depth">depth</code></td>
<td>
<p>integer (1...8) specifying the number of rectangles (=6*4^depth)</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_png">png</code></td>
<td>
<p>optional character string specifying the file name of a png-image to be rendered on the sphere. This file must contain the map to be displayed in an equirectangular projection (also known as equidistant cylindrical projection).</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_rotation">rotation</code></td>
<td>
<p>optional 3-by-3 or or 4-by-4 rotation matrix applied to the whole globe; only used of <code>png</code> is specified.</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_normals">normals</code></td>
<td>
<p>character string specifying the way the normal vectors of the surface are internally passed to <code><a href="rgl.html#topic+surface3d">surface3d</a></code>. This argument is available because <code><a href="rgl.html#topic+surface3d">surface3d</a></code> (or rather the underlying routine <code><a href="rgl.html#topic+rgl.surface">rgl.surface</a></code>) sometimes handles the sign of normal vectors incorrectly, causing light sources to appear in the wrong direction if a rotation matrix is provided. The argument can take three values: &quot;none&quot; does not pass any normal vectors to <code><a href="rgl.html#topic+rgl.surface">rgl.surface</a></code>, hence avoiding any issues with the direction of light sources, but this can cause glitches at the 180-degree meridian (choose a high depth around 7 in this case); &quot;standard&quot; passes correct normal vectors to <code><a href="rgl.html#topic+rgl.surface">rgl.surface</a></code>, which can cause wrong lighting for certain rotation matrices; &quot;improved&quot; is similar to &quot;standard&quot;, but corrects the lighting errors in most cases.</p>
</td></tr>
<tr><td><code id="rgl.ball_+3A_...">...</code></td>
<td>
<p>additional parameter to refine the material properties (see <code><a href="rgl.html#topic+rgl.material">rgl.material</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow (thanks to input from Aaron Robotham's <code>sphereplot</code> package)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show Earth with core
rgl::open3d()
rgl.ball(0, 0, 0, 1, png=system.file('earth.png', package='rglplus'), emission='grey', alpha=0.6)
rgl.ball(0, 0, 0, 0.6, col='red')

</code></pre>

<hr>
<h2 id='rgl.camera'>Place observer</h2><span id='topic+rgl.camera'></span>

<h3>Description</h3>

<p>Set the position, orientation and field-of-view of the observer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.camera(position = NULL, direction = NULL, up = NULL, fov = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.camera_+3A_position">position</code></td>
<td>
<p>either a 3-vector, a single number or NULL. A vector directly specifies the location of camera. A single number specifies the distances of the camera along the z-axis, relative to the center of the scene (= center of the bounding box returned by <code><a href="rgl.html#topic+par3d">par3d</a></code>). If no positions is given, then the camera is placed automatically.</p>
</td></tr>
<tr><td><code id="rgl.camera_+3A_direction">direction</code></td>
<td>
<p>optional 3-vector specifying the direction in which the observer is looking, that is the optical axis of the virtual camera. The norm of the vector is irrelevant, but has to be non-zero. If not given, the camera is pointed at the center of the scene.</p>
</td></tr>
<tr><td><code id="rgl.camera_+3A_up">up</code></td>
<td>
<p>optional single number or 3-vector, specifying the rotation of the camera around the optical axis (as defined with the argument direction). If a single number is provided, it is normally interpreted as the angle in degrees between the up-direction of the 2d camera image and the projected z-axis of the 3d scene. To avoid the singularity that occurs if the optical axis lies very close to the z-axis, &quot;up&quot; is, in this case, interpreted as the angle between the up-direction and the y-axis. If a 3-vector is provided, it is interpreted such that its projection points upwards on the projected image seen by the camera. Thus, this 3-vector must *not* be parallel to the direction.</p>
</td></tr>
<tr><td><code id="rgl.camera_+3A_fov">fov</code></td>
<td>
<p>field of view in degrees, as used in <code><a href="rgl.html#topic+view3d">view3d</a></code>. This is roughly the field-of-view seen along the shortest axis of the window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw knot
rgl::open3d()
a = seq(0,2*pi,len=25)
knot = rgl::cylinder3d(center=cbind(sin(a)+2*sin(2*a), 2*sin(3*a), cos(a)-2*cos(2*a)),
                       e1 = cbind(cos(a)+4*cos(2*a), 6*cos(3*a), sin(a)+4*sin(2*a)),
                       radius = 0.8, closed = TRUE)
rgl::shade3d(rgl::addNormals(rgl::subdivision3d(knot,depth=2)), col="purple")

# Place static camera
rgl.camera(c(10,0,0),fov=50)

# Animate camera
## Not run: 
  for(alpha in seq(0,2*pi,len=100)) {
    rgl.camera(10*c(cos(alpha),sin(alpha),0),fov=50)
  }

## End(Not run)

</code></pre>

<hr>
<h2 id='rgl.close.all'>Close all open rgl windows</h2><span id='topic+rgl.close.all'></span>

<h3>Description</h3>

<p>Checks if any rgl windows are currently open and, if so, closes them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.close.all()
</code></pre>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='rgl.draw'>Continue drawing on screen</h2><span id='topic+rgl.draw'></span>

<h3>Description</h3>

<p>Updates screen display after this was stopped using the function <code><a href="#topic+rgl.hold">rgl.hold</a></code>. This is identical to calling <code>par3d(skipRedraw=FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.draw()
</code></pre>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgl.hold">rgl.hold</a></code>
</p>

<hr>
<h2 id='rgl.hold'>Stop drawing on screen</h2><span id='topic+rgl.hold'></span>

<h3>Description</h3>

<p>Prevents the following rgl functions from drawing on the screen, until the function <code><a href="#topic+rgl.draw">rgl.draw</a></code> is called. This is used to accelerate complex drawings. This routine is identical to calling <code>par3d(skipRedraw=TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.hold()
</code></pre>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgl.draw">rgl.draw</a></code>
</p>

<hr>
<h2 id='rgl.makemovie'>Produce a movie from and 3d rgl scene</h2><span id='topic+rgl.makemovie'></span>

<h3>Description</h3>

<p>Generates an MP4-movie of a 3d rgl scene with time-dependent objects and/or a camera path. The routine has been developed and tested for MacOS and it requires on a working installation of ffmpeg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.makemovie(
  frame = NULL,
  path = NULL,
  tmin = 0,
  tmax = 1,
  nframes = 60,
  fps = 60,
  output.path,
  output.filename,
  keep.frames = FALSE,
  quiet = TRUE,
  separator = .Platform$file.sep,
  ffmpeg.cmd = "ffmpeg",
  ffmpeg.opt = "-vcodec libx264 -crf 18 -pix_fmt yuv420p",
  manual = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.makemovie_+3A_frame">frame</code></td>
<td>
<p>optional function that plots or updates the 3D scene at a given time. This function must have exactly one argument, which specifies the time of the frame.</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_path">path</code></td>
<td>
<p>optional list that specifies the motion of the camera at some discrete times. The list contains the following elements (for more details see <code><a href="#topic+rgl.camera">rgl.camera</a></code>):<br /><br />
<code>time</code> = optional n-vector of strictly monotonically increasing discrete times, required if and only if one of the following four arguments (position, direction, up, fov) are provided as matrices/vectors. If not given, equally spaced in times between tmin and tmax are assumed.<br />
<code>position</code> = optional argument specifying the camera position along the path. This argument must be one of three types: (1) A 3-element vector specifies a fixed camera position for the whole movie. (2) A n-by-3 matrix specifies n discrete camera positions at the exact times given in the <code>time</code> vector (see above). The code automatically generates a smooth function going through these n points. (3) A function f(t) of a single time variable t, which returns a 3-element vector, specifies the exact position at that time.<br />
<code>direction</code> = optional argument specifying the direction of the camera's optical axis. This argument can be of the same three types as the <code>position</code> argument.<br />
<code>up</code> = optional argument specifying the camera's up-direction. This argument can be of the same three types as the <code>position</code> argument.<br />
<code>fov</code> = optional argument specifying the field-of-view (FoV) in degrees. Similarly to the above arguments, this can be either a single number (fixed FoV), a n-element vector (specifying the Fov at the n discrete times), or a scalar function (specifying the FoV at any time t).<br /><br /></p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_tmin">tmin</code></td>
<td>
<p>physical time of first frame in the movie.</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_tmax">tmax</code></td>
<td>
<p>physical time of last frame in the movie.</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_nframes">nframes</code></td>
<td>
<p>number of frames in the movie. The time variable is sampled evenly between <code>tmin</code> and <code>tmax</code>.</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_fps">fps</code></td>
<td>
<p>number of frames per second</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_output.path">output.path</code></td>
<td>
<p>character specifying the directory, where the movie and temporary frames are saved</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_output.filename">output.filename</code></td>
<td>
<p>movie filename without path. This filename should end on the extension '.mp4'.</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_keep.frames">keep.frames</code></td>
<td>
<p>logical flag specifying whether the temporary directory with the individual frame files should be kept</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_quiet">quiet</code></td>
<td>
<p>logical flag; if true, all console outputs produced by 'ffmpeg' are suppressed</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_separator">separator</code></td>
<td>
<p>filename separate of the system ('/' for Mac, Linux, Unix; '\' for Windows)</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_ffmpeg.cmd">ffmpeg.cmd</code></td>
<td>
<p>command used to call ffmpeg form a terminal. Normally, this is just 'ffmpeg'.</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_ffmpeg.opt">ffmpeg.opt</code></td>
<td>
<p>optional arguments used with ffmpeg, such as compression and formatting options (see <a href="https://www.ffmpeg.org/ffmpeg.html">https://www.ffmpeg.org/ffmpeg.html</a>).</p>
</td></tr>
<tr><td><code id="rgl.makemovie_+3A_manual">manual</code></td>
<td>
<p>logical flag, if TRUE, ffmpeg is not run automatically. The ffmpeg command line is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the frame width and height should be divisible by 2 for mp4 video compression to work.<br />
To accelerate the movie generation, it is possible to suppress the screen update by calling <code><a href="#topic+rgl.hold">rgl.hold</a></code> before calling <code>rgl.makemovie</code>.
</p>


<h3>Value</h3>

<p>Returns the command line to run ffmpeg in a terminal.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

rgl.new(aspect=4/3, col='black', xlim=c(-4,4), ylim=c(-4,4), zlim=c(-4,4))
rgl::clear3d(type = "lights")
rgl::light3d(30,60,viewpoint.rel = FALSE)


# Make frame function
frame = function(t) {
  # t = time in seconds
  rgl.hold()
  if (t&gt;0) {for (i in seq(3)) rgl::pop3d()}
  rgl.ball(0, 0, 0, 1, normals='improved', depth=6, png=system.file('earth.png', package='rglplus'),
           emission='#444466', rotation=rgl::rotationMatrix(t/86400*2*pi,0,0,1))
  alpha = seq(0,2*pi,length=360)+2*pi*t/43200
  alpha = c(alpha[1],rep(alpha[2:359],each=2),alpha[360])
  y = 3.168*cos(alpha)
  z = 3.168*sin(alpha)
  rgl.ball(0,y[1],z[1],0.05,col='red',emission='#aa0000')
  rgl::segments3d(0,y,z,col='red',alpha=seq(0,1,length=720))
  rgl.draw()
}

# Make path
path = list(position=c(10,10,0), up=c(0,0.5,1), fov = function(t) 40-t/8640)

# Produce movie
## Not run: 
rgl.makemovie(frame=frame, path=path, tmin=0, tmax=86400, output.path='~/testmovie',
              output.filename = 'movie.mp4', ffmpeg.cmd = 'ffmpeg', nframes=600)

## End(Not run)

</code></pre>

<hr>
<h2 id='rgl.new'>Open and initialize new 3D plot</h2><span id='topic+rgl.new'></span>

<h3>Description</h3>

<p>Calls <code><a href="rgl.html#topic+open3d">open3d</a></code> and various additional functions to initialize a 3d plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.new(
  width = 0.5,
  aspect = 16/9,
  orientation = "xy",
  fov = 30,
  col = "white",
  light = TRUE,
  xlim = c(0, 1),
  ylim = c(0, 1),
  zlim = c(0, 1),
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  axes = FALSE,
  fixed = TRUE,
  close.all = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.new_+3A_width">width</code></td>
<td>
<p>either an integer (&gt;1) specifying the number of pixels in the horizontal direction, or a real value (&gt;0 and &lt;=1) specifying the fraction of the available pixels. If the selected aspect ratio causes the number of vertical pixels to exceed the available number, the width is reduced as much as necessary.</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_aspect">aspect</code></td>
<td>
<p>aspect ratio of window, defined as the ratio of vertical-to-horizontal size.</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_orientation">orientation</code></td>
<td>
<p>3-by-3 rotation matrix or 2-character string specifying the orientation of the camera. For character string the allowed values are 'xy', 'yx', 'yz', 'zy', 'zx', 'xz', where the  first letter is the axis displayed from left to right and the second letter is the axis displayed from bottom to top. The third axis points either out of the screen or into the screen following the right-hand convention. This is the same as the <code>plane</code> argument of <code><a href="#topic+rgl.orthoview">rgl.orthoview</a></code>.</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_fov">fov</code></td>
<td>
<p>field of view in degrees, as used in <code><a href="rgl.html#topic+view3d">view3d</a></code></p>
</td></tr>
<tr><td><code id="rgl.new_+3A_col">col</code></td>
<td>
<p>background color</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_light">light</code></td>
<td>
<p>logical flag. If <code>TRUE</code>, the standard light source created by <code><a href="rgl.html#topic+open3d">open3d</a></code> will be light up the scene. If <code>FALSE</code>, no light source is added and the user must create custom light sources manually by calling <code><a href="rgl.html#topic+light3d">light3d</a></code>.</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_xlim">xlim</code></td>
<td>
<p>2-vector specifying the range along the x-axis</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_ylim">ylim</code></td>
<td>
<p>2-vector specifying the range along the y-axis</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_zlim">zlim</code></td>
<td>
<p>2-vector specifying the range along the z-axis</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying the label of the x-axis</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_ylab">ylab</code></td>
<td>
<p>character string specifying the label of the y-axis</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_zlab">zlab</code></td>
<td>
<p>character string specifying the label of the z-axis</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_axes">axes</code></td>
<td>
<p>logical flag specifying whether axes are displayed</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_fixed">fixed</code></td>
<td>
<p>logical flag. If <code>TRUE</code> (default), the range of the axes is *not* adjusted as objects are drawn.</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_close.all">close.all</code></td>
<td>
<p>logical flag. If <code>TRUE</code> (default), all existing rgl windows are closed before the new window is opened.</p>
</td></tr>
<tr><td><code id="rgl.new_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="rgl.html#topic+view3d">view3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='rgl.orthoview'>Display orthogonal projection</h2><span id='topic+rgl.orthoview'></span>

<h3>Description</h3>

<p>Display orthogonal projection on principal Cartesian planes, with scene centre in the image centre.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.orthoview(plane = "xy", fov = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.orthoview_+3A_plane">plane</code></td>
<td>
<p>character string, which can be either of 'xy', 'yx', 'yz', 'zy', 'zx', 'xz', where the  first letter is the axis displayed from left to right and the second letter is the axis displayed from bottom to top. The third axis points either out of the screen or into the screen following the right-hand convention.</p>
</td></tr>
<tr><td><code id="rgl.orthoview_+3A_fov">fov</code></td>
<td>
<p>field of view in degrees, as used in <code><a href="rgl.html#topic+view3d">view3d</a></code>.</p>
</td></tr>
<tr><td><code id="rgl.orthoview_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="rgl.html#topic+view3d">view3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgl.camera">rgl.camera</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rgl::plot3d(array(runif(60),c(20,3)), col=rainbow(20), axes=FALSE,
            xlim=c(0,1), ylim=c(0,1), zlim=c(0,1), xlab='', ylab='', zlab='')
rgl::box3d()
rgl.orthoview('xy', fov=20)

</code></pre>

<hr>
<h2 id='rgl.test.scene'>Plot 3D test image</h2><span id='topic+rgl.test.scene'></span>

<h3>Description</h3>

<p>Draws a c3D test image with three Cartesian axes, a sphere of radius 0.5 and three light sources with RGB colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.test.scene(center = c(0, 0, 0), width = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.test.scene_+3A_center">center</code></td>
<td>
<p>3-vector specifying the centre of the 3D plot.</p>
</td></tr>
<tr><td><code id="rgl.test.scene_+3A_width">width</code></td>
<td>
<p>either an integer (&gt;1) specifying the number of pixels in the horizontal direction, or a real value (&gt;0 and &lt;=1) specifying the fraction of the available pixels. If the selected aspect ratio causes the number of vertical pixels to exceed the available number, the width is reduced as much as necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
