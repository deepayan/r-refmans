<!DOCTYPE html><html lang="en"><head><title>Help for package LMMELSM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LMMELSM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LMMELSM-package'><p>The 'LMMELSM' package.</p></a></li>
<li><a href='#.add_group_codings'><p>Adds group codings for predictive df.</p></a></li>
<li><a href='#.combine_RHS'><p>Combines multiple formulas' RHS into one.</p></a></li>
<li><a href='#.detect_L2_only'><p>Detect whether the predictors are L2-only</p></a></li>
<li><a href='#.full_to_lower_tri'><p>Get indices for subsetting lower-tri summaries of square matrices.</p></a></li>
<li><a href='#.get_elapsed_time'><p>Gets elapsed time.</p></a></li>
<li><a href='#.get_formula_names'><p>Get names in formula.</p></a></li>
<li><a href='#.get_indicator_spec'><p>Get indicator spec for stan model.</p></a></li>
<li><a href='#.get_LHS'><p>Get LHS variable as string.</p></a></li>
<li><a href='#.get_RHS'><p>Get RHS terms or variables.</p></a></li>
<li><a href='#.list_zip'><p>Zip two lists together with function.</p></a></li>
<li><a href='#.magicsep'><p>Convert char vector to columns.</p></a></li>
<li><a href='#.newline'><p>Print newline.</p></a></li>
<li><a href='#.pars_to_indices'><p>Convert stan par-string to numeric columns.</p></a></li>
<li><a href='#.parse_formula'><p>Convert spec to stan data.</p></a></li>
<li><a href='#.parse_formula.indicators'><p>Compute indicator data.</p></a></li>
<li><a href='#.parse_formula.predictor'><p>Compute predictor data.</p></a></li>
<li><a href='#.sep'><p>Print separator.</p></a></li>
<li><a href='#.simulate.X'><p>Simulate covariates without correlation.</p></a></li>
<li><a href='#.summarize'><p>Compute posterior summaries.</p></a></li>
<li><a href='#.summary_rearrange'><p>Rearrange summary output.</p></a></li>
<li><a href='#.tidy_summary'><p>Takes stan summary, returns summary with indices-as-columns.</p></a></li>
<li><a href='#.which_location_scale'><p>Check for location-scale formulas</p></a></li>
<li><a href='#+25IfNull+25'><p>Operator for testing NULL and returning expr if NULL</p></a></li>
<li><a href='#coef.lmmelsm'><p>Extract group-specific coefficients.</p></a></li>
<li><a href='#fitted.lmmelsm'><p>Extracted model fitted variates.</p></a></li>
<li><a href='#lmmelsm'><p>Specify and fit the (latent) (multivariate) melsm.</p></a></li>
<li><a href='#loo.lmmelsm'><p>loo method for LMMELSM objects.</p></a></li>
<li><a href='#nlist'><p>Creates named list.</p></a></li>
<li><a href='#predict.lmmelsm'><p>Predict method for lmmelsm objects.</p></a></li>
<li><a href='#print.lmmelsm'><p>Print method for lmmelsm objects.</p></a></li>
<li><a href='#print.summary.lmmelsm'><p>Print method for summary.lmmelsm objects.</p></a></li>
<li><a href='#ranef.lmmelsm'><p>Extract random effects.</p></a></li>
<li><a href='#row_multiply_list_mats'><p>Multiply a row by a list of matrices</p></a></li>
<li><a href='#sim_data'><p>Simulated data for fitting the LMMELSM</p></a></li>
<li><a href='#simulate_lmmelsm'><p>Simulate data from latent uni/multidimensional MELSM</p></a></li>
<li><a href='#summary.lmmelsm'><p>Summary method for lmmelsm objects.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fit Latent Multivariate Mixed Effects Location Scale Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>In addition to modeling the expectation (location) of an outcome, mixed effects location scale models (MELSMs) include submodels on the variance components (scales) directly. This allows models on the within-group variance with mixed effects, and between-group variances with fixed effects. The MELSM can be used to model volatility, intraindividual variance, uncertainty, measurement error variance, and more. Multivariate MELSMs (MMELSMs) extend the model to include multiple correlated outcomes, and therefore multiple locations and scales. The latent multivariate MELSM (LMMELSM) further includes multiple correlated latent variables as outcomes. This package implements two-level mixed effects location scale models on multiple observed or latent outcomes, and between-group variance modeling. Williams, Martin, Liu, and Rast (2020) &lt;<a href="https://doi.org/10.1027%2F1015-5759%2Fa000624">doi:10.1027/1015-5759/a000624</a>&gt;. Hedeker, Mermelstein, and Demirtas (2008) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2007.00924.x">doi:10.1111/j.1541-0420.2007.00924.x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stephenSRMMartin/LMMELSM">https://github.com/stephenSRMMartin/LMMELSM</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula (&ge; 1.2), loo (&ge; 2.3.0), MASS (&ge; 7.0), methods, nlme
(&ge; 3.0), parallel (&ge; 3.6.0), Rcpp (&ge; 0.12.0), RcppParallel
(&ge; 5.0.1), rstan (&ge; 2.18.1), rstantools (&ge; 2.2.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-11 19:30:51 UTC; hwkiller</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen Martin <a href="https://orcid.org/0000-0001-8085-2390"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Philippe Rast <a href="https://orcid.org/0000-0003-3630-6629"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Martin &lt;stephenSRMMartin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-15 08:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='LMMELSM-package'>The 'LMMELSM' package.</h2><span id='topic+LMMELSM-package'></span><span id='topic+LMMELSM'></span>

<h3>Description</h3>

<p>Fits latent (or observed) multivariate (or univariate) mixed effects location scale models.
</p>


<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.19.3. https://mc-stan.org
</p>

<hr>
<h2 id='.add_group_codings'>Adds group codings for predictive df.</h2><span id='topic+.add_group_codings'></span>

<h3>Description</h3>

<p>Adds group codings for predictive df.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.add_group_codings(gs, newdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".add_group_codings_+3A_gs">gs</code></td>
<td>
<p>group spec</p>
</td></tr>
<tr><td><code id=".add_group_codings_+3A_newdata">newdata</code></td>
<td>
<p>data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame, with numerics where group matches, and NAs otherwise.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='.combine_RHS'>Combines multiple formulas' RHS into one.</h2><span id='topic+.combine_RHS'></span>

<h3>Description</h3>

<p>Combines multiple formulas' RHS into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.combine_RHS(flist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".combine_RHS_+3A_flist">flist</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>RHS formula.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.detect_L2_only'>Detect whether the predictors are L2-only</h2><span id='topic+.detect_L2_only'></span>

<h3>Description</h3>

<p>Detects whether the predictors are level-2 only.
E.g., whether location and scale are covariates are the same across all n_k observations of each K.
This is important for efficiency reasons.
If the covariates are invariant across repeated observations of the given group k, for all K, then we can compute predicted values once, and broadcast the prediction, rather than compute the prediction for every single row.
Specifically, it detects if all <code>x == x[1]</code>, where x is a group's data, for each column in mf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.detect_L2_only(mf, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".detect_L2_only_+3A_mf">mf</code></td>
<td>
<p>Data frame for predictors. Should contain no missings.</p>
</td></tr>
<tr><td><code id=".detect_L2_only_+3A_group">group</code></td>
<td>
<p>Grouping variable for the model frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. TRUE if the covariates appear to be level-2 only.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.full_to_lower_tri'>Get indices for subsetting lower-tri summaries of square matrices.</h2><span id='topic+.full_to_lower_tri'></span>

<h3>Description</h3>

<p>Helper for correlation-matrix summarize output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.full_to_lower_tri(x, string = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".full_to_lower_tri_+3A_x">x</code></td>
<td>
<p>Integer. Dimension of matrix.</p>
</td></tr>
<tr><td><code id=".full_to_lower_tri_+3A_string">string</code></td>
<td>
<p>Logical (Default: FALSE). Whether to return strings (e.g., <code>[2,1]</code>, or row indices, assuming column-major ordering.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The .summarize function returns every redundant and constant element from a correlation matrix.
This function returns the stan-strings (when <code>string = TRUE</code>, e.g., <code>[2,1]</code>, <code>[3,1]</code>), or the row-index assuming column-major order.
</p>


<h3>Value</h3>

<p>Charactor vector (if <code>string</code> is TRUE) or integer vector.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.get_elapsed_time'>Gets elapsed time.</h2><span id='topic+.get_elapsed_time'></span>

<h3>Description</h3>

<p>Gets elapsed time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_elapsed_time(sOut)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_elapsed_time_+3A_sout">sOut</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.get_formula_names'>Get names in formula.</h2><span id='topic+.get_formula_names'></span>

<h3>Description</h3>

<p>Get names in formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_formula_names(flist, formula = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_formula_names_+3A_flist">flist</code></td>
<td>
<p>List of formulas.</p>
</td></tr>
<tr><td><code id=".get_formula_names_+3A_formula">formula</code></td>
<td>
<p>Logical. Whether to return the raw RHS (TRUE) or the vars needed (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of lists.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.get_indicator_spec'>Get indicator spec for stan model.</h2><span id='topic+.get_indicator_spec'></span>

<h3>Description</h3>

<p>Get indicator spec for stan model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_indicator_spec(mm.inds, flist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_indicator_spec_+3A_mm.inds">mm.inds</code></td>
<td>
<p>Model matrix. Complete data of all non-duplicated indicators for all factors.</p>
</td></tr>
<tr><td><code id=".get_indicator_spec_+3A_flist">flist</code></td>
<td>
<p>Formula list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with J_f (vector; Number of Indicators for each factor) and F_ind (matrix; each row contains the columns in mm.inds for the row-th factor).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.get_LHS'>Get LHS variable as string.</h2><span id='topic+.get_LHS'></span>

<h3>Description</h3>

<p>Get LHS variable as string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_LHS(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_LHS_+3A_formula">formula</code></td>
<td>
<p>Formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.get_RHS'>Get RHS terms or variables.</h2><span id='topic+.get_RHS'></span>

<h3>Description</h3>

<p>Get RHS terms or variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_RHS(formula, terms = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".get_RHS_+3A_formula">formula</code></td>
<td>
<p>Formula.</p>
</td></tr>
<tr><td><code id=".get_RHS_+3A_terms">terms</code></td>
<td>
<p>Logical (Default: TRUE). Whether to return the terms (TRUE) or the variables (FALSE). E.g., &quot;I(x^2)&quot; vs &quot;x&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.list_zip'>Zip two lists together with function.</h2><span id='topic+.list_zip'></span>

<h3>Description</h3>

<p>Zip two lists together with function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.list_zip(..., f = cbind)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".list_zip_+3A_...">...</code></td>
<td>
<p>Lists to zip.</p>
</td></tr>
<tr><td><code id=".list_zip_+3A_f">f</code></td>
<td>
<p>Function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='.magicsep'>Convert char vector to columns.</h2><span id='topic+.magicsep'></span>

<h3>Description</h3>

<p>Converts a character vector int columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.magicsep(charvec, labs, types = NULL, sep = "MAGICSEP")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".magicsep_+3A_charvec">charvec</code></td>
<td>
<p>Character vector. Characters to separate into columns.</p>
</td></tr>
<tr><td><code id=".magicsep_+3A_labs">labs</code></td>
<td>
<p>Character vector. Labels for the columns.</p>
</td></tr>
<tr><td><code id=".magicsep_+3A_types">types</code></td>
<td>
<p>List (Default: All characters). List (in order) of extracted types.</p>
</td></tr>
<tr><td><code id=".magicsep_+3A_sep">sep</code></td>
<td>
<p>String (Default: &quot;MAGICSEP&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper around strcapture.
Given &quot;a_MAGICSEP_b&quot;, returns a vector of &quot;a_&quot; and &quot;_b&quot;.
Useful for converting a multiple-parameter string into columns of parameters.
User can give column names in <code>labs</code>, and types of each extracted component as a list in <code>types</code>.
User can customize <code>sep</code>, but by default assumes MAGICSEP.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.newline'>Print newline.</h2><span id='topic+.newline'></span>

<h3>Description</h3>

<p>Print newline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newline(n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".newline_+3A_n">n</code></td>
<td>
<p>Integer. Number of lines to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.pars_to_indices'>Convert stan par-string to numeric columns.</h2><span id='topic+.pars_to_indices'></span>

<h3>Description</h3>

<p>Convert stan par-string to numeric columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pars_to_indices(x, labs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".pars_to_indices_+3A_x">x</code></td>
<td>
<p>String. E.g., <code>"lambda[1,2]"</code></p>
</td></tr>
<tr><td><code id=".pars_to_indices_+3A_labs">labs</code></td>
<td>
<p>Character vector (Optional). If supplied, provides the colnames for the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.parse_formula'>Convert spec to stan data.</h2><span id='topic+.parse_formula'></span>

<h3>Description</h3>

<p>Convert spec to stan data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parse_formula(formulaList, group, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".parse_formula_+3A_formulalist">formulaList</code></td>
<td>
<p>Formula or list of formulas.</p>
</td></tr>
<tr><td><code id=".parse_formula_+3A_group">group</code></td>
<td>
<p>Group symbol.</p>
</td></tr>
<tr><td><code id=".parse_formula_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.parse_formula.indicators'>Compute indicator data.</h2><span id='topic+.parse_formula.indicators'></span>

<h3>Description</h3>

<p>Compute indicator data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parse_formula.indicators(mlist, mf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".parse_formula.indicators_+3A_mlist">mlist</code></td>
<td>
<p>List of measurement formulas.</p>
</td></tr>
<tr><td><code id=".parse_formula.indicators_+3A_mf">mf</code></td>
<td>
<p>Data frame with complete cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named List.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.parse_formula.predictor'>Compute predictor data.</h2><span id='topic+.parse_formula.predictor'></span>

<h3>Description</h3>

<p>Compute predictor data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parse_formula.predictor(plist, mf, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".parse_formula.predictor_+3A_plist">plist</code></td>
<td>
<p>List of prediction formulas.</p>
</td></tr>
<tr><td><code id=".parse_formula.predictor_+3A_mf">mf</code></td>
<td>
<p>Data frame containing complete cases.</p>
</td></tr>
<tr><td><code id=".parse_formula.predictor_+3A_group">group</code></td>
<td>
<p>Grouping data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.sep'>Print separator.</h2><span id='topic+.sep'></span>

<h3>Description</h3>

<p>Print separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sep(sep = "\n-----", n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".sep_+3A_sep">sep</code></td>
<td>
<p>String (Default = &quot;&mdash;&ndash;&quot;). Separator.</p>
</td></tr>
<tr><td><code id=".sep_+3A_n">n</code></td>
<td>
<p>Integer (Optional). Number of newlines to call after sep.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.simulate.X'>Simulate covariates without correlation.</h2><span id='topic+.simulate.X'></span>

<h3>Description</h3>

<p>Simulate covariates without correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.simulate.X(n, K, P, L2_pred_only)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".simulate.X_+3A_n">n</code></td>
<td>
<p>Number of observations per k unit.</p>
</td></tr>
<tr><td><code id=".simulate.X_+3A_k">K</code></td>
<td>
<p>Number of k units (Level 2 units).</p>
</td></tr>
<tr><td><code id=".simulate.X_+3A_p">P</code></td>
<td>
<p>Number of covariates.</p>
</td></tr>
<tr><td><code id=".simulate.X_+3A_l2_pred_only">L2_pred_only</code></td>
<td>
<p>Logical (Default: FALSE). If generated predictors should be level-2 only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.summarize'>Compute posterior summaries.</h2><span id='topic+.summarize'></span>

<h3>Description</h3>

<p>Computes posterior summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.summarize(lmmelsm, pars, prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".summarize_+3A_lmmelsm">lmmelsm</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id=".summarize_+3A_pars">pars</code></td>
<td>
<p>Char vector. Which stan param to summarize.</p>
</td></tr>
<tr><td><code id=".summarize_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default: .95; <code style="white-space: pre;">&#8288;[0 - 1]&#8288;</code>). The desired mass to contain within the CrI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.summary_rearrange'>Rearrange summary output.</h2><span id='topic+.summary_rearrange'></span>

<h3>Description</h3>

<p>Rearrange summary output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.summary_rearrange(x, cols, arrange = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".summary_rearrange_+3A_x">x</code></td>
<td>
<p>Summary table.</p>
</td></tr>
<tr><td><code id=".summary_rearrange_+3A_cols">cols</code></td>
<td>
<p>Columns, in order, to place in front.</p>
</td></tr>
<tr><td><code id=".summary_rearrange_+3A_arrange">arrange</code></td>
<td>
<p>Logical (Default: FALSE). Whether to sort rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.tidy_summary'>Takes stan summary, returns summary with indices-as-columns.</h2><span id='topic+.tidy_summary'></span>

<h3>Description</h3>

<p>Creates &quot;tidy&quot; summaries in lieu of the stan rownames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.tidy_summary(x, labs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".tidy_summary_+3A_x">x</code></td>
<td>
<p>Output of .summarize</p>
</td></tr>
<tr><td><code id=".tidy_summary_+3A_labs">labs</code></td>
<td>
<p>The labels for each parameter index. E.g., &quot;predictor&quot;, &quot;factor&quot;</p>
</td></tr>
<tr><td><code id=".tidy_summary_+3A_...">...</code></td>
<td>
<p>Optional (but recommended). Mappings for indices. E.g., Index column 1 is replaced by ...<code style="white-space: pre;">&#8288;[[1]][col1Indices]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>.summarize creates an rstan-like summary with rownames, <code>mat[1:R, 1:C]</code>.
<code>.tidy_summary(mat, c("rows", "cols"))</code> would then create two new columns, &quot;rows&quot; and &quot;cols&quot; with the indices in them.
If arguments are provided in <code>...</code>, then these indicate the mappings between the indices and labeled values.
E.g., <code>.tidy_summary(mat, c("rows", "cols"), c("A", "B"), c("C", "D"))</code> would create two new columns, &quot;rows&quot; and &quot;cols&quot;, and replace rows = 1 with rows = A; cols=2 with cols = D, and so on.
Useful for going from stan rownames, to labeled columns.
</p>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='.which_location_scale'>Check for location-scale formulas</h2><span id='topic+.which_location_scale'></span>

<h3>Description</h3>

<p>Check for location-scale formulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.which_location_scale(flist, reduce = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".which_location_scale_+3A_flist">flist</code></td>
<td>
<p>Formula list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector (length 2); which formulas in flist correspond to location, scale.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='+25IfNull+25'>Operator for testing NULL and returning expr if NULL</h2><span id='topic++25IfNull+25'></span>

<h3>Description</h3>

<p>Operator for testing NULL and returning expr if NULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object %IfNull% expr
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25IfNull+2B25_+3A_object">object</code></td>
<td>
<p>Object to test for NULL</p>
</td></tr>
<tr><td><code id="+2B25IfNull+2B25_+3A_expr">expr</code></td>
<td>
<p>Expression to evaluate and return if object is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object if object is non-NULL, expression output if object is NULL.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='coef.lmmelsm'>Extract group-specific coefficients.</h2><span id='topic+coef.lmmelsm'></span><span id='topic+coef'></span>

<h3>Description</h3>

<p>Coef method for lmmelsm objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmelsm'
coef(object, prob = 0.95, summarize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.lmmelsm_+3A_object">object</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id="coef.lmmelsm_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default: .95). Amount of probability mass contained in the credible interval.</p>
</td></tr>
<tr><td><code id="coef.lmmelsm_+3A_summarize">summarize</code></td>
<td>
<p>Logical (Default: TRUE). Whether to return posterior summaries (TRUE) or MCMC samples (FALSE).</p>
</td></tr>
<tr><td><code id="coef.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts all group-specific coefficients from lmmelsm object.
Note that this is different from <code><a href="#topic+ranef">ranef</a></code>.
Whereas <code>ranef</code> extracts the zero-centered random effects, <code>coef</code> extracts the group-specific effects, defined as the sum of the fixed effect and random effect.
</p>


<h3>Value</h3>

<p>List of summaries (if <code>summarize</code> is TRUE), or list of MCMC samples.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='fitted.lmmelsm'>Extracted model fitted variates.</h2><span id='topic+fitted.lmmelsm'></span>

<h3>Description</h3>

<p>Extract model fitted variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmelsm'
fitted(object, prob = 0.95, summarize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.lmmelsm_+3A_object">object</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id="fitted.lmmelsm_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default: .95). Amount of probability mass contained in the credible interval.</p>
</td></tr>
<tr><td><code id="fitted.lmmelsm_+3A_summarize">summarize</code></td>
<td>
<p>Logical (Default: TRUE). Whether to return posterior summaries (TRUE) or MCMC samples (FALSE).</p>
</td></tr>
<tr><td><code id="fitted.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts model fitted variates. When a latent MMELSM, these are the latent score expectations and log standard deviations. When an observed MMELSM, these are the observed score expectations and log standard deviations.
</p>


<h3>Value</h3>

<p>List of eta and eta_logsd. If summarize is <code>TRUE</code>, then the list contains formatted summary tables. If <code>FALSE</code>, then the list contains MCMC samples for all variables.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='lmmelsm'>Specify and fit the (latent) (multivariate) melsm.</h2><span id='topic+lmmelsm'></span>

<h3>Description</h3>

<p>Fits a mixed effects location scale model on one or more observed or latent variables.
Currently supports multiple endogenous latent factors or observed outcomes,  and exogenous observed variables.
Data are assumed to be two-level data. I.e., multiple indicators, repeatedly measured within group.
Currently assumes measurement invariance (i.e., the measurement model params are equivalent across groups) and a unit-variance identification for latent variables.
Excludes rows with missing data (and warns the user).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmmelsm(formula, group, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmmelsm_+3A_formula">formula</code></td>
<td>
<p>Formula or list of formulas. See section on model specification.</p>
</td></tr>
<tr><td><code id="lmmelsm_+3A_group">group</code></td>
<td>
<p>Raw grouping variable name (not character).</p>
</td></tr>
<tr><td><code id="lmmelsm_+3A_data">data</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="lmmelsm_+3A_...">...</code></td>
<td>
<p>Options passed onto <code><a href="rstan.html#topic+sampling">sampling</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>lmmelsm object.
</p>


<h3>Model specification</h3>

<p>The model is specified as a list of formulas.
LMMELSM supports the specification of latent measurement models, location models, scale models, between-group scale models, and (if latent variables are undesired) observed outcome models.
The covariates do not need to be the same across the location, scale, and between-group models.
The specified covariates will be used to predict the location and scale of <em>all</em> latent factors via multivariate regression.
</p>
<p>The latent factor model is specified as follows.
In the simplest case, only one formula is required, and a single-factor model is estimated.
The left-hand side (LHS) contains the user-specified latent variable name, and the right-hand side (RHS) contains the indicators.
Let &quot;latent1&quot; and &quot;latent2&quot; be user-chosen names of two latent variables with three indicators each.
Then the formula syntax would be:
<code>list(latent1 ~ y1 + y2 + y3, latent2 ~ y4 + y5 + y6)</code>
</p>
<p>The location model is specified as either a one or two-part formula.
The LHS must be &quot;location&quot; and the RHS contains the covariates.
Random slopes are specified in the optional second part, separated by &quot;|&quot;.
Because LMMELSM fits MELSMs, random intercepts are <em>always</em> included.
For example, if x1 and x2 are two location predictors, then:
</p>
<p><code>location ~ x1 + x2</code>
</p>
<p>specifies a location model with a random intercept per factor, and no random slopes.
</p>
<p><code>location ~ x1 + x2 | x1</code>
</p>
<p>specifies a location model with a random intercept per factor, a random x1 coefficient per factor, and no random x2 coefficient.
</p>
<p>The within-group scale model is specified similarly.
The LHS must be &quot;scale&quot; and the RHS contains the covariates.
Random intercepts are always included, and random slopes are specified in the optional second part of the RHS.
For example, if x2 and x3 are two scale predictors, then:
</p>
<p><code>scale ~ x2 + x3</code>
</p>
<p>specifies a scale model with a random intercept per factor, and no random slopes.
</p>
<p><code>scale ~ x2 + x3 | x3</code>
</p>
<p>specifies a scale model with a random intercept perfactor, a random x3 coefficient per factor, and no random x2 coefficient.
</p>
<p>The between-group scale model is specified by a LHS of &quot;between&quot; and RHS containing covariates.
There are no random coefficients permitted in the between-group scale model.
The between-group scale model is responsible for modeling the random effect standard deviations.
<em>Note:</em> The between-group model <em>only</em> models the SDs of the random location and scale <em>intercepts</em>.
</p>
<p><code>between ~ x2</code>
</p>
<p>specifies a between-group scale model on the SDs of the location and scale intercepts for each factor.
</p>
<p>If you want to fit a non-latent multivariate MELSM, use &quot;observed&quot; as the LHS:
</p>
<p>For example, if y1, y2, and y3 are three observed outcome variables, then
</p>
<p><code>observed ~ y1 + y2 + y3</code>
</p>
<p>would fit an M-MELSM.
Location, scale, and between-group models can still be specified, but they will model the observed variables, rather than latent variables.
You cannot currently have both observed and latent outcomes in the same model.
</p>
<p><em>Note</em>: Because <code>location</code>, <code>scale</code>, <code>between</code>, and <code>observed</code> represent special formulas, latent factors cannot be named location, scale, between, nor observed.
It is assumed that any formula with <code>location</code>, <code>scale</code>, or <code>between</code> on the left-hand side (LHS) is a predictive formula, not a latent variable specification.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sim_data)

# Fit LMMELSM with two latent factors (A and B),
# Location model with one random coefficient
# Scale model with one random coefficient
# Between-group scale model with one covariate
fit &lt;- lmmelsm(list(A ~ A_1 + A_2 + A_3 + A_4 + A_5 + A_6,
                    B ~ N_1 + N_2 + N_3 + N_4 + N_5 + N_6,
                    location ~ x1 + baseline | x1,
                    scale ~ x2 + baseline | x2,
                    between ~ baseline),
               subject, sim_data, cores = 2, iter = 500, chains = 2
              )

# Summarize fit
summary(fit)

# Get random effects
ranef(fit)
# Get group-specific parameter values
coef(fit)
# Get approximate leave-one-out
loo(fit)

</code></pre>

<hr>
<h2 id='loo.lmmelsm'>loo method for LMMELSM objects.</h2><span id='topic+loo.lmmelsm'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p>loo method for LMMELSM objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmelsm'
loo(x, type = c("observation", "group"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo.lmmelsm_+3A_x">x</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id="loo.lmmelsm_+3A_type">type</code></td>
<td>
<p>String (Default: &quot;observation&quot;). If &quot;observation&quot;, then loo is leave-row-out. If &quot;group&quot;, then loo is leave-group-out.</p>
</td></tr>
<tr><td><code id="loo.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>loo object.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='nlist'>Creates named list.</h2><span id='topic+nlist'></span>

<h3>Description</h3>

<p>Creates named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlist(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlist_+3A_...">...</code></td>
<td>
<p>Objects for list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named List.
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='predict.lmmelsm'>Predict method for lmmelsm objects.</h2><span id='topic+predict.lmmelsm'></span>

<h3>Description</h3>

<p>Generates posterior predictions from fitted LMMELSM object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmelsm'
predict(
  object,
  newdata = NULL,
  prob = 0.95,
  summarize = TRUE,
  include_error = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.lmmelsm_+3A_object">object</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id="predict.lmmelsm_+3A_newdata">newdata</code></td>
<td>
<p>Data.frame (Default: NULL). If NULL, uses original data.frame.</p>
</td></tr>
<tr><td><code id="predict.lmmelsm_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default: .95). Amount of probability mass contained in the credible interval.</p>
</td></tr>
<tr><td><code id="predict.lmmelsm_+3A_summarize">summarize</code></td>
<td>
<p>Logical (Default: TRUE). Whether to return posterior summaries (TRUE) or MCMC samples (FALSE).</p>
</td></tr>
<tr><td><code id="predict.lmmelsm_+3A_include_error">include_error</code></td>
<td>
<p>Logical (Default: TRUE). If TRUE, then include stochastic realizations in outcome variables.</p>
</td></tr>
<tr><td><code id="predict.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the grouping variable is missing, or contains NAs, then new random effects are generated from the posterior random effect distribution.
Where the grouping variables are not missing, the posterior standardized, orthogonalized random effects are obtained from the fitted model, and used as a basis for predicted random effects.
Because the standardized, orthogonalized random effects are used, one can include different between-group variance values to predict new RE variances, and therefore a different random effect value.
That is, the random effect, conditional on new between-group variance model covariates, is equal to: </p>
<p style="text-align: center;"><code class="reqn">u_i = z_i U D_i</code>
</p>
<p>, where <code class="reqn">D_i</code> is the predicted between-group random effect SD, U is the upper cholesky factorization of the random effect correlations, and <code class="reqn">z_i</code> is the standardized, orthogonalized random effect for group i.
</p>


<h3>Value</h3>

<p>List. If summarize is TRUE, then a list of outcome (eta, eta_logsd) and indicator (y) posterior predictive distribution summaries. If FALSE, an N-length list of lists of outcome and indicator MCMC samples.
</p>


<h3>Author(s)</h3>

<p>Stephen Martin
</p>

<hr>
<h2 id='print.lmmelsm'>Print method for lmmelsm objects.</h2><span id='topic+print.lmmelsm'></span>

<h3>Description</h3>

<p>Print method for lmmelsm objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmelsm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lmmelsm_+3A_x">x</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id="print.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x (Invisibly).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='print.summary.lmmelsm'>Print method for summary.lmmelsm objects.</h2><span id='topic+print.summary.lmmelsm'></span>

<h3>Description</h3>

<p>Print method for summary.lmmelsm objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lmmelsm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.lmmelsm_+3A_x">x</code></td>
<td>
<p>summary.lmmelsm object.</p>
</td></tr>
<tr><td><code id="print.summary.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x (Invisibly).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='ranef.lmmelsm'>Extract random effects.</h2><span id='topic+ranef.lmmelsm'></span><span id='topic+ranef'></span>

<h3>Description</h3>

<p>Ranef method for lmmelsm objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmelsm'
ranef(object, prob = 0.95, summarize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef.lmmelsm_+3A_object">object</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id="ranef.lmmelsm_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default: .95). Amount of probability mass contained in the credible interval.</p>
</td></tr>
<tr><td><code id="ranef.lmmelsm_+3A_summarize">summarize</code></td>
<td>
<p>Logical (Default: TRUE). Whether to return posterior summaries (TRUE) or MCMC samples (FALSE).</p>
</td></tr>
<tr><td><code id="ranef.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracts the random effects from the lmmelsm object.
Note that this is different from the random <em>coefficients</em>.
E.g., if <code class="reqn">\beta_{0i} = \beta_0 + u_{0i}</code>, then <code>coef</code> extracts <code class="reqn">\beta_{0i}</code> and <code>ranef</code> extracts <code class="reqn">u_{0i}</code>.
</p>


<h3>Value</h3>

<p>List of ranef summaries (random_mu_intercept, random_logsd_intercept, random_mu_coef, and random_logsd_coef), or samples (if summarize = FALSE).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='row_multiply_list_mats'>Multiply a row by a list of matrices</h2><span id='topic+row_multiply_list_mats'></span>

<h3>Description</h3>

<p>Multiply a row by a list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_multiply_list_mats(r, mats)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row_multiply_list_mats_+3A_r">r</code></td>
<td>
<p>Row vector.</p>
</td></tr>
<tr><td><code id="row_multiply_list_mats_+3A_mats">mats</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>List of row by matrix products.
</p>


<h3>Author(s)</h3>

<p>Stephen R Martin
</p>

<hr>
<h2 id='sim_data'>Simulated data for fitting the LMMELSM</h2><span id='topic+sim_data'></span>

<h3>Description</h3>

<p>Dataset containing 50 observations of 12 items for 100 persons.
The data are generated from an LMMELSM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data
</code></pre>


<h3>Format</h3>

<p>Data frame with 5000 rows and 16 variables.
</p>

<dl>
<dt>subject</dt><dd><p>The subject ID</p>
</dd>
<dt>baseline</dt><dd><p>A subject-level covariate</p>
</dd>
<dt>x1</dt><dd><p>A time-varying covariate</p>
</dd>
<dt>x2</dt><dd><p>A time-varying covariate</p>
</dd>
<dt>A_1 - A_6</dt><dd><p>Six indicators for &quot;Agreeableness&quot;</p>
</dd>
<dt>N_1 - N_6</dt><dd><p>Six indicators for &quot;Neuroticism&quot;</p>
</dd>
</dl>


<hr>
<h2 id='simulate_lmmelsm'>Simulate data from latent uni/multidimensional MELSM</h2><span id='topic+simulate_lmmelsm'></span>

<h3>Description</h3>

<p>Simulate data from latent uni/multidimensional MELSM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_lmmelsm(
  n,
  K,
  lambda,
  resid,
  nu,
  mu_beta = NULL,
  logsd_beta = NULL,
  P_random_ind = NULL,
  Q_random_ind = NULL,
  mu_logsd_betas_cor,
  mu_logsd_betas_sigma,
  epsilon_cor,
  zeta = NULL,
  X_loc = NULL,
  X_sca = NULL,
  X_bet = NULL,
  L2_pred_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_lmmelsm_+3A_n">n</code></td>
<td>
<p>Integer. Number of repeated observations per group.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_k">K</code></td>
<td>
<p>Integer. Number of groups.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_lambda">lambda</code></td>
<td>
<p>Matrix (FxJ). Loading matrix.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_resid">resid</code></td>
<td>
<p>Numeric vector (J). Residual SDs.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_nu">nu</code></td>
<td>
<p>Numeric vector (J). Intercepts.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_mu_beta">mu_beta</code></td>
<td>
<p>Matrix (PxF). Location coefficient matrix.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_logsd_beta">logsd_beta</code></td>
<td>
<p>Matrix (QxF). Scale coefficient matrix.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_p_random_ind">P_random_ind</code></td>
<td>
<p>Integer vector (P_random). Which location predictors have random slopes.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_q_random_ind">Q_random_ind</code></td>
<td>
<p>Integer vector (Q_random). Which scale predictors have random slopes.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_mu_logsd_betas_cor">mu_logsd_betas_cor</code></td>
<td>
<p>Matrix (Symmetric, SPD; F<em>2 + P_random</em>F + Q_random*F). Correlation matrix of random effects (slopes and intercepts, for location and scale models).</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_mu_logsd_betas_sigma">mu_logsd_betas_sigma</code></td>
<td>
<p>Numeric vector (Positive; F<em>2 + P_random</em>F + Q_random*F). RE SDs (intercepts on exponentiated scale, if zeta is specified).</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_epsilon_cor">epsilon_cor</code></td>
<td>
<p>Matrix (Symmetric, SPD; F). Stochastic error term correlation between factors.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_zeta">zeta</code></td>
<td>
<p>Matrix (<code>Rx[F*2 + P_random*F + Q_random*F]</code>). Coefficient matrix for predicting RE SDs.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_x_loc">X_loc</code></td>
<td>
<p>Matrix (Optional; NxP). Location design matrix.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_x_sca">X_sca</code></td>
<td>
<p>Matrix (Optional; NxQ). Scale design matrix.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_x_bet">X_bet</code></td>
<td>
<p>Matrix (Optional; NxR). Between-SD design matrix.</p>
</td></tr>
<tr><td><code id="simulate_lmmelsm_+3A_l2_pred_only">L2_pred_only</code></td>
<td>
<p>Logical. Whether predictors should be group-level (TRUE) or observation level (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of params (list), data (list), and df (data.frame).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

<hr>
<h2 id='summary.lmmelsm'>Summary method for lmmelsm objects.</h2><span id='topic+summary.lmmelsm'></span>

<h3>Description</h3>

<p>Summary method for lmmelsm objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmelsm'
summary(object, prob = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lmmelsm_+3A_object">object</code></td>
<td>
<p>lmmelsm object.</p>
</td></tr>
<tr><td><code id="summary.lmmelsm_+3A_prob">prob</code></td>
<td>
<p>Numeric (Default: .95). Amount of probability mass contained in the credible interval.</p>
</td></tr>
<tr><td><code id="summary.lmmelsm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary.lmmelsm object. A list containing <code>meta</code> (metadata) and <code>summary</code> (summary tables).
</p>


<h3>Author(s)</h3>

<p>Stephen R. Martin
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
